/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef unsigned long __uint64_t;
typedef long __off_t;
typedef long __off64_t;
typedef long __intptr_t;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef __int32_t int32_t;
typedef __intptr_t intptr_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
typedef uint64_t strm_value;
struct strm_state ;
struct strm_stream ;
typedef int (*strm_cfunc)(struct strm_stream * , int  , strm_value * , strm_value * );
typedef int32_t strm_int;
enum strm_ptr_type {
    STRM_PTR_STREAM = 0,
    STRM_PTR_LAMBDA = 1,
    STRM_PTR_GENFUNC = 2,
    STRM_PTR_IO = 3,
    STRM_PTR_AUX = 4
} ;
typedef uint64_t strm_string;
typedef uint64_t strm_array;
struct strm_array {
   strm_int len ;
   strm_value *ptr ;
   strm_array headers ;
   struct strm_state *ns ;
};
enum __anonenum_strm_stream_mode_726947345 {
    strm_producer = 0,
    strm_filter = 1,
    strm_consumer = 2,
    strm_dying = 3,
    strm_killed = 4
} ;
typedef enum __anonenum_strm_stream_mode_726947345 strm_stream_mode;
typedef struct strm_stream strm_stream;
struct node_error ;
struct strm_queue ;
struct strm_stream {
   enum strm_ptr_type type ;
   unsigned int flags ;
   strm_stream_mode mode ;
   int (*start_func)(strm_stream * , strm_value  ) ;
   int (*close_func)(strm_stream * , strm_value  ) ;
   void *data ;
   strm_stream *dst ;
   strm_stream **rest ;
   size_t rsize ;
   size_t rcapa ;
   struct node_error *exc ;
   strm_int refcnt ;
   struct strm_queue *queue ;
   strm_int excl ;
};
struct strm_state {
   void *env ;
   struct strm_state *prev ;
   uint32_t flags ;
};
typedef struct strm_state strm_state;
struct node_lambda ;
struct strm_lambda {
   enum strm_ptr_type type ;
   struct node_lambda *body ;
   struct strm_state *state ;
};
struct strm_genfunc {
   enum strm_ptr_type type ;
   strm_state *state ;
   strm_string id ;
};
struct node_string {
   strm_int len ;
   char buf[0] ;
};
typedef struct node_string *node_string;
struct node_error {
   int type ;
   strm_value arg ;
   char const   *fname ;
   int lineno ;
};
typedef struct node_error node_error;
struct parser_state {
   int nerr ;
   void *lval ;
   char const   *fname ;
   int lineno ;
   int tline ;
};
typedef struct parser_state parser_state;
enum __anonenum_node_type_987017113 {
    NODE_INT = 0,
    NODE_FLOAT = 1,
    NODE_TIME = 2,
    NODE_STR = 3,
    NODE_NIL = 4,
    NODE_BOOL = 5,
    NODE_ARGS = 6,
    NODE_PAIR = 7,
    NODE_CFUNC = 8,
    NODE_LAMBDA = 9,
    NODE_PLAMBDA = 10,
    NODE_PARRAY = 11,
    NODE_PSTRUCT = 12,
    NODE_PSPLAT = 13,
    NODE_SPLAT = 14,
    NODE_IDENT = 15,
    NODE_LET = 16,
    NODE_IF = 17,
    NODE_EMIT = 18,
    NODE_SKIP = 19,
    NODE_RETURN = 20,
    NODE_VAR = 21,
    NODE_CONST = 22,
    NODE_OP = 23,
    NODE_CALL = 24,
    NODE_FCALL = 25,
    NODE_GENFUNC = 26,
    NODE_ARRAY = 27,
    NODE_NODES = 28,
    NODE_NS = 29,
    NODE_IMPORT = 30
} ;
typedef enum __anonenum_node_type_987017113 node_type;
struct node {
   node_type type ;
   char const   *fname ;
   int lineno ;
};
typedef struct node node;
struct __anonstruct_node_int_587342743 {
   node_type type ;
   char const   *fname ;
   int lineno ;
   int32_t value ;
};
typedef struct __anonstruct_node_int_587342743 node_int;
struct __anonstruct_node_float_504457063 {
   node_type type ;
   char const   *fname ;
   int lineno ;
   double value ;
};
typedef struct __anonstruct_node_float_504457063 node_float;
struct __anonstruct_node_time_256132641 {
   node_type type ;
   char const   *fname ;
   int lineno ;
   long sec ;
   long usec ;
   int utc_offset ;
};
typedef struct __anonstruct_node_time_256132641 node_time;
struct __anonstruct_node_str_335716169 {
   node_type type ;
   char const   *fname ;
   int lineno ;
   node_string value ;
};
typedef struct __anonstruct_node_str_335716169 node_str;
struct __anonstruct_node_bool_164879216 {
   node_type type ;
   char const   *fname ;
   int lineno ;
   int value ;
};
typedef struct __anonstruct_node_bool_164879216 node_bool;
struct __anonstruct_node_pair_758919965 {
   node_type type ;
   char const   *fname ;
   int lineno ;
   node_string key ;
   node *value ;
};
typedef struct __anonstruct_node_pair_758919965 node_pair;
struct __anonstruct_node_args_340137494 {
   node_type type ;
   char const   *fname ;
   int lineno ;
   int len ;
   int max ;
   node_string *data ;
};
typedef struct __anonstruct_node_args_340137494 node_args;
struct __anonstruct_node_nodes_446254667 {
   node_type type ;
   char const   *fname ;
   int lineno ;
   int len ;
   int max ;
   node **data ;
};
typedef struct __anonstruct_node_nodes_446254667 node_nodes;
struct __anonstruct_node_array_907279779 {
   node_type type ;
   char const   *fname ;
   int lineno ;
   int len ;
   int max ;
   node **data ;
   node_string *headers ;
   node_string ns ;
};
typedef struct __anonstruct_node_array_907279779 node_array;
struct __anonstruct_node_psplat_44597470 {
   node_type type ;
   char const   *fname ;
   int lineno ;
   node *head ;
   node *mid ;
   node *tail ;
};
typedef struct __anonstruct_node_psplat_44597470 node_psplat;
struct __anonstruct_node_splat_38903079 {
   node_type type ;
   char const   *fname ;
   int lineno ;
   node *node ;
};
typedef struct __anonstruct_node_splat_38903079 node_splat;
struct __anonstruct_node_if_44597471 {
   node_type type ;
   char const   *fname ;
   int lineno ;
   node *cond ;
   node *then ;
   node *opt_else ;
};
typedef struct __anonstruct_node_if_44597471 node_if;
struct __anonstruct_node_emit_44597472 {
   node_type type ;
   char const   *fname ;
   int lineno ;
   node *emit ;
};
typedef struct __anonstruct_node_emit_44597472 node_emit;
struct __anonstruct_node_let_907279780 {
   node_type type ;
   char const   *fname ;
   int lineno ;
   node_string lhs ;
   node *rhs ;
};
typedef struct __anonstruct_node_let_907279780 node_let;
struct __anonstruct_node_ident_907279781 {
   node_type type ;
   char const   *fname ;
   int lineno ;
   node_string name ;
};
typedef struct __anonstruct_node_ident_907279781 node_ident;
struct __anonstruct_node_op_536440336 {
   node_type type ;
   char const   *fname ;
   int lineno ;
   node_string op ;
   node *lhs ;
   node *rhs ;
};
typedef struct __anonstruct_node_op_536440336 node_op;
struct node_lambda {
   node_type type ;
   char const   *fname ;
   int lineno ;
   node *args ;
   node *body ;
   int block ;
};
typedef struct node_lambda node_lambda;
struct node_plambda {
   node_type type ;
   char const   *fname ;
   int lineno ;
   node *pat ;
   node *cond ;
   node *body ;
   node *next ;
};
typedef struct node_plambda node_plambda;
struct __anonstruct_node_call_907279782 {
   node_type type ;
   char const   *fname ;
   int lineno ;
   node_string ident ;
   node *args ;
};
typedef struct __anonstruct_node_call_907279782 node_call;
struct __anonstruct_node_fcall_1043203960 {
   node_type type ;
   char const   *fname ;
   int lineno ;
   node *func ;
   node *args ;
};
typedef struct __anonstruct_node_fcall_1043203960 node_fcall;
struct __anonstruct_node_genfunc_1043203961 {
   node_type type ;
   char const   *fname ;
   int lineno ;
   node_string id ;
};
typedef struct __anonstruct_node_genfunc_1043203961 node_genfunc;
struct __anonstruct_node_return_1043203962 {
   node_type type ;
   char const   *fname ;
   int lineno ;
   node *rv ;
};
typedef struct __anonstruct_node_return_1043203962 node_return;
struct __anonstruct_node_ns_1043203963 {
   node_type type ;
   char const   *fname ;
   int lineno ;
   node_string name ;
   node *body ;
};
typedef struct __anonstruct_node_ns_1043203963 node_ns;
struct __anonstruct_node_import_1043203964 {
   node_type type ;
   char const   *fname ;
   int lineno ;
   node_string name ;
};
typedef struct __anonstruct_node_import_1043203964 node_import;
struct array_data {
   int n ;
   strm_array arr ;
};
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __time_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
typedef __ssize_t ssize_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
typedef unsigned long pthread_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
struct strm_task {
   int (*func)(strm_stream * , strm_value  ) ;
   strm_value data ;
};
struct strm_io {
   enum strm_ptr_type type ;
   int fd ;
   int mode ;
   strm_stream *read_stream ;
   strm_stream *write_stream ;
};
typedef struct strm_io *strm_io;
union epoll_data {
   void *ptr ;
   int fd ;
   uint32_t u32 ;
   uint64_t u64 ;
};
typedef union epoll_data epoll_data_t;
struct epoll_event {
   uint32_t events ;
   epoll_data_t data ;
} __attribute__((__packed__)) ;
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
struct fd_read_buffer {
   int fd ;
   char *beg ;
   char *end ;
   strm_io io ;
   char *buf ;
   char fixed[8192] ;
};
struct write_data {
   FILE *f ;
   strm_io io ;
};
typedef unsigned int khint32_t;
typedef unsigned long khint64_t;
typedef khint32_t khint_t;
typedef khint_t khiter_t;
struct seq_data {
   double n ;
   double end ;
   double inc ;
};
struct repeat_data {
   strm_value v ;
   strm_int count ;
};
struct cycle_data {
   strm_array ary ;
   strm_int count ;
};
struct map_data {
   strm_value func ;
};
struct count_data {
   strm_int count ;
};
struct minmax_data {
   int start ;
   int min ;
   strm_value data ;
   double num ;
   strm_value func ;
};
struct reduce_data {
   strm_int init ;
   strm_value acc ;
   strm_value func ;
};
struct kh_rbk_s {
   khint_t n_buckets ;
   khint_t size ;
   khint_t n_occupied ;
   khint_t upper_bound ;
   khint32_t *flags ;
   khint64_t *keys ;
   strm_value *vals ;
};
typedef struct kh_rbk_s kh_rbk_t;
struct rbk_data {
   kh_rbk_t *tbl ;
   strm_value func ;
};
struct slice_data {
   strm_int n ;
   strm_int i ;
   strm_value *buf ;
};
struct take_data {
   int n ;
};
struct uniq_data {
   strm_value last ;
   strm_value v ;
   strm_value func ;
   int init ;
};
struct sum_data {
   double sum ;
   double c ;
   strm_int num ;
   strm_value func ;
};
struct mvavg_data {
   strm_int num ;
   strm_int i ;
   strm_int filled ;
   strm_value func ;
   strm_int func_p ;
   double data[0] ;
};
enum stdev_mode {
    mode_stdev = 0,
    mode_variance = 1,
    mode_mean_stdev = 2,
    mode_mean_variance = 3
} ;
struct stdev_data {
   strm_int num ;
   double s1 ;
   double s2 ;
   strm_value func ;
   enum stdev_mode mode ;
};
struct correl_data {
   strm_int n ;
   double sx ;
   double sy ;
   double sxx ;
   double syy ;
   double sxy ;
};
typedef long __suseconds_t;
typedef __time_t time_t;
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long __tm_gmtoff ;
   char const   *__tm_zone ;
};
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
struct strm_time {
   enum strm_ptr_type type ;
   struct strm_state *ns ;
   struct timeval tv ;
   int utc_offset ;
};
struct strm_misc {
   enum strm_ptr_type type ;
   struct strm_state *ns ;
};
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
struct strm_queue_node {
   struct strm_queue_node *next ;
   void *n ;
};
struct strm_queue {
   struct strm_queue_node *head ;
   struct strm_queue_node *tail ;
   pthread_mutex_t mutex ;
};
union __anonunion_u_274369385 {
   double f ;
   uint64_t i ;
};
struct object {
   enum strm_ptr_type type ;
};
union __anonunion_u_274369386 {
   double f ;
   uint64_t i ;
};
struct recv_data {
   strm_stream *strm ;
   int (*func)(strm_stream * , strm_value  ) ;
};
struct latch_data {
   struct strm_queue *dq ;
   struct strm_queue *rq ;
};
struct zip_data {
   strm_array a ;
   strm_int i ;
   strm_int len ;
   strm_stream *latch[0] ;
};
struct concat_data {
   strm_int i ;
   strm_int len ;
   strm_stream *latch[0] ;
};
struct kh_env_s {
   khint_t n_buckets ;
   khint_t size ;
   khint_t n_occupied ;
   khint_t upper_bound ;
   khint32_t *flags ;
   khint64_t *keys ;
   strm_value *vals ;
};
typedef struct kh_env_s kh_env_t;
typedef kh_env_t strm_env;
struct strm_worker {
   pthread_t th ;
};
struct kh_kvs_s {
   khint_t n_buckets ;
   khint_t size ;
   khint_t n_occupied ;
   khint_t upper_bound ;
   khint32_t *flags ;
   strm_string *keys ;
   strm_value *vals ;
};
typedef struct kh_kvs_s kh_kvs_t;
struct kh_txn_s {
   khint_t n_buckets ;
   khint_t size ;
   khint_t n_occupied ;
   khint_t upper_bound ;
   khint32_t *flags ;
   strm_string *keys ;
   strm_value *vals ;
};
typedef struct kh_txn_s kh_txn_t;
struct strm_kvs {
   enum strm_ptr_type type ;
   struct strm_state *ns ;
   kh_kvs_t *kv ;
   uint64_t serial ;
   pthread_mutex_t lock ;
};
typedef struct strm_kvs strm_kvs;
struct strm_txn {
   enum strm_ptr_type type ;
   struct strm_state *ns ;
   kh_txn_t *tv ;
   strm_kvs *kvs ;
   uint64_t serial ;
};
typedef struct strm_txn strm_txn;
struct yy_buffer_state ;
typedef struct yy_buffer_state *YY_BUFFER_STATE;
struct yy_buffer_state {
   FILE *yy_input_file ;
   char *yy_ch_buf ;
   char *yy_buf_pos ;
   int yy_buf_size ;
   int yy_n_chars ;
   int yy_is_our_buffer ;
   int yy_is_interactive ;
   int yy_at_bol ;
   int yy_bs_lineno ;
   int yy_bs_column ;
   int yy_fill_buffer ;
   int yy_buffer_status ;
};
struct kh_ns_s {
   khint_t n_buckets ;
   khint_t size ;
   khint_t n_occupied ;
   khint_t upper_bound ;
   khint32_t *flags ;
   khint64_t *keys ;
   strm_state **vals ;
};
typedef struct kh_ns_s kh_ns_t;
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
struct bar_data {
   char const   *title ;
   strm_int tlen ;
   strm_int col ;
   strm_int row ;
   strm_int dlen ;
   strm_int llen ;
   strm_int offset ;
   strm_int max ;
   double *data ;
};
struct sort_arg {
   strm_stream *strm ;
   strm_value func ;
};
struct sort_data {
   strm_int len ;
   strm_int capa ;
   strm_value *buf ;
   strm_value func ;
};
struct sortby_value {
   strm_value v ;
   strm_value o ;
};
struct sortby_data {
   strm_int len ;
   strm_int capa ;
   struct sortby_value *buf ;
   strm_stream *strm ;
   strm_value func ;
};
enum csv_type {
    TYPE_UNSPC = 0,
    TYPE_STR = 1,
    TYPE_NUM = 2,
    TYPE_TIME = 3,
    TYPE_ESC = 4,
    TYPE_INT = 5,
    TYPE_FLOAT = 6
} ;
struct csv_data {
   strm_array headers ;
   enum csv_type *types ;
   strm_string prev ;
   char sep ;
   int n ;
};
struct rand_data {
   uint32_t seed[4] ;
};
struct rnorm_data {
   uint32_t seed[4] ;
   int has_spare ;
   double spare ;
};
struct sample_data {
   uint32_t seed[4] ;
   strm_int i ;
   strm_int len ;
   strm_value samples[0] ;
};
typedef void (*__sighandler_t)(int  );
struct sig_list {
   int sig ;
   void (*func)(int  , void * ) ;
   void *arg ;
   struct sig_list *next ;
};
typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list___0;
typedef unsigned short __uint16_t;
typedef unsigned int __socklen_t;
typedef __socklen_t socklen_t;
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
typedef __uint16_t uint16_t;
typedef uint32_t in_addr_t;
struct in_addr {
   in_addr_t s_addr ;
};
typedef uint16_t in_port_t;
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
struct socket_data {
   int sock ;
};
struct strm_string {
   char const   *ptr ;
   strm_int len ;
};
struct sym_key {
   char const   *ptr ;
   strm_int len ;
};
struct kh_sym_s {
   khint_t n_buckets ;
   khint_t size ;
   khint_t n_occupied ;
   khint_t upper_bound ;
   khint32_t *flags ;
   struct sym_key *keys ;
   strm_string *vals ;
};
typedef struct kh_sym_s kh_sym_t;
typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef __int16_t int16_t;
typedef __uint8_t uint8_t;
union YYSTYPE {
   node *nd ;
   node_string id ;
};
typedef union YYSTYPE YYSTYPE;
typedef signed char yytype_int8;
typedef short yytype_int16;
typedef unsigned char yytype_uint8;
typedef yytype_uint8 yy_state_t;
typedef int yy_state_fast_t;
union yyalloc {
   yy_state_t yyss_alloc ;
   YYSTYPE yyvs_alloc ;
};
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef int32_t flex_int32_t;
typedef size_t yy_size_t;
typedef flex_uint8_t YY_CHAR;
typedef int yy_state_type;
#pragma merger("0","/tmp/cil-l96hFWVo.i","-std=gnu99,-g,-ggdb,-Wall")
extern FILE *stdout ;
extern FILE *stderr ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format
                   , ...) ;
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
int strm_option_verbose ;
strm_value strm_cfunc_value(int (*f)(struct strm_stream * , int  , strm_value * ,
                                     strm_value * ) ) ;
strm_value strm_bool_value(int i ) ;
strm_value strm_int_value(int i ) ;
strm_value strm_float_value(double f ) ;
strm_value strm_nil_value(void) ;
strm_cfunc strm_value_cfunc(strm_value v ) ;
int strm_value_int(strm_value v ) ;
int strm_value_bool(strm_value v ) ;
double strm_value_float(strm_value v ) ;
int strm_value_eq(strm_value a , strm_value b ) ;
int strm_nil_p(strm_value v ) ;
int strm_bool_p(strm_value v ) ;
int strm_number_p(strm_value v ) ;
int strm_cfunc_p(strm_value v ) ;
int strm_array_p(strm_value v ) ;
int strm_string_p(unsigned long s ) ;
int strm_int_p(strm_value v ) ;
int strm_float_p(strm_value v ) ;
int strm_ptr_tag_p(strm_value v , enum strm_ptr_type e ) ;
void *strm_value_ptr(strm_value v , enum strm_ptr_type e ) ;
strm_value strm_ptr_value(void *p ) ;
strm_string strm_str_new(char const   *p , strm_int len ) ;
char const   *strm_strp_ptr(strm_string *s ) ;
char const   *strm_str_cstr(strm_string s , char *buf ) ;
strm_int strm_str_len(strm_string s ) ;
strm_string strm_str_intern(char const   *p , strm_int len ) ;
int strm_str_eq(strm_string a , strm_string b ) ;
strm_string strm_to_str(strm_value v ) ;
strm_array strm_ary_new(strm_value const   *p , strm_int len ) ;
struct strm_array *strm_ary_struct(unsigned long v ) ;
strm_stream *strm_stream_new(strm_stream_mode mode , int (*start_func)(strm_stream * ,
                                                                       strm_value  ) ,
                             int (*close_func)(strm_stream * , strm_value  ) , void *data ) ;
void strm_emit(strm_stream *strm , strm_value data , int (*func)(strm_stream * , strm_value  ) ) ;
int strm_stream_connect(strm_stream *src , strm_stream *dst ) ;
int strm_connect(strm_stream *strm , strm_value src , strm_value dst , strm_value *ret ) ;
void strm_stream_close(strm_stream *strm ) ;
void strm_raise(strm_stream *strm , char const   *msg ) ;
int strm_funcall(strm_stream *strm , strm_value func , int argc , strm_value *argv ,
                 strm_value *ret ) ;
void strm_eprint(strm_stream *strm ) ;
int strm_parse_args(strm_stream *strm , int argc , strm_value *argv , char const   *format
                    , ...) ;
int strm_var_set(strm_state *state , strm_string name , strm_value val ) ;
int strm_var_def(strm_state *state , char const   *name , strm_value val ) ;
int strm_var_get(strm_state *state , strm_string name , strm_value *val ) ;
int strm_var_match(strm_state *state , strm_string name , strm_value val ) ;
int strm_env_copy(strm_state *s1 , strm_state *s2 ) ;
strm_state *strm_ns_create(strm_state *state , strm_string name ) ;
strm_state *strm_ns_get(strm_string name ) ;
strm_state *strm_value_ns(strm_value val ) ;
strm_value strm_io_new(int fd , int mode ) ;
strm_stream *strm_io_stream(strm_value iov , int mode ) ;
strm_value strm_time_new(long sec , long usec , int offset ) ;
int node_run(parser_state *p ) ;
void node_stop(void) ;
static void strm_clear_exc(strm_stream *strm )
{


  {
  if (strm->exc) {
    free((void *)strm->exc);
  }
  strm->exc = (struct node_error *)((void *)0);
  return;
}
}
static node_error *strm_set_exc(strm_stream *strm , int type , strm_value arg )
{
  node_error *exc ;
  void *tmp ;

  {
  tmp = malloc(sizeof(node_error ));
  exc = (node_error *)tmp;
  if (! exc) {
    return ((node_error *)((void *)0));
  }
  exc->type = type;
  exc->arg = arg;
  exc->fname = (char const   *)0;
  exc->lineno = 0;
  strm_clear_exc(strm);
  strm->exc = exc;
  return (exc);
}
}
static strm_string node_to_sym(node_string s )
{
  strm_string tmp ;

  {
  tmp = strm_str_intern((char const   *)(s->buf), s->len);
  return (tmp);
}
}
static strm_string node_to_str(node_string s )
{
  strm_string tmp ;

  {
  tmp = strm_str_new((char const   *)(s->buf), s->len);
  return (tmp);
}
}
static int exec_eq(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_value x ;
  strm_value y ;
  int tmp ;
  int tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "vv", & x, & y);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = strm_value_eq(x, y);
  *ret = strm_bool_value(tmp___0);
  return (0);
}
}
static int exec_neq(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_value x ;
  strm_value y ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "vv", & x, & y);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = strm_value_eq(x, y);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  *ret = strm_bool_value(tmp___1);
  return (0);
}
}
static int blk_exec(strm_stream *strm , strm_value data ) ;
static int arr_exec(strm_stream *strm , strm_value data ) ;
static int cfunc_exec(strm_stream *strm , strm_value data ) ;
static int cfunc_closer(strm_stream *strm , strm_value data )
{


  {
  return (0);
}
}
int strm_connect(strm_stream *strm , strm_value src , strm_value dst , strm_value *ret )
{
  strm_stream *tmp ;
  struct strm_lambda *lmbd ;
  void *tmp___0 ;
  strm_stream *tmp___1 ;
  struct array_data *arrd ;
  void *tmp___2 ;
  strm_stream *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  strm_stream *tmp___7 ;
  struct strm_lambda *lmbd___0 ;
  void *tmp___8 ;
  strm_stream *tmp___9 ;
  int (*func)(struct strm_stream * , int  , strm_value * , strm_value * ) ;
  strm_cfunc tmp___10 ;
  strm_stream *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  strm_stream *lstrm ;
  void *tmp___15 ;
  strm_stream *rstrm ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;

  {
  tmp___6 = strm_ptr_tag_p(src, (enum strm_ptr_type )3);
  if (tmp___6) {
    tmp = strm_io_stream(src, 1);
    src = strm_ptr_value((void *)tmp);
  } else {
    tmp___5 = strm_ptr_tag_p(src, (enum strm_ptr_type )1);
    if (tmp___5) {
      tmp___0 = strm_value_ptr(src, (enum strm_ptr_type )1);
      lmbd = (struct strm_lambda *)tmp___0;
      tmp___1 = strm_stream_new((strm_stream_mode )1, & blk_exec, (int (*)(strm_stream * ,
                                                                           strm_value  ))((void *)0),
                                (void *)lmbd);
      src = strm_ptr_value((void *)tmp___1);
    } else {
      tmp___4 = strm_array_p(src);
      if (tmp___4) {
        tmp___2 = malloc(sizeof(struct array_data ));
        arrd = (struct array_data *)tmp___2;
        arrd->arr = src;
        arrd->n = 0;
        tmp___3 = strm_stream_new((strm_stream_mode )0, & arr_exec, (int (*)(strm_stream * ,
                                                                             strm_value  ))((void *)0),
                                  (void *)arrd);
        src = strm_ptr_value((void *)tmp___3);
      }
    }
  }
  tmp___14 = strm_ptr_tag_p(dst, (enum strm_ptr_type )3);
  if (tmp___14) {
    tmp___7 = strm_io_stream(dst, 2);
    dst = strm_ptr_value((void *)tmp___7);
  } else {
    tmp___13 = strm_ptr_tag_p(dst, (enum strm_ptr_type )1);
    if (tmp___13) {
      tmp___8 = strm_value_ptr(dst, (enum strm_ptr_type )1);
      lmbd___0 = (struct strm_lambda *)tmp___8;
      tmp___9 = strm_stream_new((strm_stream_mode )1, & blk_exec, (int (*)(strm_stream * ,
                                                                           strm_value  ))((void *)0),
                                (void *)lmbd___0);
      dst = strm_ptr_value((void *)tmp___9);
    } else {
      tmp___12 = strm_cfunc_p(dst);
      if (tmp___12) {
        tmp___10 = strm_value_cfunc(dst);
        func = tmp___10;
        tmp___11 = strm_stream_new((strm_stream_mode )1, & cfunc_exec, & cfunc_closer,
                                   (void *)func);
        dst = strm_ptr_value((void *)tmp___11);
      }
    }
  }
  tmp___19 = strm_ptr_tag_p(src, (enum strm_ptr_type )0);
  if (tmp___19) {
    tmp___20 = strm_ptr_tag_p(dst, (enum strm_ptr_type )0);
    if (tmp___20) {
      tmp___15 = strm_value_ptr(src, (enum strm_ptr_type )0);
      lstrm = (strm_stream *)tmp___15;
      tmp___16 = strm_value_ptr(dst, (enum strm_ptr_type )0);
      rstrm = (strm_stream *)tmp___16;
      if ((unsigned long )lstrm == (unsigned long )((void *)0)) {
        strm_raise(strm, "stream error");
        return (1);
      } else
      if ((unsigned long )rstrm == (unsigned long )((void *)0)) {
        strm_raise(strm, "stream error");
        return (1);
      } else
      if ((unsigned int )lstrm->mode == 2U) {
        strm_raise(strm, "stream error");
        return (1);
      } else
      if ((unsigned int )rstrm->mode == 0U) {
        strm_raise(strm, "stream error");
        return (1);
      }
      tmp___17 = strm_value_ptr(dst, (enum strm_ptr_type )0);
      tmp___18 = strm_value_ptr(src, (enum strm_ptr_type )0);
      strm_stream_connect((strm_stream *)tmp___18, (strm_stream *)tmp___17);
      *ret = dst;
      return (0);
    }
  }
  return (1);
}
}
static int exec_bar(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_value x ;
  strm_value y ;
  int tmp ;
  int tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "vv", & x, & y);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = strm_connect(strm, x, y, ret);
  return (tmp___0);
}
}
static int exec_expr(strm_stream *strm , strm_state *state , node *np , strm_value *val ) ;
static int ary_get(strm_stream *strm , strm_value ary , int argc , strm_value *argv ,
                   strm_value *ret )
{
  struct strm_array *a ;
  strm_value idx ;
  strm_int i ;
  strm_int tmp ;
  int tmp___0 ;
  strm_int i___0 ;
  strm_int len ;
  struct strm_array *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if (argc != 1) {
    strm_raise(strm, "wrong number of arguments");
    return (1);
  }
  a = strm_ary_struct(ary);
  idx = *(argv + 0);
  tmp___0 = strm_number_p(idx);
  if (tmp___0) {
    tmp = strm_value_int(idx);
    i = tmp;
    if (i >= a->len) {
      return (1);
    }
    *ret = *(a->ptr + i);
    return (0);
  }
  tmp___3 = strm_string_p(idx);
  if (tmp___3) {
    if (a->headers) {
      len = a->len;
      i___0 = 0;
      while (i___0 < len) {
        tmp___1 = strm_ary_struct(a->headers);
        tmp___2 = strm_str_eq(idx, *(tmp___1->ptr + i___0));
        if (tmp___2) {
          *ret = *(a->ptr + i___0);
          return (0);
        }
        i___0 ++;
      }
    }
  }
  return (1);
}
}
static int pattern_match(strm_stream *strm , strm_state *state , node *npat , int argc ,
                         strm_value *argv ) ;
static int pmatch(strm_stream *strm , strm_state *state , node *pat , strm_value val ) ;
static int pattern_placeholder_p(node_string name )
{


  {
  if (name->len == 1) {
    if ((int )name->buf[0] == 95) {
      return (1);
    }
  }
  return (0);
}
}
static int pmatch_struct(strm_stream *strm , strm_state *state , node *pat , strm_value val ,
                         uint64_t *tbl , strm_int *len )
{
  node_nodes *pstr ;
  strm_array ary ;
  struct strm_array *a ;
  struct strm_array *tmp ;
  strm_value *headers ;
  struct strm_array *tmp___0 ;
  int i ;
  node_pair *npair ;
  strm_string key ;
  int j ;
  int tmp___2 ;
  uint64_t n ;

  {
  pstr = (node_nodes *)pat;
  ary = val;
  tmp = strm_ary_struct(ary);
  a = tmp;
  if (! a->headers) {
    return (1);
  }
  if (pstr->len > a->len) {
    return (1);
  }
  tmp___0 = strm_ary_struct(a->headers);
  headers = tmp___0->ptr;
  i = 0;
  while (i < pstr->len) {
    npair = (node_pair *)*(pstr->data + i);
    if (! ((unsigned int )npair->type == 7U)) {
      __assert_fail("npair->type == NODE_PAIR", "exec.c", 203U, "pmatch_struct");
    }
    key = node_to_sym(npair->key);
    j = 0;
    while (i < a->len) {
      if (*(headers + j) == key) {
        tmp___2 = pmatch(strm, state, npair->value, *(a->ptr + j));
        if (tmp___2 == 1) {
          return (1);
        }
        if (tbl) {
          n = (uint64_t )(1 << j % 64);
          if (*(tbl + j / 64) & n) {
            (*len) --;
          }
          *(tbl + j / 64) |= n;
        }
        break;
      }
      j ++;
    }
    i ++;
  }
  return (0);
}
}
static int pmatch(strm_stream *strm , strm_state *state , node *pat , strm_value val )
{
  node_ident *ni ;
  int tmp ;
  strm_string tmp___0 ;
  int tmp___1 ;
  strm_string tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  strm_int n ;
  strm_int tmp___5 ;
  int tmp___6 ;
  double tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  double tmp___11 ;
  int tmp___12 ;
  node_ns *ns ;
  strm_state *s1 ;
  strm_string tmp___13 ;
  strm_state *tmp___14 ;
  strm_state *s2 ;
  strm_state *tmp___15 ;
  int tmp___16 ;
  strm_array ary ;
  struct strm_array *tmp___17 ;
  struct strm_array *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  strm_array ary___0 ;
  node_psplat *psp ;
  node_nodes *pstr ;
  strm_int len ;
  uint64_t buf ;
  uint64_t *tbl ;
  void *tmp___21 ;
  int tmp___22 ;
  struct strm_array *a ;
  struct strm_array *tmp___24 ;
  strm_value *hdr ;
  struct strm_array *tmp___25 ;
  strm_array splat ;
  strm_array tmp___26 ;
  strm_array nhdr ;
  strm_array tmp___27 ;
  int n___0 ;
  int i ;
  struct strm_array *tmp___28 ;
  struct strm_array *tmp___29 ;
  struct strm_array *tmp___30 ;
  int tmp___31 ;
  struct strm_array *tmp___32 ;
  struct strm_array *tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;

  {
  switch ((unsigned int )pat->type) {
  case 15U:
  ni = (node_ident *)pat;
  tmp = pattern_placeholder_p(ni->name);
  if (tmp) {
    return (0);
  }
  tmp___0 = node_to_sym(ni->name);
  tmp___1 = strm_var_match(state, tmp___0, val);
  return (tmp___1);
  case 3U:
  tmp___4 = strm_string_p(val);
  if (tmp___4) {
    tmp___2 = node_to_str(((node_str *)pat)->value);
    tmp___3 = strm_str_eq(val, tmp___2);
    if (tmp___3) {
      return (0);
    }
  }
  break;
  case 0U:
  n = ((node_int *)pat)->value;
  tmp___6 = strm_int_p(val);
  if (tmp___6) {
    tmp___5 = strm_value_int(val);
    if (n == tmp___5) {
      return (0);
    }
    return (1);
  }
  tmp___8 = strm_float_p(val);
  if (tmp___8) {
    tmp___7 = strm_value_float(val);
    if ((double )n == tmp___7) {
      return (0);
    }
    return (1);
  }
  break;
  case 4U:
  tmp___9 = strm_nil_p(val);
  if (tmp___9) {
    return (0);
  }
  return (1);
  case 5U:
  tmp___10 = strm_value_bool(val);
  if (tmp___10 == ((node_bool *)pat)->value) {
    return (0);
  }
  return (1);
  case 1U:
  tmp___12 = strm_number_p(val);
  if (tmp___12) {
    tmp___11 = strm_value_float(val);
    if (((node_float *)pat)->value == tmp___11) {
      return (0);
    }
    return (1);
  }
  break;
  case 29U:
  ns = (node_ns *)pat;
  tmp___13 = node_to_sym(ns->name);
  tmp___14 = strm_ns_get(tmp___13);
  s1 = tmp___14;
  tmp___15 = strm_value_ns(val);
  s2 = tmp___15;
  if ((unsigned long )s1 != (unsigned long )s2) {
    return (1);
  }
  tmp___16 = pmatch(strm, state, ns->body, val);
  return (tmp___16);
  break;
  case 11U:
  tmp___20 = strm_array_p(val);
  if (tmp___20) {
    ary = val;
    tmp___17 = strm_ary_struct(ary);
    tmp___18 = strm_ary_struct(ary);
    tmp___19 = pattern_match(strm, state, pat, tmp___18->len, tmp___17->ptr);
    return (tmp___19);
  }
  break;
  case 13U:
  tmp___35 = strm_array_p(val);
  if (tmp___35) {
    ary___0 = val;
    psp = (node_psplat *)pat;
    if (psp->head) {
      if ((unsigned int )(psp->head)->type == 12U) {
        pstr = (node_nodes *)psp->head;
        len = pstr->len;
        buf = (uint64_t )0;
        tbl = & buf;
        if (len > 64) {
          tmp___21 = malloc((size_t )(len / 64 + 1));
          tbl = (uint64_t *)tmp___21;
          memset((void *)tbl, 0, (size_t )(len / 64 + 1));
        }
        tmp___22 = pmatch_struct(strm, state, psp->head, val, tbl, & len);
        if (tmp___22 == 1) {
          return (1);
        }
        if (! ((unsigned long )psp->tail == (unsigned long )((void *)0))) {
          __assert_fail("psp->tail == NULL", "exec.c", 302U, "pmatch");
        }
        tmp___24 = strm_ary_struct(ary___0);
        a = tmp___24;
        tmp___25 = strm_ary_struct(a->headers);
        hdr = tmp___25->ptr;
        tmp___26 = strm_ary_new((strm_value const   *)((void *)0), a->len - len);
        splat = tmp___26;
        tmp___27 = strm_ary_new((strm_value const   *)((void *)0), a->len - len);
        nhdr = tmp___27;
        n___0 = 0;
        i = 0;
        while (i < a->len) {
          if (*(tbl + i / 64) & (unsigned long )(1 << i % 64)) {
            goto __Cont;
          }
          tmp___28 = strm_ary_struct(nhdr);
          *(tmp___28->ptr + n___0) = *(hdr + i);
          tmp___29 = strm_ary_struct(splat);
          *(tmp___29->ptr + n___0) = *(a->ptr + i);
          n___0 ++;
          __Cont: /* CIL Label */
          i ++;
        }
        tmp___30 = strm_ary_struct(splat);
        tmp___30->headers = nhdr;
        tmp___31 = pmatch(strm, state, psp->mid, splat);
        return (tmp___31);
      }
    }
    tmp___32 = strm_ary_struct(ary___0);
    tmp___33 = strm_ary_struct(ary___0);
    tmp___34 = pattern_match(strm, state, pat, tmp___33->len, tmp___32->ptr);
    return (tmp___34);
  }
  break;
  case 12U:
  tmp___36 = strm_array_p(val);
  if (! tmp___36) {
    return (1);
  }
  tmp___37 = pmatch_struct(strm, state, pat, val, (uint64_t *)((void *)0), (strm_int *)((void *)0));
  return (tmp___37);
  default:
  break;
  }
  return (1);
}
}
static int pattern_match(strm_stream *strm , strm_state *state , node *npat , int argc ,
                         strm_value *argv )
{
  node_nodes *pat ;
  int i ;
  node_psplat *psp ;
  node_nodes *head ;
  node_nodes *tail ;
  node *rest ;
  strm_int hlen ;
  int tmp ;
  int tmp___0 ;
  strm_array tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  pat = (node_nodes *)npat;
  if ((unsigned long )pat == (unsigned long )((void *)0)) {
    return (0);
  }
  if ((unsigned int )npat->type == 13U) {
    psp = (node_psplat *)pat;
    head = (node_nodes *)psp->head;
    tail = (node_nodes *)psp->tail;
    rest = psp->mid;
    if (head) {
      tmp = head->len;
    } else {
      tmp = 0;
    }
    hlen = tmp;
    if (argc < hlen) {
      return (1);
    }
    if (head) {
      tmp___0 = pattern_match(strm, state, (node *)head, hlen, argv);
      if (tmp___0 == 1) {
        return (1);
      }
    }
    if ((unsigned long )tail == (unsigned long )((void *)0)) {
      tmp___1 = strm_ary_new((strm_value const   *)(argv + hlen), argc - hlen);
      tmp___2 = pmatch(strm, state, rest, tmp___1);
      if (tmp___2 == 1) {
        return (1);
      }
    } else {
      if (argc < hlen + tail->len) {
        return (1);
      }
      tmp___3 = pattern_match(strm, state, rest, (argc - hlen) - tail->len, argv + hlen);
      if (tmp___3 == 1) {
        return (1);
      }
      tmp___4 = pattern_match(strm, state, (node *)tail, tail->len, (argv + argc) - tail->len);
      if (tmp___4 == 1) {
        return (1);
      }
    }
    return (0);
  }
  if (pat->len != argc) {
    return (1);
  }
  i = 0;
  while (i < pat->len) {
    tmp___5 = pmatch(strm, state, *(pat->data + i), *(argv + i));
    if (tmp___5 == 1) {
      return (1);
    }
    i ++;
  }
  return (0);
}
}
static int lambda_call(strm_stream *strm , strm_value func , int argc , strm_value *argv ,
                       strm_value *ret )
{
  struct strm_lambda *lambda ;
  void *tmp ;
  strm_state c ;
  int i ;
  int n ;
  node_error *exc ;
  node_lambda *nlmbd ;
  node_args *args ;
  strm_string tmp___0 ;
  node_plambda *plmbd ;
  int nexec ;
  strm_value cond ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = strm_value_ptr(func, (enum strm_ptr_type )1);
  lambda = (struct strm_lambda *)tmp;
  c.env = (void *)0;
  c.prev = (struct strm_state *)0;
  c.flags = 0U;
  c.prev = lambda->state;
  if ((unsigned int )(lambda->body)->type == 9U) {
    nlmbd = lambda->body;
    args = (node_args *)nlmbd->args;
    if ((unsigned long )args == (unsigned long )((void *)0)) {
      if (argc > 0) {
        goto argerr;
      }
    } else
    if (args->len != argc) {
      argerr:
      strm_raise(strm, "wrong number of arguments");
      goto err;
    }
    i = 0;
    while (i < argc) {
      tmp___0 = node_to_sym(*(args->data + i));
      n = strm_var_set(& c, tmp___0, *(argv + i));
      if (n) {
        return (n);
      }
      i ++;
    }
    n = exec_expr(strm, & c, nlmbd->body, ret);
  } else
  if ((unsigned int )(lambda->body)->type == 10U) {
    plmbd = (node_plambda *)lambda->body;
    nexec = 0;
    while (plmbd) {
      tmp___2 = pattern_match(strm, & c, plmbd->pat, argc, argv);
      if (tmp___2 == 0) {
        if (plmbd->cond) {
          n = exec_expr(strm, & c, plmbd->cond, & cond);
          if (n == 0) {
            tmp___1 = strm_value_bool(cond);
            if (tmp___1) {
              nexec ++;
              n = exec_expr(strm, & c, plmbd->body, ret);
              break;
            }
          }
        } else {
          nexec ++;
          n = exec_expr(strm, & c, plmbd->body, ret);
          break;
        }
      }
      c.env = (void *)0;
      plmbd = (node_plambda *)plmbd->next;
    }
    if (nexec == 0) {
      strm_raise(strm, "match failure");
      goto err;
    }
  } else {
    return (1);
  }
  if (n == 1) {
    if (strm) {
      exc = strm->exc;
      if (exc) {
        if (exc->type == 1) {
          *ret = exc->arg;
          return (0);
        }
      }
    }
  }
  return (n);
  err:
  if (strm) {
    if (strm->exc) {
      (strm->exc)->fname = (lambda->body)->fname;
      (strm->exc)->lineno = (lambda->body)->lineno;
    }
  }
  return (1);
}
}
static struct strm_genfunc *genfunc_new(strm_state *state , strm_string id )
{
  struct strm_genfunc *gf ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct strm_genfunc ));
  gf = (struct strm_genfunc *)tmp;
  if (! gf) {
    return ((struct strm_genfunc *)((void *)0));
  }
  gf->type = (enum strm_ptr_type )2;
  gf->state = state;
  gf->id = id;
  return (gf);
}
}
static int exec_call(strm_stream *strm , strm_state *state , strm_string name , int argc ,
                     strm_value *argv , strm_value *ret ) ;
int strm_funcall(strm_stream *strm , strm_value func , int argc , strm_value *argv ,
                 strm_value *ret )
{
  strm_cfunc tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct strm_genfunc *gf ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  switch (func & (65535UL << 48)) {
  case 18445336698825998336:
  tmp = strm_value_cfunc(func);
  tmp___0 = (*tmp)(strm, argc, argv, ret);
  return (tmp___0);
  case 18443366373989023744:
  tmp___1 = ary_get(strm, func, argc, argv, ret);
  return (tmp___1);
  case 18445899648779419648:
  tmp___5 = strm_ptr_tag_p(func, (enum strm_ptr_type )2);
  if (tmp___5) {
    gf = (struct strm_genfunc *)((void *)((intptr_t )(func & ~ (65535UL << 48))));
    tmp___2 = exec_call(strm, gf->state, gf->id, argc, argv, ret);
    return (tmp___2);
  } else {
    tmp___4 = strm_ptr_tag_p(func, (enum strm_ptr_type )1);
    if (tmp___4) {
      tmp___3 = lambda_call(strm, func, argc, argv, ret);
      return (tmp___3);
    }
  }
  break;
  default:
  break;
  }
  strm_raise(strm, "not a function");
  return (1);
}
}
static int exec_call(strm_stream *strm , strm_state *state , strm_string name , int argc ,
                     strm_value *argv , strm_value *ret )
{
  int n ;
  strm_value m ;
  strm_state *ns ;
  strm_state *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  n = 1;
  if (argc > 0) {
    tmp = strm_value_ns(*(argv + 0));
    ns = tmp;
    if (ns) {
      n = strm_var_get(ns, name, & m);
      if (n == 1) {
        if (argc > 0) {
          tmp___0 = strm_array_p(*(argv + 0));
          if (tmp___0) {
            m = name;
            n = ary_get(strm, *(argv + 0), 1, & m, ret);
            if (n == 0) {
              if (argc == 1) {
                return (0);
              }
            }
            m = *ret;
          }
        }
      }
    }
  }
  if (n == 1) {
    n = strm_var_get(state, name, & m);
  }
  if (n == 0) {
    tmp___1 = strm_funcall(strm, m, argc, argv, ret);
    return (tmp___1);
  }
  strm_raise(strm, "function not found");
  return (1);
}
}
static strm_array ary_headers(node_string *headers , strm_int len )
{
  strm_array ary ;
  strm_array tmp ;
  strm_value *p ;
  struct strm_array *tmp___0 ;
  strm_int i ;

  {
  tmp = strm_ary_new((strm_value const   *)((void *)0), len);
  ary = tmp;
  tmp___0 = strm_ary_struct(ary);
  p = tmp___0->ptr;
  i = 0;
  while (i < len) {
    *(p + i) = node_to_sym(*(headers + i));
    i ++;
  }
  return (ary);
}
}
static int exec_expr(strm_stream *strm , strm_state *state , node *np , strm_value *val )
{
  int n ;
  node_ns *ns ;
  strm_string name ;
  strm_string tmp ;
  strm_state *s ;
  strm_state *tmp___0 ;
  strm_state *tmp___1 ;
  int tmp___2 ;
  node_import *ns___0 ;
  strm_state *s___0 ;
  strm_string tmp___3 ;
  strm_state *tmp___4 ;
  strm_value tmp___5 ;
  int i ;
  int n___0 ;
  node_array *v0 ;
  strm_value tmp___6 ;
  node_let *nlet ;
  strm_string tmp___7 ;
  int tmp___8 ;
  node_array *v0___0 ;
  strm_array arr ;
  strm_array tmp___9 ;
  strm_value *ptr ;
  struct strm_array *tmp___10 ;
  int splat ;
  int i___0 ;
  node_splat *s___1 ;
  int tmp___11 ;
  int len ;
  int i___1 ;
  strm_array a ;
  struct strm_array *tmp___12 ;
  strm_value *nptr ;
  struct strm_array *tmp___13 ;
  int i___2 ;
  strm_array a___0 ;
  int alen ;
  struct strm_array *tmp___14 ;
  strm_value *aptr ;
  struct strm_array *tmp___15 ;
  int j ;
  strm_value *tmp___16 ;
  strm_value *tmp___17 ;
  struct strm_array *tmp___18 ;
  strm_state *ns___1 ;
  strm_string tmp___19 ;
  strm_state *tmp___20 ;
  struct strm_array *tmp___21 ;
  struct strm_array *tmp___22 ;
  node_ident *ni ;
  strm_string tmp___23 ;
  strm_value v ;
  node_if *nif ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  node_op *nop ;
  strm_value args[2] ;
  int i___3 ;
  int tmp___28 ;
  int tmp___29 ;
  strm_string tmp___30 ;
  int tmp___31 ;
  struct strm_lambda *lambda ;
  void *tmp___32 ;
  void *tmp___33 ;
  node_call *ncall ;
  int i___4 ;
  node_nodes *v0___1 ;
  strm_value *args___0 ;
  int splat___0 ;
  strm_value aary ;
  struct strm_array *tmp___34 ;
  struct strm_array *tmp___35 ;
  void *tmp___36 ;
  strm_string tmp___37 ;
  node_fcall *ncall___0 ;
  int i___5 ;
  strm_value func ;
  node_nodes *v0___2 ;
  strm_value *args___1 ;
  int splat___1 ;
  int tmp___38 ;
  strm_value aary___0 ;
  struct strm_array *tmp___39 ;
  struct strm_array *tmp___40 ;
  void *tmp___41 ;
  node_genfunc *ngf ;
  struct strm_genfunc *gf ;
  strm_string tmp___42 ;
  node_return *nreturn ;
  node_nodes *args___2 ;
  strm_value arg ;
  strm_array ary ;
  strm_array tmp___43 ;
  strm_int i___6 ;
  struct strm_array *tmp___44 ;
  int i___7 ;
  node_nodes *v___0 ;
  node_error *exc ;
  node *n___1 ;
  node_time *nt ;
  int tmp___45 ;
  strm_string tmp___46 ;

  {
  if ((unsigned long )np == (unsigned long )((void *)0)) {
    return (1);
  }
  switch ((unsigned int )np->type) {
  case 29U:
  ns = (node_ns *)np;
  tmp = node_to_sym(ns->name);
  name = tmp;
  tmp___0 = strm_ns_create(state, name);
  s = tmp___0;
  if (! s) {
    tmp___1 = strm_ns_get(name);
    if (tmp___1) {
      strm_raise(strm, "namespace already exists");
    } else {
      strm_raise(strm, "failed to create namespace");
    }
    return (1);
  }
  s->flags |= 1U;
  if (ns->body) {
    tmp___2 = exec_expr(strm, s, ns->body, val);
    return (tmp___2);
  }
  return (0);
  case 30U:
  ns___0 = (node_import *)np;
  tmp___3 = node_to_sym(ns___0->name);
  tmp___4 = strm_ns_get(tmp___3);
  s___0 = tmp___4;
  if (! s___0) {
    strm_raise(strm, "no such namespace");
    return (1);
  }
  n = strm_env_copy(state, s___0);
  if (n) {
    strm_raise(strm, "failed to import");
    return (n);
  }
  return (0);
  break;
  case 19U:
  tmp___5 = strm_nil_value();
  strm_set_exc(strm, 2, tmp___5);
  return (1);
  case 18U:
  v0 = (node_array *)((node_emit *)np)->emit;
  if (! v0) {
    tmp___6 = strm_nil_value();
    strm_emit(strm, tmp___6, (int (*)(strm_stream * , strm_value  ))((void *)0));
  } else {
    i = 0;
    while (i < v0->len) {
      n___0 = exec_expr(strm, state, *(v0->data + i), val);
      if (n___0) {
        return (n___0);
      }
      strm_emit(strm, *val, (int (*)(strm_stream * , strm_value  ))((void *)0));
      i ++;
    }
  }
  return (0);
  break;
  case 16U:
  nlet = (node_let *)np;
  n = exec_expr(strm, state, nlet->rhs, val);
  if (n) {
    strm_raise(strm, "failed to assign");
    return (n);
  }
  tmp___7 = node_to_sym(nlet->lhs);
  tmp___8 = strm_var_set(state, tmp___7, *val);
  return (tmp___8);
  case 27U:
  v0___0 = (node_array *)np;
  tmp___9 = strm_ary_new((strm_value const   *)((void *)0), v0___0->len);
  arr = tmp___9;
  tmp___10 = strm_ary_struct(arr);
  ptr = tmp___10->ptr;
  splat = 0;
  i___0 = 0;
  while (i___0 < v0___0->len) {
    if ((unsigned int )(*(v0___0->data + i___0))->type == 14U) {
      s___1 = (node_splat *)*(v0___0->data + i___0);
      n = exec_expr(strm, state, s___1->node, ptr + i___0);
      if (n) {
        return (n);
      }
      tmp___11 = strm_array_p(*(ptr + i___0));
      if (! tmp___11) {
        strm_raise(strm, "splat requires array");
        return (1);
      }
      splat = 1;
    } else {
      n = exec_expr(strm, state, *(v0___0->data + i___0), ptr + i___0);
      if (n) {
        return (n);
      }
    }
    i___0 ++;
  }
  if (splat) {
    len = v0___0->len;
    if (v0___0->headers) {
      strm_raise(strm, "label(s) and splat(s) in an array");
      return (1);
    }
    i___1 = 0;
    while (i___1 < v0___0->len) {
      if ((unsigned int )(*(v0___0->data + i___1))->type == 14U) {
        a = *(ptr + i___1);
        tmp___12 = strm_ary_struct(a);
        len += tmp___12->len - 1;
      }
      i___1 ++;
    }
    if (len > v0___0->len) {
      arr = strm_ary_new((strm_value const   *)((void *)0), len);
      tmp___13 = strm_ary_struct(arr);
      nptr = tmp___13->ptr;
      i___2 = 0;
      while (i___2 < v0___0->len) {
        if ((unsigned int )(*(v0___0->data + i___2))->type == 14U) {
          a___0 = *(ptr + i___2);
          tmp___14 = strm_ary_struct(a___0);
          alen = tmp___14->len;
          tmp___15 = strm_ary_struct(a___0);
          aptr = tmp___15->ptr;
          j = 0;
          while (j < alen) {
            tmp___16 = nptr;
            nptr ++;
            *tmp___16 = *(aptr + j);
            j ++;
          }
        } else {
          tmp___17 = nptr;
          nptr ++;
          *tmp___17 = *(ptr + i___2);
        }
        i___2 ++;
      }
    }
  } else
  if (v0___0->headers) {
    tmp___18 = strm_ary_struct(arr);
    tmp___18->headers = ary_headers(v0___0->headers, v0___0->len);
  }
  if (v0___0->ns) {
    tmp___19 = node_to_sym(v0___0->ns);
    tmp___20 = strm_ns_get(tmp___19);
    ns___1 = tmp___20;
    if (! (ns___1->flags & 1U)) {
      strm_raise(strm, "instantiating primitive class");
      return (1);
    }
    tmp___21 = strm_ary_struct(arr);
    tmp___21->ns = ns___1;
  } else {
    tmp___22 = strm_ary_struct(arr);
    tmp___22->ns = (struct strm_state *)0;
  }
  *val = arr;
  return (0);
  case 15U:
  ni = (node_ident *)np;
  tmp___23 = node_to_sym(ni->name);
  n = strm_var_get(state, tmp___23, val);
  if (n) {
    strm_raise(strm, "failed to reference variable");
  }
  return (n);
  case 17U:
  nif = (node_if *)np;
  n = exec_expr(strm, state, nif->cond, & v);
  if (n) {
    return (n);
  }
  tmp___26 = strm_bool_p(v);
  if (tmp___26) {
    tmp___27 = strm_value_bool(v);
    if (tmp___27) {
      tmp___24 = exec_expr(strm, state, nif->then, val);
      return (tmp___24);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */
  if ((unsigned long )nif->opt_else != (unsigned long )((void *)0)) {
    tmp___25 = exec_expr(strm, state, nif->opt_else, val);
    return (tmp___25);
  } else {
    *val = strm_nil_value();
    return (0);
  }
  break;
  case 23U:
  nop = (node_op *)np;
  i___3 = 0;
  if (nop->lhs) {
    tmp___28 = i___3;
    i___3 ++;
    n = exec_expr(strm, state, nop->lhs, & args[tmp___28]);
    if (n) {
      return (n);
    }
  }
  if (nop->rhs) {
    tmp___29 = i___3;
    i___3 ++;
    n = exec_expr(strm, state, nop->rhs, & args[tmp___29]);
    if (n) {
      return (n);
    }
  }
  tmp___30 = node_to_sym(nop->op);
  tmp___31 = exec_call(strm, state, tmp___30, i___3, args, val);
  return (tmp___31);
  break;
  case 10U:
  case 9U:
  tmp___32 = malloc(sizeof(struct strm_lambda ));
  lambda = (struct strm_lambda *)tmp___32;
  if (! lambda) {
    return (1);
  }
  tmp___33 = malloc(sizeof(strm_state ));
  lambda->state = (struct strm_state *)tmp___33;
  if (! lambda->state) {
    return (1);
  }
  *(lambda->state) = *state;
  lambda->type = (enum strm_ptr_type )1;
  lambda->body = (node_lambda *)np;
  *val = strm_ptr_value((void *)lambda);
  return (0);
  break;
  case 24U:
  ncall = (node_call *)np;
  v0___1 = (node_nodes *)ncall->args;
  splat___0 = 0;
  i___4 = 0;
  while (i___4 < v0___1->len) {
    if ((unsigned int )(*(v0___1->data + i___4))->type == 14U) {
      splat___0 = 1;
      break;
    }
    i___4 ++;
  }
  if (splat___0) {
    n = exec_expr(strm, state, ncall->args, & aary);
    tmp___34 = strm_ary_struct(aary);
    args___0 = tmp___34->ptr;
    tmp___35 = strm_ary_struct(aary);
    i___4 = tmp___35->len;
  } else {
    tmp___36 = malloc(sizeof(strm_value ) * (unsigned long )v0___1->len);
    args___0 = (strm_value *)tmp___36;
    i___4 = 0;
    while (i___4 < v0___1->len) {
      n = exec_expr(strm, state, *(v0___1->data + i___4), args___0 + i___4);
      if (n == 1) {
        free((void *)args___0);
        return (n);
      }
      i___4 ++;
    }
  }
  tmp___37 = node_to_sym(ncall->ident);
  n = exec_call(strm, state, tmp___37, i___4, args___0, val);
  if (! splat___0) {
    free((void *)args___0);
  }
  return (n);
  break;
  case 25U:
  ncall___0 = (node_fcall *)np;
  v0___2 = (node_nodes *)ncall___0->args;
  splat___1 = 0;
  tmp___38 = exec_expr(strm, state, ncall___0->func, & func);
  if (tmp___38 == 1) {
    return (1);
  }
  i___5 = 0;
  while (i___5 < v0___2->len) {
    if ((unsigned int )(*(v0___2->data + i___5))->type == 14U) {
      splat___1 = 1;
      break;
    }
    i___5 ++;
  }
  if (splat___1) {
    n = exec_expr(strm, state, ncall___0->args, & aary___0);
    tmp___39 = strm_ary_struct(aary___0);
    args___1 = tmp___39->ptr;
    tmp___40 = strm_ary_struct(aary___0);
    i___5 = tmp___40->len;
  } else {
    tmp___41 = malloc(sizeof(strm_value ) * (unsigned long )v0___2->len);
    args___1 = (strm_value *)tmp___41;
    i___5 = 0;
    while (i___5 < v0___2->len) {
      n = exec_expr(strm, state, *(v0___2->data + i___5), args___1 + i___5);
      if (n == 1) {
        free((void *)args___1);
        return (n);
      }
      i___5 ++;
    }
  }
  n = strm_funcall(strm, func, i___5, args___1, val);
  if (! splat___1) {
    free((void *)args___1);
  }
  return (n);
  break;
  case 26U:
  ngf = (node_genfunc *)np;
  tmp___42 = node_to_str(ngf->id);
  gf = genfunc_new(state, tmp___42);
  if (! gf) {
    return (1);
  }
  *val = strm_ptr_value((void *)gf);
  return (0);
  break;
  case 20U:
  nreturn = (node_return *)np;
  args___2 = (node_nodes *)nreturn->rv;
  if (! args___2) {
    arg = strm_nil_value();
  } else {
    switch (args___2->len) {
    case 0:
    arg = strm_nil_value();
    break;
    case 1:
    n = exec_expr(strm, state, *(args___2->data + 0), & arg);
    if (n) {
      return (n);
    }
    break;
    default:
    tmp___43 = strm_ary_new((strm_value const   *)((void *)0), args___2->len);
    ary = tmp___43;
    i___6 = 0;
    while (i___6 < args___2->len) {
      tmp___44 = strm_ary_struct(ary);
      n = exec_expr(strm, state, *(args___2->data + i___6), tmp___44->ptr + i___6);
      if (n) {
        return (n);
      }
      i___6 ++;
    }
    arg = ary;
    break;
    }
  }
  strm_set_exc(strm, 1, arg);
  return (1);
  break;
  case 28U:
  v___0 = (node_nodes *)np;
  i___7 = 0;
  while (i___7 < v___0->len) {
    n = exec_expr(strm, state, *(v___0->data + i___7), val);
    if (n) {
      if (strm) {
        exc = strm->exc;
        if ((unsigned long )exc != (unsigned long )((void *)0)) {
          n___1 = *(v___0->data + i___7);
          exc->fname = n___1->fname;
          exc->lineno = n___1->lineno;
        }
      }
      return (n);
    }
    i___7 ++;
  }
  return (0);
  case 0U:
  *val = strm_int_value(((node_int *)np)->value);
  return (0);
  case 1U:
  *val = strm_float_value(((node_float *)np)->value);
  return (0);
  case 2U:
  nt = (node_time *)np;
  *val = strm_time_new(nt->sec, nt->usec, nt->utc_offset);
  tmp___45 = strm_nil_p(*val);
  if (tmp___45) {
    return (1);
  }
  return (0);
  case 5U:
  *val = strm_bool_value(((node_bool *)np)->value);
  return (0);
  case 4U:
  *val = strm_nil_value();
  return (0);
  case 3U:
  tmp___46 = node_to_str(((node_str *)np)->value);
  *val = tmp___46;
  return (0);
  default:
  strm_raise(strm, "unknown node");
  break;
  }
  return (1);
}
}
static int exec_cputs(strm_stream *strm , FILE *out , int argc , strm_value *args ,
                      strm_value *ret )
{
  int i ;
  strm_string s ;
  int tmp ;
  strm_int tmp___0 ;
  char const   *tmp___1 ;

  {
  i = 0;
  while (i < argc) {
    if (i != 0) {
      tmp = strm_string_p(*(args + (i - 1)));
      if (! tmp) {
        fputs((char const   * __restrict  )" ", (FILE * __restrict  )out);
      }
    }
    s = strm_to_str(*(args + i));
    tmp___0 = strm_str_len(s);
    tmp___1 = strm_strp_ptr(& s);
    fwrite((void const   * __restrict  )tmp___1, (size_t )tmp___0, (size_t )1, (FILE * __restrict  )out);
    i ++;
  }
  fputs((char const   * __restrict  )"\n", (FILE * __restrict  )out);
  *ret = strm_nil_value();
  return (0);
}
}
static int exec_puts(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  int tmp ;

  {
  tmp = exec_cputs(strm, stdout, argc, args, ret);
  return (tmp);
}
}
void strm_eprint(strm_stream *strm )
{
  strm_value v ;
  node_error *exc ;

  {
  exc = strm->exc;
  if (! exc) {
    return;
  }
  if (exc->type == 2) {
    return;
  }
  if (exc->fname) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d:", exc->fname,
            exc->lineno);
  }
  exec_cputs(strm, stderr, 1, & exc->arg, & v);
  strm_clear_exc(strm);
  return;
}
}
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag
                                                   , ...) ;
static int exec_fread(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  int fd ;
  strm_string path ;
  char buf[7] ;
  int tmp ;
  char const   *tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "S", & path);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = strm_str_cstr(path, buf);
  fd = open(tmp___0, 0);
  if (fd < 0) {
    strm_raise(strm, "fread() failed");
    return (1);
  }
  *ret = strm_io_new(fd, 1);
  return (0);
}
}
static int exec_fwrite(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  int fd ;
  strm_string path ;
  char buf[7] ;
  int tmp ;
  char const   *tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "S", & path);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = strm_str_cstr(path, buf);
  fd = open(tmp___0, 65, 420);
  if (fd < 0) {
    return (1);
  }
  *ret = strm_io_new(fd, 2);
  return (0);
}
}
static int exec_exit(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_int estatus ;
  int tmp ;

  {
  estatus = 0;
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "|i", & estatus);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  exit(estatus);
  *ret = strm_int_value(estatus);
  return (0);
}
}
static int exec_match(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_value func ;
  struct strm_lambda *lambda ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (argc < 2) {
    strm_raise(strm, "wrong number of arguments");
    return (1);
  }
  func = *(args + (argc - 1));
  tmp___0 = strm_ptr_tag_p(func, (enum strm_ptr_type )1);
  if (tmp___0) {
    tmp = strm_value_ptr(func, (enum strm_ptr_type )1);
    lambda = (struct strm_lambda *)tmp;
    if ((unsigned int )(lambda->body)->type == 9U) {
      strm_raise(strm, "not a case function");
      return (1);
    }
  }
  tmp___1 = strm_funcall(strm, func, argc - 1, args, ret);
  return (tmp___1);
}
}
void strm_raise(strm_stream *strm , char const   *msg )
{
  size_t tmp ;
  strm_string tmp___0 ;

  {
  if (! strm) {
    return;
  }
  tmp = strlen(msg);
  tmp___0 = strm_str_new(msg, (strm_int )tmp);
  strm_set_exc(strm, 0, tmp___0);
  return;
}
}
void strm_init(strm_state *state ) ;
static void node_init(strm_state *state )
{
  strm_value tmp ;
  strm_value tmp___0 ;
  strm_value tmp___1 ;
  strm_value tmp___2 ;
  strm_value tmp___3 ;
  strm_value tmp___4 ;
  strm_value tmp___5 ;
  strm_value tmp___6 ;
  strm_value tmp___7 ;
  strm_value tmp___8 ;
  strm_value tmp___9 ;
  strm_value tmp___10 ;

  {
  strm_init(state);
  tmp = strm_io_new(0, 1);
  strm_var_def(state, "stdin", tmp);
  tmp___0 = strm_io_new(1, 2);
  strm_var_def(state, "stdout", tmp___0);
  tmp___1 = strm_io_new(2, 2);
  strm_var_def(state, "stderr", tmp___1);
  tmp___2 = strm_cfunc_value(& exec_puts);
  strm_var_def(state, "puts", tmp___2);
  tmp___3 = strm_cfunc_value(& exec_puts);
  strm_var_def(state, "print", tmp___3);
  tmp___4 = strm_cfunc_value(& exec_eq);
  strm_var_def(state, "==", tmp___4);
  tmp___5 = strm_cfunc_value(& exec_neq);
  strm_var_def(state, "!=", tmp___5);
  tmp___6 = strm_cfunc_value(& exec_bar);
  strm_var_def(state, "|", tmp___6);
  tmp___7 = strm_cfunc_value(& exec_fread);
  strm_var_def(state, "fread", tmp___7);
  tmp___8 = strm_cfunc_value(& exec_fwrite);
  strm_var_def(state, "fwrite", tmp___8);
  tmp___9 = strm_cfunc_value(& exec_exit);
  strm_var_def(state, "exit", tmp___9);
  tmp___10 = strm_cfunc_value(& exec_match);
  strm_var_def(state, "match", tmp___10);
  return;
}
}
static strm_state top_state  =    {(void *)0, (struct strm_state *)0, 0U};
static strm_stream top_strm  =
     {(enum strm_ptr_type )0, 0U, 0U, (int (*)(strm_stream * , strm_value  ))0, (int (*)(strm_stream * ,
                                                                                       strm_value  ))0,
    (void *)0, (strm_stream *)0, (strm_stream **)0, 0UL, 0UL, (struct node_error *)0,
    0, (struct strm_queue *)0, 0};
int node_run(parser_state *p )
{
  strm_value v ;
  node_error *exc ;

  {
  node_init(& top_state);
  exec_expr(& top_strm, & top_state, (node *)p->lval, & v);
  exc = top_strm.exc;
  if ((unsigned long )exc != (unsigned long )((void *)0)) {
    if (exc->type != 1) {
      strm_eprint(& top_strm);
    }
    strm_clear_exc(& top_strm);
  }
  return (0);
}
}
void node_stop(void)
{


  {
  return;
}
}
static int blk_exec(strm_stream *strm , strm_value data )
{
  struct strm_lambda *lambda ;
  strm_value ret ;
  strm_value tmp ;
  node_args *args ;
  node_error *exc ;
  int n ;
  strm_state c ;
  strm_string tmp___1 ;

  {
  lambda = (struct strm_lambda *)strm->data;
  tmp = strm_nil_value();
  ret = tmp;
  args = (node_args *)(lambda->body)->args;
  c.env = (void *)0;
  c.prev = (struct strm_state *)0;
  c.flags = 0U;
  c.prev = lambda->state;
  if (args) {
    if (! (args->len == 1)) {
      __assert_fail("args->len == 1", "exec.c", 1100U, "blk_exec");
    }
    tmp___1 = node_to_sym(*(args->data + 0));
    strm_var_set(& c, tmp___1, data);
  }
  n = exec_expr(strm, & c, (lambda->body)->body, & ret);
  exc = strm->exc;
  if (exc) {
    if (exc->type == 1) {
      ret = exc->arg;
      strm_clear_exc(strm);
    } else {
      if (strm_option_verbose) {
        strm_eprint(strm);
      }
      return (1);
    }
  }
  if (n) {
    return (1);
  }
  strm_emit(strm, ret, (int (*)(strm_stream * , strm_value  ))((void *)0));
  return (0);
}
}
static int arr_exec(strm_stream *strm , strm_value data )
{
  struct array_data *arrd ;
  struct strm_array *tmp ;
  struct strm_array *tmp___0 ;
  int tmp___1 ;

  {
  arrd = (struct array_data *)strm->data;
  tmp = strm_ary_struct(arrd->arr);
  if (arrd->n == tmp->len) {
    strm_stream_close(strm);
    return (0);
  }
  tmp___0 = strm_ary_struct(arrd->arr);
  tmp___1 = arrd->n;
  (arrd->n) ++;
  strm_emit(strm, *(tmp___0->ptr + tmp___1), & arr_exec);
  return (0);
}
}
static int cfunc_exec(strm_stream *strm , strm_value data )
{
  strm_value ret ;
  int (*func)(struct strm_stream * , int  , strm_value * , strm_value * ) ;
  int tmp ;

  {
  func = (int (*)(struct strm_stream * , int  , strm_value * , strm_value * ))strm->data;
  tmp = (*func)(strm, 1, & data, & ret);
  if (tmp == 0) {
    strm_emit(strm, ret, (int (*)(strm_stream * , strm_value  ))((void *)0));
    return (0);
  }
  return (1);
}
}
#pragma merger("0","/tmp/cil-k9MFxnqT.i","-std=gnu99,-g,-ggdb,-Wall")
extern int fclose(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
extern int close(int __fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memchr)(void const   *__s ,
                                                                                     int __c ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
strm_value strm_foreign_value(void *p ) ;
void *strm_value_foreign(strm_value v ) ;
void strm_io_emit(strm_stream *strm , strm_value data , int fd , int (*cb)(strm_stream * ,
                                                                           strm_value  ) ) ;
struct strm_task *strm_task_new(int (*func)(strm_stream * , strm_value  ) , strm_value data ) ;
void strm_task_push(strm_stream *strm , int (*func)(strm_stream * , strm_value  ) ,
                    strm_value data ) ;
void strm_task_add(strm_stream *strm , struct strm_task *task ) ;
void strm_io_start_read(strm_stream *strm , int fd , int (*cb)(strm_stream * , strm_value  ) ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern  __attribute__((__nothrow__)) int epoll_create(int __size ) ;
extern  __attribute__((__nothrow__)) int epoll_ctl(int __epfd , int __op , int __fd ,
                                                   struct epoll_event *__event ) ;
extern int epoll_wait(int __epfd , struct epoll_event *__events , int __maxevents ,
                      int __timeout ) ;
extern ssize_t writev(int __fd , struct iovec  const  *__iovec , int __count ) ;
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat)(int __fd ,
                                                                                  struct stat *__buf ) ;
static pthread_t io_worker  ;
static int io_wait_num  =    0;
static int epoll_fd  ;
extern  __attribute__((__nothrow__)) void *mmap(void *__addr , size_t __len , int __prot ,
                                                int __flags , int __fd , __off_t __offset ) ;
extern  __attribute__((__nothrow__)) int munmap(void *__addr , size_t __len ) ;
static struct strm_task *io_task(strm_stream *strm , int (*func)(strm_stream * , strm_value  ) )
{
  strm_value tmp ;
  struct strm_task *tmp___0 ;

  {
  tmp = strm_foreign_value((void *)strm);
  tmp___0 = strm_task_new(func, tmp);
  return (tmp___0);
}
}
static void io_task_add(struct strm_task *task )
{
  strm_stream *strm ;
  void *tmp ;

  {
  tmp = strm_value_foreign(task->data);
  strm = (strm_stream *)tmp;
  task->data = strm_nil_value();
  strm_task_add(strm, task);
  return;
}
}
static int io_push(int fd , strm_stream *strm , int (*cb)(strm_stream * , strm_value  ) )
{
  struct epoll_event ev ;
  struct strm_task *tmp ;
  int tmp___0 ;

  {
  ev.events = (uint32_t )0;
  ev.data.ptr = (void *)0;
  ev.events = (uint32_t )1073741825;
  tmp = io_task(strm, cb);
  ev.data.ptr = (void *)tmp;
  tmp___0 = epoll_ctl(epoll_fd, 1, fd, & ev);
  return (tmp___0);
}
}
static int io_kick(int fd , strm_stream *strm , int (*cb)(strm_stream * , strm_value  ) )
{
  struct epoll_event ev ;
  struct strm_task *tmp ;
  int tmp___0 ;

  {
  ev.events = (uint32_t )1073741825;
  tmp = io_task(strm, cb);
  ev.data.ptr = (void *)tmp;
  tmp___0 = epoll_ctl(epoll_fd, 3, fd, & ev);
  return (tmp___0);
}
}
static int io_pop(int fd )
{
  int tmp ;

  {
  tmp = epoll_ctl(epoll_fd, 2, fd, (struct epoll_event *)((void *)0));
  return (tmp);
}
}
static void *io_loop(void *d )
{
  struct epoll_event events[10] ;
  int i ;
  int n ;

  {
  while (1) {
    n = epoll_wait(epoll_fd, events, 10, -1);
    if (n < 0) {
      return ((void *)0);
    }
    i = 0;
    while (i < n) {
      io_task_add((struct strm_task *)events[i].data.ptr);
      i ++;
    }
  }
  return ((void *)0);
}
}
void strm_init_io_loop(void)
{


  {
  epoll_fd = epoll_create(10);
  if (! (epoll_fd >= 0)) {
    __assert_fail("epoll_fd >= 0", "io.c", 106U, "strm_init_io_loop");
  }
  pthread_create((pthread_t * __restrict  )(& io_worker), (pthread_attr_t const   * __restrict  )((void *)0),
                 & io_loop, (void * __restrict  )((void *)0));
  return;
}
}
void strm_io_start_read(strm_stream *strm , int fd , int (*cb)(strm_stream * , strm_value  ) )
{
  int tmp ;

  {
  tmp = io_push(fd, strm, cb);
  if (tmp == 0) {
    io_wait_num ++;
  }
  return;
}
}
static void strm_io_stop(strm_stream *strm , int fd )
{


  {
  if ((strm->flags & 1U) == 0U) {
    io_wait_num --;
    io_pop(fd);
  }
  strm_stream_close(strm);
  return;
}
}
void strm_io_emit(strm_stream *strm , strm_value data , int fd , int (*cb)(strm_stream * ,
                                                                           strm_value  ) )
{


  {
  strm_emit(strm, data, (int (*)(strm_stream * , strm_value  ))((void *)0));
  io_kick(fd, strm, cb);
  return;
}
}
static int readline_cb(strm_stream *strm , strm_value data ) ;
static strm_value read_str(char const   *beg , strm_int len )
{
  char *p ;
  void *tmp ;
  strm_string tmp___0 ;

  {
  tmp = malloc((size_t )len);
  p = (char *)tmp;
  memcpy((void * __restrict  )p, (void const   * __restrict  )beg, (size_t )len);
  tmp___0 = strm_str_new((char const   *)p, len);
  return (tmp___0);
}
}
static int read_cb(strm_stream *strm , strm_value data )
{
  struct fd_read_buffer *b ;
  strm_int count ;
  strm_int n ;
  ssize_t tmp ;
  strm_value s ;
  strm_value tmp___0 ;
  char *tmp___1 ;
  strm_value tmp___2 ;

  {
  b = (struct fd_read_buffer *)strm->data;
  count = (strm_int )(8192L - (b->end - b->buf));
  tmp = read(b->fd, (void *)b->end, (size_t )count);
  n = (strm_int )tmp;
  if (n <= 0) {
    if ((unsigned long )b->buf < (unsigned long )b->end) {
      tmp___0 = read_str((char const   *)b->beg, (strm_int )(b->end - b->beg));
      s = tmp___0;
      tmp___1 = b->buf;
      b->end = tmp___1;
      b->beg = tmp___1;
      strm_io_emit(strm, s, b->fd, & read_cb);
    } else {
      strm_io_stop(strm, b->fd);
    }
    return (0);
  }
  b->end += n;
  tmp___2 = strm_nil_value();
  readline_cb(strm, tmp___2);
  return (0);
}
}
static int readline_cb(strm_stream *strm , strm_value data )
{
  struct fd_read_buffer *b ;
  strm_value s ;
  char *p ;
  strm_int len ;
  void *tmp ;
  strm_value tmp___0 ;

  {
  b = (struct fd_read_buffer *)strm->data;
  len = (strm_int )(b->end - b->beg);
  tmp = memchr((void const   *)b->beg, '\n', (size_t )len);
  p = (char *)tmp;
  if (p) {
    len = (strm_int )(p - b->beg);
  } else
  if (strm->flags & 2U) {
    if (len <= 0) {
      if (strm->flags & 4U) {
        munmap((void *)b->buf, (size_t )(b->end - b->beg));
      }
      strm_io_stop(strm, b->fd);
      return (0);
    }
  } else {
    if ((unsigned long )len < sizeof(b->buf)) {
      memmove((void *)b->buf, (void const   *)b->beg, (size_t )len);
      b->beg = b->buf;
      b->end = b->beg + len;
    }
    if (strm->flags & 1U) {
      tmp___0 = strm_nil_value();
      strm_task_push(strm, & read_cb, tmp___0);
    } else {
      io_kick(b->fd, strm, & read_cb);
    }
    return (0);
  }
  s = read_str((char const   *)b->beg, len);
  b->beg += len + 1;
  strm_emit(strm, s, & readline_cb);
  return (0);
}
}
static int stdio_read(strm_stream *strm , strm_value data )
{
  struct fd_read_buffer *b ;

  {
  b = (struct fd_read_buffer *)strm->data;
  strm_io_start_read(strm, b->fd, & read_cb);
  return (0);
}
}
static int read_close(strm_stream *strm , strm_value d )
{
  struct fd_read_buffer *b ;

  {
  b = (struct fd_read_buffer *)strm->data;
  close(b->fd);
  free((void *)b);
  return (0);
}
}
static strm_stream *strm_readio(strm_io io )
{
  int (*cb)(strm_stream * , strm_value  ) ;
  unsigned int flags ;
  struct fd_read_buffer *buf ;
  void *tmp ;
  struct stat st ;
  void *map ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  cb = & stdio_read;
  flags = 0U;
  if ((unsigned long )io->read_stream == (unsigned long )((void *)0)) {
    tmp = malloc(sizeof(struct fd_read_buffer ));
    buf = (struct fd_read_buffer *)tmp;
    io->mode |= 8;
    buf->fd = io->fd;
    buf->io = io;
    buf->buf = buf->fixed;
    tmp___4 = fstat(io->fd, & st);
    if (tmp___4 == 0) {
      if ((st.st_mode & 61440U) == 32768U) {
        flags |= 1U;
        tmp___0 = mmap((void *)0, (size_t )st.st_size, 1, 2, buf->fd, (__off_t )0);
        map = tmp___0;
        if ((unsigned long )map == (unsigned long )((void *)-1)) {
          tmp___1 = buf->buf;
          buf->end = tmp___1;
          buf->beg = tmp___1;
        } else {
          tmp___2 = (char *)map;
          buf->beg = tmp___2;
          buf->buf = tmp___2;
          buf->end = (char *)(map + st.st_size);
          flags |= 2U;
          cb = & readline_cb;
        }
      } else {
        tmp___3 = buf->buf;
        buf->end = tmp___3;
        buf->beg = tmp___3;
      }
    } else {
      tmp___3 = buf->buf;
      buf->end = tmp___3;
      buf->beg = tmp___3;
    }
    io->read_stream = strm_stream_new((strm_stream_mode )0, cb, & read_close, (void *)buf);
    (io->read_stream)->flags |= flags;
  }
  return (io->read_stream);
}
}
static int write_cb(strm_stream *strm , strm_value data )
{
  struct write_data *d ;
  strm_string p ;
  strm_string tmp ;
  struct iovec buf[2] ;
  char const   *tmp___0 ;
  strm_int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;

  {
  d = (struct write_data *)strm->data;
  tmp = strm_to_str(data);
  p = tmp;
  tmp___0 = strm_strp_ptr(& p);
  buf[0].iov_base = (void *)tmp___0;
  tmp___1 = strm_str_len(p);
  buf[0].iov_len = (size_t )tmp___1;
  buf[1].iov_base = (void *)"\n";
  buf[1].iov_len = (size_t )1;
  tmp___2 = fileno(d->f);
  tmp___3 = writev(tmp___2, (struct iovec  const  *)(buf), 2);
  if (tmp___3 < 0L) {
    return (1);
  }
  return (0);
}
}
static int write_close(strm_stream *strm , strm_value data )
{
  struct write_data *d ;
  int tmp ;

  {
  d = (struct write_data *)strm->data;
  tmp = fileno(d->f);
  shutdown(tmp, 1);
  if (((d->io)->mode & 8) == 0) {
    fclose(d->f);
  }
  free((void *)d);
  return (0);
}
}
static strm_stream *strm_writeio(strm_io io )
{
  struct write_data *d ;
  void *tmp ;

  {
  if (! io->write_stream) {
    tmp = malloc(sizeof(struct write_data ));
    d = (struct write_data *)tmp;
    d->f = fdopen(io->fd, "w");
    d->io = io;
    io->write_stream = strm_stream_new((strm_stream_mode )2, & write_cb, & write_close,
                                       (void *)d);
  }
  return (io->write_stream);
}
}
strm_value strm_io_new(int fd , int mode )
{
  strm_io io ;
  void *tmp ;
  strm_stream *tmp___0 ;
  strm_value tmp___1 ;

  {
  tmp = malloc(sizeof(struct strm_io ));
  io = (strm_io )tmp;
  io->fd = fd;
  io->mode = mode;
  io->type = (enum strm_ptr_type )3;
  tmp___0 = (strm_stream *)((void *)0);
  io->write_stream = tmp___0;
  io->read_stream = tmp___0;
  tmp___1 = strm_ptr_value((void *)io);
  return (tmp___1);
}
}
strm_stream *strm_io_stream(strm_value iov , int mode )
{
  strm_io io ;
  int tmp___2 ;
  void *tmp___3 ;
  strm_stream *tmp___4 ;
  strm_stream *tmp___5 ;

  {
  tmp___2 = strm_ptr_tag_p(iov, (enum strm_ptr_type )3);
  if (! tmp___2) {
    __assert_fail("strm_io_p(iov)", "io.c", 380U, "strm_io_stream");
  }
  tmp___3 = strm_value_ptr(iov, (enum strm_ptr_type )3);
  io = (strm_io )tmp___3;
  switch (mode) {
  case 1:
  tmp___4 = strm_readio(io);
  return (tmp___4);
  case 2:
  tmp___5 = strm_writeio(io);
  return (tmp___5);
  default:
  return ((strm_stream *)((void *)0));
  }
}
}
#pragma merger("0","/tmp/cil-PlYxfx8Z.i","-std=gnu99,-g,-ggdb,-Wall")
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
strm_state *strm_ns_array ;
static double const   khash_ac_HASH_UPPER  =    (double const   )0.77;
static int gen_seq(strm_stream *strm , strm_value data )
{
  struct seq_data *d ;
  strm_value tmp ;

  {
  d = (struct seq_data *)strm->data;
  if (d->end > (double )0) {
    if (d->n > d->end) {
      strm_stream_close(strm);
      return (0);
    }
  }
  tmp = strm_float_value(d->n);
  strm_emit(strm, tmp, & gen_seq);
  d->n += d->inc;
  return (0);
}
}
static int exec_seq(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double start ;
  double end ;
  double inc ;
  double tmp ;
  struct seq_data *d ;
  int tmp___0 ;
  void *tmp___1 ;
  strm_stream *tmp___2 ;

  {
  start = (double )1;
  end = (double )-1;
  inc = (double )1;
  while (1) {
    tmp___0 = strm_parse_args(strm, argc, args, "|fff", & start, & end, & tmp);
    if (tmp___0 == 1) {
      return (1);
    }
    break;
  }
  switch (argc) {
  case 1:
  end = start;
  start = (double )1;
  break;
  case 3:
  inc = end;
  end = tmp;
  break;
  default:
  break;
  }
  tmp___1 = malloc(sizeof(*d));
  d = (struct seq_data *)tmp___1;
  d->n = start;
  d->inc = inc;
  d->end = end;
  tmp___2 = strm_stream_new((strm_stream_mode )0, & gen_seq, (int (*)(strm_stream * ,
                                                                      strm_value  ))((void *)0),
                            (void *)d);
  *ret = strm_ptr_value((void *)tmp___2);
  return (0);
}
}
static int gen_repeat(strm_stream *strm , strm_value data )
{
  struct repeat_data *d ;

  {
  d = (struct repeat_data *)strm->data;
  (d->count) --;
  if (d->count == 0) {
    strm_emit(strm, d->v, (int (*)(strm_stream * , strm_value  ))((void *)0));
    strm_stream_close(strm);
  } else {
    strm_emit(strm, d->v, & gen_repeat);
  }
  return (0);
}
}
static int fin_repeat(strm_stream *strm , strm_value data )
{


  {
  free(strm->data);
  return (0);
}
}
static int exec_repeat(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_value v ;
  strm_int n ;
  struct repeat_data *d ;
  int tmp ;
  void *tmp___0 ;
  strm_stream *tmp___1 ;

  {
  n = -1;
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "v|i", & v, & n);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  if (argc == 2) {
    if (n <= 0) {
      strm_raise(strm, "invalid count number");
      return (1);
    }
  }
  tmp___0 = malloc(sizeof(*d));
  d = (struct repeat_data *)tmp___0;
  d->v = v;
  d->count = n;
  tmp___1 = strm_stream_new((strm_stream_mode )0, & gen_repeat, & fin_repeat, (void *)d);
  *ret = strm_ptr_value((void *)tmp___1);
  return (0);
}
}
static int gen_cycle(strm_stream *strm , strm_value data )
{
  struct cycle_data *d ;
  strm_value *p ;
  strm_int i ;
  strm_int len ;
  struct strm_array *tmp ;
  struct strm_array *tmp___0 ;

  {
  d = (struct cycle_data *)strm->data;
  (d->count) --;
  tmp = strm_ary_struct(d->ary);
  p = tmp->ptr;
  tmp___0 = strm_ary_struct(d->ary);
  len = tmp___0->len;
  if (d->count != 0) {
    len --;
  }
  i = 0;
  while (i < len) {
    strm_emit(strm, *(p + i), (int (*)(strm_stream * , strm_value  ))((void *)0));
    i ++;
  }
  if (d->count == 0) {
    strm_stream_close(strm);
  } else {
    strm_emit(strm, *(p + i), & gen_cycle);
  }
  return (0);
}
}
static int fin_cycle(strm_stream *strm , strm_value data )
{


  {
  free(strm->data);
  return (0);
}
}
static int exec_cycle(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_array a ;
  strm_int n ;
  struct cycle_data *d ;
  int tmp ;
  void *tmp___0 ;
  strm_stream *tmp___1 ;

  {
  n = -1;
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "A|i", & a, & n);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  if (argc == 2) {
    if (n <= 0) {
      strm_raise(strm, "invalid count number");
      return (1);
    }
  }
  tmp___0 = malloc(sizeof(*d));
  d = (struct cycle_data *)tmp___0;
  d->ary = a;
  d->count = n;
  tmp___1 = strm_stream_new((strm_stream_mode )0, & gen_cycle, & fin_cycle, (void *)d);
  *ret = strm_ptr_value((void *)tmp___1);
  return (0);
}
}
static int iter_each(strm_stream *strm , strm_value data )
{
  struct map_data *d ;
  strm_value val ;
  int tmp ;

  {
  d = (struct map_data *)strm->data;
  tmp = strm_funcall(strm, d->func, 1, & data, & val);
  if (tmp == 1) {
    return (1);
  }
  return (0);
}
}
static int exec_each(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  struct map_data *d ;
  strm_value func ;
  int tmp ;
  void *tmp___0 ;
  strm_stream *tmp___1 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "v", & func);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = malloc(sizeof(*d));
  d = (struct map_data *)tmp___0;
  if (! d) {
    return (1);
  }
  d->func = func;
  tmp___1 = strm_stream_new((strm_stream_mode )1, & iter_each, (int (*)(strm_stream * ,
                                                                        strm_value  ))((void *)0),
                            (void *)d);
  *ret = strm_ptr_value((void *)tmp___1);
  return (0);
}
}
static int ary_each(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_value *v ;
  strm_int len ;
  strm_value func ;
  strm_int i ;
  strm_value r ;
  int tmp ;
  int tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "av", & v, & len, & func);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  i = 0;
  while (i < len) {
    tmp___0 = strm_funcall(strm, func, 1, v + i, & r);
    if (tmp___0 == 1) {
      return (1);
    }
    i ++;
  }
  *ret = *(args + 0);
  return (0);
}
}
static int iter_map(strm_stream *strm , strm_value data )
{
  struct map_data *d ;
  strm_value val ;
  int tmp ;

  {
  d = (struct map_data *)strm->data;
  tmp = strm_funcall(strm, d->func, 1, & data, & val);
  if (tmp == 1) {
    return (1);
  }
  strm_emit(strm, val, (int (*)(strm_stream * , strm_value  ))((void *)0));
  return (0);
}
}
static int exec_map(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  struct map_data *d ;
  strm_value func ;
  int tmp ;
  void *tmp___0 ;
  strm_stream *tmp___1 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "v", & func);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = malloc(sizeof(*d));
  d = (struct map_data *)tmp___0;
  if (! d) {
    return (1);
  }
  d->func = func;
  tmp___1 = strm_stream_new((strm_stream_mode )1, & iter_map, (int (*)(strm_stream * ,
                                                                       strm_value  ))((void *)0),
                            (void *)d);
  *ret = strm_ptr_value((void *)tmp___1);
  return (0);
}
}
static int ary_map(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_value *v ;
  strm_int len ;
  strm_value func ;
  strm_int i ;
  strm_array a2 ;
  strm_value *v2 ;
  int tmp ;
  struct strm_array *tmp___0 ;
  int tmp___1 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "av", & v, & len, & func);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  a2 = strm_ary_new((strm_value const   *)((void *)0), len);
  tmp___0 = strm_ary_struct(a2);
  v2 = tmp___0->ptr;
  i = 0;
  while (i < len) {
    tmp___1 = strm_funcall(strm, func, 1, v + i, v2 + i);
    if (tmp___1 == 1) {
      return (1);
    }
    i ++;
  }
  *ret = a2;
  return (0);
}
}
static int iter_flatmap(strm_stream *strm , strm_value data )
{
  struct map_data *d ;
  strm_value val ;
  strm_int i ;
  strm_int len ;
  strm_value *e ;
  int tmp ;
  int tmp___0 ;
  struct strm_array *tmp___1 ;
  struct strm_array *tmp___2 ;

  {
  d = (struct map_data *)strm->data;
  tmp = strm_funcall(strm, d->func, 1, & data, & val);
  if (tmp == 1) {
    return (1);
  }
  tmp___0 = strm_array_p(val);
  if (! tmp___0) {
    strm_raise(strm, "no array given for flatmap");
    return (1);
  }
  tmp___1 = strm_ary_struct(val);
  len = tmp___1->len;
  tmp___2 = strm_ary_struct(val);
  e = tmp___2->ptr;
  i = 0;
  while (i < len) {
    strm_emit(strm, *(e + i), (int (*)(strm_stream * , strm_value  ))((void *)0));
    i ++;
  }
  return (0);
}
}
static int flatmap_len(strm_array ary )
{
  strm_value *v ;
  struct strm_array *tmp ;
  strm_int i ;
  strm_int len ;
  strm_int n ;
  struct strm_array *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = strm_ary_struct(ary);
  v = tmp->ptr;
  n = 0;
  tmp___0 = strm_ary_struct(ary);
  len = tmp___0->len;
  i = 0;
  while (i < len) {
    tmp___2 = strm_array_p(*(v + i));
    if (tmp___2) {
      tmp___1 = flatmap_len(*(v + i));
      n += tmp___1;
    } else {
      n ++;
    }
    i ++;
  }
  return (n);
}
}
static int flatmap_push(strm_stream *strm , strm_array ary , strm_value func , strm_value **p )
{
  strm_value *v ;
  struct strm_array *tmp ;
  strm_int i ;
  strm_int len ;
  struct strm_array *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp = strm_ary_struct(ary);
  v = tmp->ptr;
  tmp___0 = strm_ary_struct(ary);
  len = tmp___0->len;
  i = 0;
  while (i < len) {
    tmp___3 = strm_array_p(*(v + i));
    if (tmp___3) {
      tmp___1 = flatmap_push(strm, *(v + i), func, p);
      if (tmp___1 == 1) {
        return (1);
      }
    } else {
      tmp___2 = strm_funcall(strm, func, 1, v + i, *p);
      if (tmp___2 == 1) {
        return (1);
      }
      (*p) ++;
    }
    i ++;
  }
  return (0);
}
}
static int exec_flatmap(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  struct map_data *d ;
  strm_value func ;
  int tmp ;
  void *tmp___0 ;
  strm_stream *tmp___1 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "v", & func);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = malloc(sizeof(*d));
  d = (struct map_data *)tmp___0;
  if (! d) {
    return (1);
  }
  d->func = func;
  tmp___1 = strm_stream_new((strm_stream_mode )1, & iter_flatmap, (int (*)(strm_stream * ,
                                                                           strm_value  ))((void *)0),
                            (void *)d);
  *ret = strm_ptr_value((void *)tmp___1);
  return (0);
}
}
static int ary_flatmap(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_array ary ;
  strm_value func ;
  strm_array a2 ;
  strm_value *v2 ;
  int tmp ;
  int tmp___0 ;
  struct strm_array *tmp___1 ;
  int tmp___2 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "Av", & ary, & func);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = flatmap_len(ary);
  a2 = strm_ary_new((strm_value const   *)((void *)0), tmp___0);
  tmp___1 = strm_ary_struct(a2);
  v2 = tmp___1->ptr;
  tmp___2 = flatmap_push(strm, ary, func, & v2);
  if (tmp___2 == 1) {
    return (1);
  }
  *ret = a2;
  return (0);
}
}
static int iter_filter(strm_stream *strm , strm_value data )
{
  struct map_data *d ;
  strm_value val ;
  int tmp ;
  int tmp___0 ;

  {
  d = (struct map_data *)strm->data;
  tmp = strm_funcall(strm, d->func, 1, & data, & val);
  if (tmp == 1) {
    return (1);
  }
  tmp___0 = strm_value_bool(val);
  if (tmp___0) {
    strm_emit(strm, data, (int (*)(strm_stream * , strm_value  ))((void *)0));
  }
  return (0);
}
}
static int exec_filter(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  struct map_data *d ;
  void *tmp ;
  int tmp___0 ;
  strm_stream *tmp___1 ;

  {
  tmp = malloc(sizeof(*d));
  d = (struct map_data *)tmp;
  while (1) {
    tmp___0 = strm_parse_args(strm, argc, args, "v", & d->func);
    if (tmp___0 == 1) {
      return (1);
    }
    break;
  }
  tmp___1 = strm_stream_new((strm_stream_mode )1, & iter_filter, (int (*)(strm_stream * ,
                                                                          strm_value  ))((void *)0),
                            (void *)d);
  *ret = strm_ptr_value((void *)tmp___1);
  return (0);
}
}
static int iter_count(strm_stream *strm , strm_value data )
{
  struct count_data *d ;

  {
  d = (struct count_data *)strm->data;
  (d->count) ++;
  return (0);
}
}
static int count_finish(strm_stream *strm , strm_value data )
{
  struct count_data *d ;
  strm_value tmp ;

  {
  d = (struct count_data *)strm->data;
  tmp = strm_int_value(d->count);
  strm_emit(strm, tmp, (int (*)(strm_stream * , strm_value  ))((void *)0));
  free((void *)d);
  return (0);
}
}
static int exec_count(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  struct count_data *d ;
  int tmp ;
  void *tmp___0 ;
  strm_stream *tmp___1 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "");
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = malloc(sizeof(*d));
  d = (struct count_data *)tmp___0;
  d->count = 0;
  tmp___1 = strm_stream_new((strm_stream_mode )1, & iter_count, & count_finish, (void *)d);
  *ret = strm_ptr_value((void *)tmp___1);
  return (0);
}
}
static int iter_minmax(strm_stream *strm , strm_value data )
{
  struct minmax_data *d ;
  strm_value e ;
  double num ;
  int tmp ;
  int tmp___0 ;

  {
  d = (struct minmax_data *)strm->data;
  tmp___0 = strm_nil_p(d->func);
  if (tmp___0) {
    e = data;
  } else {
    tmp = strm_funcall(strm, d->func, 1, & data, & e);
    if (tmp == 1) {
      return (1);
    }
  }
  num = strm_value_float(e);
  if (d->start) {
    d->start = 0;
    d->num = num;
    d->data = data;
  } else
  if (d->min) {
    if (d->num > num) {
      d->num = num;
      d->data = data;
    }
  } else
  if (d->num < num) {
    d->num = num;
    d->data = data;
  }
  return (0);
}
}
static int minmax_finish(strm_stream *strm , strm_value data )
{
  struct minmax_data *d ;

  {
  d = (struct minmax_data *)strm->data;
  strm_emit(strm, d->data, (int (*)(strm_stream * , strm_value  ))((void *)0));
  return (0);
}
}
static int exec_minmax(strm_stream *strm , int argc , strm_value *args , strm_value *ret ,
                       int min )
{
  struct minmax_data *d ;
  strm_value func ;
  strm_value tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  strm_stream *tmp___2 ;

  {
  tmp = strm_nil_value();
  func = tmp;
  while (1) {
    tmp___0 = strm_parse_args(strm, argc, args, "|v", & func);
    if (tmp___0 == 1) {
      return (1);
    }
    break;
  }
  tmp___1 = malloc(sizeof(*d));
  d = (struct minmax_data *)tmp___1;
  if (! d) {
    return (1);
  }
  d->start = 1;
  d->min = min;
  d->num = (double )0;
  d->data = strm_nil_value();
  d->func = func;
  tmp___2 = strm_stream_new((strm_stream_mode )1, & iter_minmax, & minmax_finish,
                            (void *)d);
  *ret = strm_ptr_value((void *)tmp___2);
  return (0);
}
}
static int exec_min(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  int tmp ;

  {
  tmp = exec_minmax(strm, argc, args, ret, 1);
  return (tmp);
}
}
static int exec_max(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  int tmp ;

  {
  tmp = exec_minmax(strm, argc, args, ret, 0);
  return (tmp);
}
}
static int iter_reduce(strm_stream *strm , strm_value data )
{
  struct reduce_data *d ;
  strm_value args[2] ;
  int tmp ;

  {
  d = (struct reduce_data *)strm->data;
  if (! d->init) {
    d->init = 1;
    d->acc = data;
    return (0);
  }
  args[0] = d->acc;
  args[1] = data;
  tmp = strm_funcall(strm, d->func, 2, args, & data);
  if (tmp == 1) {
    return (1);
  }
  d->acc = data;
  return (0);
}
}
static int reduce_finish(strm_stream *strm , strm_value data )
{
  struct reduce_data *d ;

  {
  d = (struct reduce_data *)strm->data;
  if (! d->init) {
    return (1);
  }
  strm_emit(strm, d->acc, (int (*)(strm_stream * , strm_value  ))((void *)0));
  return (0);
}
}
static int exec_reduce(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  struct reduce_data *d ;
  strm_value v1 ;
  strm_value v2 ;
  int tmp ;
  void *tmp___0 ;
  strm_stream *tmp___1 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "v|v", & v1, & v2);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = malloc(sizeof(*d));
  d = (struct reduce_data *)tmp___0;
  if (! d) {
    return (1);
  }
  if (argc == 2) {
    d->init = 1;
    d->acc = v1;
    d->func = v2;
  } else {
    d->init = 0;
    d->acc = strm_nil_value();
    d->func = v1;
  }
  tmp___1 = strm_stream_new((strm_stream_mode )1, & iter_reduce, & reduce_finish,
                            (void *)d);
  *ret = strm_ptr_value((void *)tmp___1);
  return (0);
}
}
__inline static kh_rbk_t *kh_init_rbk(void)
{
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(kh_rbk_t ));
  return ((kh_rbk_t *)tmp);
}
}
__inline static int kh_resize_rbk(kh_rbk_t *h , khint_t new_n_buckets )
{
  khint32_t *new_flags ;
  khint_t j ;
  khint_t tmp ;
  void *tmp___0 ;
  khint_t tmp___1 ;
  khint64_t *new_keys ;
  void *tmp___2 ;
  strm_value *new_vals ;
  void *tmp___3 ;
  khint64_t key ;
  strm_value val ;
  khint_t new_mask ;
  khint_t k ;
  khint_t i ;
  khint_t step ;
  khint64_t tmp___4 ;
  strm_value tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
  new_flags = (khint32_t *)0;
  j = (khint_t )1;
  new_n_buckets --;
  new_n_buckets |= new_n_buckets >> 1;
  new_n_buckets |= new_n_buckets >> 2;
  new_n_buckets |= new_n_buckets >> 4;
  new_n_buckets |= new_n_buckets >> 8;
  new_n_buckets |= new_n_buckets >> 16;
  new_n_buckets ++;
  if (new_n_buckets < 4U) {
    new_n_buckets = (khint_t )4;
  }
  if (h->size >= (khint_t )((double const   )new_n_buckets * khash_ac_HASH_UPPER + (double const   )0.5)) {
    j = (khint_t )0;
  } else {
    if (new_n_buckets < 16U) {
      tmp = (khint_t )1;
    } else {
      tmp = new_n_buckets >> 4;
    }
    tmp___0 = malloc((unsigned long )tmp * sizeof(khint32_t ));
    new_flags = (khint32_t *)tmp___0;
    if (! new_flags) {
      return (-1);
    }
    if (new_n_buckets < 16U) {
      tmp___1 = (khint_t )1;
    } else {
      tmp___1 = new_n_buckets >> 4;
    }
    memset((void *)new_flags, 170, (unsigned long )tmp___1 * sizeof(khint32_t ));
    if (h->n_buckets < new_n_buckets) {
      tmp___2 = realloc((void *)h->keys, (unsigned long )new_n_buckets * sizeof(khint64_t ));
      new_keys = (khint64_t *)tmp___2;
      if (! new_keys) {
        free((void *)new_flags);
        return (-1);
      }
      h->keys = new_keys;
      tmp___3 = realloc((void *)h->vals, (unsigned long )new_n_buckets * sizeof(strm_value ));
      new_vals = (strm_value *)tmp___3;
      if (! new_vals) {
        free((void *)new_flags);
        return (-1);
      }
      h->vals = new_vals;
    }
  }
  if (j) {
    j = (khint_t )0;
    while (j != h->n_buckets) {
      if (((*(h->flags + (j >> 4)) >> ((j & 15U) << 1)) & 3U) == 0U) {
        key = *(h->keys + j);
        new_mask = new_n_buckets - 1U;
        val = *(h->vals + j);
        *(h->flags + (j >> 4)) = (khint32_t )((unsigned long )*(h->flags + (j >> 4)) | (1UL << ((j & 15U) << 1)));
        while (1) {
          step = (khint_t )0;
          k = (khint32_t )(((key >> 33) ^ key) ^ (key << 11));
          i = k & new_mask;
          while (! ((*(new_flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
            step ++;
            i = (i + step) & new_mask;
          }
          *(new_flags + (i >> 4)) = (khint32_t )((unsigned long )*(new_flags + (i >> 4)) & ~ (2UL << ((i & 15U) << 1)));
          if (i < h->n_buckets) {
            if (((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 3U) == 0U) {
              tmp___4 = *(h->keys + i);
              *(h->keys + i) = key;
              key = tmp___4;
              tmp___5 = *(h->vals + i);
              *(h->vals + i) = val;
              val = tmp___5;
              *(h->flags + (i >> 4)) = (khint32_t )((unsigned long )*(h->flags + (i >> 4)) | (1UL << ((i & 15U) << 1)));
            } else {
              *(h->keys + i) = key;
              *(h->vals + i) = val;
              break;
            }
          } else {
            *(h->keys + i) = key;
            *(h->vals + i) = val;
            break;
          }
        }
      }
      j ++;
    }
    if (h->n_buckets > new_n_buckets) {
      tmp___6 = realloc((void *)h->keys, (unsigned long )new_n_buckets * sizeof(khint64_t ));
      h->keys = (khint64_t *)tmp___6;
      tmp___7 = realloc((void *)h->vals, (unsigned long )new_n_buckets * sizeof(strm_value ));
      h->vals = (strm_value *)tmp___7;
    }
    free((void *)h->flags);
    h->flags = new_flags;
    h->n_buckets = new_n_buckets;
    h->n_occupied = h->size;
    h->upper_bound = (khint_t )((double const   )h->n_buckets * khash_ac_HASH_UPPER + (double const   )0.5);
  }
  return (0);
}
}
__inline static khint_t kh_put_rbk(kh_rbk_t *h , khint64_t key , int *ret )
{
  khint_t x ;
  int tmp ;
  int tmp___0 ;
  khint_t k ;
  khint_t i ;
  khint_t site ;
  khint_t last ;
  khint_t mask ;
  khint_t step ;

  {
  if (h->n_occupied >= h->upper_bound) {
    if (h->n_buckets > h->size << 1) {
      tmp = kh_resize_rbk(h, h->n_buckets - 1U);
      if (tmp < 0) {
        *ret = -1;
        return (h->n_buckets);
      }
    } else {
      tmp___0 = kh_resize_rbk(h, h->n_buckets + 1U);
      if (tmp___0 < 0) {
        *ret = -1;
        return (h->n_buckets);
      }
    }
  }
  mask = h->n_buckets - 1U;
  step = (khint_t )0;
  site = h->n_buckets;
  x = site;
  k = (khint32_t )(((key >> 33) ^ key) ^ (key << 11));
  i = k & mask;
  if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U) {
    x = i;
  } else {
    last = i;
    while (1) {
      if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
        if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U)) {
          if (! (! (*(h->keys + i) == key))) {
            break;
          }
        }
      } else {
        break;
      }
      if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U) {
        site = i;
      }
      step ++;
      i = (i + step) & mask;
      if (i == last) {
        x = site;
        break;
      }
    }
    if (x == h->n_buckets) {
      if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U) {
        if (site != h->n_buckets) {
          x = site;
        } else {
          x = i;
        }
      } else {
        x = i;
      }
    }
  }
  if ((*(h->flags + (x >> 4)) >> ((x & 15U) << 1)) & 2U) {
    *(h->keys + x) = key;
    *(h->flags + (x >> 4)) = (khint32_t )((unsigned long )*(h->flags + (x >> 4)) & ~ (3UL << ((x & 15U) << 1)));
    (h->size) ++;
    (h->n_occupied) ++;
    *ret = 1;
  } else
  if ((*(h->flags + (x >> 4)) >> ((x & 15U) << 1)) & 1U) {
    *(h->keys + x) = key;
    *(h->flags + (x >> 4)) = (khint32_t )((unsigned long )*(h->flags + (x >> 4)) & ~ (3UL << ((x & 15U) << 1)));
    (h->size) ++;
    *ret = 2;
  } else {
    *ret = 0;
  }
  return (x);
}
}
static int iter_rbk(strm_stream *strm , strm_value data )
{
  struct rbk_data *d ;
  strm_value k ;
  strm_value v ;
  khiter_t i ;
  int r ;
  int tmp ;
  struct strm_array *tmp___0 ;
  struct strm_array *tmp___1 ;
  struct strm_array *tmp___2 ;
  strm_value args[3] ;
  int tmp___3 ;

  {
  d = (struct rbk_data *)strm->data;
  tmp = strm_array_p(data);
  if (tmp) {
    tmp___0 = strm_ary_struct(data);
    if (tmp___0->len != 2) {
      strm_raise(strm, "reduce_by_key element must be a key-value pair");
      return (1);
    }
  } else {
    strm_raise(strm, "reduce_by_key element must be a key-value pair");
    return (1);
  }
  tmp___1 = strm_ary_struct(data);
  k = *(tmp___1->ptr + 0);
  tmp___2 = strm_ary_struct(data);
  v = *(tmp___2->ptr + 1);
  i = kh_put_rbk(d->tbl, k, & r);
  if (r < 0) {
    return (1);
  }
  if (r != 0) {
    *((d->tbl)->vals + i) = v;
  } else {
    args[0] = k;
    args[1] = *((d->tbl)->vals + i);
    args[2] = v;
    tmp___3 = strm_funcall(strm, d->func, 3, args, & v);
    if (tmp___3 == 1) {
      return (1);
    }
    *((d->tbl)->vals + i) = v;
  }
  return (0);
}
}
static int rbk_finish(strm_stream *strm , strm_value data )
{
  struct rbk_data *d ;
  khiter_t i ;
  strm_value values[2] ;
  strm_array tmp ;

  {
  d = (struct rbk_data *)strm->data;
  i = (khint_t )0;
  while (i != (d->tbl)->n_buckets) {
    if (! ((*((d->tbl)->flags + (i >> 4)) >> ((i & 15U) << 1)) & 3U)) {
      values[0] = *((d->tbl)->keys + i);
      values[1] = *((d->tbl)->vals + i);
      tmp = strm_ary_new((strm_value const   *)(values), 2);
      strm_emit(strm, tmp, (int (*)(strm_stream * , strm_value  ))((void *)0));
    }
    i ++;
  }
  return (0);
}
}
static int exec_rbk(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  struct rbk_data *d ;
  kh_rbk_t *t ;
  strm_value func ;
  int tmp ;
  void *tmp___0 ;
  strm_stream *tmp___1 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "v", & func);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  t = kh_init_rbk();
  if (! t) {
    return (1);
  }
  tmp___0 = malloc(sizeof(*d));
  d = (struct rbk_data *)tmp___0;
  d->tbl = t;
  d->func = func;
  tmp___1 = strm_stream_new((strm_stream_mode )1, & iter_rbk, & rbk_finish, (void *)d);
  *ret = strm_ptr_value((void *)tmp___1);
  return (0);
}
}
static int iter_slice(strm_stream *strm , strm_value data )
{
  struct slice_data *d ;
  strm_int n ;
  strm_int tmp ;
  strm_array ary ;
  strm_array tmp___0 ;

  {
  d = (struct slice_data *)strm->data;
  n = d->n;
  tmp = d->i;
  (d->i) ++;
  *(d->buf + tmp) = data;
  if (d->i == n) {
    tmp___0 = strm_ary_new((strm_value const   *)d->buf, n);
    ary = tmp___0;
    d->i = 0;
    strm_emit(strm, ary, (int (*)(strm_stream * , strm_value  ))((void *)0));
  }
  return (0);
}
}
static int finish_slice(strm_stream *strm , strm_value data )
{
  struct slice_data *d ;
  strm_array ary ;
  strm_array tmp ;

  {
  d = (struct slice_data *)strm->data;
  if (d->i > 0) {
    tmp = strm_ary_new((strm_value const   *)d->buf, d->i);
    ary = tmp;
    strm_emit(strm, ary, (int (*)(strm_stream * , strm_value  ))((void *)0));
  }
  free((void *)d->buf);
  free((void *)d);
  return (0);
}
}
static int exec_slice(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  struct slice_data *d ;
  strm_int n ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  strm_stream *tmp___2 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "i", & n);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = malloc(sizeof(*d));
  d = (struct slice_data *)tmp___0;
  if (! d) {
    return (1);
  }
  d->n = n;
  d->i = 0;
  tmp___1 = malloc((unsigned long )n * sizeof(strm_value ));
  d->buf = (strm_value *)tmp___1;
  if (! d->buf) {
    free((void *)d);
    return (1);
  }
  tmp___2 = strm_stream_new((strm_stream_mode )1, & iter_slice, & finish_slice, (void *)d);
  *ret = strm_ptr_value((void *)tmp___2);
  return (0);
}
}
static int iter_consec(strm_stream *strm , strm_value data )
{
  struct slice_data *d ;
  strm_int n ;
  strm_int tmp ;
  strm_array ary ;
  strm_array tmp___0 ;
  strm_array ary___0 ;
  strm_int i ;
  strm_int len ;

  {
  d = (struct slice_data *)strm->data;
  n = d->n;
  if (d->i < n) {
    tmp = d->i;
    (d->i) ++;
    *(d->buf + tmp) = data;
    if (d->i == n) {
      tmp___0 = strm_ary_new((strm_value const   *)d->buf, n);
      ary = tmp___0;
      strm_emit(strm, ary, (int (*)(strm_stream * , strm_value  ))((void *)0));
    }
    return (0);
  } else {
    len = n - 1;
    i = 0;
    while (i < len) {
      *(d->buf + i) = *(d->buf + (i + 1));
      i ++;
    }
    *(d->buf + len) = data;
    ary___0 = strm_ary_new((strm_value const   *)d->buf, n);
    strm_emit(strm, ary___0, (int (*)(strm_stream * , strm_value  ))((void *)0));
  }
  return (0);
}
}
static int finish_consec(strm_stream *strm , strm_value data )
{
  struct slice_data *d ;

  {
  d = (struct slice_data *)strm->data;
  free((void *)d->buf);
  free((void *)d);
  return (0);
}
}
static int exec_consec(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  struct slice_data *d ;
  strm_int n ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  strm_stream *tmp___2 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "i", & n);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = malloc(sizeof(*d));
  d = (struct slice_data *)tmp___0;
  if (! d) {
    return (1);
  }
  d->n = n;
  d->i = 0;
  tmp___1 = malloc((unsigned long )n * sizeof(strm_value ));
  d->buf = (strm_value *)tmp___1;
  if (! d->buf) {
    free((void *)d);
    return (1);
  }
  tmp___2 = strm_stream_new((strm_stream_mode )1, & iter_consec, & finish_consec,
                            (void *)d);
  *ret = strm_ptr_value((void *)tmp___2);
  return (0);
}
}
static int iter_take(strm_stream *strm , strm_value data )
{
  struct take_data *d ;

  {
  d = (struct take_data *)strm->data;
  strm_emit(strm, data, (int (*)(strm_stream * , strm_value  ))((void *)0));
  (d->n) --;
  if (d->n == 0) {
    strm_stream_close(strm);
  }
  return (0);
}
}
static int exec_take(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  struct take_data *d ;
  strm_int n ;
  int tmp ;
  void *tmp___0 ;
  strm_stream *tmp___1 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "i", & n);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  if (n < 0) {
    strm_raise(strm, "negative iteration");
    return (1);
  }
  tmp___0 = malloc(sizeof(*d));
  d = (struct take_data *)tmp___0;
  if (! d) {
    return (1);
  }
  d->n = n;
  tmp___1 = strm_stream_new((strm_stream_mode )1, & iter_take, (int (*)(strm_stream * ,
                                                                        strm_value  ))((void *)0),
                            (void *)d);
  *ret = strm_ptr_value((void *)tmp___1);
  return (0);
}
}
static int iter_drop(strm_stream *strm , strm_value data )
{
  struct take_data *d ;

  {
  d = (struct take_data *)strm->data;
  if (d->n > 0) {
    (d->n) --;
    return (0);
  }
  strm_emit(strm, data, (int (*)(strm_stream * , strm_value  ))((void *)0));
  return (0);
}
}
static int exec_drop(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  struct take_data *d ;
  strm_int n ;
  int tmp ;
  void *tmp___0 ;
  strm_stream *tmp___1 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "i", & n);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  if (n < 0) {
    strm_raise(strm, "negative iteration");
    return (1);
  }
  tmp___0 = malloc(sizeof(*d));
  d = (struct take_data *)tmp___0;
  if (! d) {
    return (1);
  }
  d->n = n;
  tmp___1 = strm_stream_new((strm_stream_mode )1, & iter_drop, (int (*)(strm_stream * ,
                                                                        strm_value  ))((void *)0),
                            (void *)d);
  *ret = strm_ptr_value((void *)tmp___1);
  return (0);
}
}
static int iter_uniq(strm_stream *strm , strm_value data )
{
  struct uniq_data *d ;
  int tmp ;

  {
  d = (struct uniq_data *)strm->data;
  if (! d->init) {
    d->init = 1;
    d->last = data;
    strm_emit(strm, data, (int (*)(strm_stream * , strm_value  ))((void *)0));
    return (0);
  }
  tmp = strm_value_eq(data, d->last);
  if (! tmp) {
    d->last = data;
    strm_emit(strm, data, (int (*)(strm_stream * , strm_value  ))((void *)0));
  }
  return (0);
}
}
static int iter_uniqf(strm_stream *strm , strm_value data )
{
  struct uniq_data *d ;
  strm_value val ;
  int tmp ;
  int tmp___0 ;

  {
  d = (struct uniq_data *)strm->data;
  tmp = strm_funcall(strm, d->func, 1, & data, & val);
  if (tmp == 1) {
    return (1);
  }
  if (! d->init) {
    d->init = 1;
    d->last = data;
    d->v = val;
    strm_emit(strm, data, (int (*)(strm_stream * , strm_value  ))((void *)0));
    return (0);
  }
  tmp___0 = strm_value_eq(val, d->v);
  if (! tmp___0) {
    d->last = data;
    d->v = val;
    strm_emit(strm, data, (int (*)(strm_stream * , strm_value  ))((void *)0));
  }
  return (0);
}
}
static int exec_uniq(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  struct uniq_data *d ;
  strm_value func ;
  strm_value tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int (*tmp___3)(strm_stream *strm , strm_value data ) ;
  int tmp___4 ;
  strm_stream *tmp___5 ;

  {
  tmp = strm_nil_value();
  func = tmp;
  while (1) {
    tmp___0 = strm_parse_args(strm, argc, args, "|v", & func);
    if (tmp___0 == 1) {
      return (1);
    }
    break;
  }
  tmp___1 = malloc(sizeof(*d));
  d = (struct uniq_data *)tmp___1;
  if (! d) {
    return (1);
  }
  d->last = strm_nil_value();
  d->func = func;
  d->init = 0;
  tmp___4 = strm_nil_p(func);
  if (tmp___4) {
    tmp___3 = & iter_uniq;
  } else {
    tmp___3 = & iter_uniqf;
  }
  tmp___5 = strm_stream_new((strm_stream_mode )1, tmp___3, (int (*)(strm_stream * ,
                                                                    strm_value  ))((void *)0),
                            (void *)d);
  *ret = strm_ptr_value((void *)tmp___5);
  return (0);
}
}
void strm_stat_init(strm_state *state ) ;
void strm_iter_init(strm_state *state )
{
  strm_value tmp ;
  strm_value tmp___0 ;
  strm_value tmp___1 ;
  strm_value tmp___2 ;
  strm_value tmp___3 ;
  strm_value tmp___4 ;
  strm_value tmp___5 ;
  strm_value tmp___6 ;
  strm_value tmp___7 ;
  strm_value tmp___8 ;
  strm_value tmp___9 ;
  strm_value tmp___10 ;
  strm_value tmp___11 ;
  strm_value tmp___12 ;
  strm_value tmp___13 ;
  strm_value tmp___14 ;
  strm_value tmp___15 ;
  strm_value tmp___16 ;
  strm_value tmp___17 ;
  strm_value tmp___18 ;

  {
  tmp = strm_cfunc_value(& exec_seq);
  strm_var_def(state, "seq", tmp);
  tmp___0 = strm_cfunc_value(& exec_repeat);
  strm_var_def(state, "repeat", tmp___0);
  tmp___1 = strm_cfunc_value(& exec_cycle);
  strm_var_def(state, "cycle", tmp___1);
  tmp___2 = strm_cfunc_value(& exec_each);
  strm_var_def(state, "each", tmp___2);
  tmp___3 = strm_cfunc_value(& exec_map);
  strm_var_def(state, "map", tmp___3);
  tmp___4 = strm_cfunc_value(& exec_flatmap);
  strm_var_def(state, "flatmap", tmp___4);
  tmp___5 = strm_cfunc_value(& exec_filter);
  strm_var_def(state, "filter", tmp___5);
  tmp___6 = strm_cfunc_value(& exec_count);
  strm_var_def(state, "count", tmp___6);
  tmp___7 = strm_cfunc_value(& exec_min);
  strm_var_def(state, "min", tmp___7);
  tmp___8 = strm_cfunc_value(& exec_max);
  strm_var_def(state, "max", tmp___8);
  tmp___9 = strm_cfunc_value(& exec_reduce);
  strm_var_def(state, "reduce", tmp___9);
  tmp___10 = strm_cfunc_value(& exec_rbk);
  strm_var_def(state, "reduce_by_key", tmp___10);
  tmp___11 = strm_cfunc_value(& exec_slice);
  strm_var_def(state, "slice", tmp___11);
  tmp___12 = strm_cfunc_value(& exec_consec);
  strm_var_def(state, "consec", tmp___12);
  tmp___13 = strm_cfunc_value(& exec_take);
  strm_var_def(state, "take", tmp___13);
  tmp___14 = strm_cfunc_value(& exec_drop);
  strm_var_def(state, "drop", tmp___14);
  tmp___15 = strm_cfunc_value(& exec_uniq);
  strm_var_def(state, "uniq", tmp___15);
  tmp___16 = strm_cfunc_value(& ary_each);
  strm_var_def(strm_ns_array, "each", tmp___16);
  tmp___17 = strm_cfunc_value(& ary_map);
  strm_var_def(strm_ns_array, "map", tmp___17);
  tmp___18 = strm_cfunc_value(& ary_flatmap);
  strm_var_def(strm_ns_array, "flatmap", tmp___18);
  strm_stat_init(state);
  return;
}
}
#pragma merger("0","/tmp/cil-7OQDrq99.i","-std=gnu99,-g,-ggdb,-Wall")
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
extern  __attribute__((__nothrow__)) double fabs(double __x )  __attribute__((__const__)) ;
static int iter_sum(strm_stream *strm , strm_value data )
{
  struct sum_data *d ;
  double x ;
  double t ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
  d = (struct sum_data *)strm->data;
  tmp = strm_number_p(data);
  if (! tmp) {
    return (1);
  }
  x = strm_value_float(data);
  t = d->sum + x;
  tmp___0 = fabs(d->sum);
  tmp___1 = fabs(x);
  if (tmp___0 >= tmp___1) {
    d->c += (d->sum - t) + x;
  } else {
    d->c += (x - t) + d->sum;
  }
  d->sum = t;
  (d->num) ++;
  return (0);
}
}
static strm_value convert_number(strm_stream *strm , strm_value data , strm_value func )
{
  strm_value val ;
  strm_value tmp ;
  int tmp___0 ;
  strm_value tmp___1 ;
  int tmp___2 ;

  {
  tmp___0 = strm_funcall(strm, func, 1, & data, & val);
  if (tmp___0 == 1) {
    tmp = strm_nil_value();
    return (tmp);
  }
  tmp___2 = strm_number_p(val);
  if (! tmp___2) {
    strm_raise(strm, "number required");
    tmp___1 = strm_nil_value();
    return (tmp___1);
  }
  return (val);
}
}
static int iter_sumf(strm_stream *strm , strm_value data )
{
  struct sum_data *d ;
  double x ;
  double t ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
  d = (struct sum_data *)strm->data;
  data = convert_number(strm, data, d->func);
  tmp = strm_number_p(data);
  if (! tmp) {
    return (1);
  }
  x = strm_value_float(data);
  t = d->sum + x;
  tmp___0 = fabs(d->sum);
  tmp___1 = fabs(x);
  if (tmp___0 >= tmp___1) {
    d->c += (d->sum - t) + x;
  } else {
    d->c += (x - t) + d->sum;
  }
  d->sum = t;
  (d->num) ++;
  return (0);
}
}
static int sum_finish(strm_stream *strm , strm_value data )
{
  struct sum_data *d ;
  strm_value tmp ;

  {
  d = (struct sum_data *)strm->data;
  tmp = strm_float_value(d->sum + d->c);
  strm_emit(strm, tmp, (int (*)(strm_stream * , strm_value  ))((void *)0));
  return (0);
}
}
static int avg_finish(strm_stream *strm , strm_value data )
{
  struct sum_data *d ;
  strm_value tmp ;

  {
  d = (struct sum_data *)strm->data;
  tmp = strm_float_value((d->sum + d->c) / (double )d->num);
  strm_emit(strm, tmp, (int (*)(strm_stream * , strm_value  ))((void *)0));
  return (0);
}
}
static int exec_sum_avg(strm_stream *strm , int argc , strm_value *args , strm_value *ret ,
                        int avg )
{
  struct sum_data *d ;
  strm_value func ;
  int tmp ;
  void *tmp___0 ;
  int (*tmp___1)(strm_stream *strm , strm_value data ) ;
  strm_stream *tmp___2 ;
  int (*tmp___3)(strm_stream *strm , strm_value data ) ;
  strm_stream *tmp___4 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "|v", & func);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = malloc(sizeof(struct sum_data ));
  d = (struct sum_data *)tmp___0;
  if (! d) {
    return (1);
  }
  d->sum = (double )0;
  d->c = (double )0;
  d->num = 0;
  if (argc == 0) {
    d->func = strm_nil_value();
    if (avg) {
      tmp___1 = & avg_finish;
    } else {
      tmp___1 = & sum_finish;
    }
    tmp___2 = strm_stream_new((strm_stream_mode )1, & iter_sum, tmp___1, (void *)d);
    *ret = strm_ptr_value((void *)tmp___2);
  } else {
    d->func = func;
    if (avg) {
      tmp___3 = & avg_finish;
    } else {
      tmp___3 = & sum_finish;
    }
    tmp___4 = strm_stream_new((strm_stream_mode )1, & iter_sumf, tmp___3, (void *)d);
    *ret = strm_ptr_value((void *)tmp___4);
  }
  return (0);
}
}
static int exec_sum(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  int tmp ;

  {
  tmp = exec_sum_avg(strm, argc, args, ret, 0);
  return (tmp);
}
}
static int exec_avg(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  int tmp ;

  {
  tmp = exec_sum_avg(strm, argc, args, ret, 1);
  return (tmp);
}
}
static int ary_sum_avg(strm_stream *strm , int argc , strm_value *args , strm_value *ret ,
                       int avg )
{
  int i ;
  int len ;
  strm_value *v ;
  double sum ;
  double c ;
  strm_value func ;
  int tmp ;
  double x ;
  double t ;
  int tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  strm_value val ;
  double x___0 ;
  double t___0 ;
  int tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;

  {
  sum = (double )0;
  c = (double )0;
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "a|v", & v, & len, & func);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  if (argc == 1) {
    i = 0;
    while (i < len) {
      tmp___0 = strm_number_p(*(v + i));
      if (! tmp___0) {
        return (1);
      }
      x = strm_value_float(*(v + i));
      t = sum + x;
      tmp___1 = fabs(sum);
      tmp___2 = fabs(x);
      if (tmp___1 >= tmp___2) {
        c += (sum - t) + x;
      } else {
        c += (x - t) + sum;
      }
      sum = t;
      i ++;
    }
  } else {
    i = 0;
    while (i < len) {
      val = convert_number(strm, *(v + i), func);
      tmp___3 = strm_number_p(val);
      if (! tmp___3) {
        return (1);
      }
      x___0 = strm_value_float(val);
      t___0 = sum + x___0;
      tmp___4 = fabs(sum);
      tmp___5 = fabs(x___0);
      if (tmp___4 >= tmp___5) {
        c += (sum - t___0) + x___0;
      } else {
        c += (x___0 - t___0) + sum;
      }
      sum = t___0;
      i ++;
    }
  }
  sum += c;
  if (avg) {
    *ret = strm_float_value(sum / (double )len);
  } else {
    *ret = strm_float_value(sum);
  }
  return (0);
}
}
static int ary_sum(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  int tmp ;

  {
  tmp = ary_sum_avg(strm, argc, args, ret, 0);
  return (tmp);
}
}
static int ary_avg(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  int tmp ;

  {
  tmp = ary_sum_avg(strm, argc, args, ret, 1);
  return (tmp);
}
}
static int iter_mvavg(strm_stream *strm , strm_value data )
{
  struct mvavg_data *d ;
  double sum ;
  double c ;
  strm_int i ;
  strm_int len ;
  int tmp ;
  strm_int tmp___0 ;
  strm_value tmp___1 ;
  double x ;
  double t ;
  double tmp___2 ;
  double tmp___3 ;
  strm_value tmp___4 ;

  {
  d = (struct mvavg_data *)strm->data;
  sum = (double )0;
  c = (double )0;
  len = d->num;
  if (d->func_p) {
    data = convert_number(strm, data, d->func);
  }
  tmp = strm_number_p(data);
  if (! tmp) {
    strm_raise(strm, "number required");
    return (1);
  }
  tmp___0 = d->i;
  (d->i) ++;
  d->data[tmp___0] = strm_value_float(data);
  if (d->i == d->num) {
    d->filled = 1;
    d->i = 0;
  }
  if (! d->filled) {
    tmp___1 = strm_nil_value();
    strm_emit(strm, tmp___1, (int (*)(strm_stream * , strm_value  ))((void *)0));
    return (0);
  }
  i = 0;
  while (i < len) {
    x = d->data[i];
    t = sum + x;
    tmp___2 = fabs(sum);
    tmp___3 = fabs(x);
    if (tmp___2 >= tmp___3) {
      c += (sum - t) + x;
    } else {
      c += (x - t) + sum;
    }
    sum = t;
    i ++;
  }
  tmp___4 = strm_float_value((sum + c) / (double )d->num);
  strm_emit(strm, tmp___4, (int (*)(strm_stream * , strm_value  ))((void *)0));
  return (0);
}
}
static int exec_mvavg(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  struct mvavg_data *d ;
  strm_int n ;
  strm_value func ;
  int tmp ;
  void *tmp___0 ;
  strm_stream *tmp___1 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "i|v", & n, & func);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = malloc(sizeof(struct mvavg_data ) + (unsigned long )n * sizeof(double ));
  d = (struct mvavg_data *)tmp___0;
  if (! d) {
    return (1);
  }
  d->num = n;
  d->i = 0;
  d->filled = 0;
  if (argc == 1) {
    d->func = strm_nil_value();
    d->func_p = 0;
  } else {
    d->func = func;
    d->func_p = 1;
  }
  tmp___1 = strm_stream_new((strm_stream_mode )1, & iter_mvavg, (int (*)(strm_stream * ,
                                                                         strm_value  ))((void *)0),
                            (void *)d);
  *ret = strm_ptr_value((void *)tmp___1);
  return (0);
}
}
static int iter_stdev(strm_stream *strm , strm_value data )
{
  struct stdev_data *d ;
  double x ;
  double tmp ;

  {
  d = (struct stdev_data *)strm->data;
  tmp = strm_value_float(data);
  x = tmp;
  (d->num) ++;
  x -= d->s1;
  d->s1 += x / (double )d->num;
  d->s2 += (((double )(d->num - 1) * x) * x) / (double )d->num;
  return (0);
}
}
static int iter_stdevf(strm_stream *strm , strm_value data )
{
  struct stdev_data *d ;
  double x ;
  int tmp ;

  {
  d = (struct stdev_data *)strm->data;
  data = convert_number(strm, data, d->func);
  tmp = strm_number_p(data);
  if (! tmp) {
    return (1);
  }
  x = strm_value_float(data);
  (d->num) ++;
  x -= d->s1;
  d->s1 += x / (double )d->num;
  d->s2 += (((double )(d->num - 1) * x) * x) / (double )d->num;
  return (0);
}
}
static strm_value float2(double m , double s )
{
  strm_value buf[2] ;
  strm_array tmp ;

  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"f2[%f, %f]\n",
          m, s);
  buf[0] = strm_float_value(m);
  buf[1] = strm_float_value(s);
  tmp = strm_ary_new((strm_value const   *)(buf), 2);
  return (tmp);
}
}
static int stdev_finish(strm_stream *strm , strm_value data )
{
  struct stdev_data *d ;
  double s ;
  strm_value tmp ;
  strm_value tmp___0 ;
  strm_value tmp___1 ;
  strm_value tmp___2 ;

  {
  d = (struct stdev_data *)strm->data;
  switch ((unsigned int )d->mode) {
  case 0U:
  s = sqrt(d->s2 / (double )(d->num - 1));
  tmp = strm_float_value(s);
  strm_emit(strm, tmp, (int (*)(strm_stream * , strm_value  ))((void *)0));
  break;
  case 1U:
  s = d->s2 / (double )(d->num - 1);
  tmp___0 = strm_float_value(s);
  strm_emit(strm, tmp___0, (int (*)(strm_stream * , strm_value  ))((void *)0));
  break;
  case 2U:
  s = sqrt(d->s2 / (double )(d->num - 1));
  tmp___1 = float2(d->s1, s);
  strm_emit(strm, tmp___1, (int (*)(strm_stream * , strm_value  ))((void *)0));
  break;
  case 3U:
  s = d->s2 / (double )(d->num - 1);
  tmp___2 = float2(d->s1, s);
  strm_emit(strm, tmp___2, (int (*)(strm_stream * , strm_value  ))((void *)0));
  break;
  }
  return (0);
}
}
static int exec_var_stdev(strm_stream *strm , int argc , strm_value *args , strm_value *ret ,
                          enum stdev_mode mode )
{
  struct stdev_data *d ;
  strm_value func ;
  int tmp ;
  void *tmp___0 ;
  double tmp___1 ;
  strm_stream *tmp___2 ;
  strm_stream *tmp___3 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "|v", & func);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = malloc(sizeof(struct stdev_data ));
  d = (struct stdev_data *)tmp___0;
  if (! d) {
    return (1);
  }
  d->num = 0;
  tmp___1 = 0.0;
  d->s2 = tmp___1;
  d->s1 = tmp___1;
  d->mode = mode;
  if (argc == 0) {
    tmp___2 = strm_stream_new((strm_stream_mode )1, & iter_stdev, & stdev_finish,
                              (void *)d);
    *ret = strm_ptr_value((void *)tmp___2);
  } else {
    d->func = func;
    tmp___3 = strm_stream_new((strm_stream_mode )1, & iter_stdevf, & stdev_finish,
                              (void *)d);
    *ret = strm_ptr_value((void *)tmp___3);
  }
  return (0);
}
}
static int exec_stdev(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  int tmp ;

  {
  tmp = exec_var_stdev(strm, argc, args, ret, (enum stdev_mode )0);
  return (tmp);
}
}
static int exec_variance(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  int tmp ;

  {
  tmp = exec_var_stdev(strm, argc, args, ret, (enum stdev_mode )1);
  return (tmp);
}
}
static int exec_mean_stdev(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  int tmp ;

  {
  tmp = exec_var_stdev(strm, argc, args, ret, (enum stdev_mode )2);
  return (tmp);
}
}
static int exec_mean_variance(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  int tmp ;

  {
  tmp = exec_var_stdev(strm, argc, args, ret, (enum stdev_mode )3);
  return (tmp);
}
}
static int ary_var_stdev(strm_stream *strm , int argc , strm_value *args , strm_value *ret ,
                         int stdev )
{
  strm_value func ;
  strm_value *v ;
  int i ;
  int len ;
  double s1 ;
  double s2 ;
  int tmp ;
  double x ;
  double tmp___0 ;
  strm_value val ;
  double x___0 ;
  int tmp___1 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "a|v", & v, & len, & func);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  s2 = 0.0;
  s1 = s2;
  if (argc == 0) {
    i = 0;
    while (i < len) {
      tmp___0 = strm_value_float(*(v + i));
      x = tmp___0;
      x -= s1;
      s1 += x / (double )(i + 1);
      s2 += (((double )i * x) * x) / (double )(i + 1);
      i ++;
    }
  } else {
    i = 0;
    while (i < len) {
      val = convert_number(strm, *(v + i), func);
      tmp___1 = strm_number_p(val);
      if (! tmp___1) {
        return (1);
      }
      x___0 = strm_value_float(val);
      x___0 -= s1;
      s1 += x___0 / (double )(i + 1);
      s2 += (((double )i * x___0) * x___0) / (double )(i + 1);
      i ++;
    }
  }
  s2 /= (double )(i - 1);
  if (stdev) {
    s2 = sqrt(s2);
  }
  *ret = strm_float_value(s2);
  return (0);
}
}
static int ary_stdev(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  int tmp ;

  {
  tmp = ary_var_stdev(strm, argc, args, ret, 1);
  return (tmp);
}
}
static int ary_var(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  int tmp ;

  {
  tmp = ary_var_stdev(strm, argc, args, ret, 0);
  return (tmp);
}
}
static int iter_correl(strm_stream *strm , strm_value data )
{
  struct correl_data *d ;
  strm_value *v ;
  double dx ;
  double dy ;
  int tmp ;
  struct strm_array *tmp___0 ;
  struct strm_array *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;

  {
  d = (struct correl_data *)strm->data;
  tmp = strm_array_p(data);
  if (tmp) {
    tmp___0 = strm_ary_struct(data);
    if (tmp___0->len != 2) {
      strm_raise(strm, "invalid data");
      return (1);
    }
  } else {
    strm_raise(strm, "invalid data");
    return (1);
  }
  tmp___1 = strm_ary_struct(data);
  v = tmp___1->ptr;
  tmp___2 = strm_number_p(*(v + 0));
  if (tmp___2) {
    tmp___3 = strm_number_p(*(v + 1));
    if (! tmp___3) {
      strm_raise(strm, "correl() requires [num, num]");
      return (1);
    }
  } else {
    strm_raise(strm, "correl() requires [num, num]");
    return (1);
  }
  (d->n) ++;
  tmp___4 = strm_value_float(*(v + 0));
  dx = tmp___4 - d->sx;
  d->sx += dx / (double )d->n;
  tmp___5 = strm_value_float(*(v + 1));
  dy = tmp___5 - d->sy;
  d->sy += dy / (double )d->n;
  d->sxx += (((double )(d->n - 1) * dx) * dx) / (double )d->n;
  d->syy += (((double )(d->n - 1) * dy) * dy) / (double )d->n;
  d->sxy += (((double )(d->n - 1) * dx) * dy) / (double )d->n;
  return (0);
}
}
static int correl_finish(strm_stream *strm , strm_value data )
{
  struct correl_data *d ;
  double sxx ;
  double tmp ;
  double syy ;
  double tmp___0 ;
  double sxy ;
  strm_value tmp___1 ;

  {
  d = (struct correl_data *)strm->data;
  (d->n) --;
  tmp = sqrt(d->sxx / (double )d->n);
  sxx = tmp;
  tmp___0 = sqrt(d->syy / (double )d->n);
  syy = tmp___0;
  sxy = d->sxy / (((double )d->n * sxx) * syy);
  tmp___1 = strm_float_value(sxy);
  strm_emit(strm, tmp___1, (int (*)(strm_stream * , strm_value  ))((void *)0));
  return (0);
}
}
static int exec_correl(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  struct correl_data *d ;
  int tmp ;
  void *tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  strm_stream *tmp___5 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "");
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = malloc(sizeof(struct correl_data ));
  d = (struct correl_data *)tmp___0;
  if (! d) {
    return (1);
  }
  d->n = 0;
  tmp___4 = (double )0;
  d->sxy = tmp___4;
  tmp___3 = tmp___4;
  d->syy = tmp___3;
  tmp___2 = tmp___3;
  d->sxx = tmp___2;
  tmp___1 = tmp___2;
  d->sy = tmp___1;
  d->sx = tmp___1;
  tmp___5 = strm_stream_new((strm_stream_mode )1, & iter_correl, & correl_finish,
                            (void *)d);
  *ret = strm_ptr_value((void *)tmp___5);
  return (0);
}
}
static int ary_correl(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_value *v ;
  int i ;
  int len ;
  double sx ;
  double sy ;
  double sxx ;
  double syy ;
  double sxy ;
  int tmp ;
  strm_value data ;
  strm_value *dv ;
  double dx ;
  double dy ;
  int tmp___0 ;
  struct strm_array *tmp___1 ;
  struct strm_array *tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "a", & v, & len);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  sxy = (double )0;
  syy = sxy;
  sxx = syy;
  sy = sxx;
  sx = sy;
  i = 0;
  while (i < len) {
    data = *(v + i);
    tmp___0 = strm_array_p(data);
    if (tmp___0) {
      tmp___1 = strm_ary_struct(data);
      if (tmp___1->len != 2) {
        goto __Cont;
      }
    } else {
      goto __Cont;
    }
    tmp___2 = strm_ary_struct(data);
    dv = tmp___2->ptr;
    tmp___3 = strm_value_float(*(dv + 0));
    dx = tmp___3 - sx;
    sx += dx / (double )(i + 1);
    tmp___4 = strm_value_float(*(dv + 1));
    dy = tmp___4 - sy;
    sy += dy / (double )(i + 1);
    sxx += (((double )i * dx) * dx) / (double )(i + 1);
    syy += (((double )i * dy) * dy) / (double )(i + 1);
    sxy += (((double )i * dx) * dy) / (double )(i + 1);
    __Cont: /* CIL Label */
    i ++;
  }
  sxx = sqrt(sxx / (double )(len - 1));
  syy = sqrt(syy / (double )(len - 1));
  sxy /= ((double )(len - 1) * sxx) * syy;
  *ret = strm_float_value(sxy);
  return (0);
}
}
void strm_rand_init(strm_state *state ) ;
void strm_sort_init(strm_state *state ) ;
void strm_stat_init(strm_state *state )
{
  strm_value tmp ;
  strm_value tmp___0 ;
  strm_value tmp___1 ;
  strm_value tmp___2 ;
  strm_value tmp___3 ;
  strm_value tmp___4 ;
  strm_value tmp___5 ;
  strm_value tmp___6 ;
  strm_value tmp___7 ;
  strm_value tmp___8 ;
  strm_value tmp___9 ;
  strm_value tmp___10 ;
  strm_value tmp___11 ;
  strm_value tmp___12 ;
  strm_value tmp___13 ;

  {
  tmp = strm_cfunc_value(& exec_sum);
  strm_var_def(state, "sum", tmp);
  tmp___0 = strm_cfunc_value(& exec_avg);
  strm_var_def(state, "average", tmp___0);
  tmp___1 = strm_cfunc_value(& exec_avg);
  strm_var_def(state, "mean", tmp___1);
  tmp___2 = strm_cfunc_value(& exec_mvavg);
  strm_var_def(state, "moving_average", tmp___2);
  tmp___3 = strm_cfunc_value(& exec_mvavg);
  strm_var_def(state, "rolling_mean", tmp___3);
  tmp___4 = strm_cfunc_value(& exec_stdev);
  strm_var_def(state, "stdev", tmp___4);
  tmp___5 = strm_cfunc_value(& exec_variance);
  strm_var_def(state, "variance", tmp___5);
  tmp___6 = strm_cfunc_value(& exec_mean_stdev);
  strm_var_def(state, "mean_stdev", tmp___6);
  tmp___7 = strm_cfunc_value(& exec_mean_variance);
  strm_var_def(state, "mean_variance", tmp___7);
  tmp___8 = strm_cfunc_value(& exec_correl);
  strm_var_def(state, "correl", tmp___8);
  tmp___9 = strm_cfunc_value(& ary_sum);
  strm_var_def(strm_ns_array, "sum", tmp___9);
  tmp___10 = strm_cfunc_value(& ary_avg);
  strm_var_def(strm_ns_array, "average", tmp___10);
  tmp___11 = strm_cfunc_value(& ary_stdev);
  strm_var_def(strm_ns_array, "stdev", tmp___11);
  tmp___12 = strm_cfunc_value(& ary_var);
  strm_var_def(strm_ns_array, "variance", tmp___12);
  tmp___13 = strm_cfunc_value(& ary_correl);
  strm_var_def(strm_ns_array, "correl", tmp___13);
  strm_rand_init(state);
  strm_sort_init(state);
  return;
}
}
#pragma merger("0","/tmp/cil-NtV3nzAg.i","-std=gnu99,-g,-ggdb,-Wall")
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format
                                                                             , ...) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
strm_state *strm_ns_new(strm_state *state , char const   *name ) ;
int strm_time_p(strm_value val ) ;
int strm_time_parse_time(char const   *p , strm_int len , long *sec , long *usec ,
                         int *offset ) ;
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
extern  __attribute__((__nothrow__)) double difftime(time_t __time1 , time_t __time0 )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
extern  __attribute__((__nothrow__)) size_t strftime(char * __restrict  __s , size_t __maxsize ,
                                                     char const   * __restrict  __format ,
                                                     struct tm  const  * __restrict  __tp ) ;
extern  __attribute__((__nothrow__)) char *strptime(char const   * __restrict  __s ,
                                                    char const   * __restrict  __fmt ,
                                                    struct tm *__tp ) ;
extern  __attribute__((__nothrow__)) struct tm *gmtime_r(time_t const   * __restrict  __timer ,
                                                         struct tm * __restrict  __tp ) ;
extern  __attribute__((__nothrow__)) struct tm *localtime_r(time_t const   * __restrict  __timer ,
                                                            struct tm * __restrict  __tp ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         void * __restrict  __tz ) ;
extern  __attribute__((__nothrow__)) double log10(double __x ) ;
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
extern  __attribute__((__nothrow__)) double ceil(double __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) double floor(double __x )  __attribute__((__const__)) ;
static strm_state *ns_time  ;
int strm_time_p(strm_value val )
{
  struct strm_misc *p ;

  {
  if ((val & (65535UL << 48)) != 18445899648779419648) {
    return (0);
  } else {
    p = (struct strm_misc *)((void *)((intptr_t )(val & ~ (65535UL << 48))));
    if (! p) {
      return (0);
    }
    if ((unsigned int )p->type != 4U) {
      return (0);
    }
    if ((unsigned long )p->ns != (unsigned long )ns_time) {
      return (0);
    }
  }
  return (1);
}
}
void num_to_timeval(double d , struct timeval *tv )
{
  double sec ;
  double tmp ;

  {
  tmp = floor(d);
  sec = tmp;
  tv->tv_sec = (__time_t )sec;
  tv->tv_usec = (__suseconds_t )((d - sec) * (double )1000000);
  return;
}
}
double timeval_to_num(struct timeval *tv )
{
  double d ;

  {
  d = (double )tv->tv_sec;
  return (d + (double )tv->tv_usec / 1000000.0);
}
}
static int time_localoffset(int force ) ;
static int localoffset  =    1;
static int time_localoffset(int force )
{
  time_t now ;
  struct tm gm ;
  time_t tmp ;
  double tmp___0 ;

  {
  if (force) {
    now = time((time_t *)((void *)0));
    gmtime_r((time_t const   * __restrict  )(& now), (struct tm * __restrict  )(& gm));
    tmp = mktime(& gm);
    tmp___0 = difftime(now, tmp);
    localoffset = (int )tmp___0;
  } else
  if (localoffset == 1) {
    now = time((time_t *)((void *)0));
    gmtime_r((time_t const   * __restrict  )(& now), (struct tm * __restrict  )(& gm));
    tmp = mktime(& gm);
    tmp___0 = difftime(now, tmp);
    localoffset = (int )tmp___0;
  }
  return (localoffset);
}
}
static int time_alloc(struct timeval *tv , int utc_offset , strm_value *ret )
{
  struct strm_time *t ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct strm_time ));
  t = (struct strm_time *)tmp;
  if (! t) {
    return (1);
  }
  t->type = (enum strm_ptr_type )4;
  t->ns = ns_time;
  t->tv = *tv;
  t->utc_offset = utc_offset;
  *ret = strm_ptr_value((void *)t);
  return (0);
}
}
static int scan_digit(char const   c )
{


  {
  if (48 <= (int )c) {
    if ((int const   )c <= 57) {
      return ((int )((int const   )c - 48));
    } else {
      return (60000);
    }
  } else {
    return (60000);
  }
}
}
static int scan_num(char const   **sp , char const   *send )
{
  char const   *s ;
  int n ;
  int i ;
  int tmp ;

  {
  s = *sp;
  n = 0;
  while ((unsigned long )s < (unsigned long )send) {
    tmp = scan_digit(*s);
    i = tmp;
    if (i > 9) {
      if ((unsigned long )s == (unsigned long )*sp) {
        return (-1);
      }
      *sp = s;
      return (n);
    }
    s ++;
    n = 10 * n + i;
  }
  *sp = s;
  return (n);
}
}
static int parse_tz(char const   *s , strm_int len )
{
  int h ;
  int m ;
  char c ;
  char const   *send ;
  char const   *tmp ;
  int i ;
  int tmp___0 ;

  {
  send = s + len;
  switch ((int const   )*(s + 0)) {
  case 90:
  return (0);
  case 45:
  case 43:
  tmp = s;
  s ++;
  c = (char )*tmp;
  h = scan_num(& s, send);
  if (h < 0) {
    return (60000);
  }
  if ((int const   )*s == 58) {
    s ++;
    m = scan_num(& s, send);
  } else
  if (h >= 100) {
    i = h;
    h = i / 100;
    m = i % 100;
  } else {
    m = 0;
  }
  if (h > 14) {
    return (60000);
  }
  if (m > 59) {
    return (60000);
  }
  if ((int )c == 45) {
    tmp___0 = -1;
  } else {
    tmp___0 = 1;
  }
  return (((h * 60 + m) * tmp___0) * 60);
  default:
  return (60000);
  }
}
}
int strm_time_parse_time(char const   *p , strm_int len , long *sec , long *usec ,
                         int *offset )
{
  char const   *s ;
  char const   *t ;
  char const   *t2 ;
  char const   *tend ;
  struct tm tm ;
  int localoffset___0 ;
  int tmp ;
  time_t tt ;
  char *pp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  struct tm tm2 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  long frac ;
  int tmp___11 ;
  double d ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  int n ;

  {
  s = p;
  tm.tm_sec = 0;
  tm.tm_min = 0;
  tm.tm_hour = 0;
  tm.tm_mday = 0;
  tm.tm_mon = 0;
  tm.tm_year = 0;
  tm.tm_wday = 0;
  tm.tm_yday = 0;
  tm.tm_isdst = 0;
  tm.__tm_gmtoff = 0L;
  tm.__tm_zone = (char const   *)0;
  tmp = time_localoffset(1);
  localoffset___0 = tmp;
  if ((int const   )*(s + len) != 0) {
    tmp___0 = malloc((size_t )(len + 1));
    pp = (char *)tmp___0;
    memcpy((void * __restrict  )pp, (void const   * __restrict  )p, (size_t )len);
    *(pp + len) = (char )'\000';
    s = (char const   *)pp;
  }
  tend = s + len;
  *usec = 0L;
  tmp___1 = strptime((char const   * __restrict  )s, (char const   * __restrict  )"%Y.%m.%d",
                     & tm);
  t = (char const   *)tmp___1;
  if ((unsigned long )t == (unsigned long )((void *)0)) {
    tmp___2 = strptime((char const   * __restrict  )s, (char const   * __restrict  )"%Y-%m-%d",
                       & tm);
    t = (char const   *)tmp___2;
  }
  if ((unsigned long )t == (unsigned long )((void *)0)) {
    tmp___3 = strptime((char const   * __restrict  )s, (char const   * __restrict  )"%Y/%m/%d",
                       & tm);
    t = (char const   *)tmp___3;
  }
  if ((unsigned long )t == (unsigned long )((void *)0)) {
    tmp___4 = strptime((char const   * __restrict  )s, (char const   * __restrict  )"%Y%m%d",
                       & tm);
    t = (char const   *)tmp___4;
    if (t) {
      if (! ((int const   )*(t + 0) == 84)) {
        if (! ((int const   )*(t + 0) == 32)) {
          t = (char const   *)((void *)0);
        }
      }
    }
  }
  if ((unsigned long )t == (unsigned long )((void *)0)) {
    tmp___5 = strptime((char const   * __restrict  )s, (char const   * __restrict  )"%b %d %Y",
                       & tm);
    t = (char const   *)tmp___5;
    if (t) {
      if ((int const   )*(t + 0) == 58) {
        t = (char const   *)((void *)0);
      }
    }
  }
  if ((unsigned long )t == (unsigned long )((void *)0)) {
    tt = time((time_t *)((void *)0));
    localtime_r((time_t const   * __restrict  )(& tt), (struct tm * __restrict  )(& tm2));
    tm.tm_year = tm2.tm_year;
    tmp___6 = strptime((char const   * __restrict  )s, (char const   * __restrict  )"%b %d",
                       & tm);
    t = (char const   *)tmp___6;
  }
  if ((unsigned long )t == (unsigned long )((void *)0)) {
    goto bad;
  }
  if ((unsigned long )t == (unsigned long )tend) {
    tt = mktime(& tm);
    tt += (time_t )localoffset___0;
    *sec = tt;
    *usec = 0L;
    *offset = 50000;
    goto good;
  }
  tmp___7 = t;
  t ++;
  switch ((int const   )*tmp___7) {
  case 84:
  break;
  case 32:
  while ((int const   )*t == 32) {
    t ++;
  }
  break;
  default:
  goto bad;
  }
  tmp___8 = strptime((char const   * __restrict  )t, (char const   * __restrict  )"%H:%M:%S",
                     & tm);
  t2 = (char const   *)tmp___8;
  if ((unsigned long )t2 == (unsigned long )((void *)0)) {
    tmp___9 = strptime((char const   * __restrict  )t, (char const   * __restrict  )"%H%M%S",
                       & tm);
    t2 = (char const   *)tmp___9;
  }
  if ((unsigned long )t2 == (unsigned long )((void *)0)) {
    tmp___10 = strptime((char const   * __restrict  )t, (char const   * __restrict  )"%H:%M",
                        & tm);
    t2 = (char const   *)tmp___10;
    if ((unsigned long )t2 == (unsigned long )((void *)0)) {
      goto bad;
    }
  }
  t = t2;
  tt = mktime(& tm);
  if ((int const   )*(t + 0) == 46) {
    t ++;
    tmp___11 = scan_num(& t, tend);
    frac = (long )tmp___11;
    if (frac < 0L) {
      goto bad;
    }
    if (frac > 0L) {
      tmp___12 = log10((double )frac);
      tmp___13 = ceil(tmp___12);
      d = tmp___13;
      tmp___14 = pow(10.0, d);
      d = (double )frac / tmp___14;
      *usec = (long )(d * (double )1000000);
    }
  }
  if ((int const   )*(t + 0) == 90) {
    tt += (time_t )localoffset___0;
    *offset = 0;
  } else
  if ((unsigned long )t == (unsigned long )tend) {
    *offset = localoffset___0;
  } else {
    switch ((int const   )*(t + 0)) {
    case 45:
    case 43:
    n = parse_tz(t, (strm_int )(tend - t));
    if (n == 60000) {
      goto bad;
    }
    tt += (time_t )localoffset___0;
    tt -= (time_t )n;
    *offset = n;
    break;
    default:
    goto bad;
    }
  }
  *sec = tt;
  good:
  if ((unsigned long )s != (unsigned long )p) {
    free((void *)((char *)s));
  }
  return (0);
  bad:
  if ((unsigned long )s != (unsigned long )p) {
    free((void *)((char *)s));
  }
  return (-1);
}
}
strm_value strm_time_new(long sec , long usec , int offset )
{
  struct timeval tv ;
  strm_value v ;
  strm_value tmp ;
  int tmp___0 ;

  {
  tv.tv_sec = sec;
  tv.tv_usec = usec;
  tmp___0 = time_alloc(& tv, offset, & v);
  if (tmp___0 == 1) {
    tmp = strm_nil_value();
    return (tmp);
  }
  return (v);
}
}
static int time_time(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  struct timeval tv ;
  struct tm tm ;
  time_t t ;
  int utc_offset ;
  char *s ;
  int slen ;
  long sec ;
  long usec ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  strm_int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  strm_string str ;
  strm_int tmp___5 ;
  char const   *tmp___6 ;
  strm_int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  tv.tv_sec = (__time_t )0;
  tv.tv_usec = 0L;
  tm.tm_sec = 0;
  tm.tm_min = 0;
  tm.tm_hour = 0;
  tm.tm_mday = 0;
  tm.tm_mon = 0;
  tm.tm_year = 0;
  tm.tm_wday = 0;
  tm.tm_yday = 0;
  tm.tm_isdst = 0;
  tm.__tm_gmtoff = 0L;
  tm.__tm_zone = (char const   *)0;
  utc_offset = 0;
  switch (argc) {
  case 1:
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "s", & s, & slen);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = strm_time_parse_time((char const   *)s, slen, & sec, & usec, & utc_offset);
  if (tmp___0 < 0) {
    strm_raise(strm, "bad time format");
    return (1);
  }
  tv.tv_sec = sec;
  tv.tv_usec = usec;
  tmp___1 = time_alloc(& tv, utc_offset, ret);
  return (tmp___1);
  break;
  case 3:
  tm.tm_year = strm_value_int(*(args + 0));
  tmp___2 = strm_value_int(*(args + 1));
  tm.tm_mon = tmp___2 - 1;
  tm.tm_mday = strm_value_int(*(args + 2));
  tv.tv_sec = mktime(& tm);
  tmp___3 = time_localoffset(1);
  tv.tv_sec += (__time_t )tmp___3;
  utc_offset = 50000;
  tmp___4 = time_alloc(& tv, utc_offset, ret);
  return (tmp___4);
  case 8:
  str = *(args + 7);
  tmp___5 = strm_str_len(str);
  tmp___6 = strm_strp_ptr(& str);
  utc_offset = parse_tz(tmp___6, tmp___5);
  if (utc_offset == 60000) {
    strm_raise(strm, "wrong timezeone");
    return (1);
  }
  case 7:
  tmp___7 = strm_value_int(*(args + 6));
  tv.tv_usec = (__suseconds_t )(tmp___7 / 1000);
  case 6:
  tm.tm_sec = strm_value_int(*(args + 5));
  case 5:
  tm.tm_min = strm_value_int(*(args + 4));
  case 4:
  tm.tm_year = strm_value_int(*(args + 0));
  tm.tm_mon = strm_value_int(*(args + 1));
  tm.tm_mday = strm_value_int(*(args + 2));
  tm.tm_hour = strm_value_int(*(args + 3));
  t = mktime(& tm);
  tv.tv_sec = t;
  if (argc == 8) {
    tmp___8 = time_localoffset(1);
    tv.tv_sec += (__time_t )tmp___8;
    tv.tv_sec -= (__time_t )utc_offset;
  } else {
    utc_offset = time_localoffset(0);
  }
  tmp___9 = time_alloc(& tv, utc_offset, ret);
  return (tmp___9);
  default:
  strm_raise(strm, "wrong # of arguments");
  return (1);
  }
  gettimeofday((struct timeval * __restrict  )(& tv), (void * __restrict  )((void *)0));
  tmp___10 = time_alloc(& tv, utc_offset, ret);
  return (tmp___10);
}
}
static int time_now(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  struct timeval tv ;
  int utc_offset ;
  char *s ;
  strm_int slen ;
  int tmp ;
  int tmp___0 ;

  {
  if (argc == 0) {
    utc_offset = time_localoffset(0);
  } else {
    while (1) {
      tmp = strm_parse_args(strm, argc, args, "s", & s, & slen);
      if (tmp == 1) {
        return (1);
      }
      break;
    }
    utc_offset = parse_tz((char const   *)s, slen);
    if (utc_offset == 60000) {
      strm_raise(strm, "wrong timezeone");
      return (1);
    }
  }
  gettimeofday((struct timeval * __restrict  )(& tv), (void * __restrict  )((void *)0));
  tmp___0 = time_alloc(& tv, utc_offset, ret);
  return (tmp___0);
}
}
static struct strm_time *get_time(strm_value val )
{
  struct strm_time *t ;
  void *tmp ;

  {
  tmp = strm_value_ptr(val, (enum strm_ptr_type )4);
  t = (struct strm_time *)tmp;
  if ((unsigned long )t->ns != (unsigned long )ns_time) {
    return ((struct strm_time *)((void *)0));
  }
  return (t);
}
}
static int time_plus(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  struct strm_time *t1 ;
  struct timeval tv ;
  struct timeval tv2 ;
  int tmp ;
  double tmp___0 ;
  int tmp___1 ;

  {
  if (argc != 2) {
    strm_raise(strm, "wrong # of arguments");
    return (1);
  }
  t1 = get_time(*(args + 0));
  tmp = strm_number_p(*(args + 1));
  if (! tmp) {
    strm_raise(strm, "number required");
    return (1);
  }
  tmp___0 = strm_value_float(*(args + 1));
  num_to_timeval(tmp___0, & tv);
  while (1) {
    tv2.tv_sec = t1->tv.tv_sec + tv.tv_sec;
    tv2.tv_usec = t1->tv.tv_usec + tv.tv_usec;
    while (tv2.tv_usec >= 1000000L) {
      (tv2.tv_sec) ++;
      tv2.tv_usec -= 1000000L;
    }
    break;
  }
  tmp___1 = time_alloc(& tv2, t1->utc_offset, ret);
  return (tmp___1);
}
}
static int time_minus(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  struct strm_time *t1 ;
  struct strm_time *t2 ;
  struct timeval tv ;
  double d ;
  int tmp ;
  int tmp___0 ;

  {
  if (argc != 2) {
    strm_raise(strm, "wrong # of arguments");
    return (1);
  }
  tmp___0 = strm_number_p(*(args + 1));
  if (tmp___0) {
    d = strm_value_float(*(args + 1));
    *(args + 1) = strm_float_value(- d);
    tmp = time_plus(strm, argc, args, ret);
    return (tmp);
  }
  t1 = get_time(*(args + 0));
  t2 = get_time(*(args + 1));
  while (1) {
    tv.tv_sec = t1->tv.tv_sec - t2->tv.tv_sec;
    tv.tv_usec = t1->tv.tv_usec - t2->tv.tv_usec;
    while (tv.tv_usec < 0L) {
      (tv.tv_sec) --;
      tv.tv_usec += 1000000L;
    }
    break;
  }
  d = timeval_to_num(& tv);
  *ret = strm_float_value(d);
  return (0);
}
}
static void get_tm(time_t t , int utc_offset , struct tm *tm )
{


  {
  t += (time_t )utc_offset;
  gmtime_r((time_t const   * __restrict  )(& t), (struct tm * __restrict  )tm);
  return;
}
}
static int time_str(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  struct strm_time *t ;
  struct tm tm ;
  int utc_offset ;
  char buf[256] ;
  char *p ;
  size_t n ;
  strm_value time___0 ;
  char *s ;
  strm_int slen ;
  int tmp ;
  char sbuf[20] ;
  double d ;
  char *t___0 ;
  size_t len ;
  int off ;
  char sign ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  if (argc == 1) {
    t = get_time(*(args + 0));
    utc_offset = t->utc_offset;
  } else {
    while (1) {
      tmp = strm_parse_args(strm, argc, args, "v|s", & time___0, & s, & slen);
      if (tmp == 1) {
        return (1);
      }
      break;
    }
    t = get_time(time___0);
    utc_offset = parse_tz((char const   *)s, slen);
    if (utc_offset == 60000) {
      strm_raise(strm, "wrong timezeone");
      return (1);
    }
  }
  if (utc_offset == 50000) {
    get_tm(t->tv.tv_sec, 0, & tm);
    if (tm.tm_hour == 0) {
      if (tm.tm_min == 0) {
        if (tm.tm_sec == 0) {
          n = strftime((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%Y.%m.%d",
                       (struct tm  const  * __restrict  )(& tm));
          *ret = strm_str_new((char const   *)(buf), (strm_int )n);
          return (0);
        }
      }
    }
    utc_offset = 0;
  }
  get_tm(t->tv.tv_sec, utc_offset, & tm);
  n = strftime((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%Y.%m.%dT%H:%M:%S",
               (struct tm  const  * __restrict  )(& tm));
  p = buf + n;
  if (t->tv.tv_usec != 0L) {
    d = (double )t->tv.tv_usec / 1000000.0;
    snprintf((char * __restrict  )(sbuf), sizeof(sbuf), (char const   * __restrict  )"%.3f",
             d);
    t___0 = sbuf + 1;
    len = strlen((char const   *)t___0);
    strncpy((char * __restrict  )p, (char const   * __restrict  )t___0, len);
    p += len;
  }
  if (utc_offset == 0) {
    *(p + 0) = (char )'Z';
    *(p + 1) = (char )'\000';
  } else {
    off = utc_offset / 60;
    if (off > 0) {
      tmp___0 = '+';
    } else {
      tmp___0 = '-';
    }
    sign = (char )tmp___0;
    if (off < 0) {
      off = - off;
    }
    snprintf((char * __restrict  )p, sizeof(buf) - (unsigned long )(p - buf), (char const   * __restrict  )"%c%02d:%02d",
             (int )sign, off / 60, off % 60);
  }
  tmp___1 = strlen((char const   *)(buf));
  *ret = strm_str_new((char const   *)(buf), (strm_int )tmp___1);
  return (0);
}
}
static int time_num(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_value time___0 ;
  struct strm_time *t ;
  int tmp ;
  double tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "v", & time___0);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  t = get_time(time___0);
  if (t->tv.tv_usec == 0L) {
    *ret = strm_int_value((strm_int )t->tv.tv_sec);
  } else {
    tmp___0 = timeval_to_num(& t->tv);
    *ret = strm_float_value(tmp___0);
  }
  return (0);
}
}
static int time_year(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_value time___0 ;
  struct strm_time *t ;
  struct tm tm ;
  int tmp ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "v", & time___0);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  t = get_time(time___0);
  get_tm(t->tv.tv_sec, t->utc_offset, & tm);
  *ret = strm_int_value(tm.tm_year + 1900);
  return (0);
}
}
static int time_month(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_value time___0 ;
  struct strm_time *t ;
  struct tm tm ;
  int tmp ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "v", & time___0);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  t = get_time(time___0);
  get_tm(t->tv.tv_sec, t->utc_offset, & tm);
  *ret = strm_int_value(tm.tm_mon + 1);
  return (0);
}
}
static int time_day(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_value time___0 ;
  struct strm_time *t ;
  struct tm tm ;
  int tmp ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "v", & time___0);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  t = get_time(time___0);
  get_tm(t->tv.tv_sec, t->utc_offset, & tm);
  *ret = strm_int_value(tm.tm_mday);
  return (0);
}
}
static int time_hour(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_value time___0 ;
  struct strm_time *t ;
  struct tm tm ;
  int tmp ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "v", & time___0);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  t = get_time(time___0);
  get_tm(t->tv.tv_sec, t->utc_offset, & tm);
  *ret = strm_int_value(tm.tm_hour);
  return (0);
}
}
static int time_min(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_value time___0 ;
  struct strm_time *t ;
  struct tm tm ;
  int tmp ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "v", & time___0);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  t = get_time(time___0);
  get_tm(t->tv.tv_sec, t->utc_offset, & tm);
  *ret = strm_int_value(tm.tm_min);
  return (0);
}
}
static int time_sec(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_value time___0 ;
  struct strm_time *t ;
  struct tm tm ;
  int tmp ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "v", & time___0);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  t = get_time(time___0);
  get_tm(t->tv.tv_sec, t->utc_offset, & tm);
  *ret = strm_int_value(tm.tm_sec);
  return (0);
}
}
static int time_weekday(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_value time___0 ;
  struct strm_time *t ;
  struct tm tm ;
  int tmp ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "v", & time___0);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  t = get_time(time___0);
  get_tm(t->tv.tv_sec, t->utc_offset, & tm);
  *ret = strm_int_value(tm.tm_wday);
  return (0);
}
}
static int time_nanosec(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_value time___0 ;
  struct strm_time *t ;
  int tmp ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "v", & time___0);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  t = get_time(time___0);
  *ret = strm_int_value((strm_int )(t->tv.tv_usec * 1000L));
  return (0);
}
}
void strm_time_init(strm_state *state )
{
  strm_value tmp ;
  strm_value tmp___0 ;
  strm_value tmp___1 ;
  strm_value tmp___2 ;
  strm_value tmp___3 ;
  strm_value tmp___4 ;
  strm_value tmp___5 ;
  strm_value tmp___6 ;
  strm_value tmp___7 ;
  strm_value tmp___8 ;
  strm_value tmp___9 ;
  strm_value tmp___10 ;
  strm_value tmp___11 ;
  strm_value tmp___12 ;

  {
  tmp = strm_cfunc_value(& time_now);
  strm_var_def(state, "now", tmp);
  tmp___0 = strm_cfunc_value(& time_time);
  strm_var_def(state, "time", tmp___0);
  ns_time = strm_ns_new((strm_state *)((void *)0), "time");
  tmp___1 = strm_cfunc_value(& time_plus);
  strm_var_def(ns_time, "+", tmp___1);
  tmp___2 = strm_cfunc_value(& time_minus);
  strm_var_def(ns_time, "-", tmp___2);
  tmp___3 = strm_cfunc_value(& time_str);
  strm_var_def(ns_time, "string", tmp___3);
  tmp___4 = strm_cfunc_value(& time_num);
  strm_var_def(ns_time, "number", tmp___4);
  tmp___5 = strm_cfunc_value(& time_year);
  strm_var_def(ns_time, "year", tmp___5);
  tmp___6 = strm_cfunc_value(& time_month);
  strm_var_def(ns_time, "month", tmp___6);
  tmp___7 = strm_cfunc_value(& time_day);
  strm_var_def(ns_time, "day", tmp___7);
  tmp___8 = strm_cfunc_value(& time_hour);
  strm_var_def(ns_time, "hour", tmp___8);
  tmp___9 = strm_cfunc_value(& time_min);
  strm_var_def(ns_time, "minute", tmp___9);
  tmp___10 = strm_cfunc_value(& time_sec);
  strm_var_def(ns_time, "second", tmp___10);
  tmp___11 = strm_cfunc_value(& time_nanosec);
  strm_var_def(ns_time, "nanosecond", tmp___11);
  tmp___12 = strm_cfunc_value(& time_weekday);
  strm_var_def(ns_time, "weekday", tmp___12);
  return;
}
}
#pragma merger("0","/tmp/cil-IfftU7Z7.i","-std=gnu99,-g,-ggdb,-Wall")
struct strm_queue *strm_queue_new(void) ;
int strm_queue_add(struct strm_queue *q , void *val ) ;
void *strm_queue_get(struct strm_queue *q ) ;
void strm_queue_free(struct strm_queue *q ) ;
int strm_queue_empty_p(struct strm_queue *q ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
struct strm_queue *strm_queue_new(void)
{
  struct strm_queue *q ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct strm_queue ));
  q = (struct strm_queue *)tmp;
  if ((unsigned long )q == (unsigned long )((void *)0)) {
    return ((struct strm_queue *)((void *)0));
  }
  q->head = (struct strm_queue_node *)((void *)0);
  q->tail = (struct strm_queue_node *)((void *)0);
  pthread_mutex_init(& q->mutex, (pthread_mutexattr_t const   *)((void *)0));
  return (q);
}
}
int strm_queue_add(struct strm_queue *q , void *val )
{
  struct strm_queue_node *node ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct strm_queue_node ));
  node = (struct strm_queue_node *)tmp;
  if ((unsigned long )node == (unsigned long )((void *)0)) {
    return (0);
  }
  node->n = val;
  node->next = (struct strm_queue_node *)((void *)0);
  pthread_mutex_lock(& q->mutex);
  if (q->tail) {
    (q->tail)->next = node;
  }
  q->tail = node;
  if (! q->head) {
    q->head = node;
  }
  pthread_mutex_unlock(& q->mutex);
  return (1);
}
}
void *strm_queue_get(struct strm_queue *q )
{
  struct strm_queue_node *t ;
  void *n ;

  {
  pthread_mutex_lock(& q->mutex);
  while (! q->head) {
    pthread_mutex_unlock(& q->mutex);
    return ((void *)0);
  }
  t = q->head;
  q->head = t->next;
  if ((unsigned long )q->head == (unsigned long )((void *)0)) {
    q->tail = (struct strm_queue_node *)((void *)0);
  }
  pthread_mutex_unlock(& q->mutex);
  n = t->n;
  free((void *)t);
  return (n);
}
}
void strm_queue_free(struct strm_queue *q )
{
  struct strm_queue_node *t ;
  struct strm_queue_node *tmp ;

  {
  if (! q) {
    return;
  }
  if (q->head) {
    t = q->head;
    while (t) {
      tmp = t->next;
      free((void *)t);
      t = tmp;
    }
  }
  pthread_mutex_destroy(& q->mutex);
  free((void *)q);
  return;
}
}
int strm_queue_empty_p(struct strm_queue *q )
{


  {
  if ((unsigned long )q->head == (unsigned long )((void *)0)) {
    return (1);
  }
  return (0);
}
}
#pragma merger("0","/tmp/cil-yIVCfI5f.i","-std=gnu99,-g,-ggdb,-Wall")
#pragma merger("0","/tmp/cil-YlsQ_bBr.i","-std=gnu99,-g,-ggdb,-Wall")
void strm_number_init(strm_state *state ) ;
void strm_array_init(strm_state *state ) ;
void strm_string_init(strm_state *state ) ;
void strm_latch_init(strm_state *state ) ;
void strm_socket_init(strm_state *state ) ;
void strm_csv_init(strm_state *state ) ;
void strm_kvs_init(strm_state *state ) ;
void strm_math_init(strm_state *state ) ;
void strm_graph_init(strm_state *state ) ;
void strm_init(strm_state *state )
{


  {
  strm_number_init(state);
  strm_array_init(state);
  strm_string_init(state);
  strm_latch_init(state);
  strm_iter_init(state);
  strm_socket_init(state);
  strm_csv_init(state);
  strm_kvs_init(state);
  strm_time_init(state);
  strm_math_init(state);
  strm_graph_init(state);
  return;
}
}
#pragma merger("0","/tmp/cil-GaFIm8Nr.i","-std=gnu99,-g,-ggdb,-Wall")
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format
                                                 , ...) ;
strm_string strm_str_static(char const   *p , strm_int len ) ;
strm_string strm_str_intern_static(char const   *p , strm_int len ) ;
int strm_ary_eq(strm_array a , strm_array b ) ;
strm_string strm_ns_name(strm_state *state ) ;
strm_state *strm_ns_string ;
strm_state *strm_ns_number ;
strm_value strm_ptr_value(void *p )
{


  {
  return (18445899648779419648 | ((strm_value )((intptr_t )p) & ~ (65535UL << 48)));
}
}
strm_value strm_cfunc_value(int (*f)(struct strm_stream * , int  , strm_value * ,
                                     strm_value * ) )
{


  {
  return (18445336698825998336 | ((strm_value )((intptr_t )f) & ~ (65535UL << 48)));
}
}
strm_value strm_bool_value(int i )
{


  {
  return (18442521949058891776 | (unsigned long )(! (! i)));
}
}
strm_value strm_int_value(int i )
{


  {
  return (18442803424035602432 | ((uint64_t )i & ~ (65535UL << 48)));
}
}
extern int ( /* missing proto */  __builtin_isnan)() ;
strm_value strm_float_value(double f )
{
  union __anonunion_u_274369385 u ;
  int tmp ;

  {
  tmp = __builtin_isnan(f);
  if (tmp) {
    return (18442240474082181120);
  }
  u.f = f;
  return (u.i);
}
}
strm_value strm_foreign_value(void *p )
{


  {
  return (18446462598732840960 | ((strm_value )((intptr_t )p) & ~ (65535UL << 48)));
}
}
static void *strm_ptr(strm_value v )
{


  {
  return ((void *)((intptr_t )(v & ~ (65535UL << 48))));
}
}
static enum strm_ptr_type strm_ptr_type(void *p )
{
  struct object *obj ;

  {
  obj = (struct object *)p;
  return (obj->type);
}
}
void *strm_value_ptr(strm_value v , enum strm_ptr_type e )
{
  void *p ;
  enum strm_ptr_type tmp___3 ;

  {
  if (! ((v & (65535UL << 48)) == 18445899648779419648)) {
    __assert_fail("strm_value_tag(v) == STRM_TAG_PTR", "value.c", 72U, "strm_value_ptr");
  }
  p = strm_ptr(v);
  if (p) {
    tmp___3 = strm_ptr_type(p);
    if (! ((unsigned int )tmp___3 == (unsigned int )e)) {
      __assert_fail("p && strm_ptr_type(p) == e", "value.c", 74U, "strm_value_ptr");
    }
  } else {
    __assert_fail("p && strm_ptr_type(p) == e", "value.c", 74U, "strm_value_ptr");
  }
  return (p);
}
}
void *strm_value_foreign(strm_value v )
{
  void *tmp___0 ;

  {
  if (! ((v & (65535UL << 48)) == 18446462598732840960)) {
    __assert_fail("strm_value_tag(v) == STRM_TAG_FOREIGN", "value.c", 81U, "strm_value_foreign");
  }
  tmp___0 = strm_ptr(v);
  return (tmp___0);
}
}
int strm_value_bool(strm_value v )
{
  uint64_t i ;

  {
  i = v & ~ (65535UL << 48);
  if (i == 0UL) {
    switch (v & (65535UL << 48)) {
    case 18445899648779419648:
    case 18442521949058891776:
    break;
    default:
    if (! ((v & (65535UL << 48)) == 18442521949058891776)) {
      __assert_fail("strm_value_tag(v) == STRM_TAG_BOOL", "value.c", 96U, "strm_value_bool");
    }
    break;
    }
    return (0);
  } else {
    return (1);
  }
}
}
int strm_int_p(strm_value v )
{


  {
  return ((v & (65535UL << 48)) == 18442803424035602432);
}
}
__inline static int32_t strm_to_int(strm_value v )
{


  {
  return ((int32_t )(v & ~ (65535UL << 48)));
}
}
int strm_float_p(strm_value v )
{
  int tmp ;

  {
  if (v == 18442240474082181120) {
    tmp = 1;
  } else
  if ((v & 18442240474082181120) != 18442240474082181120) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
__inline static double strm_to_float(strm_value v )
{
  union __anonunion_u_274369386 u ;

  {
  u.i = v;
  return (u.f);
}
}
int strm_value_int(strm_value v )
{
  int32_t tmp ;
  double tmp___0 ;
  int tmp___1 ;

  {
  switch (v & (65535UL << 48)) {
  case 18442803424035602432:
  tmp = strm_to_int(v);
  return (tmp);
  default:
  tmp___1 = strm_float_p(v);
  if (tmp___1) {
    tmp___0 = strm_to_float(v);
    return ((int )tmp___0);
  }
  if (! ((v & (65535UL << 48)) == 18442803424035602432)) {
    __assert_fail("strm_value_tag(v) == STRM_TAG_INT", "value.c", 146U, "strm_value_int");
  }
  break;
  }
  return (0);
}
}
double strm_value_float(strm_value v )
{
  int32_t tmp ;
  double tmp___0 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  tmp___6 = strm_int_p(v);
  if (tmp___6) {
    tmp = strm_to_int(v);
    return ((double )tmp);
  } else {
    tmp___5 = strm_float_p(v);
    if (tmp___5) {
      tmp___0 = strm_to_float(v);
      return (tmp___0);
    } else {
      tmp___4 = strm_float_p(v);
      if (! tmp___4) {
        __assert_fail("strm_float_p(v)", "value.c", 164U, "strm_value_float");
      }
    }
  }
  return (0.0);
}
}
strm_cfunc strm_value_cfunc(strm_value v )
{


  {
  if (! ((v & (65535UL << 48)) == 18445336698825998336)) {
    __assert_fail("strm_value_tag(v) == STRM_TAG_CFUNC", "value.c", 173U, "strm_value_cfunc");
  }
  return ((int (*)(struct strm_stream * , int  , strm_value * , strm_value * ))((intptr_t )(v & ~ (65535UL << 48))));
}
}
int strm_number_p(strm_value v )
{
  int tmp ;
  int tmp___0 ;

  {
  tmp = strm_int_p(v);
  if (tmp) {
    return (1);
  } else {
    tmp___0 = strm_float_p(v);
    if (tmp___0) {
      return (1);
    } else {
      return (0);
    }
  }
}
}
int strm_bool_p(strm_value v )
{
  int tmp ;

  {
  if ((v & (65535UL << 48)) == 18442521949058891776) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
int strm_nil_p(strm_value v )
{


  {
  if ((v & (65535UL << 48)) != 18445899648779419648) {
    return (0);
  }
  return ((v & ~ (65535UL << 48)) == 0UL);
}
}
int strm_cfunc_p(strm_value v )
{


  {
  return ((v & (65535UL << 48)) == 18445336698825998336);
}
}
int strm_ptr_tag_p(strm_value v , enum strm_ptr_type e )
{
  void *p ;
  void *tmp ;
  enum strm_ptr_type tmp___0 ;

  {
  if ((v & (65535UL << 48)) == 18445899648779419648) {
    tmp = strm_ptr(v);
    p = tmp;
    tmp___0 = strm_ptr_type(p);
    return ((unsigned int )tmp___0 == (unsigned int )e);
  }
  return (0);
}
}
int strm_value_eq(strm_value a , strm_value b )
{
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  if (a == b) {
    return (1);
  }
  if ((a & (65535UL << 48)) != (b & (65535UL << 48))) {
    goto typediff;
  }
  switch (a & (65535UL << 48)) {
  case 18443647848965734400:
  case 18443366373989023744:
  tmp = strm_ary_eq(a, b);
  return (tmp);
  case 18445055223849287680:
  case 18444773748872577024:
  tmp___0 = strm_str_eq(a, b);
  return (tmp___0);
  case 18445336698825998336:
  return ((unsigned long )((int (*)(struct strm_stream * , int  , strm_value * , strm_value * ))((intptr_t )(a & ~ (65535UL << 48)))) == (unsigned long )((int (*)(struct strm_stream * ,
                                                                                                                                                                   int  ,
                                                                                                                                                                   strm_value * ,
                                                                                                                                                                   strm_value * ))((intptr_t )(b & ~ (65535UL << 48)))));
  case 18445899648779419648:
  return ((unsigned long )((void *)((intptr_t )(a & ~ (65535UL << 48)))) == (unsigned long )((void *)((intptr_t )(b & ~ (65535UL << 48)))));
  typediff:
  default:
  tmp___3 = strm_number_p(a);
  if (tmp___3) {
    tmp___4 = strm_number_p(b);
    if (tmp___4) {
      tmp___1 = strm_value_float(a);
      tmp___2 = strm_value_float(b);
      return (tmp___1 == tmp___2);
    }
  }
  return (0);
  }
}
}
static int str_symbol_p(strm_string str )
{
  char const   *p ;
  char const   *tmp ;
  char const   *pend ;
  strm_int tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  tmp = strm_strp_ptr(& str);
  p = tmp;
  tmp___0 = strm_str_len(str);
  pend = p + tmp___0;
  tmp___1 = __ctype_b_loc();
  if (! ((int const   )*(*tmp___1 + (int )*p) & 1024)) {
    if ((int const   )*p != 95) {
      return (0);
    }
  }
  p ++;
  while ((unsigned long )p < (unsigned long )pend) {
    tmp___2 = __ctype_b_loc();
    if (! ((int const   )*(*tmp___2 + (int )*p) & 8)) {
      if ((int const   )*p != 95) {
        return (0);
      }
    }
    p ++;
  }
  return (1);
}
}
static strm_int str_dump_len(strm_string str )
{
  strm_int len ;
  unsigned char const   *p ;
  char const   *tmp ;
  unsigned char const   *pend ;
  strm_int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  len = 2;
  tmp = strm_strp_ptr(& str);
  p = (unsigned char const   *)((unsigned char *)tmp);
  tmp___0 = strm_str_len(str);
  pend = p + tmp___0;
  while ((unsigned long )p < (unsigned long )pend) {
    switch ((int const   )*p) {
    case 34:
    case 9:
    case 13:
    case 10:
    len += 2;
    break;
    default:
    tmp___1 = __ctype_b_loc();
    if ((int const   )*(*tmp___1 + (int )*p) & 16384) {
      len ++;
    } else
    if (((int const   )*p & 255) > 127) {
      len ++;
    } else {
      len += 3;
    }
    }
    p ++;
  }
  return (len);
}
}
static strm_string str_dump(strm_string str , strm_int len )
{
  char *buf ;
  void *tmp ;
  char *s ;
  char *p ;
  char const   *tmp___0 ;
  char *pend ;
  strm_int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  unsigned short const   **tmp___16 ;
  char *tmp___17 ;
  strm_string tmp___18 ;

  {
  tmp = malloc((size_t )len);
  buf = (char *)tmp;
  s = buf;
  tmp___0 = strm_strp_ptr(& str);
  p = (char *)tmp___0;
  tmp___1 = strm_str_len(str);
  pend = p + tmp___1;
  tmp___2 = s;
  s ++;
  *tmp___2 = (char )'\"';
  while ((unsigned long )p < (unsigned long )pend) {
    switch ((int )*p) {
    case 10:
    tmp___3 = s;
    s ++;
    *tmp___3 = (char )'\\';
    tmp___4 = s;
    s ++;
    *tmp___4 = (char )'n';
    break;
    case 13:
    tmp___5 = s;
    s ++;
    *tmp___5 = (char )'\\';
    tmp___6 = s;
    s ++;
    *tmp___6 = (char )'r';
    break;
    case 9:
    tmp___7 = s;
    s ++;
    *tmp___7 = (char )'\\';
    tmp___8 = s;
    s ++;
    *tmp___8 = (char )'t';
    break;
    case 27:
    tmp___9 = s;
    s ++;
    *tmp___9 = (char )'\\';
    tmp___10 = s;
    s ++;
    *tmp___10 = (char )'e';
    break;
    case 0:
    tmp___11 = s;
    s ++;
    *tmp___11 = (char )'\\';
    tmp___12 = s;
    s ++;
    *tmp___12 = (char )'0';
    break;
    case 34:
    tmp___13 = s;
    s ++;
    *tmp___13 = (char )'\\';
    tmp___14 = s;
    s ++;
    *tmp___14 = (char )'\"';
    break;
    default:
    tmp___16 = __ctype_b_loc();
    if ((int const   )*(*tmp___16 + (int )*p) & 16384) {
      tmp___15 = s;
      s ++;
      *tmp___15 = (char )((int )*p & 255);
    } else
    if (((int )*p & 255) > 127) {
      tmp___15 = s;
      s ++;
      *tmp___15 = (char )((int )*p & 255);
    } else {
      sprintf((char * __restrict  )s, (char const   * __restrict  )"\\x%02x", (int )*p & 255);
      s += 4;
    }
    }
    p ++;
  }
  tmp___17 = s;
  s ++;
  *tmp___17 = (char )'\"';
  tmp___18 = strm_str_new((char const   *)buf, len);
  return (tmp___18);
}
}
strm_string strm_inspect(strm_value v )
{
  strm_string str ;
  strm_int tmp ;
  strm_string tmp___0 ;
  strm_state *ns ;
  struct strm_array *tmp___1 ;
  char *buf ;
  void *tmp___2 ;
  strm_int i ;
  strm_int bi ;
  strm_int capa ;
  strm_array a ;
  strm_int tmp___3 ;
  strm_string name ;
  strm_string tmp___4 ;
  strm_int nlen ;
  strm_int tmp___5 ;
  strm_int tmp___6 ;
  char *p ;
  void *tmp___7 ;
  char const   *tmp___8 ;
  strm_int tmp___9 ;
  struct strm_array *tmp___10 ;
  strm_string str___0 ;
  struct strm_array *tmp___11 ;
  strm_string tmp___12 ;
  strm_string key ;
  struct strm_array *tmp___17 ;
  struct strm_array *tmp___18 ;
  strm_string tmp___19 ;
  struct strm_array *tmp___20 ;
  struct strm_array *tmp___21 ;
  struct strm_array *tmp___22 ;
  int tmp___23 ;
  strm_int slen ;
  strm_int tmp___24 ;
  strm_int tmp___25 ;
  strm_int tmp___26 ;
  void *tmp___27 ;
  strm_int tmp___28 ;
  strm_int tmp___29 ;
  strm_int tmp___30 ;
  int tmp___31 ;
  strm_int tmp___32 ;
  char const   *tmp___33 ;
  strm_int tmp___34 ;
  strm_int tmp___35 ;
  strm_int tmp___36 ;
  char const   *tmp___37 ;
  strm_int tmp___38 ;
  struct strm_array *tmp___39 ;
  strm_int tmp___40 ;
  strm_string tmp___41 ;
  strm_string tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;

  {
  tmp___44 = strm_string_p(v);
  if (tmp___44) {
    str = v;
    tmp = str_dump_len(str);
    tmp___0 = str_dump(str, tmp);
    return (tmp___0);
  } else {
    tmp___43 = strm_array_p(v);
    if (tmp___43) {
      tmp___1 = strm_ary_struct(v);
      ns = tmp___1->ns;
      tmp___2 = malloc((size_t )32);
      buf = (char *)tmp___2;
      bi = 0;
      capa = 32;
      a = v;
      if ((unsigned long )buf == (unsigned long )((void *)0)) {
        return ((strm_string )1);
      }
      tmp___3 = bi;
      bi ++;
      *(buf + tmp___3) = (char )'[';
      if (ns) {
        tmp___4 = strm_ns_name(ns);
        name = tmp___4;
        tmp___5 = strm_str_len(name);
        nlen = tmp___5;
        if (name != 0UL) {
          tmp___6 = bi;
          bi ++;
          *(buf + tmp___6) = (char )'@';
          if ((bi + nlen) + 2 > capa) {
            capa *= 2;
            tmp___7 = realloc((void *)buf, (size_t )capa);
            p = (char *)tmp___7;
            if ((unsigned long )p == (unsigned long )((void *)0)) {
              free((void *)buf);
              return ((strm_string )1);
            }
            buf = p;
          }
          tmp___8 = strm_strp_ptr(& name);
          memcpy((void * __restrict  )(buf + bi), (void const   * __restrict  )tmp___8,
                 (size_t )nlen);
          bi += nlen;
          tmp___10 = strm_ary_struct(a);
          if (tmp___10->len > 0) {
            tmp___9 = bi;
            bi ++;
            *(buf + tmp___9) = (char )' ';
          }
        }
      }
      i = 0;
      while (1) {
        tmp___39 = strm_ary_struct(a);
        if (! (i < tmp___39->len)) {
          break;
        }
        tmp___11 = strm_ary_struct(a);
        tmp___12 = strm_inspect(*(tmp___11->ptr + i));
        str___0 = tmp___12;
        tmp___20 = strm_ary_struct(a);
        if (tmp___20->headers) {
          tmp___21 = strm_ary_struct(a);
          tmp___22 = strm_ary_struct(tmp___21->headers);
          tmp___23 = strm_string_p(*(tmp___22->ptr + i));
          if (tmp___23) {
            tmp___17 = strm_ary_struct(a);
            tmp___18 = strm_ary_struct(tmp___17->headers);
            tmp___19 = *(tmp___18->ptr + i);
          } else {
            tmp___19 = (strm_string )0;
          }
        } else {
          tmp___19 = (strm_string )0;
        }
        key = tmp___19;
        if (key) {
          tmp___24 = strm_str_len(key);
          tmp___25 = tmp___24 + 1;
        } else {
          tmp___25 = 0;
        }
        tmp___26 = strm_str_len(str___0);
        slen = (tmp___25 + tmp___26) + 3;
        if (bi + slen > capa) {
          capa *= 2;
          tmp___27 = realloc((void *)buf, (size_t )capa);
          buf = (char *)tmp___27;
        }
        if (i > 0) {
          tmp___28 = bi;
          bi ++;
          *(buf + tmp___28) = (char )',';
          tmp___29 = bi;
          bi ++;
          *(buf + tmp___29) = (char )' ';
        }
        if (key) {
          tmp___31 = str_symbol_p(key);
          if (! tmp___31) {
            tmp___30 = str_dump_len(key);
            key = str_dump(key, tmp___30);
          }
          tmp___32 = strm_str_len(key);
          tmp___33 = strm_strp_ptr(& key);
          memcpy((void * __restrict  )(buf + bi), (void const   * __restrict  )tmp___33,
                 (size_t )tmp___32);
          tmp___34 = strm_str_len(key);
          bi += tmp___34;
          tmp___35 = bi;
          bi ++;
          *(buf + tmp___35) = (char )':';
        }
        tmp___36 = strm_str_len(str___0);
        tmp___37 = strm_strp_ptr(& str___0);
        memcpy((void * __restrict  )(buf + bi), (void const   * __restrict  )tmp___37,
               (size_t )tmp___36);
        tmp___38 = strm_str_len(str___0);
        bi += tmp___38;
        i ++;
      }
      tmp___40 = bi;
      bi ++;
      *(buf + tmp___40) = (char )']';
      tmp___41 = strm_str_new((char const   *)buf, bi);
      return (tmp___41);
    } else {
      tmp___42 = strm_to_str(v);
      return (tmp___42);
    }
  }
}
}
strm_string strm_to_str(strm_value v )
{
  char buf[32] ;
  int n ;
  strm_state *ns ;
  strm_state *tmp ;
  strm_value m ;
  strm_string tmp___0 ;
  int tmp___1 ;
  int32_t tmp___2 ;
  strm_string tmp___3 ;
  char const   *tmp___5 ;
  int32_t tmp___6 ;
  strm_string tmp___7 ;
  strm_cfunc tmp___8 ;
  strm_string tmp___9 ;
  strm_string tmp___10 ;
  strm_string tmp___11 ;
  void *p ;
  void *tmp___12 ;
  enum strm_ptr_type tmp___13 ;
  strm_io io ;
  char *mode ;
  char fbuf[7] ;
  struct strm_genfunc *gf ;
  char const   *tmp___14 ;
  strm_string tmp___15 ;
  double tmp___16 ;
  strm_string tmp___17 ;
  int tmp___18 ;
  strm_string tmp___19 ;

  {
  tmp = strm_value_ns(v);
  ns = tmp;
  if (ns) {
    tmp___0 = strm_str_intern_static("string", (strm_int )(sizeof("string") - 1UL));
    n = strm_var_get(ns, tmp___0, & m);
    if (n == 0) {
      n = strm_funcall((strm_stream *)((void *)0), m, 1, & v, & m);
      if (n == 0) {
        tmp___1 = strm_string_p(m);
        if (tmp___1) {
          return (m);
        }
      }
    }
  }
  switch (v & (65535UL << 48)) {
  case 18442803424035602432:
  tmp___2 = strm_to_int(v);
  n = sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", tmp___2);
  tmp___3 = strm_str_new((char const   *)(buf), n);
  return (tmp___3);
  case 18442521949058891776:
  tmp___6 = strm_to_int(v);
  if (tmp___6) {
    tmp___5 = "true";
  } else {
    tmp___5 = "false";
  }
  n = sprintf((char * __restrict  )(buf), (char const   * __restrict  )tmp___5);
  tmp___7 = strm_str_new((char const   *)(buf), n);
  return (tmp___7);
  case 18445336698825998336:
  tmp___8 = strm_value_cfunc(v);
  n = sprintf((char * __restrict  )(buf), (char const   * __restrict  )"<cfunc:%p>",
              (void *)tmp___8);
  tmp___9 = strm_str_new((char const   *)(buf), n);
  return (tmp___9);
  case 18445055223849287680:
  case 18444773748872577024:
  case 18444492273895866368:
  case 18444210798919155712:
  return (v);
  case 18443647848965734400:
  case 18443366373989023744:
  tmp___10 = strm_inspect(v);
  return (tmp___10);
  case 18445899648779419648:
  if ((v & ~ (65535UL << 48)) == 0UL) {
    tmp___11 = strm_str_static("nil", (strm_int )(sizeof("nil") - 1UL));
    return (tmp___11);
  } else {
    tmp___12 = strm_ptr(v);
    p = tmp___12;
    tmp___13 = strm_ptr_type(p);
    switch ((unsigned int )tmp___13) {
    case 0U:
    n = sprintf((char * __restrict  )(buf), (char const   * __restrict  )"<stream:%p>",
                p);
    break;
    case 3U:
    io = (strm_io )p;
    switch (io->mode & 3) {
    case 1:
    mode = (char *)"r";
    break;
    case 2:
    mode = (char *)"w";
    break;
    case 3:
    mode = (char *)"rw";
    break;
    default:
    mode = (char *)"?";
    break;
    }
    n = sprintf((char * __restrict  )(buf), (char const   * __restrict  )"<io: fd=%d mode=%s>",
                io->fd, mode);
    break;
    case 1U:
    n = sprintf((char * __restrict  )(buf), (char const   * __restrict  )"<lambda:%p>",
                p);
    break;
    case 2U:
    gf = (struct strm_genfunc *)p;
    tmp___14 = strm_str_cstr(gf->id, fbuf);
    n = sprintf((char * __restrict  )(buf), (char const   * __restrict  )"<genfunc:&%s>",
                tmp___14);
    break;
    case 4U:
    n = sprintf((char * __restrict  )(buf), (char const   * __restrict  )"<obj:%p>",
                p);
    break;
    }
    tmp___15 = strm_str_new((char const   *)(buf), n);
    return (tmp___15);
  }
  default:
  tmp___18 = strm_float_p(v);
  if (tmp___18) {
    tmp___16 = strm_to_float(v);
    n = sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%.14g",
                tmp___16);
    tmp___17 = strm_str_new((char const   *)(buf), n);
    return (tmp___17);
  }
  n = sprintf((char * __restrict  )(buf), (char const   * __restrict  )"<%p>", (void *)((intptr_t )(v & ~ (65535UL << 48))));
  tmp___19 = strm_str_new((char const   *)(buf), n);
  return (tmp___19);
  }
  return ((strm_string )0);
}
}
char const   *strm_p(strm_value val )
{
  char buf[7] ;
  strm_string str ;
  strm_string tmp ;
  char const   *p ;
  char const   *tmp___0 ;

  {
  tmp = strm_to_str(val);
  str = tmp;
  tmp___0 = strm_str_cstr(str, buf);
  p = tmp___0;
  fputs((char const   * __restrict  )p, (FILE * __restrict  )stdout);
  fputs((char const   * __restrict  )"\n", (FILE * __restrict  )stdout);
  return (p);
}
}
strm_value strm_nil_value(void)
{


  {
  return (18445899648779419648);
}
}
strm_state *strm_value_ns(strm_value val )
{
  strm_state *ns ;
  struct strm_array *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct strm_misc *p ;
  void *tmp___3 ;
  enum strm_ptr_type tmp___4 ;

  {
  tmp___0 = strm_array_p(val);
  if (tmp___0) {
    tmp = strm_ary_struct(val);
    ns = tmp->ns;
    if (ns) {
      return (ns);
    }
    return (strm_ns_array);
  }
  tmp___1 = strm_string_p(val);
  if (tmp___1) {
    return (strm_ns_string);
  }
  tmp___2 = strm_number_p(val);
  if (tmp___2) {
    return (strm_ns_number);
  }
  if ((val & (65535UL << 48)) == 18445899648779419648) {
    tmp___3 = strm_ptr(val);
    p = (struct strm_misc *)tmp___3;
    if (! p) {
      return ((strm_state *)((void *)0));
    }
    tmp___4 = strm_ptr_type((void *)p);
    if ((unsigned int )tmp___4 == 4U) {
      return (p->ns);
    }
  }
  return ((strm_state *)((void *)0));
}
}
#pragma merger("0","/tmp/cil-o0gEpLbU.i","-std=gnu99,-g,-ggdb,-Wall")
int strm_latch_finish_p(strm_stream *latch )
{
  struct latch_data *c ;
  int tmp ;

  {
  if ((unsigned int )latch->mode == 2U) {
    return (0);
  }
  c = (struct latch_data *)latch->data;
  tmp = strm_queue_empty_p(c->dq);
  return (tmp);
}
}
static int latch_push(strm_stream *strm , strm_value data )
{
  struct latch_data *d ;
  struct recv_data *r ;
  void *tmp ;
  strm_value *v ;
  void *tmp___0 ;

  {
  d = (struct latch_data *)strm->data;
  tmp = strm_queue_get(d->rq);
  r = (struct recv_data *)tmp;
  if ((unsigned int )strm->mode != 2U) {
    return (1);
  }
  if (r) {
    (*(r->func))(r->strm, data);
    free((void *)r);
  } else {
    tmp___0 = malloc(sizeof(strm_value ));
    v = (strm_value *)tmp___0;
    *v = data;
    strm_queue_add(d->dq, (void *)v);
  }
  return (0);
}
}
void strm_latch_receive(strm_stream *latch , strm_stream *strm , int (*func)(strm_stream * ,
                                                                             strm_value  ) )
{
  struct latch_data *d ;
  strm_value *v ;
  void *tmp___0 ;
  struct recv_data *r ;
  void *tmp___1 ;

  {
  if (! ((unsigned long )latch->start_func == (unsigned long )(& latch_push))) {
    __assert_fail("latch->start_func == latch_push", "latch.c", 53U, "strm_latch_receive");
  }
  d = (struct latch_data *)latch->data;
  tmp___0 = strm_queue_get(d->dq);
  v = (strm_value *)tmp___0;
  if (v) {
    (*func)(strm, *v);
    free((void *)v);
  } else {
    tmp___1 = malloc(sizeof(struct recv_data ));
    r = (struct recv_data *)tmp___1;
    r->strm = strm;
    r->func = func;
    strm_queue_add(d->rq, (void *)r);
  }
  return;
}
}
static int latch_close(strm_stream *strm , strm_value data )
{
  struct latch_data *d ;
  struct recv_data *r ;
  void *tmp ;

  {
  d = (struct latch_data *)strm->data;
  while (1) {
    tmp = strm_queue_get(d->rq);
    r = (struct recv_data *)tmp;
    if (! r) {
      break;
    }
    (*(r->func))(r->strm, data);
    free((void *)r);
  }
  return (0);
}
}
strm_stream *strm_latch_new(void)
{
  struct latch_data *d ;
  void *tmp ;
  strm_stream *tmp___1 ;

  {
  tmp = malloc(sizeof(struct latch_data ));
  d = (struct latch_data *)tmp;
  if (! ((unsigned long )d != (unsigned long )((void *)0))) {
    __assert_fail("d != NULL", "latch.c", 87U, "strm_latch_new");
  }
  d->dq = strm_queue_new();
  d->rq = strm_queue_new();
  tmp___1 = strm_stream_new((strm_stream_mode )2, & latch_push, & latch_close, (void *)d);
  return (tmp___1);
}
}
static int zip_start(strm_stream *strm , strm_value data ) ;
static int zip_iter(strm_stream *strm , strm_value data )
{
  struct zip_data *z ;
  struct strm_array *tmp ;
  strm_int tmp___0 ;
  strm_int i ;
  strm_int done ;
  int tmp___1 ;

  {
  z = (struct zip_data *)strm->data;
  tmp = strm_ary_struct(z->a);
  tmp___0 = z->i;
  (z->i) ++;
  *(tmp->ptr + tmp___0) = data;
  if (z->i < z->len) {
    strm_latch_receive(z->latch[z->i], strm, & zip_iter);
  } else {
    done = 0;
    i = 0;
    while (i < z->len) {
      tmp___1 = strm_latch_finish_p(z->latch[i]);
      if (tmp___1) {
        done = 1;
        break;
      }
      i ++;
    }
    if (done) {
      strm_emit(strm, z->a, (int (*)(strm_stream * , strm_value  ))((void *)0));
      i = 0;
      while (i < z->len) {
        strm_stream_close(z->latch[i]);
        i ++;
      }
      strm_stream_close(strm);
    } else {
      strm_emit(strm, z->a, & zip_start);
    }
  }
  return (0);
}
}
static int zip_start(strm_stream *strm , strm_value data )
{
  struct zip_data *z ;

  {
  z = (struct zip_data *)strm->data;
  if (z) {
    z->i = 0;
    z->a = strm_ary_new((strm_value const   *)((void *)0), z->len);
    strm_latch_receive(z->latch[0], strm, & zip_iter);
  }
  return (0);
}
}
static int zip_close(strm_stream *strm , strm_value data )
{


  {
  strm->data = (void *)0;
  return (0);
}
}
static int exec_zip(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  struct zip_data *z ;
  void *tmp ;
  strm_int i ;
  strm_stream *s ;
  strm_value r ;
  strm_value tmp___0 ;
  strm_stream *tmp___1 ;

  {
  tmp = malloc(sizeof(struct zip_data ) + sizeof(strm_stream *) * (unsigned long )argc);
  z = (struct zip_data *)tmp;
  z->i = 0;
  z->len = argc;
  i = 0;
  while (i < argc) {
    s = strm_latch_new();
    tmp___0 = strm_ptr_value((void *)s);
    strm_connect(strm, *(args + i), tmp___0, & r);
    z->latch[i] = s;
    i ++;
  }
  tmp___1 = strm_stream_new((strm_stream_mode )0, & zip_start, & zip_close, (void *)z);
  *ret = strm_ptr_value((void *)tmp___1);
  return (0);
}
}
static int concat_iter(strm_stream *strm , strm_value data )
{
  struct concat_data *d ;
  int tmp ;

  {
  d = (struct concat_data *)strm->data;
  strm_emit(strm, data, (int (*)(strm_stream * , strm_value  ))((void *)0));
  tmp = strm_latch_finish_p(d->latch[d->i]);
  if (tmp) {
    strm_stream_close(d->latch[d->i]);
    (d->i) ++;
  }
  if (d->i < d->len) {
    strm_latch_receive(d->latch[d->i], strm, & concat_iter);
  } else {
    strm_stream_close(strm);
  }
  return (0);
}
}
static int concat_start(strm_stream *strm , strm_value data )
{
  struct concat_data *d ;

  {
  d = (struct concat_data *)strm->data;
  if (d) {
    strm_latch_receive(d->latch[d->i], strm, & concat_iter);
  }
  return (0);
}
}
static int exec_concat(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  struct concat_data *d ;
  void *tmp ;
  strm_int i ;
  strm_stream *s ;
  strm_value r ;
  strm_value tmp___0 ;
  strm_stream *tmp___1 ;

  {
  tmp = malloc(sizeof(struct concat_data ) + sizeof(strm_stream *) * (unsigned long )argc);
  d = (struct concat_data *)tmp;
  d->i = 0;
  d->len = argc;
  i = 0;
  while (i < argc) {
    s = strm_latch_new();
    tmp___0 = strm_ptr_value((void *)s);
    strm_connect(strm, *(args + i), tmp___0, & r);
    d->latch[i] = s;
    i ++;
  }
  tmp___1 = strm_stream_new((strm_stream_mode )0, & concat_start, (int (*)(strm_stream * ,
                                                                           strm_value  ))((void *)0),
                            (void *)d);
  *ret = strm_ptr_value((void *)tmp___1);
  return (0);
}
}
void strm_latch_init(strm_state *state )
{
  strm_value tmp ;
  strm_value tmp___0 ;
  strm_value tmp___1 ;

  {
  tmp = strm_cfunc_value(& exec_zip);
  strm_var_def(state, "&", tmp);
  tmp___0 = strm_cfunc_value(& exec_zip);
  strm_var_def(state, "zip", tmp___0);
  tmp___1 = strm_cfunc_value(& exec_concat);
  strm_var_def(state, "concat", tmp___1);
  return;
}
}
#pragma merger("0","/tmp/cil-s1toyg6H.i","-std=gnu99,-g,-ggdb,-Wall")
strm_string strm_str_intern_str(strm_string str ) ;
int strm_str_intern_p(strm_string s ) ;
int strm_event_loop_started ;
static double const   khash_ac_HASH_UPPER___0  =    (double const   )0.77;
__inline static kh_env_t *kh_init_env(void)
{
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(kh_env_t ));
  return ((kh_env_t *)tmp);
}
}
__inline static khint_t kh_get_env(kh_env_t const   *h , khint64_t key )
{
  khint_t k ;
  khint_t i ;
  khint_t last ;
  khint_t mask ;
  khint_t step ;
  khint_t tmp ;

  {
  if (h->n_buckets) {
    step = (khint_t )0;
    mask = (khint_t )(h->n_buckets - 1U);
    k = (khint32_t )(((key >> 33) ^ key) ^ (key << 11));
    i = k & mask;
    last = i;
    while (1) {
      if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
        if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U)) {
          if (! (! (*(h->keys + i) == key))) {
            break;
          }
        }
      } else {
        break;
      }
      step ++;
      i = (i + step) & mask;
      if (i == last) {
        return ((khint_t )h->n_buckets);
      }
    }
    if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 3U) {
      tmp = h->n_buckets;
    } else {
      tmp = (khint_t const   )i;
    }
    return ((khint_t )tmp);
  } else {
    return ((khint_t )0);
  }
}
}
__inline static int kh_resize_env(kh_env_t *h , khint_t new_n_buckets )
{
  khint32_t *new_flags ;
  khint_t j ;
  khint_t tmp ;
  void *tmp___0 ;
  khint_t tmp___1 ;
  khint64_t *new_keys ;
  void *tmp___2 ;
  strm_value *new_vals ;
  void *tmp___3 ;
  khint64_t key ;
  strm_value val ;
  khint_t new_mask ;
  khint_t k ;
  khint_t i ;
  khint_t step ;
  khint64_t tmp___4 ;
  strm_value tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
  new_flags = (khint32_t *)0;
  j = (khint_t )1;
  new_n_buckets --;
  new_n_buckets |= new_n_buckets >> 1;
  new_n_buckets |= new_n_buckets >> 2;
  new_n_buckets |= new_n_buckets >> 4;
  new_n_buckets |= new_n_buckets >> 8;
  new_n_buckets |= new_n_buckets >> 16;
  new_n_buckets ++;
  if (new_n_buckets < 4U) {
    new_n_buckets = (khint_t )4;
  }
  if (h->size >= (khint_t )((double const   )new_n_buckets * khash_ac_HASH_UPPER___0 + (double const   )0.5)) {
    j = (khint_t )0;
  } else {
    if (new_n_buckets < 16U) {
      tmp = (khint_t )1;
    } else {
      tmp = new_n_buckets >> 4;
    }
    tmp___0 = malloc((unsigned long )tmp * sizeof(khint32_t ));
    new_flags = (khint32_t *)tmp___0;
    if (! new_flags) {
      return (-1);
    }
    if (new_n_buckets < 16U) {
      tmp___1 = (khint_t )1;
    } else {
      tmp___1 = new_n_buckets >> 4;
    }
    memset((void *)new_flags, 170, (unsigned long )tmp___1 * sizeof(khint32_t ));
    if (h->n_buckets < new_n_buckets) {
      tmp___2 = realloc((void *)h->keys, (unsigned long )new_n_buckets * sizeof(khint64_t ));
      new_keys = (khint64_t *)tmp___2;
      if (! new_keys) {
        free((void *)new_flags);
        return (-1);
      }
      h->keys = new_keys;
      tmp___3 = realloc((void *)h->vals, (unsigned long )new_n_buckets * sizeof(strm_value ));
      new_vals = (strm_value *)tmp___3;
      if (! new_vals) {
        free((void *)new_flags);
        return (-1);
      }
      h->vals = new_vals;
    }
  }
  if (j) {
    j = (khint_t )0;
    while (j != h->n_buckets) {
      if (((*(h->flags + (j >> 4)) >> ((j & 15U) << 1)) & 3U) == 0U) {
        key = *(h->keys + j);
        new_mask = new_n_buckets - 1U;
        val = *(h->vals + j);
        *(h->flags + (j >> 4)) = (khint32_t )((unsigned long )*(h->flags + (j >> 4)) | (1UL << ((j & 15U) << 1)));
        while (1) {
          step = (khint_t )0;
          k = (khint32_t )(((key >> 33) ^ key) ^ (key << 11));
          i = k & new_mask;
          while (! ((*(new_flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
            step ++;
            i = (i + step) & new_mask;
          }
          *(new_flags + (i >> 4)) = (khint32_t )((unsigned long )*(new_flags + (i >> 4)) & ~ (2UL << ((i & 15U) << 1)));
          if (i < h->n_buckets) {
            if (((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 3U) == 0U) {
              tmp___4 = *(h->keys + i);
              *(h->keys + i) = key;
              key = tmp___4;
              tmp___5 = *(h->vals + i);
              *(h->vals + i) = val;
              val = tmp___5;
              *(h->flags + (i >> 4)) = (khint32_t )((unsigned long )*(h->flags + (i >> 4)) | (1UL << ((i & 15U) << 1)));
            } else {
              *(h->keys + i) = key;
              *(h->vals + i) = val;
              break;
            }
          } else {
            *(h->keys + i) = key;
            *(h->vals + i) = val;
            break;
          }
        }
      }
      j ++;
    }
    if (h->n_buckets > new_n_buckets) {
      tmp___6 = realloc((void *)h->keys, (unsigned long )new_n_buckets * sizeof(khint64_t ));
      h->keys = (khint64_t *)tmp___6;
      tmp___7 = realloc((void *)h->vals, (unsigned long )new_n_buckets * sizeof(strm_value ));
      h->vals = (strm_value *)tmp___7;
    }
    free((void *)h->flags);
    h->flags = new_flags;
    h->n_buckets = new_n_buckets;
    h->n_occupied = h->size;
    h->upper_bound = (khint_t )((double const   )h->n_buckets * khash_ac_HASH_UPPER___0 + (double const   )0.5);
  }
  return (0);
}
}
__inline static khint_t kh_put_env(kh_env_t *h , khint64_t key , int *ret )
{
  khint_t x ;
  int tmp ;
  int tmp___0 ;
  khint_t k ;
  khint_t i ;
  khint_t site ;
  khint_t last ;
  khint_t mask ;
  khint_t step ;

  {
  if (h->n_occupied >= h->upper_bound) {
    if (h->n_buckets > h->size << 1) {
      tmp = kh_resize_env(h, h->n_buckets - 1U);
      if (tmp < 0) {
        *ret = -1;
        return (h->n_buckets);
      }
    } else {
      tmp___0 = kh_resize_env(h, h->n_buckets + 1U);
      if (tmp___0 < 0) {
        *ret = -1;
        return (h->n_buckets);
      }
    }
  }
  mask = h->n_buckets - 1U;
  step = (khint_t )0;
  site = h->n_buckets;
  x = site;
  k = (khint32_t )(((key >> 33) ^ key) ^ (key << 11));
  i = k & mask;
  if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U) {
    x = i;
  } else {
    last = i;
    while (1) {
      if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
        if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U)) {
          if (! (! (*(h->keys + i) == key))) {
            break;
          }
        }
      } else {
        break;
      }
      if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U) {
        site = i;
      }
      step ++;
      i = (i + step) & mask;
      if (i == last) {
        x = site;
        break;
      }
    }
    if (x == h->n_buckets) {
      if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U) {
        if (site != h->n_buckets) {
          x = site;
        } else {
          x = i;
        }
      } else {
        x = i;
      }
    }
  }
  if ((*(h->flags + (x >> 4)) >> ((x & 15U) << 1)) & 2U) {
    *(h->keys + x) = key;
    *(h->flags + (x >> 4)) = (khint32_t )((unsigned long )*(h->flags + (x >> 4)) & ~ (3UL << ((x & 15U) << 1)));
    (h->size) ++;
    (h->n_occupied) ++;
    *ret = 1;
  } else
  if ((*(h->flags + (x >> 4)) >> ((x & 15U) << 1)) & 1U) {
    *(h->keys + x) = key;
    *(h->flags + (x >> 4)) = (khint32_t )((unsigned long )*(h->flags + (x >> 4)) & ~ (3UL << ((x & 15U) << 1)));
    (h->size) ++;
    *ret = 2;
  } else {
    *ret = 0;
  }
  return (x);
}
}
strm_env *globals  ;
static int env_set(strm_env *env , strm_string name , strm_value val )
{
  int r ;
  khiter_t k ;
  int tmp___0 ;

  {
  if (! ((unsigned long )env != (unsigned long )globals)) {
    if (! (! strm_event_loop_started)) {
      __assert_fail("env != globals || !strm_event_loop_started", "env.c", 14U, "env_set");
    }
  }
  tmp___0 = strm_str_intern_p(name);
  if (! tmp___0) {
    name = strm_str_intern_str(name);
  }
  k = kh_put_env(env, name, & r);
  if (r <= 0) {
    return (1);
  }
  *(env->vals + k) = val;
  return (0);
}
}
int env_get(strm_env *env , strm_string name , strm_value *val )
{
  khiter_t k ;
  int tmp ;

  {
  tmp = strm_str_intern_p(name);
  if (! tmp) {
    name = strm_str_intern_str(name);
  }
  k = kh_get_env((kh_env_t const   *)env, name);
  if (k == env->n_buckets) {
    return (1);
  }
  *val = *(env->vals + k);
  return (0);
}
}
int strm_var_set(strm_state *state , strm_string name , strm_value val )
{
  strm_env *e ;
  kh_env_t *tmp ;
  int tmp___0 ;

  {
  if (! state) {
    if (! globals) {
      globals = kh_init_env();
    }
    e = globals;
  } else {
    if (! state->env) {
      tmp = kh_init_env();
      state->env = (void *)tmp;
    }
    e = (strm_env *)state->env;
  }
  tmp___0 = env_set(e, name, val);
  return (tmp___0);
}
}
int strm_var_def(strm_state *state , char const   *name , strm_value val )
{
  size_t tmp ;
  strm_string tmp___0 ;
  int tmp___1 ;

  {
  tmp = strlen(name);
  tmp___0 = strm_str_intern(name, (strm_int )tmp);
  tmp___1 = strm_var_set(state, tmp___0, val);
  return (tmp___1);
}
}
int strm_var_get(strm_state *state , strm_string name , strm_value *val )
{
  int tmp ;
  int tmp___0 ;

  {
  while (state) {
    if (state->env) {
      tmp = env_get((strm_env *)state->env, name, val);
      if (tmp == 0) {
        return (0);
      }
    }
    state = state->prev;
  }
  if (! globals) {
    return (1);
  }
  tmp___0 = env_get(globals, name, val);
  return (tmp___0);
}
}
int strm_var_match(strm_state *state , strm_string name , strm_value val )
{
  strm_value v0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (state) {
    if (state->env) {
      tmp___0 = env_get((strm_env *)state->env, name, & v0);
      if (tmp___0 == 0) {
        tmp = strm_value_eq(v0, val);
        if (tmp) {
          return (0);
        }
        return (1);
      }
    }
  }
  tmp___1 = strm_var_set(state, name, val);
  return (tmp___1);
}
}
int strm_env_copy(strm_state *s1 , strm_state *s2 )
{
  strm_env *e1 ;
  strm_env *e2 ;
  khiter_t k ;
  khiter_t kk ;
  int r ;
  void *tmp ;
  kh_env_t *tmp___0 ;
  void *tmp___1 ;
  kh_env_t *tmp___2 ;

  {
  e1 = (strm_env *)s1->env;
  e2 = (strm_env *)s2->env;
  if (! e1) {
    tmp___0 = kh_init_env();
    tmp = (void *)tmp___0;
    s1->env = tmp;
    e1 = (strm_env *)tmp;
  }
  if (! e2) {
    tmp___2 = kh_init_env();
    tmp___1 = (void *)tmp___2;
    s1->env = tmp___1;
    e2 = (strm_env *)tmp___1;
  }
  k = (khint_t )0;
  while (k != e2->n_buckets) {
    if (! ((*(e2->flags + (k >> 4)) >> ((k & 15U) << 1)) & 3U)) {
      kk = kh_put_env(e1, *(e2->keys + k), & r);
      if (r <= 0) {
        return (1);
      }
      *(e1->vals + kk) = *(e2->vals + k);
    }
    k ++;
  }
  return (0);
}
}
/* compiler builtin:
   void __attribute__((__overloaded__))  __sync_fetch_and_add(...) ;  */
/* compiler builtin:
   _Bool __sync_bool_compare_and_swap(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __sync_fetch_and_sub(...) ;  */
#pragma merger("0","/tmp/cil-5BaPYG7F.i","-std=gnu99,-g,-ggdb,-Wall")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
int strm_loop(void) ;
extern  __attribute__((__nothrow__)) int sched_yield(void) ;
struct strm_worker *workers  ;
static struct strm_queue *queue  ;
static struct strm_queue *prod_queue  ;
static int worker_max  ;
static int stream_count  =    0;
int strm_event_loop_started  =    0;
static void task_init(void) ;
struct strm_task *strm_task_new(int (*func)(strm_stream * , strm_value  ) , strm_value data )
{
  struct strm_task *t ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct strm_task ));
  t = (struct strm_task *)tmp;
  t->func = func;
  t->data = data;
  return (t);
}
}
void strm_task_add(strm_stream *strm , struct strm_task *task )
{


  {
  strm_queue_add(strm->queue, (void *)task);
  if ((unsigned int )strm->mode == 0U) {
    strm_queue_add(prod_queue, (void *)strm);
  } else {
    strm_queue_add(queue, (void *)strm);
  }
  return;
}
}
void strm_task_push(strm_stream *strm , int (*func)(strm_stream * , strm_value  ) ,
                    strm_value data )
{
  struct strm_task *tmp ;

  {
  if ((unsigned int )strm->mode == 4U) {
    return;
  } else
  if ((unsigned int )strm->mode == 3U) {
    return;
  }
  tmp = strm_task_new(func, data);
  strm_task_add(strm, tmp);
  return;
}
}
void strm_emit(strm_stream *strm , strm_value data , int (*func)(strm_stream * , strm_value  ) )
{
  int i ;
  int closed ;
  int i___0 ;
  int tmp ;
  strm_value tmp___0 ;

  {
  if ((unsigned int )strm->mode == 3U) {
    return;
  }
  tmp = strm_nil_p(data);
  if (! tmp) {
    if (strm->dst) {
      strm_task_push(strm->dst, (strm->dst)->start_func, data);
      if ((unsigned int )(strm->dst)->mode == 4U) {
        strm->dst = (strm_stream *)((void *)0);
      }
    }
    if (strm->rest) {
      i = 0;
      while ((size_t )i < strm->rsize) {
        strm_task_push(*(strm->rest + i), (*(strm->rest + i))->start_func, data);
        i ++;
      }
    }
    if ((unsigned long )strm->dst == (unsigned long )((void *)0)) {
      closed = 1;
      if (strm->rest) {
        i___0 = 0;
        while ((size_t )i___0 < strm->rsize) {
          if ((unsigned int )(*(strm->rest + i___0))->mode != 4U) {
            closed = 0;
            break;
          }
          i___0 ++;
        }
      }
      if (closed) {
        strm->mode = (strm_stream_mode )3;
        return;
      }
    }
  }
  sched_yield();
  if (func) {
    tmp___0 = strm_nil_value();
    strm_task_push(strm, func, tmp___0);
  }
  return;
}
}
int strm_stream_connect(strm_stream *src , strm_stream *dst )
{
  void *tmp___1 ;
  size_t tmp___2 ;
  strm_value tmp___3 ;

  {
  if (! ((unsigned int )src->mode != 2U)) {
    __assert_fail("src->mode != strm_consumer", "core.c", 102U, "strm_stream_connect");
  }
  if (! ((unsigned int )dst->mode != 0U)) {
    __assert_fail("dst->mode != strm_producer", "core.c", 103U, "strm_stream_connect");
  }
  if ((unsigned long )src->dst == (unsigned long )((void *)0)) {
    src->dst = dst;
  } else {
    if (src->rsize <= src->rcapa) {
      src->rcapa = src->rcapa * 2UL + 2UL;
      tmp___1 = realloc((void *)src->rest, sizeof(strm_stream *) * src->rcapa);
      src->rest = (strm_stream **)tmp___1;
    }
    tmp___2 = src->rsize;
    (src->rsize) ++;
    *(src->rest + tmp___2) = dst;
  }
  __sync_fetch_and_add(& dst->refcnt, 1);
  if ((unsigned int )src->mode == 0U) {
    task_init();
    tmp___3 = strm_nil_value();
    strm_task_push(src, src->start_func, tmp___3);
  }
  return (0);
}
}
int cpu_count(void) ;
static int worker_count(void)
{
  char *e ;
  char *tmp ;
  int n ;
  int tmp___0 ;

  {
  tmp = getenv("STRM_WORKER_MAX");
  e = tmp;
  if (e) {
    n = atoi((char const   *)e);
    if (n > 0) {
      return (n);
    }
  }
  tmp___0 = cpu_count();
  return (tmp___0);
}
}
static void task_exec(strm_stream *strm , struct strm_task *task )
{
  int (*func)(strm_stream * , strm_value  ) ;
  strm_value data ;
  int tmp ;

  {
  func = task->func;
  data = task->data;
  free((void *)task);
  if ((unsigned int )strm->mode == 4U) {
    return;
  }
  tmp = (*func)(strm, data);
  if (tmp == 1) {
    if (strm_option_verbose) {
      strm_eprint(strm);
    }
  }
  if ((unsigned int )strm->mode == 3U) {
    strm_stream_close(strm);
  }
  return;
}
}
static void *task_loop(void *data )
{
  strm_stream *strm ;
  void *tmp ;
  void *tmp___0 ;
  struct strm_task *t ;
  void *tmp___1 ;
  _Bool tmp___2 ;

  {
  while (1) {
    tmp = strm_queue_get(queue);
    strm = (strm_stream *)tmp;
    if (! strm) {
      tmp___0 = strm_queue_get(prod_queue);
      strm = (strm_stream *)tmp___0;
    }
    if (strm) {
      tmp___2 = __sync_bool_compare_and_swap(& strm->excl, 0, 1);
      if (tmp___2) {
        while (1) {
          tmp___1 = strm_queue_get(strm->queue);
          t = (struct strm_task *)tmp___1;
          if (! ((unsigned long )t != (unsigned long )((void *)0))) {
            break;
          }
          task_exec(strm, t);
        }
        __sync_bool_compare_and_swap(& strm->excl, 1, 0);
      }
    }
    if (stream_count == 0) {
      break;
    }
  }
  return ((void *)0);
}
}
static void task_init(void)
{
  int i ;
  void *tmp ;

  {
  if (workers) {
    return;
  }
  strm_event_loop_started = 1;
  strm_init_io_loop();
  queue = strm_queue_new();
  prod_queue = strm_queue_new();
  worker_max = worker_count();
  tmp = malloc(sizeof(struct strm_worker ) * (unsigned long )worker_max);
  workers = (struct strm_worker *)tmp;
  i = 0;
  while (i < worker_max) {
    pthread_create((pthread_t * __restrict  )(& (workers + i)->th), (pthread_attr_t const   * __restrict  )((void *)0),
                   & task_loop, (void * __restrict  )(workers + i));
    i ++;
  }
  return;
}
}
int strm_loop(void)
{


  {
  if (stream_count == 0) {
    return (0);
  }
  task_init();
  while (1) {
    sched_yield();
    if (stream_count == 0) {
      break;
    }
  }
  return (0);
}
}
strm_stream *strm_stream_new(strm_stream_mode mode , int (*start_func)(strm_stream * ,
                                                                       strm_value  ) ,
                             int (*close_func)(strm_stream * , strm_value  ) , void *data )
{
  strm_stream *s ;
  void *tmp ;

  {
  tmp = malloc(sizeof(strm_stream ));
  s = (strm_stream *)tmp;
  s->type = (enum strm_ptr_type )0;
  s->mode = mode;
  s->start_func = start_func;
  s->close_func = close_func;
  s->data = data;
  s->dst = (strm_stream *)((void *)0);
  s->rest = (strm_stream **)((void *)0);
  s->rsize = (size_t )0;
  s->rcapa = (size_t )0;
  s->flags = 0U;
  s->exc = (struct node_error *)((void *)0);
  s->refcnt = 0;
  s->excl = 0;
  s->queue = strm_queue_new();
  __sync_fetch_and_add(& stream_count, 1);
  return (s);
}
}
void strm_stream_close(strm_stream *strm )
{
  strm_stream_mode mode ;
  _Bool tmp ;
  strm_value tmp___0 ;
  int tmp___1 ;
  strm_value tmp___2 ;
  int i ;
  strm_value tmp___3 ;

  {
  mode = strm->mode;
  if ((unsigned int )mode == 4U) {
    return;
  }
  __sync_fetch_and_sub(& strm->refcnt, 1);
  if (strm->refcnt > 0) {
    return;
  }
  tmp = __sync_bool_compare_and_swap(& strm->mode, (unsigned int )mode, 4);
  if (! tmp) {
    return;
  }
  if (strm->close_func) {
    tmp___0 = strm_nil_value();
    tmp___1 = (*(strm->close_func))(strm, tmp___0);
    if (tmp___1 == 1) {
      return;
    }
  } else {
    free(strm->data);
    strm->data = (void *)0;
  }
  if (strm->dst) {
    tmp___2 = strm_nil_value();
    strm_task_push(strm->dst, (int (*)(strm_stream * , strm_value  ))(& strm_stream_close),
                   tmp___2);
  }
  if (strm->rest) {
    i = 0;
    while ((size_t )i < strm->rsize) {
      tmp___3 = strm_nil_value();
      strm_task_push(*(strm->rest + i), (int (*)(strm_stream * , strm_value  ))(& strm_stream_close),
                     tmp___3);
      i ++;
    }
    free((void *)strm->rest);
  }
  __sync_fetch_and_sub(& stream_count, 1);
  return;
}
}
#pragma merger("0","/tmp/cil-hIaXfTyu.i","-std=gnu99,-g,-ggdb,-Wall")
static double const   khash_ac_HASH_UPPER___1  =    (double const   )0.77;
__inline static kh_kvs_t *kh_init_kvs(void)
{
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(kh_kvs_t ));
  return ((kh_kvs_t *)tmp);
}
}
__inline static void kh_destroy_kvs(kh_kvs_t *h )
{


  {
  if (h) {
    free((void *)h->keys);
    free((void *)h->flags);
    free((void *)h->vals);
    free((void *)h);
  }
  return;
}
}
__inline static khint_t kh_get_kvs(kh_kvs_t const   *h , strm_string key )
{
  khint_t k ;
  khint_t i ;
  khint_t last ;
  khint_t mask ;
  khint_t step ;
  khint_t tmp ;

  {
  if (h->n_buckets) {
    step = (khint_t )0;
    mask = (khint_t )(h->n_buckets - 1U);
    k = (khint32_t )(((key >> 33) ^ key) ^ (key << 11));
    i = k & mask;
    last = i;
    while (1) {
      if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
        if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U)) {
          if (! (! (*(h->keys + i) == key))) {
            break;
          }
        }
      } else {
        break;
      }
      step ++;
      i = (i + step) & mask;
      if (i == last) {
        return ((khint_t )h->n_buckets);
      }
    }
    if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 3U) {
      tmp = h->n_buckets;
    } else {
      tmp = (khint_t const   )i;
    }
    return ((khint_t )tmp);
  } else {
    return ((khint_t )0);
  }
}
}
__inline static int kh_resize_kvs(kh_kvs_t *h , khint_t new_n_buckets )
{
  khint32_t *new_flags ;
  khint_t j ;
  khint_t tmp ;
  void *tmp___0 ;
  khint_t tmp___1 ;
  strm_string *new_keys ;
  void *tmp___2 ;
  strm_value *new_vals ;
  void *tmp___3 ;
  strm_string key ;
  strm_value val ;
  khint_t new_mask ;
  khint_t k ;
  khint_t i ;
  khint_t step ;
  strm_string tmp___4 ;
  strm_value tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
  new_flags = (khint32_t *)0;
  j = (khint_t )1;
  new_n_buckets --;
  new_n_buckets |= new_n_buckets >> 1;
  new_n_buckets |= new_n_buckets >> 2;
  new_n_buckets |= new_n_buckets >> 4;
  new_n_buckets |= new_n_buckets >> 8;
  new_n_buckets |= new_n_buckets >> 16;
  new_n_buckets ++;
  if (new_n_buckets < 4U) {
    new_n_buckets = (khint_t )4;
  }
  if (h->size >= (khint_t )((double const   )new_n_buckets * khash_ac_HASH_UPPER___1 + (double const   )0.5)) {
    j = (khint_t )0;
  } else {
    if (new_n_buckets < 16U) {
      tmp = (khint_t )1;
    } else {
      tmp = new_n_buckets >> 4;
    }
    tmp___0 = malloc((unsigned long )tmp * sizeof(khint32_t ));
    new_flags = (khint32_t *)tmp___0;
    if (! new_flags) {
      return (-1);
    }
    if (new_n_buckets < 16U) {
      tmp___1 = (khint_t )1;
    } else {
      tmp___1 = new_n_buckets >> 4;
    }
    memset((void *)new_flags, 170, (unsigned long )tmp___1 * sizeof(khint32_t ));
    if (h->n_buckets < new_n_buckets) {
      tmp___2 = realloc((void *)h->keys, (unsigned long )new_n_buckets * sizeof(strm_string ));
      new_keys = (strm_string *)tmp___2;
      if (! new_keys) {
        free((void *)new_flags);
        return (-1);
      }
      h->keys = new_keys;
      tmp___3 = realloc((void *)h->vals, (unsigned long )new_n_buckets * sizeof(strm_value ));
      new_vals = (strm_value *)tmp___3;
      if (! new_vals) {
        free((void *)new_flags);
        return (-1);
      }
      h->vals = new_vals;
    }
  }
  if (j) {
    j = (khint_t )0;
    while (j != h->n_buckets) {
      if (((*(h->flags + (j >> 4)) >> ((j & 15U) << 1)) & 3U) == 0U) {
        key = *(h->keys + j);
        new_mask = new_n_buckets - 1U;
        val = *(h->vals + j);
        *(h->flags + (j >> 4)) = (khint32_t )((unsigned long )*(h->flags + (j >> 4)) | (1UL << ((j & 15U) << 1)));
        while (1) {
          step = (khint_t )0;
          k = (khint32_t )(((key >> 33) ^ key) ^ (key << 11));
          i = k & new_mask;
          while (! ((*(new_flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
            step ++;
            i = (i + step) & new_mask;
          }
          *(new_flags + (i >> 4)) = (khint32_t )((unsigned long )*(new_flags + (i >> 4)) & ~ (2UL << ((i & 15U) << 1)));
          if (i < h->n_buckets) {
            if (((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 3U) == 0U) {
              tmp___4 = *(h->keys + i);
              *(h->keys + i) = key;
              key = tmp___4;
              tmp___5 = *(h->vals + i);
              *(h->vals + i) = val;
              val = tmp___5;
              *(h->flags + (i >> 4)) = (khint32_t )((unsigned long )*(h->flags + (i >> 4)) | (1UL << ((i & 15U) << 1)));
            } else {
              *(h->keys + i) = key;
              *(h->vals + i) = val;
              break;
            }
          } else {
            *(h->keys + i) = key;
            *(h->vals + i) = val;
            break;
          }
        }
      }
      j ++;
    }
    if (h->n_buckets > new_n_buckets) {
      tmp___6 = realloc((void *)h->keys, (unsigned long )new_n_buckets * sizeof(strm_string ));
      h->keys = (strm_string *)tmp___6;
      tmp___7 = realloc((void *)h->vals, (unsigned long )new_n_buckets * sizeof(strm_value ));
      h->vals = (strm_value *)tmp___7;
    }
    free((void *)h->flags);
    h->flags = new_flags;
    h->n_buckets = new_n_buckets;
    h->n_occupied = h->size;
    h->upper_bound = (khint_t )((double const   )h->n_buckets * khash_ac_HASH_UPPER___1 + (double const   )0.5);
  }
  return (0);
}
}
__inline static khint_t kh_put_kvs(kh_kvs_t *h , strm_string key , int *ret )
{
  khint_t x ;
  int tmp ;
  int tmp___0 ;
  khint_t k ;
  khint_t i ;
  khint_t site ;
  khint_t last ;
  khint_t mask ;
  khint_t step ;

  {
  if (h->n_occupied >= h->upper_bound) {
    if (h->n_buckets > h->size << 1) {
      tmp = kh_resize_kvs(h, h->n_buckets - 1U);
      if (tmp < 0) {
        *ret = -1;
        return (h->n_buckets);
      }
    } else {
      tmp___0 = kh_resize_kvs(h, h->n_buckets + 1U);
      if (tmp___0 < 0) {
        *ret = -1;
        return (h->n_buckets);
      }
    }
  }
  mask = h->n_buckets - 1U;
  step = (khint_t )0;
  site = h->n_buckets;
  x = site;
  k = (khint32_t )(((key >> 33) ^ key) ^ (key << 11));
  i = k & mask;
  if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U) {
    x = i;
  } else {
    last = i;
    while (1) {
      if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
        if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U)) {
          if (! (! (*(h->keys + i) == key))) {
            break;
          }
        }
      } else {
        break;
      }
      if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U) {
        site = i;
      }
      step ++;
      i = (i + step) & mask;
      if (i == last) {
        x = site;
        break;
      }
    }
    if (x == h->n_buckets) {
      if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U) {
        if (site != h->n_buckets) {
          x = site;
        } else {
          x = i;
        }
      } else {
        x = i;
      }
    }
  }
  if ((*(h->flags + (x >> 4)) >> ((x & 15U) << 1)) & 2U) {
    *(h->keys + x) = key;
    *(h->flags + (x >> 4)) = (khint32_t )((unsigned long )*(h->flags + (x >> 4)) & ~ (3UL << ((x & 15U) << 1)));
    (h->size) ++;
    (h->n_occupied) ++;
    *ret = 1;
  } else
  if ((*(h->flags + (x >> 4)) >> ((x & 15U) << 1)) & 1U) {
    *(h->keys + x) = key;
    *(h->flags + (x >> 4)) = (khint32_t )((unsigned long )*(h->flags + (x >> 4)) & ~ (3UL << ((x & 15U) << 1)));
    (h->size) ++;
    *ret = 2;
  } else {
    *ret = 0;
  }
  return (x);
}
}
__inline static kh_txn_t *kh_init_txn(void)
{
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(kh_txn_t ));
  return ((kh_txn_t *)tmp);
}
}
__inline static void kh_destroy_txn(kh_txn_t *h )
{


  {
  if (h) {
    free((void *)h->keys);
    free((void *)h->flags);
    free((void *)h->vals);
    free((void *)h);
  }
  return;
}
}
__inline static khint_t kh_get_txn(kh_txn_t const   *h , strm_string key )
{
  khint_t k ;
  khint_t i ;
  khint_t last ;
  khint_t mask ;
  khint_t step ;
  khint_t tmp ;

  {
  if (h->n_buckets) {
    step = (khint_t )0;
    mask = (khint_t )(h->n_buckets - 1U);
    k = (khint32_t )(((key >> 33) ^ key) ^ (key << 11));
    i = k & mask;
    last = i;
    while (1) {
      if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
        if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U)) {
          if (! (! (*(h->keys + i) == key))) {
            break;
          }
        }
      } else {
        break;
      }
      step ++;
      i = (i + step) & mask;
      if (i == last) {
        return ((khint_t )h->n_buckets);
      }
    }
    if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 3U) {
      tmp = h->n_buckets;
    } else {
      tmp = (khint_t const   )i;
    }
    return ((khint_t )tmp);
  } else {
    return ((khint_t )0);
  }
}
}
__inline static int kh_resize_txn(kh_txn_t *h , khint_t new_n_buckets )
{
  khint32_t *new_flags ;
  khint_t j ;
  khint_t tmp ;
  void *tmp___0 ;
  khint_t tmp___1 ;
  strm_string *new_keys ;
  void *tmp___2 ;
  strm_value *new_vals ;
  void *tmp___3 ;
  strm_string key ;
  strm_value val ;
  khint_t new_mask ;
  khint_t k ;
  khint_t i ;
  khint_t step ;
  strm_string tmp___4 ;
  strm_value tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
  new_flags = (khint32_t *)0;
  j = (khint_t )1;
  new_n_buckets --;
  new_n_buckets |= new_n_buckets >> 1;
  new_n_buckets |= new_n_buckets >> 2;
  new_n_buckets |= new_n_buckets >> 4;
  new_n_buckets |= new_n_buckets >> 8;
  new_n_buckets |= new_n_buckets >> 16;
  new_n_buckets ++;
  if (new_n_buckets < 4U) {
    new_n_buckets = (khint_t )4;
  }
  if (h->size >= (khint_t )((double const   )new_n_buckets * khash_ac_HASH_UPPER___1 + (double const   )0.5)) {
    j = (khint_t )0;
  } else {
    if (new_n_buckets < 16U) {
      tmp = (khint_t )1;
    } else {
      tmp = new_n_buckets >> 4;
    }
    tmp___0 = malloc((unsigned long )tmp * sizeof(khint32_t ));
    new_flags = (khint32_t *)tmp___0;
    if (! new_flags) {
      return (-1);
    }
    if (new_n_buckets < 16U) {
      tmp___1 = (khint_t )1;
    } else {
      tmp___1 = new_n_buckets >> 4;
    }
    memset((void *)new_flags, 170, (unsigned long )tmp___1 * sizeof(khint32_t ));
    if (h->n_buckets < new_n_buckets) {
      tmp___2 = realloc((void *)h->keys, (unsigned long )new_n_buckets * sizeof(strm_string ));
      new_keys = (strm_string *)tmp___2;
      if (! new_keys) {
        free((void *)new_flags);
        return (-1);
      }
      h->keys = new_keys;
      tmp___3 = realloc((void *)h->vals, (unsigned long )new_n_buckets * sizeof(strm_value ));
      new_vals = (strm_value *)tmp___3;
      if (! new_vals) {
        free((void *)new_flags);
        return (-1);
      }
      h->vals = new_vals;
    }
  }
  if (j) {
    j = (khint_t )0;
    while (j != h->n_buckets) {
      if (((*(h->flags + (j >> 4)) >> ((j & 15U) << 1)) & 3U) == 0U) {
        key = *(h->keys + j);
        new_mask = new_n_buckets - 1U;
        val = *(h->vals + j);
        *(h->flags + (j >> 4)) = (khint32_t )((unsigned long )*(h->flags + (j >> 4)) | (1UL << ((j & 15U) << 1)));
        while (1) {
          step = (khint_t )0;
          k = (khint32_t )(((key >> 33) ^ key) ^ (key << 11));
          i = k & new_mask;
          while (! ((*(new_flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
            step ++;
            i = (i + step) & new_mask;
          }
          *(new_flags + (i >> 4)) = (khint32_t )((unsigned long )*(new_flags + (i >> 4)) & ~ (2UL << ((i & 15U) << 1)));
          if (i < h->n_buckets) {
            if (((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 3U) == 0U) {
              tmp___4 = *(h->keys + i);
              *(h->keys + i) = key;
              key = tmp___4;
              tmp___5 = *(h->vals + i);
              *(h->vals + i) = val;
              val = tmp___5;
              *(h->flags + (i >> 4)) = (khint32_t )((unsigned long )*(h->flags + (i >> 4)) | (1UL << ((i & 15U) << 1)));
            } else {
              *(h->keys + i) = key;
              *(h->vals + i) = val;
              break;
            }
          } else {
            *(h->keys + i) = key;
            *(h->vals + i) = val;
            break;
          }
        }
      }
      j ++;
    }
    if (h->n_buckets > new_n_buckets) {
      tmp___6 = realloc((void *)h->keys, (unsigned long )new_n_buckets * sizeof(strm_string ));
      h->keys = (strm_string *)tmp___6;
      tmp___7 = realloc((void *)h->vals, (unsigned long )new_n_buckets * sizeof(strm_value ));
      h->vals = (strm_value *)tmp___7;
    }
    free((void *)h->flags);
    h->flags = new_flags;
    h->n_buckets = new_n_buckets;
    h->n_occupied = h->size;
    h->upper_bound = (khint_t )((double const   )h->n_buckets * khash_ac_HASH_UPPER___1 + (double const   )0.5);
  }
  return (0);
}
}
__inline static khint_t kh_put_txn(kh_txn_t *h , strm_string key , int *ret )
{
  khint_t x ;
  int tmp ;
  int tmp___0 ;
  khint_t k ;
  khint_t i ;
  khint_t site ;
  khint_t last ;
  khint_t mask ;
  khint_t step ;

  {
  if (h->n_occupied >= h->upper_bound) {
    if (h->n_buckets > h->size << 1) {
      tmp = kh_resize_txn(h, h->n_buckets - 1U);
      if (tmp < 0) {
        *ret = -1;
        return (h->n_buckets);
      }
    } else {
      tmp___0 = kh_resize_txn(h, h->n_buckets + 1U);
      if (tmp___0 < 0) {
        *ret = -1;
        return (h->n_buckets);
      }
    }
  }
  mask = h->n_buckets - 1U;
  step = (khint_t )0;
  site = h->n_buckets;
  x = site;
  k = (khint32_t )(((key >> 33) ^ key) ^ (key << 11));
  i = k & mask;
  if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U) {
    x = i;
  } else {
    last = i;
    while (1) {
      if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
        if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U)) {
          if (! (! (*(h->keys + i) == key))) {
            break;
          }
        }
      } else {
        break;
      }
      if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U) {
        site = i;
      }
      step ++;
      i = (i + step) & mask;
      if (i == last) {
        x = site;
        break;
      }
    }
    if (x == h->n_buckets) {
      if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U) {
        if (site != h->n_buckets) {
          x = site;
        } else {
          x = i;
        }
      } else {
        x = i;
      }
    }
  }
  if ((*(h->flags + (x >> 4)) >> ((x & 15U) << 1)) & 2U) {
    *(h->keys + x) = key;
    *(h->flags + (x >> 4)) = (khint32_t )((unsigned long )*(h->flags + (x >> 4)) & ~ (3UL << ((x & 15U) << 1)));
    (h->size) ++;
    (h->n_occupied) ++;
    *ret = 1;
  } else
  if ((*(h->flags + (x >> 4)) >> ((x & 15U) << 1)) & 1U) {
    *(h->keys + x) = key;
    *(h->flags + (x >> 4)) = (khint32_t )((unsigned long )*(h->flags + (x >> 4)) & ~ (3UL << ((x & 15U) << 1)));
    (h->size) ++;
    *ret = 2;
  } else {
    *ret = 0;
  }
  return (x);
}
}
static strm_kvs *get_kvs(int argc , strm_value *args )
{
  void *tmp ;

  {
  if (argc == 0) {
    return ((strm_kvs *)((void *)0));
  }
  tmp = strm_value_ptr(*(args + 0), (enum strm_ptr_type )4);
  return ((strm_kvs *)tmp);
}
}
static int kvs_get(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_kvs *k ;
  strm_kvs *tmp ;
  strm_string key ;
  strm_string tmp___0 ;
  strm_string tmp___1 ;
  khiter_t i ;

  {
  tmp = get_kvs(argc, args);
  k = tmp;
  tmp___0 = strm_to_str(*(args + 1));
  tmp___1 = strm_str_intern_str(tmp___0);
  key = tmp___1;
  if (! k) {
    strm_raise(strm, "no kvs given");
    return (1);
  }
  pthread_mutex_lock(& k->lock);
  i = kh_get_kvs((kh_kvs_t const   *)k->kv, key);
  if (i == (k->kv)->n_buckets) {
    *ret = strm_nil_value();
  } else {
    *ret = *((k->kv)->vals + i);
  }
  pthread_mutex_unlock(& k->lock);
  return (0);
}
}
static uint64_t kvs_serial(strm_kvs *kvs )
{
  uint64_t serial ;

  {
  pthread_mutex_lock(& kvs->lock);
  serial = kvs->serial;
  pthread_mutex_unlock(& kvs->lock);
  return (serial);
}
}
static int kvs_put(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_kvs *k ;
  strm_kvs *tmp ;
  strm_string key ;
  strm_string tmp___0 ;
  strm_string tmp___1 ;
  khiter_t i ;
  int st ;

  {
  tmp = get_kvs(argc, args);
  k = tmp;
  tmp___0 = strm_to_str(*(args + 1));
  tmp___1 = strm_str_intern_str(tmp___0);
  key = tmp___1;
  if (! k) {
    strm_raise(strm, "no kvs given");
    return (1);
  }
  pthread_mutex_lock(& k->lock);
  i = kh_put_kvs(k->kv, key, & st);
  if (st < 0) {
    pthread_mutex_unlock(& k->lock);
    return (1);
  }
  (k->serial) ++;
  *((k->kv)->vals + i) = *(args + 2);
  pthread_mutex_unlock(& k->lock);
  return (0);
}
}
static int kvs_update(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_kvs *k ;
  strm_kvs *tmp ;
  strm_string key ;
  strm_string tmp___0 ;
  strm_string tmp___1 ;
  strm_value old ;
  strm_value val ;
  khiter_t i ;
  int st ;
  int tmp___2 ;

  {
  tmp = get_kvs(argc, args);
  k = tmp;
  tmp___0 = strm_to_str(*(args + 1));
  tmp___1 = strm_str_intern_str(tmp___0);
  key = tmp___1;
  if (! k) {
    strm_raise(strm, "no kvs given");
    return (1);
  }
  pthread_mutex_lock(& k->lock);
  i = kh_get_kvs((kh_kvs_t const   *)k->kv, key);
  if (i == (k->kv)->n_buckets) {
    pthread_mutex_unlock(& k->lock);
    return (1);
  }
  old = *((k->kv)->vals + i);
  pthread_mutex_unlock(& k->lock);
  tmp___2 = strm_funcall(strm, *(args + 2), 1, & old, & val);
  if (tmp___2 == 1) {
    return (1);
  }
  pthread_mutex_lock(& k->lock);
  i = kh_put_kvs(k->kv, key, & st);
  if (st != 0) {
    pthread_mutex_unlock(& k->lock);
    return (1);
  } else
  if (*((k->kv)->vals + i) != old) {
    pthread_mutex_unlock(& k->lock);
    return (1);
  }
  (k->serial) ++;
  *((k->kv)->vals + i) = val;
  pthread_mutex_unlock(& k->lock);
  *ret = val;
  return (0);
}
}
static int kvs_close(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_kvs *k ;
  strm_kvs *tmp ;

  {
  tmp = get_kvs(argc, args);
  k = tmp;
  if (! k) {
    strm_raise(strm, "no kvs given");
    return (1);
  }
  kh_destroy_kvs(k->kv);
  return (0);
}
}
static strm_state *ns_kvs  ;
static strm_state *ns_txn  ;
static int kvs_new(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  struct strm_kvs *k ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct strm_kvs ));
  k = (struct strm_kvs *)tmp;
  if (! k) {
    return (1);
  }
  k->ns = ns_kvs;
  k->type = (enum strm_ptr_type )4;
  k->kv = kh_init_kvs();
  k->serial = (uint64_t )1;
  pthread_mutex_init(& k->lock, (pthread_mutexattr_t const   *)((void *)0));
  *ret = strm_ptr_value((void *)k);
  return (0);
}
}
static strm_txn *txn_new(strm_kvs *kvs )
{
  struct strm_txn *t ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct strm_txn ));
  t = (struct strm_txn *)tmp;
  if (! t) {
    return ((strm_txn *)((void *)0));
  }
  t->ns = ns_txn;
  t->type = (enum strm_ptr_type )4;
  t->tv = kh_init_txn();
  t->kvs = kvs;
  t->serial = kvs_serial(kvs);
  return (t);
}
}
static void txn_free(strm_txn *txn )
{


  {
  kh_destroy_txn(txn->tv);
  txn->tv = (kh_txn_t *)((void *)0);
  return;
}
}
static int kvs_txn(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_kvs *kvs ;
  strm_kvs *tmp ;
  strm_txn *txn ;
  strm_value val ;
  khiter_t i ;
  khiter_t j ;
  kh_txn_t *tv ;
  kh_kvs_t *kv ;
  int st ;
  int result ;
  int tries ;
  int tmp___0 ;
  strm_value key ;
  strm_value v ;

  {
  tmp = get_kvs(argc, args);
  kvs = tmp;
  st = 0;
  result = 0;
  tries = 0;
  if (! kvs) {
    strm_raise(strm, "no kvs given");
    return (1);
  }
  txn = txn_new(kvs);
  val = strm_ptr_value((void *)txn);
  retry:
  tmp___0 = strm_funcall(strm, *(args + 1), 1, & val, ret);
  if (tmp___0 == 1) {
    if (txn->serial == 0UL) {
      tries ++;
      if (tries > 10) {
        strm_raise(strm, "too many transaction retries");
        goto fail;
      }
      txn->serial = kvs_serial(kvs);
      goto retry;
    }
    txn_free(txn);
    return (1);
  }
  pthread_mutex_lock(& kvs->lock);
  if (kvs->serial != txn->serial) {
    pthread_mutex_unlock(& kvs->lock);
    goto retry;
  }
  kv = kvs->kv;
  tv = txn->tv;
  i = (khint_t )0;
  while (i != tv->n_buckets) {
    if (! ((*(tv->flags + (i >> 4)) >> ((i & 15U) << 1)) & 3U)) {
      key = *(tv->keys + i);
      v = *(tv->vals + i);
      j = kh_put_kvs(kv, key, & st);
      if (st < 0) {
        pthread_mutex_unlock(& kvs->lock);
        goto fail;
      }
      *(kv->vals + j) = v;
    }
    i ++;
  }
  if (result == 0) {
    (kvs->serial) ++;
  }
  pthread_mutex_unlock(& kvs->lock);
  switch (result) {
  case 1:
  goto retry;
  default:
  txn_free(txn);
  return (0);
  }
  fail:
  txn_free(txn);
  return (1);
}
}
static strm_txn *get_txn(int argc , strm_value *args )
{
  strm_txn *txn ;
  void *tmp ;

  {
  if (argc == 0) {
    return ((strm_txn *)((void *)0));
  }
  tmp = strm_value_ptr(*(args + 0), (enum strm_ptr_type )4);
  txn = (strm_txn *)tmp;
  if (! txn->tv) {
    return ((strm_txn *)((void *)0));
  }
  return (txn);
}
}
static int void_txn(strm_stream *strm )
{


  {
  strm_raise(strm, "invalid transaction");
  return (1);
}
}
static int txn_retry(strm_txn *txn )
{


  {
  txn->serial = (uint64_t )0;
  return (1);
}
}
static int txn_get(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_txn *t ;
  strm_txn *tmp ;
  strm_kvs *k ;
  strm_string key ;
  strm_string tmp___0 ;
  strm_string tmp___1 ;
  khiter_t i ;
  int tmp___2 ;
  int tmp___3 ;
  uint64_t tmp___4 ;

  {
  tmp = get_txn(argc, args);
  t = tmp;
  tmp___0 = strm_to_str(*(args + 1));
  tmp___1 = strm_str_intern_str(tmp___0);
  key = tmp___1;
  if (! t) {
    tmp___2 = void_txn(strm);
    return (tmp___2);
  }
  k = t->kvs;
  tmp___4 = kvs_serial(k);
  if (t->serial != tmp___4) {
    tmp___3 = txn_retry(t);
    return (tmp___3);
  }
  i = kh_get_txn((kh_txn_t const   *)t->tv, key);
  if (i == (t->tv)->n_buckets) {
    pthread_mutex_lock(& k->lock);
    i = kh_get_kvs((kh_kvs_t const   *)k->kv, key);
    if (i == (k->kv)->n_buckets) {
      *ret = strm_nil_value();
    } else {
      *ret = *((k->kv)->vals + i);
    }
    pthread_mutex_unlock(& k->lock);
  } else {
    *ret = *((t->tv)->vals + i);
  }
  return (0);
}
}
static int txn_put(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_txn *t ;
  strm_txn *tmp ;
  strm_string key ;
  strm_string tmp___0 ;
  strm_string tmp___1 ;
  khiter_t i ;
  int st ;
  int tmp___2 ;

  {
  tmp = get_txn(argc, args);
  t = tmp;
  tmp___0 = strm_to_str(*(args + 1));
  tmp___1 = strm_str_intern_str(tmp___0);
  key = tmp___1;
  if (! t) {
    tmp___2 = void_txn(strm);
    return (tmp___2);
  }
  i = kh_put_txn(t->tv, key, & st);
  if (st < 0) {
    return (1);
  }
  *((t->tv)->vals + i) = *(args + 2);
  return (0);
}
}
static int txn_update(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_txn *t ;
  strm_txn *tmp ;
  strm_kvs *k ;
  strm_string key ;
  strm_string tmp___0 ;
  strm_string tmp___1 ;
  strm_value val ;
  khiter_t i ;
  int st ;
  int tmp___2 ;
  int tmp___3 ;
  uint64_t tmp___4 ;
  int tmp___5 ;

  {
  tmp = get_txn(argc, args);
  t = tmp;
  tmp___0 = strm_to_str(*(args + 1));
  tmp___1 = strm_str_intern_str(tmp___0);
  key = tmp___1;
  if (! t) {
    tmp___2 = void_txn(strm);
    return (tmp___2);
  }
  k = t->kvs;
  tmp___4 = kvs_serial(k);
  if (t->serial != tmp___4) {
    tmp___3 = txn_retry(t);
    return (tmp___3);
  }
  i = kh_put_txn(t->tv, key, & st);
  if (st < 0) {
    return (1);
  }
  if (st == 0) {
    val = *((t->tv)->vals + i);
  } else {
    pthread_mutex_lock(& k->lock);
    i = kh_get_kvs((kh_kvs_t const   *)k->kv, key);
    if (i == (k->kv)->n_buckets) {
      pthread_mutex_unlock(& k->lock);
      return (1);
    } else {
      val = *((k->kv)->vals + i);
    }
    pthread_mutex_unlock(& k->lock);
  }
  tmp___5 = strm_funcall(strm, *(args + 2), 1, & val, & val);
  if (tmp___5 == 1) {
    return (1);
  }
  *((t->tv)->vals + i) = val;
  *ret = val;
  return (0);
}
}
static strm_value to_str(strm_stream *strm , strm_value val , char *type )
{
  char buf[256] ;
  int n ;
  strm_string tmp ;

  {
  n = sprintf((char * __restrict  )(buf), (char const   * __restrict  )"<%s:%p>",
              type, (void *)((intptr_t )(val & ~ (65535UL << 48))));
  tmp = strm_str_new((char const   *)(buf), n);
  return (tmp);
}
}
static int kvs_str(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{


  {
  if (argc != 1) {
    return (1);
  }
  *ret = to_str(strm, *(args + 0), (char *)"kvs");
  return (0);
}
}
static int txn_str(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{


  {
  if (argc != 1) {
    return (1);
  }
  *ret = to_str(strm, *(args + 0), (char *)"txn");
  return (0);
}
}
void strm_kvs_init(strm_state *state )
{
  strm_value tmp ;
  strm_value tmp___0 ;
  strm_value tmp___1 ;
  strm_value tmp___2 ;
  strm_value tmp___3 ;
  strm_value tmp___4 ;
  strm_value tmp___5 ;
  strm_value tmp___6 ;
  strm_value tmp___7 ;
  strm_value tmp___8 ;
  strm_value tmp___9 ;

  {
  ns_kvs = strm_ns_new((strm_state *)((void *)0), "kvs");
  tmp = strm_cfunc_value(& kvs_get);
  strm_var_def(ns_kvs, "get", tmp);
  tmp___0 = strm_cfunc_value(& kvs_put);
  strm_var_def(ns_kvs, "put", tmp___0);
  tmp___1 = strm_cfunc_value(& kvs_update);
  strm_var_def(ns_kvs, "update", tmp___1);
  tmp___2 = strm_cfunc_value(& kvs_txn);
  strm_var_def(ns_kvs, "txn", tmp___2);
  tmp___3 = strm_cfunc_value(& kvs_close);
  strm_var_def(ns_kvs, "close", tmp___3);
  tmp___4 = strm_cfunc_value(& kvs_str);
  strm_var_def(ns_kvs, "string", tmp___4);
  ns_txn = strm_ns_new((strm_state *)((void *)0), "kvs_txn");
  tmp___5 = strm_cfunc_value(& txn_get);
  strm_var_def(ns_txn, "get", tmp___5);
  tmp___6 = strm_cfunc_value(& txn_put);
  strm_var_def(ns_txn, "put", tmp___6);
  tmp___7 = strm_cfunc_value(& txn_update);
  strm_var_def(ns_txn, "update", tmp___7);
  tmp___8 = strm_cfunc_value(& txn_str);
  strm_var_def(ns_kvs, "string", tmp___8);
  tmp___9 = strm_cfunc_value(& kvs_new);
  strm_var_def(state, "kvs", tmp___9);
  return;
}
}
#pragma merger("0","/tmp/cil-OVJGRRAC.i","-std=gnu99,-g,-ggdb,-Wall")
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern void perror(char const   *__s ) ;
void node_parse_init(parser_state *p ) ;
void node_parse_free(parser_state *p ) ;
int node_parse_file(parser_state *p , char const   *fname ) ;
int node_parse_input(parser_state *p , FILE *f , char const   *fname ) ;
int node_parse_string(parser_state *p , char const   *prog ) ;
node *node_array_new(void) ;
node *node_array_headers(node *np ) ;
void node_array_add(node *a , node *data ) ;
void node_array_free(node_array *v ) ;
node *node_nodes_new(void) ;
void node_nodes_add(node *a , node *data ) ;
node *node_nodes_concat(node *s , node *s2 ) ;
node *node_pair_new(node_string key , node *value ) ;
node *node_args_new(void) ;
void node_args_add(node *v , node_string data ) ;
node *node_pattern_new(node_type type ) ;
void node_pattern_add(node *v , node *data ) ;
node *node_psplat_new(node *head , node *mid , node *tail ) ;
node *node_splat_new(node *n ) ;
node *node_plambda_new(node *pat , node *cond ) ;
node *node_plambda_body(node *n , node *body ) ;
node *node_plambda_add(node *n , node *lambda ) ;
node *node_ns_new(node_string name , node *body ) ;
node *node_import_new(node_string name ) ;
node *node_let_new(node_string lhs , node *rhs ) ;
node *node_op_new(char const   *op , node *lhs , node *rhs ) ;
node *node_obj_new(node *np , node_string ns ) ;
node *node_lambda_new(node *args , node *compstmt ) ;
node *node_block_new(node *compstmt ) ;
node *node_method_new(node *args , node *compstmt ) ;
node *node_call_new(node_string ident , node *recv , node *args , node *blk ) ;
node *node_fcall_new(node *func , node *args , node *blk ) ;
node *node_genfunc_new(node_string id ) ;
node *node_int_new(long i ) ;
node *node_float_new(double d ) ;
node *node_time_new(char const   *s , strm_int len ) ;
node *node_string_new(char const   *s , strm_int len ) ;
node *node_if_new(node *cond , node *then , node *opt_else ) ;
node *node_emit_new(node *value ) ;
node *node_skip_new(void) ;
node *node_return_new(node *value ) ;
node *node_ident_new(node_string name ) ;
node_string node_str_new(char const   *s , strm_int len ) ;
node_string node_str_escaped(char const   *s , strm_int len ) ;
node *node_nil(void) ;
node *node_true(void) ;
node *node_false(void) ;
void node_free(node *np ) ;
int yyparse(parser_state *p ) ;
void yyrestart(FILE *input_file ) ;
YY_BUFFER_STATE yy_scan_string(char const   *yystr ) ;
node *node_array_new(void)
{
  node_array *v ;
  void *tmp ;

  {
  tmp = malloc(sizeof(node_array ));
  v = (node_array *)tmp;
  v->type = (node_type )27;
  v->len = 0;
  v->max = 0;
  v->data = (node **)((void *)0);
  v->headers = (node_string *)((void *)0);
  v->ns = (node_string )((void *)0);
  return ((node *)v);
}
}
node *node_pair_new(node_string key , node *value )
{
  node_pair *npair ;
  void *tmp ;

  {
  tmp = malloc(sizeof(node_pair ));
  npair = (node_pair *)tmp;
  npair->type = (node_type )7;
  npair->key = key;
  npair->value = value;
  return ((node *)npair);
}
}
node *node_array_headers(node *np )
{
  int i ;
  node_array *v ;
  node_string *headers ;
  node_pair *npair ;
  void *tmp ;

  {
  headers = (node_string *)((void *)0);
  if (! np) {
    np = node_array_new();
  }
  v = (node_array *)np;
  i = 0;
  while (i < v->len) {
    npair = (node_pair *)*(v->data + i);
    if (npair) {
      if ((unsigned int )npair->type == 7U) {
        if (! headers) {
          tmp = malloc(sizeof(node_string ) * (unsigned long )v->len);
          headers = (node_string *)tmp;
        }
        *(headers + i) = npair->key;
        *(v->data + i) = npair->value;
        free((void *)npair);
      }
    }
    i ++;
  }
  v->headers = headers;
  return (np);
}
}
void node_array_add(node *a , node *data )
{
  node_array *_v ;
  void *tmp ;

  {
  _v = (node_array *)a;
  if (_v->len == _v->max) {
    _v->max = _v->len + 10;
    tmp = realloc((void *)_v->data, sizeof(node *) * (unsigned long )_v->max);
    _v->data = (node **)tmp;
  }
  *(_v->data + _v->len) = data;
  (_v->len) ++;
  return;
}
}
void node_array_free(node_array *v )
{
  strm_int i ;

  {
  i = 0;
  while (i < v->len) {
    node_free(*(v->data + i));
    i ++;
  }
  free((void *)v->data);
  if (v->headers) {
    i = 0;
    while (i < v->len) {
      free((void *)*(v->headers + i));
      i ++;
    }
    free((void *)v->headers);
  }
  if (v->ns) {
    free((void *)v->ns);
  }
  free((void *)v);
  return;
}
}
node *node_nodes_new(void)
{
  node_nodes *v ;
  void *tmp ;

  {
  tmp = malloc(sizeof(node_nodes ));
  v = (node_nodes *)tmp;
  v->type = (node_type )28;
  v->len = 0;
  v->max = 0;
  v->data = (node **)((void *)0);
  return ((node *)v);
}
}
void node_nodes_add(node *a , node *data )
{
  node_nodes *_v ;
  void *tmp ;

  {
  _v = (node_nodes *)a;
  if (_v->len == _v->max) {
    _v->max = _v->len + 10;
    tmp = realloc((void *)_v->data, sizeof(node *) * (unsigned long )_v->max);
    _v->data = (node **)tmp;
  }
  *(_v->data + _v->len) = data;
  (_v->len) ++;
  return;
}
}
void node_nodes_prepend(node *a , node *data )
{
  node_nodes *_v ;
  void *tmp ;

  {
  _v = (node_nodes *)a;
  if (_v->len == _v->max) {
    _v->max = _v->len + 10;
    tmp = realloc((void *)_v->data, sizeof(node *) * (unsigned long )_v->max);
    _v->data = (node **)tmp;
  }
  memmove((void *)(_v->data + 1), (void const   *)_v->data, (unsigned long )_v->len * sizeof(node *));
  *(_v->data + 0) = data;
  (_v->len) ++;
  return;
}
}
node *node_nodes_concat(node *s , node *s2 )
{
  node_nodes *v ;
  node_nodes *v2 ;
  void *tmp ;

  {
  if (! s) {
    return (s2);
  }
  if (s2) {
    v = (node_nodes *)s;
    v2 = (node_nodes *)s2;
    if (v->len + v2->len > v->max) {
      v->max = (v->len + v2->len) + 10;
      tmp = realloc((void *)v->data, sizeof(void *) * (unsigned long )v->max);
      v->data = (node **)tmp;
    }
    memcpy((void * __restrict  )(v->data + v->len), (void const   * __restrict  )v2->data,
           (unsigned long )v2->len * sizeof(node *));
    v->len += v2->len;
  }
  return (s);
}
}
void node_nodes_free(node_nodes *v )
{
  strm_int i ;

  {
  i = 0;
  while (i < v->len) {
    node_free(*(v->data + i));
    i ++;
  }
  free((void *)v->data);
  free((void *)v);
  return;
}
}
node *node_obj_new(node *np , node_string ns )
{
  node_array *v ;
  node *tmp ;

  {
  if (! np) {
    tmp = node_array_new();
    v = (node_array *)tmp;
  } else {
    v = (node_array *)np;
  }
  v->ns = ns;
  return ((node *)v);
}
}
node *node_args_new(void)
{
  node_args *v ;
  void *tmp ;

  {
  tmp = malloc(sizeof(node_args ));
  v = (node_args *)tmp;
  v->type = (node_type )6;
  v->len = 0;
  v->max = 0;
  v->data = (node_string *)((void *)0);
  return ((node *)v);
}
}
void node_args_add(node *v , node_string data )
{
  node_args *_v ;
  void *tmp ;

  {
  _v = (node_args *)v;
  if (_v->len == _v->max) {
    _v->max = _v->len + 10;
    tmp = realloc((void *)_v->data, sizeof(node_string ) * (unsigned long )_v->max);
    _v->data = (node_string *)tmp;
  }
  *(_v->data + _v->len) = data;
  (_v->len) ++;
  return;
}
}
void node_args_prepend(node *a , node_string data )
{
  node_args *_v ;
  void *tmp ;

  {
  _v = (node_args *)a;
  if (_v->len == _v->max) {
    _v->max = _v->len + 10;
    tmp = realloc((void *)_v->data, sizeof(node_string ) * (unsigned long )_v->max);
    _v->data = (node_string *)tmp;
  }
  memmove((void *)(_v->data + 1), (void const   *)_v->data, (unsigned long )_v->len * sizeof(node_string ));
  *(_v->data + 0) = data;
  (_v->len) ++;
  return;
}
}
void node_args_free(node *a )
{
  strm_int i ;
  node_args *v ;

  {
  v = (node_args *)a;
  if (! ((unsigned int )a->type == 6U)) {
    __assert_fail("a->type == NODE_ARGS", "node.c", 191U, "node_args_free");
  }
  i = 0;
  while (i < v->len) {
    free((void *)*(v->data + i));
    i ++;
  }
  free((void *)v->data);
  free((void *)v);
  return;
}
}
node *node_pattern_new(node_type type )
{
  node_nodes *v ;
  void *tmp ;

  {
  tmp = malloc(sizeof(node_nodes ));
  v = (node_nodes *)tmp;
  v->type = type;
  v->len = 0;
  v->max = 0;
  v->data = (node **)((void *)0);
  return ((node *)v);
}
}
void node_pattern_add(node *v , node *data )
{
  node_nodes *_v ;
  void *tmp ;

  {
  _v = (node_nodes *)v;
  if (_v->len == _v->max) {
    _v->max = _v->len + 10;
    tmp = realloc((void *)_v->data, sizeof(node *) * (unsigned long )_v->max);
    _v->data = (node **)tmp;
  }
  *(_v->data + _v->len) = data;
  (_v->len) ++;
  return;
}
}
node *node_psplat_new(node *head , node *mid , node *tail )
{
  node_psplat *cons ;
  void *tmp ;

  {
  tmp = malloc(sizeof(node_psplat ));
  cons = (node_psplat *)tmp;
  cons->type = (node_type )13;
  cons->head = head;
  cons->mid = mid;
  cons->tail = tail;
  return ((node *)cons);
}
}
node *node_plambda_new(node *pat , node *cond )
{
  node_plambda *lambda ;
  void *tmp ;

  {
  tmp = malloc(sizeof(node_plambda ));
  lambda = (node_plambda *)tmp;
  lambda->type = (node_type )10;
  lambda->pat = pat;
  lambda->cond = cond;
  lambda->body = (node *)((void *)0);
  return ((node *)lambda);
}
}
node *node_plambda_body(node *n , node *body )
{
  node_plambda *lambda ;

  {
  lambda = (node_plambda *)n;
  lambda->body = body;
  return ((node *)lambda);
}
}
node *node_plambda_add(node *n , node *lambda )
{
  node_plambda *l ;

  {
  l = (node_plambda *)n;
  while (l->next) {
    l = (node_plambda *)l->next;
  }
  l->next = lambda;
  return (n);
}
}
node *node_splat_new(node *n )
{
  node_splat *splat ;
  void *tmp ;

  {
  tmp = malloc(sizeof(node_splat ));
  splat = (node_splat *)tmp;
  splat->type = (node_type )14;
  splat->node = n;
  return ((node *)splat);
}
}
node *node_ns_new(node_string name , node *body )
{
  node_ns *newns ;
  void *tmp ;

  {
  tmp = malloc(sizeof(node_ns ));
  newns = (node_ns *)tmp;
  newns->type = (node_type )29;
  newns->name = name;
  newns->body = body;
  return ((node *)newns);
}
}
node *node_import_new(node_string name )
{
  node_import *nimp ;
  void *tmp ;

  {
  tmp = malloc(sizeof(node_import ));
  nimp = (node_import *)tmp;
  nimp->type = (node_type )30;
  nimp->name = name;
  return ((node *)nimp);
}
}
node *node_let_new(node_string lhs , node *rhs )
{
  node_let *nlet ;
  void *tmp ;

  {
  tmp = malloc(sizeof(node_let ));
  nlet = (node_let *)tmp;
  nlet->type = (node_type )16;
  nlet->lhs = lhs;
  nlet->rhs = rhs;
  return ((node *)nlet);
}
}
node *node_op_new(char const   *op , node *lhs , node *rhs )
{
  node_op *nop ;
  void *tmp ;
  size_t tmp___0 ;

  {
  tmp = malloc(sizeof(node_op ));
  nop = (node_op *)tmp;
  nop->type = (node_type )23;
  nop->lhs = lhs;
  tmp___0 = strlen(op);
  nop->op = node_str_new(op, (strm_int )tmp___0);
  nop->rhs = rhs;
  return ((node *)nop);
}
}
node *node_lambda_alloc(node *args , node *compstmt , int block )
{
  node_lambda *lambda ;
  void *tmp ;

  {
  tmp = malloc(sizeof(node_lambda ));
  lambda = (node_lambda *)tmp;
  lambda->type = (node_type )9;
  lambda->args = args;
  lambda->body = compstmt;
  lambda->block = block;
  if (compstmt) {
    lambda->fname = compstmt->fname;
  } else {
    lambda->fname = (char const   *)((void *)0);
  }
  if (compstmt) {
    lambda->lineno = compstmt->lineno;
  } else {
    lambda->lineno = 0;
  }
  return ((node *)lambda);
}
}
node *node_lambda_new(node *args , node *compstmt )
{
  node *tmp ;

  {
  tmp = node_lambda_alloc(args, compstmt, 0);
  return (tmp);
}
}
node *node_block_new(node *compstmt )
{
  node *tmp ;

  {
  tmp = node_lambda_alloc((node *)((void *)0), compstmt, 1);
  return (tmp);
}
}
node *node_method_new(node *args , node *compstmt )
{
  node_lambda *lambda ;
  void *tmp ;
  node_string tmp___0 ;
  node_string tmp___1 ;

  {
  tmp = malloc(sizeof(node_lambda ));
  lambda = (node_lambda *)tmp;
  lambda->type = (node_type )9;
  if (args) {
    tmp___0 = node_str_new("self", 4);
    node_args_prepend(args, tmp___0);
  } else {
    args = node_args_new();
    tmp___1 = node_str_new("self", 4);
    node_args_add(args, tmp___1);
  }
  lambda->args = args;
  lambda->body = compstmt;
  return ((node *)lambda);
}
}
node *node_call_new(node_string ident , node *recv , node *args , node *blk )
{
  node_call *ncall ;
  void *tmp ;

  {
  tmp = malloc(sizeof(node_call ));
  ncall = (node_call *)tmp;
  ncall->type = (node_type )24;
  ncall->ident = ident;
  if (! args) {
    args = node_array_new();
  }
  if (recv) {
    node_nodes_prepend(args, recv);
  }
  if (blk) {
    node_nodes_add(args, blk);
  }
  ncall->args = args;
  return ((node *)ncall);
}
}
node *node_fcall_new(node *func , node *args , node *blk )
{
  node_fcall *ncall ;
  void *tmp ;

  {
  tmp = malloc(sizeof(node_fcall ));
  ncall = (node_fcall *)tmp;
  ncall->type = (node_type )25;
  ncall->func = func;
  if (! args) {
    args = node_array_new();
  }
  if (blk) {
    node_nodes_add(args, blk);
  }
  ncall->args = args;
  return ((node *)ncall);
}
}
node *node_genfunc_new(node_string id )
{
  node_genfunc *ngf ;
  void *tmp ;

  {
  tmp = malloc(sizeof(node_genfunc ));
  ngf = (node_genfunc *)tmp;
  ngf->type = (node_type )26;
  ngf->id = id;
  return ((node *)ngf);
}
}
node *node_int_new(long i )
{
  node_int *ni ;
  void *tmp ;

  {
  tmp = malloc(sizeof(node_int ));
  ni = (node_int *)tmp;
  ni->type = (node_type )0;
  ni->value = (int32_t )i;
  return ((node *)ni);
}
}
node *node_float_new(double d )
{
  node_float *nf ;
  void *tmp ;

  {
  tmp = malloc(sizeof(node_float ));
  nf = (node_float *)tmp;
  nf->type = (node_type )1;
  nf->value = d;
  return ((node *)nf);
}
}
node *node_time_new(char const   *s , strm_int len )
{
  long sec ;
  long usec ;
  int utc_offset ;
  node_time *ns ;
  int tmp ;
  void *tmp___0 ;

  {
  tmp = strm_time_parse_time(s, len, & sec, & usec, & utc_offset);
  if (tmp < 0) {
    return ((node *)((void *)0));
  }
  tmp___0 = malloc(sizeof(node_time ));
  ns = (node_time *)tmp___0;
  ns->type = (node_type )2;
  ns->sec = sec;
  ns->usec = usec;
  ns->utc_offset = utc_offset;
  return ((node *)ns);
}
}
static strm_int string_escape(char *s , strm_int len )
{
  char *t ;
  char *tend ;
  char *p ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  unsigned char c ;
  char *xend ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  t = s;
  tend = t + len;
  p = s;
  while ((unsigned long )t < (unsigned long )tend) {
    switch ((int )*t) {
    case 92:
    t ++;
    if ((unsigned long )t == (unsigned long )tend) {
      break;
    }
    switch ((int )*t) {
    case 110:
    tmp = p;
    p ++;
    *tmp = (char )'\n';
    break;
    case 114:
    tmp___0 = p;
    p ++;
    *tmp___0 = (char )'\r';
    break;
    case 116:
    tmp___1 = p;
    p ++;
    *tmp___1 = (char )'\t';
    break;
    case 101:
    tmp___2 = p;
    p ++;
    *tmp___2 = (char)27;
    break;
    case 48:
    tmp___3 = p;
    p ++;
    *tmp___3 = (char )'\000';
    break;
    case 120:
    c = (unsigned char)0;
    xend = t + 3;
    t ++;
    while (1) {
      if ((unsigned long )t < (unsigned long )tend) {
        if (! ((unsigned long )t < (unsigned long )xend)) {
          break;
        }
      } else {
        break;
      }
      switch ((int )*t) {
      case 57:
      case 56:
      case 55:
      case 54:
      case 53:
      case 52:
      case 51:
      case 50:
      case 49:
      case 48:
      c = (unsigned char )((int )c * 16);
      c = (unsigned char )((int )c + ((int )*t - 48));
      break;
      case 102:
      case 101:
      case 100:
      case 99:
      case 98:
      case 97:
      c = (unsigned char )((int )c * 16);
      c = (unsigned char )((int )c + (((int )*t - 97) + 10));
      break;
      default:
      xend = t;
      break;
      }
      t ++;
    }
    tmp___4 = p;
    p ++;
    *tmp___4 = (char )c;
    t --;
    break;
    default:
    tmp___5 = p;
    p ++;
    *tmp___5 = *t;
    break;
    }
    t ++;
    break;
    default:
    tmp___6 = p;
    p ++;
    tmp___7 = t;
    t ++;
    *tmp___6 = *tmp___7;
    break;
    }
  }
  return ((strm_int )(p - s));
}
}
node *node_string_new(char const   *s , strm_int len )
{
  node_str *ns ;
  void *tmp ;

  {
  tmp = malloc(sizeof(node_str ));
  ns = (node_str *)tmp;
  ns->type = (node_type )3;
  len = string_escape((char *)s, len);
  ns->value = node_str_new(s, len);
  return ((node *)ns);
}
}
node *node_ident_new(node_string name )
{
  node_ident *ni ;
  void *tmp ;

  {
  tmp = malloc(sizeof(node_ident ));
  ni = (node_ident *)tmp;
  ni->type = (node_type )15;
  ni->name = name;
  return ((node *)ni);
}
}
node_string node_str_new(char const   *s , strm_int len )
{
  node_string str ;
  void *tmp ;

  {
  tmp = malloc((sizeof(struct node_string ) + (unsigned long )len) + 1UL);
  str = (node_string )tmp;
  str->len = len;
  memcpy((void * __restrict  )(str->buf), (void const   * __restrict  )s, (size_t )len);
  str->buf[len] = (char )'\000';
  return (str);
}
}
node_string node_str_escaped(char const   *s , strm_int len )
{
  node_string tmp ;

  {
  len = string_escape((char *)s, len);
  tmp = node_str_new(s, len);
  return (tmp);
}
}
static node nd  =    {(node_type )4, (char const   *)0, 0};
node *node_nil(void)
{


  {
  return (& nd);
}
}
static node_bool nd___0  =    {(node_type )5, (char const   *)0, 0, 1};
node *node_true(void)
{


  {
  return ((node *)(& nd___0));
}
}
static node_bool nd___1  =    {(node_type )5, (char const   *)0, 0, 0};
node *node_false(void)
{


  {
  return ((node *)(& nd___1));
}
}
static node *cond_body(node *body )
{
  node_lambda *lambda ;

  {
  if ((unsigned long )body == (unsigned long )((void *)0)) {
    return ((node *)((void *)0));
  }
  if ((unsigned int )body->type == 9U) {
    lambda = (node_lambda *)body;
    if (lambda->block) {
      return (lambda->body);
    }
  }
  return (body);
}
}
node *node_if_new(node *cond , node *then , node *opt_else )
{
  node_if *nif ;
  void *tmp ;

  {
  tmp = malloc(sizeof(node_if ));
  nif = (node_if *)tmp;
  nif->type = (node_type )17;
  nif->cond = cond;
  nif->then = cond_body(then);
  nif->opt_else = cond_body(opt_else);
  return ((node *)nif);
}
}
node *node_emit_new(node *value )
{
  node_emit *ne ;
  void *tmp ;

  {
  tmp = malloc(sizeof(node_emit ));
  ne = (node_emit *)tmp;
  ne->type = (node_type )18;
  ne->emit = value;
  return ((node *)ne);
}
}
static node nd___2  =    {(node_type )19, (char const   *)0, 0};
node *node_skip_new(void)
{


  {
  return (& nd___2);
}
}
node *node_return_new(node *value )
{
  node_return *nreturn ;
  void *tmp ;

  {
  tmp = malloc(sizeof(node_return ));
  nreturn = (node_return *)tmp;
  nreturn->type = (node_type )20;
  nreturn->rv = value;
  return ((node *)nreturn);
}
}
void node_parse_init(parser_state *p )
{


  {
  p->nerr = 0;
  p->lval = (void *)0;
  p->fname = (char const   *)((void *)0);
  p->lineno = 1;
  p->tline = 1;
  return;
}
}
int node_parse_file(parser_state *p , char const   *fname )
{
  int r ;
  FILE *fp ;
  FILE *tmp ;

  {
  tmp = fopen((char const   * __restrict  )fname, (char const   * __restrict  )"rb");
  fp = tmp;
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    perror("fopen");
    return (0);
  }
  p->fname = fname;
  r = node_parse_input(p, fp, fname);
  fclose(fp);
  return (r);
}
}
int node_parse_input(parser_state *p , FILE *f , char const   *fname )
{
  int n ;

  {
  yyrestart(f);
  n = yyparse(p);
  if (n == 0) {
    if (p->nerr == 0) {
      return (0);
    }
  }
  return (1);
}
}
int node_parse_string(parser_state *p , char const   *prog )
{
  int n ;

  {
  p->fname = "-e";
  yy_scan_string(prog);
  n = yyparse(p);
  if (n == 0) {
    if (p->nerr == 0) {
      return (0);
    }
  }
  return (1);
}
}
void node_free(node *np )
{


  {
  if (! np) {
    return;
  }
  switch ((unsigned int )np->type) {
  case 6U:
  node_args_free(np);
  break;
  case 17U:
  node_free(((node_if *)np)->cond);
  node_free(((node_if *)np)->then);
  node_free(((node_if *)np)->opt_else);
  free((void *)np);
  break;
  case 18U:
  node_free(((node_emit *)np)->emit);
  free((void *)np);
  break;
  case 23U:
  node_free(((node_op *)np)->lhs);
  node_free(((node_op *)np)->rhs);
  free((void *)np);
  break;
  case 9U:
  node_args_free(((node_lambda *)np)->args);
  node_free(((node_lambda *)np)->body);
  free((void *)np);
  break;
  case 24U:
  node_free(((node_call *)np)->args);
  free((void *)np);
  break;
  case 20U:
  node_free(np);
  free((void *)np);
  break;
  case 15U:
  free((void *)((node_ident *)np)->name);
  free((void *)np);
  break;
  case 27U:
  node_array_free((node_array *)np);
  break;
  case 1U:
  case 0U:
  free((void *)np);
  break;
  case 5U:
  return;
  case 3U:
  free((void *)((node_str *)np)->value);
  free((void *)np);
  break;
  default:
  break;
  }
  return;
}
}
void node_parse_free(parser_state *p )
{


  {
  node_free((node *)p->lval);
  return;
}
}
#pragma merger("0","/tmp/cil-WiB3SVIt.i","-std=gnu99,-g,-ggdb,-Wall")
static double const   khash_ac_HASH_UPPER___2  =    (double const   )0.77;
__inline static kh_ns_t *kh_init_ns(void)
{
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(kh_ns_t ));
  return ((kh_ns_t *)tmp);
}
}
__inline static khint_t kh_get_ns(kh_ns_t const   *h , khint64_t key )
{
  khint_t k ;
  khint_t i ;
  khint_t last ;
  khint_t mask ;
  khint_t step ;
  khint_t tmp ;

  {
  if (h->n_buckets) {
    step = (khint_t )0;
    mask = (khint_t )(h->n_buckets - 1U);
    k = (khint32_t )(((key >> 33) ^ key) ^ (key << 11));
    i = k & mask;
    last = i;
    while (1) {
      if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
        if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U)) {
          if (! (! (*(h->keys + i) == key))) {
            break;
          }
        }
      } else {
        break;
      }
      step ++;
      i = (i + step) & mask;
      if (i == last) {
        return ((khint_t )h->n_buckets);
      }
    }
    if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 3U) {
      tmp = h->n_buckets;
    } else {
      tmp = (khint_t const   )i;
    }
    return ((khint_t )tmp);
  } else {
    return ((khint_t )0);
  }
}
}
__inline static int kh_resize_ns(kh_ns_t *h , khint_t new_n_buckets )
{
  khint32_t *new_flags ;
  khint_t j ;
  khint_t tmp ;
  void *tmp___0 ;
  khint_t tmp___1 ;
  khint64_t *new_keys ;
  void *tmp___2 ;
  strm_state **new_vals ;
  void *tmp___3 ;
  khint64_t key ;
  strm_state *val ;
  khint_t new_mask ;
  khint_t k ;
  khint_t i ;
  khint_t step ;
  khint64_t tmp___4 ;
  strm_state *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
  new_flags = (khint32_t *)0;
  j = (khint_t )1;
  new_n_buckets --;
  new_n_buckets |= new_n_buckets >> 1;
  new_n_buckets |= new_n_buckets >> 2;
  new_n_buckets |= new_n_buckets >> 4;
  new_n_buckets |= new_n_buckets >> 8;
  new_n_buckets |= new_n_buckets >> 16;
  new_n_buckets ++;
  if (new_n_buckets < 4U) {
    new_n_buckets = (khint_t )4;
  }
  if (h->size >= (khint_t )((double const   )new_n_buckets * khash_ac_HASH_UPPER___2 + (double const   )0.5)) {
    j = (khint_t )0;
  } else {
    if (new_n_buckets < 16U) {
      tmp = (khint_t )1;
    } else {
      tmp = new_n_buckets >> 4;
    }
    tmp___0 = malloc((unsigned long )tmp * sizeof(khint32_t ));
    new_flags = (khint32_t *)tmp___0;
    if (! new_flags) {
      return (-1);
    }
    if (new_n_buckets < 16U) {
      tmp___1 = (khint_t )1;
    } else {
      tmp___1 = new_n_buckets >> 4;
    }
    memset((void *)new_flags, 170, (unsigned long )tmp___1 * sizeof(khint32_t ));
    if (h->n_buckets < new_n_buckets) {
      tmp___2 = realloc((void *)h->keys, (unsigned long )new_n_buckets * sizeof(khint64_t ));
      new_keys = (khint64_t *)tmp___2;
      if (! new_keys) {
        free((void *)new_flags);
        return (-1);
      }
      h->keys = new_keys;
      tmp___3 = realloc((void *)h->vals, (unsigned long )new_n_buckets * sizeof(strm_state *));
      new_vals = (strm_state **)tmp___3;
      if (! new_vals) {
        free((void *)new_flags);
        return (-1);
      }
      h->vals = new_vals;
    }
  }
  if (j) {
    j = (khint_t )0;
    while (j != h->n_buckets) {
      if (((*(h->flags + (j >> 4)) >> ((j & 15U) << 1)) & 3U) == 0U) {
        key = *(h->keys + j);
        new_mask = new_n_buckets - 1U;
        val = *(h->vals + j);
        *(h->flags + (j >> 4)) = (khint32_t )((unsigned long )*(h->flags + (j >> 4)) | (1UL << ((j & 15U) << 1)));
        while (1) {
          step = (khint_t )0;
          k = (khint32_t )(((key >> 33) ^ key) ^ (key << 11));
          i = k & new_mask;
          while (! ((*(new_flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
            step ++;
            i = (i + step) & new_mask;
          }
          *(new_flags + (i >> 4)) = (khint32_t )((unsigned long )*(new_flags + (i >> 4)) & ~ (2UL << ((i & 15U) << 1)));
          if (i < h->n_buckets) {
            if (((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 3U) == 0U) {
              tmp___4 = *(h->keys + i);
              *(h->keys + i) = key;
              key = tmp___4;
              tmp___5 = *(h->vals + i);
              *(h->vals + i) = val;
              val = tmp___5;
              *(h->flags + (i >> 4)) = (khint32_t )((unsigned long )*(h->flags + (i >> 4)) | (1UL << ((i & 15U) << 1)));
            } else {
              *(h->keys + i) = key;
              *(h->vals + i) = val;
              break;
            }
          } else {
            *(h->keys + i) = key;
            *(h->vals + i) = val;
            break;
          }
        }
      }
      j ++;
    }
    if (h->n_buckets > new_n_buckets) {
      tmp___6 = realloc((void *)h->keys, (unsigned long )new_n_buckets * sizeof(khint64_t ));
      h->keys = (khint64_t *)tmp___6;
      tmp___7 = realloc((void *)h->vals, (unsigned long )new_n_buckets * sizeof(strm_state *));
      h->vals = (strm_state **)tmp___7;
    }
    free((void *)h->flags);
    h->flags = new_flags;
    h->n_buckets = new_n_buckets;
    h->n_occupied = h->size;
    h->upper_bound = (khint_t )((double const   )h->n_buckets * khash_ac_HASH_UPPER___2 + (double const   )0.5);
  }
  return (0);
}
}
__inline static khint_t kh_put_ns(kh_ns_t *h , khint64_t key , int *ret )
{
  khint_t x ;
  int tmp ;
  int tmp___0 ;
  khint_t k ;
  khint_t i ;
  khint_t site ;
  khint_t last ;
  khint_t mask ;
  khint_t step ;

  {
  if (h->n_occupied >= h->upper_bound) {
    if (h->n_buckets > h->size << 1) {
      tmp = kh_resize_ns(h, h->n_buckets - 1U);
      if (tmp < 0) {
        *ret = -1;
        return (h->n_buckets);
      }
    } else {
      tmp___0 = kh_resize_ns(h, h->n_buckets + 1U);
      if (tmp___0 < 0) {
        *ret = -1;
        return (h->n_buckets);
      }
    }
  }
  mask = h->n_buckets - 1U;
  step = (khint_t )0;
  site = h->n_buckets;
  x = site;
  k = (khint32_t )(((key >> 33) ^ key) ^ (key << 11));
  i = k & mask;
  if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U) {
    x = i;
  } else {
    last = i;
    while (1) {
      if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
        if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U)) {
          if (! (! (*(h->keys + i) == key))) {
            break;
          }
        }
      } else {
        break;
      }
      if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U) {
        site = i;
      }
      step ++;
      i = (i + step) & mask;
      if (i == last) {
        x = site;
        break;
      }
    }
    if (x == h->n_buckets) {
      if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U) {
        if (site != h->n_buckets) {
          x = site;
        } else {
          x = i;
        }
      } else {
        x = i;
      }
    }
  }
  if ((*(h->flags + (x >> 4)) >> ((x & 15U) << 1)) & 2U) {
    *(h->keys + x) = key;
    *(h->flags + (x >> 4)) = (khint32_t )((unsigned long )*(h->flags + (x >> 4)) & ~ (3UL << ((x & 15U) << 1)));
    (h->size) ++;
    (h->n_occupied) ++;
    *ret = 1;
  } else
  if ((*(h->flags + (x >> 4)) >> ((x & 15U) << 1)) & 1U) {
    *(h->keys + x) = key;
    *(h->flags + (x >> 4)) = (khint32_t )((unsigned long )*(h->flags + (x >> 4)) & ~ (3UL << ((x & 15U) << 1)));
    (h->size) ++;
    *ret = 2;
  } else {
    *ret = 0;
  }
  return (x);
}
}
static kh_ns_t *nstbl  ;
static strm_state szero  =    {(void *)0, (struct strm_state *)0, 0U};
strm_string strm_ns_name(strm_state *state )
{
  khiter_t k ;

  {
  if (! nstbl) {
    return ((strm_string )0);
  }
  k = (khint_t )0;
  while (k != nstbl->n_buckets) {
    if (! ((*(nstbl->flags + (k >> 4)) >> ((k & 15U) << 1)) & 3U)) {
      if ((unsigned long )*(nstbl->vals + k) == (unsigned long )state) {
        return (*(nstbl->keys + k));
      }
    }
    k ++;
  }
  return ((strm_string )0);
}
}
strm_state *strm_ns_get(strm_string name )
{
  khiter_t k ;

  {
  if (! nstbl) {
    return ((strm_state *)((void *)0));
  }
  k = kh_get_ns((kh_ns_t const   *)nstbl, (khint64_t )((intptr_t )name));
  if (k == nstbl->n_buckets) {
    return ((strm_state *)((void *)0));
  }
  return (*(nstbl->vals + k));
}
}
strm_state *strm_ns_create(strm_state *state , strm_string name )
{
  strm_state *s ;
  strm_state *tmp ;
  int r ;
  khiter_t k ;
  void *tmp___0 ;

  {
  tmp = strm_ns_get(name);
  s = tmp;
  if (! s) {
    if (! nstbl) {
      nstbl = kh_init_ns();
    }
    k = kh_put_ns(nstbl, (khint64_t )((intptr_t )name), & r);
    if (r < 0) {
      return ((strm_state *)((void *)0));
    }
    if (r == 0) {
      if (*(nstbl->vals + k)) {
        return ((strm_state *)((void *)0));
      }
    }
    tmp___0 = malloc(sizeof(strm_state ));
    s = (strm_state *)tmp___0;
    if (s) {
      *s = szero;
      s->prev = state;
    }
    *(nstbl->vals + k) = s;
  }
  return (s);
}
}
strm_state *strm_ns_new(strm_state *state , char const   *name )
{
  strm_string s ;
  size_t tmp ;
  strm_string tmp___0 ;
  strm_state *tmp___1 ;

  {
  tmp = strlen(name);
  tmp___0 = strm_str_new(name, (strm_int )tmp);
  s = tmp___0;
  tmp___1 = strm_ns_create(state, s);
  return (tmp___1);
}
}
#pragma merger("0","/tmp/cil-7XkJsMIP.i","-std=gnu99,-g,-ggdb,-Wall")
extern  __attribute__((__nothrow__)) double acos(double __x ) ;
extern  __attribute__((__nothrow__)) double asin(double __x ) ;
extern  __attribute__((__nothrow__)) double atan(double __x ) ;
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
extern  __attribute__((__nothrow__)) double tan(double __x ) ;
extern  __attribute__((__nothrow__)) double cosh(double __x ) ;
extern  __attribute__((__nothrow__)) double sinh(double __x ) ;
extern  __attribute__((__nothrow__)) double tanh(double __x ) ;
extern  __attribute__((__nothrow__)) double acosh(double __x ) ;
extern  __attribute__((__nothrow__)) double asinh(double __x ) ;
extern  __attribute__((__nothrow__)) double atanh(double __x ) ;
extern  __attribute__((__nothrow__)) double exp(double __x ) ;
extern  __attribute__((__nothrow__)) double frexp(double __x , int *__exponent ) ;
extern  __attribute__((__nothrow__)) double ldexp(double __x , int __exponent ) ;
extern  __attribute__((__nothrow__)) double log(double __x ) ;
extern  __attribute__((__nothrow__)) double log2(double __x ) ;
extern  __attribute__((__nothrow__)) double hypot(double __x , double __y ) ;
extern  __attribute__((__nothrow__)) double cbrt(double __x ) ;
extern  __attribute__((__nothrow__)) double erfc(double  ) ;
extern  __attribute__((__nothrow__)) double round(double __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) double trunc(double __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int abs(int __x )  __attribute__((__const__)) ;
static int math_sqrt(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double f ;
  int tmp ;
  double tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "f", & f);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = sqrt(f);
  *ret = strm_float_value(tmp___0);
  return (0);
}
}
static int math_sin(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double f ;
  int tmp ;
  double tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "f", & f);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = sin(f);
  *ret = strm_float_value(tmp___0);
  return (0);
}
}
static int math_sinh(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double f ;
  int tmp ;
  double tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "f", & f);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = sinh(f);
  *ret = strm_float_value(tmp___0);
  return (0);
}
}
static int math_cos(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double f ;
  int tmp ;
  double tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "f", & f);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = cos(f);
  *ret = strm_float_value(tmp___0);
  return (0);
}
}
static int math_cosh(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double f ;
  int tmp ;
  double tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "f", & f);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = cosh(f);
  *ret = strm_float_value(tmp___0);
  return (0);
}
}
static int math_tan(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double f ;
  int tmp ;
  double tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "f", & f);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = tan(f);
  *ret = strm_float_value(tmp___0);
  return (0);
}
}
static int math_tanh(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double f ;
  int tmp ;
  double tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "f", & f);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = tanh(f);
  *ret = strm_float_value(tmp___0);
  return (0);
}
}
static int math_pow(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double x ;
  double y ;
  int tmp ;
  double tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "ff", & x, & y);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = pow(x, y);
  *ret = strm_float_value(tmp___0);
  return (0);
}
}
static int GCD(int a , int b )
{
  int tmp ;
  int tmp___0 ;

  {
  if (b) {
    tmp = GCD(b, a % b);
    tmp___0 = tmp;
  } else {
    tmp___0 = a;
  }
  return (tmp___0);
}
}
static int math_gcd(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  int x ;
  int y ;
  int tmp ;
  int tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "ii", & x, & y);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = GCD(x, y);
  *ret = strm_float_value((double )tmp___0);
  return (0);
}
}
static int math_fabs(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double f ;
  int tmp ;
  int tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "f", & f);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = abs((int )f);
  *ret = strm_float_value((double )tmp___0);
  return (0);
}
}
static int math_acosh(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double f ;
  int tmp ;
  double tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "f", & f);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = acosh(f);
  *ret = strm_float_value(tmp___0);
  return (0);
}
}
static int math_asinh(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double f ;
  int tmp ;
  double tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "f", & f);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = asinh(f);
  *ret = strm_float_value(tmp___0);
  return (0);
}
}
static int math_atanh(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double f ;
  int tmp ;
  double tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "f", & f);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = atanh(f);
  *ret = strm_float_value(tmp___0);
  return (0);
}
}
static int math_acos(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double f ;
  int tmp ;
  double tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "f", & f);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = acos(f);
  *ret = strm_float_value(tmp___0);
  return (0);
}
}
static int math_asin(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double f ;
  int tmp ;
  double tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "f", & f);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = asin(f);
  *ret = strm_float_value(tmp___0);
  return (0);
}
}
static int math_atan(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double f ;
  int tmp ;
  double tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "f", & f);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = atan(f);
  *ret = strm_float_value(tmp___0);
  return (0);
}
}
static int math_log(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double f ;
  int tmp ;
  double tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "f", & f);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = log(f);
  *ret = strm_float_value(tmp___0);
  return (0);
}
}
static int math_log10(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double f ;
  int tmp ;
  double tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "f", & f);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = log10(f);
  *ret = strm_float_value(tmp___0);
  return (0);
}
}
static int math_exp(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double f ;
  int tmp ;
  double tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "f", & f);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = exp(f);
  *ret = strm_float_value(tmp___0);
  return (0);
}
}
static int math_log2(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double f ;
  int tmp ;
  double tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "f", & f);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = log2(f);
  *ret = strm_float_value(tmp___0);
  return (0);
}
}
static int math_erfc(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double f ;
  int tmp ;
  double tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "f", & f);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = erfc(f);
  *ret = strm_float_value(tmp___0);
  return (0);
}
}
static int math_cbrt(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double f ;
  int tmp ;
  double tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "f", & f);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = cbrt(f);
  *ret = strm_float_value(tmp___0);
  return (0);
}
}
static int math_hypot(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double x ;
  double y ;
  int tmp ;
  double tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "ff", & x, & y);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = hypot(x, y);
  *ret = strm_float_value(tmp___0);
  return (0);
}
}
static int math_frexp(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double x ;
  int y ;
  int tmp ;
  double tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "ff", & x, & y);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = frexp(x, & y);
  *ret = strm_float_value(tmp___0);
  return (0);
}
}
static int math_ldexp(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double x ;
  int y ;
  int tmp ;
  double tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "ff", & x, & y);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = ldexp(x, y);
  *ret = strm_float_value(tmp___0);
  return (0);
}
}
static int math_round(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double x ;
  strm_int d ;
  int tmp ;
  double tmp___0 ;
  double f ;
  double tmp___1 ;
  double tmp___2 ;

  {
  d = 0;
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "f|i", & x, & d);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  if (argc == 1) {
    tmp___0 = round(x);
    *ret = strm_float_value(tmp___0);
  } else {
    tmp___1 = pow((double )10, (double )d);
    f = tmp___1;
    tmp___2 = round(x * f);
    *ret = strm_float_value(tmp___2 / f);
  }
  return (0);
}
}
static int math_ceil(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double x ;
  strm_int d ;
  int tmp ;
  double tmp___0 ;
  double f ;
  double tmp___1 ;
  double tmp___2 ;

  {
  d = 0;
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "f|i", & x, & d);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  if (argc == 1) {
    tmp___0 = ceil(x);
    *ret = strm_float_value(tmp___0);
  } else {
    tmp___1 = pow((double )10, (double )d);
    f = tmp___1;
    tmp___2 = ceil(x * f);
    *ret = strm_float_value(tmp___2 / f);
  }
  return (0);
}
}
static int math_floor(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double x ;
  strm_int d ;
  int tmp ;
  double tmp___0 ;
  double f ;
  double tmp___1 ;
  double tmp___2 ;

  {
  d = 0;
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "f|i", & x, & d);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  if (argc == 1) {
    tmp___0 = floor(x);
    *ret = strm_float_value(tmp___0);
  } else {
    tmp___1 = pow((double )10, (double )d);
    f = tmp___1;
    tmp___2 = floor(x * f);
    *ret = strm_float_value(tmp___2 / f);
  }
  return (0);
}
}
static int math_trunc(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double x ;
  strm_int d ;
  int tmp ;
  double tmp___0 ;
  double f ;
  double tmp___1 ;
  double tmp___2 ;

  {
  d = 0;
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "f|i", & x, & d);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  if (argc == 1) {
    tmp___0 = trunc(x);
    *ret = strm_float_value(tmp___0);
  } else {
    tmp___1 = pow((double )10, (double )d);
    f = tmp___1;
    tmp___2 = trunc(x * f);
    *ret = strm_float_value(tmp___2 / f);
  }
  return (0);
}
}
void strm_math_init(strm_state *state )
{
  strm_value tmp ;
  strm_value tmp___0 ;
  strm_value tmp___1 ;
  strm_value tmp___2 ;
  strm_value tmp___3 ;
  strm_value tmp___4 ;
  strm_value tmp___5 ;
  strm_value tmp___6 ;
  strm_value tmp___7 ;
  strm_value tmp___8 ;
  strm_value tmp___9 ;
  strm_value tmp___10 ;
  strm_value tmp___11 ;
  strm_value tmp___12 ;
  strm_value tmp___13 ;
  strm_value tmp___14 ;
  strm_value tmp___15 ;
  strm_value tmp___16 ;
  strm_value tmp___17 ;
  strm_value tmp___18 ;
  strm_value tmp___19 ;
  strm_value tmp___20 ;
  strm_value tmp___21 ;
  strm_value tmp___22 ;
  strm_value tmp___23 ;
  strm_value tmp___24 ;
  strm_value tmp___25 ;
  strm_value tmp___26 ;
  strm_value tmp___27 ;
  strm_value tmp___28 ;
  strm_value tmp___29 ;
  strm_value tmp___30 ;

  {
  tmp = strm_float_value(3.14159265358979323846);
  strm_var_def(state, "PI", tmp);
  tmp___0 = strm_float_value(2.7182818284590452354);
  strm_var_def(state, "E", tmp___0);
  tmp___1 = strm_cfunc_value(& math_sqrt);
  strm_var_def(state, "sqrt", tmp___1);
  tmp___2 = strm_cfunc_value(& math_sin);
  strm_var_def(state, "sin", tmp___2);
  tmp___3 = strm_cfunc_value(& math_cos);
  strm_var_def(state, "cos", tmp___3);
  tmp___4 = strm_cfunc_value(& math_tan);
  strm_var_def(state, "tan", tmp___4);
  tmp___5 = strm_cfunc_value(& math_sinh);
  strm_var_def(state, "sinh", tmp___5);
  tmp___6 = strm_cfunc_value(& math_cosh);
  strm_var_def(state, "cosh", tmp___6);
  tmp___7 = strm_cfunc_value(& math_asin);
  strm_var_def(state, "asin", tmp___7);
  tmp___8 = strm_cfunc_value(& math_acos);
  strm_var_def(state, "acos", tmp___8);
  tmp___9 = strm_cfunc_value(& math_atan);
  strm_var_def(state, "atan", tmp___9);
  tmp___10 = strm_cfunc_value(& math_asinh);
  strm_var_def(state, "asinh", tmp___10);
  tmp___11 = strm_cfunc_value(& math_acosh);
  strm_var_def(state, "acosh", tmp___11);
  tmp___12 = strm_cfunc_value(& math_atanh);
  strm_var_def(state, "atanh", tmp___12);
  tmp___13 = strm_cfunc_value(& math_tanh);
  strm_var_def(state, "tanh", tmp___13);
  tmp___14 = strm_cfunc_value(& math_pow);
  strm_var_def(state, "pow", tmp___14);
  tmp___15 = strm_cfunc_value(& math_round);
  strm_var_def(state, "round", tmp___15);
  tmp___16 = strm_cfunc_value(& math_ceil);
  strm_var_def(state, "ceil", tmp___16);
  tmp___17 = strm_cfunc_value(& math_floor);
  strm_var_def(state, "floor", tmp___17);
  tmp___18 = strm_cfunc_value(& math_trunc);
  strm_var_def(state, "trunc", tmp___18);
  tmp___19 = strm_cfunc_value(& math_trunc);
  strm_var_def(state, "int", tmp___19);
  tmp___20 = strm_cfunc_value(& math_fabs);
  strm_var_def(state, "fabs", tmp___20);
  tmp___21 = strm_cfunc_value(& math_log);
  strm_var_def(state, "log", tmp___21);
  tmp___22 = strm_cfunc_value(& math_log10);
  strm_var_def(state, "log10", tmp___22);
  tmp___23 = strm_cfunc_value(& math_log2);
  strm_var_def(state, "log2", tmp___23);
  tmp___24 = strm_cfunc_value(& math_exp);
  strm_var_def(state, "exp", tmp___24);
  tmp___25 = strm_cfunc_value(& math_erfc);
  strm_var_def(state, "erfc", tmp___25);
  tmp___26 = strm_cfunc_value(& math_cbrt);
  strm_var_def(state, "cbrt", tmp___26);
  tmp___27 = strm_cfunc_value(& math_hypot);
  strm_var_def(state, "hypot", tmp___27);
  tmp___28 = strm_cfunc_value(& math_frexp);
  strm_var_def(state, "frexp", tmp___28);
  tmp___29 = strm_cfunc_value(& math_ldexp);
  strm_var_def(state, "ldexp", tmp___29);
  tmp___30 = strm_cfunc_value(& math_gcd);
  strm_var_def(state, "gcd", tmp___30);
  return;
}
}
#pragma merger("0","/tmp/cil-hfwkaace.i","-std=gnu99,-g,-ggdb,-Wall")
extern int printf(char const   * __restrict  __format  , ...) ;
int strm_signal(int sig , void (*func)(int  , void * ) , void *arg ) ;
int strm_unsignal(int sig , void (*func)(int  , void * ) ) ;
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request
                                               , ...) ;
static int refcnt  =    0;
static int winch  =    0;
static int interrupt  =    0;
static void sigupdate(int sig , void *arg )
{
  int *var ;

  {
  var = (int *)arg;
  *var = 1;
  return;
}
}
static int get_winsize(int *row , int *col )
{
  struct winsize w ;
  int n ;

  {
  n = ioctl(1, 21523UL, & w);
  if (n < 0) {
    return (1);
  } else
  if ((int )w.ws_col == 0) {
    return (1);
  }
  *row = (int )w.ws_row;
  *col = (int )w.ws_col;
  return (0);
}
}
static void move_cursor(int row , int col )
{


  {
  printf((char const   * __restrict  )"\033[%d;%dH", row, col);
  return;
}
}
static void clear(void)
{


  {
  printf((char const   * __restrict  )"\033[2J");
  return;
}
}
static void erase_cursor(void)
{


  {
  printf((char const   * __restrict  )"\033[?25l");
  return;
}
}
static void show_cursor(void)
{


  {
  printf((char const   * __restrict  )"\033[?25h");
  return;
}
}
static void show_title(struct bar_data *d )
{
  int start ;

  {
  erase_cursor();
  clear();
  if (d->tlen == 0) {
    return;
  }
  start = (d->col - d->tlen) / 2;
  move_cursor(1, start);
  fwrite((void const   * __restrict  )d->title, (size_t )d->tlen, (size_t )1, (FILE * __restrict  )stdout);
  return;
}
}
static void show_yaxis(struct bar_data *d )
{
  int i ;

  {
  move_cursor(1, 2);
  printf((char const   * __restrict  )"\033[0m");
  i = 0;
  while (i < d->llen) {
    move_cursor(i + 2, d->dlen + 1);
    if (i == 0) {
      printf((char const   * __restrict  )"\342\224\234 %d   ", d->max);
    } else
    if (i == d->llen - 1) {
      printf((char const   * __restrict  )"\342\224\234 0");
    } else {
      printf((char const   * __restrict  )"|");
    }
    i ++;
  }
  return;
}
}
static void show_bar(struct bar_data *d , int i , int n )
{
  double f ;
  int line ;

  {
  f = (*(d->data + i) / (double )d->max) * (double )d->llen;
  line = 0;
  while (line < d->llen) {
    move_cursor((d->llen + 1) - line, n);
    if ((double )line < f) {
      printf((char const   * __restrict  )"\033[7m ");
    } else
    if (line == 0) {
      printf((char const   * __restrict  )"\033[0m_");
    } else {
      printf((char const   * __restrict  )"\033[0m ");
    }
    line ++;
  }
  return;
}
}
static void show_graph(struct bar_data *d )
{
  int n ;
  int i ;
  int tmp ;
  int i___0 ;
  int tmp___0 ;

  {
  n = 1;
  show_yaxis(d);
  i = d->offset;
  while (i < d->dlen) {
    tmp = n;
    n ++;
    show_bar(d, i, tmp);
    i ++;
  }
  i___0 = 0;
  while (i___0 < d->offset) {
    tmp___0 = n;
    n ++;
    show_bar(d, i___0, tmp___0);
    i___0 ++;
  }
  return;
}
}
static int init_bar(struct bar_data *d )
{
  int tmp ;
  void *tmp___0 ;
  int i ;

  {
  tmp = get_winsize(& d->row, & d->col);
  if (tmp) {
    return (1);
  }
  d->max = 1;
  d->offset = 0;
  d->dlen = d->col - 6;
  d->llen = d->row - 3;
  tmp___0 = malloc((unsigned long )d->dlen * sizeof(double ));
  d->data = (double *)tmp___0;
  i = 0;
  while (i < d->dlen) {
    *(d->data + i) = (double )0;
    i ++;
  }
  show_title(d);
  return (0);
}
}
static int iter_bar(strm_stream *strm , strm_value data )
{
  struct bar_data *d ;
  double f ;
  double max ;
  int tmp ;
  int tmp___0 ;
  strm_int tmp___1 ;
  int i ;

  {
  d = (struct bar_data *)strm->data;
  max = 1.0;
  if (interrupt) {
    interrupt = 0;
    strm_unsignal(2, & sigupdate);
    move_cursor(d->row - 1, 1);
    show_cursor();
    exit(1);
  }
  tmp = strm_number_p(data);
  if (! tmp) {
    strm_raise(strm, "invalid data");
    return (1);
  }
  if (winch) {
    winch = 0;
    free((void *)d->data);
    tmp___0 = init_bar(d);
    if (tmp___0 == 1) {
      strm_stream_close(strm);
      return (1);
    }
  }
  f = strm_value_float(data);
  if (f < (double )0) {
    f = (double )0;
  }
  tmp___1 = d->offset;
  (d->offset) ++;
  *(d->data + tmp___1) = f;
  max = 1.0;
  i = 0;
  while (i < d->dlen) {
    f = *(d->data + i);
    if (f > max) {
      max = f;
    }
    i ++;
  }
  d->max = (strm_int )max;
  if (d->offset == d->dlen) {
    d->offset = 0;
  }
  show_graph(d);
  return (0);
}
}
static int fin_bar(strm_stream *strm , strm_value data )
{
  struct bar_data *d ;

  {
  d = (struct bar_data *)strm->data;
  move_cursor(d->row, 1);
  if (d->title) {
    free((void *)d->title);
  }
  free((void *)d->data);
  free((void *)d);
  show_cursor();
  __sync_fetch_and_add(& refcnt, 1);
  if (refcnt <= 0) {
    strm_unsignal(28, & sigupdate);
    strm_unsignal(2, & sigupdate);
  }
  return (0);
}
}
static int exec_bgraph(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  struct bar_data *d ;
  char *title ;
  strm_int tlen ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  strm_stream *tmp___3 ;

  {
  title = (char *)((void *)0);
  tlen = 0;
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "|s", & title, & tlen);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = malloc(sizeof(struct bar_data ));
  d = (struct bar_data *)tmp___0;
  if (! d) {
    return (1);
  }
  tmp___1 = malloc((size_t )tlen);
  d->title = (char const   *)tmp___1;
  memcpy((void * __restrict  )((void *)d->title), (void const   * __restrict  )title,
         (size_t )tlen);
  d->tlen = tlen;
  if (refcnt == 0) {
    __sync_fetch_and_add(& refcnt, 1);
    strm_signal(28, & sigupdate, (void *)(& winch));
    strm_signal(2, & sigupdate, (void *)(& interrupt));
  }
  tmp___2 = init_bar(d);
  if (tmp___2 == 1) {
    return (1);
  }
  tmp___3 = strm_stream_new((strm_stream_mode )2, & iter_bar, & fin_bar, (void *)d);
  *ret = strm_ptr_value((void *)tmp___3);
  return (0);
}
}
void strm_graph_init(strm_state *state )
{
  strm_value tmp ;

  {
  tmp = strm_cfunc_value(& exec_bgraph);
  strm_var_def(state, "graph_bar", tmp);
  return;
}
}
#pragma merger("0","/tmp/cil-A8Kfcc50.i","-std=gnu99,-g,-ggdb,-Wall")
#pragma merger("0","/tmp/cil-AJvJPA5U.i","-std=gnu99,-g,-ggdb,-Wall")
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
extern void ( __attribute__((__nonnull__(1,4))) qsort_r)(void *__base , size_t __nmemb ,
                                                         size_t __size , int (*__compar)(void const   * ,
                                                                                         void const   * ,
                                                                                         void * ) ,
                                                         void *__arg ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
static int num_cmp(strm_value x , strm_value y )
{
  double a ;
  double tmp ;
  double b ;
  double tmp___0 ;

  {
  tmp = strm_value_float(x);
  a = tmp;
  tmp___0 = strm_value_float(y);
  b = tmp___0;
  if (a > b) {
    return (1);
  } else
  if (a < b) {
    return (-1);
  }
  return (0);
}
}
static int str_cmp(strm_value x , strm_value y )
{
  strm_string a ;
  strm_string b ;
  strm_int alen ;
  strm_int tmp ;
  strm_int blen ;
  strm_int tmp___0 ;
  strm_int len ;
  strm_int cmp ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  a = x;
  b = y;
  tmp = strm_str_len(a);
  alen = tmp;
  tmp___0 = strm_str_len(b);
  blen = tmp___0;
  if (alen > blen) {
    len = blen;
  } else {
    len = alen;
  }
  tmp___1 = strm_strp_ptr(& b);
  tmp___2 = strm_strp_ptr(& a);
  cmp = memcmp((void const   *)tmp___2, (void const   *)tmp___1, (size_t )len);
  if (cmp == 0) {
    if (alen > len) {
      return (1);
    }
    if (blen > len) {
      return (-1);
    }
  }
  return (cmp);
}
}
static int strm_cmp(strm_value a , strm_value b )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  tmp___1 = strm_number_p(a);
  if (tmp___1) {
    tmp___0 = strm_number_p(b);
    if (tmp___0) {
      tmp = num_cmp(a, b);
      return (tmp);
    }
    return (-1);
  }
  tmp___5 = strm_string_p(a);
  if (tmp___5) {
    tmp___3 = strm_string_p(b);
    if (tmp___3) {
      tmp___2 = str_cmp(a, b);
      return (tmp___2);
    }
    tmp___4 = strm_number_p(b);
    if (tmp___4) {
      return (1);
    }
    return (1);
  }
  return (1);
}
}
static int sort_cmp(void const   *a_p , void const   *b_p )
{
  strm_value a ;
  strm_value b ;
  int tmp ;

  {
  a = *((strm_value *)a_p);
  b = *((strm_value *)b_p);
  tmp = strm_cmp(a, b);
  return (tmp);
}
}
static int sort_cmpf(void const   *a_p , void const   *b_p , void *arg )
{
  strm_value args[2] ;
  struct sort_arg *a ;
  strm_value val ;
  strm_int cmp ;
  int tmp ;
  int tmp___0 ;

  {
  a = (struct sort_arg *)arg;
  args[0] = *((strm_value *)a_p);
  args[1] = *((strm_value *)b_p);
  tmp = strm_funcall(a->strm, a->func, 2, args, & val);
  if (tmp == 1) {
    return (0);
  }
  tmp___0 = strm_number_p(val);
  if (! tmp___0) {
    return (0);
  }
  cmp = strm_value_int(val);
  if (cmp > 0) {
    return (1);
  } else
  if (cmp < 0) {
    return (-1);
  }
  return (0);
}
}
static void mem_sort(strm_value *p , strm_int len , struct sort_arg *arg )
{


  {
  if (arg) {
    qsort_r((void *)p, (size_t )len, sizeof(strm_value ), & sort_cmpf, (void *)arg);
  } else {
    qsort((void *)p, (size_t )len, sizeof(strm_value ), & sort_cmp);
  }
  return;
}
}
static int iter_sort(strm_stream *strm , strm_value data )
{
  struct sort_data *d ;
  void *tmp ;
  strm_int tmp___0 ;

  {
  d = (struct sort_data *)strm->data;
  if (d->len >= d->capa) {
    d->capa *= 2;
    tmp = realloc((void *)d->buf, sizeof(strm_value ) * (unsigned long )d->capa);
    d->buf = (strm_value *)tmp;
  }
  tmp___0 = d->len;
  (d->len) ++;
  *(d->buf + tmp___0) = data;
  return (0);
}
}
static int finish_sort(strm_stream *strm , strm_value data )
{
  struct sort_data *d ;
  strm_int i ;
  strm_int len ;
  struct sort_arg arg ;
  int tmp ;

  {
  d = (struct sort_data *)strm->data;
  tmp = strm_nil_p(d->func);
  if (tmp) {
    mem_sort(d->buf, d->len, (struct sort_arg *)((void *)0));
  } else {
    arg.strm = strm;
    arg.func = d->func;
    mem_sort(d->buf, d->len, & arg);
  }
  i = 0;
  len = d->len;
  while (i < len) {
    strm_emit(strm, *(d->buf + i), (int (*)(strm_stream * , strm_value  ))((void *)0));
    i ++;
  }
  free((void *)d->buf);
  free((void *)d);
  return (0);
}
}
static int exec_sort(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  struct sort_data *d ;
  strm_value func ;
  strm_value tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  strm_stream *tmp___3 ;

  {
  tmp = strm_nil_value();
  func = tmp;
  while (1) {
    tmp___0 = strm_parse_args(strm, argc, args, "|v", & func);
    if (tmp___0 == 1) {
      return (1);
    }
    break;
  }
  tmp___1 = malloc(sizeof(struct sort_data ));
  d = (struct sort_data *)tmp___1;
  if (! d) {
    return (1);
  }
  d->func = func;
  d->len = 0;
  d->capa = 1024;
  tmp___2 = malloc(sizeof(strm_value ) * 1024UL);
  d->buf = (strm_value *)tmp___2;
  if (! d->buf) {
    free((void *)d);
    return (1);
  }
  tmp___3 = strm_stream_new((strm_stream_mode )1, & iter_sort, & finish_sort, (void *)d);
  *ret = strm_ptr_value((void *)tmp___3);
  return (0);
}
}
static int ary_sort(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_array ary ;
  strm_value *p ;
  strm_int len ;
  strm_value func ;
  int tmp ;
  struct strm_array *tmp___0 ;
  struct sort_arg arg ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "a|v", & p, & len, & func);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  ary = strm_ary_new((strm_value const   *)p, len);
  tmp___0 = strm_ary_struct(ary);
  p = tmp___0->ptr;
  if (argc == 1) {
    mem_sort(p, len, (struct sort_arg *)((void *)0));
  } else {
    arg.strm = strm;
    arg.func = func;
    mem_sort(p, len, & arg);
  }
  *ret = ary;
  return (0);
}
}
static int sortby_cmp(void const   *a_p , void const   *b_p )
{
  struct sortby_value *av ;
  struct sortby_value *bv ;
  double a ;
  double b ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  av = (struct sortby_value *)a_p;
  bv = (struct sortby_value *)b_p;
  tmp___0 = strm_number_p(av->v);
  if (tmp___0) {
    a = strm_value_float(av->v);
  } else {
    tmp = strm_number_p(bv->v);
    if (tmp) {
      return (1);
    }
    return (0);
  }
  tmp___1 = strm_number_p(bv->v);
  if (tmp___1) {
    b = strm_value_float(bv->v);
  } else {
    return (-1);
  }
  if (a > b) {
    return (1);
  } else
  if (a < b) {
    return (-1);
  }
  return (0);
}
}
static int iter_sortby(strm_stream *strm , strm_value data )
{
  struct sortby_data *d ;
  void *tmp ;
  int tmp___0 ;

  {
  d = (struct sortby_data *)strm->data;
  if (d->len >= d->capa) {
    d->capa *= 2;
    tmp = realloc((void *)d->buf, sizeof(struct sortby_value ) * (unsigned long )d->capa);
    d->buf = (struct sortby_value *)tmp;
  }
  (d->buf + d->len)->o = data;
  tmp___0 = strm_funcall(d->strm, d->func, 1, & data, & (d->buf + d->len)->v);
  if (tmp___0 == 1) {
    return (1);
  }
  (d->len) ++;
  return (0);
}
}
static int finish_sortby(strm_stream *strm , strm_value data )
{
  struct sortby_data *d ;
  strm_int i ;
  strm_int len ;

  {
  d = (struct sortby_data *)strm->data;
  qsort((void *)d->buf, (size_t )d->len, sizeof(struct sortby_value ), & sortby_cmp);
  i = 0;
  len = d->len;
  while (i < len) {
    strm_emit(strm, (d->buf + i)->o, (int (*)(strm_stream * , strm_value  ))((void *)0));
    i ++;
  }
  free((void *)d->buf);
  free((void *)d);
  return (0);
}
}
static int exec_sortby(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  struct sortby_data *d ;
  strm_value func ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  strm_stream *tmp___2 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "v", & func);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = malloc(sizeof(struct sortby_data ));
  d = (struct sortby_data *)tmp___0;
  if (! d) {
    return (1);
  }
  d->strm = strm;
  d->func = func;
  d->len = 0;
  d->capa = 1024;
  tmp___1 = malloc(sizeof(struct sortby_value ) * 1024UL);
  d->buf = (struct sortby_value *)tmp___1;
  if (! d->buf) {
    free((void *)d);
    return (1);
  }
  tmp___2 = strm_stream_new((strm_stream_mode )1, & iter_sortby, & finish_sortby,
                            (void *)d);
  *ret = strm_ptr_value((void *)tmp___2);
  return (0);
}
}
static int ary_sortby(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  struct sortby_value *buf ;
  strm_value *p ;
  strm_int len ;
  strm_value func ;
  strm_array ary ;
  strm_int i ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  struct strm_array *tmp___2 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "av", & p, & len, & func);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = malloc(sizeof(struct sortby_value ) * (unsigned long )len);
  buf = (struct sortby_value *)tmp___0;
  if (! buf) {
    return (1);
  }
  i = 0;
  while (i < len) {
    (buf + i)->o = *(p + i);
    tmp___1 = strm_funcall(strm, func, 1, p + i, & (buf + i)->v);
    if (tmp___1 == 1) {
      free((void *)buf);
      return (1);
    }
    i ++;
  }
  qsort((void *)buf, (size_t )len, sizeof(struct sortby_value ), & sortby_cmp);
  ary = strm_ary_new((strm_value const   *)((void *)0), len);
  tmp___2 = strm_ary_struct(ary);
  p = tmp___2->ptr;
  i = 0;
  while (i < len) {
    *(p + i) = (buf + i)->o;
    i ++;
  }
  free((void *)buf);
  *ret = ary;
  return (0);
}
}
static strm_value quick_select(strm_value *arr , int n )
{
  int low ;
  int high ;
  int median ;
  int middle ;
  int ll ;
  int hh ;
  strm_value t ;
  int tmp ;
  strm_value t___0 ;
  int tmp___0 ;
  strm_value t___1 ;
  int tmp___1 ;
  strm_value t___2 ;
  int tmp___2 ;
  strm_value t___3 ;
  int tmp___3 ;
  int tmp___4 ;
  strm_value t___4 ;
  strm_value t___5 ;

  {
  low = 0;
  high = n - 1;
  median = (low + high) / 2;
  while (1) {
    if (high <= low) {
      return (*(arr + median));
    }
    if (high == low + 1) {
      tmp = strm_cmp(*(arr + low), *(arr + high));
      if (tmp > 0) {
        t = *(arr + low);
        *(arr + low) = *(arr + high);
        *(arr + high) = t;
      }
      return (*(arr + median));
    }
    middle = (low + high) / 2;
    tmp___0 = strm_cmp(*(arr + middle), *(arr + high));
    if (tmp___0 > 0) {
      t___0 = *(arr + middle);
      *(arr + middle) = *(arr + high);
      *(arr + high) = t___0;
    }
    tmp___1 = strm_cmp(*(arr + low), *(arr + high));
    if (tmp___1 > 0) {
      t___1 = *(arr + low);
      *(arr + low) = *(arr + high);
      *(arr + high) = t___1;
    }
    tmp___2 = strm_cmp(*(arr + middle), *(arr + low));
    if (tmp___2 > 0) {
      t___2 = *(arr + middle);
      *(arr + middle) = *(arr + low);
      *(arr + low) = t___2;
    }
    t___3 = *(arr + middle);
    *(arr + middle) = *(arr + (low + 1));
    *(arr + (low + 1)) = t___3;
    ll = low + 1;
    hh = high;
    while (1) {
      while (1) {
        ll ++;
        tmp___3 = strm_cmp(*(arr + low), *(arr + ll));
        if (! (tmp___3 > 0)) {
          break;
        }
      }
      while (1) {
        hh --;
        tmp___4 = strm_cmp(*(arr + hh), *(arr + low));
        if (! (tmp___4 > 0)) {
          break;
        }
      }
      if (hh < ll) {
        break;
      }
      t___4 = *(arr + ll);
      *(arr + ll) = *(arr + hh);
      *(arr + hh) = t___4;
    }
    t___5 = *(arr + low);
    *(arr + low) = *(arr + hh);
    *(arr + hh) = t___5;
    if (hh <= median) {
      low = ll;
    }
    if (hh >= median) {
      high = hh - 1;
    }
  }
}
}
static strm_value quick_median(strm_value *p , int len )
{
  strm_value v ;
  strm_value tmp ;
  strm_int next ;
  double x ;
  double tmp___0 ;
  double y ;
  double tmp___1 ;
  strm_value tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  tmp = quick_select(p, len);
  v = tmp;
  if (len % 2 == 0) {
    tmp___4 = strm_number_p(v);
    if (tmp___4) {
      next = len / 2;
      tmp___3 = strm_number_p(*(p + next));
      if (tmp___3) {
        tmp___0 = strm_value_float(v);
        x = tmp___0;
        tmp___1 = strm_value_float(*(p + next));
        y = tmp___1;
        tmp___2 = strm_float_value((x + y) / (double )2);
        return (tmp___2);
      }
    }
  }
  return (v);
}
}
static int iter_median(strm_stream *strm , strm_value data )
{
  struct sort_data *d ;
  void *tmp ;
  strm_int tmp___0 ;
  strm_int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  d = (struct sort_data *)strm->data;
  if (d->len >= d->capa) {
    d->capa *= 2;
    tmp = realloc((void *)d->buf, sizeof(strm_value ) * (unsigned long )d->capa);
    d->buf = (strm_value *)tmp;
  }
  tmp___3 = strm_nil_p(d->func);
  if (tmp___3) {
    tmp___0 = d->len;
    (d->len) ++;
    *(d->buf + tmp___0) = data;
  } else {
    tmp___1 = d->len;
    (d->len) ++;
    tmp___2 = strm_funcall(strm, d->func, 1, & data, d->buf + tmp___1);
    if (tmp___2 == 1) {
      return (1);
    }
  }
  return (0);
}
}
static int finish_median(strm_stream *strm , strm_value data )
{
  struct sort_data *d ;
  strm_value v ;

  {
  d = (struct sort_data *)strm->data;
  v = quick_median(d->buf, d->len);
  free((void *)d->buf);
  strm_emit(strm, v, (int (*)(strm_stream * , strm_value  ))((void *)0));
  free((void *)d);
  return (0);
}
}
static int exec_median(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  struct sort_data *d ;
  strm_value func ;
  int tmp ;
  void *tmp___0 ;
  strm_value tmp___1 ;
  void *tmp___2 ;
  strm_stream *tmp___3 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "|v", & func);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = malloc(sizeof(struct sort_data ));
  d = (struct sort_data *)tmp___0;
  if (! d) {
    return (1);
  }
  if (argc == 0) {
    tmp___1 = strm_nil_value();
    d->func = tmp___1;
  } else {
    d->func = func;
  }
  d->len = 0;
  d->capa = 1024;
  tmp___2 = malloc(sizeof(strm_value ) * 1024UL);
  d->buf = (strm_value *)tmp___2;
  if (! d->buf) {
    free((void *)d);
    return (1);
  }
  tmp___3 = strm_stream_new((strm_stream_mode )1, & iter_median, & finish_median,
                            (void *)d);
  *ret = strm_ptr_value((void *)tmp___3);
  return (0);
}
}
static int ary_median(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_value *buf ;
  strm_value *p ;
  strm_int len ;
  strm_value func ;
  strm_int i ;
  int tmp ;
  void *tmp___0 ;
  strm_value func___0 ;
  int tmp___1 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "a|v", & p, & len, & func);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  if (len == 0) {
    strm_raise(strm, "empty array");
    return (1);
  }
  tmp___0 = malloc(sizeof(strm_value ) * (unsigned long )len);
  buf = (strm_value *)tmp___0;
  if (! buf) {
    return (1);
  }
  if (argc == 1) {
    memcpy((void * __restrict  )buf, (void const   * __restrict  )p, sizeof(strm_value ) * (unsigned long )len);
  } else {
    func___0 = *(args + 1);
    i = 0;
    while (i < len) {
      tmp___1 = strm_funcall(strm, func___0, 1, p + i, buf + i);
      if (tmp___1 == 1) {
        free((void *)buf);
        return (1);
      }
      i ++;
    }
  }
  *ret = quick_median(buf, len);
  free((void *)buf);
  return (0);
}
}
static int exec_cmp(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_int cmp ;
  strm_value x ;
  strm_value y ;
  int tmp ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "vv", & x, & y);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  cmp = strm_cmp(x, y);
  *ret = strm_int_value(cmp);
  return (0);
}
}
static int str_lt(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_value x ;
  strm_value y ;
  int cmp ;
  int tmp ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "SS", & x, & y);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  cmp = str_cmp(x, y);
  *ret = strm_bool_value(cmp < 0);
  return (0);
}
}
static int str_le(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_value x ;
  strm_value y ;
  int cmp ;
  int tmp ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "SS", & x, & y);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  cmp = str_cmp(x, y);
  *ret = strm_bool_value(cmp <= 0);
  return (0);
}
}
static int str_gt(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_value x ;
  strm_value y ;
  int cmp ;
  int tmp ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "SS", & x, & y);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  cmp = str_cmp(x, y);
  *ret = strm_bool_value(cmp > 0);
  return (0);
}
}
static int str_ge(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_value x ;
  strm_value y ;
  int cmp ;
  int tmp ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "SS", & x, & y);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  cmp = str_cmp(x, y);
  *ret = strm_bool_value(cmp >= 0);
  return (0);
}
}
void strm_sort_init(strm_state *state )
{
  strm_value tmp ;
  strm_value tmp___0 ;
  strm_value tmp___1 ;
  strm_value tmp___2 ;
  strm_value tmp___3 ;
  strm_value tmp___4 ;
  strm_value tmp___5 ;
  strm_value tmp___6 ;
  strm_value tmp___7 ;
  strm_value tmp___8 ;
  strm_value tmp___9 ;

  {
  tmp = strm_cfunc_value(& ary_sort);
  strm_var_def(strm_ns_array, "sort", tmp);
  tmp___0 = strm_cfunc_value(& ary_sortby);
  strm_var_def(strm_ns_array, "sort_by", tmp___0);
  tmp___1 = strm_cfunc_value(& ary_median);
  strm_var_def(strm_ns_array, "median", tmp___1);
  tmp___2 = strm_cfunc_value(& exec_cmp);
  strm_var_def(state, "cmp", tmp___2);
  tmp___3 = strm_cfunc_value(& exec_sort);
  strm_var_def(state, "sort", tmp___3);
  tmp___4 = strm_cfunc_value(& exec_sortby);
  strm_var_def(state, "sort_by", tmp___4);
  tmp___5 = strm_cfunc_value(& exec_median);
  strm_var_def(state, "median", tmp___5);
  tmp___6 = strm_cfunc_value(& str_lt);
  strm_var_def(strm_ns_string, "<", tmp___6);
  tmp___7 = strm_cfunc_value(& str_le);
  strm_var_def(strm_ns_string, "<=", tmp___7);
  tmp___8 = strm_cfunc_value(& str_gt);
  strm_var_def(strm_ns_string, ">", tmp___8);
  tmp___9 = strm_cfunc_value(& str_ge);
  strm_var_def(strm_ns_string, ">=", tmp___9);
  return;
}
}
#pragma merger("0","/tmp/cil-8b6ufkn3.i","-std=gnu99,-g,-ggdb,-Wall")
extern FILE *stdin ;
extern int putchar(int __c ) ;
extern int puts(char const   *__s ) ;
static void fprint_str(node_string str , FILE *f )
{


  {
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%.*s", str->len, str->buf);
  return;
}
}
static void print_str(node_string name )
{


  {
  fprint_str(name, stdout);
  fputs((char const   * __restrict  )"\n", (FILE * __restrict  )stdout);
  return;
}
}
static void print_id(char const   *pre , node_string name )
{


  {
  fputs((char const   * __restrict  )pre, (FILE * __restrict  )stdout);
  print_str(name);
  return;
}
}
static void print_quoted_id(char const   *pre , node_string name )
{


  {
  fputs((char const   * __restrict  )pre, (FILE * __restrict  )stdout);
  fputs((char const   * __restrict  )"\"", (FILE * __restrict  )stdout);
  fprint_str(name, stdout);
  fputs((char const   * __restrict  )"\"\n", (FILE * __restrict  )stdout);
  return;
}
}
static void dump_node(node *np , int indent )
{
  int i ;
  node_args *args ;
  int j ;
  node_string s ;
  node *opt_else ;
  node_nodes *ary ;
  node_nodes *ary___0 ;
  node_psplat *cons ;
  node_splat *splat ;
  node_string s___0 ;
  node_string s___1 ;
  int j___0 ;
  node_array *ary___1 ;
  node_string *h ;
  node_string ns ;
  node_nodes *ary___2 ;
  node_time *nt ;
  char const   *tmp ;

  {
  i = 0;
  while (i < indent) {
    putchar(' ');
    i ++;
  }
  if (! np) {
    printf((char const   * __restrict  )"NIL\n");
    return;
  }
  switch ((unsigned int )np->type) {
  case 6U:
  args = (node_args *)np;
  printf((char const   * __restrict  )"ARGS(%d):\n", args->len);
  i = 0;
  while (i < args->len) {
    s = *(args->data + i);
    j = 0;
    while (j < indent + 1) {
      putchar(' ');
      j ++;
    }
    print_str(s);
    i ++;
  }
  break;
  case 17U:
  printf((char const   * __restrict  )"IF:\n");
  dump_node(((node_if *)np)->cond, indent + 1);
  i = 0;
  while (i < indent) {
    putchar(' ');
    i ++;
  }
  printf((char const   * __restrict  )"THEN:\n");
  dump_node(((node_if *)np)->then, indent + 1);
  opt_else = ((node_if *)np)->opt_else;
  if ((unsigned long )opt_else != (unsigned long )((void *)0)) {
    i = 0;
    while (i < indent) {
      putchar(' ');
      i ++;
    }
    printf((char const   * __restrict  )"ELSE:\n");
    dump_node(opt_else, indent + 1);
  }
  break;
  case 18U:
  printf((char const   * __restrict  )"EMIT:\n");
  dump_node(((node_emit *)np)->emit, indent + 1);
  break;
  case 23U:
  printf((char const   * __restrict  )"OP:\n");
  i = 0;
  while (i < indent + 1) {
    putchar(' ');
    i ++;
  }
  print_id("op: ", ((node_op *)np)->op);
  dump_node(((node_op *)np)->lhs, indent + 1);
  dump_node(((node_op *)np)->rhs, indent + 1);
  break;
  case 9U:
  printf((char const   * __restrict  )"LAMBDA:\n");
  dump_node(((node_lambda *)np)->args, indent + 1);
  dump_node(((node_lambda *)np)->body, indent + 1);
  break;
  case 10U:
  printf((char const   * __restrict  )"PLAMBDA:\n");
  dump_node(((node_plambda *)np)->pat, indent + 1);
  if (((node_plambda *)np)->cond) {
    i = 0;
    while (i < indent + 2) {
      putchar(' ');
      i ++;
    }
    printf((char const   * __restrict  )"IF:\n");
    dump_node(((node_plambda *)np)->cond, indent + 2);
  }
  dump_node(((node_plambda *)np)->body, indent + 1);
  if (((node_plambda *)np)->next) {
    dump_node(((node_plambda *)np)->next, indent);
  }
  break;
  case 11U:
  printf((char const   * __restrict  )"PARRAY:\n");
  ary = (node_nodes *)np;
  i = 0;
  while (i < ary->len) {
    dump_node(*(ary->data + i), indent + 1);
    i ++;
  }
  break;
  case 12U:
  printf((char const   * __restrict  )"PSTRUCT:\n");
  ary___0 = (node_nodes *)np;
  i = 0;
  while (i < ary___0->len) {
    dump_node(*(ary___0->data + i), indent + 1);
    i ++;
  }
  break;
  case 13U:
  printf((char const   * __restrict  )"PSPLAT:\n");
  cons = (node_psplat *)np;
  dump_node(cons->head, indent + 1);
  i = 0;
  while (i < indent + 1) {
    putchar(' ');
    i ++;
  }
  printf((char const   * __restrict  )"REST:\n");
  dump_node(cons->mid, indent + 2);
  i = 0;
  while (i < indent + 1) {
    putchar(' ');
    i ++;
  }
  printf((char const   * __restrict  )"TAIL:\n");
  dump_node(cons->tail, indent + 2);
  break;
  case 14U:
  printf((char const   * __restrict  )"SPLAT:\n");
  splat = (node_splat *)np;
  dump_node(splat->node, indent + 1);
  break;
  case 24U:
  printf((char const   * __restrict  )"CALL:\n");
  i = 0;
  while (i < indent + 2) {
    putchar(' ');
    i ++;
  }
  s___0 = ((node_call *)np)->ident;
  print_str(s___0);
  dump_node(((node_call *)np)->args, indent + 2);
  break;
  case 25U:
  printf((char const   * __restrict  )"FCALL:\n");
  i = 0;
  while (i < indent + 1) {
    putchar(' ');
    i ++;
  }
  printf((char const   * __restrict  )"FUNC:\n");
  dump_node(((node_fcall *)np)->func, indent + 2);
  i = 0;
  while (i < indent + 1) {
    putchar(' ');
    i ++;
  }
  printf((char const   * __restrict  )"ARGS:\n");
  dump_node(((node_fcall *)np)->args, indent + 2);
  break;
  case 26U:
  printf((char const   * __restrict  )"GENFUNC: ");
  s___1 = ((node_genfunc *)np)->id;
  print_str(s___1);
  break;
  case 20U:
  printf((char const   * __restrict  )"RETURN:\n");
  dump_node(((node_return *)np)->rv, indent + 1);
  break;
  case 16U:
  print_id("LET: ", ((node_let *)np)->lhs);
  dump_node(((node_let *)np)->rhs, indent + 1);
  break;
  case 15U:
  print_id("IDENT: ", ((node_ident *)np)->name);
  break;
  case 27U:
  printf((char const   * __restrict  )"ARRAY:\n");
  ary___1 = (node_array *)np;
  if (ary___1->headers) {
    h = ary___1->headers;
    i = 0;
    while (i < ary___1->len) {
      j___0 = 0;
      while (j___0 < indent + 1) {
        putchar(' ');
        j___0 ++;
      }
      print_quoted_id("key: ", *(h + i));
      dump_node(*(ary___1->data + i), indent + 1);
      i ++;
    }
  } else {
    i = 0;
    while (i < ary___1->len) {
      dump_node(*(ary___1->data + i), indent + 1);
      i ++;
    }
  }
  if (ary___1->ns) {
    ns = ary___1->ns;
    j___0 = 0;
    while (j___0 < indent + 1) {
      putchar(' ');
      j___0 ++;
    }
    print_quoted_id("class: ", ns);
  }
  break;
  case 28U:
  printf((char const   * __restrict  )"NODES:\n");
  ary___2 = (node_nodes *)np;
  i = 0;
  while (i < ary___2->len) {
    dump_node(*(ary___2->data + i), indent + 1);
    i ++;
  }
  break;
  case 30U:
  print_id("IMPORT: ", ((node_import *)np)->name);
  break;
  case 29U:
  print_id("NAMESPACE: ", ((node_ns *)np)->name);
  dump_node(((node_ns *)np)->body, indent + 1);
  break;
  case 0U:
  printf((char const   * __restrict  )"VALUE(NUMBER): %d\n", ((node_int *)np)->value);
  break;
  case 1U:
  printf((char const   * __restrict  )"VALUE(NUMBER): %f\n", ((node_float *)np)->value);
  break;
  case 2U:
  nt = (node_time *)np;
  printf((char const   * __restrict  )"VALUE(TIME): %ld.%ld(%+05d)\n", nt->sec, nt->usec,
         nt->utc_offset);
  break;
  case 5U:
  if (((node_bool *)np)->value) {
    tmp = "true";
  } else {
    tmp = "false";
  }
  printf((char const   * __restrict  )"VALUE(BOOL): %s\n", tmp);
  break;
  case 3U:
  print_quoted_id("VALUE(STRING): ", ((node_str *)np)->value);
  break;
  case 4U:
  printf((char const   * __restrict  )"VALUE(NIL): nil\n");
  break;
  default:
  printf((char const   * __restrict  )"UNKNOWN(%d)\n", (unsigned int )np->type);
  break;
  }
  return;
}
}
int strm_option_verbose  =    0;
int main(int argc , char const   **argv )
{
  char const   *prog ;
  char const   *e_prog ;
  int i ;
  int n ;
  int verbose ;
  int check ;
  parser_state state ;
  char const   *s ;
  int tmp ;
  int tmp___0 ;
  strm_array av ;
  strm_array tmp___1 ;
  strm_value *buf ;
  struct strm_array *tmp___2 ;
  int i___0 ;
  size_t tmp___3 ;
  strm_string tmp___4 ;
  int tmp___5 ;

  {
  prog = *(argv + 0);
  e_prog = (char const   *)((void *)0);
  n = 0;
  verbose = 0;
  check = 0;
  while (1) {
    if (argc > 1) {
      if (! ((int const   )*(*(argv + 1) + 0) == 45)) {
        break;
      }
    } else {
      break;
    }
    s = *(argv + 1) + 1;
    while (*s) {
      switch ((int const   )*s) {
      case 118:
      verbose = 1;
      case 119:
      strm_option_verbose = 1;
      break;
      case 99:
      check = 1;
      break;
      case 101:
      if ((int const   )*(s + 1) == 0) {
        e_prog = *(argv + 2);
        argc --;
        argv ++;
      } else {
        e_prog = s + 1;
      }
      goto next_arg;
      default:
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: unknown option -%c\n",
              prog, (int const   )*s);
      }
      s ++;
    }
    next_arg:
    argc --;
    argv ++;
  }
  node_parse_init(& state);
  if (e_prog) {
    tmp = node_parse_string(& state, e_prog);
    n += tmp;
  } else
  if (argc == 1) {
    n = node_parse_input(& state, stdin, "stdin");
  } else {
    i = 1;
    while (i < argc) {
      tmp___0 = node_parse_file(& state, *(argv + i));
      n += tmp___0;
      i ++;
    }
  }
  if (n == 0) {
    if (verbose) {
      dump_node((node *)state.lval, 0);
    }
    if (check) {
      puts("Syntax OK");
    } else {
      tmp___1 = strm_ary_new((strm_value const   *)((void *)0), argc);
      av = tmp___1;
      tmp___2 = strm_ary_struct(av);
      buf = tmp___2->ptr;
      i___0 = 0;
      while (i___0 < argc) {
        tmp___3 = strlen(*(argv + i___0));
        tmp___4 = strm_str_new(*(argv + i___0), (strm_int )tmp___3);
        *(buf + i___0) = tmp___4;
        i___0 ++;
      }
      strm_var_def((strm_state *)((void *)0), "ARGV", av);
      node_run(& state);
      strm_loop();
      node_stop();
    }
  } else
  if (check) {
    puts("Syntax NG");
  }
  node_parse_free(& state);
  if (n > 0) {
    tmp___5 = 1;
  } else {
    tmp___5 = 0;
  }
  return (tmp___5);
}
}
#pragma merger("0","/tmp/cil-z7Z4J_IT.i","-std=gnu99,-g,-ggdb,-Wall")
static int count_fields(strm_string line , char sep )
{
  char const   *ptr ;
  char const   *tmp ;
  char const   *pend ;
  strm_int tmp___0 ;
  int cnt ;
  int quoted ;

  {
  tmp = strm_strp_ptr(& line);
  ptr = tmp;
  tmp___0 = strm_str_len(line);
  pend = ptr + tmp___0;
  quoted = 0;
  cnt = 1;
  while ((unsigned long )ptr < (unsigned long )pend) {
    if (quoted) {
      if ((int const   )*(ptr + 0) == 34) {
        if ((int const   )*(ptr + 1) == 34) {
          ptr ++;
          goto __Cont;
        }
        quoted = 0;
      }
      goto __Cont;
    }
    switch ((int const   )*ptr) {
    case 34:
    quoted = 1;
    goto __Cont;
    case 9:
    case 44:
    if ((int const   )*ptr == (int const   )sep) {
      cnt ++;
    }
    goto __Cont;
    default:
    goto __Cont;
    }
    __Cont: /* CIL Label */
    ptr ++;
  }
  if (quoted) {
    return (-1);
  }
  return (cnt);
}
}
static strm_value csv_string(char const   *p , strm_int len , enum csv_type ftype )
{
  strm_string str ;
  char const   *pend ;
  char *t ;
  char *s ;
  int in_quote ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  long sec ;
  long usec ;
  int offset ;
  strm_value tmp___3 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
  switch ((unsigned int )ftype) {
  case 4U:
  pend = p + len;
  in_quote = 0;
  tmp = malloc((size_t )(len + 1));
  s = (char *)tmp;
  t = s;
  while ((unsigned long )p < (unsigned long )pend) {
    if (in_quote) {
      if ((int const   )*p == 34) {
        if ((int const   )*(p + 1) == 34) {
          p ++;
          tmp___0 = t;
          t ++;
          *tmp___0 = (char )'\"';
          continue;
        } else {
          in_quote = 0;
        }
      } else {
        tmp___1 = t;
        t ++;
        *tmp___1 = (char )*p;
      }
    } else
    if ((int const   )*p == 34) {
      in_quote = 1;
    } else {
      tmp___2 = t;
      t ++;
      *tmp___2 = (char )*p;
    }
    p ++;
  }
  str = strm_str_new((char const   *)s, (strm_int )(t - s));
  free((void *)s);
  break;
  default:
  tmp___5 = __ctype_b_loc();
  if ((int const   )*(*tmp___5 + (int )*p) & 2048) {
    tmp___4 = strm_time_parse_time(p, len, & sec, & usec, & offset);
    if (tmp___4 == 0) {
      tmp___3 = strm_time_new(sec, usec, offset);
      return (tmp___3);
    }
  }
  str = strm_str_new(p, len);
  break;
  }
  return (str);
}
}
static strm_value csv_value(char const   *p , strm_int len , enum csv_type ftype )
{
  char const   *s ;
  char const   *send ;
  long i ;
  double f ;
  double pow___0 ;
  enum csv_type type ;
  unsigned short const   **tmp ;
  strm_value tmp___0 ;
  strm_value tmp___1 ;
  strm_value tmp___2 ;

  {
  s = p;
  send = s + len;
  i = 0L;
  pow___0 = (double )1;
  type = (enum csv_type )1;
  switch ((unsigned int )ftype) {
  case 2U:
  case 0U:
  while (1) {
    tmp = __ctype_b_loc();
    if (! ((int const   )*(*tmp + (int )*s) & 8192)) {
      break;
    }
    s ++;
  }
  while ((unsigned long )s < (unsigned long )send) {
    switch ((int const   )*s) {
    case 57:
    case 56:
    case 55:
    case 54:
    case 53:
    case 52:
    case 51:
    case 50:
    case 49:
    case 48:
    if ((unsigned int )type == 1U) {
      type = (enum csv_type )5;
    }
    i = i * 10L + (long )((int const   )*s - 48);
    pow___0 *= (double )10;
    break;
    case 46:
    if ((unsigned int )type == 6U) {
      type = (enum csv_type )3;
      break;
    }
    type = (enum csv_type )6;
    f = (double )i;
    i = 0L;
    pow___0 = (double )1;
    break;
    default:
    type = (enum csv_type )0;
    break;
    }
    s ++;
  }
  default:
  break;
  }
  switch ((unsigned int )type) {
  case 5U:
  tmp___0 = strm_int_value((strm_int )i);
  return (tmp___0);
  case 6U:
  f += (double )i / pow___0;
  tmp___1 = strm_float_value(f);
  return (tmp___1);
  default:
  tmp___2 = csv_string(p, len, ftype);
  return (tmp___2);
  }
}
}
enum csv_type csv_type(strm_value v )
{
  int tmp ;
  int tmp___0 ;

  {
  tmp = strm_number_p(v);
  if (tmp) {
    return ((enum csv_type )2);
  }
  tmp___0 = strm_time_p(v);
  if (tmp___0) {
    return ((enum csv_type )3);
  } else {
    return ((enum csv_type )1);
  }
}
}
static int sv_accept(strm_stream *strm , strm_value data )
{
  strm_array ary ;
  strm_string line ;
  strm_value *bp ;
  char const   *fbeg ;
  char const   *ptr ;
  char const   *pend ;
  int fieldcnt ;
  int in_quote ;
  int all_str ;
  int i ;
  enum csv_type ftype ;
  enum csv_type *types ;
  struct csv_data *cd ;
  char sep ;
  strm_int len ;
  strm_int tmp ;
  strm_int tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  strm_int tmp___3 ;
  char const   *tmp___4 ;
  strm_int tmp___5 ;
  strm_int tmp___6 ;
  char const   *tmp___7 ;
  strm_int tmp___8 ;
  strm_int tmp___9 ;
  struct strm_array *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  struct strm_array *tmp___13 ;
  strm_array h ;
  strm_value *p ;
  struct strm_array *tmp___14 ;
  int i___0 ;
  strm_string str ;
  strm_string tmp___15 ;
  struct strm_array *tmp___16 ;
  void *tmp___17 ;
  struct strm_array *tmp___18 ;
  struct strm_array *tmp___19 ;
  enum csv_type tmp___20 ;

  {
  line = data;
  in_quote = 0;
  all_str = 1;
  i = 0;
  cd = (struct csv_data *)strm->data;
  sep = cd->sep;
  if (cd->prev) {
    tmp = strm_str_len(cd->prev);
    tmp___0 = strm_str_len(line);
    len = (tmp + tmp___0) + 1;
    tmp___2 = malloc((size_t )len);
    tmp___1 = (char *)tmp___2;
    tmp___3 = strm_str_len(cd->prev);
    tmp___4 = strm_strp_ptr(& cd->prev);
    memcpy((void * __restrict  )tmp___1, (void const   * __restrict  )tmp___4, (size_t )tmp___3);
    tmp___5 = strm_str_len(cd->prev);
    *(tmp___1 + tmp___5) = (char )'\n';
    tmp___6 = strm_str_len(line);
    tmp___7 = strm_strp_ptr(& line);
    tmp___8 = strm_str_len(cd->prev);
    memcpy((void * __restrict  )((tmp___1 + tmp___8) + 1), (void const   * __restrict  )tmp___7,
           (size_t )tmp___6);
    line = strm_str_new((char const   *)tmp___1, len);
    free((void *)tmp___1);
    cd->prev = (strm_string )0;
  }
  fieldcnt = count_fields(line, cd->sep);
  if (fieldcnt == -1) {
    cd->prev = line;
    return (1);
  }
  if (cd->n > 0) {
    if (fieldcnt != cd->n) {
      return (1);
    }
  }
  ptr = strm_strp_ptr(& line);
  tmp___9 = strm_str_len(line);
  pend = ptr + tmp___9;
  ary = strm_ary_new((strm_value const   *)((void *)0), fieldcnt);
  if (! ary) {
    return (1);
  }
  tmp___10 = strm_ary_struct(ary);
  bp = tmp___10->ptr;
  types = cd->types;
  if (types) {
    ftype = *(types + 0);
  } else {
    ftype = (enum csv_type )0;
  }
  fbeg = ptr;
  while ((unsigned long )ptr < (unsigned long )pend) {
    if (in_quote) {
      if ((int const   )*ptr == 34) {
        if ((int const   )*(ptr + 1) == 34) {
          ptr ++;
          ftype = (enum csv_type )4;
          goto __Cont;
        }
        in_quote = 0;
      }
      goto __Cont;
    }
    switch ((int const   )*ptr) {
    case 34:
    in_quote = 1;
    if ((unsigned long )ptr == (unsigned long )fbeg) {
      ftype = (enum csv_type )1;
      fbeg = ptr + 1;
    } else {
      ftype = (enum csv_type )4;
    }
    goto __Cont;
    case 9:
    case 44:
    if ((int const   )*ptr != (int const   )sep) {
      goto __Cont;
    }
    *bp = csv_value(fbeg, (strm_int )(ptr - fbeg), ftype);
    tmp___11 = strm_string_p(*bp);
    if (! tmp___11) {
      all_str = 0;
    }
    bp ++;
    fbeg = ptr + 1;
    i ++;
    if (types) {
      ftype = *(types + i);
    } else {
      ftype = (enum csv_type )0;
    }
    break;
    default:
    goto __Cont;
    }
    __Cont: /* CIL Label */
    ptr ++;
  }
  if ((int const   )*(ptr + -1) == 10) {
    ptr --;
  }
  if ((int const   )*(ptr + -1) == 13) {
    ptr --;
  }
  *bp = csv_value(fbeg, (strm_int )(ptr - fbeg), ftype);
  tmp___12 = strm_string_p(*bp);
  if (! tmp___12) {
    all_str = 0;
  }
  if (! cd->headers) {
    if (! cd->types) {
      if (all_str) {
        cd->headers = ary;
        ary = (strm_array )0;
      }
      cd->n = fieldcnt;
    }
  }
  if (ary) {
    if (cd->headers) {
      tmp___13 = strm_ary_struct(ary);
      tmp___13->headers = cd->headers;
    }
    if (! cd->types) {
      if (cd->headers) {
        if (all_str) {
          strm_emit(strm, cd->headers, (int (*)(strm_stream * , strm_value  ))((void *)0));
          cd->headers = (strm_array )0;
        } else {
          h = cd->headers;
          tmp___14 = strm_ary_struct(h);
          p = tmp___14->ptr;
          i___0 = 0;
          while (1) {
            tmp___16 = strm_ary_struct(h);
            if (! (i___0 < tmp___16->len)) {
              break;
            }
            str = *(p + i___0);
            tmp___15 = strm_str_intern_str(str);
            *(p + i___0) = tmp___15;
            i___0 ++;
          }
        }
      }
      tmp___17 = malloc(sizeof(enum csv_type ) * (unsigned long )fieldcnt);
      cd->types = (enum csv_type *)tmp___17;
      if (! cd->types) {
        return (1);
      }
      i = 0;
      while (i < fieldcnt) {
        tmp___18 = strm_ary_struct(ary);
        *(cd->types + i) = csv_type(*(tmp___18->ptr + i));
        i ++;
      }
    } else {
      i = 0;
      while (i < fieldcnt) {
        tmp___19 = strm_ary_struct(ary);
        tmp___20 = csv_type(*(tmp___19->ptr + i));
        if ((unsigned int )*(cd->types + i) != (unsigned int )tmp___20) {
          strm_raise(strm, "csv type mismatch");
          return (1);
        }
        i ++;
      }
    }
    strm_emit(strm, ary, (int (*)(strm_stream * , strm_value  ))((void *)0));
  }
  return (0);
}
}
static int sv_finish(strm_stream *strm , strm_value data )
{
  struct csv_data *cd ;

  {
  cd = (struct csv_data *)strm->data;
  if (cd->headers) {
    if ((unsigned long )cd->types == (unsigned long )((void *)0)) {
      strm_emit(strm, cd->headers, (int (*)(strm_stream * , strm_value  ))((void *)0));
      cd->headers = (strm_array )0;
    }
  }
  if (cd->types) {
    free((void *)cd->types);
    cd->types = (enum csv_type *)((void *)0);
  }
  free((void *)cd);
  return (0);
}
}
static int sv(strm_stream *strm , int argc , strm_value *args , strm_value *ret ,
              char sep )
{
  strm_stream *t ;
  struct csv_data *cd ;
  int tmp ;
  void *tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "");
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = malloc(sizeof(struct csv_data ));
  cd = (struct csv_data *)tmp___0;
  if (! cd) {
    return (1);
  }
  cd->headers = (strm_array )0;
  cd->types = (enum csv_type *)((void *)0);
  cd->prev = (strm_string )0;
  cd->sep = sep;
  cd->n = 0;
  t = strm_stream_new((strm_stream_mode )1, & sv_accept, & sv_finish, (void *)cd);
  *ret = strm_ptr_value((void *)t);
  return (0);
}
}
static int csv(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  int tmp ;

  {
  tmp = sv(strm, argc, args, ret, (char )',');
  return (tmp);
}
}
static int tsv(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  int tmp ;

  {
  tmp = sv(strm, argc, args, ret, (char )'\t');
  return (tmp);
}
}
static int ltsv_accept(strm_stream *strm , strm_value data )
{
  int tmp ;
  char const   *p ;
  char const   *tmp___0 ;
  strm_int len ;
  strm_int tmp___1 ;
  char const   *pend ;
  char const   *s ;
  int nval ;
  void *tmp___2 ;
  strm_array ary ;
  strm_array tmp___3 ;
  strm_value *v ;
  struct strm_array *tmp___4 ;
  strm_array hdr ;
  strm_array tmp___5 ;
  strm_value *h ;
  struct strm_array *tmp___6 ;
  int i ;
  strm_string str ;
  char const   *rend ;
  void *tmp___7 ;
  void *tmp___8 ;
  struct strm_array *tmp___9 ;

  {
  tmp = strm_string_p(data);
  if (! tmp) {
    strm_raise(strm, "ltsv: string required");
    return (1);
  }
  tmp___0 = strm_strp_ptr(& data);
  p = tmp___0;
  tmp___1 = strm_str_len(data);
  len = tmp___1;
  pend = p + len;
  s = p;
  nval = 0;
  while ((unsigned long )p < (unsigned long )pend) {
    tmp___2 = memchr((void const   *)p, '\t', (size_t )(pend - p));
    s = (char const   *)tmp___2;
    nval ++;
    if ((unsigned long )s == (unsigned long )((void *)0)) {
      break;
    }
    p = s + 1;
  }
  tmp___3 = strm_ary_new((strm_value const   *)((void *)0), nval);
  ary = tmp___3;
  tmp___4 = strm_ary_struct(ary);
  v = tmp___4->ptr;
  tmp___5 = strm_ary_new((strm_value const   *)((void *)0), nval);
  hdr = tmp___5;
  tmp___6 = strm_ary_struct(hdr);
  h = tmp___6->ptr;
  p = strm_strp_ptr(& data);
  i = 0;
  while (i < nval) {
    tmp___7 = memchr((void const   *)p, '\t', (size_t )(pend - p));
    rend = (char const   *)tmp___7;
    if ((unsigned long )rend == (unsigned long )((void *)0)) {
      rend = pend;
    }
    tmp___8 = memchr((void const   *)p, ':', (size_t )(rend - p));
    s = (char const   *)tmp___8;
    if ((unsigned long )s == (unsigned long )((void *)0)) {
      *(h + i) = strm_nil_value();
    } else {
      str = strm_str_intern(p, (strm_int )(s - p));
      *(h + i) = str;
      p = s + 1;
    }
    if ((unsigned long )p < (unsigned long )rend) {
      *(v + i) = csv_value(p, (strm_int )(rend - p), (enum csv_type )0);
    } else {
      str = strm_str_new((char const   *)((void *)0), 0);
      *(v + i) = str;
    }
    p = rend + 1;
    i ++;
  }
  tmp___9 = strm_ary_struct(ary);
  tmp___9->headers = hdr;
  strm_emit(strm, ary, (int (*)(strm_stream * , strm_value  ))((void *)0));
  return (0);
}
}
static int ltsv(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_stream *t ;
  int tmp ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "");
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  t = strm_stream_new((strm_stream_mode )1, & ltsv_accept, (int (*)(strm_stream * ,
                                                                    strm_value  ))((void *)0),
                      (void *)0);
  *ret = strm_ptr_value((void *)t);
  return (0);
}
}
static int str_number(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_value s ;
  int tmp ;
  strm_int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "S", & s);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = strm_str_len(s);
  tmp___1 = strm_strp_ptr(& s);
  s = csv_value(tmp___1, tmp___0, (enum csv_type )2);
  tmp___2 = strm_number_p(s);
  if (! tmp___2) {
    strm_raise(strm, "invalid string for number");
    return (1);
  }
  *ret = s;
  return (0);
}
}
void strm_csv_init(strm_state *state )
{
  strm_value tmp ;
  strm_value tmp___0 ;
  strm_value tmp___1 ;
  strm_value tmp___2 ;

  {
  tmp = strm_cfunc_value(& csv);
  strm_var_def(state, "csv", tmp);
  tmp___0 = strm_cfunc_value(& tsv);
  strm_var_def(state, "tsv", tmp___0);
  tmp___1 = strm_cfunc_value(& ltsv);
  strm_var_def(state, "ltsv", tmp___1);
  tmp___2 = strm_cfunc_value(& str_number);
  strm_var_def(strm_ns_string, "number", tmp___2);
  return;
}
}
#pragma merger("0","/tmp/cil-RQGhbGy2.i","-std=gnu99,-g,-ggdb,-Wall")
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
int cpu_count(void)
{
  long tmp ;

  {
  tmp = sysconf(84);
  return ((int )tmp);
}
}
#pragma merger("0","/tmp/cil-sdYSzxdb.i","-std=gnu99,-g,-ggdb,-Wall")
strm_state *strm_ns_number  ;
extern  __attribute__((__nothrow__)) double fmod(double __x , double __y ) ;
static int num_plus(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_value x ;
  strm_value y ;
  int tmp ;
  strm_int tmp___0 ;
  strm_int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "NN", & x, & y);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___2 = strm_int_p(x);
  if (tmp___2) {
    tmp___3 = strm_int_p(y);
    if (tmp___3) {
      tmp___0 = strm_value_int(x);
      tmp___1 = strm_value_int(y);
      *ret = strm_int_value(tmp___0 + tmp___1);
      return (0);
    }
  }
  tmp___6 = strm_number_p(x);
  if (tmp___6) {
    tmp___7 = strm_number_p(y);
    if (tmp___7) {
      tmp___4 = strm_value_float(x);
      tmp___5 = strm_value_float(y);
      *ret = strm_float_value(tmp___4 + tmp___5);
      return (0);
    }
  }
  return (1);
}
}
static int num_minus(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  int tmp___2 ;
  strm_value x ;
  strm_value y ;
  int tmp___3 ;
  strm_int tmp___4 ;
  strm_int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  if (argc == 1) {
    tmp___0 = strm_int_p(*(args + 0));
    if (tmp___0) {
      tmp = strm_value_int(*(args + 0));
      *ret = strm_int_value(- tmp);
      return (0);
    }
    tmp___2 = strm_float_p(*(args + 0));
    if (tmp___2) {
      tmp___1 = strm_value_float(*(args + 0));
      *ret = strm_float_value(- tmp___1);
      return (0);
    }
  } else {
    while (1) {
      tmp___3 = strm_parse_args(strm, argc, args, "NN", & x, & y);
      if (tmp___3 == 1) {
        return (1);
      }
      break;
    }
    tmp___6 = strm_int_p(x);
    if (tmp___6) {
      tmp___7 = strm_int_p(y);
      if (tmp___7) {
        tmp___4 = strm_value_int(x);
        tmp___5 = strm_value_int(y);
        *ret = strm_int_value(tmp___4 - tmp___5);
        return (0);
      }
    }
    tmp___10 = strm_number_p(x);
    if (tmp___10) {
      tmp___11 = strm_number_p(y);
      if (tmp___11) {
        tmp___8 = strm_value_float(x);
        tmp___9 = strm_value_float(y);
        *ret = strm_float_value(tmp___8 - tmp___9);
        return (0);
      }
    }
  }
  return (1);
}
}
static int num_mult(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_value x ;
  strm_value y ;
  int tmp ;
  strm_int tmp___0 ;
  strm_int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "NN", & x, & y);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___2 = strm_int_p(x);
  if (tmp___2) {
    tmp___3 = strm_int_p(y);
    if (tmp___3) {
      tmp___0 = strm_value_int(x);
      tmp___1 = strm_value_int(y);
      *ret = strm_int_value(tmp___0 * tmp___1);
      return (0);
    }
  }
  tmp___4 = strm_value_float(x);
  tmp___5 = strm_value_float(y);
  *ret = strm_float_value(tmp___4 * tmp___5);
  return (0);
}
}
static int num_div(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double x ;
  double y ;
  int tmp ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "ff", & x, & y);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  *ret = strm_float_value(x / y);
  return (0);
}
}
static int num_bar(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_value x ;
  strm_value y ;
  int tmp ;
  strm_int tmp___0 ;
  strm_int tmp___1 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "ii", & x, & y);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = strm_value_int(x);
  tmp___1 = strm_value_int(y);
  *ret = strm_int_value(tmp___0 | tmp___1);
  return (0);
}
}
static int num_mod(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_value x ;
  strm_int y ;
  int tmp ;
  strm_int tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  int tmp___4 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "Ni", & x, & y);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___1 = strm_int_p(x);
  if (tmp___1) {
    tmp___0 = strm_value_int(x);
    *ret = strm_int_value(tmp___0 % y);
    return (0);
  }
  tmp___4 = strm_float_p(x);
  if (tmp___4) {
    tmp___2 = strm_value_float(x);
    tmp___3 = fmod(tmp___2, (double )y);
    *ret = strm_float_value(tmp___3);
    return (0);
  }
  return (1);
}
}
static int num_gt(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double x ;
  double y ;
  int tmp ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "ff", & x, & y);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  *ret = strm_bool_value(x > y);
  return (0);
}
}
static int num_ge(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double x ;
  double y ;
  int tmp ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "ff", & x, & y);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  *ret = strm_bool_value(x >= y);
  return (0);
}
}
static int num_lt(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double x ;
  double y ;
  int tmp ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "ff", & x, & y);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  *ret = strm_bool_value(x < y);
  return (0);
}
}
static int num_le(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  double x ;
  double y ;
  int tmp ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "ff", & x, & y);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  *ret = strm_bool_value(x <= y);
  return (0);
}
}
static int num_number(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  int tmp ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "N", ret);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  return (0);
}
}
void strm_number_init(strm_state *state )
{
  strm_value tmp ;
  strm_value tmp___0 ;
  strm_value tmp___1 ;
  strm_value tmp___2 ;
  strm_value tmp___3 ;
  strm_value tmp___4 ;
  strm_value tmp___5 ;
  strm_value tmp___6 ;
  strm_value tmp___7 ;
  strm_value tmp___8 ;
  strm_value tmp___9 ;

  {
  strm_ns_number = strm_ns_new((strm_state *)((void *)0), "number");
  tmp = strm_cfunc_value(& num_plus);
  strm_var_def(strm_ns_number, "+", tmp);
  tmp___0 = strm_cfunc_value(& num_minus);
  strm_var_def(strm_ns_number, "-", tmp___0);
  tmp___1 = strm_cfunc_value(& num_mult);
  strm_var_def(strm_ns_number, "*", tmp___1);
  tmp___2 = strm_cfunc_value(& num_div);
  strm_var_def(strm_ns_number, "/", tmp___2);
  tmp___3 = strm_cfunc_value(& num_mod);
  strm_var_def(strm_ns_number, "%", tmp___3);
  tmp___4 = strm_cfunc_value(& num_bar);
  strm_var_def(strm_ns_number, "|", tmp___4);
  tmp___5 = strm_cfunc_value(& num_lt);
  strm_var_def(strm_ns_number, "<", tmp___5);
  tmp___6 = strm_cfunc_value(& num_le);
  strm_var_def(strm_ns_number, "<=", tmp___6);
  tmp___7 = strm_cfunc_value(& num_gt);
  strm_var_def(strm_ns_number, ">", tmp___7);
  tmp___8 = strm_cfunc_value(& num_ge);
  strm_var_def(strm_ns_number, ">=", tmp___8);
  tmp___9 = strm_cfunc_value(& num_number);
  strm_var_def(state, "number", tmp___9);
  return;
}
}
#pragma merger("0","/tmp/cil-nEllj_iu.i","-std=gnu99,-g,-ggdb,-Wall")
static void xorshift128init(uint32_t *seed )
{
  struct timeval tv ;
  uint32_t y ;
  int i ;
  int fd ;
  int tmp ;
  struct stat statbuf ;
  ssize_t ret ;
  size_t size ;
  int tmp___0 ;

  {
  tmp = open("/dev/urandom", 2304, 0);
  fd = tmp;
  if (fd > 0) {
    ret = (ssize_t )0;
    size = sizeof(uint64_t ) * 2UL;
    tmp___0 = fstat(fd, & statbuf);
    if (tmp___0 == 0) {
      if ((statbuf.st_mode & 61440U) == 8192U) {
        ret = read(fd, (void *)seed, size);
      }
    }
    close(fd);
    if ((size_t )ret == size) {
      return;
    }
  }
  y = (uint32_t )2463534242L;
  gettimeofday((struct timeval * __restrict  )(& tv), (void * __restrict  )((void *)0));
  y ^= (uint32_t )tv.tv_usec;
  i = 0;
  while (i < 4) {
    y ^= y << 13;
    y ^= y >> 17;
    y ^= y << 5;
    *(seed + i) = y;
    i ++;
  }
  return;
}
}
static uint32_t xorshift128(uint32_t *seed )
{
  uint32_t x ;
  uint32_t y ;
  uint32_t z ;
  uint32_t w ;
  uint32_t t ;

  {
  x = *(seed + 0);
  y = *(seed + 1);
  z = *(seed + 2);
  w = *(seed + 3);
  t = x ^ (x << 11);
  x = y;
  y = z;
  z = w;
  w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));
  *(seed + 0) = x;
  *(seed + 1) = y;
  *(seed + 2) = z;
  *(seed + 3) = w;
  return (w);
}
}
static double rand_float(uint32_t *seed )
{
  uint32_t tmp ;

  {
  tmp = xorshift128(seed);
  return ((double )tmp * (1.0 / 4294967295.0));
}
}
static int gen_rand(strm_stream *strm , strm_value data )
{
  struct rand_data *d ;
  double f ;
  double tmp ;
  strm_value tmp___0 ;

  {
  d = (struct rand_data *)strm->data;
  tmp = rand_float((uint32_t *)(d->seed));
  f = tmp;
  tmp___0 = strm_float_value(f);
  strm_emit(strm, tmp___0, & gen_rand);
  return (0);
}
}
static int exec_rand(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  struct rand_data *d ;
  char const   *s ;
  strm_int len ;
  int tmp ;
  void *tmp___0 ;
  strm_stream *tmp___1 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "|s", & s, & len);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = malloc(sizeof(struct rand_data ));
  d = (struct rand_data *)tmp___0;
  if (! d) {
    return (1);
  }
  if (argc == 2) {
    if ((unsigned long )len != sizeof(d->seed)) {
      strm_raise(strm, "seed size differ");
      free((void *)d);
      return (1);
    }
    memcpy((void * __restrict  )(d->seed), (void const   * __restrict  )s, (size_t )len);
  } else {
    xorshift128init((uint32_t *)(d->seed));
  }
  tmp___1 = strm_stream_new((strm_stream_mode )0, & gen_rand, (int (*)(strm_stream * ,
                                                                       strm_value  ))((void *)0),
                            (void *)d);
  *ret = strm_ptr_value((void *)tmp___1);
  return (0);
}
}
static int rand_seed(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  uint32_t seed[4] ;
  int tmp ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "");
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  xorshift128init((uint32_t *)(seed));
  *ret = strm_str_new((char const   *)(seed), (strm_int )sizeof(seed));
  return (0);
}
}
static double rand_normal(struct rnorm_data *d )
{
  double u ;
  double v ;
  double s ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
  if (d->has_spare) {
    d->has_spare = 0;
    return (d->spare);
  }
  d->has_spare = 1;
  while (1) {
    tmp = rand_float((uint32_t *)(d->seed));
    u = tmp * 2.0 - 1.0;
    tmp___0 = rand_float((uint32_t *)(d->seed));
    v = tmp___0 * 2.0 - 1.0;
    s = u * u + v * v;
    if (! (s >= 1.0)) {
      if (! (s == 0.0)) {
        break;
      }
    }
  }
  tmp___1 = log(s);
  s = sqrt((- 2.0 * tmp___1) / s);
  d->spare = v * s;
  return (u * s);
}
}
static int gen_rnorm(strm_stream *strm , strm_value data )
{
  struct rnorm_data *d ;
  double f ;
  double tmp ;
  strm_value tmp___0 ;

  {
  d = (struct rnorm_data *)strm->data;
  tmp = rand_normal(d);
  f = tmp;
  tmp___0 = strm_float_value(f);
  strm_emit(strm, tmp___0, & gen_rnorm);
  return (0);
}
}
static int exec_rnorm(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  struct rnorm_data *d ;
  char const   *s ;
  strm_int len ;
  int tmp ;
  void *tmp___0 ;
  strm_stream *tmp___1 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "|s", & s, & len);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = malloc(sizeof(struct rnorm_data ));
  d = (struct rnorm_data *)tmp___0;
  if (! d) {
    return (1);
  }
  if (argc == 2) {
    if ((unsigned long )len != sizeof(d->seed)) {
      strm_raise(strm, "seed size differ");
      free((void *)d);
      return (1);
    }
    memcpy((void * __restrict  )(d->seed), (void const   * __restrict  )s, (size_t )len);
  } else {
    xorshift128init((uint32_t *)(d->seed));
  }
  d->has_spare = 0;
  tmp___1 = strm_stream_new((strm_stream_mode )0, & gen_rnorm, (int (*)(strm_stream * ,
                                                                        strm_value  ))((void *)0),
                            (void *)d);
  *ret = strm_ptr_value((void *)tmp___1);
  return (0);
}
}
static int iter_sample(strm_stream *strm , strm_value data )
{
  struct sample_data *d ;
  uint32_t r ;
  strm_int tmp ;
  uint32_t tmp___0 ;

  {
  d = (struct sample_data *)strm->data;
  if (d->i < d->len) {
    tmp = d->i;
    (d->i) ++;
    d->samples[tmp] = data;
    return (0);
  }
  tmp___0 = xorshift128((uint32_t *)(d->seed));
  r = tmp___0 % (unsigned int )d->i;
  if (r < (uint32_t )d->len) {
    d->samples[r] = data;
  }
  (d->i) ++;
  return (0);
}
}
static int finish_sample(strm_stream *strm , strm_value data )
{
  struct sample_data *d ;
  strm_int i ;
  strm_int len ;

  {
  d = (struct sample_data *)strm->data;
  len = d->len;
  i = 0;
  while (i < len) {
    strm_emit(strm, d->samples[i], (int (*)(strm_stream * , strm_value  ))((void *)0));
    i ++;
  }
  free((void *)d);
  return (0);
}
}
static int exec_sample(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  struct sample_data *d ;
  strm_int len ;
  int tmp ;
  void *tmp___0 ;
  strm_stream *tmp___1 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "i", & len);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = malloc(sizeof(struct sample_data ) + sizeof(strm_value ) * (unsigned long )len);
  d = (struct sample_data *)tmp___0;
  if (! d) {
    return (1);
  }
  d->len = len;
  d->i = 0;
  xorshift128init((uint32_t *)(d->seed));
  tmp___1 = strm_stream_new((strm_stream_mode )1, & iter_sample, & finish_sample,
                            (void *)d);
  *ret = strm_ptr_value((void *)tmp___1);
  return (0);
}
}
void strm_rand_init(strm_state *state )
{
  strm_value tmp ;
  strm_value tmp___0 ;
  strm_value tmp___1 ;
  strm_value tmp___2 ;

  {
  tmp = strm_cfunc_value(& rand_seed);
  strm_var_def(state, "rand_seed", tmp);
  tmp___0 = strm_cfunc_value(& exec_rand);
  strm_var_def(state, "rand", tmp___0);
  tmp___1 = strm_cfunc_value(& exec_rnorm);
  strm_var_def(state, "rand_norm", tmp___1);
  tmp___2 = strm_cfunc_value(& exec_sample);
  strm_var_def(state, "sample", tmp___2);
  return;
}
}
#pragma merger("0","/tmp/cil-aOu7K0RU.i","-std=gnu99,-g,-ggdb,-Wall")
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
struct sig_list *sig_list  ;
static void handler(int sig )
{
  struct sig_list *list ;

  {
  list = sig_list;
  while (list) {
    if (list->sig == sig) {
      (*(list->func))(sig, list->arg);
    }
    list = list->next;
  }
  return;
}
}
static void sigcall(int sig , void *f )
{


  {
  (*((void (*)(int  ))f))(sig);
  return;
}
}
static int add_sig(int sig , void (*func)(int  , void * ) , void *arg )
{
  struct sig_list *node ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct sig_list ));
  node = (struct sig_list *)tmp;
  if ((unsigned long )node == (unsigned long )((void *)0)) {
    return (1);
  }
  node->next = sig_list;
  node->sig = sig;
  node->func = func;
  node->arg = arg;
  sig_list = node;
  return (0);
}
}
int strm_signal(int sig , void (*func)(int  , void * ) , void *arg )
{
  void (*r)(int  ) ;
  __sighandler_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = signal(sig, (void (*)(int  ))1);
  r = tmp;
  if ((unsigned long )r == (unsigned long )((void (*)(int  ))-1)) {
    return (1);
  }
  if (r) {
    if ((unsigned long )r != (unsigned long )(& handler)) {
      tmp___0 = add_sig(sig, & sigcall, (void *)r);
      if (tmp___0 == 1) {
        return (1);
      }
    }
  }
  tmp___1 = add_sig(sig, func, arg);
  if (tmp___1 == 1) {
    return (1);
  }
  r = signal(sig, & handler);
  if ((unsigned long )r == (unsigned long )((void (*)(int  ))-1)) {
    return (1);
  }
  return (0);
}
}
int strm_unsignal(int sig , void (*func)(int  , void * ) )
{
  void (*r)(int  ) ;
  __sighandler_t tmp ;
  struct sig_list *list ;
  struct sig_list *tmp___0 ;

  {
  tmp = signal(sig, (void (*)(int  ))1);
  r = tmp;
  tmp___0 = (struct sig_list *)((void *)0);
  if ((unsigned long )r == (unsigned long )((void (*)(int  ))-1)) {
    return (1);
  }
  list = sig_list;
  while (list) {
    if (list->sig == sig) {
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        sig_list = list->next;
      } else {
        tmp___0->next = list->next;
        tmp___0 = list;
      }
    }
    list = list->next;
  }
  signal(sig, & handler);
  return (0);
}
}
/* compiler builtin:
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin:
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin:
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#pragma merger("0","/tmp/cil-einFAXBs.i","-std=gnu99,-g,-ggdb,-Wall")
int strm_parse_args(strm_stream *strm , int argc , strm_value *argv , char const   *format
                    , ...)
{
  char c ;
  int i ;
  va_list___0 ap ;
  int arg_i ;
  strm_int opt ;
  strm_int given ;
  strm_value *p ;
  strm_value *tmp ;
  int tmp___0 ;
  strm_value *p___0 ;
  strm_value *tmp___1 ;
  strm_value nn ;
  int tmp___2 ;
  int tmp___3 ;
  strm_value ss ;
  strm_string *p___1 ;
  strm_string *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  strm_value ss___0 ;
  char const   **ps ;
  strm_int *pl ;
  char const   **tmp___7 ;
  strm_int *tmp___8 ;
  int tmp___9 ;
  strm_array *p___2 ;
  strm_value v ;
  strm_array *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  strm_array aa ;
  strm_value **pb ;
  strm_int *pl___0 ;
  strm_value **tmp___13 ;
  strm_int *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  struct strm_array *tmp___18 ;
  struct strm_array *tmp___19 ;
  double *p___3 ;
  strm_value ff ;
  double *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  strm_int *p___4 ;
  strm_value ff___0 ;
  strm_int *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  strm_int *p___5 ;
  strm_int bb ;
  strm_int *tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  strm_int *p___6 ;
  strm_int *tmp___29 ;
  char const   *tmp___30 ;

  {
  i = 0;
  arg_i = 0;
  opt = 0;
  given = 1;
  __builtin_va_start(ap, format);
  while (1) {
    tmp___30 = format;
    format ++;
    c = (char )*tmp___30;
    if (! c) {
      break;
    }
    switch ((int )c) {
    case 63:
    case 38:
    case 42:
    case 124:
    break;
    default:
    if (argc <= i) {
      if (opt) {
        given = 0;
      } else {
        strm_raise(strm, "wrong number of arguments");
        return (1);
      }
    }
    break;
    }
    switch ((int )c) {
    case 118:
    tmp = __builtin_va_arg(ap, strm_value *);
    p = tmp;
    if (i < argc) {
      tmp___0 = arg_i;
      arg_i ++;
      *p = *(argv + tmp___0);
      i ++;
    }
    break;
    case 78:
    tmp___1 = __builtin_va_arg(ap, strm_value *);
    p___0 = tmp___1;
    if (i < argc) {
      tmp___2 = arg_i;
      arg_i ++;
      nn = *(argv + tmp___2);
      tmp___3 = strm_number_p(nn);
      if (! tmp___3) {
        strm_raise(strm, "number required");
      }
      *p___0 = nn;
      i ++;
    }
    break;
    case 83:
    tmp___4 = __builtin_va_arg(ap, strm_string *);
    p___1 = tmp___4;
    if (i < argc) {
      tmp___5 = arg_i;
      arg_i ++;
      ss = *(argv + tmp___5);
      i ++;
      tmp___6 = strm_string_p(ss);
      if (! tmp___6) {
        strm_raise(strm, "string required");
        return (1);
      }
      *p___1 = ss;
    }
    break;
    case 115:
    tmp___7 = __builtin_va_arg(ap, char const   **);
    ps = tmp___7;
    tmp___8 = __builtin_va_arg(ap, strm_int *);
    pl = tmp___8;
    if (i < argc) {
      ss___0 = *(argv + arg_i);
      tmp___9 = strm_string_p(ss___0);
      if (! tmp___9) {
        strm_raise(strm, "string required");
        return (1);
      }
      *ps = strm_strp_ptr(argv + arg_i);
      *pl = strm_str_len(ss___0);
      i ++;
      arg_i ++;
    }
    break;
    case 65:
    tmp___10 = __builtin_va_arg(ap, strm_array *);
    p___2 = tmp___10;
    if (i < argc) {
      tmp___11 = arg_i;
      arg_i ++;
      v = *(argv + tmp___11);
      i ++;
      tmp___12 = strm_array_p(v);
      if (! tmp___12) {
        strm_raise(strm, "array required");
        return (1);
      }
      *p___2 = v;
    }
    break;
    case 97:
    tmp___13 = __builtin_va_arg(ap, strm_value **);
    pb = tmp___13;
    tmp___14 = __builtin_va_arg(ap, strm_int *);
    pl___0 = tmp___14;
    if (i < argc) {
      tmp___15 = arg_i;
      arg_i ++;
      aa = *(argv + tmp___15);
      i ++;
      tmp___16 = strm_nil_p(aa);
      if (tmp___16) {
        *pb = (strm_value *)((void *)0);
        *pl___0 = 0;
        break;
      }
      tmp___17 = strm_array_p(aa);
      if (! tmp___17) {
        strm_raise(strm, "array required");
        return (1);
      }
      tmp___18 = strm_ary_struct(aa);
      *pb = tmp___18->ptr;
      tmp___19 = strm_ary_struct(aa);
      *pl___0 = tmp___19->len;
    }
    break;
    case 102:
    tmp___20 = __builtin_va_arg(ap, double *);
    p___3 = tmp___20;
    if (i < argc) {
      tmp___21 = arg_i;
      arg_i ++;
      ff = *(argv + tmp___21);
      i ++;
      tmp___22 = strm_number_p(ff);
      if (! tmp___22) {
        strm_raise(strm, "number required");
        return (1);
      }
      *p___3 = strm_value_float(ff);
    }
    break;
    case 105:
    tmp___23 = __builtin_va_arg(ap, strm_int *);
    p___4 = tmp___23;
    if (i < argc) {
      tmp___24 = arg_i;
      arg_i ++;
      ff___0 = *(argv + tmp___24);
      i ++;
      tmp___25 = strm_number_p(ff___0);
      if (! tmp___25) {
        strm_raise(strm, "number required");
        return (1);
      }
      *p___4 = strm_value_int(ff___0);
    }
    break;
    case 98:
    tmp___26 = __builtin_va_arg(ap, strm_int *);
    p___5 = tmp___26;
    if (i < argc) {
      tmp___27 = arg_i;
      arg_i ++;
      bb = (strm_int )*(argv + tmp___27);
      i ++;
      tmp___28 = strm_bool_p((strm_value )bb);
      if (! tmp___28) {
        strm_raise(strm, "boolean required");
        return (1);
      }
      *p___5 = strm_value_bool((strm_value )bb);
    }
    break;
    case 124:
    opt = 1;
    break;
    case 63:
    tmp___29 = __builtin_va_arg(ap, strm_int *);
    p___6 = tmp___29;
    *p___6 = given;
    break;
    default:
    strm_raise(strm, "invalid argument specifier");
    break;
    }
  }
  __builtin_va_end(ap);
  if (! c) {
    if (argc > i) {
      strm_raise(strm, "wrong number of arguments");
      return (1);
    }
  }
  return (0);
}
}
#pragma merger("0","/tmp/cil-iPVdk5Ri.i","-std=gnu99,-g,-ggdb,-Wall")
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  *__addr ,
                                              socklen_t __len ) ;
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
static int accept_cb(strm_stream *task , strm_value data )
{
  struct socket_data *sd ;
  struct sockaddr_in writer_addr ;
  socklen_t writer_len ;
  int sock ;
  strm_value tmp ;

  {
  sd = (struct socket_data *)task->data;
  memset((void *)(& writer_addr), 0, sizeof(writer_addr));
  writer_len = (socklen_t )sizeof(writer_addr);
  sock = accept(sd->sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& writer_addr)),
                (socklen_t * __restrict  )(& writer_len));
  if (sock < 0) {
    close(sock);
    strm_raise(task, "socket error: listen");
    return (1);
  }
  tmp = strm_io_new(sock, 7);
  strm_io_emit(task, tmp, sd->sock, & accept_cb);
  return (0);
}
}
static int server_accept(strm_stream *task , strm_value data )
{
  struct socket_data *sd ;

  {
  sd = (struct socket_data *)task->data;
  strm_io_start_read(task, sd->sock, & accept_cb);
  return (0);
}
}
static int server_close(strm_stream *task , strm_value d )
{
  struct socket_data *sd ;

  {
  sd = (struct socket_data *)task->data;
  close(sd->sock);
  free((void *)sd);
  return (0);
}
}
static int tcp_server(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  struct addrinfo hints ;
  struct addrinfo *result ;
  struct addrinfo *rp ;
  int sock ;
  int s ;
  strm_value srv ;
  char const   *service ;
  char buf[12] ;
  struct socket_data *sd ;
  strm_stream *t ;
  int tmp ;
  strm_int tmp___0 ;
  strm_string str ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "v", & srv);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___1 = strm_number_p(srv);
  if (tmp___1) {
    tmp___0 = strm_value_int(srv);
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%d", tmp___0);
    service = (char const   *)(buf);
  } else {
    str = srv;
    service = strm_str_cstr(str, buf);
  }
  memset((void *)(& hints), 0, sizeof(struct addrinfo ));
  hints.ai_family = 0;
  hints.ai_socktype = 1;
  hints.ai_flags = 1;
  hints.ai_protocol = 0;
  while (1) {
    s = getaddrinfo((char const   * __restrict  )((void *)0), (char const   * __restrict  )service,
                    (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& result));
    if (s != 0) {
      if (s == -3) {
        goto __Cont;
      }
      tmp___2 = gai_strerror(s);
      strm_raise(strm, tmp___2);
      return (1);
    }
    break;
    __Cont: /* CIL Label */ ;
  }
  rp = result;
  while ((unsigned long )rp != (unsigned long )((void *)0)) {
    sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
    if (sock == -1) {
      goto __Cont___0;
    }
    tmp___3 = bind(sock, (struct sockaddr  const  *)rp->ai_addr, rp->ai_addrlen);
    if (tmp___3 == 0) {
      break;
    }
    close(sock);
    __Cont___0: /* CIL Label */
    rp = rp->ai_next;
  }
  freeaddrinfo(result);
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
    strm_raise(strm, "socket error: bind");
    return (1);
  }
  tmp___4 = listen(sock, 5);
  if (tmp___4 < 0) {
    close(sock);
    strm_raise(strm, "socket error: listen");
    return (1);
  }
  tmp___5 = malloc(sizeof(struct socket_data ));
  sd = (struct socket_data *)tmp___5;
  sd->sock = sock;
  t = strm_stream_new((strm_stream_mode )0, & server_accept, & server_close, (void *)sd);
  *ret = strm_ptr_value((void *)t);
  return (0);
}
}
static int tcp_socket(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  struct addrinfo hints ;
  struct addrinfo *result ;
  struct addrinfo *rp ;
  int sock ;
  int s ;
  char const   *service ;
  char sbuf[12] ;
  char hbuf[7] ;
  strm_string host ;
  strm_value srv ;
  int tmp ;
  strm_int tmp___0 ;
  strm_string str ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "Sv", & host, & srv);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___1 = strm_number_p(srv);
  if (tmp___1) {
    tmp___0 = strm_value_int(srv);
    sprintf((char * __restrict  )(sbuf), (char const   * __restrict  )"%d", tmp___0);
    service = (char const   *)(sbuf);
  } else {
    str = srv;
    service = strm_str_cstr(str, sbuf);
  }
  memset((void *)(& hints), 0, sizeof(struct addrinfo ));
  hints.ai_family = 0;
  hints.ai_socktype = 1;
  hints.ai_protocol = 0;
  tmp___2 = strm_str_cstr(host, hbuf);
  s = getaddrinfo((char const   * __restrict  )tmp___2, (char const   * __restrict  )service,
                  (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& result));
  if (s != 0) {
    tmp___3 = gai_strerror(s);
    strm_raise(strm, tmp___3);
    return (1);
  }
  rp = result;
  while ((unsigned long )rp != (unsigned long )((void *)0)) {
    sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
    if (sock == -1) {
      goto __Cont;
    }
    tmp___4 = connect(sock, (struct sockaddr  const  *)rp->ai_addr, rp->ai_addrlen);
    if (tmp___4 != -1) {
      break;
    }
    close(sock);
    __Cont: /* CIL Label */
    rp = rp->ai_next;
  }
  freeaddrinfo(result);
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
    strm_raise(strm, "socket error: connect");
    return (1);
  }
  *ret = strm_io_new(sock, 7);
  return (0);
}
}
void strm_socket_init(strm_state *state )
{
  strm_value tmp ;
  strm_value tmp___0 ;

  {
  tmp = strm_cfunc_value(& tcp_server);
  strm_var_def(state, "tcp_server", tmp);
  tmp___0 = strm_cfunc_value(& tcp_socket);
  strm_var_def(state, "tcp_socket", tmp___0);
  return;
}
}
#pragma merger("0","/tmp/cil-93d6dZjZ.i","-std=gnu99,-g,-ggdb,-Wall")
strm_state *strm_ns_string  ;
static double const   khash_ac_HASH_UPPER___3  =    (double const   )0.77;
extern char _etext[] ;
extern char __init_array_start[] ;
__inline static int readonly_data_p(char const   *p )
{
  int tmp ;

  {
  if ((unsigned long )(_etext) < (unsigned long )p) {
    if ((unsigned long )p < (unsigned long )((char *)(& __init_array_start))) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
static khint_t sym_hash(struct sym_key key )
{
  char const   *s ;
  khint_t h ;
  strm_int len ;
  char const   *tmp ;
  char const   *tmp___0 ;
  strm_int tmp___1 ;

  {
  s = key.ptr;
  len = key.len;
  tmp = s;
  s ++;
  h = (khint_t )*tmp;
  while (1) {
    tmp___1 = len;
    len --;
    if (! tmp___1) {
      break;
    }
    tmp___0 = s;
    s ++;
    h = ((h << 5) - h) + (khint_t )*tmp___0;
  }
  return (h);
}
}
static khint_t sym_eq(struct sym_key a , struct sym_key b )
{
  int tmp ;

  {
  if (a.len != b.len) {
    return ((khint_t )0);
  }
  tmp = memcmp((void const   *)a.ptr, (void const   *)b.ptr, (size_t )a.len);
  if (tmp == 0) {
    return ((khint_t )1);
  }
  return ((khint_t )0);
}
}
__inline static kh_sym_t *kh_init_sym(void)
{
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(kh_sym_t ));
  return ((kh_sym_t *)tmp);
}
}
__inline static int kh_resize_sym(kh_sym_t *h , khint_t new_n_buckets )
{
  khint32_t *new_flags ;
  khint_t j ;
  khint_t tmp ;
  void *tmp___0 ;
  khint_t tmp___1 ;
  struct sym_key *new_keys ;
  void *tmp___2 ;
  strm_string *new_vals ;
  void *tmp___3 ;
  struct sym_key key ;
  strm_string val ;
  khint_t new_mask ;
  khint_t k ;
  khint_t i ;
  khint_t step ;
  struct sym_key tmp___4 ;
  strm_string tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
  new_flags = (khint32_t *)0;
  j = (khint_t )1;
  new_n_buckets --;
  new_n_buckets |= new_n_buckets >> 1;
  new_n_buckets |= new_n_buckets >> 2;
  new_n_buckets |= new_n_buckets >> 4;
  new_n_buckets |= new_n_buckets >> 8;
  new_n_buckets |= new_n_buckets >> 16;
  new_n_buckets ++;
  if (new_n_buckets < 4U) {
    new_n_buckets = (khint_t )4;
  }
  if (h->size >= (khint_t )((double const   )new_n_buckets * khash_ac_HASH_UPPER___3 + (double const   )0.5)) {
    j = (khint_t )0;
  } else {
    if (new_n_buckets < 16U) {
      tmp = (khint_t )1;
    } else {
      tmp = new_n_buckets >> 4;
    }
    tmp___0 = malloc((unsigned long )tmp * sizeof(khint32_t ));
    new_flags = (khint32_t *)tmp___0;
    if (! new_flags) {
      return (-1);
    }
    if (new_n_buckets < 16U) {
      tmp___1 = (khint_t )1;
    } else {
      tmp___1 = new_n_buckets >> 4;
    }
    memset((void *)new_flags, 170, (unsigned long )tmp___1 * sizeof(khint32_t ));
    if (h->n_buckets < new_n_buckets) {
      tmp___2 = realloc((void *)h->keys, (unsigned long )new_n_buckets * sizeof(struct sym_key ));
      new_keys = (struct sym_key *)tmp___2;
      if (! new_keys) {
        free((void *)new_flags);
        return (-1);
      }
      h->keys = new_keys;
      tmp___3 = realloc((void *)h->vals, (unsigned long )new_n_buckets * sizeof(strm_string ));
      new_vals = (strm_string *)tmp___3;
      if (! new_vals) {
        free((void *)new_flags);
        return (-1);
      }
      h->vals = new_vals;
    }
  }
  if (j) {
    j = (khint_t )0;
    while (j != h->n_buckets) {
      if (((*(h->flags + (j >> 4)) >> ((j & 15U) << 1)) & 3U) == 0U) {
        key = *(h->keys + j);
        new_mask = new_n_buckets - 1U;
        val = *(h->vals + j);
        *(h->flags + (j >> 4)) = (khint32_t )((unsigned long )*(h->flags + (j >> 4)) | (1UL << ((j & 15U) << 1)));
        while (1) {
          step = (khint_t )0;
          k = sym_hash(key);
          i = k & new_mask;
          while (! ((*(new_flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
            step ++;
            i = (i + step) & new_mask;
          }
          *(new_flags + (i >> 4)) = (khint32_t )((unsigned long )*(new_flags + (i >> 4)) & ~ (2UL << ((i & 15U) << 1)));
          if (i < h->n_buckets) {
            if (((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 3U) == 0U) {
              tmp___4 = *(h->keys + i);
              *(h->keys + i) = key;
              key = tmp___4;
              tmp___5 = *(h->vals + i);
              *(h->vals + i) = val;
              val = tmp___5;
              *(h->flags + (i >> 4)) = (khint32_t )((unsigned long )*(h->flags + (i >> 4)) | (1UL << ((i & 15U) << 1)));
            } else {
              *(h->keys + i) = key;
              *(h->vals + i) = val;
              break;
            }
          } else {
            *(h->keys + i) = key;
            *(h->vals + i) = val;
            break;
          }
        }
      }
      j ++;
    }
    if (h->n_buckets > new_n_buckets) {
      tmp___6 = realloc((void *)h->keys, (unsigned long )new_n_buckets * sizeof(struct sym_key ));
      h->keys = (struct sym_key *)tmp___6;
      tmp___7 = realloc((void *)h->vals, (unsigned long )new_n_buckets * sizeof(strm_string ));
      h->vals = (strm_string *)tmp___7;
    }
    free((void *)h->flags);
    h->flags = new_flags;
    h->n_buckets = new_n_buckets;
    h->n_occupied = h->size;
    h->upper_bound = (khint_t )((double const   )h->n_buckets * khash_ac_HASH_UPPER___3 + (double const   )0.5);
  }
  return (0);
}
}
__inline static khint_t kh_put_sym(kh_sym_t *h , struct sym_key key , int *ret )
{
  khint_t x ;
  int tmp ;
  int tmp___0 ;
  khint_t k ;
  khint_t i ;
  khint_t site ;
  khint_t last ;
  khint_t mask ;
  khint_t step ;
  khint_t tmp___1 ;

  {
  if (h->n_occupied >= h->upper_bound) {
    if (h->n_buckets > h->size << 1) {
      tmp = kh_resize_sym(h, h->n_buckets - 1U);
      if (tmp < 0) {
        *ret = -1;
        return (h->n_buckets);
      }
    } else {
      tmp___0 = kh_resize_sym(h, h->n_buckets + 1U);
      if (tmp___0 < 0) {
        *ret = -1;
        return (h->n_buckets);
      }
    }
  }
  mask = h->n_buckets - 1U;
  step = (khint_t )0;
  site = h->n_buckets;
  x = site;
  k = sym_hash(key);
  i = k & mask;
  if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U) {
    x = i;
  } else {
    last = i;
    while (1) {
      if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
        if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U)) {
          tmp___1 = sym_eq(*(h->keys + i), key);
          if (tmp___1) {
            break;
          }
        }
      } else {
        break;
      }
      if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U) {
        site = i;
      }
      step ++;
      i = (i + step) & mask;
      if (i == last) {
        x = site;
        break;
      }
    }
    if (x == h->n_buckets) {
      if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U) {
        if (site != h->n_buckets) {
          x = site;
        } else {
          x = i;
        }
      } else {
        x = i;
      }
    }
  }
  if ((*(h->flags + (x >> 4)) >> ((x & 15U) << 1)) & 2U) {
    *(h->keys + x) = key;
    *(h->flags + (x >> 4)) = (khint32_t )((unsigned long )*(h->flags + (x >> 4)) & ~ (3UL << ((x & 15U) << 1)));
    (h->size) ++;
    (h->n_occupied) ++;
    *ret = 1;
  } else
  if ((*(h->flags + (x >> 4)) >> ((x & 15U) << 1)) & 1U) {
    *(h->keys + x) = key;
    *(h->flags + (x >> 4)) = (khint32_t )((unsigned long )*(h->flags + (x >> 4)) & ~ (3UL << ((x & 15U) << 1)));
    (h->size) ++;
    *ret = 2;
  } else {
    *ret = 0;
  }
  return (x);
}
}
static pthread_mutex_t sym_mutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
static kh_sym_t *sym_table  ;
static strm_string str_new(char const   *p , strm_int len , int foreign )
{
  strm_value tag ;
  strm_value val ;
  char *s ;
  struct strm_string *str ;
  void *tmp ;
  char *buf ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  if (! p) {
    goto mkbuf;
  }
  if (len < 6) {
    tag = 18444210798919155712;
    val = (strm_value )0;
    s = (char *)(& val) + 1;
    memcpy((void * __restrict  )s, (void const   * __restrict  )p, (size_t )len);
    *(s + -1) = (char )len;
  } else
  if (len == 6) {
    tag = 18444492273895866368;
    val = (strm_value )0;
    s = (char *)(& val);
    memcpy((void * __restrict  )s, (void const   * __restrict  )p, (size_t )len);
  } else {
    if (p) {
      if (foreign) {
        tag = 18445055223849287680;
        tmp = malloc(sizeof(struct strm_string ));
        str = (struct strm_string *)tmp;
        str->ptr = p;
      } else {
        tmp___1 = readonly_data_p(p);
        if (tmp___1) {
          tag = 18445055223849287680;
          tmp = malloc(sizeof(struct strm_string ));
          str = (struct strm_string *)tmp;
          str->ptr = p;
        } else {
          goto mkbuf;
        }
      }
    } else {
      mkbuf:
      tag = 18444773748872577024;
      tmp___0 = malloc((sizeof(struct strm_string ) + (unsigned long )len) + 1UL);
      str = (struct strm_string *)tmp___0;
      buf = (char *)(str + 1);
      if (p) {
        memcpy((void * __restrict  )buf, (void const   * __restrict  )p, (size_t )len);
      } else {
        memset((void *)buf, 0, (size_t )len);
      }
      *(buf + len) = (char )'\000';
      str->ptr = (char const   *)buf;
    }
    str->len = len;
    val = (strm_value )((intptr_t )str) & ~ (65535UL << 48);
  }
  return (tag | (val & ~ (65535UL << 48)));
}
}
static strm_string str_intern(char const   *p , strm_int len , int foreign )
{
  khiter_t k ;
  struct sym_key key ;
  int ret ;
  strm_string str ;
  strm_string tmp ;

  {
  if (len <= 6) {
    tmp = str_new(p, len, foreign);
    return (tmp);
  }
  if (! sym_table) {
    sym_table = kh_init_sym();
  }
  key.ptr = p;
  key.len = len;
  k = kh_put_sym(sym_table, key, & ret);
  if (ret == 0) {
    return (*(sym_table->vals + k));
  }
  str = str_new(p, len, foreign);
  (sym_table->keys + k)->ptr = strm_strp_ptr(& str);
  *(sym_table->vals + k) = str;
  return (str);
}
}
strm_string strm_str_new(char const   *p , strm_int len )
{
  strm_string tmp ;
  int tmp___0 ;
  strm_string tmp___1 ;

  {
  if (! strm_event_loop_started) {
    if (p) {
      if (len < 64) {
        tmp = str_intern(p, len, 0);
        return (tmp);
      } else {
        tmp___0 = readonly_data_p(p);
        if (tmp___0) {
          tmp = str_intern(p, len, 0);
          return (tmp);
        }
      }
    }
  }
  tmp___1 = str_new(p, len, 0);
  return (tmp___1);
}
}
strm_string strm_str_static(char const   *p , strm_int len )
{
  strm_string tmp ;

  {
  tmp = str_new(p, len, 1);
  return (tmp);
}
}
strm_string strm_str_intern(char const   *p , strm_int len )
{
  strm_string str ;
  strm_string tmp___0 ;

  {
  if (! ((unsigned long )p != (unsigned long )((void *)0))) {
    __assert_fail("p!=NULL", "string.c", 182U, "strm_str_intern");
  }
  if (! strm_event_loop_started) {
    tmp___0 = str_intern(p, len, 0);
    return (tmp___0);
  }
  pthread_mutex_lock(& sym_mutex);
  str = str_intern(p, len, 0);
  pthread_mutex_unlock(& sym_mutex);
  return (str);
}
}
strm_string strm_str_intern_str(strm_string str )
{
  int tmp ;
  strm_int tmp___0 ;
  char const   *tmp___1 ;
  strm_string tmp___2 ;
  strm_int tmp___3 ;
  char const   *tmp___4 ;

  {
  tmp = strm_str_intern_p(str);
  if (tmp) {
    return (str);
  }
  if (! strm_event_loop_started) {
    tmp___0 = strm_str_len(str);
    tmp___1 = strm_strp_ptr(& str);
    tmp___2 = str_intern(tmp___1, tmp___0, 0);
    return (tmp___2);
  }
  pthread_mutex_lock(& sym_mutex);
  tmp___3 = strm_str_len(str);
  tmp___4 = strm_strp_ptr(& str);
  str = str_intern(tmp___4, tmp___3, 0);
  pthread_mutex_unlock(& sym_mutex);
  return (str);
}
}
strm_string strm_str_intern_static(char const   *p , strm_int len )
{
  strm_string tmp ;

  {
  tmp = str_intern(p, len, 1);
  return (tmp);
}
}
int strm_str_intern_p(strm_string s )
{


  {
  switch (s & (65535UL << 48)) {
  case 18445055223849287680:
  case 18444492273895866368:
  case 18444210798919155712:
  return (1);
  default:
  return (0);
  }
}
}
int strm_str_eq(strm_string a , strm_string b )
{
  strm_int tmp ;
  strm_int tmp___0 ;
  strm_int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;

  {
  if (a == b) {
    return (1);
  }
  if ((a & (65535UL << 48)) == 18445055223849287680) {
    if ((b & (65535UL << 48)) == 18445055223849287680) {
      return (0);
    }
  }
  tmp = strm_str_len(a);
  tmp___0 = strm_str_len(b);
  if (tmp != tmp___0) {
    return (0);
  }
  tmp___1 = strm_str_len(a);
  tmp___2 = strm_strp_ptr(& b);
  tmp___3 = strm_strp_ptr(& a);
  tmp___4 = memcmp((void const   *)tmp___3, (void const   *)tmp___2, (size_t )tmp___1);
  if (tmp___4 == 0) {
    return (1);
  }
  return (0);
}
}
int strm_str_p(strm_value v )
{


  {
  switch (v & (65535UL << 48)) {
  case 18444773748872577024:
  case 18445055223849287680:
  case 18444492273895866368:
  case 18444210798919155712:
  return (1);
  default:
  return (0);
  }
}
}
char const   *strm_strp_ptr(strm_string *s )
{
  struct strm_string *str ;

  {
  switch (*s & (65535UL << 48)) {
  case 18444210798919155712:
  return ((char const   *)((char *)s + 1));
  case 18444492273895866368:
  return ((char const   *)((char *)s));
  case 18445055223849287680:
  case 18444773748872577024:
  str = (struct strm_string *)((void *)((intptr_t )(*s & ~ (65535UL << 48))));
  return (str->ptr);
  default:
  return ((char const   *)((void *)0));
  }
}
}
char const   *strm_str_cstr(strm_string s , char *buf )
{
  strm_int len ;
  struct strm_string *str ;

  {
  switch (s & (65535UL << 48)) {
  case 18444210798919155712:
  len = (strm_int )*((char *)(& s) + 0);
  memcpy((void * __restrict  )buf, (void const   * __restrict  )((char *)(& s) + 1),
         (size_t )len);
  *(buf + len) = (char )'\000';
  return ((char const   *)buf);
  case 18444492273895866368:
  memcpy((void * __restrict  )buf, (void const   * __restrict  )((char *)(& s)), (size_t )6);
  *(buf + 6) = (char )'\000';
  return ((char const   *)buf);
  case 18445055223849287680:
  case 18444773748872577024:
  str = (struct strm_string *)((void *)((intptr_t )(s & ~ (65535UL << 48))));
  return (str->ptr);
  default:
  return ((char const   *)((void *)0));
  }
}
}
strm_int strm_str_len(strm_string s )
{
  struct strm_string *str ;

  {
  switch (s & (65535UL << 48)) {
  case 18444210798919155712:
  return ((strm_int )*((char *)(& s) + 0));
  case 18444492273895866368:
  return (6);
  case 18445055223849287680:
  case 18444773748872577024:
  str = (struct strm_string *)((void *)((intptr_t )(s & ~ (65535UL << 48))));
  return (str->len);
  default:
  return (0);
  }
}
}
int strm_string_p(unsigned long s )
{


  {
  switch (s & (65535UL << 48)) {
  case 18445055223849287680:
  case 18444773748872577024:
  case 18444492273895866368:
  case 18444210798919155712:
  return (1);
  default:
  return (0);
  }
}
}
static int str_length(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  char *p ;
  strm_int len ;
  int tmp ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "s", & p, & len);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  *ret = strm_int_value(len);
  return (0);
}
}
static int str_split(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  char const   *s ;
  strm_int slen ;
  char const   *b ;
  char const   *t ;
  char const   *p ;
  strm_int plen ;
  char const   *pend ;
  char c ;
  strm_int n ;
  strm_array ary ;
  strm_value *sps ;
  strm_int i ;
  int tmp ;
  int tmp___0 ;
  struct strm_array *tmp___1 ;
  strm_int tmp___2 ;
  int tmp___3 ;
  strm_int tmp___4 ;

  {
  n = 0;
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "s|s", & p, & plen, & s, & slen);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  if (argc == 1) {
    s = " ";
    slen = 1;
  }
  c = (char )*(s + 0);
  t = p;
  b = t;
  pend = (p + plen) - slen;
  n = 0;
  while ((unsigned long )p < (unsigned long )pend) {
    if ((int const   )*p == (int const   )c) {
      tmp___0 = memcmp((void const   *)p, (void const   *)s, (size_t )slen);
      if (tmp___0 == 0) {
        if (slen == 1) {
          if ((int )c == 32) {
            if (! (p - t == 0L)) {
              n ++;
            }
          } else {
            n ++;
          }
        } else {
          n ++;
        }
        t = p + slen;
      }
    }
    p ++;
  }
  n ++;
  ary = strm_ary_new((strm_value const   *)((void *)0), n);
  tmp___1 = strm_ary_struct(ary);
  sps = tmp___1->ptr;
  c = (char )*(s + 0);
  t = b;
  p = t;
  i = 0;
  while ((unsigned long )p < (unsigned long )pend) {
    if ((int const   )*p == (int const   )c) {
      tmp___3 = memcmp((void const   *)p, (void const   *)s, (size_t )slen);
      if (tmp___3 == 0) {
        if (slen == 1) {
          if ((int )c == 32) {
            if (! (p - t == 0L)) {
              tmp___2 = i;
              i ++;
              *(sps + tmp___2) = strm_str_new(t, (strm_int )(p - t));
            }
          } else {
            tmp___2 = i;
            i ++;
            *(sps + tmp___2) = strm_str_new(t, (strm_int )(p - t));
          }
        } else {
          tmp___2 = i;
          i ++;
          *(sps + tmp___2) = strm_str_new(t, (strm_int )(p - t));
        }
        t = p + slen;
      }
    }
    p ++;
  }
  pend = b + plen;
  tmp___4 = i;
  i ++;
  *(sps + tmp___4) = strm_str_new(t, (strm_int )(pend - t));
  *ret = ary;
  return (0);
}
}
static int str_plus(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_string str1 ;
  strm_string str2 ;
  strm_string str3 ;
  char *p ;
  int tmp ;
  strm_int tmp___0 ;
  strm_int tmp___1 ;
  char const   *tmp___2 ;
  strm_int tmp___3 ;
  char const   *tmp___4 ;
  strm_int tmp___5 ;
  char const   *tmp___6 ;
  strm_int tmp___7 ;
  strm_int tmp___8 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "SS", & str1, & str2);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  tmp___0 = strm_str_len(str1);
  tmp___1 = strm_str_len(str2);
  str3 = strm_str_new((char const   *)((void *)0), tmp___0 + tmp___1);
  tmp___2 = strm_strp_ptr(& str3);
  p = (char *)tmp___2;
  tmp___3 = strm_str_len(str1);
  tmp___4 = strm_strp_ptr(& str1);
  memcpy((void * __restrict  )p, (void const   * __restrict  )tmp___4, (size_t )tmp___3);
  tmp___5 = strm_str_len(str2);
  tmp___6 = strm_strp_ptr(& str2);
  tmp___7 = strm_str_len(str1);
  memcpy((void * __restrict  )(p + tmp___7), (void const   * __restrict  )tmp___6,
         (size_t )tmp___5);
  tmp___8 = strm_str_len(str3);
  *(p + tmp___8) = (char )'\000';
  *ret = str3;
  return (0);
}
}
static char const   utf8len_codepage[256]  =
  {      (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2,
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2,
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2,
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2,
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2,
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2,
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2,
        (char const   )2,      (char const   )2,      (char const   )2,      (char const   )2,
        (char const   )3,      (char const   )3,      (char const   )3,      (char const   )3,
        (char const   )3,      (char const   )3,      (char const   )3,      (char const   )3,
        (char const   )3,      (char const   )3,      (char const   )3,      (char const   )3,
        (char const   )3,      (char const   )3,      (char const   )3,      (char const   )3,
        (char const   )4,      (char const   )4,      (char const   )4,      (char const   )4,
        (char const   )4,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1,
        (char const   )1,      (char const   )1,      (char const   )1,      (char const   )1};
static int utf8len(char const   *p , char const   *e )
{
  strm_int len ;
  strm_int i ;

  {
  len = (strm_int )utf8len_codepage[(unsigned char )*p];
  if ((unsigned long )(p + len) > (unsigned long )e) {
    return (1);
  }
  i = 1;
  while (i < len) {
    if (((int const   )*(p + i) & 192) != 128) {
      return (1);
    }
    i ++;
  }
  return (len);
}
}
static int str_chars(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  char const   *str ;
  char const   *s ;
  char const   *prev ;
  strm_int slen ;
  strm_array ary ;
  strm_int n ;
  strm_value *sps ;
  strm_int i ;
  int tmp ;
  int tmp___0 ;
  struct strm_array *tmp___1 ;
  int tmp___2 ;
  strm_int tmp___3 ;

  {
  prev = (char const   *)((void *)0);
  n = 0;
  i = 0;
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "s", & str, & slen);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  s = str;
  while (*s) {
    tmp___0 = utf8len(s, s + slen);
    s += tmp___0;
    n ++;
  }
  ary = strm_ary_new((strm_value const   *)((void *)0), n);
  tmp___1 = strm_ary_struct(ary);
  sps = tmp___1->ptr;
  s = str;
  while (*s) {
    prev = s;
    tmp___2 = utf8len(s, s + slen);
    s += tmp___2;
    tmp___3 = i;
    i ++;
    *(sps + tmp___3) = strm_str_new(prev, (strm_int )(s - prev));
  }
  *ret = ary;
  return (0);
}
}
void strm_string_init(strm_state *state )
{
  strm_value tmp ;
  strm_value tmp___0 ;
  strm_value tmp___1 ;
  strm_value tmp___2 ;

  {
  strm_ns_string = strm_ns_new((strm_state *)((void *)0), "string");
  tmp = strm_cfunc_value(& str_length);
  strm_var_def(strm_ns_string, "length", tmp);
  tmp___0 = strm_cfunc_value(& str_split);
  strm_var_def(strm_ns_string, "split", tmp___0);
  tmp___1 = strm_cfunc_value(& str_plus);
  strm_var_def(strm_ns_string, "+", tmp___1);
  tmp___2 = strm_cfunc_value(& str_chars);
  strm_var_def(strm_ns_string, "chars", tmp___2);
  return;
}
}
#pragma merger("0","/tmp/cil-2d2cwYpQ.i","-std=gnu99,-g,-ggdb,-Wall")
strm_state *strm_ns_array  ;
int strm_array_p(strm_value v )
{


  {
  switch (v & (65535UL << 48)) {
  case 18443647848965734400:
  case 18443366373989023744:
  return (1);
  default:
  return (0);
  }
}
}
strm_array strm_ary_new(strm_value const   *p , strm_int len )
{
  struct strm_array *ary ;
  strm_value *buf ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct strm_array ) + sizeof(strm_value ) * (unsigned long )len);
  ary = (struct strm_array *)tmp;
  buf = (strm_value *)(ary + 1);
  if (p) {
    memcpy((void * __restrict  )buf, (void const   * __restrict  )p, sizeof(strm_value ) * (unsigned long )len);
  } else {
    memset((void *)buf, 0, sizeof(strm_value ) * (unsigned long )len);
  }
  ary->ptr = buf;
  ary->len = len;
  ary->ns = (struct strm_state *)((void *)0);
  ary->headers = (strm_array )0;
  return (18443366373989023744 | ((unsigned long )((intptr_t )ary) & ~ (65535UL << 48)));
}
}
int strm_ary_eq(strm_array a , strm_array b )
{
  strm_int i ;
  strm_int len ;
  struct strm_array *tmp ;
  struct strm_array *tmp___0 ;
  struct strm_array *tmp___1 ;
  struct strm_array *tmp___2 ;
  struct strm_array *tmp___3 ;
  int tmp___4 ;

  {
  if (a == b) {
    return (1);
  }
  tmp = strm_ary_struct(a);
  tmp___0 = strm_ary_struct(b);
  if (tmp->len != tmp___0->len) {
    return (0);
  }
  i = 0;
  tmp___1 = strm_ary_struct(a);
  len = tmp___1->len;
  while (i < len) {
    tmp___2 = strm_ary_struct(b);
    tmp___3 = strm_ary_struct(a);
    tmp___4 = strm_value_eq(*(tmp___3->ptr + i), *(tmp___2->ptr + i));
    if (! tmp___4) {
      return (0);
    }
    i ++;
  }
  return (1);
}
}
struct strm_array *strm_ary_struct(unsigned long v )
{


  {
  return ((struct strm_array *)((void *)((intptr_t )(v & ~ (65535UL << 48)))));
}
}
static int ary_length(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_value *v ;
  strm_int len ;
  int tmp ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "a", & v, & len);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  *ret = strm_int_value(len);
  return (0);
}
}
static int ary_reverse(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  strm_value *v ;
  strm_value *v2 ;
  strm_int len ;
  strm_array ary ;
  strm_int i ;
  int tmp ;
  struct strm_array *tmp___0 ;

  {
  while (1) {
    tmp = strm_parse_args(strm, argc, args, "a", & v, & len);
    if (tmp == 1) {
      return (1);
    }
    break;
  }
  ary = strm_ary_new((strm_value const   *)((void *)0), len);
  tmp___0 = strm_ary_struct(ary);
  v2 = tmp___0->ptr;
  i = 0;
  while (i < len) {
    *(v2 + ((len - i) - 1)) = *(v + i);
    i ++;
  }
  *ret = ary;
  return (0);
}
}
static int ary_minmax(strm_stream *strm , int argc , strm_value *args , strm_value *ret ,
                      int min )
{
  strm_value func ;
  strm_value tmp ;
  int i ;
  int len ;
  strm_value *v ;
  strm_value e ;
  strm_value val ;
  double num ;
  double f ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = strm_nil_value();
  func = tmp;
  while (1) {
    tmp___0 = strm_parse_args(strm, argc, args, "a|v", & v, & len, & func);
    if (tmp___0 == 1) {
      return (1);
    }
    break;
  }
  if (len == 0) {
    *ret = strm_nil_value();
    return (0);
  }
  val = *(v + 0);
  if (argc == 2) {
    tmp___1 = strm_funcall(strm, func, 1, v + 0, & e);
    if (tmp___1 == 1) {
      return (1);
    }
  } else {
    e = *(v + 0);
  }
  num = strm_value_float(e);
  i = 1;
  while (i < len) {
    if (argc == 2) {
      tmp___2 = strm_funcall(strm, func, 1, v + i, & e);
      if (tmp___2 == 1) {
        return (1);
      }
    } else {
      e = *(v + 0);
    }
    f = strm_value_float(e);
    if (min) {
      if (num > f) {
        num = f;
        val = *(v + i);
      }
    } else
    if (num < f) {
      num = f;
      val = *(v + i);
    }
    i ++;
  }
  *ret = val;
  return (0);
}
}
static int ary_min(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  int tmp ;

  {
  tmp = ary_minmax(strm, argc, args, ret, 1);
  return (tmp);
}
}
static int ary_max(strm_stream *strm , int argc , strm_value *args , strm_value *ret )
{
  int tmp ;

  {
  tmp = ary_minmax(strm, argc, args, ret, 0);
  return (tmp);
}
}
void strm_array_init(strm_state *state )
{
  strm_value tmp ;
  strm_value tmp___0 ;
  strm_value tmp___1 ;
  strm_value tmp___2 ;

  {
  strm_ns_array = strm_ns_new((strm_state *)((void *)0), "array");
  tmp = strm_cfunc_value(& ary_length);
  strm_var_def(strm_ns_array, "length", tmp);
  tmp___0 = strm_cfunc_value(& ary_reverse);
  strm_var_def(strm_ns_array, "reverse", tmp___0);
  tmp___1 = strm_cfunc_value(& ary_min);
  strm_var_def(strm_ns_array, "min", tmp___1);
  tmp___2 = strm_cfunc_value(& ary_max);
  strm_var_def(strm_ns_array, "max", tmp___2);
  return;
}
}
/* compiler builtin:
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
#pragma merger("0","/tmp/cil-RihIokAW.i","-g")
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format
                                                , ...)  __asm__("__isoc99_sscanf")  ;
extern int getc(FILE *__stream ) ;
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
static void node_lineinfo(parser_state *p , node *node___0 )
{


  {
  if (! node___0) {
    return;
  }
  node___0->fname = p->fname;
  node___0->lineno = p->lineno;
  return;
}
}
int yydebug  ;
int yylex(YYSTYPE *lval , parser_state *p ) ;
static void yyerror(parser_state *p , char const   *s ) ;
static yytype_int8 const   yytranslate[302]  =
  {      (yytype_int8 const   )0,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )60,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )46,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )51,      (yytype_int8 const   )52,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )54,      (yytype_int8 const   )2,      (yytype_int8 const   )57,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )59,
        (yytype_int8 const   )2,      (yytype_int8 const   )53,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )58,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )55,
        (yytype_int8 const   )2,      (yytype_int8 const   )56,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )49,
        (yytype_int8 const   )2,      (yytype_int8 const   )50,      (yytype_int8 const   )47,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )1,      (yytype_int8 const   )2,      (yytype_int8 const   )3,      (yytype_int8 const   )4,
        (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8,
        (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )11,      (yytype_int8 const   )12,
        (yytype_int8 const   )13,      (yytype_int8 const   )14,      (yytype_int8 const   )15,      (yytype_int8 const   )16,
        (yytype_int8 const   )17,      (yytype_int8 const   )18,      (yytype_int8 const   )19,      (yytype_int8 const   )20,
        (yytype_int8 const   )21,      (yytype_int8 const   )22,      (yytype_int8 const   )23,      (yytype_int8 const   )24,
        (yytype_int8 const   )25,      (yytype_int8 const   )26,      (yytype_int8 const   )27,      (yytype_int8 const   )28,
        (yytype_int8 const   )29,      (yytype_int8 const   )30,      (yytype_int8 const   )31,      (yytype_int8 const   )32,
        (yytype_int8 const   )33,      (yytype_int8 const   )34,      (yytype_int8 const   )35,      (yytype_int8 const   )36,
        (yytype_int8 const   )37,      (yytype_int8 const   )38,      (yytype_int8 const   )39,      (yytype_int8 const   )40,
        (yytype_int8 const   )41,      (yytype_int8 const   )42,      (yytype_int8 const   )43,      (yytype_int8 const   )44,
        (yytype_int8 const   )45,      (yytype_int8 const   )48};
static yytype_int16 const   yyrline[129]  =
  {      (yytype_int16 const   )0,      (yytype_int16 const   )113,      (yytype_int16 const   )113,      (yytype_int16 const   )119,
        (yytype_int16 const   )123,      (yytype_int16 const   )127,      (yytype_int16 const   )133,      (yytype_int16 const   )142,
        (yytype_int16 const   )163,      (yytype_int16 const   )174,      (yytype_int16 const   )182,      (yytype_int16 const   )197,
        (yytype_int16 const   )209,      (yytype_int16 const   )213,      (yytype_int16 const   )216,      (yytype_int16 const   )220,
        (yytype_int16 const   )224,      (yytype_int16 const   )230,      (yytype_int16 const   )239,      (yytype_int16 const   )254,
        (yytype_int16 const   )264,      (yytype_int16 const   )272,      (yytype_int16 const   )280,      (yytype_int16 const   )284,
        (yytype_int16 const   )288,      (yytype_int16 const   )292,      (yytype_int16 const   )296,      (yytype_int16 const   )300,
        (yytype_int16 const   )303,      (yytype_int16 const   )306,      (yytype_int16 const   )307,      (yytype_int16 const   )313,
        (yytype_int16 const   )317,      (yytype_int16 const   )321,      (yytype_int16 const   )325,      (yytype_int16 const   )329,
        (yytype_int16 const   )333,      (yytype_int16 const   )337,      (yytype_int16 const   )341,      (yytype_int16 const   )345,
        (yytype_int16 const   )349,      (yytype_int16 const   )353,      (yytype_int16 const   )357,      (yytype_int16 const   )361,
        (yytype_int16 const   )365,      (yytype_int16 const   )369,      (yytype_int16 const   )373,      (yytype_int16 const   )377,
        (yytype_int16 const   )381,      (yytype_int16 const   )385,      (yytype_int16 const   )389,      (yytype_int16 const   )393,
        (yytype_int16 const   )397,      (yytype_int16 const   )401,      (yytype_int16 const   )404,      (yytype_int16 const   )410,
        (yytype_int16 const   )414,      (yytype_int16 const   )421,      (yytype_int16 const   )424,      (yytype_int16 const   )431,
        (yytype_int16 const   )432,      (yytype_int16 const   )436,      (yytype_int16 const   )442,      (yytype_int16 const   )447,
        (yytype_int16 const   )454,      (yytype_int16 const   )455,      (yytype_int16 const   )456,      (yytype_int16 const   )457,
        (yytype_int16 const   )458,      (yytype_int16 const   )462,      (yytype_int16 const   )472,      (yytype_int16 const   )476,
        (yytype_int16 const   )480,      (yytype_int16 const   )481,      (yytype_int16 const   )485,      (yytype_int16 const   )489,
        (yytype_int16 const   )493,      (yytype_int16 const   )497,      (yytype_int16 const   )501,      (yytype_int16 const   )505,
        (yytype_int16 const   )509,      (yytype_int16 const   )513,      (yytype_int16 const   )517,      (yytype_int16 const   )524,
        (yytype_int16 const   )527,      (yytype_int16 const   )530,      (yytype_int16 const   )534,      (yytype_int16 const   )535,
        (yytype_int16 const   )536,      (yytype_int16 const   )540,      (yytype_int16 const   )544,      (yytype_int16 const   )548,
        (yytype_int16 const   )552,      (yytype_int16 const   )556,      (yytype_int16 const   )560,      (yytype_int16 const   )564,
        (yytype_int16 const   )570,      (yytype_int16 const   )575,      (yytype_int16 const   )582,      (yytype_int16 const   )587,
        (yytype_int16 const   )594,      (yytype_int16 const   )595,      (yytype_int16 const   )599,      (yytype_int16 const   )603,
        (yytype_int16 const   )607,      (yytype_int16 const   )611,      (yytype_int16 const   )612,      (yytype_int16 const   )618,
        (yytype_int16 const   )622,      (yytype_int16 const   )626,      (yytype_int16 const   )630,      (yytype_int16 const   )636,
        (yytype_int16 const   )640,      (yytype_int16 const   )646,      (yytype_int16 const   )650,      (yytype_int16 const   )654,
        (yytype_int16 const   )658,      (yytype_int16 const   )665,      (yytype_int16 const   )669,      (yytype_int16 const   )676,
        (yytype_int16 const   )679,      (yytype_int16 const   )682,      (yytype_int16 const   )687,      (yytype_int16 const   )694,
        (yytype_int16 const   )695,      (yytype_int16 const   )698,      (yytype_int16 const   )699,      (yytype_int16 const   )702,
        (yytype_int16 const   )703};
static char const   * const  yytname[93]  =
  {      (char const   * const  )"$end",      (char const   * const  )"error",      (char const   * const  )"$undefined",      (char const   * const  )"keyword_if",
        (char const   * const  )"keyword_else",      (char const   * const  )"keyword_case",      (char const   * const  )"keyword_emit",      (char const   * const  )"keyword_skip",
        (char const   * const  )"keyword_return",      (char const   * const  )"keyword_namespace",      (char const   * const  )"keyword_class",      (char const   * const  )"keyword_import",
        (char const   * const  )"keyword_def",      (char const   * const  )"keyword_method",      (char const   * const  )"keyword_new",      (char const   * const  )"keyword_nil",
        (char const   * const  )"keyword_true",      (char const   * const  )"keyword_false",      (char const   * const  )"op_lasgn",      (char const   * const  )"op_rasgn",
        (char const   * const  )"op_lambda",      (char const   * const  )"op_lambda2",      (char const   * const  )"op_lambda3",      (char const   * const  )"op_plus",
        (char const   * const  )"op_minus",      (char const   * const  )"op_mult",      (char const   * const  )"op_div",      (char const   * const  )"op_mod",
        (char const   * const  )"op_eq",      (char const   * const  )"op_neq",      (char const   * const  )"op_lt",      (char const   * const  )"op_le",
        (char const   * const  )"op_gt",      (char const   * const  )"op_ge",      (char const   * const  )"op_and",      (char const   * const  )"op_or",
        (char const   * const  )"op_bar",      (char const   * const  )"op_amper",      (char const   * const  )"op_colon2",      (char const   * const  )"lit_time",
        (char const   * const  )"lit_number",      (char const   * const  )"lit_symbol",      (char const   * const  )"lit_string",      (char const   * const  )"identifier",
        (char const   * const  )"label",      (char const   * const  )"op_LOWEST",      (char const   * const  )"\'!\'",      (char const   * const  )"\'~\'",
        (char const   * const  )"op_HIGHEST",      (char const   * const  )"\'{\'",      (char const   * const  )"\'}\'",      (char const   * const  )"\'(\'",
        (char const   * const  )"\')\'",      (char const   * const  )"\'=\'",      (char const   * const  )"\',\'",      (char const   * const  )"\'[\'",
        (char const   * const  )"\']\'",      (char const   * const  )"\'.\'",      (char const   * const  )"\'@\'",      (char const   * const  )"\';\'",
        (char const   * const  )"\'\\n\'",      (char const   * const  )"$accept",      (char const   * const  )"program",      (char const   * const  )"topstmts",
        (char const   * const  )"topstmt_list",      (char const   * const  )"topstmt",      (char const   * const  )"stmts",      (char const   * const  )"stmt_list",
        (char const   * const  )"stmt",      (char const   * const  )"var",      (char const   * const  )"fname",      (char const   * const  )"expr",
        (char const   * const  )"condition",      (char const   * const  )"opt_else",      (char const   * const  )"opt_args",      (char const   * const  )"arg",
        (char const   * const  )"args",      (char const   * const  )"primary",      (char const   * const  )"opt_block",      (char const   * const  )"pterm",
        (char const   * const  )"pary",      (char const   * const  )"pstruct",      (char const   * const  )"pattern",      (char const   * const  )"cparam",
        (char const   * const  )"case_body",      (char const   * const  )"block",      (char const   * const  )"bparam",      (char const   * const  )"opt_f_args",
        (char const   * const  )"f_args",      (char const   * const  )"opt_terms",      (char const   * const  )"terms",      (char const   * const  )"term",
        (char const   * const  )((void *)0)};
static yytype_int16 const   yypact[254]  =
  {      (yytype_int16 const   )257,      (yytype_int16 const   )-46,      (yytype_int16 const   )457,      (yytype_int16 const   )-211,
        (yytype_int16 const   )457,      (yytype_int16 const   )-27,      (yytype_int16 const   )-12,      (yytype_int16 const   )-9,
        (yytype_int16 const   )98,      (yytype_int16 const   )98,      (yytype_int16 const   )-2,      (yytype_int16 const   )-211,
        (yytype_int16 const   )-211,      (yytype_int16 const   )-211,      (yytype_int16 const   )499,      (yytype_int16 const   )499,
        (yytype_int16 const   )98,      (yytype_int16 const   )-211,      (yytype_int16 const   )-211,      (yytype_int16 const   )-211,
        (yytype_int16 const   )-41,      (yytype_int16 const   )-23,      (yytype_int16 const   )499,      (yytype_int16 const   )499,
        (yytype_int16 const   )315,      (yytype_int16 const   )499,      (yytype_int16 const   )412,      (yytype_int16 const   )-211,
        (yytype_int16 const   )-211,      (yytype_int16 const   )56,      (yytype_int16 const   )-211,      (yytype_int16 const   )126,
        (yytype_int16 const   )-211,      (yytype_int16 const   )-211,      (yytype_int16 const   )-30,      (yytype_int16 const   )82,
        (yytype_int16 const   )690,      (yytype_int16 const   )6,      (yytype_int16 const   )-211,      (yytype_int16 const   )-211,
        (yytype_int16 const   )257,      (yytype_int16 const   )-211,      (yytype_int16 const   )499,      (yytype_int16 const   )499,
        (yytype_int16 const   )499,      (yytype_int16 const   )499,      (yytype_int16 const   )-211,      (yytype_int16 const   )741,
        (yytype_int16 const   )-211,      (yytype_int16 const   )-211,      (yytype_int16 const   )16,      (yytype_int16 const   )-211,
        (yytype_int16 const   )33,      (yytype_int16 const   )36,      (yytype_int16 const   )-211,      (yytype_int16 const   )-211,
        (yytype_int16 const   )-211,      (yytype_int16 const   )111,      (yytype_int16 const   )68,      (yytype_int16 const   )71,
        (yytype_int16 const   )-211,      (yytype_int16 const   )-211,      (yytype_int16 const   )-211,      (yytype_int16 const   )-211,
        (yytype_int16 const   )-211,      (yytype_int16 const   )540,      (yytype_int16 const   )-211,      (yytype_int16 const   )41,
        (yytype_int16 const   )126,      (yytype_int16 const   )-211,      (yytype_int16 const   )-18,      (yytype_int16 const   )10,
        (yytype_int16 const   )365,      (yytype_int16 const   )-8,      (yytype_int16 const   )-211,      (yytype_int16 const   )365,
        (yytype_int16 const   )40,      (yytype_int16 const   )630,      (yytype_int16 const   )136,      (yytype_int16 const   )97,
        (yytype_int16 const   )-211,      (yytype_int16 const   )113,      (yytype_int16 const   )-211,      (yytype_int16 const   )-211,
        (yytype_int16 const   )257,      (yytype_int16 const   )499,      (yytype_int16 const   )457,      (yytype_int16 const   )-211,
        (yytype_int16 const   )118,      (yytype_int16 const   )499,      (yytype_int16 const   )499,      (yytype_int16 const   )499,
        (yytype_int16 const   )499,      (yytype_int16 const   )499,      (yytype_int16 const   )499,      (yytype_int16 const   )499,
        (yytype_int16 const   )499,      (yytype_int16 const   )499,      (yytype_int16 const   )499,      (yytype_int16 const   )499,
        (yytype_int16 const   )499,      (yytype_int16 const   )499,      (yytype_int16 const   )499,      (yytype_int16 const   )499,
        (yytype_int16 const   )44,      (yytype_int16 const   )126,      (yytype_int16 const   )-211,      (yytype_int16 const   )660,
        (yytype_int16 const   )615,      (yytype_int16 const   )741,      (yytype_int16 const   )741,      (yytype_int16 const   )457,
        (yytype_int16 const   )257,      (yytype_int16 const   )257,      (yytype_int16 const   )118,      (yytype_int16 const   )499,
        (yytype_int16 const   )118,      (yytype_int16 const   )457,      (yytype_int16 const   )499,      (yytype_int16 const   )-211,
        (yytype_int16 const   )-211,      (yytype_int16 const   )-211,      (yytype_int16 const   )-211,      (yytype_int16 const   )185,
        (yytype_int16 const   )-211,      (yytype_int16 const   )-211,      (yytype_int16 const   )-211,      (yytype_int16 const   )185,
        (yytype_int16 const   )546,      (yytype_int16 const   )-211,      (yytype_int16 const   )108,      (yytype_int16 const   )123,
        (yytype_int16 const   )134,      (yytype_int16 const   )51,      (yytype_int16 const   )365,      (yytype_int16 const   )-211,
        (yytype_int16 const   )-211,      (yytype_int16 const   )365,      (yytype_int16 const   )153,      (yytype_int16 const   )540,
        (yytype_int16 const   )-211,      (yytype_int16 const   )140,      (yytype_int16 const   )-211,      (yytype_int16 const   )118,
        (yytype_int16 const   )126,      (yytype_int16 const   )-211,      (yytype_int16 const   )499,      (yytype_int16 const   )365,
        (yytype_int16 const   )-211,      (yytype_int16 const   )-211,      (yytype_int16 const   )741,      (yytype_int16 const   )142,
        (yytype_int16 const   )-211,      (yytype_int16 const   )119,      (yytype_int16 const   )119,      (yytype_int16 const   )-211,
        (yytype_int16 const   )-211,      (yytype_int16 const   )-211,      (yytype_int16 const   )317,      (yytype_int16 const   )317,
        (yytype_int16 const   )157,      (yytype_int16 const   )157,      (yytype_int16 const   )157,      (yytype_int16 const   )157,
        (yytype_int16 const   )367,      (yytype_int16 const   )259,      (yytype_int16 const   )756,      (yytype_int16 const   )645,
        (yytype_int16 const   )457,      (yytype_int16 const   )121,      (yytype_int16 const   )-211,      (yytype_int16 const   )-211,
        (yytype_int16 const   )499,      (yytype_int16 const   )-211,      (yytype_int16 const   )-211,      (yytype_int16 const   )147,
        (yytype_int16 const   )149,      (yytype_int16 const   )-211,      (yytype_int16 const   )151,      (yytype_int16 const   )741,
        (yytype_int16 const   )158,      (yytype_int16 const   )156,      (yytype_int16 const   )708,      (yytype_int16 const   )22,
        (yytype_int16 const   )108,      (yytype_int16 const   )-211,      (yytype_int16 const   )166,      (yytype_int16 const   )160,
        (yytype_int16 const   )170,      (yytype_int16 const   )2,      (yytype_int16 const   )23,      (yytype_int16 const   )499,
        (yytype_int16 const   )-211,      (yytype_int16 const   )-211,      (yytype_int16 const   )-211,      (yytype_int16 const   )365,
        (yytype_int16 const   )365,      (yytype_int16 const   )-211,      (yytype_int16 const   )-211,      (yytype_int16 const   )-211,
        (yytype_int16 const   )741,      (yytype_int16 const   )167,      (yytype_int16 const   )143,      (yytype_int16 const   )171,
        (yytype_int16 const   )457,      (yytype_int16 const   )-211,      (yytype_int16 const   )-211,      (yytype_int16 const   )741,
        (yytype_int16 const   )-211,      (yytype_int16 const   )-211,      (yytype_int16 const   )20,      (yytype_int16 const   )30,
        (yytype_int16 const   )-211,      (yytype_int16 const   )-211,      (yytype_int16 const   )185,      (yytype_int16 const   )581,
        (yytype_int16 const   )-211,      (yytype_int16 const   )-211,      (yytype_int16 const   )185,      (yytype_int16 const   )108,
        (yytype_int16 const   )185,      (yytype_int16 const   )185,      (yytype_int16 const   )726,      (yytype_int16 const   )169,
        (yytype_int16 const   )-211,      (yytype_int16 const   )-211,      (yytype_int16 const   )-211,      (yytype_int16 const   )143,
        (yytype_int16 const   )172,      (yytype_int16 const   )365,      (yytype_int16 const   )499,      (yytype_int16 const   )365,
        (yytype_int16 const   )499,      (yytype_int16 const   )168,      (yytype_int16 const   )-211,      (yytype_int16 const   )174,
        (yytype_int16 const   )78,      (yytype_int16 const   )108,      (yytype_int16 const   )108,      (yytype_int16 const   )-211,
        (yytype_int16 const   )-211,      (yytype_int16 const   )-211,      (yytype_int16 const   )143,      (yytype_int16 const   )176,
        (yytype_int16 const   )741,      (yytype_int16 const   )182,      (yytype_int16 const   )741,      (yytype_int16 const   )185,
        (yytype_int16 const   )-211,      (yytype_int16 const   )185,      (yytype_int16 const   )-211,      (yytype_int16 const   )-211,
        (yytype_int16 const   )-211,      (yytype_int16 const   )168};
static yytype_uint8 const   yydefact[254]  =
  {      (yytype_uint8 const   )123,      (yytype_uint8 const   )0,      (yytype_uint8 const   )57,      (yytype_uint8 const   )24,
        (yytype_uint8 const   )57,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )73,
        (yytype_uint8 const   )74,      (yytype_uint8 const   )75,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,
        (yytype_uint8 const   )0,      (yytype_uint8 const   )67,      (yytype_uint8 const   )64,      (yytype_uint8 const   )66,
        (yytype_uint8 const   )65,      (yytype_uint8 const   )28,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,
        (yytype_uint8 const   )123,      (yytype_uint8 const   )119,      (yytype_uint8 const   )0,      (yytype_uint8 const   )127,
        (yytype_uint8 const   )128,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )123,
        (yytype_uint8 const   )6,      (yytype_uint8 const   )13,      (yytype_uint8 const   )68,      (yytype_uint8 const   )0,
        (yytype_uint8 const   )27,      (yytype_uint8 const   )53,      (yytype_uint8 const   )72,      (yytype_uint8 const   )5,
        (yytype_uint8 const   )124,      (yytype_uint8 const   )125,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )68,      (yytype_uint8 const   )59,
        (yytype_uint8 const   )25,      (yytype_uint8 const   )62,      (yytype_uint8 const   )58,      (yytype_uint8 const   )26,
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )10,      (yytype_uint8 const   )30,
        (yytype_uint8 const   )29,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,
        (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )82,      (yytype_uint8 const   )46,
        (yytype_uint8 const   )47,      (yytype_uint8 const   )0,      (yytype_uint8 const   )117,      (yytype_uint8 const   )0,
        (yytype_uint8 const   )123,      (yytype_uint8 const   )17,      (yytype_uint8 const   )68,      (yytype_uint8 const   )0,
        (yytype_uint8 const   )123,      (yytype_uint8 const   )0,      (yytype_uint8 const   )16,      (yytype_uint8 const   )124,
        (yytype_uint8 const   )68,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )120,
        (yytype_uint8 const   )71,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,
        (yytype_uint8 const   )124,      (yytype_uint8 const   )0,      (yytype_uint8 const   )57,      (yytype_uint8 const   )77,
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,
        (yytype_uint8 const   )0,      (yytype_uint8 const   )123,      (yytype_uint8 const   )126,      (yytype_uint8 const   )0,
        (yytype_uint8 const   )55,      (yytype_uint8 const   )61,      (yytype_uint8 const   )60,      (yytype_uint8 const   )0,
        (yytype_uint8 const   )123,      (yytype_uint8 const   )123,      (yytype_uint8 const   )119,      (yytype_uint8 const   )0,
        (yytype_uint8 const   )119,      (yytype_uint8 const   )57,      (yytype_uint8 const   )0,      (yytype_uint8 const   )88,
        (yytype_uint8 const   )89,      (yytype_uint8 const   )90,      (yytype_uint8 const   )107,      (yytype_uint8 const   )0,
        (yytype_uint8 const   )86,      (yytype_uint8 const   )87,      (yytype_uint8 const   )28,      (yytype_uint8 const   )0,
        (yytype_uint8 const   )0,      (yytype_uint8 const   )85,      (yytype_uint8 const   )96,      (yytype_uint8 const   )100,
        (yytype_uint8 const   )105,      (yytype_uint8 const   )0,      (yytype_uint8 const   )123,      (yytype_uint8 const   )113,
        (yytype_uint8 const   )14,      (yytype_uint8 const   )124,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,
        (yytype_uint8 const   )115,      (yytype_uint8 const   )0,      (yytype_uint8 const   )118,      (yytype_uint8 const   )0,
        (yytype_uint8 const   )123,      (yytype_uint8 const   )69,      (yytype_uint8 const   )0,      (yytype_uint8 const   )123,
        (yytype_uint8 const   )70,      (yytype_uint8 const   )7,      (yytype_uint8 const   )19,      (yytype_uint8 const   )0,
        (yytype_uint8 const   )23,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32,      (yytype_uint8 const   )33,
        (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43,
        (yytype_uint8 const   )40,      (yytype_uint8 const   )41,      (yytype_uint8 const   )38,      (yytype_uint8 const   )39,
        (yytype_uint8 const   )48,      (yytype_uint8 const   )49,      (yytype_uint8 const   )36,      (yytype_uint8 const   )37,
        (yytype_uint8 const   )57,      (yytype_uint8 const   )83,      (yytype_uint8 const   )4,      (yytype_uint8 const   )54,
        (yytype_uint8 const   )0,      (yytype_uint8 const   )52,      (yytype_uint8 const   )63,      (yytype_uint8 const   )0,
        (yytype_uint8 const   )0,      (yytype_uint8 const   )121,      (yytype_uint8 const   )0,      (yytype_uint8 const   )22,
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )103,
        (yytype_uint8 const   )98,      (yytype_uint8 const   )91,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,
        (yytype_uint8 const   )109,      (yytype_uint8 const   )111,      (yytype_uint8 const   )18,      (yytype_uint8 const   )123,
        (yytype_uint8 const   )123,      (yytype_uint8 const   )114,      (yytype_uint8 const   )122,      (yytype_uint8 const   )15,
        (yytype_uint8 const   )50,      (yytype_uint8 const   )0,      (yytype_uint8 const   )83,      (yytype_uint8 const   )0,
        (yytype_uint8 const   )57,      (yytype_uint8 const   )80,      (yytype_uint8 const   )84,      (yytype_uint8 const   )56,
        (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,
        (yytype_uint8 const   )76,      (yytype_uint8 const   )108,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,
        (yytype_uint8 const   )93,      (yytype_uint8 const   )95,      (yytype_uint8 const   )0,      (yytype_uint8 const   )97,
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,
        (yytype_uint8 const   )112,      (yytype_uint8 const   )51,      (yytype_uint8 const   )78,      (yytype_uint8 const   )83,
        (yytype_uint8 const   )0,      (yytype_uint8 const   )123,      (yytype_uint8 const   )0,      (yytype_uint8 const   )123,
        (yytype_uint8 const   )0,      (yytype_uint8 const   )104,      (yytype_uint8 const   )92,      (yytype_uint8 const   )0,
        (yytype_uint8 const   )101,      (yytype_uint8 const   )106,      (yytype_uint8 const   )99,      (yytype_uint8 const   )110,
        (yytype_uint8 const   )116,      (yytype_uint8 const   )81,      (yytype_uint8 const   )83,      (yytype_uint8 const   )0,
        (yytype_uint8 const   )21,      (yytype_uint8 const   )0,      (yytype_uint8 const   )12,      (yytype_uint8 const   )0,
        (yytype_uint8 const   )94,      (yytype_uint8 const   )0,      (yytype_uint8 const   )79,      (yytype_uint8 const   )20,
        (yytype_uint8 const   )11,      (yytype_uint8 const   )102};
static yytype_int16 const   yypgoto[31]  =
  {      (yytype_int16 const   )-211,      (yytype_int16 const   )-211,      (yytype_int16 const   )93,      (yytype_int16 const   )194,
        (yytype_int16 const   )154,      (yytype_int16 const   )-66,      (yytype_int16 const   )173,      (yytype_int16 const   )37,
        (yytype_int16 const   )0,      (yytype_int16 const   )50,      (yytype_int16 const   )7,      (yytype_int16 const   )-211,
        (yytype_int16 const   )-211,      (yytype_int16 const   )3,      (yytype_int16 const   )130,      (yytype_int16 const   )216,
        (yytype_int16 const   )-211,      (yytype_int16 const   )-189,      (yytype_int16 const   )15,      (yytype_int16 const   )-210,
        (yytype_int16 const   )-211,      (yytype_int16 const   )-125,      (yytype_int16 const   )104,      (yytype_int16 const   )-211,
        (yytype_int16 const   )-34,      (yytype_int16 const   )-211,      (yytype_int16 const   )62,      (yytype_int16 const   )220,
        (yytype_int16 const   )43,      (yytype_int16 const   )47,      (yytype_int16 const   )-20};
static yytype_int16 const   yydefgoto[31]  =
  {      (yytype_int16 const   )-1,      (yytype_int16 const   )29,      (yytype_int16 const   )30,      (yytype_int16 const   )31,
        (yytype_int16 const   )32,      (yytype_int16 const   )67,      (yytype_int16 const   )68,      (yytype_int16 const   )69,
        (yytype_int16 const   )46,      (yytype_int16 const   )35,      (yytype_int16 const   )36,      (yytype_int16 const   )43,
        (yytype_int16 const   )173,      (yytype_int16 const   )48,      (yytype_int16 const   )49,      (yytype_int16 const   )50,
        (yytype_int16 const   )37,      (yytype_int16 const   )205,      (yytype_int16 const   )130,      (yytype_int16 const   )131,
        (yytype_int16 const   )132,      (yytype_int16 const   )133,      (yytype_int16 const   )134,      (yytype_int16 const   )71,
        (yytype_int16 const   )38,      (yytype_int16 const   )72,      (yytype_int16 const   )78,      (yytype_int16 const   )79,
        (yytype_int16 const   )74,      (yytype_int16 const   )75,      (yytype_int16 const   )41};
static yytype_int16 const   yytable[794]  =
  {      (yytype_int16 const   )34,      (yytype_int16 const   )87,      (yytype_int16 const   )-121,      (yytype_int16 const   )187,
        (yytype_int16 const   )233,      (yytype_int16 const   )42,      (yytype_int16 const   )141,      (yytype_int16 const   )51,
        (yytype_int16 const   )-30,      (yytype_int16 const   )47,      (yytype_int16 const   )-30,      (yytype_int16 const   )47,
        (yytype_int16 const   )142,      (yytype_int16 const   )226,      (yytype_int16 const   )138,      (yytype_int16 const   )139,
        (yytype_int16 const   )52,      (yytype_int16 const   )119,      (yytype_int16 const   )120,      (yytype_int16 const   )121,
        (yytype_int16 const   )106,      (yytype_int16 const   )60,      (yytype_int16 const   )61,      (yytype_int16 const   )85,
        (yytype_int16 const   )70,      (yytype_int16 const   )76,      (yytype_int16 const   )-29,      (yytype_int16 const   )218,
        (yytype_int16 const   )-29,      (yytype_int16 const   )63,      (yytype_int16 const   )64,      (yytype_int16 const   )53,
        (yytype_int16 const   )77,      (yytype_int16 const   )47,      (yytype_int16 const   )54,      (yytype_int16 const   )85,
        (yytype_int16 const   )-121,      (yytype_int16 const   )33,      (yytype_int16 const   )241,      (yytype_int16 const   )253,
        (yytype_int16 const   )34,      (yytype_int16 const   )59,      (yytype_int16 const   )124,      (yytype_int16 const   )39,
        (yytype_int16 const   )125,      (yytype_int16 const   )126,      (yytype_int16 const   )143,      (yytype_int16 const   )40,
        (yytype_int16 const   )220,      (yytype_int16 const   )107,      (yytype_int16 const   )108,      (yytype_int16 const   )109,
        (yytype_int16 const   )110,      (yytype_int16 const   )250,      (yytype_int16 const   )191,      (yytype_int16 const   )106,
        (yytype_int16 const   )82,      (yytype_int16 const   )128,      (yytype_int16 const   )57,      (yytype_int16 const   )58,
        (yytype_int16 const   )140,      (yytype_int16 const   )-121,      (yytype_int16 const   )-121,      (yytype_int16 const   )104,
        (yytype_int16 const   )106,      (yytype_int16 const   )129,      (yytype_int16 const   )62,      (yytype_int16 const   )221,
        (yytype_int16 const   )193,      (yytype_int16 const   )229,      (yytype_int16 const   )111,      (yytype_int16 const   )192,
        (yytype_int16 const   )34,      (yytype_int16 const   )230,      (yytype_int16 const   )83,      (yytype_int16 const   )34,
        (yytype_int16 const   )214,      (yytype_int16 const   )33,      (yytype_int16 const   )84,      (yytype_int16 const   )231,
        (yytype_int16 const   )188,      (yytype_int16 const   )201,      (yytype_int16 const   )112,      (yytype_int16 const   )232,
        (yytype_int16 const   )34,      (yytype_int16 const   )113,      (yytype_int16 const   )55,      (yytype_int16 const   )56,
        (yytype_int16 const   )152,      (yytype_int16 const   )151,      (yytype_int16 const   )235,      (yytype_int16 const   )135,
        (yytype_int16 const   )150,      (yytype_int16 const   )47,      (yytype_int16 const   )-121,      (yytype_int16 const   )168,
        (yytype_int16 const   )153,      (yytype_int16 const   )154,      (yytype_int16 const   )155,      (yytype_int16 const   )156,
        (yytype_int16 const   )157,      (yytype_int16 const   )158,      (yytype_int16 const   )159,      (yytype_int16 const   )160,
        (yytype_int16 const   )161,      (yytype_int16 const   )162,      (yytype_int16 const   )163,      (yytype_int16 const   )164,
        (yytype_int16 const   )165,      (yytype_int16 const   )166,      (yytype_int16 const   )167,      (yytype_int16 const   )136,
        (yytype_int16 const   )34,      (yytype_int16 const   )34,      (yytype_int16 const   )177,      (yytype_int16 const   )137,
        (yytype_int16 const   )177,      (yytype_int16 const   )106,      (yytype_int16 const   )47,      (yytype_int16 const   )116,
        (yytype_int16 const   )181,      (yytype_int16 const   )33,      (yytype_int16 const   )179,      (yytype_int16 const   )129,
        (yytype_int16 const   )47,      (yytype_int16 const   )182,      (yytype_int16 const   )117,      (yytype_int16 const   )129,
        (yytype_int16 const   )129,      (yytype_int16 const   )223,      (yytype_int16 const   )224,      (yytype_int16 const   )24,
        (yytype_int16 const   )249,      (yytype_int16 const   )86,      (yytype_int16 const   )34,      (yytype_int16 const   )206,
        (yytype_int16 const   )188,      (yytype_int16 const   )34,      (yytype_int16 const   )183,      (yytype_int16 const   )129,
        (yytype_int16 const   )55,      (yytype_int16 const   )56,      (yytype_int16 const   )184,      (yytype_int16 const   )198,
        (yytype_int16 const   )91,      (yytype_int16 const   )92,      (yytype_int16 const   )93,      (yytype_int16 const   )34,
        (yytype_int16 const   )170,      (yytype_int16 const   )33,      (yytype_int16 const   )33,      (yytype_int16 const   )143,
        (yytype_int16 const   )84,      (yytype_int16 const   )200,      (yytype_int16 const   )169,      (yytype_int16 const   )39,
        (yytype_int16 const   )39,      (yytype_int16 const   )146,      (yytype_int16 const   )147,      (yytype_int16 const   )40,
        (yytype_int16 const   )40,      (yytype_int16 const   )126,      (yytype_int16 const   )114,      (yytype_int16 const   )243,
        (yytype_int16 const   )115,      (yytype_int16 const   )245,      (yytype_int16 const   )188,      (yytype_int16 const   )111,
        (yytype_int16 const   )206,      (yytype_int16 const   )148,      (yytype_int16 const   )24,      (yytype_int16 const   )203,
        (yytype_int16 const   )204,      (yytype_int16 const   )195,      (yytype_int16 const   )194,      (yytype_int16 const   )47,
        (yytype_int16 const   )178,      (yytype_int16 const   )189,      (yytype_int16 const   )180,      (yytype_int16 const   )207,
        (yytype_int16 const   )89,      (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )92,
        (yytype_int16 const   )93,      (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )199,
        (yytype_int16 const   )190,      (yytype_int16 const   )129,      (yytype_int16 const   )197,      (yytype_int16 const   )137,
        (yytype_int16 const   )24,      (yytype_int16 const   )206,      (yytype_int16 const   )202,      (yytype_int16 const   )34,
        (yytype_int16 const   )34,      (yytype_int16 const   )208,      (yytype_int16 const   )222,      (yytype_int16 const   )209,
        (yytype_int16 const   )119,      (yytype_int16 const   )120,      (yytype_int16 const   )121,      (yytype_int16 const   )210,
        (yytype_int16 const   )219,      (yytype_int16 const   )175,      (yytype_int16 const   )176,      (yytype_int16 const   )228,
        (yytype_int16 const   )206,      (yytype_int16 const   )215,      (yytype_int16 const   )211,      (yytype_int16 const   )47,
        (yytype_int16 const   )212,      (yytype_int16 const   )217,      (yytype_int16 const   )129,      (yytype_int16 const   )129,
        (yytype_int16 const   )216,      (yytype_int16 const   )225,      (yytype_int16 const   )129,      (yytype_int16 const   )240,
        (yytype_int16 const   )129,      (yytype_int16 const   )129,      (yytype_int16 const   )247,      (yytype_int16 const   )227,
        (yytype_int16 const   )242,      (yytype_int16 const   )124,      (yytype_int16 const   )251,      (yytype_int16 const   )125,
        (yytype_int16 const   )126,      (yytype_int16 const   )34,      (yytype_int16 const   )248,      (yytype_int16 const   )34,
        (yytype_int16 const   )252,      (yytype_int16 const   )236,      (yytype_int16 const   )105,      (yytype_int16 const   )237,
        (yytype_int16 const   )238,      (yytype_int16 const   )244,      (yytype_int16 const   )149,      (yytype_int16 const   )246,
        (yytype_int16 const   )128,      (yytype_int16 const   )174,      (yytype_int16 const   )81,      (yytype_int16 const   )196,
        (yytype_int16 const   )73,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )129,
        (yytype_int16 const   )144,      (yytype_int16 const   )129,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )1,      (yytype_int16 const   )0,      (yytype_int16 const   )219,      (yytype_int16 const   )2,
        (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )5,      (yytype_int16 const   )6,
        (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )9,      (yytype_int16 const   )10,
        (yytype_int16 const   )11,      (yytype_int16 const   )12,      (yytype_int16 const   )13,      (yytype_int16 const   )0,
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )89,      (yytype_int16 const   )90,
        (yytype_int16 const   )91,      (yytype_int16 const   )92,      (yytype_int16 const   )93,      (yytype_int16 const   )94,
        (yytype_int16 const   )95,      (yytype_int16 const   )96,      (yytype_int16 const   )97,      (yytype_int16 const   )98,
        (yytype_int16 const   )99,      (yytype_int16 const   )100,      (yytype_int16 const   )16,      (yytype_int16 const   )0,
        (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20,
        (yytype_int16 const   )21,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )22,
        (yytype_int16 const   )23,      (yytype_int16 const   )0,      (yytype_int16 const   )24,      (yytype_int16 const   )0,
        (yytype_int16 const   )25,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )26,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )1,      (yytype_int16 const   )0,
        (yytype_int16 const   )65,      (yytype_int16 const   )2,      (yytype_int16 const   )3,      (yytype_int16 const   )4,
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )8,
        (yytype_int16 const   )0,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )12,
        (yytype_int16 const   )13,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )66,
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )14,      (yytype_int16 const   )15,
        (yytype_int16 const   )89,      (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )92,
        (yytype_int16 const   )93,      (yytype_int16 const   )-122,      (yytype_int16 const   )-122,      (yytype_int16 const   )96,
        (yytype_int16 const   )97,      (yytype_int16 const   )98,      (yytype_int16 const   )99,      (yytype_int16 const   )0,
        (yytype_int16 const   )16,      (yytype_int16 const   )0,      (yytype_int16 const   )17,      (yytype_int16 const   )18,
        (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )0,
        (yytype_int16 const   )0,      (yytype_int16 const   )22,      (yytype_int16 const   )23,      (yytype_int16 const   )0,
        (yytype_int16 const   )24,      (yytype_int16 const   )0,      (yytype_int16 const   )25,      (yytype_int16 const   )0,
        (yytype_int16 const   )1,      (yytype_int16 const   )0,      (yytype_int16 const   )26,      (yytype_int16 const   )2,
        (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )27,      (yytype_int16 const   )28,
        (yytype_int16 const   )0,      (yytype_int16 const   )8,      (yytype_int16 const   )0,      (yytype_int16 const   )10,
        (yytype_int16 const   )11,      (yytype_int16 const   )12,      (yytype_int16 const   )13,      (yytype_int16 const   )0,
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )89,      (yytype_int16 const   )90,
        (yytype_int16 const   )91,      (yytype_int16 const   )92,      (yytype_int16 const   )93,      (yytype_int16 const   )94,
        (yytype_int16 const   )95,      (yytype_int16 const   )96,      (yytype_int16 const   )97,      (yytype_int16 const   )98,
        (yytype_int16 const   )99,      (yytype_int16 const   )0,      (yytype_int16 const   )16,      (yytype_int16 const   )0,
        (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20,
        (yytype_int16 const   )21,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )22,
        (yytype_int16 const   )23,      (yytype_int16 const   )0,      (yytype_int16 const   )24,      (yytype_int16 const   )1,
        (yytype_int16 const   )25,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )26,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )10,      (yytype_int16 const   )11,
        (yytype_int16 const   )12,      (yytype_int16 const   )13,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )14,
        (yytype_int16 const   )15,      (yytype_int16 const   )44,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )0,      (yytype_int16 const   )16,      (yytype_int16 const   )0,      (yytype_int16 const   )17,
        (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )21,
        (yytype_int16 const   )45,      (yytype_int16 const   )0,      (yytype_int16 const   )22,      (yytype_int16 const   )23,
        (yytype_int16 const   )1,      (yytype_int16 const   )24,      (yytype_int16 const   )0,      (yytype_int16 const   )25,
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )26,
        (yytype_int16 const   )80,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )10,
        (yytype_int16 const   )11,      (yytype_int16 const   )12,      (yytype_int16 const   )13,      (yytype_int16 const   )0,
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )44,      (yytype_int16 const   )0,
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )16,      (yytype_int16 const   )0,
        (yytype_int16 const   )17,      (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20,
        (yytype_int16 const   )21,      (yytype_int16 const   )45,      (yytype_int16 const   )1,      (yytype_int16 const   )22,
        (yytype_int16 const   )23,      (yytype_int16 const   )0,      (yytype_int16 const   )24,      (yytype_int16 const   )0,
        (yytype_int16 const   )25,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )26,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )12,
        (yytype_int16 const   )13,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )14,      (yytype_int16 const   )15,
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )16,      (yytype_int16 const   )0,      (yytype_int16 const   )17,      (yytype_int16 const   )18,
        (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )118,
        (yytype_int16 const   )0,      (yytype_int16 const   )22,      (yytype_int16 const   )23,      (yytype_int16 const   )0,
        (yytype_int16 const   )24,      (yytype_int16 const   )0,      (yytype_int16 const   )25,      (yytype_int16 const   )0,
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )26,      (yytype_int16 const   )119,
        (yytype_int16 const   )120,      (yytype_int16 const   )121,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )122,      (yytype_int16 const   )119,      (yytype_int16 const   )120,      (yytype_int16 const   )121,
        (yytype_int16 const   )0,      (yytype_int16 const   )123,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )123,
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )124,      (yytype_int16 const   )0,      (yytype_int16 const   )125,      (yytype_int16 const   )126,
        (yytype_int16 const   )127,      (yytype_int16 const   )0,      (yytype_int16 const   )124,      (yytype_int16 const   )0,
        (yytype_int16 const   )125,      (yytype_int16 const   )126,      (yytype_int16 const   )127,      (yytype_int16 const   )0,
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )128,
        (yytype_int16 const   )119,      (yytype_int16 const   )120,      (yytype_int16 const   )121,      (yytype_int16 const   )0,
        (yytype_int16 const   )0,      (yytype_int16 const   )128,      (yytype_int16 const   )185,      (yytype_int16 const   )0,
        (yytype_int16 const   )186,      (yytype_int16 const   )0,      (yytype_int16 const   )123,      (yytype_int16 const   )0,
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )172,
        (yytype_int16 const   )0,      (yytype_int16 const   )124,      (yytype_int16 const   )0,      (yytype_int16 const   )125,
        (yytype_int16 const   )126,      (yytype_int16 const   )127,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )128,      (yytype_int16 const   )234,      (yytype_int16 const   )89,      (yytype_int16 const   )90,
        (yytype_int16 const   )91,      (yytype_int16 const   )92,      (yytype_int16 const   )93,      (yytype_int16 const   )94,
        (yytype_int16 const   )95,      (yytype_int16 const   )96,      (yytype_int16 const   )97,      (yytype_int16 const   )98,
        (yytype_int16 const   )99,      (yytype_int16 const   )100,      (yytype_int16 const   )101,      (yytype_int16 const   )102,
        (yytype_int16 const   )103,      (yytype_int16 const   )89,      (yytype_int16 const   )90,      (yytype_int16 const   )91,
        (yytype_int16 const   )92,      (yytype_int16 const   )93,      (yytype_int16 const   )94,      (yytype_int16 const   )95,
        (yytype_int16 const   )96,      (yytype_int16 const   )97,      (yytype_int16 const   )98,      (yytype_int16 const   )99,
        (yytype_int16 const   )100,      (yytype_int16 const   )101,      (yytype_int16 const   )102,      (yytype_int16 const   )103,
        (yytype_int16 const   )89,      (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )92,
        (yytype_int16 const   )93,      (yytype_int16 const   )94,      (yytype_int16 const   )95,      (yytype_int16 const   )96,
        (yytype_int16 const   )97,      (yytype_int16 const   )98,      (yytype_int16 const   )99,      (yytype_int16 const   )100,
        (yytype_int16 const   )101,      (yytype_int16 const   )0,      (yytype_int16 const   )145,      (yytype_int16 const   )89,
        (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )92,      (yytype_int16 const   )93,
        (yytype_int16 const   )94,      (yytype_int16 const   )95,      (yytype_int16 const   )96,      (yytype_int16 const   )97,
        (yytype_int16 const   )98,      (yytype_int16 const   )99,      (yytype_int16 const   )100,      (yytype_int16 const   )101,
        (yytype_int16 const   )102,      (yytype_int16 const   )103,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )0,      (yytype_int16 const   )88,      (yytype_int16 const   )0,      (yytype_int16 const   )0,
        (yytype_int16 const   )171,      (yytype_int16 const   )89,      (yytype_int16 const   )90,      (yytype_int16 const   )91,
        (yytype_int16 const   )92,      (yytype_int16 const   )93,      (yytype_int16 const   )94,      (yytype_int16 const   )95,
        (yytype_int16 const   )96,      (yytype_int16 const   )97,      (yytype_int16 const   )98,      (yytype_int16 const   )99,
        (yytype_int16 const   )100,      (yytype_int16 const   )101,      (yytype_int16 const   )102,      (yytype_int16 const   )103,
        (yytype_int16 const   )213,      (yytype_int16 const   )0,      (yytype_int16 const   )0,      (yytype_int16 const   )89,
        (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )92,      (yytype_int16 const   )93,
        (yytype_int16 const   )94,      (yytype_int16 const   )95,      (yytype_int16 const   )96,      (yytype_int16 const   )97,
        (yytype_int16 const   )98,      (yytype_int16 const   )99,      (yytype_int16 const   )100,      (yytype_int16 const   )101,
        (yytype_int16 const   )102,      (yytype_int16 const   )103,      (yytype_int16 const   )239,      (yytype_int16 const   )0,
        (yytype_int16 const   )0,      (yytype_int16 const   )89,      (yytype_int16 const   )90,      (yytype_int16 const   )91,
        (yytype_int16 const   )92,      (yytype_int16 const   )93,      (yytype_int16 const   )94,      (yytype_int16 const   )95,
        (yytype_int16 const   )96,      (yytype_int16 const   )97,      (yytype_int16 const   )98,      (yytype_int16 const   )99,
        (yytype_int16 const   )100,      (yytype_int16 const   )101,      (yytype_int16 const   )102,      (yytype_int16 const   )103,
        (yytype_int16 const   )89,      (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )92,
        (yytype_int16 const   )93,      (yytype_int16 const   )94,      (yytype_int16 const   )95,      (yytype_int16 const   )96,
        (yytype_int16 const   )97,      (yytype_int16 const   )98,      (yytype_int16 const   )99,      (yytype_int16 const   )100,
        (yytype_int16 const   )101,      (yytype_int16 const   )102,      (yytype_int16 const   )103,      (yytype_int16 const   )89,
        (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )92,      (yytype_int16 const   )93,
        (yytype_int16 const   )94,      (yytype_int16 const   )95,      (yytype_int16 const   )96,      (yytype_int16 const   )97,
        (yytype_int16 const   )98,      (yytype_int16 const   )99,      (yytype_int16 const   )100,      (yytype_int16 const   )101,
        (yytype_int16 const   )0,      (yytype_int16 const   )103};
static yytype_int16 const   yycheck[794]  =
  {      (yytype_int16 const   )0,      (yytype_int16 const   )35,      (yytype_int16 const   )20,      (yytype_int16 const   )128,
        (yytype_int16 const   )214,      (yytype_int16 const   )51,      (yytype_int16 const   )72,      (yytype_int16 const   )4,
        (yytype_int16 const   )49,      (yytype_int16 const   )2,      (yytype_int16 const   )51,      (yytype_int16 const   )4,
        (yytype_int16 const   )20,      (yytype_int16 const   )202,      (yytype_int16 const   )4,      (yytype_int16 const   )5,
        (yytype_int16 const   )43,      (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17,
        (yytype_int16 const   )40,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )53,
        (yytype_int16 const   )24,      (yytype_int16 const   )25,      (yytype_int16 const   )49,      (yytype_int16 const   )25,
        (yytype_int16 const   )51,      (yytype_int16 const   )22,      (yytype_int16 const   )23,      (yytype_int16 const   )43,
        (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )43,      (yytype_int16 const   )53,
        (yytype_int16 const   )54,      (yytype_int16 const   )0,      (yytype_int16 const   )227,      (yytype_int16 const   )249,
        (yytype_int16 const   )40,      (yytype_int16 const   )43,      (yytype_int16 const   )40,      (yytype_int16 const   )0,
        (yytype_int16 const   )42,      (yytype_int16 const   )43,      (yytype_int16 const   )54,      (yytype_int16 const   )0,
        (yytype_int16 const   )25,      (yytype_int16 const   )42,      (yytype_int16 const   )43,      (yytype_int16 const   )44,
        (yytype_int16 const   )45,      (yytype_int16 const   )242,      (yytype_int16 const   )3,      (yytype_int16 const   )75,
        (yytype_int16 const   )0,      (yytype_int16 const   )55,      (yytype_int16 const   )8,      (yytype_int16 const   )9,
        (yytype_int16 const   )50,      (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )57,
        (yytype_int16 const   )84,      (yytype_int16 const   )65,      (yytype_int16 const   )16,      (yytype_int16 const   )44,
        (yytype_int16 const   )134,      (yytype_int16 const   )49,      (yytype_int16 const   )54,      (yytype_int16 const   )20,
        (yytype_int16 const   )72,      (yytype_int16 const   )53,      (yytype_int16 const   )31,      (yytype_int16 const   )75,
        (yytype_int16 const   )54,      (yytype_int16 const   )40,      (yytype_int16 const   )31,      (yytype_int16 const   )49,
        (yytype_int16 const   )58,      (yytype_int16 const   )147,      (yytype_int16 const   )49,      (yytype_int16 const   )53,
        (yytype_int16 const   )84,      (yytype_int16 const   )49,      (yytype_int16 const   )42,      (yytype_int16 const   )43,
        (yytype_int16 const   )88,      (yytype_int16 const   )86,      (yytype_int16 const   )215,      (yytype_int16 const   )50,
        (yytype_int16 const   )85,      (yytype_int16 const   )86,      (yytype_int16 const   )54,      (yytype_int16 const   )51,
        (yytype_int16 const   )89,      (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )92,
        (yytype_int16 const   )93,      (yytype_int16 const   )94,      (yytype_int16 const   )95,      (yytype_int16 const   )96,
        (yytype_int16 const   )97,      (yytype_int16 const   )98,      (yytype_int16 const   )99,      (yytype_int16 const   )100,
        (yytype_int16 const   )101,      (yytype_int16 const   )102,      (yytype_int16 const   )103,      (yytype_int16 const   )68,
        (yytype_int16 const   )112,      (yytype_int16 const   )113,      (yytype_int16 const   )114,      (yytype_int16 const   )68,
        (yytype_int16 const   )116,      (yytype_int16 const   )137,      (yytype_int16 const   )111,      (yytype_int16 const   )51,
        (yytype_int16 const   )117,      (yytype_int16 const   )84,      (yytype_int16 const   )115,      (yytype_int16 const   )123,
        (yytype_int16 const   )117,      (yytype_int16 const   )118,      (yytype_int16 const   )55,      (yytype_int16 const   )127,
        (yytype_int16 const   )128,      (yytype_int16 const   )195,      (yytype_int16 const   )196,      (yytype_int16 const   )49,
        (yytype_int16 const   )54,      (yytype_int16 const   )51,      (yytype_int16 const   )134,      (yytype_int16 const   )169,
        (yytype_int16 const   )58,      (yytype_int16 const   )137,      (yytype_int16 const   )123,      (yytype_int16 const   )139,
        (yytype_int16 const   )42,      (yytype_int16 const   )43,      (yytype_int16 const   )127,      (yytype_int16 const   )143,
        (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )27,      (yytype_int16 const   )147,
        (yytype_int16 const   )105,      (yytype_int16 const   )112,      (yytype_int16 const   )113,      (yytype_int16 const   )54,
        (yytype_int16 const   )105,      (yytype_int16 const   )146,      (yytype_int16 const   )104,      (yytype_int16 const   )112,
        (yytype_int16 const   )113,      (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )112,
        (yytype_int16 const   )113,      (yytype_int16 const   )43,      (yytype_int16 const   )51,      (yytype_int16 const   )229,
        (yytype_int16 const   )53,      (yytype_int16 const   )231,      (yytype_int16 const   )58,      (yytype_int16 const   )54,
        (yytype_int16 const   )202,      (yytype_int16 const   )56,      (yytype_int16 const   )49,      (yytype_int16 const   )168,
        (yytype_int16 const   )51,      (yytype_int16 const   )20,      (yytype_int16 const   )137,      (yytype_int16 const   )168,
        (yytype_int16 const   )114,      (yytype_int16 const   )54,      (yytype_int16 const   )116,      (yytype_int16 const   )172,
        (yytype_int16 const   )23,      (yytype_int16 const   )24,      (yytype_int16 const   )25,      (yytype_int16 const   )26,
        (yytype_int16 const   )27,      (yytype_int16 const   )59,      (yytype_int16 const   )60,      (yytype_int16 const   )144,
        (yytype_int16 const   )54,      (yytype_int16 const   )189,      (yytype_int16 const   )50,      (yytype_int16 const   )144,
        (yytype_int16 const   )49,      (yytype_int16 const   )227,      (yytype_int16 const   )52,      (yytype_int16 const   )195,
        (yytype_int16 const   )196,      (yytype_int16 const   )50,      (yytype_int16 const   )191,      (yytype_int16 const   )50,
        (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )52,
        (yytype_int16 const   )189,      (yytype_int16 const   )112,      (yytype_int16 const   )113,      (yytype_int16 const   )204,
        (yytype_int16 const   )242,      (yytype_int16 const   )43,      (yytype_int16 const   )52,      (yytype_int16 const   )204,
        (yytype_int16 const   )56,      (yytype_int16 const   )43,      (yytype_int16 const   )214,      (yytype_int16 const   )215,
        (yytype_int16 const   )56,      (yytype_int16 const   )50,      (yytype_int16 const   )218,      (yytype_int16 const   )50,
        (yytype_int16 const   )220,      (yytype_int16 const   )221,      (yytype_int16 const   )54,      (yytype_int16 const   )52,
        (yytype_int16 const   )52,      (yytype_int16 const   )40,      (yytype_int16 const   )50,      (yytype_int16 const   )42,
        (yytype_int16 const   )43,      (yytype_int16 const   )229,      (yytype_int16 const   )56,      (yytype_int16 const   )231,
        (yytype_int16 const   )50,      (yytype_int16 const   )218,      (yytype_int16 const   )40,      (yytype_int16 const   )220,
        (yytype_int16 const   )221,      (yytype_int16 const   )230,      (yytype_int16 const   )84,      (yytype_int16 const   )232,
        (yytype_int16 const   )55,      (yytype_int16 const   )111,      (yytype_int16 const   )26,      (yytype_int16 const   )139,
        (yytype_int16 const   )24,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )247,
        (yytype_int16 const   )75,      (yytype_int16 const   )249,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )3,      (yytype_int16 const   )-1,      (yytype_int16 const   )247,      (yytype_int16 const   )6,
        (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )9,      (yytype_int16 const   )10,
        (yytype_int16 const   )11,      (yytype_int16 const   )12,      (yytype_int16 const   )13,      (yytype_int16 const   )14,
        (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )-1,
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )23,      (yytype_int16 const   )24,      (yytype_int16 const   )23,      (yytype_int16 const   )24,
        (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )27,      (yytype_int16 const   )28,
        (yytype_int16 const   )29,      (yytype_int16 const   )30,      (yytype_int16 const   )31,      (yytype_int16 const   )32,
        (yytype_int16 const   )33,      (yytype_int16 const   )34,      (yytype_int16 const   )37,      (yytype_int16 const   )-1,
        (yytype_int16 const   )39,      (yytype_int16 const   )40,      (yytype_int16 const   )41,      (yytype_int16 const   )42,
        (yytype_int16 const   )43,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )46,
        (yytype_int16 const   )47,      (yytype_int16 const   )-1,      (yytype_int16 const   )49,      (yytype_int16 const   )-1,
        (yytype_int16 const   )51,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )55,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )59,      (yytype_int16 const   )60,      (yytype_int16 const   )3,      (yytype_int16 const   )-1,
        (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )7,      (yytype_int16 const   )8,
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )12,
        (yytype_int16 const   )-1,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16,
        (yytype_int16 const   )17,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )20,
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )23,      (yytype_int16 const   )24,
        (yytype_int16 const   )23,      (yytype_int16 const   )24,      (yytype_int16 const   )25,      (yytype_int16 const   )26,
        (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )29,      (yytype_int16 const   )30,
        (yytype_int16 const   )31,      (yytype_int16 const   )32,      (yytype_int16 const   )33,      (yytype_int16 const   )-1,
        (yytype_int16 const   )37,      (yytype_int16 const   )-1,      (yytype_int16 const   )39,      (yytype_int16 const   )40,
        (yytype_int16 const   )41,      (yytype_int16 const   )42,      (yytype_int16 const   )43,      (yytype_int16 const   )-1,
        (yytype_int16 const   )-1,      (yytype_int16 const   )46,      (yytype_int16 const   )47,      (yytype_int16 const   )-1,
        (yytype_int16 const   )49,      (yytype_int16 const   )-1,      (yytype_int16 const   )51,      (yytype_int16 const   )-1,
        (yytype_int16 const   )3,      (yytype_int16 const   )-1,      (yytype_int16 const   )55,      (yytype_int16 const   )6,
        (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )59,      (yytype_int16 const   )60,
        (yytype_int16 const   )-1,      (yytype_int16 const   )12,      (yytype_int16 const   )-1,      (yytype_int16 const   )14,
        (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )-1,
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )23,      (yytype_int16 const   )24,      (yytype_int16 const   )23,      (yytype_int16 const   )24,
        (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )27,      (yytype_int16 const   )28,
        (yytype_int16 const   )29,      (yytype_int16 const   )30,      (yytype_int16 const   )31,      (yytype_int16 const   )32,
        (yytype_int16 const   )33,      (yytype_int16 const   )-1,      (yytype_int16 const   )37,      (yytype_int16 const   )-1,
        (yytype_int16 const   )39,      (yytype_int16 const   )40,      (yytype_int16 const   )41,      (yytype_int16 const   )42,
        (yytype_int16 const   )43,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )46,
        (yytype_int16 const   )47,      (yytype_int16 const   )-1,      (yytype_int16 const   )49,      (yytype_int16 const   )3,
        (yytype_int16 const   )51,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )55,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )59,      (yytype_int16 const   )60,      (yytype_int16 const   )14,      (yytype_int16 const   )15,
        (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )23,
        (yytype_int16 const   )24,      (yytype_int16 const   )25,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )-1,      (yytype_int16 const   )37,      (yytype_int16 const   )-1,      (yytype_int16 const   )39,
        (yytype_int16 const   )40,      (yytype_int16 const   )41,      (yytype_int16 const   )42,      (yytype_int16 const   )43,
        (yytype_int16 const   )44,      (yytype_int16 const   )-1,      (yytype_int16 const   )46,      (yytype_int16 const   )47,
        (yytype_int16 const   )3,      (yytype_int16 const   )49,      (yytype_int16 const   )-1,      (yytype_int16 const   )51,
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )55,
        (yytype_int16 const   )56,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )14,
        (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )-1,
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )23,      (yytype_int16 const   )24,      (yytype_int16 const   )25,      (yytype_int16 const   )-1,
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )37,      (yytype_int16 const   )-1,
        (yytype_int16 const   )39,      (yytype_int16 const   )40,      (yytype_int16 const   )41,      (yytype_int16 const   )42,
        (yytype_int16 const   )43,      (yytype_int16 const   )44,      (yytype_int16 const   )3,      (yytype_int16 const   )46,
        (yytype_int16 const   )47,      (yytype_int16 const   )-1,      (yytype_int16 const   )49,      (yytype_int16 const   )-1,
        (yytype_int16 const   )51,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )55,      (yytype_int16 const   )14,      (yytype_int16 const   )15,      (yytype_int16 const   )16,
        (yytype_int16 const   )17,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )23,      (yytype_int16 const   )24,
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )37,      (yytype_int16 const   )-1,      (yytype_int16 const   )39,      (yytype_int16 const   )40,
        (yytype_int16 const   )41,      (yytype_int16 const   )42,      (yytype_int16 const   )43,      (yytype_int16 const   )3,
        (yytype_int16 const   )-1,      (yytype_int16 const   )46,      (yytype_int16 const   )47,      (yytype_int16 const   )-1,
        (yytype_int16 const   )49,      (yytype_int16 const   )-1,      (yytype_int16 const   )51,      (yytype_int16 const   )-1,
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )55,      (yytype_int16 const   )15,
        (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )20,      (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17,
        (yytype_int16 const   )-1,      (yytype_int16 const   )25,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )25,
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )40,      (yytype_int16 const   )-1,      (yytype_int16 const   )42,      (yytype_int16 const   )43,
        (yytype_int16 const   )44,      (yytype_int16 const   )-1,      (yytype_int16 const   )40,      (yytype_int16 const   )-1,
        (yytype_int16 const   )42,      (yytype_int16 const   )43,      (yytype_int16 const   )44,      (yytype_int16 const   )-1,
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )55,
        (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )-1,
        (yytype_int16 const   )-1,      (yytype_int16 const   )55,      (yytype_int16 const   )56,      (yytype_int16 const   )-1,
        (yytype_int16 const   )58,      (yytype_int16 const   )-1,      (yytype_int16 const   )25,      (yytype_int16 const   )-1,
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )4,
        (yytype_int16 const   )-1,      (yytype_int16 const   )40,      (yytype_int16 const   )-1,      (yytype_int16 const   )42,
        (yytype_int16 const   )43,      (yytype_int16 const   )44,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )55,      (yytype_int16 const   )56,      (yytype_int16 const   )23,      (yytype_int16 const   )24,
        (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )27,      (yytype_int16 const   )28,
        (yytype_int16 const   )29,      (yytype_int16 const   )30,      (yytype_int16 const   )31,      (yytype_int16 const   )32,
        (yytype_int16 const   )33,      (yytype_int16 const   )34,      (yytype_int16 const   )35,      (yytype_int16 const   )36,
        (yytype_int16 const   )37,      (yytype_int16 const   )23,      (yytype_int16 const   )24,      (yytype_int16 const   )25,
        (yytype_int16 const   )26,      (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )29,
        (yytype_int16 const   )30,      (yytype_int16 const   )31,      (yytype_int16 const   )32,      (yytype_int16 const   )33,
        (yytype_int16 const   )34,      (yytype_int16 const   )35,      (yytype_int16 const   )36,      (yytype_int16 const   )37,
        (yytype_int16 const   )23,      (yytype_int16 const   )24,      (yytype_int16 const   )25,      (yytype_int16 const   )26,
        (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )29,      (yytype_int16 const   )30,
        (yytype_int16 const   )31,      (yytype_int16 const   )32,      (yytype_int16 const   )33,      (yytype_int16 const   )34,
        (yytype_int16 const   )35,      (yytype_int16 const   )-1,      (yytype_int16 const   )52,      (yytype_int16 const   )23,
        (yytype_int16 const   )24,      (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )27,
        (yytype_int16 const   )28,      (yytype_int16 const   )29,      (yytype_int16 const   )30,      (yytype_int16 const   )31,
        (yytype_int16 const   )32,      (yytype_int16 const   )33,      (yytype_int16 const   )34,      (yytype_int16 const   )35,
        (yytype_int16 const   )36,      (yytype_int16 const   )37,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )-1,      (yytype_int16 const   )19,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,
        (yytype_int16 const   )52,      (yytype_int16 const   )23,      (yytype_int16 const   )24,      (yytype_int16 const   )25,
        (yytype_int16 const   )26,      (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )29,
        (yytype_int16 const   )30,      (yytype_int16 const   )31,      (yytype_int16 const   )32,      (yytype_int16 const   )33,
        (yytype_int16 const   )34,      (yytype_int16 const   )35,      (yytype_int16 const   )36,      (yytype_int16 const   )37,
        (yytype_int16 const   )20,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )23,
        (yytype_int16 const   )24,      (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )27,
        (yytype_int16 const   )28,      (yytype_int16 const   )29,      (yytype_int16 const   )30,      (yytype_int16 const   )31,
        (yytype_int16 const   )32,      (yytype_int16 const   )33,      (yytype_int16 const   )34,      (yytype_int16 const   )35,
        (yytype_int16 const   )36,      (yytype_int16 const   )37,      (yytype_int16 const   )20,      (yytype_int16 const   )-1,
        (yytype_int16 const   )-1,      (yytype_int16 const   )23,      (yytype_int16 const   )24,      (yytype_int16 const   )25,
        (yytype_int16 const   )26,      (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )29,
        (yytype_int16 const   )30,      (yytype_int16 const   )31,      (yytype_int16 const   )32,      (yytype_int16 const   )33,
        (yytype_int16 const   )34,      (yytype_int16 const   )35,      (yytype_int16 const   )36,      (yytype_int16 const   )37,
        (yytype_int16 const   )23,      (yytype_int16 const   )24,      (yytype_int16 const   )25,      (yytype_int16 const   )26,
        (yytype_int16 const   )27,      (yytype_int16 const   )28,      (yytype_int16 const   )29,      (yytype_int16 const   )30,
        (yytype_int16 const   )31,      (yytype_int16 const   )32,      (yytype_int16 const   )33,      (yytype_int16 const   )34,
        (yytype_int16 const   )35,      (yytype_int16 const   )36,      (yytype_int16 const   )37,      (yytype_int16 const   )23,
        (yytype_int16 const   )24,      (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )27,
        (yytype_int16 const   )28,      (yytype_int16 const   )29,      (yytype_int16 const   )30,      (yytype_int16 const   )31,
        (yytype_int16 const   )32,      (yytype_int16 const   )33,      (yytype_int16 const   )34,      (yytype_int16 const   )35,
        (yytype_int16 const   )-1,      (yytype_int16 const   )37};
static yytype_int8 const   yystos[254]  =
  {      (yytype_int8 const   )0,      (yytype_int8 const   )3,      (yytype_int8 const   )6,      (yytype_int8 const   )7,
        (yytype_int8 const   )8,      (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )11,
        (yytype_int8 const   )12,      (yytype_int8 const   )13,      (yytype_int8 const   )14,      (yytype_int8 const   )15,
        (yytype_int8 const   )16,      (yytype_int8 const   )17,      (yytype_int8 const   )23,      (yytype_int8 const   )24,
        (yytype_int8 const   )37,      (yytype_int8 const   )39,      (yytype_int8 const   )40,      (yytype_int8 const   )41,
        (yytype_int8 const   )42,      (yytype_int8 const   )43,      (yytype_int8 const   )46,      (yytype_int8 const   )47,
        (yytype_int8 const   )49,      (yytype_int8 const   )51,      (yytype_int8 const   )55,      (yytype_int8 const   )59,
        (yytype_int8 const   )60,      (yytype_int8 const   )62,      (yytype_int8 const   )63,      (yytype_int8 const   )64,
        (yytype_int8 const   )65,      (yytype_int8 const   )68,      (yytype_int8 const   )69,      (yytype_int8 const   )70,
        (yytype_int8 const   )71,      (yytype_int8 const   )77,      (yytype_int8 const   )85,      (yytype_int8 const   )89,
        (yytype_int8 const   )90,      (yytype_int8 const   )91,      (yytype_int8 const   )51,      (yytype_int8 const   )72,
        (yytype_int8 const   )25,      (yytype_int8 const   )44,      (yytype_int8 const   )69,      (yytype_int8 const   )71,
        (yytype_int8 const   )74,      (yytype_int8 const   )75,      (yytype_int8 const   )76,      (yytype_int8 const   )74,
        (yytype_int8 const   )43,      (yytype_int8 const   )43,      (yytype_int8 const   )43,      (yytype_int8 const   )42,
        (yytype_int8 const   )43,      (yytype_int8 const   )70,      (yytype_int8 const   )70,      (yytype_int8 const   )43,
        (yytype_int8 const   )71,      (yytype_int8 const   )71,      (yytype_int8 const   )70,      (yytype_int8 const   )71,
        (yytype_int8 const   )71,      (yytype_int8 const   )5,      (yytype_int8 const   )20,      (yytype_int8 const   )66,
        (yytype_int8 const   )67,      (yytype_int8 const   )68,      (yytype_int8 const   )69,      (yytype_int8 const   )84,
        (yytype_int8 const   )86,      (yytype_int8 const   )88,      (yytype_int8 const   )89,      (yytype_int8 const   )90,
        (yytype_int8 const   )69,      (yytype_int8 const   )71,      (yytype_int8 const   )87,      (yytype_int8 const   )88,
        (yytype_int8 const   )56,      (yytype_int8 const   )76,      (yytype_int8 const   )0,      (yytype_int8 const   )89,
        (yytype_int8 const   )90,      (yytype_int8 const   )53,      (yytype_int8 const   )51,      (yytype_int8 const   )85,
        (yytype_int8 const   )19,      (yytype_int8 const   )23,      (yytype_int8 const   )24,      (yytype_int8 const   )25,
        (yytype_int8 const   )26,      (yytype_int8 const   )27,      (yytype_int8 const   )28,      (yytype_int8 const   )29,
        (yytype_int8 const   )30,      (yytype_int8 const   )31,      (yytype_int8 const   )32,      (yytype_int8 const   )33,
        (yytype_int8 const   )34,      (yytype_int8 const   )35,      (yytype_int8 const   )36,      (yytype_int8 const   )37,
        (yytype_int8 const   )57,      (yytype_int8 const   )64,      (yytype_int8 const   )91,      (yytype_int8 const   )71,
        (yytype_int8 const   )71,      (yytype_int8 const   )71,      (yytype_int8 const   )71,      (yytype_int8 const   )54,
        (yytype_int8 const   )49,      (yytype_int8 const   )49,      (yytype_int8 const   )51,      (yytype_int8 const   )53,
        (yytype_int8 const   )51,      (yytype_int8 const   )55,      (yytype_int8 const   )3,      (yytype_int8 const   )15,
        (yytype_int8 const   )16,      (yytype_int8 const   )17,      (yytype_int8 const   )20,      (yytype_int8 const   )25,
        (yytype_int8 const   )40,      (yytype_int8 const   )42,      (yytype_int8 const   )43,      (yytype_int8 const   )44,
        (yytype_int8 const   )55,      (yytype_int8 const   )69,      (yytype_int8 const   )79,      (yytype_int8 const   )80,
        (yytype_int8 const   )81,      (yytype_int8 const   )82,      (yytype_int8 const   )83,      (yytype_int8 const   )50,
        (yytype_int8 const   )89,      (yytype_int8 const   )90,      (yytype_int8 const   )4,      (yytype_int8 const   )5,
        (yytype_int8 const   )50,      (yytype_int8 const   )66,      (yytype_int8 const   )20,      (yytype_int8 const   )54,
        (yytype_int8 const   )67,      (yytype_int8 const   )52,      (yytype_int8 const   )21,      (yytype_int8 const   )22,
        (yytype_int8 const   )56,      (yytype_int8 const   )65,      (yytype_int8 const   )71,      (yytype_int8 const   )74,
        (yytype_int8 const   )69,      (yytype_int8 const   )71,      (yytype_int8 const   )71,      (yytype_int8 const   )71,
        (yytype_int8 const   )71,      (yytype_int8 const   )71,      (yytype_int8 const   )71,      (yytype_int8 const   )71,
        (yytype_int8 const   )71,      (yytype_int8 const   )71,      (yytype_int8 const   )71,      (yytype_int8 const   )71,
        (yytype_int8 const   )71,      (yytype_int8 const   )71,      (yytype_int8 const   )71,      (yytype_int8 const   )71,
        (yytype_int8 const   )51,      (yytype_int8 const   )70,      (yytype_int8 const   )89,      (yytype_int8 const   )52,
        (yytype_int8 const   )4,      (yytype_int8 const   )73,      (yytype_int8 const   )75,      (yytype_int8 const   )63,
        (yytype_int8 const   )63,      (yytype_int8 const   )69,      (yytype_int8 const   )87,      (yytype_int8 const   )71,
        (yytype_int8 const   )87,      (yytype_int8 const   )74,      (yytype_int8 const   )71,      (yytype_int8 const   )79,
        (yytype_int8 const   )79,      (yytype_int8 const   )56,      (yytype_int8 const   )58,      (yytype_int8 const   )82,
        (yytype_int8 const   )58,      (yytype_int8 const   )54,      (yytype_int8 const   )54,      (yytype_int8 const   )3,
        (yytype_int8 const   )20,      (yytype_int8 const   )66,      (yytype_int8 const   )68,      (yytype_int8 const   )20,
        (yytype_int8 const   )83,      (yytype_int8 const   )50,      (yytype_int8 const   )69,      (yytype_int8 const   )89,
        (yytype_int8 const   )71,      (yytype_int8 const   )66,      (yytype_int8 const   )52,      (yytype_int8 const   )74,
        (yytype_int8 const   )51,      (yytype_int8 const   )78,      (yytype_int8 const   )85,      (yytype_int8 const   )71,
        (yytype_int8 const   )50,      (yytype_int8 const   )50,      (yytype_int8 const   )52,      (yytype_int8 const   )52,
        (yytype_int8 const   )56,      (yytype_int8 const   )20,      (yytype_int8 const   )54,      (yytype_int8 const   )43,
        (yytype_int8 const   )56,      (yytype_int8 const   )43,      (yytype_int8 const   )25,      (yytype_int8 const   )79,
        (yytype_int8 const   )25,      (yytype_int8 const   )44,      (yytype_int8 const   )71,      (yytype_int8 const   )66,
        (yytype_int8 const   )66,      (yytype_int8 const   )50,      (yytype_int8 const   )78,      (yytype_int8 const   )52,
        (yytype_int8 const   )74,      (yytype_int8 const   )49,      (yytype_int8 const   )53,      (yytype_int8 const   )49,
        (yytype_int8 const   )53,      (yytype_int8 const   )80,      (yytype_int8 const   )56,      (yytype_int8 const   )82,
        (yytype_int8 const   )79,      (yytype_int8 const   )79,      (yytype_int8 const   )79,      (yytype_int8 const   )20,
        (yytype_int8 const   )50,      (yytype_int8 const   )78,      (yytype_int8 const   )52,      (yytype_int8 const   )66,
        (yytype_int8 const   )71,      (yytype_int8 const   )66,      (yytype_int8 const   )71,      (yytype_int8 const   )54,
        (yytype_int8 const   )56,      (yytype_int8 const   )54,      (yytype_int8 const   )78,      (yytype_int8 const   )50,
        (yytype_int8 const   )50,      (yytype_int8 const   )80};
static yytype_int8 const   yyr1[129]  =
  {      (yytype_int8 const   )0,      (yytype_int8 const   )61,      (yytype_int8 const   )62,      (yytype_int8 const   )63,
        (yytype_int8 const   )63,      (yytype_int8 const   )63,      (yytype_int8 const   )64,      (yytype_int8 const   )64,
        (yytype_int8 const   )65,      (yytype_int8 const   )65,      (yytype_int8 const   )65,      (yytype_int8 const   )65,
        (yytype_int8 const   )65,      (yytype_int8 const   )65,      (yytype_int8 const   )66,      (yytype_int8 const   )66,
        (yytype_int8 const   )66,      (yytype_int8 const   )67,      (yytype_int8 const   )67,      (yytype_int8 const   )68,
        (yytype_int8 const   )68,      (yytype_int8 const   )68,      (yytype_int8 const   )68,      (yytype_int8 const   )68,
        (yytype_int8 const   )68,      (yytype_int8 const   )68,      (yytype_int8 const   )68,      (yytype_int8 const   )68,
        (yytype_int8 const   )69,      (yytype_int8 const   )70,      (yytype_int8 const   )70,      (yytype_int8 const   )71,
        (yytype_int8 const   )71,      (yytype_int8 const   )71,      (yytype_int8 const   )71,      (yytype_int8 const   )71,
        (yytype_int8 const   )71,      (yytype_int8 const   )71,      (yytype_int8 const   )71,      (yytype_int8 const   )71,
        (yytype_int8 const   )71,      (yytype_int8 const   )71,      (yytype_int8 const   )71,      (yytype_int8 const   )71,
        (yytype_int8 const   )71,      (yytype_int8 const   )71,      (yytype_int8 const   )71,      (yytype_int8 const   )71,
        (yytype_int8 const   )71,      (yytype_int8 const   )71,      (yytype_int8 const   )71,      (yytype_int8 const   )71,
        (yytype_int8 const   )71,      (yytype_int8 const   )71,      (yytype_int8 const   )72,      (yytype_int8 const   )73,
        (yytype_int8 const   )73,      (yytype_int8 const   )74,      (yytype_int8 const   )74,      (yytype_int8 const   )75,
        (yytype_int8 const   )75,      (yytype_int8 const   )75,      (yytype_int8 const   )76,      (yytype_int8 const   )76,
        (yytype_int8 const   )77,      (yytype_int8 const   )77,      (yytype_int8 const   )77,      (yytype_int8 const   )77,
        (yytype_int8 const   )77,      (yytype_int8 const   )77,      (yytype_int8 const   )77,      (yytype_int8 const   )77,
        (yytype_int8 const   )77,      (yytype_int8 const   )77,      (yytype_int8 const   )77,      (yytype_int8 const   )77,
        (yytype_int8 const   )77,      (yytype_int8 const   )77,      (yytype_int8 const   )77,      (yytype_int8 const   )77,
        (yytype_int8 const   )77,      (yytype_int8 const   )77,      (yytype_int8 const   )77,      (yytype_int8 const   )78,
        (yytype_int8 const   )78,      (yytype_int8 const   )79,      (yytype_int8 const   )79,      (yytype_int8 const   )79,
        (yytype_int8 const   )79,      (yytype_int8 const   )79,      (yytype_int8 const   )79,      (yytype_int8 const   )79,
        (yytype_int8 const   )79,      (yytype_int8 const   )79,      (yytype_int8 const   )79,      (yytype_int8 const   )79,
        (yytype_int8 const   )80,      (yytype_int8 const   )80,      (yytype_int8 const   )81,      (yytype_int8 const   )81,
        (yytype_int8 const   )82,      (yytype_int8 const   )82,      (yytype_int8 const   )82,      (yytype_int8 const   )82,
        (yytype_int8 const   )82,      (yytype_int8 const   )82,      (yytype_int8 const   )82,      (yytype_int8 const   )83,
        (yytype_int8 const   )83,      (yytype_int8 const   )83,      (yytype_int8 const   )83,      (yytype_int8 const   )84,
        (yytype_int8 const   )84,      (yytype_int8 const   )85,      (yytype_int8 const   )85,      (yytype_int8 const   )85,
        (yytype_int8 const   )85,      (yytype_int8 const   )86,      (yytype_int8 const   )86,      (yytype_int8 const   )87,
        (yytype_int8 const   )87,      (yytype_int8 const   )88,      (yytype_int8 const   )88,      (yytype_int8 const   )89,
        (yytype_int8 const   )89,      (yytype_int8 const   )90,      (yytype_int8 const   )90,      (yytype_int8 const   )91,
        (yytype_int8 const   )91};
static yytype_int8 const   yyr2[129]  =
  {      (yytype_int8 const   )0,      (yytype_int8 const   )2,      (yytype_int8 const   )1,      (yytype_int8 const   )2,
        (yytype_int8 const   )3,      (yytype_int8 const   )1,      (yytype_int8 const   )1,      (yytype_int8 const   )3,
        (yytype_int8 const   )5,      (yytype_int8 const   )5,      (yytype_int8 const   )2,      (yytype_int8 const   )8,
        (yytype_int8 const   )7,      (yytype_int8 const   )1,      (yytype_int8 const   )2,      (yytype_int8 const   )3,
        (yytype_int8 const   )1,      (yytype_int8 const   )1,      (yytype_int8 const   )3,      (yytype_int8 const   )3,
        (yytype_int8 const   )8,      (yytype_int8 const   )7,      (yytype_int8 const   )4,      (yytype_int8 const   )3,
        (yytype_int8 const   )1,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )1,
        (yytype_int8 const   )1,      (yytype_int8 const   )1,      (yytype_int8 const   )1,      (yytype_int8 const   )3,
        (yytype_int8 const   )3,      (yytype_int8 const   )3,      (yytype_int8 const   )3,      (yytype_int8 const   )3,
        (yytype_int8 const   )3,      (yytype_int8 const   )3,      (yytype_int8 const   )3,      (yytype_int8 const   )3,
        (yytype_int8 const   )3,      (yytype_int8 const   )3,      (yytype_int8 const   )3,      (yytype_int8 const   )3,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )2,
        (yytype_int8 const   )3,      (yytype_int8 const   )3,      (yytype_int8 const   )4,      (yytype_int8 const   )5,
        (yytype_int8 const   )4,      (yytype_int8 const   )1,      (yytype_int8 const   )3,      (yytype_int8 const   )0,
        (yytype_int8 const   )2,      (yytype_int8 const   )0,      (yytype_int8 const   )1,      (yytype_int8 const   )1,
        (yytype_int8 const   )2,      (yytype_int8 const   )2,      (yytype_int8 const   )1,      (yytype_int8 const   )3,
        (yytype_int8 const   )1,      (yytype_int8 const   )1,      (yytype_int8 const   )1,      (yytype_int8 const   )1,
        (yytype_int8 const   )1,      (yytype_int8 const   )3,      (yytype_int8 const   )3,      (yytype_int8 const   )2,
        (yytype_int8 const   )1,      (yytype_int8 const   )1,      (yytype_int8 const   )1,      (yytype_int8 const   )1,
        (yytype_int8 const   )5,      (yytype_int8 const   )2,      (yytype_int8 const   )5,      (yytype_int8 const   )7,
        (yytype_int8 const   )4,      (yytype_int8 const   )6,      (yytype_int8 const   )2,      (yytype_int8 const   )0,
        (yytype_int8 const   )1,      (yytype_int8 const   )1,      (yytype_int8 const   )1,      (yytype_int8 const   )1,
        (yytype_int8 const   )1,      (yytype_int8 const   )1,      (yytype_int8 const   )1,      (yytype_int8 const   )2,
        (yytype_int8 const   )4,      (yytype_int8 const   )3,      (yytype_int8 const   )5,      (yytype_int8 const   )3,
        (yytype_int8 const   )1,      (yytype_int8 const   )3,      (yytype_int8 const   )2,      (yytype_int8 const   )4,
        (yytype_int8 const   )1,      (yytype_int8 const   )4,      (yytype_int8 const   )6,      (yytype_int8 const   )2,
        (yytype_int8 const   )4,      (yytype_int8 const   )1,      (yytype_int8 const   )4,      (yytype_int8 const   )1,
        (yytype_int8 const   )3,      (yytype_int8 const   )2,      (yytype_int8 const   )4,      (yytype_int8 const   )3,
        (yytype_int8 const   )4,      (yytype_int8 const   )3,      (yytype_int8 const   )4,      (yytype_int8 const   )3,
        (yytype_int8 const   )6,      (yytype_int8 const   )1,      (yytype_int8 const   )2,      (yytype_int8 const   )0,
        (yytype_int8 const   )1,      (yytype_int8 const   )1,      (yytype_int8 const   )3,      (yytype_int8 const   )0,
        (yytype_int8 const   )1,      (yytype_int8 const   )1,      (yytype_int8 const   )2,      (yytype_int8 const   )1,
        (yytype_int8 const   )1};
static void yy_symbol_value_print(FILE *yyo , int yytype , YYSTYPE const   * const  yyvaluep ,
                                  parser_state *p )
{
  FILE *yyoutput ;

  {
  yyoutput = yyo;
  if (! yyvaluep) {
    return;
  }
  return;
}
}
static void yy_symbol_print(FILE *yyo , int yytype , YYSTYPE const   * const  yyvaluep ,
                            parser_state *p )
{
  char const   *tmp ;

  {
  if (yytype < 61) {
    tmp = "token";
  } else {
    tmp = "nterm";
  }
  fprintf((FILE * __restrict  )yyo, (char const   * __restrict  )"%s %s (", tmp, yytname[yytype]);
  yy_symbol_value_print(yyo, yytype, yyvaluep, p);
  fprintf((FILE * __restrict  )yyo, (char const   * __restrict  )")");
  return;
}
}
static void yy_stack_print(yy_state_t *yybottom , yy_state_t *yytop )
{
  int yybot ;

  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Stack now");
  while ((unsigned long )yybottom <= (unsigned long )yytop) {
    yybot = (int )*yybottom;
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" %d", yybot);
    yybottom ++;
  }
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  return;
}
}
static void yy_reduce_print(yy_state_t *yyssp , YYSTYPE *yyvsp , int yyrule , parser_state *p )
{
  int yylno ;
  int yynrhs ;
  int yyi ;

  {
  yylno = (int )yyrline[yyrule];
  yynrhs = (int )yyr2[yyrule];
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Reducing stack by rule %d (line %d):\n",
          yyrule - 1, yylno);
  yyi = 0;
  while (yyi < yynrhs) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"   $%d = ",
            yyi + 1);
    yy_symbol_print(stderr, (int )yystos[*(yyssp + ((yyi + 1) - yynrhs))], (YYSTYPE const   * const  )(yyvsp + ((yyi + 1) - yynrhs)),
                    p);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
    yyi ++;
  }
  return;
}
}
static char *yystpcpy(char *yydest , char const   *yysrc )
{
  char *yyd ;
  char const   *yys ;
  char *tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;

  {
  yyd = yydest;
  yys = yysrc;
  while (1) {
    tmp = yyd;
    yyd ++;
    tmp___1 = yys;
    yys ++;
    tmp___0 = (char )*tmp___1;
    *tmp = tmp___0;
    if (! ((int )tmp___0 != 0)) {
      break;
    }
    continue;
  }
  return (yyd - 1);
}
}
static long yytnamerr(char *yyres , char const   *yystr )
{
  long yyn ;
  char const   *yyp ;
  char *tmp ;
  size_t tmp___0 ;

  {
  if ((int const   )*yystr == 34) {
    yyn = 0L;
    yyp = yystr;
    while (1) {
      yyp ++;
      switch ((int const   )*yyp) {
      case 44:
      case 39:
      goto do_not_strip_quotes;
      case 92:
      yyp ++;
      if ((int const   )*yyp != 92) {
        goto do_not_strip_quotes;
      }
      default:
      if (yyres) {
        *(yyres + yyn) = (char )*yyp;
      }
      yyn ++;
      break;
      case 34:
      if (yyres) {
        *(yyres + yyn) = (char )'\000';
      }
      return (yyn);
      }
    }
    do_not_strip_quotes: ;
  }
  if (yyres) {
    tmp = yystpcpy(yyres, yystr);
    return (tmp - yyres);
  } else {
    tmp___0 = strlen(yystr);
    return ((long )tmp___0);
  }
}
}
static int yysyntax_error(long *yymsg_alloc , char **yymsg , yy_state_t *yyssp , int yytoken )
{
  char const   *yyformat ;
  char const   *yyarg[5] ;
  int yycount ;
  long yysize ;
  int yyn ;
  long yysize0 ;
  long tmp ;
  int tmp___0 ;
  int yyxbegin ;
  int tmp___1 ;
  int yychecklim ;
  int yyxend ;
  int tmp___2 ;
  int yyx ;
  int tmp___3 ;
  long yysize1 ;
  long tmp___4 ;
  long yysize1___0 ;
  size_t tmp___5 ;
  char *yyp ;
  int yyi ;
  int tmp___6 ;
  long tmp___7 ;
  char tmp___8 ;

  {
  yyformat = (char const   *)((void *)0);
  yycount = 0;
  yysize = 0L;
  if (yytoken != -2) {
    yyn = (int )yypact[*yyssp];
    tmp = yytnamerr((char *)((void *)0), (char const   *)yytname[yytoken]);
    yysize0 = tmp;
    yysize = yysize0;
    tmp___0 = yycount;
    yycount ++;
    yyarg[tmp___0] = (char const   *)yytname[yytoken];
    if (! (yyn == -211)) {
      if (yyn < 0) {
        tmp___1 = - yyn;
      } else {
        tmp___1 = 0;
      }
      yyxbegin = tmp___1;
      yychecklim = (793 - yyn) + 1;
      if (yychecklim < 61) {
        tmp___2 = yychecklim;
      } else {
        tmp___2 = 61;
      }
      yyxend = tmp___2;
      yyx = yyxbegin;
      while (yyx < yyxend) {
        if ((int const   )yycheck[yyx + yyn] == (int const   )yyx) {
          if (yyx != 1) {
            if (! ((int const   )yytable[yyx + yyn] == -122)) {
              if (yycount == 5) {
                yycount = 1;
                yysize = yysize0;
                break;
              }
              tmp___3 = yycount;
              yycount ++;
              yyarg[tmp___3] = (char const   *)yytname[yyx];
              tmp___4 = yytnamerr((char *)((void *)0), (char const   *)yytname[yyx]);
              yysize1 = yysize + tmp___4;
              if (yysize <= yysize1) {
                if (yysize1 <= 9223372036854775807L) {
                  yysize = yysize1;
                } else {
                  return (2);
                }
              } else {
                return (2);
              }
            }
          }
        }
        yyx ++;
      }
    }
  }
  switch (yycount) {
  default:
  yyformat = "syntax error";
  break;
  case 1:
  yyformat = "syntax error, unexpected %s";
  break;
  case 2:
  yyformat = "syntax error, unexpected %s, expecting %s";
  break;
  case 3:
  yyformat = "syntax error, unexpected %s, expecting %s or %s";
  break;
  case 4:
  yyformat = "syntax error, unexpected %s, expecting %s or %s or %s";
  break;
  case 5:
  yyformat = "syntax error, unexpected %s, expecting %s or %s or %s or %s";
  break;
  }
  tmp___5 = strlen(yyformat);
  yysize1___0 = (yysize + ((long )tmp___5 - (long )(2 * yycount))) + 1L;
  if (yysize <= yysize1___0) {
    if (yysize1___0 <= 9223372036854775807L) {
      yysize = yysize1___0;
    } else {
      return (2);
    }
  } else {
    return (2);
  }
  if (*yymsg_alloc < yysize) {
    *yymsg_alloc = 2L * yysize;
    if (yysize <= *yymsg_alloc) {
      if (! (*yymsg_alloc <= 9223372036854775807L)) {
        *yymsg_alloc = 9223372036854775807L;
      }
    } else {
      *yymsg_alloc = 9223372036854775807L;
    }
    return (1);
  }
  yyp = *yymsg;
  yyi = 0;
  while (1) {
    tmp___8 = (char )*yyformat;
    *yyp = tmp___8;
    if (! ((int )tmp___8 != 0)) {
      break;
    }
    if ((int )*yyp == 37) {
      if ((int const   )*(yyformat + 1) == 115) {
        if (yyi < yycount) {
          tmp___6 = yyi;
          yyi ++;
          tmp___7 = yytnamerr(yyp, yyarg[tmp___6]);
          yyp += tmp___7;
          yyformat += 2;
        } else {
          yyp ++;
          yyformat ++;
        }
      } else {
        yyp ++;
        yyformat ++;
      }
    } else {
      yyp ++;
      yyformat ++;
    }
  }
  return (0);
}
}
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE *yyvaluep , parser_state *p )
{


  {
  if (! yymsg) {
    yymsg = "Deleting";
  }
  while (1) {
    if (yydebug) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s ", yymsg);
      yy_symbol_print(stderr, yytype, (YYSTYPE const   * const  )yyvaluep, p);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
    }
    break;
  }
  return;
}
}
static YYSTYPE yyval_default  ;
int yyparse(parser_state *p )
{
  int yychar ;
  YYSTYPE yylval ;
  int yynerrs ;
  yy_state_fast_t yystate ;
  int yyerrstatus ;
  yy_state_t yyssa[200] ;
  yy_state_t *yyss ;
  yy_state_t *yyssp ;
  YYSTYPE yyvsa[200] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  long yystacksize ;
  int yyn ;
  int yyresult ;
  int yytoken ;
  YYSTYPE yyval ;
  char yymsgbuf[128] ;
  char *yymsg ;
  long yymsg_alloc ;
  int yylen ;
  long yysize ;
  yy_state_t *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  long yynewbytes ;
  long yynewbytes___0 ;
  node *tmp___0 ;
  node *tmp___1 ;
  node *tmp___2 ;
  node *tmp___3 ;
  node *tmp___4 ;
  node_lambda *lambda ;
  node *tmp___5 ;
  node *tmp___6 ;
  node *tmp___7 ;
  node *tmp___8 ;
  node *tmp___9 ;
  node *tmp___10 ;
  node *e ;
  node *tmp___11 ;
  node *tmp___12 ;
  int yylhs ;
  int yyi ;
  int tmp___13 ;
  char const   *yymsgp ;
  int yysyntax_error_status ;
  void *tmp___14 ;

  {
  yylval = yyval_default;
  yytoken = 0;
  yymsg = yymsgbuf;
  yymsg_alloc = (long )sizeof(yymsgbuf);
  yylen = 0;
  yyss = yyssa;
  yyssp = yyss;
  yyvs = yyvsa;
  yyvsp = yyvs;
  yystacksize = 200L;
  while (1) {
    if (yydebug) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Starting parse\n");
    }
    break;
  }
  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = -2;
  goto yysetstate;
  yynewstate:
  yyssp ++;
  yysetstate:
  while (1) {
    if (yydebug) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Entering state %d\n",
              yystate);
    }
    break;
  }
  *yyssp = (yy_state_t )yystate;
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
    yysize = (yyssp - yyss) + 1L;
    if (10000L <= yystacksize) {
      goto yyexhaustedlab;
    }
    yystacksize *= 2L;
    if (10000L < yystacksize) {
      yystacksize = 10000L;
    }
    yyss1 = yyss;
    tmp = malloc((unsigned long )(yystacksize * ((long )sizeof(yy_state_t ) + (long )sizeof(YYSTYPE )) + ((long )sizeof(union yyalloc ) - 1L)));
    yyptr = (union yyalloc *)tmp;
    if (! yyptr) {
      goto yyexhaustedlab;
    }
    while (1) {
      __builtin_memcpy((void *)(& yyptr->yyss_alloc), (void const   *)yyss, (unsigned long )yysize * sizeof(*yyss));
      yyss = & yyptr->yyss_alloc;
      yynewbytes = yystacksize * (long )sizeof(*yyss) + ((long )sizeof(union yyalloc ) - 1L);
      yyptr += yynewbytes / (long )sizeof(*yyptr);
      break;
    }
    while (1) {
      __builtin_memcpy((void *)(& yyptr->yyvs_alloc), (void const   *)yyvs, (unsigned long )yysize * sizeof(*yyvs));
      yyvs = & yyptr->yyvs_alloc;
      yynewbytes___0 = yystacksize * (long )sizeof(*yyvs) + ((long )sizeof(union yyalloc ) - 1L);
      yyptr += yynewbytes___0 / (long )sizeof(*yyptr);
      break;
    }
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      free((void *)yyss1);
    }
    yyssp = (yyss + yysize) - 1;
    yyvsp = (yyvs + yysize) - 1;
    while (1) {
      if (yydebug) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Stack size increased to %ld\n",
                yystacksize);
      }
      break;
    }
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
      goto yyabortlab;
    }
  }
  if (yystate == 82) {
    goto yyacceptlab;
  }
  goto yybackup;
  yybackup:
  yyn = (int )yypact[yystate];
  if (yyn == -211) {
    goto yydefault;
  }
  if (yychar == -2) {
    while (1) {
      if (yydebug) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Reading a token: ");
      }
      break;
    }
    yychar = yylex(& yylval, p);
  }
  if (yychar <= 0) {
    yytoken = 0;
    yychar = yytoken;
    while (1) {
      if (yydebug) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Now at end of input.\n");
      }
      break;
    }
  } else {
    if (0 <= yychar) {
      if (yychar <= 301) {
        yytoken = (int )yytranslate[yychar];
      } else {
        yytoken = 2;
      }
    } else {
      yytoken = 2;
    }
    while (1) {
      if (yydebug) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s ", "Next token is");
        yy_symbol_print(stderr, yytoken, (YYSTYPE const   * const  )(& yylval), p);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
      }
      break;
    }
  }
  yyn += yytoken;
  if (yyn < 0) {
    goto yydefault;
  } else
  if (793 < yyn) {
    goto yydefault;
  } else
  if ((int const   )yycheck[yyn] != (int const   )yytoken) {
    goto yydefault;
  }
  yyn = (int )yytable[yyn];
  if (yyn <= 0) {
    if (yyn == -122) {
      goto yyerrlab;
    }
    yyn = - yyn;
    goto yyreduce;
  }
  if (yyerrstatus) {
    yyerrstatus --;
  }
  while (1) {
    if (yydebug) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s ", "Shifting");
      yy_symbol_print(stderr, yytoken, (YYSTYPE const   * const  )(& yylval), p);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
    }
    break;
  }
  yystate = yyn;
  yyvsp ++;
  *yyvsp = yylval;
  yychar = -2;
  goto yynewstate;
  yydefault:
  yyn = (int )yydefact[yystate];
  if (yyn == 0) {
    goto yyerrlab;
  }
  goto yyreduce;
  yyreduce:
  yylen = (int )yyr2[yyn];
  yyval = *(yyvsp + (1 - yylen));
  while (1) {
    if (yydebug) {
      yy_reduce_print(yyssp, yyvsp, yyn, p);
    }
    break;
  }
  switch (yyn) {
  case 2:
  p->lval = (void *)(yyvsp + 0)->nd;
  break;
  case 3:
  yyval.nd = (yyvsp + -1)->nd;
  break;
  case 4:
  yyval.nd = (yyvsp + -1)->nd;
  break;
  case 5:
  yyval.nd = (node *)((void *)0);
  break;
  case 6:
  yyval.nd = node_nodes_new();
  node_lineinfo(p, yyval.nd);
  if ((yyvsp + 0)->nd) {
    node_nodes_add(yyval.nd, (yyvsp + 0)->nd);
    node_lineinfo(p, (yyvsp + 0)->nd);
  }
  break;
  case 7:
  yyval.nd = (yyvsp + -2)->nd;
  if ((yyvsp + 0)->nd) {
    if ((yyvsp + -2)->nd) {
      node_nodes_add(yyval.nd, (yyvsp + 0)->nd);
    } else {
      (yyvsp + -2)->nd = (yyvsp + 0)->nd;
    }
    node_lineinfo(p, (yyvsp + 0)->nd);
  }
  break;
  case 8:
  yyval.nd = node_ns_new((yyvsp + -3)->id, (yyvsp + -1)->nd);
  break;
  case 9:
  yyval.nd = node_ns_new((yyvsp + -3)->id, (yyvsp + -1)->nd);
  break;
  case 10:
  yyval.nd = node_import_new((yyvsp + 0)->id);
  break;
  case 11:
  tmp___0 = node_method_new((yyvsp + -4)->nd, (yyvsp + -1)->nd);
  yyval.nd = node_let_new((yyvsp + -6)->id, tmp___0);
  break;
  case 12:
  tmp___1 = node_method_new((yyvsp + -3)->nd, (yyvsp + 0)->nd);
  yyval.nd = node_let_new((yyvsp + -5)->id, tmp___1);
  break;
  case 14:
  yyval.nd = (yyvsp + -1)->nd;
  break;
  case 15:
  yyval.nd = (yyvsp + -1)->nd;
  break;
  case 16:
  yyval.nd = (node *)((void *)0);
  break;
  case 17:
  yyval.nd = node_nodes_new();
  node_lineinfo(p, yyval.nd);
  if ((yyvsp + 0)->nd) {
    node_nodes_add(yyval.nd, (yyvsp + 0)->nd);
    node_lineinfo(p, (yyvsp + 0)->nd);
  }
  break;
  case 18:
  yyval.nd = (yyvsp + -2)->nd;
  if ((yyvsp + 0)->nd) {
    if ((yyvsp + -2)->nd) {
      node_nodes_add(yyval.nd, (yyvsp + 0)->nd);
    } else {
      (yyvsp + -2)->nd = (yyvsp + 0)->nd;
    }
    node_lineinfo(p, (yyvsp + 0)->nd);
  }
  break;
  case 19:
  yyval.nd = node_let_new((yyvsp + -2)->id, (yyvsp + 0)->nd);
  break;
  case 20:
  tmp___2 = node_lambda_new((yyvsp + -4)->nd, (yyvsp + -1)->nd);
  yyval.nd = node_let_new((yyvsp + -6)->id, tmp___2);
  break;
  case 21:
  tmp___3 = node_lambda_new((yyvsp + -3)->nd, (yyvsp + 0)->nd);
  yyval.nd = node_let_new((yyvsp + -5)->id, tmp___3);
  break;
  case 22:
  tmp___4 = node_lambda_new((node *)((void *)0), (yyvsp + 0)->nd);
  yyval.nd = node_let_new((yyvsp + -2)->id, tmp___4);
  break;
  case 23:
  yyval.nd = node_let_new((yyvsp + 0)->id, (yyvsp + -2)->nd);
  break;
  case 24:
  yyval.nd = node_skip_new();
  break;
  case 25:
  yyval.nd = node_emit_new((yyvsp + 0)->nd);
  break;
  case 26:
  yyval.nd = node_return_new((yyvsp + 0)->nd);
  break;
  case 30:
  yyval.id = ((node_str *)(yyvsp + 0)->nd)->value;
  break;
  case 31:
  yyval.nd = node_op_new("+", (yyvsp + -2)->nd, (yyvsp + 0)->nd);
  break;
  case 32:
  yyval.nd = node_op_new("-", (yyvsp + -2)->nd, (yyvsp + 0)->nd);
  break;
  case 33:
  yyval.nd = node_op_new("*", (yyvsp + -2)->nd, (yyvsp + 0)->nd);
  break;
  case 34:
  yyval.nd = node_op_new("/", (yyvsp + -2)->nd, (yyvsp + 0)->nd);
  break;
  case 35:
  yyval.nd = node_op_new("%", (yyvsp + -2)->nd, (yyvsp + 0)->nd);
  break;
  case 36:
  yyval.nd = node_op_new("|", (yyvsp + -2)->nd, (yyvsp + 0)->nd);
  break;
  case 37:
  yyval.nd = node_op_new("&", (yyvsp + -2)->nd, (yyvsp + 0)->nd);
  break;
  case 38:
  yyval.nd = node_op_new(">", (yyvsp + -2)->nd, (yyvsp + 0)->nd);
  break;
  case 39:
  yyval.nd = node_op_new(">=", (yyvsp + -2)->nd, (yyvsp + 0)->nd);
  break;
  case 40:
  yyval.nd = node_op_new("<", (yyvsp + -2)->nd, (yyvsp + 0)->nd);
  break;
  case 41:
  yyval.nd = node_op_new("<=", (yyvsp + -2)->nd, (yyvsp + 0)->nd);
  break;
  case 42:
  yyval.nd = node_op_new("==", (yyvsp + -2)->nd, (yyvsp + 0)->nd);
  break;
  case 43:
  yyval.nd = node_op_new("!=", (yyvsp + -2)->nd, (yyvsp + 0)->nd);
  break;
  case 44:
  yyval.nd = (yyvsp + 0)->nd;
  break;
  case 45:
  yyval.nd = node_op_new("-", (node *)((void *)0), (yyvsp + 0)->nd);
  break;
  case 46:
  yyval.nd = node_op_new("!", (node *)((void *)0), (yyvsp + 0)->nd);
  break;
  case 47:
  yyval.nd = node_op_new("~", (node *)((void *)0), (yyvsp + 0)->nd);
  break;
  case 48:
  yyval.nd = node_op_new("&&", (yyvsp + -2)->nd, (yyvsp + 0)->nd);
  break;
  case 49:
  yyval.nd = node_op_new("||", (yyvsp + -2)->nd, (yyvsp + 0)->nd);
  break;
  case 50:
  yyval.nd = node_lambda_new((yyvsp + -2)->nd, (yyvsp + 0)->nd);
  break;
  case 51:
  yyval.nd = node_lambda_new((yyvsp + -3)->nd, (yyvsp + -1)->nd);
  break;
  case 52:
  yyval.nd = node_if_new((yyvsp + -2)->nd, (yyvsp + -1)->nd, (yyvsp + 0)->nd);
  break;
  case 54:
  yyval.nd = (yyvsp + -1)->nd;
  break;
  case 55:
  yyval.nd = (node *)((void *)0);
  break;
  case 56:
  yyval.nd = (yyvsp + 0)->nd;
  break;
  case 57:
  yyval.nd = (node *)((void *)0);
  break;
  case 58:
  yyval.nd = node_array_headers((yyvsp + 0)->nd);
  break;
  case 60:
  yyval.nd = node_pair_new((yyvsp + -1)->id, (yyvsp + 0)->nd);
  break;
  case 61:
  yyval.nd = node_splat_new((yyvsp + 0)->nd);
  break;
  case 62:
  yyval.nd = node_array_new();
  node_array_add(yyval.nd, (yyvsp + 0)->nd);
  break;
  case 63:
  yyval.nd = (yyvsp + -2)->nd;
  node_array_add((yyvsp + -2)->nd, (yyvsp + 0)->nd);
  break;
  case 68:
  yyval.nd = node_ident_new((yyvsp + 0)->id);
  break;
  case 69:
  if ((unsigned int )((yyvsp + -1)->nd)->type == 9U) {
    lambda = (node_lambda *)(yyvsp + -1)->nd;
    if (lambda->block) {
      lambda->block = 0;
    }
  }
  yyval.nd = (yyvsp + -1)->nd;
  break;
  case 70:
  yyval.nd = node_array_headers((yyvsp + -1)->nd);
  break;
  case 71:
  yyval.nd = node_array_new();
  break;
  case 73:
  yyval.nd = node_nil();
  break;
  case 74:
  yyval.nd = node_true();
  break;
  case 75:
  yyval.nd = node_false();
  break;
  case 76:
  yyval.nd = node_obj_new((yyvsp + -1)->nd, (yyvsp + -3)->id);
  break;
  case 77:
  yyval.nd = node_call_new((yyvsp + -1)->id, (node *)((void *)0), (node *)((void *)0),
                           (yyvsp + 0)->nd);
  break;
  case 78:
  yyval.nd = node_call_new((yyvsp + -4)->id, (node *)((void *)0), (yyvsp + -2)->nd,
                           (yyvsp + 0)->nd);
  break;
  case 79:
  yyval.nd = node_call_new((yyvsp + -4)->id, (yyvsp + -6)->nd, (yyvsp + -2)->nd, (yyvsp + 0)->nd);
  break;
  case 80:
  yyval.nd = node_call_new((yyvsp + -1)->id, (yyvsp + -3)->nd, (node *)((void *)0),
                           (yyvsp + 0)->nd);
  break;
  case 81:
  yyval.nd = node_fcall_new((yyvsp + -5)->nd, (yyvsp + -2)->nd, (yyvsp + 0)->nd);
  break;
  case 82:
  yyval.nd = node_genfunc_new((yyvsp + 0)->id);
  break;
  case 83:
  yyval.nd = (node *)((void *)0);
  break;
  case 85:
  yyval.nd = node_ident_new((yyvsp + 0)->id);
  break;
  case 88:
  yyval.nd = node_nil();
  break;
  case 89:
  yyval.nd = node_true();
  break;
  case 90:
  yyval.nd = node_false();
  break;
  case 91:
  yyval.nd = node_pattern_new(11);
  break;
  case 92:
  tmp___5 = node_pattern_new(11);
  yyval.nd = node_ns_new((yyvsp + -1)->id, tmp___5);
  break;
  case 93:
  yyval.nd = (yyvsp + -1)->nd;
  break;
  case 94:
  yyval.nd = node_ns_new((yyvsp + -2)->id, (yyvsp + -1)->nd);
  break;
  case 95:
  yyval.nd = node_ns_new((yyvsp + 0)->id, (yyvsp + -2)->nd);
  break;
  case 96:
  yyval.nd = node_pattern_new(11);
  node_pattern_add(yyval.nd, (yyvsp + 0)->nd);
  break;
  case 97:
  yyval.nd = (yyvsp + -2)->nd;
  node_pattern_add(yyval.nd, (yyvsp + 0)->nd);
  break;
  case 98:
  yyval.nd = node_pattern_new(12);
  tmp___6 = node_pair_new((yyvsp + -1)->id, (yyvsp + 0)->nd);
  node_pattern_add(yyval.nd, tmp___6);
  break;
  case 99:
  yyval.nd = (yyvsp + -3)->nd;
  tmp___7 = node_pair_new((yyvsp + -1)->id, (yyvsp + 0)->nd);
  node_pattern_add(yyval.nd, tmp___7);
  break;
  case 101:
  yyval.nd = node_psplat_new((yyvsp + -3)->nd, (yyvsp + 0)->nd, (node *)((void *)0));
  break;
  case 102:
  yyval.nd = node_psplat_new((yyvsp + -5)->nd, (yyvsp + -2)->nd, (yyvsp + 0)->nd);
  break;
  case 103:
  yyval.nd = node_psplat_new((node *)((void *)0), (yyvsp + 0)->nd, (node *)((void *)0));
  break;
  case 104:
  yyval.nd = node_psplat_new((node *)((void *)0), (yyvsp + -2)->nd, (yyvsp + 0)->nd);
  break;
  case 106:
  yyval.nd = node_psplat_new((yyvsp + -3)->nd, (yyvsp + 0)->nd, (node *)((void *)0));
  break;
  case 107:
  tmp___8 = node_pattern_new(11);
  yyval.nd = node_plambda_new(tmp___8, (node *)((void *)0));
  break;
  case 108:
  tmp___9 = node_pattern_new(11);
  yyval.nd = node_plambda_new(tmp___9, (yyvsp + -1)->nd);
  break;
  case 109:
  yyval.nd = node_plambda_new((yyvsp + -1)->nd, (node *)((void *)0));
  break;
  case 110:
  yyval.nd = node_plambda_new((yyvsp + -3)->nd, (yyvsp + -1)->nd);
  break;
  case 111:
  yyval.nd = node_plambda_body((yyvsp + -1)->nd, (yyvsp + 0)->nd);
  break;
  case 112:
  tmp___10 = node_plambda_body((yyvsp + -1)->nd, (yyvsp + 0)->nd);
  yyval.nd = node_plambda_add((yyvsp + -3)->nd, tmp___10);
  break;
  case 113:
  yyval.nd = node_block_new((yyvsp + -1)->nd);
  break;
  case 114:
  yyval.nd = node_lambda_new((yyvsp + -2)->nd, (yyvsp + -1)->nd);
  break;
  case 115:
  yyval.nd = (yyvsp + -1)->nd;
  break;
  case 116:
  tmp___11 = node_plambda_new((node *)((void *)0), (node *)((void *)0));
  e = tmp___11;
  tmp___12 = node_plambda_body(e, (yyvsp + -1)->nd);
  yyval.nd = node_plambda_add((yyvsp + -4)->nd, tmp___12);
  break;
  case 117:
  yyval.nd = (node *)((void *)0);
  break;
  case 118:
  yyval.nd = (yyvsp + -1)->nd;
  break;
  case 119:
  yyval.nd = (node *)((void *)0);
  break;
  case 121:
  yyval.nd = node_args_new();
  node_args_add(yyval.nd, (yyvsp + 0)->id);
  break;
  case 122:
  yyval.nd = (yyvsp + -2)->nd;
  node_args_add(yyval.nd, (yyvsp + 0)->id);
  break;
  case 126:
  yyerrstatus = 0;
  break;
  case 127:
  yyerrstatus = 0;
  break;
  default:
  break;
  }
  while (1) {
    if (yydebug) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s ", "-> $$ =");
      yy_symbol_print(stderr, (int )yyr1[yyn], (YYSTYPE const   * const  )(& yyval),
                      p);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
    }
    break;
  }
  yyvsp -= yylen;
  yyssp -= yylen;
  yylen = 0;
  while (1) {
    if (yydebug) {
      yy_stack_print(yyss, yyssp);
    }
    break;
  }
  yyvsp ++;
  *yyvsp = yyval;
  yylhs = (int )((int const   )yyr1[yyn] - 61);
  yyi = (int )((int const   )yypgoto[yylhs] + (int const   )*yyssp);
  if (0 <= yyi) {
    if (yyi <= 793) {
      if ((int const   )yycheck[yyi] == (int const   )*yyssp) {
        yystate = (yy_state_fast_t )yytable[yyi];
      } else {
        yystate = (yy_state_fast_t )yydefgoto[yylhs];
      }
    } else {
      yystate = (yy_state_fast_t )yydefgoto[yylhs];
    }
  } else {
    yystate = (yy_state_fast_t )yydefgoto[yylhs];
  }
  goto yynewstate;
  yyerrlab:
  if (yychar == -2) {
    yytoken = -2;
  } else {
    if (0 <= yychar) {
      if (yychar <= 301) {
        tmp___13 = (int const   )yytranslate[yychar];
      } else {
        tmp___13 = (int const   )2;
      }
    } else {
      tmp___13 = (int const   )2;
    }
    yytoken = (int )tmp___13;
  }
  if (! yyerrstatus) {
    yynerrs ++;
    yymsgp = "syntax error";
    yysyntax_error_status = yysyntax_error(& yymsg_alloc, & yymsg, yyssp, yytoken);
    if (yysyntax_error_status == 0) {
      yymsgp = (char const   *)yymsg;
    } else
    if (yysyntax_error_status == 1) {
      if ((unsigned long )yymsg != (unsigned long )(yymsgbuf)) {
        free((void *)yymsg);
      }
      tmp___14 = malloc((unsigned long )yymsg_alloc);
      yymsg = (char *)tmp___14;
      if (! yymsg) {
        yymsg = yymsgbuf;
        yymsg_alloc = (long )sizeof(yymsgbuf);
        yysyntax_error_status = 2;
      } else {
        yysyntax_error_status = yysyntax_error(& yymsg_alloc, & yymsg, yyssp, yytoken);
        yymsgp = (char const   *)yymsg;
      }
    }
    yyerror(p, yymsgp);
    if (yysyntax_error_status == 2) {
      goto yyexhaustedlab;
    }
  }
  if (yyerrstatus == 3) {
    if (yychar <= 0) {
      if (yychar == 0) {
        goto yyabortlab;
      }
    } else {
      yydestruct("Error: discarding", yytoken, & yylval, p);
      yychar = -2;
    }
  }
  goto yyerrlab1;
  yyvsp -= yylen;
  yyssp -= yylen;
  yylen = 0;
  while (1) {
    if (yydebug) {
      yy_stack_print(yyss, yyssp);
    }
    break;
  }
  yystate = (yy_state_fast_t )*yyssp;
  goto yyerrlab1;
  yyerrlab1:
  yyerrstatus = 3;
  while (1) {
    yyn = (int )yypact[yystate];
    if (! (yyn == -211)) {
      yyn ++;
      if (0 <= yyn) {
        if (yyn <= 793) {
          if ((int const   )yycheck[yyn] == 1) {
            yyn = (int )yytable[yyn];
            if (0 < yyn) {
              break;
            }
          }
        }
      }
    }
    if ((unsigned long )yyssp == (unsigned long )yyss) {
      goto yyabortlab;
    }
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp, p);
    yyvsp --;
    yyssp --;
    yystate = (yy_state_fast_t )*yyssp;
    while (1) {
      if (yydebug) {
        yy_stack_print(yyss, yyssp);
      }
      break;
    }
  }
  yyvsp ++;
  *yyvsp = yylval;
  while (1) {
    if (yydebug) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s ", "Shifting");
      yy_symbol_print(stderr, (int )yystos[yyn], (YYSTYPE const   * const  )yyvsp,
                      p);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
    }
    break;
  }
  yystate = yyn;
  goto yynewstate;
  yyacceptlab:
  yyresult = 0;
  goto yyreturn;
  yyabortlab:
  yyresult = 1;
  goto yyreturn;
  yyexhaustedlab:
  yyerror(p, "memory exhausted");
  yyresult = 2;
  yyreturn:
  if (yychar != -2) {
    if (0 <= yychar) {
      if (yychar <= 301) {
        yytoken = (int )yytranslate[yychar];
      } else {
        yytoken = 2;
      }
    } else {
      yytoken = 2;
    }
    yydestruct("Cleanup: discarding lookahead", yytoken, & yylval, p);
  }
  yyvsp -= yylen;
  yyssp -= yylen;
  while (1) {
    if (yydebug) {
      yy_stack_print(yyss, yyssp);
    }
    break;
  }
  while ((unsigned long )yyssp != (unsigned long )yyss) {
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp, p);
    yyvsp --;
    yyssp --;
  }
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    free((void *)yyss);
  }
  if ((unsigned long )yymsg != (unsigned long )(yymsgbuf)) {
    free((void *)yymsg);
  }
  return (yyresult);
}
}
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
int yyleng  ;
FILE *yyin ;
FILE *yyout ;
static size_t yy_buffer_stack_top  =    (size_t )0;
static size_t yy_buffer_stack_max  =    (size_t )0;
static YY_BUFFER_STATE *yy_buffer_stack  =    (YY_BUFFER_STATE *)((void *)0);
static char yy_hold_char  ;
static int yy_n_chars  ;
static char *yy_c_buf_p  =    (char *)((void *)0);
static int yy_init  =    0;
static int yy_start  =    0;
static int yy_did_buffer_switch_on_eof  ;
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
YY_BUFFER_STATE yy_create_buffer(FILE *file , int size ) ;
void yy_delete_buffer(YY_BUFFER_STATE b ) ;
void yy_flush_buffer(YY_BUFFER_STATE b ) ;
void yypush_buffer_state(YY_BUFFER_STATE new_buffer ) ;
void yypop_buffer_state(void) ;
static void yyensure_buffer_stack(void) ;
static void yy_load_buffer_state(void) ;
static void yy_init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
YY_BUFFER_STATE yy_scan_buffer(char *base , yy_size_t size ) ;
YY_BUFFER_STATE yy_scan_bytes(char const   *yybytes , int _yybytes_len ) ;
void *yyalloc(yy_size_t size ) ;
void *yyrealloc(void *ptr , yy_size_t size ) ;
void yyfree(void *ptr ) ;
FILE *yyin  =    (FILE *)((void *)0);
FILE *yyout  =    (FILE *)((void *)0);
int yylineno ;
int yylineno  =    1;
char *yytext  ;
static yy_state_type yy_get_previous_state(void) ;
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) ;
static int yy_get_next_buffer(void) ;
static  __attribute__((__noreturn__)) void yy_fatal_error(char const   *msg ) ;
static flex_int16_t const   yy_accept[290]  =
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )56,
        (flex_int16_t const   )54,      (flex_int16_t const   )53,      (flex_int16_t const   )43,      (flex_int16_t const   )54,
        (flex_int16_t const   )54,      (flex_int16_t const   )54,      (flex_int16_t const   )5,      (flex_int16_t const   )14,
        (flex_int16_t const   )41,      (flex_int16_t const   )42,      (flex_int16_t const   )3,      (flex_int16_t const   )1,
        (flex_int16_t const   )2,      (flex_int16_t const   )40,      (flex_int16_t const   )4,      (flex_int16_t const   )45,
        (flex_int16_t const   )45,      (flex_int16_t const   )41,      (flex_int16_t const   )8,      (flex_int16_t const   )20,
        (flex_int16_t const   )10,      (flex_int16_t const   )42,      (flex_int16_t const   )37,      (flex_int16_t const   )37,
        (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )37,
        (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )37,
        (flex_int16_t const   )37,      (flex_int16_t const   )39,      (flex_int16_t const   )54,      (flex_int16_t const   )54,
        (flex_int16_t const   )54,      (flex_int16_t const   )54,      (flex_int16_t const   )54,      (flex_int16_t const   )0,
        (flex_int16_t const   )0,      (flex_int16_t const   )40,      (flex_int16_t const   )0,      (flex_int16_t const   )39,
        (flex_int16_t const   )7,      (flex_int16_t const   )0,      (flex_int16_t const   )50,      (flex_int16_t const   )0,
        (flex_int16_t const   )0,      (flex_int16_t const   )44,      (flex_int16_t const   )5,      (flex_int16_t const   )0,
        (flex_int16_t const   )14,      (flex_int16_t const   )0,      (flex_int16_t const   )12,      (flex_int16_t const   )41,
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )3,
        (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )0,      (flex_int16_t const   )2,
        (flex_int16_t const   )0,      (flex_int16_t const   )17,      (flex_int16_t const   )40,      (flex_int16_t const   )0,
        (flex_int16_t const   )4,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )45,      (flex_int16_t const   )21,
        (flex_int16_t const   )51,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )8,      (flex_int16_t const   )0,
        (flex_int16_t const   )15,      (flex_int16_t const   )9,      (flex_int16_t const   )20,      (flex_int16_t const   )0,
        (flex_int16_t const   )6,      (flex_int16_t const   )16,      (flex_int16_t const   )10,      (flex_int16_t const   )0,
        (flex_int16_t const   )11,      (flex_int16_t const   )37,      (flex_int16_t const   )38,      (flex_int16_t const   )0,
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,
        (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )37,
        (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )22,      (flex_int16_t const   )37,
        (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )37,
        (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )39,
        (flex_int16_t const   )0,      (flex_int16_t const   )13,      (flex_int16_t const   )37,      (flex_int16_t const   )0,
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,
        (flex_int16_t const   )0,      (flex_int16_t const   )7,      (flex_int16_t const   )0,      (flex_int16_t const   )52,
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )12,      (flex_int16_t const   )0,
        (flex_int16_t const   )0,      (flex_int16_t const   )18,      (flex_int16_t const   )0,      (flex_int16_t const   )0,
        (flex_int16_t const   )0,      (flex_int16_t const   )17,      (flex_int16_t const   )0,      (flex_int16_t const   )0,
        (flex_int16_t const   )0,      (flex_int16_t const   )46,      (flex_int16_t const   )0,      (flex_int16_t const   )48,
        (flex_int16_t const   )47,      (flex_int16_t const   )21,      (flex_int16_t const   )0,      (flex_int16_t const   )51,
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )15,      (flex_int16_t const   )0,
        (flex_int16_t const   )9,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )6,
        (flex_int16_t const   )0,      (flex_int16_t const   )16,      (flex_int16_t const   )0,      (flex_int16_t const   )0,
        (flex_int16_t const   )11,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )37,      (flex_int16_t const   )37,
        (flex_int16_t const   )31,      (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )37,
        (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )33,
        (flex_int16_t const   )34,      (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )37,
        (flex_int16_t const   )0,      (flex_int16_t const   )13,      (flex_int16_t const   )0,      (flex_int16_t const   )0,
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,
        (flex_int16_t const   )18,      (flex_int16_t const   )18,      (flex_int16_t const   )0,      (flex_int16_t const   )19,
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )46,      (flex_int16_t const   )0,
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )25,      (flex_int16_t const   )37,
        (flex_int16_t const   )23,      (flex_int16_t const   )26,      (flex_int16_t const   )37,      (flex_int16_t const   )37,
        (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )24,
        (flex_int16_t const   )35,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,
        (flex_int16_t const   )23,      (flex_int16_t const   )0,      (flex_int16_t const   )19,      (flex_int16_t const   )0,
        (flex_int16_t const   )49,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )25,
        (flex_int16_t const   )0,      (flex_int16_t const   )29,      (flex_int16_t const   )23,      (flex_int16_t const   )0,
        (flex_int16_t const   )36,      (flex_int16_t const   )37,      (flex_int16_t const   )37,      (flex_int16_t const   )37,
        (flex_int16_t const   )37,      (flex_int16_t const   )24,      (flex_int16_t const   )0,      (flex_int16_t const   )0,
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,
        (flex_int16_t const   )30,      (flex_int16_t const   )32,      (flex_int16_t const   )37,      (flex_int16_t const   )27,
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )37,
        (flex_int16_t const   )0,      (flex_int16_t const   )37,      (flex_int16_t const   )49,      (flex_int16_t const   )28,
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )49,
        (flex_int16_t const   )49,      (flex_int16_t const   )49,      (flex_int16_t const   )49,      (flex_int16_t const   )0,
        (flex_int16_t const   )49,      (flex_int16_t const   )0};
static YY_CHAR const   yy_ec[256]  =
  {      (YY_CHAR const   )0,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )2,      (YY_CHAR const   )3,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )4,      (YY_CHAR const   )5,      (YY_CHAR const   )6,      (YY_CHAR const   )7,
        (YY_CHAR const   )1,      (YY_CHAR const   )8,      (YY_CHAR const   )9,      (YY_CHAR const   )1,
        (YY_CHAR const   )10,      (YY_CHAR const   )11,      (YY_CHAR const   )12,      (YY_CHAR const   )13,
        (YY_CHAR const   )10,      (YY_CHAR const   )14,      (YY_CHAR const   )15,      (YY_CHAR const   )16,
        (YY_CHAR const   )17,      (YY_CHAR const   )18,      (YY_CHAR const   )18,      (YY_CHAR const   )18,
        (YY_CHAR const   )18,      (YY_CHAR const   )18,      (YY_CHAR const   )18,      (YY_CHAR const   )18,
        (YY_CHAR const   )19,      (YY_CHAR const   )19,      (YY_CHAR const   )20,      (YY_CHAR const   )10,
        (YY_CHAR const   )21,      (YY_CHAR const   )22,      (YY_CHAR const   )23,      (YY_CHAR const   )1,
        (YY_CHAR const   )24,      (YY_CHAR const   )25,      (YY_CHAR const   )25,      (YY_CHAR const   )25,
        (YY_CHAR const   )25,      (YY_CHAR const   )25,      (YY_CHAR const   )25,      (YY_CHAR const   )26,
        (YY_CHAR const   )26,      (YY_CHAR const   )26,      (YY_CHAR const   )26,      (YY_CHAR const   )26,
        (YY_CHAR const   )26,      (YY_CHAR const   )26,      (YY_CHAR const   )26,      (YY_CHAR const   )26,
        (YY_CHAR const   )26,      (YY_CHAR const   )26,      (YY_CHAR const   )26,      (YY_CHAR const   )26,
        (YY_CHAR const   )27,      (YY_CHAR const   )26,      (YY_CHAR const   )26,      (YY_CHAR const   )26,
        (YY_CHAR const   )26,      (YY_CHAR const   )26,      (YY_CHAR const   )28,      (YY_CHAR const   )10,
        (YY_CHAR const   )29,      (YY_CHAR const   )24,      (YY_CHAR const   )1,      (YY_CHAR const   )26,
        (YY_CHAR const   )1,      (YY_CHAR const   )30,      (YY_CHAR const   )25,      (YY_CHAR const   )31,
        (YY_CHAR const   )32,      (YY_CHAR const   )33,      (YY_CHAR const   )34,      (YY_CHAR const   )26,
        (YY_CHAR const   )35,      (YY_CHAR const   )36,      (YY_CHAR const   )26,      (YY_CHAR const   )37,
        (YY_CHAR const   )38,      (YY_CHAR const   )39,      (YY_CHAR const   )40,      (YY_CHAR const   )41,
        (YY_CHAR const   )42,      (YY_CHAR const   )26,      (YY_CHAR const   )43,      (YY_CHAR const   )44,
        (YY_CHAR const   )45,      (YY_CHAR const   )46,      (YY_CHAR const   )26,      (YY_CHAR const   )47,
        (YY_CHAR const   )48,      (YY_CHAR const   )26,      (YY_CHAR const   )26,      (YY_CHAR const   )49,
        (YY_CHAR const   )50,      (YY_CHAR const   )24,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )51,      (YY_CHAR const   )51,      (YY_CHAR const   )51,      (YY_CHAR const   )51,
        (YY_CHAR const   )51,      (YY_CHAR const   )51,      (YY_CHAR const   )51,      (YY_CHAR const   )51,
        (YY_CHAR const   )51,      (YY_CHAR const   )51,      (YY_CHAR const   )51,      (YY_CHAR const   )51,
        (YY_CHAR const   )51,      (YY_CHAR const   )51,      (YY_CHAR const   )51,      (YY_CHAR const   )51,
        (YY_CHAR const   )51,      (YY_CHAR const   )51,      (YY_CHAR const   )51,      (YY_CHAR const   )51,
        (YY_CHAR const   )51,      (YY_CHAR const   )51,      (YY_CHAR const   )51,      (YY_CHAR const   )51,
        (YY_CHAR const   )51,      (YY_CHAR const   )51,      (YY_CHAR const   )51,      (YY_CHAR const   )51,
        (YY_CHAR const   )51,      (YY_CHAR const   )51,      (YY_CHAR const   )51,      (YY_CHAR const   )51,
        (YY_CHAR const   )51,      (YY_CHAR const   )51,      (YY_CHAR const   )51,      (YY_CHAR const   )51,
        (YY_CHAR const   )51,      (YY_CHAR const   )51,      (YY_CHAR const   )51,      (YY_CHAR const   )51,
        (YY_CHAR const   )51,      (YY_CHAR const   )51,      (YY_CHAR const   )51,      (YY_CHAR const   )51,
        (YY_CHAR const   )51,      (YY_CHAR const   )51,      (YY_CHAR const   )51,      (YY_CHAR const   )51,
        (YY_CHAR const   )51,      (YY_CHAR const   )51,      (YY_CHAR const   )51,      (YY_CHAR const   )51,
        (YY_CHAR const   )51,      (YY_CHAR const   )51,      (YY_CHAR const   )51,      (YY_CHAR const   )51,
        (YY_CHAR const   )51,      (YY_CHAR const   )51,      (YY_CHAR const   )51,      (YY_CHAR const   )51,
        (YY_CHAR const   )51,      (YY_CHAR const   )51,      (YY_CHAR const   )51,      (YY_CHAR const   )51,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )52,      (YY_CHAR const   )52,
        (YY_CHAR const   )52,      (YY_CHAR const   )52,      (YY_CHAR const   )52,      (YY_CHAR const   )52,
        (YY_CHAR const   )52,      (YY_CHAR const   )52,      (YY_CHAR const   )52,      (YY_CHAR const   )52,
        (YY_CHAR const   )52,      (YY_CHAR const   )52,      (YY_CHAR const   )52,      (YY_CHAR const   )52,
        (YY_CHAR const   )52,      (YY_CHAR const   )52,      (YY_CHAR const   )52,      (YY_CHAR const   )52,
        (YY_CHAR const   )52,      (YY_CHAR const   )52,      (YY_CHAR const   )52,      (YY_CHAR const   )52,
        (YY_CHAR const   )52,      (YY_CHAR const   )52,      (YY_CHAR const   )52,      (YY_CHAR const   )52,
        (YY_CHAR const   )52,      (YY_CHAR const   )52,      (YY_CHAR const   )52,      (YY_CHAR const   )52,
        (YY_CHAR const   )53,      (YY_CHAR const   )53,      (YY_CHAR const   )53,      (YY_CHAR const   )53,
        (YY_CHAR const   )53,      (YY_CHAR const   )53,      (YY_CHAR const   )53,      (YY_CHAR const   )53,
        (YY_CHAR const   )53,      (YY_CHAR const   )53,      (YY_CHAR const   )53,      (YY_CHAR const   )53,
        (YY_CHAR const   )53,      (YY_CHAR const   )53,      (YY_CHAR const   )53,      (YY_CHAR const   )53,
        (YY_CHAR const   )54,      (YY_CHAR const   )54,      (YY_CHAR const   )54,      (YY_CHAR const   )54,
        (YY_CHAR const   )54,      (YY_CHAR const   )54,      (YY_CHAR const   )54,      (YY_CHAR const   )54,
        (YY_CHAR const   )55,      (YY_CHAR const   )55,      (YY_CHAR const   )55,      (YY_CHAR const   )55,
        (YY_CHAR const   )56,      (YY_CHAR const   )56,      (YY_CHAR const   )1,      (YY_CHAR const   )1};
static YY_CHAR const   yy_meta[57]  =
  {      (YY_CHAR const   )0,      (YY_CHAR const   )1,      (YY_CHAR const   )2,      (YY_CHAR const   )2,
        (YY_CHAR const   )2,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )2,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )3,      (YY_CHAR const   )3,      (YY_CHAR const   )3,
        (YY_CHAR const   )4,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )1,      (YY_CHAR const   )5,      (YY_CHAR const   )6,      (YY_CHAR const   )6,
        (YY_CHAR const   )6,      (YY_CHAR const   )1,      (YY_CHAR const   )5,      (YY_CHAR const   )5,
        (YY_CHAR const   )5,      (YY_CHAR const   )5,      (YY_CHAR const   )5,      (YY_CHAR const   )6,
        (YY_CHAR const   )6,      (YY_CHAR const   )6,      (YY_CHAR const   )6,      (YY_CHAR const   )6,
        (YY_CHAR const   )6,      (YY_CHAR const   )6,      (YY_CHAR const   )6,      (YY_CHAR const   )6,
        (YY_CHAR const   )6,      (YY_CHAR const   )6,      (YY_CHAR const   )6,      (YY_CHAR const   )6,
        (YY_CHAR const   )6,      (YY_CHAR const   )1,      (YY_CHAR const   )1,      (YY_CHAR const   )1,
        (YY_CHAR const   )6,      (YY_CHAR const   )6,      (YY_CHAR const   )6,      (YY_CHAR const   )6,
        (YY_CHAR const   )6};
static flex_int16_t const   yy_base[324]  =
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )952,
        (flex_int16_t const   )953,      (flex_int16_t const   )55,      (flex_int16_t const   )61,      (flex_int16_t const   )929,
        (flex_int16_t const   )54,      (flex_int16_t const   )947,      (flex_int16_t const   )70,      (flex_int16_t const   )77,
        (flex_int16_t const   )88,      (flex_int16_t const   )57,      (flex_int16_t const   )94,      (flex_int16_t const   )100,
        (flex_int16_t const   )106,      (flex_int16_t const   )112,      (flex_int16_t const   )118,      (flex_int16_t const   )109,
        (flex_int16_t const   )115,      (flex_int16_t const   )156,      (flex_int16_t const   )133,      (flex_int16_t const   )139,
        (flex_int16_t const   )149,      (flex_int16_t const   )953,      (flex_int16_t const   )125,      (flex_int16_t const   )134,
        (flex_int16_t const   )135,      (flex_int16_t const   )136,      (flex_int16_t const   )37,      (flex_int16_t const   )161,
        (flex_int16_t const   )163,      (flex_int16_t const   )183,      (flex_int16_t const   )164,      (flex_int16_t const   )101,
        (flex_int16_t const   )177,      (flex_int16_t const   )220,      (flex_int16_t const   )898,      (flex_int16_t const   )897,
        (flex_int16_t const   )896,      (flex_int16_t const   )895,      (flex_int16_t const   )894,      (flex_int16_t const   )226,
        (flex_int16_t const   )941,      (flex_int16_t const   )232,      (flex_int16_t const   )905,      (flex_int16_t const   )240,
        (flex_int16_t const   )246,      (flex_int16_t const   )60,      (flex_int16_t const   )922,      (flex_int16_t const   )938,
        (flex_int16_t const   )937,      (flex_int16_t const   )253,      (flex_int16_t const   )259,      (flex_int16_t const   )936,
        (flex_int16_t const   )270,      (flex_int16_t const   )935,      (flex_int16_t const   )276,      (flex_int16_t const   )285,
        (flex_int16_t const   )818,      (flex_int16_t const   )178,      (flex_int16_t const   )795,      (flex_int16_t const   )291,
        (flex_int16_t const   )752,      (flex_int16_t const   )297,      (flex_int16_t const   )730,      (flex_int16_t const   )303,
        (flex_int16_t const   )726,      (flex_int16_t const   )309,      (flex_int16_t const   )315,      (flex_int16_t const   )719,
        (flex_int16_t const   )321,      (flex_int16_t const   )718,      (flex_int16_t const   )166,      (flex_int16_t const   )312,
        (flex_int16_t const   )82,      (flex_int16_t const   )0,      (flex_int16_t const   )317,      (flex_int16_t const   )335,
        (flex_int16_t const   )291,      (flex_int16_t const   )643,      (flex_int16_t const   )640,      (flex_int16_t const   )638,
        (flex_int16_t const   )627,      (flex_int16_t const   )625,      (flex_int16_t const   )346,      (flex_int16_t const   )671,
        (flex_int16_t const   )352,      (flex_int16_t const   )358,      (flex_int16_t const   )364,      (flex_int16_t const   )669,
        (flex_int16_t const   )370,      (flex_int16_t const   )376,      (flex_int16_t const   )382,      (flex_int16_t const   )632,
        (flex_int16_t const   )388,      (flex_int16_t const   )55,      (flex_int16_t const   )953,      (flex_int16_t const   )583,
        (flex_int16_t const   )577,      (flex_int16_t const   )564,      (flex_int16_t const   )561,      (flex_int16_t const   )560,
        (flex_int16_t const   )187,      (flex_int16_t const   )168,      (flex_int16_t const   )237,      (flex_int16_t const   )188,
        (flex_int16_t const   )216,      (flex_int16_t const   )207,      (flex_int16_t const   )252,      (flex_int16_t const   )358,
        (flex_int16_t const   )363,      (flex_int16_t const   )364,      (flex_int16_t const   )367,      (flex_int16_t const   )303,
        (flex_int16_t const   )368,      (flex_int16_t const   )374,      (flex_int16_t const   )369,      (flex_int16_t const   )414,
        (flex_int16_t const   )603,      (flex_int16_t const   )420,      (flex_int16_t const   )381,      (flex_int16_t const   )554,
        (flex_int16_t const   )549,      (flex_int16_t const   )532,      (flex_int16_t const   )520,      (flex_int16_t const   )562,
        (flex_int16_t const   )520,      (flex_int16_t const   )426,      (flex_int16_t const   )556,      (flex_int16_t const   )953,
        (flex_int16_t const   )555,      (flex_int16_t const   )550,      (flex_int16_t const   )432,      (flex_int16_t const   )544,
        (flex_int16_t const   )538,      (flex_int16_t const   )438,      (flex_int16_t const   )532,      (flex_int16_t const   )527,
        (flex_int16_t const   )510,      (flex_int16_t const   )444,      (flex_int16_t const   )507,      (flex_int16_t const   )497,
        (flex_int16_t const   )495,      (flex_int16_t const   )435,      (flex_int16_t const   )186,      (flex_int16_t const   )100,
        (flex_int16_t const   )0,      (flex_int16_t const   )453,      (flex_int16_t const   )485,      (flex_int16_t const   )409,
        (flex_int16_t const   )431,      (flex_int16_t const   )430,      (flex_int16_t const   )425,      (flex_int16_t const   )424,
        (flex_int16_t const   )419,      (flex_int16_t const   )418,      (flex_int16_t const   )408,      (flex_int16_t const   )407,
        (flex_int16_t const   )398,      (flex_int16_t const   )441,      (flex_int16_t const   )464,      (flex_int16_t const   )440,
        (flex_int16_t const   )470,      (flex_int16_t const   )435,      (flex_int16_t const   )434,      (flex_int16_t const   )476,
        (flex_int16_t const   )429,      (flex_int16_t const   )482,      (flex_int16_t const   )428,      (flex_int16_t const   )423,
        (flex_int16_t const   )488,      (flex_int16_t const   )422,      (flex_int16_t const   )369,      (flex_int16_t const   )358,
        (flex_int16_t const   )336,      (flex_int16_t const   )331,      (flex_int16_t const   )463,      (flex_int16_t const   )464,
        (flex_int16_t const   )467,      (flex_int16_t const   )473,      (flex_int16_t const   )469,      (flex_int16_t const   )474,
        (flex_int16_t const   )479,      (flex_int16_t const   )486,      (flex_int16_t const   )489,      (flex_int16_t const   )485,
        (flex_int16_t const   )495,      (flex_int16_t const   )496,      (flex_int16_t const   )498,      (flex_int16_t const   )499,
        (flex_int16_t const   )378,      (flex_int16_t const   )541,      (flex_int16_t const   )373,      (flex_int16_t const   )324,
        (flex_int16_t const   )319,      (flex_int16_t const   )336,      (flex_int16_t const   )361,      (flex_int16_t const   )360,
        (flex_int16_t const   )547,      (flex_int16_t const   )553,      (flex_int16_t const   )355,      (flex_int16_t const   )559,
        (flex_int16_t const   )354,      (flex_int16_t const   )550,      (flex_int16_t const   )555,      (flex_int16_t const   )560,
        (flex_int16_t const   )349,      (flex_int16_t const   )300,      (flex_int16_t const   )289,      (flex_int16_t const   )275,
        (flex_int16_t const   )270,      (flex_int16_t const   )269,      (flex_int16_t const   )264,      (flex_int16_t const   )311,
        (flex_int16_t const   )306,      (flex_int16_t const   )305,      (flex_int16_t const   )299,      (flex_int16_t const   )294,
        (flex_int16_t const   )245,      (flex_int16_t const   )240,      (flex_int16_t const   )578,      (flex_int16_t const   )508,
        (flex_int16_t const   )584,      (flex_int16_t const   )501,      (flex_int16_t const   )559,      (flex_int16_t const   )560,
        (flex_int16_t const   )563,      (flex_int16_t const   )569,      (flex_int16_t const   )580,      (flex_int16_t const   )617,
        (flex_int16_t const   )546,      (flex_int16_t const   )282,      (flex_int16_t const   )233,      (flex_int16_t const   )230,
        (flex_int16_t const   )623,      (flex_int16_t const   )266,      (flex_int16_t const   )629,      (flex_int16_t const   )262,
        (flex_int16_t const   )621,      (flex_int16_t const   )213,      (flex_int16_t const   )207,      (flex_int16_t const   )200,
        (flex_int16_t const   )189,      (flex_int16_t const   )187,      (flex_int16_t const   )163,      (flex_int16_t const   )639,
        (flex_int16_t const   )167,      (flex_int16_t const   )579,      (flex_int16_t const   )647,      (flex_int16_t const   )166,
        (flex_int16_t const   )599,      (flex_int16_t const   )614,      (flex_int16_t const   )626,      (flex_int16_t const   )615,
        (flex_int16_t const   )630,      (flex_int16_t const   )659,      (flex_int16_t const   )164,      (flex_int16_t const   )98,
        (flex_int16_t const   )145,      (flex_int16_t const   )577,      (flex_int16_t const   )93,      (flex_int16_t const   )72,
        (flex_int16_t const   )61,      (flex_int16_t const   )55,      (flex_int16_t const   )84,      (flex_int16_t const   )79,
        (flex_int16_t const   )635,      (flex_int16_t const   )637,      (flex_int16_t const   )639,      (flex_int16_t const   )641,
        (flex_int16_t const   )75,      (flex_int16_t const   )663,      (flex_int16_t const   )18,      (flex_int16_t const   )654,
        (flex_int16_t const   )669,      (flex_int16_t const   )660,      (flex_int16_t const   )682,      (flex_int16_t const   )673,
        (flex_int16_t const   )687,      (flex_int16_t const   )690,      (flex_int16_t const   )695,      (flex_int16_t const   )953,
        (flex_int16_t const   )698,      (flex_int16_t const   )706,      (flex_int16_t const   )713,      (flex_int16_t const   )718,
        (flex_int16_t const   )721,      (flex_int16_t const   )953,      (flex_int16_t const   )741,      (flex_int16_t const   )747,
        (flex_int16_t const   )752,      (flex_int16_t const   )756,      (flex_int16_t const   )762,      (flex_int16_t const   )768,
        (flex_int16_t const   )774,      (flex_int16_t const   )780,      (flex_int16_t const   )786,      (flex_int16_t const   )792,
        (flex_int16_t const   )798,      (flex_int16_t const   )804,      (flex_int16_t const   )810,      (flex_int16_t const   )814,
        (flex_int16_t const   )817,      (flex_int16_t const   )823,      (flex_int16_t const   )829,      (flex_int16_t const   )835,
        (flex_int16_t const   )841,      (flex_int16_t const   )847,      (flex_int16_t const   )853,      (flex_int16_t const   )859,
        (flex_int16_t const   )865,      (flex_int16_t const   )871,      (flex_int16_t const   )877,      (flex_int16_t const   )883,
        (flex_int16_t const   )889,      (flex_int16_t const   )895,      (flex_int16_t const   )901,      (flex_int16_t const   )907,
        (flex_int16_t const   )913,      (flex_int16_t const   )919,      (flex_int16_t const   )925,      (flex_int16_t const   )931};
static flex_int16_t const   yy_def[324]  =
  {      (flex_int16_t const   )0,      (flex_int16_t const   )289,      (flex_int16_t const   )1,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )290,      (flex_int16_t const   )291,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )292,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )293,      (flex_int16_t const   )293,
        (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,
        (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,
        (flex_int16_t const   )27,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )294,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )290,      (flex_int16_t const   )289,      (flex_int16_t const   )290,
        (flex_int16_t const   )291,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )295,
        (flex_int16_t const   )289,      (flex_int16_t const   )296,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )297,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )298,      (flex_int16_t const   )289,      (flex_int16_t const   )299,      (flex_int16_t const   )289,
        (flex_int16_t const   )300,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )301,
        (flex_int16_t const   )289,      (flex_int16_t const   )302,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )303,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )304,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )305,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )306,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )307,
        (flex_int16_t const   )289,      (flex_int16_t const   )27,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,
        (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,
        (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,
        (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )289,
        (flex_int16_t const   )308,      (flex_int16_t const   )289,      (flex_int16_t const   )27,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )294,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )309,      (flex_int16_t const   )289,
        (flex_int16_t const   )295,      (flex_int16_t const   )296,      (flex_int16_t const   )289,      (flex_int16_t const   )310,
        (flex_int16_t const   )297,      (flex_int16_t const   )289,      (flex_int16_t const   )298,      (flex_int16_t const   )299,
        (flex_int16_t const   )300,      (flex_int16_t const   )289,      (flex_int16_t const   )311,      (flex_int16_t const   )301,
        (flex_int16_t const   )302,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )303,      (flex_int16_t const   )289,      (flex_int16_t const   )312,      (flex_int16_t const   )304,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )305,      (flex_int16_t const   )289,      (flex_int16_t const   )313,
        (flex_int16_t const   )289,      (flex_int16_t const   )314,      (flex_int16_t const   )306,      (flex_int16_t const   )289,
        (flex_int16_t const   )315,      (flex_int16_t const   )289,      (flex_int16_t const   )316,      (flex_int16_t const   )307,
        (flex_int16_t const   )289,      (flex_int16_t const   )317,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )27,      (flex_int16_t const   )27,
        (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,
        (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,
        (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,
        (flex_int16_t const   )308,      (flex_int16_t const   )289,      (flex_int16_t const   )318,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )309,      (flex_int16_t const   )310,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )319,      (flex_int16_t const   )289,
        (flex_int16_t const   )311,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )312,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )313,
        (flex_int16_t const   )314,      (flex_int16_t const   )315,      (flex_int16_t const   )316,      (flex_int16_t const   )317,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )27,      (flex_int16_t const   )27,
        (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,
        (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,
        (flex_int16_t const   )27,      (flex_int16_t const   )318,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )319,      (flex_int16_t const   )289,      (flex_int16_t const   )320,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )321,      (flex_int16_t const   )27,      (flex_int16_t const   )289,      (flex_int16_t const   )322,
        (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,
        (flex_int16_t const   )27,      (flex_int16_t const   )289,      (flex_int16_t const   )323,      (flex_int16_t const   )289,
        (flex_int16_t const   )320,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )321,      (flex_int16_t const   )322,
        (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,
        (flex_int16_t const   )323,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )27,
        (flex_int16_t const   )289,      (flex_int16_t const   )27,      (flex_int16_t const   )289,      (flex_int16_t const   )27,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )0,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289};
static flex_int16_t const   yy_nxt[1010]  =
  {      (flex_int16_t const   )0,      (flex_int16_t const   )4,      (flex_int16_t const   )5,      (flex_int16_t const   )6,
        (flex_int16_t const   )5,      (flex_int16_t const   )7,      (flex_int16_t const   )8,      (flex_int16_t const   )9,
        (flex_int16_t const   )10,      (flex_int16_t const   )11,      (flex_int16_t const   )12,      (flex_int16_t const   )13,
        (flex_int16_t const   )14,      (flex_int16_t const   )15,      (flex_int16_t const   )16,      (flex_int16_t const   )17,
        (flex_int16_t const   )18,      (flex_int16_t const   )19,      (flex_int16_t const   )20,      (flex_int16_t const   )20,
        (flex_int16_t const   )21,      (flex_int16_t const   )22,      (flex_int16_t const   )23,      (flex_int16_t const   )24,
        (flex_int16_t const   )25,      (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )26,
        (flex_int16_t const   )26,      (flex_int16_t const   )4,      (flex_int16_t const   )26,      (flex_int16_t const   )27,
        (flex_int16_t const   )28,      (flex_int16_t const   )29,      (flex_int16_t const   )30,      (flex_int16_t const   )26,
        (flex_int16_t const   )31,      (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )32,
        (flex_int16_t const   )33,      (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )34,
        (flex_int16_t const   )35,      (flex_int16_t const   )36,      (flex_int16_t const   )26,      (flex_int16_t const   )26,
        (flex_int16_t const   )26,      (flex_int16_t const   )12,      (flex_int16_t const   )37,      (flex_int16_t const   )4,
        (flex_int16_t const   )38,      (flex_int16_t const   )39,      (flex_int16_t const   )40,      (flex_int16_t const   )41,
        (flex_int16_t const   )42,      (flex_int16_t const   )43,      (flex_int16_t const   )43,      (flex_int16_t const   )43,
        (flex_int16_t const   )50,      (flex_int16_t const   )61,      (flex_int16_t const   )44,      (flex_int16_t const   )43,
        (flex_int16_t const   )43,      (flex_int16_t const   )43,      (flex_int16_t const   )50,      (flex_int16_t const   )109,
        (flex_int16_t const   )44,      (flex_int16_t const   )151,      (flex_int16_t const   )45,      (flex_int16_t const   )62,
        (flex_int16_t const   )54,      (flex_int16_t const   )54,      (flex_int16_t const   )54,      (flex_int16_t const   )97,
        (flex_int16_t const   )45,      (flex_int16_t const   )55,      (flex_int16_t const   )257,      (flex_int16_t const   )56,
        (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )250,      (flex_int16_t const   )51,
        (flex_int16_t const   )57,      (flex_int16_t const   )97,      (flex_int16_t const   )58,      (flex_int16_t const   )247,
        (flex_int16_t const   )46,      (flex_int16_t const   )51,      (flex_int16_t const   )59,      (flex_int16_t const   )59,
        (flex_int16_t const   )59,      (flex_int16_t const   )97,      (flex_int16_t const   )46,      (flex_int16_t const   )60,
        (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )147,
        (flex_int16_t const   )147,      (flex_int16_t const   )64,      (flex_int16_t const   )65,      (flex_int16_t const   )65,
        (flex_int16_t const   )65,      (flex_int16_t const   )47,      (flex_int16_t const   )97,      (flex_int16_t const   )66,
        (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )47,
        (flex_int16_t const   )80,      (flex_int16_t const   )68,      (flex_int16_t const   )70,      (flex_int16_t const   )70,
        (flex_int16_t const   )70,      (flex_int16_t const   )147,      (flex_int16_t const   )147,      (flex_int16_t const   )71,
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )274,
        (flex_int16_t const   )74,      (flex_int16_t const   )73,      (flex_int16_t const   )75,      (flex_int16_t const   )75,
        (flex_int16_t const   )75,      (flex_int16_t const   )69,      (flex_int16_t const   )74,      (flex_int16_t const   )97,
        (flex_int16_t const   )78,      (flex_int16_t const   )78,      (flex_int16_t const   )78,      (flex_int16_t const   )86,
        (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )117,      (flex_int16_t const   )97,
        (flex_int16_t const   )87,      (flex_int16_t const   )90,      (flex_int16_t const   )90,      (flex_int16_t const   )90,
        (flex_int16_t const   )151,      (flex_int16_t const   )98,      (flex_int16_t const   )91,      (flex_int16_t const   )88,
        (flex_int16_t const   )238,      (flex_int16_t const   )122,      (flex_int16_t const   )76,      (flex_int16_t const   )94,
        (flex_int16_t const   )94,      (flex_int16_t const   )94,      (flex_int16_t const   )98,      (flex_int16_t const   )89,
        (flex_int16_t const   )95,      (flex_int16_t const   )77,      (flex_int16_t const   )59,      (flex_int16_t const   )59,
        (flex_int16_t const   )59,      (flex_int16_t const   )92,      (flex_int16_t const   )93,      (flex_int16_t const   )60,
        (flex_int16_t const   )104,      (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )257,
        (flex_int16_t const   )106,      (flex_int16_t const   )250,      (flex_int16_t const   )247,      (flex_int16_t const   )96,
        (flex_int16_t const   )105,      (flex_int16_t const   )97,      (flex_int16_t const   )107,      (flex_int16_t const   )108,
        (flex_int16_t const   )79,      (flex_int16_t const   )99,      (flex_int16_t const   )100,      (flex_int16_t const   )101,
        (flex_int16_t const   )102,      (flex_int16_t const   )103,      (flex_int16_t const   )61,      (flex_int16_t const   )145,
        (flex_int16_t const   )145,      (flex_int16_t const   )145,      (flex_int16_t const   )99,      (flex_int16_t const   )100,
        (flex_int16_t const   )101,      (flex_int16_t const   )102,      (flex_int16_t const   )103,      (flex_int16_t const   )97,
        (flex_int16_t const   )62,      (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )110,
        (flex_int16_t const   )112,      (flex_int16_t const   )116,      (flex_int16_t const   )179,      (flex_int16_t const   )97,
        (flex_int16_t const   )111,      (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )207,
        (flex_int16_t const   )207,      (flex_int16_t const   )207,      (flex_int16_t const   )97,      (flex_int16_t const   )97,
        (flex_int16_t const   )81,      (flex_int16_t const   )82,      (flex_int16_t const   )83,      (flex_int16_t const   )84,
        (flex_int16_t const   )85,      (flex_int16_t const   )113,      (flex_int16_t const   )265,      (flex_int16_t const   )97,
        (flex_int16_t const   )114,      (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )115,
        (flex_int16_t const   )118,      (flex_int16_t const   )97,      (flex_int16_t const   )119,      (flex_int16_t const   )119,
        (flex_int16_t const   )119,      (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )120,
        (flex_int16_t const   )43,      (flex_int16_t const   )43,      (flex_int16_t const   )43,      (flex_int16_t const   )178,
        (flex_int16_t const   )181,      (flex_int16_t const   )44,      (flex_int16_t const   )70,      (flex_int16_t const   )70,
        (flex_int16_t const   )70,      (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )71,
        (flex_int16_t const   )264,      (flex_int16_t const   )45,      (flex_int16_t const   )119,      (flex_int16_t const   )119,
        (flex_int16_t const   )119,      (flex_int16_t const   )183,      (flex_int16_t const   )97,      (flex_int16_t const   )120,
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )80,
        (flex_int16_t const   )182,      (flex_int16_t const   )130,      (flex_int16_t const   )97,      (flex_int16_t const   )43,
        (flex_int16_t const   )43,      (flex_int16_t const   )43,      (flex_int16_t const   )263,      (flex_int16_t const   )46,
        (flex_int16_t const   )44,      (flex_int16_t const   )54,      (flex_int16_t const   )54,      (flex_int16_t const   )54,
        (flex_int16_t const   )262,      (flex_int16_t const   )238,      (flex_int16_t const   )55,      (flex_int16_t const   )97,
        (flex_int16_t const   )45,      (flex_int16_t const   )200,      (flex_int16_t const   )121,      (flex_int16_t const   )180,
        (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )97,
        (flex_int16_t const   )47,      (flex_int16_t const   )57,      (flex_int16_t const   )134,      (flex_int16_t const   )134,
        (flex_int16_t const   )134,      (flex_int16_t const   )259,      (flex_int16_t const   )97,      (flex_int16_t const   )135,
        (flex_int16_t const   )122,      (flex_int16_t const   )193,      (flex_int16_t const   )46,      (flex_int16_t const   )59,
        (flex_int16_t const   )59,      (flex_int16_t const   )59,      (flex_int16_t const   )97,      (flex_int16_t const   )246,
        (flex_int16_t const   )60,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,
        (flex_int16_t const   )245,      (flex_int16_t const   )172,      (flex_int16_t const   )64,      (flex_int16_t const   )65,
        (flex_int16_t const   )65,      (flex_int16_t const   )65,      (flex_int16_t const   )169,      (flex_int16_t const   )47,
        (flex_int16_t const   )66,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67,
        (flex_int16_t const   )167,      (flex_int16_t const   )164,      (flex_int16_t const   )68,      (flex_int16_t const   )141,
        (flex_int16_t const   )141,      (flex_int16_t const   )141,      (flex_int16_t const   )162,      (flex_int16_t const   )244,
        (flex_int16_t const   )142,      (flex_int16_t const   )70,      (flex_int16_t const   )70,      (flex_int16_t const   )70,
        (flex_int16_t const   )243,      (flex_int16_t const   )242,      (flex_int16_t const   )71,      (flex_int16_t const   )72,
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )241,      (flex_int16_t const   )146,
        (flex_int16_t const   )73,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,
        (flex_int16_t const   )74,      (flex_int16_t const   )97,      (flex_int16_t const   )78,      (flex_int16_t const   )78,
        (flex_int16_t const   )78,      (flex_int16_t const   )149,      (flex_int16_t const   )149,      (flex_int16_t const   )149,
        (flex_int16_t const   )151,      (flex_int16_t const   )188,      (flex_int16_t const   )150,      (flex_int16_t const   )152,
        (flex_int16_t const   )153,      (flex_int16_t const   )154,      (flex_int16_t const   )155,      (flex_int16_t const   )156,
        (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )151,
        (flex_int16_t const   )149,      (flex_int16_t const   )87,      (flex_int16_t const   )162,      (flex_int16_t const   )162,
        (flex_int16_t const   )162,      (flex_int16_t const   )141,      (flex_int16_t const   )200,      (flex_int16_t const   )163,
        (flex_int16_t const   )164,      (flex_int16_t const   )164,      (flex_int16_t const   )164,      (flex_int16_t const   )134,
        (flex_int16_t const   )129,      (flex_int16_t const   )165,      (flex_int16_t const   )90,      (flex_int16_t const   )90,
        (flex_int16_t const   )90,      (flex_int16_t const   )236,      (flex_int16_t const   )235,      (flex_int16_t const   )91,
        (flex_int16_t const   )167,      (flex_int16_t const   )167,      (flex_int16_t const   )167,      (flex_int16_t const   )234,
        (flex_int16_t const   )193,      (flex_int16_t const   )168,      (flex_int16_t const   )169,      (flex_int16_t const   )169,
        (flex_int16_t const   )169,      (flex_int16_t const   )119,      (flex_int16_t const   )221,      (flex_int16_t const   )170,
        (flex_int16_t const   )94,      (flex_int16_t const   )94,      (flex_int16_t const   )94,      (flex_int16_t const   )220,
        (flex_int16_t const   )97,      (flex_int16_t const   )95,      (flex_int16_t const   )172,      (flex_int16_t const   )172,
        (flex_int16_t const   )172,      (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )173,
        (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )97,
        (flex_int16_t const   )184,      (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )186,
        (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )97,
        (flex_int16_t const   )185,      (flex_int16_t const   )97,      (flex_int16_t const   )190,      (flex_int16_t const   )97,
        (flex_int16_t const   )97,      (flex_int16_t const   )189,      (flex_int16_t const   )187,      (flex_int16_t const   )191,
        (flex_int16_t const   )119,      (flex_int16_t const   )119,      (flex_int16_t const   )119,      (flex_int16_t const   )97,
        (flex_int16_t const   )97,      (flex_int16_t const   )120,      (flex_int16_t const   )193,      (flex_int16_t const   )193,
        (flex_int16_t const   )193,      (flex_int16_t const   )172,      (flex_int16_t const   )94,      (flex_int16_t const   )194,
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )169,
        (flex_int16_t const   )167,      (flex_int16_t const   )130,      (flex_int16_t const   )134,      (flex_int16_t const   )134,
        (flex_int16_t const   )134,      (flex_int16_t const   )90,      (flex_int16_t const   )164,      (flex_int16_t const   )135,
        (flex_int16_t const   )200,      (flex_int16_t const   )200,      (flex_int16_t const   )201,      (flex_int16_t const   )162,
        (flex_int16_t const   )86,      (flex_int16_t const   )202,      (flex_int16_t const   )141,      (flex_int16_t const   )141,
        (flex_int16_t const   )141,      (flex_int16_t const   )214,      (flex_int16_t const   )205,      (flex_int16_t const   )142,
        (flex_int16_t const   )206,      (flex_int16_t const   )206,      (flex_int16_t const   )206,      (flex_int16_t const   )149,
        (flex_int16_t const   )149,      (flex_int16_t const   )149,      (flex_int16_t const   )213,      (flex_int16_t const   )80,
        (flex_int16_t const   )150,      (flex_int16_t const   )152,      (flex_int16_t const   )153,      (flex_int16_t const   )154,
        (flex_int16_t const   )155,      (flex_int16_t const   )156,      (flex_int16_t const   )162,      (flex_int16_t const   )162,
        (flex_int16_t const   )162,      (flex_int16_t const   )80,      (flex_int16_t const   )212,      (flex_int16_t const   )163,
        (flex_int16_t const   )164,      (flex_int16_t const   )164,      (flex_int16_t const   )164,      (flex_int16_t const   )211,
        (flex_int16_t const   )210,      (flex_int16_t const   )165,      (flex_int16_t const   )167,      (flex_int16_t const   )167,
        (flex_int16_t const   )167,      (flex_int16_t const   )209,      (flex_int16_t const   )151,      (flex_int16_t const   )168,
        (flex_int16_t const   )169,      (flex_int16_t const   )169,      (flex_int16_t const   )169,      (flex_int16_t const   )203,
        (flex_int16_t const   )149,      (flex_int16_t const   )170,      (flex_int16_t const   )172,      (flex_int16_t const   )172,
        (flex_int16_t const   )172,      (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )173,
        (flex_int16_t const   )222,      (flex_int16_t const   )97,      (flex_int16_t const   )72,      (flex_int16_t const   )97,
        (flex_int16_t const   )70,      (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )97,
        (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )224,      (flex_int16_t const   )97,
        (flex_int16_t const   )223,      (flex_int16_t const   )97,      (flex_int16_t const   )141,      (flex_int16_t const   )97,
        (flex_int16_t const   )97,      (flex_int16_t const   )67,      (flex_int16_t const   )225,      (flex_int16_t const   )97,
        (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )226,      (flex_int16_t const   )97,
        (flex_int16_t const   )227,      (flex_int16_t const   )228,      (flex_int16_t const   )229,      (flex_int16_t const   )97,
        (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )97,
        (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )65,      (flex_int16_t const   )97,
        (flex_int16_t const   )232,      (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )63,
        (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )97,
        (flex_int16_t const   )231,      (flex_int16_t const   )59,      (flex_int16_t const   )230,      (flex_int16_t const   )193,
        (flex_int16_t const   )193,      (flex_int16_t const   )193,      (flex_int16_t const   )97,      (flex_int16_t const   )134,
        (flex_int16_t const   )194,      (flex_int16_t const   )200,      (flex_int16_t const   )200,      (flex_int16_t const   )200,
        (flex_int16_t const   )249,      (flex_int16_t const   )56,      (flex_int16_t const   )202,      (flex_int16_t const   )200,
        (flex_int16_t const   )200,      (flex_int16_t const   )201,      (flex_int16_t const   )54,      (flex_int16_t const   )129,
        (flex_int16_t const   )202,      (flex_int16_t const   )238,      (flex_int16_t const   )238,      (flex_int16_t const   )238,
        (flex_int16_t const   )197,      (flex_int16_t const   )43,      (flex_int16_t const   )239,      (flex_int16_t const   )240,
        (flex_int16_t const   )240,      (flex_int16_t const   )240,      (flex_int16_t const   )205,      (flex_int16_t const   )196,
        (flex_int16_t const   )206,      (flex_int16_t const   )206,      (flex_int16_t const   )206,      (flex_int16_t const   )205,
        (flex_int16_t const   )97,      (flex_int16_t const   )207,      (flex_int16_t const   )207,      (flex_int16_t const   )207,
        (flex_int16_t const   )247,      (flex_int16_t const   )247,      (flex_int16_t const   )247,      (flex_int16_t const   )195,
        (flex_int16_t const   )97,      (flex_int16_t const   )248,      (flex_int16_t const   )250,      (flex_int16_t const   )250,
        (flex_int16_t const   )250,      (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )251,
        (flex_int16_t const   )252,      (flex_int16_t const   )97,      (flex_int16_t const   )273,      (flex_int16_t const   )273,
        (flex_int16_t const   )273,      (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )97,
        (flex_int16_t const   )122,      (flex_int16_t const   )97,      (flex_int16_t const   )203,      (flex_int16_t const   )253,
        (flex_int16_t const   )254,      (flex_int16_t const   )122,      (flex_int16_t const   )119,      (flex_int16_t const   )97,
        (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )177,
        (flex_int16_t const   )176,      (flex_int16_t const   )255,      (flex_int16_t const   )97,      (flex_int16_t const   )175,
        (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )257,
        (flex_int16_t const   )257,      (flex_int16_t const   )257,      (flex_int16_t const   )97,      (flex_int16_t const   )256,
        (flex_int16_t const   )258,      (flex_int16_t const   )250,      (flex_int16_t const   )250,      (flex_int16_t const   )250,
        (flex_int16_t const   )174,      (flex_int16_t const   )97,      (flex_int16_t const   )251,      (flex_int16_t const   )238,
        (flex_int16_t const   )238,      (flex_int16_t const   )238,      (flex_int16_t const   )97,      (flex_int16_t const   )94,
        (flex_int16_t const   )239,      (flex_int16_t const   )97,      (flex_int16_t const   )240,      (flex_int16_t const   )240,
        (flex_int16_t const   )240,      (flex_int16_t const   )247,      (flex_int16_t const   )247,      (flex_int16_t const   )247,
        (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )248,      (flex_int16_t const   )97,
        (flex_int16_t const   )261,      (flex_int16_t const   )250,      (flex_int16_t const   )250,      (flex_int16_t const   )250,
        (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )251,      (flex_int16_t const   )97,
        (flex_int16_t const   )97,      (flex_int16_t const   )270,      (flex_int16_t const   )269,      (flex_int16_t const   )268,
        (flex_int16_t const   )97,      (flex_int16_t const   )257,      (flex_int16_t const   )257,      (flex_int16_t const   )257,
        (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )258,      (flex_int16_t const   )97,
        (flex_int16_t const   )97,      (flex_int16_t const   )275,      (flex_int16_t const   )271,      (flex_int16_t const   )97,
        (flex_int16_t const   )90,      (flex_int16_t const   )97,      (flex_int16_t const   )86,      (flex_int16_t const   )97,
        (flex_int16_t const   )160,      (flex_int16_t const   )97,      (flex_int16_t const   )159,      (flex_int16_t const   )97,
        (flex_int16_t const   )273,      (flex_int16_t const   )273,      (flex_int16_t const   )273,      (flex_int16_t const   )276,
        (flex_int16_t const   )97,      (flex_int16_t const   )277,      (flex_int16_t const   )278,      (flex_int16_t const   )278,
        (flex_int16_t const   )278,      (flex_int16_t const   )158,      (flex_int16_t const   )97,      (flex_int16_t const   )157,
        (flex_int16_t const   )97,      (flex_int16_t const   )279,      (flex_int16_t const   )80,      (flex_int16_t const   )280,
        (flex_int16_t const   )280,      (flex_int16_t const   )281,      (flex_int16_t const   )97,      (flex_int16_t const   )278,
        (flex_int16_t const   )278,      (flex_int16_t const   )278,      (flex_int16_t const   )282,      (flex_int16_t const   )97,
        (flex_int16_t const   )284,      (flex_int16_t const   )284,      (flex_int16_t const   )284,      (flex_int16_t const   )285,
        (flex_int16_t const   )285,      (flex_int16_t const   )285,      (flex_int16_t const   )283,      (flex_int16_t const   )97,
        (flex_int16_t const   )286,      (flex_int16_t const   )286,      (flex_int16_t const   )286,      (flex_int16_t const   )284,
        (flex_int16_t const   )284,      (flex_int16_t const   )284,      (flex_int16_t const   )287,      (flex_int16_t const   )280,
        (flex_int16_t const   )280,      (flex_int16_t const   )72,      (flex_int16_t const   )70,      (flex_int16_t const   )285,
        (flex_int16_t const   )285,      (flex_int16_t const   )285,      (flex_int16_t const   )280,      (flex_int16_t const   )280,
        (flex_int16_t const   )281,      (flex_int16_t const   )67,      (flex_int16_t const   )286,      (flex_int16_t const   )286,
        (flex_int16_t const   )286,      (flex_int16_t const   )65,      (flex_int16_t const   )283,      (flex_int16_t const   )288,
        (flex_int16_t const   )288,      (flex_int16_t const   )288,      (flex_int16_t const   )288,      (flex_int16_t const   )288,
        (flex_int16_t const   )288,      (flex_int16_t const   )283,      (flex_int16_t const   )49,      (flex_int16_t const   )49,
        (flex_int16_t const   )49,      (flex_int16_t const   )49,      (flex_int16_t const   )49,      (flex_int16_t const   )49,
        (flex_int16_t const   )52,      (flex_int16_t const   )52,      (flex_int16_t const   )52,      (flex_int16_t const   )52,
        (flex_int16_t const   )52,      (flex_int16_t const   )52,      (flex_int16_t const   )80,      (flex_int16_t const   )63,
        (flex_int16_t const   )80,      (flex_int16_t const   )80,      (flex_int16_t const   )80,      (flex_int16_t const   )97,
        (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )127,
        (flex_int16_t const   )127,      (flex_int16_t const   )127,      (flex_int16_t const   )127,      (flex_int16_t const   )127,
        (flex_int16_t const   )127,      (flex_int16_t const   )132,      (flex_int16_t const   )132,      (flex_int16_t const   )132,
        (flex_int16_t const   )132,      (flex_int16_t const   )132,      (flex_int16_t const   )132,      (flex_int16_t const   )133,
        (flex_int16_t const   )133,      (flex_int16_t const   )133,      (flex_int16_t const   )133,      (flex_int16_t const   )133,
        (flex_int16_t const   )133,      (flex_int16_t const   )136,      (flex_int16_t const   )136,      (flex_int16_t const   )136,
        (flex_int16_t const   )136,      (flex_int16_t const   )136,      (flex_int16_t const   )136,      (flex_int16_t const   )138,
        (flex_int16_t const   )138,      (flex_int16_t const   )138,      (flex_int16_t const   )138,      (flex_int16_t const   )138,
        (flex_int16_t const   )138,      (flex_int16_t const   )139,      (flex_int16_t const   )139,      (flex_int16_t const   )139,
        (flex_int16_t const   )139,      (flex_int16_t const   )139,      (flex_int16_t const   )139,      (flex_int16_t const   )140,
        (flex_int16_t const   )140,      (flex_int16_t const   )140,      (flex_int16_t const   )140,      (flex_int16_t const   )140,
        (flex_int16_t const   )140,      (flex_int16_t const   )143,      (flex_int16_t const   )143,      (flex_int16_t const   )143,
        (flex_int16_t const   )143,      (flex_int16_t const   )143,      (flex_int16_t const   )143,      (flex_int16_t const   )144,
        (flex_int16_t const   )144,      (flex_int16_t const   )144,      (flex_int16_t const   )144,      (flex_int16_t const   )144,
        (flex_int16_t const   )144,      (flex_int16_t const   )148,      (flex_int16_t const   )137,      (flex_int16_t const   )148,
        (flex_int16_t const   )151,      (flex_int16_t const   )59,      (flex_int16_t const   )151,      (flex_int16_t const   )151,
        (flex_int16_t const   )161,      (flex_int16_t const   )161,      (flex_int16_t const   )161,      (flex_int16_t const   )161,
        (flex_int16_t const   )161,      (flex_int16_t const   )161,      (flex_int16_t const   )166,      (flex_int16_t const   )166,
        (flex_int16_t const   )166,      (flex_int16_t const   )166,      (flex_int16_t const   )166,      (flex_int16_t const   )166,
        (flex_int16_t const   )171,      (flex_int16_t const   )171,      (flex_int16_t const   )171,      (flex_int16_t const   )171,
        (flex_int16_t const   )171,      (flex_int16_t const   )171,      (flex_int16_t const   )192,      (flex_int16_t const   )192,
        (flex_int16_t const   )192,      (flex_int16_t const   )192,      (flex_int16_t const   )192,      (flex_int16_t const   )192,
        (flex_int16_t const   )198,      (flex_int16_t const   )198,      (flex_int16_t const   )198,      (flex_int16_t const   )198,
        (flex_int16_t const   )198,      (flex_int16_t const   )198,      (flex_int16_t const   )199,      (flex_int16_t const   )199,
        (flex_int16_t const   )199,      (flex_int16_t const   )199,      (flex_int16_t const   )199,      (flex_int16_t const   )199,
        (flex_int16_t const   )204,      (flex_int16_t const   )204,      (flex_int16_t const   )204,      (flex_int16_t const   )204,
        (flex_int16_t const   )204,      (flex_int16_t const   )204,      (flex_int16_t const   )208,      (flex_int16_t const   )208,
        (flex_int16_t const   )208,      (flex_int16_t const   )208,      (flex_int16_t const   )208,      (flex_int16_t const   )208,
        (flex_int16_t const   )215,      (flex_int16_t const   )215,      (flex_int16_t const   )215,      (flex_int16_t const   )215,
        (flex_int16_t const   )215,      (flex_int16_t const   )215,      (flex_int16_t const   )216,      (flex_int16_t const   )216,
        (flex_int16_t const   )216,      (flex_int16_t const   )216,      (flex_int16_t const   )216,      (flex_int16_t const   )216,
        (flex_int16_t const   )217,      (flex_int16_t const   )217,      (flex_int16_t const   )217,      (flex_int16_t const   )217,
        (flex_int16_t const   )217,      (flex_int16_t const   )217,      (flex_int16_t const   )218,      (flex_int16_t const   )218,
        (flex_int16_t const   )218,      (flex_int16_t const   )218,      (flex_int16_t const   )218,      (flex_int16_t const   )218,
        (flex_int16_t const   )219,      (flex_int16_t const   )219,      (flex_int16_t const   )219,      (flex_int16_t const   )219,
        (flex_int16_t const   )219,      (flex_int16_t const   )219,      (flex_int16_t const   )233,      (flex_int16_t const   )233,
        (flex_int16_t const   )233,      (flex_int16_t const   )233,      (flex_int16_t const   )233,      (flex_int16_t const   )233,
        (flex_int16_t const   )237,      (flex_int16_t const   )237,      (flex_int16_t const   )237,      (flex_int16_t const   )237,
        (flex_int16_t const   )237,      (flex_int16_t const   )237,      (flex_int16_t const   )260,      (flex_int16_t const   )260,
        (flex_int16_t const   )260,      (flex_int16_t const   )260,      (flex_int16_t const   )260,      (flex_int16_t const   )260,
        (flex_int16_t const   )266,      (flex_int16_t const   )266,      (flex_int16_t const   )266,      (flex_int16_t const   )266,
        (flex_int16_t const   )266,      (flex_int16_t const   )266,      (flex_int16_t const   )267,      (flex_int16_t const   )267,
        (flex_int16_t const   )267,      (flex_int16_t const   )267,      (flex_int16_t const   )267,      (flex_int16_t const   )267,
        (flex_int16_t const   )272,      (flex_int16_t const   )272,      (flex_int16_t const   )272,      (flex_int16_t const   )272,
        (flex_int16_t const   )272,      (flex_int16_t const   )272,      (flex_int16_t const   )56,      (flex_int16_t const   )54,
        (flex_int16_t const   )53,      (flex_int16_t const   )289,      (flex_int16_t const   )131,      (flex_int16_t const   )128,
        (flex_int16_t const   )43,      (flex_int16_t const   )126,      (flex_int16_t const   )125,      (flex_int16_t const   )124,
        (flex_int16_t const   )123,      (flex_int16_t const   )122,      (flex_int16_t const   )53,      (flex_int16_t const   )48,
        (flex_int16_t const   )289,      (flex_int16_t const   )3,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289};
static flex_int16_t const   yy_chk[1010]  =
  {      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,
        (flex_int16_t const   )1,      (flex_int16_t const   )5,      (flex_int16_t const   )5,      (flex_int16_t const   )5,
        (flex_int16_t const   )8,      (flex_int16_t const   )13,      (flex_int16_t const   )5,      (flex_int16_t const   )6,
        (flex_int16_t const   )6,      (flex_int16_t const   )6,      (flex_int16_t const   )49,      (flex_int16_t const   )30,
        (flex_int16_t const   )6,      (flex_int16_t const   )274,      (flex_int16_t const   )5,      (flex_int16_t const   )13,
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )30,
        (flex_int16_t const   )6,      (flex_int16_t const   )10,      (flex_int16_t const   )272,      (flex_int16_t const   )11,
        (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )267,      (flex_int16_t const   )8,
        (flex_int16_t const   )11,      (flex_int16_t const   )97,      (flex_int16_t const   )11,      (flex_int16_t const   )266,
        (flex_int16_t const   )5,      (flex_int16_t const   )49,      (flex_int16_t const   )12,      (flex_int16_t const   )12,
        (flex_int16_t const   )12,      (flex_int16_t const   )97,      (flex_int16_t const   )6,      (flex_int16_t const   )12,
        (flex_int16_t const   )14,      (flex_int16_t const   )14,      (flex_int16_t const   )14,      (flex_int16_t const   )76,
        (flex_int16_t const   )76,      (flex_int16_t const   )14,      (flex_int16_t const   )15,      (flex_int16_t const   )15,
        (flex_int16_t const   )15,      (flex_int16_t const   )5,      (flex_int16_t const   )265,      (flex_int16_t const   )15,
        (flex_int16_t const   )16,      (flex_int16_t const   )16,      (flex_int16_t const   )16,      (flex_int16_t const   )6,
        (flex_int16_t const   )264,      (flex_int16_t const   )16,      (flex_int16_t const   )17,      (flex_int16_t const   )17,
        (flex_int16_t const   )17,      (flex_int16_t const   )147,      (flex_int16_t const   )147,      (flex_int16_t const   )17,
        (flex_int16_t const   )18,      (flex_int16_t const   )18,      (flex_int16_t const   )18,      (flex_int16_t const   )263,
        (flex_int16_t const   )19,      (flex_int16_t const   )18,      (flex_int16_t const   )19,      (flex_int16_t const   )19,
        (flex_int16_t const   )19,      (flex_int16_t const   )16,      (flex_int16_t const   )20,      (flex_int16_t const   )35,
        (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )22,
        (flex_int16_t const   )22,      (flex_int16_t const   )22,      (flex_int16_t const   )35,      (flex_int16_t const   )35,
        (flex_int16_t const   )22,      (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )23,
        (flex_int16_t const   )262,      (flex_int16_t const   )26,      (flex_int16_t const   )23,      (flex_int16_t const   )22,
        (flex_int16_t const   )260,      (flex_int16_t const   )259,      (flex_int16_t const   )19,      (flex_int16_t const   )24,
        (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )27,      (flex_int16_t const   )22,
        (flex_int16_t const   )24,      (flex_int16_t const   )19,      (flex_int16_t const   )21,      (flex_int16_t const   )21,
        (flex_int16_t const   )21,      (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )21,
        (flex_int16_t const   )27,      (flex_int16_t const   )28,      (flex_int16_t const   )29,      (flex_int16_t const   )258,
        (flex_int16_t const   )28,      (flex_int16_t const   )251,      (flex_int16_t const   )248,      (flex_int16_t const   )24,
        (flex_int16_t const   )27,      (flex_int16_t const   )28,      (flex_int16_t const   )29,      (flex_int16_t const   )29,
        (flex_int16_t const   )21,      (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )26,
        (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )61,      (flex_int16_t const   )74,
        (flex_int16_t const   )74,      (flex_int16_t const   )74,      (flex_int16_t const   )27,      (flex_int16_t const   )27,
        (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )31,
        (flex_int16_t const   )61,      (flex_int16_t const   )32,      (flex_int16_t const   )34,      (flex_int16_t const   )31,
        (flex_int16_t const   )32,      (flex_int16_t const   )34,      (flex_int16_t const   )105,      (flex_int16_t const   )31,
        (flex_int16_t const   )31,      (flex_int16_t const   )32,      (flex_int16_t const   )34,      (flex_int16_t const   )146,
        (flex_int16_t const   )146,      (flex_int16_t const   )146,      (flex_int16_t const   )105,      (flex_int16_t const   )36,
        (flex_int16_t const   )21,      (flex_int16_t const   )21,      (flex_int16_t const   )21,      (flex_int16_t const   )21,
        (flex_int16_t const   )21,      (flex_int16_t const   )33,      (flex_int16_t const   )246,      (flex_int16_t const   )36,
        (flex_int16_t const   )33,      (flex_int16_t const   )104,      (flex_int16_t const   )107,      (flex_int16_t const   )33,
        (flex_int16_t const   )36,      (flex_int16_t const   )33,      (flex_int16_t const   )37,      (flex_int16_t const   )37,
        (flex_int16_t const   )37,      (flex_int16_t const   )104,      (flex_int16_t const   )107,      (flex_int16_t const   )37,
        (flex_int16_t const   )43,      (flex_int16_t const   )43,      (flex_int16_t const   )43,      (flex_int16_t const   )104,
        (flex_int16_t const   )107,      (flex_int16_t const   )43,      (flex_int16_t const   )45,      (flex_int16_t const   )45,
        (flex_int16_t const   )45,      (flex_int16_t const   )109,      (flex_int16_t const   )245,      (flex_int16_t const   )45,
        (flex_int16_t const   )244,      (flex_int16_t const   )43,      (flex_int16_t const   )47,      (flex_int16_t const   )47,
        (flex_int16_t const   )47,      (flex_int16_t const   )109,      (flex_int16_t const   )108,      (flex_int16_t const   )47,
        (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )243,
        (flex_int16_t const   )108,      (flex_int16_t const   )48,      (flex_int16_t const   )108,      (flex_int16_t const   )53,
        (flex_int16_t const   )53,      (flex_int16_t const   )53,      (flex_int16_t const   )242,      (flex_int16_t const   )43,
        (flex_int16_t const   )53,      (flex_int16_t const   )54,      (flex_int16_t const   )54,      (flex_int16_t const   )54,
        (flex_int16_t const   )241,      (flex_int16_t const   )239,      (flex_int16_t const   )54,      (flex_int16_t const   )106,
        (flex_int16_t const   )53,      (flex_int16_t const   )237,      (flex_int16_t const   )37,      (flex_int16_t const   )106,
        (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )106,
        (flex_int16_t const   )43,      (flex_int16_t const   )56,      (flex_int16_t const   )58,      (flex_int16_t const   )58,
        (flex_int16_t const   )58,      (flex_int16_t const   )235,      (flex_int16_t const   )110,      (flex_int16_t const   )58,
        (flex_int16_t const   )234,      (flex_int16_t const   )233,      (flex_int16_t const   )53,      (flex_int16_t const   )59,
        (flex_int16_t const   )59,      (flex_int16_t const   )59,      (flex_int16_t const   )110,      (flex_int16_t const   )221,
        (flex_int16_t const   )59,      (flex_int16_t const   )63,      (flex_int16_t const   )63,      (flex_int16_t const   )63,
        (flex_int16_t const   )220,      (flex_int16_t const   )219,      (flex_int16_t const   )63,      (flex_int16_t const   )65,
        (flex_int16_t const   )65,      (flex_int16_t const   )65,      (flex_int16_t const   )218,      (flex_int16_t const   )53,
        (flex_int16_t const   )65,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67,
        (flex_int16_t const   )217,      (flex_int16_t const   )216,      (flex_int16_t const   )67,      (flex_int16_t const   )69,
        (flex_int16_t const   )69,      (flex_int16_t const   )69,      (flex_int16_t const   )215,      (flex_int16_t const   )214,
        (flex_int16_t const   )69,      (flex_int16_t const   )70,      (flex_int16_t const   )70,      (flex_int16_t const   )70,
        (flex_int16_t const   )213,      (flex_int16_t const   )212,      (flex_int16_t const   )70,      (flex_int16_t const   )72,
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )211,      (flex_int16_t const   )75,
        (flex_int16_t const   )72,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,
        (flex_int16_t const   )78,      (flex_int16_t const   )115,      (flex_int16_t const   )78,      (flex_int16_t const   )78,
        (flex_int16_t const   )78,      (flex_int16_t const   )79,      (flex_int16_t const   )79,      (flex_int16_t const   )79,
        (flex_int16_t const   )210,      (flex_int16_t const   )115,      (flex_int16_t const   )79,      (flex_int16_t const   )80,
        (flex_int16_t const   )80,      (flex_int16_t const   )80,      (flex_int16_t const   )80,      (flex_int16_t const   )80,
        (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )86,      (flex_int16_t const   )209,
        (flex_int16_t const   )208,      (flex_int16_t const   )86,      (flex_int16_t const   )88,      (flex_int16_t const   )88,
        (flex_int16_t const   )88,      (flex_int16_t const   )204,      (flex_int16_t const   )202,      (flex_int16_t const   )88,
        (flex_int16_t const   )89,      (flex_int16_t const   )89,      (flex_int16_t const   )89,      (flex_int16_t const   )199,
        (flex_int16_t const   )198,      (flex_int16_t const   )89,      (flex_int16_t const   )90,      (flex_int16_t const   )90,
        (flex_int16_t const   )90,      (flex_int16_t const   )197,      (flex_int16_t const   )196,      (flex_int16_t const   )90,
        (flex_int16_t const   )92,      (flex_int16_t const   )92,      (flex_int16_t const   )92,      (flex_int16_t const   )195,
        (flex_int16_t const   )194,      (flex_int16_t const   )92,      (flex_int16_t const   )93,      (flex_int16_t const   )93,
        (flex_int16_t const   )93,      (flex_int16_t const   )192,      (flex_int16_t const   )177,      (flex_int16_t const   )93,
        (flex_int16_t const   )94,      (flex_int16_t const   )94,      (flex_int16_t const   )94,      (flex_int16_t const   )176,
        (flex_int16_t const   )111,      (flex_int16_t const   )94,      (flex_int16_t const   )96,      (flex_int16_t const   )96,
        (flex_int16_t const   )96,      (flex_int16_t const   )112,      (flex_int16_t const   )113,      (flex_int16_t const   )96,
        (flex_int16_t const   )111,      (flex_int16_t const   )114,      (flex_int16_t const   )116,      (flex_int16_t const   )118,
        (flex_int16_t const   )111,      (flex_int16_t const   )112,      (flex_int16_t const   )113,      (flex_int16_t const   )113,
        (flex_int16_t const   )117,      (flex_int16_t const   )114,      (flex_int16_t const   )116,      (flex_int16_t const   )118,
        (flex_int16_t const   )112,      (flex_int16_t const   )175,      (flex_int16_t const   )117,      (flex_int16_t const   )122,
        (flex_int16_t const   )117,      (flex_int16_t const   )116,      (flex_int16_t const   )114,      (flex_int16_t const   )118,
        (flex_int16_t const   )119,      (flex_int16_t const   )119,      (flex_int16_t const   )119,      (flex_int16_t const   )122,
        (flex_int16_t const   )174,      (flex_int16_t const   )119,      (flex_int16_t const   )121,      (flex_int16_t const   )121,
        (flex_int16_t const   )121,      (flex_int16_t const   )173,      (flex_int16_t const   )171,      (flex_int16_t const   )121,
        (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )129,      (flex_int16_t const   )170,
        (flex_int16_t const   )168,      (flex_int16_t const   )129,      (flex_int16_t const   )134,      (flex_int16_t const   )134,
        (flex_int16_t const   )134,      (flex_int16_t const   )166,      (flex_int16_t const   )165,      (flex_int16_t const   )134,
        (flex_int16_t const   )137,      (flex_int16_t const   )137,      (flex_int16_t const   )137,      (flex_int16_t const   )163,
        (flex_int16_t const   )161,      (flex_int16_t const   )137,      (flex_int16_t const   )141,      (flex_int16_t const   )141,
        (flex_int16_t const   )141,      (flex_int16_t const   )160,      (flex_int16_t const   )145,      (flex_int16_t const   )141,
        (flex_int16_t const   )145,      (flex_int16_t const   )145,      (flex_int16_t const   )145,      (flex_int16_t const   )149,
        (flex_int16_t const   )149,      (flex_int16_t const   )149,      (flex_int16_t const   )159,      (flex_int16_t const   )158,
        (flex_int16_t const   )149,      (flex_int16_t const   )151,      (flex_int16_t const   )151,      (flex_int16_t const   )151,
        (flex_int16_t const   )151,      (flex_int16_t const   )151,      (flex_int16_t const   )162,      (flex_int16_t const   )162,
        (flex_int16_t const   )162,      (flex_int16_t const   )157,      (flex_int16_t const   )156,      (flex_int16_t const   )162,
        (flex_int16_t const   )164,      (flex_int16_t const   )164,      (flex_int16_t const   )164,      (flex_int16_t const   )155,
        (flex_int16_t const   )154,      (flex_int16_t const   )164,      (flex_int16_t const   )167,      (flex_int16_t const   )167,
        (flex_int16_t const   )167,      (flex_int16_t const   )153,      (flex_int16_t const   )152,      (flex_int16_t const   )167,
        (flex_int16_t const   )169,      (flex_int16_t const   )169,      (flex_int16_t const   )169,      (flex_int16_t const   )137,
        (flex_int16_t const   )150,      (flex_int16_t const   )169,      (flex_int16_t const   )172,      (flex_int16_t const   )172,
        (flex_int16_t const   )172,      (flex_int16_t const   )178,      (flex_int16_t const   )179,      (flex_int16_t const   )172,
        (flex_int16_t const   )178,      (flex_int16_t const   )180,      (flex_int16_t const   )144,      (flex_int16_t const   )182,
        (flex_int16_t const   )143,      (flex_int16_t const   )178,      (flex_int16_t const   )179,      (flex_int16_t const   )181,
        (flex_int16_t const   )183,      (flex_int16_t const   )180,      (flex_int16_t const   )181,      (flex_int16_t const   )182,
        (flex_int16_t const   )179,      (flex_int16_t const   )184,      (flex_int16_t const   )142,      (flex_int16_t const   )181,
        (flex_int16_t const   )183,      (flex_int16_t const   )140,      (flex_int16_t const   )182,      (flex_int16_t const   )187,
        (flex_int16_t const   )185,      (flex_int16_t const   )184,      (flex_int16_t const   )183,      (flex_int16_t const   )186,
        (flex_int16_t const   )184,      (flex_int16_t const   )185,      (flex_int16_t const   )186,      (flex_int16_t const   )187,
        (flex_int16_t const   )185,      (flex_int16_t const   )188,      (flex_int16_t const   )189,      (flex_int16_t const   )186,
        (flex_int16_t const   )190,      (flex_int16_t const   )191,      (flex_int16_t const   )139,      (flex_int16_t const   )225,
        (flex_int16_t const   )191,      (flex_int16_t const   )188,      (flex_int16_t const   )189,      (flex_int16_t const   )138,
        (flex_int16_t const   )190,      (flex_int16_t const   )191,      (flex_int16_t const   )223,      (flex_int16_t const   )225,
        (flex_int16_t const   )190,      (flex_int16_t const   )136,      (flex_int16_t const   )189,      (flex_int16_t const   )193,
        (flex_int16_t const   )193,      (flex_int16_t const   )193,      (flex_int16_t const   )223,      (flex_int16_t const   )135,
        (flex_int16_t const   )193,      (flex_int16_t const   )200,      (flex_int16_t const   )200,      (flex_int16_t const   )200,
        (flex_int16_t const   )223,      (flex_int16_t const   )133,      (flex_int16_t const   )200,      (flex_int16_t const   )201,
        (flex_int16_t const   )201,      (flex_int16_t const   )201,      (flex_int16_t const   )132,      (flex_int16_t const   )130,
        (flex_int16_t const   )201,      (flex_int16_t const   )203,      (flex_int16_t const   )203,      (flex_int16_t const   )203,
        (flex_int16_t const   )128,      (flex_int16_t const   )127,      (flex_int16_t const   )203,      (flex_int16_t const   )205,
        (flex_int16_t const   )205,      (flex_int16_t const   )205,      (flex_int16_t const   )206,      (flex_int16_t const   )126,
        (flex_int16_t const   )206,      (flex_int16_t const   )206,      (flex_int16_t const   )206,      (flex_int16_t const   )207,
        (flex_int16_t const   )232,      (flex_int16_t const   )207,      (flex_int16_t const   )207,      (flex_int16_t const   )207,
        (flex_int16_t const   )222,      (flex_int16_t const   )222,      (flex_int16_t const   )222,      (flex_int16_t const   )125,
        (flex_int16_t const   )232,      (flex_int16_t const   )222,      (flex_int16_t const   )224,      (flex_int16_t const   )224,
        (flex_int16_t const   )224,      (flex_int16_t const   )226,      (flex_int16_t const   )227,      (flex_int16_t const   )224,
        (flex_int16_t const   )226,      (flex_int16_t const   )228,      (flex_int16_t const   )261,      (flex_int16_t const   )261,
        (flex_int16_t const   )261,      (flex_int16_t const   )226,      (flex_int16_t const   )227,      (flex_int16_t const   )229,
        (flex_int16_t const   )124,      (flex_int16_t const   )228,      (flex_int16_t const   )201,      (flex_int16_t const   )227,
        (flex_int16_t const   )228,      (flex_int16_t const   )123,      (flex_int16_t const   )120,      (flex_int16_t const   )229,
        (flex_int16_t const   )222,      (flex_int16_t const   )249,      (flex_int16_t const   )230,      (flex_int16_t const   )103,
        (flex_int16_t const   )102,      (flex_int16_t const   )229,      (flex_int16_t const   )224,      (flex_int16_t const   )101,
        (flex_int16_t const   )222,      (flex_int16_t const   )249,      (flex_int16_t const   )230,      (flex_int16_t const   )231,
        (flex_int16_t const   )231,      (flex_int16_t const   )231,      (flex_int16_t const   )224,      (flex_int16_t const   )230,
        (flex_int16_t const   )231,      (flex_int16_t const   )236,      (flex_int16_t const   )236,      (flex_int16_t const   )236,
        (flex_int16_t const   )100,      (flex_int16_t const   )252,      (flex_int16_t const   )236,      (flex_int16_t const   )238,
        (flex_int16_t const   )238,      (flex_int16_t const   )238,      (flex_int16_t const   )99,      (flex_int16_t const   )95,
        (flex_int16_t const   )238,      (flex_int16_t const   )252,      (flex_int16_t const   )240,      (flex_int16_t const   )240,
        (flex_int16_t const   )240,      (flex_int16_t const   )247,      (flex_int16_t const   )247,      (flex_int16_t const   )247,
        (flex_int16_t const   )253,      (flex_int16_t const   )255,      (flex_int16_t const   )247,      (flex_int16_t const   )231,
        (flex_int16_t const   )240,      (flex_int16_t const   )250,      (flex_int16_t const   )250,      (flex_int16_t const   )250,
        (flex_int16_t const   )253,      (flex_int16_t const   )255,      (flex_int16_t const   )250,      (flex_int16_t const   )231,
        (flex_int16_t const   )254,      (flex_int16_t const   )255,      (flex_int16_t const   )254,      (flex_int16_t const   )253,
        (flex_int16_t const   )256,      (flex_int16_t const   )257,      (flex_int16_t const   )257,      (flex_int16_t const   )257,
        (flex_int16_t const   )254,      (flex_int16_t const   )268,      (flex_int16_t const   )257,      (flex_int16_t const   )269,
        (flex_int16_t const   )256,      (flex_int16_t const   )270,      (flex_int16_t const   )256,      (flex_int16_t const   )271,
        (flex_int16_t const   )91,      (flex_int16_t const   )268,      (flex_int16_t const   )87,      (flex_int16_t const   )269,
        (flex_int16_t const   )85,      (flex_int16_t const   )270,      (flex_int16_t const   )84,      (flex_int16_t const   )271,
        (flex_int16_t const   )273,      (flex_int16_t const   )273,      (flex_int16_t const   )273,      (flex_int16_t const   )273,
        (flex_int16_t const   )275,      (flex_int16_t const   )275,      (flex_int16_t const   )276,      (flex_int16_t const   )276,
        (flex_int16_t const   )276,      (flex_int16_t const   )83,      (flex_int16_t const   )277,      (flex_int16_t const   )82,
        (flex_int16_t const   )275,      (flex_int16_t const   )277,      (flex_int16_t const   )81,      (flex_int16_t const   )278,
        (flex_int16_t const   )278,      (flex_int16_t const   )278,      (flex_int16_t const   )277,      (flex_int16_t const   )278,
        (flex_int16_t const   )278,      (flex_int16_t const   )278,      (flex_int16_t const   )278,      (flex_int16_t const   )279,
        (flex_int16_t const   )280,      (flex_int16_t const   )280,      (flex_int16_t const   )280,      (flex_int16_t const   )281,
        (flex_int16_t const   )281,      (flex_int16_t const   )281,      (flex_int16_t const   )278,      (flex_int16_t const   )279,
        (flex_int16_t const   )282,      (flex_int16_t const   )282,      (flex_int16_t const   )282,      (flex_int16_t const   )284,
        (flex_int16_t const   )284,      (flex_int16_t const   )284,      (flex_int16_t const   )284,      (flex_int16_t const   )285,
        (flex_int16_t const   )285,      (flex_int16_t const   )73,      (flex_int16_t const   )71,      (flex_int16_t const   )285,
        (flex_int16_t const   )285,      (flex_int16_t const   )285,      (flex_int16_t const   )286,      (flex_int16_t const   )286,
        (flex_int16_t const   )286,      (flex_int16_t const   )68,      (flex_int16_t const   )286,      (flex_int16_t const   )286,
        (flex_int16_t const   )286,      (flex_int16_t const   )66,      (flex_int16_t const   )285,      (flex_int16_t const   )287,
        (flex_int16_t const   )287,      (flex_int16_t const   )287,      (flex_int16_t const   )288,      (flex_int16_t const   )288,
        (flex_int16_t const   )288,      (flex_int16_t const   )286,      (flex_int16_t const   )290,      (flex_int16_t const   )290,
        (flex_int16_t const   )290,      (flex_int16_t const   )290,      (flex_int16_t const   )290,      (flex_int16_t const   )290,
        (flex_int16_t const   )291,      (flex_int16_t const   )291,      (flex_int16_t const   )291,      (flex_int16_t const   )291,
        (flex_int16_t const   )291,      (flex_int16_t const   )291,      (flex_int16_t const   )292,      (flex_int16_t const   )64,
        (flex_int16_t const   )292,      (flex_int16_t const   )292,      (flex_int16_t const   )292,      (flex_int16_t const   )293,
        (flex_int16_t const   )293,      (flex_int16_t const   )293,      (flex_int16_t const   )293,      (flex_int16_t const   )294,
        (flex_int16_t const   )294,      (flex_int16_t const   )294,      (flex_int16_t const   )294,      (flex_int16_t const   )294,
        (flex_int16_t const   )294,      (flex_int16_t const   )295,      (flex_int16_t const   )295,      (flex_int16_t const   )295,
        (flex_int16_t const   )295,      (flex_int16_t const   )295,      (flex_int16_t const   )295,      (flex_int16_t const   )296,
        (flex_int16_t const   )296,      (flex_int16_t const   )296,      (flex_int16_t const   )296,      (flex_int16_t const   )296,
        (flex_int16_t const   )296,      (flex_int16_t const   )297,      (flex_int16_t const   )297,      (flex_int16_t const   )297,
        (flex_int16_t const   )297,      (flex_int16_t const   )297,      (flex_int16_t const   )297,      (flex_int16_t const   )298,
        (flex_int16_t const   )298,      (flex_int16_t const   )298,      (flex_int16_t const   )298,      (flex_int16_t const   )298,
        (flex_int16_t const   )298,      (flex_int16_t const   )299,      (flex_int16_t const   )299,      (flex_int16_t const   )299,
        (flex_int16_t const   )299,      (flex_int16_t const   )299,      (flex_int16_t const   )299,      (flex_int16_t const   )300,
        (flex_int16_t const   )300,      (flex_int16_t const   )300,      (flex_int16_t const   )300,      (flex_int16_t const   )300,
        (flex_int16_t const   )300,      (flex_int16_t const   )301,      (flex_int16_t const   )301,      (flex_int16_t const   )301,
        (flex_int16_t const   )301,      (flex_int16_t const   )301,      (flex_int16_t const   )301,      (flex_int16_t const   )302,
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,
        (flex_int16_t const   )302,      (flex_int16_t const   )303,      (flex_int16_t const   )62,      (flex_int16_t const   )303,
        (flex_int16_t const   )304,      (flex_int16_t const   )60,      (flex_int16_t const   )304,      (flex_int16_t const   )304,
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )306,      (flex_int16_t const   )306,
        (flex_int16_t const   )306,      (flex_int16_t const   )306,      (flex_int16_t const   )306,      (flex_int16_t const   )306,
        (flex_int16_t const   )307,      (flex_int16_t const   )307,      (flex_int16_t const   )307,      (flex_int16_t const   )307,
        (flex_int16_t const   )307,      (flex_int16_t const   )307,      (flex_int16_t const   )308,      (flex_int16_t const   )308,
        (flex_int16_t const   )308,      (flex_int16_t const   )308,      (flex_int16_t const   )308,      (flex_int16_t const   )308,
        (flex_int16_t const   )309,      (flex_int16_t const   )309,      (flex_int16_t const   )309,      (flex_int16_t const   )309,
        (flex_int16_t const   )309,      (flex_int16_t const   )309,      (flex_int16_t const   )310,      (flex_int16_t const   )310,
        (flex_int16_t const   )310,      (flex_int16_t const   )310,      (flex_int16_t const   )310,      (flex_int16_t const   )310,
        (flex_int16_t const   )311,      (flex_int16_t const   )311,      (flex_int16_t const   )311,      (flex_int16_t const   )311,
        (flex_int16_t const   )311,      (flex_int16_t const   )311,      (flex_int16_t const   )312,      (flex_int16_t const   )312,
        (flex_int16_t const   )312,      (flex_int16_t const   )312,      (flex_int16_t const   )312,      (flex_int16_t const   )312,
        (flex_int16_t const   )313,      (flex_int16_t const   )313,      (flex_int16_t const   )313,      (flex_int16_t const   )313,
        (flex_int16_t const   )313,      (flex_int16_t const   )313,      (flex_int16_t const   )314,      (flex_int16_t const   )314,
        (flex_int16_t const   )314,      (flex_int16_t const   )314,      (flex_int16_t const   )314,      (flex_int16_t const   )314,
        (flex_int16_t const   )315,      (flex_int16_t const   )315,      (flex_int16_t const   )315,      (flex_int16_t const   )315,
        (flex_int16_t const   )315,      (flex_int16_t const   )315,      (flex_int16_t const   )316,      (flex_int16_t const   )316,
        (flex_int16_t const   )316,      (flex_int16_t const   )316,      (flex_int16_t const   )316,      (flex_int16_t const   )316,
        (flex_int16_t const   )317,      (flex_int16_t const   )317,      (flex_int16_t const   )317,      (flex_int16_t const   )317,
        (flex_int16_t const   )317,      (flex_int16_t const   )317,      (flex_int16_t const   )318,      (flex_int16_t const   )318,
        (flex_int16_t const   )318,      (flex_int16_t const   )318,      (flex_int16_t const   )318,      (flex_int16_t const   )318,
        (flex_int16_t const   )319,      (flex_int16_t const   )319,      (flex_int16_t const   )319,      (flex_int16_t const   )319,
        (flex_int16_t const   )319,      (flex_int16_t const   )319,      (flex_int16_t const   )320,      (flex_int16_t const   )320,
        (flex_int16_t const   )320,      (flex_int16_t const   )320,      (flex_int16_t const   )320,      (flex_int16_t const   )320,
        (flex_int16_t const   )321,      (flex_int16_t const   )321,      (flex_int16_t const   )321,      (flex_int16_t const   )321,
        (flex_int16_t const   )321,      (flex_int16_t const   )321,      (flex_int16_t const   )322,      (flex_int16_t const   )322,
        (flex_int16_t const   )322,      (flex_int16_t const   )322,      (flex_int16_t const   )322,      (flex_int16_t const   )322,
        (flex_int16_t const   )323,      (flex_int16_t const   )323,      (flex_int16_t const   )323,      (flex_int16_t const   )323,
        (flex_int16_t const   )323,      (flex_int16_t const   )323,      (flex_int16_t const   )57,      (flex_int16_t const   )55,
        (flex_int16_t const   )52,      (flex_int16_t const   )51,      (flex_int16_t const   )50,      (flex_int16_t const   )46,
        (flex_int16_t const   )44,      (flex_int16_t const   )42,      (flex_int16_t const   )41,      (flex_int16_t const   )40,
        (flex_int16_t const   )39,      (flex_int16_t const   )38,      (flex_int16_t const   )9,      (flex_int16_t const   )7,
        (flex_int16_t const   )3,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,      (flex_int16_t const   )289,
        (flex_int16_t const   )289,      (flex_int16_t const   )289};
static flex_int32_t const   yy_rule_can_match_eol[56]  =
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )0,      (flex_int32_t const   )1,
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )0,      (flex_int32_t const   )0,
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )1,
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )0,      (flex_int32_t const   )1,
        (flex_int32_t const   )1,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0,
        (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )0,
        (flex_int32_t const   )1,      (flex_int32_t const   )0,      (flex_int32_t const   )0,      (flex_int32_t const   )0};
static yy_state_type yy_last_accepting_state  ;
static char *yy_last_accepting_cpos  ;
int yy_flex_debug ;
int yy_flex_debug  =    0;
static int lex_return(parser_state *p , int c )
{


  {
  p->lineno = p->tline;
  p->tline = yylineno;
  return (c);
}
}
static int yy_init_globals(void) ;
int yylex_destroy(void) ;
int yyget_debug(void) ;
void yyset_debug(int _bdebug ) ;
FILE *yyget_in(void) ;
void yyset_in(FILE *_in_str ) ;
FILE *yyget_out(void) ;
void yyset_out(FILE *_out_str ) ;
int yyget_leng(void) ;
char *yyget_text(void) ;
int yyget_lineno(void) ;
void yyset_lineno(int _line_number ) ;
int yylex(YYSTYPE *lval , parser_state *p )
{
  yy_state_type yy_current_state ;
  char *yy_cp ;
  char *yy_bp ;
  int yy_act ;
  YY_BUFFER_STATE tmp ;
  YY_CHAR yy_c ;
  int yyl ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  long tmp___44 ;
  int tmp___45 ;
  double temp ;
  int tmp___46 ;
  unsigned long temp___0 ;
  int tmp___47 ;
  unsigned long temp___1 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  char c ;
  unsigned short const   **tmp___53 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___54 ;

  {
  if (! yy_init) {
    yy_init = 1;
    if (! yy_start) {
      yy_start = 1;
    }
    if (! yyin) {
      yyin = stdin;
    }
    if (! yyout) {
      yyout = stdout;
    }
    if (yy_buffer_stack) {
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    if (! tmp) {
      yyensure_buffer_stack();
      *(yy_buffer_stack + yy_buffer_stack_top) = yy_create_buffer(yyin, 16384);
    }
    yy_load_buffer_state();
  }
  while (1) {
    yy_cp = yy_c_buf_p;
    *yy_cp = yy_hold_char;
    yy_bp = yy_cp;
    yy_current_state = yy_start;
    yy_match:
    while (1) {
      yy_c = (YY_CHAR )yy_ec[(YY_CHAR )*yy_cp];
      if (yy_accept[yy_current_state]) {
        yy_last_accepting_state = yy_current_state;
        yy_last_accepting_cpos = yy_cp;
      }
      while ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state) {
        yy_current_state = (int )yy_def[yy_current_state];
        if (yy_current_state >= 290) {
          yy_c = (YY_CHAR )yy_meta[yy_c];
        }
      }
      yy_current_state = (yy_state_type )yy_nxt[(int const   )yy_base[yy_current_state] + (int const   )yy_c];
      yy_cp ++;
      if (! ((int const   )yy_base[yy_current_state] != 953)) {
        break;
      }
    }
    yy_find_action:
    yy_act = (int )yy_accept[yy_current_state];
    if (yy_act == 0) {
      yy_cp = yy_last_accepting_cpos;
      yy_current_state = yy_last_accepting_state;
      yy_act = (int )yy_accept[yy_current_state];
    }
    yytext = yy_bp;
    yyleng = (int )(yy_cp - yy_bp);
    yy_hold_char = *yy_cp;
    *yy_cp = (char )'\000';
    yy_c_buf_p = yy_cp;
    if (yy_act != 56) {
      if (yy_rule_can_match_eol[yy_act]) {
        yyl = 0;
        while (yyl < yyleng) {
          if ((int )*(yytext + yyl) == 10) {
            yylineno ++;
          }
          yyl ++;
        }
      }
    }
    do_action:
    switch (yy_act) {
    case 0:
    *yy_cp = yy_hold_char;
    yy_cp = yy_last_accepting_cpos;
    yy_current_state = yy_last_accepting_state;
    goto yy_find_action;
    case 1:
    tmp___0 = lex_return(p, 278);
    return (tmp___0);
    break;
    case 2:
    tmp___1 = lex_return(p, 279);
    return (tmp___1);
    break;
    case 3:
    tmp___2 = lex_return(p, 280);
    return (tmp___2);
    break;
    case 4:
    tmp___3 = lex_return(p, 281);
    return (tmp___3);
    break;
    case 5:
    tmp___4 = lex_return(p, 282);
    return (tmp___4);
    break;
    case 6:
    tmp___5 = lex_return(p, 283);
    return (tmp___5);
    break;
    case 7:
    tmp___6 = lex_return(p, 284);
    return (tmp___6);
    break;
    case 8:
    tmp___7 = lex_return(p, 285);
    return (tmp___7);
    break;
    case 9:
    tmp___8 = lex_return(p, 286);
    return (tmp___8);
    break;
    case 10:
    tmp___9 = lex_return(p, 287);
    return (tmp___9);
    break;
    case 11:
    tmp___10 = lex_return(p, 288);
    return (tmp___10);
    break;
    case 12:
    tmp___11 = lex_return(p, 289);
    return (tmp___11);
    break;
    case 13:
    tmp___12 = lex_return(p, 290);
    return (tmp___12);
    break;
    case 14:
    tmp___13 = lex_return(p, 292);
    return (tmp___13);
    break;
    case 15:
    tmp___14 = lex_return(p, 273);
    return (tmp___14);
    break;
    case 16:
    tmp___15 = lex_return(p, 274);
    return (tmp___15);
    break;
    case 17:
    tmp___16 = lex_return(p, 275);
    return (tmp___16);
    break;
    case 18:
    tmp___17 = lex_return(p, 276);
    return (tmp___17);
    break;
    case 19:
    tmp___18 = lex_return(p, 277);
    return (tmp___18);
    break;
    case 20:
    tmp___19 = lex_return(p, '=');
    return (tmp___19);
    break;
    case 21:
    tmp___20 = lex_return(p, 293);
    return (tmp___20);
    break;
    case 22:
    tmp___21 = lex_return(p, 258);
    return (tmp___21);
    break;
    case 23:
    tmp___22 = lex_return(p, 259);
    return (tmp___22);
    break;
    case 24:
    tmp___23 = lex_return(p, 262);
    return (tmp___23);
    break;
    case 25:
    tmp___24 = lex_return(p, 260);
    return (tmp___24);
    break;
    case 26:
    tmp___25 = lex_return(p, 261);
    return (tmp___25);
    break;
    case 27:
    tmp___26 = lex_return(p, 263);
    return (tmp___26);
    break;
    case 28:
    tmp___27 = lex_return(p, 264);
    return (tmp___27);
    break;
    case 29:
    tmp___28 = lex_return(p, 265);
    return (tmp___28);
    break;
    case 30:
    tmp___29 = lex_return(p, 266);
    return (tmp___29);
    break;
    case 31:
    tmp___30 = lex_return(p, 267);
    return (tmp___30);
    break;
    case 32:
    tmp___31 = lex_return(p, 268);
    return (tmp___31);
    break;
    case 33:
    tmp___32 = lex_return(p, 269);
    return (tmp___32);
    break;
    case 34:
    tmp___33 = lex_return(p, 270);
    return (tmp___33);
    break;
    case 35:
    tmp___34 = lex_return(p, 271);
    return (tmp___34);
    break;
    case 36:
    tmp___35 = lex_return(p, 272);
    return (tmp___35);
    break;
    case 37:
    lval->id = node_str_new((char const   *)yytext, yyleng);
    tmp___36 = lex_return(p, 298);
    return (tmp___36);
    break;
    case 38:
    *(yytext + (yyleng - 1)) = (char )'\000';
    lval->id = node_str_new((char const   *)yytext, yyleng - 1);
    tmp___37 = lex_return(p, 299);
    return (tmp___37);
    break;
    case 39:
    tmp___38 = lex_return(p, 291);
    return (tmp___38);
    break;
    case 40:
    tmp___39 = lex_return(p, '.');
    return (tmp___39);
    break;
    case 41:
    tmp___40 = lex_return(p, (int )*(yytext + 0));
    return (tmp___40);
    break;
    case 42:
    tmp___41 = lex_return(p, (int )*(yytext + 0));
    return (tmp___41);
    break;
    case 43:
    tmp___42 = lex_return(p, '\n');
    return (tmp___42);
    break;
    case 44:
    tmp___43 = lex_return(p, '\n');
    return (tmp___43);
    break;
    case 45:
    tmp___44 = atol((char const   *)yytext);
    lval->nd = node_int_new(tmp___44);
    tmp___45 = lex_return(p, 295);
    return (tmp___45);
    break;
    case 46:
    sscanf((char const   * __restrict  )yytext, (char const   * __restrict  )"%lf",
           & temp);
    lval->nd = node_float_new(temp);
    tmp___46 = lex_return(p, 295);
    return (tmp___46);
    break;
    case 47:
    sscanf((char const   * __restrict  )(yytext + 2), (char const   * __restrict  )"%lx",
           & temp___0);
    lval->nd = node_int_new((long )temp___0);
    tmp___47 = lex_return(p, 295);
    return (tmp___47);
    break;
    case 48:
    sscanf((char const   * __restrict  )(yytext + 2), (char const   * __restrict  )"%lo",
           & temp___1);
    lval->nd = node_int_new((long )temp___1);
    tmp___48 = lex_return(p, 295);
    return (tmp___48);
    break;
    case 49:
    lval->nd = node_time_new((char const   *)yytext, yyleng);
    if ((unsigned long )lval->nd == (unsigned long )((void *)0)) {
      yyerror(p, "bad time format");
    }
    tmp___49 = lex_return(p, 294);
    return (tmp___49);
    break;
    case 50:
    lval->nd = node_string_new((char const   *)(yytext + 1), yyleng - 2);
    tmp___50 = lex_return(p, 297);
    return (tmp___50);
    break;
    case 51:
    lval->nd = node_string_new((char const   *)(yytext + 1), yyleng - 1);
    tmp___51 = lex_return(p, 296);
    return (tmp___51);
    break;
    case 52:
    lval->id = node_str_escaped((char const   *)(yytext + 1), yyleng - 3);
    tmp___52 = lex_return(p, 299);
    return (tmp___52);
    break;
    case 53: ;
    break;
    case 54:
    c = *(yytext + 0);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d:lexical error",
            p->fname, yylineno);
    if ((int )c & 128) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"(\'\\%03o\').\n",
              (int )c);
    } else {
      tmp___53 = __ctype_b_loc();
      if ((int const   )*(*tmp___53 + (int )c) & 16384) {
        if ((int )c == 92) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"(\'\\\\\').\n");
        } else {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"(\'%c\').\n",
                  (int )c);
        }
      } else {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"(\'\\%03o\').\n",
                (int )c);
      }
    }
    exit(1);
    break;
    case 55:
    while (1) {
      fwrite((void const   * __restrict  )yytext, (size_t )yyleng, (size_t )1, (FILE * __restrict  )yyout);
      break;
    }
    break;
    case 57:
    return (0);
    case 56:
    yy_amount_of_matched_text = (int )(yy_cp - yytext) - 1;
    *yy_cp = yy_hold_char;
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 0) {
      yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file = yyin;
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 1;
    }
    if ((unsigned long )yy_c_buf_p <= (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars)) {
      yy_c_buf_p = yytext + yy_amount_of_matched_text;
      yy_current_state = yy_get_previous_state();
      yy_next_state = yy_try_NUL_trans(yy_current_state);
      yy_bp = yytext + 0;
      if (yy_next_state) {
        yy_c_buf_p ++;
        yy_cp = yy_c_buf_p;
        yy_current_state = yy_next_state;
        goto yy_match;
      } else {
        yy_cp = yy_c_buf_p;
        goto yy_find_action;
      }
    } else {
      tmp___54 = yy_get_next_buffer();
      switch (tmp___54) {
      case 1:
      yy_did_buffer_switch_on_eof = 0;
      yy_c_buf_p = yytext + 0;
      yy_act = (56 + (yy_start - 1) / 2) + 1;
      goto do_action;
      break;
      case 0:
      yy_c_buf_p = yytext + yy_amount_of_matched_text;
      yy_current_state = yy_get_previous_state();
      yy_cp = yy_c_buf_p;
      yy_bp = yytext + 0;
      goto yy_match;
      case 2:
      yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars;
      yy_current_state = yy_get_previous_state();
      yy_cp = yy_c_buf_p;
      yy_bp = yytext + 0;
      goto yy_find_action;
      }
    }
    break;
    default:
    yy_fatal_error("fatal flex scanner internal error--no action found");
    }
  }
}
}
static int yy_get_next_buffer(void)
{
  char *dest ;
  char *source ;
  int number_to_move ;
  int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___1 ;
  int c ;
  int n ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int new_size___0 ;
  void *tmp___9 ;

  {
  dest = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf;
  source = yytext;
  if ((unsigned long )yy_c_buf_p > (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1))) {
    yy_fatal_error("fatal flex scanner internal error--end of buffer missed");
  }
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_fill_buffer == 0) {
    if (yy_c_buf_p - yytext == 1L) {
      return (1);
    } else {
      return (2);
    }
  }
  number_to_move = (int )((yy_c_buf_p - yytext) - 1L);
  i = 0;
  while (i < number_to_move) {
    tmp = dest;
    dest ++;
    tmp___0 = source;
    source ++;
    *tmp = *tmp___0;
    i ++;
  }
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 2) {
    yy_n_chars = 0;
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  } else {
    num_to_read = ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - number_to_move) - 1;
    while (num_to_read <= 0) {
      b = *(yy_buffer_stack + yy_buffer_stack_top);
      yy_c_buf_p_offset = (int )(yy_c_buf_p - b->yy_ch_buf);
      if (b->yy_is_our_buffer) {
        new_size = b->yy_buf_size * 2;
        if (new_size <= 0) {
          b->yy_buf_size += b->yy_buf_size / 8;
        } else {
          b->yy_buf_size *= 2;
        }
        tmp___1 = yyrealloc((void *)b->yy_ch_buf, (yy_size_t )(b->yy_buf_size + 2));
        b->yy_ch_buf = (char *)tmp___1;
      } else {
        b->yy_ch_buf = (char *)((void *)0);
      }
      if (! b->yy_ch_buf) {
        yy_fatal_error("fatal error - scanner input buffer overflow");
      }
      yy_c_buf_p = b->yy_ch_buf + yy_c_buf_p_offset;
      num_to_read = ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - number_to_move) - 1;
    }
    if (num_to_read > 8192) {
      num_to_read = 8192;
    }
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_is_interactive) {
      c = '*';
      n = 0;
      while (1) {
        if (n < num_to_read) {
          c = getc(yyin);
          if (c != -1) {
            if (! (c != 10)) {
              break;
            }
          } else {
            break;
          }
        } else {
          break;
        }
        *(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move) + n) = (char )c;
        n ++;
      }
      if (c == 10) {
        tmp___2 = n;
        n ++;
        *(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move) + tmp___2) = (char )c;
      }
      if (c == -1) {
        tmp___3 = ferror(yyin);
        if (tmp___3) {
          yy_fatal_error("input in flex scanner failed");
        }
      }
      yy_n_chars = n;
    } else {
      tmp___4 = __errno_location();
      *tmp___4 = 0;
      while (1) {
        tmp___7 = fread((void * __restrict  )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move),
                        (size_t )1, (yy_size_t )num_to_read, (FILE * __restrict  )yyin);
        yy_n_chars = (int )tmp___7;
        if (yy_n_chars == 0) {
          tmp___8 = ferror(yyin);
          if (! tmp___8) {
            break;
          }
        } else {
          break;
        }
        tmp___5 = __errno_location();
        if (*tmp___5 != 4) {
          yy_fatal_error("input in flex scanner failed");
          break;
        }
        tmp___6 = __errno_location();
        *tmp___6 = 0;
        clearerr(yyin);
      }
    }
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
  if (yy_n_chars == 0) {
    if (number_to_move == 0) {
      ret_val = 1;
      yyrestart(yyin);
    } else {
      ret_val = 2;
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 2;
    }
  } else {
    ret_val = 0;
  }
  if (yy_n_chars + number_to_move > (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size) {
    new_size___0 = (yy_n_chars + number_to_move) + (yy_n_chars >> 1);
    tmp___9 = yyrealloc((void *)(*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf,
                        (yy_size_t )new_size___0);
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf = (char *)tmp___9;
    if (! (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf) {
      yy_fatal_error("out of dynamic memory in yy_get_next_buffer()");
    }
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size = new_size___0 - 2;
  }
  yy_n_chars += number_to_move;
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars) = (char)0;
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1)) = (char)0;
  yytext = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 0;
  return (ret_val);
}
}
static yy_state_type yy_get_previous_state(void)
{
  yy_state_type yy_current_state ;
  char *yy_cp ;
  YY_CHAR yy_c ;
  int tmp ;

  {
  yy_current_state = yy_start;
  yy_cp = yytext + 0;
  while ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p) {
    if (*yy_cp) {
      tmp = (int const   )yy_ec[(YY_CHAR )*yy_cp];
    } else {
      tmp = (int const   )1;
    }
    yy_c = (YY_CHAR )tmp;
    if (yy_accept[yy_current_state]) {
      yy_last_accepting_state = yy_current_state;
      yy_last_accepting_cpos = yy_cp;
    }
    while ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state) {
      yy_current_state = (int )yy_def[yy_current_state];
      if (yy_current_state >= 290) {
        yy_c = (YY_CHAR )yy_meta[yy_c];
      }
    }
    yy_current_state = (yy_state_type )yy_nxt[(int const   )yy_base[yy_current_state] + (int const   )yy_c];
    yy_cp ++;
  }
  return (yy_current_state);
}
}
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state )
{
  int yy_is_jam ;
  char *yy_cp ;
  YY_CHAR yy_c ;
  int tmp ;

  {
  yy_cp = yy_c_buf_p;
  yy_c = (YY_CHAR )1;
  if (yy_accept[yy_current_state]) {
    yy_last_accepting_state = yy_current_state;
    yy_last_accepting_cpos = yy_cp;
  }
  while ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state) {
    yy_current_state = (int )yy_def[yy_current_state];
    if (yy_current_state >= 290) {
      yy_c = (YY_CHAR )yy_meta[yy_c];
    }
  }
  yy_current_state = (yy_state_type )yy_nxt[(int const   )yy_base[yy_current_state] + (int const   )yy_c];
  yy_is_jam = yy_current_state == 289;
  if (yy_is_jam) {
    tmp = 0;
  } else {
    tmp = yy_current_state;
  }
  return (tmp);
}
}
void yyrestart(FILE *input_file )
{
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  if (yy_buffer_stack) {
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
  if (! tmp) {
    yyensure_buffer_stack();
    *(yy_buffer_stack + yy_buffer_stack_top) = yy_create_buffer(yyin, 16384);
  }
  if (yy_buffer_stack) {
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  yy_init_buffer(tmp___0, input_file);
  yy_load_buffer_state();
  return;
}
}
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer )
{
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  yyensure_buffer_stack();
  if (yy_buffer_stack) {
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
    return;
  }
  if (yy_buffer_stack) {
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  if (tmp___0) {
    *yy_c_buf_p = yy_hold_char;
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
  yy_load_buffer_state();
  yy_did_buffer_switch_on_eof = 1;
  return;
}
}
static void yy_load_buffer_state(void)
{


  {
  yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
  yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos;
  yytext = yy_c_buf_p;
  yyin = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file;
  yy_hold_char = *yy_c_buf_p;
  return;
}
}
YY_BUFFER_STATE yy_create_buffer(FILE *file , int size )
{
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = yyalloc(sizeof(struct yy_buffer_state ));
  b = (YY_BUFFER_STATE )tmp;
  if (! b) {
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
  }
  b->yy_buf_size = size;
  tmp___0 = yyalloc((yy_size_t )(b->yy_buf_size + 2));
  b->yy_ch_buf = (char *)tmp___0;
  if (! b->yy_ch_buf) {
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
  }
  b->yy_is_our_buffer = 1;
  yy_init_buffer(b, file);
  return (b);
}
}
void yy_delete_buffer(YY_BUFFER_STATE b )
{
  YY_BUFFER_STATE tmp ;

  {
  if (! b) {
    return;
  }
  if (yy_buffer_stack) {
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
  if ((unsigned long )b == (unsigned long )tmp) {
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )0;
  }
  if (b->yy_is_our_buffer) {
    yyfree((void *)b->yy_ch_buf);
  }
  yyfree((void *)b);
  return;
}
}
static void yy_init_buffer(YY_BUFFER_STATE b , FILE *file )
{
  int oerrno ;
  int *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  tmp = __errno_location();
  oerrno = *tmp;
  yy_flush_buffer(b);
  b->yy_input_file = file;
  b->yy_fill_buffer = 1;
  if (yy_buffer_stack) {
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  if ((unsigned long )b != (unsigned long )tmp___0) {
    b->yy_bs_lineno = 1;
    b->yy_bs_column = 0;
  }
  if (file) {
    tmp___1 = fileno(file);
    tmp___2 = isatty(tmp___1);
    b->yy_is_interactive = tmp___2 > 0;
  } else {
    b->yy_is_interactive = 0;
  }
  tmp___3 = __errno_location();
  *tmp___3 = oerrno;
  return;
}
}
void yy_flush_buffer(YY_BUFFER_STATE b )
{
  YY_BUFFER_STATE tmp ;

  {
  if (! b) {
    return;
  }
  b->yy_n_chars = 0;
  *(b->yy_ch_buf + 0) = (char)0;
  *(b->yy_ch_buf + 1) = (char)0;
  b->yy_buf_pos = b->yy_ch_buf + 0;
  b->yy_at_bol = 1;
  b->yy_buffer_status = 0;
  if (yy_buffer_stack) {
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
  if ((unsigned long )b == (unsigned long )tmp) {
    yy_load_buffer_state();
  }
  return;
}
}
void yypush_buffer_state(YY_BUFFER_STATE new_buffer )
{
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
    return;
  }
  yyensure_buffer_stack();
  if (yy_buffer_stack) {
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
  if (tmp) {
    *yy_c_buf_p = yy_hold_char;
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
  if (yy_buffer_stack) {
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  if (tmp___0) {
    yy_buffer_stack_top ++;
  }
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
  yy_load_buffer_state();
  yy_did_buffer_switch_on_eof = 1;
  return;
}
}
void yypop_buffer_state(void)
{
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
  if (yy_buffer_stack) {
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
  if (! tmp) {
    return;
  }
  if (yy_buffer_stack) {
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  yy_delete_buffer(tmp___0);
  *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
  if (yy_buffer_stack_top > 0UL) {
    yy_buffer_stack_top --;
  }
  if (yy_buffer_stack) {
    tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
  if (tmp___1) {
    yy_load_buffer_state();
    yy_did_buffer_switch_on_eof = 1;
  }
  return;
}
}
static void yyensure_buffer_stack(void)
{
  yy_size_t num_to_alloc ;
  void *tmp ;
  yy_size_t grow_size ;
  void *tmp___0 ;

  {
  if (! yy_buffer_stack) {
    num_to_alloc = (yy_size_t )1;
    tmp = yyalloc(num_to_alloc * sizeof(struct yy_buffer_state *));
    yy_buffer_stack = (struct yy_buffer_state **)tmp;
    if (! yy_buffer_stack) {
      yy_fatal_error("out of dynamic memory in yyensure_buffer_stack()");
    }
    memset((void *)yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state *));
    yy_buffer_stack_max = num_to_alloc;
    yy_buffer_stack_top = (size_t )0;
    return;
  }
  if (yy_buffer_stack_top >= yy_buffer_stack_max - 1UL) {
    grow_size = (yy_size_t )8;
    num_to_alloc = yy_buffer_stack_max + grow_size;
    tmp___0 = yyrealloc((void *)yy_buffer_stack, num_to_alloc * sizeof(struct yy_buffer_state *));
    yy_buffer_stack = (struct yy_buffer_state **)tmp___0;
    if (! yy_buffer_stack) {
      yy_fatal_error("out of dynamic memory in yyensure_buffer_stack()");
    }
    memset((void *)(yy_buffer_stack + yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state *));
    yy_buffer_stack_max = num_to_alloc;
  }
  return;
}
}
YY_BUFFER_STATE yy_scan_buffer(char *base , yy_size_t size )
{
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;

  {
  if (size < 2UL) {
    return ((YY_BUFFER_STATE )((void *)0));
  } else
  if ((int )*(base + (size - 2UL)) != 0) {
    return ((YY_BUFFER_STATE )((void *)0));
  } else
  if ((int )*(base + (size - 1UL)) != 0) {
    return ((YY_BUFFER_STATE )((void *)0));
  }
  tmp = yyalloc(sizeof(struct yy_buffer_state ));
  b = (YY_BUFFER_STATE )tmp;
  if (! b) {
    yy_fatal_error("out of dynamic memory in yy_scan_buffer()");
  }
  b->yy_buf_size = (int )(size - 2UL);
  tmp___0 = base;
  b->yy_ch_buf = tmp___0;
  b->yy_buf_pos = tmp___0;
  b->yy_is_our_buffer = 0;
  b->yy_input_file = (FILE *)((void *)0);
  b->yy_n_chars = b->yy_buf_size;
  b->yy_is_interactive = 0;
  b->yy_at_bol = 1;
  b->yy_fill_buffer = 0;
  b->yy_buffer_status = 0;
  yy_switch_to_buffer(b);
  return (b);
}
}
YY_BUFFER_STATE yy_scan_string(char const   *yystr )
{
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  tmp = strlen(yystr);
  tmp___0 = yy_scan_bytes(yystr, (int )tmp);
  return (tmp___0);
}
}
YY_BUFFER_STATE yy_scan_bytes(char const   *yybytes , int _yybytes_len )
{
  YY_BUFFER_STATE b ;
  char *buf ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;

  {
  n = (yy_size_t )(_yybytes_len + 2);
  tmp = yyalloc(n);
  buf = (char *)tmp;
  if (! buf) {
    yy_fatal_error("out of dynamic memory in yy_scan_bytes()");
  }
  i = 0;
  while (i < _yybytes_len) {
    *(buf + i) = (char )*(yybytes + i);
    i ++;
  }
  tmp___0 = (char)0;
  *(buf + (_yybytes_len + 1)) = tmp___0;
  *(buf + _yybytes_len) = tmp___0;
  b = yy_scan_buffer(buf, n);
  if (! b) {
    yy_fatal_error("bad buffer in yy_scan_bytes()");
  }
  b->yy_is_our_buffer = 1;
  return (b);
}
}
static  __attribute__((__noreturn__)) void yy_fatal_error(char const   *msg ) ;
static void yy_fatal_error(char const   *msg )
{


  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n", msg);
  exit(2);
}
}
int yyget_lineno(void)
{


  {
  return (yylineno);
}
}
FILE *yyget_in(void)
{


  {
  return (yyin);
}
}
FILE *yyget_out(void)
{


  {
  return (yyout);
}
}
int yyget_leng(void)
{


  {
  return (yyleng);
}
}
char *yyget_text(void)
{


  {
  return (yytext);
}
}
void yyset_lineno(int _line_number )
{


  {
  yylineno = _line_number;
  return;
}
}
void yyset_in(FILE *_in_str )
{


  {
  yyin = _in_str;
  return;
}
}
void yyset_out(FILE *_out_str )
{


  {
  yyout = _out_str;
  return;
}
}
int yyget_debug(void)
{


  {
  return (yy_flex_debug);
}
}
void yyset_debug(int _bdebug )
{


  {
  yy_flex_debug = _bdebug;
  return;
}
}
static int yy_init_globals(void)
{


  {
  yylineno = 1;
  yy_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
  yy_buffer_stack_top = (size_t )0;
  yy_buffer_stack_max = (size_t )0;
  yy_c_buf_p = (char *)((void *)0);
  yy_init = 0;
  yy_start = 0;
  yyin = (FILE *)((void *)0);
  yyout = (FILE *)((void *)0);
  return (0);
}
}
int yylex_destroy(void)
{
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  while (1) {
    if (yy_buffer_stack) {
      tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
    if (! tmp___0) {
      break;
    }
    if (yy_buffer_stack) {
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    yy_delete_buffer(tmp);
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
    yypop_buffer_state();
  }
  yyfree((void *)yy_buffer_stack);
  yy_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
  yy_init_globals();
  return (0);
}
}
void *yyalloc(yy_size_t size )
{
  void *tmp ;

  {
  tmp = malloc(size);
  return (tmp);
}
}
void *yyrealloc(void *ptr , yy_size_t size )
{
  void *tmp ;

  {
  tmp = realloc(ptr, size);
  return (tmp);
}
}
void yyfree(void *ptr )
{


  {
  free((void *)((char *)ptr));
  return;
}
}
static void yyerror(parser_state *p , char const   *s )
{


  {
  (p->nerr) ++;
  if (p->fname) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d:%s\n",
            p->fname, p->lineno, s);
  } else {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%d:%s\n", p->lineno,
            s);
  }
  return;
}
}
