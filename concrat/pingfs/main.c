/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef unsigned char __uint8_t;
typedef unsigned short __uint16_t;
typedef unsigned int __uint32_t;
typedef long __ssize_t;
typedef unsigned int __socklen_t;
typedef __ssize_t ssize_t;
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __socklen_t socklen_t;
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct sockaddr_storage {
   sa_family_t ss_family ;
   char __ss_padding[(128UL - sizeof(unsigned short )) - sizeof(unsigned long )] ;
   unsigned long __ss_align ;
};
struct sockaddr_in ;
struct sockaddr_in6 ;
typedef uint32_t in_addr_t;
struct in_addr {
   in_addr_t s_addr ;
};
typedef uint16_t in_port_t;
union __anonunion___in6_u_979734923 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
struct in6_addr {
   union __anonunion___in6_u_979734923 __in6_u ;
};
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
enum icmp_type {
    ICMP_REQUEST = 0,
    ICMP_REPLY = 1
} ;
struct icmp_packet {
   struct sockaddr_storage peer ;
   socklen_t peer_len ;
   enum icmp_type type ;
   uint16_t id ;
   uint16_t seqno ;
   uint8_t *payload ;
   uint32_t payload_len ;
};
struct icmp_rule {
   int request_type ;
   int reply_type ;
   int use_checksum ;
   int strip_iphdr ;
};
typedef unsigned long __uint64_t;
typedef long __off_t;
typedef long __off64_t;
typedef long __time_t;
typedef long __suseconds_t;
typedef int __clockid_t;
typedef long __syscall_slong_t;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef __uint64_t uint64_t;
typedef __clockid_t clockid_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
struct gaicb {
   char const   *ar_name ;
   char const   *ar_service ;
   struct addrinfo  const  *ar_request ;
   struct addrinfo *ar_result ;
   int __return ;
   int __glibc_reserved[5] ;
};
struct host {
   struct host *next ;
   struct sockaddr_storage sockaddr ;
   socklen_t sockaddr_len ;
};
struct linked_gaicb {
   struct gaicb gaicb ;
   struct linked_gaicb *next ;
};
struct eval_host {
   struct host *host ;
   struct timespec sendtime ;
   uint16_t cur_seqno ;
   uint16_t id ;
   uint8_t *payload ;
   size_t payload_len ;
   int done ;
   int num_tx ;
   int num_rx ;
};
struct evaldata {
   struct eval_host *hosts ;
   int count ;
};
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned long __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef int __pid_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef unsigned long __fsblkcnt64_t;
typedef unsigned long __fsfilcnt64_t;
typedef __ino64_t ino_t;
typedef __dev_t dev_t;
typedef __gid_t gid_t;
typedef __mode_t mode_t;
typedef __uid_t uid_t;
typedef __off64_t off_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
typedef union sigval __sigval_t;
struct __anonstruct__sigev_thread_746770901 {
   void (*_function)(__sigval_t  ) ;
   pthread_attr_t *_attribute ;
};
union __anonunion__sigev_un_233858830 {
   int _pad[64UL / sizeof(int ) - 4UL] ;
   __pid_t _tid ;
   struct __anonstruct__sigev_thread_746770901 _sigev_thread ;
};
struct sigevent {
   __sigval_t sigev_value ;
   int sigev_signo ;
   int sigev_notify ;
   union __anonunion__sigev_un_233858830 _sigev_un ;
};
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
struct fuse_opt {
   char const   *templ ;
   unsigned long offset ;
   int value ;
};
struct fuse_args {
   int argc ;
   char **argv ;
   int allocated ;
};
struct fuse_file_info {
   int flags ;
   unsigned long fh_old ;
   int writepage ;
   unsigned int direct_io : 1 ;
   unsigned int keep_cache : 1 ;
   unsigned int flush : 1 ;
   unsigned int nonseekable : 1 ;
   unsigned int flock_release : 1 ;
   unsigned int padding : 27 ;
   uint64_t fh ;
   uint64_t lock_owner ;
};
struct fuse_conn_info {
   unsigned int proto_major ;
   unsigned int proto_minor ;
   unsigned int async_read ;
   unsigned int max_write ;
   unsigned int max_readahead ;
   unsigned int capable ;
   unsigned int want ;
   unsigned int max_background ;
   unsigned int congestion_threshold ;
   unsigned int reserved[23] ;
};
struct fuse_pollhandle ;
enum fuse_buf_flags {
    FUSE_BUF_IS_FD = 2,
    FUSE_BUF_FD_SEEK = 4,
    FUSE_BUF_FD_RETRY = 8
} ;
struct fuse_buf {
   size_t size ;
   enum fuse_buf_flags flags ;
   void *mem ;
   int fd ;
   off_t pos ;
};
struct fuse_bufvec {
   size_t count ;
   size_t idx ;
   size_t off ;
   struct fuse_buf buf[1] ;
};
struct flock {
   short l_type ;
   short l_whence ;
   __off64_t l_start ;
   __off64_t l_len ;
   __pid_t l_pid ;
};
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
struct statvfs {
   unsigned long f_bsize ;
   unsigned long f_frsize ;
   __fsblkcnt64_t f_blocks ;
   __fsblkcnt64_t f_bfree ;
   __fsblkcnt64_t f_bavail ;
   __fsfilcnt64_t f_files ;
   __fsfilcnt64_t f_ffree ;
   __fsfilcnt64_t f_favail ;
   unsigned long f_fsid ;
   unsigned long f_flag ;
   unsigned long f_namemax ;
   int __f_spare[6] ;
};
struct fuse_dirhandle ;
typedef struct fuse_dirhandle *fuse_dirh_t;
struct fuse_operations {
   int (*getattr)(char const   * , struct stat * ) ;
   int (*readlink)(char const   * , char * , size_t  ) ;
   int (*getdir)(char const   * , fuse_dirh_t  , int (*)(fuse_dirh_t h , char const   *name ,
                                                         int type , ino_t ino ) ) ;
   int (*mknod)(char const   * , mode_t  , dev_t  ) ;
   int (*mkdir)(char const   * , mode_t  ) ;
   int (*unlink)(char const   * ) ;
   int (*rmdir)(char const   * ) ;
   int (*symlink)(char const   * , char const   * ) ;
   int (*rename)(char const   * , char const   * ) ;
   int (*link)(char const   * , char const   * ) ;
   int (*chmod)(char const   * , mode_t  ) ;
   int (*chown)(char const   * , uid_t  , gid_t  ) ;
   int (*truncate)(char const   * , off_t  ) ;
   int (*utime)(char const   * , struct utimbuf * ) ;
   int (*open)(char const   * , struct fuse_file_info * ) ;
   int (*read)(char const   * , char * , size_t  , off_t  , struct fuse_file_info * ) ;
   int (*write)(char const   * , char const   * , size_t  , off_t  , struct fuse_file_info * ) ;
   int (*statfs)(char const   * , struct statvfs * ) ;
   int (*flush)(char const   * , struct fuse_file_info * ) ;
   int (*release)(char const   * , struct fuse_file_info * ) ;
   int (*fsync)(char const   * , int  , struct fuse_file_info * ) ;
   int (*setxattr)(char const   * , char const   * , char const   * , size_t  , int  ) ;
   int (*getxattr)(char const   * , char const   * , char * , size_t  ) ;
   int (*listxattr)(char const   * , char * , size_t  ) ;
   int (*removexattr)(char const   * , char const   * ) ;
   int (*opendir)(char const   * , struct fuse_file_info * ) ;
   int (*readdir)(char const   * , void * , int (*)(void *buf , char const   *name ,
                                                    struct stat  const  *stbuf , off_t off ) ,
                  off_t  , struct fuse_file_info * ) ;
   int (*releasedir)(char const   * , struct fuse_file_info * ) ;
   int (*fsyncdir)(char const   * , int  , struct fuse_file_info * ) ;
   void *(*init)(struct fuse_conn_info *conn ) ;
   void (*destroy)(void * ) ;
   int (*access)(char const   * , int  ) ;
   int (*create)(char const   * , mode_t  , struct fuse_file_info * ) ;
   int (*ftruncate)(char const   * , off_t  , struct fuse_file_info * ) ;
   int (*fgetattr)(char const   * , struct stat * , struct fuse_file_info * ) ;
   int (*lock)(char const   * , struct fuse_file_info * , int cmd , struct flock * ) ;
   int (*utimens)(char const   * , struct timespec  const  *tv ) ;
   int (*bmap)(char const   * , size_t blocksize , uint64_t *idx ) ;
   unsigned int flag_nullpath_ok : 1 ;
   unsigned int flag_nopath : 1 ;
   unsigned int flag_utime_omit_ok : 1 ;
   unsigned int flag_reserved : 29 ;
   int (*ioctl)(char const   * , int cmd , void *arg , struct fuse_file_info * , unsigned int flags ,
                void *data ) ;
   int (*poll)(char const   * , struct fuse_file_info * , struct fuse_pollhandle *ph ,
               unsigned int *reventsp ) ;
   int (*write_buf)(char const   * , struct fuse_bufvec *buf , off_t off , struct fuse_file_info * ) ;
   int (*read_buf)(char const   * , struct fuse_bufvec **bufp , size_t size , off_t off ,
                   struct fuse_file_info * ) ;
   int (*flock)(char const   * , struct fuse_file_info * , int op ) ;
   int (*fallocate)(char const   * , int  , off_t  , off_t  , struct fuse_file_info * ) ;
};
struct arginfo {
   char *hostfile ;
   char *mountpoint ;
   int num_args ;
   int timeout ;
};
struct io ;
struct chunk {
   struct chunk *next_active ;
   struct chunk *next_file ;
   struct host *host ;
   struct io *io ;
   uint16_t id ;
   uint16_t seqno ;
   uint16_t len ;
};
struct file {
   struct file *next ;
   char const   *name ;
   struct chunk *chunks ;
   mode_t mode ;
};
typedef long __fd_mask;
struct __anonstruct_fd_set_356711149 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
typedef struct __anonstruct_fd_set_356711149 fd_set;
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
typedef unsigned long pthread_t;
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
struct icmp6_filter {
   uint32_t icmp6_filt[8] ;
};
struct pkt_stats {
   unsigned long long packets ;
   unsigned long long bytes ;
};
struct net_data {
   pthread_t responder ;
   pthread_t status ;
   pthread_mutex_t stats_mutex ;
   struct pkt_stats tx ;
   struct pkt_stats rx ;
};
struct __anonstruct___wseq32_112954846 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_752798888 {
   unsigned long long __wseq ;
   struct __anonstruct___wseq32_112954846 __wseq32 ;
};
struct __anonstruct___g1_start32_900150283 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_900150282 {
   unsigned long long __g1_start ;
   struct __anonstruct___g1_start32_900150283 __g1_start32 ;
};
struct __pthread_cond_s {
   union __anonunion____missing_field_name_752798888 __annonCompField1 ;
   union __anonunion____missing_field_name_900150282 __annonCompField2 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
union __anonunion_pthread_condattr_t_488594145 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_condattr_t_488594145 pthread_condattr_t;
union __anonunion_pthread_cond_t_951761805 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
typedef union __anonunion_pthread_cond_t_951761805 pthread_cond_t;
enum io_owner {
    OWNER_FS = 1,
    OWNER_NET = 2
} ;
struct io {
   pthread_cond_t fs_cond ;
   pthread_cond_t net_cond ;
   pthread_mutex_t mutex ;
   enum io_owner owner ;
   uint8_t *data ;
   size_t len ;
};
#pragma merger("0","/tmp/cil-tceeHj1x.i","-Wall,-Wshadow,-pedantic,-g")
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1))) bzero)(void *__s ,
                                                                                   size_t __n ) ;
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  * __restrict  __addr , socklen_t __addr_len ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
extern  __attribute__((__nothrow__)) char const   *inet_ntop(int __af , void const   * __restrict  __cp ,
                                                             char * __restrict  __buf ,
                                                             socklen_t __len ) ;
int icmp_parse(struct icmp_packet *pkt , uint8_t *data , int len ) ;
void icmp_dump(struct icmp_packet *pkt ) ;
int icmp_send(int socket___0 , struct icmp_packet *pkt ) ;
static struct icmp_rule  const  icmpv4  =    {8, 0, 1, 1};
static struct icmp_rule  const  icmpv6  =    {128, 129, 0, 0};
static uint16_t checksum(uint8_t *data , uint32_t len ) 
{ 
  uint32_t csum ;
  uint32_t i ;
  uint16_t c ;

  {
  csum = (uint32_t )0;
  i = (uint32_t )0;
  while (i < len) {
    c = (uint16_t )((int )*(data + i) << 8);
    if (i + 1U < len) {
      c = (uint16_t )((int )c | (int )*(data + (i + 1U)));
    }
    csum += (uint32_t )c;
    i += 2U;
  }
  csum = (csum >> 16) + (csum & 65535U);
  csum += csum >> 16;
  return ((uint16_t )(~ csum));
}
}
static uint16_t read16(uint8_t *data ) 
{ 


  {
  return ((uint16_t )(((int )*(data + 0) << 8) | (int )*(data + 1)));
}
}
static void write16(uint8_t *data , uint16_t s ) 
{ 


  {
  *(data + 0) = (uint8_t )((int )s >> 8);
  *(data + 1) = (uint8_t )((int )s & 255);
  return;
}
}
static uint8_t *icmp_encode(struct icmp_packet *pkt , int *len ) 
{ 
  struct icmp_rule  const  *rule ;
  struct icmp_rule  const  *tmp ;
  uint8_t *data ;
  int pktlen ;
  void *tmp___0 ;
  uint16_t tmp___1 ;

  {
  if ((int )pkt->peer.ss_family == 2) {
    tmp = & icmpv4;
  } else {
    tmp = & icmpv6;
  }
  rule = tmp;
  pktlen = (int )(8U + pkt->payload_len);
  tmp___0 = calloc((size_t )1, (size_t )pktlen);
  data = (uint8_t *)tmp___0;
  if (! data) {
    return ((uint8_t *)((void *)0));
  }
  if ((unsigned int )pkt->type == 0U) {
    *(data + 0) = (uint8_t )rule->request_type;
  } else {
    *(data + 0) = (uint8_t )rule->reply_type;
  }
  write16(data + 4, pkt->id);
  write16(data + 6, pkt->seqno);
  if (pkt->payload_len) {
    memcpy((void * __restrict  )(data + 8), (void const   * __restrict  )pkt->payload,
           (size_t )pkt->payload_len);
  }
  if (rule->use_checksum) {
    tmp___1 = checksum(data, (uint32_t )pktlen);
    write16(data + 2, tmp___1);
  }
  *len = pktlen;
  return (data);
}
}
int icmp_send(int socket___0 , struct icmp_packet *pkt ) 
{ 
  int len ;
  uint8_t *icmpdata ;
  ssize_t tmp ;

  {
  icmpdata = icmp_encode(pkt, & len);
  if (! icmpdata) {
    return (0);
  }
  tmp = sendto(socket___0, (void const   *)icmpdata, (size_t )len, 0, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& pkt->peer)),
               pkt->peer_len);
  len = (int )tmp;
  free((void *)icmpdata);
  return (len);
}
}
int icmp_parse(struct icmp_packet *pkt , uint8_t *data , int len ) 
{ 
  struct icmp_rule  const  *rule ;
  struct icmp_rule  const  *tmp ;
  int hdrlen ;
  uint16_t tmp___0 ;
  void *tmp___1 ;

  {
  if ((int )pkt->peer.ss_family == 2) {
    tmp = & icmpv4;
  } else {
    tmp = & icmpv6;
  }
  rule = tmp;
  if (rule->strip_iphdr) {
    if (len == 0) {
      return (-3);
    }
    hdrlen = ((int )*(data + 0) & 15) << 2;
    if (len < hdrlen) {
      return (-4);
    }
    data += hdrlen;
    len -= hdrlen;
  }
  if (len < 8) {
    return (-1);
  }
  if (rule->use_checksum) {
    tmp___0 = checksum(data, (uint32_t )len);
    if ((int )tmp___0 != 0) {
      return (-2);
    }
  }
  if (rule->request_type == (int const   )*(data + 0)) {
    pkt->type = (enum icmp_type )0;
  } else
  if (rule->reply_type == (int const   )*(data + 0)) {
    pkt->type = (enum icmp_type )1;
  } else {
    return (-5);
  }
  pkt->id = read16(data + 4);
  pkt->seqno = read16(data + 6);
  pkt->payload_len = (uint32_t )(len - 8);
  if (pkt->payload_len) {
    tmp___1 = malloc((size_t )pkt->payload_len);
    pkt->payload = (uint8_t *)tmp___1;
    memcpy((void * __restrict  )pkt->payload, (void const   * __restrict  )(data + 8),
           (size_t )pkt->payload_len);
  } else {
    pkt->payload = (uint8_t *)((void *)0);
  }
  return (0);
}
}
static void *get_in_addr(struct sockaddr_storage *ss ) 
{ 


  {
  if ((int )ss->ss_family == 2) {
    return ((void *)(& ((struct sockaddr_in *)ss)->sin_addr));
  } else {
    return ((void *)(& ((struct sockaddr_in6 *)ss)->sin6_addr));
  }
}
}
static char *icmp_type_str(struct icmp_packet *pkt ) 
{ 


  {
  if ((unsigned int )pkt->type == 1U) {
    return ((char *)"Reply from");
  }
  if ((unsigned int )pkt->type == 0U) {
    return ((char *)"Request to");
  }
  return ((char *)"Other");
}
}
void icmp_dump(struct icmp_packet *pkt ) 
{ 
  char ipaddr[64] ;
  void *tmp ;
  char *tmp___0 ;

  {
  bzero((void *)(ipaddr), sizeof(ipaddr));
  tmp = get_in_addr(& pkt->peer);
  inet_ntop((int )pkt->peer.ss_family, (void const   * __restrict  )tmp, (char * __restrict  )(ipaddr),
            (socklen_t )sizeof(ipaddr));
  tmp___0 = icmp_type_str(pkt);
  printf((char const   * __restrict  )"%s %s, id %04X, seqno %04X, payload %d bytes\n",
         tmp___0, ipaddr, (int )pkt->id, (int )pkt->seqno, pkt->payload_len);
  return;
}
}
#pragma merger("0","/tmp/cil-xec1G8MP.i","-Wall,-Wshadow,-pedantic,-g")
extern FILE *stdout ;
extern int fflush(FILE *__stream ) ;
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strndup)(char const   *__string ,
                                                                                      size_t __n )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
extern  __attribute__((__nothrow__)) int gai_error(struct gaicb *__req ) ;
int host_make_resolvlist(FILE *file , struct gaicb ***list ) ;
void host_free_resolvlist(struct gaicb **list , int length ) ;
struct host *host_create(struct gaicb **list , int listlength ) ;
int host_evaluate(struct host **hosts , int length , int timeout___0 ) ;
void host_use(struct host *hosts ) ;
struct host *host_get_next(void) ;
void net_send(struct host *host , uint16_t id , uint16_t seqno , uint8_t const   *data ,
              size_t len ) ;
int net_recv(struct timeval *tv , void (*recv_fn)(void *userdata , struct sockaddr_storage *addr ,
                                                  size_t addrlen , uint16_t id , uint16_t seqno ,
                                                  uint8_t **data , size_t len ) ,
             void *recv_data ) ;
void net_inc_rx(int packetsize ) ;
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
static struct addrinfo  const  addr_request  = 
     {0, 0, 3, 0, 0U, (struct sockaddr *)0, (char *)0, (struct addrinfo *)0};
int host_make_resolvlist(FILE *file , struct gaicb ***list ) 
{ 
  int hosts ;
  int i ;
  struct gaicb **l ;
  struct linked_gaicb *head ;
  struct linked_gaicb *tail ;
  struct linked_gaicb *lg ;
  char hostname[300] ;
  int res ;
  void *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;

  {
  hosts = 0;
  head = (struct linked_gaicb *)((void *)0);
  tail = (struct linked_gaicb *)((void *)0);
  while (1) {
    memset((void *)(hostname), 0, sizeof(hostname));
    res = fscanf((FILE * __restrict  )file, (char const   * __restrict  )"%256s",
                 hostname);
    if (res == -1) {
      break;
    }
    tmp = calloc((size_t )1, sizeof(*lg));
    lg = (struct linked_gaicb *)tmp;
    if (! lg) {
      return (0);
    }
    tmp___0 = strlen((char const   *)(hostname));
    tmp___1 = strndup((char const   *)(hostname), tmp___0);
    lg->gaicb.ar_name = (char const   *)tmp___1;
    lg->gaicb.ar_request = & addr_request;
    if (! head) {
      head = lg;
    }
    if (tail) {
      tail->next = lg;
    }
    tail = lg;
    hosts ++;
  }
  tmp___2 = calloc((size_t )hosts, sizeof(struct gaicb *));
  l = (struct gaicb **)tmp___2;
  if (! l) {
    return (0);
  }
  lg = head;
  i = 0;
  while (i < hosts) {
    *(l + i) = & lg->gaicb;
    lg = lg->next;
    i ++;
  }
  *list = l;
  return (hosts);
}
}
void host_free_resolvlist(struct gaicb **list , int length ) 
{ 
  int i ;

  {
  i = 0;
  while (i < length) {
    free((void *)((char *)(*(list + i))->ar_name));
    if ((*(list + i))->ar_result) {
      freeaddrinfo((*(list + i))->ar_result);
    }
    free((void *)*(list + i));
    i ++;
  }
  free((void *)list);
  return;
}
}
struct host *host_create(struct gaicb **list , int listlength ) 
{ 
  struct host *hosts ;
  struct host *last ;
  int i ;
  struct addrinfo *result ;
  struct host *h ;
  void *tmp ;
  int tmp___0 ;

  {
  hosts = (struct host *)((void *)0);
  last = (struct host *)((void *)0);
  i = 0;
  while (i < listlength) {
    tmp___0 = gai_error(*(list + i));
    if (tmp___0 == 0) {
      result = (*(list + i))->ar_result;
      while (result) {
        tmp = calloc((size_t )1, sizeof(struct host ));
        h = (struct host *)tmp;
        if (! h) {
          return ((struct host *)((void *)0));
        }
        memcpy((void * __restrict  )(& h->sockaddr), (void const   * __restrict  )result->ai_addr,
               (size_t )result->ai_addrlen);
        h->sockaddr_len = result->ai_addrlen;
        if (! hosts) {
          hosts = h;
        }
        if (last) {
          last->next = h;
        }
        last = h;
        result = result->ai_next;
      }
    }
    i ++;
  }
  return (hosts);
}
}
static uint64_t latency_sum_us  ;
static uint32_t latency_count  ;
static void diff_add(struct timespec *start , struct timespec *end ) 
{ 
  uint64_t us ;

  {
  us = (uint64_t )((end->tv_sec - start->tv_sec) * 1000000L);
  us -= (uint64_t )(start->tv_nsec / 1000L);
  us += (uint64_t )(end->tv_nsec / 1000L);
  latency_sum_us += us;
  latency_count ++;
  return;
}
}
static void eval_reply(void *userdata , struct sockaddr_storage *addr , size_t addrlen ,
                       uint16_t id , uint16_t seqno , uint8_t **data , size_t len ) 
{ 
  int i ;
  struct evaldata *eval ;
  struct timespec recvtime ;
  struct eval_host *eh ;
  int tmp ;
  int tmp___0 ;

  {
  eval = (struct evaldata *)userdata;
  clock_gettime(4, & recvtime);
  i = 0;
  while (i < eval->count) {
    eh = eval->hosts + i;
    if (addrlen == (size_t )(eh->host)->sockaddr_len) {
      tmp = memcmp((void const   *)addr, (void const   *)(& (eh->host)->sockaddr),
                   addrlen);
      if (tmp == 0) {
        if (eh->payload_len == len) {
          tmp___0 = memcmp((void const   *)*data, (void const   *)eh->payload, eh->payload_len);
          if (tmp___0 == 0) {
            if ((int )eh->id == (int )id) {
              if ((int )eh->cur_seqno == (int )seqno) {
                (eh->num_rx) ++;
                eh->done = 1;
                net_inc_rx((int )eh->payload_len);
                eh->cur_seqno = (uint16_t )((int )eh->cur_seqno + 1);
                diff_add(& eh->sendtime, & recvtime);
                break;
              }
            }
          }
        }
      }
    }
    i ++;
  }
  return;
}
}
int host_evaluate(struct host **hosts , int length , int timeout___0 ) 
{ 
  int i ;
  int addr ;
  int good_hosts ;
  struct host *host ;
  struct host *prev ;
  struct evaldata evaldata ;
  uint8_t eval_payload[1024] ;
  void *tmp ;
  int h ;
  struct timeval tv ;
  struct eval_host *eh ;
  int alldone ;
  int res ;
  struct eval_host *eh___0 ;
  struct host *next ;

  {
  evaldata.count = length;
  tmp = calloc((size_t )length, sizeof(struct eval_host ));
  evaldata.hosts = (struct eval_host *)tmp;
  if (! evaldata.hosts) {
    return (0);
  }
  i = 0;
  while ((unsigned long )i < sizeof(eval_payload)) {
    eval_payload[i] = (uint8_t )(i & 255);
    i ++;
  }
  addr = 0;
  host = *hosts;
  i = 0;
  while (i < length) {
    (evaldata.hosts + addr)->host = host;
    (evaldata.hosts + addr)->id = (uint16_t )addr;
    (evaldata.hosts + addr)->cur_seqno = (uint16_t )(addr * 2);
    (evaldata.hosts + addr)->payload = eval_payload;
    (evaldata.hosts + addr)->payload_len = sizeof(eval_payload);
    addr ++;
    host = host->next;
    i ++;
  }
  printf((char const   * __restrict  )"Evaluating %d hosts (timeout=%ds).", length,
         timeout___0);
  i = 0;
  while (i < 5) {
    printf((char const   * __restrict  )".");
    fflush(stdout);
    h = 0;
    while (h < length) {
      eh = evaldata.hosts + h;
      clock_gettime(4, & eh->sendtime);
      eh->done = 0;
      (eh->num_tx) ++;
      net_send(eh->host, eh->id, eh->cur_seqno, (uint8_t const   *)eh->payload, eh->payload_len);
      h ++;
    }
    tv.tv_sec = (__time_t )timeout___0;
    tv.tv_usec = (__suseconds_t )0;
    while (1) {
      alldone = 1;
      h = 0;
      while (h < length) {
        alldone &= (evaldata.hosts + h)->done;
        h ++;
      }
      if (alldone) {
        break;
      }
      res = net_recv(& tv, & eval_reply, (void *)(& evaldata));
      if (! res) {
        break;
      }
    }
    i ++;
  }
  printf((char const   * __restrict  )" done.\n");
  good_hosts = 0;
  i = 0;
  while (i < length) {
    eh___0 = evaldata.hosts + i;
    if (eh___0->num_tx == 0) {
      (eh___0->host)->sockaddr_len = (socklen_t )0;
    } else
    if (eh___0->num_tx != eh___0->num_rx) {
      (eh___0->host)->sockaddr_len = (socklen_t )0;
    } else {
      good_hosts ++;
    }
    i ++;
  }
  host = *hosts;
  prev = (struct host *)((void *)0);
  while (host) {
    next = host->next;
    if (host->sockaddr_len == 0U) {
      if ((unsigned long )host == (unsigned long )*hosts) {
        *hosts = next;
      }
      if (prev) {
        prev->next = next;
      }
      free((void *)host);
    } else {
      prev = host;
    }
    host = next;
  }
  free((void *)evaldata.hosts);
  printf((char const   * __restrict  )"%d of %d hosts responded correctly to all pings",
         good_hosts, length);
  if (good_hosts) {
    printf((char const   * __restrict  )" (average RTT %.02f ms)", (double )((float )latency_sum_us / ((float )latency_count * 1000.0f)));
  }
  printf((char const   * __restrict  )"\n");
  return (good_hosts);
}
}
static struct host *hosts_start  ;
static struct host *hosts_cur  ;
void host_use(struct host *hosts ) 
{ 


  {
  hosts_start = hosts;
  return;
}
}
struct host *host_get_next(void) 
{ 
  struct host *h ;

  {
  if (! hosts_start) {
    __assert_fail("hosts_start", "host.c", 307U, "host_get_next");
  }
  if (! hosts_cur) {
    hosts_cur = hosts_start;
  }
  h = hosts_cur;
  hosts_cur = hosts_cur->next;
  return (h);
}
}
#pragma merger("0","/tmp/cil-qjbrDscr.i","-Wall,-Wshadow,-pedantic,-g")
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern FILE *stdin ;
extern FILE *stderr ;
extern int fclose(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...)  __asm__("__isoc99_sscanf")  ;
extern void perror(char const   *__s ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
extern int getaddrinfo_a(int __mode , struct gaicb ** __restrict  __list , int __ent ,
                         struct sigevent * __restrict  __sig ) ;
extern struct passwd *( __attribute__((__nonnull__(1))) getpwnam)(char const   *__name ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __file ,
                                                                                   struct stat * __restrict  __buf )  __asm__("stat64")  ;
extern int fuse_opt_parse(struct fuse_args *args , void *data , struct fuse_opt  const  *opts ,
                          int (*proc)(void *data , char const   *arg , int key , struct fuse_args *outargs ) ) ;
extern int fuse_opt_add_arg(struct fuse_args *args , char const   *arg ) ;
extern void fuse_opt_free_args(struct fuse_args *args ) ;
extern int fuse_main_real(int argc , char **argv , struct fuse_operations  const  *op ,
                          size_t op_size , void *user_data ) ;
struct fuse_operations  const  fs_ops ;
int net_open_sockets(void) ;
void chunk_set_timeout(int t ) ;
static struct fuse_opt  const  pingfs_opts[4]  = {      {"-h", 4294967295UL, 0}, 
        {"-u ", 4294967295UL, 1}, 
        {"-t ", 4294967295UL, 2}, 
        {(char const   *)((void *)0), 0UL, 0}};
static int read_hostnames(char const   *hfile , struct gaicb ***list ) 
{ 
  int h ;
  FILE *file ;
  int tmp ;

  {
  h = 0;
  tmp = strcmp("-", hfile);
  if (tmp == 0) {
    file = stdin;
  } else {
    file = fopen((char const   * __restrict  )hfile, (char const   * __restrict  )"r");
    if (! file) {
      perror("Failed to read file");
      return (h);
    }
  }
  h = host_make_resolvlist(file, list);
  fclose(file);
  return (h);
}
}
static int resolve_names(struct gaicb **list , int names , struct host **hosts ) 
{ 
  int ret ;
  int hostcount ;
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  struct addrinfo *result ;

  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Resolving %d hostnames... ",
          names);
  fflush(stderr);
  ret = getaddrinfo_a(0, (struct gaicb ** __restrict  )list, names, (struct sigevent * __restrict  )((void *)0));
  if (ret != 0) {
    tmp = gai_strerror(ret);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Resolving failed: %s\n",
            tmp);
    return (-1);
  }
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"done.\n");
  hostcount = 0;
  i = 0;
  while (i < names) {
    ret = gai_error(*(list + i));
    if (ret) {
      tmp___0 = gai_strerror(ret);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Skipping %s: %s\n",
              (*(list + i))->ar_name, tmp___0);
    } else {
      result = (*(list + i))->ar_result;
      while (1) {
        hostcount ++;
        result = result->ai_next;
        if (! result) {
          break;
        }
      }
    }
    i ++;
  }
  if (! hostcount) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"No hosts found! Exiting\n");
    return (-1);
  }
  *hosts = host_create(list, names);
  host_free_resolvlist(list, names);
  if ((unsigned long )*hosts == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed creating list list, exiting\n");
    return (-1);
  }
  return (hostcount);
}
}
static void print_usage(char *progname ) 
{ 


  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: %s [options] hostfile mountpoint\nOptions:\n -h           : Print this help and exit\n -u username  : Mount the filesystem as this user\n -t timeout   : Max time to wait for icmp reply (seconds, default 1)\n",
          progname);
  return;
}
}
static int pingfs_opt_proc(void *data , char const   *arg , int key , struct fuse_args *outargs ) 
{ 
  struct arginfo *arginfo ;
  struct passwd *pw ;
  int res ;
  char userarg[64] ;

  {
  arginfo = (struct arginfo *)data;
  switch (key) {
  case -2: 
  (arginfo->num_args) ++;
  if (! arginfo->hostfile) {
    arginfo->hostfile = strdup(arg);
    return (0);
  } else
  if (! arginfo->mountpoint) {
    arginfo->mountpoint = strdup(arg);
  }
  break;
  case 0: 
  print_usage(*(outargs->argv + 0));
  exit(0);
  case 1: 
  pw = getpwnam(arg + 2);
  if (pw) {
    snprintf((char * __restrict  )(userarg), sizeof(userarg), (char const   * __restrict  )"-ouid=%d,gid=%d",
             pw->pw_uid, pw->pw_gid);
    fuse_opt_add_arg(outargs, (char const   *)(userarg));
    return (0);
  } else {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad username given! Exiting\n");
    print_usage(*(outargs->argv + 0));
    exit(1);
  }
  break;
  case 2: 
  res = sscanf((char const   * __restrict  )arg, (char const   * __restrict  )"-t%d",
               & arginfo->timeout);
  if (res == 1) {
    if (arginfo->timeout > 0) {
      if (arginfo->timeout < 60) {
        return (0);
      } else {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad timeout given! Exiting\n");
        print_usage(*(outargs->argv + 0));
        exit(1);
      }
    } else {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad timeout given! Exiting\n");
      print_usage(*(outargs->argv + 0));
      exit(1);
    }
  } else {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Bad timeout given! Exiting\n");
    print_usage(*(outargs->argv + 0));
    exit(1);
  }
  }
  return (1);
}
}
int main(int argc , char **argv ) 
{ 
  struct gaicb **list ;
  struct host *hosts ;
  struct host *h ;
  int hostnames ;
  int host_count ;
  struct fuse_args args ;
  struct arginfo arginfo ;
  struct stat mountdir ;
  int res ;
  int tmp ;
  int tmp___0 ;
  struct host *host ;

  {
  hosts = (struct host *)((void *)0);
  args.argc = argc;
  args.argv = argv;
  args.allocated = 0;
  memset((void *)(& arginfo), 0, sizeof(arginfo));
  arginfo.timeout = 1;
  tmp = fuse_opt_parse(& args, (void *)(& arginfo), pingfs_opts, & pingfs_opt_proc);
  if (tmp == -1) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error parsing options!\n");
    print_usage(*(argv + 0));
    return (1);
  }
  if (arginfo.num_args != 2) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Need two arguments!\n");
    print_usage(*(argv + 0));
    return (1);
  }
  res = stat((char const   * __restrict  )arginfo.mountpoint, (struct stat * __restrict  )(& mountdir));
  if (res) {
    perror("Failed to check mountpoint");
    return (1);
  }
  if (! ((mountdir.st_mode & 61440U) == 16384U)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Mountpoint must be a directory! Exiting\n");
    return (1);
  }
  free((void *)arginfo.mountpoint);
  hostnames = read_hostnames((char const   *)arginfo.hostfile, & list);
  free((void *)arginfo.hostfile);
  if (! hostnames) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"No hosts configured! Exiting\n");
    return (1);
  }
  tmp___0 = net_open_sockets();
  if (tmp___0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"No raw sockets opened. Got root?\n");
    return (1);
  }
  host_count = resolve_names(list, hostnames, & hosts);
  if (host_count < 0) {
    return (1);
  }
  host_count = host_evaluate(& hosts, host_count, arginfo.timeout);
  if (! host_count) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"No host passed the test\n");
    return (1);
  }
  chunk_set_timeout(arginfo.timeout);
  host_use(hosts);
  fuse_opt_add_arg(& args, "-f");
  fuse_opt_add_arg(& args, "-s");
  fuse_opt_add_arg(& args, "-odefault_permissions,allow_other");
  fuse_opt_add_arg(& args, "-odirect_io");
  printf((char const   * __restrict  )"Mounting filesystem\n");
  fuse_main_real(args.argc, args.argv, & fs_ops, sizeof(fs_ops), (void *)0);
  fuse_opt_free_args(& args);
  h = hosts;
  while (h) {
    host = h;
    h = h->next;
    free((void *)host);
  }
  return (0);
}
}
#pragma merger("0","/tmp/cil-G8ADnnP0.i","-Wall,-Wshadow,-pedantic,-g")
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
void net_start(void) ;
void net_stop(void) ;
struct chunk *chunk_create(void) ;
void chunk_free(struct chunk *c ) ;
void chunk_add(struct chunk *c ) ;
void chunk_remove(struct chunk *c ) ;
int chunk_wait_for(struct chunk *c , uint8_t **data ) ;
void chunk_done(struct chunk *c , uint8_t *data , size_t len ) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
struct file *files  ;
static void fs_free(struct file *f ) 
{ 
  struct chunk *c ;
  struct chunk *next ;

  {
  c = f->chunks;
  while (c) {
    next = c->next_file;
    chunk_remove(c);
    chunk_free(c);
    c = next;
  }
  free((void *)f->name);
  free((void *)f);
  return;
}
}
static size_t file_size(struct file *f ) 
{ 
  struct chunk *c ;
  size_t size ;

  {
  size = (size_t )0;
  c = f->chunks;
  while (c) {
    size += (size_t )c->len;
    c = c->next_file;
  }
  return (size);
}
}
static void *fs_init(struct fuse_conn_info *conn ) 
{ 


  {
  net_start();
  return ((void *)0);
}
}
static void fs_destroy(void *data ) 
{ 
  struct file *f ;
  struct file *next ;

  {
  net_stop();
  f = files;
  while (f) {
    next = f->next;
    fs_free(f);
    f = next;
  }
  return;
}
}
static struct file *find_file(char const   *name ) 
{ 
  struct file *f ;
  int tmp ;

  {
  f = files;
  while (f) {
    tmp = strcmp(name, f->name);
    if (tmp == 0) {
      return (f);
    }
    f = f->next;
  }
  return ((struct file *)((void *)0));
}
}
static int fs_mkdir(char const   *name , mode_t mode ) 
{ 


  {
  return (-95);
}
}
static int fs_mknod(char const   *name , mode_t mode , dev_t device ) 
{ 
  struct file *f ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  if (! ((mode & 61440U) == 32768U)) {
    return (-95);
  }
  f = find_file(name);
  if (f) {
    return (-17);
  }
  tmp = calloc((size_t )1, sizeof(struct file ));
  f = (struct file *)tmp;
  if (! f) {
    tmp___0 = __errno_location();
    return (- *tmp___0);
  }
  tmp___1 = strdup(name);
  f->name = (char const   *)tmp___1;
  f->mode = mode;
  f->next = files;
  files = f;
  return (0);
}
}
static int fs_chmod(char const   *name , mode_t mode ) 
{ 
  struct file *f ;

  {
  f = find_file(name);
  if (! f) {
    return (-2);
  }
  f->mode = mode;
  return (0);
}
}
static int fs_utime(char const   *name , struct utimbuf *utim ) 
{ 
  struct file *f ;

  {
  f = find_file(name);
  if (! f) {
    return (-2);
  }
  return (0);
}
}
static int fs_getattr(char const   *name , struct stat *stat___0 ) 
{ 
  struct file *f ;
  int tmp ;
  size_t tmp___0 ;

  {
  stat___0->st_nlink = (__nlink_t )1;
  stat___0->st_uid = getuid();
  stat___0->st_gid = getgid();
  stat___0->st_atim.tv_sec = (__time_t )0;
  stat___0->st_mtim.tv_sec = (__time_t )0;
  stat___0->st_ctim.tv_sec = (__time_t )0;
  tmp = strcmp("/", name);
  if (tmp == 0) {
    stat___0->st_mode = (__mode_t )16893;
    stat___0->st_size = (__off_t )0;
    stat___0->st_blksize = (__blksize_t )0;
    stat___0->st_blocks = (__blkcnt_t )0;
    return (0);
  }
  f = find_file(name);
  if (! f) {
    return (-2);
  }
  stat___0->st_mode = f->mode;
  tmp___0 = file_size(f);
  stat___0->st_size = (__off_t )tmp___0;
  return (0);
}
}
static int fs_unlink(char const   *name ) 
{ 
  struct file *f ;
  struct file *last ;
  int tmp ;

  {
  f = files;
  last = (struct file *)((void *)0);
  while (f) {
    tmp = strcmp(name, f->name);
    if (tmp == 0) {
      if (last) {
        last->next = f->next;
      } else {
        files = f->next;
      }
      fs_free(f);
      return (0);
    }
    last = f;
    f = f->next;
  }
  return (-2);
}
}
static int fs_readdir(char const   *path , void *buf , int (*filler)(void *buf , char const   *name ,
                                                                     struct stat  const  *stbuf ,
                                                                     off_t off ) ,
                      off_t offset , struct fuse_file_info *fi ) 
{ 
  struct file *f ;
  int tmp ;

  {
  tmp = strcmp("/", path);
  if (tmp) {
    return (-2);
  }
  (*filler)(buf, ".", (struct stat  const  *)((void *)0), (off_t )0);
  (*filler)(buf, "..", (struct stat  const  *)((void *)0), (off_t )0);
  f = files;
  while (f) {
    (*filler)(buf, f->name + 1, (struct stat  const  *)((void *)0), (off_t )0);
    f = f->next;
  }
  return (0);
}
}
static int fs_open(char const   *name , struct fuse_file_info *fileinfo ) 
{ 
  struct file *f ;

  {
  f = find_file(name);
  if (! f) {
    return (-2);
  }
  return (0);
}
}
static int fs_inner_write(struct file *f , char const   *buf , size_t size , off_t offset ) 
{ 
  struct chunk *c ;
  struct chunk *last ;
  uint8_t *chunkdata ;
  int len ;
  int clen ;
  void *tmp ;

  {
  last = (struct chunk *)((void *)0);
  c = f->chunks;
  while (1) {
    if (c) {
      if (! (offset >= (off_t )c->len)) {
        break;
      }
    } else {
      break;
    }
    if ((int )c->len != 1024) {
      break;
    }
    offset -= (off_t )c->len;
    last = c;
    c = c->next_file;
  }
  if (! c) {
    c = chunk_create();
    if (size < 1024UL) {
      c->len = (uint16_t )size;
    } else {
      c->len = (uint16_t )1024;
    }
    chunk_add(c);
    if (last) {
      last->next_file = c;
    } else {
      f->chunks = c;
    }
    c->host = host_get_next();
    net_send(c->host, c->id, c->seqno, (uint8_t const   *)buf, (size_t )c->len);
    return ((int )c->len);
  }
  chunkdata = (uint8_t *)((void *)0);
  clen = chunk_wait_for(c, & chunkdata);
  if (clen <= 0) {
    return (clen);
  }
  if (1024UL < size + (size_t )offset) {
    clen = 1024;
  } else {
    clen = (int )(size + (size_t )offset);
  }
  if ((size_t )((off_t )clen - offset) < size) {
    len = (int )((off_t )clen - offset);
  } else {
    len = (int )size;
  }
  tmp = realloc((void *)chunkdata, (size_t )clen);
  chunkdata = (uint8_t *)tmp;
  memcpy((void * __restrict  )(chunkdata + offset), (void const   * __restrict  )buf,
         (size_t )len);
  chunk_done(c, chunkdata, (size_t )clen);
  return (len);
}
}
static int fs_write(char const   *name , char const   *buf , size_t size , off_t offset ,
                    struct fuse_file_info *fileinfo ) 
{ 
  struct file *f ;
  int tmp ;

  {
  f = find_file(name);
  if (! f) {
    return (-2);
  }
  tmp = fs_inner_write(f, buf, size, offset);
  return (tmp);
}
}
static int fs_read(char const   *name , char *buf , size_t size , off_t offset , struct fuse_file_info *fileinfo ) 
{ 
  struct file *f ;
  struct chunk *c ;
  uint8_t *chunkdata ;
  int len ;
  int clen ;

  {
  f = find_file(name);
  if (! f) {
    return (-2);
  }
  c = f->chunks;
  while (1) {
    if (c) {
      if (! (offset >= (off_t )c->len)) {
        break;
      }
    } else {
      break;
    }
    offset -= (off_t )c->len;
    c = c->next_file;
  }
  if (! c) {
    return (0);
  }
  if ((size_t )((off_t )c->len - offset) < size) {
    len = (int )((off_t )c->len - offset);
  } else {
    len = (int )size;
  }
  chunkdata = (uint8_t *)((void *)0);
  clen = chunk_wait_for(c, & chunkdata);
  if (! clen) {
    return (-5);
  }
  memcpy((void * __restrict  )buf, (void const   * __restrict  )(chunkdata + offset),
         (size_t )len);
  chunk_done(c, chunkdata, (size_t )clen);
  return (len);
}
}
static int shrink_file(struct file *f , off_t length ) 
{ 
  struct chunk *c ;
  struct chunk *prev ;
  struct chunk *next ;
  uint8_t *cdata ;
  int clen ;

  {
  c = f->chunks;
  prev = (struct chunk *)((void *)0);
  while ((off_t )c->len <= length) {
    length -= (off_t )c->len;
    prev = c;
    c = c->next_file;
  }
  if (! length) {
    if (prev) {
      prev->next_file = (struct chunk *)((void *)0);
    } else {
      f->chunks = (struct chunk *)((void *)0);
    }
  }
  while (c) {
    next = c->next_file;
    if (length) {
      clen = chunk_wait_for(c, & cdata);
      if (! clen) {
        return (-5);
      }
      chunk_done(c, cdata, (size_t )length);
      c->next_file = (struct chunk *)((void *)0);
      length = (off_t )0;
    } else {
      chunk_remove(c);
      chunk_free(c);
    }
    c = next;
  }
  return (0);
}
}
static int grow_file(struct file *f , off_t length ) 
{ 
  int offset ;
  size_t tmp ;
  int to_grow ;
  char zerobuf[1024] ;
  int res ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = file_size(f);
  offset = (int )tmp;
  to_grow = (int )(length - (off_t )offset);
  memset((void *)(zerobuf), 0, sizeof(zerobuf));
  while (to_grow) {
    if (to_grow < 1024) {
      tmp___0 = to_grow;
    } else {
      tmp___0 = 1024;
    }
    tmp___1 = fs_inner_write(f, (char const   *)(zerobuf), (size_t )tmp___0, (off_t )offset);
    res = tmp___1;
    if (res < 0) {
      return (res);
    }
    if (! res) {
      __assert_fail("res", "fs.c", 379U, "grow_file");
    }
    offset += res;
    to_grow -= res;
  }
  return (0);
}
}
static int fs_truncate(char const   *name , off_t length ) 
{ 
  struct file *f ;
  int cur_size ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  f = find_file(name);
  if (! f) {
    return (-2);
  }
  tmp = file_size(f);
  cur_size = (int )tmp;
  if (length > (off_t )cur_size) {
    tmp___0 = grow_file(f, length);
    return (tmp___0);
  }
  if (length < (off_t )cur_size) {
    tmp___1 = shrink_file(f, length);
    return (tmp___1);
  }
  return (0);
}
}
static int fs_rename(char const   *name , char const   *newname ) 
{ 
  struct file *f ;
  char *tmp ;

  {
  f = find_file(name);
  if (! f) {
    return (-2);
  }
  free((void *)f->name);
  tmp = strdup(newname);
  f->name = (char const   *)tmp;
  return (0);
}
}
struct fuse_operations  const  fs_ops  = 
     {& fs_getattr, (int (*)(char const   * , char * , size_t  ))0, (int (*)(char const   * ,
                                                                           fuse_dirh_t  ,
                                                                           int (*)(fuse_dirh_t h ,
                                                                                   char const   *name ,
                                                                                   int type ,
                                                                                   ino_t ino ) ))0,
    & fs_mknod, & fs_mkdir, & fs_unlink, (int (*)(char const   * ))0, (int (*)(char const   * ,
                                                                               char const   * ))0,
    & fs_rename, (int (*)(char const   * , char const   * ))0, & fs_chmod, (int (*)(char const   * ,
                                                                                    uid_t  ,
                                                                                    gid_t  ))0,
    & fs_truncate, & fs_utime, & fs_open, & fs_read, & fs_write, (int (*)(char const   * ,
                                                                          struct statvfs * ))0,
    (int (*)(char const   * , struct fuse_file_info * ))0, (int (*)(char const   * ,
                                                                    struct fuse_file_info * ))0,
    (int (*)(char const   * , int  , struct fuse_file_info * ))0, (int (*)(char const   * ,
                                                                           char const   * ,
                                                                           char const   * ,
                                                                           size_t  ,
                                                                           int  ))0,
    (int (*)(char const   * , char const   * , char * , size_t  ))0, (int (*)(char const   * ,
                                                                              char * ,
                                                                              size_t  ))0,
    (int (*)(char const   * , char const   * ))0, (int (*)(char const   * , struct fuse_file_info * ))0,
    & fs_readdir, (int (*)(char const   * , struct fuse_file_info * ))0, (int (*)(char const   * ,
                                                                                  int  ,
                                                                                  struct fuse_file_info * ))0,
    & fs_init, & fs_destroy, (int (*)(char const   * , int  ))0, (int (*)(char const   * ,
                                                                          mode_t  ,
                                                                          struct fuse_file_info * ))0,
    (int (*)(char const   * , off_t  , struct fuse_file_info * ))0, (int (*)(char const   * ,
                                                                             struct stat * ,
                                                                             struct fuse_file_info * ))0,
    (int (*)(char const   * , struct fuse_file_info * , int cmd , struct flock * ))0,
    (int (*)(char const   * , struct timespec  const  *tv ))0, (int (*)(char const   * ,
                                                                        size_t blocksize ,
                                                                        uint64_t *idx ))0,
    0U, 0U, 0U, 0U, (int (*)(char const   * , int cmd , void *arg , struct fuse_file_info * ,
                             unsigned int flags , void *data ))0, (int (*)(char const   * ,
                                                                           struct fuse_file_info * ,
                                                                           struct fuse_pollhandle *ph ,
                                                                           unsigned int *reventsp ))0,
    (int (*)(char const   * , struct fuse_bufvec *buf , off_t off , struct fuse_file_info * ))0,
    (int (*)(char const   * , struct fuse_bufvec **bufp , size_t size , off_t off ,
             struct fuse_file_info * ))0, (int (*)(char const   * , struct fuse_file_info * ,
                                                   int op ))0, (int (*)(char const   * ,
                                                                        int  , off_t  ,
                                                                        off_t  , struct fuse_file_info * ))0};
#pragma merger("0","/tmp/cil-f7_EiQMq.i","-Wall,-Wshadow,-pedantic,-g")
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
void chunk_reply(void *userdata , struct sockaddr_storage *addr , size_t addrlen ,
                 uint16_t id , uint16_t seqno , uint8_t **data , size_t len ) ;
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
extern int pthread_cancel(pthread_t __th ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
static int sockv4  ;
static int sockv6  ;
static struct net_data netdata  ;
static void inc_stats(struct pkt_stats *stats , int packetsize ) 
{ 


  {
  pthread_mutex_lock(& netdata.stats_mutex);
  (stats->packets) ++;
  stats->bytes += (unsigned long long )(packetsize + 8);
  pthread_mutex_unlock(& netdata.stats_mutex);
  return;
}
}
static void net_inc_tx(int packetsize ) 
{ 


  {
  inc_stats(& netdata.tx, packetsize);
  return;
}
}
void net_inc_rx(int packetsize ) 
{ 


  {
  inc_stats(& netdata.rx, packetsize);
  return;
}
}
int net_open_sockets(void) 
{ 
  int rcvbuf ;
  int res ;
  int tmp ;
  struct icmp6_filter filter ;
  int res___0 ;
  int tmp___0 ;

  {
  rcvbuf = 1048576;
  sockv4 = socket(2, 3, 1);
  if (sockv4 < 0) {
    perror("Failed to open IPv4 socket");
  } else {
    tmp = setsockopt(sockv4, 1, 8, (void const   *)(& rcvbuf), (socklen_t )sizeof(rcvbuf));
    res = tmp;
    if (res < 0) {
      perror("Failed to set receive buffer size on IPv4 socket");
    }
  }
  sockv6 = socket(10, 3, 58);
  if (sockv6 >= 0) {
    tmp___0 = setsockopt(sockv6, 1, 8, (void const   *)(& rcvbuf), (socklen_t )sizeof(rcvbuf));
    res___0 = tmp___0;
    if (res___0 < 0) {
      perror("Failed to set receive buffer size on IPv6 socket");
    }
    memset((void *)(& filter), 255, sizeof(struct icmp6_filter ));
    filter.icmp6_filt[129 >> 5] &= (unsigned int )(~ (1 << 1));
    res___0 = setsockopt(sockv6, 58, 1, (void const   *)(& filter), (socklen_t )sizeof(filter));
    if (res___0 < 0) {
      perror("Failed to set ICMP filters on IPv6 socket");
    }
  } else {
    perror("Failed to open IPv6 socket");
  }
  if (sockv4 < 0) {
    if (sockv6 < 0) {
      return (1);
    }
  }
  return (0);
}
}
void net_send(struct host *host , uint16_t id , uint16_t seqno , uint8_t const   *data ,
              size_t len ) 
{ 
  int sock ;
  struct icmp_packet pkt ;
  int tmp ;

  {
  memcpy((void * __restrict  )(& pkt.peer), (void const   * __restrict  )(& host->sockaddr),
         (size_t )host->sockaddr_len);
  pkt.peer_len = host->sockaddr_len;
  pkt.type = (enum icmp_type )0;
  pkt.id = id;
  pkt.seqno = seqno;
  pkt.payload = (uint8_t *)data;
  pkt.payload_len = (uint32_t )len;
  if ((int )pkt.peer.ss_family == 2) {
    sock = sockv4;
  } else {
    sock = sockv6;
  }
  if (sock >= 0) {
    net_inc_tx((int )pkt.payload_len);
    tmp = icmp_send(sock, & pkt);
    if (! tmp) {
      perror("Failed sending data packet");
    }
  }
  return;
}
}
static void handle_recv(int sock , void (*recv_fn)(void *userdata , struct sockaddr_storage *addr ,
                                                   size_t addrlen , uint16_t id ,
                                                   uint16_t seqno , uint8_t **data ,
                                                   size_t len ) , void *recv_data ) 
{ 
  struct icmp_packet mypkt ;
  uint8_t buf[8192] ;
  int len ;
  ssize_t tmp ;
  int tmp___0 ;

  {
  mypkt.peer_len = (socklen_t )sizeof(struct sockaddr_storage );
  tmp = recvfrom(sock, (void * __restrict  )(buf), sizeof(buf), 0, (struct sockaddr * __restrict  )((struct sockaddr *)(& mypkt.peer)),
                 (socklen_t * __restrict  )(& mypkt.peer_len));
  len = (int )tmp;
  if (len > 0) {
    tmp___0 = icmp_parse(& mypkt, buf, len);
    if (tmp___0 == 0) {
      if ((unsigned int )mypkt.type == 1U) {
        (*recv_fn)(recv_data, & mypkt.peer, (size_t )mypkt.peer_len, mypkt.id, mypkt.seqno,
                   & mypkt.payload, (size_t )mypkt.payload_len);
      }
      free((void *)mypkt.payload);
    }
  }
  return;
}
}
int net_recv(struct timeval *tv , void (*recv_fn)(void *userdata , struct sockaddr_storage *addr ,
                                                  size_t addrlen , uint16_t id , uint16_t seqno ,
                                                  uint8_t **data , size_t len ) ,
             void *recv_data ) 
{ 
  int maxfd ;
  fd_set fds ;
  int i ;
  int __d0 ;
  int __d1 ;

  {
  while (1) {
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fds.fds_bits[0]): "memory");
    break;
  }
  if (sockv4 >= 0) {
    fds.fds_bits[sockv4 / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << sockv4 % (8 * (int )sizeof(__fd_mask )));
  }
  if (sockv6 >= 0) {
    fds.fds_bits[sockv6 / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << sockv6 % (8 * (int )sizeof(__fd_mask )));
  }
  if (sockv4 > sockv6) {
    maxfd = sockv4;
  } else {
    maxfd = sockv6;
  }
  i = select(maxfd + 1, (fd_set * __restrict  )(& fds), (fd_set * __restrict  )((void *)0),
             (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )tv);
  if (sockv4 >= 0) {
    if ((fds.fds_bits[sockv4 / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << sockv4 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      handle_recv(sockv4, recv_fn, recv_data);
    }
  }
  if (sockv6 >= 0) {
    if ((fds.fds_bits[sockv6 / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << sockv6 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      handle_recv(sockv6, recv_fn, recv_data);
    }
  }
  return (i);
}
}
static void *responder_thread(void *arg ) 
{ 
  struct timeval tv ;

  {
  while (1) {
    tv.tv_sec = (__time_t )1;
    tv.tv_usec = (__suseconds_t )0;
    net_recv(& tv, & chunk_reply, (void *)0);
  }
  return ((void *)0);
}
}
static void get_stats(struct pkt_stats *rx , struct pkt_stats *tx ) 
{ 


  {
  pthread_mutex_lock(& netdata.stats_mutex);
  memcpy((void * __restrict  )rx, (void const   * __restrict  )(& netdata.rx), sizeof(netdata.rx));
  memcpy((void * __restrict  )tx, (void const   * __restrict  )(& netdata.tx), sizeof(netdata.tx));
  pthread_mutex_unlock(& netdata.stats_mutex);
  return;
}
}
static float format_bytes(unsigned long long bytes , char const   **suffix ) 
{ 
  char const   *suffixes[5] ;
  int i ;
  float bps ;

  {
  suffixes[0] = "B";
  suffixes[1] = "kB";
  suffixes[2] = "MB";
  suffixes[3] = "GB";
  suffixes[4] = (char const   *)((void *)0);
  i = 0;
  bps = (float )bytes;
  while (1) {
    if (suffixes[i + 1]) {
      if (! (bps > (float )1300)) {
        break;
      }
    } else {
      break;
    }
    bps /= 1000.0f;
    i ++;
  }
  *suffix = suffixes[i];
  return (bps);
}
}
static void diff_stats(struct pkt_stats *new , struct pkt_stats *old ) 
{ 
  struct pkt_stats diff ;
  float bytes ;
  char const   *byte_suffix ;

  {
  diff.packets = new->packets - old->packets;
  diff.bytes = new->bytes - old->bytes;
  memcpy((void * __restrict  )old, (void const   * __restrict  )new, sizeof(*old));
  bytes = format_bytes(diff.bytes, & byte_suffix);
  printf((char const   * __restrict  )"%6llu pkt/s, %7.01f %2s/s", diff.packets, (double )bytes,
         byte_suffix);
  return;
}
}
static struct pkt_stats prev_rx  ;
static struct pkt_stats prev_tx  ;
static void *status_thread(void *arg ) 
{ 
  struct timespec status_sleep ;
  struct pkt_stats rx ;
  struct pkt_stats tx ;

  {
  status_sleep.tv_sec = (__time_t )1;
  status_sleep.tv_nsec = (__syscall_slong_t )0;
  get_stats(& prev_rx, & prev_tx);
  nanosleep((struct timespec  const  *)(& status_sleep), (struct timespec *)((void *)0));
  while (1) {
    get_stats(& rx, & tx);
    printf((char const   * __restrict  )"\rICMP in: ");
    diff_stats(& rx, & prev_rx);
    printf((char const   * __restrict  )"    ICMP out: ");
    diff_stats(& tx, & prev_tx);
    fflush(stdout);
    nanosleep((struct timespec  const  *)(& status_sleep), (struct timespec *)((void *)0));
  }
  return ((void *)0);
}
}
void net_start(void) 
{ 
  int tmp ;

  {
  tmp = pthread_mutex_init(& netdata.stats_mutex, (pthread_mutexattr_t const   *)((void *)0));
  if (tmp) {
    perror("Fatal, failed to create a mutex");
    exit(1);
  }
  pthread_create((pthread_t * __restrict  )(& netdata.responder), (pthread_attr_t const   * __restrict  )((void *)0),
                 & responder_thread, (void * __restrict  )((void *)0));
  pthread_create((pthread_t * __restrict  )(& netdata.status), (pthread_attr_t const   * __restrict  )((void *)0),
                 & status_thread, (void * __restrict  )((void *)0));
  return;
}
}
void net_stop(void) 
{ 


  {
  pthread_cancel(netdata.responder);
  pthread_join(netdata.responder, (void **)((void *)0));
  pthread_cancel(netdata.status);
  pthread_join(netdata.status, (void **)((void *)0));
  pthread_mutex_lock(& netdata.stats_mutex);
  printf((char const   * __restrict  )"\n\nTotal network resources consumed:\nin:  %10llu packets, %10llu bytes\nout: %10llu packets, %10llu bytes\n (bytes counted above IP level)\n",
         netdata.rx.packets, netdata.rx.bytes, netdata.tx.packets, netdata.tx.bytes);
  pthread_mutex_unlock(& netdata.stats_mutex);
  return;
}
}
#pragma merger("0","/tmp/cil-tJWv9_nS.i","-Wall,-Wshadow,-pedantic,-g")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                                              pthread_condattr_t const   * __restrict  __cond_attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_signal)(pthread_cond_t *__cond ) ;
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
extern int ( __attribute__((__nonnull__(1,2,3))) pthread_cond_timedwait)(pthread_cond_t * __restrict  __cond ,
                                                                         pthread_mutex_t * __restrict  __mutex ,
                                                                         struct timespec  const  * __restrict  __abstime ) ;
static uint16_t icmp_id  ;
static int timeout  ;
static struct chunk *chunk_head  ;
static pthread_mutex_t chunk_mutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
void chunk_set_timeout(int t ) 
{ 


  {
  timeout = t;
  return;
}
}
struct chunk *chunk_create(void) 
{ 
  struct chunk *c ;
  void *tmp ;
  uint16_t tmp___0 ;

  {
  tmp = calloc((size_t )1, sizeof(*c));
  c = (struct chunk *)tmp;
  if (! c) {
    return ((struct chunk *)((void *)0));
  }
  tmp___0 = icmp_id;
  icmp_id = (uint16_t )((int )icmp_id + 1);
  c->id = tmp___0;
  return (c);
}
}
void chunk_free(struct chunk *c ) 
{ 


  {
  free((void *)c);
  return;
}
}
void chunk_add(struct chunk *c ) 
{ 


  {
  pthread_mutex_lock(& chunk_mutex);
  c->next_active = chunk_head;
  chunk_head = c;
  pthread_mutex_unlock(& chunk_mutex);
  return;
}
}
void chunk_remove(struct chunk *c ) 
{ 
  struct chunk *prev ;
  struct chunk *curr ;

  {
  prev = (struct chunk *)((void *)0);
  pthread_mutex_lock(& chunk_mutex);
  curr = chunk_head;
  while (curr) {
    if ((unsigned long )curr == (unsigned long )c) {
      if (prev) {
        prev->next_active = curr->next_active;
      } else {
        chunk_head = curr->next_active;
      }
      break;
    }
    prev = curr;
    curr = curr->next_active;
  }
  pthread_mutex_unlock(& chunk_mutex);
  return;
}
}
static void process_chunk(struct chunk *c , uint8_t **data ) 
{ 
  struct io *io ;

  {
  c->seqno = (uint16_t )((int )c->seqno + 1);
  if (c->io) {
    io = c->io;
    pthread_mutex_lock(& io->mutex);
    io->data = *data;
    io->len = (size_t )c->len;
    io->owner = (enum io_owner )1;
    pthread_cond_signal(& io->fs_cond);
    while ((unsigned int )io->owner != 2U) {
      pthread_cond_wait((pthread_cond_t * __restrict  )(& io->net_cond), (pthread_mutex_t * __restrict  )(& io->mutex));
    }
    *data = io->data;
    pthread_mutex_unlock(& io->mutex);
    free((void *)c->io);
    c->io = (struct io *)((void *)0);
  }
  net_send(c->host, c->id, c->seqno, (uint8_t const   *)*data, (size_t )c->len);
  return;
}
}
void chunk_reply(void *userdata , struct sockaddr_storage *addr , size_t addrlen ,
                 uint16_t id , uint16_t seqno , uint8_t **data , size_t len ) 
{ 
  struct chunk *c ;

  {
  pthread_mutex_lock(& chunk_mutex);
  c = chunk_head;
  while (c) {
    if ((int )c->id == (int )id) {
      net_inc_rx((int )len);
      if (len == (size_t )c->len) {
        if ((int )seqno == (int )c->seqno) {
          process_chunk(c, data);
        }
      }
      break;
    }
    c = c->next_active;
  }
  pthread_mutex_unlock(& chunk_mutex);
  return;
}
}
int chunk_wait_for(struct chunk *c , uint8_t **data ) 
{ 
  void *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int res ;
  struct timespec ts ;

  {
  pthread_mutex_lock(& chunk_mutex);
  if (c->io) {
    pthread_mutex_unlock(& chunk_mutex);
    return (-16);
  }
  tmp = calloc((size_t )1, sizeof(struct io ));
  c->io = (struct io *)tmp;
  if (! c->io) {
    pthread_mutex_unlock(& chunk_mutex);
    return (-12);
  }
  pthread_mutex_unlock(& chunk_mutex);
  (c->io)->owner = (enum io_owner )2;
  pthread_cond_init((pthread_cond_t * __restrict  )(& (c->io)->fs_cond), (pthread_condattr_t const   * __restrict  )((void *)0));
  pthread_cond_init((pthread_cond_t * __restrict  )(& (c->io)->net_cond), (pthread_condattr_t const   * __restrict  )((void *)0));
  tmp___1 = pthread_mutex_init(& (c->io)->mutex, (pthread_mutexattr_t const   *)((void *)0));
  if (tmp___1) {
    pthread_mutex_unlock(& chunk_mutex);
    free((void *)c->io);
    tmp___0 = __errno_location();
    return (- *tmp___0);
  }
  pthread_mutex_lock(& (c->io)->mutex);
  while ((unsigned int )(c->io)->owner != 1U) {
    clock_gettime(0, & ts);
    ts.tv_sec += (__time_t )timeout;
    res = pthread_cond_timedwait((pthread_cond_t * __restrict  )(& (c->io)->fs_cond),
                                 (pthread_mutex_t * __restrict  )(& (c->io)->mutex),
                                 (struct timespec  const  * __restrict  )(& ts));
    if (res) {
      pthread_mutex_unlock(& (c->io)->mutex);
      pthread_mutex_lock(& chunk_mutex);
      free((void *)c->io);
      c->io = (struct io *)((void *)0);
      pthread_mutex_unlock(& chunk_mutex);
      return (0);
    }
  }
  *data = (c->io)->data;
  return ((int )(c->io)->len);
}
}
void chunk_done(struct chunk *c , uint8_t *data , size_t len ) 
{ 


  {
  (c->io)->data = data;
  (c->io)->len = len;
  c->len = (uint16_t )(c->io)->len;
  (c->io)->owner = (enum io_owner )2;
  pthread_cond_signal(& (c->io)->net_cond);
  pthread_mutex_unlock(& (c->io)->mutex);
  return;
}
}
