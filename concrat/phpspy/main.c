/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef unsigned long __uint64_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned long __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef int __pid_t;
typedef long __clock_t;
typedef long __time_t;
typedef long __suseconds_t;
typedef int __clockid_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __blkcnt64_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
typedef unsigned long size_t;
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
typedef __pid_t pid_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
typedef __clockid_t clockid_t;
typedef unsigned long pthread_t;
struct __anonstruct___sigset_t_991265788 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___sigset_t_991265788 __sigset_t;
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
typedef union sigval __sigval_t;
struct __anonstruct__kill_244518854 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
struct __anonstruct__timer_490064738 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
struct __anonstruct__rt_619254530 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
struct __anonstruct__sigchld_284671705 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
struct __anonstruct__addr_bnd_5259977 {
   void *_lower ;
   void *_upper ;
};
union __anonunion__bounds_814482283 {
   struct __anonstruct__addr_bnd_5259977 _addr_bnd ;
   __uint32_t _pkey ;
};
struct __anonstruct__sigfault_168944780 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion__bounds_814482283 _bounds ;
};
struct __anonstruct__sigpoll_386613454 {
   long si_band ;
   int si_fd ;
};
struct __anonstruct__sigsys_44812255 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
union __anonunion__sifields_339798158 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_244518854 _kill ;
   struct __anonstruct__timer_490064738 _timer ;
   struct __anonstruct__rt_619254530 _rt ;
   struct __anonstruct__sigchld_284671705 _sigchld ;
   struct __anonstruct__sigfault_168944780 _sigfault ;
   struct __anonstruct__sigpoll_386613454 _sigpoll ;
   struct __anonstruct__sigsys_44812255 _sigsys ;
};
struct __anonstruct_siginfo_t_201813247 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion__sifields_339798158 _sifields ;
};
typedef struct __anonstruct_siginfo_t_201813247 siginfo_t;
union __anonunion___sigaction_handler_363639592 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
struct sigaction {
   union __anonunion___sigaction_handler_363639592 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
typedef __builtin_va_list __gnuc_va_list;
typedef long ptrdiff_t;
typedef int wchar_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
union __anonunion___value_919941124 {
   unsigned int __wch ;
   char __wchb[4] ;
};
struct __anonstruct___mbstate_t_408856939 {
   int __count ;
   union __anonunion___value_919941124 __value ;
};
typedef struct __anonstruct___mbstate_t_408856939 __mbstate_t;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef __gnuc_va_list va_list___0;
typedef __ssize_t ssize_t;
typedef long __fd_mask;
struct __anonstruct_fd_set_356711149 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
typedef struct __anonstruct_fd_set_356711149 fd_set;
enum __ptrace_request {
    PTRACE_TRACEME = 0,
    PTRACE_PEEKTEXT = 1,
    PTRACE_PEEKDATA = 2,
    PTRACE_PEEKUSER = 3,
    PTRACE_POKETEXT = 4,
    PTRACE_POKEDATA = 5,
    PTRACE_POKEUSER = 6,
    PTRACE_CONT = 7,
    PTRACE_KILL = 8,
    PTRACE_SINGLESTEP = 9,
    PTRACE_GETREGS = 12,
    PTRACE_SETREGS = 13,
    PTRACE_GETFPREGS = 14,
    PTRACE_SETFPREGS = 15,
    PTRACE_ATTACH = 16,
    PTRACE_DETACH = 17,
    PTRACE_GETFPXREGS = 18,
    PTRACE_SETFPXREGS = 19,
    PTRACE_SYSCALL = 24,
    PTRACE_GET_THREAD_AREA = 25,
    PTRACE_SET_THREAD_AREA = 26,
    PTRACE_ARCH_PRCTL = 30,
    PTRACE_SYSEMU = 31,
    PTRACE_SYSEMU_SINGLESTEP = 32,
    PTRACE_SINGLEBLOCK = 33,
    PTRACE_SETOPTIONS = 16896,
    PTRACE_GETEVENTMSG = 16897,
    PTRACE_GETSIGINFO = 16898,
    PTRACE_SETSIGINFO = 16899,
    PTRACE_GETREGSET = 16900,
    PTRACE_SETREGSET = 16901,
    PTRACE_SEIZE = 16902,
    PTRACE_INTERRUPT = 16903,
    PTRACE_LISTEN = 16904,
    PTRACE_PEEKSIGINFO = 16905,
    PTRACE_GETSIGMASK = 16906,
    PTRACE_SETSIGMASK = 16907,
    PTRACE_SECCOMP_GET_FILTER = 16908,
    PTRACE_SECCOMP_GET_METADATA = 16909,
    PTRACE_GET_SYSCALL_INFO = 16910
} ;
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
typedef unsigned char cc_t;
typedef unsigned int speed_t;
typedef unsigned int tcflag_t;
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
typedef unsigned int wint_t;
typedef __mbstate_t mbstate_t;
typedef uint16_t uintattr_t;
struct tb_cell {
   uint32_t ch ;
   uintattr_t fg ;
   uintattr_t bg ;
};
struct tb_event {
   uint8_t type ;
   uint8_t mod ;
   uint16_t key ;
   uint32_t ch ;
   int32_t w ;
   int32_t h ;
   int32_t x ;
   int32_t y ;
};
typedef unsigned long __re_long_size_t;
typedef unsigned long reg_syntax_t;
struct re_dfa_t ;
struct re_pattern_buffer {
   struct re_dfa_t *buffer ;
   __re_long_size_t allocated ;
   __re_long_size_t used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
typedef struct re_pattern_buffer regex_t;
struct _zend_executor_globals_70  __attribute__((__packed__)) ;
typedef struct _zend_executor_globals_70 zend_executor_globals_70;
struct _zend_execute_data_70  __attribute__((__packed__)) ;
typedef struct _zend_execute_data_70 zend_execute_data_70;
struct _zend_op_array_70  __attribute__((__packed__)) ;
typedef struct _zend_op_array_70 zend_op_array_70;
union _zend_function_70  __attribute__((__packed__)) ;
typedef union _zend_function_70 zend_function_70;
struct _zend_class_entry_70  __attribute__((__packed__)) ;
typedef struct _zend_class_entry_70 zend_class_entry_70;
struct _zend_string_70  __attribute__((__packed__)) ;
typedef struct _zend_string_70 zend_string_70;
struct _zend_op_70  __attribute__((__packed__)) ;
typedef struct _zend_op_70 zend_op_70;
struct _sapi_request_info_70  __attribute__((__packed__)) ;
typedef struct _sapi_request_info_70 sapi_request_info_70;
struct _sapi_globals_struct_70  __attribute__((__packed__)) ;
typedef struct _sapi_globals_struct_70 sapi_globals_struct_70;
union _zend_value_70  __attribute__((__packed__)) ;
typedef union _zend_value_70 zend_value_70;
struct _zval_70  __attribute__((__packed__)) ;
typedef struct _zval_70 zval_70;
struct _Bucket_70  __attribute__((__packed__)) ;
typedef struct _Bucket_70 Bucket_70;
struct _zend_array_70  __attribute__((__packed__)) ;
typedef struct _zend_array_70 zend_array_70;
struct _zend_alloc_globals_70  __attribute__((__packed__)) ;
typedef struct _zend_alloc_globals_70 zend_alloc_globals_70;
struct _zend_mm_heap_70  __attribute__((__packed__)) ;
typedef struct _zend_mm_heap_70 zend_mm_heap_70;
struct _zend_array_70 {
   uint8_t pad0[12] ;
   uint32_t nTableMask ;
   Bucket_70 *arData ;
   uint32_t nNumUsed ;
   uint32_t nNumOfElements ;
   uint32_t nTableSize ;
} __attribute__((__packed__)) ;
struct _zend_executor_globals_70 {
   uint8_t pad0[304] ;
   zend_array_70 symbol_table ;
   uint8_t pad1[140] ;
   zend_execute_data_70 *current_execute_data ;
} __attribute__((__packed__)) ;
struct _zend_execute_data_70 {
   zend_op_70 *opline ;
   uint8_t pad0[16] ;
   zend_function_70 *func ;
   uint8_t pad1[24] ;
   zend_execute_data_70 *prev_execute_data ;
   zend_array_70 *symbol_table ;
} __attribute__((__packed__)) ;
struct _zend_op_array_70 {
   uint8_t pad0[72] ;
   int last_var ;
   uint8_t pad1[4] ;
   zend_string_70 **vars ;
   uint8_t pad2[32] ;
   zend_string_70 *filename ;
   uint32_t line_start ;
} __attribute__((__packed__)) ;
struct __anonstruct_common_869165211 {
   uint8_t pad0[8] ;
   zend_string_70 *function_name ;
   zend_class_entry_70 *scope ;
};
union _zend_function_70 {
   uint8_t type ;
   struct __anonstruct_common_869165211 common ;
   zend_op_array_70 op_array ;
} __attribute__((__packed__)) ;
struct _zend_class_entry_70 {
   uint8_t pad0[8] ;
   zend_string_70 *name ;
} __attribute__((__packed__)) ;
struct _zend_string_70 {
   uint8_t pad0[16] ;
   size_t len ;
   char val[1] ;
} __attribute__((__packed__)) ;
struct _zend_op_70 {
   uint8_t pad0[24] ;
   uint32_t lineno ;
} __attribute__((__packed__)) ;
struct _sapi_request_info_70 {
   uint8_t pad0[8] ;
   char *query_string ;
   char *cookie_data ;
   uint8_t pad1[8] ;
   char *path_translated ;
   char *request_uri ;
} __attribute__((__packed__)) ;
struct _sapi_globals_struct_70 {
   uint8_t pad0[8] ;
   sapi_request_info_70 request_info ;
   uint8_t pad1[384] ;
   double global_request_time ;
} __attribute__((__packed__)) ;
union _zend_value_70 {
   long lval ;
   double dval ;
   zend_string_70 *str ;
   zend_array_70 *arr ;
} __attribute__((__packed__)) ;
struct __anonstruct_v_569059773 {
   uint8_t type ;
   uint8_t pad0[3] ;
};
union __anonunion_u1_468731550 {
   struct __anonstruct_v_569059773 v ;
};
union __anonunion_u2_346947711 {
   uint32_t next ;
};
struct _zval_70 {
   zend_value_70 value ;
   union __anonunion_u1_468731550 u1 ;
   union __anonunion_u2_346947711 u2 ;
} __attribute__((__packed__)) ;
struct _Bucket_70 {
   zval_70 val ;
   uint64_t h ;
   zend_string_70 *key ;
} __attribute__((__packed__)) ;
struct _zend_alloc_globals_70 {
   zend_mm_heap_70 *mm_heap ;
} __attribute__((__packed__)) ;
struct _zend_mm_heap_70 {
   uint8_t pad0[16] ;
   size_t size ;
   size_t peak ;
} __attribute__((__packed__)) ;
struct _zend_executor_globals_71  __attribute__((__packed__)) ;
typedef struct _zend_executor_globals_71 zend_executor_globals_71;
struct _zend_execute_data_71  __attribute__((__packed__)) ;
typedef struct _zend_execute_data_71 zend_execute_data_71;
struct _zend_op_array_71  __attribute__((__packed__)) ;
typedef struct _zend_op_array_71 zend_op_array_71;
union _zend_function_71  __attribute__((__packed__)) ;
typedef union _zend_function_71 zend_function_71;
struct _zend_class_entry_71  __attribute__((__packed__)) ;
typedef struct _zend_class_entry_71 zend_class_entry_71;
struct _zend_string_71  __attribute__((__packed__)) ;
typedef struct _zend_string_71 zend_string_71;
struct _zend_op_71  __attribute__((__packed__)) ;
typedef struct _zend_op_71 zend_op_71;
struct _sapi_request_info_71  __attribute__((__packed__)) ;
typedef struct _sapi_request_info_71 sapi_request_info_71;
struct _sapi_globals_struct_71  __attribute__((__packed__)) ;
typedef struct _sapi_globals_struct_71 sapi_globals_struct_71;
union _zend_value_71  __attribute__((__packed__)) ;
typedef union _zend_value_71 zend_value_71;
struct _zval_71  __attribute__((__packed__)) ;
typedef struct _zval_71 zval_71;
struct _Bucket_71  __attribute__((__packed__)) ;
typedef struct _Bucket_71 Bucket_71;
struct _zend_array_71  __attribute__((__packed__)) ;
typedef struct _zend_array_71 zend_array_71;
struct _zend_alloc_globals_71  __attribute__((__packed__)) ;
typedef struct _zend_alloc_globals_71 zend_alloc_globals_71;
struct _zend_mm_heap_71  __attribute__((__packed__)) ;
typedef struct _zend_mm_heap_71 zend_mm_heap_71;
struct _zend_array_71 {
   uint8_t pad0[12] ;
   uint32_t nTableMask ;
   Bucket_71 *arData ;
   uint32_t nNumUsed ;
   uint32_t nNumOfElements ;
   uint32_t nTableSize ;
} __attribute__((__packed__)) ;
struct _zend_executor_globals_71 {
   uint8_t pad0[304] ;
   zend_array_71 symbol_table ;
   uint8_t pad1[140] ;
   zend_execute_data_71 *current_execute_data ;
} __attribute__((__packed__)) ;
struct _zend_execute_data_71 {
   zend_op_71 *opline ;
   uint8_t pad0[16] ;
   zend_function_71 *func ;
   uint8_t pad1[16] ;
   zend_execute_data_71 *prev_execute_data ;
   zend_array_71 *symbol_table ;
} __attribute__((__packed__)) ;
struct _zend_op_array_71 {
   uint8_t pad0[72] ;
   int last_var ;
   uint8_t pad1[4] ;
   zend_string_71 **vars ;
   uint8_t pad2[32] ;
   zend_string_71 *filename ;
   uint32_t line_start ;
} __attribute__((__packed__)) ;
struct __anonstruct_common_568689746 {
   uint8_t pad0[8] ;
   zend_string_71 *function_name ;
   zend_class_entry_71 *scope ;
};
union _zend_function_71 {
   uint8_t type ;
   struct __anonstruct_common_568689746 common ;
   zend_op_array_71 op_array ;
} __attribute__((__packed__)) ;
struct _zend_class_entry_71 {
   uint8_t pad0[8] ;
   zend_string_71 *name ;
} __attribute__((__packed__)) ;
struct _zend_string_71 {
   uint8_t pad0[16] ;
   size_t len ;
   char val[1] ;
} __attribute__((__packed__)) ;
struct _zend_op_71 {
   uint8_t pad0[24] ;
   uint32_t lineno ;
} __attribute__((__packed__)) ;
struct _sapi_request_info_71 {
   uint8_t pad0[8] ;
   char *query_string ;
   char *cookie_data ;
   uint8_t pad1[8] ;
   char *path_translated ;
   char *request_uri ;
} __attribute__((__packed__)) ;
struct _sapi_globals_struct_71 {
   uint8_t pad0[8] ;
   sapi_request_info_71 request_info ;
   uint8_t pad1[384] ;
   double global_request_time ;
} __attribute__((__packed__)) ;
union _zend_value_71 {
   long lval ;
   double dval ;
   zend_string_71 *str ;
   zend_array_71 *arr ;
} __attribute__((__packed__)) ;
struct __anonstruct_v_569059774 {
   uint8_t type ;
   uint8_t pad0[3] ;
};
union __anonunion_u1_382201446 {
   struct __anonstruct_v_569059774 v ;
};
union __anonunion_u2_569059775 {
   uint32_t next ;
};
struct _zval_71 {
   zend_value_71 value ;
   union __anonunion_u1_382201446 u1 ;
   union __anonunion_u2_569059775 u2 ;
} __attribute__((__packed__)) ;
struct _Bucket_71 {
   zval_71 val ;
   uint64_t h ;
   zend_string_71 *key ;
} __attribute__((__packed__)) ;
struct _zend_alloc_globals_71 {
   zend_mm_heap_71 *mm_heap ;
} __attribute__((__packed__)) ;
struct _zend_mm_heap_71 {
   uint8_t pad0[16] ;
   size_t size ;
   size_t peak ;
} __attribute__((__packed__)) ;
struct _zend_executor_globals_72  __attribute__((__packed__)) ;
typedef struct _zend_executor_globals_72 zend_executor_globals_72;
struct _zend_execute_data_72  __attribute__((__packed__)) ;
typedef struct _zend_execute_data_72 zend_execute_data_72;
struct _zend_op_array_72  __attribute__((__packed__)) ;
typedef struct _zend_op_array_72 zend_op_array_72;
union _zend_function_72  __attribute__((__packed__)) ;
typedef union _zend_function_72 zend_function_72;
struct _zend_class_entry_72  __attribute__((__packed__)) ;
typedef struct _zend_class_entry_72 zend_class_entry_72;
struct _zend_string_72  __attribute__((__packed__)) ;
typedef struct _zend_string_72 zend_string_72;
struct _zend_op_72  __attribute__((__packed__)) ;
typedef struct _zend_op_72 zend_op_72;
struct _sapi_request_info_72  __attribute__((__packed__)) ;
typedef struct _sapi_request_info_72 sapi_request_info_72;
struct _sapi_globals_struct_72  __attribute__((__packed__)) ;
typedef struct _sapi_globals_struct_72 sapi_globals_struct_72;
union _zend_value_72  __attribute__((__packed__)) ;
typedef union _zend_value_72 zend_value_72;
struct _zval_72  __attribute__((__packed__)) ;
typedef struct _zval_72 zval_72;
struct _Bucket_72  __attribute__((__packed__)) ;
typedef struct _Bucket_72 Bucket_72;
struct _zend_array_72  __attribute__((__packed__)) ;
typedef struct _zend_array_72 zend_array_72;
struct _zend_alloc_globals_72  __attribute__((__packed__)) ;
typedef struct _zend_alloc_globals_72 zend_alloc_globals_72;
struct _zend_mm_heap_72  __attribute__((__packed__)) ;
typedef struct _zend_mm_heap_72 zend_mm_heap_72;
struct _zend_array_72 {
   uint8_t pad0[12] ;
   uint32_t nTableMask ;
   Bucket_72 *arData ;
   uint32_t nNumUsed ;
   uint32_t nNumOfElements ;
   uint32_t nTableSize ;
} __attribute__((__packed__)) ;
struct _zend_executor_globals_72 {
   uint8_t pad0[304] ;
   zend_array_72 symbol_table ;
   uint8_t pad1[140] ;
   zend_execute_data_72 *current_execute_data ;
} __attribute__((__packed__)) ;
struct _zend_execute_data_72 {
   zend_op_72 *opline ;
   uint8_t pad0[16] ;
   zend_function_72 *func ;
   uint8_t pad1[16] ;
   zend_execute_data_72 *prev_execute_data ;
   zend_array_72 *symbol_table ;
} __attribute__((__packed__)) ;
struct _zend_op_array_72 {
   uint8_t pad0[72] ;
   int last_var ;
   uint8_t pad1[4] ;
   zend_string_72 **vars ;
   uint8_t pad2[32] ;
   zend_string_72 *filename ;
   uint32_t line_start ;
} __attribute__((__packed__)) ;
struct __anonstruct_common_997371363 {
   uint8_t pad0[8] ;
   zend_string_72 *function_name ;
   zend_class_entry_72 *scope ;
};
union _zend_function_72 {
   uint8_t type ;
   struct __anonstruct_common_997371363 common ;
   zend_op_array_72 op_array ;
} __attribute__((__packed__)) ;
struct _zend_class_entry_72 {
   uint8_t pad0[8] ;
   zend_string_72 *name ;
} __attribute__((__packed__)) ;
struct _zend_string_72 {
   uint8_t pad0[16] ;
   size_t len ;
   char val[1] ;
} __attribute__((__packed__)) ;
struct _zend_op_72 {
   uint8_t pad0[24] ;
   uint32_t lineno ;
} __attribute__((__packed__)) ;
struct _sapi_request_info_72 {
   uint8_t pad0[8] ;
   char *query_string ;
   char *cookie_data ;
   uint8_t pad1[8] ;
   char *path_translated ;
   char *request_uri ;
} __attribute__((__packed__)) ;
struct _sapi_globals_struct_72 {
   uint8_t pad0[8] ;
   sapi_request_info_72 request_info ;
   uint8_t pad1[384] ;
   double global_request_time ;
} __attribute__((__packed__)) ;
union _zend_value_72 {
   long lval ;
   double dval ;
   zend_string_72 *str ;
   zend_array_72 *arr ;
} __attribute__((__packed__)) ;
struct __anonstruct_v_997371364 {
   uint8_t type ;
   uint8_t pad0[3] ;
};
union __anonunion_u1_787548746 {
   struct __anonstruct_v_997371364 v ;
};
union __anonunion_u2_997371365 {
   uint32_t next ;
};
struct _zval_72 {
   zend_value_72 value ;
   union __anonunion_u1_787548746 u1 ;
   union __anonunion_u2_997371365 u2 ;
} __attribute__((__packed__)) ;
struct _Bucket_72 {
   zval_72 val ;
   uint64_t h ;
   zend_string_72 *key ;
} __attribute__((__packed__)) ;
struct _zend_alloc_globals_72 {
   zend_mm_heap_72 *mm_heap ;
} __attribute__((__packed__)) ;
struct _zend_mm_heap_72 {
   uint8_t pad0[16] ;
   size_t size ;
   size_t peak ;
} __attribute__((__packed__)) ;
struct _zend_executor_globals_73  __attribute__((__packed__)) ;
typedef struct _zend_executor_globals_73 zend_executor_globals_73;
struct _zend_execute_data_73  __attribute__((__packed__)) ;
typedef struct _zend_execute_data_73 zend_execute_data_73;
struct _zend_op_array_73  __attribute__((__packed__)) ;
typedef struct _zend_op_array_73 zend_op_array_73;
union _zend_function_73  __attribute__((__packed__)) ;
typedef union _zend_function_73 zend_function_73;
struct _zend_class_entry_73  __attribute__((__packed__)) ;
typedef struct _zend_class_entry_73 zend_class_entry_73;
struct _zend_string_73  __attribute__((__packed__)) ;
typedef struct _zend_string_73 zend_string_73;
struct _zend_op_73  __attribute__((__packed__)) ;
typedef struct _zend_op_73 zend_op_73;
struct _sapi_request_info_73  __attribute__((__packed__)) ;
typedef struct _sapi_request_info_73 sapi_request_info_73;
struct _sapi_globals_struct_73  __attribute__((__packed__)) ;
typedef struct _sapi_globals_struct_73 sapi_globals_struct_73;
union _zend_value_73  __attribute__((__packed__)) ;
typedef union _zend_value_73 zend_value_73;
struct _zval_73  __attribute__((__packed__)) ;
typedef struct _zval_73 zval_73;
struct _Bucket_73  __attribute__((__packed__)) ;
typedef struct _Bucket_73 Bucket_73;
struct _zend_array_73  __attribute__((__packed__)) ;
typedef struct _zend_array_73 zend_array_73;
struct _zend_alloc_globals_73  __attribute__((__packed__)) ;
typedef struct _zend_alloc_globals_73 zend_alloc_globals_73;
struct _zend_mm_heap_73  __attribute__((__packed__)) ;
typedef struct _zend_mm_heap_73 zend_mm_heap_73;
struct _zend_array_73 {
   uint8_t pad0[12] ;
   uint32_t nTableMask ;
   Bucket_73 *arData ;
   uint32_t nNumUsed ;
   uint32_t nNumOfElements ;
   uint32_t nTableSize ;
} __attribute__((__packed__)) ;
struct _zend_executor_globals_73 {
   uint8_t pad0[304] ;
   zend_array_73 symbol_table ;
   uint8_t pad1[148] ;
   zend_execute_data_73 *current_execute_data ;
} __attribute__((__packed__)) ;
struct _zend_execute_data_73 {
   zend_op_73 *opline ;
   uint8_t pad0[16] ;
   zend_function_73 *func ;
   uint8_t pad1[16] ;
   zend_execute_data_73 *prev_execute_data ;
   zend_array_73 *symbol_table ;
} __attribute__((__packed__)) ;
struct _zend_op_array_73 {
   uint8_t pad0[52] ;
   int last_var ;
   uint8_t pad1[32] ;
   zend_string_73 **vars ;
   uint8_t pad2[32] ;
   zend_string_73 *filename ;
   uint32_t line_start ;
} __attribute__((__packed__)) ;
struct __anonstruct_common_503990880 {
   uint8_t pad0[8] ;
   zend_string_73 *function_name ;
   zend_class_entry_73 *scope ;
};
union _zend_function_73 {
   uint8_t type ;
   struct __anonstruct_common_503990880 common ;
   zend_op_array_73 op_array ;
} __attribute__((__packed__)) ;
struct _zend_class_entry_73 {
   uint8_t pad0[8] ;
   zend_string_73 *name ;
} __attribute__((__packed__)) ;
struct _zend_string_73 {
   uint8_t pad0[16] ;
   size_t len ;
   char val[1] ;
} __attribute__((__packed__)) ;
struct _zend_op_73 {
   uint8_t pad0[24] ;
   uint32_t lineno ;
} __attribute__((__packed__)) ;
struct _sapi_request_info_73 {
   uint8_t pad0[8] ;
   char *query_string ;
   char *cookie_data ;
   uint8_t pad1[8] ;
   char *path_translated ;
   char *request_uri ;
} __attribute__((__packed__)) ;
struct _sapi_globals_struct_73 {
   uint8_t pad0[8] ;
   sapi_request_info_73 request_info ;
   uint8_t pad1[384] ;
   double global_request_time ;
} __attribute__((__packed__)) ;
union _zend_value_73 {
   long lval ;
   double dval ;
   zend_string_73 *str ;
   zend_array_73 *arr ;
} __attribute__((__packed__)) ;
struct __anonstruct_v_997371366 {
   uint8_t type ;
   uint8_t pad0[3] ;
};
union __anonunion_u1_488409722 {
   struct __anonstruct_v_997371366 v ;
};
union __anonunion_u2_997371367 {
   uint32_t next ;
};
struct _zval_73 {
   zend_value_73 value ;
   union __anonunion_u1_488409722 u1 ;
   union __anonunion_u2_997371367 u2 ;
} __attribute__((__packed__)) ;
struct _Bucket_73 {
   zval_73 val ;
   uint64_t h ;
   zend_string_73 *key ;
} __attribute__((__packed__)) ;
struct _zend_alloc_globals_73 {
   zend_mm_heap_73 *mm_heap ;
} __attribute__((__packed__)) ;
struct _zend_mm_heap_73 {
   uint8_t pad0[16] ;
   size_t size ;
   size_t peak ;
} __attribute__((__packed__)) ;
struct _zend_executor_globals_74  __attribute__((__packed__)) ;
typedef struct _zend_executor_globals_74 zend_executor_globals_74;
struct _zend_execute_data_74  __attribute__((__packed__)) ;
typedef struct _zend_execute_data_74 zend_execute_data_74;
struct _zend_op_array_74  __attribute__((__packed__)) ;
typedef struct _zend_op_array_74 zend_op_array_74;
union _zend_function_74  __attribute__((__packed__)) ;
typedef union _zend_function_74 zend_function_74;
struct _zend_class_entry_74  __attribute__((__packed__)) ;
typedef struct _zend_class_entry_74 zend_class_entry_74;
struct _zend_string_74  __attribute__((__packed__)) ;
typedef struct _zend_string_74 zend_string_74;
struct _zend_op_74  __attribute__((__packed__)) ;
typedef struct _zend_op_74 zend_op_74;
struct _sapi_request_info_74  __attribute__((__packed__)) ;
typedef struct _sapi_request_info_74 sapi_request_info_74;
struct _sapi_globals_struct_74  __attribute__((__packed__)) ;
typedef struct _sapi_globals_struct_74 sapi_globals_struct_74;
union _zend_value_74  __attribute__((__packed__)) ;
typedef union _zend_value_74 zend_value_74;
struct _zval_74  __attribute__((__packed__)) ;
typedef struct _zval_74 zval_74;
struct _Bucket_74  __attribute__((__packed__)) ;
typedef struct _Bucket_74 Bucket_74;
struct _zend_array_74  __attribute__((__packed__)) ;
typedef struct _zend_array_74 zend_array_74;
struct _zend_alloc_globals_74  __attribute__((__packed__)) ;
typedef struct _zend_alloc_globals_74 zend_alloc_globals_74;
struct _zend_mm_heap_74  __attribute__((__packed__)) ;
typedef struct _zend_mm_heap_74 zend_mm_heap_74;
struct _zend_array_74 {
   uint8_t pad0[12] ;
   uint32_t nTableMask ;
   Bucket_74 *arData ;
   uint32_t nNumUsed ;
   uint32_t nNumOfElements ;
   uint32_t nTableSize ;
} __attribute__((__packed__)) ;
struct _zend_executor_globals_74 {
   uint8_t pad0[304] ;
   zend_array_74 symbol_table ;
   uint8_t pad1[148] ;
   zend_execute_data_74 *current_execute_data ;
} __attribute__((__packed__)) ;
struct _zend_execute_data_74 {
   zend_op_74 *opline ;
   uint8_t pad0[16] ;
   zend_function_74 *func ;
   uint8_t pad1[16] ;
   zend_execute_data_74 *prev_execute_data ;
   zend_array_74 *symbol_table ;
} __attribute__((__packed__)) ;
struct _zend_op_array_74 {
   uint8_t pad0[52] ;
   int last_var ;
   uint8_t pad1[40] ;
   zend_string_74 **vars ;
   uint8_t pad2[32] ;
   zend_string_74 *filename ;
   uint32_t line_start ;
} __attribute__((__packed__)) ;
struct __anonstruct_common_199519939 {
   uint8_t pad0[8] ;
   zend_string_74 *function_name ;
   zend_class_entry_74 *scope ;
};
union _zend_function_74 {
   uint8_t type ;
   struct __anonstruct_common_199519939 common ;
   zend_op_array_74 op_array ;
} __attribute__((__packed__)) ;
struct _zend_class_entry_74 {
   uint8_t pad0[8] ;
   zend_string_74 *name ;
} __attribute__((__packed__)) ;
struct _zend_string_74 {
   uint8_t pad0[16] ;
   size_t len ;
   char val[1] ;
} __attribute__((__packed__)) ;
struct _zend_op_74 {
   uint8_t pad0[24] ;
   uint32_t lineno ;
} __attribute__((__packed__)) ;
struct _sapi_request_info_74 {
   uint8_t pad0[8] ;
   char *query_string ;
   char *cookie_data ;
   uint8_t pad1[8] ;
   char *path_translated ;
   char *request_uri ;
} __attribute__((__packed__)) ;
struct _sapi_globals_struct_74 {
   uint8_t pad0[8] ;
   sapi_request_info_74 request_info ;
   uint8_t pad1[384] ;
   double global_request_time ;
} __attribute__((__packed__)) ;
union _zend_value_74 {
   long lval ;
   double dval ;
   zend_string_74 *str ;
   zend_array_74 *arr ;
} __attribute__((__packed__)) ;
struct __anonstruct_v_997371368 {
   uint8_t type ;
   uint8_t pad0[3] ;
};
union __anonunion_u1_609040281 {
   struct __anonstruct_v_997371368 v ;
};
union __anonunion_u2_997371369 {
   uint32_t next ;
};
struct _zval_74 {
   zend_value_74 value ;
   union __anonunion_u1_609040281 u1 ;
   union __anonunion_u2_997371369 u2 ;
} __attribute__((__packed__)) ;
struct _Bucket_74 {
   zval_74 val ;
   uint64_t h ;
   zend_string_74 *key ;
} __attribute__((__packed__)) ;
struct _zend_alloc_globals_74 {
   zend_mm_heap_74 *mm_heap ;
} __attribute__((__packed__)) ;
struct _zend_mm_heap_74 {
   uint8_t pad0[16] ;
   size_t size ;
   size_t peak ;
} __attribute__((__packed__)) ;
struct _zend_executor_globals_80  __attribute__((__packed__)) ;
typedef struct _zend_executor_globals_80 zend_executor_globals_80;
struct _zend_execute_data_80  __attribute__((__packed__)) ;
typedef struct _zend_execute_data_80 zend_execute_data_80;
struct _zend_op_array_80  __attribute__((__packed__)) ;
typedef struct _zend_op_array_80 zend_op_array_80;
union _zend_function_80  __attribute__((__packed__)) ;
typedef union _zend_function_80 zend_function_80;
struct _zend_class_entry_80  __attribute__((__packed__)) ;
typedef struct _zend_class_entry_80 zend_class_entry_80;
struct _zend_string_80  __attribute__((__packed__)) ;
typedef struct _zend_string_80 zend_string_80;
struct _zend_op_80  __attribute__((__packed__)) ;
typedef struct _zend_op_80 zend_op_80;
struct _sapi_request_info_80  __attribute__((__packed__)) ;
typedef struct _sapi_request_info_80 sapi_request_info_80;
struct _sapi_globals_struct_80  __attribute__((__packed__)) ;
typedef struct _sapi_globals_struct_80 sapi_globals_struct_80;
union _zend_value_80  __attribute__((__packed__)) ;
typedef union _zend_value_80 zend_value_80;
struct _zval_80  __attribute__((__packed__)) ;
typedef struct _zval_80 zval_80;
struct _Bucket_80  __attribute__((__packed__)) ;
typedef struct _Bucket_80 Bucket_80;
struct _zend_array_80  __attribute__((__packed__)) ;
typedef struct _zend_array_80 zend_array_80;
struct _zend_alloc_globals_80  __attribute__((__packed__)) ;
typedef struct _zend_alloc_globals_80 zend_alloc_globals_80;
struct _zend_mm_heap_80  __attribute__((__packed__)) ;
typedef struct _zend_mm_heap_80 zend_mm_heap_80;
struct _zend_array_80 {
   uint8_t pad0[12] ;
   uint32_t nTableMask ;
   Bucket_80 *arData ;
   uint32_t nNumUsed ;
   uint32_t nNumOfElements ;
   uint32_t nTableSize ;
} __attribute__((__packed__)) ;
struct _zend_executor_globals_80 {
   uint8_t pad0[304] ;
   zend_array_80 symbol_table ;
   uint8_t pad1[148] ;
   zend_execute_data_80 *current_execute_data ;
} __attribute__((__packed__)) ;
struct _zend_execute_data_80 {
   zend_op_80 *opline ;
   uint8_t pad0[16] ;
   zend_function_80 *func ;
   uint8_t pad1[16] ;
   zend_execute_data_80 *prev_execute_data ;
   zend_array_80 *symbol_table ;
} __attribute__((__packed__)) ;
struct _zend_op_array_80 {
   uint8_t pad0[60] ;
   int last_var ;
   uint8_t pad1[40] ;
   zend_string_80 **vars ;
   uint8_t pad2[32] ;
   zend_string_80 *filename ;
   uint32_t line_start ;
} __attribute__((__packed__)) ;
struct __anonstruct_common_655473623 {
   uint8_t pad0[8] ;
   zend_string_80 *function_name ;
   zend_class_entry_80 *scope ;
};
union _zend_function_80 {
   uint8_t type ;
   struct __anonstruct_common_655473623 common ;
   zend_op_array_80 op_array ;
} __attribute__((__packed__)) ;
struct _zend_class_entry_80 {
   uint8_t pad0[8] ;
   zend_string_80 *name ;
} __attribute__((__packed__)) ;
struct _zend_string_80 {
   uint8_t pad0[16] ;
   size_t len ;
   char val[1] ;
} __attribute__((__packed__)) ;
struct _zend_op_80 {
   uint8_t pad0[24] ;
   uint32_t lineno ;
} __attribute__((__packed__)) ;
struct _sapi_request_info_80 {
   uint8_t pad0[8] ;
   char *query_string ;
   char *cookie_data ;
   uint8_t pad1[8] ;
   char *path_translated ;
   char *request_uri ;
} __attribute__((__packed__)) ;
struct _sapi_globals_struct_80 {
   uint8_t pad0[8] ;
   sapi_request_info_80 request_info ;
   uint8_t pad1[384] ;
   double global_request_time ;
} __attribute__((__packed__)) ;
union _zend_value_80 {
   long lval ;
   double dval ;
   zend_string_80 *str ;
   zend_array_80 *arr ;
} __attribute__((__packed__)) ;
struct __anonstruct_v_997371370 {
   uint8_t type ;
   uint8_t pad0[3] ;
};
union __anonunion_u1_920790402 {
   struct __anonstruct_v_997371370 v ;
};
union __anonunion_u2_997371371 {
   uint32_t next ;
};
struct _zval_80 {
   zend_value_80 value ;
   union __anonunion_u1_920790402 u1 ;
   union __anonunion_u2_997371371 u2 ;
} __attribute__((__packed__)) ;
struct _Bucket_80 {
   zval_80 val ;
   uint64_t h ;
   zend_string_80 *key ;
} __attribute__((__packed__)) ;
struct _zend_alloc_globals_80 {
   zend_mm_heap_80 *mm_heap ;
} __attribute__((__packed__)) ;
struct _zend_mm_heap_80 {
   uint8_t pad0[16] ;
   size_t size ;
   size_t peak ;
} __attribute__((__packed__)) ;
struct _zend_executor_globals_81  __attribute__((__packed__)) ;
typedef struct _zend_executor_globals_81 zend_executor_globals_81;
struct _zend_execute_data_81  __attribute__((__packed__)) ;
typedef struct _zend_execute_data_81 zend_execute_data_81;
struct _zend_op_array_81  __attribute__((__packed__)) ;
typedef struct _zend_op_array_81 zend_op_array_81;
union _zend_function_81  __attribute__((__packed__)) ;
typedef union _zend_function_81 zend_function_81;
struct _zend_class_entry_81  __attribute__((__packed__)) ;
typedef struct _zend_class_entry_81 zend_class_entry_81;
struct _zend_string_81  __attribute__((__packed__)) ;
typedef struct _zend_string_81 zend_string_81;
struct _zend_op_81  __attribute__((__packed__)) ;
typedef struct _zend_op_81 zend_op_81;
struct _sapi_request_info_81  __attribute__((__packed__)) ;
typedef struct _sapi_request_info_81 sapi_request_info_81;
struct _sapi_globals_struct_81  __attribute__((__packed__)) ;
typedef struct _sapi_globals_struct_81 sapi_globals_struct_81;
union _zend_value_81  __attribute__((__packed__)) ;
typedef union _zend_value_81 zend_value_81;
struct _zval_81  __attribute__((__packed__)) ;
typedef struct _zval_81 zval_81;
struct _Bucket_81  __attribute__((__packed__)) ;
typedef struct _Bucket_81 Bucket_81;
struct _zend_array_81  __attribute__((__packed__)) ;
typedef struct _zend_array_81 zend_array_81;
struct _zend_alloc_globals_81  __attribute__((__packed__)) ;
typedef struct _zend_alloc_globals_81 zend_alloc_globals_81;
struct _zend_mm_heap_81  __attribute__((__packed__)) ;
typedef struct _zend_mm_heap_81 zend_mm_heap_81;
struct _zend_array_81 {
   uint8_t pad0[12] ;
   uint32_t nTableMask ;
   Bucket_81 *arData ;
   uint32_t nNumUsed ;
   uint32_t nNumOfElements ;
   uint32_t nTableSize ;
} __attribute__((__packed__)) ;
struct _zend_executor_globals_81 {
   uint8_t pad0[304] ;
   zend_array_81 symbol_table ;
   uint8_t pad1[148] ;
   zend_execute_data_81 *current_execute_data ;
} __attribute__((__packed__)) ;
struct _zend_execute_data_81 {
   zend_op_81 *opline ;
   uint8_t pad0[16] ;
   zend_function_81 *func ;
   uint8_t pad1[16] ;
   zend_execute_data_81 *prev_execute_data ;
   zend_array_81 *symbol_table ;
} __attribute__((__packed__)) ;
struct _zend_op_array_81 {
   uint8_t pad0[60] ;
   int last_var ;
   uint8_t pad1[40] ;
   zend_string_81 **vars ;
   uint8_t pad2[32] ;
   zend_string_81 *filename ;
   uint32_t line_start ;
} __attribute__((__packed__)) ;
struct __anonstruct_common_762800949 {
   uint8_t pad0[8] ;
   zend_string_81 *function_name ;
   zend_class_entry_81 *scope ;
};
union _zend_function_81 {
   uint8_t type ;
   struct __anonstruct_common_762800949 common ;
   zend_op_array_81 op_array ;
} __attribute__((__packed__)) ;
struct _zend_class_entry_81 {
   uint8_t pad0[8] ;
   zend_string_81 *name ;
} __attribute__((__packed__)) ;
struct _zend_string_81 {
   uint8_t pad0[16] ;
   size_t len ;
   char val[1] ;
} __attribute__((__packed__)) ;
struct _zend_op_81 {
   uint8_t pad0[24] ;
   uint32_t lineno ;
} __attribute__((__packed__)) ;
struct _sapi_request_info_81 {
   uint8_t pad0[8] ;
   char *query_string ;
   char *cookie_data ;
   uint8_t pad1[8] ;
   char *path_translated ;
   char *request_uri ;
} __attribute__((__packed__)) ;
struct _sapi_globals_struct_81 {
   uint8_t pad0[8] ;
   sapi_request_info_81 request_info ;
   uint8_t pad1[384] ;
   double global_request_time ;
} __attribute__((__packed__)) ;
union _zend_value_81 {
   long lval ;
   double dval ;
   zend_string_81 *str ;
   zend_array_81 *arr ;
} __attribute__((__packed__)) ;
struct __anonstruct_v_997371372 {
   uint8_t type ;
   uint8_t pad0[3] ;
};
union __anonunion_u1_671508906 {
   struct __anonstruct_v_997371372 v ;
};
union __anonunion_u2_997371373 {
   uint32_t next ;
};
struct _zval_81 {
   zend_value_81 value ;
   union __anonunion_u1_671508906 u1 ;
   union __anonunion_u2_997371373 u2 ;
} __attribute__((__packed__)) ;
struct _Bucket_81 {
   zval_81 val ;
   uint64_t h ;
   zend_string_81 *key ;
} __attribute__((__packed__)) ;
struct _zend_alloc_globals_81 {
   zend_mm_heap_81 *mm_heap ;
} __attribute__((__packed__)) ;
struct _zend_mm_heap_81 {
   uint8_t pad0[16] ;
   size_t size ;
   size_t peak ;
} __attribute__((__packed__)) ;
struct UT_hash_handle ;
struct UT_hash_bucket {
   struct UT_hash_handle *hh_head ;
   unsigned int count ;
   unsigned int expand_mult ;
};
typedef struct UT_hash_bucket UT_hash_bucket;
struct UT_hash_table {
   UT_hash_bucket *buckets ;
   unsigned int num_buckets ;
   unsigned int log2_num_buckets ;
   unsigned int num_items ;
   struct UT_hash_handle *tail ;
   ptrdiff_t hho ;
   unsigned int ideal_chain_maxlen ;
   unsigned int nonideal_items ;
   unsigned int ineff_expands ;
   unsigned int noexpand ;
   uint32_t signature ;
};
typedef struct UT_hash_table UT_hash_table;
struct UT_hash_handle {
   struct UT_hash_table *tbl ;
   void *prev ;
   void *next ;
   struct UT_hash_handle *hh_prev ;
   struct UT_hash_handle *hh_next ;
   void *key ;
   unsigned int keylen ;
   unsigned int hashv ;
};
typedef struct UT_hash_handle UT_hash_handle;
struct varpeek_var_s {
   char name[256] ;
   UT_hash_handle hh ;
};
typedef struct varpeek_var_s varpeek_var_t;
struct varpeek_entry_s {
   char filename_lineno[256] ;
   varpeek_var_t *varmap ;
   UT_hash_handle hh ;
};
typedef struct varpeek_entry_s varpeek_entry_t;
struct glopeek_entry_s {
   char key[256] ;
   char gloname[256] ;
   char varname[256] ;
   UT_hash_handle hh ;
};
typedef struct glopeek_entry_s glopeek_entry_t;
struct trace_loc_s {
   char func[256] ;
   char class[256] ;
   char file[256] ;
   size_t func_len ;
   size_t class_len ;
   size_t file_len ;
   int lineno ;
};
typedef struct trace_loc_s trace_loc_t;
struct trace_frame_s {
   trace_loc_t loc ;
   int depth ;
};
typedef struct trace_frame_s trace_frame_t;
struct trace_request_s {
   char uri[256] ;
   char path[256] ;
   char qstring[256] ;
   char cookie[256] ;
   double ts ;
};
typedef struct trace_request_s trace_request_t;
struct trace_mem_s {
   size_t size ;
   size_t peak ;
};
typedef struct trace_mem_s trace_mem_t;
struct trace_varpeek_s {
   varpeek_entry_t *entry ;
   varpeek_var_t *var ;
   char *zval_str ;
};
typedef struct trace_varpeek_s trace_varpeek_t;
struct trace_glopeek_s {
   glopeek_entry_t *gentry ;
   char *zval_str ;
};
typedef struct trace_glopeek_s trace_glopeek_t;
struct trace_target_s {
   pid_t pid ;
   uint64_t executor_globals_addr ;
   uint64_t sapi_globals_addr ;
   uint64_t alloc_globals_addr ;
   uint64_t basic_functions_module_addr ;
};
typedef struct trace_target_s trace_target_t;
struct __anonstruct_event_441004094 {
   trace_frame_t frame ;
   trace_request_t request ;
   trace_mem_t mem ;
   trace_varpeek_t varpeek ;
   trace_glopeek_t glopeek ;
};
struct trace_context_s {
   trace_target_t target ;
   struct __anonstruct_event_441004094 event ;
   void *event_udata ;
   int (*event_handler)(struct trace_context_s *context , int event_type ) ;
   char buf[256] ;
   size_t buf_len ;
};
typedef struct trace_context_s trace_context_t;
struct addr_memo_s {
   char php_bin_path[256] ;
   char php_bin_path_root[256] ;
   uint64_t php_base_addr ;
};
typedef struct addr_memo_s addr_memo_t;
struct _zend_module_entry {
   uint8_t pad0[88] ;
   char const   *version ;
} __attribute__((__packed__)) ;
struct bytebuf_t {
   char *buf ;
   size_t len ;
   size_t cap ;
};
struct cellbuf_t {
   int width ;
   int height ;
   struct tb_cell *cells ;
};
struct cap_trie_t {
   char c ;
   struct cap_trie_t *children ;
   size_t nchildren ;
   int is_leaf ;
   uint16_t key ;
   uint8_t mod ;
};
struct tb_global_t {
   int ttyfd ;
   int rfd ;
   int wfd ;
   int ttyfd_open ;
   int resize_pipefd[2] ;
   int width ;
   int height ;
   int cursor_x ;
   int cursor_y ;
   int last_x ;
   int last_y ;
   uintattr_t fg ;
   uintattr_t bg ;
   uintattr_t last_fg ;
   uintattr_t last_bg ;
   int input_mode ;
   int output_mode ;
   char *terminfo ;
   size_t nterminfo ;
   char const   *caps[36] ;
   struct cap_trie_t cap_trie ;
   struct bytebuf_t in ;
   struct bytebuf_t out ;
   struct cellbuf_t back ;
   struct cellbuf_t front ;
   struct termios orig_tios ;
   int has_orig_tios ;
   int last_errno ;
   int initialized ;
   int (*fn_extract_esc_pre)(struct tb_event * , size_t * ) ;
   int (*fn_extract_esc_post)(struct tb_event * , size_t * ) ;
};
struct __anonstruct_builtin_terms_737686262 {
   char const   *name ;
   char const   **caps ;
   char const   *alias ;
};
struct __anonstruct_builtin_mod_caps_1052271791 {
   char const   *cap ;
   uint16_t const   key ;
   uint8_t const   mod ;
};
enum type {
    TYPE_VT200 = 0,
    TYPE_1006 = 1,
    TYPE_1015 = 2,
    TYPE_MAX = 3
} ;
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
struct __anonstruct___wseq32_112954846 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_419419941 {
   unsigned long long __wseq ;
   struct __anonstruct___wseq32_112954846 __wseq32 ;
};
struct __anonstruct___g1_start32_349613680 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_349613679 {
   unsigned long long __g1_start ;
   struct __anonstruct___g1_start32_349613680 __g1_start32 ;
};
struct __pthread_cond_s {
   union __anonunion____missing_field_name_419419941 __annonCompField1 ;
   union __anonunion____missing_field_name_349613679 __annonCompField2 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
union __anonunion_pthread_condattr_t_488594145 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_condattr_t_488594145 pthread_condattr_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
union __anonunion_pthread_cond_t_951761805 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
typedef union __anonunion_pthread_cond_t_951761805 pthread_cond_t;
typedef __sigset_t sigset_t;
struct func_entry_s {
   char func[256] ;
   unsigned long count_excl ;
   unsigned long count_incl ;
   unsigned long total_count_excl ;
   unsigned long total_count_incl ;
   float percent_excl ;
   UT_hash_handle hh ;
};
typedef struct func_entry_s func_entry_t;
typedef int regoff_t;
struct __anonstruct_regmatch_t_1035675074 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
typedef struct __anonstruct_regmatch_t_1035675074 regmatch_t;
struct event_handler_fout_udata_s {
   int fd ;
   char *buf ;
   char *cur ;
   size_t buf_size ;
   size_t rem ;
};
typedef struct event_handler_fout_udata_s event_handler_fout_udata_t;
struct __anonstruct_callgrind_callee_t_105864190 {
   char loc_str[256] ;
   trace_loc_t loc ;
   uint64_t inclusive ;
   uint64_t count ;
   UT_hash_handle hh ;
};
typedef struct __anonstruct_callgrind_callee_t_105864190 callgrind_callee_t;
struct __anonstruct_callgrind_caller_t_89571561 {
   char loc_str[256] ;
   trace_loc_t loc ;
   uint64_t exclusive ;
   callgrind_callee_t *callees ;
   UT_hash_handle hh ;
};
typedef struct __anonstruct_callgrind_caller_t_89571561 callgrind_caller_t;
struct __anonstruct_callgrind_udata_t_855107567 {
   trace_loc_t self[128] ;
   trace_loc_t prev[128] ;
   char self_str[128][256] ;
   char prev_str[128][256] ;
   int self_len ;
   int prev_len ;
   FILE *fout ;
   callgrind_caller_t *callers ;
};
typedef struct __anonstruct_callgrind_udata_t_855107567 callgrind_udata_t;
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __atomic_add_fetch(...) ;  */
#pragma merger("0","/tmp/cil-wgPrlQ_w.i","-std=c11,-Wall,-Wextra,-pedantic,-g,-O3,-Wno-address-of-packed-member,-pthread")
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
extern char *optarg ;
extern int optind ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) getopt_long)(int ___argc ,
                                                                                          char * const  *___argv ,
                                                                                          char const   *__shortopts ,
                                                                                          struct option  const  *__longopts ,
                                                                                          int *__longind ) ;
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                     pthread_t __thread2 ) 
{ 


  {
  return (__thread1 == __thread2);
}
}
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
extern FILE *stdin ;
extern FILE *stdout ;
extern FILE *stderr ;
extern int fclose(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...)  __asm__("__isoc99_sscanf")  ;
extern int getc(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
extern int putc(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
extern __ssize_t __getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                            int __delimiter , FILE * __restrict  __stream ) ;
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                     size_t * __restrict  __n ,
                                                                     FILE * __restrict  __stream ) ;
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
extern void perror(char const   *__s ) ;
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
extern FILE *popen(char const   *__command , char const   *__modes ) ;
extern int pclose(FILE *__stream ) ;
extern int __uflow(FILE * ) ;
extern int __overflow(FILE * , int  ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) 
{ 
  int tmp ;

  {
  tmp = vfprintf((FILE * __restrict  )stdout, __fmt, __arg);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) 
{ 
  int tmp ;

  {
  tmp = getc(stdin);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(__fp);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = __fp->_IO_read_ptr;
    (__fp->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(stdin);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = stdin->_IO_read_ptr;
    (stdin->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) 
{ 
  int tmp ;

  {
  tmp = putc(__c, stdout);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = __stream->_IO_write_ptr;
    (__stream->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = stdout->_IO_write_ptr;
    (stdout->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                     size_t * __restrict  __n ,
                                                                     FILE * __restrict  __stream ) 
{ 
  __ssize_t tmp ;

  {
  tmp = __getdelim(__lineptr, __n, '\n', __stream);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 16) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 32) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) strtoul)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1))) strtoll)(char const   * __restrict  __nptr ,
                                                                                          char ** __restrict  __endptr ,
                                                                                          int __base ) ;
extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__nonnull__(1))) strtoull)(char const   * __restrict  __nptr ,
                                                                                                    char ** __restrict  __endptr ,
                                                                                                    int __base ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) atoi)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return ((int )tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long ( __attribute__((__nonnull__(1), __gnu_inline__)) atol)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long long ( __attribute__((__nonnull__(1), __gnu_inline__)) atoll)(char const   *__nptr ) 
{ 
  long long tmp ;

  {
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
  return (tmp);
}
}
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
  __l = (size_t )0;
  __u = __nmemb;
  while (__l < __u) {
    __idx = (__l + __u) / 2UL;
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
    __comparison = (*__compar)(__key, __p);
    if (__comparison < 0) {
      __u = __idx;
    } else
    if (__comparison > 0) {
      __l = __idx + 1UL;
    } else {
      return ((void *)__p);
    }
  }
  return ((void *)0);
}
}
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern double ( __attribute__((__nonnull__(1), __gnu_inline__)) atof)(char const   *__nptr ) 
{ 
  double tmp ;

  {
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2))) strtok)(char * __restrict  __s ,
                                                                                     char const   * __restrict  __delim ) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
extern  __attribute__((__nothrow__)) long ptrace(enum __ptrace_request __request 
                                                 , ...) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat64)(int __fd , struct stat64 *__statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat64)(int __fd , char const   * __restrict  __filename , struct stat64 * __restrict  __statbuf ,
                            int __flag ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat)(int __ver ,
                                                                                     int __fildes ,
                                                                                     struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat)(int __ver ,
                                                                                      char const   *__filename ,
                                                                                      struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat)(int __ver ,
                                                                                       char const   *__filename ,
                                                                                       struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4))) __fxstatat)(int __ver ,
                                                                                         int __fildes ,
                                                                                         char const   *__filename ,
                                                                                         struct stat *__stat_buf ,
                                                                                         int __flag ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat64)(int __ver ,
                                                                                       int __fildes ,
                                                                                       struct stat64 *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat64)(int __ver ,
                                                                                        char const   *__filename ,
                                                                                        struct stat64 *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat64)(int __ver ,
                                                                                         char const   *__filename ,
                                                                                         struct stat64 *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4))) __fxstatat64)(int __ver ,
                                                                                           int __fildes ,
                                                                                           char const   *__filename ,
                                                                                           struct stat64 *__stat_buf ,
                                                                                           int __flag ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4))) __xmknod)(int __ver ,
                                                                                       char const   *__path ,
                                                                                       __mode_t __mode ,
                                                                                       __dev_t *__dev ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,5))) __xmknodat)(int __ver ,
                                                                                         int __fd ,
                                                                                         char const   *__path ,
                                                                                         __mode_t __mode ,
                                                                                         __dev_t *__dev ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) stat)(char const   * __restrict  __path ,
                                                                              struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __xstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) lstat)(char const   * __restrict  __path ,
                                                                               struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __lxstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) fstat)(int __fd ,
                                                                             struct stat *__statbuf ) 
{ 
  int tmp ;

  {
  tmp = __fxstat(1, __fd, __statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag ) ;
__inline extern int ( __attribute__((__nonnull__(2,3), __gnu_inline__)) fstatat)(int __fd ,
                                                                                 char const   * __restrict  __filename ,
                                                                                 struct stat * __restrict  __statbuf ,
                                                                                 int __flag ) 
{ 
  int tmp ;

  {
  tmp = __fxstatat(1, __fd, (char const   *)__filename, (struct stat *)__statbuf,
                   __flag);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) mknod)(char const   *__path ,
                                                                             __mode_t __mode ,
                                                                             __dev_t __dev ) 
{ 
  int tmp ;

  {
  tmp = __xmknod(0, __path, __mode, & __dev);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) mknodat)(int __fd ,
                                                                               char const   *__path ,
                                                                               __mode_t __mode ,
                                                                               __dev_t __dev ) 
{ 
  int tmp ;

  {
  tmp = __xmknodat(0, __fd, __path, __mode, & __dev);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) stat64)(char const   * __restrict  __path ,
                                                                                struct stat64 * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __xstat64(1, (char const   *)__path, (struct stat64 *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) lstat64)(char const   * __restrict  __path ,
                                                                                 struct stat64 * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __lxstat64(1, (char const   *)__path, (struct stat64 *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat64)(int __fd , struct stat64 *__statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) fstat64)(int __fd ,
                                                                               struct stat64 *__statbuf ) 
{ 
  int tmp ;

  {
  tmp = __fxstat64(1, __fd, __statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat64)(int __fd , char const   * __restrict  __filename , struct stat64 * __restrict  __statbuf ,
                            int __flag ) ;
__inline extern int ( __attribute__((__nonnull__(2,3), __gnu_inline__)) fstatat64)(int __fd ,
                                                                                   char const   * __restrict  __filename ,
                                                                                   struct stat64 * __restrict  __statbuf ,
                                                                                   int __flag ) 
{ 
  int tmp ;

  {
  tmp = __fxstatat64(1, __fd, (char const   *)__filename, (struct stat64 *)__statbuf,
                     __flag);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) ssize_t process_vm_readv(pid_t __pid , struct iovec  const  *__lvec ,
                                                              unsigned long __liovcnt ,
                                                              struct iovec  const  *__rvec ,
                                                              unsigned long __riovcnt ,
                                                              unsigned long __flags ) ;
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
extern int close(int __fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) execvp)(char const   *__file ,
                                                                                     char * const  *__argv ) ;
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
extern  __attribute__((__nothrow__)) void cfmakeraw(struct termios *__termios_p ) ;
__inline extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__gnu_inline__)) btowc)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) wctob)(wint_t __wc ) ;
extern  __attribute__((__nothrow__)) size_t mbrtowc(wchar_t * __restrict  __pwc ,
                                                    char const   * __restrict  __s ,
                                                    size_t __n , mbstate_t * __restrict  __p ) ;
extern  __attribute__((__nothrow__)) size_t __mbrlen(char const   * __restrict  __s ,
                                                     size_t __n , mbstate_t * __restrict  __ps ) ;
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) mbrlen)(char const   * __restrict  __s ,
                                                                                               size_t __n ,
                                                                                               mbstate_t * __restrict  __ps ) ;
extern wint_t __btowc_alias(int __c )  __asm__("btowc")  ;
__inline extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__gnu_inline__)) btowc)(int __c ) ;
__inline extern wint_t ( __attribute__((__gnu_inline__)) btowc)(int __c ) 
{ 
  wint_t tmp ;

  {
  tmp = __btowc_alias(__c);
  return (tmp);
}
}
extern int __wctob_alias(wint_t __c )  __asm__("wctob")  ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) wctob)(wint_t __wc ) ;
__inline extern int ( __attribute__((__gnu_inline__)) wctob)(wint_t __wc ) 
{ 
  int tmp ;

  {
  tmp = __wctob_alias(__wc);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__)) mbrlen)(char const   * __restrict  __s ,
                                                                                               size_t __n ,
                                                                                               mbstate_t * __restrict  __ps ) ;
__inline extern size_t ( __attribute__((__gnu_inline__)) mbrlen)(char const   * __restrict  __s ,
                                                                 size_t __n , mbstate_t * __restrict  __ps ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  if ((unsigned long )__ps != (unsigned long )((void *)0)) {
    tmp = mbrtowc((wchar_t * __restrict  )((void *)0), __s, __n, __ps);
    tmp___1 = tmp;
  } else {
    tmp___0 = __mbrlen(__s, __n, (mbstate_t * __restrict  )((void *)0));
    tmp___1 = tmp___0;
  }
  return (tmp___1);
}
}
extern  __attribute__((__nothrow__)) int wcwidth(wchar_t __c ) ;
int tb_init(void) ;
int tb_init_file(char const   *path ) ;
int tb_init_fd(int ttyfd ) ;
int tb_init_rwfd(int rfd , int wfd ) ;
int tb_shutdown(void) ;
int tb_width(void) ;
int tb_height(void) ;
int tb_clear(void) ;
int tb_set_clear_attrs(uintattr_t fg , uintattr_t bg ) ;
int tb_present(void) ;
int tb_set_cursor(int cx , int cy ) ;
int tb_hide_cursor(void) ;
int tb_set_cell(int x , int y , uint32_t ch , uintattr_t fg , uintattr_t bg ) ;
int tb_set_cell_ex(int x , int y , uint32_t *ch , size_t nch , uintattr_t fg , uintattr_t bg ) ;
int tb_extend_cell(int x , int y , uint32_t ch ) ;
int tb_set_input_mode(int mode ) ;
int tb_set_output_mode(int mode ) ;
int tb_peek_event(struct tb_event *event , int timeout_ms ) ;
int tb_poll_event(struct tb_event *event ) ;
int tb_get_fds(int *ttyfd , int *resizefd ) ;
int tb_print(int x , int y , uintattr_t fg , uintattr_t bg , char const   *str ) ;
int tb_printf(int x , int y , uintattr_t fg , uintattr_t bg , char const   *fmt  , ...) ;
int tb_print_ex(int x , int y , uintattr_t fg , uintattr_t bg , size_t *out_w , char const   *str ) ;
int tb_printf_ex(int x , int y , uintattr_t fg , uintattr_t bg , size_t *out_w , char const   *fmt 
                 , ...) ;
int tb_send(char const   *buf___0 , size_t nbuf ) ;
int tb_sendf(char const   *fmt  , ...) ;
int tb_set_func(int fn_type , int (*fn)(struct tb_event * , size_t * ) ) ;
int tb_utf8_char_length(char c ) ;
int tb_utf8_char_to_unicode(uint32_t *out , char const   *c ) ;
int tb_utf8_unicode_to_char(char *out , uint32_t c ) ;
int tb_last_errno(void) ;
char const   *tb_strerror(int err ) ;
struct tb_cell *tb_cell_buffer(void) ;
int tb_has_truecolor(void) ;
int tb_has_egc(void) ;
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
extern void regfree(regex_t *__preg ) ;
char *opt_pgrep_args ;
int done ;
int opt_num_workers ;
pid_t opt_pid ;
char opt_frame_delim ;
char opt_trace_delim ;
char *opt_path_output ;
regex_t *opt_filter_re ;
int opt_filter_negate ;
int opt_verbose_fields_pid ;
int opt_verbose_fields_ts ;
int opt_continue_on_error ;
int opt_fout_buffer_size ;
long opt_time_limit_ms ;
int main_pgrep(void) ;
int main_pid(pid_t pid ) ;
int main_top(int argc , char **argv ) ;
void usage(FILE *fp , int exit_code ) ;
int get_symbol_addr(addr_memo_t *memo , pid_t pid , char const   *symbol , uint64_t *raddr ) ;
int event_handler_fout(struct trace_context_s *context , int event_type ) ;
int event_handler_callgrind(struct trace_context_s *context , int event_type ) ;
void write_done_pipe(void) ;
void log_error(char const   *fmt  , ...) ;
uint64_t phpspy_zend_inline_hash_func(char const   *str , size_t len ) ;
static struct tb_global_t global  = 
     {0, 0, 0, 0, {0, 0}, 0, 0, 0, 0, 0, 0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
    (unsigned short)0, 0, 0, (char *)0, 0UL, {(char const   *)0, (char const   *)0,
                                              (char const   *)0, (char const   *)0,
                                              (char const   *)0, (char const   *)0,
                                              (char const   *)0, (char const   *)0,
                                              (char const   *)0, (char const   *)0,
                                              (char const   *)0, (char const   *)0,
                                              (char const   *)0, (char const   *)0,
                                              (char const   *)0, (char const   *)0,
                                              (char const   *)0, (char const   *)0,
                                              (char const   *)0, (char const   *)0,
                                              (char const   *)0, (char const   *)0,
                                              (char const   *)0, (char const   *)0,
                                              (char const   *)0, (char const   *)0,
                                              (char const   *)0, (char const   *)0,
                                              (char const   *)0, (char const   *)0,
                                              (char const   *)0, (char const   *)0,
                                              (char const   *)0, (char const   *)0,
                                              (char const   *)0, (char const   *)0},
    {(char)0, (struct cap_trie_t *)0, 0UL, 0, (unsigned short)0, (unsigned char)0},
    {(char *)0, 0UL, 0UL}, {(char *)0, 0UL, 0UL}, {0, 0, (struct tb_cell *)0}, {0,
                                                                                0,
                                                                                (struct tb_cell *)0},
    {0U, 0U, 0U, 0U, (unsigned char)0, {(unsigned char)0, (unsigned char)0, (unsigned char)0,
                                        (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                        (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                        (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                        (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                        (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                        (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                        (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                        (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                        (unsigned char)0, (unsigned char)0, (unsigned char)0,
                                        (unsigned char)0, (unsigned char)0}, 0U, 0U},
    0, 0, 0, (int (*)(struct tb_event * , size_t * ))0, (int (*)(struct tb_event * ,
                                                                 size_t * ))0};
static int16_t const   terminfo_cap_indexes[36]  = 
  {      (int16_t const   )66,      (int16_t const   )68,      (int16_t const   )69,      (int16_t const   )70, 
        (int16_t const   )71,      (int16_t const   )72,      (int16_t const   )73,      (int16_t const   )74, 
        (int16_t const   )75,      (int16_t const   )67,      (int16_t const   )216,      (int16_t const   )217, 
        (int16_t const   )77,      (int16_t const   )59,      (int16_t const   )76,      (int16_t const   )164, 
        (int16_t const   )82,      (int16_t const   )81,      (int16_t const   )87,      (int16_t const   )61, 
        (int16_t const   )79,      (int16_t const   )83,      (int16_t const   )148,      (int16_t const   )28, 
        (int16_t const   )40,      (int16_t const   )16,      (int16_t const   )13,      (int16_t const   )5, 
        (int16_t const   )39,      (int16_t const   )36,      (int16_t const   )27,      (int16_t const   )26, 
        (int16_t const   )311,      (int16_t const   )34,      (int16_t const   )89,      (int16_t const   )88};
static char const   *xterm_caps[36]  = 
  {      "\033OP",      "\033OQ",      "\033OR",      "\033OS", 
        "\033[15~",      "\033[17~",      "\033[18~",      "\033[19~", 
        "\033[20~",      "\033[21~",      "\033[23~",      "\033[24~", 
        "\033[2~",      "\033[3~",      "\033OH",      "\033OF", 
        "\033[5~",      "\033[6~",      "\033OA",      "\033OB", 
        "\033OD",      "\033OC",      "\033[Z",      "\033[?1049h\033[22;0;0t", 
        "\033[?1049l\033[23;0;0t",      "\033[?12l\033[?25h",      "\033[?25l",      "\033[H\033[2J", 
        "\033(B\033[m",      "\033[4m",      "\033[1m",      "\033[5m", 
        "\033[3m",      "\033[7m",      "\033[?1h\033=",      "\033[?1l\033>"};
static char const   *linux_caps[36]  = 
  {      "\033[[A",      "\033[[B",      "\033[[C",      "\033[[D", 
        "\033[[E",      "\033[17~",      "\033[18~",      "\033[19~", 
        "\033[20~",      "\033[21~",      "\033[23~",      "\033[24~", 
        "\033[2~",      "\033[3~",      "\033[1~",      "\033[4~", 
        "\033[5~",      "\033[6~",      "\033[A",      "\033[B", 
        "\033[D",      "\033[C",      "\033[Z",      "", 
        "",      "\033[?25h\033[?0c",      "\033[?25l\033[?1c",      "\033[H\033[J", 
        "\033[m\017",      "\033[4m",      "\033[1m",      "\033[5m", 
        "",      "\033[7m",      "",      ""};
static char const   *screen_caps[36]  = 
  {      "\033OP",      "\033OQ",      "\033OR",      "\033OS", 
        "\033[15~",      "\033[17~",      "\033[18~",      "\033[19~", 
        "\033[20~",      "\033[21~",      "\033[23~",      "\033[24~", 
        "\033[2~",      "\033[3~",      "\033[1~",      "\033[4~", 
        "\033[5~",      "\033[6~",      "\033OA",      "\033OB", 
        "\033OD",      "\033OC",      "\033[Z",      "\033[?1049h", 
        "\033[?1049l",      "\033[34h\033[?25h",      "\033[?25l",      "\033[H\033[J", 
        "\033[m\017",      "\033[4m",      "\033[1m",      "\033[5m", 
        "",      "\033[7m",      "\033[?1h\033=",      "\033[?1l\033>"};
static char const   *rxvt_256color_caps[36]  = 
  {      "\033[11~",      "\033[12~",      "\033[13~",      "\033[14~", 
        "\033[15~",      "\033[17~",      "\033[18~",      "\033[19~", 
        "\033[20~",      "\033[21~",      "\033[23~",      "\033[24~", 
        "\033[2~",      "\033[3~",      "\033[7~",      "\033[8~", 
        "\033[5~",      "\033[6~",      "\033[A",      "\033[B", 
        "\033[D",      "\033[C",      "\033[Z",      "\0337\033[?47h", 
        "\033[2J\033[?47l\0338",      "\033[?25h",      "\033[?25l",      "\033[H\033[2J", 
        "\033[m\017",      "\033[4m",      "\033[1m",      "\033[5m", 
        "",      "\033[7m",      "\033=",      "\033>"};
static char const   *rxvt_unicode_caps[36]  = 
  {      "\033[11~",      "\033[12~",      "\033[13~",      "\033[14~", 
        "\033[15~",      "\033[17~",      "\033[18~",      "\033[19~", 
        "\033[20~",      "\033[21~",      "\033[23~",      "\033[24~", 
        "\033[2~",      "\033[3~",      "\033[7~",      "\033[8~", 
        "\033[5~",      "\033[6~",      "\033[A",      "\033[B", 
        "\033[D",      "\033[C",      "\033[Z",      "\033[?1049h", 
        "\033[r\033[?1049l",      "\033[?12l\033[?25h",      "\033[?25l",      "\033[H\033[2J", 
        "\033[m\033(B",      "\033[4m",      "\033[1m",      "\033[5m", 
        "\033[3m",      "\033[7m",      "\033=",      "\033>"};
static char const   *eterm_caps[36]  = 
  {      "\033[11~",      "\033[12~",      "\033[13~",      "\033[14~", 
        "\033[15~",      "\033[17~",      "\033[18~",      "\033[19~", 
        "\033[20~",      "\033[21~",      "\033[23~",      "\033[24~", 
        "\033[2~",      "\033[3~",      "\033[7~",      "\033[8~", 
        "\033[5~",      "\033[6~",      "\033[A",      "\033[B", 
        "\033[D",      "\033[C",      "",      "\0337\033[?47h", 
        "\033[2J\033[?47l\0338",      "\033[?25h",      "\033[?25l",      "\033[H\033[2J", 
        "\033[m\017",      "\033[4m",      "\033[1m",      "\033[5m", 
        "",      "\033[7m",      "",      ""};
static struct __anonstruct_builtin_terms_737686262 builtin_terms[7]  = {      {"xterm", xterm_caps, ""}, 
        {"linux", linux_caps, ""}, 
        {"screen", screen_caps, "tmux"}, 
        {"rxvt-256color", rxvt_256color_caps, ""}, 
        {"rxvt-unicode", rxvt_unicode_caps, "rxvt"}, 
        {"Eterm", eterm_caps, ""}, 
        {(char const   *)((void *)0), (char const   **)((void *)0), (char const   *)((void *)0)}};
static struct __anonstruct_builtin_mod_caps_1052271791 builtin_mod_caps[313]  = 
  {      {"\033[1;2A", (uint16_t const   )65517, (uint8_t const   )4}, 
        {"\033[1;3A", (uint16_t const   )65517, (uint8_t const   )1}, 
        {"\033[1;4A", (uint16_t const   )65517, (uint8_t const   )5}, 
        {"\033[1;5A", (uint16_t const   )65517, (uint8_t const   )2}, 
        {"\033[1;6A", (uint16_t const   )65517, (uint8_t const   )6}, 
        {"\033[1;7A", (uint16_t const   )65517, (uint8_t const   )3}, 
        {"\033[1;8A", (uint16_t const   )65517, (uint8_t const   )7}, 
        {"\033[1;2B", (uint16_t const   )65516, (uint8_t const   )4}, 
        {"\033[1;3B", (uint16_t const   )65516, (uint8_t const   )1}, 
        {"\033[1;4B", (uint16_t const   )65516, (uint8_t const   )5}, 
        {"\033[1;5B", (uint16_t const   )65516, (uint8_t const   )2}, 
        {"\033[1;6B", (uint16_t const   )65516, (uint8_t const   )6}, 
        {"\033[1;7B", (uint16_t const   )65516, (uint8_t const   )3}, 
        {"\033[1;8B", (uint16_t const   )65516, (uint8_t const   )7}, 
        {"\033[1;2C", (uint16_t const   )65514, (uint8_t const   )4}, 
        {"\033[1;3C", (uint16_t const   )65514, (uint8_t const   )1}, 
        {"\033[1;4C", (uint16_t const   )65514, (uint8_t const   )5}, 
        {"\033[1;5C", (uint16_t const   )65514, (uint8_t const   )2}, 
        {"\033[1;6C", (uint16_t const   )65514, (uint8_t const   )6}, 
        {"\033[1;7C", (uint16_t const   )65514, (uint8_t const   )3}, 
        {"\033[1;8C", (uint16_t const   )65514, (uint8_t const   )7}, 
        {"\033[1;2D", (uint16_t const   )65515, (uint8_t const   )4}, 
        {"\033[1;3D", (uint16_t const   )65515, (uint8_t const   )1}, 
        {"\033[1;4D", (uint16_t const   )65515, (uint8_t const   )5}, 
        {"\033[1;5D", (uint16_t const   )65515, (uint8_t const   )2}, 
        {"\033[1;6D", (uint16_t const   )65515, (uint8_t const   )6}, 
        {"\033[1;7D", (uint16_t const   )65515, (uint8_t const   )3}, 
        {"\033[1;8D", (uint16_t const   )65515, (uint8_t const   )7}, 
        {"\033[1;2H", (uint16_t const   )65521, (uint8_t const   )4}, 
        {"\033[1;3H", (uint16_t const   )65521, (uint8_t const   )1}, 
        {"\033[1;4H", (uint16_t const   )65521, (uint8_t const   )5}, 
        {"\033[1;5H", (uint16_t const   )65521, (uint8_t const   )2}, 
        {"\033[1;6H", (uint16_t const   )65521, (uint8_t const   )6}, 
        {"\033[1;7H", (uint16_t const   )65521, (uint8_t const   )3}, 
        {"\033[1;8H", (uint16_t const   )65521, (uint8_t const   )7}, 
        {"\033[1;2F", (uint16_t const   )65520, (uint8_t const   )4}, 
        {"\033[1;3F", (uint16_t const   )65520, (uint8_t const   )1}, 
        {"\033[1;4F", (uint16_t const   )65520, (uint8_t const   )5}, 
        {"\033[1;5F", (uint16_t const   )65520, (uint8_t const   )2}, 
        {"\033[1;6F", (uint16_t const   )65520, (uint8_t const   )6}, 
        {"\033[1;7F", (uint16_t const   )65520, (uint8_t const   )3}, 
        {"\033[1;8F", (uint16_t const   )65520, (uint8_t const   )7}, 
        {"\033[2;2~", (uint16_t const   )65523, (uint8_t const   )4}, 
        {"\033[2;3~", (uint16_t const   )65523, (uint8_t const   )1}, 
        {"\033[2;4~", (uint16_t const   )65523, (uint8_t const   )5}, 
        {"\033[2;5~", (uint16_t const   )65523, (uint8_t const   )2}, 
        {"\033[2;6~", (uint16_t const   )65523, (uint8_t const   )6}, 
        {"\033[2;7~", (uint16_t const   )65523, (uint8_t const   )3}, 
        {"\033[2;8~", (uint16_t const   )65523, (uint8_t const   )7}, 
        {"\033[3;2~", (uint16_t const   )65522, (uint8_t const   )4}, 
        {"\033[3;3~", (uint16_t const   )65522, (uint8_t const   )1}, 
        {"\033[3;4~", (uint16_t const   )65522, (uint8_t const   )5}, 
        {"\033[3;5~", (uint16_t const   )65522, (uint8_t const   )2}, 
        {"\033[3;6~", (uint16_t const   )65522, (uint8_t const   )6}, 
        {"\033[3;7~", (uint16_t const   )65522, (uint8_t const   )3}, 
        {"\033[3;8~", (uint16_t const   )65522, (uint8_t const   )7}, 
        {"\033[5;2~", (uint16_t const   )65519, (uint8_t const   )4}, 
        {"\033[5;3~", (uint16_t const   )65519, (uint8_t const   )1}, 
        {"\033[5;4~", (uint16_t const   )65519, (uint8_t const   )5}, 
        {"\033[5;5~", (uint16_t const   )65519, (uint8_t const   )2}, 
        {"\033[5;6~", (uint16_t const   )65519, (uint8_t const   )6}, 
        {"\033[5;7~", (uint16_t const   )65519, (uint8_t const   )3}, 
        {"\033[5;8~", (uint16_t const   )65519, (uint8_t const   )7}, 
        {"\033[6;2~", (uint16_t const   )65518, (uint8_t const   )4}, 
        {"\033[6;3~", (uint16_t const   )65518, (uint8_t const   )1}, 
        {"\033[6;4~", (uint16_t const   )65518, (uint8_t const   )5}, 
        {"\033[6;5~", (uint16_t const   )65518, (uint8_t const   )2}, 
        {"\033[6;6~", (uint16_t const   )65518, (uint8_t const   )6}, 
        {"\033[6;7~", (uint16_t const   )65518, (uint8_t const   )3}, 
        {"\033[6;8~", (uint16_t const   )65518, (uint8_t const   )7}, 
        {"\033[1;2P", (uint16_t const   )65535, (uint8_t const   )4}, 
        {"\033[1;3P", (uint16_t const   )65535, (uint8_t const   )1}, 
        {"\033[1;4P", (uint16_t const   )65535, (uint8_t const   )5}, 
        {"\033[1;5P", (uint16_t const   )65535, (uint8_t const   )2}, 
        {"\033[1;6P", (uint16_t const   )65535, (uint8_t const   )6}, 
        {"\033[1;7P", (uint16_t const   )65535, (uint8_t const   )3}, 
        {"\033[1;8P", (uint16_t const   )65535, (uint8_t const   )7}, 
        {"\033[1;2Q", (uint16_t const   )65534, (uint8_t const   )4}, 
        {"\033[1;3Q", (uint16_t const   )65534, (uint8_t const   )1}, 
        {"\033[1;4Q", (uint16_t const   )65534, (uint8_t const   )5}, 
        {"\033[1;5Q", (uint16_t const   )65534, (uint8_t const   )2}, 
        {"\033[1;6Q", (uint16_t const   )65534, (uint8_t const   )6}, 
        {"\033[1;7Q", (uint16_t const   )65534, (uint8_t const   )3}, 
        {"\033[1;8Q", (uint16_t const   )65534, (uint8_t const   )7}, 
        {"\033[1;2R", (uint16_t const   )65533, (uint8_t const   )4}, 
        {"\033[1;3R", (uint16_t const   )65533, (uint8_t const   )1}, 
        {"\033[1;4R", (uint16_t const   )65533, (uint8_t const   )5}, 
        {"\033[1;5R", (uint16_t const   )65533, (uint8_t const   )2}, 
        {"\033[1;6R", (uint16_t const   )65533, (uint8_t const   )6}, 
        {"\033[1;7R", (uint16_t const   )65533, (uint8_t const   )3}, 
        {"\033[1;8R", (uint16_t const   )65533, (uint8_t const   )7}, 
        {"\033[1;2S", (uint16_t const   )65532, (uint8_t const   )4}, 
        {"\033[1;3S", (uint16_t const   )65532, (uint8_t const   )1}, 
        {"\033[1;4S", (uint16_t const   )65532, (uint8_t const   )5}, 
        {"\033[1;5S", (uint16_t const   )65532, (uint8_t const   )2}, 
        {"\033[1;6S", (uint16_t const   )65532, (uint8_t const   )6}, 
        {"\033[1;7S", (uint16_t const   )65532, (uint8_t const   )3}, 
        {"\033[1;8S", (uint16_t const   )65532, (uint8_t const   )7}, 
        {"\033[15;2~", (uint16_t const   )65531, (uint8_t const   )4}, 
        {"\033[15;3~", (uint16_t const   )65531, (uint8_t const   )1}, 
        {"\033[15;4~", (uint16_t const   )65531, (uint8_t const   )5}, 
        {"\033[15;5~", (uint16_t const   )65531, (uint8_t const   )2}, 
        {"\033[15;6~", (uint16_t const   )65531, (uint8_t const   )6}, 
        {"\033[15;7~", (uint16_t const   )65531, (uint8_t const   )3}, 
        {"\033[15;8~", (uint16_t const   )65531, (uint8_t const   )7}, 
        {"\033[17;2~", (uint16_t const   )65530, (uint8_t const   )4}, 
        {"\033[17;3~", (uint16_t const   )65530, (uint8_t const   )1}, 
        {"\033[17;4~", (uint16_t const   )65530, (uint8_t const   )5}, 
        {"\033[17;5~", (uint16_t const   )65530, (uint8_t const   )2}, 
        {"\033[17;6~", (uint16_t const   )65530, (uint8_t const   )6}, 
        {"\033[17;7~", (uint16_t const   )65530, (uint8_t const   )3}, 
        {"\033[17;8~", (uint16_t const   )65530, (uint8_t const   )7}, 
        {"\033[18;2~", (uint16_t const   )65529, (uint8_t const   )4}, 
        {"\033[18;3~", (uint16_t const   )65529, (uint8_t const   )1}, 
        {"\033[18;4~", (uint16_t const   )65529, (uint8_t const   )5}, 
        {"\033[18;5~", (uint16_t const   )65529, (uint8_t const   )2}, 
        {"\033[18;6~", (uint16_t const   )65529, (uint8_t const   )6}, 
        {"\033[18;7~", (uint16_t const   )65529, (uint8_t const   )3}, 
        {"\033[18;8~", (uint16_t const   )65529, (uint8_t const   )7}, 
        {"\033[19;2~", (uint16_t const   )65528, (uint8_t const   )4}, 
        {"\033[19;3~", (uint16_t const   )65528, (uint8_t const   )1}, 
        {"\033[19;4~", (uint16_t const   )65528, (uint8_t const   )5}, 
        {"\033[19;5~", (uint16_t const   )65528, (uint8_t const   )2}, 
        {"\033[19;6~", (uint16_t const   )65528, (uint8_t const   )6}, 
        {"\033[19;7~", (uint16_t const   )65528, (uint8_t const   )3}, 
        {"\033[19;8~", (uint16_t const   )65528, (uint8_t const   )7}, 
        {"\033[20;2~", (uint16_t const   )65527, (uint8_t const   )4}, 
        {"\033[20;3~", (uint16_t const   )65527, (uint8_t const   )1}, 
        {"\033[20;4~", (uint16_t const   )65527, (uint8_t const   )5}, 
        {"\033[20;5~", (uint16_t const   )65527, (uint8_t const   )2}, 
        {"\033[20;6~", (uint16_t const   )65527, (uint8_t const   )6}, 
        {"\033[20;7~", (uint16_t const   )65527, (uint8_t const   )3}, 
        {"\033[20;8~", (uint16_t const   )65527, (uint8_t const   )7}, 
        {"\033[21;2~", (uint16_t const   )65526, (uint8_t const   )4}, 
        {"\033[21;3~", (uint16_t const   )65526, (uint8_t const   )1}, 
        {"\033[21;4~", (uint16_t const   )65526, (uint8_t const   )5}, 
        {"\033[21;5~", (uint16_t const   )65526, (uint8_t const   )2}, 
        {"\033[21;6~", (uint16_t const   )65526, (uint8_t const   )6}, 
        {"\033[21;7~", (uint16_t const   )65526, (uint8_t const   )3}, 
        {"\033[21;8~", (uint16_t const   )65526, (uint8_t const   )7}, 
        {"\033[23;2~", (uint16_t const   )65525, (uint8_t const   )4}, 
        {"\033[23;3~", (uint16_t const   )65525, (uint8_t const   )1}, 
        {"\033[23;4~", (uint16_t const   )65525, (uint8_t const   )5}, 
        {"\033[23;5~", (uint16_t const   )65525, (uint8_t const   )2}, 
        {"\033[23;6~", (uint16_t const   )65525, (uint8_t const   )6}, 
        {"\033[23;7~", (uint16_t const   )65525, (uint8_t const   )3}, 
        {"\033[23;8~", (uint16_t const   )65525, (uint8_t const   )7}, 
        {"\033[24;2~", (uint16_t const   )65524, (uint8_t const   )4}, 
        {"\033[24;3~", (uint16_t const   )65524, (uint8_t const   )1}, 
        {"\033[24;4~", (uint16_t const   )65524, (uint8_t const   )5}, 
        {"\033[24;5~", (uint16_t const   )65524, (uint8_t const   )2}, 
        {"\033[24;6~", (uint16_t const   )65524, (uint8_t const   )6}, 
        {"\033[24;7~", (uint16_t const   )65524, (uint8_t const   )3}, 
        {"\033[24;8~", (uint16_t const   )65524, (uint8_t const   )7}, 
        {"\033[a", (uint16_t const   )65517, (uint8_t const   )4}, 
        {"\033\033[A", (uint16_t const   )65517, (uint8_t const   )1}, 
        {"\033\033[a", (uint16_t const   )65517, (uint8_t const   )5}, 
        {"\033Oa", (uint16_t const   )65517, (uint8_t const   )2}, 
        {"\033\033Oa", (uint16_t const   )65517, (uint8_t const   )3}, 
        {"\033[b", (uint16_t const   )65516, (uint8_t const   )4}, 
        {"\033\033[B", (uint16_t const   )65516, (uint8_t const   )1}, 
        {"\033\033[b", (uint16_t const   )65516, (uint8_t const   )5}, 
        {"\033Ob", (uint16_t const   )65516, (uint8_t const   )2}, 
        {"\033\033Ob", (uint16_t const   )65516, (uint8_t const   )3}, 
        {"\033[c", (uint16_t const   )65514, (uint8_t const   )4}, 
        {"\033\033[C", (uint16_t const   )65514, (uint8_t const   )1}, 
        {"\033\033[c", (uint16_t const   )65514, (uint8_t const   )5}, 
        {"\033Oc", (uint16_t const   )65514, (uint8_t const   )2}, 
        {"\033\033Oc", (uint16_t const   )65514, (uint8_t const   )3}, 
        {"\033[d", (uint16_t const   )65515, (uint8_t const   )4}, 
        {"\033\033[D", (uint16_t const   )65515, (uint8_t const   )1}, 
        {"\033\033[d", (uint16_t const   )65515, (uint8_t const   )5}, 
        {"\033Od", (uint16_t const   )65515, (uint8_t const   )2}, 
        {"\033\033Od", (uint16_t const   )65515, (uint8_t const   )3}, 
        {"\033[7$", (uint16_t const   )65521, (uint8_t const   )4}, 
        {"\033\033[7~", (uint16_t const   )65521, (uint8_t const   )1}, 
        {"\033\033[7$", (uint16_t const   )65521, (uint8_t const   )5}, 
        {"\033[7^", (uint16_t const   )65521, (uint8_t const   )2}, 
        {"\033[7@", (uint16_t const   )65521, (uint8_t const   )6}, 
        {"\033\033[7^", (uint16_t const   )65521, (uint8_t const   )3}, 
        {"\033\033[7@", (uint16_t const   )65521, (uint8_t const   )7}, 
        {"\033\033[8~", (uint16_t const   )65520, (uint8_t const   )1}, 
        {"\033\033[8$", (uint16_t const   )65520, (uint8_t const   )5}, 
        {"\033[8^", (uint16_t const   )65520, (uint8_t const   )2}, 
        {"\033\033[8^", (uint16_t const   )65520, (uint8_t const   )3}, 
        {"\033\033[8@", (uint16_t const   )65520, (uint8_t const   )7}, 
        {"\033[8@", (uint16_t const   )65520, (uint8_t const   )6}, 
        {"\033[8$", (uint16_t const   )65520, (uint8_t const   )4}, 
        {"\033\033[2~", (uint16_t const   )65523, (uint8_t const   )1}, 
        {"\033\033[2$", (uint16_t const   )65523, (uint8_t const   )5}, 
        {"\033[2^", (uint16_t const   )65523, (uint8_t const   )2}, 
        {"\033\033[2^", (uint16_t const   )65523, (uint8_t const   )3}, 
        {"\033\033[2@", (uint16_t const   )65523, (uint8_t const   )7}, 
        {"\033[2@", (uint16_t const   )65523, (uint8_t const   )6}, 
        {"\033[2$", (uint16_t const   )65523, (uint8_t const   )4}, 
        {"\033\033[3~", (uint16_t const   )65522, (uint8_t const   )1}, 
        {"\033\033[3$", (uint16_t const   )65522, (uint8_t const   )5}, 
        {"\033[3^", (uint16_t const   )65522, (uint8_t const   )2}, 
        {"\033\033[3^", (uint16_t const   )65522, (uint8_t const   )3}, 
        {"\033\033[3@", (uint16_t const   )65522, (uint8_t const   )7}, 
        {"\033[3@", (uint16_t const   )65522, (uint8_t const   )6}, 
        {"\033[3$", (uint16_t const   )65522, (uint8_t const   )4}, 
        {"\033\033[5~", (uint16_t const   )65519, (uint8_t const   )1}, 
        {"\033\033[5$", (uint16_t const   )65519, (uint8_t const   )5}, 
        {"\033[5^", (uint16_t const   )65519, (uint8_t const   )2}, 
        {"\033\033[5^", (uint16_t const   )65519, (uint8_t const   )3}, 
        {"\033\033[5@", (uint16_t const   )65519, (uint8_t const   )7}, 
        {"\033[5@", (uint16_t const   )65519, (uint8_t const   )6}, 
        {"\033[5$", (uint16_t const   )65519, (uint8_t const   )4}, 
        {"\033\033[6~", (uint16_t const   )65518, (uint8_t const   )1}, 
        {"\033\033[6$", (uint16_t const   )65518, (uint8_t const   )5}, 
        {"\033[6^", (uint16_t const   )65518, (uint8_t const   )2}, 
        {"\033\033[6^", (uint16_t const   )65518, (uint8_t const   )3}, 
        {"\033\033[6@", (uint16_t const   )65518, (uint8_t const   )7}, 
        {"\033[6@", (uint16_t const   )65518, (uint8_t const   )6}, 
        {"\033[6$", (uint16_t const   )65518, (uint8_t const   )4}, 
        {"\033\033[11~", (uint16_t const   )65535, (uint8_t const   )1}, 
        {"\033\033[23~", (uint16_t const   )65535, (uint8_t const   )5}, 
        {"\033[11^", (uint16_t const   )65535, (uint8_t const   )2}, 
        {"\033\033[11^", (uint16_t const   )65535, (uint8_t const   )3}, 
        {"\033\033[23^", (uint16_t const   )65535, (uint8_t const   )7}, 
        {"\033[23^", (uint16_t const   )65535, (uint8_t const   )6}, 
        {"\033[23~", (uint16_t const   )65535, (uint8_t const   )4}, 
        {"\033\033[12~", (uint16_t const   )65534, (uint8_t const   )1}, 
        {"\033\033[24~", (uint16_t const   )65534, (uint8_t const   )5}, 
        {"\033[12^", (uint16_t const   )65534, (uint8_t const   )2}, 
        {"\033\033[12^", (uint16_t const   )65534, (uint8_t const   )3}, 
        {"\033\033[24^", (uint16_t const   )65534, (uint8_t const   )7}, 
        {"\033[24^", (uint16_t const   )65534, (uint8_t const   )6}, 
        {"\033[24~", (uint16_t const   )65534, (uint8_t const   )4}, 
        {"\033\033[13~", (uint16_t const   )65533, (uint8_t const   )1}, 
        {"\033\033[25~", (uint16_t const   )65533, (uint8_t const   )5}, 
        {"\033[13^", (uint16_t const   )65533, (uint8_t const   )2}, 
        {"\033\033[13^", (uint16_t const   )65533, (uint8_t const   )3}, 
        {"\033\033[25^", (uint16_t const   )65533, (uint8_t const   )7}, 
        {"\033[25^", (uint16_t const   )65533, (uint8_t const   )6}, 
        {"\033[25~", (uint16_t const   )65533, (uint8_t const   )4}, 
        {"\033\033[14~", (uint16_t const   )65532, (uint8_t const   )1}, 
        {"\033\033[26~", (uint16_t const   )65532, (uint8_t const   )5}, 
        {"\033[14^", (uint16_t const   )65532, (uint8_t const   )2}, 
        {"\033\033[14^", (uint16_t const   )65532, (uint8_t const   )3}, 
        {"\033\033[26^", (uint16_t const   )65532, (uint8_t const   )7}, 
        {"\033[26^", (uint16_t const   )65532, (uint8_t const   )6}, 
        {"\033[26~", (uint16_t const   )65532, (uint8_t const   )4}, 
        {"\033\033[15~", (uint16_t const   )65531, (uint8_t const   )1}, 
        {"\033\033[28~", (uint16_t const   )65531, (uint8_t const   )5}, 
        {"\033[15^", (uint16_t const   )65531, (uint8_t const   )2}, 
        {"\033\033[15^", (uint16_t const   )65531, (uint8_t const   )3}, 
        {"\033\033[28^", (uint16_t const   )65531, (uint8_t const   )7}, 
        {"\033[28^", (uint16_t const   )65531, (uint8_t const   )6}, 
        {"\033[28~", (uint16_t const   )65531, (uint8_t const   )4}, 
        {"\033\033[17~", (uint16_t const   )65530, (uint8_t const   )1}, 
        {"\033\033[29~", (uint16_t const   )65530, (uint8_t const   )5}, 
        {"\033[17^", (uint16_t const   )65530, (uint8_t const   )2}, 
        {"\033\033[17^", (uint16_t const   )65530, (uint8_t const   )3}, 
        {"\033\033[29^", (uint16_t const   )65530, (uint8_t const   )7}, 
        {"\033[29^", (uint16_t const   )65530, (uint8_t const   )6}, 
        {"\033[29~", (uint16_t const   )65530, (uint8_t const   )4}, 
        {"\033\033[18~", (uint16_t const   )65529, (uint8_t const   )1}, 
        {"\033\033[31~", (uint16_t const   )65529, (uint8_t const   )5}, 
        {"\033[18^", (uint16_t const   )65529, (uint8_t const   )2}, 
        {"\033\033[18^", (uint16_t const   )65529, (uint8_t const   )3}, 
        {"\033\033[31^", (uint16_t const   )65529, (uint8_t const   )7}, 
        {"\033[31^", (uint16_t const   )65529, (uint8_t const   )6}, 
        {"\033[31~", (uint16_t const   )65529, (uint8_t const   )4}, 
        {"\033\033[19~", (uint16_t const   )65528, (uint8_t const   )1}, 
        {"\033\033[32~", (uint16_t const   )65528, (uint8_t const   )5}, 
        {"\033[19^", (uint16_t const   )65528, (uint8_t const   )2}, 
        {"\033\033[19^", (uint16_t const   )65528, (uint8_t const   )3}, 
        {"\033\033[32^", (uint16_t const   )65528, (uint8_t const   )7}, 
        {"\033[32^", (uint16_t const   )65528, (uint8_t const   )6}, 
        {"\033[32~", (uint16_t const   )65528, (uint8_t const   )4}, 
        {"\033\033[20~", (uint16_t const   )65527, (uint8_t const   )1}, 
        {"\033\033[33~", (uint16_t const   )65527, (uint8_t const   )5}, 
        {"\033[20^", (uint16_t const   )65527, (uint8_t const   )2}, 
        {"\033\033[20^", (uint16_t const   )65527, (uint8_t const   )3}, 
        {"\033\033[33^", (uint16_t const   )65527, (uint8_t const   )7}, 
        {"\033[33^", (uint16_t const   )65527, (uint8_t const   )6}, 
        {"\033[33~", (uint16_t const   )65527, (uint8_t const   )4}, 
        {"\033\033[21~", (uint16_t const   )65526, (uint8_t const   )1}, 
        {"\033\033[34~", (uint16_t const   )65526, (uint8_t const   )5}, 
        {"\033[21^", (uint16_t const   )65526, (uint8_t const   )2}, 
        {"\033\033[21^", (uint16_t const   )65526, (uint8_t const   )3}, 
        {"\033\033[34^", (uint16_t const   )65526, (uint8_t const   )7}, 
        {"\033[34^", (uint16_t const   )65526, (uint8_t const   )6}, 
        {"\033[34~", (uint16_t const   )65526, (uint8_t const   )4}, 
        {"\033\033[23~", (uint16_t const   )65525, (uint8_t const   )1}, 
        {"\033\033[23$", (uint16_t const   )65525, (uint8_t const   )5}, 
        {"\033[23^", (uint16_t const   )65525, (uint8_t const   )2}, 
        {"\033\033[23^", (uint16_t const   )65525, (uint8_t const   )3}, 
        {"\033\033[23@", (uint16_t const   )65525, (uint8_t const   )7}, 
        {"\033[23@", (uint16_t const   )65525, (uint8_t const   )6}, 
        {"\033[23$", (uint16_t const   )65525, (uint8_t const   )4}, 
        {"\033\033[24~", (uint16_t const   )65524, (uint8_t const   )1}, 
        {"\033\033[24$", (uint16_t const   )65524, (uint8_t const   )5}, 
        {"\033[24^", (uint16_t const   )65524, (uint8_t const   )2}, 
        {"\033\033[24^", (uint16_t const   )65524, (uint8_t const   )3}, 
        {"\033\033[24@", (uint16_t const   )65524, (uint8_t const   )7}, 
        {"\033[24@", (uint16_t const   )65524, (uint8_t const   )6}, 
        {"\033[24$", (uint16_t const   )65524, (uint8_t const   )4}, 
        {"\033[A", (uint16_t const   )65517, (uint8_t const   )4}, 
        {"\033[B", (uint16_t const   )65516, (uint8_t const   )4}, 
        {"\033[C", (uint16_t const   )65514, (uint8_t const   )4}, 
        {"\033[D", (uint16_t const   )65515, (uint8_t const   )4}, 
        {"\033OA", (uint16_t const   )65517, (uint8_t const   )2}, 
        {"\033\033OA", (uint16_t const   )65517, (uint8_t const   )3}, 
        {"\033OB", (uint16_t const   )65516, (uint8_t const   )2}, 
        {"\033\033OB", (uint16_t const   )65516, (uint8_t const   )3}, 
        {"\033OC", (uint16_t const   )65514, (uint8_t const   )2}, 
        {"\033\033OC", (uint16_t const   )65514, (uint8_t const   )3}, 
        {"\033OD", (uint16_t const   )65515, (uint8_t const   )2}, 
        {"\033\033OD", (uint16_t const   )65515, (uint8_t const   )3}, 
        {(char const   *)((void *)0), (uint16_t const   )0, (uint8_t const   )0}};
static unsigned char const   utf8_length[256]  = 
  {      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )3, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4,      (unsigned char const   )4, 
        (unsigned char const   )5,      (unsigned char const   )5,      (unsigned char const   )5,      (unsigned char const   )5, 
        (unsigned char const   )6,      (unsigned char const   )6,      (unsigned char const   )1,      (unsigned char const   )1};
static unsigned char const   utf8_mask[6]  = {      (unsigned char const   )127,      (unsigned char const   )31,      (unsigned char const   )15,      (unsigned char const   )7, 
        (unsigned char const   )3,      (unsigned char const   )1};
static int tb_reset(void) ;
static int tb_printf_inner(int x , int y , uintattr_t fg , uintattr_t bg , size_t *out_w ,
                           char const   *fmt , va_list___0 vl ) ;
static int init_term_attrs(void) ;
static int init_term_caps(void) ;
static int init_cap_trie(void) ;
static int cap_trie_add(char const   *cap , uint16_t key , uint8_t mod ) ;
static int cap_trie_find(char const   *buf___0 , size_t nbuf , struct cap_trie_t **last ,
                         size_t *depth ) ;
static int cap_trie_deinit(struct cap_trie_t *node ) ;
static int init_resize_handler(void) ;
static int send_init_escape_codes(void) ;
static int send_clear(void) ;
static int update_term_size(void) ;
static int update_term_size_via_esc(void) ;
static int init_cellbuf(void) ;
static int tb_deinit(void) ;
static int load_terminfo(void) ;
static int load_terminfo_from_path(char const   *path , char const   *term ) ;
static int read_terminfo_path(char const   *path ) ;
static int parse_terminfo_caps(void) ;
static int load_builtin_caps(void) ;
static char const   *get_terminfo_string(int16_t str_offsets_pos , int16_t str_table_pos ,
                                         int16_t str_table_len , int16_t str_index ) ;
static int wait_event(struct tb_event *event , int timeout ) ;
static int extract_event(struct tb_event *event ) ;
static int extract_esc(struct tb_event *event ) ;
static int extract_esc_user(struct tb_event *event , int is_post ) ;
static int extract_esc_cap(struct tb_event *event ) ;
static int extract_esc_mouse(struct tb_event *event ) ;
static int resize_cellbufs(void) ;
static void handle_resize(int sig ) ;
static int send_attr(uintattr_t fg , uintattr_t bg ) ;
static int send_sgr(uintattr_t fg , uintattr_t bg ) ;
static int send_cursor_if(int x , int y ) ;
static int send_char(int x , int y , uint32_t ch ) ;
static int send_cluster(int x , int y , uint32_t *ch , size_t nch ) ;
static int convert_num(uint32_t num , char *buf___0 ) ;
static int cell_cmp(struct tb_cell *a , struct tb_cell *b ) ;
static int cell_copy(struct tb_cell *dst , struct tb_cell *src ) ;
static int cell_set(struct tb_cell *cell , uint32_t *ch , size_t nch , uintattr_t fg ,
                    uintattr_t bg ) ;
static int cell_free(struct tb_cell *cell ) ;
static int cellbuf_init(struct cellbuf_t *c , int w , int h ) ;
static int cellbuf_free(struct cellbuf_t *c ) ;
static int cellbuf_clear(struct cellbuf_t *c ) ;
static int cellbuf_get(struct cellbuf_t *c , int x , int y , struct tb_cell **out ) ;
static int cellbuf_resize(struct cellbuf_t *c , int w , int h ) ;
static int bytebuf_puts(struct bytebuf_t *b , char const   *str ) ;
static int bytebuf_nputs(struct bytebuf_t *b , char const   *str , size_t nstr ) ;
static int bytebuf_shift(struct bytebuf_t *b , size_t n ) ;
static int bytebuf_flush(struct bytebuf_t *b , int fd ) ;
static int bytebuf_reserve(struct bytebuf_t *b , size_t sz ) ;
static int bytebuf_free(struct bytebuf_t *b ) ;
int tb_init(void) 
{ 
  int tmp ;

  {
  tmp = tb_init_file("/dev/tty");
  return (tmp);
}
}
int tb_init_file(char const   *path ) 
{ 
  int ttyfd ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  if (global.initialized) {
    return (-3);
  }
  tmp = open(path, 2);
  ttyfd = tmp;
  if (ttyfd < 0) {
    tmp___0 = __errno_location();
    global.last_errno = *tmp___0;
    return (-4);
  }
  global.ttyfd_open = 1;
  tmp___1 = tb_init_fd(ttyfd);
  return (tmp___1);
}
}
int tb_init_fd(int ttyfd ) 
{ 
  int tmp ;

  {
  tmp = tb_init_rwfd(ttyfd, ttyfd);
  return (tmp);
}
}
int tb_init_rwfd(int rfd , int wfd ) 
{ 
  int rv ;
  int tmp___0 ;

  {
  tb_reset();
  if (rfd == wfd) {
    tmp___0 = isatty(rfd);
    if (tmp___0) {
      global.ttyfd = rfd;
    } else {
      global.ttyfd = -1;
    }
  } else {
    global.ttyfd = -1;
  }
  global.rfd = rfd;
  global.wfd = wfd;
  while (1) {
    rv = init_term_attrs();
    if (rv != 0) {
      break;
    }
    rv = init_term_caps();
    if (rv != 0) {
      break;
    }
    rv = init_cap_trie();
    if (rv != 0) {
      break;
    }
    rv = init_resize_handler();
    if (rv != 0) {
      break;
    }
    rv = send_init_escape_codes();
    if (rv != 0) {
      break;
    }
    rv = send_clear();
    if (rv != 0) {
      break;
    }
    rv = update_term_size();
    if (rv != 0) {
      break;
    }
    rv = init_cellbuf();
    if (rv != 0) {
      break;
    }
    global.initialized = 1;
    break;
  }
  if (rv != 0) {
    tb_deinit();
  }
  return (rv);
}
}
int tb_shutdown(void) 
{ 


  {
  if (! global.initialized) {
    return (-8);
  }
  tb_deinit();
  return (0);
}
}
int tb_width(void) 
{ 


  {
  if (! global.initialized) {
    return (-8);
  }
  return (global.width);
}
}
int tb_height(void) 
{ 


  {
  if (! global.initialized) {
    return (-8);
  }
  return (global.height);
}
}
int tb_clear(void) 
{ 
  int tmp ;

  {
  if (! global.initialized) {
    return (-8);
  }
  tmp = cellbuf_clear(& global.back);
  return (tmp);
}
}
int tb_set_clear_attrs(uintattr_t fg , uintattr_t bg ) 
{ 


  {
  if (! global.initialized) {
    return (-8);
  }
  global.fg = fg;
  global.bg = bg;
  return (0);
}
}
int tb_present(void) 
{ 
  int rv ;
  int x ;
  int y ;
  int i ;
  struct tb_cell *back ;
  struct tb_cell *front ;
  int w ;
  struct tb_cell *front_wide ;
  int tmp ;

  {
  if (! global.initialized) {
    return (-8);
  }
  global.last_x = -1;
  global.last_y = -1;
  y = 0;
  while (y < global.front.height) {
    x = 0;
    while (x < global.front.width) {
      rv = cellbuf_get(& global.back, x, y, & back);
      if (rv != 0) {
        return (rv);
      }
      rv = cellbuf_get(& global.front, x, y, & front);
      if (rv != 0) {
        return (rv);
      }
      w = wcwidth((wchar_t )back->ch);
      if (w < 1) {
        w = 1;
      }
      tmp = cell_cmp(back, front);
      if (tmp != 0) {
        cell_copy(front, back);
        send_attr(back->fg, back->bg);
        if (w > 1) {
          if (x >= global.front.width - (w - 1)) {
            i = x;
            while (i < global.front.width) {
              send_char(i, y, (uint32_t )' ');
              i ++;
            }
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          send_char(x, y, back->ch);
          i = 1;
          while (i < w) {
            rv = cellbuf_get(& global.front, x + i, y, & front_wide);
            if (rv != 0) {
              return (rv);
            }
            rv = cell_set(front_wide, (uint32_t *)0, (size_t )1, back->fg, back->bg);
            if (rv != 0) {
              return (rv);
            }
            i ++;
          }
        }
      }
      x += w;
    }
    y ++;
  }
  rv = send_cursor_if(global.cursor_x, global.cursor_y);
  if (rv != 0) {
    return (rv);
  }
  rv = bytebuf_flush(& global.out, global.wfd);
  if (rv != 0) {
    return (rv);
  }
  return (0);
}
}
int tb_set_cursor(int cx , int cy ) 
{ 
  int rv ;

  {
  if (! global.initialized) {
    return (-8);
  }
  if (cx < 0) {
    cx = 0;
  }
  if (cy < 0) {
    cy = 0;
  }
  if (global.cursor_x == -1) {
    rv = bytebuf_puts(& global.out, global.caps[25]);
    if (rv != 0) {
      return (rv);
    }
  }
  rv = send_cursor_if(cx, cy);
  if (rv != 0) {
    return (rv);
  }
  global.cursor_x = cx;
  global.cursor_y = cy;
  return (0);
}
}
int tb_hide_cursor(void) 
{ 
  int rv ;

  {
  if (! global.initialized) {
    return (-8);
  }
  if (global.cursor_x >= 0) {
    rv = bytebuf_puts(& global.out, global.caps[26]);
    if (rv != 0) {
      return (rv);
    }
  }
  global.cursor_x = -1;
  global.cursor_y = -1;
  return (0);
}
}
int tb_set_cell(int x , int y , uint32_t ch , uintattr_t fg , uintattr_t bg ) 
{ 
  int tmp ;

  {
  if (! global.initialized) {
    return (-8);
  }
  tmp = tb_set_cell_ex(x, y, & ch, (size_t )1, fg, bg);
  return (tmp);
}
}
int tb_set_cell_ex(int x , int y , uint32_t *ch , size_t nch , uintattr_t fg , uintattr_t bg ) 
{ 
  int rv ;
  struct tb_cell *cell ;

  {
  if (! global.initialized) {
    return (-8);
  }
  rv = cellbuf_get(& global.back, x, y, & cell);
  if (rv != 0) {
    return (rv);
  }
  rv = cell_set(cell, ch, nch, fg, bg);
  if (rv != 0) {
    return (rv);
  }
  return (0);
}
}
int tb_extend_cell(int x , int y , uint32_t ch ) 
{ 


  {
  if (! global.initialized) {
    return (-8);
  }
  return (-1);
}
}
int tb_set_input_mode(int mode ) 
{ 


  {
  if (! global.initialized) {
    return (-8);
  }
  if (mode == 0) {
    return (global.input_mode);
  }
  if ((mode & 3) == 0) {
    mode |= 1;
  }
  if ((mode & 3) == 3) {
    mode &= -3;
  }
  if (mode & 4) {
    bytebuf_puts(& global.out, "\033[?1000h\033[?1002h\033[?1015h\033[?1006h");
    bytebuf_flush(& global.out, global.wfd);
  } else {
    bytebuf_puts(& global.out, "\033[?1006l\033[?1015l\033[?1002l\033[?1000l");
    bytebuf_flush(& global.out, global.wfd);
  }
  global.input_mode = mode;
  return (0);
}
}
int tb_set_output_mode(int mode ) 
{ 


  {
  if (! global.initialized) {
    return (-8);
  }
  switch (mode) {
  case 0: 
  return (global.output_mode);
  case 4: 
  case 3: 
  case 2: 
  case 1: 
  global.output_mode = mode;
  return (0);
  }
  return (-1);
}
}
int tb_peek_event(struct tb_event *event , int timeout_ms ) 
{ 
  int tmp ;

  {
  if (! global.initialized) {
    return (-8);
  }
  tmp = wait_event(event, timeout_ms);
  return (tmp);
}
}
int tb_poll_event(struct tb_event *event ) 
{ 
  int tmp ;

  {
  if (! global.initialized) {
    return (-8);
  }
  tmp = wait_event(event, -1);
  return (tmp);
}
}
int tb_get_fds(int *ttyfd , int *resizefd ) 
{ 


  {
  if (! global.initialized) {
    return (-8);
  }
  *ttyfd = global.rfd;
  *resizefd = global.resize_pipefd[0];
  return (0);
}
}
int tb_print(int x , int y , uintattr_t fg , uintattr_t bg , char const   *str ) 
{ 
  int tmp ;

  {
  tmp = tb_print_ex(x, y, fg, bg, (size_t *)((void *)0), str);
  return (tmp);
}
}
int tb_print_ex(int x , int y , uintattr_t fg , uintattr_t bg , size_t *out_w , char const   *str ) 
{ 
  int rv ;
  uint32_t uni ;
  int w ;
  int ix ;
  int tmp ;

  {
  ix = x;
  if (out_w) {
    *out_w = (size_t )0;
  }
  while (*str) {
    tmp = tb_utf8_char_to_unicode(& uni, str);
    str += tmp;
    w = wcwidth((wchar_t )uni);
    if (w < 0) {
      w = 1;
    }
    if (w == 0) {
      if (x > ix) {
        rv = tb_extend_cell(x - 1, y, uni);
        if (rv != 0) {
          return (rv);
        }
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      rv = tb_set_cell(x, y, uni, fg, bg);
      if (rv != 0) {
        return (rv);
      }
    }
    x += w;
    if (out_w) {
      *out_w += (size_t )w;
    }
  }
  return (0);
}
}
int tb_printf(int x , int y , uintattr_t fg , uintattr_t bg , char const   *fmt  , ...) 
{ 
  int rv ;
  va_list___0 vl ;

  {
  __builtin_va_start(vl, fmt);
  rv = tb_printf_inner(x, y, fg, bg, (size_t *)((void *)0), fmt, vl);
  __builtin_va_end(vl);
  return (rv);
}
}
int tb_printf_ex(int x , int y , uintattr_t fg , uintattr_t bg , size_t *out_w , char const   *fmt 
                 , ...) 
{ 
  int rv ;
  va_list___0 vl ;

  {
  __builtin_va_start(vl, fmt);
  rv = tb_printf_inner(x, y, fg, bg, out_w, fmt, vl);
  __builtin_va_end(vl);
  return (rv);
}
}
int tb_send(char const   *buf___0 , size_t nbuf ) 
{ 
  int tmp ;

  {
  tmp = bytebuf_nputs(& global.out, buf___0, nbuf);
  return (tmp);
}
}
int tb_sendf(char const   *fmt  , ...) 
{ 
  int rv ;
  char buf___0[4096] ;
  va_list___0 vl ;
  int tmp ;

  {
  __builtin_va_start(vl, fmt);
  rv = vsnprintf((char * __restrict  )(buf___0), sizeof(buf___0), (char const   * __restrict  )fmt,
                 vl);
  __builtin_va_end(vl);
  if (rv < 0) {
    return (-1);
  } else
  if (rv >= (int )sizeof(buf___0)) {
    return (-1);
  }
  tmp = tb_send((char const   *)(buf___0), (size_t )rv);
  return (tmp);
}
}
int tb_set_func(int fn_type , int (*fn)(struct tb_event * , size_t * ) ) 
{ 


  {
  switch (fn_type) {
  case 0: 
  global.fn_extract_esc_pre = fn;
  return (0);
  case 1: 
  global.fn_extract_esc_post = fn;
  return (0);
  }
  return (-1);
}
}
struct tb_cell *tb_cell_buffer(void) 
{ 


  {
  if (! global.initialized) {
    return ((struct tb_cell *)((void *)0));
  }
  return (global.back.cells);
}
}
int tb_utf8_char_length(char c ) 
{ 


  {
  return ((int )utf8_length[(unsigned char )c]);
}
}
int tb_utf8_char_to_unicode(uint32_t *out , char const   *c ) 
{ 
  int i ;
  unsigned char len ;
  int tmp ;
  unsigned char mask ;
  uint32_t result ;

  {
  if ((int const   )*c == 0) {
    return (-1);
  }
  tmp = tb_utf8_char_length((char )*c);
  len = (unsigned char )tmp;
  mask = (unsigned char )utf8_mask[(int )len - 1];
  result = (uint32_t )((int const   )*(c + 0) & (int const   )mask);
  i = 1;
  while (i < (int )len) {
    result <<= 6;
    result |= (unsigned int )((int const   )*(c + i) & 63);
    i ++;
  }
  *out = result;
  return ((int )len);
}
}
int tb_utf8_unicode_to_char(char *out , uint32_t c ) 
{ 
  int len ;
  int first ;
  int i ;

  {
  len = 0;
  if (c < 128U) {
    first = 0;
    len = 1;
  } else
  if (c < 2048U) {
    first = 192;
    len = 2;
  } else
  if (c < 65536U) {
    first = 224;
    len = 3;
  } else
  if (c < 2097152U) {
    first = 240;
    len = 4;
  } else
  if (c < 67108864U) {
    first = 248;
    len = 5;
  } else {
    first = 252;
    len = 6;
  }
  i = len - 1;
  while (i > 0) {
    *(out + i) = (char )((c & 63U) | 128U);
    c >>= 6;
    i --;
  }
  *(out + 0) = (char )(c | (unsigned int )first);
  return (len);
}
}
int tb_last_errno(void) 
{ 


  {
  return (global.last_errno);
}
}
char const   *tb_strerror(int err ) 
{ 
  char *tmp ;

  {
  switch (err) {
  case 0: 
  return ("Success");
  case -2: 
  return ("Not enough input");
  case -3: 
  return ("Termbox initialized already");
  case -5: 
  return ("Out of memory");
  case -6: 
  return ("No event");
  case -7: 
  return ("No TERM in environment");
  case -8: 
  return ("Termbox not initialized");
  case -9: 
  return ("Out of bounds");
  case -17: 
  return ("Unsupported terminal");
  case -22: 
  return ("Termcaps collision");
  case -21: 
  return ("Terminal width/height not received by sscanf() after resize");
  default: 
  tmp = strerror(global.last_errno);
  return ((char const   *)tmp);
  }
}
}
int tb_has_truecolor(void) 
{ 


  {
  return (0);
}
}
int tb_has_egc(void) 
{ 


  {
  return (0);
}
}
static int tb_reset(void) 
{ 
  int ttyfd_open ;

  {
  ttyfd_open = global.ttyfd_open;
  memset((void *)(& global), 0, sizeof(global));
  global.ttyfd = -1;
  global.rfd = -1;
  global.wfd = -1;
  global.ttyfd_open = ttyfd_open;
  global.resize_pipefd[0] = -1;
  global.resize_pipefd[1] = -1;
  global.width = -1;
  global.height = -1;
  global.cursor_x = -1;
  global.cursor_y = -1;
  global.last_x = -1;
  global.last_y = -1;
  global.fg = (uintattr_t )0;
  global.bg = (uintattr_t )0;
  global.last_fg = (uintattr_t )(~ ((int )global.fg));
  global.last_bg = (uintattr_t )(~ ((int )global.bg));
  global.input_mode = 1;
  global.output_mode = 1;
  return (0);
}
}
static int init_term_attrs(void) 
{ 
  int *tmp ;
  int tmp___0 ;
  struct termios tios ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  if (global.ttyfd < 0) {
    return (0);
  }
  tmp___0 = tcgetattr(global.ttyfd, & global.orig_tios);
  if (tmp___0 != 0) {
    tmp = __errno_location();
    global.last_errno = *tmp;
    return (-15);
  }
  memcpy((void * __restrict  )(& tios), (void const   * __restrict  )(& global.orig_tios),
         sizeof(tios));
  global.has_orig_tios = 1;
  cfmakeraw(& tios);
  tios.c_cc[6] = (cc_t )1;
  tios.c_cc[5] = (cc_t )0;
  tmp___2 = tcsetattr(global.ttyfd, 2, (struct termios  const  *)(& tios));
  if (tmp___2 != 0) {
    tmp___1 = __errno_location();
    global.last_errno = *tmp___1;
    return (-16);
  }
  return (0);
}
}
static int tb_printf_inner(int x , int y , uintattr_t fg , uintattr_t bg , size_t *out_w ,
                           char const   *fmt , va_list___0 vl ) 
{ 
  int rv ;
  char buf___0[4096] ;
  int tmp ;

  {
  rv = vsnprintf((char * __restrict  )(buf___0), sizeof(buf___0), (char const   * __restrict  )fmt,
                 vl);
  if (rv < 0) {
    return (-1);
  } else
  if (rv >= (int )sizeof(buf___0)) {
    return (-1);
  }
  tmp = tb_print_ex(x, y, fg, bg, out_w, (char const   *)(buf___0));
  return (tmp);
}
}
static int init_term_caps(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp___0 = load_terminfo();
  if (tmp___0 == 0) {
    tmp = parse_terminfo_caps();
    return (tmp);
  }
  tmp___1 = load_builtin_caps();
  return (tmp___1);
}
}
static int init_cap_trie(void) 
{ 
  int rv ;
  int i ;

  {
  i = 0;
  while (i < 23) {
    rv = cap_trie_add(global.caps[i], (uint16_t )(65535 - i), (uint8_t )0);
    if (rv != 0) {
      return (rv);
    }
    i ++;
  }
  i = 0;
  while ((unsigned long )builtin_mod_caps[i].cap != (unsigned long )((void *)0)) {
    rv = cap_trie_add(builtin_mod_caps[i].cap, (uint16_t )builtin_mod_caps[i].key,
                      (uint8_t )builtin_mod_caps[i].mod);
    if (rv != 0) {
      if (rv != -22) {
        return (rv);
      }
    }
    i ++;
  }
  return (0);
}
}
static int cap_trie_add(char const   *cap , uint16_t key , uint8_t mod ) 
{ 
  struct cap_trie_t *next ;
  struct cap_trie_t *node ;
  size_t i ;
  size_t j ;
  char c ;
  void *tmp ;

  {
  node = & global.cap_trie;
  i = (size_t )0;
  while ((int const   )*(cap + i) != 0) {
    c = (char )*(cap + i);
    next = (struct cap_trie_t *)((void *)0);
    j = (size_t )0;
    while (j < node->nchildren) {
      if ((int )(node->children + j)->c == (int )c) {
        next = node->children + j;
        break;
      }
      j ++;
    }
    if (! next) {
      (node->nchildren) ++;
      tmp = realloc((void *)node->children, sizeof(*node) * node->nchildren);
      node->children = (struct cap_trie_t *)tmp;
      if (! node->children) {
        return (-5);
      }
      next = node->children + (node->nchildren - 1UL);
      memset((void *)next, 0, sizeof(*next));
      next->c = c;
    }
    node = next;
    i ++;
  }
  if (node->is_leaf) {
    return (-22);
  }
  node->is_leaf = 1;
  node->key = key;
  node->mod = mod;
  return (0);
}
}
static int cap_trie_find(char const   *buf___0 , size_t nbuf , struct cap_trie_t **last ,
                         size_t *depth ) 
{ 
  struct cap_trie_t *next ;
  struct cap_trie_t *node ;
  size_t i ;
  size_t j ;
  char c ;

  {
  node = & global.cap_trie;
  *last = node;
  *depth = (size_t )0;
  i = (size_t )0;
  while (i < nbuf) {
    c = (char )*(buf___0 + i);
    next = (struct cap_trie_t *)((void *)0);
    j = (size_t )0;
    while (j < node->nchildren) {
      if ((int )(node->children + j)->c == (int )c) {
        next = node->children + j;
        break;
      }
      j ++;
    }
    if (! next) {
      return (0);
    }
    node = next;
    *last = node;
    (*depth) ++;
    if (node->is_leaf) {
      if (node->nchildren < 1UL) {
        break;
      }
    }
    i ++;
  }
  return (0);
}
}
static int cap_trie_deinit(struct cap_trie_t *node ) 
{ 
  size_t j ;

  {
  j = (size_t )0;
  while (j < node->nchildren) {
    cap_trie_deinit(node->children + j);
    j ++;
  }
  if (node->children) {
    free((void *)node->children);
  }
  memset((void *)node, 0, sizeof(*node));
  return (0);
}
}
static int init_resize_handler(void) 
{ 
  int *tmp ;
  int tmp___0 ;
  struct sigaction sa ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  tmp___0 = pipe((int *)(global.resize_pipefd));
  if (tmp___0 != 0) {
    tmp = __errno_location();
    global.last_errno = *tmp;
    return (-12);
  }
  memset((void *)(& sa), 0, sizeof(sa));
  sa.__sigaction_handler.sa_handler = & handle_resize;
  tmp___2 = sigaction(28, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
  if (tmp___2 != 0) {
    tmp___1 = __errno_location();
    global.last_errno = *tmp___1;
    return (-13);
  }
  return (0);
}
}
static int send_init_escape_codes(void) 
{ 
  int rv ;

  {
  rv = bytebuf_puts(& global.out, global.caps[23]);
  if (rv != 0) {
    return (rv);
  }
  rv = bytebuf_puts(& global.out, global.caps[34]);
  if (rv != 0) {
    return (rv);
  }
  rv = bytebuf_puts(& global.out, global.caps[26]);
  if (rv != 0) {
    return (rv);
  }
  return (0);
}
}
static int send_clear(void) 
{ 
  int rv ;

  {
  rv = send_attr(global.fg, global.bg);
  if (rv != 0) {
    return (rv);
  }
  rv = bytebuf_puts(& global.out, global.caps[27]);
  if (rv != 0) {
    return (rv);
  }
  rv = send_cursor_if(global.cursor_x, global.cursor_y);
  if (rv != 0) {
    return (rv);
  }
  rv = bytebuf_flush(& global.out, global.wfd);
  if (rv != 0) {
    return (rv);
  }
  global.last_x = -1;
  global.last_y = -1;
  return (0);
}
}
static int update_term_size(void) 
{ 
  int rv ;
  int ioctl_errno ;
  struct winsize sz ;
  int tmp ;
  int *tmp___0 ;

  {
  if (global.ttyfd < 0) {
    return (0);
  }
  memset((void *)(& sz), 0, sizeof(sz));
  tmp = ioctl(global.ttyfd, 21523UL, & sz);
  if (tmp == 0) {
    global.width = (int )sz.ws_col;
    global.height = (int )sz.ws_row;
    return (0);
  }
  tmp___0 = __errno_location();
  ioctl_errno = *tmp___0;
  rv = update_term_size_via_esc();
  if (rv == 0) {
    return (rv);
  }
  global.last_errno = ioctl_errno;
  return (-11);
}
}
static int update_term_size_via_esc(void) 
{ 
  char *move_and_report ;
  ssize_t write_rv ;
  size_t tmp ;
  ssize_t tmp___0 ;
  size_t tmp___1 ;
  fd_set fds ;
  int __d0 ;
  int __d1 ;
  struct timeval timeout ;
  int select_rv ;
  int tmp___2 ;
  int *tmp___3 ;
  char buf___0[64] ;
  ssize_t read_rv ;
  ssize_t tmp___4 ;
  int *tmp___5 ;
  int rw ;
  int rh ;
  int tmp___6 ;

  {
  move_and_report = (char *)"\033[9999;9999H\033[6n";
  tmp = strlen((char const   *)move_and_report);
  tmp___0 = write(global.wfd, (void const   *)move_and_report, tmp);
  write_rv = tmp___0;
  tmp___1 = strlen((char const   *)move_and_report);
  if (write_rv != (ssize_t )tmp___1) {
    return (-18);
  }
  while (1) {
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fds.fds_bits[0]): "memory");
    break;
  }
  fds.fds_bits[global.rfd / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << global.rfd % (8 * (int )sizeof(__fd_mask )));
  timeout.tv_sec = (__time_t )0;
  timeout.tv_usec = (__suseconds_t )1000000;
  tmp___2 = select(global.rfd + 1, (fd_set * __restrict  )(& fds), (fd_set * __restrict  )((void *)0),
                   (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )(& timeout));
  select_rv = tmp___2;
  if (select_rv != 1) {
    tmp___3 = __errno_location();
    global.last_errno = *tmp___3;
    return (-19);
  }
  tmp___4 = read(global.rfd, (void *)(buf___0), sizeof(buf___0) - 1UL);
  read_rv = tmp___4;
  if (read_rv < 1L) {
    tmp___5 = __errno_location();
    global.last_errno = *tmp___5;
    return (-20);
  }
  buf___0[read_rv] = (char )'\000';
  tmp___6 = sscanf((char const   * __restrict  )(buf___0), (char const   * __restrict  )"\033[%d;%dR",
                   & rh, & rw);
  if (tmp___6 != 2) {
    return (-21);
  }
  global.width = rw;
  global.height = rh;
  return (0);
}
}
static int init_cellbuf(void) 
{ 
  int rv ;

  {
  rv = cellbuf_init(& global.back, global.width, global.height);
  if (rv != 0) {
    return (rv);
  }
  rv = cellbuf_init(& global.front, global.width, global.height);
  if (rv != 0) {
    return (rv);
  }
  rv = cellbuf_clear(& global.back);
  if (rv != 0) {
    return (rv);
  }
  rv = cellbuf_clear(& global.front);
  if (rv != 0) {
    return (rv);
  }
  return (0);
}
}
static int tb_deinit(void) 
{ 
  struct sigaction __constr_expr_0 ;

  {
  if ((unsigned long )global.caps[0] != (unsigned long )((void *)0)) {
    if (global.wfd >= 0) {
      bytebuf_puts(& global.out, global.caps[25]);
      bytebuf_puts(& global.out, global.caps[28]);
      bytebuf_puts(& global.out, global.caps[27]);
      bytebuf_puts(& global.out, global.caps[24]);
      bytebuf_puts(& global.out, global.caps[35]);
      bytebuf_puts(& global.out, "\033[?1006l\033[?1015l\033[?1002l\033[?1000l");
      bytebuf_flush(& global.out, global.wfd);
    }
  }
  if (global.ttyfd >= 0) {
    if (global.has_orig_tios) {
      tcsetattr(global.ttyfd, 2, (struct termios  const  *)(& global.orig_tios));
    }
    if (global.ttyfd_open) {
      close(global.ttyfd);
      global.ttyfd_open = 0;
    }
  }
  __constr_expr_0.__sigaction_handler.sa_handler = (void (*)(int  ))0;
  __constr_expr_0.sa_mask.__val[0] = 0UL;
  __constr_expr_0.sa_mask.__val[1] = 0UL;
  __constr_expr_0.sa_mask.__val[2] = 0UL;
  __constr_expr_0.sa_mask.__val[3] = 0UL;
  __constr_expr_0.sa_mask.__val[4] = 0UL;
  __constr_expr_0.sa_mask.__val[5] = 0UL;
  __constr_expr_0.sa_mask.__val[6] = 0UL;
  __constr_expr_0.sa_mask.__val[7] = 0UL;
  __constr_expr_0.sa_mask.__val[8] = 0UL;
  __constr_expr_0.sa_mask.__val[9] = 0UL;
  __constr_expr_0.sa_mask.__val[10] = 0UL;
  __constr_expr_0.sa_mask.__val[11] = 0UL;
  __constr_expr_0.sa_mask.__val[12] = 0UL;
  __constr_expr_0.sa_mask.__val[13] = 0UL;
  __constr_expr_0.sa_mask.__val[14] = 0UL;
  __constr_expr_0.sa_mask.__val[15] = 0UL;
  __constr_expr_0.sa_flags = 0;
  __constr_expr_0.sa_restorer = (void (*)(void))0;
  sigaction(28, (struct sigaction  const  * __restrict  )(& __constr_expr_0), (struct sigaction * __restrict  )((void *)0));
  if (global.resize_pipefd[0] >= 0) {
    close(global.resize_pipefd[0]);
  }
  if (global.resize_pipefd[1] >= 0) {
    close(global.resize_pipefd[1]);
  }
  cellbuf_free(& global.back);
  cellbuf_free(& global.front);
  bytebuf_free(& global.in);
  bytebuf_free(& global.out);
  if (global.terminfo) {
    free((void *)global.terminfo);
  }
  cap_trie_deinit(& global.cap_trie);
  tb_reset();
  return (0);
}
}
static int load_terminfo(void) 
{ 
  int rv ;
  char tmp[4096] ;
  char const   *term ;
  char *tmp___0 ;
  char const   *terminfo ;
  char *tmp___1 ;
  int tmp___2 ;
  char const   *home ;
  char *tmp___3 ;
  char const   *dirs ;
  char *tmp___4 ;
  char *dir ;
  char *tmp___5 ;
  char const   *cdir ;

  {
  tmp___0 = getenv("TERM");
  term = (char const   *)tmp___0;
  if (! term) {
    return (-1);
  }
  tmp___1 = getenv("TERMINFO");
  terminfo = (char const   *)tmp___1;
  if (terminfo) {
    tmp___2 = load_terminfo_from_path(terminfo, term);
    return (tmp___2);
  }
  tmp___3 = getenv("HOME");
  home = (char const   *)tmp___3;
  if (home) {
    while (1) {
      rv = snprintf((char * __restrict  )(tmp), sizeof(tmp), (char const   * __restrict  )"%s/.terminfo",
                    home);
      if (rv < 0) {
        return (-1);
      } else
      if (rv >= (int )sizeof(tmp)) {
        return (-1);
      }
      break;
    }
    rv = load_terminfo_from_path((char const   *)(tmp), term);
    if (rv == 0) {
      return (rv);
    }
  }
  tmp___4 = getenv("TERMINFO_DIRS");
  dirs = (char const   *)tmp___4;
  if (dirs) {
    while (1) {
      rv = snprintf((char * __restrict  )(tmp), sizeof(tmp), (char const   * __restrict  )"%s",
                    dirs);
      if (rv < 0) {
        return (-1);
      } else
      if (rv >= (int )sizeof(tmp)) {
        return (-1);
      }
      break;
    }
    tmp___5 = strtok((char * __restrict  )(tmp), (char const   * __restrict  )":");
    dir = tmp___5;
    while (dir) {
      cdir = (char const   *)dir;
      if ((int const   )*cdir != 0) {
        rv = load_terminfo_from_path(cdir, term);
        if (rv == 0) {
          return (rv);
        }
      }
      dir = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )":");
    }
  }
  rv = load_terminfo_from_path("/usr/local/etc/terminfo", term);
  if (rv == 0) {
    return (rv);
  }
  rv = load_terminfo_from_path("/usr/local/share/terminfo", term);
  if (rv == 0) {
    return (rv);
  }
  rv = load_terminfo_from_path("/usr/local/lib/terminfo", term);
  if (rv == 0) {
    return (rv);
  }
  rv = load_terminfo_from_path("/etc/terminfo", term);
  if (rv == 0) {
    return (rv);
  }
  rv = load_terminfo_from_path("/usr/share/terminfo", term);
  if (rv == 0) {
    return (rv);
  }
  rv = load_terminfo_from_path("/usr/lib/terminfo", term);
  if (rv == 0) {
    return (rv);
  }
  rv = load_terminfo_from_path("/usr/share/lib/terminfo", term);
  if (rv == 0) {
    return (rv);
  }
  rv = load_terminfo_from_path("/lib/terminfo", term);
  if (rv == 0) {
    return (rv);
  }
  return (-1);
}
}
static int load_terminfo_from_path(char const   *path , char const   *term ) 
{ 
  int rv ;
  char tmp[4096] ;

  {
  while (1) {
    rv = snprintf((char * __restrict  )(tmp), sizeof(tmp), (char const   * __restrict  )"%s/%c/%s",
                  path, (int const   )*(term + 0), term);
    if (rv < 0) {
      return (-1);
    } else
    if (rv >= (int )sizeof(tmp)) {
      return (-1);
    }
    break;
  }
  rv = read_terminfo_path((char const   *)(tmp));
  if (rv == 0) {
    return (rv);
  }
  return (-1);
}
}
static int read_terminfo_path(char const   *path ) 
{ 
  FILE *fp ;
  FILE *tmp ;
  struct stat st ;
  int tmp___0 ;
  int tmp___1 ;
  size_t fsize ;
  char *data ;
  void *tmp___2 ;
  size_t tmp___3 ;

  {
  tmp = fopen((char const   * __restrict  )path, (char const   * __restrict  )"rb");
  fp = tmp;
  if (! fp) {
    return (-1);
  }
  tmp___0 = fileno(fp);
  tmp___1 = fstat(tmp___0, & st);
  if (tmp___1 != 0) {
    fclose(fp);
    return (-1);
  }
  fsize = (size_t )st.st_size;
  tmp___2 = malloc(fsize);
  data = (char *)tmp___2;
  if (! data) {
    fclose(fp);
    return (-1);
  }
  tmp___3 = fread((void * __restrict  )data, (size_t )1, fsize, (FILE * __restrict  )fp);
  if (tmp___3 != fsize) {
    fclose(fp);
    free((void *)data);
    return (-1);
  }
  global.terminfo = data;
  global.nterminfo = fsize;
  fclose(fp);
  return (0);
}
}
static int parse_terminfo_caps(void) 
{ 
  int16_t *header ;
  int bytes_per_int ;
  int tmp ;
  int align_offset ;
  int tmp___0 ;
  int pos_str_offsets ;
  int pos_str_table ;
  int i ;
  char const   *cap ;
  char const   *tmp___1 ;

  {
  if (global.nterminfo < 6UL) {
    return (-1);
  }
  header = (int16_t *)global.terminfo;
  if ((int )*(header + 0) == 542) {
    tmp = 4;
  } else {
    tmp = 2;
  }
  bytes_per_int = tmp;
  if (((int )*(header + 1) + (int )*(header + 2)) % 2 != 0) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  align_offset = tmp___0;
  pos_str_offsets = (int )((((6UL * sizeof(int16_t ) + (unsigned long )*(header + 1)) + (unsigned long )*(header + 2)) + (unsigned long )align_offset) + (unsigned long )((int )*(header + 3) * bytes_per_int));
  pos_str_table = (int )((unsigned long )pos_str_offsets + (unsigned long )*(header + 4) * sizeof(int16_t ));
  i = 0;
  while (i < 36) {
    tmp___1 = get_terminfo_string((int16_t )pos_str_offsets, (int16_t )pos_str_table,
                                  *(header + 5), (int16_t )terminfo_cap_indexes[i]);
    cap = tmp___1;
    if (! cap) {
      return (-1);
    }
    global.caps[i] = cap;
    i ++;
  }
  return (0);
}
}
static int load_builtin_caps(void) 
{ 
  int i ;
  int j ;
  char const   *term ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  tmp = getenv("TERM");
  term = (char const   *)tmp;
  if (! term) {
    return (-7);
  }
  i = 0;
  while ((unsigned long )builtin_terms[i].name != (unsigned long )((void *)0)) {
    tmp___0 = strcmp(term, builtin_terms[i].name);
    if (tmp___0 == 0) {
      j = 0;
      while (j < 36) {
        global.caps[j] = *(builtin_terms[i].caps + j);
        j ++;
      }
      return (0);
    }
    i ++;
  }
  i = 0;
  while ((unsigned long )builtin_terms[i].name != (unsigned long )((void *)0)) {
    tmp___1 = strstr(term, builtin_terms[i].name);
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
      goto _L;
    } else
    if ((int const   )*(builtin_terms[i].alias) != 0) {
      tmp___2 = strstr(term, builtin_terms[i].alias);
      if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
        j = 0;
        while (j < 36) {
          global.caps[j] = *(builtin_terms[i].caps + j);
          j ++;
        }
        return (0);
      }
    }
    i ++;
  }
  return (-17);
}
}
static char const   *get_terminfo_string(int16_t str_offsets_pos , int16_t str_table_pos ,
                                         int16_t str_table_len , int16_t str_index ) 
{ 
  int16_t const   *str_offset ;

  {
  str_offset = (int16_t const   *)((int16_t *)((global.terminfo + (int )str_offsets_pos) + (int )str_index * (int )sizeof(int16_t )));
  if ((int const   )*str_offset >= (int const   )str_table_len) {
    return ((char const   *)((void *)0));
  }
  if ((size_t )((int )str_table_pos + (int )*str_offset) >= global.nterminfo) {
    return ((char const   *)((void *)0));
  }
  return ((char const   *)((global.terminfo + (int )str_table_pos) + (int )*str_offset));
}
}
static int wait_event(struct tb_event *event , int timeout ) 
{ 
  int rv ;
  char buf___0[64] ;
  fd_set fds ;
  struct timeval tv ;
  int __d0 ;
  int __d1 ;
  int maxfd ;
  int tmp ;
  int select_rv ;
  struct timeval *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tty_has_events ;
  int resize_has_events ;
  ssize_t read_rv ;
  ssize_t tmp___3 ;
  int *tmp___4 ;
  int ignore ;

  {
  memset((void *)event, 0, sizeof(*event));
  rv = extract_event(event);
  if (rv == 0) {
    return (rv);
  }
  tv.tv_sec = (__time_t )(timeout / 1000);
  tv.tv_usec = ((__time_t )timeout - tv.tv_sec * 1000L) * 1000L;
  while (1) {
    while (1) {
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fds.fds_bits[0]): "memory");
      break;
    }
    fds.fds_bits[global.rfd / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << global.rfd % (8 * (int )sizeof(__fd_mask )));
    fds.fds_bits[global.resize_pipefd[0] / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << global.resize_pipefd[0] % (8 * (int )sizeof(__fd_mask )));
    if (global.resize_pipefd[0] > global.rfd) {
      tmp = global.resize_pipefd[0];
    } else {
      tmp = global.rfd;
    }
    maxfd = tmp;
    if (timeout < 0) {
      tmp___0 = (struct timeval *)((void *)0);
    } else {
      tmp___0 = & tv;
    }
    tmp___1 = select(maxfd + 1, (fd_set * __restrict  )(& fds), (fd_set * __restrict  )((void *)0),
                     (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )tmp___0);
    select_rv = tmp___1;
    if (select_rv < 0) {
      tmp___2 = __errno_location();
      global.last_errno = *tmp___2;
      return (-14);
    } else
    if (select_rv == 0) {
      return (-6);
    }
    tty_has_events = (fds.fds_bits[global.rfd / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << global.rfd % (8 * (int )sizeof(__fd_mask )))) != 0L;
    resize_has_events = (fds.fds_bits[global.resize_pipefd[0] / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << global.resize_pipefd[0] % (8 * (int )sizeof(__fd_mask )))) != 0L;
    if (tty_has_events) {
      tmp___3 = read(global.rfd, (void *)(buf___0), sizeof(buf___0));
      read_rv = tmp___3;
      if (read_rv < 0L) {
        tmp___4 = __errno_location();
        global.last_errno = *tmp___4;
        return (-10);
      } else
      if (read_rv > 0L) {
        bytebuf_nputs(& global.in, (char const   *)(buf___0), (size_t )read_rv);
      }
    }
    if (resize_has_events) {
      ignore = 0;
      read(global.resize_pipefd[0], (void *)(& ignore), sizeof(ignore));
      rv = update_term_size();
      if (rv != 0) {
        return (rv);
      }
      rv = resize_cellbufs();
      if (rv != 0) {
        return (rv);
      }
      event->type = (uint8_t )2;
      event->w = global.width;
      event->h = global.height;
      return (0);
    }
    memset((void *)event, 0, sizeof(*event));
    rv = extract_event(event);
    if (rv == 0) {
      return (rv);
    }
    if (! (timeout == -1)) {
      break;
    }
  }
  return (rv);
}
}
static int extract_event(struct tb_event *event ) 
{ 
  int rv ;
  struct bytebuf_t *in ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  in = & global.in;
  if (in->len == 0UL) {
    return (-1);
  }
  if ((int )*(in->buf + 0) == 27) {
    if (global.input_mode & 1) {
      if (! (in->len == 1UL)) {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      rv = extract_esc(event);
      if (rv == 0) {
        return (rv);
      } else
      if (rv == -2) {
        return (rv);
      }
    }
    if (global.input_mode & 1) {
      event->type = (uint8_t )1;
      event->ch = (uint32_t )0;
      event->key = (uint16_t )27;
      event->mod = (uint8_t )0;
      bytebuf_shift(in, (size_t )1);
      return (0);
    }
    event->mod = (uint8_t )((int )event->mod | 1);
    bytebuf_shift(in, (size_t )1);
    tmp = extract_event(event);
    return (tmp);
  }
  if ((int )((uint16_t )*(in->buf + 0)) < 32) {
    goto _L___0;
  } else
  if ((int )*(in->buf + 0) == 127) {
    _L___0: /* CIL Label */ 
    event->type = (uint8_t )1;
    event->ch = (uint32_t )0;
    event->key = (uint16_t )*(in->buf + 0);
    event->mod = (uint8_t )((int )event->mod | 2);
    bytebuf_shift(in, (size_t )1);
    return (0);
  }
  tmp___1 = tb_utf8_char_length(*(in->buf + 0));
  if (in->len >= (size_t )tmp___1) {
    event->type = (uint8_t )1;
    tb_utf8_char_to_unicode(& event->ch, (char const   *)in->buf);
    event->key = (uint16_t )0;
    tmp___0 = tb_utf8_char_length(*(in->buf + 0));
    bytebuf_shift(in, (size_t )tmp___0);
    return (0);
  }
  return (-1);
}
}
static int extract_esc(struct tb_event *event ) 
{ 
  int rv ;

  {
  rv = extract_esc_user(event, 0);
  if (rv == 0) {
    return (rv);
  } else
  if (rv == -2) {
    return (rv);
  }
  rv = extract_esc_cap(event);
  if (rv == 0) {
    return (rv);
  } else
  if (rv == -2) {
    return (rv);
  }
  rv = extract_esc_mouse(event);
  if (rv == 0) {
    return (rv);
  } else
  if (rv == -2) {
    return (rv);
  }
  rv = extract_esc_user(event, 1);
  if (rv == 0) {
    return (rv);
  } else
  if (rv == -2) {
    return (rv);
  }
  return (-1);
}
}
static int extract_esc_user(struct tb_event *event , int is_post ) 
{ 
  int rv ;
  size_t consumed ;
  struct bytebuf_t *in ;
  int (*fn)(struct tb_event * , size_t * ) ;

  {
  consumed = (size_t )0;
  in = & global.in;
  if (is_post) {
    fn = global.fn_extract_esc_post;
  } else {
    fn = global.fn_extract_esc_pre;
  }
  if (! fn) {
    return (-1);
  }
  rv = (*fn)(event, & consumed);
  if (rv == 0) {
    bytebuf_shift(in, consumed);
  }
  rv = rv;
  if (rv == 0) {
    return (rv);
  } else
  if (rv == -2) {
    return (rv);
  }
  return (-1);
}
}
static int extract_esc_cap(struct tb_event *event ) 
{ 
  int rv ;
  struct bytebuf_t *in ;
  struct cap_trie_t *node ;
  size_t depth ;

  {
  in = & global.in;
  rv = cap_trie_find((char const   *)in->buf, in->len, & node, & depth);
  if (rv != 0) {
    return (rv);
  }
  if (node->is_leaf) {
    event->type = (uint8_t )1;
    event->ch = (uint32_t )0;
    event->key = node->key;
    event->mod = node->mod;
    bytebuf_shift(in, depth);
    return (0);
  } else
  if (node->nchildren > 0UL) {
    if (in->len <= depth) {
      return (-2);
    }
  }
  return (-1);
}
}
static int extract_esc_mouse(struct tb_event *event ) 
{ 
  struct bytebuf_t *in ;
  char *cmp[3] ;
  enum type type ;
  int ret ;
  size_t size ;
  size_t tmp ;
  int tmp___0 ;
  size_t buf_shift ;
  int b ;
  int fail ;
  size_t index_fail ;
  size_t indices[3] ;
  int m_is_capital ;
  size_t i ;
  int start ;
  int tmp___1 ;
  int n1 ;
  unsigned long tmp___2 ;
  int n2 ;
  unsigned long tmp___3 ;
  int n3 ;
  unsigned long tmp___4 ;
  int fail___0 ;

  {
  in = & global.in;
  cmp[0] = (char *)"\033[M";
  cmp[1] = (char *)"\033[<";
  cmp[2] = (char *)"\033[";
  type = (enum type )0;
  ret = -1;
  while ((unsigned int )type < 3U) {
    tmp = strlen((char const   *)cmp[type]);
    size = tmp;
    if (in->len >= size) {
      tmp___0 = strncmp((char const   *)cmp[type], (char const   *)in->buf, size);
      if (tmp___0 == 0) {
        break;
      }
    }
    type = (enum type )((unsigned int )type + 1U);
  }
  if ((unsigned int )type == 3U) {
    ret = -1;
    return (ret);
  }
  buf_shift = (size_t )0;
  switch ((unsigned int )type) {
  case 0U: 
  if (in->len >= 6UL) {
    b = (int )*(in->buf + 3) - 32;
    fail = 0;
    switch (b & 3) {
    case 0: 
    if ((b & 64) != 0) {
      event->key = (uint16_t )65508;
    } else {
      event->key = (uint16_t )65512;
    }
    break;
    case 1: 
    if ((b & 64) != 0) {
      event->key = (uint16_t )65507;
    } else {
      event->key = (uint16_t )65510;
    }
    break;
    case 2: 
    event->key = (uint16_t )65511;
    break;
    case 3: 
    event->key = (uint16_t )65509;
    break;
    default: 
    ret = -1;
    fail = 1;
    break;
    }
    if (! fail) {
      if ((b & 32) != 0) {
        event->mod = (uint8_t )((int )event->mod | 8);
      }
      event->x = (int )((uint8_t )*(in->buf + 4)) - 33;
      event->y = (int )((uint8_t )*(in->buf + 5)) - 33;
      ret = 0;
    }
    buf_shift = (size_t )6;
  }
  break;
  case 2U: 
  case 1U: 
  index_fail = (size_t )-1;
  indices[0] = index_fail;
  indices[1] = index_fail;
  indices[2] = index_fail;
  m_is_capital = 0;
  i = (size_t )0;
  while (i < in->len) {
    if ((int )*(in->buf + i) == 59) {
      if (indices[1] == index_fail) {
        indices[1] = i;
      } else {
        indices[2] = i;
      }
    } else
    if (indices[0] == index_fail) {
      if ((int )*(in->buf + i) == 109) {
        m_is_capital = (int )*(in->buf + i) == 77;
        indices[0] = i;
      } else
      if ((int )*(in->buf + i) == 77) {
        m_is_capital = (int )*(in->buf + i) == 77;
        indices[0] = i;
      }
    }
    i ++;
  }
  if (indices[0] == index_fail) {
    ret = -1;
  } else
  if (indices[1] == index_fail) {
    ret = -1;
  } else
  if (indices[2] == index_fail) {
    ret = -1;
  } else {
    if ((unsigned int )type == 2U) {
      tmp___1 = 2;
    } else {
      tmp___1 = 3;
    }
    start = tmp___1;
    tmp___2 = strtoul((char const   * __restrict  )(in->buf + start), (char ** __restrict  )((void *)0),
                      10);
    n1 = (int )tmp___2;
    tmp___3 = strtoul((char const   * __restrict  )(in->buf + (indices[1] + 1UL)),
                      (char ** __restrict  )((void *)0), 10);
    n2 = (int )tmp___3;
    tmp___4 = strtoul((char const   * __restrict  )(in->buf + (indices[2] + 1UL)),
                      (char ** __restrict  )((void *)0), 10);
    n3 = (int )tmp___4;
    if ((unsigned int )type == 2U) {
      n1 -= 32;
    }
    fail___0 = 0;
    switch (n1 & 3) {
    case 0: 
    if ((n1 & 64) != 0) {
      event->key = (uint16_t )65508;
    } else {
      event->key = (uint16_t )65512;
    }
    break;
    case 1: 
    if ((n1 & 64) != 0) {
      event->key = (uint16_t )65507;
    } else {
      event->key = (uint16_t )65510;
    }
    break;
    case 2: 
    event->key = (uint16_t )65511;
    break;
    case 3: 
    event->key = (uint16_t )65509;
    break;
    default: 
    ret = -1;
    fail___0 = 1;
    break;
    }
    buf_shift = in->len;
    if (! fail___0) {
      if (! m_is_capital) {
        event->key = (uint16_t )65509;
      }
      if ((n1 & 32) != 0) {
        event->mod = (uint8_t )((int )event->mod | 8);
      }
      event->x = (int )((uint8_t )n2) - 1;
      event->y = (int )((uint8_t )n3) - 1;
      ret = 0;
    }
  }
  break;
  case 3U: 
  ret = -1;
  }
  if (buf_shift > 0UL) {
    bytebuf_shift(in, buf_shift);
  }
  if (ret == 0) {
    event->type = (uint8_t )3;
  }
  return (ret);
}
}
static int resize_cellbufs(void) 
{ 
  int rv ;

  {
  rv = cellbuf_resize(& global.back, global.width, global.height);
  if (rv != 0) {
    return (rv);
  }
  rv = cellbuf_resize(& global.front, global.width, global.height);
  if (rv != 0) {
    return (rv);
  }
  rv = cellbuf_clear(& global.front);
  if (rv != 0) {
    return (rv);
  }
  rv = send_clear();
  if (rv != 0) {
    return (rv);
  }
  return (0);
}
}
static void handle_resize(int sig ) 
{ 
  int errno_copy ;
  int *tmp ;
  int *tmp___0 ;

  {
  tmp = __errno_location();
  errno_copy = *tmp;
  write(global.resize_pipefd[1], (void const   *)(& sig), sizeof(sig));
  tmp___0 = __errno_location();
  *tmp___0 = errno_copy;
  return;
}
}
static int send_attr(uintattr_t fg , uintattr_t bg ) 
{ 
  int rv ;
  uintattr_t cfg ;
  uintattr_t cbg ;
  uintattr_t attr_bold ;
  uintattr_t attr_blink ;
  uintattr_t attr_italic ;
  uintattr_t attr_underline ;
  uintattr_t attr_reverse ;

  {
  if ((int )fg == (int )global.last_fg) {
    if ((int )bg == (int )global.last_bg) {
      return (0);
    }
  }
  rv = bytebuf_puts(& global.out, global.caps[28]);
  if (rv != 0) {
    return (rv);
  }
  switch (global.output_mode) {
  default: 
  cfg = (uintattr_t )((int )fg & 15);
  cbg = (uintattr_t )((int )bg & 15);
  break;
  case 2: 
  cfg = (uintattr_t )((int )fg & 255);
  cbg = (uintattr_t )((int )bg & 255);
  break;
  case 3: 
  cfg = (uintattr_t )((int )fg & 255);
  if ((int )cfg > 215) {
    cfg = (uintattr_t )7;
  }
  cbg = (uintattr_t )((int )bg & 255);
  if ((int )cbg > 215) {
    cbg = (uintattr_t )0;
  }
  cfg = (uintattr_t )((int )cfg + 16);
  cbg = (uintattr_t )((int )cbg + 16);
  break;
  case 4: 
  cfg = (uintattr_t )((int )fg & 255);
  if ((int )cfg > 23) {
    cfg = (uintattr_t )23;
  }
  cbg = (uintattr_t )((int )bg & 255);
  if ((int )cbg > 23) {
    cbg = (uintattr_t )0;
  }
  cfg = (uintattr_t )((int )cfg + 232);
  cbg = (uintattr_t )((int )cbg + 232);
  break;
  }
  attr_bold = (uintattr_t )256;
  attr_blink = (uintattr_t )4096;
  attr_italic = (uintattr_t )2048;
  attr_underline = (uintattr_t )512;
  attr_reverse = (uintattr_t )1024;
  if ((int )fg & (int )attr_bold) {
    rv = bytebuf_puts(& global.out, global.caps[30]);
    if (rv != 0) {
      return (rv);
    }
  }
  if ((int )fg & (int )attr_blink) {
    rv = bytebuf_puts(& global.out, global.caps[31]);
    if (rv != 0) {
      return (rv);
    }
  }
  if ((int )fg & (int )attr_underline) {
    rv = bytebuf_puts(& global.out, global.caps[29]);
    if (rv != 0) {
      return (rv);
    }
  }
  if ((int )fg & (int )attr_italic) {
    rv = bytebuf_puts(& global.out, global.caps[32]);
    if (rv != 0) {
      return (rv);
    }
  }
  if ((int )fg & (int )attr_reverse) {
    goto _L;
  } else
  if ((int )bg & (int )attr_reverse) {
    _L: /* CIL Label */ 
    rv = bytebuf_puts(& global.out, global.caps[33]);
    if (rv != 0) {
      return (rv);
    }
  }
  rv = send_sgr(cfg, cbg);
  if (rv != 0) {
    return (rv);
  }
  global.last_fg = fg;
  global.last_bg = bg;
  return (0);
}
}
static int send_sgr(uintattr_t fg , uintattr_t bg ) 
{ 
  int rv ;
  char nbuf[32] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if ((int )fg == 0) {
    if ((int )bg == 0) {
      return (0);
    }
  }
  switch (global.output_mode) {
  default: 
  rv = bytebuf_nputs(& global.out, "\033[", sizeof("\033[") - 1UL);
  if (rv != 0) {
    return (rv);
  }
  if ((int )fg != 0) {
    rv = bytebuf_nputs(& global.out, "3", sizeof("3") - 1UL);
    if (rv != 0) {
      return (rv);
    }
    tmp = convert_num((uint32_t )((int )fg - 1), nbuf);
    rv = bytebuf_nputs(& global.out, (char const   *)(nbuf), (size_t )tmp);
    if (rv != 0) {
      return (rv);
    }
    if ((int )bg != 0) {
      rv = bytebuf_nputs(& global.out, ";", sizeof(";") - 1UL);
      if (rv != 0) {
        return (rv);
      }
    }
  }
  if ((int )bg != 0) {
    rv = bytebuf_nputs(& global.out, "4", sizeof("4") - 1UL);
    if (rv != 0) {
      return (rv);
    }
    tmp___0 = convert_num((uint32_t )((int )bg - 1), nbuf);
    rv = bytebuf_nputs(& global.out, (char const   *)(nbuf), (size_t )tmp___0);
    if (rv != 0) {
      return (rv);
    }
  }
  rv = bytebuf_nputs(& global.out, "m", sizeof("m") - 1UL);
  if (rv != 0) {
    return (rv);
  }
  break;
  case 4: 
  case 3: 
  case 2: 
  rv = bytebuf_nputs(& global.out, "\033[", sizeof("\033[") - 1UL);
  if (rv != 0) {
    return (rv);
  }
  if ((int )fg != 0) {
    rv = bytebuf_nputs(& global.out, "38;5;", sizeof("38;5;") - 1UL);
    if (rv != 0) {
      return (rv);
    }
    tmp___1 = convert_num((uint32_t )fg, nbuf);
    rv = bytebuf_nputs(& global.out, (char const   *)(nbuf), (size_t )tmp___1);
    if (rv != 0) {
      return (rv);
    }
    if ((int )bg != 0) {
      rv = bytebuf_nputs(& global.out, ";", sizeof(";") - 1UL);
      if (rv != 0) {
        return (rv);
      }
    }
  }
  if ((int )bg != 0) {
    rv = bytebuf_nputs(& global.out, "48;5;", sizeof("48;5;") - 1UL);
    if (rv != 0) {
      return (rv);
    }
    tmp___2 = convert_num((uint32_t )bg, nbuf);
    rv = bytebuf_nputs(& global.out, (char const   *)(nbuf), (size_t )tmp___2);
    if (rv != 0) {
      return (rv);
    }
  }
  rv = bytebuf_nputs(& global.out, "m", sizeof("m") - 1UL);
  if (rv != 0) {
    return (rv);
  }
  break;
  }
  return (0);
}
}
static int send_cursor_if(int x , int y ) 
{ 
  int rv ;
  char nbuf[32] ;
  int tmp ;
  int tmp___0 ;

  {
  if (x < 0) {
    return (0);
  } else
  if (y < 0) {
    return (0);
  }
  rv = bytebuf_nputs(& global.out, "\033[", sizeof("\033[") - 1UL);
  if (rv != 0) {
    return (rv);
  }
  tmp = convert_num((uint32_t )(y + 1), nbuf);
  rv = bytebuf_nputs(& global.out, (char const   *)(nbuf), (size_t )tmp);
  if (rv != 0) {
    return (rv);
  }
  rv = bytebuf_nputs(& global.out, ";", sizeof(";") - 1UL);
  if (rv != 0) {
    return (rv);
  }
  tmp___0 = convert_num((uint32_t )(x + 1), nbuf);
  rv = bytebuf_nputs(& global.out, (char const   *)(nbuf), (size_t )tmp___0);
  if (rv != 0) {
    return (rv);
  }
  rv = bytebuf_nputs(& global.out, "H", sizeof("H") - 1UL);
  if (rv != 0) {
    return (rv);
  }
  return (0);
}
}
static int send_char(int x , int y , uint32_t ch ) 
{ 
  int tmp ;

  {
  tmp = send_cluster(x, y, & ch, (size_t )1);
  return (tmp);
}
}
static int send_cluster(int x , int y , uint32_t *ch , size_t nch ) 
{ 
  int rv ;
  char abuf[8] ;
  int i ;
  uint32_t ach ;
  int aw ;
  int tmp ;

  {
  if (global.last_x != x - 1) {
    goto _L;
  } else
  if (global.last_y != y) {
    _L: /* CIL Label */ 
    rv = send_cursor_if(x, y);
    if (rv != 0) {
      return (rv);
    }
  }
  global.last_x = x;
  global.last_y = y;
  i = 0;
  while (i < (int )nch) {
    ach = *(ch + i);
    tmp = tb_utf8_unicode_to_char(abuf, ach);
    aw = tmp;
    if (! ach) {
      abuf[0] = (char )' ';
    }
    rv = bytebuf_nputs(& global.out, (char const   *)(abuf), (size_t )aw);
    if (rv != 0) {
      return (rv);
    }
    i ++;
  }
  return (0);
}
}
static int convert_num(uint32_t num , char *buf___0 ) 
{ 
  int i ;
  int l ;
  int ch ;
  int tmp ;

  {
  l = 0;
  while (1) {
    tmp = l;
    l ++;
    *(buf___0 + tmp) = (char )(48U + num % 10U);
    num /= 10U;
    if (! num) {
      break;
    }
  }
  i = 0;
  while (i < l / 2) {
    ch = (int )*(buf___0 + i);
    *(buf___0 + i) = *(buf___0 + ((l - 1) - i));
    *(buf___0 + ((l - 1) - i)) = (char )ch;
    i ++;
  }
  return (l);
}
}
static int cell_cmp(struct tb_cell *a , struct tb_cell *b ) 
{ 


  {
  if (a->ch != b->ch) {
    return (1);
  } else
  if ((int )a->fg != (int )b->fg) {
    return (1);
  } else
  if ((int )a->bg != (int )b->bg) {
    return (1);
  }
  return (0);
}
}
static int cell_copy(struct tb_cell *dst , struct tb_cell *src ) 
{ 
  int tmp ;

  {
  tmp = cell_set(dst, & src->ch, (size_t )1, src->fg, src->bg);
  return (tmp);
}
}
static int cell_set(struct tb_cell *cell , uint32_t *ch , size_t nch , uintattr_t fg ,
                    uintattr_t bg ) 
{ 


  {
  if (ch) {
    cell->ch = *ch;
  } else {
    cell->ch = (uint32_t )0;
  }
  cell->fg = fg;
  cell->bg = bg;
  return (0);
}
}
static int cell_free(struct tb_cell *cell ) 
{ 


  {
  memset((void *)cell, 0, sizeof(*cell));
  return (0);
}
}
static int cellbuf_init(struct cellbuf_t *c , int w , int h ) 
{ 
  void *tmp ;

  {
  tmp = malloc((sizeof(struct tb_cell ) * (unsigned long )w) * (unsigned long )h);
  c->cells = (struct tb_cell *)tmp;
  if (! c->cells) {
    return (-5);
  }
  memset((void *)c->cells, 0, (sizeof(struct tb_cell ) * (unsigned long )w) * (unsigned long )h);
  c->width = w;
  c->height = h;
  return (0);
}
}
static int cellbuf_free(struct cellbuf_t *c ) 
{ 
  int i ;

  {
  if (c->cells) {
    i = 0;
    while (i < c->width * c->height) {
      cell_free(c->cells + i);
      i ++;
    }
    free((void *)c->cells);
  }
  memset((void *)c, 0, sizeof(*c));
  return (0);
}
}
static int cellbuf_clear(struct cellbuf_t *c ) 
{ 
  int rv ;
  int i ;
  uint32_t space ;

  {
  space = (uint32_t )' ';
  i = 0;
  while (i < c->width * c->height) {
    rv = cell_set(c->cells + i, & space, (size_t )1, global.fg, global.bg);
    if (rv != 0) {
      return (rv);
    }
    i ++;
  }
  return (0);
}
}
static int cellbuf_get(struct cellbuf_t *c , int x , int y , struct tb_cell **out ) 
{ 


  {
  if (x < 0) {
    *out = (struct tb_cell *)((void *)0);
    return (-9);
  } else
  if (x >= c->width) {
    *out = (struct tb_cell *)((void *)0);
    return (-9);
  } else
  if (y < 0) {
    *out = (struct tb_cell *)((void *)0);
    return (-9);
  } else
  if (y >= c->height) {
    *out = (struct tb_cell *)((void *)0);
    return (-9);
  }
  *out = c->cells + (y * c->width + x);
  return (0);
}
}
static int cellbuf_resize(struct cellbuf_t *c , int w , int h ) 
{ 
  int rv ;
  int ow ;
  int oh ;
  int minw ;
  int tmp ;
  int minh ;
  int tmp___0 ;
  struct tb_cell *prev ;
  int x ;
  int y ;
  struct tb_cell *src ;
  struct tb_cell *dst ;

  {
  ow = c->width;
  oh = c->height;
  if (ow == w) {
    if (oh == h) {
      return (0);
    }
  }
  if (w < 1) {
    w = 1;
  } else {
    w = w;
  }
  if (h < 1) {
    h = 1;
  } else {
    h = h;
  }
  if (w < ow) {
    tmp = w;
  } else {
    tmp = ow;
  }
  minw = tmp;
  if (h < oh) {
    tmp___0 = h;
  } else {
    tmp___0 = oh;
  }
  minh = tmp___0;
  prev = c->cells;
  rv = cellbuf_init(c, w, h);
  if (rv != 0) {
    return (rv);
  }
  rv = cellbuf_clear(c);
  if (rv != 0) {
    return (rv);
  }
  x = 0;
  while (x < minw) {
    y = 0;
    while (y < minh) {
      src = prev + (y * ow + x);
      rv = cellbuf_get(c, x, y, & dst);
      if (rv != 0) {
        return (rv);
      }
      rv = cell_copy(dst, src);
      if (rv != 0) {
        return (rv);
      }
      y ++;
    }
    x ++;
  }
  free((void *)prev);
  return (0);
}
}
static int bytebuf_puts(struct bytebuf_t *b , char const   *str ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  tmp = strlen(str);
  tmp___0 = bytebuf_nputs(b, str, tmp);
  return (tmp___0);
}
}
static int bytebuf_nputs(struct bytebuf_t *b , char const   *str , size_t nstr ) 
{ 
  int rv ;

  {
  rv = bytebuf_reserve(b, (b->len + nstr) + 1UL);
  if (rv != 0) {
    return (rv);
  }
  memcpy((void * __restrict  )(b->buf + b->len), (void const   * __restrict  )str,
         nstr);
  b->len += nstr;
  *(b->buf + b->len) = (char )'\000';
  return (0);
}
}
static int bytebuf_shift(struct bytebuf_t *b , size_t n ) 
{ 
  size_t nmove ;

  {
  if (n > b->len) {
    n = b->len;
  }
  nmove = b->len - n;
  memmove((void *)b->buf, (void const   *)(b->buf + n), nmove);
  b->len -= n;
  return (0);
}
}
static int bytebuf_flush(struct bytebuf_t *b , int fd ) 
{ 
  ssize_t write_rv ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
  if (b->len <= 0UL) {
    return (0);
  }
  tmp = write(fd, (void const   *)b->buf, b->len);
  write_rv = tmp;
  if (write_rv < 0L) {
    tmp___0 = __errno_location();
    global.last_errno = *tmp___0;
    return (-1);
  } else
  if ((size_t )write_rv != b->len) {
    tmp___0 = __errno_location();
    global.last_errno = *tmp___0;
    return (-1);
  }
  b->len = (size_t )0;
  return (0);
}
}
static int bytebuf_reserve(struct bytebuf_t *b , size_t sz ) 
{ 
  size_t newcap ;
  size_t tmp ;
  char *newbuf ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  if (b->cap >= sz) {
    return (0);
  }
  if (b->cap > 0UL) {
    tmp = b->cap;
  } else {
    tmp = (size_t )1;
  }
  newcap = tmp;
  while (newcap < sz) {
    newcap *= 2UL;
  }
  if (b->buf) {
    tmp___0 = realloc((void *)b->buf, newcap);
    newbuf = (char *)tmp___0;
  } else {
    tmp___1 = malloc(newcap);
    newbuf = (char *)tmp___1;
  }
  if (! newbuf) {
    return (-5);
  }
  b->buf = newbuf;
  b->cap = newcap;
  return (0);
}
}
static int bytebuf_free(struct bytebuf_t *b ) 
{ 


  {
  if (b->buf) {
    free((void *)b->buf);
  }
  memset((void *)b, 0, sizeof(*b));
  return (0);
}
}
pid_t opt_pid  =    -1;
char *opt_pgrep_args  =    (char *)((void *)0);
int opt_num_workers  =    16;
int opt_top_mode  =    0;
long opt_sleep_ns  =    10101010L;
uint64_t opt_executor_globals_addr  =    (uint64_t )0;
uint64_t opt_sapi_globals_addr  =    (uint64_t )0;
int opt_capture_req  =    0;
int opt_capture_req_qstring  =    0;
int opt_capture_req_cookie  =    0;
int opt_capture_req_uri  =    0;
int opt_capture_req_path  =    0;
int opt_capture_mem  =    0;
int opt_max_stack_depth  =    -1;
char opt_frame_delim  =    (char )'\n';
char opt_trace_delim  =    (char )'\n';
uint64_t opt_trace_limit  =    (uint64_t )0;
long opt_time_limit_ms  =    0L;
char *opt_path_output  =    (char *)"-";
char *opt_path_child_out  =    (char *)"phpspy.%d.out";
char *opt_path_child_err  =    (char *)"phpspy.%d.err";
char *opt_phpv  =    (char *)"auto";
int opt_pause  =    0;
regex_t *opt_filter_re  =    (regex_t *)((void *)0);
int opt_filter_negate  =    0;
int opt_verbose_fields_pid  =    0;
int opt_verbose_fields_ts  =    0;
int (*opt_event_handler)(struct trace_context_s *context , int event_type )  =    & event_handler_fout;
int opt_continue_on_error  =    0;
int opt_fout_buffer_size  =    4096;
int done  =    0;
int (*do_trace_ptr)(trace_context_t *context )  =    (int (*)(trace_context_t *context ))((void *)0);
varpeek_entry_t *varpeek_map  =    (varpeek_entry_t *)((void *)0);
glopeek_entry_t *glopeek_map  =    (glopeek_entry_t *)((void *)0);
regex_t filter_re  ;
int log_error_enabled  =    1;
int in_pgrep_mode  =    0;
uint64_t trace_count  =    (uint64_t )0;
static void parse_opts(int argc , char **argv ) ;
static int main_fork(int argc , char **argv ) ;
static void cleanup(void) ;
static int pause_pid(pid_t pid ) ;
static int unpause_pid(pid_t pid ) ;
static void redirect_child_stdio(int proc_fd , char *opt_path ) ;
static int find_addresses(trace_target_t *target ) ;
static void clock_get(struct timespec *ts ) ;
static void clock_add(struct timespec *a , struct timespec *b , struct timespec *res ) ;
static int clock_diff(struct timespec *a , struct timespec *b ) ;
static void calc_sleep_time(struct timespec *end , struct timespec *start , struct timespec *sleep___0 ) ;
static void varpeek_add(char *varspec ) ;
static void glopeek_add(char *glospec ) ;
static int copy_proc_mem(pid_t pid , char const   *what , void *raddr , void *laddr ,
                         size_t size ) ;
static int get_php_version(trace_target_t *target ) ;
static int do_trace_70(trace_context_t *context ) ;
static int do_trace_71(trace_context_t *context ) ;
static int do_trace_72(trace_context_t *context ) ;
static int do_trace_73(trace_context_t *context ) ;
static int do_trace_74(trace_context_t *context ) ;
static int do_trace_80(trace_context_t *context ) ;
static int do_trace_81(trace_context_t *context ) ;
int main(int argc , char **argv ) 
{ 
  int rv ;

  {
  parse_opts(argc, argv);
  if (opt_top_mode != 0) {
    rv = main_top(argc, argv);
  } else
  if (opt_pid != -1) {
    rv = main_pid(opt_pid);
  } else
  if ((unsigned long )opt_pgrep_args != (unsigned long )((void *)0)) {
    in_pgrep_mode = 1;
    rv = main_pgrep();
  } else
  if (optind < argc) {
    rv = main_fork(argc, argv);
  } else {
    log_error("Expected pid (-p), pgrep (-P), or command\n\n");
    usage(stderr, 1);
    rv = 1;
  }
  cleanup();
  return (rv);
}
}
void usage(FILE *fp , int exit_code ) 
{ 


  {
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"Usage:\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  phpspy [options] -p <pid>\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  phpspy [options] -P <pgrep-args>\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  phpspy [options] [--] <cmd>\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"Options:\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  -h, --help                         Show this help\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  -p, --pid=<pid>                    Trace PHP process at `pid`\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  -P, --pgrep=<args>                 Concurrently trace processes that\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       match pgrep `args` (see also `-T`)\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  -T, --threads=<num>                Set number of threads to use with `-P`\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       (default: %d)\n",
          opt_num_workers);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  -s, --sleep-ns=<ns>                Sleep `ns` nanoseconds between traces\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       (see also `-H`) (default: %ld)\n",
          opt_sleep_ns);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  -H, --rate-hz=<hz>                 Trace `hz` times per second\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       (see also `-s`) (default: %lu)\n",
          1000000000UL / (unsigned long )opt_sleep_ns);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  -V, --php-version=<ver>            Set PHP version\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       (default: %s;\n",
          opt_phpv);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       supported: 70 71 72 73 74 80 81 82)\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  -l, --limit=<num>                  Limit total number of traces to capture\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       (approximate limit in pgrep mode)\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       (default: %lu; 0=unlimited)\n",
          opt_trace_limit);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  -i, --time-limit-ms=<ms>           Stop tracing after `ms` milliseconds\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       (second granularity in pgrep mode)\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       (default: %lu; 0=unlimited)\n",
          opt_time_limit_ms);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  -n, --max-depth=<max>              Set max stack trace depth\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       (default: %d; -1=unlimited)\n",
          opt_max_stack_depth);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  -r, --request-info=<opts>          Set request info parts to capture\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       (q=query c=cookie u=uri p=path\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       capital=negation)\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       (default: QCUP; none)\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  -m, --memory-usage                 Capture peak and current memory usage\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       with each trace (requires target PHP\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       process to have debug symbols)\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  -o, --output=<path>                Write phpspy output to `path`\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       (default: %s; -=stdout)\n",
          opt_path_output);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  -O, --child-stdout=<path>          Write child stdout to `path`\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       (default: %s)\n",
          opt_path_child_out);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  -E, --child-stderr=<path>          Write child stderr to `path`\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       (default: %s)\n",
          opt_path_child_err);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  -x, --addr-executor-globals=<hex>  Set address of executor_globals in hex\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       (default: %lu; 0=find dynamically)\n",
          opt_sapi_globals_addr);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  -a, --addr-sapi-globals=<hex>      Set address of sapi_globals in hex\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       (default: %lu; 0=find dynamically)\n",
          opt_executor_globals_addr);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  -1, --single-line                  Output in single-line mode\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  -b, --buffer-size=<size>           Set output buffer size to `size`.\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       Note: In `-P` mode, setting this\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       above PIPE_BUF (4096) may lead to\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       interlaced writes across threads.\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       (default: %d)\n",
          opt_fout_buffer_size);
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  -f, --filter=<regex>               Filter output by POSIX regex\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       (default: none)\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  -F, --filter-negate=<regex>        Same as `-f` except negated\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  -d, --verbose-fields=<opts>        Set verbose output fields\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       (p=pid t=timestamp\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       capital=negation)\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       (default: PT; none)\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  -c, --continue-on-error            Attempt to continue tracing after\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       encountering an error\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  -#, --comment=<any>                Ignored; intended for self-documenting\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       commands\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  -@, --nothing                      Ignored\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  -v, --version                      Print phpspy version and exit\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"Experimental options:\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  -j, --event-handler=<handler>      Set event handler (fout, callgrind)\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       (default: fout)\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  -S, --pause-process                Pause process while reading stacktrace\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       (unsafe for production!)\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  -e, --peek-var=<varspec>           Peek at the contents of the var located\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       at `varspec`, which has the format:\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       <varname>@<path>:<lineno>\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       <varname>@<path>:<start>-<end>\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       e.g., xyz@/path/to.php:10-20\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  -g, --peek-global=<glospec>        Peek at the contents of a global var\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       located at `glospec`, which has\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       the format: <global>.<key>\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       where <global> is one of:\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       post|get|cookie|server|files|globals\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"                                       e.g., server.REQUEST_TIME\n");
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  -t, --top                          Show dynamic top-like output\n");
  cleanup();
  exit(exit_code);
}
}
static long strtol_with_min_or_exit(char const   *name , char const   *str , int min ) 
{ 
  long result ;
  char *end ;
  int *tmp ;

  {
  tmp = __errno_location();
  *tmp = 0;
  result = strtol((char const   * __restrict  )str, (char ** __restrict  )(& end),
                  10);
  if ((unsigned long )end <= (unsigned long )str) {
    log_error("Expected integer for %s, got \'%s\'\n", name, str);
    usage(stderr, 1);
  } else
  if ((int )*end != 0) {
    log_error("Expected integer for %s, got \'%s\'\n", name, str);
    usage(stderr, 1);
  }
  if (result < (long )min) {
    log_error("Expected integer >= %d for %s, got \'%s\'\n", min, name, str);
    usage(stderr, 1);
  }
  return (result);
}
}
static int atoi_with_min_or_exit(char const   *name , char const   *str , int min ) 
{ 
  long result ;
  long tmp ;

  {
  tmp = strtol_with_min_or_exit(name, str, min);
  result = tmp;
  if (result > 2147483647L) {
    log_error("Expected value that could fit in a C int for %s, got \'%s\'\n", name,
              str);
    usage(stderr, 1);
  }
  return ((int )result);
}
}
static void parse_opts(int argc , char **argv ) 
{ 
  int c ;
  size_t i ;
  struct option long_opts[32] ;
  long tmp ;
  unsigned long long tmp___0 ;
  size_t tmp___1 ;
  unsigned long long tmp___2 ;
  unsigned long long tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  long_opts[0].name = "help";
  long_opts[0].has_arg = 0;
  long_opts[0].flag = (int *)((void *)0);
  long_opts[0].val = 'h';
  long_opts[1].name = "pid";
  long_opts[1].has_arg = 1;
  long_opts[1].flag = (int *)((void *)0);
  long_opts[1].val = 'p';
  long_opts[2].name = "pgrep";
  long_opts[2].has_arg = 1;
  long_opts[2].flag = (int *)((void *)0);
  long_opts[2].val = 'P';
  long_opts[3].name = "threads";
  long_opts[3].has_arg = 1;
  long_opts[3].flag = (int *)((void *)0);
  long_opts[3].val = 'T';
  long_opts[4].name = "sleep-ns";
  long_opts[4].has_arg = 1;
  long_opts[4].flag = (int *)((void *)0);
  long_opts[4].val = 's';
  long_opts[5].name = "rate-hz";
  long_opts[5].has_arg = 1;
  long_opts[5].flag = (int *)((void *)0);
  long_opts[5].val = 'H';
  long_opts[6].name = "php-version";
  long_opts[6].has_arg = 1;
  long_opts[6].flag = (int *)((void *)0);
  long_opts[6].val = 'V';
  long_opts[7].name = "limit";
  long_opts[7].has_arg = 1;
  long_opts[7].flag = (int *)((void *)0);
  long_opts[7].val = 'l';
  long_opts[8].name = "time-limit-ms";
  long_opts[8].has_arg = 1;
  long_opts[8].flag = (int *)((void *)0);
  long_opts[8].val = 'i';
  long_opts[9].name = "max-depth";
  long_opts[9].has_arg = 1;
  long_opts[9].flag = (int *)((void *)0);
  long_opts[9].val = 'n';
  long_opts[10].name = "request-info";
  long_opts[10].has_arg = 1;
  long_opts[10].flag = (int *)((void *)0);
  long_opts[10].val = 'r';
  long_opts[11].name = "memory-usage";
  long_opts[11].has_arg = 0;
  long_opts[11].flag = (int *)((void *)0);
  long_opts[11].val = 'm';
  long_opts[12].name = "output";
  long_opts[12].has_arg = 1;
  long_opts[12].flag = (int *)((void *)0);
  long_opts[12].val = 'o';
  long_opts[13].name = "child-stdout";
  long_opts[13].has_arg = 1;
  long_opts[13].flag = (int *)((void *)0);
  long_opts[13].val = 'O';
  long_opts[14].name = "child-stderr";
  long_opts[14].has_arg = 1;
  long_opts[14].flag = (int *)((void *)0);
  long_opts[14].val = 'E';
  long_opts[15].name = "addr-executor-globals";
  long_opts[15].has_arg = 1;
  long_opts[15].flag = (int *)((void *)0);
  long_opts[15].val = 'x';
  long_opts[16].name = "addr-sapi-globals";
  long_opts[16].has_arg = 1;
  long_opts[16].flag = (int *)((void *)0);
  long_opts[16].val = 'a';
  long_opts[17].name = "single-line";
  long_opts[17].has_arg = 0;
  long_opts[17].flag = (int *)((void *)0);
  long_opts[17].val = '1';
  long_opts[18].name = "buffer-size";
  long_opts[18].has_arg = 1;
  long_opts[18].flag = (int *)((void *)0);
  long_opts[18].val = 'b';
  long_opts[19].name = "filter";
  long_opts[19].has_arg = 1;
  long_opts[19].flag = (int *)((void *)0);
  long_opts[19].val = 'f';
  long_opts[20].name = "filter-negate";
  long_opts[20].has_arg = 1;
  long_opts[20].flag = (int *)((void *)0);
  long_opts[20].val = 'F';
  long_opts[21].name = "verbose-fields";
  long_opts[21].has_arg = 1;
  long_opts[21].flag = (int *)((void *)0);
  long_opts[21].val = 'd';
  long_opts[22].name = "continue-on-error";
  long_opts[22].has_arg = 0;
  long_opts[22].flag = (int *)((void *)0);
  long_opts[22].val = 'c';
  long_opts[23].name = "event-handler";
  long_opts[23].has_arg = 1;
  long_opts[23].flag = (int *)((void *)0);
  long_opts[23].val = 'j';
  long_opts[24].name = "comment";
  long_opts[24].has_arg = 1;
  long_opts[24].flag = (int *)((void *)0);
  long_opts[24].val = '#';
  long_opts[25].name = "nothing";
  long_opts[25].has_arg = 0;
  long_opts[25].flag = (int *)((void *)0);
  long_opts[25].val = '@';
  long_opts[26].name = "version";
  long_opts[26].has_arg = 0;
  long_opts[26].flag = (int *)((void *)0);
  long_opts[26].val = 'v';
  long_opts[27].name = "pause-process";
  long_opts[27].has_arg = 0;
  long_opts[27].flag = (int *)((void *)0);
  long_opts[27].val = 'S';
  long_opts[28].name = "peek-var";
  long_opts[28].has_arg = 1;
  long_opts[28].flag = (int *)((void *)0);
  long_opts[28].val = 'e';
  long_opts[29].name = "peek-global";
  long_opts[29].has_arg = 1;
  long_opts[29].flag = (int *)((void *)0);
  long_opts[29].val = 'g';
  long_opts[30].name = "top";
  long_opts[30].has_arg = 0;
  long_opts[30].flag = (int *)((void *)0);
  long_opts[30].val = 't';
  long_opts[31].name = (char const   *)0;
  long_opts[31].has_arg = 0;
  long_opts[31].flag = (int *)0;
  long_opts[31].val = 0;
  optind = 1;
  while (1) {
    if (optind < argc) {
      if ((int )*(*(argv + optind) + 0) == 45) {
        c = getopt_long(argc, (char * const  *)argv, "hp:P:T:te:s:H:V:l:i:n:r:mo:O:E:x:a:1b:f:F:d:cj:#:@vSe:g:t",
                        (struct option  const  *)(long_opts), (int *)((void *)0));
        if (! (c != -1)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    switch (c) {
    case 104: 
    usage(stdout, 0);
    break;
    case 112: 
    opt_pid = atoi_with_min_or_exit("-p", (char const   *)optarg, 1);
    break;
    case 80: 
    opt_pgrep_args = optarg;
    break;
    case 84: 
    opt_num_workers = atoi_with_min_or_exit("-T", (char const   *)optarg, 1);
    break;
    case 115: 
    opt_sleep_ns = strtol_with_min_or_exit("-s", (char const   *)optarg, 1);
    break;
    case 72: 
    tmp = strtol_with_min_or_exit("-H", (char const   *)optarg, 1);
    opt_sleep_ns = (long )(1000000000UL / (unsigned long )tmp);
    break;
    case 86: 
    opt_phpv = optarg;
    break;
    case 108: 
    tmp___0 = strtoull((char const   * __restrict  )optarg, (char ** __restrict  )((void *)0),
                       10);
    opt_trace_limit = (uint64_t )tmp___0;
    break;
    case 105: 
    opt_time_limit_ms = strtol_with_min_or_exit("-i", (char const   *)optarg, 0);
    break;
    case 110: 
    opt_max_stack_depth = atoi_with_min_or_exit("-n", (char const   *)optarg, -1);
    break;
    case 114: 
    i = (size_t )0;
    while (1) {
      tmp___1 = strlen((char const   *)optarg);
      if (! (i < tmp___1)) {
        break;
      }
      switch ((int )*(optarg + i)) {
      case 113: 
      opt_capture_req_qstring = 1;
      break;
      case 99: 
      opt_capture_req_cookie = 1;
      break;
      case 117: 
      opt_capture_req_uri = 1;
      break;
      case 112: 
      opt_capture_req_path = 1;
      break;
      case 81: 
      opt_capture_req_qstring = 0;
      break;
      case 67: 
      opt_capture_req_cookie = 0;
      break;
      case 85: 
      opt_capture_req_uri = 0;
      break;
      case 80: 
      opt_capture_req_path = 0;
      break;
      }
      i ++;
    }
    opt_capture_req = ((opt_capture_req_qstring | opt_capture_req_cookie) | opt_capture_req_uri) | opt_capture_req_path;
    break;
    case 109: 
    opt_capture_mem = 1;
    break;
    case 111: 
    opt_path_output = optarg;
    break;
    case 79: 
    opt_path_child_out = optarg;
    break;
    case 69: 
    opt_path_child_err = optarg;
    break;
    case 120: 
    tmp___2 = strtoull((char const   * __restrict  )optarg, (char ** __restrict  )((void *)0),
                       16);
    opt_executor_globals_addr = (uint64_t )tmp___2;
    break;
    case 97: 
    tmp___3 = strtoull((char const   * __restrict  )optarg, (char ** __restrict  )((void *)0),
                       16);
    opt_sapi_globals_addr = (uint64_t )tmp___3;
    break;
    case 49: 
    opt_frame_delim = (char )'\t';
    opt_trace_delim = (char )'\n';
    break;
    case 98: 
    opt_fout_buffer_size = atoi_with_min_or_exit("-b", (char const   *)optarg, 1);
    break;
    case 70: 
    case 102: 
    if (opt_filter_re) {
      regfree(opt_filter_re);
    }
    tmp___4 = regcomp((regex_t * __restrict  )(& filter_re), (char const   * __restrict  )optarg,
                      (1 | (1 << 3)) | (1 << 2));
    if (tmp___4 == 0) {
      opt_filter_re = & filter_re;
    } else {
      log_error("parse_opts: Failed to compile filter regex\n\n");
      usage(stderr, 1);
    }
    if (c == 70) {
      opt_filter_negate = 1;
    } else {
      opt_filter_negate = 0;
    }
    break;
    case 100: 
    i = (size_t )0;
    while (1) {
      tmp___5 = strlen((char const   *)optarg);
      if (! (i < tmp___5)) {
        break;
      }
      switch ((int )*(optarg + i)) {
      case 112: 
      opt_verbose_fields_pid = 1;
      break;
      case 116: 
      opt_verbose_fields_ts = 1;
      break;
      case 80: 
      opt_verbose_fields_pid = 0;
      break;
      case 84: 
      opt_verbose_fields_ts = 0;
      break;
      }
      i ++;
    }
    break;
    case 99: 
    opt_continue_on_error = 1;
    break;
    case 106: 
    tmp___7 = strcmp((char const   *)optarg, "fout");
    if (tmp___7 == 0) {
      opt_event_handler = & event_handler_fout;
    } else {
      tmp___6 = strcmp((char const   *)optarg, "callgrind");
      if (tmp___6 == 0) {
        opt_event_handler = & event_handler_callgrind;
      } else {
        log_error("parse_opts: Expected \'fout\' or \'callgrind\' for `--event-handler`\n\n");
        usage(stderr, 1);
      }
    }
    break;
    case 35: 
    break;
    case 64: 
    break;
    case 118: 
    printf((char const   * __restrict  )"phpspy v%s USE_ZEND=%s COMMIT=%s\n", "0.6.0",
           "n", "-");
    exit(0);
    case 83: 
    opt_pause = 1;
    break;
    case 101: 
    varpeek_add(optarg);
    break;
    case 103: 
    glopeek_add(optarg);
    break;
    case 116: 
    opt_top_mode = 1;
    break;
    }
  }
  return;
}
}
int main_pid(pid_t pid ) 
{ 
  int rv ;
  trace_context_t context ;
  struct timespec start_time ;
  struct timespec end_time ;
  struct timespec sleep_time ;
  struct timespec _stop_time ;
  struct timespec limit_time ;
  struct timespec *stop_time ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  memset((void *)(& context), 0, sizeof(trace_context_t ));
  context.target.pid = pid;
  context.event_handler = opt_event_handler;
  while (1) {
    rv = find_addresses(& context.target);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = (*(context.event_handler))(& context, 0);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  tmp = strcmp((char const   *)opt_phpv, "auto");
  if (tmp == 0) {
    while (1) {
      rv = get_php_version(& context.target);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
  }
  tmp___7 = strcmp("70", (char const   *)opt_phpv);
  if (tmp___7 == 0) {
    do_trace_ptr = & do_trace_70;
  } else {
    tmp___6 = strcmp("71", (char const   *)opt_phpv);
    if (tmp___6 == 0) {
      do_trace_ptr = & do_trace_71;
    } else {
      tmp___5 = strcmp("72", (char const   *)opt_phpv);
      if (tmp___5 == 0) {
        do_trace_ptr = & do_trace_72;
      } else {
        tmp___4 = strcmp("73", (char const   *)opt_phpv);
        if (tmp___4 == 0) {
          do_trace_ptr = & do_trace_73;
        } else {
          tmp___3 = strcmp("74", (char const   *)opt_phpv);
          if (tmp___3 == 0) {
            do_trace_ptr = & do_trace_74;
          } else {
            tmp___2 = strcmp("80", (char const   *)opt_phpv);
            if (tmp___2 == 0) {
              do_trace_ptr = & do_trace_80;
            } else {
              tmp___1 = strcmp("81", (char const   *)opt_phpv);
              if (tmp___1 == 0) {
                do_trace_ptr = & do_trace_81;
              } else {
                tmp___0 = strcmp("82", (char const   *)opt_phpv);
                if (tmp___0 == 0) {
                  do_trace_ptr = & do_trace_81;
                } else {
                  log_error("main_pid: Unrecognized PHP version (%s)\n", opt_phpv);
                  return (1);
                }
              }
            }
          }
        }
      }
    }
  }
  stop_time = (struct timespec *)((void *)0);
  if (! in_pgrep_mode) {
    if (opt_time_limit_ms > 0L) {
      stop_time = & _stop_time;
      limit_time.tv_sec = opt_time_limit_ms / 1000L;
      limit_time.tv_nsec = (opt_time_limit_ms % 1000L) * 1000000L;
      clock_get(stop_time);
      clock_add(stop_time, & limit_time, stop_time);
    }
  }
  while (! done) {
    clock_get(& start_time);
    rv = 0;
    if (opt_pause) {
      tmp___8 = pause_pid(pid);
      rv |= tmp___8;
    }
    tmp___9 = (*do_trace_ptr)(& context);
    rv |= tmp___9;
    if (opt_pause) {
      tmp___10 = unpause_pid(pid);
      rv |= tmp___10;
    }
    if ((rv & 2) != 0) {
      break;
    }
    if (opt_trace_limit > 0UL) {
      if (rv == 0) {
        if (in_pgrep_mode) {
          __atomic_add_fetch(& trace_count, 1, 5);
        } else {
          trace_count ++;
        }
        if (trace_count >= opt_trace_limit) {
          break;
        }
      }
    }
    if (stop_time) {
      tmp___11 = clock_diff(& end_time, stop_time);
      if (tmp___11 >= 1) {
        break;
      }
    }
    clock_get(& end_time);
    calc_sleep_time(& end_time, & start_time, & sleep_time);
    nanosleep((struct timespec  const  *)(& sleep_time), (struct timespec *)((void *)0));
  }
  (*(context.event_handler))(& context, 9);
  if (in_pgrep_mode) {
    if (opt_trace_limit > 0UL) {
      if (trace_count >= opt_trace_limit) {
        write_done_pipe();
      }
    }
  }
  return (0);
}
}
static int main_fork(int argc , char **argv ) 
{ 
  int rv ;
  int status ;
  pid_t fork_pid ;

  {
  fork_pid = fork();
  if (fork_pid == 0) {
    redirect_child_stdio(1, opt_path_child_out);
    redirect_child_stdio(2, opt_path_child_err);
    ptrace((enum __ptrace_request )0, 0, (void *)0, (void *)0);
    execvp((char const   *)*(argv + optind), (char * const  *)(argv + optind));
    perror("execvp");
    exit(1);
  } else
  if (fork_pid < 0) {
    perror("fork");
    exit(1);
  }
  waitpid(fork_pid, & status, 0);
  if (! ((status & 255) == 127)) {
    log_error("main_fork: Expected SIGTRAP from child\n");
  } else
  if ((status & 65280) >> 8 != 5) {
    log_error("main_fork: Expected SIGTRAP from child\n");
  }
  ptrace((enum __ptrace_request )17, fork_pid, (void *)0, (void *)0);
  rv = main_pid(fork_pid);
  waitpid(fork_pid, (int *)((void *)0), 0);
  return (rv);
}
}
static void cleanup(void) 
{ 
  varpeek_entry_t *entry ;
  varpeek_entry_t *entry_tmp ;
  varpeek_var_t *var ;
  varpeek_var_t *var_tmp ;
  glopeek_entry_t *gentry ;
  glopeek_entry_t *gentry_tmp ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  struct UT_hash_handle *_hd_hh_del ;
  unsigned int _hd_bkt ;
  UT_hash_bucket *_hd_head ;
  struct UT_hash_handle *_hd_hh_del___0 ;
  unsigned int _hd_bkt___0 ;
  UT_hash_bucket *_hd_head___0 ;
  void *tmp___3 ;
  void *tmp___4 ;
  struct UT_hash_handle *_hd_hh_del___1 ;
  unsigned int _hd_bkt___1 ;
  UT_hash_bucket *_hd_head___1 ;

  {
  if (opt_filter_re) {
    regfree(opt_filter_re);
  }
  entry = varpeek_map;
  if ((unsigned long )varpeek_map != (unsigned long )((void *)0)) {
    tmp = varpeek_map->hh.next;
  } else {
    tmp = (void *)0;
  }
  entry_tmp = (varpeek_entry_t *)tmp;
  while ((unsigned long )entry != (unsigned long )((void *)0)) {
    var = entry->varmap;
    if ((unsigned long )entry->varmap != (unsigned long )((void *)0)) {
      tmp___1 = (entry->varmap)->hh.next;
    } else {
      tmp___1 = (void *)0;
    }
    var_tmp = (varpeek_var_t *)tmp___1;
    while ((unsigned long )var != (unsigned long )((void *)0)) {
      while (1) {
        _hd_hh_del = & var->hh;
        if ((unsigned long )_hd_hh_del->prev == (unsigned long )((void *)0)) {
          if ((unsigned long )_hd_hh_del->next == (unsigned long )((void *)0)) {
            free((void *)((entry->varmap)->hh.tbl)->buckets);
            free((void *)(entry->varmap)->hh.tbl);
            entry->varmap = (varpeek_var_t *)((void *)0);
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          if ((unsigned long )_hd_hh_del == (unsigned long )((entry->varmap)->hh.tbl)->tail) {
            ((entry->varmap)->hh.tbl)->tail = (UT_hash_handle *)((char *)_hd_hh_del->prev + ((entry->varmap)->hh.tbl)->hho);
          }
          if ((unsigned long )_hd_hh_del->prev != (unsigned long )((void *)0)) {
            ((UT_hash_handle *)((char *)_hd_hh_del->prev + ((entry->varmap)->hh.tbl)->hho))->next = _hd_hh_del->next;
          } else {
            while (1) {
              entry->varmap = (varpeek_var_t *)_hd_hh_del->next;
              break;
            }
          }
          if ((unsigned long )_hd_hh_del->next != (unsigned long )((void *)0)) {
            ((UT_hash_handle *)((char *)_hd_hh_del->next + ((entry->varmap)->hh.tbl)->hho))->prev = _hd_hh_del->prev;
          }
          while (1) {
            _hd_bkt = _hd_hh_del->hashv & (((entry->varmap)->hh.tbl)->num_buckets - 1U);
            break;
          }
          while (1) {
            _hd_head = ((entry->varmap)->hh.tbl)->buckets + _hd_bkt;
            (_hd_head->count) --;
            if ((unsigned long )_hd_head->hh_head == (unsigned long )_hd_hh_del) {
              _hd_head->hh_head = _hd_hh_del->hh_next;
            }
            if (_hd_hh_del->hh_prev) {
              (_hd_hh_del->hh_prev)->hh_next = _hd_hh_del->hh_next;
            }
            if (_hd_hh_del->hh_next) {
              (_hd_hh_del->hh_next)->hh_prev = _hd_hh_del->hh_prev;
            }
            break;
          }
          (((entry->varmap)->hh.tbl)->num_items) --;
        }
        break;
      }
      free((void *)var);
      var = var_tmp;
      if ((unsigned long )var_tmp != (unsigned long )((void *)0)) {
        tmp___2 = var_tmp->hh.next;
      } else {
        tmp___2 = (void *)0;
      }
      var_tmp = (varpeek_var_t *)tmp___2;
    }
    while (1) {
      _hd_hh_del___0 = & entry->hh;
      if ((unsigned long )_hd_hh_del___0->prev == (unsigned long )((void *)0)) {
        if ((unsigned long )_hd_hh_del___0->next == (unsigned long )((void *)0)) {
          free((void *)(varpeek_map->hh.tbl)->buckets);
          free((void *)varpeek_map->hh.tbl);
          varpeek_map = (varpeek_entry_t *)((void *)0);
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        if ((unsigned long )_hd_hh_del___0 == (unsigned long )(varpeek_map->hh.tbl)->tail) {
          (varpeek_map->hh.tbl)->tail = (UT_hash_handle *)((char *)_hd_hh_del___0->prev + (varpeek_map->hh.tbl)->hho);
        }
        if ((unsigned long )_hd_hh_del___0->prev != (unsigned long )((void *)0)) {
          ((UT_hash_handle *)((char *)_hd_hh_del___0->prev + (varpeek_map->hh.tbl)->hho))->next = _hd_hh_del___0->next;
        } else {
          while (1) {
            varpeek_map = (varpeek_entry_t *)_hd_hh_del___0->next;
            break;
          }
        }
        if ((unsigned long )_hd_hh_del___0->next != (unsigned long )((void *)0)) {
          ((UT_hash_handle *)((char *)_hd_hh_del___0->next + (varpeek_map->hh.tbl)->hho))->prev = _hd_hh_del___0->prev;
        }
        while (1) {
          _hd_bkt___0 = _hd_hh_del___0->hashv & ((varpeek_map->hh.tbl)->num_buckets - 1U);
          break;
        }
        while (1) {
          _hd_head___0 = (varpeek_map->hh.tbl)->buckets + _hd_bkt___0;
          (_hd_head___0->count) --;
          if ((unsigned long )_hd_head___0->hh_head == (unsigned long )_hd_hh_del___0) {
            _hd_head___0->hh_head = _hd_hh_del___0->hh_next;
          }
          if (_hd_hh_del___0->hh_prev) {
            (_hd_hh_del___0->hh_prev)->hh_next = _hd_hh_del___0->hh_next;
          }
          if (_hd_hh_del___0->hh_next) {
            (_hd_hh_del___0->hh_next)->hh_prev = _hd_hh_del___0->hh_prev;
          }
          break;
        }
        ((varpeek_map->hh.tbl)->num_items) --;
      }
      break;
    }
    free((void *)entry);
    entry = entry_tmp;
    if ((unsigned long )entry_tmp != (unsigned long )((void *)0)) {
      tmp___0 = entry_tmp->hh.next;
    } else {
      tmp___0 = (void *)0;
    }
    entry_tmp = (varpeek_entry_t *)tmp___0;
  }
  gentry = glopeek_map;
  if ((unsigned long )glopeek_map != (unsigned long )((void *)0)) {
    tmp___3 = glopeek_map->hh.next;
  } else {
    tmp___3 = (void *)0;
  }
  gentry_tmp = (glopeek_entry_t *)tmp___3;
  while ((unsigned long )gentry != (unsigned long )((void *)0)) {
    while (1) {
      _hd_hh_del___1 = & gentry->hh;
      if ((unsigned long )_hd_hh_del___1->prev == (unsigned long )((void *)0)) {
        if ((unsigned long )_hd_hh_del___1->next == (unsigned long )((void *)0)) {
          free((void *)(glopeek_map->hh.tbl)->buckets);
          free((void *)glopeek_map->hh.tbl);
          glopeek_map = (glopeek_entry_t *)((void *)0);
        } else {
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        if ((unsigned long )_hd_hh_del___1 == (unsigned long )(glopeek_map->hh.tbl)->tail) {
          (glopeek_map->hh.tbl)->tail = (UT_hash_handle *)((char *)_hd_hh_del___1->prev + (glopeek_map->hh.tbl)->hho);
        }
        if ((unsigned long )_hd_hh_del___1->prev != (unsigned long )((void *)0)) {
          ((UT_hash_handle *)((char *)_hd_hh_del___1->prev + (glopeek_map->hh.tbl)->hho))->next = _hd_hh_del___1->next;
        } else {
          while (1) {
            glopeek_map = (glopeek_entry_t *)_hd_hh_del___1->next;
            break;
          }
        }
        if ((unsigned long )_hd_hh_del___1->next != (unsigned long )((void *)0)) {
          ((UT_hash_handle *)((char *)_hd_hh_del___1->next + (glopeek_map->hh.tbl)->hho))->prev = _hd_hh_del___1->prev;
        }
        while (1) {
          _hd_bkt___1 = _hd_hh_del___1->hashv & ((glopeek_map->hh.tbl)->num_buckets - 1U);
          break;
        }
        while (1) {
          _hd_head___1 = (glopeek_map->hh.tbl)->buckets + _hd_bkt___1;
          (_hd_head___1->count) --;
          if ((unsigned long )_hd_head___1->hh_head == (unsigned long )_hd_hh_del___1) {
            _hd_head___1->hh_head = _hd_hh_del___1->hh_next;
          }
          if (_hd_hh_del___1->hh_prev) {
            (_hd_hh_del___1->hh_prev)->hh_next = _hd_hh_del___1->hh_next;
          }
          if (_hd_hh_del___1->hh_next) {
            (_hd_hh_del___1->hh_next)->hh_prev = _hd_hh_del___1->hh_prev;
          }
          break;
        }
        ((glopeek_map->hh.tbl)->num_items) --;
      }
      break;
    }
    free((void *)gentry);
    gentry = gentry_tmp;
    if ((unsigned long )gentry_tmp != (unsigned long )((void *)0)) {
      tmp___4 = gentry_tmp->hh.next;
    } else {
      tmp___4 = (void *)0;
    }
    gentry_tmp = (glopeek_entry_t *)tmp___4;
  }
  return;
}
}
static int pause_pid(pid_t pid ) 
{ 
  int rv ;
  int *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  __pid_t tmp___2 ;

  {
  tmp___1 = ptrace((enum __ptrace_request )16, pid, 0, 0);
  if (tmp___1 == -1L) {
    tmp = __errno_location();
    rv = *tmp;
    perror("ptrace");
    if (rv == 3) {
      tmp___0 = 2;
    } else {
      tmp___0 = 0;
    }
    return (1 + tmp___0);
  }
  tmp___2 = waitpid(pid, (int *)((void *)0), 0);
  if (tmp___2 < 0) {
    perror("waitpid");
    return (1);
  }
  return (0);
}
}
static int unpause_pid(pid_t pid ) 
{ 
  int rv ;
  int *tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp___1 = ptrace((enum __ptrace_request )17, pid, 0, 0);
  if (tmp___1 == -1L) {
    tmp = __errno_location();
    rv = *tmp;
    perror("ptrace");
    if (rv == 3) {
      tmp___0 = 2;
    } else {
      tmp___0 = 0;
    }
    return (1 + tmp___0);
  }
  return (0);
}
}
static void redirect_child_stdio(int proc_fd , char *opt_path ) 
{ 
  char *redir_path ;
  FILE *redir_file ;
  int *tmp ;
  __pid_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  tmp___3 = strcmp((char const   *)opt_path, "-");
  if (tmp___3 == 0) {
    return;
  } else {
    tmp___2 = strstr((char const   *)opt_path, "%d");
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
      tmp___0 = getpid();
      tmp___1 = asprintf((char ** __restrict  )(& redir_path), (char const   * __restrict  )opt_path,
                         tmp___0);
      if (tmp___1 < 0) {
        tmp = __errno_location();
        *tmp = 12;
        perror("asprintf");
        exit(1);
      }
    } else {
      redir_path = strdup((char const   *)opt_path);
      if ((unsigned long )redir_path == (unsigned long )((void *)0)) {
        perror("strdup");
        exit(1);
      }
    }
  }
  redir_file = fopen((char const   * __restrict  )redir_path, (char const   * __restrict  )"w");
  if ((unsigned long )redir_file == (unsigned long )((void *)0)) {
    perror("fopen");
    free((void *)redir_path);
    exit(1);
  }
  tmp___4 = fileno(redir_file);
  dup2(tmp___4, proc_fd);
  fclose(redir_file);
  free((void *)redir_path);
  return;
}
}
static int find_addresses(trace_target_t *target ) 
{ 
  int rv ;
  addr_memo_t memo ;
  int tmp ;

  {
  memset((void *)(& memo), 0, sizeof(addr_memo_t ));
  if (opt_executor_globals_addr != 0UL) {
    target->executor_globals_addr = opt_executor_globals_addr;
  } else {
    while (1) {
      rv = get_symbol_addr(& memo, target->pid, "executor_globals", & target->executor_globals_addr);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
  }
  if (opt_sapi_globals_addr != 0UL) {
    target->sapi_globals_addr = opt_sapi_globals_addr;
  } else
  if (opt_capture_req) {
    while (1) {
      rv = get_symbol_addr(& memo, target->pid, "sapi_globals", & target->sapi_globals_addr);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
  }
  if (opt_capture_mem) {
    while (1) {
      rv = get_symbol_addr(& memo, target->pid, "alloc_globals", & target->alloc_globals_addr);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
  }
  log_error_enabled = 0;
  tmp = get_symbol_addr(& memo, target->pid, "basic_functions_module", & target->basic_functions_module_addr);
  if (tmp != 0) {
    target->basic_functions_module_addr = (uint64_t )0;
  }
  log_error_enabled = 1;
  return (0);
}
}
static void clock_get(struct timespec *ts ) 
{ 
  int tmp ;

  {
  tmp = clock_gettime(4, ts);
  if (tmp == -1) {
    perror("clock_gettime");
    ts->tv_sec = (__time_t )0;
    ts->tv_nsec = (__syscall_slong_t )0;
  }
  return;
}
}
static void clock_add(struct timespec *a , struct timespec *b , struct timespec *res ) 
{ 


  {
  res->tv_sec = a->tv_sec + b->tv_sec;
  res->tv_nsec = a->tv_nsec + b->tv_nsec;
  if (res->tv_nsec >= 1000000000L) {
    res->tv_sec += res->tv_nsec / 1000000000L;
    res->tv_nsec %= 1000000000L;
  }
  return;
}
}
static int clock_diff(struct timespec *a , struct timespec *b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (a->tv_sec == b->tv_sec) {
    if (a->tv_nsec == b->tv_nsec) {
      return (0);
    }
    if (a->tv_nsec > b->tv_nsec) {
      tmp = 1;
    } else {
      tmp = -1;
    }
    return (tmp);
  }
  if (a->tv_sec > b->tv_sec) {
    tmp___0 = 1;
  } else {
    tmp___0 = -1;
  }
  return (tmp___0);
}
}
static void calc_sleep_time(struct timespec *end , struct timespec *start , struct timespec *sleep___0 ) 
{ 
  long end_ns ;
  long start_ns ;
  long sleep_ns ;

  {
  if (end->tv_sec == start->tv_sec) {
    sleep_ns = opt_sleep_ns - (end->tv_nsec - start->tv_nsec);
  } else {
    end_ns = (long )((unsigned long )end->tv_sec * 1000000000UL + (unsigned long )end->tv_nsec);
    start_ns = (long )((unsigned long )start->tv_sec * 1000000000UL + (unsigned long )start->tv_nsec);
    sleep_ns = opt_sleep_ns - (end_ns - start_ns);
  }
  if (sleep_ns < 0L) {
    log_error("calc_sleep_time: Expected sleep_ns>0; decrease sample rate\n");
    sleep_ns = 0L;
  }
  if (sleep_ns < 1000000000L) {
    sleep___0->tv_sec = (__time_t )0;
    sleep___0->tv_nsec = sleep_ns;
  } else {
    sleep___0->tv_sec = sleep_ns / 1000000000L;
    sleep___0->tv_nsec = sleep_ns - sleep___0->tv_sec * 1000000000L;
  }
  return;
}
}
static void varpeek_add(char *varspec ) 
{ 
  char *at_sign ;
  char *colon ;
  char *dash ;
  uint32_t line_start ;
  uint32_t line_end ;
  uint32_t lineno ;
  varpeek_entry_t *varpeek ;
  varpeek_var_t *var ;
  char varpeek_key[256] ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned int _uthash_hfstr_keylen ;
  size_t tmp___1 ;
  unsigned int _hf_hashv ;
  unsigned int _hj_i ;
  unsigned int _hj_j ;
  unsigned int _hj_k ;
  unsigned char const   *_hj_key ;
  unsigned int _hf_bkt ;
  int tmp___2 ;
  void *tmp___3 ;
  unsigned int _uthash_hastr_keylen ;
  size_t tmp___4 ;
  unsigned int _ha_hashv ;
  unsigned int _hj_i___0 ;
  unsigned int _hj_j___0 ;
  unsigned int _hj_k___0 ;
  unsigned char const   *_hj_key___0 ;
  void *tmp___5 ;
  void *tmp___6 ;
  unsigned int _ha_bkt ;
  UT_hash_bucket *_ha_head ;
  unsigned int _he_bkt ;
  unsigned int _he_bkt_i ;
  struct UT_hash_handle *_he_thh ;
  struct UT_hash_handle *_he_hh_nxt ;
  UT_hash_bucket *_he_new_buckets ;
  UT_hash_bucket *_he_newbkt ;
  void *tmp___7 ;
  unsigned int tmp___8 ;
  void *tmp___9 ;
  unsigned int _uthash_hastr_keylen___0 ;
  size_t tmp___10 ;
  unsigned int _ha_hashv___0 ;
  unsigned int _hj_i___1 ;
  unsigned int _hj_j___1 ;
  unsigned int _hj_k___1 ;
  unsigned char const   *_hj_key___1 ;
  void *tmp___11 ;
  void *tmp___12 ;
  unsigned int _ha_bkt___0 ;
  UT_hash_bucket *_ha_head___0 ;
  unsigned int _he_bkt___0 ;
  unsigned int _he_bkt_i___0 ;
  struct UT_hash_handle *_he_thh___0 ;
  struct UT_hash_handle *_he_hh_nxt___0 ;
  UT_hash_bucket *_he_new_buckets___0 ;
  UT_hash_bucket *_he_newbkt___0 ;
  void *tmp___13 ;
  unsigned int tmp___14 ;

  {
  at_sign = strchr((char const   *)varspec, '@');
  colon = strrchr((char const   *)varspec, ':');
  dash = strrchr((char const   *)varspec, '-');
  if (! at_sign) {
    log_error("varpeek_add: Malformed varspec: %s\n\n", varspec);
    usage(stderr, 1);
  } else
  if (! colon) {
    log_error("varpeek_add: Malformed varspec: %s\n\n", varspec);
    usage(stderr, 1);
  }
  tmp = strtoul((char const   * __restrict  )(colon + 1), (char ** __restrict  )((void *)0),
                10);
  line_start = (uint32_t )tmp;
  if (dash) {
    tmp___0 = strtoul((char const   * __restrict  )(dash + 1), (char ** __restrict  )((void *)0),
                      10);
    line_end = (uint32_t )tmp___0;
  } else {
    line_end = line_start;
  }
  lineno = line_start;
  while (lineno <= line_end) {
    snprintf((char * __restrict  )(varpeek_key), sizeof(varpeek_key), (char const   * __restrict  )"%.*s:%d",
             (int )((colon - at_sign) - 1L), at_sign + 1, lineno);
    while (1) {
      tmp___1 = strlen((char const   *)(varpeek_key));
      _uthash_hfstr_keylen = (unsigned int )tmp___1;
      while (1) {
        while (1) {
          while (1) {
            _hj_key = (unsigned char const   *)(varpeek_key);
            _hf_hashv = 4276993775U;
            _hj_j = 2654435769U;
            _hj_i = _hj_j;
            _hj_k = _uthash_hfstr_keylen;
            while (_hj_k >= 12U) {
              _hj_i += (((unsigned int )*(_hj_key + 0) + ((unsigned int )*(_hj_key + 1) << 8)) + ((unsigned int )*(_hj_key + 2) << 16)) + ((unsigned int )*(_hj_key + 3) << 24);
              _hj_j += (((unsigned int )*(_hj_key + 4) + ((unsigned int )*(_hj_key + 5) << 8)) + ((unsigned int )*(_hj_key + 6) << 16)) + ((unsigned int )*(_hj_key + 7) << 24);
              _hf_hashv += (((unsigned int )*(_hj_key + 8) + ((unsigned int )*(_hj_key + 9) << 8)) + ((unsigned int )*(_hj_key + 10) << 16)) + ((unsigned int )*(_hj_key + 11) << 24);
              while (1) {
                _hj_i -= _hj_j;
                _hj_i -= _hf_hashv;
                _hj_i ^= _hf_hashv >> 13;
                _hj_j -= _hf_hashv;
                _hj_j -= _hj_i;
                _hj_j ^= _hj_i << 8;
                _hf_hashv -= _hj_i;
                _hf_hashv -= _hj_j;
                _hf_hashv ^= _hj_j >> 13;
                _hj_i -= _hj_j;
                _hj_i -= _hf_hashv;
                _hj_i ^= _hf_hashv >> 12;
                _hj_j -= _hf_hashv;
                _hj_j -= _hj_i;
                _hj_j ^= _hj_i << 16;
                _hf_hashv -= _hj_i;
                _hf_hashv -= _hj_j;
                _hf_hashv ^= _hj_j >> 5;
                _hj_i -= _hj_j;
                _hj_i -= _hf_hashv;
                _hj_i ^= _hf_hashv >> 3;
                _hj_j -= _hf_hashv;
                _hj_j -= _hj_i;
                _hj_j ^= _hj_i << 10;
                _hf_hashv -= _hj_i;
                _hf_hashv -= _hj_j;
                _hf_hashv ^= _hj_j >> 15;
                break;
              }
              _hj_key += 12;
              _hj_k -= 12U;
            }
            _hf_hashv += _uthash_hfstr_keylen;
            switch (_hj_k) {
            case 11U: 
            _hf_hashv += (unsigned int )*(_hj_key + 10) << 24;
            case 10U: 
            _hf_hashv += (unsigned int )*(_hj_key + 9) << 16;
            case 9U: 
            _hf_hashv += (unsigned int )*(_hj_key + 8) << 8;
            case 8U: 
            _hj_j += (unsigned int )*(_hj_key + 7) << 24;
            case 7U: 
            _hj_j += (unsigned int )*(_hj_key + 6) << 16;
            case 6U: 
            _hj_j += (unsigned int )*(_hj_key + 5) << 8;
            case 5U: 
            _hj_j += (unsigned int )*(_hj_key + 4);
            case 4U: 
            _hj_i += (unsigned int )*(_hj_key + 3) << 24;
            case 3U: 
            _hj_i += (unsigned int )*(_hj_key + 2) << 16;
            case 2U: 
            _hj_i += (unsigned int )*(_hj_key + 1) << 8;
            case 1U: 
            _hj_i += (unsigned int )*(_hj_key + 0);
            }
            while (1) {
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 13;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 8;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 13;
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 12;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 16;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 5;
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 3;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 10;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 15;
              break;
            }
            break;
          }
          break;
        }
        while (1) {
          varpeek = (varpeek_entry_t *)((void *)0);
          if (varpeek_map) {
            while (1) {
              _hf_bkt = _hf_hashv & ((varpeek_map->hh.tbl)->num_buckets - 1U);
              break;
            }
            while (1) {
              if ((unsigned long )((varpeek_map->hh.tbl)->buckets + _hf_bkt)->hh_head != (unsigned long )((void *)0)) {
                while (1) {
                  varpeek = (varpeek_entry_t *)((void *)((char *)((varpeek_map->hh.tbl)->buckets + _hf_bkt)->hh_head - (varpeek_map->hh.tbl)->hho));
                  break;
                }
              } else {
                varpeek = (varpeek_entry_t *)((void *)0);
              }
              while ((unsigned long )varpeek != (unsigned long )((void *)0)) {
                if (varpeek->hh.hashv == _hf_hashv) {
                  if (varpeek->hh.keylen == _uthash_hfstr_keylen) {
                    tmp___2 = memcmp((void const   *)varpeek->hh.key, (void const   *)(varpeek_key),
                                     (size_t )_uthash_hfstr_keylen);
                    if (tmp___2 == 0) {
                      break;
                    }
                  }
                }
                if ((unsigned long )varpeek->hh.hh_next != (unsigned long )((void *)0)) {
                  while (1) {
                    varpeek = (varpeek_entry_t *)((void *)((char *)varpeek->hh.hh_next - (varpeek_map->hh.tbl)->hho));
                    break;
                  }
                } else {
                  varpeek = (varpeek_entry_t *)((void *)0);
                }
              }
              break;
            }
          }
          break;
        }
        break;
      }
      break;
    }
    if (! varpeek) {
      tmp___3 = calloc((size_t )1, sizeof(varpeek_entry_t ));
      varpeek = (varpeek_entry_t *)tmp___3;
      strncpy((char * __restrict  )(varpeek->filename_lineno), (char const   * __restrict  )(varpeek_key),
              sizeof(varpeek->filename_lineno));
      while (1) {
        tmp___4 = strlen((char const   *)(varpeek->filename_lineno));
        _uthash_hastr_keylen = (unsigned int )tmp___4;
        while (1) {
          while (1) {
            while (1) {
              _hj_key___0 = (unsigned char const   *)(& varpeek->filename_lineno[0]);
              _ha_hashv = 4276993775U;
              _hj_j___0 = 2654435769U;
              _hj_i___0 = _hj_j___0;
              _hj_k___0 = _uthash_hastr_keylen;
              while (_hj_k___0 >= 12U) {
                _hj_i___0 += (((unsigned int )*(_hj_key___0 + 0) + ((unsigned int )*(_hj_key___0 + 1) << 8)) + ((unsigned int )*(_hj_key___0 + 2) << 16)) + ((unsigned int )*(_hj_key___0 + 3) << 24);
                _hj_j___0 += (((unsigned int )*(_hj_key___0 + 4) + ((unsigned int )*(_hj_key___0 + 5) << 8)) + ((unsigned int )*(_hj_key___0 + 6) << 16)) + ((unsigned int )*(_hj_key___0 + 7) << 24);
                _ha_hashv += (((unsigned int )*(_hj_key___0 + 8) + ((unsigned int )*(_hj_key___0 + 9) << 8)) + ((unsigned int )*(_hj_key___0 + 10) << 16)) + ((unsigned int )*(_hj_key___0 + 11) << 24);
                while (1) {
                  _hj_i___0 -= _hj_j___0;
                  _hj_i___0 -= _ha_hashv;
                  _hj_i___0 ^= _ha_hashv >> 13;
                  _hj_j___0 -= _ha_hashv;
                  _hj_j___0 -= _hj_i___0;
                  _hj_j___0 ^= _hj_i___0 << 8;
                  _ha_hashv -= _hj_i___0;
                  _ha_hashv -= _hj_j___0;
                  _ha_hashv ^= _hj_j___0 >> 13;
                  _hj_i___0 -= _hj_j___0;
                  _hj_i___0 -= _ha_hashv;
                  _hj_i___0 ^= _ha_hashv >> 12;
                  _hj_j___0 -= _ha_hashv;
                  _hj_j___0 -= _hj_i___0;
                  _hj_j___0 ^= _hj_i___0 << 16;
                  _ha_hashv -= _hj_i___0;
                  _ha_hashv -= _hj_j___0;
                  _ha_hashv ^= _hj_j___0 >> 5;
                  _hj_i___0 -= _hj_j___0;
                  _hj_i___0 -= _ha_hashv;
                  _hj_i___0 ^= _ha_hashv >> 3;
                  _hj_j___0 -= _ha_hashv;
                  _hj_j___0 -= _hj_i___0;
                  _hj_j___0 ^= _hj_i___0 << 10;
                  _ha_hashv -= _hj_i___0;
                  _ha_hashv -= _hj_j___0;
                  _ha_hashv ^= _hj_j___0 >> 15;
                  break;
                }
                _hj_key___0 += 12;
                _hj_k___0 -= 12U;
              }
              _ha_hashv += _uthash_hastr_keylen;
              switch (_hj_k___0) {
              case 11U: 
              _ha_hashv += (unsigned int )*(_hj_key___0 + 10) << 24;
              case 10U: 
              _ha_hashv += (unsigned int )*(_hj_key___0 + 9) << 16;
              case 9U: 
              _ha_hashv += (unsigned int )*(_hj_key___0 + 8) << 8;
              case 8U: 
              _hj_j___0 += (unsigned int )*(_hj_key___0 + 7) << 24;
              case 7U: 
              _hj_j___0 += (unsigned int )*(_hj_key___0 + 6) << 16;
              case 6U: 
              _hj_j___0 += (unsigned int )*(_hj_key___0 + 5) << 8;
              case 5U: 
              _hj_j___0 += (unsigned int )*(_hj_key___0 + 4);
              case 4U: 
              _hj_i___0 += (unsigned int )*(_hj_key___0 + 3) << 24;
              case 3U: 
              _hj_i___0 += (unsigned int )*(_hj_key___0 + 2) << 16;
              case 2U: 
              _hj_i___0 += (unsigned int )*(_hj_key___0 + 1) << 8;
              case 1U: 
              _hj_i___0 += (unsigned int )*(_hj_key___0 + 0);
              }
              while (1) {
                _hj_i___0 -= _hj_j___0;
                _hj_i___0 -= _ha_hashv;
                _hj_i___0 ^= _ha_hashv >> 13;
                _hj_j___0 -= _ha_hashv;
                _hj_j___0 -= _hj_i___0;
                _hj_j___0 ^= _hj_i___0 << 8;
                _ha_hashv -= _hj_i___0;
                _ha_hashv -= _hj_j___0;
                _ha_hashv ^= _hj_j___0 >> 13;
                _hj_i___0 -= _hj_j___0;
                _hj_i___0 -= _ha_hashv;
                _hj_i___0 ^= _ha_hashv >> 12;
                _hj_j___0 -= _ha_hashv;
                _hj_j___0 -= _hj_i___0;
                _hj_j___0 ^= _hj_i___0 << 16;
                _ha_hashv -= _hj_i___0;
                _ha_hashv -= _hj_j___0;
                _ha_hashv ^= _hj_j___0 >> 5;
                _hj_i___0 -= _hj_j___0;
                _hj_i___0 -= _ha_hashv;
                _hj_i___0 ^= _ha_hashv >> 3;
                _hj_j___0 -= _ha_hashv;
                _hj_j___0 -= _hj_i___0;
                _hj_j___0 ^= _hj_i___0 << 10;
                _ha_hashv -= _hj_i___0;
                _ha_hashv -= _hj_j___0;
                _ha_hashv ^= _hj_j___0 >> 15;
                break;
              }
              break;
            }
            break;
          }
          while (1) {
            varpeek->hh.hashv = _ha_hashv;
            varpeek->hh.key = (void *)(& varpeek->filename_lineno[0]);
            varpeek->hh.keylen = _uthash_hastr_keylen;
            if (! varpeek_map) {
              varpeek->hh.next = (void *)0;
              varpeek->hh.prev = (void *)0;
              while (1) {
                tmp___5 = malloc(sizeof(UT_hash_table ));
                varpeek->hh.tbl = (UT_hash_table *)tmp___5;
                if (! varpeek->hh.tbl) {
                  exit(-1);
                } else {
                  memset((void *)varpeek->hh.tbl, '\000', sizeof(UT_hash_table ));
                  (varpeek->hh.tbl)->tail = & varpeek->hh;
                  (varpeek->hh.tbl)->num_buckets = 32U;
                  (varpeek->hh.tbl)->log2_num_buckets = 5U;
                  (varpeek->hh.tbl)->hho = (char *)(& varpeek->hh) - (char *)varpeek;
                  tmp___6 = malloc(32UL * sizeof(struct UT_hash_bucket ));
                  (varpeek->hh.tbl)->buckets = (UT_hash_bucket *)tmp___6;
                  (varpeek->hh.tbl)->signature = 2685476833U;
                  if (! (varpeek->hh.tbl)->buckets) {
                    exit(-1);
                    free((void *)varpeek->hh.tbl);
                  } else {
                    memset((void *)(varpeek->hh.tbl)->buckets, '\000', 32UL * sizeof(struct UT_hash_bucket ));
                  }
                }
                break;
              }
              varpeek_map = varpeek;
            } else {
              varpeek->hh.tbl = varpeek_map->hh.tbl;
              while (1) {
                varpeek->hh.next = (void *)0;
                varpeek->hh.prev = (void *)((char *)(varpeek_map->hh.tbl)->tail - (varpeek_map->hh.tbl)->hho);
                ((varpeek_map->hh.tbl)->tail)->next = (void *)varpeek;
                (varpeek_map->hh.tbl)->tail = & varpeek->hh;
                break;
              }
            }
            while (1) {
              ((varpeek_map->hh.tbl)->num_items) ++;
              while (1) {
                _ha_bkt = _ha_hashv & ((varpeek_map->hh.tbl)->num_buckets - 1U);
                break;
              }
              while (1) {
                _ha_head = (varpeek_map->hh.tbl)->buckets + _ha_bkt;
                (_ha_head->count) ++;
                varpeek->hh.hh_next = _ha_head->hh_head;
                varpeek->hh.hh_prev = (struct UT_hash_handle *)((void *)0);
                if ((unsigned long )_ha_head->hh_head != (unsigned long )((void *)0)) {
                  (_ha_head->hh_head)->hh_prev = & varpeek->hh;
                }
                _ha_head->hh_head = & varpeek->hh;
                if (_ha_head->count >= (_ha_head->expand_mult + 1U) * 10U) {
                  if (! (varpeek->hh.tbl)->noexpand) {
                    while (1) {
                      tmp___7 = malloc((2UL * (unsigned long )(varpeek->hh.tbl)->num_buckets) * sizeof(struct UT_hash_bucket ));
                      _he_new_buckets = (UT_hash_bucket *)tmp___7;
                      if (! _he_new_buckets) {
                        exit(-1);
                      } else {
                        memset((void *)_he_new_buckets, '\000', (2UL * (unsigned long )(varpeek->hh.tbl)->num_buckets) * sizeof(struct UT_hash_bucket ));
                        if (((varpeek->hh.tbl)->num_items & ((varpeek->hh.tbl)->num_buckets * 2U - 1U)) != 0U) {
                          tmp___8 = 1U;
                        } else {
                          tmp___8 = 0U;
                        }
                        (varpeek->hh.tbl)->ideal_chain_maxlen = ((varpeek->hh.tbl)->num_items >> ((varpeek->hh.tbl)->log2_num_buckets + 1U)) + tmp___8;
                        (varpeek->hh.tbl)->nonideal_items = 0U;
                        _he_bkt_i = 0U;
                        while (_he_bkt_i < (varpeek->hh.tbl)->num_buckets) {
                          _he_thh = ((varpeek->hh.tbl)->buckets + _he_bkt_i)->hh_head;
                          while ((unsigned long )_he_thh != (unsigned long )((void *)0)) {
                            _he_hh_nxt = _he_thh->hh_next;
                            while (1) {
                              _he_bkt = _he_thh->hashv & ((varpeek->hh.tbl)->num_buckets * 2U - 1U);
                              break;
                            }
                            _he_newbkt = _he_new_buckets + _he_bkt;
                            (_he_newbkt->count) ++;
                            if (_he_newbkt->count > (varpeek->hh.tbl)->ideal_chain_maxlen) {
                              ((varpeek->hh.tbl)->nonideal_items) ++;
                              _he_newbkt->expand_mult = _he_newbkt->count / (varpeek->hh.tbl)->ideal_chain_maxlen;
                            }
                            _he_thh->hh_prev = (struct UT_hash_handle *)((void *)0);
                            _he_thh->hh_next = _he_newbkt->hh_head;
                            if ((unsigned long )_he_newbkt->hh_head != (unsigned long )((void *)0)) {
                              (_he_newbkt->hh_head)->hh_prev = _he_thh;
                            }
                            _he_newbkt->hh_head = _he_thh;
                            _he_thh = _he_hh_nxt;
                          }
                          _he_bkt_i ++;
                        }
                        free((void *)(varpeek->hh.tbl)->buckets);
                        (varpeek->hh.tbl)->num_buckets *= 2U;
                        ((varpeek->hh.tbl)->log2_num_buckets) ++;
                        (varpeek->hh.tbl)->buckets = _he_new_buckets;
                        if ((varpeek->hh.tbl)->nonideal_items > (varpeek->hh.tbl)->num_items >> 1) {
                          ((varpeek->hh.tbl)->ineff_expands) ++;
                        } else {
                          (varpeek->hh.tbl)->ineff_expands = 0U;
                        }
                        if ((varpeek->hh.tbl)->ineff_expands > 1U) {
                          (varpeek->hh.tbl)->noexpand = 1U;
                        }
                      }
                      break;
                    }
                  }
                }
                break;
              }
              break;
            }
            break;
          }
          break;
        }
        break;
      }
    }
    tmp___9 = calloc((size_t )1, sizeof(varpeek_var_t ));
    var = (varpeek_var_t *)tmp___9;
    snprintf((char * __restrict  )(var->name), sizeof(var->name), (char const   * __restrict  )"%.*s",
             (int )(at_sign - varspec), varspec);
    while (1) {
      tmp___10 = strlen((char const   *)(var->name));
      _uthash_hastr_keylen___0 = (unsigned int )tmp___10;
      while (1) {
        while (1) {
          while (1) {
            _hj_key___1 = (unsigned char const   *)(& var->name[0]);
            _ha_hashv___0 = 4276993775U;
            _hj_j___1 = 2654435769U;
            _hj_i___1 = _hj_j___1;
            _hj_k___1 = _uthash_hastr_keylen___0;
            while (_hj_k___1 >= 12U) {
              _hj_i___1 += (((unsigned int )*(_hj_key___1 + 0) + ((unsigned int )*(_hj_key___1 + 1) << 8)) + ((unsigned int )*(_hj_key___1 + 2) << 16)) + ((unsigned int )*(_hj_key___1 + 3) << 24);
              _hj_j___1 += (((unsigned int )*(_hj_key___1 + 4) + ((unsigned int )*(_hj_key___1 + 5) << 8)) + ((unsigned int )*(_hj_key___1 + 6) << 16)) + ((unsigned int )*(_hj_key___1 + 7) << 24);
              _ha_hashv___0 += (((unsigned int )*(_hj_key___1 + 8) + ((unsigned int )*(_hj_key___1 + 9) << 8)) + ((unsigned int )*(_hj_key___1 + 10) << 16)) + ((unsigned int )*(_hj_key___1 + 11) << 24);
              while (1) {
                _hj_i___1 -= _hj_j___1;
                _hj_i___1 -= _ha_hashv___0;
                _hj_i___1 ^= _ha_hashv___0 >> 13;
                _hj_j___1 -= _ha_hashv___0;
                _hj_j___1 -= _hj_i___1;
                _hj_j___1 ^= _hj_i___1 << 8;
                _ha_hashv___0 -= _hj_i___1;
                _ha_hashv___0 -= _hj_j___1;
                _ha_hashv___0 ^= _hj_j___1 >> 13;
                _hj_i___1 -= _hj_j___1;
                _hj_i___1 -= _ha_hashv___0;
                _hj_i___1 ^= _ha_hashv___0 >> 12;
                _hj_j___1 -= _ha_hashv___0;
                _hj_j___1 -= _hj_i___1;
                _hj_j___1 ^= _hj_i___1 << 16;
                _ha_hashv___0 -= _hj_i___1;
                _ha_hashv___0 -= _hj_j___1;
                _ha_hashv___0 ^= _hj_j___1 >> 5;
                _hj_i___1 -= _hj_j___1;
                _hj_i___1 -= _ha_hashv___0;
                _hj_i___1 ^= _ha_hashv___0 >> 3;
                _hj_j___1 -= _ha_hashv___0;
                _hj_j___1 -= _hj_i___1;
                _hj_j___1 ^= _hj_i___1 << 10;
                _ha_hashv___0 -= _hj_i___1;
                _ha_hashv___0 -= _hj_j___1;
                _ha_hashv___0 ^= _hj_j___1 >> 15;
                break;
              }
              _hj_key___1 += 12;
              _hj_k___1 -= 12U;
            }
            _ha_hashv___0 += _uthash_hastr_keylen___0;
            switch (_hj_k___1) {
            case 11U: 
            _ha_hashv___0 += (unsigned int )*(_hj_key___1 + 10) << 24;
            case 10U: 
            _ha_hashv___0 += (unsigned int )*(_hj_key___1 + 9) << 16;
            case 9U: 
            _ha_hashv___0 += (unsigned int )*(_hj_key___1 + 8) << 8;
            case 8U: 
            _hj_j___1 += (unsigned int )*(_hj_key___1 + 7) << 24;
            case 7U: 
            _hj_j___1 += (unsigned int )*(_hj_key___1 + 6) << 16;
            case 6U: 
            _hj_j___1 += (unsigned int )*(_hj_key___1 + 5) << 8;
            case 5U: 
            _hj_j___1 += (unsigned int )*(_hj_key___1 + 4);
            case 4U: 
            _hj_i___1 += (unsigned int )*(_hj_key___1 + 3) << 24;
            case 3U: 
            _hj_i___1 += (unsigned int )*(_hj_key___1 + 2) << 16;
            case 2U: 
            _hj_i___1 += (unsigned int )*(_hj_key___1 + 1) << 8;
            case 1U: 
            _hj_i___1 += (unsigned int )*(_hj_key___1 + 0);
            }
            while (1) {
              _hj_i___1 -= _hj_j___1;
              _hj_i___1 -= _ha_hashv___0;
              _hj_i___1 ^= _ha_hashv___0 >> 13;
              _hj_j___1 -= _ha_hashv___0;
              _hj_j___1 -= _hj_i___1;
              _hj_j___1 ^= _hj_i___1 << 8;
              _ha_hashv___0 -= _hj_i___1;
              _ha_hashv___0 -= _hj_j___1;
              _ha_hashv___0 ^= _hj_j___1 >> 13;
              _hj_i___1 -= _hj_j___1;
              _hj_i___1 -= _ha_hashv___0;
              _hj_i___1 ^= _ha_hashv___0 >> 12;
              _hj_j___1 -= _ha_hashv___0;
              _hj_j___1 -= _hj_i___1;
              _hj_j___1 ^= _hj_i___1 << 16;
              _ha_hashv___0 -= _hj_i___1;
              _ha_hashv___0 -= _hj_j___1;
              _ha_hashv___0 ^= _hj_j___1 >> 5;
              _hj_i___1 -= _hj_j___1;
              _hj_i___1 -= _ha_hashv___0;
              _hj_i___1 ^= _ha_hashv___0 >> 3;
              _hj_j___1 -= _ha_hashv___0;
              _hj_j___1 -= _hj_i___1;
              _hj_j___1 ^= _hj_i___1 << 10;
              _ha_hashv___0 -= _hj_i___1;
              _ha_hashv___0 -= _hj_j___1;
              _ha_hashv___0 ^= _hj_j___1 >> 15;
              break;
            }
            break;
          }
          break;
        }
        while (1) {
          var->hh.hashv = _ha_hashv___0;
          var->hh.key = (void *)(& var->name[0]);
          var->hh.keylen = _uthash_hastr_keylen___0;
          if (! varpeek->varmap) {
            var->hh.next = (void *)0;
            var->hh.prev = (void *)0;
            while (1) {
              tmp___11 = malloc(sizeof(UT_hash_table ));
              var->hh.tbl = (UT_hash_table *)tmp___11;
              if (! var->hh.tbl) {
                exit(-1);
              } else {
                memset((void *)var->hh.tbl, '\000', sizeof(UT_hash_table ));
                (var->hh.tbl)->tail = & var->hh;
                (var->hh.tbl)->num_buckets = 32U;
                (var->hh.tbl)->log2_num_buckets = 5U;
                (var->hh.tbl)->hho = (char *)(& var->hh) - (char *)var;
                tmp___12 = malloc(32UL * sizeof(struct UT_hash_bucket ));
                (var->hh.tbl)->buckets = (UT_hash_bucket *)tmp___12;
                (var->hh.tbl)->signature = 2685476833U;
                if (! (var->hh.tbl)->buckets) {
                  exit(-1);
                  free((void *)var->hh.tbl);
                } else {
                  memset((void *)(var->hh.tbl)->buckets, '\000', 32UL * sizeof(struct UT_hash_bucket ));
                }
              }
              break;
            }
            varpeek->varmap = var;
          } else {
            var->hh.tbl = (varpeek->varmap)->hh.tbl;
            while (1) {
              var->hh.next = (void *)0;
              var->hh.prev = (void *)((char *)((varpeek->varmap)->hh.tbl)->tail - ((varpeek->varmap)->hh.tbl)->hho);
              (((varpeek->varmap)->hh.tbl)->tail)->next = (void *)var;
              ((varpeek->varmap)->hh.tbl)->tail = & var->hh;
              break;
            }
          }
          while (1) {
            (((varpeek->varmap)->hh.tbl)->num_items) ++;
            while (1) {
              _ha_bkt___0 = _ha_hashv___0 & (((varpeek->varmap)->hh.tbl)->num_buckets - 1U);
              break;
            }
            while (1) {
              _ha_head___0 = ((varpeek->varmap)->hh.tbl)->buckets + _ha_bkt___0;
              (_ha_head___0->count) ++;
              var->hh.hh_next = _ha_head___0->hh_head;
              var->hh.hh_prev = (struct UT_hash_handle *)((void *)0);
              if ((unsigned long )_ha_head___0->hh_head != (unsigned long )((void *)0)) {
                (_ha_head___0->hh_head)->hh_prev = & var->hh;
              }
              _ha_head___0->hh_head = & var->hh;
              if (_ha_head___0->count >= (_ha_head___0->expand_mult + 1U) * 10U) {
                if (! (var->hh.tbl)->noexpand) {
                  while (1) {
                    tmp___13 = malloc((2UL * (unsigned long )(var->hh.tbl)->num_buckets) * sizeof(struct UT_hash_bucket ));
                    _he_new_buckets___0 = (UT_hash_bucket *)tmp___13;
                    if (! _he_new_buckets___0) {
                      exit(-1);
                    } else {
                      memset((void *)_he_new_buckets___0, '\000', (2UL * (unsigned long )(var->hh.tbl)->num_buckets) * sizeof(struct UT_hash_bucket ));
                      if (((var->hh.tbl)->num_items & ((var->hh.tbl)->num_buckets * 2U - 1U)) != 0U) {
                        tmp___14 = 1U;
                      } else {
                        tmp___14 = 0U;
                      }
                      (var->hh.tbl)->ideal_chain_maxlen = ((var->hh.tbl)->num_items >> ((var->hh.tbl)->log2_num_buckets + 1U)) + tmp___14;
                      (var->hh.tbl)->nonideal_items = 0U;
                      _he_bkt_i___0 = 0U;
                      while (_he_bkt_i___0 < (var->hh.tbl)->num_buckets) {
                        _he_thh___0 = ((var->hh.tbl)->buckets + _he_bkt_i___0)->hh_head;
                        while ((unsigned long )_he_thh___0 != (unsigned long )((void *)0)) {
                          _he_hh_nxt___0 = _he_thh___0->hh_next;
                          while (1) {
                            _he_bkt___0 = _he_thh___0->hashv & ((var->hh.tbl)->num_buckets * 2U - 1U);
                            break;
                          }
                          _he_newbkt___0 = _he_new_buckets___0 + _he_bkt___0;
                          (_he_newbkt___0->count) ++;
                          if (_he_newbkt___0->count > (var->hh.tbl)->ideal_chain_maxlen) {
                            ((var->hh.tbl)->nonideal_items) ++;
                            _he_newbkt___0->expand_mult = _he_newbkt___0->count / (var->hh.tbl)->ideal_chain_maxlen;
                          }
                          _he_thh___0->hh_prev = (struct UT_hash_handle *)((void *)0);
                          _he_thh___0->hh_next = _he_newbkt___0->hh_head;
                          if ((unsigned long )_he_newbkt___0->hh_head != (unsigned long )((void *)0)) {
                            (_he_newbkt___0->hh_head)->hh_prev = _he_thh___0;
                          }
                          _he_newbkt___0->hh_head = _he_thh___0;
                          _he_thh___0 = _he_hh_nxt___0;
                        }
                        _he_bkt_i___0 ++;
                      }
                      free((void *)(var->hh.tbl)->buckets);
                      (var->hh.tbl)->num_buckets *= 2U;
                      ((var->hh.tbl)->log2_num_buckets) ++;
                      (var->hh.tbl)->buckets = _he_new_buckets___0;
                      if ((var->hh.tbl)->nonideal_items > (var->hh.tbl)->num_items >> 1) {
                        ((var->hh.tbl)->ineff_expands) ++;
                      } else {
                        (var->hh.tbl)->ineff_expands = 0U;
                      }
                      if ((var->hh.tbl)->ineff_expands > 1U) {
                        (var->hh.tbl)->noexpand = 1U;
                      }
                    }
                    break;
                  }
                }
              }
              break;
            }
            break;
          }
          break;
        }
        break;
      }
      break;
    }
    lineno ++;
  }
  return;
}
}
static void glopeek_add(char *glospec ) 
{ 
  char *dot ;
  char *gloname ;
  glopeek_entry_t *gentry ;
  unsigned int _uthash_hfstr_keylen ;
  size_t tmp ;
  unsigned int _hf_hashv ;
  unsigned int _hj_i ;
  unsigned int _hj_j ;
  unsigned int _hj_k ;
  unsigned char const   *_hj_key ;
  unsigned int _hf_bkt ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  unsigned int _uthash_hastr_keylen ;
  size_t tmp___8 ;
  unsigned int _ha_hashv ;
  unsigned int _hj_i___0 ;
  unsigned int _hj_j___0 ;
  unsigned int _hj_k___0 ;
  unsigned char const   *_hj_key___0 ;
  void *tmp___9 ;
  void *tmp___10 ;
  unsigned int _ha_bkt ;
  UT_hash_bucket *_ha_head ;
  unsigned int _he_bkt ;
  unsigned int _he_bkt_i ;
  struct UT_hash_handle *_he_thh ;
  struct UT_hash_handle *_he_hh_nxt ;
  UT_hash_bucket *_he_new_buckets ;
  UT_hash_bucket *_he_newbkt ;
  void *tmp___11 ;
  unsigned int tmp___12 ;

  {
  dot = strchr((char const   *)glospec, '.');
  if (! dot) {
    log_error("glopeek_add: Malformed glospec: %s\n\n", glospec);
    usage(stderr, 1);
  }
  while (1) {
    tmp = strlen((char const   *)glospec);
    _uthash_hfstr_keylen = (unsigned int )tmp;
    while (1) {
      while (1) {
        while (1) {
          _hj_key = (unsigned char const   *)glospec;
          _hf_hashv = 4276993775U;
          _hj_j = 2654435769U;
          _hj_i = _hj_j;
          _hj_k = _uthash_hfstr_keylen;
          while (_hj_k >= 12U) {
            _hj_i += (((unsigned int )*(_hj_key + 0) + ((unsigned int )*(_hj_key + 1) << 8)) + ((unsigned int )*(_hj_key + 2) << 16)) + ((unsigned int )*(_hj_key + 3) << 24);
            _hj_j += (((unsigned int )*(_hj_key + 4) + ((unsigned int )*(_hj_key + 5) << 8)) + ((unsigned int )*(_hj_key + 6) << 16)) + ((unsigned int )*(_hj_key + 7) << 24);
            _hf_hashv += (((unsigned int )*(_hj_key + 8) + ((unsigned int )*(_hj_key + 9) << 8)) + ((unsigned int )*(_hj_key + 10) << 16)) + ((unsigned int )*(_hj_key + 11) << 24);
            while (1) {
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 13;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 8;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 13;
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 12;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 16;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 5;
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 3;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 10;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 15;
              break;
            }
            _hj_key += 12;
            _hj_k -= 12U;
          }
          _hf_hashv += _uthash_hfstr_keylen;
          switch (_hj_k) {
          case 11U: 
          _hf_hashv += (unsigned int )*(_hj_key + 10) << 24;
          case 10U: 
          _hf_hashv += (unsigned int )*(_hj_key + 9) << 16;
          case 9U: 
          _hf_hashv += (unsigned int )*(_hj_key + 8) << 8;
          case 8U: 
          _hj_j += (unsigned int )*(_hj_key + 7) << 24;
          case 7U: 
          _hj_j += (unsigned int )*(_hj_key + 6) << 16;
          case 6U: 
          _hj_j += (unsigned int )*(_hj_key + 5) << 8;
          case 5U: 
          _hj_j += (unsigned int )*(_hj_key + 4);
          case 4U: 
          _hj_i += (unsigned int )*(_hj_key + 3) << 24;
          case 3U: 
          _hj_i += (unsigned int )*(_hj_key + 2) << 16;
          case 2U: 
          _hj_i += (unsigned int )*(_hj_key + 1) << 8;
          case 1U: 
          _hj_i += (unsigned int )*(_hj_key + 0);
          }
          while (1) {
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 13;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 8;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 13;
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 12;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 16;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 5;
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 3;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 10;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 15;
            break;
          }
          break;
        }
        break;
      }
      while (1) {
        gentry = (glopeek_entry_t *)((void *)0);
        if (glopeek_map) {
          while (1) {
            _hf_bkt = _hf_hashv & ((glopeek_map->hh.tbl)->num_buckets - 1U);
            break;
          }
          while (1) {
            if ((unsigned long )((glopeek_map->hh.tbl)->buckets + _hf_bkt)->hh_head != (unsigned long )((void *)0)) {
              while (1) {
                gentry = (glopeek_entry_t *)((void *)((char *)((glopeek_map->hh.tbl)->buckets + _hf_bkt)->hh_head - (glopeek_map->hh.tbl)->hho));
                break;
              }
            } else {
              gentry = (glopeek_entry_t *)((void *)0);
            }
            while ((unsigned long )gentry != (unsigned long )((void *)0)) {
              if (gentry->hh.hashv == _hf_hashv) {
                if (gentry->hh.keylen == _uthash_hfstr_keylen) {
                  tmp___0 = memcmp((void const   *)gentry->hh.key, (void const   *)glospec,
                                   (size_t )_uthash_hfstr_keylen);
                  if (tmp___0 == 0) {
                    break;
                  }
                }
              }
              if ((unsigned long )gentry->hh.hh_next != (unsigned long )((void *)0)) {
                while (1) {
                  gentry = (glopeek_entry_t *)((void *)((char *)gentry->hh.hh_next - (glopeek_map->hh.tbl)->hho));
                  break;
                }
              } else {
                gentry = (glopeek_entry_t *)((void *)0);
              }
            }
            break;
          }
        }
        break;
      }
      break;
    }
    break;
  }
  if (gentry) {
    return;
  }
  tmp___6 = strncmp("post.", (char const   *)glospec, (size_t )(dot - glospec));
  if (tmp___6 == 0) {
    gloname = (char *)"_POST";
  } else {
    tmp___5 = strncmp("get.", (char const   *)glospec, (size_t )(dot - glospec));
    if (tmp___5 == 0) {
      gloname = (char *)"_GET";
    } else {
      tmp___4 = strncmp("cookie.", (char const   *)glospec, (size_t )(dot - glospec));
      if (tmp___4 == 0) {
        gloname = (char *)"_COOKIE";
      } else {
        tmp___3 = strncmp("server.", (char const   *)glospec, (size_t )(dot - glospec));
        if (tmp___3 == 0) {
          gloname = (char *)"_SERVER";
        } else {
          tmp___2 = strncmp("files.", (char const   *)glospec, (size_t )(dot - glospec));
          if (tmp___2 == 0) {
            gloname = (char *)"_FILES";
          } else {
            tmp___1 = strncmp("globals.", (char const   *)glospec, (size_t )(dot - glospec));
            if (tmp___1 == 0) {
              gloname = (char *)"";
            } else {
              log_error("glopeek_add: Invalid global: %s\n\n", glospec);
              usage(stderr, 1);
            }
          }
        }
      }
    }
  }
  tmp___7 = calloc((size_t )1, sizeof(glopeek_entry_t ));
  gentry = (glopeek_entry_t *)tmp___7;
  snprintf((char * __restrict  )(gentry->key), sizeof(gentry->key), (char const   * __restrict  )"%s",
           glospec);
  snprintf((char * __restrict  )(gentry->gloname), sizeof(gentry->gloname), (char const   * __restrict  )"%s",
           gloname);
  snprintf((char * __restrict  )(gentry->varname), sizeof(gentry->varname), (char const   * __restrict  )"%s",
           dot + 1);
  while (1) {
    tmp___8 = strlen((char const   *)(gentry->key));
    _uthash_hastr_keylen = (unsigned int )tmp___8;
    while (1) {
      while (1) {
        while (1) {
          _hj_key___0 = (unsigned char const   *)(& gentry->key[0]);
          _ha_hashv = 4276993775U;
          _hj_j___0 = 2654435769U;
          _hj_i___0 = _hj_j___0;
          _hj_k___0 = _uthash_hastr_keylen;
          while (_hj_k___0 >= 12U) {
            _hj_i___0 += (((unsigned int )*(_hj_key___0 + 0) + ((unsigned int )*(_hj_key___0 + 1) << 8)) + ((unsigned int )*(_hj_key___0 + 2) << 16)) + ((unsigned int )*(_hj_key___0 + 3) << 24);
            _hj_j___0 += (((unsigned int )*(_hj_key___0 + 4) + ((unsigned int )*(_hj_key___0 + 5) << 8)) + ((unsigned int )*(_hj_key___0 + 6) << 16)) + ((unsigned int )*(_hj_key___0 + 7) << 24);
            _ha_hashv += (((unsigned int )*(_hj_key___0 + 8) + ((unsigned int )*(_hj_key___0 + 9) << 8)) + ((unsigned int )*(_hj_key___0 + 10) << 16)) + ((unsigned int )*(_hj_key___0 + 11) << 24);
            while (1) {
              _hj_i___0 -= _hj_j___0;
              _hj_i___0 -= _ha_hashv;
              _hj_i___0 ^= _ha_hashv >> 13;
              _hj_j___0 -= _ha_hashv;
              _hj_j___0 -= _hj_i___0;
              _hj_j___0 ^= _hj_i___0 << 8;
              _ha_hashv -= _hj_i___0;
              _ha_hashv -= _hj_j___0;
              _ha_hashv ^= _hj_j___0 >> 13;
              _hj_i___0 -= _hj_j___0;
              _hj_i___0 -= _ha_hashv;
              _hj_i___0 ^= _ha_hashv >> 12;
              _hj_j___0 -= _ha_hashv;
              _hj_j___0 -= _hj_i___0;
              _hj_j___0 ^= _hj_i___0 << 16;
              _ha_hashv -= _hj_i___0;
              _ha_hashv -= _hj_j___0;
              _ha_hashv ^= _hj_j___0 >> 5;
              _hj_i___0 -= _hj_j___0;
              _hj_i___0 -= _ha_hashv;
              _hj_i___0 ^= _ha_hashv >> 3;
              _hj_j___0 -= _ha_hashv;
              _hj_j___0 -= _hj_i___0;
              _hj_j___0 ^= _hj_i___0 << 10;
              _ha_hashv -= _hj_i___0;
              _ha_hashv -= _hj_j___0;
              _ha_hashv ^= _hj_j___0 >> 15;
              break;
            }
            _hj_key___0 += 12;
            _hj_k___0 -= 12U;
          }
          _ha_hashv += _uthash_hastr_keylen;
          switch (_hj_k___0) {
          case 11U: 
          _ha_hashv += (unsigned int )*(_hj_key___0 + 10) << 24;
          case 10U: 
          _ha_hashv += (unsigned int )*(_hj_key___0 + 9) << 16;
          case 9U: 
          _ha_hashv += (unsigned int )*(_hj_key___0 + 8) << 8;
          case 8U: 
          _hj_j___0 += (unsigned int )*(_hj_key___0 + 7) << 24;
          case 7U: 
          _hj_j___0 += (unsigned int )*(_hj_key___0 + 6) << 16;
          case 6U: 
          _hj_j___0 += (unsigned int )*(_hj_key___0 + 5) << 8;
          case 5U: 
          _hj_j___0 += (unsigned int )*(_hj_key___0 + 4);
          case 4U: 
          _hj_i___0 += (unsigned int )*(_hj_key___0 + 3) << 24;
          case 3U: 
          _hj_i___0 += (unsigned int )*(_hj_key___0 + 2) << 16;
          case 2U: 
          _hj_i___0 += (unsigned int )*(_hj_key___0 + 1) << 8;
          case 1U: 
          _hj_i___0 += (unsigned int )*(_hj_key___0 + 0);
          }
          while (1) {
            _hj_i___0 -= _hj_j___0;
            _hj_i___0 -= _ha_hashv;
            _hj_i___0 ^= _ha_hashv >> 13;
            _hj_j___0 -= _ha_hashv;
            _hj_j___0 -= _hj_i___0;
            _hj_j___0 ^= _hj_i___0 << 8;
            _ha_hashv -= _hj_i___0;
            _ha_hashv -= _hj_j___0;
            _ha_hashv ^= _hj_j___0 >> 13;
            _hj_i___0 -= _hj_j___0;
            _hj_i___0 -= _ha_hashv;
            _hj_i___0 ^= _ha_hashv >> 12;
            _hj_j___0 -= _ha_hashv;
            _hj_j___0 -= _hj_i___0;
            _hj_j___0 ^= _hj_i___0 << 16;
            _ha_hashv -= _hj_i___0;
            _ha_hashv -= _hj_j___0;
            _ha_hashv ^= _hj_j___0 >> 5;
            _hj_i___0 -= _hj_j___0;
            _hj_i___0 -= _ha_hashv;
            _hj_i___0 ^= _ha_hashv >> 3;
            _hj_j___0 -= _ha_hashv;
            _hj_j___0 -= _hj_i___0;
            _hj_j___0 ^= _hj_i___0 << 10;
            _ha_hashv -= _hj_i___0;
            _ha_hashv -= _hj_j___0;
            _ha_hashv ^= _hj_j___0 >> 15;
            break;
          }
          break;
        }
        break;
      }
      while (1) {
        gentry->hh.hashv = _ha_hashv;
        gentry->hh.key = (void *)(& gentry->key[0]);
        gentry->hh.keylen = _uthash_hastr_keylen;
        if (! glopeek_map) {
          gentry->hh.next = (void *)0;
          gentry->hh.prev = (void *)0;
          while (1) {
            tmp___9 = malloc(sizeof(UT_hash_table ));
            gentry->hh.tbl = (UT_hash_table *)tmp___9;
            if (! gentry->hh.tbl) {
              exit(-1);
            } else {
              memset((void *)gentry->hh.tbl, '\000', sizeof(UT_hash_table ));
              (gentry->hh.tbl)->tail = & gentry->hh;
              (gentry->hh.tbl)->num_buckets = 32U;
              (gentry->hh.tbl)->log2_num_buckets = 5U;
              (gentry->hh.tbl)->hho = (char *)(& gentry->hh) - (char *)gentry;
              tmp___10 = malloc(32UL * sizeof(struct UT_hash_bucket ));
              (gentry->hh.tbl)->buckets = (UT_hash_bucket *)tmp___10;
              (gentry->hh.tbl)->signature = 2685476833U;
              if (! (gentry->hh.tbl)->buckets) {
                exit(-1);
                free((void *)gentry->hh.tbl);
              } else {
                memset((void *)(gentry->hh.tbl)->buckets, '\000', 32UL * sizeof(struct UT_hash_bucket ));
              }
            }
            break;
          }
          glopeek_map = gentry;
        } else {
          gentry->hh.tbl = glopeek_map->hh.tbl;
          while (1) {
            gentry->hh.next = (void *)0;
            gentry->hh.prev = (void *)((char *)(glopeek_map->hh.tbl)->tail - (glopeek_map->hh.tbl)->hho);
            ((glopeek_map->hh.tbl)->tail)->next = (void *)gentry;
            (glopeek_map->hh.tbl)->tail = & gentry->hh;
            break;
          }
        }
        while (1) {
          ((glopeek_map->hh.tbl)->num_items) ++;
          while (1) {
            _ha_bkt = _ha_hashv & ((glopeek_map->hh.tbl)->num_buckets - 1U);
            break;
          }
          while (1) {
            _ha_head = (glopeek_map->hh.tbl)->buckets + _ha_bkt;
            (_ha_head->count) ++;
            gentry->hh.hh_next = _ha_head->hh_head;
            gentry->hh.hh_prev = (struct UT_hash_handle *)((void *)0);
            if ((unsigned long )_ha_head->hh_head != (unsigned long )((void *)0)) {
              (_ha_head->hh_head)->hh_prev = & gentry->hh;
            }
            _ha_head->hh_head = & gentry->hh;
            if (_ha_head->count >= (_ha_head->expand_mult + 1U) * 10U) {
              if (! (gentry->hh.tbl)->noexpand) {
                while (1) {
                  tmp___11 = malloc((2UL * (unsigned long )(gentry->hh.tbl)->num_buckets) * sizeof(struct UT_hash_bucket ));
                  _he_new_buckets = (UT_hash_bucket *)tmp___11;
                  if (! _he_new_buckets) {
                    exit(-1);
                  } else {
                    memset((void *)_he_new_buckets, '\000', (2UL * (unsigned long )(gentry->hh.tbl)->num_buckets) * sizeof(struct UT_hash_bucket ));
                    if (((gentry->hh.tbl)->num_items & ((gentry->hh.tbl)->num_buckets * 2U - 1U)) != 0U) {
                      tmp___12 = 1U;
                    } else {
                      tmp___12 = 0U;
                    }
                    (gentry->hh.tbl)->ideal_chain_maxlen = ((gentry->hh.tbl)->num_items >> ((gentry->hh.tbl)->log2_num_buckets + 1U)) + tmp___12;
                    (gentry->hh.tbl)->nonideal_items = 0U;
                    _he_bkt_i = 0U;
                    while (_he_bkt_i < (gentry->hh.tbl)->num_buckets) {
                      _he_thh = ((gentry->hh.tbl)->buckets + _he_bkt_i)->hh_head;
                      while ((unsigned long )_he_thh != (unsigned long )((void *)0)) {
                        _he_hh_nxt = _he_thh->hh_next;
                        while (1) {
                          _he_bkt = _he_thh->hashv & ((gentry->hh.tbl)->num_buckets * 2U - 1U);
                          break;
                        }
                        _he_newbkt = _he_new_buckets + _he_bkt;
                        (_he_newbkt->count) ++;
                        if (_he_newbkt->count > (gentry->hh.tbl)->ideal_chain_maxlen) {
                          ((gentry->hh.tbl)->nonideal_items) ++;
                          _he_newbkt->expand_mult = _he_newbkt->count / (gentry->hh.tbl)->ideal_chain_maxlen;
                        }
                        _he_thh->hh_prev = (struct UT_hash_handle *)((void *)0);
                        _he_thh->hh_next = _he_newbkt->hh_head;
                        if ((unsigned long )_he_newbkt->hh_head != (unsigned long )((void *)0)) {
                          (_he_newbkt->hh_head)->hh_prev = _he_thh;
                        }
                        _he_newbkt->hh_head = _he_thh;
                        _he_thh = _he_hh_nxt;
                      }
                      _he_bkt_i ++;
                    }
                    free((void *)(gentry->hh.tbl)->buckets);
                    (gentry->hh.tbl)->num_buckets *= 2U;
                    ((gentry->hh.tbl)->log2_num_buckets) ++;
                    (gentry->hh.tbl)->buckets = _he_new_buckets;
                    if ((gentry->hh.tbl)->nonideal_items > (gentry->hh.tbl)->num_items >> 1) {
                      ((gentry->hh.tbl)->ineff_expands) ++;
                    } else {
                      (gentry->hh.tbl)->ineff_expands = 0U;
                    }
                    if ((gentry->hh.tbl)->ineff_expands > 1U) {
                      (gentry->hh.tbl)->noexpand = 1U;
                    }
                  }
                  break;
                }
              }
            }
            break;
          }
          break;
        }
        break;
      }
      break;
    }
    break;
  }
  return;
}
}
static int copy_proc_mem(pid_t pid , char const   *what , void *raddr , void *laddr ,
                         size_t size ) 
{ 
  struct iovec local[1] ;
  struct iovec remote[1] ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  ssize_t tmp___2 ;

  {
  if ((unsigned long )raddr == (unsigned long )((void *)0)) {
    log_error("copy_proc_mem: Not copying %s; raddr is NULL\n", what);
    return (1);
  }
  local[0].iov_base = laddr;
  local[0].iov_len = size;
  remote[0].iov_base = raddr;
  remote[0].iov_len = size;
  tmp___2 = process_vm_readv(pid, (struct iovec  const  *)(local), 1UL, (struct iovec  const  *)(remote),
                             1UL, 0UL);
  if (tmp___2 == -1L) {
    tmp = __errno_location();
    if (*tmp == 3) {
      perror("process_vm_readv");
      return (3);
    }
    tmp___0 = __errno_location();
    tmp___1 = strerror(*tmp___0);
    log_error("copy_proc_mem: Failed to copy %s; err=%s raddr=%p size=%lu\n", what,
              tmp___1, raddr, size);
    return (1);
  }
  return (0);
}
}
static int get_php_version(trace_target_t *target ) 
{ 
  struct _zend_module_entry basic_functions_module ;
  char version_cmd[1024] ;
  char phpv[4] ;
  pid_t pid ;
  FILE *pcmd ;
  int tmp ;
  int n ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  pid = target->pid;
  phpv[0] = (char )'\000';
  if (target->basic_functions_module_addr) {
    tmp = copy_proc_mem(pid, "basic_functions_module", (void *)target->basic_functions_module_addr,
                        (void *)(& basic_functions_module), sizeof(basic_functions_module));
    if (tmp == 0) {
      copy_proc_mem(pid, "basic_functions_module.version", (void *)basic_functions_module.version,
                    (void *)(phpv), (size_t )3);
    }
  }
  if ((int )phpv[0] == 0) {
    tmp___0 = snprintf((char * __restrict  )(version_cmd), sizeof(version_cmd), (char const   * __restrict  )"{ echo -n /proc/%d/root/;   awk -ve=1 \'/libphp[78]?/{print $NF; e=0; exit} END{exit e}\' /proc/%d/maps   || readlink /proc/%d/exe; } | { xargs stat --printf=%%n 2>/dev/null || echo /proc/%d/exe; } | xargs strings | grep -Po \'(?<=X-Powered-By: PHP/)\\d\\.\\d\'",
                       pid, pid, pid, pid);
    n = tmp___0;
    if ((size_t )n >= sizeof(version_cmd) - 1UL) {
      log_error("get_php_version: snprintf overflow\n");
      return (1);
    }
    pcmd = popen((char const   *)(version_cmd), "r");
    if ((unsigned long )pcmd == (unsigned long )((void *)0)) {
      perror("get_php_version: popen");
      return (1);
    } else {
      tmp___1 = fread((void * __restrict  )(& phpv), sizeof(char ), (size_t )3, (FILE * __restrict  )pcmd);
      if (tmp___1 != 3UL) {
        log_error("get_php_version: Could not detect PHP version\n");
        pclose(pcmd);
        return (1);
      }
    }
    pclose(pcmd);
  }
  tmp___9 = strncmp((char const   *)(phpv), "7.0", (size_t )3);
  if (tmp___9 == 0) {
    opt_phpv = (char *)"70";
  } else {
    tmp___8 = strncmp((char const   *)(phpv), "7.1", (size_t )3);
    if (tmp___8 == 0) {
      opt_phpv = (char *)"71";
    } else {
      tmp___7 = strncmp((char const   *)(phpv), "7.2", (size_t )3);
      if (tmp___7 == 0) {
        opt_phpv = (char *)"72";
      } else {
        tmp___6 = strncmp((char const   *)(phpv), "7.3", (size_t )3);
        if (tmp___6 == 0) {
          opt_phpv = (char *)"73";
        } else {
          tmp___5 = strncmp((char const   *)(phpv), "7.4", (size_t )3);
          if (tmp___5 == 0) {
            opt_phpv = (char *)"74";
          } else {
            tmp___4 = strncmp((char const   *)(phpv), "8.0", (size_t )3);
            if (tmp___4 == 0) {
              opt_phpv = (char *)"80";
            } else {
              tmp___3 = strncmp((char const   *)(phpv), "8.1", (size_t )3);
              if (tmp___3 == 0) {
                opt_phpv = (char *)"81";
              } else {
                tmp___2 = strncmp((char const   *)(phpv), "8.2", (size_t )3);
                if (tmp___2 == 0) {
                  opt_phpv = (char *)"82";
                } else {
                  log_error("get_php_version: Unrecognized PHP version (%s)\n", phpv);
                  return (1);
                }
              }
            }
          }
        }
      }
    }
  }
  return (0);
}
}
uint64_t phpspy_zend_inline_hash_func(char const   *str , size_t len ) 
{ 
  uint64_t hash ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;

  {
  hash = 5381UL;
  while (len >= 8UL) {
    tmp = str;
    str ++;
    hash = ((hash << 5) + hash) + (uint64_t )*tmp;
    tmp___0 = str;
    str ++;
    hash = ((hash << 5) + hash) + (uint64_t )*tmp___0;
    tmp___1 = str;
    str ++;
    hash = ((hash << 5) + hash) + (uint64_t )*tmp___1;
    tmp___2 = str;
    str ++;
    hash = ((hash << 5) + hash) + (uint64_t )*tmp___2;
    tmp___3 = str;
    str ++;
    hash = ((hash << 5) + hash) + (uint64_t )*tmp___3;
    tmp___4 = str;
    str ++;
    hash = ((hash << 5) + hash) + (uint64_t )*tmp___4;
    tmp___5 = str;
    str ++;
    hash = ((hash << 5) + hash) + (uint64_t )*tmp___5;
    tmp___6 = str;
    str ++;
    hash = ((hash << 5) + hash) + (uint64_t )*tmp___6;
    len -= 8UL;
  }
  switch (len) {
  case 7UL: 
  tmp___7 = str;
  str ++;
  hash = ((hash << 5) + hash) + (uint64_t )*tmp___7;
  case 6UL: 
  tmp___8 = str;
  str ++;
  hash = ((hash << 5) + hash) + (uint64_t )*tmp___8;
  case 5UL: 
  tmp___9 = str;
  str ++;
  hash = ((hash << 5) + hash) + (uint64_t )*tmp___9;
  case 4UL: 
  tmp___10 = str;
  str ++;
  hash = ((hash << 5) + hash) + (uint64_t )*tmp___10;
  case 3UL: 
  tmp___11 = str;
  str ++;
  hash = ((hash << 5) + hash) + (uint64_t )*tmp___11;
  case 2UL: 
  tmp___12 = str;
  str ++;
  hash = ((hash << 5) + hash) + (uint64_t )*tmp___12;
  case 1UL: 
  tmp___13 = str;
  str ++;
  hash = ((hash << 5) + hash) + (uint64_t )*tmp___13;
  break;
  case 0UL: 
  break;
  }
  return (hash | 9223372036854775808);
}
}
void log_error(char const   *fmt  , ...) 
{ 
  va_list___0 args ;

  {
  if (log_error_enabled) {
    __builtin_va_start(args, fmt);
    vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )fmt, args);
  }
  return;
}
}
static int trace_stack_70(trace_context_t *context , zend_execute_data_70 *remote_execute_data ,
                          int *depth ) ;
static int trace_request_info_70(trace_context_t *context ) ;
static int trace_memory_info_70(trace_context_t *context ) ;
static int trace_globals_70(trace_context_t *context ) ;
static int trace_locals_70(trace_context_t *context , zend_op_70 *zop , zend_execute_data_70 *remote_execute_data ,
                           zend_op_array_70 *op_array , char *file , int file_len ) ;
static int copy_executor_globals_70(trace_context_t *context , zend_executor_globals_70 *executor_globals ) ;
static int copy_zarray_bucket_70(trace_context_t *context , zend_array_70 *rzarray ,
                                 char const   *key , Bucket_70 *lbucket ) ;
static int sprint_zstring_70(trace_context_t *context , char const   *what , zend_string_70 *rzstring ,
                             char *buf___0 , size_t buf_size , size_t *buf_len___0 ) ;
static int sprint_zval_70(trace_context_t *context , zval_70 *lzval , char *buf___0 ,
                          size_t buf_size , size_t *buf_len___0 ) ;
static int sprint_zarray_70(trace_context_t *context , zend_array_70 *rzarray , char *buf___0 ,
                            size_t buf_size , size_t *buf_len___0 ) ;
static int sprint_zarray_val70(trace_context_t *context , zend_array_70 *rzarray ,
                               char const   *key , char *buf___0 , size_t buf_size ,
                               size_t *buf_len___0 ) ;
static int sprint_zarray_bucket_70(trace_context_t *context , Bucket_70 *lbucket ,
                                   char *buf___0 , size_t buf_size , size_t *buf_len___0 ) ;
static int do_trace_70(trace_context_t *context ) 
{ 
  int rv ;
  int depth ;
  zend_executor_globals_70 executor_globals ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;

  {
  while (1) {
    rv = copy_executor_globals_70(context, & executor_globals);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = (*(context->event_handler))(context, 1);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  rv = 0;
  while (1) {
    tmp = trace_stack_70(context, executor_globals.current_execute_data, & depth);
    rv |= tmp;
    while (1) {
      if ((rv & 2) != 0) {
        break;
      } else
      if ((rv & 4) != 0) {
        break;
      } else
      if (! opt_continue_on_error) {
        break;
      }
      break;
    }
    if (depth < 1) {
      break;
    }
    if (opt_capture_req) {
      tmp___0 = trace_request_info_70(context);
      rv |= tmp___0;
      while (1) {
        if ((rv & 2) != 0) {
          break;
        } else
        if ((rv & 4) != 0) {
          break;
        } else
        if (! opt_continue_on_error) {
          break;
        }
        break;
      }
    }
    if (opt_capture_mem) {
      tmp___1 = trace_memory_info_70(context);
      rv |= tmp___1;
      while (1) {
        if ((rv & 2) != 0) {
          break;
        } else
        if ((rv & 4) != 0) {
          break;
        } else
        if (! opt_continue_on_error) {
          break;
        }
        break;
      }
    }
    if ((unsigned long )glopeek_map != (unsigned long )((void *)0)) {
      tmp___3 = (glopeek_map->hh.tbl)->num_items;
    } else {
      tmp___3 = 0U;
    }
    if (tmp___3 > 0U) {
      tmp___2 = trace_globals_70(context);
      rv |= tmp___2;
      while (1) {
        if ((rv & 2) != 0) {
          break;
        } else
        if ((rv & 4) != 0) {
          break;
        } else
        if (! opt_continue_on_error) {
          break;
        }
        break;
      }
    }
    break;
  }
  if (rv == 0) {
    goto _L;
  } else
  if (opt_continue_on_error) {
    _L: /* CIL Label */ 
    while (1) {
      rv = (*(context->event_handler))(context, 7);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
  }
  return (0);
}
}
static int trace_stack_70(trace_context_t *context , zend_execute_data_70 *remote_execute_data ,
                          int *depth ) 
{ 
  int rv ;
  zend_execute_data_70 execute_data ;
  zend_function_70 zfunc ;
  zend_string_70 zstring ;
  zend_class_entry_70 zce ;
  zend_op_70 zop ;
  trace_target_t *target ;
  trace_frame_t *frame ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
  target = & context->target;
  frame = & context->event.frame;
  *depth = 0;
  while (1) {
    if (remote_execute_data) {
      if (! (*depth != opt_max_stack_depth)) {
        break;
      }
    } else {
      break;
    }
    memset((void *)(& execute_data), 0, sizeof(execute_data));
    memset((void *)(& zfunc), 0, sizeof(zfunc));
    memset((void *)(& zstring), 0, sizeof(zstring));
    memset((void *)(& zce), 0, sizeof(zce));
    memset((void *)(& zop), 0, sizeof(zop));
    while (1) {
      rv = copy_proc_mem(context->target.pid, "execute_data", (void *)remote_execute_data,
                         (void *)(& execute_data), sizeof(execute_data));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    while (1) {
      rv = copy_proc_mem(context->target.pid, "zfunc", (void *)execute_data.func,
                         (void *)(& zfunc), sizeof(zfunc));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    if (zfunc.common.function_name) {
      while (1) {
        rv = sprint_zstring_70(context, "function_name", zfunc.common.function_name,
                               frame->loc.func, sizeof(frame->loc.func), & frame->loc.func_len);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
    } else {
      tmp = snprintf((char * __restrict  )(frame->loc.func), sizeof(frame->loc.func),
                     (char const   * __restrict  )"<main>");
      frame->loc.func_len = (size_t )tmp;
    }
    if (zfunc.common.scope) {
      while (1) {
        rv = copy_proc_mem(context->target.pid, "zce", (void *)zfunc.common.scope,
                           (void *)(& zce), sizeof(zce));
        if (rv != 0) {
          return (rv);
        }
        break;
      }
      while (1) {
        rv = sprint_zstring_70(context, "class_name", zce.name, frame->loc.class,
                               sizeof(frame->loc.class), & frame->loc.class_len);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
    } else {
      frame->loc.class[0] = (char )'\000';
      frame->loc.class_len = (size_t )0;
    }
    if ((int )zfunc.type == 2) {
      while (1) {
        rv = sprint_zstring_70(context, "filename", zfunc.op_array.filename, frame->loc.file,
                               sizeof(frame->loc.file), & frame->loc.file_len);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
      frame->loc.lineno = (int )zfunc.op_array.line_start;
      if ((unsigned long )varpeek_map != (unsigned long )((void *)0)) {
        tmp___1 = (varpeek_map->hh.tbl)->num_items;
      } else {
        tmp___1 = 0U;
      }
      if (tmp___1 > 0U) {
        tmp___0 = copy_proc_mem(target->pid, "opline", (void *)execute_data.opline,
                                (void *)(& zop), sizeof(zop));
        if (tmp___0 == 0) {
          trace_locals_70(context, & zop, remote_execute_data, & zfunc.op_array, frame->loc.file,
                          (int )frame->loc.file_len);
        }
      }
    } else {
      tmp___2 = snprintf((char * __restrict  )(frame->loc.file), sizeof(frame->loc.file),
                         (char const   * __restrict  )"<internal>");
      frame->loc.file_len = (size_t )tmp___2;
      frame->loc.lineno = -1;
    }
    frame->depth = *depth;
    while (1) {
      rv = (*(context->event_handler))(context, 2);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    remote_execute_data = execute_data.prev_execute_data;
    (*depth) ++;
  }
  return (0);
}
}
static int trace_request_info_70(trace_context_t *context ) 
{ 
  int rv ;
  sapi_globals_struct_70 sapi_globals ;
  trace_target_t *target ;
  trace_request_t *request ;

  {
  memset((void *)(& sapi_globals), 0, sizeof(sapi_globals));
  request = & context->event.request;
  target = & context->target;
  while (1) {
    rv = copy_proc_mem(context->target.pid, "sapi_globals", (void *)target->sapi_globals_addr,
                       (void *)(& sapi_globals), sizeof(sapi_globals));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    if (opt_capture_req_qstring) {
      if (sapi_globals.request_info.query_string) {
        while (1) {
          rv = copy_proc_mem(context->target.pid, "query_string", (void *)sapi_globals.request_info.query_string,
                             (void *)(request->qstring), (size_t )256);
          if (rv != 0) {
            return (rv);
          }
          break;
        }
      } else {
        request->qstring[0] = (char )'-';
        request->qstring[1] = (char )'\000';
      }
    } else {
      request->qstring[0] = (char )'-';
      request->qstring[1] = (char )'\000';
    }
    break;
  }
  while (1) {
    if (opt_capture_req_cookie) {
      if (sapi_globals.request_info.cookie_data) {
        while (1) {
          rv = copy_proc_mem(context->target.pid, "cookie_data", (void *)sapi_globals.request_info.cookie_data,
                             (void *)(request->cookie), (size_t )256);
          if (rv != 0) {
            return (rv);
          }
          break;
        }
      } else {
        request->cookie[0] = (char )'-';
        request->cookie[1] = (char )'\000';
      }
    } else {
      request->cookie[0] = (char )'-';
      request->cookie[1] = (char )'\000';
    }
    break;
  }
  while (1) {
    if (opt_capture_req_uri) {
      if (sapi_globals.request_info.request_uri) {
        while (1) {
          rv = copy_proc_mem(context->target.pid, "request_uri", (void *)sapi_globals.request_info.request_uri,
                             (void *)(request->uri), (size_t )256);
          if (rv != 0) {
            return (rv);
          }
          break;
        }
      } else {
        request->uri[0] = (char )'-';
        request->uri[1] = (char )'\000';
      }
    } else {
      request->uri[0] = (char )'-';
      request->uri[1] = (char )'\000';
    }
    break;
  }
  while (1) {
    if (opt_capture_req_path) {
      if (sapi_globals.request_info.path_translated) {
        while (1) {
          rv = copy_proc_mem(context->target.pid, "path_translated", (void *)sapi_globals.request_info.path_translated,
                             (void *)(request->path), (size_t )256);
          if (rv != 0) {
            return (rv);
          }
          break;
        }
      } else {
        request->path[0] = (char )'-';
        request->path[1] = (char )'\000';
      }
    } else {
      request->path[0] = (char )'-';
      request->path[1] = (char )'\000';
    }
    break;
  }
  request->ts = sapi_globals.global_request_time;
  while (1) {
    rv = (*(context->event_handler))(context, 5);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  return (0);
}
}
static int trace_memory_info_70(trace_context_t *context ) 
{ 
  int rv ;
  zend_mm_heap_70 mm_heap ;
  zend_alloc_globals_70 alloc_globals ;
  trace_target_t *target ;

  {
  memset((void *)(& mm_heap), 0, sizeof(mm_heap));
  alloc_globals.mm_heap = (zend_mm_heap_70 *)((void *)0);
  target = & context->target;
  while (1) {
    rv = copy_proc_mem(context->target.pid, "alloc_globals", (void *)target->alloc_globals_addr,
                       (void *)(& alloc_globals), sizeof(alloc_globals));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = copy_proc_mem(context->target.pid, "mm_heap", (void *)alloc_globals.mm_heap,
                       (void *)(& mm_heap), sizeof(mm_heap));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  context->event.mem.size = mm_heap.size;
  context->event.mem.peak = mm_heap.peak;
  while (1) {
    rv = (*(context->event_handler))(context, 6);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  return (0);
}
}
static int trace_globals_70(trace_context_t *context ) 
{ 
  int rv ;
  glopeek_entry_t *gentry ;
  glopeek_entry_t *gentry_tmp ;
  zend_array_70 *garray ;
  zend_array_70 *symtable ;
  Bucket_70 lbucket ;
  void *tmp ;
  void *tmp___0 ;

  {
  symtable = (zend_array_70 *)(context->target.executor_globals_addr + (unsigned long )(& ((zend_executor_globals_70 *)0)->symbol_table));
  gentry = glopeek_map;
  if ((unsigned long )glopeek_map != (unsigned long )((void *)0)) {
    tmp = glopeek_map->hh.next;
  } else {
    tmp = (void *)0;
  }
  gentry_tmp = (glopeek_entry_t *)tmp;
  while ((unsigned long )gentry != (unsigned long )((void *)0)) {
    if (gentry->gloname[0]) {
      while (1) {
        rv = copy_zarray_bucket_70(context, symtable, (char const   *)(gentry->gloname),
                                   & lbucket);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
      garray = lbucket.val.value.arr;
    } else {
      garray = symtable;
    }
    rv = sprint_zarray_val70(context, garray, (char const   *)(gentry->varname), context->buf,
                             sizeof(context->buf), & context->buf_len);
    if (rv == 0) {
      context->event.glopeek.gentry = gentry;
      context->event.glopeek.zval_str = context->buf;
      while (1) {
        rv = (*(context->event_handler))(context, 4);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
    }
    gentry = gentry_tmp;
    if ((unsigned long )gentry_tmp != (unsigned long )((void *)0)) {
      tmp___0 = gentry_tmp->hh.next;
    } else {
      tmp___0 = (void *)0;
    }
    gentry_tmp = (glopeek_entry_t *)tmp___0;
  }
  return (0);
}
}
static int trace_locals_70(trace_context_t *context , zend_op_70 *zop , zend_execute_data_70 *remote_execute_data ,
                           zend_op_array_70 *op_array , char *file , int file_len ) 
{ 
  int rv ;
  int i ;
  int num_vars_found ;
  int num_vars_peeking ;
  char tmp[256] ;
  size_t tmp_len ;
  zend_string_70 *zstrp ;
  varpeek_entry_t *entry ;
  varpeek_var_t *var ;
  char varpeek_key[256] ;
  zval_70 zv ;
  unsigned int _uthash_hfstr_keylen ;
  size_t tmp___0 ;
  unsigned int _hf_hashv ;
  unsigned int _hj_i ;
  unsigned int _hj_j ;
  unsigned int _hj_k ;
  unsigned char const   *_hj_key ;
  unsigned int _hf_bkt ;
  int tmp___1 ;
  unsigned int _hf_hashv___0 ;
  unsigned int _hj_i___0 ;
  unsigned int _hj_j___0 ;
  unsigned int _hj_k___0 ;
  unsigned char const   *_hj_key___0 ;
  unsigned int _hf_bkt___0 ;
  int tmp___2 ;

  {
  snprintf((char * __restrict  )(varpeek_key), sizeof(varpeek_key), (char const   * __restrict  )"%.*s:%d",
           file_len, file, zop->lineno);
  while (1) {
    tmp___0 = strlen((char const   *)(varpeek_key));
    _uthash_hfstr_keylen = (unsigned int )tmp___0;
    while (1) {
      while (1) {
        while (1) {
          _hj_key = (unsigned char const   *)(varpeek_key);
          _hf_hashv = 4276993775U;
          _hj_j = 2654435769U;
          _hj_i = _hj_j;
          _hj_k = _uthash_hfstr_keylen;
          while (_hj_k >= 12U) {
            _hj_i += (((unsigned int )*(_hj_key + 0) + ((unsigned int )*(_hj_key + 1) << 8)) + ((unsigned int )*(_hj_key + 2) << 16)) + ((unsigned int )*(_hj_key + 3) << 24);
            _hj_j += (((unsigned int )*(_hj_key + 4) + ((unsigned int )*(_hj_key + 5) << 8)) + ((unsigned int )*(_hj_key + 6) << 16)) + ((unsigned int )*(_hj_key + 7) << 24);
            _hf_hashv += (((unsigned int )*(_hj_key + 8) + ((unsigned int )*(_hj_key + 9) << 8)) + ((unsigned int )*(_hj_key + 10) << 16)) + ((unsigned int )*(_hj_key + 11) << 24);
            while (1) {
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 13;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 8;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 13;
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 12;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 16;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 5;
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 3;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 10;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 15;
              break;
            }
            _hj_key += 12;
            _hj_k -= 12U;
          }
          _hf_hashv += _uthash_hfstr_keylen;
          switch (_hj_k) {
          case 11U: 
          _hf_hashv += (unsigned int )*(_hj_key + 10) << 24;
          case 10U: 
          _hf_hashv += (unsigned int )*(_hj_key + 9) << 16;
          case 9U: 
          _hf_hashv += (unsigned int )*(_hj_key + 8) << 8;
          case 8U: 
          _hj_j += (unsigned int )*(_hj_key + 7) << 24;
          case 7U: 
          _hj_j += (unsigned int )*(_hj_key + 6) << 16;
          case 6U: 
          _hj_j += (unsigned int )*(_hj_key + 5) << 8;
          case 5U: 
          _hj_j += (unsigned int )*(_hj_key + 4);
          case 4U: 
          _hj_i += (unsigned int )*(_hj_key + 3) << 24;
          case 3U: 
          _hj_i += (unsigned int )*(_hj_key + 2) << 16;
          case 2U: 
          _hj_i += (unsigned int )*(_hj_key + 1) << 8;
          case 1U: 
          _hj_i += (unsigned int )*(_hj_key + 0);
          }
          while (1) {
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 13;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 8;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 13;
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 12;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 16;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 5;
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 3;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 10;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 15;
            break;
          }
          break;
        }
        break;
      }
      while (1) {
        entry = (varpeek_entry_t *)((void *)0);
        if (varpeek_map) {
          while (1) {
            _hf_bkt = _hf_hashv & ((varpeek_map->hh.tbl)->num_buckets - 1U);
            break;
          }
          while (1) {
            if ((unsigned long )((varpeek_map->hh.tbl)->buckets + _hf_bkt)->hh_head != (unsigned long )((void *)0)) {
              while (1) {
                entry = (varpeek_entry_t *)((void *)((char *)((varpeek_map->hh.tbl)->buckets + _hf_bkt)->hh_head - (varpeek_map->hh.tbl)->hho));
                break;
              }
            } else {
              entry = (varpeek_entry_t *)((void *)0);
            }
            while ((unsigned long )entry != (unsigned long )((void *)0)) {
              if (entry->hh.hashv == _hf_hashv) {
                if (entry->hh.keylen == _uthash_hfstr_keylen) {
                  tmp___1 = memcmp((void const   *)entry->hh.key, (void const   *)(varpeek_key),
                                   (size_t )_uthash_hfstr_keylen);
                  if (tmp___1 == 0) {
                    break;
                  }
                }
              }
              if ((unsigned long )entry->hh.hh_next != (unsigned long )((void *)0)) {
                while (1) {
                  entry = (varpeek_entry_t *)((void *)((char *)entry->hh.hh_next - (varpeek_map->hh.tbl)->hho));
                  break;
                }
              } else {
                entry = (varpeek_entry_t *)((void *)0);
              }
            }
            break;
          }
        }
        break;
      }
      break;
    }
    break;
  }
  if (! entry) {
    return (0);
  }
  num_vars_found = 0;
  if ((unsigned long )entry->varmap != (unsigned long )((void *)0)) {
    num_vars_peeking = (int )((entry->varmap)->hh.tbl)->num_items;
  } else {
    num_vars_peeking = 0;
  }
  i = 0;
  while (i < op_array->last_var) {
    while (1) {
      rv = copy_proc_mem(context->target.pid, "var", (void *)(op_array->vars + i),
                         (void *)(& zstrp), sizeof(zstrp));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    while (1) {
      rv = sprint_zstring_70(context, "var", zstrp, tmp, sizeof(tmp), & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    while (1) {
      while (1) {
        while (1) {
          _hj_key___0 = (unsigned char const   *)(tmp);
          _hf_hashv___0 = 4276993775U;
          _hj_j___0 = 2654435769U;
          _hj_i___0 = _hj_j___0;
          _hj_k___0 = (unsigned int )tmp_len;
          while (_hj_k___0 >= 12U) {
            _hj_i___0 += (((unsigned int )*(_hj_key___0 + 0) + ((unsigned int )*(_hj_key___0 + 1) << 8)) + ((unsigned int )*(_hj_key___0 + 2) << 16)) + ((unsigned int )*(_hj_key___0 + 3) << 24);
            _hj_j___0 += (((unsigned int )*(_hj_key___0 + 4) + ((unsigned int )*(_hj_key___0 + 5) << 8)) + ((unsigned int )*(_hj_key___0 + 6) << 16)) + ((unsigned int )*(_hj_key___0 + 7) << 24);
            _hf_hashv___0 += (((unsigned int )*(_hj_key___0 + 8) + ((unsigned int )*(_hj_key___0 + 9) << 8)) + ((unsigned int )*(_hj_key___0 + 10) << 16)) + ((unsigned int )*(_hj_key___0 + 11) << 24);
            while (1) {
              _hj_i___0 -= _hj_j___0;
              _hj_i___0 -= _hf_hashv___0;
              _hj_i___0 ^= _hf_hashv___0 >> 13;
              _hj_j___0 -= _hf_hashv___0;
              _hj_j___0 -= _hj_i___0;
              _hj_j___0 ^= _hj_i___0 << 8;
              _hf_hashv___0 -= _hj_i___0;
              _hf_hashv___0 -= _hj_j___0;
              _hf_hashv___0 ^= _hj_j___0 >> 13;
              _hj_i___0 -= _hj_j___0;
              _hj_i___0 -= _hf_hashv___0;
              _hj_i___0 ^= _hf_hashv___0 >> 12;
              _hj_j___0 -= _hf_hashv___0;
              _hj_j___0 -= _hj_i___0;
              _hj_j___0 ^= _hj_i___0 << 16;
              _hf_hashv___0 -= _hj_i___0;
              _hf_hashv___0 -= _hj_j___0;
              _hf_hashv___0 ^= _hj_j___0 >> 5;
              _hj_i___0 -= _hj_j___0;
              _hj_i___0 -= _hf_hashv___0;
              _hj_i___0 ^= _hf_hashv___0 >> 3;
              _hj_j___0 -= _hf_hashv___0;
              _hj_j___0 -= _hj_i___0;
              _hj_j___0 ^= _hj_i___0 << 10;
              _hf_hashv___0 -= _hj_i___0;
              _hf_hashv___0 -= _hj_j___0;
              _hf_hashv___0 ^= _hj_j___0 >> 15;
              break;
            }
            _hj_key___0 += 12;
            _hj_k___0 -= 12U;
          }
          _hf_hashv___0 += (unsigned int )tmp_len;
          switch (_hj_k___0) {
          case 11U: 
          _hf_hashv___0 += (unsigned int )*(_hj_key___0 + 10) << 24;
          case 10U: 
          _hf_hashv___0 += (unsigned int )*(_hj_key___0 + 9) << 16;
          case 9U: 
          _hf_hashv___0 += (unsigned int )*(_hj_key___0 + 8) << 8;
          case 8U: 
          _hj_j___0 += (unsigned int )*(_hj_key___0 + 7) << 24;
          case 7U: 
          _hj_j___0 += (unsigned int )*(_hj_key___0 + 6) << 16;
          case 6U: 
          _hj_j___0 += (unsigned int )*(_hj_key___0 + 5) << 8;
          case 5U: 
          _hj_j___0 += (unsigned int )*(_hj_key___0 + 4);
          case 4U: 
          _hj_i___0 += (unsigned int )*(_hj_key___0 + 3) << 24;
          case 3U: 
          _hj_i___0 += (unsigned int )*(_hj_key___0 + 2) << 16;
          case 2U: 
          _hj_i___0 += (unsigned int )*(_hj_key___0 + 1) << 8;
          case 1U: 
          _hj_i___0 += (unsigned int )*(_hj_key___0 + 0);
          }
          while (1) {
            _hj_i___0 -= _hj_j___0;
            _hj_i___0 -= _hf_hashv___0;
            _hj_i___0 ^= _hf_hashv___0 >> 13;
            _hj_j___0 -= _hf_hashv___0;
            _hj_j___0 -= _hj_i___0;
            _hj_j___0 ^= _hj_i___0 << 8;
            _hf_hashv___0 -= _hj_i___0;
            _hf_hashv___0 -= _hj_j___0;
            _hf_hashv___0 ^= _hj_j___0 >> 13;
            _hj_i___0 -= _hj_j___0;
            _hj_i___0 -= _hf_hashv___0;
            _hj_i___0 ^= _hf_hashv___0 >> 12;
            _hj_j___0 -= _hf_hashv___0;
            _hj_j___0 -= _hj_i___0;
            _hj_j___0 ^= _hj_i___0 << 16;
            _hf_hashv___0 -= _hj_i___0;
            _hf_hashv___0 -= _hj_j___0;
            _hf_hashv___0 ^= _hj_j___0 >> 5;
            _hj_i___0 -= _hj_j___0;
            _hj_i___0 -= _hf_hashv___0;
            _hj_i___0 ^= _hf_hashv___0 >> 3;
            _hj_j___0 -= _hf_hashv___0;
            _hj_j___0 -= _hj_i___0;
            _hj_j___0 ^= _hj_i___0 << 10;
            _hf_hashv___0 -= _hj_i___0;
            _hf_hashv___0 -= _hj_j___0;
            _hf_hashv___0 ^= _hj_j___0 >> 15;
            break;
          }
          break;
        }
        break;
      }
      while (1) {
        var = (varpeek_var_t *)((void *)0);
        if (entry->varmap) {
          while (1) {
            _hf_bkt___0 = _hf_hashv___0 & (((entry->varmap)->hh.tbl)->num_buckets - 1U);
            break;
          }
          while (1) {
            if ((unsigned long )(((entry->varmap)->hh.tbl)->buckets + _hf_bkt___0)->hh_head != (unsigned long )((void *)0)) {
              while (1) {
                var = (varpeek_var_t *)((void *)((char *)(((entry->varmap)->hh.tbl)->buckets + _hf_bkt___0)->hh_head - ((entry->varmap)->hh.tbl)->hho));
                break;
              }
            } else {
              var = (varpeek_var_t *)((void *)0);
            }
            while ((unsigned long )var != (unsigned long )((void *)0)) {
              if (var->hh.hashv == _hf_hashv___0) {
                if ((size_t )var->hh.keylen == tmp_len) {
                  tmp___2 = memcmp((void const   *)var->hh.key, (void const   *)(tmp),
                                   tmp_len);
                  if (tmp___2 == 0) {
                    break;
                  }
                }
              }
              if ((unsigned long )var->hh.hh_next != (unsigned long )((void *)0)) {
                while (1) {
                  var = (varpeek_var_t *)((void *)((char *)var->hh.hh_next - ((entry->varmap)->hh.tbl)->hho));
                  break;
                }
              } else {
                var = (varpeek_var_t *)((void *)0);
              }
            }
            break;
          }
        }
        break;
      }
      break;
    }
    if (! var) {
      goto __Cont;
    }
    num_vars_found ++;
    while (1) {
      rv = copy_proc_mem(context->target.pid, "zval", (void *)((zval_70 *)remote_execute_data + (5 + i)),
                         (void *)(& zv), sizeof(zv));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    while (1) {
      rv = sprint_zval_70(context, & zv, tmp, sizeof(tmp), & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    context->event.varpeek.entry = entry;
    context->event.varpeek.var = var;
    context->event.varpeek.zval_str = tmp;
    while (1) {
      rv = (*(context->event_handler))(context, 3);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    if (num_vars_found >= num_vars_peeking) {
      break;
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  return (0);
}
}
static int copy_executor_globals_70(trace_context_t *context , zend_executor_globals_70 *executor_globals ) 
{ 
  int rv ;

  {
  executor_globals->current_execute_data = (zend_execute_data_70 *)((void *)0);
  while (1) {
    rv = copy_proc_mem(context->target.pid, "executor_globals", (void *)context->target.executor_globals_addr,
                       (void *)executor_globals, sizeof(*executor_globals));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  return (0);
}
}
static int copy_zarray_bucket_70(trace_context_t *context , zend_array_70 *rzarray ,
                                 char const   *key , Bucket_70 *lbucket ) 
{ 
  int rv ;
  zend_array_70 lzarray ;
  uint32_t hash_table_size ;
  uint64_t hash_val ;
  uint32_t hash_index ;
  uint32_t hash_table_val ;
  uint32_t *hash_bucket ;
  char tmp_key[256] ;
  size_t tmp_len ;
  size_t tmp ;
  int tmp___0 ;

  {
  while (1) {
    rv = copy_proc_mem(context->target.pid, "array", (void *)rzarray, (void *)(& lzarray),
                       sizeof(lzarray));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  tmp = strlen(key);
  hash_val = phpspy_zend_inline_hash_func(key, tmp);
  hash_table_size = (uint32_t )(-1 * (int32_t )lzarray.nTableMask);
  hash_index = (uint32_t )(hash_val % (unsigned long )hash_table_size);
  while (1) {
    rv = copy_proc_mem(context->target.pid, "hash_table_val", (void *)(((uint32_t *)lzarray.arData - hash_table_size) + hash_index),
                       (void *)(& hash_table_val), sizeof(uint32_t ));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  hash_bucket = & hash_table_val;
  while (1) {
    if (*hash_bucket == 4294967295U) {
      return (1);
    }
    while (1) {
      rv = copy_proc_mem(context->target.pid, "bucket", (void *)(lzarray.arData + *hash_bucket),
                         (void *)lbucket, sizeof(Bucket_70 ));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    if ((unsigned long )lbucket->key == (unsigned long )((void *)0)) {
      break;
    }
    while (1) {
      rv = sprint_zstring_70(context, "array_key", lbucket->key, tmp_key, sizeof(tmp_key),
                             & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    tmp___0 = strcmp(key, (char const   *)(tmp_key));
    if (tmp___0 == 0) {
      hash_bucket = (uint32_t *)((void *)0);
    } else {
      hash_bucket = & lbucket->val.u2.next;
    }
    if (! hash_bucket) {
      break;
    }
  }
  return (0);
}
}
static int sprint_zstring_70(trace_context_t *context , char const   *what , zend_string_70 *rzstring ,
                             char *buf___0 , size_t buf_size , size_t *buf_len___0 ) 
{ 
  int rv ;
  zend_string_70 lzstring ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  *buf___0 = (char )'\000';
  *buf_len___0 = (size_t )0;
  while (1) {
    rv = copy_proc_mem(context->target.pid, what, (void *)rzstring, (void *)(& lzstring),
                       sizeof(lzstring));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  if (1UL > buf_size) {
    tmp___1 = (size_t )1;
  } else {
    tmp___1 = buf_size;
  }
  if (lzstring.len < tmp___1 - 1UL) {
    *buf_len___0 = lzstring.len;
  } else {
    if (1UL > buf_size) {
      tmp___0 = (size_t )1;
    } else {
      tmp___0 = buf_size;
    }
    *buf_len___0 = tmp___0 - 1UL;
  }
  while (1) {
    rv = copy_proc_mem(context->target.pid, what, (void *)((char *)rzstring + (unsigned long )(& ((zend_string_70 *)0)->val)),
                       (void *)buf___0, *buf_len___0);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  *(buf___0 + (int )*buf_len___0) = (char )'\000';
  return (0);
}
}
static int sprint_zval_70(trace_context_t *context , zval_70 *lzval , char *buf___0 ,
                          size_t buf_size , size_t *buf_len___0 ) 
{ 
  int rv ;
  int type ;

  {
  type = (int )lzval->u1.v.type;
  switch (type) {
  case 4: 
  snprintf((char * __restrict  )buf___0, buf_size, (char const   * __restrict  )"%ld",
           lzval->value.lval);
  *buf_len___0 = strlen((char const   *)buf___0);
  break;
  case 5: 
  snprintf((char * __restrict  )buf___0, buf_size, (char const   * __restrict  )"%f",
           lzval->value.dval);
  *buf_len___0 = strlen((char const   *)buf___0);
  break;
  case 6: 
  while (1) {
    rv = sprint_zstring_70(context, "zval", lzval->value.str, buf___0, buf_size, buf_len___0);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  break;
  case 7: 
  while (1) {
    rv = sprint_zarray_70(context, lzval->value.arr, buf___0, buf_size, buf_len___0);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  break;
  default: 
  return (1);
  }
  return (0);
}
}
static int sprint_zarray_70(trace_context_t *context , zend_array_70 *rzarray , char *buf___0 ,
                            size_t buf_size , size_t *buf_len___0 ) 
{ 
  int rv ;
  int i ;
  int array_len ;
  size_t tmp_len ;
  Bucket_70 buckets[128] ;
  zend_array_70 lzarray ;
  char *obuf ;

  {
  obuf = buf___0;
  while (1) {
    rv = copy_proc_mem(context->target.pid, "array", (void *)rzarray, (void *)(& lzarray),
                       sizeof(lzarray));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  if (lzarray.nNumOfElements < 128U) {
    array_len = (int )lzarray.nNumOfElements;
  } else {
    array_len = 128;
  }
  while (1) {
    rv = copy_proc_mem(context->target.pid, "buckets", (void *)lzarray.arData, (void *)(buckets),
                       sizeof(Bucket_70 ) * (unsigned long )array_len);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  i = 0;
  while (i < array_len) {
    while (1) {
      rv = sprint_zarray_bucket_70(context, buckets + i, buf___0, buf_size, & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    buf_size -= tmp_len;
    buf___0 += tmp_len;
    if (buf_size >= 2UL) {
      *buf___0 = (char )',';
      buf_size --;
      buf___0 ++;
    }
    i ++;
  }
  *buf_len___0 = (size_t )(buf___0 - obuf);
  return (0);
}
}
static int sprint_zarray_val70(trace_context_t *context , zend_array_70 *rzarray ,
                               char const   *key , char *buf___0 , size_t buf_size ,
                               size_t *buf_len___0 ) 
{ 
  int rv ;
  Bucket_70 bucket ;

  {
  while (1) {
    rv = copy_zarray_bucket_70(context, rzarray, key, & bucket);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = sprint_zval_70(context, & bucket.val, buf___0, buf_size, buf_len___0);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  return (0);
}
}
static int sprint_zarray_bucket_70(trace_context_t *context , Bucket_70 *lbucket ,
                                   char *buf___0 , size_t buf_size , size_t *buf_len___0 ) 
{ 
  int rv ;
  char tmp_key[256] ;
  size_t tmp_len ;
  char *obuf ;

  {
  obuf = buf___0;
  if ((unsigned long )lbucket->key != (unsigned long )((void *)0)) {
    while (1) {
      rv = sprint_zstring_70(context, "array_key", lbucket->key, tmp_key, sizeof(tmp_key),
                             & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    if (buf_size > (tmp_len + 1UL) + 1UL) {
      snprintf((char * __restrict  )buf___0, buf_size, (char const   * __restrict  )"%s=",
               tmp_key);
      buf_size -= tmp_len + 1UL;
      buf___0 += tmp_len + 1UL;
    }
  }
  while (1) {
    rv = sprint_zval_70(context, & lbucket->val, buf___0, buf_size, & tmp_len);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  buf___0 += tmp_len;
  *buf_len___0 = (size_t )(buf___0 - obuf);
  return (0);
}
}
static int trace_stack_71(trace_context_t *context , zend_execute_data_71 *remote_execute_data ,
                          int *depth ) ;
static int trace_request_info_71(trace_context_t *context ) ;
static int trace_memory_info_71(trace_context_t *context ) ;
static int trace_globals_71(trace_context_t *context ) ;
static int trace_locals_71(trace_context_t *context , zend_op_71 *zop , zend_execute_data_71 *remote_execute_data ,
                           zend_op_array_71 *op_array , char *file , int file_len ) ;
static int copy_executor_globals_71(trace_context_t *context , zend_executor_globals_71 *executor_globals ) ;
static int copy_zarray_bucket_71(trace_context_t *context , zend_array_71 *rzarray ,
                                 char const   *key , Bucket_71 *lbucket ) ;
static int sprint_zstring_71(trace_context_t *context , char const   *what , zend_string_71 *rzstring ,
                             char *buf___0 , size_t buf_size , size_t *buf_len___0 ) ;
static int sprint_zval_71(trace_context_t *context , zval_71 *lzval , char *buf___0 ,
                          size_t buf_size , size_t *buf_len___0 ) ;
static int sprint_zarray_71(trace_context_t *context , zend_array_71 *rzarray , char *buf___0 ,
                            size_t buf_size , size_t *buf_len___0 ) ;
static int sprint_zarray_val71(trace_context_t *context , zend_array_71 *rzarray ,
                               char const   *key , char *buf___0 , size_t buf_size ,
                               size_t *buf_len___0 ) ;
static int sprint_zarray_bucket_71(trace_context_t *context , Bucket_71 *lbucket ,
                                   char *buf___0 , size_t buf_size , size_t *buf_len___0 ) ;
static int do_trace_71(trace_context_t *context ) 
{ 
  int rv ;
  int depth ;
  zend_executor_globals_71 executor_globals ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;

  {
  while (1) {
    rv = copy_executor_globals_71(context, & executor_globals);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = (*(context->event_handler))(context, 1);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  rv = 0;
  while (1) {
    tmp = trace_stack_71(context, executor_globals.current_execute_data, & depth);
    rv |= tmp;
    while (1) {
      if ((rv & 2) != 0) {
        break;
      } else
      if ((rv & 4) != 0) {
        break;
      } else
      if (! opt_continue_on_error) {
        break;
      }
      break;
    }
    if (depth < 1) {
      break;
    }
    if (opt_capture_req) {
      tmp___0 = trace_request_info_71(context);
      rv |= tmp___0;
      while (1) {
        if ((rv & 2) != 0) {
          break;
        } else
        if ((rv & 4) != 0) {
          break;
        } else
        if (! opt_continue_on_error) {
          break;
        }
        break;
      }
    }
    if (opt_capture_mem) {
      tmp___1 = trace_memory_info_71(context);
      rv |= tmp___1;
      while (1) {
        if ((rv & 2) != 0) {
          break;
        } else
        if ((rv & 4) != 0) {
          break;
        } else
        if (! opt_continue_on_error) {
          break;
        }
        break;
      }
    }
    if ((unsigned long )glopeek_map != (unsigned long )((void *)0)) {
      tmp___3 = (glopeek_map->hh.tbl)->num_items;
    } else {
      tmp___3 = 0U;
    }
    if (tmp___3 > 0U) {
      tmp___2 = trace_globals_71(context);
      rv |= tmp___2;
      while (1) {
        if ((rv & 2) != 0) {
          break;
        } else
        if ((rv & 4) != 0) {
          break;
        } else
        if (! opt_continue_on_error) {
          break;
        }
        break;
      }
    }
    break;
  }
  if (rv == 0) {
    goto _L;
  } else
  if (opt_continue_on_error) {
    _L: /* CIL Label */ 
    while (1) {
      rv = (*(context->event_handler))(context, 7);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
  }
  return (0);
}
}
static int trace_stack_71(trace_context_t *context , zend_execute_data_71 *remote_execute_data ,
                          int *depth ) 
{ 
  int rv ;
  zend_execute_data_71 execute_data ;
  zend_function_71 zfunc ;
  zend_string_71 zstring ;
  zend_class_entry_71 zce ;
  zend_op_71 zop ;
  trace_target_t *target ;
  trace_frame_t *frame ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
  target = & context->target;
  frame = & context->event.frame;
  *depth = 0;
  while (1) {
    if (remote_execute_data) {
      if (! (*depth != opt_max_stack_depth)) {
        break;
      }
    } else {
      break;
    }
    memset((void *)(& execute_data), 0, sizeof(execute_data));
    memset((void *)(& zfunc), 0, sizeof(zfunc));
    memset((void *)(& zstring), 0, sizeof(zstring));
    memset((void *)(& zce), 0, sizeof(zce));
    memset((void *)(& zop), 0, sizeof(zop));
    while (1) {
      rv = copy_proc_mem(context->target.pid, "execute_data", (void *)remote_execute_data,
                         (void *)(& execute_data), sizeof(execute_data));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    while (1) {
      rv = copy_proc_mem(context->target.pid, "zfunc", (void *)execute_data.func,
                         (void *)(& zfunc), sizeof(zfunc));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    if (zfunc.common.function_name) {
      while (1) {
        rv = sprint_zstring_71(context, "function_name", zfunc.common.function_name,
                               frame->loc.func, sizeof(frame->loc.func), & frame->loc.func_len);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
    } else {
      tmp = snprintf((char * __restrict  )(frame->loc.func), sizeof(frame->loc.func),
                     (char const   * __restrict  )"<main>");
      frame->loc.func_len = (size_t )tmp;
    }
    if (zfunc.common.scope) {
      while (1) {
        rv = copy_proc_mem(context->target.pid, "zce", (void *)zfunc.common.scope,
                           (void *)(& zce), sizeof(zce));
        if (rv != 0) {
          return (rv);
        }
        break;
      }
      while (1) {
        rv = sprint_zstring_71(context, "class_name", zce.name, frame->loc.class,
                               sizeof(frame->loc.class), & frame->loc.class_len);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
    } else {
      frame->loc.class[0] = (char )'\000';
      frame->loc.class_len = (size_t )0;
    }
    if ((int )zfunc.type == 2) {
      while (1) {
        rv = sprint_zstring_71(context, "filename", zfunc.op_array.filename, frame->loc.file,
                               sizeof(frame->loc.file), & frame->loc.file_len);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
      frame->loc.lineno = (int )zfunc.op_array.line_start;
      if ((unsigned long )varpeek_map != (unsigned long )((void *)0)) {
        tmp___1 = (varpeek_map->hh.tbl)->num_items;
      } else {
        tmp___1 = 0U;
      }
      if (tmp___1 > 0U) {
        tmp___0 = copy_proc_mem(target->pid, "opline", (void *)execute_data.opline,
                                (void *)(& zop), sizeof(zop));
        if (tmp___0 == 0) {
          trace_locals_71(context, & zop, remote_execute_data, & zfunc.op_array, frame->loc.file,
                          (int )frame->loc.file_len);
        }
      }
    } else {
      tmp___2 = snprintf((char * __restrict  )(frame->loc.file), sizeof(frame->loc.file),
                         (char const   * __restrict  )"<internal>");
      frame->loc.file_len = (size_t )tmp___2;
      frame->loc.lineno = -1;
    }
    frame->depth = *depth;
    while (1) {
      rv = (*(context->event_handler))(context, 2);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    remote_execute_data = execute_data.prev_execute_data;
    (*depth) ++;
  }
  return (0);
}
}
static int trace_request_info_71(trace_context_t *context ) 
{ 
  int rv ;
  sapi_globals_struct_71 sapi_globals ;
  trace_target_t *target ;
  trace_request_t *request ;

  {
  memset((void *)(& sapi_globals), 0, sizeof(sapi_globals));
  request = & context->event.request;
  target = & context->target;
  while (1) {
    rv = copy_proc_mem(context->target.pid, "sapi_globals", (void *)target->sapi_globals_addr,
                       (void *)(& sapi_globals), sizeof(sapi_globals));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    if (opt_capture_req_qstring) {
      if (sapi_globals.request_info.query_string) {
        while (1) {
          rv = copy_proc_mem(context->target.pid, "query_string", (void *)sapi_globals.request_info.query_string,
                             (void *)(request->qstring), (size_t )256);
          if (rv != 0) {
            return (rv);
          }
          break;
        }
      } else {
        request->qstring[0] = (char )'-';
        request->qstring[1] = (char )'\000';
      }
    } else {
      request->qstring[0] = (char )'-';
      request->qstring[1] = (char )'\000';
    }
    break;
  }
  while (1) {
    if (opt_capture_req_cookie) {
      if (sapi_globals.request_info.cookie_data) {
        while (1) {
          rv = copy_proc_mem(context->target.pid, "cookie_data", (void *)sapi_globals.request_info.cookie_data,
                             (void *)(request->cookie), (size_t )256);
          if (rv != 0) {
            return (rv);
          }
          break;
        }
      } else {
        request->cookie[0] = (char )'-';
        request->cookie[1] = (char )'\000';
      }
    } else {
      request->cookie[0] = (char )'-';
      request->cookie[1] = (char )'\000';
    }
    break;
  }
  while (1) {
    if (opt_capture_req_uri) {
      if (sapi_globals.request_info.request_uri) {
        while (1) {
          rv = copy_proc_mem(context->target.pid, "request_uri", (void *)sapi_globals.request_info.request_uri,
                             (void *)(request->uri), (size_t )256);
          if (rv != 0) {
            return (rv);
          }
          break;
        }
      } else {
        request->uri[0] = (char )'-';
        request->uri[1] = (char )'\000';
      }
    } else {
      request->uri[0] = (char )'-';
      request->uri[1] = (char )'\000';
    }
    break;
  }
  while (1) {
    if (opt_capture_req_path) {
      if (sapi_globals.request_info.path_translated) {
        while (1) {
          rv = copy_proc_mem(context->target.pid, "path_translated", (void *)sapi_globals.request_info.path_translated,
                             (void *)(request->path), (size_t )256);
          if (rv != 0) {
            return (rv);
          }
          break;
        }
      } else {
        request->path[0] = (char )'-';
        request->path[1] = (char )'\000';
      }
    } else {
      request->path[0] = (char )'-';
      request->path[1] = (char )'\000';
    }
    break;
  }
  request->ts = sapi_globals.global_request_time;
  while (1) {
    rv = (*(context->event_handler))(context, 5);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  return (0);
}
}
static int trace_memory_info_71(trace_context_t *context ) 
{ 
  int rv ;
  zend_mm_heap_71 mm_heap ;
  zend_alloc_globals_71 alloc_globals ;
  trace_target_t *target ;

  {
  memset((void *)(& mm_heap), 0, sizeof(mm_heap));
  alloc_globals.mm_heap = (zend_mm_heap_71 *)((void *)0);
  target = & context->target;
  while (1) {
    rv = copy_proc_mem(context->target.pid, "alloc_globals", (void *)target->alloc_globals_addr,
                       (void *)(& alloc_globals), sizeof(alloc_globals));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = copy_proc_mem(context->target.pid, "mm_heap", (void *)alloc_globals.mm_heap,
                       (void *)(& mm_heap), sizeof(mm_heap));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  context->event.mem.size = mm_heap.size;
  context->event.mem.peak = mm_heap.peak;
  while (1) {
    rv = (*(context->event_handler))(context, 6);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  return (0);
}
}
static int trace_globals_71(trace_context_t *context ) 
{ 
  int rv ;
  glopeek_entry_t *gentry ;
  glopeek_entry_t *gentry_tmp ;
  zend_array_71 *garray ;
  zend_array_71 *symtable ;
  Bucket_71 lbucket ;
  void *tmp ;
  void *tmp___0 ;

  {
  symtable = (zend_array_71 *)(context->target.executor_globals_addr + (unsigned long )(& ((zend_executor_globals_71 *)0)->symbol_table));
  gentry = glopeek_map;
  if ((unsigned long )glopeek_map != (unsigned long )((void *)0)) {
    tmp = glopeek_map->hh.next;
  } else {
    tmp = (void *)0;
  }
  gentry_tmp = (glopeek_entry_t *)tmp;
  while ((unsigned long )gentry != (unsigned long )((void *)0)) {
    if (gentry->gloname[0]) {
      while (1) {
        rv = copy_zarray_bucket_71(context, symtable, (char const   *)(gentry->gloname),
                                   & lbucket);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
      garray = lbucket.val.value.arr;
    } else {
      garray = symtable;
    }
    rv = sprint_zarray_val71(context, garray, (char const   *)(gentry->varname), context->buf,
                             sizeof(context->buf), & context->buf_len);
    if (rv == 0) {
      context->event.glopeek.gentry = gentry;
      context->event.glopeek.zval_str = context->buf;
      while (1) {
        rv = (*(context->event_handler))(context, 4);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
    }
    gentry = gentry_tmp;
    if ((unsigned long )gentry_tmp != (unsigned long )((void *)0)) {
      tmp___0 = gentry_tmp->hh.next;
    } else {
      tmp___0 = (void *)0;
    }
    gentry_tmp = (glopeek_entry_t *)tmp___0;
  }
  return (0);
}
}
static int trace_locals_71(trace_context_t *context , zend_op_71 *zop , zend_execute_data_71 *remote_execute_data ,
                           zend_op_array_71 *op_array , char *file , int file_len ) 
{ 
  int rv ;
  int i ;
  int num_vars_found ;
  int num_vars_peeking ;
  char tmp[256] ;
  size_t tmp_len ;
  zend_string_71 *zstrp ;
  varpeek_entry_t *entry ;
  varpeek_var_t *var ;
  char varpeek_key[256] ;
  zval_71 zv ;
  unsigned int _uthash_hfstr_keylen ;
  size_t tmp___0 ;
  unsigned int _hf_hashv ;
  unsigned int _hj_i ;
  unsigned int _hj_j ;
  unsigned int _hj_k ;
  unsigned char const   *_hj_key ;
  unsigned int _hf_bkt ;
  int tmp___1 ;
  unsigned int _hf_hashv___0 ;
  unsigned int _hj_i___0 ;
  unsigned int _hj_j___0 ;
  unsigned int _hj_k___0 ;
  unsigned char const   *_hj_key___0 ;
  unsigned int _hf_bkt___0 ;
  int tmp___2 ;

  {
  snprintf((char * __restrict  )(varpeek_key), sizeof(varpeek_key), (char const   * __restrict  )"%.*s:%d",
           file_len, file, zop->lineno);
  while (1) {
    tmp___0 = strlen((char const   *)(varpeek_key));
    _uthash_hfstr_keylen = (unsigned int )tmp___0;
    while (1) {
      while (1) {
        while (1) {
          _hj_key = (unsigned char const   *)(varpeek_key);
          _hf_hashv = 4276993775U;
          _hj_j = 2654435769U;
          _hj_i = _hj_j;
          _hj_k = _uthash_hfstr_keylen;
          while (_hj_k >= 12U) {
            _hj_i += (((unsigned int )*(_hj_key + 0) + ((unsigned int )*(_hj_key + 1) << 8)) + ((unsigned int )*(_hj_key + 2) << 16)) + ((unsigned int )*(_hj_key + 3) << 24);
            _hj_j += (((unsigned int )*(_hj_key + 4) + ((unsigned int )*(_hj_key + 5) << 8)) + ((unsigned int )*(_hj_key + 6) << 16)) + ((unsigned int )*(_hj_key + 7) << 24);
            _hf_hashv += (((unsigned int )*(_hj_key + 8) + ((unsigned int )*(_hj_key + 9) << 8)) + ((unsigned int )*(_hj_key + 10) << 16)) + ((unsigned int )*(_hj_key + 11) << 24);
            while (1) {
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 13;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 8;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 13;
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 12;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 16;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 5;
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 3;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 10;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 15;
              break;
            }
            _hj_key += 12;
            _hj_k -= 12U;
          }
          _hf_hashv += _uthash_hfstr_keylen;
          switch (_hj_k) {
          case 11U: 
          _hf_hashv += (unsigned int )*(_hj_key + 10) << 24;
          case 10U: 
          _hf_hashv += (unsigned int )*(_hj_key + 9) << 16;
          case 9U: 
          _hf_hashv += (unsigned int )*(_hj_key + 8) << 8;
          case 8U: 
          _hj_j += (unsigned int )*(_hj_key + 7) << 24;
          case 7U: 
          _hj_j += (unsigned int )*(_hj_key + 6) << 16;
          case 6U: 
          _hj_j += (unsigned int )*(_hj_key + 5) << 8;
          case 5U: 
          _hj_j += (unsigned int )*(_hj_key + 4);
          case 4U: 
          _hj_i += (unsigned int )*(_hj_key + 3) << 24;
          case 3U: 
          _hj_i += (unsigned int )*(_hj_key + 2) << 16;
          case 2U: 
          _hj_i += (unsigned int )*(_hj_key + 1) << 8;
          case 1U: 
          _hj_i += (unsigned int )*(_hj_key + 0);
          }
          while (1) {
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 13;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 8;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 13;
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 12;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 16;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 5;
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 3;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 10;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 15;
            break;
          }
          break;
        }
        break;
      }
      while (1) {
        entry = (varpeek_entry_t *)((void *)0);
        if (varpeek_map) {
          while (1) {
            _hf_bkt = _hf_hashv & ((varpeek_map->hh.tbl)->num_buckets - 1U);
            break;
          }
          while (1) {
            if ((unsigned long )((varpeek_map->hh.tbl)->buckets + _hf_bkt)->hh_head != (unsigned long )((void *)0)) {
              while (1) {
                entry = (varpeek_entry_t *)((void *)((char *)((varpeek_map->hh.tbl)->buckets + _hf_bkt)->hh_head - (varpeek_map->hh.tbl)->hho));
                break;
              }
            } else {
              entry = (varpeek_entry_t *)((void *)0);
            }
            while ((unsigned long )entry != (unsigned long )((void *)0)) {
              if (entry->hh.hashv == _hf_hashv) {
                if (entry->hh.keylen == _uthash_hfstr_keylen) {
                  tmp___1 = memcmp((void const   *)entry->hh.key, (void const   *)(varpeek_key),
                                   (size_t )_uthash_hfstr_keylen);
                  if (tmp___1 == 0) {
                    break;
                  }
                }
              }
              if ((unsigned long )entry->hh.hh_next != (unsigned long )((void *)0)) {
                while (1) {
                  entry = (varpeek_entry_t *)((void *)((char *)entry->hh.hh_next - (varpeek_map->hh.tbl)->hho));
                  break;
                }
              } else {
                entry = (varpeek_entry_t *)((void *)0);
              }
            }
            break;
          }
        }
        break;
      }
      break;
    }
    break;
  }
  if (! entry) {
    return (0);
  }
  num_vars_found = 0;
  if ((unsigned long )entry->varmap != (unsigned long )((void *)0)) {
    num_vars_peeking = (int )((entry->varmap)->hh.tbl)->num_items;
  } else {
    num_vars_peeking = 0;
  }
  i = 0;
  while (i < op_array->last_var) {
    while (1) {
      rv = copy_proc_mem(context->target.pid, "var", (void *)(op_array->vars + i),
                         (void *)(& zstrp), sizeof(zstrp));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    while (1) {
      rv = sprint_zstring_71(context, "var", zstrp, tmp, sizeof(tmp), & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    while (1) {
      while (1) {
        while (1) {
          _hj_key___0 = (unsigned char const   *)(tmp);
          _hf_hashv___0 = 4276993775U;
          _hj_j___0 = 2654435769U;
          _hj_i___0 = _hj_j___0;
          _hj_k___0 = (unsigned int )tmp_len;
          while (_hj_k___0 >= 12U) {
            _hj_i___0 += (((unsigned int )*(_hj_key___0 + 0) + ((unsigned int )*(_hj_key___0 + 1) << 8)) + ((unsigned int )*(_hj_key___0 + 2) << 16)) + ((unsigned int )*(_hj_key___0 + 3) << 24);
            _hj_j___0 += (((unsigned int )*(_hj_key___0 + 4) + ((unsigned int )*(_hj_key___0 + 5) << 8)) + ((unsigned int )*(_hj_key___0 + 6) << 16)) + ((unsigned int )*(_hj_key___0 + 7) << 24);
            _hf_hashv___0 += (((unsigned int )*(_hj_key___0 + 8) + ((unsigned int )*(_hj_key___0 + 9) << 8)) + ((unsigned int )*(_hj_key___0 + 10) << 16)) + ((unsigned int )*(_hj_key___0 + 11) << 24);
            while (1) {
              _hj_i___0 -= _hj_j___0;
              _hj_i___0 -= _hf_hashv___0;
              _hj_i___0 ^= _hf_hashv___0 >> 13;
              _hj_j___0 -= _hf_hashv___0;
              _hj_j___0 -= _hj_i___0;
              _hj_j___0 ^= _hj_i___0 << 8;
              _hf_hashv___0 -= _hj_i___0;
              _hf_hashv___0 -= _hj_j___0;
              _hf_hashv___0 ^= _hj_j___0 >> 13;
              _hj_i___0 -= _hj_j___0;
              _hj_i___0 -= _hf_hashv___0;
              _hj_i___0 ^= _hf_hashv___0 >> 12;
              _hj_j___0 -= _hf_hashv___0;
              _hj_j___0 -= _hj_i___0;
              _hj_j___0 ^= _hj_i___0 << 16;
              _hf_hashv___0 -= _hj_i___0;
              _hf_hashv___0 -= _hj_j___0;
              _hf_hashv___0 ^= _hj_j___0 >> 5;
              _hj_i___0 -= _hj_j___0;
              _hj_i___0 -= _hf_hashv___0;
              _hj_i___0 ^= _hf_hashv___0 >> 3;
              _hj_j___0 -= _hf_hashv___0;
              _hj_j___0 -= _hj_i___0;
              _hj_j___0 ^= _hj_i___0 << 10;
              _hf_hashv___0 -= _hj_i___0;
              _hf_hashv___0 -= _hj_j___0;
              _hf_hashv___0 ^= _hj_j___0 >> 15;
              break;
            }
            _hj_key___0 += 12;
            _hj_k___0 -= 12U;
          }
          _hf_hashv___0 += (unsigned int )tmp_len;
          switch (_hj_k___0) {
          case 11U: 
          _hf_hashv___0 += (unsigned int )*(_hj_key___0 + 10) << 24;
          case 10U: 
          _hf_hashv___0 += (unsigned int )*(_hj_key___0 + 9) << 16;
          case 9U: 
          _hf_hashv___0 += (unsigned int )*(_hj_key___0 + 8) << 8;
          case 8U: 
          _hj_j___0 += (unsigned int )*(_hj_key___0 + 7) << 24;
          case 7U: 
          _hj_j___0 += (unsigned int )*(_hj_key___0 + 6) << 16;
          case 6U: 
          _hj_j___0 += (unsigned int )*(_hj_key___0 + 5) << 8;
          case 5U: 
          _hj_j___0 += (unsigned int )*(_hj_key___0 + 4);
          case 4U: 
          _hj_i___0 += (unsigned int )*(_hj_key___0 + 3) << 24;
          case 3U: 
          _hj_i___0 += (unsigned int )*(_hj_key___0 + 2) << 16;
          case 2U: 
          _hj_i___0 += (unsigned int )*(_hj_key___0 + 1) << 8;
          case 1U: 
          _hj_i___0 += (unsigned int )*(_hj_key___0 + 0);
          }
          while (1) {
            _hj_i___0 -= _hj_j___0;
            _hj_i___0 -= _hf_hashv___0;
            _hj_i___0 ^= _hf_hashv___0 >> 13;
            _hj_j___0 -= _hf_hashv___0;
            _hj_j___0 -= _hj_i___0;
            _hj_j___0 ^= _hj_i___0 << 8;
            _hf_hashv___0 -= _hj_i___0;
            _hf_hashv___0 -= _hj_j___0;
            _hf_hashv___0 ^= _hj_j___0 >> 13;
            _hj_i___0 -= _hj_j___0;
            _hj_i___0 -= _hf_hashv___0;
            _hj_i___0 ^= _hf_hashv___0 >> 12;
            _hj_j___0 -= _hf_hashv___0;
            _hj_j___0 -= _hj_i___0;
            _hj_j___0 ^= _hj_i___0 << 16;
            _hf_hashv___0 -= _hj_i___0;
            _hf_hashv___0 -= _hj_j___0;
            _hf_hashv___0 ^= _hj_j___0 >> 5;
            _hj_i___0 -= _hj_j___0;
            _hj_i___0 -= _hf_hashv___0;
            _hj_i___0 ^= _hf_hashv___0 >> 3;
            _hj_j___0 -= _hf_hashv___0;
            _hj_j___0 -= _hj_i___0;
            _hj_j___0 ^= _hj_i___0 << 10;
            _hf_hashv___0 -= _hj_i___0;
            _hf_hashv___0 -= _hj_j___0;
            _hf_hashv___0 ^= _hj_j___0 >> 15;
            break;
          }
          break;
        }
        break;
      }
      while (1) {
        var = (varpeek_var_t *)((void *)0);
        if (entry->varmap) {
          while (1) {
            _hf_bkt___0 = _hf_hashv___0 & (((entry->varmap)->hh.tbl)->num_buckets - 1U);
            break;
          }
          while (1) {
            if ((unsigned long )(((entry->varmap)->hh.tbl)->buckets + _hf_bkt___0)->hh_head != (unsigned long )((void *)0)) {
              while (1) {
                var = (varpeek_var_t *)((void *)((char *)(((entry->varmap)->hh.tbl)->buckets + _hf_bkt___0)->hh_head - ((entry->varmap)->hh.tbl)->hho));
                break;
              }
            } else {
              var = (varpeek_var_t *)((void *)0);
            }
            while ((unsigned long )var != (unsigned long )((void *)0)) {
              if (var->hh.hashv == _hf_hashv___0) {
                if ((size_t )var->hh.keylen == tmp_len) {
                  tmp___2 = memcmp((void const   *)var->hh.key, (void const   *)(tmp),
                                   tmp_len);
                  if (tmp___2 == 0) {
                    break;
                  }
                }
              }
              if ((unsigned long )var->hh.hh_next != (unsigned long )((void *)0)) {
                while (1) {
                  var = (varpeek_var_t *)((void *)((char *)var->hh.hh_next - ((entry->varmap)->hh.tbl)->hho));
                  break;
                }
              } else {
                var = (varpeek_var_t *)((void *)0);
              }
            }
            break;
          }
        }
        break;
      }
      break;
    }
    if (! var) {
      goto __Cont;
    }
    num_vars_found ++;
    while (1) {
      rv = copy_proc_mem(context->target.pid, "zval", (void *)((zval_71 *)remote_execute_data + (5 + i)),
                         (void *)(& zv), sizeof(zv));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    while (1) {
      rv = sprint_zval_71(context, & zv, tmp, sizeof(tmp), & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    context->event.varpeek.entry = entry;
    context->event.varpeek.var = var;
    context->event.varpeek.zval_str = tmp;
    while (1) {
      rv = (*(context->event_handler))(context, 3);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    if (num_vars_found >= num_vars_peeking) {
      break;
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  return (0);
}
}
static int copy_executor_globals_71(trace_context_t *context , zend_executor_globals_71 *executor_globals ) 
{ 
  int rv ;

  {
  executor_globals->current_execute_data = (zend_execute_data_71 *)((void *)0);
  while (1) {
    rv = copy_proc_mem(context->target.pid, "executor_globals", (void *)context->target.executor_globals_addr,
                       (void *)executor_globals, sizeof(*executor_globals));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  return (0);
}
}
static int copy_zarray_bucket_71(trace_context_t *context , zend_array_71 *rzarray ,
                                 char const   *key , Bucket_71 *lbucket ) 
{ 
  int rv ;
  zend_array_71 lzarray ;
  uint32_t hash_table_size ;
  uint64_t hash_val ;
  uint32_t hash_index ;
  uint32_t hash_table_val ;
  uint32_t *hash_bucket ;
  char tmp_key[256] ;
  size_t tmp_len ;
  size_t tmp ;
  int tmp___0 ;

  {
  while (1) {
    rv = copy_proc_mem(context->target.pid, "array", (void *)rzarray, (void *)(& lzarray),
                       sizeof(lzarray));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  tmp = strlen(key);
  hash_val = phpspy_zend_inline_hash_func(key, tmp);
  hash_table_size = (uint32_t )(-1 * (int32_t )lzarray.nTableMask);
  hash_index = (uint32_t )(hash_val % (unsigned long )hash_table_size);
  while (1) {
    rv = copy_proc_mem(context->target.pid, "hash_table_val", (void *)(((uint32_t *)lzarray.arData - hash_table_size) + hash_index),
                       (void *)(& hash_table_val), sizeof(uint32_t ));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  hash_bucket = & hash_table_val;
  while (1) {
    if (*hash_bucket == 4294967295U) {
      return (1);
    }
    while (1) {
      rv = copy_proc_mem(context->target.pid, "bucket", (void *)(lzarray.arData + *hash_bucket),
                         (void *)lbucket, sizeof(Bucket_71 ));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    if ((unsigned long )lbucket->key == (unsigned long )((void *)0)) {
      break;
    }
    while (1) {
      rv = sprint_zstring_71(context, "array_key", lbucket->key, tmp_key, sizeof(tmp_key),
                             & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    tmp___0 = strcmp(key, (char const   *)(tmp_key));
    if (tmp___0 == 0) {
      hash_bucket = (uint32_t *)((void *)0);
    } else {
      hash_bucket = & lbucket->val.u2.next;
    }
    if (! hash_bucket) {
      break;
    }
  }
  return (0);
}
}
static int sprint_zstring_71(trace_context_t *context , char const   *what , zend_string_71 *rzstring ,
                             char *buf___0 , size_t buf_size , size_t *buf_len___0 ) 
{ 
  int rv ;
  zend_string_71 lzstring ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  *buf___0 = (char )'\000';
  *buf_len___0 = (size_t )0;
  while (1) {
    rv = copy_proc_mem(context->target.pid, what, (void *)rzstring, (void *)(& lzstring),
                       sizeof(lzstring));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  if (1UL > buf_size) {
    tmp___1 = (size_t )1;
  } else {
    tmp___1 = buf_size;
  }
  if (lzstring.len < tmp___1 - 1UL) {
    *buf_len___0 = lzstring.len;
  } else {
    if (1UL > buf_size) {
      tmp___0 = (size_t )1;
    } else {
      tmp___0 = buf_size;
    }
    *buf_len___0 = tmp___0 - 1UL;
  }
  while (1) {
    rv = copy_proc_mem(context->target.pid, what, (void *)((char *)rzstring + (unsigned long )(& ((zend_string_71 *)0)->val)),
                       (void *)buf___0, *buf_len___0);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  *(buf___0 + (int )*buf_len___0) = (char )'\000';
  return (0);
}
}
static int sprint_zval_71(trace_context_t *context , zval_71 *lzval , char *buf___0 ,
                          size_t buf_size , size_t *buf_len___0 ) 
{ 
  int rv ;
  int type ;

  {
  type = (int )lzval->u1.v.type;
  switch (type) {
  case 4: 
  snprintf((char * __restrict  )buf___0, buf_size, (char const   * __restrict  )"%ld",
           lzval->value.lval);
  *buf_len___0 = strlen((char const   *)buf___0);
  break;
  case 5: 
  snprintf((char * __restrict  )buf___0, buf_size, (char const   * __restrict  )"%f",
           lzval->value.dval);
  *buf_len___0 = strlen((char const   *)buf___0);
  break;
  case 6: 
  while (1) {
    rv = sprint_zstring_71(context, "zval", lzval->value.str, buf___0, buf_size, buf_len___0);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  break;
  case 7: 
  while (1) {
    rv = sprint_zarray_71(context, lzval->value.arr, buf___0, buf_size, buf_len___0);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  break;
  default: 
  return (1);
  }
  return (0);
}
}
static int sprint_zarray_71(trace_context_t *context , zend_array_71 *rzarray , char *buf___0 ,
                            size_t buf_size , size_t *buf_len___0 ) 
{ 
  int rv ;
  int i ;
  int array_len ;
  size_t tmp_len ;
  Bucket_71 buckets[128] ;
  zend_array_71 lzarray ;
  char *obuf ;

  {
  obuf = buf___0;
  while (1) {
    rv = copy_proc_mem(context->target.pid, "array", (void *)rzarray, (void *)(& lzarray),
                       sizeof(lzarray));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  if (lzarray.nNumOfElements < 128U) {
    array_len = (int )lzarray.nNumOfElements;
  } else {
    array_len = 128;
  }
  while (1) {
    rv = copy_proc_mem(context->target.pid, "buckets", (void *)lzarray.arData, (void *)(buckets),
                       sizeof(Bucket_71 ) * (unsigned long )array_len);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  i = 0;
  while (i < array_len) {
    while (1) {
      rv = sprint_zarray_bucket_71(context, buckets + i, buf___0, buf_size, & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    buf_size -= tmp_len;
    buf___0 += tmp_len;
    if (buf_size >= 2UL) {
      *buf___0 = (char )',';
      buf_size --;
      buf___0 ++;
    }
    i ++;
  }
  *buf_len___0 = (size_t )(buf___0 - obuf);
  return (0);
}
}
static int sprint_zarray_val71(trace_context_t *context , zend_array_71 *rzarray ,
                               char const   *key , char *buf___0 , size_t buf_size ,
                               size_t *buf_len___0 ) 
{ 
  int rv ;
  Bucket_71 bucket ;

  {
  while (1) {
    rv = copy_zarray_bucket_71(context, rzarray, key, & bucket);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = sprint_zval_71(context, & bucket.val, buf___0, buf_size, buf_len___0);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  return (0);
}
}
static int sprint_zarray_bucket_71(trace_context_t *context , Bucket_71 *lbucket ,
                                   char *buf___0 , size_t buf_size , size_t *buf_len___0 ) 
{ 
  int rv ;
  char tmp_key[256] ;
  size_t tmp_len ;
  char *obuf ;

  {
  obuf = buf___0;
  if ((unsigned long )lbucket->key != (unsigned long )((void *)0)) {
    while (1) {
      rv = sprint_zstring_71(context, "array_key", lbucket->key, tmp_key, sizeof(tmp_key),
                             & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    if (buf_size > (tmp_len + 1UL) + 1UL) {
      snprintf((char * __restrict  )buf___0, buf_size, (char const   * __restrict  )"%s=",
               tmp_key);
      buf_size -= tmp_len + 1UL;
      buf___0 += tmp_len + 1UL;
    }
  }
  while (1) {
    rv = sprint_zval_71(context, & lbucket->val, buf___0, buf_size, & tmp_len);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  buf___0 += tmp_len;
  *buf_len___0 = (size_t )(buf___0 - obuf);
  return (0);
}
}
static int trace_stack_72(trace_context_t *context , zend_execute_data_72 *remote_execute_data ,
                          int *depth ) ;
static int trace_request_info_72(trace_context_t *context ) ;
static int trace_memory_info_72(trace_context_t *context ) ;
static int trace_globals_72(trace_context_t *context ) ;
static int trace_locals_72(trace_context_t *context , zend_op_72 *zop , zend_execute_data_72 *remote_execute_data ,
                           zend_op_array_72 *op_array , char *file , int file_len ) ;
static int copy_executor_globals_72(trace_context_t *context , zend_executor_globals_72 *executor_globals ) ;
static int copy_zarray_bucket_72(trace_context_t *context , zend_array_72 *rzarray ,
                                 char const   *key , Bucket_72 *lbucket ) ;
static int sprint_zstring_72(trace_context_t *context , char const   *what , zend_string_72 *rzstring ,
                             char *buf___0 , size_t buf_size , size_t *buf_len___0 ) ;
static int sprint_zval_72(trace_context_t *context , zval_72 *lzval , char *buf___0 ,
                          size_t buf_size , size_t *buf_len___0 ) ;
static int sprint_zarray_72(trace_context_t *context , zend_array_72 *rzarray , char *buf___0 ,
                            size_t buf_size , size_t *buf_len___0 ) ;
static int sprint_zarray_val72(trace_context_t *context , zend_array_72 *rzarray ,
                               char const   *key , char *buf___0 , size_t buf_size ,
                               size_t *buf_len___0 ) ;
static int sprint_zarray_bucket_72(trace_context_t *context , Bucket_72 *lbucket ,
                                   char *buf___0 , size_t buf_size , size_t *buf_len___0 ) ;
static int do_trace_72(trace_context_t *context ) 
{ 
  int rv ;
  int depth ;
  zend_executor_globals_72 executor_globals ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;

  {
  while (1) {
    rv = copy_executor_globals_72(context, & executor_globals);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = (*(context->event_handler))(context, 1);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  rv = 0;
  while (1) {
    tmp = trace_stack_72(context, executor_globals.current_execute_data, & depth);
    rv |= tmp;
    while (1) {
      if ((rv & 2) != 0) {
        break;
      } else
      if ((rv & 4) != 0) {
        break;
      } else
      if (! opt_continue_on_error) {
        break;
      }
      break;
    }
    if (depth < 1) {
      break;
    }
    if (opt_capture_req) {
      tmp___0 = trace_request_info_72(context);
      rv |= tmp___0;
      while (1) {
        if ((rv & 2) != 0) {
          break;
        } else
        if ((rv & 4) != 0) {
          break;
        } else
        if (! opt_continue_on_error) {
          break;
        }
        break;
      }
    }
    if (opt_capture_mem) {
      tmp___1 = trace_memory_info_72(context);
      rv |= tmp___1;
      while (1) {
        if ((rv & 2) != 0) {
          break;
        } else
        if ((rv & 4) != 0) {
          break;
        } else
        if (! opt_continue_on_error) {
          break;
        }
        break;
      }
    }
    if ((unsigned long )glopeek_map != (unsigned long )((void *)0)) {
      tmp___3 = (glopeek_map->hh.tbl)->num_items;
    } else {
      tmp___3 = 0U;
    }
    if (tmp___3 > 0U) {
      tmp___2 = trace_globals_72(context);
      rv |= tmp___2;
      while (1) {
        if ((rv & 2) != 0) {
          break;
        } else
        if ((rv & 4) != 0) {
          break;
        } else
        if (! opt_continue_on_error) {
          break;
        }
        break;
      }
    }
    break;
  }
  if (rv == 0) {
    goto _L;
  } else
  if (opt_continue_on_error) {
    _L: /* CIL Label */ 
    while (1) {
      rv = (*(context->event_handler))(context, 7);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
  }
  return (0);
}
}
static int trace_stack_72(trace_context_t *context , zend_execute_data_72 *remote_execute_data ,
                          int *depth ) 
{ 
  int rv ;
  zend_execute_data_72 execute_data ;
  zend_function_72 zfunc ;
  zend_string_72 zstring ;
  zend_class_entry_72 zce ;
  zend_op_72 zop ;
  trace_target_t *target ;
  trace_frame_t *frame ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
  target = & context->target;
  frame = & context->event.frame;
  *depth = 0;
  while (1) {
    if (remote_execute_data) {
      if (! (*depth != opt_max_stack_depth)) {
        break;
      }
    } else {
      break;
    }
    memset((void *)(& execute_data), 0, sizeof(execute_data));
    memset((void *)(& zfunc), 0, sizeof(zfunc));
    memset((void *)(& zstring), 0, sizeof(zstring));
    memset((void *)(& zce), 0, sizeof(zce));
    memset((void *)(& zop), 0, sizeof(zop));
    while (1) {
      rv = copy_proc_mem(context->target.pid, "execute_data", (void *)remote_execute_data,
                         (void *)(& execute_data), sizeof(execute_data));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    while (1) {
      rv = copy_proc_mem(context->target.pid, "zfunc", (void *)execute_data.func,
                         (void *)(& zfunc), sizeof(zfunc));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    if (zfunc.common.function_name) {
      while (1) {
        rv = sprint_zstring_72(context, "function_name", zfunc.common.function_name,
                               frame->loc.func, sizeof(frame->loc.func), & frame->loc.func_len);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
    } else {
      tmp = snprintf((char * __restrict  )(frame->loc.func), sizeof(frame->loc.func),
                     (char const   * __restrict  )"<main>");
      frame->loc.func_len = (size_t )tmp;
    }
    if (zfunc.common.scope) {
      while (1) {
        rv = copy_proc_mem(context->target.pid, "zce", (void *)zfunc.common.scope,
                           (void *)(& zce), sizeof(zce));
        if (rv != 0) {
          return (rv);
        }
        break;
      }
      while (1) {
        rv = sprint_zstring_72(context, "class_name", zce.name, frame->loc.class,
                               sizeof(frame->loc.class), & frame->loc.class_len);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
    } else {
      frame->loc.class[0] = (char )'\000';
      frame->loc.class_len = (size_t )0;
    }
    if ((int )zfunc.type == 2) {
      while (1) {
        rv = sprint_zstring_72(context, "filename", zfunc.op_array.filename, frame->loc.file,
                               sizeof(frame->loc.file), & frame->loc.file_len);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
      frame->loc.lineno = (int )zfunc.op_array.line_start;
      if ((unsigned long )varpeek_map != (unsigned long )((void *)0)) {
        tmp___1 = (varpeek_map->hh.tbl)->num_items;
      } else {
        tmp___1 = 0U;
      }
      if (tmp___1 > 0U) {
        tmp___0 = copy_proc_mem(target->pid, "opline", (void *)execute_data.opline,
                                (void *)(& zop), sizeof(zop));
        if (tmp___0 == 0) {
          trace_locals_72(context, & zop, remote_execute_data, & zfunc.op_array, frame->loc.file,
                          (int )frame->loc.file_len);
        }
      }
    } else {
      tmp___2 = snprintf((char * __restrict  )(frame->loc.file), sizeof(frame->loc.file),
                         (char const   * __restrict  )"<internal>");
      frame->loc.file_len = (size_t )tmp___2;
      frame->loc.lineno = -1;
    }
    frame->depth = *depth;
    while (1) {
      rv = (*(context->event_handler))(context, 2);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    remote_execute_data = execute_data.prev_execute_data;
    (*depth) ++;
  }
  return (0);
}
}
static int trace_request_info_72(trace_context_t *context ) 
{ 
  int rv ;
  sapi_globals_struct_72 sapi_globals ;
  trace_target_t *target ;
  trace_request_t *request ;

  {
  memset((void *)(& sapi_globals), 0, sizeof(sapi_globals));
  request = & context->event.request;
  target = & context->target;
  while (1) {
    rv = copy_proc_mem(context->target.pid, "sapi_globals", (void *)target->sapi_globals_addr,
                       (void *)(& sapi_globals), sizeof(sapi_globals));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    if (opt_capture_req_qstring) {
      if (sapi_globals.request_info.query_string) {
        while (1) {
          rv = copy_proc_mem(context->target.pid, "query_string", (void *)sapi_globals.request_info.query_string,
                             (void *)(request->qstring), (size_t )256);
          if (rv != 0) {
            return (rv);
          }
          break;
        }
      } else {
        request->qstring[0] = (char )'-';
        request->qstring[1] = (char )'\000';
      }
    } else {
      request->qstring[0] = (char )'-';
      request->qstring[1] = (char )'\000';
    }
    break;
  }
  while (1) {
    if (opt_capture_req_cookie) {
      if (sapi_globals.request_info.cookie_data) {
        while (1) {
          rv = copy_proc_mem(context->target.pid, "cookie_data", (void *)sapi_globals.request_info.cookie_data,
                             (void *)(request->cookie), (size_t )256);
          if (rv != 0) {
            return (rv);
          }
          break;
        }
      } else {
        request->cookie[0] = (char )'-';
        request->cookie[1] = (char )'\000';
      }
    } else {
      request->cookie[0] = (char )'-';
      request->cookie[1] = (char )'\000';
    }
    break;
  }
  while (1) {
    if (opt_capture_req_uri) {
      if (sapi_globals.request_info.request_uri) {
        while (1) {
          rv = copy_proc_mem(context->target.pid, "request_uri", (void *)sapi_globals.request_info.request_uri,
                             (void *)(request->uri), (size_t )256);
          if (rv != 0) {
            return (rv);
          }
          break;
        }
      } else {
        request->uri[0] = (char )'-';
        request->uri[1] = (char )'\000';
      }
    } else {
      request->uri[0] = (char )'-';
      request->uri[1] = (char )'\000';
    }
    break;
  }
  while (1) {
    if (opt_capture_req_path) {
      if (sapi_globals.request_info.path_translated) {
        while (1) {
          rv = copy_proc_mem(context->target.pid, "path_translated", (void *)sapi_globals.request_info.path_translated,
                             (void *)(request->path), (size_t )256);
          if (rv != 0) {
            return (rv);
          }
          break;
        }
      } else {
        request->path[0] = (char )'-';
        request->path[1] = (char )'\000';
      }
    } else {
      request->path[0] = (char )'-';
      request->path[1] = (char )'\000';
    }
    break;
  }
  request->ts = sapi_globals.global_request_time;
  while (1) {
    rv = (*(context->event_handler))(context, 5);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  return (0);
}
}
static int trace_memory_info_72(trace_context_t *context ) 
{ 
  int rv ;
  zend_mm_heap_72 mm_heap ;
  zend_alloc_globals_72 alloc_globals ;
  trace_target_t *target ;

  {
  memset((void *)(& mm_heap), 0, sizeof(mm_heap));
  alloc_globals.mm_heap = (zend_mm_heap_72 *)((void *)0);
  target = & context->target;
  while (1) {
    rv = copy_proc_mem(context->target.pid, "alloc_globals", (void *)target->alloc_globals_addr,
                       (void *)(& alloc_globals), sizeof(alloc_globals));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = copy_proc_mem(context->target.pid, "mm_heap", (void *)alloc_globals.mm_heap,
                       (void *)(& mm_heap), sizeof(mm_heap));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  context->event.mem.size = mm_heap.size;
  context->event.mem.peak = mm_heap.peak;
  while (1) {
    rv = (*(context->event_handler))(context, 6);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  return (0);
}
}
static int trace_globals_72(trace_context_t *context ) 
{ 
  int rv ;
  glopeek_entry_t *gentry ;
  glopeek_entry_t *gentry_tmp ;
  zend_array_72 *garray ;
  zend_array_72 *symtable ;
  Bucket_72 lbucket ;
  void *tmp ;
  void *tmp___0 ;

  {
  symtable = (zend_array_72 *)(context->target.executor_globals_addr + (unsigned long )(& ((zend_executor_globals_72 *)0)->symbol_table));
  gentry = glopeek_map;
  if ((unsigned long )glopeek_map != (unsigned long )((void *)0)) {
    tmp = glopeek_map->hh.next;
  } else {
    tmp = (void *)0;
  }
  gentry_tmp = (glopeek_entry_t *)tmp;
  while ((unsigned long )gentry != (unsigned long )((void *)0)) {
    if (gentry->gloname[0]) {
      while (1) {
        rv = copy_zarray_bucket_72(context, symtable, (char const   *)(gentry->gloname),
                                   & lbucket);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
      garray = lbucket.val.value.arr;
    } else {
      garray = symtable;
    }
    rv = sprint_zarray_val72(context, garray, (char const   *)(gentry->varname), context->buf,
                             sizeof(context->buf), & context->buf_len);
    if (rv == 0) {
      context->event.glopeek.gentry = gentry;
      context->event.glopeek.zval_str = context->buf;
      while (1) {
        rv = (*(context->event_handler))(context, 4);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
    }
    gentry = gentry_tmp;
    if ((unsigned long )gentry_tmp != (unsigned long )((void *)0)) {
      tmp___0 = gentry_tmp->hh.next;
    } else {
      tmp___0 = (void *)0;
    }
    gentry_tmp = (glopeek_entry_t *)tmp___0;
  }
  return (0);
}
}
static int trace_locals_72(trace_context_t *context , zend_op_72 *zop , zend_execute_data_72 *remote_execute_data ,
                           zend_op_array_72 *op_array , char *file , int file_len ) 
{ 
  int rv ;
  int i ;
  int num_vars_found ;
  int num_vars_peeking ;
  char tmp[256] ;
  size_t tmp_len ;
  zend_string_72 *zstrp ;
  varpeek_entry_t *entry ;
  varpeek_var_t *var ;
  char varpeek_key[256] ;
  zval_72 zv ;
  unsigned int _uthash_hfstr_keylen ;
  size_t tmp___0 ;
  unsigned int _hf_hashv ;
  unsigned int _hj_i ;
  unsigned int _hj_j ;
  unsigned int _hj_k ;
  unsigned char const   *_hj_key ;
  unsigned int _hf_bkt ;
  int tmp___1 ;
  unsigned int _hf_hashv___0 ;
  unsigned int _hj_i___0 ;
  unsigned int _hj_j___0 ;
  unsigned int _hj_k___0 ;
  unsigned char const   *_hj_key___0 ;
  unsigned int _hf_bkt___0 ;
  int tmp___2 ;

  {
  snprintf((char * __restrict  )(varpeek_key), sizeof(varpeek_key), (char const   * __restrict  )"%.*s:%d",
           file_len, file, zop->lineno);
  while (1) {
    tmp___0 = strlen((char const   *)(varpeek_key));
    _uthash_hfstr_keylen = (unsigned int )tmp___0;
    while (1) {
      while (1) {
        while (1) {
          _hj_key = (unsigned char const   *)(varpeek_key);
          _hf_hashv = 4276993775U;
          _hj_j = 2654435769U;
          _hj_i = _hj_j;
          _hj_k = _uthash_hfstr_keylen;
          while (_hj_k >= 12U) {
            _hj_i += (((unsigned int )*(_hj_key + 0) + ((unsigned int )*(_hj_key + 1) << 8)) + ((unsigned int )*(_hj_key + 2) << 16)) + ((unsigned int )*(_hj_key + 3) << 24);
            _hj_j += (((unsigned int )*(_hj_key + 4) + ((unsigned int )*(_hj_key + 5) << 8)) + ((unsigned int )*(_hj_key + 6) << 16)) + ((unsigned int )*(_hj_key + 7) << 24);
            _hf_hashv += (((unsigned int )*(_hj_key + 8) + ((unsigned int )*(_hj_key + 9) << 8)) + ((unsigned int )*(_hj_key + 10) << 16)) + ((unsigned int )*(_hj_key + 11) << 24);
            while (1) {
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 13;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 8;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 13;
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 12;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 16;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 5;
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 3;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 10;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 15;
              break;
            }
            _hj_key += 12;
            _hj_k -= 12U;
          }
          _hf_hashv += _uthash_hfstr_keylen;
          switch (_hj_k) {
          case 11U: 
          _hf_hashv += (unsigned int )*(_hj_key + 10) << 24;
          case 10U: 
          _hf_hashv += (unsigned int )*(_hj_key + 9) << 16;
          case 9U: 
          _hf_hashv += (unsigned int )*(_hj_key + 8) << 8;
          case 8U: 
          _hj_j += (unsigned int )*(_hj_key + 7) << 24;
          case 7U: 
          _hj_j += (unsigned int )*(_hj_key + 6) << 16;
          case 6U: 
          _hj_j += (unsigned int )*(_hj_key + 5) << 8;
          case 5U: 
          _hj_j += (unsigned int )*(_hj_key + 4);
          case 4U: 
          _hj_i += (unsigned int )*(_hj_key + 3) << 24;
          case 3U: 
          _hj_i += (unsigned int )*(_hj_key + 2) << 16;
          case 2U: 
          _hj_i += (unsigned int )*(_hj_key + 1) << 8;
          case 1U: 
          _hj_i += (unsigned int )*(_hj_key + 0);
          }
          while (1) {
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 13;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 8;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 13;
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 12;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 16;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 5;
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 3;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 10;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 15;
            break;
          }
          break;
        }
        break;
      }
      while (1) {
        entry = (varpeek_entry_t *)((void *)0);
        if (varpeek_map) {
          while (1) {
            _hf_bkt = _hf_hashv & ((varpeek_map->hh.tbl)->num_buckets - 1U);
            break;
          }
          while (1) {
            if ((unsigned long )((varpeek_map->hh.tbl)->buckets + _hf_bkt)->hh_head != (unsigned long )((void *)0)) {
              while (1) {
                entry = (varpeek_entry_t *)((void *)((char *)((varpeek_map->hh.tbl)->buckets + _hf_bkt)->hh_head - (varpeek_map->hh.tbl)->hho));
                break;
              }
            } else {
              entry = (varpeek_entry_t *)((void *)0);
            }
            while ((unsigned long )entry != (unsigned long )((void *)0)) {
              if (entry->hh.hashv == _hf_hashv) {
                if (entry->hh.keylen == _uthash_hfstr_keylen) {
                  tmp___1 = memcmp((void const   *)entry->hh.key, (void const   *)(varpeek_key),
                                   (size_t )_uthash_hfstr_keylen);
                  if (tmp___1 == 0) {
                    break;
                  }
                }
              }
              if ((unsigned long )entry->hh.hh_next != (unsigned long )((void *)0)) {
                while (1) {
                  entry = (varpeek_entry_t *)((void *)((char *)entry->hh.hh_next - (varpeek_map->hh.tbl)->hho));
                  break;
                }
              } else {
                entry = (varpeek_entry_t *)((void *)0);
              }
            }
            break;
          }
        }
        break;
      }
      break;
    }
    break;
  }
  if (! entry) {
    return (0);
  }
  num_vars_found = 0;
  if ((unsigned long )entry->varmap != (unsigned long )((void *)0)) {
    num_vars_peeking = (int )((entry->varmap)->hh.tbl)->num_items;
  } else {
    num_vars_peeking = 0;
  }
  i = 0;
  while (i < op_array->last_var) {
    while (1) {
      rv = copy_proc_mem(context->target.pid, "var", (void *)(op_array->vars + i),
                         (void *)(& zstrp), sizeof(zstrp));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    while (1) {
      rv = sprint_zstring_72(context, "var", zstrp, tmp, sizeof(tmp), & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    while (1) {
      while (1) {
        while (1) {
          _hj_key___0 = (unsigned char const   *)(tmp);
          _hf_hashv___0 = 4276993775U;
          _hj_j___0 = 2654435769U;
          _hj_i___0 = _hj_j___0;
          _hj_k___0 = (unsigned int )tmp_len;
          while (_hj_k___0 >= 12U) {
            _hj_i___0 += (((unsigned int )*(_hj_key___0 + 0) + ((unsigned int )*(_hj_key___0 + 1) << 8)) + ((unsigned int )*(_hj_key___0 + 2) << 16)) + ((unsigned int )*(_hj_key___0 + 3) << 24);
            _hj_j___0 += (((unsigned int )*(_hj_key___0 + 4) + ((unsigned int )*(_hj_key___0 + 5) << 8)) + ((unsigned int )*(_hj_key___0 + 6) << 16)) + ((unsigned int )*(_hj_key___0 + 7) << 24);
            _hf_hashv___0 += (((unsigned int )*(_hj_key___0 + 8) + ((unsigned int )*(_hj_key___0 + 9) << 8)) + ((unsigned int )*(_hj_key___0 + 10) << 16)) + ((unsigned int )*(_hj_key___0 + 11) << 24);
            while (1) {
              _hj_i___0 -= _hj_j___0;
              _hj_i___0 -= _hf_hashv___0;
              _hj_i___0 ^= _hf_hashv___0 >> 13;
              _hj_j___0 -= _hf_hashv___0;
              _hj_j___0 -= _hj_i___0;
              _hj_j___0 ^= _hj_i___0 << 8;
              _hf_hashv___0 -= _hj_i___0;
              _hf_hashv___0 -= _hj_j___0;
              _hf_hashv___0 ^= _hj_j___0 >> 13;
              _hj_i___0 -= _hj_j___0;
              _hj_i___0 -= _hf_hashv___0;
              _hj_i___0 ^= _hf_hashv___0 >> 12;
              _hj_j___0 -= _hf_hashv___0;
              _hj_j___0 -= _hj_i___0;
              _hj_j___0 ^= _hj_i___0 << 16;
              _hf_hashv___0 -= _hj_i___0;
              _hf_hashv___0 -= _hj_j___0;
              _hf_hashv___0 ^= _hj_j___0 >> 5;
              _hj_i___0 -= _hj_j___0;
              _hj_i___0 -= _hf_hashv___0;
              _hj_i___0 ^= _hf_hashv___0 >> 3;
              _hj_j___0 -= _hf_hashv___0;
              _hj_j___0 -= _hj_i___0;
              _hj_j___0 ^= _hj_i___0 << 10;
              _hf_hashv___0 -= _hj_i___0;
              _hf_hashv___0 -= _hj_j___0;
              _hf_hashv___0 ^= _hj_j___0 >> 15;
              break;
            }
            _hj_key___0 += 12;
            _hj_k___0 -= 12U;
          }
          _hf_hashv___0 += (unsigned int )tmp_len;
          switch (_hj_k___0) {
          case 11U: 
          _hf_hashv___0 += (unsigned int )*(_hj_key___0 + 10) << 24;
          case 10U: 
          _hf_hashv___0 += (unsigned int )*(_hj_key___0 + 9) << 16;
          case 9U: 
          _hf_hashv___0 += (unsigned int )*(_hj_key___0 + 8) << 8;
          case 8U: 
          _hj_j___0 += (unsigned int )*(_hj_key___0 + 7) << 24;
          case 7U: 
          _hj_j___0 += (unsigned int )*(_hj_key___0 + 6) << 16;
          case 6U: 
          _hj_j___0 += (unsigned int )*(_hj_key___0 + 5) << 8;
          case 5U: 
          _hj_j___0 += (unsigned int )*(_hj_key___0 + 4);
          case 4U: 
          _hj_i___0 += (unsigned int )*(_hj_key___0 + 3) << 24;
          case 3U: 
          _hj_i___0 += (unsigned int )*(_hj_key___0 + 2) << 16;
          case 2U: 
          _hj_i___0 += (unsigned int )*(_hj_key___0 + 1) << 8;
          case 1U: 
          _hj_i___0 += (unsigned int )*(_hj_key___0 + 0);
          }
          while (1) {
            _hj_i___0 -= _hj_j___0;
            _hj_i___0 -= _hf_hashv___0;
            _hj_i___0 ^= _hf_hashv___0 >> 13;
            _hj_j___0 -= _hf_hashv___0;
            _hj_j___0 -= _hj_i___0;
            _hj_j___0 ^= _hj_i___0 << 8;
            _hf_hashv___0 -= _hj_i___0;
            _hf_hashv___0 -= _hj_j___0;
            _hf_hashv___0 ^= _hj_j___0 >> 13;
            _hj_i___0 -= _hj_j___0;
            _hj_i___0 -= _hf_hashv___0;
            _hj_i___0 ^= _hf_hashv___0 >> 12;
            _hj_j___0 -= _hf_hashv___0;
            _hj_j___0 -= _hj_i___0;
            _hj_j___0 ^= _hj_i___0 << 16;
            _hf_hashv___0 -= _hj_i___0;
            _hf_hashv___0 -= _hj_j___0;
            _hf_hashv___0 ^= _hj_j___0 >> 5;
            _hj_i___0 -= _hj_j___0;
            _hj_i___0 -= _hf_hashv___0;
            _hj_i___0 ^= _hf_hashv___0 >> 3;
            _hj_j___0 -= _hf_hashv___0;
            _hj_j___0 -= _hj_i___0;
            _hj_j___0 ^= _hj_i___0 << 10;
            _hf_hashv___0 -= _hj_i___0;
            _hf_hashv___0 -= _hj_j___0;
            _hf_hashv___0 ^= _hj_j___0 >> 15;
            break;
          }
          break;
        }
        break;
      }
      while (1) {
        var = (varpeek_var_t *)((void *)0);
        if (entry->varmap) {
          while (1) {
            _hf_bkt___0 = _hf_hashv___0 & (((entry->varmap)->hh.tbl)->num_buckets - 1U);
            break;
          }
          while (1) {
            if ((unsigned long )(((entry->varmap)->hh.tbl)->buckets + _hf_bkt___0)->hh_head != (unsigned long )((void *)0)) {
              while (1) {
                var = (varpeek_var_t *)((void *)((char *)(((entry->varmap)->hh.tbl)->buckets + _hf_bkt___0)->hh_head - ((entry->varmap)->hh.tbl)->hho));
                break;
              }
            } else {
              var = (varpeek_var_t *)((void *)0);
            }
            while ((unsigned long )var != (unsigned long )((void *)0)) {
              if (var->hh.hashv == _hf_hashv___0) {
                if ((size_t )var->hh.keylen == tmp_len) {
                  tmp___2 = memcmp((void const   *)var->hh.key, (void const   *)(tmp),
                                   tmp_len);
                  if (tmp___2 == 0) {
                    break;
                  }
                }
              }
              if ((unsigned long )var->hh.hh_next != (unsigned long )((void *)0)) {
                while (1) {
                  var = (varpeek_var_t *)((void *)((char *)var->hh.hh_next - ((entry->varmap)->hh.tbl)->hho));
                  break;
                }
              } else {
                var = (varpeek_var_t *)((void *)0);
              }
            }
            break;
          }
        }
        break;
      }
      break;
    }
    if (! var) {
      goto __Cont;
    }
    num_vars_found ++;
    while (1) {
      rv = copy_proc_mem(context->target.pid, "zval", (void *)((zval_72 *)remote_execute_data + (5 + i)),
                         (void *)(& zv), sizeof(zv));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    while (1) {
      rv = sprint_zval_72(context, & zv, tmp, sizeof(tmp), & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    context->event.varpeek.entry = entry;
    context->event.varpeek.var = var;
    context->event.varpeek.zval_str = tmp;
    while (1) {
      rv = (*(context->event_handler))(context, 3);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    if (num_vars_found >= num_vars_peeking) {
      break;
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  return (0);
}
}
static int copy_executor_globals_72(trace_context_t *context , zend_executor_globals_72 *executor_globals ) 
{ 
  int rv ;

  {
  executor_globals->current_execute_data = (zend_execute_data_72 *)((void *)0);
  while (1) {
    rv = copy_proc_mem(context->target.pid, "executor_globals", (void *)context->target.executor_globals_addr,
                       (void *)executor_globals, sizeof(*executor_globals));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  return (0);
}
}
static int copy_zarray_bucket_72(trace_context_t *context , zend_array_72 *rzarray ,
                                 char const   *key , Bucket_72 *lbucket ) 
{ 
  int rv ;
  zend_array_72 lzarray ;
  uint32_t hash_table_size ;
  uint64_t hash_val ;
  uint32_t hash_index ;
  uint32_t hash_table_val ;
  uint32_t *hash_bucket ;
  char tmp_key[256] ;
  size_t tmp_len ;
  size_t tmp ;
  int tmp___0 ;

  {
  while (1) {
    rv = copy_proc_mem(context->target.pid, "array", (void *)rzarray, (void *)(& lzarray),
                       sizeof(lzarray));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  tmp = strlen(key);
  hash_val = phpspy_zend_inline_hash_func(key, tmp);
  hash_table_size = (uint32_t )(-1 * (int32_t )lzarray.nTableMask);
  hash_index = (uint32_t )(hash_val % (unsigned long )hash_table_size);
  while (1) {
    rv = copy_proc_mem(context->target.pid, "hash_table_val", (void *)(((uint32_t *)lzarray.arData - hash_table_size) + hash_index),
                       (void *)(& hash_table_val), sizeof(uint32_t ));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  hash_bucket = & hash_table_val;
  while (1) {
    if (*hash_bucket == 4294967295U) {
      return (1);
    }
    while (1) {
      rv = copy_proc_mem(context->target.pid, "bucket", (void *)(lzarray.arData + *hash_bucket),
                         (void *)lbucket, sizeof(Bucket_72 ));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    if ((unsigned long )lbucket->key == (unsigned long )((void *)0)) {
      break;
    }
    while (1) {
      rv = sprint_zstring_72(context, "array_key", lbucket->key, tmp_key, sizeof(tmp_key),
                             & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    tmp___0 = strcmp(key, (char const   *)(tmp_key));
    if (tmp___0 == 0) {
      hash_bucket = (uint32_t *)((void *)0);
    } else {
      hash_bucket = & lbucket->val.u2.next;
    }
    if (! hash_bucket) {
      break;
    }
  }
  return (0);
}
}
static int sprint_zstring_72(trace_context_t *context , char const   *what , zend_string_72 *rzstring ,
                             char *buf___0 , size_t buf_size , size_t *buf_len___0 ) 
{ 
  int rv ;
  zend_string_72 lzstring ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  *buf___0 = (char )'\000';
  *buf_len___0 = (size_t )0;
  while (1) {
    rv = copy_proc_mem(context->target.pid, what, (void *)rzstring, (void *)(& lzstring),
                       sizeof(lzstring));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  if (1UL > buf_size) {
    tmp___1 = (size_t )1;
  } else {
    tmp___1 = buf_size;
  }
  if (lzstring.len < tmp___1 - 1UL) {
    *buf_len___0 = lzstring.len;
  } else {
    if (1UL > buf_size) {
      tmp___0 = (size_t )1;
    } else {
      tmp___0 = buf_size;
    }
    *buf_len___0 = tmp___0 - 1UL;
  }
  while (1) {
    rv = copy_proc_mem(context->target.pid, what, (void *)((char *)rzstring + (unsigned long )(& ((zend_string_72 *)0)->val)),
                       (void *)buf___0, *buf_len___0);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  *(buf___0 + (int )*buf_len___0) = (char )'\000';
  return (0);
}
}
static int sprint_zval_72(trace_context_t *context , zval_72 *lzval , char *buf___0 ,
                          size_t buf_size , size_t *buf_len___0 ) 
{ 
  int rv ;
  int type ;

  {
  type = (int )lzval->u1.v.type;
  switch (type) {
  case 4: 
  snprintf((char * __restrict  )buf___0, buf_size, (char const   * __restrict  )"%ld",
           lzval->value.lval);
  *buf_len___0 = strlen((char const   *)buf___0);
  break;
  case 5: 
  snprintf((char * __restrict  )buf___0, buf_size, (char const   * __restrict  )"%f",
           lzval->value.dval);
  *buf_len___0 = strlen((char const   *)buf___0);
  break;
  case 6: 
  while (1) {
    rv = sprint_zstring_72(context, "zval", lzval->value.str, buf___0, buf_size, buf_len___0);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  break;
  case 7: 
  while (1) {
    rv = sprint_zarray_72(context, lzval->value.arr, buf___0, buf_size, buf_len___0);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  break;
  default: 
  return (1);
  }
  return (0);
}
}
static int sprint_zarray_72(trace_context_t *context , zend_array_72 *rzarray , char *buf___0 ,
                            size_t buf_size , size_t *buf_len___0 ) 
{ 
  int rv ;
  int i ;
  int array_len ;
  size_t tmp_len ;
  Bucket_72 buckets[128] ;
  zend_array_72 lzarray ;
  char *obuf ;

  {
  obuf = buf___0;
  while (1) {
    rv = copy_proc_mem(context->target.pid, "array", (void *)rzarray, (void *)(& lzarray),
                       sizeof(lzarray));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  if (lzarray.nNumOfElements < 128U) {
    array_len = (int )lzarray.nNumOfElements;
  } else {
    array_len = 128;
  }
  while (1) {
    rv = copy_proc_mem(context->target.pid, "buckets", (void *)lzarray.arData, (void *)(buckets),
                       sizeof(Bucket_72 ) * (unsigned long )array_len);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  i = 0;
  while (i < array_len) {
    while (1) {
      rv = sprint_zarray_bucket_72(context, buckets + i, buf___0, buf_size, & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    buf_size -= tmp_len;
    buf___0 += tmp_len;
    if (buf_size >= 2UL) {
      *buf___0 = (char )',';
      buf_size --;
      buf___0 ++;
    }
    i ++;
  }
  *buf_len___0 = (size_t )(buf___0 - obuf);
  return (0);
}
}
static int sprint_zarray_val72(trace_context_t *context , zend_array_72 *rzarray ,
                               char const   *key , char *buf___0 , size_t buf_size ,
                               size_t *buf_len___0 ) 
{ 
  int rv ;
  Bucket_72 bucket ;

  {
  while (1) {
    rv = copy_zarray_bucket_72(context, rzarray, key, & bucket);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = sprint_zval_72(context, & bucket.val, buf___0, buf_size, buf_len___0);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  return (0);
}
}
static int sprint_zarray_bucket_72(trace_context_t *context , Bucket_72 *lbucket ,
                                   char *buf___0 , size_t buf_size , size_t *buf_len___0 ) 
{ 
  int rv ;
  char tmp_key[256] ;
  size_t tmp_len ;
  char *obuf ;

  {
  obuf = buf___0;
  if ((unsigned long )lbucket->key != (unsigned long )((void *)0)) {
    while (1) {
      rv = sprint_zstring_72(context, "array_key", lbucket->key, tmp_key, sizeof(tmp_key),
                             & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    if (buf_size > (tmp_len + 1UL) + 1UL) {
      snprintf((char * __restrict  )buf___0, buf_size, (char const   * __restrict  )"%s=",
               tmp_key);
      buf_size -= tmp_len + 1UL;
      buf___0 += tmp_len + 1UL;
    }
  }
  while (1) {
    rv = sprint_zval_72(context, & lbucket->val, buf___0, buf_size, & tmp_len);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  buf___0 += tmp_len;
  *buf_len___0 = (size_t )(buf___0 - obuf);
  return (0);
}
}
static int trace_stack_73(trace_context_t *context , zend_execute_data_73 *remote_execute_data ,
                          int *depth ) ;
static int trace_request_info_73(trace_context_t *context ) ;
static int trace_memory_info_73(trace_context_t *context ) ;
static int trace_globals_73(trace_context_t *context ) ;
static int trace_locals_73(trace_context_t *context , zend_op_73 *zop , zend_execute_data_73 *remote_execute_data ,
                           zend_op_array_73 *op_array , char *file , int file_len ) ;
static int copy_executor_globals_73(trace_context_t *context , zend_executor_globals_73 *executor_globals ) ;
static int copy_zarray_bucket_73(trace_context_t *context , zend_array_73 *rzarray ,
                                 char const   *key , Bucket_73 *lbucket ) ;
static int sprint_zstring_73(trace_context_t *context , char const   *what , zend_string_73 *rzstring ,
                             char *buf___0 , size_t buf_size , size_t *buf_len___0 ) ;
static int sprint_zval_73(trace_context_t *context , zval_73 *lzval , char *buf___0 ,
                          size_t buf_size , size_t *buf_len___0 ) ;
static int sprint_zarray_73(trace_context_t *context , zend_array_73 *rzarray , char *buf___0 ,
                            size_t buf_size , size_t *buf_len___0 ) ;
static int sprint_zarray_val73(trace_context_t *context , zend_array_73 *rzarray ,
                               char const   *key , char *buf___0 , size_t buf_size ,
                               size_t *buf_len___0 ) ;
static int sprint_zarray_bucket_73(trace_context_t *context , Bucket_73 *lbucket ,
                                   char *buf___0 , size_t buf_size , size_t *buf_len___0 ) ;
static int do_trace_73(trace_context_t *context ) 
{ 
  int rv ;
  int depth ;
  zend_executor_globals_73 executor_globals ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;

  {
  while (1) {
    rv = copy_executor_globals_73(context, & executor_globals);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = (*(context->event_handler))(context, 1);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  rv = 0;
  while (1) {
    tmp = trace_stack_73(context, executor_globals.current_execute_data, & depth);
    rv |= tmp;
    while (1) {
      if ((rv & 2) != 0) {
        break;
      } else
      if ((rv & 4) != 0) {
        break;
      } else
      if (! opt_continue_on_error) {
        break;
      }
      break;
    }
    if (depth < 1) {
      break;
    }
    if (opt_capture_req) {
      tmp___0 = trace_request_info_73(context);
      rv |= tmp___0;
      while (1) {
        if ((rv & 2) != 0) {
          break;
        } else
        if ((rv & 4) != 0) {
          break;
        } else
        if (! opt_continue_on_error) {
          break;
        }
        break;
      }
    }
    if (opt_capture_mem) {
      tmp___1 = trace_memory_info_73(context);
      rv |= tmp___1;
      while (1) {
        if ((rv & 2) != 0) {
          break;
        } else
        if ((rv & 4) != 0) {
          break;
        } else
        if (! opt_continue_on_error) {
          break;
        }
        break;
      }
    }
    if ((unsigned long )glopeek_map != (unsigned long )((void *)0)) {
      tmp___3 = (glopeek_map->hh.tbl)->num_items;
    } else {
      tmp___3 = 0U;
    }
    if (tmp___3 > 0U) {
      tmp___2 = trace_globals_73(context);
      rv |= tmp___2;
      while (1) {
        if ((rv & 2) != 0) {
          break;
        } else
        if ((rv & 4) != 0) {
          break;
        } else
        if (! opt_continue_on_error) {
          break;
        }
        break;
      }
    }
    break;
  }
  if (rv == 0) {
    goto _L;
  } else
  if (opt_continue_on_error) {
    _L: /* CIL Label */ 
    while (1) {
      rv = (*(context->event_handler))(context, 7);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
  }
  return (0);
}
}
static int trace_stack_73(trace_context_t *context , zend_execute_data_73 *remote_execute_data ,
                          int *depth ) 
{ 
  int rv ;
  zend_execute_data_73 execute_data ;
  zend_function_73 zfunc ;
  zend_string_73 zstring ;
  zend_class_entry_73 zce ;
  zend_op_73 zop ;
  trace_target_t *target ;
  trace_frame_t *frame ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
  target = & context->target;
  frame = & context->event.frame;
  *depth = 0;
  while (1) {
    if (remote_execute_data) {
      if (! (*depth != opt_max_stack_depth)) {
        break;
      }
    } else {
      break;
    }
    memset((void *)(& execute_data), 0, sizeof(execute_data));
    memset((void *)(& zfunc), 0, sizeof(zfunc));
    memset((void *)(& zstring), 0, sizeof(zstring));
    memset((void *)(& zce), 0, sizeof(zce));
    memset((void *)(& zop), 0, sizeof(zop));
    while (1) {
      rv = copy_proc_mem(context->target.pid, "execute_data", (void *)remote_execute_data,
                         (void *)(& execute_data), sizeof(execute_data));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    while (1) {
      rv = copy_proc_mem(context->target.pid, "zfunc", (void *)execute_data.func,
                         (void *)(& zfunc), sizeof(zfunc));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    if (zfunc.common.function_name) {
      while (1) {
        rv = sprint_zstring_73(context, "function_name", zfunc.common.function_name,
                               frame->loc.func, sizeof(frame->loc.func), & frame->loc.func_len);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
    } else {
      tmp = snprintf((char * __restrict  )(frame->loc.func), sizeof(frame->loc.func),
                     (char const   * __restrict  )"<main>");
      frame->loc.func_len = (size_t )tmp;
    }
    if (zfunc.common.scope) {
      while (1) {
        rv = copy_proc_mem(context->target.pid, "zce", (void *)zfunc.common.scope,
                           (void *)(& zce), sizeof(zce));
        if (rv != 0) {
          return (rv);
        }
        break;
      }
      while (1) {
        rv = sprint_zstring_73(context, "class_name", zce.name, frame->loc.class,
                               sizeof(frame->loc.class), & frame->loc.class_len);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
    } else {
      frame->loc.class[0] = (char )'\000';
      frame->loc.class_len = (size_t )0;
    }
    if ((int )zfunc.type == 2) {
      while (1) {
        rv = sprint_zstring_73(context, "filename", zfunc.op_array.filename, frame->loc.file,
                               sizeof(frame->loc.file), & frame->loc.file_len);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
      frame->loc.lineno = (int )zfunc.op_array.line_start;
      if ((unsigned long )varpeek_map != (unsigned long )((void *)0)) {
        tmp___1 = (varpeek_map->hh.tbl)->num_items;
      } else {
        tmp___1 = 0U;
      }
      if (tmp___1 > 0U) {
        tmp___0 = copy_proc_mem(target->pid, "opline", (void *)execute_data.opline,
                                (void *)(& zop), sizeof(zop));
        if (tmp___0 == 0) {
          trace_locals_73(context, & zop, remote_execute_data, & zfunc.op_array, frame->loc.file,
                          (int )frame->loc.file_len);
        }
      }
    } else {
      tmp___2 = snprintf((char * __restrict  )(frame->loc.file), sizeof(frame->loc.file),
                         (char const   * __restrict  )"<internal>");
      frame->loc.file_len = (size_t )tmp___2;
      frame->loc.lineno = -1;
    }
    frame->depth = *depth;
    while (1) {
      rv = (*(context->event_handler))(context, 2);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    remote_execute_data = execute_data.prev_execute_data;
    (*depth) ++;
  }
  return (0);
}
}
static int trace_request_info_73(trace_context_t *context ) 
{ 
  int rv ;
  sapi_globals_struct_73 sapi_globals ;
  trace_target_t *target ;
  trace_request_t *request ;

  {
  memset((void *)(& sapi_globals), 0, sizeof(sapi_globals));
  request = & context->event.request;
  target = & context->target;
  while (1) {
    rv = copy_proc_mem(context->target.pid, "sapi_globals", (void *)target->sapi_globals_addr,
                       (void *)(& sapi_globals), sizeof(sapi_globals));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    if (opt_capture_req_qstring) {
      if (sapi_globals.request_info.query_string) {
        while (1) {
          rv = copy_proc_mem(context->target.pid, "query_string", (void *)sapi_globals.request_info.query_string,
                             (void *)(request->qstring), (size_t )256);
          if (rv != 0) {
            return (rv);
          }
          break;
        }
      } else {
        request->qstring[0] = (char )'-';
        request->qstring[1] = (char )'\000';
      }
    } else {
      request->qstring[0] = (char )'-';
      request->qstring[1] = (char )'\000';
    }
    break;
  }
  while (1) {
    if (opt_capture_req_cookie) {
      if (sapi_globals.request_info.cookie_data) {
        while (1) {
          rv = copy_proc_mem(context->target.pid, "cookie_data", (void *)sapi_globals.request_info.cookie_data,
                             (void *)(request->cookie), (size_t )256);
          if (rv != 0) {
            return (rv);
          }
          break;
        }
      } else {
        request->cookie[0] = (char )'-';
        request->cookie[1] = (char )'\000';
      }
    } else {
      request->cookie[0] = (char )'-';
      request->cookie[1] = (char )'\000';
    }
    break;
  }
  while (1) {
    if (opt_capture_req_uri) {
      if (sapi_globals.request_info.request_uri) {
        while (1) {
          rv = copy_proc_mem(context->target.pid, "request_uri", (void *)sapi_globals.request_info.request_uri,
                             (void *)(request->uri), (size_t )256);
          if (rv != 0) {
            return (rv);
          }
          break;
        }
      } else {
        request->uri[0] = (char )'-';
        request->uri[1] = (char )'\000';
      }
    } else {
      request->uri[0] = (char )'-';
      request->uri[1] = (char )'\000';
    }
    break;
  }
  while (1) {
    if (opt_capture_req_path) {
      if (sapi_globals.request_info.path_translated) {
        while (1) {
          rv = copy_proc_mem(context->target.pid, "path_translated", (void *)sapi_globals.request_info.path_translated,
                             (void *)(request->path), (size_t )256);
          if (rv != 0) {
            return (rv);
          }
          break;
        }
      } else {
        request->path[0] = (char )'-';
        request->path[1] = (char )'\000';
      }
    } else {
      request->path[0] = (char )'-';
      request->path[1] = (char )'\000';
    }
    break;
  }
  request->ts = sapi_globals.global_request_time;
  while (1) {
    rv = (*(context->event_handler))(context, 5);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  return (0);
}
}
static int trace_memory_info_73(trace_context_t *context ) 
{ 
  int rv ;
  zend_mm_heap_73 mm_heap ;
  zend_alloc_globals_73 alloc_globals ;
  trace_target_t *target ;

  {
  memset((void *)(& mm_heap), 0, sizeof(mm_heap));
  alloc_globals.mm_heap = (zend_mm_heap_73 *)((void *)0);
  target = & context->target;
  while (1) {
    rv = copy_proc_mem(context->target.pid, "alloc_globals", (void *)target->alloc_globals_addr,
                       (void *)(& alloc_globals), sizeof(alloc_globals));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = copy_proc_mem(context->target.pid, "mm_heap", (void *)alloc_globals.mm_heap,
                       (void *)(& mm_heap), sizeof(mm_heap));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  context->event.mem.size = mm_heap.size;
  context->event.mem.peak = mm_heap.peak;
  while (1) {
    rv = (*(context->event_handler))(context, 6);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  return (0);
}
}
static int trace_globals_73(trace_context_t *context ) 
{ 
  int rv ;
  glopeek_entry_t *gentry ;
  glopeek_entry_t *gentry_tmp ;
  zend_array_73 *garray ;
  zend_array_73 *symtable ;
  Bucket_73 lbucket ;
  void *tmp ;
  void *tmp___0 ;

  {
  symtable = (zend_array_73 *)(context->target.executor_globals_addr + (unsigned long )(& ((zend_executor_globals_73 *)0)->symbol_table));
  gentry = glopeek_map;
  if ((unsigned long )glopeek_map != (unsigned long )((void *)0)) {
    tmp = glopeek_map->hh.next;
  } else {
    tmp = (void *)0;
  }
  gentry_tmp = (glopeek_entry_t *)tmp;
  while ((unsigned long )gentry != (unsigned long )((void *)0)) {
    if (gentry->gloname[0]) {
      while (1) {
        rv = copy_zarray_bucket_73(context, symtable, (char const   *)(gentry->gloname),
                                   & lbucket);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
      garray = lbucket.val.value.arr;
    } else {
      garray = symtable;
    }
    rv = sprint_zarray_val73(context, garray, (char const   *)(gentry->varname), context->buf,
                             sizeof(context->buf), & context->buf_len);
    if (rv == 0) {
      context->event.glopeek.gentry = gentry;
      context->event.glopeek.zval_str = context->buf;
      while (1) {
        rv = (*(context->event_handler))(context, 4);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
    }
    gentry = gentry_tmp;
    if ((unsigned long )gentry_tmp != (unsigned long )((void *)0)) {
      tmp___0 = gentry_tmp->hh.next;
    } else {
      tmp___0 = (void *)0;
    }
    gentry_tmp = (glopeek_entry_t *)tmp___0;
  }
  return (0);
}
}
static int trace_locals_73(trace_context_t *context , zend_op_73 *zop , zend_execute_data_73 *remote_execute_data ,
                           zend_op_array_73 *op_array , char *file , int file_len ) 
{ 
  int rv ;
  int i ;
  int num_vars_found ;
  int num_vars_peeking ;
  char tmp[256] ;
  size_t tmp_len ;
  zend_string_73 *zstrp ;
  varpeek_entry_t *entry ;
  varpeek_var_t *var ;
  char varpeek_key[256] ;
  zval_73 zv ;
  unsigned int _uthash_hfstr_keylen ;
  size_t tmp___0 ;
  unsigned int _hf_hashv ;
  unsigned int _hj_i ;
  unsigned int _hj_j ;
  unsigned int _hj_k ;
  unsigned char const   *_hj_key ;
  unsigned int _hf_bkt ;
  int tmp___1 ;
  unsigned int _hf_hashv___0 ;
  unsigned int _hj_i___0 ;
  unsigned int _hj_j___0 ;
  unsigned int _hj_k___0 ;
  unsigned char const   *_hj_key___0 ;
  unsigned int _hf_bkt___0 ;
  int tmp___2 ;

  {
  snprintf((char * __restrict  )(varpeek_key), sizeof(varpeek_key), (char const   * __restrict  )"%.*s:%d",
           file_len, file, zop->lineno);
  while (1) {
    tmp___0 = strlen((char const   *)(varpeek_key));
    _uthash_hfstr_keylen = (unsigned int )tmp___0;
    while (1) {
      while (1) {
        while (1) {
          _hj_key = (unsigned char const   *)(varpeek_key);
          _hf_hashv = 4276993775U;
          _hj_j = 2654435769U;
          _hj_i = _hj_j;
          _hj_k = _uthash_hfstr_keylen;
          while (_hj_k >= 12U) {
            _hj_i += (((unsigned int )*(_hj_key + 0) + ((unsigned int )*(_hj_key + 1) << 8)) + ((unsigned int )*(_hj_key + 2) << 16)) + ((unsigned int )*(_hj_key + 3) << 24);
            _hj_j += (((unsigned int )*(_hj_key + 4) + ((unsigned int )*(_hj_key + 5) << 8)) + ((unsigned int )*(_hj_key + 6) << 16)) + ((unsigned int )*(_hj_key + 7) << 24);
            _hf_hashv += (((unsigned int )*(_hj_key + 8) + ((unsigned int )*(_hj_key + 9) << 8)) + ((unsigned int )*(_hj_key + 10) << 16)) + ((unsigned int )*(_hj_key + 11) << 24);
            while (1) {
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 13;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 8;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 13;
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 12;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 16;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 5;
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 3;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 10;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 15;
              break;
            }
            _hj_key += 12;
            _hj_k -= 12U;
          }
          _hf_hashv += _uthash_hfstr_keylen;
          switch (_hj_k) {
          case 11U: 
          _hf_hashv += (unsigned int )*(_hj_key + 10) << 24;
          case 10U: 
          _hf_hashv += (unsigned int )*(_hj_key + 9) << 16;
          case 9U: 
          _hf_hashv += (unsigned int )*(_hj_key + 8) << 8;
          case 8U: 
          _hj_j += (unsigned int )*(_hj_key + 7) << 24;
          case 7U: 
          _hj_j += (unsigned int )*(_hj_key + 6) << 16;
          case 6U: 
          _hj_j += (unsigned int )*(_hj_key + 5) << 8;
          case 5U: 
          _hj_j += (unsigned int )*(_hj_key + 4);
          case 4U: 
          _hj_i += (unsigned int )*(_hj_key + 3) << 24;
          case 3U: 
          _hj_i += (unsigned int )*(_hj_key + 2) << 16;
          case 2U: 
          _hj_i += (unsigned int )*(_hj_key + 1) << 8;
          case 1U: 
          _hj_i += (unsigned int )*(_hj_key + 0);
          }
          while (1) {
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 13;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 8;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 13;
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 12;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 16;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 5;
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 3;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 10;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 15;
            break;
          }
          break;
        }
        break;
      }
      while (1) {
        entry = (varpeek_entry_t *)((void *)0);
        if (varpeek_map) {
          while (1) {
            _hf_bkt = _hf_hashv & ((varpeek_map->hh.tbl)->num_buckets - 1U);
            break;
          }
          while (1) {
            if ((unsigned long )((varpeek_map->hh.tbl)->buckets + _hf_bkt)->hh_head != (unsigned long )((void *)0)) {
              while (1) {
                entry = (varpeek_entry_t *)((void *)((char *)((varpeek_map->hh.tbl)->buckets + _hf_bkt)->hh_head - (varpeek_map->hh.tbl)->hho));
                break;
              }
            } else {
              entry = (varpeek_entry_t *)((void *)0);
            }
            while ((unsigned long )entry != (unsigned long )((void *)0)) {
              if (entry->hh.hashv == _hf_hashv) {
                if (entry->hh.keylen == _uthash_hfstr_keylen) {
                  tmp___1 = memcmp((void const   *)entry->hh.key, (void const   *)(varpeek_key),
                                   (size_t )_uthash_hfstr_keylen);
                  if (tmp___1 == 0) {
                    break;
                  }
                }
              }
              if ((unsigned long )entry->hh.hh_next != (unsigned long )((void *)0)) {
                while (1) {
                  entry = (varpeek_entry_t *)((void *)((char *)entry->hh.hh_next - (varpeek_map->hh.tbl)->hho));
                  break;
                }
              } else {
                entry = (varpeek_entry_t *)((void *)0);
              }
            }
            break;
          }
        }
        break;
      }
      break;
    }
    break;
  }
  if (! entry) {
    return (0);
  }
  num_vars_found = 0;
  if ((unsigned long )entry->varmap != (unsigned long )((void *)0)) {
    num_vars_peeking = (int )((entry->varmap)->hh.tbl)->num_items;
  } else {
    num_vars_peeking = 0;
  }
  i = 0;
  while (i < op_array->last_var) {
    while (1) {
      rv = copy_proc_mem(context->target.pid, "var", (void *)(op_array->vars + i),
                         (void *)(& zstrp), sizeof(zstrp));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    while (1) {
      rv = sprint_zstring_73(context, "var", zstrp, tmp, sizeof(tmp), & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    while (1) {
      while (1) {
        while (1) {
          _hj_key___0 = (unsigned char const   *)(tmp);
          _hf_hashv___0 = 4276993775U;
          _hj_j___0 = 2654435769U;
          _hj_i___0 = _hj_j___0;
          _hj_k___0 = (unsigned int )tmp_len;
          while (_hj_k___0 >= 12U) {
            _hj_i___0 += (((unsigned int )*(_hj_key___0 + 0) + ((unsigned int )*(_hj_key___0 + 1) << 8)) + ((unsigned int )*(_hj_key___0 + 2) << 16)) + ((unsigned int )*(_hj_key___0 + 3) << 24);
            _hj_j___0 += (((unsigned int )*(_hj_key___0 + 4) + ((unsigned int )*(_hj_key___0 + 5) << 8)) + ((unsigned int )*(_hj_key___0 + 6) << 16)) + ((unsigned int )*(_hj_key___0 + 7) << 24);
            _hf_hashv___0 += (((unsigned int )*(_hj_key___0 + 8) + ((unsigned int )*(_hj_key___0 + 9) << 8)) + ((unsigned int )*(_hj_key___0 + 10) << 16)) + ((unsigned int )*(_hj_key___0 + 11) << 24);
            while (1) {
              _hj_i___0 -= _hj_j___0;
              _hj_i___0 -= _hf_hashv___0;
              _hj_i___0 ^= _hf_hashv___0 >> 13;
              _hj_j___0 -= _hf_hashv___0;
              _hj_j___0 -= _hj_i___0;
              _hj_j___0 ^= _hj_i___0 << 8;
              _hf_hashv___0 -= _hj_i___0;
              _hf_hashv___0 -= _hj_j___0;
              _hf_hashv___0 ^= _hj_j___0 >> 13;
              _hj_i___0 -= _hj_j___0;
              _hj_i___0 -= _hf_hashv___0;
              _hj_i___0 ^= _hf_hashv___0 >> 12;
              _hj_j___0 -= _hf_hashv___0;
              _hj_j___0 -= _hj_i___0;
              _hj_j___0 ^= _hj_i___0 << 16;
              _hf_hashv___0 -= _hj_i___0;
              _hf_hashv___0 -= _hj_j___0;
              _hf_hashv___0 ^= _hj_j___0 >> 5;
              _hj_i___0 -= _hj_j___0;
              _hj_i___0 -= _hf_hashv___0;
              _hj_i___0 ^= _hf_hashv___0 >> 3;
              _hj_j___0 -= _hf_hashv___0;
              _hj_j___0 -= _hj_i___0;
              _hj_j___0 ^= _hj_i___0 << 10;
              _hf_hashv___0 -= _hj_i___0;
              _hf_hashv___0 -= _hj_j___0;
              _hf_hashv___0 ^= _hj_j___0 >> 15;
              break;
            }
            _hj_key___0 += 12;
            _hj_k___0 -= 12U;
          }
          _hf_hashv___0 += (unsigned int )tmp_len;
          switch (_hj_k___0) {
          case 11U: 
          _hf_hashv___0 += (unsigned int )*(_hj_key___0 + 10) << 24;
          case 10U: 
          _hf_hashv___0 += (unsigned int )*(_hj_key___0 + 9) << 16;
          case 9U: 
          _hf_hashv___0 += (unsigned int )*(_hj_key___0 + 8) << 8;
          case 8U: 
          _hj_j___0 += (unsigned int )*(_hj_key___0 + 7) << 24;
          case 7U: 
          _hj_j___0 += (unsigned int )*(_hj_key___0 + 6) << 16;
          case 6U: 
          _hj_j___0 += (unsigned int )*(_hj_key___0 + 5) << 8;
          case 5U: 
          _hj_j___0 += (unsigned int )*(_hj_key___0 + 4);
          case 4U: 
          _hj_i___0 += (unsigned int )*(_hj_key___0 + 3) << 24;
          case 3U: 
          _hj_i___0 += (unsigned int )*(_hj_key___0 + 2) << 16;
          case 2U: 
          _hj_i___0 += (unsigned int )*(_hj_key___0 + 1) << 8;
          case 1U: 
          _hj_i___0 += (unsigned int )*(_hj_key___0 + 0);
          }
          while (1) {
            _hj_i___0 -= _hj_j___0;
            _hj_i___0 -= _hf_hashv___0;
            _hj_i___0 ^= _hf_hashv___0 >> 13;
            _hj_j___0 -= _hf_hashv___0;
            _hj_j___0 -= _hj_i___0;
            _hj_j___0 ^= _hj_i___0 << 8;
            _hf_hashv___0 -= _hj_i___0;
            _hf_hashv___0 -= _hj_j___0;
            _hf_hashv___0 ^= _hj_j___0 >> 13;
            _hj_i___0 -= _hj_j___0;
            _hj_i___0 -= _hf_hashv___0;
            _hj_i___0 ^= _hf_hashv___0 >> 12;
            _hj_j___0 -= _hf_hashv___0;
            _hj_j___0 -= _hj_i___0;
            _hj_j___0 ^= _hj_i___0 << 16;
            _hf_hashv___0 -= _hj_i___0;
            _hf_hashv___0 -= _hj_j___0;
            _hf_hashv___0 ^= _hj_j___0 >> 5;
            _hj_i___0 -= _hj_j___0;
            _hj_i___0 -= _hf_hashv___0;
            _hj_i___0 ^= _hf_hashv___0 >> 3;
            _hj_j___0 -= _hf_hashv___0;
            _hj_j___0 -= _hj_i___0;
            _hj_j___0 ^= _hj_i___0 << 10;
            _hf_hashv___0 -= _hj_i___0;
            _hf_hashv___0 -= _hj_j___0;
            _hf_hashv___0 ^= _hj_j___0 >> 15;
            break;
          }
          break;
        }
        break;
      }
      while (1) {
        var = (varpeek_var_t *)((void *)0);
        if (entry->varmap) {
          while (1) {
            _hf_bkt___0 = _hf_hashv___0 & (((entry->varmap)->hh.tbl)->num_buckets - 1U);
            break;
          }
          while (1) {
            if ((unsigned long )(((entry->varmap)->hh.tbl)->buckets + _hf_bkt___0)->hh_head != (unsigned long )((void *)0)) {
              while (1) {
                var = (varpeek_var_t *)((void *)((char *)(((entry->varmap)->hh.tbl)->buckets + _hf_bkt___0)->hh_head - ((entry->varmap)->hh.tbl)->hho));
                break;
              }
            } else {
              var = (varpeek_var_t *)((void *)0);
            }
            while ((unsigned long )var != (unsigned long )((void *)0)) {
              if (var->hh.hashv == _hf_hashv___0) {
                if ((size_t )var->hh.keylen == tmp_len) {
                  tmp___2 = memcmp((void const   *)var->hh.key, (void const   *)(tmp),
                                   tmp_len);
                  if (tmp___2 == 0) {
                    break;
                  }
                }
              }
              if ((unsigned long )var->hh.hh_next != (unsigned long )((void *)0)) {
                while (1) {
                  var = (varpeek_var_t *)((void *)((char *)var->hh.hh_next - ((entry->varmap)->hh.tbl)->hho));
                  break;
                }
              } else {
                var = (varpeek_var_t *)((void *)0);
              }
            }
            break;
          }
        }
        break;
      }
      break;
    }
    if (! var) {
      goto __Cont;
    }
    num_vars_found ++;
    while (1) {
      rv = copy_proc_mem(context->target.pid, "zval", (void *)((zval_73 *)remote_execute_data + (5 + i)),
                         (void *)(& zv), sizeof(zv));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    while (1) {
      rv = sprint_zval_73(context, & zv, tmp, sizeof(tmp), & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    context->event.varpeek.entry = entry;
    context->event.varpeek.var = var;
    context->event.varpeek.zval_str = tmp;
    while (1) {
      rv = (*(context->event_handler))(context, 3);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    if (num_vars_found >= num_vars_peeking) {
      break;
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  return (0);
}
}
static int copy_executor_globals_73(trace_context_t *context , zend_executor_globals_73 *executor_globals ) 
{ 
  int rv ;

  {
  executor_globals->current_execute_data = (zend_execute_data_73 *)((void *)0);
  while (1) {
    rv = copy_proc_mem(context->target.pid, "executor_globals", (void *)context->target.executor_globals_addr,
                       (void *)executor_globals, sizeof(*executor_globals));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  return (0);
}
}
static int copy_zarray_bucket_73(trace_context_t *context , zend_array_73 *rzarray ,
                                 char const   *key , Bucket_73 *lbucket ) 
{ 
  int rv ;
  zend_array_73 lzarray ;
  uint32_t hash_table_size ;
  uint64_t hash_val ;
  uint32_t hash_index ;
  uint32_t hash_table_val ;
  uint32_t *hash_bucket ;
  char tmp_key[256] ;
  size_t tmp_len ;
  size_t tmp ;
  int tmp___0 ;

  {
  while (1) {
    rv = copy_proc_mem(context->target.pid, "array", (void *)rzarray, (void *)(& lzarray),
                       sizeof(lzarray));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  tmp = strlen(key);
  hash_val = phpspy_zend_inline_hash_func(key, tmp);
  hash_table_size = (uint32_t )(-1 * (int32_t )lzarray.nTableMask);
  hash_index = (uint32_t )(hash_val % (unsigned long )hash_table_size);
  while (1) {
    rv = copy_proc_mem(context->target.pid, "hash_table_val", (void *)(((uint32_t *)lzarray.arData - hash_table_size) + hash_index),
                       (void *)(& hash_table_val), sizeof(uint32_t ));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  hash_bucket = & hash_table_val;
  while (1) {
    if (*hash_bucket == 4294967295U) {
      return (1);
    }
    while (1) {
      rv = copy_proc_mem(context->target.pid, "bucket", (void *)(lzarray.arData + *hash_bucket),
                         (void *)lbucket, sizeof(Bucket_73 ));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    if ((unsigned long )lbucket->key == (unsigned long )((void *)0)) {
      break;
    }
    while (1) {
      rv = sprint_zstring_73(context, "array_key", lbucket->key, tmp_key, sizeof(tmp_key),
                             & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    tmp___0 = strcmp(key, (char const   *)(tmp_key));
    if (tmp___0 == 0) {
      hash_bucket = (uint32_t *)((void *)0);
    } else {
      hash_bucket = & lbucket->val.u2.next;
    }
    if (! hash_bucket) {
      break;
    }
  }
  return (0);
}
}
static int sprint_zstring_73(trace_context_t *context , char const   *what , zend_string_73 *rzstring ,
                             char *buf___0 , size_t buf_size , size_t *buf_len___0 ) 
{ 
  int rv ;
  zend_string_73 lzstring ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  *buf___0 = (char )'\000';
  *buf_len___0 = (size_t )0;
  while (1) {
    rv = copy_proc_mem(context->target.pid, what, (void *)rzstring, (void *)(& lzstring),
                       sizeof(lzstring));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  if (1UL > buf_size) {
    tmp___1 = (size_t )1;
  } else {
    tmp___1 = buf_size;
  }
  if (lzstring.len < tmp___1 - 1UL) {
    *buf_len___0 = lzstring.len;
  } else {
    if (1UL > buf_size) {
      tmp___0 = (size_t )1;
    } else {
      tmp___0 = buf_size;
    }
    *buf_len___0 = tmp___0 - 1UL;
  }
  while (1) {
    rv = copy_proc_mem(context->target.pid, what, (void *)((char *)rzstring + (unsigned long )(& ((zend_string_73 *)0)->val)),
                       (void *)buf___0, *buf_len___0);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  *(buf___0 + (int )*buf_len___0) = (char )'\000';
  return (0);
}
}
static int sprint_zval_73(trace_context_t *context , zval_73 *lzval , char *buf___0 ,
                          size_t buf_size , size_t *buf_len___0 ) 
{ 
  int rv ;
  int type ;

  {
  type = (int )lzval->u1.v.type;
  switch (type) {
  case 4: 
  snprintf((char * __restrict  )buf___0, buf_size, (char const   * __restrict  )"%ld",
           lzval->value.lval);
  *buf_len___0 = strlen((char const   *)buf___0);
  break;
  case 5: 
  snprintf((char * __restrict  )buf___0, buf_size, (char const   * __restrict  )"%f",
           lzval->value.dval);
  *buf_len___0 = strlen((char const   *)buf___0);
  break;
  case 6: 
  while (1) {
    rv = sprint_zstring_73(context, "zval", lzval->value.str, buf___0, buf_size, buf_len___0);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  break;
  case 7: 
  while (1) {
    rv = sprint_zarray_73(context, lzval->value.arr, buf___0, buf_size, buf_len___0);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  break;
  default: 
  return (1);
  }
  return (0);
}
}
static int sprint_zarray_73(trace_context_t *context , zend_array_73 *rzarray , char *buf___0 ,
                            size_t buf_size , size_t *buf_len___0 ) 
{ 
  int rv ;
  int i ;
  int array_len ;
  size_t tmp_len ;
  Bucket_73 buckets[128] ;
  zend_array_73 lzarray ;
  char *obuf ;

  {
  obuf = buf___0;
  while (1) {
    rv = copy_proc_mem(context->target.pid, "array", (void *)rzarray, (void *)(& lzarray),
                       sizeof(lzarray));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  if (lzarray.nNumOfElements < 128U) {
    array_len = (int )lzarray.nNumOfElements;
  } else {
    array_len = 128;
  }
  while (1) {
    rv = copy_proc_mem(context->target.pid, "buckets", (void *)lzarray.arData, (void *)(buckets),
                       sizeof(Bucket_73 ) * (unsigned long )array_len);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  i = 0;
  while (i < array_len) {
    while (1) {
      rv = sprint_zarray_bucket_73(context, buckets + i, buf___0, buf_size, & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    buf_size -= tmp_len;
    buf___0 += tmp_len;
    if (buf_size >= 2UL) {
      *buf___0 = (char )',';
      buf_size --;
      buf___0 ++;
    }
    i ++;
  }
  *buf_len___0 = (size_t )(buf___0 - obuf);
  return (0);
}
}
static int sprint_zarray_val73(trace_context_t *context , zend_array_73 *rzarray ,
                               char const   *key , char *buf___0 , size_t buf_size ,
                               size_t *buf_len___0 ) 
{ 
  int rv ;
  Bucket_73 bucket ;

  {
  while (1) {
    rv = copy_zarray_bucket_73(context, rzarray, key, & bucket);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = sprint_zval_73(context, & bucket.val, buf___0, buf_size, buf_len___0);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  return (0);
}
}
static int sprint_zarray_bucket_73(trace_context_t *context , Bucket_73 *lbucket ,
                                   char *buf___0 , size_t buf_size , size_t *buf_len___0 ) 
{ 
  int rv ;
  char tmp_key[256] ;
  size_t tmp_len ;
  char *obuf ;

  {
  obuf = buf___0;
  if ((unsigned long )lbucket->key != (unsigned long )((void *)0)) {
    while (1) {
      rv = sprint_zstring_73(context, "array_key", lbucket->key, tmp_key, sizeof(tmp_key),
                             & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    if (buf_size > (tmp_len + 1UL) + 1UL) {
      snprintf((char * __restrict  )buf___0, buf_size, (char const   * __restrict  )"%s=",
               tmp_key);
      buf_size -= tmp_len + 1UL;
      buf___0 += tmp_len + 1UL;
    }
  }
  while (1) {
    rv = sprint_zval_73(context, & lbucket->val, buf___0, buf_size, & tmp_len);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  buf___0 += tmp_len;
  *buf_len___0 = (size_t )(buf___0 - obuf);
  return (0);
}
}
static int trace_stack_74(trace_context_t *context , zend_execute_data_74 *remote_execute_data ,
                          int *depth ) ;
static int trace_request_info_74(trace_context_t *context ) ;
static int trace_memory_info_74(trace_context_t *context ) ;
static int trace_globals_74(trace_context_t *context ) ;
static int trace_locals_74(trace_context_t *context , zend_op_74 *zop , zend_execute_data_74 *remote_execute_data ,
                           zend_op_array_74 *op_array , char *file , int file_len ) ;
static int copy_executor_globals_74(trace_context_t *context , zend_executor_globals_74 *executor_globals ) ;
static int copy_zarray_bucket_74(trace_context_t *context , zend_array_74 *rzarray ,
                                 char const   *key , Bucket_74 *lbucket ) ;
static int sprint_zstring_74(trace_context_t *context , char const   *what , zend_string_74 *rzstring ,
                             char *buf___0 , size_t buf_size , size_t *buf_len___0 ) ;
static int sprint_zval_74(trace_context_t *context , zval_74 *lzval , char *buf___0 ,
                          size_t buf_size , size_t *buf_len___0 ) ;
static int sprint_zarray_74(trace_context_t *context , zend_array_74 *rzarray , char *buf___0 ,
                            size_t buf_size , size_t *buf_len___0 ) ;
static int sprint_zarray_val74(trace_context_t *context , zend_array_74 *rzarray ,
                               char const   *key , char *buf___0 , size_t buf_size ,
                               size_t *buf_len___0 ) ;
static int sprint_zarray_bucket_74(trace_context_t *context , Bucket_74 *lbucket ,
                                   char *buf___0 , size_t buf_size , size_t *buf_len___0 ) ;
static int do_trace_74(trace_context_t *context ) 
{ 
  int rv ;
  int depth ;
  zend_executor_globals_74 executor_globals ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;

  {
  while (1) {
    rv = copy_executor_globals_74(context, & executor_globals);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = (*(context->event_handler))(context, 1);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  rv = 0;
  while (1) {
    tmp = trace_stack_74(context, executor_globals.current_execute_data, & depth);
    rv |= tmp;
    while (1) {
      if ((rv & 2) != 0) {
        break;
      } else
      if ((rv & 4) != 0) {
        break;
      } else
      if (! opt_continue_on_error) {
        break;
      }
      break;
    }
    if (depth < 1) {
      break;
    }
    if (opt_capture_req) {
      tmp___0 = trace_request_info_74(context);
      rv |= tmp___0;
      while (1) {
        if ((rv & 2) != 0) {
          break;
        } else
        if ((rv & 4) != 0) {
          break;
        } else
        if (! opt_continue_on_error) {
          break;
        }
        break;
      }
    }
    if (opt_capture_mem) {
      tmp___1 = trace_memory_info_74(context);
      rv |= tmp___1;
      while (1) {
        if ((rv & 2) != 0) {
          break;
        } else
        if ((rv & 4) != 0) {
          break;
        } else
        if (! opt_continue_on_error) {
          break;
        }
        break;
      }
    }
    if ((unsigned long )glopeek_map != (unsigned long )((void *)0)) {
      tmp___3 = (glopeek_map->hh.tbl)->num_items;
    } else {
      tmp___3 = 0U;
    }
    if (tmp___3 > 0U) {
      tmp___2 = trace_globals_74(context);
      rv |= tmp___2;
      while (1) {
        if ((rv & 2) != 0) {
          break;
        } else
        if ((rv & 4) != 0) {
          break;
        } else
        if (! opt_continue_on_error) {
          break;
        }
        break;
      }
    }
    break;
  }
  if (rv == 0) {
    goto _L;
  } else
  if (opt_continue_on_error) {
    _L: /* CIL Label */ 
    while (1) {
      rv = (*(context->event_handler))(context, 7);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
  }
  return (0);
}
}
static int trace_stack_74(trace_context_t *context , zend_execute_data_74 *remote_execute_data ,
                          int *depth ) 
{ 
  int rv ;
  zend_execute_data_74 execute_data ;
  zend_function_74 zfunc ;
  zend_string_74 zstring ;
  zend_class_entry_74 zce ;
  zend_op_74 zop ;
  trace_target_t *target ;
  trace_frame_t *frame ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
  target = & context->target;
  frame = & context->event.frame;
  *depth = 0;
  while (1) {
    if (remote_execute_data) {
      if (! (*depth != opt_max_stack_depth)) {
        break;
      }
    } else {
      break;
    }
    memset((void *)(& execute_data), 0, sizeof(execute_data));
    memset((void *)(& zfunc), 0, sizeof(zfunc));
    memset((void *)(& zstring), 0, sizeof(zstring));
    memset((void *)(& zce), 0, sizeof(zce));
    memset((void *)(& zop), 0, sizeof(zop));
    while (1) {
      rv = copy_proc_mem(context->target.pid, "execute_data", (void *)remote_execute_data,
                         (void *)(& execute_data), sizeof(execute_data));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    while (1) {
      rv = copy_proc_mem(context->target.pid, "zfunc", (void *)execute_data.func,
                         (void *)(& zfunc), sizeof(zfunc));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    if (zfunc.common.function_name) {
      while (1) {
        rv = sprint_zstring_74(context, "function_name", zfunc.common.function_name,
                               frame->loc.func, sizeof(frame->loc.func), & frame->loc.func_len);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
    } else {
      tmp = snprintf((char * __restrict  )(frame->loc.func), sizeof(frame->loc.func),
                     (char const   * __restrict  )"<main>");
      frame->loc.func_len = (size_t )tmp;
    }
    if (zfunc.common.scope) {
      while (1) {
        rv = copy_proc_mem(context->target.pid, "zce", (void *)zfunc.common.scope,
                           (void *)(& zce), sizeof(zce));
        if (rv != 0) {
          return (rv);
        }
        break;
      }
      while (1) {
        rv = sprint_zstring_74(context, "class_name", zce.name, frame->loc.class,
                               sizeof(frame->loc.class), & frame->loc.class_len);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
    } else {
      frame->loc.class[0] = (char )'\000';
      frame->loc.class_len = (size_t )0;
    }
    if ((int )zfunc.type == 2) {
      while (1) {
        rv = sprint_zstring_74(context, "filename", zfunc.op_array.filename, frame->loc.file,
                               sizeof(frame->loc.file), & frame->loc.file_len);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
      frame->loc.lineno = (int )zfunc.op_array.line_start;
      if ((unsigned long )varpeek_map != (unsigned long )((void *)0)) {
        tmp___1 = (varpeek_map->hh.tbl)->num_items;
      } else {
        tmp___1 = 0U;
      }
      if (tmp___1 > 0U) {
        tmp___0 = copy_proc_mem(target->pid, "opline", (void *)execute_data.opline,
                                (void *)(& zop), sizeof(zop));
        if (tmp___0 == 0) {
          trace_locals_74(context, & zop, remote_execute_data, & zfunc.op_array, frame->loc.file,
                          (int )frame->loc.file_len);
        }
      }
    } else {
      tmp___2 = snprintf((char * __restrict  )(frame->loc.file), sizeof(frame->loc.file),
                         (char const   * __restrict  )"<internal>");
      frame->loc.file_len = (size_t )tmp___2;
      frame->loc.lineno = -1;
    }
    frame->depth = *depth;
    while (1) {
      rv = (*(context->event_handler))(context, 2);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    remote_execute_data = execute_data.prev_execute_data;
    (*depth) ++;
  }
  return (0);
}
}
static int trace_request_info_74(trace_context_t *context ) 
{ 
  int rv ;
  sapi_globals_struct_74 sapi_globals ;
  trace_target_t *target ;
  trace_request_t *request ;

  {
  memset((void *)(& sapi_globals), 0, sizeof(sapi_globals));
  request = & context->event.request;
  target = & context->target;
  while (1) {
    rv = copy_proc_mem(context->target.pid, "sapi_globals", (void *)target->sapi_globals_addr,
                       (void *)(& sapi_globals), sizeof(sapi_globals));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    if (opt_capture_req_qstring) {
      if (sapi_globals.request_info.query_string) {
        while (1) {
          rv = copy_proc_mem(context->target.pid, "query_string", (void *)sapi_globals.request_info.query_string,
                             (void *)(request->qstring), (size_t )256);
          if (rv != 0) {
            return (rv);
          }
          break;
        }
      } else {
        request->qstring[0] = (char )'-';
        request->qstring[1] = (char )'\000';
      }
    } else {
      request->qstring[0] = (char )'-';
      request->qstring[1] = (char )'\000';
    }
    break;
  }
  while (1) {
    if (opt_capture_req_cookie) {
      if (sapi_globals.request_info.cookie_data) {
        while (1) {
          rv = copy_proc_mem(context->target.pid, "cookie_data", (void *)sapi_globals.request_info.cookie_data,
                             (void *)(request->cookie), (size_t )256);
          if (rv != 0) {
            return (rv);
          }
          break;
        }
      } else {
        request->cookie[0] = (char )'-';
        request->cookie[1] = (char )'\000';
      }
    } else {
      request->cookie[0] = (char )'-';
      request->cookie[1] = (char )'\000';
    }
    break;
  }
  while (1) {
    if (opt_capture_req_uri) {
      if (sapi_globals.request_info.request_uri) {
        while (1) {
          rv = copy_proc_mem(context->target.pid, "request_uri", (void *)sapi_globals.request_info.request_uri,
                             (void *)(request->uri), (size_t )256);
          if (rv != 0) {
            return (rv);
          }
          break;
        }
      } else {
        request->uri[0] = (char )'-';
        request->uri[1] = (char )'\000';
      }
    } else {
      request->uri[0] = (char )'-';
      request->uri[1] = (char )'\000';
    }
    break;
  }
  while (1) {
    if (opt_capture_req_path) {
      if (sapi_globals.request_info.path_translated) {
        while (1) {
          rv = copy_proc_mem(context->target.pid, "path_translated", (void *)sapi_globals.request_info.path_translated,
                             (void *)(request->path), (size_t )256);
          if (rv != 0) {
            return (rv);
          }
          break;
        }
      } else {
        request->path[0] = (char )'-';
        request->path[1] = (char )'\000';
      }
    } else {
      request->path[0] = (char )'-';
      request->path[1] = (char )'\000';
    }
    break;
  }
  request->ts = sapi_globals.global_request_time;
  while (1) {
    rv = (*(context->event_handler))(context, 5);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  return (0);
}
}
static int trace_memory_info_74(trace_context_t *context ) 
{ 
  int rv ;
  zend_mm_heap_74 mm_heap ;
  zend_alloc_globals_74 alloc_globals ;
  trace_target_t *target ;

  {
  memset((void *)(& mm_heap), 0, sizeof(mm_heap));
  alloc_globals.mm_heap = (zend_mm_heap_74 *)((void *)0);
  target = & context->target;
  while (1) {
    rv = copy_proc_mem(context->target.pid, "alloc_globals", (void *)target->alloc_globals_addr,
                       (void *)(& alloc_globals), sizeof(alloc_globals));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = copy_proc_mem(context->target.pid, "mm_heap", (void *)alloc_globals.mm_heap,
                       (void *)(& mm_heap), sizeof(mm_heap));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  context->event.mem.size = mm_heap.size;
  context->event.mem.peak = mm_heap.peak;
  while (1) {
    rv = (*(context->event_handler))(context, 6);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  return (0);
}
}
static int trace_globals_74(trace_context_t *context ) 
{ 
  int rv ;
  glopeek_entry_t *gentry ;
  glopeek_entry_t *gentry_tmp ;
  zend_array_74 *garray ;
  zend_array_74 *symtable ;
  Bucket_74 lbucket ;
  void *tmp ;
  void *tmp___0 ;

  {
  symtable = (zend_array_74 *)(context->target.executor_globals_addr + (unsigned long )(& ((zend_executor_globals_74 *)0)->symbol_table));
  gentry = glopeek_map;
  if ((unsigned long )glopeek_map != (unsigned long )((void *)0)) {
    tmp = glopeek_map->hh.next;
  } else {
    tmp = (void *)0;
  }
  gentry_tmp = (glopeek_entry_t *)tmp;
  while ((unsigned long )gentry != (unsigned long )((void *)0)) {
    if (gentry->gloname[0]) {
      while (1) {
        rv = copy_zarray_bucket_74(context, symtable, (char const   *)(gentry->gloname),
                                   & lbucket);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
      garray = lbucket.val.value.arr;
    } else {
      garray = symtable;
    }
    rv = sprint_zarray_val74(context, garray, (char const   *)(gentry->varname), context->buf,
                             sizeof(context->buf), & context->buf_len);
    if (rv == 0) {
      context->event.glopeek.gentry = gentry;
      context->event.glopeek.zval_str = context->buf;
      while (1) {
        rv = (*(context->event_handler))(context, 4);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
    }
    gentry = gentry_tmp;
    if ((unsigned long )gentry_tmp != (unsigned long )((void *)0)) {
      tmp___0 = gentry_tmp->hh.next;
    } else {
      tmp___0 = (void *)0;
    }
    gentry_tmp = (glopeek_entry_t *)tmp___0;
  }
  return (0);
}
}
static int trace_locals_74(trace_context_t *context , zend_op_74 *zop , zend_execute_data_74 *remote_execute_data ,
                           zend_op_array_74 *op_array , char *file , int file_len ) 
{ 
  int rv ;
  int i ;
  int num_vars_found ;
  int num_vars_peeking ;
  char tmp[256] ;
  size_t tmp_len ;
  zend_string_74 *zstrp ;
  varpeek_entry_t *entry ;
  varpeek_var_t *var ;
  char varpeek_key[256] ;
  zval_74 zv ;
  unsigned int _uthash_hfstr_keylen ;
  size_t tmp___0 ;
  unsigned int _hf_hashv ;
  unsigned int _hj_i ;
  unsigned int _hj_j ;
  unsigned int _hj_k ;
  unsigned char const   *_hj_key ;
  unsigned int _hf_bkt ;
  int tmp___1 ;
  unsigned int _hf_hashv___0 ;
  unsigned int _hj_i___0 ;
  unsigned int _hj_j___0 ;
  unsigned int _hj_k___0 ;
  unsigned char const   *_hj_key___0 ;
  unsigned int _hf_bkt___0 ;
  int tmp___2 ;

  {
  snprintf((char * __restrict  )(varpeek_key), sizeof(varpeek_key), (char const   * __restrict  )"%.*s:%d",
           file_len, file, zop->lineno);
  while (1) {
    tmp___0 = strlen((char const   *)(varpeek_key));
    _uthash_hfstr_keylen = (unsigned int )tmp___0;
    while (1) {
      while (1) {
        while (1) {
          _hj_key = (unsigned char const   *)(varpeek_key);
          _hf_hashv = 4276993775U;
          _hj_j = 2654435769U;
          _hj_i = _hj_j;
          _hj_k = _uthash_hfstr_keylen;
          while (_hj_k >= 12U) {
            _hj_i += (((unsigned int )*(_hj_key + 0) + ((unsigned int )*(_hj_key + 1) << 8)) + ((unsigned int )*(_hj_key + 2) << 16)) + ((unsigned int )*(_hj_key + 3) << 24);
            _hj_j += (((unsigned int )*(_hj_key + 4) + ((unsigned int )*(_hj_key + 5) << 8)) + ((unsigned int )*(_hj_key + 6) << 16)) + ((unsigned int )*(_hj_key + 7) << 24);
            _hf_hashv += (((unsigned int )*(_hj_key + 8) + ((unsigned int )*(_hj_key + 9) << 8)) + ((unsigned int )*(_hj_key + 10) << 16)) + ((unsigned int )*(_hj_key + 11) << 24);
            while (1) {
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 13;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 8;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 13;
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 12;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 16;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 5;
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 3;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 10;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 15;
              break;
            }
            _hj_key += 12;
            _hj_k -= 12U;
          }
          _hf_hashv += _uthash_hfstr_keylen;
          switch (_hj_k) {
          case 11U: 
          _hf_hashv += (unsigned int )*(_hj_key + 10) << 24;
          case 10U: 
          _hf_hashv += (unsigned int )*(_hj_key + 9) << 16;
          case 9U: 
          _hf_hashv += (unsigned int )*(_hj_key + 8) << 8;
          case 8U: 
          _hj_j += (unsigned int )*(_hj_key + 7) << 24;
          case 7U: 
          _hj_j += (unsigned int )*(_hj_key + 6) << 16;
          case 6U: 
          _hj_j += (unsigned int )*(_hj_key + 5) << 8;
          case 5U: 
          _hj_j += (unsigned int )*(_hj_key + 4);
          case 4U: 
          _hj_i += (unsigned int )*(_hj_key + 3) << 24;
          case 3U: 
          _hj_i += (unsigned int )*(_hj_key + 2) << 16;
          case 2U: 
          _hj_i += (unsigned int )*(_hj_key + 1) << 8;
          case 1U: 
          _hj_i += (unsigned int )*(_hj_key + 0);
          }
          while (1) {
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 13;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 8;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 13;
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 12;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 16;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 5;
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 3;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 10;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 15;
            break;
          }
          break;
        }
        break;
      }
      while (1) {
        entry = (varpeek_entry_t *)((void *)0);
        if (varpeek_map) {
          while (1) {
            _hf_bkt = _hf_hashv & ((varpeek_map->hh.tbl)->num_buckets - 1U);
            break;
          }
          while (1) {
            if ((unsigned long )((varpeek_map->hh.tbl)->buckets + _hf_bkt)->hh_head != (unsigned long )((void *)0)) {
              while (1) {
                entry = (varpeek_entry_t *)((void *)((char *)((varpeek_map->hh.tbl)->buckets + _hf_bkt)->hh_head - (varpeek_map->hh.tbl)->hho));
                break;
              }
            } else {
              entry = (varpeek_entry_t *)((void *)0);
            }
            while ((unsigned long )entry != (unsigned long )((void *)0)) {
              if (entry->hh.hashv == _hf_hashv) {
                if (entry->hh.keylen == _uthash_hfstr_keylen) {
                  tmp___1 = memcmp((void const   *)entry->hh.key, (void const   *)(varpeek_key),
                                   (size_t )_uthash_hfstr_keylen);
                  if (tmp___1 == 0) {
                    break;
                  }
                }
              }
              if ((unsigned long )entry->hh.hh_next != (unsigned long )((void *)0)) {
                while (1) {
                  entry = (varpeek_entry_t *)((void *)((char *)entry->hh.hh_next - (varpeek_map->hh.tbl)->hho));
                  break;
                }
              } else {
                entry = (varpeek_entry_t *)((void *)0);
              }
            }
            break;
          }
        }
        break;
      }
      break;
    }
    break;
  }
  if (! entry) {
    return (0);
  }
  num_vars_found = 0;
  if ((unsigned long )entry->varmap != (unsigned long )((void *)0)) {
    num_vars_peeking = (int )((entry->varmap)->hh.tbl)->num_items;
  } else {
    num_vars_peeking = 0;
  }
  i = 0;
  while (i < op_array->last_var) {
    while (1) {
      rv = copy_proc_mem(context->target.pid, "var", (void *)(op_array->vars + i),
                         (void *)(& zstrp), sizeof(zstrp));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    while (1) {
      rv = sprint_zstring_74(context, "var", zstrp, tmp, sizeof(tmp), & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    while (1) {
      while (1) {
        while (1) {
          _hj_key___0 = (unsigned char const   *)(tmp);
          _hf_hashv___0 = 4276993775U;
          _hj_j___0 = 2654435769U;
          _hj_i___0 = _hj_j___0;
          _hj_k___0 = (unsigned int )tmp_len;
          while (_hj_k___0 >= 12U) {
            _hj_i___0 += (((unsigned int )*(_hj_key___0 + 0) + ((unsigned int )*(_hj_key___0 + 1) << 8)) + ((unsigned int )*(_hj_key___0 + 2) << 16)) + ((unsigned int )*(_hj_key___0 + 3) << 24);
            _hj_j___0 += (((unsigned int )*(_hj_key___0 + 4) + ((unsigned int )*(_hj_key___0 + 5) << 8)) + ((unsigned int )*(_hj_key___0 + 6) << 16)) + ((unsigned int )*(_hj_key___0 + 7) << 24);
            _hf_hashv___0 += (((unsigned int )*(_hj_key___0 + 8) + ((unsigned int )*(_hj_key___0 + 9) << 8)) + ((unsigned int )*(_hj_key___0 + 10) << 16)) + ((unsigned int )*(_hj_key___0 + 11) << 24);
            while (1) {
              _hj_i___0 -= _hj_j___0;
              _hj_i___0 -= _hf_hashv___0;
              _hj_i___0 ^= _hf_hashv___0 >> 13;
              _hj_j___0 -= _hf_hashv___0;
              _hj_j___0 -= _hj_i___0;
              _hj_j___0 ^= _hj_i___0 << 8;
              _hf_hashv___0 -= _hj_i___0;
              _hf_hashv___0 -= _hj_j___0;
              _hf_hashv___0 ^= _hj_j___0 >> 13;
              _hj_i___0 -= _hj_j___0;
              _hj_i___0 -= _hf_hashv___0;
              _hj_i___0 ^= _hf_hashv___0 >> 12;
              _hj_j___0 -= _hf_hashv___0;
              _hj_j___0 -= _hj_i___0;
              _hj_j___0 ^= _hj_i___0 << 16;
              _hf_hashv___0 -= _hj_i___0;
              _hf_hashv___0 -= _hj_j___0;
              _hf_hashv___0 ^= _hj_j___0 >> 5;
              _hj_i___0 -= _hj_j___0;
              _hj_i___0 -= _hf_hashv___0;
              _hj_i___0 ^= _hf_hashv___0 >> 3;
              _hj_j___0 -= _hf_hashv___0;
              _hj_j___0 -= _hj_i___0;
              _hj_j___0 ^= _hj_i___0 << 10;
              _hf_hashv___0 -= _hj_i___0;
              _hf_hashv___0 -= _hj_j___0;
              _hf_hashv___0 ^= _hj_j___0 >> 15;
              break;
            }
            _hj_key___0 += 12;
            _hj_k___0 -= 12U;
          }
          _hf_hashv___0 += (unsigned int )tmp_len;
          switch (_hj_k___0) {
          case 11U: 
          _hf_hashv___0 += (unsigned int )*(_hj_key___0 + 10) << 24;
          case 10U: 
          _hf_hashv___0 += (unsigned int )*(_hj_key___0 + 9) << 16;
          case 9U: 
          _hf_hashv___0 += (unsigned int )*(_hj_key___0 + 8) << 8;
          case 8U: 
          _hj_j___0 += (unsigned int )*(_hj_key___0 + 7) << 24;
          case 7U: 
          _hj_j___0 += (unsigned int )*(_hj_key___0 + 6) << 16;
          case 6U: 
          _hj_j___0 += (unsigned int )*(_hj_key___0 + 5) << 8;
          case 5U: 
          _hj_j___0 += (unsigned int )*(_hj_key___0 + 4);
          case 4U: 
          _hj_i___0 += (unsigned int )*(_hj_key___0 + 3) << 24;
          case 3U: 
          _hj_i___0 += (unsigned int )*(_hj_key___0 + 2) << 16;
          case 2U: 
          _hj_i___0 += (unsigned int )*(_hj_key___0 + 1) << 8;
          case 1U: 
          _hj_i___0 += (unsigned int )*(_hj_key___0 + 0);
          }
          while (1) {
            _hj_i___0 -= _hj_j___0;
            _hj_i___0 -= _hf_hashv___0;
            _hj_i___0 ^= _hf_hashv___0 >> 13;
            _hj_j___0 -= _hf_hashv___0;
            _hj_j___0 -= _hj_i___0;
            _hj_j___0 ^= _hj_i___0 << 8;
            _hf_hashv___0 -= _hj_i___0;
            _hf_hashv___0 -= _hj_j___0;
            _hf_hashv___0 ^= _hj_j___0 >> 13;
            _hj_i___0 -= _hj_j___0;
            _hj_i___0 -= _hf_hashv___0;
            _hj_i___0 ^= _hf_hashv___0 >> 12;
            _hj_j___0 -= _hf_hashv___0;
            _hj_j___0 -= _hj_i___0;
            _hj_j___0 ^= _hj_i___0 << 16;
            _hf_hashv___0 -= _hj_i___0;
            _hf_hashv___0 -= _hj_j___0;
            _hf_hashv___0 ^= _hj_j___0 >> 5;
            _hj_i___0 -= _hj_j___0;
            _hj_i___0 -= _hf_hashv___0;
            _hj_i___0 ^= _hf_hashv___0 >> 3;
            _hj_j___0 -= _hf_hashv___0;
            _hj_j___0 -= _hj_i___0;
            _hj_j___0 ^= _hj_i___0 << 10;
            _hf_hashv___0 -= _hj_i___0;
            _hf_hashv___0 -= _hj_j___0;
            _hf_hashv___0 ^= _hj_j___0 >> 15;
            break;
          }
          break;
        }
        break;
      }
      while (1) {
        var = (varpeek_var_t *)((void *)0);
        if (entry->varmap) {
          while (1) {
            _hf_bkt___0 = _hf_hashv___0 & (((entry->varmap)->hh.tbl)->num_buckets - 1U);
            break;
          }
          while (1) {
            if ((unsigned long )(((entry->varmap)->hh.tbl)->buckets + _hf_bkt___0)->hh_head != (unsigned long )((void *)0)) {
              while (1) {
                var = (varpeek_var_t *)((void *)((char *)(((entry->varmap)->hh.tbl)->buckets + _hf_bkt___0)->hh_head - ((entry->varmap)->hh.tbl)->hho));
                break;
              }
            } else {
              var = (varpeek_var_t *)((void *)0);
            }
            while ((unsigned long )var != (unsigned long )((void *)0)) {
              if (var->hh.hashv == _hf_hashv___0) {
                if ((size_t )var->hh.keylen == tmp_len) {
                  tmp___2 = memcmp((void const   *)var->hh.key, (void const   *)(tmp),
                                   tmp_len);
                  if (tmp___2 == 0) {
                    break;
                  }
                }
              }
              if ((unsigned long )var->hh.hh_next != (unsigned long )((void *)0)) {
                while (1) {
                  var = (varpeek_var_t *)((void *)((char *)var->hh.hh_next - ((entry->varmap)->hh.tbl)->hho));
                  break;
                }
              } else {
                var = (varpeek_var_t *)((void *)0);
              }
            }
            break;
          }
        }
        break;
      }
      break;
    }
    if (! var) {
      goto __Cont;
    }
    num_vars_found ++;
    while (1) {
      rv = copy_proc_mem(context->target.pid, "zval", (void *)((zval_74 *)remote_execute_data + (5 + i)),
                         (void *)(& zv), sizeof(zv));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    while (1) {
      rv = sprint_zval_74(context, & zv, tmp, sizeof(tmp), & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    context->event.varpeek.entry = entry;
    context->event.varpeek.var = var;
    context->event.varpeek.zval_str = tmp;
    while (1) {
      rv = (*(context->event_handler))(context, 3);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    if (num_vars_found >= num_vars_peeking) {
      break;
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  return (0);
}
}
static int copy_executor_globals_74(trace_context_t *context , zend_executor_globals_74 *executor_globals ) 
{ 
  int rv ;

  {
  executor_globals->current_execute_data = (zend_execute_data_74 *)((void *)0);
  while (1) {
    rv = copy_proc_mem(context->target.pid, "executor_globals", (void *)context->target.executor_globals_addr,
                       (void *)executor_globals, sizeof(*executor_globals));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  return (0);
}
}
static int copy_zarray_bucket_74(trace_context_t *context , zend_array_74 *rzarray ,
                                 char const   *key , Bucket_74 *lbucket ) 
{ 
  int rv ;
  zend_array_74 lzarray ;
  uint32_t hash_table_size ;
  uint64_t hash_val ;
  uint32_t hash_index ;
  uint32_t hash_table_val ;
  uint32_t *hash_bucket ;
  char tmp_key[256] ;
  size_t tmp_len ;
  size_t tmp ;
  int tmp___0 ;

  {
  while (1) {
    rv = copy_proc_mem(context->target.pid, "array", (void *)rzarray, (void *)(& lzarray),
                       sizeof(lzarray));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  tmp = strlen(key);
  hash_val = phpspy_zend_inline_hash_func(key, tmp);
  hash_table_size = (uint32_t )(-1 * (int32_t )lzarray.nTableMask);
  hash_index = (uint32_t )(hash_val % (unsigned long )hash_table_size);
  while (1) {
    rv = copy_proc_mem(context->target.pid, "hash_table_val", (void *)(((uint32_t *)lzarray.arData - hash_table_size) + hash_index),
                       (void *)(& hash_table_val), sizeof(uint32_t ));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  hash_bucket = & hash_table_val;
  while (1) {
    if (*hash_bucket == 4294967295U) {
      return (1);
    }
    while (1) {
      rv = copy_proc_mem(context->target.pid, "bucket", (void *)(lzarray.arData + *hash_bucket),
                         (void *)lbucket, sizeof(Bucket_74 ));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    if ((unsigned long )lbucket->key == (unsigned long )((void *)0)) {
      break;
    }
    while (1) {
      rv = sprint_zstring_74(context, "array_key", lbucket->key, tmp_key, sizeof(tmp_key),
                             & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    tmp___0 = strcmp(key, (char const   *)(tmp_key));
    if (tmp___0 == 0) {
      hash_bucket = (uint32_t *)((void *)0);
    } else {
      hash_bucket = & lbucket->val.u2.next;
    }
    if (! hash_bucket) {
      break;
    }
  }
  return (0);
}
}
static int sprint_zstring_74(trace_context_t *context , char const   *what , zend_string_74 *rzstring ,
                             char *buf___0 , size_t buf_size , size_t *buf_len___0 ) 
{ 
  int rv ;
  zend_string_74 lzstring ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  *buf___0 = (char )'\000';
  *buf_len___0 = (size_t )0;
  while (1) {
    rv = copy_proc_mem(context->target.pid, what, (void *)rzstring, (void *)(& lzstring),
                       sizeof(lzstring));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  if (1UL > buf_size) {
    tmp___1 = (size_t )1;
  } else {
    tmp___1 = buf_size;
  }
  if (lzstring.len < tmp___1 - 1UL) {
    *buf_len___0 = lzstring.len;
  } else {
    if (1UL > buf_size) {
      tmp___0 = (size_t )1;
    } else {
      tmp___0 = buf_size;
    }
    *buf_len___0 = tmp___0 - 1UL;
  }
  while (1) {
    rv = copy_proc_mem(context->target.pid, what, (void *)((char *)rzstring + (unsigned long )(& ((zend_string_74 *)0)->val)),
                       (void *)buf___0, *buf_len___0);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  *(buf___0 + (int )*buf_len___0) = (char )'\000';
  return (0);
}
}
static int sprint_zval_74(trace_context_t *context , zval_74 *lzval , char *buf___0 ,
                          size_t buf_size , size_t *buf_len___0 ) 
{ 
  int rv ;
  int type ;

  {
  type = (int )lzval->u1.v.type;
  switch (type) {
  case 4: 
  snprintf((char * __restrict  )buf___0, buf_size, (char const   * __restrict  )"%ld",
           lzval->value.lval);
  *buf_len___0 = strlen((char const   *)buf___0);
  break;
  case 5: 
  snprintf((char * __restrict  )buf___0, buf_size, (char const   * __restrict  )"%f",
           lzval->value.dval);
  *buf_len___0 = strlen((char const   *)buf___0);
  break;
  case 6: 
  while (1) {
    rv = sprint_zstring_74(context, "zval", lzval->value.str, buf___0, buf_size, buf_len___0);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  break;
  case 7: 
  while (1) {
    rv = sprint_zarray_74(context, lzval->value.arr, buf___0, buf_size, buf_len___0);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  break;
  default: 
  return (1);
  }
  return (0);
}
}
static int sprint_zarray_74(trace_context_t *context , zend_array_74 *rzarray , char *buf___0 ,
                            size_t buf_size , size_t *buf_len___0 ) 
{ 
  int rv ;
  int i ;
  int array_len ;
  size_t tmp_len ;
  Bucket_74 buckets[128] ;
  zend_array_74 lzarray ;
  char *obuf ;

  {
  obuf = buf___0;
  while (1) {
    rv = copy_proc_mem(context->target.pid, "array", (void *)rzarray, (void *)(& lzarray),
                       sizeof(lzarray));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  if (lzarray.nNumOfElements < 128U) {
    array_len = (int )lzarray.nNumOfElements;
  } else {
    array_len = 128;
  }
  while (1) {
    rv = copy_proc_mem(context->target.pid, "buckets", (void *)lzarray.arData, (void *)(buckets),
                       sizeof(Bucket_74 ) * (unsigned long )array_len);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  i = 0;
  while (i < array_len) {
    while (1) {
      rv = sprint_zarray_bucket_74(context, buckets + i, buf___0, buf_size, & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    buf_size -= tmp_len;
    buf___0 += tmp_len;
    if (buf_size >= 2UL) {
      *buf___0 = (char )',';
      buf_size --;
      buf___0 ++;
    }
    i ++;
  }
  *buf_len___0 = (size_t )(buf___0 - obuf);
  return (0);
}
}
static int sprint_zarray_val74(trace_context_t *context , zend_array_74 *rzarray ,
                               char const   *key , char *buf___0 , size_t buf_size ,
                               size_t *buf_len___0 ) 
{ 
  int rv ;
  Bucket_74 bucket ;

  {
  while (1) {
    rv = copy_zarray_bucket_74(context, rzarray, key, & bucket);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = sprint_zval_74(context, & bucket.val, buf___0, buf_size, buf_len___0);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  return (0);
}
}
static int sprint_zarray_bucket_74(trace_context_t *context , Bucket_74 *lbucket ,
                                   char *buf___0 , size_t buf_size , size_t *buf_len___0 ) 
{ 
  int rv ;
  char tmp_key[256] ;
  size_t tmp_len ;
  char *obuf ;

  {
  obuf = buf___0;
  if ((unsigned long )lbucket->key != (unsigned long )((void *)0)) {
    while (1) {
      rv = sprint_zstring_74(context, "array_key", lbucket->key, tmp_key, sizeof(tmp_key),
                             & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    if (buf_size > (tmp_len + 1UL) + 1UL) {
      snprintf((char * __restrict  )buf___0, buf_size, (char const   * __restrict  )"%s=",
               tmp_key);
      buf_size -= tmp_len + 1UL;
      buf___0 += tmp_len + 1UL;
    }
  }
  while (1) {
    rv = sprint_zval_74(context, & lbucket->val, buf___0, buf_size, & tmp_len);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  buf___0 += tmp_len;
  *buf_len___0 = (size_t )(buf___0 - obuf);
  return (0);
}
}
static int trace_stack_80(trace_context_t *context , zend_execute_data_80 *remote_execute_data ,
                          int *depth ) ;
static int trace_request_info_80(trace_context_t *context ) ;
static int trace_memory_info_80(trace_context_t *context ) ;
static int trace_globals_80(trace_context_t *context ) ;
static int trace_locals_80(trace_context_t *context , zend_op_80 *zop , zend_execute_data_80 *remote_execute_data ,
                           zend_op_array_80 *op_array , char *file , int file_len ) ;
static int copy_executor_globals_80(trace_context_t *context , zend_executor_globals_80 *executor_globals ) ;
static int copy_zarray_bucket_80(trace_context_t *context , zend_array_80 *rzarray ,
                                 char const   *key , Bucket_80 *lbucket ) ;
static int sprint_zstring_80(trace_context_t *context , char const   *what , zend_string_80 *rzstring ,
                             char *buf___0 , size_t buf_size , size_t *buf_len___0 ) ;
static int sprint_zval_80(trace_context_t *context , zval_80 *lzval , char *buf___0 ,
                          size_t buf_size , size_t *buf_len___0 ) ;
static int sprint_zarray_80(trace_context_t *context , zend_array_80 *rzarray , char *buf___0 ,
                            size_t buf_size , size_t *buf_len___0 ) ;
static int sprint_zarray_val80(trace_context_t *context , zend_array_80 *rzarray ,
                               char const   *key , char *buf___0 , size_t buf_size ,
                               size_t *buf_len___0 ) ;
static int sprint_zarray_bucket_80(trace_context_t *context , Bucket_80 *lbucket ,
                                   char *buf___0 , size_t buf_size , size_t *buf_len___0 ) ;
static int do_trace_80(trace_context_t *context ) 
{ 
  int rv ;
  int depth ;
  zend_executor_globals_80 executor_globals ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;

  {
  while (1) {
    rv = copy_executor_globals_80(context, & executor_globals);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = (*(context->event_handler))(context, 1);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  rv = 0;
  while (1) {
    tmp = trace_stack_80(context, executor_globals.current_execute_data, & depth);
    rv |= tmp;
    while (1) {
      if ((rv & 2) != 0) {
        break;
      } else
      if ((rv & 4) != 0) {
        break;
      } else
      if (! opt_continue_on_error) {
        break;
      }
      break;
    }
    if (depth < 1) {
      break;
    }
    if (opt_capture_req) {
      tmp___0 = trace_request_info_80(context);
      rv |= tmp___0;
      while (1) {
        if ((rv & 2) != 0) {
          break;
        } else
        if ((rv & 4) != 0) {
          break;
        } else
        if (! opt_continue_on_error) {
          break;
        }
        break;
      }
    }
    if (opt_capture_mem) {
      tmp___1 = trace_memory_info_80(context);
      rv |= tmp___1;
      while (1) {
        if ((rv & 2) != 0) {
          break;
        } else
        if ((rv & 4) != 0) {
          break;
        } else
        if (! opt_continue_on_error) {
          break;
        }
        break;
      }
    }
    if ((unsigned long )glopeek_map != (unsigned long )((void *)0)) {
      tmp___3 = (glopeek_map->hh.tbl)->num_items;
    } else {
      tmp___3 = 0U;
    }
    if (tmp___3 > 0U) {
      tmp___2 = trace_globals_80(context);
      rv |= tmp___2;
      while (1) {
        if ((rv & 2) != 0) {
          break;
        } else
        if ((rv & 4) != 0) {
          break;
        } else
        if (! opt_continue_on_error) {
          break;
        }
        break;
      }
    }
    break;
  }
  if (rv == 0) {
    goto _L;
  } else
  if (opt_continue_on_error) {
    _L: /* CIL Label */ 
    while (1) {
      rv = (*(context->event_handler))(context, 7);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
  }
  return (0);
}
}
static int trace_stack_80(trace_context_t *context , zend_execute_data_80 *remote_execute_data ,
                          int *depth ) 
{ 
  int rv ;
  zend_execute_data_80 execute_data ;
  zend_function_80 zfunc ;
  zend_string_80 zstring ;
  zend_class_entry_80 zce ;
  zend_op_80 zop ;
  trace_target_t *target ;
  trace_frame_t *frame ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
  target = & context->target;
  frame = & context->event.frame;
  *depth = 0;
  while (1) {
    if (remote_execute_data) {
      if (! (*depth != opt_max_stack_depth)) {
        break;
      }
    } else {
      break;
    }
    memset((void *)(& execute_data), 0, sizeof(execute_data));
    memset((void *)(& zfunc), 0, sizeof(zfunc));
    memset((void *)(& zstring), 0, sizeof(zstring));
    memset((void *)(& zce), 0, sizeof(zce));
    memset((void *)(& zop), 0, sizeof(zop));
    while (1) {
      rv = copy_proc_mem(context->target.pid, "execute_data", (void *)remote_execute_data,
                         (void *)(& execute_data), sizeof(execute_data));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    while (1) {
      rv = copy_proc_mem(context->target.pid, "zfunc", (void *)execute_data.func,
                         (void *)(& zfunc), sizeof(zfunc));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    if (zfunc.common.function_name) {
      while (1) {
        rv = sprint_zstring_80(context, "function_name", zfunc.common.function_name,
                               frame->loc.func, sizeof(frame->loc.func), & frame->loc.func_len);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
    } else {
      tmp = snprintf((char * __restrict  )(frame->loc.func), sizeof(frame->loc.func),
                     (char const   * __restrict  )"<main>");
      frame->loc.func_len = (size_t )tmp;
    }
    if (zfunc.common.scope) {
      while (1) {
        rv = copy_proc_mem(context->target.pid, "zce", (void *)zfunc.common.scope,
                           (void *)(& zce), sizeof(zce));
        if (rv != 0) {
          return (rv);
        }
        break;
      }
      while (1) {
        rv = sprint_zstring_80(context, "class_name", zce.name, frame->loc.class,
                               sizeof(frame->loc.class), & frame->loc.class_len);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
    } else {
      frame->loc.class[0] = (char )'\000';
      frame->loc.class_len = (size_t )0;
    }
    if ((int )zfunc.type == 2) {
      while (1) {
        rv = sprint_zstring_80(context, "filename", zfunc.op_array.filename, frame->loc.file,
                               sizeof(frame->loc.file), & frame->loc.file_len);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
      frame->loc.lineno = (int )zfunc.op_array.line_start;
      if ((unsigned long )varpeek_map != (unsigned long )((void *)0)) {
        tmp___1 = (varpeek_map->hh.tbl)->num_items;
      } else {
        tmp___1 = 0U;
      }
      if (tmp___1 > 0U) {
        tmp___0 = copy_proc_mem(target->pid, "opline", (void *)execute_data.opline,
                                (void *)(& zop), sizeof(zop));
        if (tmp___0 == 0) {
          trace_locals_80(context, & zop, remote_execute_data, & zfunc.op_array, frame->loc.file,
                          (int )frame->loc.file_len);
        }
      }
    } else {
      tmp___2 = snprintf((char * __restrict  )(frame->loc.file), sizeof(frame->loc.file),
                         (char const   * __restrict  )"<internal>");
      frame->loc.file_len = (size_t )tmp___2;
      frame->loc.lineno = -1;
    }
    frame->depth = *depth;
    while (1) {
      rv = (*(context->event_handler))(context, 2);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    remote_execute_data = execute_data.prev_execute_data;
    (*depth) ++;
  }
  return (0);
}
}
static int trace_request_info_80(trace_context_t *context ) 
{ 
  int rv ;
  sapi_globals_struct_80 sapi_globals ;
  trace_target_t *target ;
  trace_request_t *request ;

  {
  memset((void *)(& sapi_globals), 0, sizeof(sapi_globals));
  request = & context->event.request;
  target = & context->target;
  while (1) {
    rv = copy_proc_mem(context->target.pid, "sapi_globals", (void *)target->sapi_globals_addr,
                       (void *)(& sapi_globals), sizeof(sapi_globals));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    if (opt_capture_req_qstring) {
      if (sapi_globals.request_info.query_string) {
        while (1) {
          rv = copy_proc_mem(context->target.pid, "query_string", (void *)sapi_globals.request_info.query_string,
                             (void *)(request->qstring), (size_t )256);
          if (rv != 0) {
            return (rv);
          }
          break;
        }
      } else {
        request->qstring[0] = (char )'-';
        request->qstring[1] = (char )'\000';
      }
    } else {
      request->qstring[0] = (char )'-';
      request->qstring[1] = (char )'\000';
    }
    break;
  }
  while (1) {
    if (opt_capture_req_cookie) {
      if (sapi_globals.request_info.cookie_data) {
        while (1) {
          rv = copy_proc_mem(context->target.pid, "cookie_data", (void *)sapi_globals.request_info.cookie_data,
                             (void *)(request->cookie), (size_t )256);
          if (rv != 0) {
            return (rv);
          }
          break;
        }
      } else {
        request->cookie[0] = (char )'-';
        request->cookie[1] = (char )'\000';
      }
    } else {
      request->cookie[0] = (char )'-';
      request->cookie[1] = (char )'\000';
    }
    break;
  }
  while (1) {
    if (opt_capture_req_uri) {
      if (sapi_globals.request_info.request_uri) {
        while (1) {
          rv = copy_proc_mem(context->target.pid, "request_uri", (void *)sapi_globals.request_info.request_uri,
                             (void *)(request->uri), (size_t )256);
          if (rv != 0) {
            return (rv);
          }
          break;
        }
      } else {
        request->uri[0] = (char )'-';
        request->uri[1] = (char )'\000';
      }
    } else {
      request->uri[0] = (char )'-';
      request->uri[1] = (char )'\000';
    }
    break;
  }
  while (1) {
    if (opt_capture_req_path) {
      if (sapi_globals.request_info.path_translated) {
        while (1) {
          rv = copy_proc_mem(context->target.pid, "path_translated", (void *)sapi_globals.request_info.path_translated,
                             (void *)(request->path), (size_t )256);
          if (rv != 0) {
            return (rv);
          }
          break;
        }
      } else {
        request->path[0] = (char )'-';
        request->path[1] = (char )'\000';
      }
    } else {
      request->path[0] = (char )'-';
      request->path[1] = (char )'\000';
    }
    break;
  }
  request->ts = sapi_globals.global_request_time;
  while (1) {
    rv = (*(context->event_handler))(context, 5);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  return (0);
}
}
static int trace_memory_info_80(trace_context_t *context ) 
{ 
  int rv ;
  zend_mm_heap_80 mm_heap ;
  zend_alloc_globals_80 alloc_globals ;
  trace_target_t *target ;

  {
  memset((void *)(& mm_heap), 0, sizeof(mm_heap));
  alloc_globals.mm_heap = (zend_mm_heap_80 *)((void *)0);
  target = & context->target;
  while (1) {
    rv = copy_proc_mem(context->target.pid, "alloc_globals", (void *)target->alloc_globals_addr,
                       (void *)(& alloc_globals), sizeof(alloc_globals));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = copy_proc_mem(context->target.pid, "mm_heap", (void *)alloc_globals.mm_heap,
                       (void *)(& mm_heap), sizeof(mm_heap));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  context->event.mem.size = mm_heap.size;
  context->event.mem.peak = mm_heap.peak;
  while (1) {
    rv = (*(context->event_handler))(context, 6);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  return (0);
}
}
static int trace_globals_80(trace_context_t *context ) 
{ 
  int rv ;
  glopeek_entry_t *gentry ;
  glopeek_entry_t *gentry_tmp ;
  zend_array_80 *garray ;
  zend_array_80 *symtable ;
  Bucket_80 lbucket ;
  void *tmp ;
  void *tmp___0 ;

  {
  symtable = (zend_array_80 *)(context->target.executor_globals_addr + (unsigned long )(& ((zend_executor_globals_80 *)0)->symbol_table));
  gentry = glopeek_map;
  if ((unsigned long )glopeek_map != (unsigned long )((void *)0)) {
    tmp = glopeek_map->hh.next;
  } else {
    tmp = (void *)0;
  }
  gentry_tmp = (glopeek_entry_t *)tmp;
  while ((unsigned long )gentry != (unsigned long )((void *)0)) {
    if (gentry->gloname[0]) {
      while (1) {
        rv = copy_zarray_bucket_80(context, symtable, (char const   *)(gentry->gloname),
                                   & lbucket);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
      garray = lbucket.val.value.arr;
    } else {
      garray = symtable;
    }
    rv = sprint_zarray_val80(context, garray, (char const   *)(gentry->varname), context->buf,
                             sizeof(context->buf), & context->buf_len);
    if (rv == 0) {
      context->event.glopeek.gentry = gentry;
      context->event.glopeek.zval_str = context->buf;
      while (1) {
        rv = (*(context->event_handler))(context, 4);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
    }
    gentry = gentry_tmp;
    if ((unsigned long )gentry_tmp != (unsigned long )((void *)0)) {
      tmp___0 = gentry_tmp->hh.next;
    } else {
      tmp___0 = (void *)0;
    }
    gentry_tmp = (glopeek_entry_t *)tmp___0;
  }
  return (0);
}
}
static int trace_locals_80(trace_context_t *context , zend_op_80 *zop , zend_execute_data_80 *remote_execute_data ,
                           zend_op_array_80 *op_array , char *file , int file_len ) 
{ 
  int rv ;
  int i ;
  int num_vars_found ;
  int num_vars_peeking ;
  char tmp[256] ;
  size_t tmp_len ;
  zend_string_80 *zstrp ;
  varpeek_entry_t *entry ;
  varpeek_var_t *var ;
  char varpeek_key[256] ;
  zval_80 zv ;
  unsigned int _uthash_hfstr_keylen ;
  size_t tmp___0 ;
  unsigned int _hf_hashv ;
  unsigned int _hj_i ;
  unsigned int _hj_j ;
  unsigned int _hj_k ;
  unsigned char const   *_hj_key ;
  unsigned int _hf_bkt ;
  int tmp___1 ;
  unsigned int _hf_hashv___0 ;
  unsigned int _hj_i___0 ;
  unsigned int _hj_j___0 ;
  unsigned int _hj_k___0 ;
  unsigned char const   *_hj_key___0 ;
  unsigned int _hf_bkt___0 ;
  int tmp___2 ;

  {
  snprintf((char * __restrict  )(varpeek_key), sizeof(varpeek_key), (char const   * __restrict  )"%.*s:%d",
           file_len, file, zop->lineno);
  while (1) {
    tmp___0 = strlen((char const   *)(varpeek_key));
    _uthash_hfstr_keylen = (unsigned int )tmp___0;
    while (1) {
      while (1) {
        while (1) {
          _hj_key = (unsigned char const   *)(varpeek_key);
          _hf_hashv = 4276993775U;
          _hj_j = 2654435769U;
          _hj_i = _hj_j;
          _hj_k = _uthash_hfstr_keylen;
          while (_hj_k >= 12U) {
            _hj_i += (((unsigned int )*(_hj_key + 0) + ((unsigned int )*(_hj_key + 1) << 8)) + ((unsigned int )*(_hj_key + 2) << 16)) + ((unsigned int )*(_hj_key + 3) << 24);
            _hj_j += (((unsigned int )*(_hj_key + 4) + ((unsigned int )*(_hj_key + 5) << 8)) + ((unsigned int )*(_hj_key + 6) << 16)) + ((unsigned int )*(_hj_key + 7) << 24);
            _hf_hashv += (((unsigned int )*(_hj_key + 8) + ((unsigned int )*(_hj_key + 9) << 8)) + ((unsigned int )*(_hj_key + 10) << 16)) + ((unsigned int )*(_hj_key + 11) << 24);
            while (1) {
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 13;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 8;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 13;
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 12;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 16;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 5;
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 3;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 10;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 15;
              break;
            }
            _hj_key += 12;
            _hj_k -= 12U;
          }
          _hf_hashv += _uthash_hfstr_keylen;
          switch (_hj_k) {
          case 11U: 
          _hf_hashv += (unsigned int )*(_hj_key + 10) << 24;
          case 10U: 
          _hf_hashv += (unsigned int )*(_hj_key + 9) << 16;
          case 9U: 
          _hf_hashv += (unsigned int )*(_hj_key + 8) << 8;
          case 8U: 
          _hj_j += (unsigned int )*(_hj_key + 7) << 24;
          case 7U: 
          _hj_j += (unsigned int )*(_hj_key + 6) << 16;
          case 6U: 
          _hj_j += (unsigned int )*(_hj_key + 5) << 8;
          case 5U: 
          _hj_j += (unsigned int )*(_hj_key + 4);
          case 4U: 
          _hj_i += (unsigned int )*(_hj_key + 3) << 24;
          case 3U: 
          _hj_i += (unsigned int )*(_hj_key + 2) << 16;
          case 2U: 
          _hj_i += (unsigned int )*(_hj_key + 1) << 8;
          case 1U: 
          _hj_i += (unsigned int )*(_hj_key + 0);
          }
          while (1) {
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 13;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 8;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 13;
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 12;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 16;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 5;
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 3;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 10;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 15;
            break;
          }
          break;
        }
        break;
      }
      while (1) {
        entry = (varpeek_entry_t *)((void *)0);
        if (varpeek_map) {
          while (1) {
            _hf_bkt = _hf_hashv & ((varpeek_map->hh.tbl)->num_buckets - 1U);
            break;
          }
          while (1) {
            if ((unsigned long )((varpeek_map->hh.tbl)->buckets + _hf_bkt)->hh_head != (unsigned long )((void *)0)) {
              while (1) {
                entry = (varpeek_entry_t *)((void *)((char *)((varpeek_map->hh.tbl)->buckets + _hf_bkt)->hh_head - (varpeek_map->hh.tbl)->hho));
                break;
              }
            } else {
              entry = (varpeek_entry_t *)((void *)0);
            }
            while ((unsigned long )entry != (unsigned long )((void *)0)) {
              if (entry->hh.hashv == _hf_hashv) {
                if (entry->hh.keylen == _uthash_hfstr_keylen) {
                  tmp___1 = memcmp((void const   *)entry->hh.key, (void const   *)(varpeek_key),
                                   (size_t )_uthash_hfstr_keylen);
                  if (tmp___1 == 0) {
                    break;
                  }
                }
              }
              if ((unsigned long )entry->hh.hh_next != (unsigned long )((void *)0)) {
                while (1) {
                  entry = (varpeek_entry_t *)((void *)((char *)entry->hh.hh_next - (varpeek_map->hh.tbl)->hho));
                  break;
                }
              } else {
                entry = (varpeek_entry_t *)((void *)0);
              }
            }
            break;
          }
        }
        break;
      }
      break;
    }
    break;
  }
  if (! entry) {
    return (0);
  }
  num_vars_found = 0;
  if ((unsigned long )entry->varmap != (unsigned long )((void *)0)) {
    num_vars_peeking = (int )((entry->varmap)->hh.tbl)->num_items;
  } else {
    num_vars_peeking = 0;
  }
  i = 0;
  while (i < op_array->last_var) {
    while (1) {
      rv = copy_proc_mem(context->target.pid, "var", (void *)(op_array->vars + i),
                         (void *)(& zstrp), sizeof(zstrp));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    while (1) {
      rv = sprint_zstring_80(context, "var", zstrp, tmp, sizeof(tmp), & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    while (1) {
      while (1) {
        while (1) {
          _hj_key___0 = (unsigned char const   *)(tmp);
          _hf_hashv___0 = 4276993775U;
          _hj_j___0 = 2654435769U;
          _hj_i___0 = _hj_j___0;
          _hj_k___0 = (unsigned int )tmp_len;
          while (_hj_k___0 >= 12U) {
            _hj_i___0 += (((unsigned int )*(_hj_key___0 + 0) + ((unsigned int )*(_hj_key___0 + 1) << 8)) + ((unsigned int )*(_hj_key___0 + 2) << 16)) + ((unsigned int )*(_hj_key___0 + 3) << 24);
            _hj_j___0 += (((unsigned int )*(_hj_key___0 + 4) + ((unsigned int )*(_hj_key___0 + 5) << 8)) + ((unsigned int )*(_hj_key___0 + 6) << 16)) + ((unsigned int )*(_hj_key___0 + 7) << 24);
            _hf_hashv___0 += (((unsigned int )*(_hj_key___0 + 8) + ((unsigned int )*(_hj_key___0 + 9) << 8)) + ((unsigned int )*(_hj_key___0 + 10) << 16)) + ((unsigned int )*(_hj_key___0 + 11) << 24);
            while (1) {
              _hj_i___0 -= _hj_j___0;
              _hj_i___0 -= _hf_hashv___0;
              _hj_i___0 ^= _hf_hashv___0 >> 13;
              _hj_j___0 -= _hf_hashv___0;
              _hj_j___0 -= _hj_i___0;
              _hj_j___0 ^= _hj_i___0 << 8;
              _hf_hashv___0 -= _hj_i___0;
              _hf_hashv___0 -= _hj_j___0;
              _hf_hashv___0 ^= _hj_j___0 >> 13;
              _hj_i___0 -= _hj_j___0;
              _hj_i___0 -= _hf_hashv___0;
              _hj_i___0 ^= _hf_hashv___0 >> 12;
              _hj_j___0 -= _hf_hashv___0;
              _hj_j___0 -= _hj_i___0;
              _hj_j___0 ^= _hj_i___0 << 16;
              _hf_hashv___0 -= _hj_i___0;
              _hf_hashv___0 -= _hj_j___0;
              _hf_hashv___0 ^= _hj_j___0 >> 5;
              _hj_i___0 -= _hj_j___0;
              _hj_i___0 -= _hf_hashv___0;
              _hj_i___0 ^= _hf_hashv___0 >> 3;
              _hj_j___0 -= _hf_hashv___0;
              _hj_j___0 -= _hj_i___0;
              _hj_j___0 ^= _hj_i___0 << 10;
              _hf_hashv___0 -= _hj_i___0;
              _hf_hashv___0 -= _hj_j___0;
              _hf_hashv___0 ^= _hj_j___0 >> 15;
              break;
            }
            _hj_key___0 += 12;
            _hj_k___0 -= 12U;
          }
          _hf_hashv___0 += (unsigned int )tmp_len;
          switch (_hj_k___0) {
          case 11U: 
          _hf_hashv___0 += (unsigned int )*(_hj_key___0 + 10) << 24;
          case 10U: 
          _hf_hashv___0 += (unsigned int )*(_hj_key___0 + 9) << 16;
          case 9U: 
          _hf_hashv___0 += (unsigned int )*(_hj_key___0 + 8) << 8;
          case 8U: 
          _hj_j___0 += (unsigned int )*(_hj_key___0 + 7) << 24;
          case 7U: 
          _hj_j___0 += (unsigned int )*(_hj_key___0 + 6) << 16;
          case 6U: 
          _hj_j___0 += (unsigned int )*(_hj_key___0 + 5) << 8;
          case 5U: 
          _hj_j___0 += (unsigned int )*(_hj_key___0 + 4);
          case 4U: 
          _hj_i___0 += (unsigned int )*(_hj_key___0 + 3) << 24;
          case 3U: 
          _hj_i___0 += (unsigned int )*(_hj_key___0 + 2) << 16;
          case 2U: 
          _hj_i___0 += (unsigned int )*(_hj_key___0 + 1) << 8;
          case 1U: 
          _hj_i___0 += (unsigned int )*(_hj_key___0 + 0);
          }
          while (1) {
            _hj_i___0 -= _hj_j___0;
            _hj_i___0 -= _hf_hashv___0;
            _hj_i___0 ^= _hf_hashv___0 >> 13;
            _hj_j___0 -= _hf_hashv___0;
            _hj_j___0 -= _hj_i___0;
            _hj_j___0 ^= _hj_i___0 << 8;
            _hf_hashv___0 -= _hj_i___0;
            _hf_hashv___0 -= _hj_j___0;
            _hf_hashv___0 ^= _hj_j___0 >> 13;
            _hj_i___0 -= _hj_j___0;
            _hj_i___0 -= _hf_hashv___0;
            _hj_i___0 ^= _hf_hashv___0 >> 12;
            _hj_j___0 -= _hf_hashv___0;
            _hj_j___0 -= _hj_i___0;
            _hj_j___0 ^= _hj_i___0 << 16;
            _hf_hashv___0 -= _hj_i___0;
            _hf_hashv___0 -= _hj_j___0;
            _hf_hashv___0 ^= _hj_j___0 >> 5;
            _hj_i___0 -= _hj_j___0;
            _hj_i___0 -= _hf_hashv___0;
            _hj_i___0 ^= _hf_hashv___0 >> 3;
            _hj_j___0 -= _hf_hashv___0;
            _hj_j___0 -= _hj_i___0;
            _hj_j___0 ^= _hj_i___0 << 10;
            _hf_hashv___0 -= _hj_i___0;
            _hf_hashv___0 -= _hj_j___0;
            _hf_hashv___0 ^= _hj_j___0 >> 15;
            break;
          }
          break;
        }
        break;
      }
      while (1) {
        var = (varpeek_var_t *)((void *)0);
        if (entry->varmap) {
          while (1) {
            _hf_bkt___0 = _hf_hashv___0 & (((entry->varmap)->hh.tbl)->num_buckets - 1U);
            break;
          }
          while (1) {
            if ((unsigned long )(((entry->varmap)->hh.tbl)->buckets + _hf_bkt___0)->hh_head != (unsigned long )((void *)0)) {
              while (1) {
                var = (varpeek_var_t *)((void *)((char *)(((entry->varmap)->hh.tbl)->buckets + _hf_bkt___0)->hh_head - ((entry->varmap)->hh.tbl)->hho));
                break;
              }
            } else {
              var = (varpeek_var_t *)((void *)0);
            }
            while ((unsigned long )var != (unsigned long )((void *)0)) {
              if (var->hh.hashv == _hf_hashv___0) {
                if ((size_t )var->hh.keylen == tmp_len) {
                  tmp___2 = memcmp((void const   *)var->hh.key, (void const   *)(tmp),
                                   tmp_len);
                  if (tmp___2 == 0) {
                    break;
                  }
                }
              }
              if ((unsigned long )var->hh.hh_next != (unsigned long )((void *)0)) {
                while (1) {
                  var = (varpeek_var_t *)((void *)((char *)var->hh.hh_next - ((entry->varmap)->hh.tbl)->hho));
                  break;
                }
              } else {
                var = (varpeek_var_t *)((void *)0);
              }
            }
            break;
          }
        }
        break;
      }
      break;
    }
    if (! var) {
      goto __Cont;
    }
    num_vars_found ++;
    while (1) {
      rv = copy_proc_mem(context->target.pid, "zval", (void *)((zval_80 *)remote_execute_data + (5 + i)),
                         (void *)(& zv), sizeof(zv));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    while (1) {
      rv = sprint_zval_80(context, & zv, tmp, sizeof(tmp), & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    context->event.varpeek.entry = entry;
    context->event.varpeek.var = var;
    context->event.varpeek.zval_str = tmp;
    while (1) {
      rv = (*(context->event_handler))(context, 3);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    if (num_vars_found >= num_vars_peeking) {
      break;
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  return (0);
}
}
static int copy_executor_globals_80(trace_context_t *context , zend_executor_globals_80 *executor_globals ) 
{ 
  int rv ;

  {
  executor_globals->current_execute_data = (zend_execute_data_80 *)((void *)0);
  while (1) {
    rv = copy_proc_mem(context->target.pid, "executor_globals", (void *)context->target.executor_globals_addr,
                       (void *)executor_globals, sizeof(*executor_globals));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  return (0);
}
}
static int copy_zarray_bucket_80(trace_context_t *context , zend_array_80 *rzarray ,
                                 char const   *key , Bucket_80 *lbucket ) 
{ 
  int rv ;
  zend_array_80 lzarray ;
  uint32_t hash_table_size ;
  uint64_t hash_val ;
  uint32_t hash_index ;
  uint32_t hash_table_val ;
  uint32_t *hash_bucket ;
  char tmp_key[256] ;
  size_t tmp_len ;
  size_t tmp ;
  int tmp___0 ;

  {
  while (1) {
    rv = copy_proc_mem(context->target.pid, "array", (void *)rzarray, (void *)(& lzarray),
                       sizeof(lzarray));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  tmp = strlen(key);
  hash_val = phpspy_zend_inline_hash_func(key, tmp);
  hash_table_size = (uint32_t )(-1 * (int32_t )lzarray.nTableMask);
  hash_index = (uint32_t )(hash_val % (unsigned long )hash_table_size);
  while (1) {
    rv = copy_proc_mem(context->target.pid, "hash_table_val", (void *)(((uint32_t *)lzarray.arData - hash_table_size) + hash_index),
                       (void *)(& hash_table_val), sizeof(uint32_t ));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  hash_bucket = & hash_table_val;
  while (1) {
    if (*hash_bucket == 4294967295U) {
      return (1);
    }
    while (1) {
      rv = copy_proc_mem(context->target.pid, "bucket", (void *)(lzarray.arData + *hash_bucket),
                         (void *)lbucket, sizeof(Bucket_80 ));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    if ((unsigned long )lbucket->key == (unsigned long )((void *)0)) {
      break;
    }
    while (1) {
      rv = sprint_zstring_80(context, "array_key", lbucket->key, tmp_key, sizeof(tmp_key),
                             & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    tmp___0 = strcmp(key, (char const   *)(tmp_key));
    if (tmp___0 == 0) {
      hash_bucket = (uint32_t *)((void *)0);
    } else {
      hash_bucket = & lbucket->val.u2.next;
    }
    if (! hash_bucket) {
      break;
    }
  }
  return (0);
}
}
static int sprint_zstring_80(trace_context_t *context , char const   *what , zend_string_80 *rzstring ,
                             char *buf___0 , size_t buf_size , size_t *buf_len___0 ) 
{ 
  int rv ;
  zend_string_80 lzstring ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  *buf___0 = (char )'\000';
  *buf_len___0 = (size_t )0;
  while (1) {
    rv = copy_proc_mem(context->target.pid, what, (void *)rzstring, (void *)(& lzstring),
                       sizeof(lzstring));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  if (1UL > buf_size) {
    tmp___1 = (size_t )1;
  } else {
    tmp___1 = buf_size;
  }
  if (lzstring.len < tmp___1 - 1UL) {
    *buf_len___0 = lzstring.len;
  } else {
    if (1UL > buf_size) {
      tmp___0 = (size_t )1;
    } else {
      tmp___0 = buf_size;
    }
    *buf_len___0 = tmp___0 - 1UL;
  }
  while (1) {
    rv = copy_proc_mem(context->target.pid, what, (void *)((char *)rzstring + (unsigned long )(& ((zend_string_80 *)0)->val)),
                       (void *)buf___0, *buf_len___0);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  *(buf___0 + (int )*buf_len___0) = (char )'\000';
  return (0);
}
}
static int sprint_zval_80(trace_context_t *context , zval_80 *lzval , char *buf___0 ,
                          size_t buf_size , size_t *buf_len___0 ) 
{ 
  int rv ;
  int type ;

  {
  type = (int )lzval->u1.v.type;
  switch (type) {
  case 4: 
  snprintf((char * __restrict  )buf___0, buf_size, (char const   * __restrict  )"%ld",
           lzval->value.lval);
  *buf_len___0 = strlen((char const   *)buf___0);
  break;
  case 5: 
  snprintf((char * __restrict  )buf___0, buf_size, (char const   * __restrict  )"%f",
           lzval->value.dval);
  *buf_len___0 = strlen((char const   *)buf___0);
  break;
  case 6: 
  while (1) {
    rv = sprint_zstring_80(context, "zval", lzval->value.str, buf___0, buf_size, buf_len___0);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  break;
  case 7: 
  while (1) {
    rv = sprint_zarray_80(context, lzval->value.arr, buf___0, buf_size, buf_len___0);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  break;
  default: 
  return (1);
  }
  return (0);
}
}
static int sprint_zarray_80(trace_context_t *context , zend_array_80 *rzarray , char *buf___0 ,
                            size_t buf_size , size_t *buf_len___0 ) 
{ 
  int rv ;
  int i ;
  int array_len ;
  size_t tmp_len ;
  Bucket_80 buckets[128] ;
  zend_array_80 lzarray ;
  char *obuf ;

  {
  obuf = buf___0;
  while (1) {
    rv = copy_proc_mem(context->target.pid, "array", (void *)rzarray, (void *)(& lzarray),
                       sizeof(lzarray));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  if (lzarray.nNumOfElements < 128U) {
    array_len = (int )lzarray.nNumOfElements;
  } else {
    array_len = 128;
  }
  while (1) {
    rv = copy_proc_mem(context->target.pid, "buckets", (void *)lzarray.arData, (void *)(buckets),
                       sizeof(Bucket_80 ) * (unsigned long )array_len);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  i = 0;
  while (i < array_len) {
    while (1) {
      rv = sprint_zarray_bucket_80(context, buckets + i, buf___0, buf_size, & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    buf_size -= tmp_len;
    buf___0 += tmp_len;
    if (buf_size >= 2UL) {
      *buf___0 = (char )',';
      buf_size --;
      buf___0 ++;
    }
    i ++;
  }
  *buf_len___0 = (size_t )(buf___0 - obuf);
  return (0);
}
}
static int sprint_zarray_val80(trace_context_t *context , zend_array_80 *rzarray ,
                               char const   *key , char *buf___0 , size_t buf_size ,
                               size_t *buf_len___0 ) 
{ 
  int rv ;
  Bucket_80 bucket ;

  {
  while (1) {
    rv = copy_zarray_bucket_80(context, rzarray, key, & bucket);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = sprint_zval_80(context, & bucket.val, buf___0, buf_size, buf_len___0);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  return (0);
}
}
static int sprint_zarray_bucket_80(trace_context_t *context , Bucket_80 *lbucket ,
                                   char *buf___0 , size_t buf_size , size_t *buf_len___0 ) 
{ 
  int rv ;
  char tmp_key[256] ;
  size_t tmp_len ;
  char *obuf ;

  {
  obuf = buf___0;
  if ((unsigned long )lbucket->key != (unsigned long )((void *)0)) {
    while (1) {
      rv = sprint_zstring_80(context, "array_key", lbucket->key, tmp_key, sizeof(tmp_key),
                             & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    if (buf_size > (tmp_len + 1UL) + 1UL) {
      snprintf((char * __restrict  )buf___0, buf_size, (char const   * __restrict  )"%s=",
               tmp_key);
      buf_size -= tmp_len + 1UL;
      buf___0 += tmp_len + 1UL;
    }
  }
  while (1) {
    rv = sprint_zval_80(context, & lbucket->val, buf___0, buf_size, & tmp_len);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  buf___0 += tmp_len;
  *buf_len___0 = (size_t )(buf___0 - obuf);
  return (0);
}
}
static int trace_stack_81(trace_context_t *context , zend_execute_data_81 *remote_execute_data ,
                          int *depth ) ;
static int trace_request_info_81(trace_context_t *context ) ;
static int trace_memory_info_81(trace_context_t *context ) ;
static int trace_globals_81(trace_context_t *context ) ;
static int trace_locals_81(trace_context_t *context , zend_op_81 *zop , zend_execute_data_81 *remote_execute_data ,
                           zend_op_array_81 *op_array , char *file , int file_len ) ;
static int copy_executor_globals_81(trace_context_t *context , zend_executor_globals_81 *executor_globals ) ;
static int copy_zarray_bucket_81(trace_context_t *context , zend_array_81 *rzarray ,
                                 char const   *key , Bucket_81 *lbucket ) ;
static int sprint_zstring_81(trace_context_t *context , char const   *what , zend_string_81 *rzstring ,
                             char *buf___0 , size_t buf_size , size_t *buf_len___0 ) ;
static int sprint_zval_81(trace_context_t *context , zval_81 *lzval , char *buf___0 ,
                          size_t buf_size , size_t *buf_len___0 ) ;
static int sprint_zarray_81(trace_context_t *context , zend_array_81 *rzarray , char *buf___0 ,
                            size_t buf_size , size_t *buf_len___0 ) ;
static int sprint_zarray_val81(trace_context_t *context , zend_array_81 *rzarray ,
                               char const   *key , char *buf___0 , size_t buf_size ,
                               size_t *buf_len___0 ) ;
static int sprint_zarray_bucket_81(trace_context_t *context , Bucket_81 *lbucket ,
                                   char *buf___0 , size_t buf_size , size_t *buf_len___0 ) ;
static int do_trace_81(trace_context_t *context ) 
{ 
  int rv ;
  int depth ;
  zend_executor_globals_81 executor_globals ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;

  {
  while (1) {
    rv = copy_executor_globals_81(context, & executor_globals);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = (*(context->event_handler))(context, 1);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  rv = 0;
  while (1) {
    tmp = trace_stack_81(context, executor_globals.current_execute_data, & depth);
    rv |= tmp;
    while (1) {
      if ((rv & 2) != 0) {
        break;
      } else
      if ((rv & 4) != 0) {
        break;
      } else
      if (! opt_continue_on_error) {
        break;
      }
      break;
    }
    if (depth < 1) {
      break;
    }
    if (opt_capture_req) {
      tmp___0 = trace_request_info_81(context);
      rv |= tmp___0;
      while (1) {
        if ((rv & 2) != 0) {
          break;
        } else
        if ((rv & 4) != 0) {
          break;
        } else
        if (! opt_continue_on_error) {
          break;
        }
        break;
      }
    }
    if (opt_capture_mem) {
      tmp___1 = trace_memory_info_81(context);
      rv |= tmp___1;
      while (1) {
        if ((rv & 2) != 0) {
          break;
        } else
        if ((rv & 4) != 0) {
          break;
        } else
        if (! opt_continue_on_error) {
          break;
        }
        break;
      }
    }
    if ((unsigned long )glopeek_map != (unsigned long )((void *)0)) {
      tmp___3 = (glopeek_map->hh.tbl)->num_items;
    } else {
      tmp___3 = 0U;
    }
    if (tmp___3 > 0U) {
      tmp___2 = trace_globals_81(context);
      rv |= tmp___2;
      while (1) {
        if ((rv & 2) != 0) {
          break;
        } else
        if ((rv & 4) != 0) {
          break;
        } else
        if (! opt_continue_on_error) {
          break;
        }
        break;
      }
    }
    break;
  }
  if (rv == 0) {
    goto _L;
  } else
  if (opt_continue_on_error) {
    _L: /* CIL Label */ 
    while (1) {
      rv = (*(context->event_handler))(context, 7);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
  }
  return (0);
}
}
static int trace_stack_81(trace_context_t *context , zend_execute_data_81 *remote_execute_data ,
                          int *depth ) 
{ 
  int rv ;
  zend_execute_data_81 execute_data ;
  zend_function_81 zfunc ;
  zend_string_81 zstring ;
  zend_class_entry_81 zce ;
  zend_op_81 zop ;
  trace_target_t *target ;
  trace_frame_t *frame ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
  target = & context->target;
  frame = & context->event.frame;
  *depth = 0;
  while (1) {
    if (remote_execute_data) {
      if (! (*depth != opt_max_stack_depth)) {
        break;
      }
    } else {
      break;
    }
    memset((void *)(& execute_data), 0, sizeof(execute_data));
    memset((void *)(& zfunc), 0, sizeof(zfunc));
    memset((void *)(& zstring), 0, sizeof(zstring));
    memset((void *)(& zce), 0, sizeof(zce));
    memset((void *)(& zop), 0, sizeof(zop));
    while (1) {
      rv = copy_proc_mem(context->target.pid, "execute_data", (void *)remote_execute_data,
                         (void *)(& execute_data), sizeof(execute_data));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    while (1) {
      rv = copy_proc_mem(context->target.pid, "zfunc", (void *)execute_data.func,
                         (void *)(& zfunc), sizeof(zfunc));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    if (zfunc.common.function_name) {
      while (1) {
        rv = sprint_zstring_81(context, "function_name", zfunc.common.function_name,
                               frame->loc.func, sizeof(frame->loc.func), & frame->loc.func_len);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
    } else {
      tmp = snprintf((char * __restrict  )(frame->loc.func), sizeof(frame->loc.func),
                     (char const   * __restrict  )"<main>");
      frame->loc.func_len = (size_t )tmp;
    }
    if (zfunc.common.scope) {
      while (1) {
        rv = copy_proc_mem(context->target.pid, "zce", (void *)zfunc.common.scope,
                           (void *)(& zce), sizeof(zce));
        if (rv != 0) {
          return (rv);
        }
        break;
      }
      while (1) {
        rv = sprint_zstring_81(context, "class_name", zce.name, frame->loc.class,
                               sizeof(frame->loc.class), & frame->loc.class_len);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
    } else {
      frame->loc.class[0] = (char )'\000';
      frame->loc.class_len = (size_t )0;
    }
    if ((int )zfunc.type == 2) {
      while (1) {
        rv = sprint_zstring_81(context, "filename", zfunc.op_array.filename, frame->loc.file,
                               sizeof(frame->loc.file), & frame->loc.file_len);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
      frame->loc.lineno = (int )zfunc.op_array.line_start;
      if ((unsigned long )varpeek_map != (unsigned long )((void *)0)) {
        tmp___1 = (varpeek_map->hh.tbl)->num_items;
      } else {
        tmp___1 = 0U;
      }
      if (tmp___1 > 0U) {
        tmp___0 = copy_proc_mem(target->pid, "opline", (void *)execute_data.opline,
                                (void *)(& zop), sizeof(zop));
        if (tmp___0 == 0) {
          trace_locals_81(context, & zop, remote_execute_data, & zfunc.op_array, frame->loc.file,
                          (int )frame->loc.file_len);
        }
      }
    } else {
      tmp___2 = snprintf((char * __restrict  )(frame->loc.file), sizeof(frame->loc.file),
                         (char const   * __restrict  )"<internal>");
      frame->loc.file_len = (size_t )tmp___2;
      frame->loc.lineno = -1;
    }
    frame->depth = *depth;
    while (1) {
      rv = (*(context->event_handler))(context, 2);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    remote_execute_data = execute_data.prev_execute_data;
    (*depth) ++;
  }
  return (0);
}
}
static int trace_request_info_81(trace_context_t *context ) 
{ 
  int rv ;
  sapi_globals_struct_81 sapi_globals ;
  trace_target_t *target ;
  trace_request_t *request ;

  {
  memset((void *)(& sapi_globals), 0, sizeof(sapi_globals));
  request = & context->event.request;
  target = & context->target;
  while (1) {
    rv = copy_proc_mem(context->target.pid, "sapi_globals", (void *)target->sapi_globals_addr,
                       (void *)(& sapi_globals), sizeof(sapi_globals));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    if (opt_capture_req_qstring) {
      if (sapi_globals.request_info.query_string) {
        while (1) {
          rv = copy_proc_mem(context->target.pid, "query_string", (void *)sapi_globals.request_info.query_string,
                             (void *)(request->qstring), (size_t )256);
          if (rv != 0) {
            return (rv);
          }
          break;
        }
      } else {
        request->qstring[0] = (char )'-';
        request->qstring[1] = (char )'\000';
      }
    } else {
      request->qstring[0] = (char )'-';
      request->qstring[1] = (char )'\000';
    }
    break;
  }
  while (1) {
    if (opt_capture_req_cookie) {
      if (sapi_globals.request_info.cookie_data) {
        while (1) {
          rv = copy_proc_mem(context->target.pid, "cookie_data", (void *)sapi_globals.request_info.cookie_data,
                             (void *)(request->cookie), (size_t )256);
          if (rv != 0) {
            return (rv);
          }
          break;
        }
      } else {
        request->cookie[0] = (char )'-';
        request->cookie[1] = (char )'\000';
      }
    } else {
      request->cookie[0] = (char )'-';
      request->cookie[1] = (char )'\000';
    }
    break;
  }
  while (1) {
    if (opt_capture_req_uri) {
      if (sapi_globals.request_info.request_uri) {
        while (1) {
          rv = copy_proc_mem(context->target.pid, "request_uri", (void *)sapi_globals.request_info.request_uri,
                             (void *)(request->uri), (size_t )256);
          if (rv != 0) {
            return (rv);
          }
          break;
        }
      } else {
        request->uri[0] = (char )'-';
        request->uri[1] = (char )'\000';
      }
    } else {
      request->uri[0] = (char )'-';
      request->uri[1] = (char )'\000';
    }
    break;
  }
  while (1) {
    if (opt_capture_req_path) {
      if (sapi_globals.request_info.path_translated) {
        while (1) {
          rv = copy_proc_mem(context->target.pid, "path_translated", (void *)sapi_globals.request_info.path_translated,
                             (void *)(request->path), (size_t )256);
          if (rv != 0) {
            return (rv);
          }
          break;
        }
      } else {
        request->path[0] = (char )'-';
        request->path[1] = (char )'\000';
      }
    } else {
      request->path[0] = (char )'-';
      request->path[1] = (char )'\000';
    }
    break;
  }
  request->ts = sapi_globals.global_request_time;
  while (1) {
    rv = (*(context->event_handler))(context, 5);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  return (0);
}
}
static int trace_memory_info_81(trace_context_t *context ) 
{ 
  int rv ;
  zend_mm_heap_81 mm_heap ;
  zend_alloc_globals_81 alloc_globals ;
  trace_target_t *target ;

  {
  memset((void *)(& mm_heap), 0, sizeof(mm_heap));
  alloc_globals.mm_heap = (zend_mm_heap_81 *)((void *)0);
  target = & context->target;
  while (1) {
    rv = copy_proc_mem(context->target.pid, "alloc_globals", (void *)target->alloc_globals_addr,
                       (void *)(& alloc_globals), sizeof(alloc_globals));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = copy_proc_mem(context->target.pid, "mm_heap", (void *)alloc_globals.mm_heap,
                       (void *)(& mm_heap), sizeof(mm_heap));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  context->event.mem.size = mm_heap.size;
  context->event.mem.peak = mm_heap.peak;
  while (1) {
    rv = (*(context->event_handler))(context, 6);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  return (0);
}
}
static int trace_globals_81(trace_context_t *context ) 
{ 
  int rv ;
  glopeek_entry_t *gentry ;
  glopeek_entry_t *gentry_tmp ;
  zend_array_81 *garray ;
  zend_array_81 *symtable ;
  Bucket_81 lbucket ;
  void *tmp ;
  void *tmp___0 ;

  {
  symtable = (zend_array_81 *)(context->target.executor_globals_addr + (unsigned long )(& ((zend_executor_globals_81 *)0)->symbol_table));
  gentry = glopeek_map;
  if ((unsigned long )glopeek_map != (unsigned long )((void *)0)) {
    tmp = glopeek_map->hh.next;
  } else {
    tmp = (void *)0;
  }
  gentry_tmp = (glopeek_entry_t *)tmp;
  while ((unsigned long )gentry != (unsigned long )((void *)0)) {
    if (gentry->gloname[0]) {
      while (1) {
        rv = copy_zarray_bucket_81(context, symtable, (char const   *)(gentry->gloname),
                                   & lbucket);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
      garray = lbucket.val.value.arr;
    } else {
      garray = symtable;
    }
    rv = sprint_zarray_val81(context, garray, (char const   *)(gentry->varname), context->buf,
                             sizeof(context->buf), & context->buf_len);
    if (rv == 0) {
      context->event.glopeek.gentry = gentry;
      context->event.glopeek.zval_str = context->buf;
      while (1) {
        rv = (*(context->event_handler))(context, 4);
        if (rv != 0) {
          return (rv);
        }
        break;
      }
    }
    gentry = gentry_tmp;
    if ((unsigned long )gentry_tmp != (unsigned long )((void *)0)) {
      tmp___0 = gentry_tmp->hh.next;
    } else {
      tmp___0 = (void *)0;
    }
    gentry_tmp = (glopeek_entry_t *)tmp___0;
  }
  return (0);
}
}
static int trace_locals_81(trace_context_t *context , zend_op_81 *zop , zend_execute_data_81 *remote_execute_data ,
                           zend_op_array_81 *op_array , char *file , int file_len ) 
{ 
  int rv ;
  int i ;
  int num_vars_found ;
  int num_vars_peeking ;
  char tmp[256] ;
  size_t tmp_len ;
  zend_string_81 *zstrp ;
  varpeek_entry_t *entry ;
  varpeek_var_t *var ;
  char varpeek_key[256] ;
  zval_81 zv ;
  unsigned int _uthash_hfstr_keylen ;
  size_t tmp___0 ;
  unsigned int _hf_hashv ;
  unsigned int _hj_i ;
  unsigned int _hj_j ;
  unsigned int _hj_k ;
  unsigned char const   *_hj_key ;
  unsigned int _hf_bkt ;
  int tmp___1 ;
  unsigned int _hf_hashv___0 ;
  unsigned int _hj_i___0 ;
  unsigned int _hj_j___0 ;
  unsigned int _hj_k___0 ;
  unsigned char const   *_hj_key___0 ;
  unsigned int _hf_bkt___0 ;
  int tmp___2 ;

  {
  snprintf((char * __restrict  )(varpeek_key), sizeof(varpeek_key), (char const   * __restrict  )"%.*s:%d",
           file_len, file, zop->lineno);
  while (1) {
    tmp___0 = strlen((char const   *)(varpeek_key));
    _uthash_hfstr_keylen = (unsigned int )tmp___0;
    while (1) {
      while (1) {
        while (1) {
          _hj_key = (unsigned char const   *)(varpeek_key);
          _hf_hashv = 4276993775U;
          _hj_j = 2654435769U;
          _hj_i = _hj_j;
          _hj_k = _uthash_hfstr_keylen;
          while (_hj_k >= 12U) {
            _hj_i += (((unsigned int )*(_hj_key + 0) + ((unsigned int )*(_hj_key + 1) << 8)) + ((unsigned int )*(_hj_key + 2) << 16)) + ((unsigned int )*(_hj_key + 3) << 24);
            _hj_j += (((unsigned int )*(_hj_key + 4) + ((unsigned int )*(_hj_key + 5) << 8)) + ((unsigned int )*(_hj_key + 6) << 16)) + ((unsigned int )*(_hj_key + 7) << 24);
            _hf_hashv += (((unsigned int )*(_hj_key + 8) + ((unsigned int )*(_hj_key + 9) << 8)) + ((unsigned int )*(_hj_key + 10) << 16)) + ((unsigned int )*(_hj_key + 11) << 24);
            while (1) {
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 13;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 8;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 13;
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 12;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 16;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 5;
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 3;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 10;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 15;
              break;
            }
            _hj_key += 12;
            _hj_k -= 12U;
          }
          _hf_hashv += _uthash_hfstr_keylen;
          switch (_hj_k) {
          case 11U: 
          _hf_hashv += (unsigned int )*(_hj_key + 10) << 24;
          case 10U: 
          _hf_hashv += (unsigned int )*(_hj_key + 9) << 16;
          case 9U: 
          _hf_hashv += (unsigned int )*(_hj_key + 8) << 8;
          case 8U: 
          _hj_j += (unsigned int )*(_hj_key + 7) << 24;
          case 7U: 
          _hj_j += (unsigned int )*(_hj_key + 6) << 16;
          case 6U: 
          _hj_j += (unsigned int )*(_hj_key + 5) << 8;
          case 5U: 
          _hj_j += (unsigned int )*(_hj_key + 4);
          case 4U: 
          _hj_i += (unsigned int )*(_hj_key + 3) << 24;
          case 3U: 
          _hj_i += (unsigned int )*(_hj_key + 2) << 16;
          case 2U: 
          _hj_i += (unsigned int )*(_hj_key + 1) << 8;
          case 1U: 
          _hj_i += (unsigned int )*(_hj_key + 0);
          }
          while (1) {
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 13;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 8;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 13;
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 12;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 16;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 5;
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 3;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 10;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 15;
            break;
          }
          break;
        }
        break;
      }
      while (1) {
        entry = (varpeek_entry_t *)((void *)0);
        if (varpeek_map) {
          while (1) {
            _hf_bkt = _hf_hashv & ((varpeek_map->hh.tbl)->num_buckets - 1U);
            break;
          }
          while (1) {
            if ((unsigned long )((varpeek_map->hh.tbl)->buckets + _hf_bkt)->hh_head != (unsigned long )((void *)0)) {
              while (1) {
                entry = (varpeek_entry_t *)((void *)((char *)((varpeek_map->hh.tbl)->buckets + _hf_bkt)->hh_head - (varpeek_map->hh.tbl)->hho));
                break;
              }
            } else {
              entry = (varpeek_entry_t *)((void *)0);
            }
            while ((unsigned long )entry != (unsigned long )((void *)0)) {
              if (entry->hh.hashv == _hf_hashv) {
                if (entry->hh.keylen == _uthash_hfstr_keylen) {
                  tmp___1 = memcmp((void const   *)entry->hh.key, (void const   *)(varpeek_key),
                                   (size_t )_uthash_hfstr_keylen);
                  if (tmp___1 == 0) {
                    break;
                  }
                }
              }
              if ((unsigned long )entry->hh.hh_next != (unsigned long )((void *)0)) {
                while (1) {
                  entry = (varpeek_entry_t *)((void *)((char *)entry->hh.hh_next - (varpeek_map->hh.tbl)->hho));
                  break;
                }
              } else {
                entry = (varpeek_entry_t *)((void *)0);
              }
            }
            break;
          }
        }
        break;
      }
      break;
    }
    break;
  }
  if (! entry) {
    return (0);
  }
  num_vars_found = 0;
  if ((unsigned long )entry->varmap != (unsigned long )((void *)0)) {
    num_vars_peeking = (int )((entry->varmap)->hh.tbl)->num_items;
  } else {
    num_vars_peeking = 0;
  }
  i = 0;
  while (i < op_array->last_var) {
    while (1) {
      rv = copy_proc_mem(context->target.pid, "var", (void *)(op_array->vars + i),
                         (void *)(& zstrp), sizeof(zstrp));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    while (1) {
      rv = sprint_zstring_81(context, "var", zstrp, tmp, sizeof(tmp), & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    while (1) {
      while (1) {
        while (1) {
          _hj_key___0 = (unsigned char const   *)(tmp);
          _hf_hashv___0 = 4276993775U;
          _hj_j___0 = 2654435769U;
          _hj_i___0 = _hj_j___0;
          _hj_k___0 = (unsigned int )tmp_len;
          while (_hj_k___0 >= 12U) {
            _hj_i___0 += (((unsigned int )*(_hj_key___0 + 0) + ((unsigned int )*(_hj_key___0 + 1) << 8)) + ((unsigned int )*(_hj_key___0 + 2) << 16)) + ((unsigned int )*(_hj_key___0 + 3) << 24);
            _hj_j___0 += (((unsigned int )*(_hj_key___0 + 4) + ((unsigned int )*(_hj_key___0 + 5) << 8)) + ((unsigned int )*(_hj_key___0 + 6) << 16)) + ((unsigned int )*(_hj_key___0 + 7) << 24);
            _hf_hashv___0 += (((unsigned int )*(_hj_key___0 + 8) + ((unsigned int )*(_hj_key___0 + 9) << 8)) + ((unsigned int )*(_hj_key___0 + 10) << 16)) + ((unsigned int )*(_hj_key___0 + 11) << 24);
            while (1) {
              _hj_i___0 -= _hj_j___0;
              _hj_i___0 -= _hf_hashv___0;
              _hj_i___0 ^= _hf_hashv___0 >> 13;
              _hj_j___0 -= _hf_hashv___0;
              _hj_j___0 -= _hj_i___0;
              _hj_j___0 ^= _hj_i___0 << 8;
              _hf_hashv___0 -= _hj_i___0;
              _hf_hashv___0 -= _hj_j___0;
              _hf_hashv___0 ^= _hj_j___0 >> 13;
              _hj_i___0 -= _hj_j___0;
              _hj_i___0 -= _hf_hashv___0;
              _hj_i___0 ^= _hf_hashv___0 >> 12;
              _hj_j___0 -= _hf_hashv___0;
              _hj_j___0 -= _hj_i___0;
              _hj_j___0 ^= _hj_i___0 << 16;
              _hf_hashv___0 -= _hj_i___0;
              _hf_hashv___0 -= _hj_j___0;
              _hf_hashv___0 ^= _hj_j___0 >> 5;
              _hj_i___0 -= _hj_j___0;
              _hj_i___0 -= _hf_hashv___0;
              _hj_i___0 ^= _hf_hashv___0 >> 3;
              _hj_j___0 -= _hf_hashv___0;
              _hj_j___0 -= _hj_i___0;
              _hj_j___0 ^= _hj_i___0 << 10;
              _hf_hashv___0 -= _hj_i___0;
              _hf_hashv___0 -= _hj_j___0;
              _hf_hashv___0 ^= _hj_j___0 >> 15;
              break;
            }
            _hj_key___0 += 12;
            _hj_k___0 -= 12U;
          }
          _hf_hashv___0 += (unsigned int )tmp_len;
          switch (_hj_k___0) {
          case 11U: 
          _hf_hashv___0 += (unsigned int )*(_hj_key___0 + 10) << 24;
          case 10U: 
          _hf_hashv___0 += (unsigned int )*(_hj_key___0 + 9) << 16;
          case 9U: 
          _hf_hashv___0 += (unsigned int )*(_hj_key___0 + 8) << 8;
          case 8U: 
          _hj_j___0 += (unsigned int )*(_hj_key___0 + 7) << 24;
          case 7U: 
          _hj_j___0 += (unsigned int )*(_hj_key___0 + 6) << 16;
          case 6U: 
          _hj_j___0 += (unsigned int )*(_hj_key___0 + 5) << 8;
          case 5U: 
          _hj_j___0 += (unsigned int )*(_hj_key___0 + 4);
          case 4U: 
          _hj_i___0 += (unsigned int )*(_hj_key___0 + 3) << 24;
          case 3U: 
          _hj_i___0 += (unsigned int )*(_hj_key___0 + 2) << 16;
          case 2U: 
          _hj_i___0 += (unsigned int )*(_hj_key___0 + 1) << 8;
          case 1U: 
          _hj_i___0 += (unsigned int )*(_hj_key___0 + 0);
          }
          while (1) {
            _hj_i___0 -= _hj_j___0;
            _hj_i___0 -= _hf_hashv___0;
            _hj_i___0 ^= _hf_hashv___0 >> 13;
            _hj_j___0 -= _hf_hashv___0;
            _hj_j___0 -= _hj_i___0;
            _hj_j___0 ^= _hj_i___0 << 8;
            _hf_hashv___0 -= _hj_i___0;
            _hf_hashv___0 -= _hj_j___0;
            _hf_hashv___0 ^= _hj_j___0 >> 13;
            _hj_i___0 -= _hj_j___0;
            _hj_i___0 -= _hf_hashv___0;
            _hj_i___0 ^= _hf_hashv___0 >> 12;
            _hj_j___0 -= _hf_hashv___0;
            _hj_j___0 -= _hj_i___0;
            _hj_j___0 ^= _hj_i___0 << 16;
            _hf_hashv___0 -= _hj_i___0;
            _hf_hashv___0 -= _hj_j___0;
            _hf_hashv___0 ^= _hj_j___0 >> 5;
            _hj_i___0 -= _hj_j___0;
            _hj_i___0 -= _hf_hashv___0;
            _hj_i___0 ^= _hf_hashv___0 >> 3;
            _hj_j___0 -= _hf_hashv___0;
            _hj_j___0 -= _hj_i___0;
            _hj_j___0 ^= _hj_i___0 << 10;
            _hf_hashv___0 -= _hj_i___0;
            _hf_hashv___0 -= _hj_j___0;
            _hf_hashv___0 ^= _hj_j___0 >> 15;
            break;
          }
          break;
        }
        break;
      }
      while (1) {
        var = (varpeek_var_t *)((void *)0);
        if (entry->varmap) {
          while (1) {
            _hf_bkt___0 = _hf_hashv___0 & (((entry->varmap)->hh.tbl)->num_buckets - 1U);
            break;
          }
          while (1) {
            if ((unsigned long )(((entry->varmap)->hh.tbl)->buckets + _hf_bkt___0)->hh_head != (unsigned long )((void *)0)) {
              while (1) {
                var = (varpeek_var_t *)((void *)((char *)(((entry->varmap)->hh.tbl)->buckets + _hf_bkt___0)->hh_head - ((entry->varmap)->hh.tbl)->hho));
                break;
              }
            } else {
              var = (varpeek_var_t *)((void *)0);
            }
            while ((unsigned long )var != (unsigned long )((void *)0)) {
              if (var->hh.hashv == _hf_hashv___0) {
                if ((size_t )var->hh.keylen == tmp_len) {
                  tmp___2 = memcmp((void const   *)var->hh.key, (void const   *)(tmp),
                                   tmp_len);
                  if (tmp___2 == 0) {
                    break;
                  }
                }
              }
              if ((unsigned long )var->hh.hh_next != (unsigned long )((void *)0)) {
                while (1) {
                  var = (varpeek_var_t *)((void *)((char *)var->hh.hh_next - ((entry->varmap)->hh.tbl)->hho));
                  break;
                }
              } else {
                var = (varpeek_var_t *)((void *)0);
              }
            }
            break;
          }
        }
        break;
      }
      break;
    }
    if (! var) {
      goto __Cont;
    }
    num_vars_found ++;
    while (1) {
      rv = copy_proc_mem(context->target.pid, "zval", (void *)((zval_81 *)remote_execute_data + (5 + i)),
                         (void *)(& zv), sizeof(zv));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    while (1) {
      rv = sprint_zval_81(context, & zv, tmp, sizeof(tmp), & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    context->event.varpeek.entry = entry;
    context->event.varpeek.var = var;
    context->event.varpeek.zval_str = tmp;
    while (1) {
      rv = (*(context->event_handler))(context, 3);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    if (num_vars_found >= num_vars_peeking) {
      break;
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  return (0);
}
}
static int copy_executor_globals_81(trace_context_t *context , zend_executor_globals_81 *executor_globals ) 
{ 
  int rv ;

  {
  executor_globals->current_execute_data = (zend_execute_data_81 *)((void *)0);
  while (1) {
    rv = copy_proc_mem(context->target.pid, "executor_globals", (void *)context->target.executor_globals_addr,
                       (void *)executor_globals, sizeof(*executor_globals));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  return (0);
}
}
static int copy_zarray_bucket_81(trace_context_t *context , zend_array_81 *rzarray ,
                                 char const   *key , Bucket_81 *lbucket ) 
{ 
  int rv ;
  zend_array_81 lzarray ;
  uint32_t hash_table_size ;
  uint64_t hash_val ;
  uint32_t hash_index ;
  uint32_t hash_table_val ;
  uint32_t *hash_bucket ;
  char tmp_key[256] ;
  size_t tmp_len ;
  size_t tmp ;
  int tmp___0 ;

  {
  while (1) {
    rv = copy_proc_mem(context->target.pid, "array", (void *)rzarray, (void *)(& lzarray),
                       sizeof(lzarray));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  tmp = strlen(key);
  hash_val = phpspy_zend_inline_hash_func(key, tmp);
  hash_table_size = (uint32_t )(-1 * (int32_t )lzarray.nTableMask);
  hash_index = (uint32_t )(hash_val % (unsigned long )hash_table_size);
  while (1) {
    rv = copy_proc_mem(context->target.pid, "hash_table_val", (void *)(((uint32_t *)lzarray.arData - hash_table_size) + hash_index),
                       (void *)(& hash_table_val), sizeof(uint32_t ));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  hash_bucket = & hash_table_val;
  while (1) {
    if (*hash_bucket == 4294967295U) {
      return (1);
    }
    while (1) {
      rv = copy_proc_mem(context->target.pid, "bucket", (void *)(lzarray.arData + *hash_bucket),
                         (void *)lbucket, sizeof(Bucket_81 ));
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    if ((unsigned long )lbucket->key == (unsigned long )((void *)0)) {
      break;
    }
    while (1) {
      rv = sprint_zstring_81(context, "array_key", lbucket->key, tmp_key, sizeof(tmp_key),
                             & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    tmp___0 = strcmp(key, (char const   *)(tmp_key));
    if (tmp___0 == 0) {
      hash_bucket = (uint32_t *)((void *)0);
    } else {
      hash_bucket = & lbucket->val.u2.next;
    }
    if (! hash_bucket) {
      break;
    }
  }
  return (0);
}
}
static int sprint_zstring_81(trace_context_t *context , char const   *what , zend_string_81 *rzstring ,
                             char *buf___0 , size_t buf_size , size_t *buf_len___0 ) 
{ 
  int rv ;
  zend_string_81 lzstring ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  *buf___0 = (char )'\000';
  *buf_len___0 = (size_t )0;
  while (1) {
    rv = copy_proc_mem(context->target.pid, what, (void *)rzstring, (void *)(& lzstring),
                       sizeof(lzstring));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  if (1UL > buf_size) {
    tmp___1 = (size_t )1;
  } else {
    tmp___1 = buf_size;
  }
  if (lzstring.len < tmp___1 - 1UL) {
    *buf_len___0 = lzstring.len;
  } else {
    if (1UL > buf_size) {
      tmp___0 = (size_t )1;
    } else {
      tmp___0 = buf_size;
    }
    *buf_len___0 = tmp___0 - 1UL;
  }
  while (1) {
    rv = copy_proc_mem(context->target.pid, what, (void *)((char *)rzstring + (unsigned long )(& ((zend_string_81 *)0)->val)),
                       (void *)buf___0, *buf_len___0);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  *(buf___0 + (int )*buf_len___0) = (char )'\000';
  return (0);
}
}
static int sprint_zval_81(trace_context_t *context , zval_81 *lzval , char *buf___0 ,
                          size_t buf_size , size_t *buf_len___0 ) 
{ 
  int rv ;
  int type ;

  {
  type = (int )lzval->u1.v.type;
  switch (type) {
  case 4: 
  snprintf((char * __restrict  )buf___0, buf_size, (char const   * __restrict  )"%ld",
           lzval->value.lval);
  *buf_len___0 = strlen((char const   *)buf___0);
  break;
  case 5: 
  snprintf((char * __restrict  )buf___0, buf_size, (char const   * __restrict  )"%f",
           lzval->value.dval);
  *buf_len___0 = strlen((char const   *)buf___0);
  break;
  case 6: 
  while (1) {
    rv = sprint_zstring_81(context, "zval", lzval->value.str, buf___0, buf_size, buf_len___0);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  break;
  case 7: 
  while (1) {
    rv = sprint_zarray_81(context, lzval->value.arr, buf___0, buf_size, buf_len___0);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  break;
  default: 
  return (1);
  }
  return (0);
}
}
static int sprint_zarray_81(trace_context_t *context , zend_array_81 *rzarray , char *buf___0 ,
                            size_t buf_size , size_t *buf_len___0 ) 
{ 
  int rv ;
  int i ;
  int array_len ;
  size_t tmp_len ;
  Bucket_81 buckets[128] ;
  zend_array_81 lzarray ;
  char *obuf ;

  {
  obuf = buf___0;
  while (1) {
    rv = copy_proc_mem(context->target.pid, "array", (void *)rzarray, (void *)(& lzarray),
                       sizeof(lzarray));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  if (lzarray.nNumOfElements < 128U) {
    array_len = (int )lzarray.nNumOfElements;
  } else {
    array_len = 128;
  }
  while (1) {
    rv = copy_proc_mem(context->target.pid, "buckets", (void *)lzarray.arData, (void *)(buckets),
                       sizeof(Bucket_81 ) * (unsigned long )array_len);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  i = 0;
  while (i < array_len) {
    while (1) {
      rv = sprint_zarray_bucket_81(context, buckets + i, buf___0, buf_size, & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    buf_size -= tmp_len;
    buf___0 += tmp_len;
    if (buf_size >= 2UL) {
      *buf___0 = (char )',';
      buf_size --;
      buf___0 ++;
    }
    i ++;
  }
  *buf_len___0 = (size_t )(buf___0 - obuf);
  return (0);
}
}
static int sprint_zarray_val81(trace_context_t *context , zend_array_81 *rzarray ,
                               char const   *key , char *buf___0 , size_t buf_size ,
                               size_t *buf_len___0 ) 
{ 
  int rv ;
  Bucket_81 bucket ;

  {
  while (1) {
    rv = copy_zarray_bucket_81(context, rzarray, key, & bucket);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = sprint_zval_81(context, & bucket.val, buf___0, buf_size, buf_len___0);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  return (0);
}
}
static int sprint_zarray_bucket_81(trace_context_t *context , Bucket_81 *lbucket ,
                                   char *buf___0 , size_t buf_size , size_t *buf_len___0 ) 
{ 
  int rv ;
  char tmp_key[256] ;
  size_t tmp_len ;
  char *obuf ;

  {
  obuf = buf___0;
  if ((unsigned long )lbucket->key != (unsigned long )((void *)0)) {
    while (1) {
      rv = sprint_zstring_81(context, "array_key", lbucket->key, tmp_key, sizeof(tmp_key),
                             & tmp_len);
      if (rv != 0) {
        return (rv);
      }
      break;
    }
    if (buf_size > (tmp_len + 1UL) + 1UL) {
      snprintf((char * __restrict  )buf___0, buf_size, (char const   * __restrict  )"%s=",
               tmp_key);
      buf_size -= tmp_len + 1UL;
      buf___0 += tmp_len + 1UL;
    }
  }
  while (1) {
    rv = sprint_zval_81(context, & lbucket->val, buf___0, buf_size, & tmp_len);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  buf___0 += tmp_len;
  *buf_len___0 = (size_t )(buf___0 - obuf);
  return (0);
}
}
#pragma merger("0","/tmp/cil-TZrg2JBD.i","-std=c11,-Wall,-Wextra,-pedantic,-g,-O3,-Wno-address-of-packed-member,-pthread")
extern int fcntl(int __fd , int __cmd  , ...) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                                              pthread_condattr_t const   * __restrict  __cond_attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_destroy)(pthread_cond_t *__cond ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_signal)(pthread_cond_t *__cond ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_broadcast)(pthread_cond_t *__cond ) ;
extern int ( __attribute__((__nonnull__(1,2,3))) pthread_cond_timedwait)(pthread_cond_t * __restrict  __cond ,
                                                                         pthread_mutex_t * __restrict  __mutex ,
                                                                         struct timespec  const  * __restrict  __abstime ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigfillset)(sigset_t *__set ) ;
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
static int wait_for_turn(char producer_or_consumer ) ;
static void pgrep_for_pids(void) ;
static void *run_work_thread(void *arg ) ;
static int is_already_attached(int pid ) ;
static void init_work_threads(void) ;
static void deinit_work_threads(void) ;
static int block_all_signals(void) ;
static void handle_signal(int signum ) ;
static void *run_signal_thread(void *arg ) ;
static int *avail_pids  =    (int *)((void *)0);
static int *attached_pids  =    (int *)((void *)0);
static pthread_t *work_threads  =    (pthread_t *)((void *)0);
static pthread_t signal_thread  ;
static int avail_pids_count  =    0;
static pthread_mutex_t mutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
static pthread_cond_t can_produce  =    {{{0ULL},
     {0ULL}, {0U, 0U}, {0U, 0U}, 0U, 0U, {0U, 0U}}};
static pthread_cond_t can_consume  =    {{{0ULL}, {0ULL}, {0U, 0U}, {0U, 0U}, 0U, 0U, {0U, 0U}}};
static int done_pipe[2]  = {      -1,      -1};
int main_pgrep(void) 
{ 
  long i ;
  long tmp ;

  {
  if (opt_num_workers < 1) {
    log_error("Expected max concurrent workers (-T) > 0\n");
    exit(1);
  }
  pthread_create((pthread_t * __restrict  )(& signal_thread), (pthread_attr_t const   * __restrict  )((void *)0),
                 & run_signal_thread, (void * __restrict  )((void *)0));
  block_all_signals();
  init_work_threads();
  i = 0L;
  while (i < (long )opt_num_workers) {
    pthread_create((pthread_t * __restrict  )(work_threads + i), (pthread_attr_t const   * __restrict  )((void *)0),
                   & run_work_thread, (void * __restrict  )((void *)i));
    i ++;
  }
  if (opt_time_limit_ms > 0L) {
    if (1L > opt_time_limit_ms / 1000L) {
      tmp = 1L;
    } else {
      tmp = opt_time_limit_ms / 1000L;
    }
    alarm((unsigned int )tmp);
  }
  pgrep_for_pids();
  i = 0L;
  while (i < (long )opt_num_workers) {
    pthread_join(*(work_threads + i), (void **)((void *)0));
    i ++;
  }
  pthread_join(signal_thread, (void **)((void *)0));
  deinit_work_threads();
  log_error("main_pgrep finished gracefully\n");
  return (0);
}
}
static int wait_for_turn(char producer_or_consumer ) 
{ 
  struct timespec timeout ;
  pthread_cond_t *tmp ;

  {
  pthread_mutex_lock(& mutex);
  while (! done) {
    if ((int )producer_or_consumer == 112) {
      if (avail_pids_count < opt_num_workers) {
        break;
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (avail_pids_count > 0) {
      break;
    }
    clock_gettime(0, & timeout);
    timeout.tv_sec += 2L;
    if ((int )producer_or_consumer == 112) {
      tmp = & can_produce;
    } else {
      tmp = & can_consume;
    }
    pthread_cond_timedwait((pthread_cond_t * __restrict  )tmp, (pthread_mutex_t * __restrict  )(& mutex),
                           (struct timespec  const  * __restrict  )(& timeout));
  }
  if (done) {
    pthread_mutex_unlock(& mutex);
    return (1);
  }
  return (0);
}
}
static void pgrep_for_pids(void) 
{ 
  FILE *pcmd ;
  char *pgrep_cmd ;
  char line[64] ;
  int pid ;
  int found ;
  struct timespec timeout ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
  tmp___0 = asprintf((char ** __restrict  )(& pgrep_cmd), (char const   * __restrict  )"pgrep %s",
                     opt_pgrep_args);
  if (tmp___0 < 0) {
    tmp = __errno_location();
    *tmp = 12;
    perror("asprintf");
    exit(1);
  }
  while (! done) {
    tmp___1 = wait_for_turn((char )'p');
    if (tmp___1) {
      break;
    }
    found = 0;
    pcmd = popen((char const   *)pgrep_cmd, "r");
    if ((unsigned long )pcmd != (unsigned long )((void *)0)) {
      while (1) {
        if (avail_pids_count < opt_num_workers) {
          tmp___5 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )pcmd);
          if (! ((unsigned long )tmp___5 != (unsigned long )((void *)0))) {
            break;
          }
        } else {
          break;
        }
        tmp___2 = strlen((char const   *)(line));
        if (tmp___2 < 1UL) {
          continue;
        } else
        if ((int )line[0] == 10) {
          continue;
        }
        pid = atoi((char const   *)(line));
        tmp___3 = is_already_attached(pid);
        if (tmp___3) {
          continue;
        }
        tmp___4 = avail_pids_count;
        avail_pids_count ++;
        *(avail_pids + tmp___4) = pid;
        found ++;
      }
      pclose(pcmd);
    }
    if (found > 0) {
      pthread_cond_broadcast(& can_consume);
    } else {
      clock_gettime(0, & timeout);
      timeout.tv_sec += 2L;
      pthread_cond_timedwait((pthread_cond_t * __restrict  )(& can_produce), (pthread_mutex_t * __restrict  )(& mutex),
                             (struct timespec  const  * __restrict  )(& timeout));
    }
    pthread_mutex_unlock(& mutex);
  }
  free((void *)pgrep_cmd);
  return;
}
}
static void *run_work_thread(void *arg ) 
{ 
  int worker_num ;
  int tmp ;

  {
  worker_num = (int )((long )arg);
  while (! done) {
    tmp = wait_for_turn((char )'c');
    if (tmp) {
      break;
    }
    avail_pids_count --;
    *(attached_pids + worker_num) = *(avail_pids + avail_pids_count);
    pthread_cond_signal(& can_produce);
    pthread_mutex_unlock(& mutex);
    main_pid(*(attached_pids + worker_num));
    *(attached_pids + worker_num) = 0;
  }
  return ((void *)0);
}
}
static int is_already_attached(int pid ) 
{ 
  int i ;

  {
  i = 0;
  while (i < opt_num_workers) {
    if (*(attached_pids + i) == pid) {
      return (1);
    } else
    if (i < avail_pids_count) {
      if (*(avail_pids + i) == pid) {
        return (1);
      }
    }
    i ++;
  }
  return (0);
}
}
static void init_work_threads(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
  tmp = calloc((size_t )opt_num_workers, sizeof(int ));
  avail_pids = (int *)tmp;
  tmp___0 = calloc((size_t )opt_num_workers, sizeof(int ));
  attached_pids = (int *)tmp___0;
  tmp___1 = calloc((size_t )opt_num_workers, sizeof(pthread_t ));
  work_threads = (pthread_t *)tmp___1;
  if (! avail_pids) {
    tmp___2 = __errno_location();
    *tmp___2 = 12;
    perror("calloc");
    exit(1);
  } else
  if (! attached_pids) {
    tmp___2 = __errno_location();
    *tmp___2 = 12;
    perror("calloc");
    exit(1);
  } else
  if (! work_threads) {
    tmp___2 = __errno_location();
    *tmp___2 = 12;
    perror("calloc");
    exit(1);
  }
  pthread_mutex_init(& mutex, (pthread_mutexattr_t const   *)((void *)0));
  pthread_cond_init((pthread_cond_t * __restrict  )(& can_produce), (pthread_condattr_t const   * __restrict  )((void *)0));
  pthread_cond_init((pthread_cond_t * __restrict  )(& can_consume), (pthread_condattr_t const   * __restrict  )((void *)0));
  return;
}
}
static void deinit_work_threads(void) 
{ 


  {
  free((void *)avail_pids);
  free((void *)attached_pids);
  free((void *)work_threads);
  pthread_mutex_destroy(& mutex);
  pthread_cond_destroy(& can_produce);
  pthread_cond_destroy(& can_consume);
  return;
}
}
static int block_all_signals(void) 
{ 
  int rv ;
  sigset_t set ;

  {
  while (1) {
    rv = sigfillset(& set);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = sigprocmask(0, (sigset_t const   * __restrict  )(& set), (sigset_t * __restrict  )((void *)0));
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  return (0);
}
}
void write_done_pipe(void) 
{ 
  int rv ;
  int ignore ;
  ssize_t tmp ;

  {
  if (done_pipe[1] >= 0) {
    ignore = 1;
    tmp = write(done_pipe[1], (void const   *)(& ignore), sizeof(int ));
    rv = (int )tmp;
  }
  return;
}
}
static void handle_signal(int signum ) 
{ 


  {
  write_done_pipe();
  return;
}
}
static void *run_signal_thread(void *arg ) 
{ 
  int rv ;
  int ignore ;
  fd_set rfds ;
  struct timeval tv ;
  struct sigaction sa ;
  int __d0 ;
  int __d1 ;
  ssize_t tmp ;

  {
  rv = pipe((int *)(done_pipe));
  rv = fcntl(done_pipe[1], 4, 2048);
  memset((void *)(& sa), 0, sizeof(struct sigaction ));
  sa.__sigaction_handler.sa_handler = & handle_signal;
  sigaction(2, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
  sigaction(15, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
  sigaction(1, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
  sigaction(14, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))1;
  sigaction(13, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
  while (1) {
    while (1) {
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& rfds.fds_bits[0]): "memory");
      break;
    }
    rfds.fds_bits[done_pipe[0] / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << done_pipe[0] % (8 * (int )sizeof(__fd_mask )));
    tv.tv_sec = (__time_t )1;
    tv.tv_usec = (__suseconds_t )0;
    rv = select(done_pipe[0] + 1, (fd_set * __restrict  )(& rfds), (fd_set * __restrict  )((void *)0),
                (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )(& tv));
    if (! (rv < 1)) {
      break;
    }
  }
  tmp = read(done_pipe[0], (void *)(& ignore), sizeof(int ));
  rv = (int )tmp;
  done = 1;
  pthread_mutex_lock(& mutex);
  pthread_cond_broadcast(& can_consume);
  pthread_cond_broadcast(& can_produce);
  pthread_mutex_unlock(& mutex);
  return ((void *)0);
}
}
#pragma merger("0","/tmp/cil-TPeL67wZ.i","-std=c11,-Wall,-Wextra,-pedantic,-g,-O3,-Wno-address-of-packed-member,-pthread")
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memchr)(void const   *__s ,
                                                                                     int __c ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
static int fork_child(int argc , char **argv , pid_t *pid , int *outfd , int *errfd ) ;
static void filter_child_args(int argc , char **argv ) ;
static void read_child_out(int fd ) ;
static void read_child_err(int fd ) ;
static void handle_line(char *line , int line_len ) ;
static void handle_event(struct tb_event *event ) ;
static void display(void) ;
static func_entry_t *func_map  =    (func_entry_t *)((void *)0);
static func_entry_t **func_list  =    (func_entry_t **)((void *)0);
static size_t func_list_len  =    (size_t )0;
static size_t func_list_size  =    (size_t )0;
static char buf[512]  ;
static size_t buf_len  =    (size_t )0;
static unsigned long total_samp_count  =    0UL;
static unsigned long samp_count  =    0UL;
static unsigned long total_err_count  =    0UL;
static int is_paused  =    0;
static char phpspy_args[512]  ;
int main_top(int argc , char **argv ) 
{ 
  fd_set readfds ;
  int ttyfd ;
  int outfd ;
  int errfd ;
  int maxfd ;
  pid_t pid ;
  struct timeval timeout ;
  struct timespec ts ;
  struct timespec last_display ;
  struct tb_event event ;
  int rc ;
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;
  int __d0 ;
  int __d1 ;
  int *tmp___5 ;

  {
  pid = -1;
  ttyfd = pid;
  errfd = ttyfd;
  outfd = errfd;
  if (opt_pid == -1) {
    if ((unsigned long )opt_pgrep_args == (unsigned long )((void *)0)) {
      if (optind >= argc) {
        log_error("Expected pid (-p), pgrep (-P), or command\n\n");
        usage(stderr, 1);
        return (1);
      }
    }
  }
  filter_child_args(argc, argv);
  snprintf((char * __restrict  )(phpspy_args), (size_t )512, (char const   * __restrict  )"phpspy ");
  i = 1;
  while (i < argc) {
    tmp = strlen((char const   *)(phpspy_args));
    tmp___0 = strlen((char const   *)(phpspy_args));
    snprintf((char * __restrict  )(phpspy_args + tmp___0), 512UL - tmp, (char const   * __restrict  )"%s ",
             *(argv + i));
    i ++;
  }
  ttyfd = open("/dev/tty", 0);
  if (ttyfd < 0) {
    perror("open");
    return (1);
  }
  tmp___1 = fork_child(argc, argv, & pid, & outfd, & errfd);
  if (tmp___1 < 0) {
    return (1);
  }
  if (ttyfd > outfd) {
    tmp___4 = ttyfd;
  } else {
    tmp___4 = outfd;
  }
  if (tmp___4 > errfd) {
    if (ttyfd > outfd) {
      tmp___3 = ttyfd;
    } else {
      tmp___3 = outfd;
    }
    maxfd = tmp___3;
  } else {
    maxfd = errfd;
  }
  last_display.tv_sec = (__time_t )0;
  last_display.tv_nsec = (__syscall_slong_t )0;
  tb_init();
  while (! done) {
    clock_gettime(1, & ts);
    if (last_display.tv_sec == 0L) {
      display();
      last_display = ts;
    } else
    if (ts.tv_sec - last_display.tv_sec >= 1L) {
      display();
      last_display = ts;
    }
    while (1) {
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& readfds.fds_bits[0]): "memory");
      break;
    }
    readfds.fds_bits[ttyfd / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << ttyfd % (8 * (int )sizeof(__fd_mask )));
    readfds.fds_bits[outfd / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << outfd % (8 * (int )sizeof(__fd_mask )));
    readfds.fds_bits[errfd / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << errfd % (8 * (int )sizeof(__fd_mask )));
    timeout.tv_sec = (__time_t )1;
    timeout.tv_usec = (__suseconds_t )0;
    rc = select(maxfd + 1, (fd_set * __restrict  )(& readfds), (fd_set * __restrict  )((void *)0),
                (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )(& timeout));
    if (rc < 0) {
      tmp___5 = __errno_location();
      if (*tmp___5 == 4) {
        tb_peek_event(& event, 0);
        last_display.tv_sec = (__time_t )0;
        continue;
      }
      perror("select");
      break;
    }
    if ((readfds.fds_bits[outfd / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << outfd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      read_child_out(outfd);
    }
    if ((readfds.fds_bits[errfd / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << errfd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      read_child_err(errfd);
    }
    if ((readfds.fds_bits[ttyfd / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << ttyfd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      event.type = (uint8_t )0;
      tb_peek_event(& event, 0);
      handle_event(& event);
    }
  }
  tb_shutdown();
  close(outfd);
  close(errfd);
  close(ttyfd);
  kill(pid, 15);
  waitpid(pid, (int *)((void *)0), 0);
  return (0);
}
}
static int fork_child(int argc , char **argv , pid_t *pid , int *outfd , int *errfd ) 
{ 
  int pout[2] ;
  int perr[2] ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = pipe((int *)(pout));
  if (tmp < 0) {
    perror("pipe");
    return (1);
  } else {
    tmp___0 = pipe((int *)(perr));
    if (tmp___0 < 0) {
      perror("pipe");
      return (1);
    }
  }
  *pid = fork();
  if (*pid == 0) {
    close(pout[0]);
    dup2(pout[1], 1);
    close(pout[1]);
    close(perr[0]);
    dup2(perr[1], 2);
    close(perr[1]);
    execvp((char const   *)*(argv + 0), (char * const  *)argv);
    perror("execvp");
    exit(1);
  } else
  if (*pid < 0) {
    perror("fork");
    return (1);
  }
  close(pout[1]);
  close(perr[1]);
  *outfd = pout[0];
  *errfd = perr[0];
  return (0);
}
}
static void filter_child_args(int argc , char **argv ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  i = 0;
  while (i < argc) {
    tmp = strncmp((char const   *)*(argv + i), "-o", sizeof("-o") - 1UL);
    if (tmp == 0) {
      *(*(argv + i) + 1) = (char )'#';
      *(*(argv + i) + 2) = (char )'\000';
    } else {
      tmp___0 = strncmp((char const   *)*(argv + i), "--output", sizeof("--output") - 1UL);
      if (tmp___0 == 0) {
        *(*(argv + i) + 1) = (char )'#';
        *(*(argv + i) + 2) = (char )'\000';
      }
    }
    tmp___1 = strncmp((char const   *)*(argv + i), "-1", sizeof("-1") - 1UL);
    if (tmp___1 == 0) {
      *(*(argv + i) + 1) = (char )'@';
      *(*(argv + i) + 2) = (char )'\000';
    } else {
      tmp___2 = strncmp((char const   *)*(argv + i), "--single-line", sizeof("--single-line") - 1UL);
      if (tmp___2 == 0) {
        *(*(argv + i) + 1) = (char )'@';
        *(*(argv + i) + 2) = (char )'\000';
      } else {
        tmp___3 = strncmp((char const   *)*(argv + i), "-t", sizeof("-t") - 1UL);
        if (tmp___3 == 0) {
          *(*(argv + i) + 1) = (char )'@';
          *(*(argv + i) + 2) = (char )'\000';
        } else {
          tmp___4 = strncmp((char const   *)*(argv + i), "--top", sizeof("--top") - 1UL);
          if (tmp___4 == 0) {
            *(*(argv + i) + 1) = (char )'@';
            *(*(argv + i) + 2) = (char )'\000';
          }
        }
      }
    }
    i ++;
  }
  return;
}
}
static void read_child_out(int fd ) 
{ 
  size_t rem ;
  size_t line_len ;
  char *nl ;
  ssize_t read_rv ;
  void *tmp ;

  {
  rem = 512UL - buf_len;
  if (rem < 1UL) {
    buf_len = (size_t )0;
    rem = (size_t )512;
  }
  read_rv = read(fd, (void *)(buf + buf_len), rem);
  if (read_rv < 0L) {
    perror("read");
    return;
  } else
  if (read_rv == 0L) {
    done = 1;
    return;
  }
  buf_len += (size_t )read_rv;
  while (1) {
    tmp = memchr((void const   *)(buf), '\n', buf_len);
    nl = (char *)tmp;
    if (! ((unsigned long )nl != (unsigned long )((void *)0))) {
      break;
    }
    line_len = (size_t )(nl - buf);
    handle_line(buf, (int )line_len);
    memmove((void *)(buf), (void const   *)(nl + 1), buf_len - (line_len + 1UL));
    buf_len -= line_len + 1UL;
  }
  return;
}
}
static void read_child_err(int fd ) 
{ 
  char buf___0[512] ;
  char *nl ;
  size_t buf_pos ;
  ssize_t read_rv ;
  void *tmp ;

  {
  read_rv = read(fd, (void *)(buf___0), (size_t )512);
  if (read_rv < 0L) {
    perror("read");
    return;
  } else
  if (read_rv == 0L) {
    done = 1;
    return;
  }
  buf_pos = (size_t )0;
  while (1) {
    if (read_rv > 0L) {
      tmp = memchr((void const   *)(buf___0 + buf_pos), '\n', (size_t )read_rv);
      nl = (char *)tmp;
      if (! ((unsigned long )nl != (unsigned long )((void *)0))) {
        break;
      }
    } else {
      break;
    }
    total_err_count ++;
    buf_pos += (size_t )((nl - buf___0) + 1L);
    read_rv -= (nl - buf___0) + 1L;
  }
  return;
}
}
static void handle_line(char *line , int line_len ) 
{ 
  unsigned long frame_num ;
  char *func ;
  size_t func_len ;
  func_entry_t *func_el ;
  unsigned long long tmp ;
  unsigned int _hf_hashv ;
  unsigned int _hj_i ;
  unsigned int _hj_j ;
  unsigned int _hj_k ;
  unsigned char const   *_hj_key ;
  unsigned int _hf_bkt ;
  int tmp___0 ;
  void *tmp___1 ;
  unsigned int _uthash_hastr_keylen ;
  size_t tmp___2 ;
  unsigned int _ha_hashv ;
  unsigned int _hj_i___0 ;
  unsigned int _hj_j___0 ;
  unsigned int _hj_k___0 ;
  unsigned char const   *_hj_key___0 ;
  void *tmp___3 ;
  void *tmp___4 ;
  unsigned int _ha_bkt ;
  UT_hash_bucket *_ha_head ;
  unsigned int _he_bkt ;
  unsigned int _he_bkt_i ;
  struct UT_hash_handle *_he_thh ;
  struct UT_hash_handle *_he_hh_nxt ;
  UT_hash_bucket *_he_new_buckets ;
  UT_hash_bucket *_he_newbkt ;
  void *tmp___5 ;
  unsigned int tmp___6 ;
  void *tmp___7 ;

  {
  if (line_len < 3) {
    return;
  }
  if ((int )*(line + 0) == 35) {
    return;
  }
  tmp = strtoull((char const   * __restrict  )line, (char ** __restrict  )(& func),
                 10);
  frame_num = (unsigned long )tmp;
  if (frame_num == 0UL) {
    if ((int )*(line + 0) != 48) {
      return;
    }
  }
  if ((int )*func != 32) {
    return;
  }
  func ++;
  func_len = (size_t )((long )line_len - (func - line));
  if (func_len < 1UL) {
    return;
  } else
  if (func_len >= 256UL) {
    return;
  }
  while (1) {
    while (1) {
      while (1) {
        _hj_key = (unsigned char const   *)func;
        _hf_hashv = 4276993775U;
        _hj_j = 2654435769U;
        _hj_i = _hj_j;
        _hj_k = (unsigned int )func_len;
        while (_hj_k >= 12U) {
          _hj_i += (((unsigned int )*(_hj_key + 0) + ((unsigned int )*(_hj_key + 1) << 8)) + ((unsigned int )*(_hj_key + 2) << 16)) + ((unsigned int )*(_hj_key + 3) << 24);
          _hj_j += (((unsigned int )*(_hj_key + 4) + ((unsigned int )*(_hj_key + 5) << 8)) + ((unsigned int )*(_hj_key + 6) << 16)) + ((unsigned int )*(_hj_key + 7) << 24);
          _hf_hashv += (((unsigned int )*(_hj_key + 8) + ((unsigned int )*(_hj_key + 9) << 8)) + ((unsigned int )*(_hj_key + 10) << 16)) + ((unsigned int )*(_hj_key + 11) << 24);
          while (1) {
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 13;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 8;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 13;
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 12;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 16;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 5;
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 3;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 10;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 15;
            break;
          }
          _hj_key += 12;
          _hj_k -= 12U;
        }
        _hf_hashv += (unsigned int )func_len;
        switch (_hj_k) {
        case 11U: 
        _hf_hashv += (unsigned int )*(_hj_key + 10) << 24;
        case 10U: 
        _hf_hashv += (unsigned int )*(_hj_key + 9) << 16;
        case 9U: 
        _hf_hashv += (unsigned int )*(_hj_key + 8) << 8;
        case 8U: 
        _hj_j += (unsigned int )*(_hj_key + 7) << 24;
        case 7U: 
        _hj_j += (unsigned int )*(_hj_key + 6) << 16;
        case 6U: 
        _hj_j += (unsigned int )*(_hj_key + 5) << 8;
        case 5U: 
        _hj_j += (unsigned int )*(_hj_key + 4);
        case 4U: 
        _hj_i += (unsigned int )*(_hj_key + 3) << 24;
        case 3U: 
        _hj_i += (unsigned int )*(_hj_key + 2) << 16;
        case 2U: 
        _hj_i += (unsigned int )*(_hj_key + 1) << 8;
        case 1U: 
        _hj_i += (unsigned int )*(_hj_key + 0);
        }
        while (1) {
          _hj_i -= _hj_j;
          _hj_i -= _hf_hashv;
          _hj_i ^= _hf_hashv >> 13;
          _hj_j -= _hf_hashv;
          _hj_j -= _hj_i;
          _hj_j ^= _hj_i << 8;
          _hf_hashv -= _hj_i;
          _hf_hashv -= _hj_j;
          _hf_hashv ^= _hj_j >> 13;
          _hj_i -= _hj_j;
          _hj_i -= _hf_hashv;
          _hj_i ^= _hf_hashv >> 12;
          _hj_j -= _hf_hashv;
          _hj_j -= _hj_i;
          _hj_j ^= _hj_i << 16;
          _hf_hashv -= _hj_i;
          _hf_hashv -= _hj_j;
          _hf_hashv ^= _hj_j >> 5;
          _hj_i -= _hj_j;
          _hj_i -= _hf_hashv;
          _hj_i ^= _hf_hashv >> 3;
          _hj_j -= _hf_hashv;
          _hj_j -= _hj_i;
          _hj_j ^= _hj_i << 10;
          _hf_hashv -= _hj_i;
          _hf_hashv -= _hj_j;
          _hf_hashv ^= _hj_j >> 15;
          break;
        }
        break;
      }
      break;
    }
    while (1) {
      func_el = (func_entry_t *)((void *)0);
      if (func_map) {
        while (1) {
          _hf_bkt = _hf_hashv & ((func_map->hh.tbl)->num_buckets - 1U);
          break;
        }
        while (1) {
          if ((unsigned long )((func_map->hh.tbl)->buckets + _hf_bkt)->hh_head != (unsigned long )((void *)0)) {
            while (1) {
              func_el = (func_entry_t *)((void *)((char *)((func_map->hh.tbl)->buckets + _hf_bkt)->hh_head - (func_map->hh.tbl)->hho));
              break;
            }
          } else {
            func_el = (func_entry_t *)((void *)0);
          }
          while ((unsigned long )func_el != (unsigned long )((void *)0)) {
            if (func_el->hh.hashv == _hf_hashv) {
              if ((size_t )func_el->hh.keylen == func_len) {
                tmp___0 = memcmp((void const   *)func_el->hh.key, (void const   *)func,
                                 func_len);
                if (tmp___0 == 0) {
                  break;
                }
              }
            }
            if ((unsigned long )func_el->hh.hh_next != (unsigned long )((void *)0)) {
              while (1) {
                func_el = (func_entry_t *)((void *)((char *)func_el->hh.hh_next - (func_map->hh.tbl)->hho));
                break;
              }
            } else {
              func_el = (func_entry_t *)((void *)0);
            }
          }
          break;
        }
      }
      break;
    }
    break;
  }
  if (! func_el) {
    tmp___1 = calloc((size_t )1, sizeof(func_entry_t ));
    func_el = (func_entry_t *)tmp___1;
    snprintf((char * __restrict  )(func_el->func), (size_t )256, (char const   * __restrict  )"%.*s",
             (int )func_len, func);
    while (1) {
      tmp___2 = strlen((char const   *)(func_el->func));
      _uthash_hastr_keylen = (unsigned int )tmp___2;
      while (1) {
        while (1) {
          while (1) {
            _hj_key___0 = (unsigned char const   *)(& func_el->func[0]);
            _ha_hashv = 4276993775U;
            _hj_j___0 = 2654435769U;
            _hj_i___0 = _hj_j___0;
            _hj_k___0 = _uthash_hastr_keylen;
            while (_hj_k___0 >= 12U) {
              _hj_i___0 += (((unsigned int )*(_hj_key___0 + 0) + ((unsigned int )*(_hj_key___0 + 1) << 8)) + ((unsigned int )*(_hj_key___0 + 2) << 16)) + ((unsigned int )*(_hj_key___0 + 3) << 24);
              _hj_j___0 += (((unsigned int )*(_hj_key___0 + 4) + ((unsigned int )*(_hj_key___0 + 5) << 8)) + ((unsigned int )*(_hj_key___0 + 6) << 16)) + ((unsigned int )*(_hj_key___0 + 7) << 24);
              _ha_hashv += (((unsigned int )*(_hj_key___0 + 8) + ((unsigned int )*(_hj_key___0 + 9) << 8)) + ((unsigned int )*(_hj_key___0 + 10) << 16)) + ((unsigned int )*(_hj_key___0 + 11) << 24);
              while (1) {
                _hj_i___0 -= _hj_j___0;
                _hj_i___0 -= _ha_hashv;
                _hj_i___0 ^= _ha_hashv >> 13;
                _hj_j___0 -= _ha_hashv;
                _hj_j___0 -= _hj_i___0;
                _hj_j___0 ^= _hj_i___0 << 8;
                _ha_hashv -= _hj_i___0;
                _ha_hashv -= _hj_j___0;
                _ha_hashv ^= _hj_j___0 >> 13;
                _hj_i___0 -= _hj_j___0;
                _hj_i___0 -= _ha_hashv;
                _hj_i___0 ^= _ha_hashv >> 12;
                _hj_j___0 -= _ha_hashv;
                _hj_j___0 -= _hj_i___0;
                _hj_j___0 ^= _hj_i___0 << 16;
                _ha_hashv -= _hj_i___0;
                _ha_hashv -= _hj_j___0;
                _ha_hashv ^= _hj_j___0 >> 5;
                _hj_i___0 -= _hj_j___0;
                _hj_i___0 -= _ha_hashv;
                _hj_i___0 ^= _ha_hashv >> 3;
                _hj_j___0 -= _ha_hashv;
                _hj_j___0 -= _hj_i___0;
                _hj_j___0 ^= _hj_i___0 << 10;
                _ha_hashv -= _hj_i___0;
                _ha_hashv -= _hj_j___0;
                _ha_hashv ^= _hj_j___0 >> 15;
                break;
              }
              _hj_key___0 += 12;
              _hj_k___0 -= 12U;
            }
            _ha_hashv += _uthash_hastr_keylen;
            switch (_hj_k___0) {
            case 11U: 
            _ha_hashv += (unsigned int )*(_hj_key___0 + 10) << 24;
            case 10U: 
            _ha_hashv += (unsigned int )*(_hj_key___0 + 9) << 16;
            case 9U: 
            _ha_hashv += (unsigned int )*(_hj_key___0 + 8) << 8;
            case 8U: 
            _hj_j___0 += (unsigned int )*(_hj_key___0 + 7) << 24;
            case 7U: 
            _hj_j___0 += (unsigned int )*(_hj_key___0 + 6) << 16;
            case 6U: 
            _hj_j___0 += (unsigned int )*(_hj_key___0 + 5) << 8;
            case 5U: 
            _hj_j___0 += (unsigned int )*(_hj_key___0 + 4);
            case 4U: 
            _hj_i___0 += (unsigned int )*(_hj_key___0 + 3) << 24;
            case 3U: 
            _hj_i___0 += (unsigned int )*(_hj_key___0 + 2) << 16;
            case 2U: 
            _hj_i___0 += (unsigned int )*(_hj_key___0 + 1) << 8;
            case 1U: 
            _hj_i___0 += (unsigned int )*(_hj_key___0 + 0);
            }
            while (1) {
              _hj_i___0 -= _hj_j___0;
              _hj_i___0 -= _ha_hashv;
              _hj_i___0 ^= _ha_hashv >> 13;
              _hj_j___0 -= _ha_hashv;
              _hj_j___0 -= _hj_i___0;
              _hj_j___0 ^= _hj_i___0 << 8;
              _ha_hashv -= _hj_i___0;
              _ha_hashv -= _hj_j___0;
              _ha_hashv ^= _hj_j___0 >> 13;
              _hj_i___0 -= _hj_j___0;
              _hj_i___0 -= _ha_hashv;
              _hj_i___0 ^= _ha_hashv >> 12;
              _hj_j___0 -= _ha_hashv;
              _hj_j___0 -= _hj_i___0;
              _hj_j___0 ^= _hj_i___0 << 16;
              _ha_hashv -= _hj_i___0;
              _ha_hashv -= _hj_j___0;
              _ha_hashv ^= _hj_j___0 >> 5;
              _hj_i___0 -= _hj_j___0;
              _hj_i___0 -= _ha_hashv;
              _hj_i___0 ^= _ha_hashv >> 3;
              _hj_j___0 -= _ha_hashv;
              _hj_j___0 -= _hj_i___0;
              _hj_j___0 ^= _hj_i___0 << 10;
              _ha_hashv -= _hj_i___0;
              _ha_hashv -= _hj_j___0;
              _ha_hashv ^= _hj_j___0 >> 15;
              break;
            }
            break;
          }
          break;
        }
        while (1) {
          func_el->hh.hashv = _ha_hashv;
          func_el->hh.key = (void *)(& func_el->func[0]);
          func_el->hh.keylen = _uthash_hastr_keylen;
          if (! func_map) {
            func_el->hh.next = (void *)0;
            func_el->hh.prev = (void *)0;
            while (1) {
              tmp___3 = malloc(sizeof(UT_hash_table ));
              func_el->hh.tbl = (UT_hash_table *)tmp___3;
              if (! func_el->hh.tbl) {
                exit(-1);
              } else {
                memset((void *)func_el->hh.tbl, '\000', sizeof(UT_hash_table ));
                (func_el->hh.tbl)->tail = & func_el->hh;
                (func_el->hh.tbl)->num_buckets = 32U;
                (func_el->hh.tbl)->log2_num_buckets = 5U;
                (func_el->hh.tbl)->hho = (char *)(& func_el->hh) - (char *)func_el;
                tmp___4 = malloc(32UL * sizeof(struct UT_hash_bucket ));
                (func_el->hh.tbl)->buckets = (UT_hash_bucket *)tmp___4;
                (func_el->hh.tbl)->signature = 2685476833U;
                if (! (func_el->hh.tbl)->buckets) {
                  exit(-1);
                  free((void *)func_el->hh.tbl);
                } else {
                  memset((void *)(func_el->hh.tbl)->buckets, '\000', 32UL * sizeof(struct UT_hash_bucket ));
                }
              }
              break;
            }
            func_map = func_el;
          } else {
            func_el->hh.tbl = func_map->hh.tbl;
            while (1) {
              func_el->hh.next = (void *)0;
              func_el->hh.prev = (void *)((char *)(func_map->hh.tbl)->tail - (func_map->hh.tbl)->hho);
              ((func_map->hh.tbl)->tail)->next = (void *)func_el;
              (func_map->hh.tbl)->tail = & func_el->hh;
              break;
            }
          }
          while (1) {
            ((func_map->hh.tbl)->num_items) ++;
            while (1) {
              _ha_bkt = _ha_hashv & ((func_map->hh.tbl)->num_buckets - 1U);
              break;
            }
            while (1) {
              _ha_head = (func_map->hh.tbl)->buckets + _ha_bkt;
              (_ha_head->count) ++;
              func_el->hh.hh_next = _ha_head->hh_head;
              func_el->hh.hh_prev = (struct UT_hash_handle *)((void *)0);
              if ((unsigned long )_ha_head->hh_head != (unsigned long )((void *)0)) {
                (_ha_head->hh_head)->hh_prev = & func_el->hh;
              }
              _ha_head->hh_head = & func_el->hh;
              if (_ha_head->count >= (_ha_head->expand_mult + 1U) * 10U) {
                if (! (func_el->hh.tbl)->noexpand) {
                  while (1) {
                    tmp___5 = malloc((2UL * (unsigned long )(func_el->hh.tbl)->num_buckets) * sizeof(struct UT_hash_bucket ));
                    _he_new_buckets = (UT_hash_bucket *)tmp___5;
                    if (! _he_new_buckets) {
                      exit(-1);
                    } else {
                      memset((void *)_he_new_buckets, '\000', (2UL * (unsigned long )(func_el->hh.tbl)->num_buckets) * sizeof(struct UT_hash_bucket ));
                      if (((func_el->hh.tbl)->num_items & ((func_el->hh.tbl)->num_buckets * 2U - 1U)) != 0U) {
                        tmp___6 = 1U;
                      } else {
                        tmp___6 = 0U;
                      }
                      (func_el->hh.tbl)->ideal_chain_maxlen = ((func_el->hh.tbl)->num_items >> ((func_el->hh.tbl)->log2_num_buckets + 1U)) + tmp___6;
                      (func_el->hh.tbl)->nonideal_items = 0U;
                      _he_bkt_i = 0U;
                      while (_he_bkt_i < (func_el->hh.tbl)->num_buckets) {
                        _he_thh = ((func_el->hh.tbl)->buckets + _he_bkt_i)->hh_head;
                        while ((unsigned long )_he_thh != (unsigned long )((void *)0)) {
                          _he_hh_nxt = _he_thh->hh_next;
                          while (1) {
                            _he_bkt = _he_thh->hashv & ((func_el->hh.tbl)->num_buckets * 2U - 1U);
                            break;
                          }
                          _he_newbkt = _he_new_buckets + _he_bkt;
                          (_he_newbkt->count) ++;
                          if (_he_newbkt->count > (func_el->hh.tbl)->ideal_chain_maxlen) {
                            ((func_el->hh.tbl)->nonideal_items) ++;
                            _he_newbkt->expand_mult = _he_newbkt->count / (func_el->hh.tbl)->ideal_chain_maxlen;
                          }
                          _he_thh->hh_prev = (struct UT_hash_handle *)((void *)0);
                          _he_thh->hh_next = _he_newbkt->hh_head;
                          if ((unsigned long )_he_newbkt->hh_head != (unsigned long )((void *)0)) {
                            (_he_newbkt->hh_head)->hh_prev = _he_thh;
                          }
                          _he_newbkt->hh_head = _he_thh;
                          _he_thh = _he_hh_nxt;
                        }
                        _he_bkt_i ++;
                      }
                      free((void *)(func_el->hh.tbl)->buckets);
                      (func_el->hh.tbl)->num_buckets *= 2U;
                      ((func_el->hh.tbl)->log2_num_buckets) ++;
                      (func_el->hh.tbl)->buckets = _he_new_buckets;
                      if ((func_el->hh.tbl)->nonideal_items > (func_el->hh.tbl)->num_items >> 1) {
                        ((func_el->hh.tbl)->ineff_expands) ++;
                      } else {
                        (func_el->hh.tbl)->ineff_expands = 0U;
                      }
                      if ((func_el->hh.tbl)->ineff_expands > 1U) {
                        (func_el->hh.tbl)->noexpand = 1U;
                      }
                    }
                    break;
                  }
                }
              }
              break;
            }
            break;
          }
          break;
        }
        break;
      }
      break;
    }
    func_list_len ++;
    if (func_list_len > func_list_size) {
      tmp___7 = realloc((void *)func_list, sizeof(func_entry_t *) * (func_list_size + 1024UL));
      func_list = (func_entry_t **)tmp___7;
      func_list_size += 1024UL;
    }
    *(func_list + (func_list_len - 1UL)) = func_el;
  }
  if (frame_num == 0UL) {
    samp_count ++;
    (func_el->count_excl) ++;
  }
  (func_el->count_incl) ++;
  return;
}
}
static void handle_event(struct tb_event *event ) 
{ 


  {
  if ((int )event->type != 1) {
    return;
  } else
  if (event->ch == 113U) {
    done = 1;
  } else
  if (event->ch == 112U) {
    is_paused = 1 - is_paused;
  }
  return;
}
}
static int func_list_compare(void const   *a , void const   *b ) 
{ 
  func_entry_t *fa ;
  func_entry_t *fb ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  fa = *((func_entry_t **)a);
  fb = *((func_entry_t **)b);
  if (fb->count_excl == fa->count_excl) {
    if (fb->count_incl == fa->count_incl) {
      if (fb->total_count_excl == fa->total_count_excl) {
        if (fb->total_count_incl == fa->total_count_incl) {
          return (0);
        }
        if (fb->total_count_incl > fa->total_count_incl) {
          tmp = 1;
        } else {
          tmp = -1;
        }
        return (tmp);
      }
      if (fb->total_count_excl > fa->total_count_excl) {
        tmp___0 = 1;
      } else {
        tmp___0 = -1;
      }
      return (tmp___0);
    }
    if (fb->count_incl > fa->count_incl) {
      tmp___1 = 1;
    } else {
      tmp___1 = -1;
    }
    return (tmp___1);
  }
  if (fb->count_excl > fa->count_excl) {
    tmp___2 = 1;
  } else {
    tmp___2 = -1;
  }
  return (tmp___2);
}
}
static void display(void) 
{ 
  int y ;
  int w ;
  int h ;
  func_entry_t *el ;
  size_t i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  if (func_list_len > 0UL) {
    qsort((void *)func_list, func_list_len, sizeof(func_entry_t *), & func_list_compare);
    i = (size_t )0;
    while (i < func_list_len) {
      (*(func_list + i))->total_count_excl += (*(func_list + i))->count_excl;
      (*(func_list + i))->total_count_incl += (*(func_list + i))->count_incl;
      if (samp_count < 1UL) {
        (*(func_list + i))->percent_excl = 0.f;
      } else {
        (*(func_list + i))->percent_excl = (100.f * (float )(*(func_list + i))->count_excl) / (float )samp_count;
      }
      i ++;
    }
  }
  total_samp_count += samp_count;
  tb_clear();
  w = tb_width();
  h = tb_height();
  y = 0;
  tmp = y;
  y ++;
  tb_printf(0, tmp, (uintattr_t )256, (uintattr_t )0, "%s", phpspy_args);
  tmp___0 = y;
  y ++;
  tb_printf(0, tmp___0, (uintattr_t )0, (uintattr_t )0, "samp_count=%llu  err_count=%llu  func_count=%llu",
            total_samp_count, total_err_count, func_list_len);
  y ++;
  tb_printf(0, y, (uintattr_t )1280, (uintattr_t )0, "%-10s %-10s %-10s %-10s %-7s ",
            "tincl", "texcl", "incl", "excl", "excl%");
  tmp___1 = y;
  y ++;
  tb_printf(52, tmp___1, (uintattr_t )1280, (uintattr_t )0, "%-*s", w - 52, "func");
  i = (size_t )0;
  while (1) {
    if (y < h) {
      if (! (i < func_list_len)) {
        break;
      }
    } else {
      break;
    }
    tmp___2 = i;
    i ++;
    el = *(func_list + tmp___2);
    tmp___3 = y;
    y ++;
    tb_printf(0, tmp___3, (uintattr_t )0, (uintattr_t )0, "%-9llu  %-9llu  %-9llu  %-9llu  %-6.2f  %s",
              el->total_count_incl, el->total_count_excl, el->count_incl, el->count_excl,
              (double )el->percent_excl, el->func);
  }
  i = (size_t )0;
  while (i < func_list_len) {
    (*(func_list + i))->count_excl = 0UL;
    (*(func_list + i))->count_incl = 0UL;
    i ++;
  }
  samp_count = 0UL;
  if (! is_paused) {
    tb_present();
  }
  return;
}
}
#pragma merger("0","/tmp/cil-Qqp4Jd8O.i","-std=c11,-Wall,-Wextra,-pedantic,-g,-O3,-Wno-address-of-packed-member,-pthread")
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) access)(char const   *__name ,
                                                                                   int __type ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
static int get_php_bin_path(pid_t pid , char *path_root , char *path ) ;
static int get_php_base_addr(pid_t pid , char *path_root , char *path , uint64_t *raddr ) ;
static int get_symbol_offset(char *path_root , char const   *symbol , uint64_t *raddr ) ;
static int popen_read_line(char *buf___0 , size_t buf_size , char *cmd_fmt  , ...) ;
static int shell_escape(char const   *arg , char *buf___0 , size_t buf_size ) 
{ 
  char *buf_end ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;

  {
  buf_end = buf___0 + buf_size;
  if (! (buf_size >= 1UL)) {
    __assert_fail("buf_size >= 1", "addr_objdump.c", 11U, "shell_escape");
  }
  tmp = buf___0;
  buf___0 ++;
  *tmp = (char )'\'';
  while (*arg) {
    if ((int const   )*arg == 39) {
      if (buf_end - buf___0 < 4L) {
        return (1);
      }
      tmp___0 = buf___0;
      buf___0 ++;
      *tmp___0 = (char )'\'';
      tmp___1 = buf___0;
      buf___0 ++;
      *tmp___1 = (char )'\\';
      tmp___2 = buf___0;
      buf___0 ++;
      *tmp___2 = (char )'\'';
      tmp___3 = buf___0;
      buf___0 ++;
      *tmp___3 = (char )'\'';
      arg ++;
    } else {
      if (buf_end - buf___0 < 1L) {
        return (1);
      }
      tmp___4 = buf___0;
      buf___0 ++;
      tmp___5 = arg;
      arg ++;
      *tmp___4 = (char )*tmp___5;
    }
  }
  if (buf_end - buf___0 < 2L) {
    return (1);
  }
  tmp___6 = buf___0;
  buf___0 ++;
  *tmp___6 = (char )'\'';
  *buf___0 = (char )'\000';
  return (0);
}
}
int get_symbol_addr(addr_memo_t *memo , pid_t pid , char const   *symbol , uint64_t *raddr ) 
{ 
  char *php_bin_path ;
  char *php_bin_path_root ;
  uint64_t *php_base_addr ;
  uint64_t addr_offset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  php_bin_path = memo->php_bin_path;
  php_bin_path_root = memo->php_bin_path_root;
  php_base_addr = & memo->php_base_addr;
  if ((int )*php_bin_path == 0) {
    tmp___1 = get_php_bin_path(pid, php_bin_path_root, php_bin_path);
    if (tmp___1 != 0) {
      return (1);
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if (*php_base_addr == 0UL) {
    tmp___0 = get_php_base_addr(pid, php_bin_path_root, php_bin_path, php_base_addr);
    if (tmp___0 != 0) {
      return (1);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    tmp = get_symbol_offset(php_bin_path_root, symbol, & addr_offset);
    if (tmp != 0) {
      return (1);
    }
  }
  *raddr = *php_base_addr + addr_offset;
  return (0);
}
}
static int get_php_bin_path(pid_t pid , char *path_root , char *path ) 
{ 
  char buf___0[256] ;
  char *cmd_fmt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  cmd_fmt = (char *)"awk -ve=1 \'/libphp[78]?/{print $NF; e=0; exit} END{exit e}\' /proc/%d/maps || readlink /proc/%d/exe";
  tmp = popen_read_line(buf___0, sizeof(buf___0), cmd_fmt, pid, pid);
  if (tmp != 0) {
    log_error("get_php_bin_path: Failed\n");
    return (1);
  }
  tmp___0 = snprintf((char * __restrict  )path_root, (size_t )256, (char const   * __restrict  )"/proc/%d/root/%s",
                     pid, buf___0);
  if (tmp___0 > 255) {
    log_error("get_php_bin_path: snprintf overflow\n");
    return (1);
  }
  tmp___1 = access((char const   *)path_root, 0);
  if (tmp___1 != 0) {
    snprintf((char * __restrict  )path_root, (size_t )256, (char const   * __restrict  )"/proc/%d/exe",
             pid);
  }
  strcpy((char * __restrict  )path, (char const   * __restrict  )(buf___0));
  return (0);
}
}
static int get_php_base_addr(pid_t pid , char *path_root , char *path , uint64_t *raddr ) 
{ 
  char buf___0[256] ;
  char arg_buf[256] ;
  uint64_t start_addr ;
  uint64_t virt_addr ;
  char *cmd_fmt ;
  int tmp ;
  int tmp___0 ;
  unsigned long long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned long long tmp___4 ;

  {
  cmd_fmt = (char *)"grep -m1 \' \'%s\\$ /proc/%d/maps";
  tmp = shell_escape((char const   *)path, arg_buf, sizeof(arg_buf));
  if (tmp) {
    log_error("shell_escape: Buffer too small to escape path: %s\n", path);
    return (1);
  }
  tmp___0 = popen_read_line(buf___0, sizeof(buf___0), cmd_fmt, arg_buf, pid);
  if (tmp___0 != 0) {
    log_error("get_php_base_addr: Failed to get start_addr\n");
    return (1);
  }
  tmp___1 = strtoull((char const   * __restrict  )(buf___0), (char ** __restrict  )((void *)0),
                     16);
  start_addr = (uint64_t )tmp___1;
  tmp___2 = shell_escape((char const   *)path_root, arg_buf, sizeof(arg_buf));
  if (tmp___2) {
    log_error("shell_escape: Buffer too small to escape path_root: %s\n", path_root);
    return (1);
  }
  cmd_fmt = (char *)"objdump -p %s | awk \'/LOAD/{print $5; exit}\'";
  tmp___3 = popen_read_line(buf___0, sizeof(buf___0), cmd_fmt, arg_buf);
  if (tmp___3 != 0) {
    log_error("get_php_base_addr: Failed to get virt_addr\n");
    return (1);
  }
  tmp___4 = strtoull((char const   * __restrict  )(buf___0), (char ** __restrict  )((void *)0),
                     16);
  virt_addr = (uint64_t )tmp___4;
  *raddr = start_addr - virt_addr;
  return (0);
}
}
static int get_symbol_offset(char *path_root , char const   *symbol , uint64_t *raddr ) 
{ 
  char buf___0[256] ;
  char arg_buf[256] ;
  char *cmd_fmt ;
  int tmp ;
  int tmp___0 ;
  unsigned long long tmp___1 ;

  {
  cmd_fmt = (char *)"objdump -Tt %s | awk \'/ %s$/{print $1; exit}\'";
  tmp = shell_escape((char const   *)path_root, arg_buf, sizeof(arg_buf));
  if (tmp) {
    log_error("shell_escape: Buffer too smal to escape path_root: %s\n", path_root);
    return (1);
  }
  tmp___0 = popen_read_line(buf___0, sizeof(buf___0), cmd_fmt, arg_buf, symbol);
  if (tmp___0 != 0) {
    log_error("get_symbol_offset: Failed\n");
    return (1);
  }
  tmp___1 = strtoull((char const   * __restrict  )(buf___0), (char ** __restrict  )((void *)0),
                     16);
  *raddr = (uint64_t )tmp___1;
  return (0);
}
}
static int popen_read_line(char *buf___0 , size_t buf_size , char *cmd_fmt  , ...) 
{ 
  FILE *fp ;
  char cmd[256] ;
  int buf_len___0 ;
  va_list___0 cmd_args ;
  int tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
  __builtin_va_start(cmd_args, cmd_fmt);
  tmp = vsnprintf((char * __restrict  )(cmd), sizeof(cmd), (char const   * __restrict  )cmd_fmt,
                  cmd_args);
  if (tmp >= (int )(sizeof(cmd) - 1UL)) {
    log_error("vsnprintf overflow\n");
    return (1);
  }
  __builtin_va_end(cmd_args);
  fp = popen((char const   *)(cmd), "r");
  if (! fp) {
    perror("popen");
    return (1);
  }
  tmp___0 = fgets((char * __restrict  )buf___0, (int )(buf_size - 1UL), (FILE * __restrict  )fp);
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    log_error("popen_read_line: No stdout; cmd=%s\n", cmd);
    pclose(fp);
    return (1);
  }
  pclose(fp);
  tmp___1 = strlen((char const   *)buf___0);
  buf_len___0 = (int )tmp___1;
  while (1) {
    if (buf_len___0 > 0) {
      if (! ((int )*(buf___0 + (buf_len___0 - 1)) == 10)) {
        break;
      }
    } else {
      break;
    }
    buf_len___0 --;
  }
  if (buf_len___0 < 1) {
    log_error("popen_read_line: Expected strlen(buf)>0; cmd=%s\n", cmd);
    return (1);
  }
  *(buf___0 + buf_len___0) = (char )'\000';
  return (0);
}
}
#pragma merger("0","/tmp/cil-KRO3U35E.i","-std=c11,-Wall,-Wextra,-pedantic,-g,-O3,-Wno-address-of-packed-member,-pthread")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         void * __restrict  __tz ) ;
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __String ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
static int event_handler_fout_write(event_handler_fout_udata_t *udata ) ;
static int event_handler_fout_snprintf(char **s , size_t *n , size_t *ret_len , int repl_delim ,
                                       char const   *fmt  , ...) ;
static int event_handler_fout_open(int *fd ) ;
int event_handler_fout(struct trace_context_s *context , int event_type ) 
{ 
  int rv ;
  int fd ;
  size_t len ;
  trace_frame_t *frame ;
  trace_request_t *request ;
  event_handler_fout_udata_t *udata ;
  struct timeval tv ;
  void *tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;

  {
  udata = (event_handler_fout_udata_t *)context->event_udata;
  if (! udata) {
    if (event_type != 0) {
      return (1);
    }
  }
  len = (size_t )0;
  switch (event_type) {
  case 0: 
  while (1) {
    rv = event_handler_fout_open(& fd);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  tmp = calloc((size_t )1, sizeof(event_handler_fout_udata_t ));
  udata = (event_handler_fout_udata_t *)tmp;
  udata->fd = fd;
  udata->buf_size = (size_t )(opt_fout_buffer_size + 1);
  tmp___0 = malloc(udata->buf_size);
  udata->buf = (char *)tmp___0;
  udata->cur = udata->buf;
  udata->rem = udata->buf_size;
  context->event_udata = (void *)udata;
  break;
  case 1: 
  udata->cur = udata->buf;
  *(udata->cur + 0) = (char )'\000';
  udata->rem = udata->buf_size;
  break;
  case 2: 
  frame = & context->event.frame;
  while (1) {
    if (frame->loc.class_len > 0UL) {
      tmp___1 = "::";
    } else {
      tmp___1 = "";
    }
    rv = event_handler_fout_snprintf(& udata->cur, & udata->rem, & len, 1, "%d %.*s%s%.*s %.*s:%d",
                                     frame->depth, (int )frame->loc.class_len, frame->loc.class,
                                     tmp___1, (int )frame->loc.func_len, frame->loc.func,
                                     (int )frame->loc.file_len, frame->loc.file, frame->loc.lineno);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = event_handler_fout_snprintf(& udata->cur, & udata->rem, & len, 0, "%c", (int )opt_frame_delim);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  break;
  case 3: 
  while (1) {
    rv = event_handler_fout_snprintf(& udata->cur, & udata->rem, & len, 1, "# varpeek %s@%s = %s",
                                     (context->event.varpeek.var)->name, (context->event.varpeek.entry)->filename_lineno,
                                     context->event.varpeek.zval_str);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = event_handler_fout_snprintf(& udata->cur, & udata->rem, & len, 0, "%c", (int )opt_frame_delim);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  break;
  case 4: 
  while (1) {
    rv = event_handler_fout_snprintf(& udata->cur, & udata->rem, & len, 1, "# glopeek %s = %s",
                                     (context->event.glopeek.gentry)->key, context->event.glopeek.zval_str);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = event_handler_fout_snprintf(& udata->cur, & udata->rem, & len, 0, "%c", (int )opt_frame_delim);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  break;
  case 5: 
  request = & context->event.request;
  while (1) {
    rv = event_handler_fout_snprintf(& udata->cur, & udata->rem, & len, 1, "# uri = %s",
                                     request->uri);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = event_handler_fout_snprintf(& udata->cur, & udata->rem, & len, 0, "%c", (int )opt_frame_delim);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = event_handler_fout_snprintf(& udata->cur, & udata->rem, & len, 1, "# path = %s",
                                     request->path);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = event_handler_fout_snprintf(& udata->cur, & udata->rem, & len, 0, "%c", (int )opt_frame_delim);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = event_handler_fout_snprintf(& udata->cur, & udata->rem, & len, 1, "# qstring = %s",
                                     request->qstring);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = event_handler_fout_snprintf(& udata->cur, & udata->rem, & len, 0, "%c", (int )opt_frame_delim);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = event_handler_fout_snprintf(& udata->cur, & udata->rem, & len, 1, "# cookie = %s",
                                     request->cookie);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = event_handler_fout_snprintf(& udata->cur, & udata->rem, & len, 0, "%c", (int )opt_frame_delim);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = event_handler_fout_snprintf(& udata->cur, & udata->rem, & len, 1, "# ts = %f",
                                     request->ts);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = event_handler_fout_snprintf(& udata->cur, & udata->rem, & len, 0, "%c", (int )opt_frame_delim);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  break;
  case 6: 
  while (1) {
    rv = event_handler_fout_snprintf(& udata->cur, & udata->rem, & len, 1, "# mem %lu %lu",
                                     context->event.mem.size, context->event.mem.peak);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  while (1) {
    rv = event_handler_fout_snprintf(& udata->cur, & udata->rem, & len, 0, "%c", (int )opt_frame_delim);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  break;
  case 7: 
  if ((unsigned long )udata->cur == (unsigned long )udata->buf) {
    break;
  }
  if (opt_filter_re) {
    rv = regexec((regex_t const   * __restrict  )opt_filter_re, (char const   * __restrict  )udata->buf,
                 (size_t )0, (regmatch_t * __restrict  )((void *)0), 0);
    if (opt_filter_negate == 0) {
      if (rv != 0) {
        break;
      }
    }
    if (opt_filter_negate != 0) {
      if (rv == 0) {
        break;
      }
    }
  }
  while (1) {
    if (opt_verbose_fields_ts) {
      gettimeofday((struct timeval * __restrict  )(& tv), (void * __restrict  )((void *)0));
      while (1) {
        rv = event_handler_fout_snprintf(& udata->cur, & udata->rem, & len, 1, "# trace_ts = %f",
                                         (double )tv.tv_sec + (double )tv.tv_usec / 1000000.0);
        if (rv != 0) {
          break;
        }
        break;
      }
      while (1) {
        rv = event_handler_fout_snprintf(& udata->cur, & udata->rem, & len, 0, "%c",
                                         (int )opt_frame_delim);
        if (rv != 0) {
          break;
        }
        break;
      }
    }
    if (opt_verbose_fields_pid) {
      while (1) {
        rv = event_handler_fout_snprintf(& udata->cur, & udata->rem, & len, 1, "# pid = %d",
                                         context->target.pid);
        if (rv != 0) {
          break;
        }
        break;
      }
      while (1) {
        rv = event_handler_fout_snprintf(& udata->cur, & udata->rem, & len, 0, "%c",
                                         (int )opt_frame_delim);
        if (rv != 0) {
          break;
        }
        break;
      }
    }
    while (1) {
      rv = event_handler_fout_snprintf(& udata->cur, & udata->rem, & len, 0, "%c",
                                       (int )opt_trace_delim);
      if (rv != 0) {
        break;
      }
      break;
    }
    break;
  }
  while (1) {
    rv = event_handler_fout_write(udata);
    if (rv != 0) {
      return (rv);
    }
    break;
  }
  break;
  case 9: 
  close(udata->fd);
  free((void *)udata->buf);
  free((void *)udata);
  break;
  }
  return (0);
}
}
static int event_handler_fout_write(event_handler_fout_udata_t *udata ) 
{ 
  ssize_t write_len ;
  int *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  int *tmp___3 ;
  ssize_t tmp___4 ;

  {
  write_len = udata->cur - udata->buf;
  if (! (write_len < 1L)) {
    tmp___4 = write(udata->fd, (void const   *)udata->buf, (size_t )write_len);
    if (tmp___4 != write_len) {
      tmp___3 = __errno_location();
      if (*tmp___3 != 0) {
        tmp___0 = __errno_location();
        tmp___1 = strerror(*tmp___0);
        tmp___2 = (char const   *)tmp___1;
      } else {
        tmp___2 = "partial";
      }
      log_error("event_handler_fout: Write failed (%s)\n", tmp___2);
      return (1);
    }
  }
  return (0);
}
}
static int event_handler_fout_snprintf(char **s , size_t *n , size_t *ret_len , int repl_delim ,
                                       char const   *fmt  , ...) 
{ 
  int len ;
  int i ;
  va_list___0 vl ;
  char *c ;

  {
  __builtin_va_start(vl, fmt);
  len = vsnprintf((char * __restrict  )*s, *n, (char const   * __restrict  )fmt, vl);
  __builtin_va_end(vl);
  if (len < 0) {
    log_error("event_handler_fout_snprintf: Not enough space in buffer; truncating\n");
    return (5);
  } else
  if ((size_t )len >= *n) {
    log_error("event_handler_fout_snprintf: Not enough space in buffer; truncating\n");
    return (5);
  }
  if (repl_delim) {
    i = 0;
    while (i < len) {
      c = *s + i;
      if ((int )*c == (int )opt_trace_delim) {
        *c = (char )'?';
      } else
      if ((int )*c == (int )opt_frame_delim) {
        *c = (char )'?';
      }
      i ++;
    }
  }
  *s += len;
  *n -= (size_t )len;
  *ret_len = (size_t )len;
  return (0);
}
}
static int event_handler_fout_open(int *fd ) 
{ 
  int tfd ;
  int tmp ;

  {
  tmp = strcmp((char const   *)opt_path_output, "-");
  if (tmp == 0) {
    tfd = dup(1);
    if (tfd < 0) {
      perror("event_handler_fout_open: dup");
      return (1);
    }
  } else {
    tfd = open((char const   *)opt_path_output, 577, (384 | (256 >> 3)) | ((256 >> 3) >> 3));
    if (tfd < 0) {
      perror("event_handler_fout_open: open");
      return (1);
    }
  }
  *fd = tfd;
  return (0);
}
}
#pragma merger("0","/tmp/cil-wz3YyY7d.i","-std=c11,-Wall,-Wextra,-pedantic,-g,-O3,-Wno-address-of-packed-member,-pthread")
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
extern  __attribute__((__nothrow__)) int setvbuf(FILE * __restrict  __stream , char * __restrict  __buf ,
                                                 int __modes , size_t __n ) ;
static int callgrind_open(FILE **fout ) ;
static void callgrind_sprint_loc(char *str , trace_loc_t *loc ) ;
static void callgrind_ingest_frame(callgrind_udata_t *udata , struct trace_context_s *context ) ;
static void callgrind_digest_stack(callgrind_udata_t *udata ) ;
static void callgrind_dump(callgrind_udata_t *udata ) ;
static void callgrind_free(callgrind_udata_t *udata ) ;
static int callgrind_sort_callers(callgrind_caller_t *a , callgrind_caller_t *b ) ;
static int callgrind_sort_callees(callgrind_callee_t *a , callgrind_callee_t *b ) ;
int event_handler_callgrind(struct trace_context_s *context , int event_type ) 
{ 
  callgrind_udata_t *udata ;
  void *tmp ;
  int tmp___0 ;

  {
  udata = (callgrind_udata_t *)context->event_udata;
  if (! udata) {
    if (event_type != 0) {
      return (1);
    }
  }
  switch (event_type) {
  case 0: 
  tmp = calloc((size_t )1, sizeof(callgrind_udata_t ));
  udata = (callgrind_udata_t *)tmp;
  tmp___0 = callgrind_open(& udata->fout);
  if (tmp___0 != 0) {
    free((void *)udata);
    return (1);
  }
  context->event_udata = (void *)udata;
  break;
  case 1: 
  udata->self_len = 0;
  break;
  case 2: 
  callgrind_ingest_frame(udata, context);
  break;
  case 7: 
  callgrind_digest_stack(udata);
  memcpy((void * __restrict  )(udata->prev), (void const   * __restrict  )(udata->self),
         sizeof(trace_loc_t ) * (unsigned long )udata->self_len);
  memcpy((void * __restrict  )(udata->prev_str), (void const   * __restrict  )(udata->self_str),
         (size_t )(256 * udata->self_len));
  udata->prev_len = udata->self_len;
  udata->self_len = 0;
  break;
  case 9: 
  callgrind_dump(udata);
  callgrind_free(udata);
  free((void *)udata);
  break;
  }
  return (0);
}
}
static void callgrind_ingest_frame(callgrind_udata_t *udata , struct trace_context_s *context ) 
{ 


  {
  if (udata->self_len >= 128) {
    log_error("callgrind_ingest_frame: Exceeded max stack depth (%d); truncating\n",
              128);
    return;
  }
  memcpy((void * __restrict  )(& udata->self[udata->self_len]), (void const   * __restrict  )(& context->event.frame.loc),
         sizeof(trace_loc_t ));
  callgrind_sprint_loc(udata->self_str[udata->self_len], & context->event.frame.loc);
  (udata->self_len) ++;
  return;
}
}
static void callgrind_sprint_loc(char *str , trace_loc_t *loc ) 
{ 
  int len ;
  char const   *tmp ;

  {
  if (loc->class_len > 0UL) {
    tmp = "::";
  } else {
    tmp = "";
  }
  len = snprintf((char * __restrict  )str, (size_t )256, (char const   * __restrict  )"%.*s%s%.*s %.*s:%d",
                 (int )loc->class_len, loc->class, tmp, (int )loc->func_len, loc->func,
                 (int )loc->file_len, loc->file, loc->lineno);
  if (len >= 256) {
    log_error("callgrind_sprint_loc: Exceeded max loc len (%d); truncating\n", 256);
  }
  return;
}
}
static void callgrind_digest_stack(callgrind_udata_t *udata ) 
{ 
  callgrind_caller_t *caller ;
  callgrind_caller_t *prev_caller ;
  callgrind_callee_t *callee ;
  int i ;
  unsigned int _uthash_hfstr_keylen ;
  size_t tmp ;
  unsigned int _hf_hashv ;
  unsigned int _hj_i ;
  unsigned int _hj_j ;
  unsigned int _hj_k ;
  unsigned char const   *_hj_key ;
  unsigned int _hf_bkt ;
  int tmp___0 ;
  void *tmp___1 ;
  unsigned int _uthash_hastr_keylen ;
  size_t tmp___2 ;
  unsigned int _ha_hashv ;
  unsigned int _hj_i___0 ;
  unsigned int _hj_j___0 ;
  unsigned int _hj_k___0 ;
  unsigned char const   *_hj_key___0 ;
  void *tmp___3 ;
  void *tmp___4 ;
  unsigned int _ha_bkt ;
  UT_hash_bucket *_ha_head ;
  unsigned int _he_bkt ;
  unsigned int _he_bkt_i ;
  struct UT_hash_handle *_he_thh ;
  struct UT_hash_handle *_he_hh_nxt ;
  UT_hash_bucket *_he_new_buckets ;
  UT_hash_bucket *_he_newbkt ;
  void *tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int _uthash_hfstr_keylen___0 ;
  size_t tmp___7 ;
  unsigned int _hf_hashv___0 ;
  unsigned int _hj_i___1 ;
  unsigned int _hj_j___1 ;
  unsigned int _hj_k___1 ;
  unsigned char const   *_hj_key___1 ;
  unsigned int _hf_bkt___0 ;
  int tmp___8 ;
  void *tmp___9 ;
  unsigned int _uthash_hastr_keylen___0 ;
  size_t tmp___10 ;
  unsigned int _ha_hashv___0 ;
  unsigned int _hj_i___2 ;
  unsigned int _hj_j___2 ;
  unsigned int _hj_k___2 ;
  unsigned char const   *_hj_key___2 ;
  void *tmp___11 ;
  void *tmp___12 ;
  unsigned int _ha_bkt___0 ;
  UT_hash_bucket *_ha_head___0 ;
  unsigned int _he_bkt___0 ;
  unsigned int _he_bkt_i___0 ;
  struct UT_hash_handle *_he_thh___0 ;
  struct UT_hash_handle *_he_hh_nxt___0 ;
  UT_hash_bucket *_he_new_buckets___0 ;
  UT_hash_bucket *_he_newbkt___0 ;
  void *tmp___13 ;
  unsigned int tmp___14 ;
  int tmp___15 ;

  {
  prev_caller = (callgrind_caller_t *)((void *)0);
  i = udata->self_len - 1;
  while (i >= 0) {
    while (1) {
      tmp = strlen((char const   *)(udata->self_str[i]));
      _uthash_hfstr_keylen = (unsigned int )tmp;
      while (1) {
        while (1) {
          while (1) {
            _hj_key = (unsigned char const   *)(udata->self_str[i]);
            _hf_hashv = 4276993775U;
            _hj_j = 2654435769U;
            _hj_i = _hj_j;
            _hj_k = _uthash_hfstr_keylen;
            while (_hj_k >= 12U) {
              _hj_i += (((unsigned int )*(_hj_key + 0) + ((unsigned int )*(_hj_key + 1) << 8)) + ((unsigned int )*(_hj_key + 2) << 16)) + ((unsigned int )*(_hj_key + 3) << 24);
              _hj_j += (((unsigned int )*(_hj_key + 4) + ((unsigned int )*(_hj_key + 5) << 8)) + ((unsigned int )*(_hj_key + 6) << 16)) + ((unsigned int )*(_hj_key + 7) << 24);
              _hf_hashv += (((unsigned int )*(_hj_key + 8) + ((unsigned int )*(_hj_key + 9) << 8)) + ((unsigned int )*(_hj_key + 10) << 16)) + ((unsigned int )*(_hj_key + 11) << 24);
              while (1) {
                _hj_i -= _hj_j;
                _hj_i -= _hf_hashv;
                _hj_i ^= _hf_hashv >> 13;
                _hj_j -= _hf_hashv;
                _hj_j -= _hj_i;
                _hj_j ^= _hj_i << 8;
                _hf_hashv -= _hj_i;
                _hf_hashv -= _hj_j;
                _hf_hashv ^= _hj_j >> 13;
                _hj_i -= _hj_j;
                _hj_i -= _hf_hashv;
                _hj_i ^= _hf_hashv >> 12;
                _hj_j -= _hf_hashv;
                _hj_j -= _hj_i;
                _hj_j ^= _hj_i << 16;
                _hf_hashv -= _hj_i;
                _hf_hashv -= _hj_j;
                _hf_hashv ^= _hj_j >> 5;
                _hj_i -= _hj_j;
                _hj_i -= _hf_hashv;
                _hj_i ^= _hf_hashv >> 3;
                _hj_j -= _hf_hashv;
                _hj_j -= _hj_i;
                _hj_j ^= _hj_i << 10;
                _hf_hashv -= _hj_i;
                _hf_hashv -= _hj_j;
                _hf_hashv ^= _hj_j >> 15;
                break;
              }
              _hj_key += 12;
              _hj_k -= 12U;
            }
            _hf_hashv += _uthash_hfstr_keylen;
            switch (_hj_k) {
            case 11U: 
            _hf_hashv += (unsigned int )*(_hj_key + 10) << 24;
            case 10U: 
            _hf_hashv += (unsigned int )*(_hj_key + 9) << 16;
            case 9U: 
            _hf_hashv += (unsigned int )*(_hj_key + 8) << 8;
            case 8U: 
            _hj_j += (unsigned int )*(_hj_key + 7) << 24;
            case 7U: 
            _hj_j += (unsigned int )*(_hj_key + 6) << 16;
            case 6U: 
            _hj_j += (unsigned int )*(_hj_key + 5) << 8;
            case 5U: 
            _hj_j += (unsigned int )*(_hj_key + 4);
            case 4U: 
            _hj_i += (unsigned int )*(_hj_key + 3) << 24;
            case 3U: 
            _hj_i += (unsigned int )*(_hj_key + 2) << 16;
            case 2U: 
            _hj_i += (unsigned int )*(_hj_key + 1) << 8;
            case 1U: 
            _hj_i += (unsigned int )*(_hj_key + 0);
            }
            while (1) {
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 13;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 8;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 13;
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 12;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 16;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 5;
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 3;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 10;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 15;
              break;
            }
            break;
          }
          break;
        }
        while (1) {
          caller = (callgrind_caller_t *)((void *)0);
          if (udata->callers) {
            while (1) {
              _hf_bkt = _hf_hashv & (((udata->callers)->hh.tbl)->num_buckets - 1U);
              break;
            }
            while (1) {
              if ((unsigned long )(((udata->callers)->hh.tbl)->buckets + _hf_bkt)->hh_head != (unsigned long )((void *)0)) {
                while (1) {
                  caller = (callgrind_caller_t *)((void *)((char *)(((udata->callers)->hh.tbl)->buckets + _hf_bkt)->hh_head - ((udata->callers)->hh.tbl)->hho));
                  break;
                }
              } else {
                caller = (callgrind_caller_t *)((void *)0);
              }
              while ((unsigned long )caller != (unsigned long )((void *)0)) {
                if (caller->hh.hashv == _hf_hashv) {
                  if (caller->hh.keylen == _uthash_hfstr_keylen) {
                    tmp___0 = memcmp((void const   *)caller->hh.key, (void const   *)(udata->self_str[i]),
                                     (size_t )_uthash_hfstr_keylen);
                    if (tmp___0 == 0) {
                      break;
                    }
                  }
                }
                if ((unsigned long )caller->hh.hh_next != (unsigned long )((void *)0)) {
                  while (1) {
                    caller = (callgrind_caller_t *)((void *)((char *)caller->hh.hh_next - ((udata->callers)->hh.tbl)->hho));
                    break;
                  }
                } else {
                  caller = (callgrind_caller_t *)((void *)0);
                }
              }
              break;
            }
          }
          break;
        }
        break;
      }
      break;
    }
    if (! caller) {
      tmp___1 = calloc((size_t )1, sizeof(callgrind_caller_t ));
      caller = (callgrind_caller_t *)tmp___1;
      strcpy((char * __restrict  )(caller->loc_str), (char const   * __restrict  )(udata->self_str[i]));
      memcpy((void * __restrict  )(& caller->loc), (void const   * __restrict  )(& udata->self[i]),
             sizeof(trace_loc_t ));
      while (1) {
        tmp___2 = strlen((char const   *)(caller->loc_str));
        _uthash_hastr_keylen = (unsigned int )tmp___2;
        while (1) {
          while (1) {
            while (1) {
              _hj_key___0 = (unsigned char const   *)(& caller->loc_str[0]);
              _ha_hashv = 4276993775U;
              _hj_j___0 = 2654435769U;
              _hj_i___0 = _hj_j___0;
              _hj_k___0 = _uthash_hastr_keylen;
              while (_hj_k___0 >= 12U) {
                _hj_i___0 += (((unsigned int )*(_hj_key___0 + 0) + ((unsigned int )*(_hj_key___0 + 1) << 8)) + ((unsigned int )*(_hj_key___0 + 2) << 16)) + ((unsigned int )*(_hj_key___0 + 3) << 24);
                _hj_j___0 += (((unsigned int )*(_hj_key___0 + 4) + ((unsigned int )*(_hj_key___0 + 5) << 8)) + ((unsigned int )*(_hj_key___0 + 6) << 16)) + ((unsigned int )*(_hj_key___0 + 7) << 24);
                _ha_hashv += (((unsigned int )*(_hj_key___0 + 8) + ((unsigned int )*(_hj_key___0 + 9) << 8)) + ((unsigned int )*(_hj_key___0 + 10) << 16)) + ((unsigned int )*(_hj_key___0 + 11) << 24);
                while (1) {
                  _hj_i___0 -= _hj_j___0;
                  _hj_i___0 -= _ha_hashv;
                  _hj_i___0 ^= _ha_hashv >> 13;
                  _hj_j___0 -= _ha_hashv;
                  _hj_j___0 -= _hj_i___0;
                  _hj_j___0 ^= _hj_i___0 << 8;
                  _ha_hashv -= _hj_i___0;
                  _ha_hashv -= _hj_j___0;
                  _ha_hashv ^= _hj_j___0 >> 13;
                  _hj_i___0 -= _hj_j___0;
                  _hj_i___0 -= _ha_hashv;
                  _hj_i___0 ^= _ha_hashv >> 12;
                  _hj_j___0 -= _ha_hashv;
                  _hj_j___0 -= _hj_i___0;
                  _hj_j___0 ^= _hj_i___0 << 16;
                  _ha_hashv -= _hj_i___0;
                  _ha_hashv -= _hj_j___0;
                  _ha_hashv ^= _hj_j___0 >> 5;
                  _hj_i___0 -= _hj_j___0;
                  _hj_i___0 -= _ha_hashv;
                  _hj_i___0 ^= _ha_hashv >> 3;
                  _hj_j___0 -= _ha_hashv;
                  _hj_j___0 -= _hj_i___0;
                  _hj_j___0 ^= _hj_i___0 << 10;
                  _ha_hashv -= _hj_i___0;
                  _ha_hashv -= _hj_j___0;
                  _ha_hashv ^= _hj_j___0 >> 15;
                  break;
                }
                _hj_key___0 += 12;
                _hj_k___0 -= 12U;
              }
              _ha_hashv += _uthash_hastr_keylen;
              switch (_hj_k___0) {
              case 11U: 
              _ha_hashv += (unsigned int )*(_hj_key___0 + 10) << 24;
              case 10U: 
              _ha_hashv += (unsigned int )*(_hj_key___0 + 9) << 16;
              case 9U: 
              _ha_hashv += (unsigned int )*(_hj_key___0 + 8) << 8;
              case 8U: 
              _hj_j___0 += (unsigned int )*(_hj_key___0 + 7) << 24;
              case 7U: 
              _hj_j___0 += (unsigned int )*(_hj_key___0 + 6) << 16;
              case 6U: 
              _hj_j___0 += (unsigned int )*(_hj_key___0 + 5) << 8;
              case 5U: 
              _hj_j___0 += (unsigned int )*(_hj_key___0 + 4);
              case 4U: 
              _hj_i___0 += (unsigned int )*(_hj_key___0 + 3) << 24;
              case 3U: 
              _hj_i___0 += (unsigned int )*(_hj_key___0 + 2) << 16;
              case 2U: 
              _hj_i___0 += (unsigned int )*(_hj_key___0 + 1) << 8;
              case 1U: 
              _hj_i___0 += (unsigned int )*(_hj_key___0 + 0);
              }
              while (1) {
                _hj_i___0 -= _hj_j___0;
                _hj_i___0 -= _ha_hashv;
                _hj_i___0 ^= _ha_hashv >> 13;
                _hj_j___0 -= _ha_hashv;
                _hj_j___0 -= _hj_i___0;
                _hj_j___0 ^= _hj_i___0 << 8;
                _ha_hashv -= _hj_i___0;
                _ha_hashv -= _hj_j___0;
                _ha_hashv ^= _hj_j___0 >> 13;
                _hj_i___0 -= _hj_j___0;
                _hj_i___0 -= _ha_hashv;
                _hj_i___0 ^= _ha_hashv >> 12;
                _hj_j___0 -= _ha_hashv;
                _hj_j___0 -= _hj_i___0;
                _hj_j___0 ^= _hj_i___0 << 16;
                _ha_hashv -= _hj_i___0;
                _ha_hashv -= _hj_j___0;
                _ha_hashv ^= _hj_j___0 >> 5;
                _hj_i___0 -= _hj_j___0;
                _hj_i___0 -= _ha_hashv;
                _hj_i___0 ^= _ha_hashv >> 3;
                _hj_j___0 -= _ha_hashv;
                _hj_j___0 -= _hj_i___0;
                _hj_j___0 ^= _hj_i___0 << 10;
                _ha_hashv -= _hj_i___0;
                _ha_hashv -= _hj_j___0;
                _ha_hashv ^= _hj_j___0 >> 15;
                break;
              }
              break;
            }
            break;
          }
          while (1) {
            caller->hh.hashv = _ha_hashv;
            caller->hh.key = (void *)(& caller->loc_str[0]);
            caller->hh.keylen = _uthash_hastr_keylen;
            if (! udata->callers) {
              caller->hh.next = (void *)0;
              caller->hh.prev = (void *)0;
              while (1) {
                tmp___3 = malloc(sizeof(UT_hash_table ));
                caller->hh.tbl = (UT_hash_table *)tmp___3;
                if (! caller->hh.tbl) {
                  exit(-1);
                } else {
                  memset((void *)caller->hh.tbl, '\000', sizeof(UT_hash_table ));
                  (caller->hh.tbl)->tail = & caller->hh;
                  (caller->hh.tbl)->num_buckets = 32U;
                  (caller->hh.tbl)->log2_num_buckets = 5U;
                  (caller->hh.tbl)->hho = (char *)(& caller->hh) - (char *)caller;
                  tmp___4 = malloc(32UL * sizeof(struct UT_hash_bucket ));
                  (caller->hh.tbl)->buckets = (UT_hash_bucket *)tmp___4;
                  (caller->hh.tbl)->signature = 2685476833U;
                  if (! (caller->hh.tbl)->buckets) {
                    exit(-1);
                    free((void *)caller->hh.tbl);
                  } else {
                    memset((void *)(caller->hh.tbl)->buckets, '\000', 32UL * sizeof(struct UT_hash_bucket ));
                  }
                }
                break;
              }
              udata->callers = caller;
            } else {
              caller->hh.tbl = (udata->callers)->hh.tbl;
              while (1) {
                caller->hh.next = (void *)0;
                caller->hh.prev = (void *)((char *)((udata->callers)->hh.tbl)->tail - ((udata->callers)->hh.tbl)->hho);
                (((udata->callers)->hh.tbl)->tail)->next = (void *)caller;
                ((udata->callers)->hh.tbl)->tail = & caller->hh;
                break;
              }
            }
            while (1) {
              (((udata->callers)->hh.tbl)->num_items) ++;
              while (1) {
                _ha_bkt = _ha_hashv & (((udata->callers)->hh.tbl)->num_buckets - 1U);
                break;
              }
              while (1) {
                _ha_head = ((udata->callers)->hh.tbl)->buckets + _ha_bkt;
                (_ha_head->count) ++;
                caller->hh.hh_next = _ha_head->hh_head;
                caller->hh.hh_prev = (struct UT_hash_handle *)((void *)0);
                if ((unsigned long )_ha_head->hh_head != (unsigned long )((void *)0)) {
                  (_ha_head->hh_head)->hh_prev = & caller->hh;
                }
                _ha_head->hh_head = & caller->hh;
                if (_ha_head->count >= (_ha_head->expand_mult + 1U) * 10U) {
                  if (! (caller->hh.tbl)->noexpand) {
                    while (1) {
                      tmp___5 = malloc((2UL * (unsigned long )(caller->hh.tbl)->num_buckets) * sizeof(struct UT_hash_bucket ));
                      _he_new_buckets = (UT_hash_bucket *)tmp___5;
                      if (! _he_new_buckets) {
                        exit(-1);
                      } else {
                        memset((void *)_he_new_buckets, '\000', (2UL * (unsigned long )(caller->hh.tbl)->num_buckets) * sizeof(struct UT_hash_bucket ));
                        if (((caller->hh.tbl)->num_items & ((caller->hh.tbl)->num_buckets * 2U - 1U)) != 0U) {
                          tmp___6 = 1U;
                        } else {
                          tmp___6 = 0U;
                        }
                        (caller->hh.tbl)->ideal_chain_maxlen = ((caller->hh.tbl)->num_items >> ((caller->hh.tbl)->log2_num_buckets + 1U)) + tmp___6;
                        (caller->hh.tbl)->nonideal_items = 0U;
                        _he_bkt_i = 0U;
                        while (_he_bkt_i < (caller->hh.tbl)->num_buckets) {
                          _he_thh = ((caller->hh.tbl)->buckets + _he_bkt_i)->hh_head;
                          while ((unsigned long )_he_thh != (unsigned long )((void *)0)) {
                            _he_hh_nxt = _he_thh->hh_next;
                            while (1) {
                              _he_bkt = _he_thh->hashv & ((caller->hh.tbl)->num_buckets * 2U - 1U);
                              break;
                            }
                            _he_newbkt = _he_new_buckets + _he_bkt;
                            (_he_newbkt->count) ++;
                            if (_he_newbkt->count > (caller->hh.tbl)->ideal_chain_maxlen) {
                              ((caller->hh.tbl)->nonideal_items) ++;
                              _he_newbkt->expand_mult = _he_newbkt->count / (caller->hh.tbl)->ideal_chain_maxlen;
                            }
                            _he_thh->hh_prev = (struct UT_hash_handle *)((void *)0);
                            _he_thh->hh_next = _he_newbkt->hh_head;
                            if ((unsigned long )_he_newbkt->hh_head != (unsigned long )((void *)0)) {
                              (_he_newbkt->hh_head)->hh_prev = _he_thh;
                            }
                            _he_newbkt->hh_head = _he_thh;
                            _he_thh = _he_hh_nxt;
                          }
                          _he_bkt_i ++;
                        }
                        free((void *)(caller->hh.tbl)->buckets);
                        (caller->hh.tbl)->num_buckets *= 2U;
                        ((caller->hh.tbl)->log2_num_buckets) ++;
                        (caller->hh.tbl)->buckets = _he_new_buckets;
                        if ((caller->hh.tbl)->nonideal_items > (caller->hh.tbl)->num_items >> 1) {
                          ((caller->hh.tbl)->ineff_expands) ++;
                        } else {
                          (caller->hh.tbl)->ineff_expands = 0U;
                        }
                        if ((caller->hh.tbl)->ineff_expands > 1U) {
                          (caller->hh.tbl)->noexpand = 1U;
                        }
                      }
                      break;
                    }
                  }
                }
                break;
              }
              break;
            }
            break;
          }
          break;
        }
        break;
      }
    }
    if (i == 0) {
      (caller->exclusive) ++;
    }
    if (prev_caller) {
      while (1) {
        tmp___7 = strlen((char const   *)(udata->self_str[i]));
        _uthash_hfstr_keylen___0 = (unsigned int )tmp___7;
        while (1) {
          while (1) {
            while (1) {
              _hj_key___1 = (unsigned char const   *)(udata->self_str[i]);
              _hf_hashv___0 = 4276993775U;
              _hj_j___1 = 2654435769U;
              _hj_i___1 = _hj_j___1;
              _hj_k___1 = _uthash_hfstr_keylen___0;
              while (_hj_k___1 >= 12U) {
                _hj_i___1 += (((unsigned int )*(_hj_key___1 + 0) + ((unsigned int )*(_hj_key___1 + 1) << 8)) + ((unsigned int )*(_hj_key___1 + 2) << 16)) + ((unsigned int )*(_hj_key___1 + 3) << 24);
                _hj_j___1 += (((unsigned int )*(_hj_key___1 + 4) + ((unsigned int )*(_hj_key___1 + 5) << 8)) + ((unsigned int )*(_hj_key___1 + 6) << 16)) + ((unsigned int )*(_hj_key___1 + 7) << 24);
                _hf_hashv___0 += (((unsigned int )*(_hj_key___1 + 8) + ((unsigned int )*(_hj_key___1 + 9) << 8)) + ((unsigned int )*(_hj_key___1 + 10) << 16)) + ((unsigned int )*(_hj_key___1 + 11) << 24);
                while (1) {
                  _hj_i___1 -= _hj_j___1;
                  _hj_i___1 -= _hf_hashv___0;
                  _hj_i___1 ^= _hf_hashv___0 >> 13;
                  _hj_j___1 -= _hf_hashv___0;
                  _hj_j___1 -= _hj_i___1;
                  _hj_j___1 ^= _hj_i___1 << 8;
                  _hf_hashv___0 -= _hj_i___1;
                  _hf_hashv___0 -= _hj_j___1;
                  _hf_hashv___0 ^= _hj_j___1 >> 13;
                  _hj_i___1 -= _hj_j___1;
                  _hj_i___1 -= _hf_hashv___0;
                  _hj_i___1 ^= _hf_hashv___0 >> 12;
                  _hj_j___1 -= _hf_hashv___0;
                  _hj_j___1 -= _hj_i___1;
                  _hj_j___1 ^= _hj_i___1 << 16;
                  _hf_hashv___0 -= _hj_i___1;
                  _hf_hashv___0 -= _hj_j___1;
                  _hf_hashv___0 ^= _hj_j___1 >> 5;
                  _hj_i___1 -= _hj_j___1;
                  _hj_i___1 -= _hf_hashv___0;
                  _hj_i___1 ^= _hf_hashv___0 >> 3;
                  _hj_j___1 -= _hf_hashv___0;
                  _hj_j___1 -= _hj_i___1;
                  _hj_j___1 ^= _hj_i___1 << 10;
                  _hf_hashv___0 -= _hj_i___1;
                  _hf_hashv___0 -= _hj_j___1;
                  _hf_hashv___0 ^= _hj_j___1 >> 15;
                  break;
                }
                _hj_key___1 += 12;
                _hj_k___1 -= 12U;
              }
              _hf_hashv___0 += _uthash_hfstr_keylen___0;
              switch (_hj_k___1) {
              case 11U: 
              _hf_hashv___0 += (unsigned int )*(_hj_key___1 + 10) << 24;
              case 10U: 
              _hf_hashv___0 += (unsigned int )*(_hj_key___1 + 9) << 16;
              case 9U: 
              _hf_hashv___0 += (unsigned int )*(_hj_key___1 + 8) << 8;
              case 8U: 
              _hj_j___1 += (unsigned int )*(_hj_key___1 + 7) << 24;
              case 7U: 
              _hj_j___1 += (unsigned int )*(_hj_key___1 + 6) << 16;
              case 6U: 
              _hj_j___1 += (unsigned int )*(_hj_key___1 + 5) << 8;
              case 5U: 
              _hj_j___1 += (unsigned int )*(_hj_key___1 + 4);
              case 4U: 
              _hj_i___1 += (unsigned int )*(_hj_key___1 + 3) << 24;
              case 3U: 
              _hj_i___1 += (unsigned int )*(_hj_key___1 + 2) << 16;
              case 2U: 
              _hj_i___1 += (unsigned int )*(_hj_key___1 + 1) << 8;
              case 1U: 
              _hj_i___1 += (unsigned int )*(_hj_key___1 + 0);
              }
              while (1) {
                _hj_i___1 -= _hj_j___1;
                _hj_i___1 -= _hf_hashv___0;
                _hj_i___1 ^= _hf_hashv___0 >> 13;
                _hj_j___1 -= _hf_hashv___0;
                _hj_j___1 -= _hj_i___1;
                _hj_j___1 ^= _hj_i___1 << 8;
                _hf_hashv___0 -= _hj_i___1;
                _hf_hashv___0 -= _hj_j___1;
                _hf_hashv___0 ^= _hj_j___1 >> 13;
                _hj_i___1 -= _hj_j___1;
                _hj_i___1 -= _hf_hashv___0;
                _hj_i___1 ^= _hf_hashv___0 >> 12;
                _hj_j___1 -= _hf_hashv___0;
                _hj_j___1 -= _hj_i___1;
                _hj_j___1 ^= _hj_i___1 << 16;
                _hf_hashv___0 -= _hj_i___1;
                _hf_hashv___0 -= _hj_j___1;
                _hf_hashv___0 ^= _hj_j___1 >> 5;
                _hj_i___1 -= _hj_j___1;
                _hj_i___1 -= _hf_hashv___0;
                _hj_i___1 ^= _hf_hashv___0 >> 3;
                _hj_j___1 -= _hf_hashv___0;
                _hj_j___1 -= _hj_i___1;
                _hj_j___1 ^= _hj_i___1 << 10;
                _hf_hashv___0 -= _hj_i___1;
                _hf_hashv___0 -= _hj_j___1;
                _hf_hashv___0 ^= _hj_j___1 >> 15;
                break;
              }
              break;
            }
            break;
          }
          while (1) {
            callee = (callgrind_callee_t *)((void *)0);
            if (prev_caller->callees) {
              while (1) {
                _hf_bkt___0 = _hf_hashv___0 & (((prev_caller->callees)->hh.tbl)->num_buckets - 1U);
                break;
              }
              while (1) {
                if ((unsigned long )(((prev_caller->callees)->hh.tbl)->buckets + _hf_bkt___0)->hh_head != (unsigned long )((void *)0)) {
                  while (1) {
                    callee = (callgrind_callee_t *)((void *)((char *)(((prev_caller->callees)->hh.tbl)->buckets + _hf_bkt___0)->hh_head - ((prev_caller->callees)->hh.tbl)->hho));
                    break;
                  }
                } else {
                  callee = (callgrind_callee_t *)((void *)0);
                }
                while ((unsigned long )callee != (unsigned long )((void *)0)) {
                  if (callee->hh.hashv == _hf_hashv___0) {
                    if (callee->hh.keylen == _uthash_hfstr_keylen___0) {
                      tmp___8 = memcmp((void const   *)callee->hh.key, (void const   *)(udata->self_str[i]),
                                       (size_t )_uthash_hfstr_keylen___0);
                      if (tmp___8 == 0) {
                        break;
                      }
                    }
                  }
                  if ((unsigned long )callee->hh.hh_next != (unsigned long )((void *)0)) {
                    while (1) {
                      callee = (callgrind_callee_t *)((void *)((char *)callee->hh.hh_next - ((prev_caller->callees)->hh.tbl)->hho));
                      break;
                    }
                  } else {
                    callee = (callgrind_callee_t *)((void *)0);
                  }
                }
                break;
              }
            }
            break;
          }
          break;
        }
        break;
      }
      if (! callee) {
        tmp___9 = calloc((size_t )1, sizeof(callgrind_callee_t ));
        callee = (callgrind_callee_t *)tmp___9;
        strcpy((char * __restrict  )(callee->loc_str), (char const   * __restrict  )(udata->self_str[i]));
        memcpy((void * __restrict  )(& callee->loc), (void const   * __restrict  )(& udata->self[i]),
               sizeof(trace_loc_t ));
        while (1) {
          tmp___10 = strlen((char const   *)(callee->loc_str));
          _uthash_hastr_keylen___0 = (unsigned int )tmp___10;
          while (1) {
            while (1) {
              while (1) {
                _hj_key___2 = (unsigned char const   *)(& callee->loc_str[0]);
                _ha_hashv___0 = 4276993775U;
                _hj_j___2 = 2654435769U;
                _hj_i___2 = _hj_j___2;
                _hj_k___2 = _uthash_hastr_keylen___0;
                while (_hj_k___2 >= 12U) {
                  _hj_i___2 += (((unsigned int )*(_hj_key___2 + 0) + ((unsigned int )*(_hj_key___2 + 1) << 8)) + ((unsigned int )*(_hj_key___2 + 2) << 16)) + ((unsigned int )*(_hj_key___2 + 3) << 24);
                  _hj_j___2 += (((unsigned int )*(_hj_key___2 + 4) + ((unsigned int )*(_hj_key___2 + 5) << 8)) + ((unsigned int )*(_hj_key___2 + 6) << 16)) + ((unsigned int )*(_hj_key___2 + 7) << 24);
                  _ha_hashv___0 += (((unsigned int )*(_hj_key___2 + 8) + ((unsigned int )*(_hj_key___2 + 9) << 8)) + ((unsigned int )*(_hj_key___2 + 10) << 16)) + ((unsigned int )*(_hj_key___2 + 11) << 24);
                  while (1) {
                    _hj_i___2 -= _hj_j___2;
                    _hj_i___2 -= _ha_hashv___0;
                    _hj_i___2 ^= _ha_hashv___0 >> 13;
                    _hj_j___2 -= _ha_hashv___0;
                    _hj_j___2 -= _hj_i___2;
                    _hj_j___2 ^= _hj_i___2 << 8;
                    _ha_hashv___0 -= _hj_i___2;
                    _ha_hashv___0 -= _hj_j___2;
                    _ha_hashv___0 ^= _hj_j___2 >> 13;
                    _hj_i___2 -= _hj_j___2;
                    _hj_i___2 -= _ha_hashv___0;
                    _hj_i___2 ^= _ha_hashv___0 >> 12;
                    _hj_j___2 -= _ha_hashv___0;
                    _hj_j___2 -= _hj_i___2;
                    _hj_j___2 ^= _hj_i___2 << 16;
                    _ha_hashv___0 -= _hj_i___2;
                    _ha_hashv___0 -= _hj_j___2;
                    _ha_hashv___0 ^= _hj_j___2 >> 5;
                    _hj_i___2 -= _hj_j___2;
                    _hj_i___2 -= _ha_hashv___0;
                    _hj_i___2 ^= _ha_hashv___0 >> 3;
                    _hj_j___2 -= _ha_hashv___0;
                    _hj_j___2 -= _hj_i___2;
                    _hj_j___2 ^= _hj_i___2 << 10;
                    _ha_hashv___0 -= _hj_i___2;
                    _ha_hashv___0 -= _hj_j___2;
                    _ha_hashv___0 ^= _hj_j___2 >> 15;
                    break;
                  }
                  _hj_key___2 += 12;
                  _hj_k___2 -= 12U;
                }
                _ha_hashv___0 += _uthash_hastr_keylen___0;
                switch (_hj_k___2) {
                case 11U: 
                _ha_hashv___0 += (unsigned int )*(_hj_key___2 + 10) << 24;
                case 10U: 
                _ha_hashv___0 += (unsigned int )*(_hj_key___2 + 9) << 16;
                case 9U: 
                _ha_hashv___0 += (unsigned int )*(_hj_key___2 + 8) << 8;
                case 8U: 
                _hj_j___2 += (unsigned int )*(_hj_key___2 + 7) << 24;
                case 7U: 
                _hj_j___2 += (unsigned int )*(_hj_key___2 + 6) << 16;
                case 6U: 
                _hj_j___2 += (unsigned int )*(_hj_key___2 + 5) << 8;
                case 5U: 
                _hj_j___2 += (unsigned int )*(_hj_key___2 + 4);
                case 4U: 
                _hj_i___2 += (unsigned int )*(_hj_key___2 + 3) << 24;
                case 3U: 
                _hj_i___2 += (unsigned int )*(_hj_key___2 + 2) << 16;
                case 2U: 
                _hj_i___2 += (unsigned int )*(_hj_key___2 + 1) << 8;
                case 1U: 
                _hj_i___2 += (unsigned int )*(_hj_key___2 + 0);
                }
                while (1) {
                  _hj_i___2 -= _hj_j___2;
                  _hj_i___2 -= _ha_hashv___0;
                  _hj_i___2 ^= _ha_hashv___0 >> 13;
                  _hj_j___2 -= _ha_hashv___0;
                  _hj_j___2 -= _hj_i___2;
                  _hj_j___2 ^= _hj_i___2 << 8;
                  _ha_hashv___0 -= _hj_i___2;
                  _ha_hashv___0 -= _hj_j___2;
                  _ha_hashv___0 ^= _hj_j___2 >> 13;
                  _hj_i___2 -= _hj_j___2;
                  _hj_i___2 -= _ha_hashv___0;
                  _hj_i___2 ^= _ha_hashv___0 >> 12;
                  _hj_j___2 -= _ha_hashv___0;
                  _hj_j___2 -= _hj_i___2;
                  _hj_j___2 ^= _hj_i___2 << 16;
                  _ha_hashv___0 -= _hj_i___2;
                  _ha_hashv___0 -= _hj_j___2;
                  _ha_hashv___0 ^= _hj_j___2 >> 5;
                  _hj_i___2 -= _hj_j___2;
                  _hj_i___2 -= _ha_hashv___0;
                  _hj_i___2 ^= _ha_hashv___0 >> 3;
                  _hj_j___2 -= _ha_hashv___0;
                  _hj_j___2 -= _hj_i___2;
                  _hj_j___2 ^= _hj_i___2 << 10;
                  _ha_hashv___0 -= _hj_i___2;
                  _ha_hashv___0 -= _hj_j___2;
                  _ha_hashv___0 ^= _hj_j___2 >> 15;
                  break;
                }
                break;
              }
              break;
            }
            while (1) {
              callee->hh.hashv = _ha_hashv___0;
              callee->hh.key = (void *)(& callee->loc_str[0]);
              callee->hh.keylen = _uthash_hastr_keylen___0;
              if (! prev_caller->callees) {
                callee->hh.next = (void *)0;
                callee->hh.prev = (void *)0;
                while (1) {
                  tmp___11 = malloc(sizeof(UT_hash_table ));
                  callee->hh.tbl = (UT_hash_table *)tmp___11;
                  if (! callee->hh.tbl) {
                    exit(-1);
                  } else {
                    memset((void *)callee->hh.tbl, '\000', sizeof(UT_hash_table ));
                    (callee->hh.tbl)->tail = & callee->hh;
                    (callee->hh.tbl)->num_buckets = 32U;
                    (callee->hh.tbl)->log2_num_buckets = 5U;
                    (callee->hh.tbl)->hho = (char *)(& callee->hh) - (char *)callee;
                    tmp___12 = malloc(32UL * sizeof(struct UT_hash_bucket ));
                    (callee->hh.tbl)->buckets = (UT_hash_bucket *)tmp___12;
                    (callee->hh.tbl)->signature = 2685476833U;
                    if (! (callee->hh.tbl)->buckets) {
                      exit(-1);
                      free((void *)callee->hh.tbl);
                    } else {
                      memset((void *)(callee->hh.tbl)->buckets, '\000', 32UL * sizeof(struct UT_hash_bucket ));
                    }
                  }
                  break;
                }
                prev_caller->callees = callee;
              } else {
                callee->hh.tbl = (prev_caller->callees)->hh.tbl;
                while (1) {
                  callee->hh.next = (void *)0;
                  callee->hh.prev = (void *)((char *)((prev_caller->callees)->hh.tbl)->tail - ((prev_caller->callees)->hh.tbl)->hho);
                  (((prev_caller->callees)->hh.tbl)->tail)->next = (void *)callee;
                  ((prev_caller->callees)->hh.tbl)->tail = & callee->hh;
                  break;
                }
              }
              while (1) {
                (((prev_caller->callees)->hh.tbl)->num_items) ++;
                while (1) {
                  _ha_bkt___0 = _ha_hashv___0 & (((prev_caller->callees)->hh.tbl)->num_buckets - 1U);
                  break;
                }
                while (1) {
                  _ha_head___0 = ((prev_caller->callees)->hh.tbl)->buckets + _ha_bkt___0;
                  (_ha_head___0->count) ++;
                  callee->hh.hh_next = _ha_head___0->hh_head;
                  callee->hh.hh_prev = (struct UT_hash_handle *)((void *)0);
                  if ((unsigned long )_ha_head___0->hh_head != (unsigned long )((void *)0)) {
                    (_ha_head___0->hh_head)->hh_prev = & callee->hh;
                  }
                  _ha_head___0->hh_head = & callee->hh;
                  if (_ha_head___0->count >= (_ha_head___0->expand_mult + 1U) * 10U) {
                    if (! (callee->hh.tbl)->noexpand) {
                      while (1) {
                        tmp___13 = malloc((2UL * (unsigned long )(callee->hh.tbl)->num_buckets) * sizeof(struct UT_hash_bucket ));
                        _he_new_buckets___0 = (UT_hash_bucket *)tmp___13;
                        if (! _he_new_buckets___0) {
                          exit(-1);
                        } else {
                          memset((void *)_he_new_buckets___0, '\000', (2UL * (unsigned long )(callee->hh.tbl)->num_buckets) * sizeof(struct UT_hash_bucket ));
                          if (((callee->hh.tbl)->num_items & ((callee->hh.tbl)->num_buckets * 2U - 1U)) != 0U) {
                            tmp___14 = 1U;
                          } else {
                            tmp___14 = 0U;
                          }
                          (callee->hh.tbl)->ideal_chain_maxlen = ((callee->hh.tbl)->num_items >> ((callee->hh.tbl)->log2_num_buckets + 1U)) + tmp___14;
                          (callee->hh.tbl)->nonideal_items = 0U;
                          _he_bkt_i___0 = 0U;
                          while (_he_bkt_i___0 < (callee->hh.tbl)->num_buckets) {
                            _he_thh___0 = ((callee->hh.tbl)->buckets + _he_bkt_i___0)->hh_head;
                            while ((unsigned long )_he_thh___0 != (unsigned long )((void *)0)) {
                              _he_hh_nxt___0 = _he_thh___0->hh_next;
                              while (1) {
                                _he_bkt___0 = _he_thh___0->hashv & ((callee->hh.tbl)->num_buckets * 2U - 1U);
                                break;
                              }
                              _he_newbkt___0 = _he_new_buckets___0 + _he_bkt___0;
                              (_he_newbkt___0->count) ++;
                              if (_he_newbkt___0->count > (callee->hh.tbl)->ideal_chain_maxlen) {
                                ((callee->hh.tbl)->nonideal_items) ++;
                                _he_newbkt___0->expand_mult = _he_newbkt___0->count / (callee->hh.tbl)->ideal_chain_maxlen;
                              }
                              _he_thh___0->hh_prev = (struct UT_hash_handle *)((void *)0);
                              _he_thh___0->hh_next = _he_newbkt___0->hh_head;
                              if ((unsigned long )_he_newbkt___0->hh_head != (unsigned long )((void *)0)) {
                                (_he_newbkt___0->hh_head)->hh_prev = _he_thh___0;
                              }
                              _he_newbkt___0->hh_head = _he_thh___0;
                              _he_thh___0 = _he_hh_nxt___0;
                            }
                            _he_bkt_i___0 ++;
                          }
                          free((void *)(callee->hh.tbl)->buckets);
                          (callee->hh.tbl)->num_buckets *= 2U;
                          ((callee->hh.tbl)->log2_num_buckets) ++;
                          (callee->hh.tbl)->buckets = _he_new_buckets___0;
                          if ((callee->hh.tbl)->nonideal_items > (callee->hh.tbl)->num_items >> 1) {
                            ((callee->hh.tbl)->ineff_expands) ++;
                          } else {
                            (callee->hh.tbl)->ineff_expands = 0U;
                          }
                          if ((callee->hh.tbl)->ineff_expands > 1U) {
                            (callee->hh.tbl)->noexpand = 1U;
                          }
                        }
                        break;
                      }
                    }
                  }
                  break;
                }
                break;
              }
              break;
            }
            break;
          }
          break;
        }
      }
      (callee->inclusive) ++;
      if (i >= udata->prev_len) {
        (callee->count) ++;
      } else {
        tmp___15 = strcmp((char const   *)(udata->self_str[i]), (char const   *)(udata->prev_str[i]));
        if (tmp___15 != 0) {
          (callee->count) ++;
        }
      }
    }
    prev_caller = caller;
    i --;
  }
  return;
}
}
static void callgrind_dump(callgrind_udata_t *udata ) 
{ 
  callgrind_caller_t *caller ;
  callgrind_caller_t *caller_tmp ;
  callgrind_callee_t *callee ;
  callgrind_callee_t *callee_tmp ;
  unsigned int _hs_i ;
  unsigned int _hs_looping ;
  unsigned int _hs_nmerges ;
  unsigned int _hs_insize ;
  unsigned int _hs_psize ;
  unsigned int _hs_qsize ;
  struct UT_hash_handle *_hs_p ;
  struct UT_hash_handle *_hs_q ;
  struct UT_hash_handle *_hs_e ;
  struct UT_hash_handle *_hs_list ;
  struct UT_hash_handle *_hs_tail ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  unsigned int _hs_i___0 ;
  unsigned int _hs_looping___0 ;
  unsigned int _hs_nmerges___0 ;
  unsigned int _hs_insize___0 ;
  unsigned int _hs_psize___0 ;
  unsigned int _hs_qsize___0 ;
  struct UT_hash_handle *_hs_p___0 ;
  struct UT_hash_handle *_hs_q___0 ;
  struct UT_hash_handle *_hs_e___0 ;
  struct UT_hash_handle *_hs_list___0 ;
  struct UT_hash_handle *_hs_tail___0 ;
  int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  char const   *tmp___6 ;

  {
  fprintf((FILE * __restrict  )udata->fout, (char const   * __restrict  )"# callgrind format\n");
  fprintf((FILE * __restrict  )udata->fout, (char const   * __restrict  )"version: 1\n");
  fprintf((FILE * __restrict  )udata->fout, (char const   * __restrict  )"creator: phpspy\n");
  fprintf((FILE * __restrict  )udata->fout, (char const   * __restrict  )"events: Samples\n");
  while (1) {
    if ((unsigned long )udata->callers != (unsigned long )((void *)0)) {
      _hs_insize = 1U;
      _hs_looping = 1U;
      _hs_list = & (udata->callers)->hh;
      while (_hs_looping != 0U) {
        _hs_p = _hs_list;
        _hs_list = (struct UT_hash_handle *)((void *)0);
        _hs_tail = (struct UT_hash_handle *)((void *)0);
        _hs_nmerges = 0U;
        while ((unsigned long )_hs_p != (unsigned long )((void *)0)) {
          _hs_nmerges ++;
          _hs_q = _hs_p;
          _hs_psize = 0U;
          _hs_i = 0U;
          while (_hs_i < _hs_insize) {
            _hs_psize ++;
            if ((unsigned long )_hs_q->next != (unsigned long )((void *)0)) {
              _hs_q = (UT_hash_handle *)((char *)_hs_q->next + ((udata->callers)->hh.tbl)->hho);
            } else {
              _hs_q = (struct UT_hash_handle *)((void *)0);
            }
            if ((unsigned long )_hs_q == (unsigned long )((void *)0)) {
              break;
            }
            _hs_i ++;
          }
          _hs_qsize = _hs_insize;
          while (1) {
            if (! (_hs_psize != 0U)) {
              if (_hs_qsize != 0U) {
                if (! ((unsigned long )_hs_q != (unsigned long )((void *)0))) {
                  break;
                }
              } else {
                break;
              }
            }
            if (_hs_psize == 0U) {
              _hs_e = _hs_q;
              if ((unsigned long )_hs_q->next != (unsigned long )((void *)0)) {
                _hs_q = (UT_hash_handle *)((char *)_hs_q->next + ((udata->callers)->hh.tbl)->hho);
              } else {
                _hs_q = (struct UT_hash_handle *)((void *)0);
              }
              _hs_qsize --;
            } else
            if (_hs_qsize == 0U) {
              goto _L;
            } else
            if ((unsigned long )_hs_q == (unsigned long )((void *)0)) {
              _L: /* CIL Label */ 
              _hs_e = _hs_p;
              if ((unsigned long )_hs_p != (unsigned long )((void *)0)) {
                if ((unsigned long )_hs_p->next != (unsigned long )((void *)0)) {
                  _hs_p = (UT_hash_handle *)((char *)_hs_p->next + ((udata->callers)->hh.tbl)->hho);
                } else {
                  _hs_p = (struct UT_hash_handle *)((void *)0);
                }
              }
              _hs_psize --;
            } else {
              tmp = callgrind_sort_callers((callgrind_caller_t *)((void *)((char *)_hs_p - ((udata->callers)->hh.tbl)->hho)),
                                           (callgrind_caller_t *)((void *)((char *)_hs_q - ((udata->callers)->hh.tbl)->hho)));
              if (tmp <= 0) {
                _hs_e = _hs_p;
                if ((unsigned long )_hs_p != (unsigned long )((void *)0)) {
                  if ((unsigned long )_hs_p->next != (unsigned long )((void *)0)) {
                    _hs_p = (UT_hash_handle *)((char *)_hs_p->next + ((udata->callers)->hh.tbl)->hho);
                  } else {
                    _hs_p = (struct UT_hash_handle *)((void *)0);
                  }
                }
                _hs_psize --;
              } else {
                _hs_e = _hs_q;
                if ((unsigned long )_hs_q->next != (unsigned long )((void *)0)) {
                  _hs_q = (UT_hash_handle *)((char *)_hs_q->next + ((udata->callers)->hh.tbl)->hho);
                } else {
                  _hs_q = (struct UT_hash_handle *)((void *)0);
                }
                _hs_qsize --;
              }
            }
            if ((unsigned long )_hs_tail != (unsigned long )((void *)0)) {
              if ((unsigned long )_hs_e != (unsigned long )((void *)0)) {
                _hs_tail->next = (void *)((char *)_hs_e - ((udata->callers)->hh.tbl)->hho);
              } else {
                _hs_tail->next = (void *)0;
              }
            } else {
              _hs_list = _hs_e;
            }
            if ((unsigned long )_hs_e != (unsigned long )((void *)0)) {
              if ((unsigned long )_hs_tail != (unsigned long )((void *)0)) {
                _hs_e->prev = (void *)((char *)_hs_tail - ((udata->callers)->hh.tbl)->hho);
              } else {
                _hs_e->prev = (void *)0;
              }
            }
            _hs_tail = _hs_e;
          }
          _hs_p = _hs_q;
        }
        if ((unsigned long )_hs_tail != (unsigned long )((void *)0)) {
          _hs_tail->next = (void *)0;
        }
        if (_hs_nmerges <= 1U) {
          _hs_looping = 0U;
          ((udata->callers)->hh.tbl)->tail = _hs_tail;
          while (1) {
            udata->callers = (callgrind_caller_t *)((void *)((char *)_hs_list - ((udata->callers)->hh.tbl)->hho));
            break;
          }
        }
        _hs_insize *= 2U;
      }
    }
    break;
  }
  caller = udata->callers;
  if ((unsigned long )udata->callers != (unsigned long )((void *)0)) {
    tmp___0 = (udata->callers)->hh.next;
  } else {
    tmp___0 = (void *)0;
  }
  caller_tmp = (callgrind_caller_t *)tmp___0;
  while ((unsigned long )caller != (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )udata->fout, (char const   * __restrict  )"\n");
    fprintf((FILE * __restrict  )udata->fout, (char const   * __restrict  )"fl=%.*s\n",
            (int )caller->loc.file_len, caller->loc.file);
    if (caller->loc.class_len > 0UL) {
      tmp___2 = "::";
    } else {
      tmp___2 = "";
    }
    fprintf((FILE * __restrict  )udata->fout, (char const   * __restrict  )"fn=%.*s%s%.*s\n",
            (int )caller->loc.class_len, caller->loc.class, tmp___2, (int )caller->loc.func_len,
            caller->loc.func);
    fprintf((FILE * __restrict  )udata->fout, (char const   * __restrict  )"%d %ld\n",
            caller->loc.lineno, caller->exclusive);
    while (1) {
      if ((unsigned long )caller->callees != (unsigned long )((void *)0)) {
        _hs_insize___0 = 1U;
        _hs_looping___0 = 1U;
        _hs_list___0 = & (caller->callees)->hh;
        while (_hs_looping___0 != 0U) {
          _hs_p___0 = _hs_list___0;
          _hs_list___0 = (struct UT_hash_handle *)((void *)0);
          _hs_tail___0 = (struct UT_hash_handle *)((void *)0);
          _hs_nmerges___0 = 0U;
          while ((unsigned long )_hs_p___0 != (unsigned long )((void *)0)) {
            _hs_nmerges___0 ++;
            _hs_q___0 = _hs_p___0;
            _hs_psize___0 = 0U;
            _hs_i___0 = 0U;
            while (_hs_i___0 < _hs_insize___0) {
              _hs_psize___0 ++;
              if ((unsigned long )_hs_q___0->next != (unsigned long )((void *)0)) {
                _hs_q___0 = (UT_hash_handle *)((char *)_hs_q___0->next + ((caller->callees)->hh.tbl)->hho);
              } else {
                _hs_q___0 = (struct UT_hash_handle *)((void *)0);
              }
              if ((unsigned long )_hs_q___0 == (unsigned long )((void *)0)) {
                break;
              }
              _hs_i___0 ++;
            }
            _hs_qsize___0 = _hs_insize___0;
            while (1) {
              if (! (_hs_psize___0 != 0U)) {
                if (_hs_qsize___0 != 0U) {
                  if (! ((unsigned long )_hs_q___0 != (unsigned long )((void *)0))) {
                    break;
                  }
                } else {
                  break;
                }
              }
              if (_hs_psize___0 == 0U) {
                _hs_e___0 = _hs_q___0;
                if ((unsigned long )_hs_q___0->next != (unsigned long )((void *)0)) {
                  _hs_q___0 = (UT_hash_handle *)((char *)_hs_q___0->next + ((caller->callees)->hh.tbl)->hho);
                } else {
                  _hs_q___0 = (struct UT_hash_handle *)((void *)0);
                }
                _hs_qsize___0 --;
              } else
              if (_hs_qsize___0 == 0U) {
                goto _L___0;
              } else
              if ((unsigned long )_hs_q___0 == (unsigned long )((void *)0)) {
                _L___0: /* CIL Label */ 
                _hs_e___0 = _hs_p___0;
                if ((unsigned long )_hs_p___0 != (unsigned long )((void *)0)) {
                  if ((unsigned long )_hs_p___0->next != (unsigned long )((void *)0)) {
                    _hs_p___0 = (UT_hash_handle *)((char *)_hs_p___0->next + ((caller->callees)->hh.tbl)->hho);
                  } else {
                    _hs_p___0 = (struct UT_hash_handle *)((void *)0);
                  }
                }
                _hs_psize___0 --;
              } else {
                tmp___3 = callgrind_sort_callees((callgrind_callee_t *)((void *)((char *)_hs_p___0 - ((caller->callees)->hh.tbl)->hho)),
                                                 (callgrind_callee_t *)((void *)((char *)_hs_q___0 - ((caller->callees)->hh.tbl)->hho)));
                if (tmp___3 <= 0) {
                  _hs_e___0 = _hs_p___0;
                  if ((unsigned long )_hs_p___0 != (unsigned long )((void *)0)) {
                    if ((unsigned long )_hs_p___0->next != (unsigned long )((void *)0)) {
                      _hs_p___0 = (UT_hash_handle *)((char *)_hs_p___0->next + ((caller->callees)->hh.tbl)->hho);
                    } else {
                      _hs_p___0 = (struct UT_hash_handle *)((void *)0);
                    }
                  }
                  _hs_psize___0 --;
                } else {
                  _hs_e___0 = _hs_q___0;
                  if ((unsigned long )_hs_q___0->next != (unsigned long )((void *)0)) {
                    _hs_q___0 = (UT_hash_handle *)((char *)_hs_q___0->next + ((caller->callees)->hh.tbl)->hho);
                  } else {
                    _hs_q___0 = (struct UT_hash_handle *)((void *)0);
                  }
                  _hs_qsize___0 --;
                }
              }
              if ((unsigned long )_hs_tail___0 != (unsigned long )((void *)0)) {
                if ((unsigned long )_hs_e___0 != (unsigned long )((void *)0)) {
                  _hs_tail___0->next = (void *)((char *)_hs_e___0 - ((caller->callees)->hh.tbl)->hho);
                } else {
                  _hs_tail___0->next = (void *)0;
                }
              } else {
                _hs_list___0 = _hs_e___0;
              }
              if ((unsigned long )_hs_e___0 != (unsigned long )((void *)0)) {
                if ((unsigned long )_hs_tail___0 != (unsigned long )((void *)0)) {
                  _hs_e___0->prev = (void *)((char *)_hs_tail___0 - ((caller->callees)->hh.tbl)->hho);
                } else {
                  _hs_e___0->prev = (void *)0;
                }
              }
              _hs_tail___0 = _hs_e___0;
            }
            _hs_p___0 = _hs_q___0;
          }
          if ((unsigned long )_hs_tail___0 != (unsigned long )((void *)0)) {
            _hs_tail___0->next = (void *)0;
          }
          if (_hs_nmerges___0 <= 1U) {
            _hs_looping___0 = 0U;
            ((caller->callees)->hh.tbl)->tail = _hs_tail___0;
            while (1) {
              caller->callees = (callgrind_callee_t *)((void *)((char *)_hs_list___0 - ((caller->callees)->hh.tbl)->hho));
              break;
            }
          }
          _hs_insize___0 *= 2U;
        }
      }
      break;
    }
    callee = caller->callees;
    if ((unsigned long )caller->callees != (unsigned long )((void *)0)) {
      tmp___4 = (caller->callees)->hh.next;
    } else {
      tmp___4 = (void *)0;
    }
    callee_tmp = (callgrind_callee_t *)tmp___4;
    while ((unsigned long )callee != (unsigned long )((void *)0)) {
      fprintf((FILE * __restrict  )udata->fout, (char const   * __restrict  )"\n");
      fprintf((FILE * __restrict  )udata->fout, (char const   * __restrict  )"cfl=%.*s\n",
              (int )callee->loc.file_len, callee->loc.file);
      if (callee->loc.class_len > 0UL) {
        tmp___6 = "::";
      } else {
        tmp___6 = "";
      }
      fprintf((FILE * __restrict  )udata->fout, (char const   * __restrict  )"cfn=%.*s%s%.*s\n",
              (int )callee->loc.class_len, callee->loc.class, tmp___6, (int )callee->loc.func_len,
              callee->loc.func);
      fprintf((FILE * __restrict  )udata->fout, (char const   * __restrict  )"calls=%ld %d\n",
              callee->count, callee->loc.lineno);
      fprintf((FILE * __restrict  )udata->fout, (char const   * __restrict  )"%d %ld\n",
              caller->loc.lineno, callee->inclusive);
      callee = callee_tmp;
      if ((unsigned long )callee_tmp != (unsigned long )((void *)0)) {
        tmp___5 = callee_tmp->hh.next;
      } else {
        tmp___5 = (void *)0;
      }
      callee_tmp = (callgrind_callee_t *)tmp___5;
    }
    caller = caller_tmp;
    if ((unsigned long )caller_tmp != (unsigned long )((void *)0)) {
      tmp___1 = caller_tmp->hh.next;
    } else {
      tmp___1 = (void *)0;
    }
    caller_tmp = (callgrind_caller_t *)tmp___1;
  }
  return;
}
}
static void callgrind_free(callgrind_udata_t *udata ) 
{ 
  callgrind_caller_t *caller ;
  callgrind_caller_t *caller_tmp ;
  callgrind_callee_t *callee ;
  callgrind_callee_t *callee_tmp ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  struct UT_hash_handle *_hd_hh_del ;
  unsigned int _hd_bkt ;
  UT_hash_bucket *_hd_head ;
  struct UT_hash_handle *_hd_hh_del___0 ;
  unsigned int _hd_bkt___0 ;
  UT_hash_bucket *_hd_head___0 ;

  {
  caller = udata->callers;
  if ((unsigned long )udata->callers != (unsigned long )((void *)0)) {
    tmp = (udata->callers)->hh.next;
  } else {
    tmp = (void *)0;
  }
  caller_tmp = (callgrind_caller_t *)tmp;
  while ((unsigned long )caller != (unsigned long )((void *)0)) {
    callee = caller->callees;
    if ((unsigned long )caller->callees != (unsigned long )((void *)0)) {
      tmp___1 = (caller->callees)->hh.next;
    } else {
      tmp___1 = (void *)0;
    }
    callee_tmp = (callgrind_callee_t *)tmp___1;
    while ((unsigned long )callee != (unsigned long )((void *)0)) {
      while (1) {
        _hd_hh_del = & callee->hh;
        if ((unsigned long )_hd_hh_del->prev == (unsigned long )((void *)0)) {
          if ((unsigned long )_hd_hh_del->next == (unsigned long )((void *)0)) {
            free((void *)((caller->callees)->hh.tbl)->buckets);
            free((void *)(caller->callees)->hh.tbl);
            caller->callees = (callgrind_callee_t *)((void *)0);
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          if ((unsigned long )_hd_hh_del == (unsigned long )((caller->callees)->hh.tbl)->tail) {
            ((caller->callees)->hh.tbl)->tail = (UT_hash_handle *)((char *)_hd_hh_del->prev + ((caller->callees)->hh.tbl)->hho);
          }
          if ((unsigned long )_hd_hh_del->prev != (unsigned long )((void *)0)) {
            ((UT_hash_handle *)((char *)_hd_hh_del->prev + ((caller->callees)->hh.tbl)->hho))->next = _hd_hh_del->next;
          } else {
            while (1) {
              caller->callees = (callgrind_callee_t *)_hd_hh_del->next;
              break;
            }
          }
          if ((unsigned long )_hd_hh_del->next != (unsigned long )((void *)0)) {
            ((UT_hash_handle *)((char *)_hd_hh_del->next + ((caller->callees)->hh.tbl)->hho))->prev = _hd_hh_del->prev;
          }
          while (1) {
            _hd_bkt = _hd_hh_del->hashv & (((caller->callees)->hh.tbl)->num_buckets - 1U);
            break;
          }
          while (1) {
            _hd_head = ((caller->callees)->hh.tbl)->buckets + _hd_bkt;
            (_hd_head->count) --;
            if ((unsigned long )_hd_head->hh_head == (unsigned long )_hd_hh_del) {
              _hd_head->hh_head = _hd_hh_del->hh_next;
            }
            if (_hd_hh_del->hh_prev) {
              (_hd_hh_del->hh_prev)->hh_next = _hd_hh_del->hh_next;
            }
            if (_hd_hh_del->hh_next) {
              (_hd_hh_del->hh_next)->hh_prev = _hd_hh_del->hh_prev;
            }
            break;
          }
          (((caller->callees)->hh.tbl)->num_items) --;
        }
        break;
      }
      free((void *)callee);
      callee = callee_tmp;
      if ((unsigned long )callee_tmp != (unsigned long )((void *)0)) {
        tmp___2 = callee_tmp->hh.next;
      } else {
        tmp___2 = (void *)0;
      }
      callee_tmp = (callgrind_callee_t *)tmp___2;
    }
    while (1) {
      _hd_hh_del___0 = & caller->hh;
      if ((unsigned long )_hd_hh_del___0->prev == (unsigned long )((void *)0)) {
        if ((unsigned long )_hd_hh_del___0->next == (unsigned long )((void *)0)) {
          free((void *)((udata->callers)->hh.tbl)->buckets);
          free((void *)(udata->callers)->hh.tbl);
          udata->callers = (callgrind_caller_t *)((void *)0);
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        if ((unsigned long )_hd_hh_del___0 == (unsigned long )((udata->callers)->hh.tbl)->tail) {
          ((udata->callers)->hh.tbl)->tail = (UT_hash_handle *)((char *)_hd_hh_del___0->prev + ((udata->callers)->hh.tbl)->hho);
        }
        if ((unsigned long )_hd_hh_del___0->prev != (unsigned long )((void *)0)) {
          ((UT_hash_handle *)((char *)_hd_hh_del___0->prev + ((udata->callers)->hh.tbl)->hho))->next = _hd_hh_del___0->next;
        } else {
          while (1) {
            udata->callers = (callgrind_caller_t *)_hd_hh_del___0->next;
            break;
          }
        }
        if ((unsigned long )_hd_hh_del___0->next != (unsigned long )((void *)0)) {
          ((UT_hash_handle *)((char *)_hd_hh_del___0->next + ((udata->callers)->hh.tbl)->hho))->prev = _hd_hh_del___0->prev;
        }
        while (1) {
          _hd_bkt___0 = _hd_hh_del___0->hashv & (((udata->callers)->hh.tbl)->num_buckets - 1U);
          break;
        }
        while (1) {
          _hd_head___0 = ((udata->callers)->hh.tbl)->buckets + _hd_bkt___0;
          (_hd_head___0->count) --;
          if ((unsigned long )_hd_head___0->hh_head == (unsigned long )_hd_hh_del___0) {
            _hd_head___0->hh_head = _hd_hh_del___0->hh_next;
          }
          if (_hd_hh_del___0->hh_prev) {
            (_hd_hh_del___0->hh_prev)->hh_next = _hd_hh_del___0->hh_next;
          }
          if (_hd_hh_del___0->hh_next) {
            (_hd_hh_del___0->hh_next)->hh_prev = _hd_hh_del___0->hh_prev;
          }
          break;
        }
        (((udata->callers)->hh.tbl)->num_items) --;
      }
      break;
    }
    free((void *)caller);
    caller = caller_tmp;
    if ((unsigned long )caller_tmp != (unsigned long )((void *)0)) {
      tmp___0 = caller_tmp->hh.next;
    } else {
      tmp___0 = (void *)0;
    }
    caller_tmp = (callgrind_caller_t *)tmp___0;
  }
  return;
}
}
static int callgrind_sort_callers(callgrind_caller_t *a , callgrind_caller_t *b ) 
{ 
  int tmp ;

  {
  tmp = strcmp((char const   *)(a->loc_str), (char const   *)(b->loc_str));
  return (tmp);
}
}
static int callgrind_sort_callees(callgrind_callee_t *a , callgrind_callee_t *b ) 
{ 
  int tmp ;

  {
  tmp = strcmp((char const   *)(a->loc_str), (char const   *)(b->loc_str));
  return (tmp);
}
}
static int callgrind_open(FILE **fout ) 
{ 
  int tfd ;
  int tmp ;

  {
  tfd = -1;
  tmp = strcmp((char const   *)opt_path_output, "-");
  if (tmp == 0) {
    tfd = dup(1);
    *fout = fdopen(tfd, "w");
  } else {
    *fout = fopen((char const   * __restrict  )opt_path_output, (char const   * __restrict  )"w");
  }
  if (! *fout) {
    perror("fopen");
    if (tfd != -1) {
      close(tfd);
    }
    return (1);
  }
  setvbuf((FILE * __restrict  )*fout, (char * __restrict  )((void *)0), 1, (size_t )4096);
  return (0);
}
}
