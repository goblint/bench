/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef __builtin_va_list __gnuc_va_list;
typedef long __off_t;
typedef long __off64_t;
typedef unsigned long size_t;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
struct __anonstruct_snoopy_configuration_t_620930686 {
   int initialized ;
   int configfile_enabled ;
   char *configfile_path ;
   int configfile_found ;
   int configfile_parsed ;
   int error_logging_enabled ;
   char *message_format ;
   int message_format_malloced ;
   int filtering_enabled ;
   char *filter_chain ;
   int filter_chain_malloced ;
   char *output ;
   int output_malloced ;
   char *output_arg ;
   int output_arg_malloced ;
   int syslog_facility ;
   int syslog_level ;
   int syslog_ident_format_malloced ;
   char *syslog_ident_format ;
};
typedef struct __anonstruct_snoopy_configuration_t_620930686 snoopy_configuration_t;
typedef long __time_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
typedef __ssize_t ssize_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
typedef unsigned long pthread_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
struct __anonstruct_tData_t_1064464920 {
   int seqNr ;
};
typedef struct __anonstruct_tData_t_1064464920 tData_t;
typedef int __pid_t;
typedef __pid_t pid_t;
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#pragma merger("0","/tmp/cil-YQyqXhlZ.i","-Wall,-Werror,-Wextra,-Wno-unused-parameter,-std=c99,-Wpedantic,-fvisibility=hidden,-g,-O2")
void fatalError(char const   * const  message ) ;
void fatalErrorValue(char const   * const  message , char const   * const  value ) ;
int snoopyTestCli_action_run_configfile(int argc , char **argv ) ;
int snoopyTestCli_action_run_datasource(int argc , char **argv ) ;
int snoopyTestCli_action_run_filter(int argc , char **argv ) ;
int snoopyTestCli_action_run_filterchain(int argc , char **argv ) ;
int snoopyTestCli_action_run_messageformat(int argc , char **argv ) ;
int snoopyTestCli_action_run_output(int argc , char **argv ) ;
int snoopyTestCli_action_run_everything(void) ;
extern FILE *stdin ;
extern FILE *stdout ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) ;
extern int getc(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
extern int putc(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
extern int __uflow(FILE * ) ;
extern int __overflow(FILE * , int  ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) 
{ 
  int tmp ;

  {
  tmp = vfprintf((FILE * __restrict  )stdout, __fmt, __arg);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) 
{ 
  int tmp ;

  {
  tmp = getc(stdin);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(__fp);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = __fp->_IO_read_ptr;
    (__fp->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(stdin);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = stdin->_IO_read_ptr;
    (stdin->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) 
{ 
  int tmp ;

  {
  tmp = putc(__c, stdout);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = __stream->_IO_write_ptr;
    (__stream->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = stdout->_IO_write_ptr;
    (stdout->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1))) strtoll)(char const   * __restrict  __nptr ,
                                                                                          char ** __restrict  __endptr ,
                                                                                          int __base ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) atoi)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return ((int )tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long ( __attribute__((__nonnull__(1), __gnu_inline__)) atol)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long long ( __attribute__((__nonnull__(1), __gnu_inline__)) atoll)(char const   *__nptr ) 
{ 
  long long tmp ;

  {
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
  return (tmp);
}
}
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
  __l = (size_t )0;
  __u = __nmemb;
  while (__l < __u) {
    __idx = (__l + __u) / 2UL;
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
    __comparison = (*__compar)(__key, __p);
    if (__comparison < 0) {
      __u = __idx;
    } else
    if (__comparison > 0) {
      __l = __idx + 1UL;
    } else {
      return ((void *)__p);
    }
  }
  return ((void *)0);
}
}
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern double ( __attribute__((__nonnull__(1), __gnu_inline__)) atof)(char const   *__nptr ) 
{ 
  double tmp ;

  {
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
void snoopyTestCli_action_run_showHelp(void) 
{ 
  char *helpContent ;

  {
  helpContent = (char *)"Snoopy TEST SUITE CLI utility :: Action `run`\n\nUsage:\n    snoopy run SUBSYSTEM [ARGS]\n\nAvailable subsystems:\n    configfile,cf      Run a configfile (.ini) parser\n    datasource,ds      Run a data source\n    filter,f           Run a filter\n    filterchain,fc     Run a filter chain (as if it would be configured in snoopy.ini)\n    messageformat,mf   Run the message formatter\n    output,o           Run an output\n\n    everything         Runs every subsystem, as much as possible (for Valgrind)\n\n    help,h             Show this help\n    SUBSYSTEM help     Show SUBSYSTEM\'s help\n\n";
  printf((char const   * __restrict  )"%s", helpContent);
  return;
}
}
int snoopyTestCli_action_run(int argc , char **argv ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;

  {
  if (argc < 1) {
    snoopyTestCli_action_run_showHelp();
    fatalError((char const   * const  )"No subsystem specified.");
  }
  tmp___0 = strcmp((char const   *)*(argv + 0), "configfile");
  if (0 == tmp___0) {
    tmp = snoopyTestCli_action_run_configfile(argc - 1, argv + 1);
    return (tmp);
  } else {
    tmp___1 = strcmp((char const   *)*(argv + 0), "cf");
    if (0 == tmp___1) {
      tmp = snoopyTestCli_action_run_configfile(argc - 1, argv + 1);
      return (tmp);
    }
  }
  tmp___3 = strcmp((char const   *)*(argv + 0), "datasource");
  if (0 == tmp___3) {
    tmp___2 = snoopyTestCli_action_run_datasource(argc - 1, argv + 1);
    return (tmp___2);
  } else {
    tmp___4 = strcmp((char const   *)*(argv + 0), "ds");
    if (0 == tmp___4) {
      tmp___2 = snoopyTestCli_action_run_datasource(argc - 1, argv + 1);
      return (tmp___2);
    }
  }
  tmp___6 = strcmp((char const   *)*(argv + 0), "filter");
  if (0 == tmp___6) {
    tmp___5 = snoopyTestCli_action_run_filter(argc - 1, argv + 1);
    return (tmp___5);
  } else {
    tmp___7 = strcmp((char const   *)*(argv + 0), "f");
    if (0 == tmp___7) {
      tmp___5 = snoopyTestCli_action_run_filter(argc - 1, argv + 1);
      return (tmp___5);
    }
  }
  tmp___9 = strcmp((char const   *)*(argv + 0), "filterchain");
  if (0 == tmp___9) {
    tmp___8 = snoopyTestCli_action_run_filterchain(argc - 1, argv + 1);
    return (tmp___8);
  } else {
    tmp___10 = strcmp((char const   *)*(argv + 0), "fc");
    if (0 == tmp___10) {
      tmp___8 = snoopyTestCli_action_run_filterchain(argc - 1, argv + 1);
      return (tmp___8);
    }
  }
  tmp___12 = strcmp((char const   *)*(argv + 0), "messageformat");
  if (0 == tmp___12) {
    tmp___11 = snoopyTestCli_action_run_messageformat(argc - 1, argv + 1);
    return (tmp___11);
  } else {
    tmp___13 = strcmp((char const   *)*(argv + 0), "mf");
    if (0 == tmp___13) {
      tmp___11 = snoopyTestCli_action_run_messageformat(argc - 1, argv + 1);
      return (tmp___11);
    }
  }
  tmp___15 = strcmp((char const   *)*(argv + 0), "output");
  if (0 == tmp___15) {
    tmp___14 = snoopyTestCli_action_run_output(argc - 1, argv + 1);
    return (tmp___14);
  } else {
    tmp___16 = strcmp((char const   *)*(argv + 0), "o");
    if (0 == tmp___16) {
      tmp___14 = snoopyTestCli_action_run_output(argc - 1, argv + 1);
      return (tmp___14);
    }
  }
  tmp___18 = strcmp((char const   *)*(argv + 0), "everything");
  if (0 == tmp___18) {
    tmp___17 = snoopyTestCli_action_run_everything();
    return (tmp___17);
  }
  tmp___19 = strcmp((char const   *)*(argv + 0), "help");
  if (0 == tmp___19) {
    snoopyTestCli_action_run_showHelp();
    return (0);
  } else {
    tmp___20 = strcmp((char const   *)*(argv + 0), "h");
    if (0 == tmp___20) {
      snoopyTestCli_action_run_showHelp();
      return (0);
    }
  }
  snoopyTestCli_action_run_showHelp();
  fatalErrorValue((char const   * const  )"Unknown subsystem", (char const   * const  )*(argv + 0));
  return (127);
}
}
#pragma merger("0","/tmp/cil-Q5bQPc6h.i","-Wall,-Werror,-Wextra,-Wno-unused-parameter,-std=c99,-Wpedantic,-fvisibility=hidden,-g,-O2")
void snoopyTestCli_action_run_datasource_all(void) ;
char **g_argv ;
extern void snoopy_entrypoint_test_cli_init(char const   *filename , char * const  *argv ,
                                            char * const  configFilePath ) ;
extern void snoopy_entrypoint_test_cli_exit() ;
extern void snoopy_error_handler(char const   * const  errorMsg ) ;
extern int snoopy_datasourceregistry_getCount() ;
extern int snoopy_datasourceregistry_doesNameExist(char const   * const  datasourceName ) ;
extern char *snoopy_datasourceregistry_getName(int datasourceId ) ;
extern int snoopy_datasourceregistry_callById(int datasourceId , char * const  result ,
                                              char const   * const  datasourceArg ) ;
extern int snoopy_datasourceregistry_callByName(char const   * const  datasourceName ,
                                                char * const  result , char const   * const  datasourceArg ) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
void snoopyTestCli_action_run_datasource_showList(void) 
{ 
  int dCount ;
  int tmp ;
  int i ;
  char *tmp___0 ;

  {
  printf((char const   * __restrict  )"Available datasources:\n");
  tmp = snoopy_datasourceregistry_getCount();
  dCount = tmp;
  i = 0;
  while (i < dCount) {
    tmp___0 = snoopy_datasourceregistry_getName(i);
    printf((char const   * __restrict  )"    %s\n", tmp___0);
    i ++;
  }
  return;
}
}
void snoopyTestCli_action_run_datasource_showHelp(void) 
{ 
  char *helpContent ;

  {
  helpContent = (char *)"Snoopy TEST SUITE CLI utility :: Action `run` :: Subsystem `datasource`\n\nUsage:\n    snoopy-test run datasource DATASOURCE [ARGS]\n    snoopy-test run datasource --all    # Runs all datasources\n    snoopy-test run datasource --help   # Shows this help message\n    snoopy-test run datasource --list   # Lists all available datasources\n\n";
  printf((char const   * __restrict  )"%s", helpContent);
  snoopyTestCli_action_run_datasource_showList();
  return;
}
}
int snoopyTestCli_action_run_datasource(int argc , char **argv ) 
{ 
  char const   *arg1 ;
  char const   *datasourceName ;
  char const   *datasourceArg ;
  char datasourceResult[2048] ;
  int retVal ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  snoopy_entrypoint_test_cli_init((char const   *)*(g_argv + 0), (char * const  *)g_argv,
                                  (char * const  )((void *)0));
  if (argc < 1) {
    snoopyTestCli_action_run_datasource_showHelp();
    fatalError((char const   * const  )"Missing argument: `datasource name` or `--list`");
  }
  arg1 = (char const   *)*(argv + 0);
  tmp = strcmp(arg1, "--all");
  if (0 == tmp) {
    snoopyTestCli_action_run_datasource_all();
    return (0);
  }
  tmp___0 = strcmp(arg1, "--help");
  if (0 == tmp___0) {
    snoopyTestCli_action_run_datasource_showHelp();
    return (0);
  }
  tmp___1 = strcmp(arg1, "--list");
  if (0 == tmp___1) {
    snoopyTestCli_action_run_datasource_showList();
    return (0);
  }
  datasourceName = arg1;
  tmp___2 = snoopy_datasourceregistry_doesNameExist((char const   * const  )datasourceName);
  if (0 == tmp___2) {
    snoopyTestCli_action_run_datasource_showHelp();
    fatalError((char const   * const  )"Invalid datasource name given");
  }
  if (argc >= 2) {
    datasourceArg = (char const   *)*(argv + 1);
  } else {
    datasourceArg = "";
  }
  retVal = snoopy_datasourceregistry_callByName((char const   * const  )datasourceName,
                                                (char * const  )(datasourceResult),
                                                (char const   * const  )datasourceArg);
  if (retVal < 0) {
    fatalErrorValue((char const   * const  )"Datasource failed", (char const   * const  )(datasourceResult));
  }
  printf((char const   * __restrict  )"%s\n", datasourceResult);
  snoopy_entrypoint_test_cli_exit();
  return (0);
}
}
void snoopyTestCli_action_run_datasource_all(void) 
{ 
  char *itemName ;
  char const   *itemArgs ;
  char *itemResult ;
  int itemResultSize ;
  int dCount ;
  void *tmp ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;

  {
  itemName = (char *)((void *)0);
  itemArgs = (char const   *)((void *)0);
  itemResult = (char *)((void *)0);
  tmp = malloc((size_t )2049);
  itemResult = (char *)tmp;
  dCount = snoopy_datasourceregistry_getCount();
  i = 0;
  while (i < dCount) {
    itemName = snoopy_datasourceregistry_getName(i);
    printf((char const   * __restrict  )"Datasource %15s: ", itemName);
    tmp___1 = strcmp((char const   *)itemName, "env");
    if (tmp___1 == 0) {
      itemArgs = "HOME";
    } else {
      tmp___0 = strcmp((char const   *)itemName, "snoopy_literal");
      if (tmp___0 == 0) {
        itemArgs = "somestring";
      } else {
        itemArgs = "";
      }
    }
    itemResultSize = snoopy_datasourceregistry_callById(i, (char * const  )itemResult,
                                                        (char const   * const  )itemArgs);
    if (itemResultSize > 2048) {
      snoopy_error_handler((char const   * const  )"Maximum data source message size exceeded");
    }
    printf((char const   * __restrict  )"%s\n", itemResult);
    i ++;
  }
  free((void *)itemResult);
  return;
}
}
#pragma merger("0","/tmp/cil-SarvWjV2.i","-Wall,-Werror,-Wextra,-Wno-unused-parameter,-std=c99,-Wpedantic,-fvisibility=hidden,-g,-O2")
void snoopyTestCli_action_run_filter_all(void) ;
void snoopyTestCli_action_run_output_all(void) ;
extern snoopy_configuration_t *snoopy_configuration_get() ;
extern int snoopy_filtering_check_chain(char const   * const  chain ) ;
extern int snoopy_action_log_message_dispatch(char const   *logMessage ) ;
extern void snoopy_message_generateFromFormat(char *logMessage , size_t logMessageBufSize ,
                                              char *logMessageFormat ) ;
extern FILE *stderr ;
extern int fclose(FILE *__stream ) ;
void snoopyTestCli_action_run_everything_showHelp(void) 
{ 
  char *helpContent ;

  {
  helpContent = (char *)"Snoopy TEST SUITE CLI utility :: Action `run` :: Run everything (for Valgrind)\n\nUsage:\n    snoopy-test run everything\n\nResult:\n    Runs as many subsystems as possible, to cover as much code as possible.\n    Useful for Valgrind analysis.\n\n";
  printf((char const   * __restrict  )"%s", helpContent);
  return;
}
}
int snoopyTestCli_action_run_everything(void) 
{ 
  char *logMessage ;
  snoopy_configuration_t *CFG ;
  void *tmp ;

  {
  logMessage = (char *)((void *)0);
  snoopy_entrypoint_test_cli_init((char const   *)*(g_argv + 0), (char * const  *)g_argv,
                                  (char * const  )((void *)0));
  CFG = snoopy_configuration_get();
  tmp = malloc((size_t )16383);
  logMessage = (char *)tmp;
  *(logMessage + 0) = (char )'\000';
  printf((char const   * __restrict  )"-----[ Filters ]---------------------------------------\n");
  snoopyTestCli_action_run_filter_all();
  printf((char const   * __restrict  )"-----[ Filtering ]-------------------------------------\n");
  snoopy_filtering_check_chain((char const   * const  )"exclude_uid:10,11,12;only_uid=0,1,2,3");
  printf((char const   * __restrict  )"Done.\n");
  printf((char const   * __restrict  )"-----[ Datasources ]-----------------------------------\n");
  snoopyTestCli_action_run_datasource_all();
  printf((char const   * __restrict  )"-----[ Outputs ]---------------------------------------\n");
  snoopyTestCli_action_run_output_all();
  printf((char const   * __restrict  )"-----[ Message formatting ]----------------------------\n");
  snoopy_message_generateFromFormat(logMessage, (size_t )16383, CFG->message_format);
  printf((char const   * __restrict  )"Message: %s\n", logMessage);
  printf((char const   * __restrict  )"-----[ Dispatching ]-----------------------------------\n");
  snoopy_action_log_message_dispatch((char const   *)logMessage);
  printf((char const   * __restrict  )"Done.\n");
  printf((char const   * __restrict  )"\nAll done.\n");
  free((void *)logMessage);
  snoopy_entrypoint_test_cli_exit();
  fclose(stdin);
  fclose(stdout);
  fclose(stderr);
  return (0);
}
}
#pragma merger("0","/tmp/cil-58GUFMbX.i","-Wall,-Werror,-Wextra,-Wno-unused-parameter,-std=c99,-Wpedantic,-fvisibility=hidden,-g,-O2")
void snoopyTestCli_action_run_messageformat_showHelp(void) 
{ 
  char *helpContent ;

  {
  helpContent = (char *)"Snoopy TEST SUITE CLI utility :: Action `run` :: Subsystem `message formatter`\n\nUsage:\n    snoopy-test run messageformat \"FORMAT SPECIFICATION\"\n\nResult:\n    Prints a log message formatted according to the given format specification.\n    Process data is taken from self.\n\n";
  printf((char const   * __restrict  )"%s", helpContent);
  return;
}
}
int snoopyTestCli_action_run_messageformat(int argc , char **argv ) 
{ 
  char *messageFormat ;
  char *message ;
  void *tmp ;

  {
  snoopy_entrypoint_test_cli_init((char const   *)*(g_argv + 0), (char * const  *)g_argv,
                                  (char * const  )((void *)0));
  if (argc < 1) {
    snoopyTestCli_action_run_messageformat_showHelp();
    fatalError((char const   * const  )"Missing argument: message format");
  }
  messageFormat = *(argv + 0);
  tmp = malloc((size_t )16383);
  message = (char *)tmp;
  *(message + 0) = (char )'\000';
  snoopy_message_generateFromFormat(message, (size_t )16383, messageFormat);
  printf((char const   * __restrict  )"%s\n", message);
  free((void *)message);
  snoopy_entrypoint_test_cli_exit();
  return (0);
}
}
#pragma merger("0","/tmp/cil-T7SNxxSd.i","-Wall,-Werror,-Wextra,-Wno-unused-parameter,-std=c99,-Wpedantic,-fvisibility=hidden,-g,-O2")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
extern int snoopy_outputregistry_getCount() ;
extern int snoopy_outputregistry_doesNameExist(char const   * const  outputName ) ;
extern char *snoopy_outputregistry_getName(int outputId ) ;
extern int snoopy_outputregistry_callById(int outputId , char const   * const  logMessage ,
                                          char const   * const  outputArg ) ;
extern int snoopy_outputregistry_callByName(char const   * const  outputName , char const   * const  logMessage ,
                                            char const   * const  outputArg ) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
void snoopyTestCli_action_run_output_showList(void) 
{ 
  int oCount ;
  int tmp ;
  int i ;
  char *tmp___0 ;

  {
  printf((char const   * __restrict  )"Available outputs:\n");
  tmp = snoopy_outputregistry_getCount();
  oCount = tmp;
  i = 0;
  while (i < oCount) {
    tmp___0 = snoopy_outputregistry_getName(i);
    printf((char const   * __restrict  )"    %s\n", tmp___0);
    i ++;
  }
  return;
}
}
void snoopyTestCli_action_run_output_showHelp(void) 
{ 
  char *helpContent ;

  {
  helpContent = (char *)"Snoopy TEST SUITE CLI utility :: Action `run` :: Subsystem `output`\n\nUsage:\n    snoopy-test run output \"LOG MESSAGE\" OUTPUT [OUTPUT_ARGS]\n    snoopy-test run output --all\n    snoopy-test run output --list\n    snoopy-test run output --help\n\n";
  printf((char const   * __restrict  )"%s", helpContent);
  snoopyTestCli_action_run_output_showList();
  return;
}
}
int snoopyTestCli_action_run_output(int argc , char **argv ) 
{ 
  char const   *arg1 ;
  char const   *message ;
  char const   *outputName ;
  char const   *outputArg ;
  int retVal ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  snoopy_entrypoint_test_cli_init((char const   *)*(g_argv + 0), (char * const  *)g_argv,
                                  (char * const  )((void *)0));
  if (argc < 1) {
    snoopyTestCli_action_run_output_showHelp();
    fatalError((char const   * const  )"Missing argument: log message, or --all or --list");
  }
  arg1 = (char const   *)*(argv + 0);
  tmp = strcmp(arg1, "--all");
  if (0 == tmp) {
    snoopyTestCli_action_run_output_all();
    return (0);
  }
  tmp___0 = strcmp(arg1, "--help");
  if (0 == tmp___0) {
    snoopyTestCli_action_run_output_showHelp();
    return (0);
  }
  tmp___1 = strcmp(arg1, "--list");
  if (0 == tmp___1) {
    snoopyTestCli_action_run_output_showList();
    return (0);
  }
  message = arg1;
  if (argc < 2) {
    snoopyTestCli_action_run_output_showHelp();
    fatalError((char const   * const  )"Missing argument: output name");
  }
  outputName = (char const   *)*(argv + 1);
  if (argc > 2) {
    outputArg = (char const   *)*(argv + 2);
  } else {
    outputArg = "";
  }
  tmp___2 = snoopy_outputregistry_doesNameExist((char const   * const  )outputName);
  if (0 == tmp___2) {
    snoopyTestCli_action_run_output_showHelp();
    fatalErrorValue((char const   * const  )"Invalid output name given", (char const   * const  )outputName);
  }
  retVal = snoopy_outputregistry_callByName((char const   * const  )outputName, (char const   * const  )message,
                                            (char const   * const  )outputArg);
  if (retVal < 0) {
    fatalError((char const   * const  )"Output failure");
  }
  snoopy_entrypoint_test_cli_exit();
  return (0);
}
}
void snoopyTestCli_action_run_output_all(void) 
{ 
  char *message ;
  char *itemName ;
  char const   *itemArgs ;
  int itemResult ;
  int iCount ;
  void *tmp ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  message = (char *)((void *)0);
  itemName = (char *)((void *)0);
  itemArgs = (char const   *)((void *)0);
  tmp = malloc((size_t )16383);
  message = (char *)tmp;
  snprintf((char * __restrict  )message, (size_t )16383, (char const   * __restrict  )"Snoopy output debugging");
  iCount = snoopy_outputregistry_getCount();
  i = 0;
  while (i < iCount) {
    itemName = snoopy_outputregistry_getName(i);
    printf((char const   * __restrict  )"Output %19s: ", itemName);
    tmp___1 = strcmp((char const   *)itemName, "file");
    if (tmp___1 == 0) {
      itemArgs = "./fileoutput.out";
    } else {
      tmp___0 = strcmp((char const   *)itemName, "socket");
      if (tmp___0 == 0) {
        itemArgs = "/dev/log";
      } else {
        itemArgs = "";
      }
    }
    itemResult = snoopy_outputregistry_callById(i, (char const   * const  )message,
                                                (char const   * const  )itemArgs);
    printf((char const   * __restrict  )"%d chars transmitted. (output arg:%s)\n",
           itemResult, itemArgs);
    tmp___2 = strcmp((char const   *)itemName, "file");
    if (tmp___2 == 0) {
      unlink(itemArgs);
    }
    i ++;
  }
  free((void *)message);
  return;
}
}
#pragma merger("0","/tmp/cil-Q3ApJr8c.i","-Wall,-Werror,-Wextra,-Wno-unused-parameter,-std=c99,-Wpedantic,-fvisibility=hidden,-g,-O2")
int snoopyTestCli_action_stress_threads(int argc , char **argv ) ;
int snoopyTestCli_action_stress_threadsexec(int argc , char **argv ) ;
void snoopyTestCli_action_stress_showHelp(void) 
{ 
  char *helpContent ;

  {
  helpContent = (char *)"Snoopy TEST SUITE CLI utility :: Action `stress`\n\nUsage:\n    snoopy stress SUBSYSTEM [ARGS]\n\nAvailable subsystems:\n    threads,t          Stress internal threading implementation\n    threadsexec,te     Stress threading implementation by including execution of an external command\n\n    help,h             Show this help\n    SUBSYSTEM help     Show SUBSYSTEM\'s help\n\n";
  printf((char const   * __restrict  )"%s", helpContent);
  return;
}
}
int snoopyTestCli_action_stress(int argc , char **argv ) 
{ 
  char const   *subsystem ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  if (argc < 1) {
    snoopyTestCli_action_stress_showHelp();
    fatalError((char const   * const  )"No subsystem specified.");
  }
  subsystem = (char const   *)*(argv + 0);
  tmp = strcmp(subsystem, "help");
  if (0 == tmp) {
    snoopyTestCli_action_stress_showHelp();
    return (0);
  } else {
    tmp___0 = strcmp(subsystem, "h");
    if (0 == tmp___0) {
      snoopyTestCli_action_stress_showHelp();
      return (0);
    }
  }
  tmp___2 = strcmp(subsystem, "threads");
  if (0 == tmp___2) {
    tmp___1 = snoopyTestCli_action_stress_threads(argc - 1, argv + 1);
    return (tmp___1);
  } else {
    tmp___3 = strcmp(subsystem, "t");
    if (0 == tmp___3) {
      tmp___1 = snoopyTestCli_action_stress_threads(argc - 1, argv + 1);
      return (tmp___1);
    }
  }
  tmp___5 = strcmp(subsystem, "threadsexec");
  if (0 == tmp___5) {
    tmp___4 = snoopyTestCli_action_stress_threadsexec(argc - 1, argv + 1);
    return (tmp___4);
  } else {
    tmp___6 = strcmp(subsystem, "te");
    if (0 == tmp___6) {
      tmp___4 = snoopyTestCli_action_stress_threadsexec(argc - 1, argv + 1);
      return (tmp___4);
    }
  }
  snoopyTestCli_action_stress_showHelp();
  fatalErrorValue((char const   * const  )"Unknown subsystem", (char const   * const  )subsystem);
  return (127);
}
}
#pragma merger("0","/tmp/cil-WkYh2yjg.i","-Wall,-Werror,-Wextra,-Wno-unused-parameter,-std=c99,-Wpedantic,-fvisibility=hidden,-g,-O2")
int snoopyTestCli_action_unit_action(int argc , char **argv ) ;
int snoopyTestCli_action_unit_error(int argc , char **argv ) ;
int snoopyTestCli_action_unit_ext_ini(int argc , char **argv ) ;
int snoopyTestCli_action_unit_filterregistry(int argc , char **argv ) ;
int snoopyTestCli_action_unit_outputregistry(int argc , char **argv ) ;
int snoopyTestCli_action_unit_util(int argc , char **argv ) ;
void snoopyTestCli_action_unit_showHelp(void) 
{ 
  char *helpContent ;

  {
  helpContent = (char *)"Snoopy TEST SUITE CLI utility :: Action `unit`\n\nUsage:\n    snoopy-test unit UNIT [ARGS]\n\nAvailable units:\n    action,a           Run a unit test on action/*.c\n    error,e            Run a unit test on src/error.c\n    ext-ini,ei         Run a unit test on lib/inih/src/ini.c\n    filterregistry,fr  Run a unit test on src/filterregistry.c\n    outputregistry,or  Run a unit test on src/outputregistry.c\n    util,u             Run a unit test on src/util/*.c\n\n    --help,-h          Show this help\n    UNIT --help        Show UNIT\'s help\n\n";
  printf((char const   * __restrict  )"%s", helpContent);
  return;
}
}
int snoopyTestCli_action_unit(int argc , char **argv ) 
{ 
  char const   *unit ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
  if (argc < 1) {
    snoopyTestCli_action_unit_showHelp();
    fatalError((char const   * const  )"No unit specified.");
  }
  unit = (char const   *)*(argv + 0);
  tmp___0 = strcmp(unit, "action");
  if (0 == tmp___0) {
    tmp = snoopyTestCli_action_unit_action(argc - 1, argv + 1);
    return (tmp);
  } else {
    tmp___1 = strcmp(unit, "a");
    if (0 == tmp___1) {
      tmp = snoopyTestCli_action_unit_action(argc - 1, argv + 1);
      return (tmp);
    }
  }
  tmp___3 = strcmp(unit, "error");
  if (0 == tmp___3) {
    tmp___2 = snoopyTestCli_action_unit_error(argc - 1, argv + 1);
    return (tmp___2);
  } else {
    tmp___4 = strcmp(unit, "e");
    if (0 == tmp___4) {
      tmp___2 = snoopyTestCli_action_unit_error(argc - 1, argv + 1);
      return (tmp___2);
    }
  }
  tmp___6 = strcmp(unit, "ext-ini");
  if (0 == tmp___6) {
    tmp___5 = snoopyTestCli_action_unit_ext_ini(argc - 1, argv + 1);
    return (tmp___5);
  } else {
    tmp___7 = strcmp(unit, "ei");
    if (0 == tmp___7) {
      tmp___5 = snoopyTestCli_action_unit_ext_ini(argc - 1, argv + 1);
      return (tmp___5);
    }
  }
  tmp___9 = strcmp(unit, "filterregistry");
  if (0 == tmp___9) {
    tmp___8 = snoopyTestCli_action_unit_filterregistry(argc - 1, argv + 1);
    return (tmp___8);
  } else {
    tmp___10 = strcmp(unit, "fr");
    if (0 == tmp___10) {
      tmp___8 = snoopyTestCli_action_unit_filterregistry(argc - 1, argv + 1);
      return (tmp___8);
    }
  }
  tmp___12 = strcmp(unit, "outputregistry");
  if (0 == tmp___12) {
    tmp___11 = snoopyTestCli_action_unit_outputregistry(argc - 1, argv + 1);
    return (tmp___11);
  } else {
    tmp___13 = strcmp(unit, "or");
    if (0 == tmp___13) {
      tmp___11 = snoopyTestCli_action_unit_outputregistry(argc - 1, argv + 1);
      return (tmp___11);
    }
  }
  tmp___15 = strcmp(unit, "util");
  if (0 == tmp___15) {
    tmp___14 = snoopyTestCli_action_unit_util(argc - 1, argv + 1);
    return (tmp___14);
  } else {
    tmp___16 = strcmp(unit, "u");
    if (0 == tmp___16) {
      tmp___14 = snoopyTestCli_action_unit_util(argc - 1, argv + 1);
      return (tmp___14);
    }
  }
  tmp___17 = strcmp(unit, "--help");
  if (0 == tmp___17) {
    snoopyTestCli_action_unit_showHelp();
    return (0);
  } else {
    tmp___18 = strcmp(unit, "-h");
    if (0 == tmp___18) {
      snoopyTestCli_action_unit_showHelp();
      return (0);
    }
  }
  snoopyTestCli_action_unit_showHelp();
  fatalErrorValue((char const   * const  )"Unknown unit", (char const   * const  )unit);
  return (127);
}
}
#pragma merger("0","/tmp/cil-ksyLBt22.i","-Wall,-Werror,-Wextra,-Wno-unused-parameter,-std=c99,-Wpedantic,-fvisibility=hidden,-g,-O2")
int snoopyTestCli_action_unit_action_log_message_dispatch(int argc , char **argv ) ;
int snoopyTestCli_action_unit_action_log_syscall_exec(int argc , char **argv ) ;
void snoopyTestCli_action_unit_action_showHelp(void) 
{ 
  char *helpContent ;

  {
  helpContent = (char *)"Snoopy TEST SUITE CLI utility :: Action `unit` :: Unit `action`\n\nUsage:\n    snoopy-test unit action SUBUNIT [ARGS]\n\nAvailable subunits:\n    log-message-dispatch,lmd   Run a unit test on src/action/log-message-dispatch.c\n    log-syscall-exec,lse       Run a unit test on src/action/log-syscall-exec.c\n\n    --help,-h          Show this help\n    UNIT --help        Show UNIT\'s help\n\n";
  printf((char const   * __restrict  )"%s", helpContent);
  return;
}
}
int snoopyTestCli_action_unit_action(int argc , char **argv ) 
{ 
  char const   *subunit ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  if (argc < 1) {
    snoopyTestCli_action_unit_action_showHelp();
    fatalError((char const   * const  )"No subunit specified.");
  }
  subunit = (char const   *)*(argv + 0);
  tmp___0 = strcmp(subunit, "log-message-dispatch");
  if (0 == tmp___0) {
    tmp = snoopyTestCli_action_unit_action_log_message_dispatch(argc - 1, argv + 1);
    return (tmp);
  } else {
    tmp___1 = strcmp(subunit, "lmd");
    if (0 == tmp___1) {
      tmp = snoopyTestCli_action_unit_action_log_message_dispatch(argc - 1, argv + 1);
      return (tmp);
    }
  }
  tmp___3 = strcmp(subunit, "log-syscall-exec");
  if (0 == tmp___3) {
    tmp___2 = snoopyTestCli_action_unit_action_log_syscall_exec(argc - 1, argv + 1);
    return (tmp___2);
  } else {
    tmp___4 = strcmp(subunit, "lse");
    if (0 == tmp___4) {
      tmp___2 = snoopyTestCli_action_unit_action_log_syscall_exec(argc - 1, argv + 1);
      return (tmp___2);
    }
  }
  tmp___5 = strcmp(subunit, "--help");
  if (0 == tmp___5) {
    snoopyTestCli_action_unit_action_showHelp();
    return (0);
  } else {
    tmp___6 = strcmp(subunit, "-h");
    if (0 == tmp___6) {
      snoopyTestCli_action_unit_action_showHelp();
      return (0);
    }
  }
  snoopyTestCli_action_unit_action_showHelp();
  fatalErrorValue((char const   * const  )"Unknown subunit", (char const   * const  )subunit);
  return (127);
}
}
#pragma merger("0","/tmp/cil-cTiDI8hm.i","-Wall,-Werror,-Wextra,-Wno-unused-parameter,-std=c99,-Wpedantic,-fvisibility=hidden,-g,-O2")
void printSuccess(char const   * const  message ) ;
extern void snoopy_action_log_syscall_exec() ;
void snoopyTestCli_action_unit_action_log_syscall_exec_showHelp(void) 
{ 
  char *helpContent ;

  {
  helpContent = (char *)"Snoopy TEST SUITE CLI utility :: Action `unit` :: Unit `action` :: Subunit \'log-syscall-exec\'\n\nDescription:\n    Mocks src/action/log-syscall-exec.c implementation code paths (mainly for the coverage of code parts/paths not covered by the test suite).\n\nUsage:\n    snoopy-test unit action log-syscall-exec\n    snoopy-test unit action log-syscall-exec --help\n\n";
  printf((char const   * __restrict  )"%s", helpContent);
  return;
}
}
int snoopyTestCli_action_unit_action_log_syscall_exec(int argc , char **argv ) 
{ 
  char const   *arg1 ;
  int tmp ;
  snoopy_configuration_t *CFG ;

  {
  if (argc > 0) {
    arg1 = (char const   *)*(argv + 0);
  } else {
    arg1 = "";
  }
  tmp = strcmp(arg1, "--help");
  if (0 == tmp) {
    snoopyTestCli_action_unit_action_log_syscall_exec_showHelp();
    return (0);
  }
  snoopy_entrypoint_test_cli_init((char const   *)*(g_argv + 0), (char * const  *)g_argv,
                                  (char * const  )((void *)0));
  CFG = snoopy_configuration_get();
  CFG->message_format = (char *)"Test error message, sent out via stdout output.";
  CFG->filter_chain = (char *)"";
  CFG->output = (char *)"stdout";
  snoopy_action_log_syscall_exec();
  snoopy_entrypoint_test_cli_exit();
  printSuccess((char const   * const  )"Mocking src/action/log-syscall-exec.c complete.");
  return (0);
}
}
#pragma merger("0","/tmp/cil-e8hNcqdn.i","-Wall,-Werror,-Wextra,-Wno-unused-parameter,-std=c99,-Wpedantic,-fvisibility=hidden,-g,-O2")
void snoopyTestCli_action_unit_action_log_message_dispatch_showHelp(void) 
{ 
  char *helpContent ;

  {
  helpContent = (char *)"Snoopy TEST SUITE CLI utility :: Action `unit` :: Unit `action` :: Subunit \'log-message-dispatch\'\n\nDescription:\n    Mocks src/action/log-message-dispatch.c implementation code paths (mainly for the coverage of code parts/paths not covered by the test suite).\n\nUsage:\n    snoopy-test unit action log-message-dispatch\n    snoopy-test unit action log-message-dispatch --help\n\n";
  printf((char const   * __restrict  )"%s", helpContent);
  return;
}
}
int snoopyTestCli_action_unit_action_log_message_dispatch(int argc , char **argv ) 
{ 
  char const   *arg1 ;
  int tmp ;
  snoopy_configuration_t *CFG ;

  {
  if (argc > 0) {
    arg1 = (char const   *)*(argv + 0);
  } else {
    arg1 = "";
  }
  tmp = strcmp(arg1, "--help");
  if (0 == tmp) {
    snoopyTestCli_action_unit_action_log_message_dispatch_showHelp();
    return (0);
  }
  snoopy_entrypoint_test_cli_init((char const   *)*(g_argv + 0), (char * const  *)g_argv,
                                  (char * const  )((void *)0));
  CFG = snoopy_configuration_get();
  CFG->output = (char *)"stdout";
  snoopy_action_log_message_dispatch("Test error message, sent out via stdout output.");
  snoopy_entrypoint_test_cli_exit();
  printSuccess((char const   * const  )"Mocking src/action/log-message-dispatch.c complete.");
  return (0);
}
}
#pragma merger("0","/tmp/cil-xvZ7PBra.i","-Wall,-Werror,-Wextra,-Wno-unused-parameter,-std=c99,-Wpedantic,-fvisibility=hidden,-g,-O2")
void snoopyTestCli_action_unit_error_showHelp(void) 
{ 
  char *helpContent ;

  {
  helpContent = (char *)"Snoopy TEST SUITE CLI utility :: Action `unit` :: Unit `error`\n\nDescription:\n    Mocks src/error.c implementation code paths (mainly for the coverage of code parts/paths not covered by the test suite).\n\nUsage:\n    snoopy-test unit error\n    snoopy-test unit error --help\n\n";
  printf((char const   * __restrict  )"%s", helpContent);
  return;
}
}
int snoopyTestCli_action_unit_error(int argc , char **argv ) 
{ 
  char const   *arg1 ;
  int tmp ;
  snoopy_configuration_t *CFG ;

  {
  if (argc > 0) {
    arg1 = (char const   *)*(argv + 0);
  } else {
    arg1 = "";
  }
  tmp = strcmp(arg1, "--help");
  if (0 == tmp) {
    snoopyTestCli_action_unit_error_showHelp();
    return (0);
  }
  snoopy_entrypoint_test_cli_init((char const   *)*(g_argv + 0), (char * const  *)g_argv,
                                  (char * const  )((void *)0));
  CFG = snoopy_configuration_get();
  CFG->output = (char *)"stderr";
  snoopy_error_handler((char const   * const  )"Test error message, sent out via stderr output.");
  snoopy_entrypoint_test_cli_exit();
  printSuccess((char const   * const  )"Mocking src/error.c complete.");
  return (0);
}
}
#pragma merger("0","/tmp/cil-YJuc2RHe.i","-Wall,-Werror,-Wextra,-Wno-unused-parameter,-std=c99,-Wpedantic,-fvisibility=hidden,-g,-O2")
extern int snoopy_outputregistry_doesIdExist(int outputId ) ;
extern int snoopy_outputregistry_getIdFromName(char const   * const  outputName ) ;
extern int snoopy_outputregistry_dispatch(char const   * const  logMessage ) ;
void snoopyTestCli_action_unit_outputregistry_showHelp(void) 
{ 
  char *helpContent ;

  {
  helpContent = (char *)"Snoopy TEST SUITE CLI utility :: Action `unit` :: Unit `outputregistry`\n\nDescription:\n    Mocks outputregistry implementation code paths (mainly for the coverage of code parts/paths not covered by the test suite).\n\nUsage:\n    snoopy-test unit outputregistry\n    snoopy-test unit outputregistry --help\n\n";
  printf((char const   * __restrict  )"%s", helpContent);
  return;
}
}
int snoopyTestCli_action_unit_outputregistry(int argc , char **argv ) 
{ 
  char const   *arg1 ;
  int tmp ;
  char const   *outputName ;
  int outputCount ;
  int outputIdPreset ;
  int outputIdReceived ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  snoopy_configuration_t *CFG ;

  {
  if (argc > 0) {
    arg1 = (char const   *)*(argv + 0);
  } else {
    arg1 = "";
  }
  tmp = strcmp(arg1, "--help");
  if (0 == tmp) {
    snoopyTestCli_action_unit_outputregistry_showHelp();
    return (0);
  }
  outputName = (char const   *)((void *)0);
  outputCount = 0;
  outputIdPreset = 0;
  outputIdReceived = 0;
  outputCount = snoopy_outputregistry_getCount();
  if (outputCount < 1) {
    fatalError((char const   * const  )"No outputs available, output count is 0");
  }
  printf((char const   * __restrict  )"[DEBUG] Number of outputs available: %d\n",
         outputCount);
  tmp___0 = snoopy_outputregistry_doesIdExist(outputIdPreset);
  if (tmp___0 != 1) {
    fatalError((char const   * const  )"Output with a preset ID (0) does not exist");
  }
  tmp___1 = snoopy_outputregistry_getName(outputIdPreset);
  outputName = (char const   *)tmp___1;
  outputIdReceived = snoopy_outputregistry_getIdFromName((char const   * const  )outputName);
  if (outputIdPreset != outputIdReceived) {
    fatalError((char const   * const  )"Output ID returned when searching by name differs from the initially used ID to find that same output");
  }
  outputName = "noop";
  outputIdReceived = snoopy_outputregistry_getIdFromName((char const   * const  )outputName);
  snoopy_outputregistry_callById(outputIdReceived, (char const   * const  )((void *)0),
                                 (char const   * const  )"");
  tmp___2 = snoopy_outputregistry_callById(-1, (char const   * const  )((void *)0),
                                           (char const   * const  )"");
  if (-1 != tmp___2) {
    fatalError((char const   * const  )"Output ID -1 unexpectedly exists");
  }
  tmp___3 = snoopy_outputregistry_callByName((char const   * const  )"fakeOutputNameThatShouldNeverExist",
                                             (char const   * const  )((void *)0),
                                             (char const   * const  )"");
  if (-1 != tmp___3) {
    fatalError((char const   * const  )"Output with an unexpected name actually exists");
  }
  snoopy_entrypoint_test_cli_init((char const   *)*(g_argv + 0), (char * const  *)g_argv,
                                  (char * const  )((void *)0));
  CFG = snoopy_configuration_get();
  CFG->output = (char *)"noop";
  snoopy_outputregistry_dispatch((char const   * const  )((void *)0));
  snoopy_entrypoint_test_cli_exit();
  printSuccess((char const   * const  )"Mocking src/outputregistry.c complete.");
  return (0);
}
}
#pragma merger("0","/tmp/cil-osnhPRWS.i","-Wall,-Werror,-Wextra,-Wno-unused-parameter,-std=c99,-Wpedantic,-fvisibility=hidden,-g,-O2")
int snoopyTestCli_action_unit_util_syslog(int argc , char **argv ) ;
int snoopyTestCli_action_unit_util_systemd(int argc , char **argv ) ;
void snoopyTestCli_action_unit_util_showHelp(void) 
{ 
  char *helpContent ;

  {
  helpContent = (char *)"Snoopy TEST SUITE CLI utility :: Action `unit` :: Unit `util`\n\nUsage:\n    snoopy-test unit util SUBUNIT [ARGS]\n\nAvailable subunits:\n    syslog             Run a unit test on src/util/syslog.c\n    systemd            Run a unit test on src/util/systemd.c\n\n    --help,-h          Show this help\n    UNIT --help        Show UNIT\'s help\n\n";
  printf((char const   * __restrict  )"%s", helpContent);
  return;
}
}
int snoopyTestCli_action_unit_util(int argc , char **argv ) 
{ 
  char const   *subunit ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  if (argc < 1) {
    snoopyTestCli_action_unit_util_showHelp();
    fatalError((char const   * const  )"No subunit specified.");
  }
  subunit = (char const   *)*(argv + 0);
  tmp___0 = strcmp(subunit, "syslog");
  if (0 == tmp___0) {
    tmp = snoopyTestCli_action_unit_util_syslog(argc - 1, argv + 1);
    return (tmp);
  }
  tmp___2 = strcmp(subunit, "systemd");
  if (0 == tmp___2) {
    tmp___1 = snoopyTestCli_action_unit_util_systemd(argc - 1, argv + 1);
    return (tmp___1);
  }
  tmp___3 = strcmp(subunit, "--help");
  if (0 == tmp___3) {
    snoopyTestCli_action_unit_util_showHelp();
    return (0);
  } else {
    tmp___4 = strcmp(subunit, "-h");
    if (0 == tmp___4) {
      snoopyTestCli_action_unit_util_showHelp();
      return (0);
    }
  }
  snoopyTestCli_action_unit_util_showHelp();
  fatalErrorValue((char const   * const  )"Unknown subunit", (char const   * const  )subunit);
  return (127);
}
}
#pragma merger("0","/tmp/cil-0uX_aXOE.i","-Wall,-Werror,-Wextra,-Wno-unused-parameter,-std=c99,-Wpedantic,-fvisibility=hidden,-g,-O2")
extern int snoopy_util_syslog_convertFacilityToInt(char const   *facilityStr ) ;
extern char const   *snoopy_util_syslog_convertFacilityToStr(int facilityInt ) ;
extern int snoopy_util_syslog_convertLevelToInt(char const   *levelStr ) ;
extern char const   *snoopy_util_syslog_convertLevelToStr(int levelInt ) ;
void snoopyTestCli_action_unit_util_syslog_showHelp(void) 
{ 
  char *helpContent ;

  {
  helpContent = (char *)"Snoopy TEST SUITE CLI utility :: Action `unit` :: Unit `misc` :: Subunit `syslog`\n\nDescription:\n    Mocks src/unit/syslog.c implementation code paths (mainly for the coverage of code parts/paths not covered by the test suite).\n\nUsage:\n    snoopy-test unit util syslog\n    snoopy-test unit util syslog --help\n\n";
  printf((char const   * __restrict  )"%s", helpContent);
  return;
}
}
int snoopyTestCli_action_unit_util_syslog(int argc , char **argv ) 
{ 
  char const   *arg1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  char const   *tmp___40 ;
  int tmp___41 ;
  char const   *tmp___42 ;
  int tmp___43 ;
  char const   *tmp___44 ;
  int tmp___45 ;
  char const   *tmp___46 ;
  int tmp___47 ;
  char const   *tmp___48 ;
  int tmp___49 ;
  char const   *tmp___50 ;
  int tmp___51 ;
  char const   *tmp___52 ;
  int tmp___53 ;
  char const   *tmp___54 ;
  int tmp___55 ;
  char const   *tmp___56 ;
  int tmp___57 ;
  char const   *tmp___58 ;
  int tmp___59 ;
  char const   *tmp___60 ;
  int tmp___61 ;
  char const   *tmp___62 ;
  int tmp___63 ;
  char const   *tmp___64 ;
  int tmp___65 ;
  char const   *tmp___66 ;
  int tmp___67 ;
  char const   *tmp___68 ;
  int tmp___69 ;
  char const   *tmp___70 ;
  int tmp___71 ;
  char const   *tmp___72 ;
  int tmp___73 ;
  char const   *tmp___74 ;
  int tmp___75 ;
  char const   *tmp___76 ;
  int tmp___77 ;
  char const   *tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  char const   *tmp___96 ;
  int tmp___97 ;
  char const   *tmp___98 ;
  int tmp___99 ;
  char const   *tmp___100 ;
  int tmp___101 ;
  char const   *tmp___102 ;
  int tmp___103 ;
  char const   *tmp___104 ;
  int tmp___105 ;
  char const   *tmp___106 ;
  int tmp___107 ;
  char const   *tmp___108 ;
  int tmp___109 ;
  char const   *tmp___110 ;
  int tmp___111 ;

  {
  if (argc > 0) {
    arg1 = (char const   *)*(argv + 0);
  } else {
    arg1 = "";
  }
  tmp = strcmp(arg1, "--help");
  if (0 == tmp) {
    snoopyTestCli_action_unit_util_syslog_showHelp();
    return (0);
  }
  tmp___0 = snoopy_util_syslog_convertFacilityToInt("AUTH");
  if (tmp___0 != 4 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"AUTH");
  }
  tmp___1 = snoopy_util_syslog_convertFacilityToInt("AUTHPRIV");
  if (tmp___1 != 10 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"AUTHPRIV");
  }
  tmp___2 = snoopy_util_syslog_convertFacilityToInt("CRON");
  if (tmp___2 != 9 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"CRON");
  }
  tmp___3 = snoopy_util_syslog_convertFacilityToInt("DAEMON");
  if (tmp___3 != 3 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"DAEMON");
  }
  tmp___4 = snoopy_util_syslog_convertFacilityToInt("FTP");
  if (tmp___4 != 11 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"FTP");
  }
  tmp___5 = snoopy_util_syslog_convertFacilityToInt("KERN");
  if (tmp___5 != 0) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"KERN");
  }
  tmp___6 = snoopy_util_syslog_convertFacilityToInt("LOCAL0");
  if (tmp___6 != 16 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"LOCAL0");
  }
  tmp___7 = snoopy_util_syslog_convertFacilityToInt("LOCAL1");
  if (tmp___7 != 17 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"LOCAL1");
  }
  tmp___8 = snoopy_util_syslog_convertFacilityToInt("LOCAL2");
  if (tmp___8 != 18 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"LOCAL2");
  }
  tmp___9 = snoopy_util_syslog_convertFacilityToInt("LOCAL3");
  if (tmp___9 != 19 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"LOCAL3");
  }
  tmp___10 = snoopy_util_syslog_convertFacilityToInt("LOCAL4");
  if (tmp___10 != 20 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"LOCAL4");
  }
  tmp___11 = snoopy_util_syslog_convertFacilityToInt("LOCAL5");
  if (tmp___11 != 21 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"LOCAL5");
  }
  tmp___12 = snoopy_util_syslog_convertFacilityToInt("LOCAL6");
  if (tmp___12 != 22 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"LOCAL6");
  }
  tmp___13 = snoopy_util_syslog_convertFacilityToInt("LOCAL7");
  if (tmp___13 != 23 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"LOCAL7");
  }
  tmp___14 = snoopy_util_syslog_convertFacilityToInt("LPR");
  if (tmp___14 != 6 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"LPR");
  }
  tmp___15 = snoopy_util_syslog_convertFacilityToInt("MAIL");
  if (tmp___15 != 2 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"MAIL");
  }
  tmp___16 = snoopy_util_syslog_convertFacilityToInt("NEWS");
  if (tmp___16 != 7 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"NEWS");
  }
  tmp___17 = snoopy_util_syslog_convertFacilityToInt("SYSLOG");
  if (tmp___17 != 5 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"SYSLOG");
  }
  tmp___18 = snoopy_util_syslog_convertFacilityToInt("USER");
  if (tmp___18 != 1 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"USER");
  }
  tmp___19 = snoopy_util_syslog_convertFacilityToInt("UUCP");
  if (tmp___19 != 8 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"UUCP");
  }
  tmp___20 = snoopy_util_syslog_convertFacilityToInt("LOG_AUTH");
  if (tmp___20 != 4 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"LOG_AUTH");
  }
  tmp___21 = snoopy_util_syslog_convertFacilityToInt("LOG_AUTHPRIV");
  if (tmp___21 != 10 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"LOG_AUTHPRIV");
  }
  tmp___22 = snoopy_util_syslog_convertFacilityToInt("LOG_CRON");
  if (tmp___22 != 9 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"LOG_CRON");
  }
  tmp___23 = snoopy_util_syslog_convertFacilityToInt("LOG_DAEMON");
  if (tmp___23 != 3 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"LOG_DAEMON");
  }
  tmp___24 = snoopy_util_syslog_convertFacilityToInt("LOG_FTP");
  if (tmp___24 != 11 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"LOG_FTP");
  }
  tmp___25 = snoopy_util_syslog_convertFacilityToInt("LOG_KERN");
  if (tmp___25 != 0) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"LOG_KERN");
  }
  tmp___26 = snoopy_util_syslog_convertFacilityToInt("LOG_LOCAL0");
  if (tmp___26 != 16 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"LOG_LOCAL0");
  }
  tmp___27 = snoopy_util_syslog_convertFacilityToInt("LOG_LOCAL1");
  if (tmp___27 != 17 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"LOG_LOCAL1");
  }
  tmp___28 = snoopy_util_syslog_convertFacilityToInt("LOG_LOCAL2");
  if (tmp___28 != 18 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"LOG_LOCAL2");
  }
  tmp___29 = snoopy_util_syslog_convertFacilityToInt("LOG_LOCAL3");
  if (tmp___29 != 19 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"LOG_LOCAL3");
  }
  tmp___30 = snoopy_util_syslog_convertFacilityToInt("LOG_LOCAL4");
  if (tmp___30 != 20 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"LOG_LOCAL4");
  }
  tmp___31 = snoopy_util_syslog_convertFacilityToInt("LOG_LOCAL5");
  if (tmp___31 != 21 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"LOG_LOCAL5");
  }
  tmp___32 = snoopy_util_syslog_convertFacilityToInt("LOG_LOCAL6");
  if (tmp___32 != 22 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"LOG_LOCAL6");
  }
  tmp___33 = snoopy_util_syslog_convertFacilityToInt("LOG_LOCAL7");
  if (tmp___33 != 23 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"LOG_LOCAL7");
  }
  tmp___34 = snoopy_util_syslog_convertFacilityToInt("LOG_LPR");
  if (tmp___34 != 6 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"LOG_LPR");
  }
  tmp___35 = snoopy_util_syslog_convertFacilityToInt("LOG_MAIL");
  if (tmp___35 != 2 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"LOG_MAIL");
  }
  tmp___36 = snoopy_util_syslog_convertFacilityToInt("LOG_NEWS");
  if (tmp___36 != 7 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"LOG_NEWS");
  }
  tmp___37 = snoopy_util_syslog_convertFacilityToInt("LOG_SYSLOG");
  if (tmp___37 != 5 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"LOG_SYSLOG");
  }
  tmp___38 = snoopy_util_syslog_convertFacilityToInt("LOG_USER");
  if (tmp___38 != 1 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"LOG_USER");
  }
  tmp___39 = snoopy_util_syslog_convertFacilityToInt("LOG_UUCP");
  if (tmp___39 != 8 << 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility str to int",
                    (char const   * const  )"LOG_UUCP");
  }
  tmp___40 = snoopy_util_syslog_convertFacilityToStr(4 << 3);
  tmp___41 = strcmp(tmp___40, "AUTH");
  if (0 != tmp___41) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility int to str",
                    (char const   * const  )"AUTH");
  }
  tmp___42 = snoopy_util_syslog_convertFacilityToStr(10 << 3);
  tmp___43 = strcmp(tmp___42, "AUTHPRIV");
  if (0 != tmp___43) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility int to str",
                    (char const   * const  )"AUTHPRIV");
  }
  tmp___44 = snoopy_util_syslog_convertFacilityToStr(9 << 3);
  tmp___45 = strcmp(tmp___44, "CRON");
  if (0 != tmp___45) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility int to str",
                    (char const   * const  )"CRON");
  }
  tmp___46 = snoopy_util_syslog_convertFacilityToStr(3 << 3);
  tmp___47 = strcmp(tmp___46, "DAEMON");
  if (0 != tmp___47) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility int to str",
                    (char const   * const  )"DAEMON");
  }
  tmp___48 = snoopy_util_syslog_convertFacilityToStr(11 << 3);
  tmp___49 = strcmp(tmp___48, "FTP");
  if (0 != tmp___49) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility int to str",
                    (char const   * const  )"FTP");
  }
  tmp___50 = snoopy_util_syslog_convertFacilityToStr(0);
  tmp___51 = strcmp(tmp___50, "KERN");
  if (0 != tmp___51) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility int to str",
                    (char const   * const  )"KERN");
  }
  tmp___52 = snoopy_util_syslog_convertFacilityToStr(16 << 3);
  tmp___53 = strcmp(tmp___52, "LOCAL0");
  if (0 != tmp___53) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility int to str",
                    (char const   * const  )"LOCAL0");
  }
  tmp___54 = snoopy_util_syslog_convertFacilityToStr(17 << 3);
  tmp___55 = strcmp(tmp___54, "LOCAL1");
  if (0 != tmp___55) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility int to str",
                    (char const   * const  )"LOCAL1");
  }
  tmp___56 = snoopy_util_syslog_convertFacilityToStr(18 << 3);
  tmp___57 = strcmp(tmp___56, "LOCAL2");
  if (0 != tmp___57) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility int to str",
                    (char const   * const  )"LOCAL2");
  }
  tmp___58 = snoopy_util_syslog_convertFacilityToStr(19 << 3);
  tmp___59 = strcmp(tmp___58, "LOCAL3");
  if (0 != tmp___59) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility int to str",
                    (char const   * const  )"LOCAL3");
  }
  tmp___60 = snoopy_util_syslog_convertFacilityToStr(20 << 3);
  tmp___61 = strcmp(tmp___60, "LOCAL4");
  if (0 != tmp___61) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility int to str",
                    (char const   * const  )"LOCAL4");
  }
  tmp___62 = snoopy_util_syslog_convertFacilityToStr(21 << 3);
  tmp___63 = strcmp(tmp___62, "LOCAL5");
  if (0 != tmp___63) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility int to str",
                    (char const   * const  )"LOCAL5");
  }
  tmp___64 = snoopy_util_syslog_convertFacilityToStr(22 << 3);
  tmp___65 = strcmp(tmp___64, "LOCAL6");
  if (0 != tmp___65) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility int to str",
                    (char const   * const  )"LOCAL6");
  }
  tmp___66 = snoopy_util_syslog_convertFacilityToStr(23 << 3);
  tmp___67 = strcmp(tmp___66, "LOCAL7");
  if (0 != tmp___67) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility int to str",
                    (char const   * const  )"LOCAL7");
  }
  tmp___68 = snoopy_util_syslog_convertFacilityToStr(6 << 3);
  tmp___69 = strcmp(tmp___68, "LPR");
  if (0 != tmp___69) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility int to str",
                    (char const   * const  )"LPR");
  }
  tmp___70 = snoopy_util_syslog_convertFacilityToStr(2 << 3);
  tmp___71 = strcmp(tmp___70, "MAIL");
  if (0 != tmp___71) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility int to str",
                    (char const   * const  )"MAIL");
  }
  tmp___72 = snoopy_util_syslog_convertFacilityToStr(7 << 3);
  tmp___73 = strcmp(tmp___72, "NEWS");
  if (0 != tmp___73) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility int to str",
                    (char const   * const  )"NEWS");
  }
  tmp___74 = snoopy_util_syslog_convertFacilityToStr(5 << 3);
  tmp___75 = strcmp(tmp___74, "SYSLOG");
  if (0 != tmp___75) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility int to str",
                    (char const   * const  )"SYSLOG");
  }
  tmp___76 = snoopy_util_syslog_convertFacilityToStr(1 << 3);
  tmp___77 = strcmp(tmp___76, "USER");
  if (0 != tmp___77) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility int to str",
                    (char const   * const  )"USER");
  }
  tmp___78 = snoopy_util_syslog_convertFacilityToStr(8 << 3);
  tmp___79 = strcmp(tmp___78, "UUCP");
  if (0 != tmp___79) {
    fatalErrorValue((char const   * const  )"Error converting syslog facility int to str",
                    (char const   * const  )"UUCP");
  }
  tmp___80 = snoopy_util_syslog_convertLevelToInt("EMERG");
  if (tmp___80 != 0) {
    fatalErrorValue((char const   * const  )"Error converting syslog level str to int",
                    (char const   * const  )"EMERG");
  }
  tmp___81 = snoopy_util_syslog_convertLevelToInt("ALERT");
  if (tmp___81 != 1) {
    fatalErrorValue((char const   * const  )"Error converting syslog level str to int",
                    (char const   * const  )"ALERT");
  }
  tmp___82 = snoopy_util_syslog_convertLevelToInt("CRIT");
  if (tmp___82 != 2) {
    fatalErrorValue((char const   * const  )"Error converting syslog level str to int",
                    (char const   * const  )"CRIT");
  }
  tmp___83 = snoopy_util_syslog_convertLevelToInt("ERR");
  if (tmp___83 != 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog level str to int",
                    (char const   * const  )"ERR");
  }
  tmp___84 = snoopy_util_syslog_convertLevelToInt("WARNING");
  if (tmp___84 != 4) {
    fatalErrorValue((char const   * const  )"Error converting syslog level str to int",
                    (char const   * const  )"WARNING");
  }
  tmp___85 = snoopy_util_syslog_convertLevelToInt("NOTICE");
  if (tmp___85 != 5) {
    fatalErrorValue((char const   * const  )"Error converting syslog level str to int",
                    (char const   * const  )"NOTICE");
  }
  tmp___86 = snoopy_util_syslog_convertLevelToInt("INFO");
  if (tmp___86 != 6) {
    fatalErrorValue((char const   * const  )"Error converting syslog level str to int",
                    (char const   * const  )"INFO");
  }
  tmp___87 = snoopy_util_syslog_convertLevelToInt("DEBUG");
  if (tmp___87 != 7) {
    fatalErrorValue((char const   * const  )"Error converting syslog level str to int",
                    (char const   * const  )"DEBUG");
  }
  tmp___88 = snoopy_util_syslog_convertLevelToInt("LOG_EMERG");
  if (tmp___88 != 0) {
    fatalErrorValue((char const   * const  )"Error converting syslog level str to int",
                    (char const   * const  )"EMERG");
  }
  tmp___89 = snoopy_util_syslog_convertLevelToInt("LOG_ALERT");
  if (tmp___89 != 1) {
    fatalErrorValue((char const   * const  )"Error converting syslog level str to int",
                    (char const   * const  )"ALERT");
  }
  tmp___90 = snoopy_util_syslog_convertLevelToInt("LOG_CRIT");
  if (tmp___90 != 2) {
    fatalErrorValue((char const   * const  )"Error converting syslog level str to int",
                    (char const   * const  )"CRIT");
  }
  tmp___91 = snoopy_util_syslog_convertLevelToInt("LOG_ERR");
  if (tmp___91 != 3) {
    fatalErrorValue((char const   * const  )"Error converting syslog level str to int",
                    (char const   * const  )"ERR");
  }
  tmp___92 = snoopy_util_syslog_convertLevelToInt("LOG_WARNING");
  if (tmp___92 != 4) {
    fatalErrorValue((char const   * const  )"Error converting syslog level str to int",
                    (char const   * const  )"WARNING");
  }
  tmp___93 = snoopy_util_syslog_convertLevelToInt("LOG_NOTICE");
  if (tmp___93 != 5) {
    fatalErrorValue((char const   * const  )"Error converting syslog level str to int",
                    (char const   * const  )"NOTICE");
  }
  tmp___94 = snoopy_util_syslog_convertLevelToInt("LOG_INFO");
  if (tmp___94 != 6) {
    fatalErrorValue((char const   * const  )"Error converting syslog level str to int",
                    (char const   * const  )"INFO");
  }
  tmp___95 = snoopy_util_syslog_convertLevelToInt("LOG_DEBUG");
  if (tmp___95 != 7) {
    fatalErrorValue((char const   * const  )"Error converting syslog level str to int",
                    (char const   * const  )"DEBUG");
  }
  tmp___96 = snoopy_util_syslog_convertLevelToStr(0);
  tmp___97 = strcmp(tmp___96, "EMERG");
  if (0 != tmp___97) {
    fatalErrorValue((char const   * const  )"Error converting syslog level int to str",
                    (char const   * const  )"EMERG");
  }
  tmp___98 = snoopy_util_syslog_convertLevelToStr(1);
  tmp___99 = strcmp(tmp___98, "ALERT");
  if (0 != tmp___99) {
    fatalErrorValue((char const   * const  )"Error converting syslog level int to str",
                    (char const   * const  )"ALERT");
  }
  tmp___100 = snoopy_util_syslog_convertLevelToStr(2);
  tmp___101 = strcmp(tmp___100, "CRIT");
  if (0 != tmp___101) {
    fatalErrorValue((char const   * const  )"Error converting syslog level int to str",
                    (char const   * const  )"CRIT");
  }
  tmp___102 = snoopy_util_syslog_convertLevelToStr(3);
  tmp___103 = strcmp(tmp___102, "ERR");
  if (0 != tmp___103) {
    fatalErrorValue((char const   * const  )"Error converting syslog level int to str",
                    (char const   * const  )"ERR");
  }
  tmp___104 = snoopy_util_syslog_convertLevelToStr(4);
  tmp___105 = strcmp(tmp___104, "WARNING");
  if (0 != tmp___105) {
    fatalErrorValue((char const   * const  )"Error converting syslog level int to str",
                    (char const   * const  )"WARNING");
  }
  tmp___106 = snoopy_util_syslog_convertLevelToStr(5);
  tmp___107 = strcmp(tmp___106, "NOTICE");
  if (0 != tmp___107) {
    fatalErrorValue((char const   * const  )"Error converting syslog level int to str",
                    (char const   * const  )"NOTICE");
  }
  tmp___108 = snoopy_util_syslog_convertLevelToStr(6);
  tmp___109 = strcmp(tmp___108, "INFO");
  if (0 != tmp___109) {
    fatalErrorValue((char const   * const  )"Error converting syslog level int to str",
                    (char const   * const  )"INFO");
  }
  tmp___110 = snoopy_util_syslog_convertLevelToStr(7);
  tmp___111 = strcmp(tmp___110, "DEBUG");
  if (0 != tmp___111) {
    fatalErrorValue((char const   * const  )"Error converting syslog level int to str",
                    (char const   * const  )"DEBUG");
  }
  printSuccess((char const   * const  )"Mocking src/misc.c complete.");
  return (0);
}
}
#pragma merger("0","/tmp/cil-rwY2gemM.i","-Wall,-Werror,-Wextra,-Wno-unused-parameter,-std=c99,-Wpedantic,-fvisibility=hidden,-g,-O2")
int g_argc  ;
char **g_argv  ;
void snoopyTestCli_showHelp(void) 
{ 
  char *helpContent ;

  {
  helpContent = (char *)"Snoopy TEST SUITE CLI utility\n\nUsage:\n    snoopy ACTION [SUBACTION] [ARGS]\n\nAvailable actions:\n    run            Run Snoopy\'s subsystem\n    stress         Run stress tests\n    unit           Run unit tests\n\n    --help,-h      Show this help\n    ACTION --help  Show ACTION\'s help\n\n";
  printf((char const   * __restrict  )"%s", helpContent);
  return;
}
}
int main(int argc , char **argv ) 
{ 
  char const   *action ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  g_argc = argc;
  g_argv = argv;
  if (argc < 2) {
    snoopyTestCli_showHelp();
    fatalError((char const   * const  )"No action specified.");
  }
  action = (char const   *)*(argv + 1);
  tmp = strcmp(action, "--help");
  if (0 == tmp) {
    snoopyTestCli_showHelp();
    return (0);
  } else {
    tmp___0 = strcmp(action, "-h");
    if (0 == tmp___0) {
      snoopyTestCli_showHelp();
      return (0);
    }
  }
  tmp___2 = strcmp(action, "run");
  if (0 == tmp___2) {
    tmp___1 = snoopyTestCli_action_run(argc - 2, argv + 2);
    return (tmp___1);
  }
  tmp___4 = strcmp(action, "stress");
  if (0 == tmp___4) {
    tmp___3 = snoopyTestCli_action_stress(argc - 2, argv + 2);
    return (tmp___3);
  }
  tmp___6 = strcmp(action, "unit");
  if (0 == tmp___6) {
    tmp___5 = snoopyTestCli_action_unit(argc - 2, argv + 2);
    return (tmp___5);
  }
  snoopyTestCli_showHelp();
  fatalErrorValue((char const   * const  )"Unknown action", (char const   * const  )action);
  return (0);
}
}
#pragma merger("0","/tmp/cil-3j2Adaqx.i","-Wall,-Werror,-Wextra,-Wno-unused-parameter,-std=c99,-Wpedantic,-fvisibility=hidden,-g,-O2")
void printMessage(char const   * const  message ) ;
void printDiag(char const   * const  message ) ;
void printDiagValue(char const   * const  message , char const   * const  value ) ;
void printInfo(char const   * const  message ) ;
void printInfoValue(char const   * const  message , char const   * const  value ) ;
void printNotice(char const   * const  message ) ;
void printNoticeValue(char const   * const  message , char const   * const  value ) ;
void printWarning(char const   * const  message ) ;
void printWarningValue(char const   * const  message , char const   * const  value ) ;
void printError(char const   * const  message ) ;
void printErrorValue(char const   * const  message , char const   * const  value ) ;
char *libsnoopySo_getFilePath(void) ;
char *libsnoopySo_getFilePathNoCheck(void) ;
void libsnoopySo_load(void) ;
void *libsnoopySo_dlsym(char const   * const  functionName ) ;
char const   *etcLdSoPreload_getFilePath(void) ;
char *etcLdSoPreload_readFile(void) ;
void etcLdSoPreload_writeFile(char *newContent ) ;
char const   *etcLdSoPreload_findNonCommentLineContainingString(char const   *content ,
                                                                char const   *searchString ) ;
char const   *etcLdSoPreload_findEntry(char const   *content , char const   *entry ) ;
char const   *g_etcLdSoPreloadPath  ;
char const   *g_libsnoopySoPath  ;
void *g_libsnoopySoHandle  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) access)(char const   *__name ,
                                                                                   int __type ) ;
extern  __attribute__((__nothrow__)) void *dlopen(char const   *__file , int __mode ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(2))) dlsym)(void * __restrict  __handle ,
                                                                                    char const   * __restrict  __name ) ;
extern  __attribute__((__nothrow__)) char *dlerror(void) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
extern int fseek(FILE *__stream , long __off , int __whence ) ;
extern long ftell(FILE *__stream ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
void printMessage(char const   * const  message ) 
{ 


  {
  printf((char const   * __restrict  )"%s\n", message);
  return;
}
}
void printDiag(char const   * const  message ) 
{ 


  {
  printf((char const   * __restrict  )"[DIAG] %s\n", message);
  return;
}
}
void printDiagValue(char const   * const  message , char const   * const  value ) 
{ 


  {
  printf((char const   * __restrict  )"[DIAG] %s: %s\n", message, value);
  return;
}
}
void printInfo(char const   * const  message ) 
{ 


  {
  printf((char const   * __restrict  )"[INFO] %s\n", message);
  return;
}
}
void printInfoValue(char const   * const  message , char const   * const  value ) 
{ 


  {
  printf((char const   * __restrict  )"[INFO] %s: %s\n", message, value);
  return;
}
}
void printNotice(char const   * const  message ) 
{ 


  {
  printf((char const   * __restrict  )"[NOTICE] %s\n", message);
  return;
}
}
void printNoticeValue(char const   * const  message , char const   * const  value ) 
{ 


  {
  printf((char const   * __restrict  )"[NOTICE] %s: %s\n", message, value);
  return;
}
}
void printSuccess(char const   * const  message ) 
{ 


  {
  printf((char const   * __restrict  )"[SUCCESS] %s\n", message);
  return;
}
}
void printWarning(char const   * const  message ) 
{ 


  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[WARNING] %s\n",
          message);
  return;
}
}
void printWarningValue(char const   * const  message , char const   * const  value ) 
{ 


  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[WARNING] %s: %s\n",
          message, value);
  return;
}
}
void printError(char const   * const  message ) 
{ 


  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[ERROR] %s\n",
          message);
  return;
}
}
void printErrorValue(char const   * const  message , char const   * const  value ) 
{ 


  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[ERROR] %s: %s\n",
          message, value);
  return;
}
}
void fatalError(char const   * const  message ) 
{ 


  {
  printError(message);
  exit(127);
}
}
void fatalErrorValue(char const   * const  message , char const   * const  value ) 
{ 


  {
  printErrorValue(message, value);
  exit(127);
}
}
char *libsnoopySo_getFilePath(void) 
{ 
  char *filePath ;
  int tmp ;

  {
  filePath = libsnoopySo_getFilePathNoCheck();
  tmp = access((char const   *)filePath, 4);
  if (tmp != 0) {
    printDiagValue((char const   * const  )"libsnoopy.so path", (char const   * const  )filePath);
    fatalError((char const   * const  )"Unable to access libsnoopy.so file");
  }
  return (filePath);
}
}
char *libsnoopySo_getFilePathNoCheck(void) 
{ 
  char *filePath ;
  char *envValue ;

  {
  envValue = getenv("SNOOPY_TEST_LIBSNOOPY_SO_PATH");
  if ((unsigned long )envValue != (unsigned long )((void *)0)) {
    printWarningValue((char const   * const  )"Using non-default path to libsnoopy.so",
                      (char const   * const  )envValue);
    filePath = envValue;
  } else {
    filePath = (char *)"/usr/local/lib/libsnoopy.so";
  }
  return (filePath);
}
}
void libsnoopySo_load(void) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  tmp = libsnoopySo_getFilePath();
  g_libsnoopySoPath = (char const   *)tmp;
  g_libsnoopySoHandle = dlopen(g_libsnoopySoPath, 1);
  if (! g_libsnoopySoHandle) {
    tmp___0 = dlerror();
    printErrorValue((char const   * const  )"Dynamic linker error message", (char const   * const  )tmp___0);
    fatalError((char const   * const  )"Unable to load shared library");
  }
  dlerror();
  return;
}
}
void *libsnoopySo_dlsym(char const   * const  functionName ) 
{ 
  void *functionPtr ;
  char const   *error ;
  char *tmp ;

  {
  functionPtr = dlsym((void * __restrict  )g_libsnoopySoHandle, (char const   * __restrict  )functionName);
  tmp = dlerror();
  error = (char const   *)tmp;
  if ((unsigned long )error != (unsigned long )((void *)0)) {
    printDiagValue((char const   * const  )"libsnoopy.so path", (char const   * const  )g_libsnoopySoPath);
    fatalError((char const   * const  )error);
  }
  return (functionPtr);
}
}
char const   *etcLdSoPreload_getFilePath(void) 
{ 
  char const   *envValue ;
  char *tmp ;

  {
  envValue = (char const   *)((void *)0);
  tmp = getenv("SNOOPY_TEST_LD_SO_PRELOAD_PATH");
  envValue = (char const   *)tmp;
  if ((unsigned long )envValue != (unsigned long )((void *)0)) {
    printWarningValue((char const   * const  )"Using non-standard path to ld.so.preload",
                      (char const   * const  )envValue);
    return (envValue);
  } else {
    return ("/etc/ld.so.preload");
  }
}
}
char *etcLdSoPreload_readFile(void) 
{ 
  char const   *filePath ;
  int fileContentLen ;
  char *fileContentBuf ;
  FILE *fileHandle ;
  FILE *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  void *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  long freadRes ;
  size_t tmp___13 ;

  {
  fileContentBuf = (char *)0;
  filePath = etcLdSoPreload_getFilePath();
  tmp = fopen((char const   * __restrict  )filePath, (char const   * __restrict  )"r");
  fileHandle = tmp;
  if ((unsigned long )fileHandle == (unsigned long )((void *)0)) {
    tmp___3 = __errno_location();
    if (*tmp___3 == 2) {
      tmp___0 = malloc((size_t )1);
      fileContentBuf = (char *)tmp___0;
      *(fileContentBuf + 0) = (char )'\000';
      return (fileContentBuf);
    } else {
      printDiagValue((char const   * const  )"ld.so.preload path", (char const   * const  )filePath);
      tmp___1 = __errno_location();
      tmp___2 = strerror(*tmp___1);
      printDiagValue((char const   * const  )"Error message", (char const   * const  )tmp___2);
      fatalError((char const   * const  )"Unable to read ld.so.preload file.");
    }
  }
  tmp___6 = fseek(fileHandle, 0L, 2);
  if (tmp___6 != 0) {
    printDiagValue((char const   * const  )"ld.so.preload path", (char const   * const  )filePath);
    printDiagValue((char const   * const  )"function called", (char const   * const  )"fseek(fh, 0, SEEK_END)");
    tmp___4 = __errno_location();
    tmp___5 = strerror(*tmp___4);
    printDiagValue((char const   * const  )"Error message", (char const   * const  )tmp___5);
    fatalError((char const   * const  )"Unable to determine the size of the ld.so.preload file.");
  }
  tmp___7 = ftell(fileHandle);
  fileContentLen = (int )tmp___7;
  if (fileContentLen == -1) {
    printDiagValue((char const   * const  )"ld.so.preload path", (char const   * const  )filePath);
    printDiagValue((char const   * const  )"function called", (char const   * const  )"ftell(fh)");
    tmp___8 = __errno_location();
    tmp___9 = strerror(*tmp___8);
    printDiagValue((char const   * const  )"Error message", (char const   * const  )tmp___9);
    fatalError((char const   * const  )"Unable to determine the size of the ld.so.preload file.");
  }
  fseek(fileHandle, 0L, 0);
  tmp___10 = malloc((size_t )(fileContentLen + 1));
  fileContentBuf = (char *)tmp___10;
  if ((unsigned long )fileContentBuf == (unsigned long )((void *)0)) {
    printDiagValue((char const   * const  )"ld.so.preload path", (char const   * const  )filePath);
    tmp___11 = __errno_location();
    tmp___12 = strerror(*tmp___11);
    printDiagValue((char const   * const  )"Error message", (char const   * const  )tmp___12);
    fatalError((char const   * const  )"Unable to malloc() for reading the file content.");
  }
  if (fileContentLen == 0) {
    *(fileContentBuf + 0) = (char )'\000';
  } else {
    tmp___13 = fread((void * __restrict  )fileContentBuf, (size_t )1, (size_t )fileContentLen,
                     (FILE * __restrict  )fileHandle);
    freadRes = (long )tmp___13;
    if (freadRes < (long )fileContentLen) {
      *(fileContentBuf + freadRes) = (char )'\000';
      printDiagValue((char const   * const  )"ld.so.preload path", (char const   * const  )filePath);
      fatalError((char const   * const  )"Unable to read the whole content of the file.");
    } else {
      *(fileContentBuf + fileContentLen) = (char )'\000';
    }
  }
  fclose(fileHandle);
  g_etcLdSoPreloadPath = filePath;
  return (fileContentBuf);
}
}
void etcLdSoPreload_writeFile(char *newContent ) 
{ 
  char const   *filePath ;
  FILE *fileHandle ;
  FILE *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  filePath = etcLdSoPreload_getFilePath();
  tmp = fopen((char const   * __restrict  )filePath, (char const   * __restrict  )"w+");
  fileHandle = tmp;
  if ((unsigned long )fileHandle == (unsigned long )((void *)0)) {
    printDiagValue((char const   * const  )"ld.so.preload path", (char const   * const  )filePath);
    tmp___0 = __errno_location();
    tmp___1 = strerror(*tmp___0);
    printDiagValue((char const   * const  )"Error message", (char const   * const  )tmp___1);
    fatalError((char const   * const  )"Unable to open file for writing (missing sudo, maybe?).");
  }
  tmp___4 = fprintf((FILE * __restrict  )fileHandle, (char const   * __restrict  )"%s",
                    newContent);
  if (tmp___4 < 0) {
    printDiagValue((char const   * const  )"ld.so.preload path", (char const   * const  )filePath);
    tmp___2 = __errno_location();
    tmp___3 = strerror(*tmp___2);
    printDiagValue((char const   * const  )"Error message", (char const   * const  )tmp___3);
    fatalError((char const   * const  )"Unable to write to file.");
  }
  fclose(fileHandle);
  return;
}
}
char const   *etcLdSoPreload_findEntry(char const   *content , char const   *entry ) 
{ 
  char const   *contentPos ;
  char const   *entryPos ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;

  {
  contentPos = (char const   *)((void *)0);
  entryPos = (char const   *)((void *)0);
  contentPos = content;
  while (1) {
    tmp___5 = strstr(contentPos, entry);
    entryPos = (char const   *)tmp___5;
    if (! ((unsigned long )entryPos != (unsigned long )((void *)0))) {
      break;
    }
    if ((unsigned long )entryPos == (unsigned long )content) {
      goto _L;
    } else
    if ((unsigned long )entryPos > (unsigned long )content) {
      if ((int const   )*(entryPos + -1) == 10) {
        _L: /* CIL Label */ 
        tmp = strlen(entry);
        if ((int const   )*(entryPos + tmp) == 0) {
          return (entryPos);
        } else {
          tmp___0 = strlen(entry);
          if ((int const   )*(entryPos + tmp___0) == 10) {
            return (entryPos);
          } else {
            tmp___1 = strlen(entry);
            if ((int const   )*(entryPos + tmp___1) == 35) {
              return (entryPos);
            } else {
              tmp___2 = strlen(entry);
              if ((int const   )*(entryPos + tmp___2) == 32) {
                return (entryPos);
              } else {
                tmp___3 = strlen(entry);
                if ((int const   )*(entryPos + tmp___3) == 9) {
                  return (entryPos);
                }
              }
            }
          }
        }
      }
    }
    tmp___4 = strlen(entry);
    contentPos = entryPos + tmp___4;
  }
  return ((char const   *)((void *)0));
}
}
char const   *etcLdSoPreload_findNonCommentLineContainingString(char const   *content ,
                                                                char const   *searchString ) 
{ 
  char const   *contentPos ;
  char const   *foundStringPos ;
  char const   *lineStartPtr ;
  size_t tmp ;
  char *tmp___0 ;

  {
  contentPos = (char const   *)((void *)0);
  foundStringPos = (char const   *)((void *)0);
  lineStartPtr = (char const   *)((void *)0);
  contentPos = content;
  while (1) {
    tmp___0 = strstr(contentPos, searchString);
    foundStringPos = (char const   *)tmp___0;
    if (! ((unsigned long )foundStringPos != (unsigned long )((void *)0))) {
      break;
    }
    lineStartPtr = foundStringPos;
    while (1) {
      if ((unsigned long )lineStartPtr > (unsigned long )contentPos) {
        if (! ((int const   )*lineStartPtr != 10)) {
          break;
        }
      } else {
        break;
      }
      lineStartPtr --;
    }
    if ((int const   )*lineStartPtr == 10) {
      lineStartPtr ++;
    }
    if ((int const   )*lineStartPtr != 35) {
      return (lineStartPtr);
    }
    tmp = strlen(searchString);
    contentPos = foundStringPos + tmp;
  }
  return ((char const   *)((void *)0));
}
}
#pragma merger("0","/tmp/cil-qLHzF6Bz.i","-Wall,-Werror,-Wextra,-Wno-unused-parameter,-std=c99,-Wpedantic,-fvisibility=hidden,-g,-O2")
void displayHelp(void) 
{ 


  {
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"Usage: \n");
  printf((char const   * __restrict  )"    snoopy-test-configfile PATH-TO-INI CONFIG-VARIABLE-TO-DISPLAY\n");
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"Available configfile variables:\n");
  printf((char const   * __restrict  )"    (check etc/snoopy.ini for list of supported configuration variables)\n");
  printf((char const   * __restrict  )"\n");
  return;
}
}
void snoopyTestCli_action_run_configfile_showHelp(void) 
{ 
  char *helpContent ;

  {
  helpContent = (char *)"Snoopy TEST SUITE CLI utility :: Action `run` :: Subsystem `configfile`\n\nUsage:\n    snoopy-test run configfile INI_FILE KEY\n\nResult:\n    Prints value of the requested configuration KEY from the given INI_FILE.\n\nSupported configuration keys (check etc/snoopy.ini for more information):\n    message_format\n    filter_chain\n    output\n    syslog_facility\n    syslog_ident\n    syslog_level\nNOTICE: These keys MUST be placed in a section named [snoopy].\n\n";
  printf((char const   * __restrict  )"%s", helpContent);
  return;
}
}
int snoopyTestCli_action_run_configfile(int argc , char **argv ) 
{ 
  char *iniFilePath ;
  char const   *showConfigVar ;
  snoopy_configuration_t *CFG ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  if (argc < 1) {
    snoopyTestCli_action_run_configfile_showHelp();
    fatalError((char const   * const  )"Missing argument: path to INI config file");
  }
  tmp = strcmp((char const   *)*(argv + 0), "--help");
  if (0 == tmp) {
    snoopyTestCli_action_run_configfile_showHelp();
    return (0);
  }
  iniFilePath = *(argv + 0);
  if (argc < 2) {
    snoopyTestCli_action_run_configfile_showHelp();
    fatalError((char const   * const  )"Missing argument: configuration variable to display");
  }
  showConfigVar = (char const   *)*(argv + 1);
  tmp___2 = access((char const   *)iniFilePath, 4);
  if (-1 == tmp___2) {
    snoopyTestCli_action_run_configfile_showHelp();
    printErrorValue((char const   * const  )"INI file path", (char const   * const  )iniFilePath);
    tmp___0 = __errno_location();
    tmp___1 = strerror(*tmp___0);
    fatalErrorValue((char const   * const  )"Unable to open/read given INI file",
                    (char const   * const  )tmp___1);
  }
  snoopy_entrypoint_test_cli_init((char const   *)*(g_argv + 0), (char * const  *)g_argv,
                                  (char * const  )iniFilePath);
  CFG = snoopy_configuration_get();
  tmp___12 = strcmp(showConfigVar, "message_format");
  if (0 == tmp___12) {
    printf((char const   * __restrict  )"%s\n", CFG->message_format);
  } else {
    tmp___11 = strcmp(showConfigVar, "filter_chain");
    if (0 == tmp___11) {
      printf((char const   * __restrict  )"%s\n", CFG->filter_chain);
    } else {
      tmp___10 = strcmp(showConfigVar, "output");
      if (0 == tmp___10) {
        printf((char const   * __restrict  )"%s", CFG->output);
        if (0 != (int )*(CFG->output_arg + 0)) {
          printf((char const   * __restrict  )":%s", CFG->output_arg);
        }
        printf((char const   * __restrict  )"\n");
      } else {
        tmp___9 = strcmp(showConfigVar, "syslog_facility");
        if (0 == tmp___9) {
          tmp___3 = snoopy_util_syslog_convertFacilityToStr(CFG->syslog_facility);
          printf((char const   * __restrict  )"%s\n", tmp___3);
        } else {
          tmp___8 = strcmp(showConfigVar, "syslog_ident");
          if (0 == tmp___8) {
            printf((char const   * __restrict  )"%s\n", CFG->syslog_ident_format);
          } else {
            tmp___7 = strcmp(showConfigVar, "syslog_level");
            if (0 == tmp___7) {
              tmp___4 = snoopy_util_syslog_convertLevelToStr(CFG->syslog_level);
              printf((char const   * __restrict  )"%s\n", tmp___4);
            } else {
              tmp___6 = strcmp(showConfigVar, "error_logging");
              if (0 == tmp___6) {
                if (CFG->error_logging_enabled == 1) {
                  tmp___5 = "y";
                } else {
                  tmp___5 = "n";
                }
                printf((char const   * __restrict  )"%s\n", tmp___5);
              } else {
                fatalErrorValue((char const   * const  )"Unknown setting given", (char const   * const  )showConfigVar);
              }
            }
          }
        }
      }
    }
  }
  snoopy_entrypoint_test_cli_exit();
  return (0);
}
}
#pragma merger("0","/tmp/cil-8EdgJTSd.i","-Wall,-Werror,-Wextra,-Wno-unused-parameter,-std=c99,-Wpedantic,-fvisibility=hidden,-g,-O2")
extern int __attribute__((__visibility__("default")))  snoopy_ini_parse_string(char const   *string ,
                                                                               int (*handler)(void *user ,
                                                                                              char const   *section ,
                                                                                              char const   *name ,
                                                                                              char const   *value ) ,
                                                                               void *user ) ;
void snoopyTestCli_action_unit_ext_ini_showHelp(void) 
{ 
  char *helpContent ;

  {
  helpContent = (char *)"Snoopy TEST SUITE CLI utility :: Action `unit` :: Unit `ext-ini`\n\nDescription:\n    Mocks external ini implementation code paths (mainly for the code coverage of parts not used by Snoopy).\n\nUsage:\n    snoopy-test unit ext-ini\n    snoopy-test unit ext-ini --help\n\n";
  printf((char const   * __restrict  )"%s", helpContent);
  return;
}
}
int snoopyTestCli_action_unit_ext_ini_parserCallback(void *userPtr , char const   *section ,
                                                     char const   *name , char const   *value ) 
{ 
  char const   **errorMessage ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  errorMessage = (char const   **)userPtr;
  if ((unsigned long )*errorMessage != (unsigned long )((void *)0)) {
    return (1);
  }
  tmp = strcmp(section, "sectionName");
  if (0 != tmp) {
    *errorMessage = "Unexpected section";
    return (1);
  }
  tmp___0 = strcmp(name, "testKey");
  if (0 != tmp___0) {
    *errorMessage = "Unexpected key";
    return (1);
  }
  tmp___1 = strcmp(value, "testVal");
  if (0 != tmp___1) {
    *errorMessage = "Unexpected value";
    return (1);
  }
  return (1);
}
}
int snoopyTestCli_action_unit_ext_ini(int argc , char **argv ) 
{ 
  char const   *arg1 ;
  int tmp ;
  char const   *iniContent ;
  char const   *errorMessage ;
  int parserStatus ;
  int __attribute__((__visibility__("default")))  tmp___0 ;

  {
  snoopy_entrypoint_test_cli_init((char const   *)*(g_argv + 0), (char * const  *)g_argv,
                                  (char * const  )((void *)0));
  if (argc > 0) {
    arg1 = (char const   *)*(argv + 0);
  } else {
    arg1 = "";
  }
  tmp = strcmp(arg1, "--help");
  if (0 == tmp) {
    snoopyTestCli_action_unit_ext_ini_showHelp();
    return (0);
  }
  iniContent = "[sectionName]\ntestKey=testVal\n";
  errorMessage = (char const   *)((void *)0);
  parserStatus = 0;
  tmp___0 = snoopy_ini_parse_string(iniContent, & snoopyTestCli_action_unit_ext_ini_parserCallback,
                                    (void *)(& errorMessage));
  parserStatus = (int )tmp___0;
  if (parserStatus < 0) {
    fatalError((char const   * const  )"INI parsing failed");
  }
  if ((unsigned long )errorMessage != (unsigned long )((void *)0)) {
    fatalErrorValue((char const   * const  )"INI parsing failure", (char const   * const  )errorMessage);
  }
  printSuccess((char const   * const  )"Mocking lib/inih/src/ini.c complete.");
  snoopy_entrypoint_test_cli_exit();
  return (0);
}
}
#pragma merger("0","/tmp/cil-fkYKq6cG.i","-Wall,-Werror,-Wextra,-Wno-unused-parameter,-std=c99,-Wpedantic,-fvisibility=hidden,-g,-O2")
extern int snoopy_filterregistry_getCount() ;
extern int snoopy_filterregistry_doesNameExist(char const   * const  filterName ) ;
extern char *snoopy_filterregistry_getName(int filterId ) ;
extern int snoopy_filterregistry_callById(int filterId , char const   * const  filterArg ) ;
extern int snoopy_filterregistry_callByName(char const   * const  filterName , char const   * const  filterArg ) ;
void snoopyTestCli_action_run_filter_showList(void) 
{ 
  int fCount ;
  int tmp ;
  int i ;
  char *tmp___0 ;

  {
  printf((char const   * __restrict  )"Available filters:\n");
  tmp = snoopy_filterregistry_getCount();
  fCount = tmp;
  i = 0;
  while (i < fCount) {
    tmp___0 = snoopy_filterregistry_getName(i);
    printf((char const   * __restrict  )"    %s\n", tmp___0);
    i ++;
  }
  return;
}
}
void snoopyTestCli_action_run_filter_showHelp(void) 
{ 
  char *helpContent ;

  {
  helpContent = (char *)"Snoopy TEST SUITE CLI utility :: Action `run` :: Subsystem `filter`\n\nUsage:\n    snoopy-test run filter FILTER [FILTER_ARGS]\n    snoopy-test run filter --all\n    snoopy-test run filter --list\n    snoopy-test run filter --help\n\nResult:\n    Prints the result of a called filter as a \"PASS\" or a \"DROP\" to stdout.\n    Sets the exit status to 0 or PASS or 1 for DROP.\n\n";
  printf((char const   * __restrict  )"%s", helpContent);
  snoopyTestCli_action_run_filter_showList();
  return;
}
}
int snoopyTestCli_action_run_filter(int argc , char **argv ) 
{ 
  char const   *arg1 ;
  char const   *filterName ;
  char const   *filterArg ;
  int filterResult ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  snoopy_entrypoint_test_cli_init((char const   *)*(g_argv + 0), (char * const  *)g_argv,
                                  (char * const  )((void *)0));
  if (argc < 1) {
    snoopyTestCli_action_run_filter_showHelp();
    fatalError((char const   * const  )"Missing argument: filter name, or --all, or --list, or --help");
  }
  arg1 = (char const   *)*(argv + 0);
  tmp = strcmp(arg1, "--all");
  if (0 == tmp) {
    snoopyTestCli_action_run_filter_all();
    return (0);
  }
  tmp___0 = strcmp(arg1, "--help");
  if (0 == tmp___0) {
    snoopyTestCli_action_run_filter_showHelp();
    return (0);
  }
  tmp___1 = strcmp(arg1, "--list");
  if (0 == tmp___1) {
    snoopyTestCli_action_run_filter_showList();
    return (0);
  }
  filterName = arg1;
  if (argc > 1) {
    filterArg = (char const   *)*(argv + 1);
  } else {
    filterArg = "";
  }
  tmp___2 = snoopy_filterregistry_doesNameExist((char const   * const  )filterName);
  if (0 == tmp___2) {
    snoopyTestCli_action_run_filter_showHelp();
    fatalErrorValue((char const   * const  )"Invalid filter name given", (char const   * const  )filterName);
  }
  filterResult = snoopy_filterregistry_callByName((char const   * const  )filterName,
                                                  (char const   * const  )filterArg);
  snoopy_entrypoint_test_cli_exit();
  if (1 == filterResult) {
    printf((char const   * __restrict  )"PASS\n");
    return (0);
  } else {
    printf((char const   * __restrict  )"DROP\n");
    return (1);
  }
}
}
void snoopyTestCli_action_run_filter_all(void) 
{ 
  char *itemName ;
  char const   *itemArgs ;
  int itemResult ;
  int fCount ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  itemName = (char *)((void *)0);
  itemArgs = (char const   *)((void *)0);
  fCount = snoopy_filterregistry_getCount();
  i = 0;
  while (i < fCount) {
    itemName = snoopy_filterregistry_getName(i);
    printf((char const   * __restrict  )"Filter %19s: ", itemName);
    tmp___2 = strcmp((char const   *)itemName, "exclude_spawns_of");
    if (tmp___2 == 0) {
      itemArgs = "asdf,bsdf";
    } else {
      tmp___1 = strcmp((char const   *)itemName, "exclude_uid");
      if (tmp___1 == 0) {
        itemArgs = "0";
      } else {
        tmp___0 = strcmp((char const   *)itemName, "only_root");
        if (tmp___0 == 0) {
          itemArgs = "";
        } else {
          tmp = strcmp((char const   *)itemName, "only_uid");
          if (tmp == 0) {
            itemArgs = "0";
          } else {
            itemArgs = "";
          }
        }
      }
    }
    itemResult = snoopy_filterregistry_callById(i, (char const   * const  )itemArgs);
    if (1 == itemResult) {
      printf((char const   * __restrict  )"PASS");
    } else {
      printf((char const   * __restrict  )"DROP");
    }
    printf((char const   * __restrict  )"\n");
    i ++;
  }
  return;
}
}
#pragma merger("0","/tmp/cil-U5kbaxvZ.i","-Wall,-Werror,-Wextra,-Wno-unused-parameter,-std=c99,-Wpedantic,-fvisibility=hidden,-g,-O2")
void snoopyTestCli_action_run_filterchain_showHelp(void) 
{ 
  char *helpContent ;

  {
  helpContent = (char *)"Snoopy TEST SUITE CLI utility :: Action `run` :: Subsystem `filterchain`\n\nUsage:\n    snoopy-test run filterchain \"FILTER_CHAIN\"\n    snoopy-test run filterchain --help\n\nDescription:\n    Runs MESSAGE through a specified FILTER_CHAIN, with filters acting on the data taken from the current process.\n    Filter chain specification format is described in the comments of snoopy.ini.\n\nResult:\n    Prints the result of a filter chain as a \"PASS\" or a \"DROP\" to stdout.\n    Sets the exit status to 0 or PASS or 1 for DROP.\n\n";
  printf((char const   * __restrict  )"%s", helpContent);
  return;
}
}
int snoopyTestCli_action_run_filterchain(int argc , char **argv ) 
{ 
  char const   *arg1 ;
  char const   *filterChain ;
  int filterResult ;
  int tmp ;

  {
  snoopy_entrypoint_test_cli_init((char const   *)*(g_argv + 0), (char * const  *)g_argv,
                                  (char * const  )((void *)0));
  if (argc < 1) {
    snoopyTestCli_action_run_filterchain_showHelp();
    fatalError((char const   * const  )"Missing argument: filter chain specification, or --help");
  }
  arg1 = (char const   *)*(argv + 0);
  tmp = strcmp(arg1, "--help");
  if (0 == tmp) {
    snoopyTestCli_action_run_filterchain_showHelp();
    return (0);
  }
  filterChain = arg1;
  if (argc < 1) {
    snoopyTestCli_action_run_filterchain_showHelp();
    fatalError((char const   * const  )"Missing argument: filter chain specification");
  }
  filterResult = snoopy_filtering_check_chain((char const   * const  )filterChain);
  snoopy_entrypoint_test_cli_exit();
  if (1 == filterResult) {
    printf((char const   * __restrict  )"PASS\n");
    return (0);
  } else {
    printf((char const   * __restrict  )"DROP\n");
    return (1);
  }
}
}
#pragma merger("0","/tmp/cil-gRZEO_71.i","-Wall,-Werror,-Wextra,-Wno-unused-parameter,-std=c99,-Wpedantic,-fvisibility=hidden,-g,-O2")
extern int snoopy_filterregistry_doesIdExist(int filterId ) ;
extern int snoopy_filterregistry_getIdFromName(char const   * const  filterName ) ;
void snoopyTestCli_action_unit_filterregistry_showHelp(void) 
{ 
  char *helpContent ;

  {
  helpContent = (char *)"Snoopy TEST SUITE CLI utility :: Action `unit` :: Unit `filterregistry`\n\nDescription:\n    Mocks filterregistry implementation code paths (mainly for the coverage of code parts/paths not covered by the test suite).\n\nUsage:\n    snoopy-test unit filterregistry\n    snoopy-test unit filterregistry --help\n\n";
  printf((char const   * __restrict  )"%s", helpContent);
  return;
}
}
int snoopyTestCli_action_unit_filterregistry(int argc , char **argv ) 
{ 
  char const   *arg1 ;
  int tmp ;
  char const   *filterName ;
  int filterCount ;
  int filterIdPreset ;
  int filterIdReceived ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if (argc > 0) {
    arg1 = (char const   *)*(argv + 0);
  } else {
    arg1 = "";
  }
  tmp = strcmp(arg1, "--help");
  if (0 == tmp) {
    snoopyTestCli_action_unit_filterregistry_showHelp();
    return (0);
  }
  filterName = (char const   *)((void *)0);
  filterCount = 0;
  filterIdPreset = 0;
  filterIdReceived = 0;
  filterCount = snoopy_filterregistry_getCount();
  if (filterCount < 1) {
    fatalError((char const   * const  )"No filters available, filter count is 0");
  }
  printf((char const   * __restrict  )"[DEBUG] Number of filters available: %d\n",
         filterCount);
  tmp___0 = snoopy_filterregistry_doesIdExist(filterIdPreset);
  if (tmp___0 != 1) {
    fatalError((char const   * const  )"Filter with a preset ID (0) does not exist");
  }
  tmp___1 = snoopy_filterregistry_getName(filterIdPreset);
  filterName = (char const   *)tmp___1;
  filterIdReceived = snoopy_filterregistry_getIdFromName((char const   * const  )filterName);
  if (filterIdPreset != filterIdReceived) {
    fatalError((char const   * const  )"Filter ID returned when searching by name differs from the initially used ID to find that same filter");
  }
  filterName = "noop";
  filterIdReceived = snoopy_filterregistry_getIdFromName((char const   * const  )filterName);
  snoopy_filterregistry_callById(filterIdReceived, (char const   * const  )"");
  tmp___2 = snoopy_filterregistry_callById(-1, (char const   * const  )"");
  if (-1 != tmp___2) {
    fatalError((char const   * const  )"Filter ID -1 unexpectedly exists");
  }
  tmp___3 = snoopy_filterregistry_callByName((char const   * const  )"fakeFilterNameThatShouldNeverExist",
                                             (char const   * const  )"");
  if (-1 != tmp___3) {
    fatalError((char const   * const  )"Filter with an unexpected name actually exists");
  }
  printSuccess((char const   * const  )"Mocking src/filterregistry.c complete.");
  return (0);
}
}
#pragma merger("0","/tmp/cil-m98L8OYI.i","-Wall,-Werror,-Wextra,-Wno-unused-parameter,-std=c99,-Wpedantic,-fvisibility=hidden,-g,-O2")
extern int close(int __fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern void snoopy_entrypoint_test_cli_threads_init() ;
extern void snoopy_configuration_preinit_disableConfigFileParsing() ;
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
extern  __attribute__((__nothrow__)) pthread_t pthread_self(void)  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                     pthread_t __thread2 ) 
{ 


  {
  return (__thread1 == __thread2);
}
}
extern int snoopy_tsrm_get_threadCount() ;
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
void *snoopyTestCli_action_stress_threads_threadMain(void *args ) ;
int snoopyTestCli_action_stress_threads_randomNumberInclusive(int nMin , int nMax ) ;
pthread_t snoopyTestCli_action_stress_threads_tRepo[10000]  ;
pthread_mutex_t threadCountMutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
int threadCountCreated  =    0;
int threadCountAliveNow  =    0;
int threadCountAliveMax  =    0;
int verbose  ;
void snoopyTestCli_action_stress_threads_showHelp(void) 
{ 
  char *helpContent ;

  {
  helpContent = (char *)"Snoopy TEST SUITE CLI utility :: Action `stress` :: Subsystem `threads`\n\nUsage:\n    snoopy-test stress threads THREAD_COUNT [-v]\n\nDescription:\n    Stresses Snoopy\'s threading implementation by creating and destroying THREAD_COUNT\n    threads as fast as possible.\n\nArguments:\n    THREAD_COUNT       Number of threads to create and destroy\n    -v                 Verbose debugging output\n\nOutput:\n    Various threading-related messages and some statistics at the end.\n\n";
  printf((char const   * __restrict  )"%s", helpContent);
  return;
}
}
int snoopyTestCli_action_stress_threads(int argc , char **argv ) 
{ 
  int threadsToCreate ;
  int maxConcurrentThreadsObserved ;
  int retVal ;
  int tmp ;
  int i ;
  tData_t *tArgs ;
  void *tmp___0 ;
  struct timespec ts_sleep ;
  int tmp___1 ;
  int i___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  maxConcurrentThreadsObserved = 0;
  retVal = 0;
  if (argc < 1) {
    snoopyTestCli_action_stress_threads_showHelp();
    fatalError((char const   * const  )"Missing argument: number of threads to create");
  }
  threadsToCreate = atoi((char const   *)*(argv + 0));
  if (threadsToCreate < 1) {
    snoopyTestCli_action_stress_threads_showHelp();
    fatalError((char const   * const  )"Invalid number of threads to create (min 1, max THREAD_COUNT_MAX)");
  } else
  if (threadsToCreate > 10000) {
    snoopyTestCli_action_stress_threads_showHelp();
    fatalError((char const   * const  )"Invalid number of threads to create (min 1, max THREAD_COUNT_MAX)");
  }
  if (argc >= 2) {
    tmp = strcmp((char const   *)*(argv + 1), "-v");
    if (0 == tmp) {
      verbose = 1;
    } else {
      verbose = 0;
    }
  } else {
    verbose = 0;
  }
  snoopy_configuration_preinit_disableConfigFileParsing();
  printf((char const   * __restrict  )"M: Starting threads... ");
  i = 0;
  while (i < threadsToCreate) {
    tmp___0 = malloc(sizeof(*tArgs));
    tArgs = (tData_t *)tmp___0;
    tArgs->seqNr = i;
    if (verbose) {
      printf((char const   * __restrict  )" M: Starting thread #%d:\n", i + 1);
    }
    retVal = pthread_create((pthread_t * __restrict  )(& snoopyTestCli_action_stress_threads_tRepo[i]),
                            (pthread_attr_t const   * __restrict  )((void *)0), & snoopyTestCli_action_stress_threads_threadMain,
                            (void * __restrict  )tArgs);
    i ++;
  }
  printf((char const   * __restrict  )"done.\n");
  printf((char const   * __restrict  )"M: Threads alive right after thread creation was completed: %d\n",
         threadCountAliveNow);
  if (verbose) {
    ts_sleep.tv_sec = (__time_t )0;
    ts_sleep.tv_nsec = (__syscall_slong_t )200000000;
    nanosleep((struct timespec  const  *)(& ts_sleep), (struct timespec *)((void *)0));
    maxConcurrentThreadsObserved = snoopy_tsrm_get_threadCount();
    printf((char const   * __restrict  )"M: Threads after first sleep: %d\n", maxConcurrentThreadsObserved);
    nanosleep((struct timespec  const  *)(& ts_sleep), (struct timespec *)((void *)0));
    tmp___1 = snoopy_tsrm_get_threadCount();
    printf((char const   * __restrict  )"M: Threads after all threads are supposedly finished: %d\n",
           tmp___1);
  }
  printf((char const   * __restrict  )"M: Waiting for all threads to finish... ");
  i___0 = 0;
  while (i___0 < threadsToCreate) {
    pthread_join(snoopyTestCli_action_stress_threads_tRepo[i___0], (void **)((void *)0));
    if (verbose) {
      printf((char const   * __restrict  )"M: Thread joined: #%d\n", i___0 + 1);
      printf((char const   * __restrict  )" M: Thread #%d joined.\n", i___0 + 1);
    }
    i___0 ++;
  }
  printf((char const   * __restrict  )"done.\n");
  printf((char const   * __restrict  )"M: Number of threads created:        %d\n",
         threadCountCreated);
  printf((char const   * __restrict  )"M: Max threads alive simultaneously: %d\n",
         threadCountAliveMax);
  if (verbose) {
    tmp___2 = snoopy_tsrm_get_threadCount();
    printf((char const   * __restrict  )"M: Threads after all threads, except main, have finished: %d\n",
           tmp___2);
  }
  if (verbose) {
    tmp___3 = snoopy_tsrm_get_threadCount();
    printf((char const   * __restrict  )"M: Threads after all threads have finished: %d\n",
           tmp___3);
  }
  if (verbose) {
    printf((char const   * __restrict  )"SUCCESS! Expected Snoopy threads count reached: %d\n",
           maxConcurrentThreadsObserved);
  }
  return (retVal);
}
}
void *snoopyTestCli_action_stress_threads_threadMain(void *args ) 
{ 
  tData_t *tArgs ;
  int seqNr ;
  int seqNrPub ;
  int dsCount ;
  int dsId ;
  char *dsName ;
  char const   *dsArg ;
  char dsResult[2048] ;
  int retVal ;
  pthread_t tmp ;
  int tmp___0 ;
  pthread_t tmp___1 ;
  int tmp___2 ;
  pthread_t tmp___3 ;
  pthread_t tmp___4 ;
  pthread_t tmp___5 ;
  int tmp___6 ;
  pthread_t tmp___7 ;
  int tmp___8 ;
  pthread_t tmp___9 ;
  pthread_t tmp___10 ;

  {
  tArgs = (tData_t *)args;
  seqNr = tArgs->seqNr;
  seqNrPub = seqNr + 1;
  dsArg = "";
  pthread_mutex_lock(& threadCountMutex);
  threadCountCreated ++;
  threadCountAliveNow ++;
  if (threadCountAliveNow > threadCountAliveMax) {
    threadCountAliveMax = threadCountAliveNow;
  }
  pthread_mutex_unlock(& threadCountMutex);
  if (verbose) {
    tmp = pthread_self();
    printf((char const   * __restrict  )"    t%d %llu : Hello from thread #%d\n",
           seqNrPub, (unsigned long long )tmp, seqNrPub);
  }
  if (verbose) {
    tmp___0 = snoopy_tsrm_get_threadCount();
    tmp___1 = pthread_self();
    printf((char const   * __restrict  )"    t%d %llu : Threads before snoopy_init():    %d\n",
           seqNrPub, (unsigned long long )tmp___1, tmp___0);
  }
  snoopy_entrypoint_test_cli_threads_init();
  if (verbose) {
    tmp___2 = snoopy_tsrm_get_threadCount();
    tmp___3 = pthread_self();
    printf((char const   * __restrict  )"    t%d %llu : Threads after  snoopy_init():    %d\n",
           seqNrPub, (unsigned long long )tmp___3, tmp___2);
  }
  dsCount = snoopy_datasourceregistry_getCount();
  dsId = snoopyTestCli_action_stress_threads_randomNumberInclusive(0, dsCount - 1);
  dsName = snoopy_datasourceregistry_getName(dsId);
  retVal = snoopy_datasourceregistry_callById(dsId, (char * const  )(dsResult), (char const   * const  )dsArg);
  if (0 > retVal) {
    tmp___4 = pthread_self();
    printf((char const   * __restrict  )"    t%d %llu : Datasource %s returned negative result: %d\n",
           seqNrPub, (unsigned long long )tmp___4, dsName, retVal);
  } else {
    tmp___5 = pthread_self();
    printf((char const   * __restrict  )"    t%d %llu : DS result: %30s = %s\n", seqNrPub,
           (unsigned long long )tmp___5, dsName, dsResult);
  }
  if (verbose) {
    tmp___6 = snoopy_tsrm_get_threadCount();
    tmp___7 = pthread_self();
    printf((char const   * __restrict  )"    t%d %llu : Threads before snoopy_cleanup(): %d\n",
           seqNrPub, (unsigned long long )tmp___7, tmp___6);
  }
  snoopy_entrypoint_test_cli_exit();
  if (verbose) {
    tmp___8 = snoopy_tsrm_get_threadCount();
    tmp___9 = pthread_self();
    printf((char const   * __restrict  )"    t%d %llu : Threads after  snoopy_cleanup(): %d\n",
           seqNrPub, (unsigned long long )tmp___9, tmp___8);
  }
  if (verbose) {
    tmp___10 = pthread_self();
    printf((char const   * __restrict  )"    t%d %llu : Thread exiting: #%d\n", seqNrPub,
           (unsigned long long )tmp___10, seqNrPub);
  }
  pthread_mutex_lock(& threadCountMutex);
  threadCountAliveNow --;
  pthread_mutex_unlock(& threadCountMutex);
  free((void *)tArgs);
  return ((void *)0);
}
}
int snoopyTestCli_action_stress_threads_randomNumberInclusive(int nMin , int nMax ) 
{ 
  int randomNrRaw ;
  int randomNr ;
  ssize_t bytesRead ;
  unsigned char buffer[sizeof(randomNrRaw)] ;
  int fd ;
  int tmp ;
  unsigned int i ;

  {
  randomNrRaw = 0;
  bytesRead = (ssize_t )0;
  tmp = open("/dev/urandom", 0);
  fd = tmp;
  if (-1 == fd) {
    printf((char const   * __restrict  )"ERROR: Unable to open /dev/urandom.\n");
    return (-1);
  }
  bytesRead = read(fd, (void *)(buffer), sizeof(randomNrRaw));
  close(fd);
  if ((unsigned long )bytesRead != sizeof(randomNrRaw)) {
    printf((char const   * __restrict  )"ERROR: Unable to read %lu bytes from /dev/urandom, only got %li bytes.\n",
           sizeof(randomNrRaw), bytesRead);
    return (-1);
  }
  i = 0U;
  while ((unsigned long )i < sizeof(randomNrRaw)) {
    randomNrRaw += (int )buffer[i] << i * 8U;
    i ++;
  }
  if (randomNrRaw < 0) {
    randomNrRaw = - randomNrRaw;
  }
  randomNr = randomNrRaw % ((nMax - nMin) + 1) + nMin;
  return (randomNr);
}
}
#pragma merger("0","/tmp/cil-4S2mZhQy.i","-Wall,-Werror,-Wextra,-Wno-unused-parameter,-std=c99,-Wpedantic,-fvisibility=hidden,-g,-O2")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) execv)(char const   *__path ,
                                                                                    char * const  *__argv ) ;
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
void *snoopyTestCli_action_stress_threadsexec_threadMain(void *args ) ;
char **snoopyTestCli_action_stress_threadsexec_runCmdAndArgv  ;
pthread_t snoopyTestCli_action_stress_threadsexec_tRepo[10000]  ;
void snoopyTestCli_action_stress_threadsexec_showHelp(void) 
{ 
  char *helpContent ;

  {
  helpContent = (char *)"Snoopy TEST SUITE CLI utility :: Action `stress` :: Subsystem `threadsexec`\n\nUsage:\n    snoopy-test stress threadsexec THREAD_COUNT CMD [CMD_ARGS]\n\nDescription:\n    Stresses Snoopy\'s threading implementation by creating and destroying THREAD_COUNT\n    threads as fast as possible and executing CMD from those threads.\n\nArguments:\n    THREAD_COUNT       Number of threads to create and destroy\n    CMD                External command to execute from each newly created thread\n    [CMD_ARGS]         Optional argument(s) for the external command\n\nOutput:\n    Various threading-related messages are shown, followed by a word \"SUCCESS!\".\n\n";
  printf((char const   * __restrict  )"%s", helpContent);
  return;
}
}
int snoopyTestCli_action_stress_threadsexec(int argc , char **argv ) 
{ 
  int threadsToCreate ;
  int i ;
  int retVal ;
  tData_t *tArgs ;
  void *tmp ;

  {
  retVal = 0;
  if (argc < 1) {
    snoopyTestCli_action_stress_threadsexec_showHelp();
    fatalError((char const   * const  )"Missing argument: number of threads to run");
  }
  threadsToCreate = atoi((char const   *)*(argv + 0));
  if (threadsToCreate < 1) {
    snoopyTestCli_action_stress_threadsexec_showHelp();
    fatalErrorValue((char const   * const  )"Invalid number of threads to create (min 1, max THREAD_COUNT_MAX)",
                    (char const   * const  )*(argv + 0));
  } else
  if (threadsToCreate > 10000) {
    snoopyTestCli_action_stress_threadsexec_showHelp();
    fatalErrorValue((char const   * const  )"Invalid number of threads to create (min 1, max THREAD_COUNT_MAX)",
                    (char const   * const  )*(argv + 0));
  }
  if (argc < 2) {
    snoopyTestCli_action_stress_threadsexec_showHelp();
    fatalError((char const   * const  )"Missing argument: external command to run");
  }
  snoopyTestCli_action_stress_threadsexec_runCmdAndArgv = argv + 1;
  printf((char const   * __restrict  )"M: Starting threads:\n");
  i = 0;
  while (i < threadsToCreate) {
    tmp = malloc(sizeof(*tArgs));
    tArgs = (tData_t *)tmp;
    tArgs->seqNr = i;
    printf((char const   * __restrict  )" M: Starting thread #%d:\n", i + 1);
    retVal = pthread_create((pthread_t * __restrict  )(& snoopyTestCli_action_stress_threadsexec_tRepo[i]),
                            (pthread_attr_t const   * __restrict  )((void *)0), & snoopyTestCli_action_stress_threadsexec_threadMain,
                            (void * __restrict  )tArgs);
    i ++;
  }
  printf((char const   * __restrict  )"M: All threads started\n");
  printf((char const   * __restrict  )"M: Waiting for all threads to finish:\n");
  i = 0;
  while (i < threadsToCreate) {
    pthread_join(snoopyTestCli_action_stress_threadsexec_tRepo[i], (void **)((void *)0));
    printf((char const   * __restrict  )" M: Thread #%d joined.\n", i + 1);
    i ++;
  }
  printf((char const   * __restrict  )"M: All threads have finished.\n");
  printf((char const   * __restrict  )"SUCCESS!\n");
  return (retVal);
}
}
void *snoopyTestCli_action_stress_threadsexec_threadMain(void *args ) 
{ 
  tData_t *tArgs ;
  char *cmd ;
  char **argv ;
  pid_t pid ;
  __pid_t tmp ;
  int *status ;

  {
  tArgs = (tData_t *)args;
  printf((char const   * __restrict  )"  t%d : Hello from thread #%d.\n", tArgs->seqNr + 1,
         tArgs->seqNr + 1);
  tmp = fork();
  pid = tmp;
  if (pid > 0) {
    printf((char const   * __restrict  )"  t%dp: Hello from parent proc\n", tArgs->seqNr + 1);
    status = (int *)0;
    waitpid(pid, status, 0);
    printf((char const   * __restrict  )"  t%dp: Child proc has finished\n", tArgs->seqNr + 1);
  } else
  if (pid == 0) {
    printf((char const   * __restrict  )"  t%dc: Hello from child proc\n", tArgs->seqNr + 1);
    cmd = *(snoopyTestCli_action_stress_threadsexec_runCmdAndArgv + 0);
    argv = snoopyTestCli_action_stress_threadsexec_runCmdAndArgv + 0;
    printf((char const   * __restrict  )"  t%dc: running cmd %s %s\n", tArgs->seqNr + 1,
           cmd, *(argv + 0));
    execv((char const   *)cmd, (char * const  *)argv);
  } else {
    printf((char const   * __restrict  )"  t%d : Fork failed!\n", tArgs->seqNr + 1);
  }
  free((void *)tArgs);
  return ((void *)0);
}
}
#pragma merger("0","/tmp/cil-vM5FnDqc.i","-Wall,-Werror,-Wextra,-Wno-unused-parameter,-std=c99,-Wpedantic,-fvisibility=hidden,-g,-O2")
extern char *snoopy_util_systemd_convertCgroupEntryToUnitName(char const   * const  cgroupEntry ) ;
static void mockCgroupEntryConversion(char const   * const  cgroupEntry , char const   * const  expectedUnitName ) ;
void snoopyTestCli_action_unit_util_systemd_showHelp(void) 
{ 
  char *helpContent ;

  {
  helpContent = (char *)"Snoopy TEST SUITE CLI utility :: Action `unit` :: Unit `util` :: Subunit \'systemd\'\n\nDescription:\n    Mocks src/action/systemd.c implementation code paths (mainly for the coverage of code parts/paths not covered by the test suite).\n\nUsage:\n    snoopy-test unit util systemd\n    snoopy-test unit util systemd --help\n\n";
  printf((char const   * __restrict  )"%s", helpContent);
  return;
}
}
int snoopyTestCli_action_unit_util_systemd(int argc , char **argv ) 
{ 
  char const   *arg1 ;
  int tmp ;
  char cgroupEntry1[27] ;
  char const   *expectedUnitName1 ;
  char cgroupEntry2[42] ;
  char const   *expectedUnitName2 ;
  char cgroupEntry3[59] ;
  char const   *expectedUnitName3 ;
  char cgroupEntry4[63] ;
  char const   *expectedUnitName4 ;
  char cgroupEntry5[17] ;
  char const   *expectedUnitName5 ;
  char cgroupEntry6[13] ;
  char const   *expectedUnitName6 ;
  char cgroupEntry7[93] ;
  char const   *expectedUnitName7 ;

  {
  if (argc > 0) {
    arg1 = (char const   *)*(argv + 0);
  } else {
    arg1 = "";
  }
  tmp = strcmp(arg1, "--help");
  if (0 == tmp) {
    snoopyTestCli_action_unit_util_systemd_showHelp();
    return (0);
  }
  cgroupEntry1[0] = (char )'1';
  cgroupEntry1[1] = (char )':';
  cgroupEntry1[2] = (char )'n';
  cgroupEntry1[3] = (char )'a';
  cgroupEntry1[4] = (char )'m';
  cgroupEntry1[5] = (char )'e';
  cgroupEntry1[6] = (char )'=';
  cgroupEntry1[7] = (char )'s';
  cgroupEntry1[8] = (char )'y';
  cgroupEntry1[9] = (char )'s';
  cgroupEntry1[10] = (char )'t';
  cgroupEntry1[11] = (char )'e';
  cgroupEntry1[12] = (char )'m';
  cgroupEntry1[13] = (char )'d';
  cgroupEntry1[14] = (char )':';
  cgroupEntry1[15] = (char )'/';
  cgroupEntry1[16] = (char )'i';
  cgroupEntry1[17] = (char )'n';
  cgroupEntry1[18] = (char )'i';
  cgroupEntry1[19] = (char )'t';
  cgroupEntry1[20] = (char )'.';
  cgroupEntry1[21] = (char )'s';
  cgroupEntry1[22] = (char )'c';
  cgroupEntry1[23] = (char )'o';
  cgroupEntry1[24] = (char )'p';
  cgroupEntry1[25] = (char )'e';
  cgroupEntry1[26] = (char )'\000';
  expectedUnitName1 = "init";
  mockCgroupEntryConversion((char const   * const  )(cgroupEntry1), (char const   * const  )expectedUnitName1);
  cgroupEntry2[0] = (char )'1';
  cgroupEntry2[1] = (char )':';
  cgroupEntry2[2] = (char )'n';
  cgroupEntry2[3] = (char )'a';
  cgroupEntry2[4] = (char )'m';
  cgroupEntry2[5] = (char )'e';
  cgroupEntry2[6] = (char )'=';
  cgroupEntry2[7] = (char )'s';
  cgroupEntry2[8] = (char )'y';
  cgroupEntry2[9] = (char )'s';
  cgroupEntry2[10] = (char )'t';
  cgroupEntry2[11] = (char )'e';
  cgroupEntry2[12] = (char )'m';
  cgroupEntry2[13] = (char )'d';
  cgroupEntry2[14] = (char )':';
  cgroupEntry2[15] = (char )'/';
  cgroupEntry2[16] = (char )'s';
  cgroupEntry2[17] = (char )'y';
  cgroupEntry2[18] = (char )'s';
  cgroupEntry2[19] = (char )'t';
  cgroupEntry2[20] = (char )'e';
  cgroupEntry2[21] = (char )'m';
  cgroupEntry2[22] = (char )'.';
  cgroupEntry2[23] = (char )'s';
  cgroupEntry2[24] = (char )'l';
  cgroupEntry2[25] = (char )'i';
  cgroupEntry2[26] = (char )'c';
  cgroupEntry2[27] = (char )'e';
  cgroupEntry2[28] = (char )'/';
  cgroupEntry2[29] = (char )'d';
  cgroupEntry2[30] = (char )'b';
  cgroupEntry2[31] = (char )'u';
  cgroupEntry2[32] = (char )'s';
  cgroupEntry2[33] = (char )'.';
  cgroupEntry2[34] = (char )'s';
  cgroupEntry2[35] = (char )'e';
  cgroupEntry2[36] = (char )'r';
  cgroupEntry2[37] = (char )'v';
  cgroupEntry2[38] = (char )'i';
  cgroupEntry2[39] = (char )'c';
  cgroupEntry2[40] = (char )'e';
  cgroupEntry2[41] = (char )'\000';
  expectedUnitName2 = "dbus";
  mockCgroupEntryConversion((char const   * const  )(cgroupEntry2), (char const   * const  )expectedUnitName2);
  cgroupEntry3[0] = (char )'1';
  cgroupEntry3[1] = (char )':';
  cgroupEntry3[2] = (char )'n';
  cgroupEntry3[3] = (char )'a';
  cgroupEntry3[4] = (char )'m';
  cgroupEntry3[5] = (char )'e';
  cgroupEntry3[6] = (char )'=';
  cgroupEntry3[7] = (char )'s';
  cgroupEntry3[8] = (char )'y';
  cgroupEntry3[9] = (char )'s';
  cgroupEntry3[10] = (char )'t';
  cgroupEntry3[11] = (char )'e';
  cgroupEntry3[12] = (char )'m';
  cgroupEntry3[13] = (char )'d';
  cgroupEntry3[14] = (char )':';
  cgroupEntry3[15] = (char )'/';
  cgroupEntry3[16] = (char )'u';
  cgroupEntry3[17] = (char )'s';
  cgroupEntry3[18] = (char )'e';
  cgroupEntry3[19] = (char )'r';
  cgroupEntry3[20] = (char )'.';
  cgroupEntry3[21] = (char )'s';
  cgroupEntry3[22] = (char )'l';
  cgroupEntry3[23] = (char )'i';
  cgroupEntry3[24] = (char )'c';
  cgroupEntry3[25] = (char )'e';
  cgroupEntry3[26] = (char )'/';
  cgroupEntry3[27] = (char )'u';
  cgroupEntry3[28] = (char )'s';
  cgroupEntry3[29] = (char )'e';
  cgroupEntry3[30] = (char )'r';
  cgroupEntry3[31] = (char )'-';
  cgroupEntry3[32] = (char )'0';
  cgroupEntry3[33] = (char )'.';
  cgroupEntry3[34] = (char )'s';
  cgroupEntry3[35] = (char )'l';
  cgroupEntry3[36] = (char )'i';
  cgroupEntry3[37] = (char )'c';
  cgroupEntry3[38] = (char )'e';
  cgroupEntry3[39] = (char )'/';
  cgroupEntry3[40] = (char )'s';
  cgroupEntry3[41] = (char )'e';
  cgroupEntry3[42] = (char )'s';
  cgroupEntry3[43] = (char )'s';
  cgroupEntry3[44] = (char )'i';
  cgroupEntry3[45] = (char )'o';
  cgroupEntry3[46] = (char )'n';
  cgroupEntry3[47] = (char )'-';
  cgroupEntry3[48] = (char )'3';
  cgroupEntry3[49] = (char )'1';
  cgroupEntry3[50] = (char )'7';
  cgroupEntry3[51] = (char )'7';
  cgroupEntry3[52] = (char )'.';
  cgroupEntry3[53] = (char )'s';
  cgroupEntry3[54] = (char )'c';
  cgroupEntry3[55] = (char )'o';
  cgroupEntry3[56] = (char )'p';
  cgroupEntry3[57] = (char )'e';
  cgroupEntry3[58] = (char )'\000';
  expectedUnitName3 = "root";
  mockCgroupEntryConversion((char const   * const  )(cgroupEntry3), (char const   * const  )expectedUnitName3);
  cgroupEntry4[0] = (char )'1';
  cgroupEntry4[1] = (char )':';
  cgroupEntry4[2] = (char )'n';
  cgroupEntry4[3] = (char )'a';
  cgroupEntry4[4] = (char )'m';
  cgroupEntry4[5] = (char )'e';
  cgroupEntry4[6] = (char )'=';
  cgroupEntry4[7] = (char )'s';
  cgroupEntry4[8] = (char )'y';
  cgroupEntry4[9] = (char )'s';
  cgroupEntry4[10] = (char )'t';
  cgroupEntry4[11] = (char )'e';
  cgroupEntry4[12] = (char )'m';
  cgroupEntry4[13] = (char )'d';
  cgroupEntry4[14] = (char )':';
  cgroupEntry4[15] = (char )'/';
  cgroupEntry4[16] = (char )'u';
  cgroupEntry4[17] = (char )'s';
  cgroupEntry4[18] = (char )'e';
  cgroupEntry4[19] = (char )'r';
  cgroupEntry4[20] = (char )'.';
  cgroupEntry4[21] = (char )'s';
  cgroupEntry4[22] = (char )'l';
  cgroupEntry4[23] = (char )'i';
  cgroupEntry4[24] = (char )'c';
  cgroupEntry4[25] = (char )'e';
  cgroupEntry4[26] = (char )'/';
  cgroupEntry4[27] = (char )'u';
  cgroupEntry4[28] = (char )'s';
  cgroupEntry4[29] = (char )'e';
  cgroupEntry4[30] = (char )'r';
  cgroupEntry4[31] = (char )'-';
  cgroupEntry4[32] = (char )'5';
  cgroupEntry4[33] = (char )'7';
  cgroupEntry4[34] = (char )'1';
  cgroupEntry4[35] = (char )'2';
  cgroupEntry4[36] = (char )'3';
  cgroupEntry4[37] = (char )'.';
  cgroupEntry4[38] = (char )'s';
  cgroupEntry4[39] = (char )'l';
  cgroupEntry4[40] = (char )'i';
  cgroupEntry4[41] = (char )'c';
  cgroupEntry4[42] = (char )'e';
  cgroupEntry4[43] = (char )'/';
  cgroupEntry4[44] = (char )'s';
  cgroupEntry4[45] = (char )'e';
  cgroupEntry4[46] = (char )'s';
  cgroupEntry4[47] = (char )'s';
  cgroupEntry4[48] = (char )'i';
  cgroupEntry4[49] = (char )'o';
  cgroupEntry4[50] = (char )'n';
  cgroupEntry4[51] = (char )'-';
  cgroupEntry4[52] = (char )'3';
  cgroupEntry4[53] = (char )'1';
  cgroupEntry4[54] = (char )'7';
  cgroupEntry4[55] = (char )'7';
  cgroupEntry4[56] = (char )'.';
  cgroupEntry4[57] = (char )'s';
  cgroupEntry4[58] = (char )'c';
  cgroupEntry4[59] = (char )'o';
  cgroupEntry4[60] = (char )'p';
  cgroupEntry4[61] = (char )'e';
  cgroupEntry4[62] = (char )'\000';
  expectedUnitName4 = "user-57123";
  mockCgroupEntryConversion((char const   * const  )(cgroupEntry4), (char const   * const  )expectedUnitName4);
  cgroupEntry5[0] = (char )'1';
  cgroupEntry5[1] = (char )':';
  cgroupEntry5[2] = (char )'n';
  cgroupEntry5[3] = (char )'a';
  cgroupEntry5[4] = (char )'m';
  cgroupEntry5[5] = (char )'e';
  cgroupEntry5[6] = (char )'=';
  cgroupEntry5[7] = (char )'s';
  cgroupEntry5[8] = (char )'y';
  cgroupEntry5[9] = (char )'s';
  cgroupEntry5[10] = (char )'t';
  cgroupEntry5[11] = (char )'e';
  cgroupEntry5[12] = (char )'m';
  cgroupEntry5[13] = (char )'d';
  cgroupEntry5[14] = (char )':';
  cgroupEntry5[15] = (char )'/';
  cgroupEntry5[16] = (char )'\000';
  expectedUnitName5 = "-";
  mockCgroupEntryConversion((char const   * const  )(cgroupEntry5), (char const   * const  )expectedUnitName5);
  cgroupEntry6[0] = (char )'0';
  cgroupEntry6[1] = (char )':';
  cgroupEntry6[2] = (char )':';
  cgroupEntry6[3] = (char )'/';
  cgroupEntry6[4] = (char )'w';
  cgroupEntry6[5] = (char )'h';
  cgroupEntry6[6] = (char )'a';
  cgroupEntry6[7] = (char )'t';
  cgroupEntry6[8] = (char )'e';
  cgroupEntry6[9] = (char )'v';
  cgroupEntry6[10] = (char )'e';
  cgroupEntry6[11] = (char )'r';
  cgroupEntry6[12] = (char )'\000';
  expectedUnitName6 = (char const   *)((void *)0);
  mockCgroupEntryConversion((char const   * const  )(cgroupEntry6), (char const   * const  )expectedUnitName6);
  cgroupEntry7[0] = (char )'1';
  cgroupEntry7[1] = (char )':';
  cgroupEntry7[2] = (char )'n';
  cgroupEntry7[3] = (char )'a';
  cgroupEntry7[4] = (char )'m';
  cgroupEntry7[5] = (char )'e';
  cgroupEntry7[6] = (char )'=';
  cgroupEntry7[7] = (char )'s';
  cgroupEntry7[8] = (char )'y';
  cgroupEntry7[9] = (char )'s';
  cgroupEntry7[10] = (char )'t';
  cgroupEntry7[11] = (char )'e';
  cgroupEntry7[12] = (char )'m';
  cgroupEntry7[13] = (char )'d';
  cgroupEntry7[14] = (char )':';
  cgroupEntry7[15] = (char )'/';
  cgroupEntry7[16] = (char )'a';
  cgroupEntry7[17] = (char )'c';
  cgroupEntry7[18] = (char )'t';
  cgroupEntry7[19] = (char )'i';
  cgroupEntry7[20] = (char )'o';
  cgroupEntry7[21] = (char )'n';
  cgroupEntry7[22] = (char )'s';
  cgroupEntry7[23] = (char )'_';
  cgroupEntry7[24] = (char )'j';
  cgroupEntry7[25] = (char )'o';
  cgroupEntry7[26] = (char )'b';
  cgroupEntry7[27] = (char )'/';
  cgroupEntry7[28] = (char )'4';
  cgroupEntry7[29] = (char )'4';
  cgroupEntry7[30] = (char )'e';
  cgroupEntry7[31] = (char )'2';
  cgroupEntry7[32] = (char )'b';
  cgroupEntry7[33] = (char )'f';
  cgroupEntry7[34] = (char )'e';
  cgroupEntry7[35] = (char )'9';
  cgroupEntry7[36] = (char )'d';
  cgroupEntry7[37] = (char )'6';
  cgroupEntry7[38] = (char )'f';
  cgroupEntry7[39] = (char )'3';
  cgroupEntry7[40] = (char )'e';
  cgroupEntry7[41] = (char )'c';
  cgroupEntry7[42] = (char )'e';
  cgroupEntry7[43] = (char )'1';
  cgroupEntry7[44] = (char )'9';
  cgroupEntry7[45] = (char )'2';
  cgroupEntry7[46] = (char )'a';
  cgroupEntry7[47] = (char )'9';
  cgroupEntry7[48] = (char )'f';
  cgroupEntry7[49] = (char )'7';
  cgroupEntry7[50] = (char )'6';
  cgroupEntry7[51] = (char )'2';
  cgroupEntry7[52] = (char )'d';
  cgroupEntry7[53] = (char )'9';
  cgroupEntry7[54] = (char )'1';
  cgroupEntry7[55] = (char )'c';
  cgroupEntry7[56] = (char )'9';
  cgroupEntry7[57] = (char )'5';
  cgroupEntry7[58] = (char )'1';
  cgroupEntry7[59] = (char )'4';
  cgroupEntry7[60] = (char )'1';
  cgroupEntry7[61] = (char )'3';
  cgroupEntry7[62] = (char )'1';
  cgroupEntry7[63] = (char )'b';
  cgroupEntry7[64] = (char )'8';
  cgroupEntry7[65] = (char )'c';
  cgroupEntry7[66] = (char )'f';
  cgroupEntry7[67] = (char )'b';
  cgroupEntry7[68] = (char )'b';
  cgroupEntry7[69] = (char )'d';
  cgroupEntry7[70] = (char )'0';
  cgroupEntry7[71] = (char )'4';
  cgroupEntry7[72] = (char )'6';
  cgroupEntry7[73] = (char )'9';
  cgroupEntry7[74] = (char )'b';
  cgroupEntry7[75] = (char )'1';
  cgroupEntry7[76] = (char )'7';
  cgroupEntry7[77] = (char )'2';
  cgroupEntry7[78] = (char )'2';
  cgroupEntry7[79] = (char )'f';
  cgroupEntry7[80] = (char )'d';
  cgroupEntry7[81] = (char )'8';
  cgroupEntry7[82] = (char )'6';
  cgroupEntry7[83] = (char )'3';
  cgroupEntry7[84] = (char )'7';
  cgroupEntry7[85] = (char )'e';
  cgroupEntry7[86] = (char )'f';
  cgroupEntry7[87] = (char )'6';
  cgroupEntry7[88] = (char )'f';
  cgroupEntry7[89] = (char )'e';
  cgroupEntry7[90] = (char )'a';
  cgroupEntry7[91] = (char )'c';
  cgroupEntry7[92] = (char )'\000';
  expectedUnitName7 = (char const   *)((void *)0);
  mockCgroupEntryConversion((char const   * const  )(cgroupEntry7), (char const   * const  )expectedUnitName7);
  printSuccess((char const   * const  )"Mocking src/unit/systemd.c complete.");
  return (0);
}
}
static void mockCgroupEntryConversion(char const   * const  cgroupEntry , char const   * const  expectedUnitName ) 
{ 
  char *unitName ;
  char *tmp ;
  int tmp___0 ;

  {
  tmp = snoopy_util_systemd_convertCgroupEntryToUnitName(cgroupEntry);
  unitName = tmp;
  if (! unitName) {
    if (! expectedUnitName) {
      return;
    }
  }
  if (! unitName) {
    if (expectedUnitName) {
      printDiagValue((char const   * const  )"cgroupEntry", cgroupEntry);
      printDiagValue((char const   * const  )"Expected unit name", expectedUnitName);
      fatalError((char const   * const  )"Unable to convert cgroup entry to Systemd unit name");
      return;
    }
  }
  if (unitName) {
    if (! expectedUnitName) {
      printDiagValue((char const   * const  )"cgroupEntry", cgroupEntry);
      printDiagValue((char const   * const  )"Converted unit name", (char const   * const  )unitName);
      fatalError((char const   * const  )"Cgroup entry not converted to NULL");
      return;
    }
  }
  tmp___0 = strcmp((char const   *)expectedUnitName, (char const   *)unitName);
  if (0 != tmp___0) {
    printDiagValue((char const   * const  )"cgroupEntry", cgroupEntry);
    printDiagValue((char const   * const  )"Expected  unit name", expectedUnitName);
    printDiagValue((char const   * const  )"Converted unit name", (char const   * const  )unitName);
    fatalError((char const   * const  )"Unexpected unit name conversion");
    return;
  }
  if (unitName) {
    free((void *)unitName);
  }
  return;
}
}
