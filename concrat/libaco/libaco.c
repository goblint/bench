/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef unsigned long __uint64_t;
typedef long __off_t;
typedef long __off64_t;
typedef __uint64_t uint64_t;
typedef unsigned long uintptr_t;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
struct __anonstruct_aco_save_stack_t_539581013 {
   void *ptr ;
   size_t sz ;
   size_t valid_sz ;
   size_t max_cpsz ;
   size_t ct_save ;
   size_t ct_restore ;
};
typedef struct __anonstruct_aco_save_stack_t_539581013 aco_save_stack_t;
struct aco_s ;
typedef struct aco_s aco_t;
struct __anonstruct_aco_share_stack_t_624142846 {
   void *ptr ;
   size_t sz ;
   void *align_highptr ;
   void *align_retptr ;
   size_t align_validsz ;
   size_t align_limit ;
   aco_t *owner ;
   char guard_page_enabled ;
   void *real_ptr ;
   size_t real_sz ;
};
typedef struct __anonstruct_aco_share_stack_t_624142846 aco_share_stack_t;
struct aco_s {
   void *reg[9] ;
   aco_t *main_co ;
   void *arg ;
   char is_end ;
   void (*fp)(void) ;
   aco_save_stack_t save_stack ;
   aco_share_stack_t *share_stack ;
};
typedef unsigned char __uint8_t;
typedef __uint8_t uint8_t;
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
typedef unsigned long pthread_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
/* compiler builtin:
   long __builtin_expect(long  , long  ) ;  */
#pragma merger("0","/tmp/cil-OZm4mXxb.i","")
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
extern FILE *stderr ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format
                   , ...) ;
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
extern  __attribute__((__nothrow__)) void *mmap(void *__addr , size_t __len , int __prot ,
                                                int __flags , int __fd , __off_t __offset ) ;
extern  __attribute__((__nothrow__)) int munmap(void *__addr , size_t __len ) ;
extern  __attribute__((__nothrow__)) int mprotect(void *__addr , size_t __len , int __prot ) ;
void aco_runtime_test(void) ;
void aco_thread_init(void (*last_word_co_fp)(void) ) ;
extern void *acosw(aco_t *from_co , aco_t *to_co )  __asm__("acosw")  ;
extern void aco_save_fpucw_mxcsr(void *p )  __asm__("aco_save_fpucw_mxcsr")  ;
extern void aco_funcp_protector_asm(void)  __asm__("aco_funcp_protector_asm")  ;
void aco_funcp_protector(void) ;
aco_share_stack_t *aco_share_stack_new(size_t sz ) ;
aco_share_stack_t *aco_share_stack_new2(size_t sz , char guard_page_enabled ) ;
void aco_share_stack_destroy(aco_share_stack_t *sstk ) ;
aco_t *aco_create(aco_t *main_co , aco_share_stack_t *share_stack , size_t save_stack_sz ,
                  void (*fp)(void) , void *arg ) ;
 __thread  aco_t *aco_gtls_co  ;
void aco_resume(aco_t *resume_co ) ;
void aco_destroy(aco_t *co ) ;
void aco_runtime_test(void)
{
  long tmp ;
  long tmp___0 ;

  {
  tmp = __builtin_expect((long )(! (! (sizeof(int ) >= 4UL))), 1L);
  if (! tmp) {
    abort();
  }
  tmp___0 = __builtin_expect((long )(! (! (sizeof(int ) <= sizeof(size_t )))), 1L);
  if (! tmp___0) {
    abort();
  }
  return;
}
}
static void aco_default_protector_last_word(void)
{
  aco_t *co ;
  long tmp ;

  {
  co = aco_gtls_co;
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"error: aco_default_protector_last_word triggered\n");
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"error: co:%p should call `aco_exit()` instead of direct `return` in co_fp:%p to finish its execution\n",
          co, (void *)co->fp);
  tmp = __builtin_expect(0L, 1L);
  if (! tmp) {
    abort();
  }
  return;
}
}
static  __thread  void (*aco_gtls_last_word_fp)(void)  =    & aco_default_protector_last_word;
static  __thread  void *aco_gtls_fpucw_mxcsr[1]  ;
void aco_thread_init(void (*last_word_co_fp)(void) )
{


  {
  aco_save_fpucw_mxcsr((void *)(aco_gtls_fpucw_mxcsr));
  if ((unsigned long )((void *)last_word_co_fp) != (unsigned long )((void *)0)) {
    aco_gtls_last_word_fp = last_word_co_fp;
  }
  return;
}
}
void aco_funcp_protector(void)
{
  long tmp ;

  {
  if ((unsigned long )((void *)aco_gtls_last_word_fp) != (unsigned long )((void *)0)) {
    (*aco_gtls_last_word_fp)();
  } else {
    aco_default_protector_last_word();
  }
  tmp = __builtin_expect(0L, 1L);
  if (! tmp) {
    abort();
  }
  return;
}
}
aco_share_stack_t *aco_share_stack_new(size_t sz )
{
  aco_share_stack_t *tmp ;

  {
  tmp = aco_share_stack_new2(sz, (char)1);
  return (tmp);
}
}
aco_share_stack_t *aco_share_stack_new2(size_t sz , char guard_page_enabled )
{
  long tmp ;
  size_t u_pgsz ;
  long pgsz ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  size_t new_sz ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  aco_share_stack_t *p ;
  void *tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  long tmp___19 ;
  uintptr_t u_p ;
  long tmp___20 ;

  {
  if (sz == 0UL) {
    sz = (size_t )2097152;
  }
  if (sz < 4096UL) {
    sz = (size_t )4096;
  }
  tmp = __builtin_expect((long )(! (! (sz > 0UL))), 1L);
  if (! tmp) {
    abort();
  }
  u_pgsz = (size_t )0;
  if ((int )guard_page_enabled != 0) {
    tmp___0 = sysconf(30);
    pgsz = tmp___0;
    if (pgsz > 0L) {
      if (((pgsz - 1L) & pgsz) == 0L) {
        tmp___1 = 1;
      } else {
        tmp___1 = 0;
      }
    } else {
      tmp___1 = 0;
    }
    tmp___2 = __builtin_expect((long )tmp___1, 1L);
    if (! tmp___2) {
      abort();
    }
    u_pgsz = (unsigned long )pgsz;
    if (u_pgsz == (unsigned long )pgsz) {
      if ((u_pgsz << 1) >> 1 == u_pgsz) {
        tmp___3 = 1;
      } else {
        tmp___3 = 0;
      }
    } else {
      tmp___3 = 0;
    }
    tmp___4 = __builtin_expect((long )tmp___3, 1L);
    if (! tmp___4) {
      abort();
    }
    if (sz <= u_pgsz) {
      sz = u_pgsz << 1;
    } else {
      if ((sz & (u_pgsz - 1UL)) != 0UL) {
        new_sz = sz & ~ (u_pgsz - 1UL);
        tmp___5 = __builtin_expect((long )(! (! (new_sz >= u_pgsz))), 1L);
        if (! tmp___5) {
          abort();
        }
        while (1) {
          tmp___6 = __builtin_expect((long )(! (! (new_sz + (u_pgsz << 1) >= new_sz))),
                                     1L);
          if (! tmp___6) {
            abort();
          }
          break;
        }
        new_sz += u_pgsz << 1;
        tmp___7 = __builtin_expect((long )(! (! (sz / u_pgsz + 2UL == new_sz / u_pgsz))),
                                   1L);
        if (! tmp___7) {
          abort();
        }
      } else {
        while (1) {
          tmp___8 = __builtin_expect((long )(! (! (sz + u_pgsz >= sz))), 1L);
          if (! tmp___8) {
            abort();
          }
          break;
        }
        new_sz = sz + u_pgsz;
        tmp___9 = __builtin_expect((long )(! (! (sz / u_pgsz + 1UL == new_sz / u_pgsz))),
                                   1L);
        if (! tmp___9) {
          abort();
        }
      }
      sz = new_sz;
      if (sz / u_pgsz > 1UL) {
        if ((sz & (u_pgsz - 1UL)) == 0UL) {
          tmp___10 = 1;
        } else {
          tmp___10 = 0;
        }
      } else {
        tmp___10 = 0;
      }
      tmp___11 = __builtin_expect((long )tmp___10, 1L);
      if (! tmp___11) {
        abort();
      }
    }
  }
  tmp___12 = malloc(sizeof(aco_share_stack_t ));
  p = (aco_share_stack_t *)tmp___12;
  while (1) {
    tmp___13 = __builtin_expect((long )(! (! ((unsigned long )p == (unsigned long )((void *)0)))),
                                0L);
    if (tmp___13) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Aborting: failed to allocate memory: %s:%d:%s\n",
              "aco.c", 248, "aco_share_stack_new2");
      abort();
    }
    break;
  }
  memset((void *)p, 0, sizeof(aco_share_stack_t ));
  if ((int )guard_page_enabled != 0) {
    p->real_ptr = mmap((void *)0, sz, 3, 34, -1, (__off_t )0);
    while (1) {
      tmp___14 = __builtin_expect((long )(! (! (! ((unsigned long )p->real_ptr != (unsigned long )((void *)-1))))),
                                  0L);
      if (tmp___14) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Aborting: failed to allocate memory: %s:%d:%s\n",
                "aco.c", 255, "aco_share_stack_new2");
        abort();
      }
      break;
    }
    p->guard_page_enabled = (char)1;
    tmp___15 = mprotect(p->real_ptr, u_pgsz, 1);
    if (0 == tmp___15) {
      tmp___16 = 1;
    } else {
      tmp___16 = 0;
    }
    tmp___17 = __builtin_expect((long )tmp___16, 1L);
    if (! tmp___17) {
      abort();
    }
    p->ptr = (void *)((uintptr_t )p->real_ptr + u_pgsz);
    p->real_sz = sz;
    tmp___18 = __builtin_expect((long )(! (! (sz >= u_pgsz << 1))), 1L);
    if (! tmp___18) {
      abort();
    }
    p->sz = sz - u_pgsz;
  } else {
    p->sz = sz;
    p->ptr = malloc(sz);
    while (1) {
      tmp___19 = __builtin_expect((long )(! (! ((unsigned long )p->ptr == (unsigned long )((void *)0)))),
                                  0L);
      if (tmp___19) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Aborting: failed to allocate memory: %s:%d:%s\n",
                "aco.c", 267, "aco_share_stack_new2");
        abort();
      }
      break;
    }
  }
  p->owner = (aco_t *)((void *)0);
  u_p = (p->sz - (sizeof(void *) << 1)) + (uintptr_t )p->ptr;
  u_p = (u_p >> 4) << 4;
  p->align_highptr = (void *)u_p;
  p->align_retptr = (void *)(u_p - sizeof(void *));
  *((void **)p->align_retptr) = (void *)(& aco_funcp_protector_asm);
  tmp___20 = __builtin_expect((long )(! (! (p->sz > (16UL + (sizeof(void *) << 1)) + sizeof(void *)))),
                              1L);
  if (! tmp___20) {
    abort();
  }
  p->align_limit = (p->sz - 16UL) - (sizeof(void *) << 1);
  return (p);
}
}
void aco_share_stack_destroy(aco_share_stack_t *sstk )
{
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  if ((unsigned long )sstk != (unsigned long )((void *)0)) {
    if ((unsigned long )sstk->ptr != (unsigned long )((void *)0)) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  tmp___0 = __builtin_expect((long )tmp, 1L);
  if (! tmp___0) {
    abort();
  }
  if (sstk->guard_page_enabled) {
    tmp___1 = munmap(sstk->real_ptr, sstk->real_sz);
    if (0 == tmp___1) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
    tmp___3 = __builtin_expect((long )tmp___2, 1L);
    if (! tmp___3) {
      abort();
    }
    sstk->real_ptr = (void *)0;
    sstk->ptr = (void *)0;
  } else {
    free(sstk->ptr);
    sstk->ptr = (void *)0;
  }
  free((void *)sstk);
  return;
}
}
aco_t *aco_create(aco_t *main_co , aco_share_stack_t *share_stack , size_t save_stack_sz ,
                  void (*fp)(void) , void *arg )
{
  aco_t *p ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
  tmp = malloc(sizeof(aco_t ));
  p = (aco_t *)tmp;
  while (1) {
    tmp___0 = __builtin_expect((long )(! (! ((unsigned long )p == (unsigned long )((void *)0)))),
                               0L);
    if (tmp___0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Aborting: failed to allocate memory: %s:%d:%s\n",
              "aco.c", 312, "aco_create");
      abort();
    }
    break;
  }
  memset((void *)p, 0, sizeof(aco_t ));
  if ((unsigned long )main_co != (unsigned long )((void *)0)) {
    tmp___1 = __builtin_expect((long )(! (! ((unsigned long )share_stack != (unsigned long )((void *)0)))),
                               1L);
    if (! tmp___1) {
      abort();
    }
    p->share_stack = share_stack;
    p->reg[4] = (void *)fp;
    p->reg[5] = (p->share_stack)->align_retptr;
    p->reg[8] = aco_gtls_fpucw_mxcsr[0];
    p->main_co = main_co;
    p->arg = arg;
    p->fp = fp;
    if (save_stack_sz == 0UL) {
      save_stack_sz = (size_t )64;
    }
    p->save_stack.ptr = malloc(save_stack_sz);
    while (1) {
      tmp___2 = __builtin_expect((long )(! (! ((unsigned long )p->save_stack.ptr == (unsigned long )((void *)0)))),
                                 0L);
      if (tmp___2) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Aborting: failed to allocate memory: %s:%d:%s\n",
                "aco.c", 344, "aco_create");
        abort();
      }
      break;
    }
    p->save_stack.sz = save_stack_sz;
    p->save_stack.valid_sz = (size_t )0;
    return (p);
  } else {
    p->main_co = (aco_t *)((void *)0);
    p->arg = arg;
    p->fp = fp;
    p->share_stack = (aco_share_stack_t *)((void *)0);
    p->save_stack.ptr = (void *)0;
    return (p);
  }
  tmp___3 = __builtin_expect(0L, 1L);
  if (! tmp___3) {
    abort();
  }
}
}
void aco_resume(aco_t *resume_co )
{
  int tmp ;
  long tmp___0 ;
  aco_t *owner_co ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  unsigned __int128 xmm0 ;
  unsigned __int128 xmm1 ;
  unsigned __int128 xmm2 ;
  unsigned __int128 xmm3 ;
  unsigned __int128 xmm4 ;
  unsigned __int128 xmm5 ;
  unsigned __int128 xmm6 ;
  unsigned __int128 xmm7 ;
  long tmp___6 ;
  long tmp___7 ;
  unsigned __int128 xmm0___0 ;
  unsigned __int128 xmm1___0 ;
  unsigned __int128 xmm2___0 ;
  unsigned __int128 xmm3___0 ;
  unsigned __int128 xmm4___0 ;
  unsigned __int128 xmm5___0 ;
  unsigned __int128 xmm6___0 ;
  unsigned __int128 xmm7___0 ;

  {
  if ((unsigned long )resume_co != (unsigned long )((void *)0)) {
    if ((unsigned long )resume_co->main_co != (unsigned long )((void *)0)) {
      if ((int )resume_co->is_end == 0) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  tmp___0 = __builtin_expect((long )tmp, 1L);
  if (! tmp___0) {
    abort();
  }
  if ((unsigned long )(resume_co->share_stack)->owner != (unsigned long )resume_co) {
    if ((unsigned long )(resume_co->share_stack)->owner != (unsigned long )((void *)0)) {
      owner_co = (resume_co->share_stack)->owner;
      tmp___1 = __builtin_expect((long )(! (! ((unsigned long )owner_co->share_stack == (unsigned long )resume_co->share_stack))),
                                 1L);
      if (! tmp___1) {
        abort();
      }
      if ((uintptr_t )(owner_co->share_stack)->align_retptr >= (uintptr_t )owner_co->reg[5]) {
        if ((uintptr_t )(owner_co->share_stack)->align_highptr - (owner_co->share_stack)->align_limit <= (uintptr_t )owner_co->reg[5]) {
          tmp___2 = 1;
        } else {
          tmp___2 = 0;
        }
      } else {
        tmp___2 = 0;
      }
      tmp___3 = __builtin_expect((long )tmp___2, 1L);
      if (! tmp___3) {
        abort();
      }
      owner_co->save_stack.valid_sz = (uintptr_t )(owner_co->share_stack)->align_retptr - (uintptr_t )owner_co->reg[5];
      if (owner_co->save_stack.sz < owner_co->save_stack.valid_sz) {
        free(owner_co->save_stack.ptr);
        owner_co->save_stack.ptr = (void *)0;
        while (1) {
          owner_co->save_stack.sz <<= 1;
          tmp___4 = __builtin_expect((long )(! (! (owner_co->save_stack.sz > 0UL))),
                                     1L);
          if (! tmp___4) {
            abort();
          }
          if (owner_co->save_stack.sz >= owner_co->save_stack.valid_sz) {
            break;
          }
        }
        owner_co->save_stack.ptr = malloc(owner_co->save_stack.sz);
        while (1) {
          tmp___5 = __builtin_expect((long )(! (! ((unsigned long )owner_co->save_stack.ptr == (unsigned long )((void *)0)))),
                                     0L);
          if (tmp___5) {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Aborting: failed to allocate memory: %s:%d:%s\n",
                    "aco.c", 403, "aco_resume");
            abort();
          }
          break;
        }
      }
      if (owner_co->save_stack.valid_sz > 0UL) {
        while (1) {
          if (((uintptr_t )owner_co->reg[5] & 15UL) == 0UL) {
            if (((uintptr_t )owner_co->save_stack.ptr & 15UL) == 0UL) {
              if ((owner_co->save_stack.valid_sz & 15UL) == 8UL) {
                if (owner_co->save_stack.valid_sz >> 4 >= 0UL) {
                  if (owner_co->save_stack.valid_sz >> 4 <= 8UL) {
                    while (1) {
                      switch (owner_co->save_stack.valid_sz >> 4) {
                      case 0UL:
                      break;
                      case 1UL:
                      xmm0 = *((unsigned __int128 *)owner_co->reg[5] + 0);
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 0) = xmm0;
                      break;
                      case 2UL:
                      xmm0 = *((unsigned __int128 *)owner_co->reg[5] + 0);
                      xmm1 = *((unsigned __int128 *)owner_co->reg[5] + 1);
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 0) = xmm0;
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 1) = xmm1;
                      break;
                      case 3UL:
                      xmm0 = *((unsigned __int128 *)owner_co->reg[5] + 0);
                      xmm1 = *((unsigned __int128 *)owner_co->reg[5] + 1);
                      xmm2 = *((unsigned __int128 *)owner_co->reg[5] + 2);
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 0) = xmm0;
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 1) = xmm1;
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 2) = xmm2;
                      break;
                      case 4UL:
                      xmm0 = *((unsigned __int128 *)owner_co->reg[5] + 0);
                      xmm1 = *((unsigned __int128 *)owner_co->reg[5] + 1);
                      xmm2 = *((unsigned __int128 *)owner_co->reg[5] + 2);
                      xmm3 = *((unsigned __int128 *)owner_co->reg[5] + 3);
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 0) = xmm0;
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 1) = xmm1;
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 2) = xmm2;
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 3) = xmm3;
                      break;
                      case 5UL:
                      xmm0 = *((unsigned __int128 *)owner_co->reg[5] + 0);
                      xmm1 = *((unsigned __int128 *)owner_co->reg[5] + 1);
                      xmm2 = *((unsigned __int128 *)owner_co->reg[5] + 2);
                      xmm3 = *((unsigned __int128 *)owner_co->reg[5] + 3);
                      xmm4 = *((unsigned __int128 *)owner_co->reg[5] + 4);
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 0) = xmm0;
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 1) = xmm1;
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 2) = xmm2;
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 3) = xmm3;
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 4) = xmm4;
                      break;
                      case 6UL:
                      xmm0 = *((unsigned __int128 *)owner_co->reg[5] + 0);
                      xmm1 = *((unsigned __int128 *)owner_co->reg[5] + 1);
                      xmm2 = *((unsigned __int128 *)owner_co->reg[5] + 2);
                      xmm3 = *((unsigned __int128 *)owner_co->reg[5] + 3);
                      xmm4 = *((unsigned __int128 *)owner_co->reg[5] + 4);
                      xmm5 = *((unsigned __int128 *)owner_co->reg[5] + 5);
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 0) = xmm0;
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 1) = xmm1;
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 2) = xmm2;
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 3) = xmm3;
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 4) = xmm4;
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 5) = xmm5;
                      break;
                      case 7UL:
                      xmm0 = *((unsigned __int128 *)owner_co->reg[5] + 0);
                      xmm1 = *((unsigned __int128 *)owner_co->reg[5] + 1);
                      xmm2 = *((unsigned __int128 *)owner_co->reg[5] + 2);
                      xmm3 = *((unsigned __int128 *)owner_co->reg[5] + 3);
                      xmm4 = *((unsigned __int128 *)owner_co->reg[5] + 4);
                      xmm5 = *((unsigned __int128 *)owner_co->reg[5] + 5);
                      xmm6 = *((unsigned __int128 *)owner_co->reg[5] + 6);
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 0) = xmm0;
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 1) = xmm1;
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 2) = xmm2;
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 3) = xmm3;
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 4) = xmm4;
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 5) = xmm5;
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 6) = xmm6;
                      break;
                      case 8UL:
                      xmm0 = *((unsigned __int128 *)owner_co->reg[5] + 0);
                      xmm1 = *((unsigned __int128 *)owner_co->reg[5] + 1);
                      xmm2 = *((unsigned __int128 *)owner_co->reg[5] + 2);
                      xmm3 = *((unsigned __int128 *)owner_co->reg[5] + 3);
                      xmm4 = *((unsigned __int128 *)owner_co->reg[5] + 4);
                      xmm5 = *((unsigned __int128 *)owner_co->reg[5] + 5);
                      xmm6 = *((unsigned __int128 *)owner_co->reg[5] + 6);
                      xmm7 = *((unsigned __int128 *)owner_co->reg[5] + 7);
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 0) = xmm0;
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 1) = xmm1;
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 2) = xmm2;
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 3) = xmm3;
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 4) = xmm4;
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 5) = xmm5;
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 6) = xmm6;
                      *((unsigned __int128 *)owner_co->save_stack.ptr + 7) = xmm7;
                      break;
                      }
                      *((uint64_t *)(((uintptr_t )owner_co->save_stack.ptr + owner_co->save_stack.valid_sz) - 8UL)) = *((uint64_t *)(((uintptr_t )owner_co->reg[5] + owner_co->save_stack.valid_sz) - 8UL));
                      break;
                    }
                  } else {
                    memcpy((void * __restrict  )owner_co->save_stack.ptr, (void const   * __restrict  )owner_co->reg[5],
                           owner_co->save_stack.valid_sz);
                  }
                } else {
                  memcpy((void * __restrict  )owner_co->save_stack.ptr, (void const   * __restrict  )owner_co->reg[5],
                         owner_co->save_stack.valid_sz);
                }
              } else {
                memcpy((void * __restrict  )owner_co->save_stack.ptr, (void const   * __restrict  )owner_co->reg[5],
                       owner_co->save_stack.valid_sz);
              }
            } else {
              memcpy((void * __restrict  )owner_co->save_stack.ptr, (void const   * __restrict  )owner_co->reg[5],
                     owner_co->save_stack.valid_sz);
            }
          } else {
            memcpy((void * __restrict  )owner_co->save_stack.ptr, (void const   * __restrict  )owner_co->reg[5],
                   owner_co->save_stack.valid_sz);
          }
          break;
        }
        (owner_co->save_stack.ct_save) ++;
      }
      if (owner_co->save_stack.valid_sz > owner_co->save_stack.max_cpsz) {
        owner_co->save_stack.max_cpsz = owner_co->save_stack.valid_sz;
      }
      (owner_co->share_stack)->owner = (aco_t *)((void *)0);
      (owner_co->share_stack)->align_validsz = (size_t )0;
    }
    tmp___6 = __builtin_expect((long )(! (! ((unsigned long )(resume_co->share_stack)->owner == (unsigned long )((void *)0)))),
                               1L);
    if (! tmp___6) {
      abort();
    }
    tmp___7 = __builtin_expect((long )(! (! (resume_co->save_stack.valid_sz <= (resume_co->share_stack)->align_limit - sizeof(void *)))),
                               1L);
    if (! tmp___7) {
      abort();
    }
    if (resume_co->save_stack.valid_sz > 0UL) {
      while (1) {
        if (((uintptr_t )resume_co->save_stack.ptr & 15UL) == 0UL) {
          if (((uintptr_t )((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) & 15UL) == 0UL) {
            if ((resume_co->save_stack.valid_sz & 15UL) == 8UL) {
              if (resume_co->save_stack.valid_sz >> 4 >= 0UL) {
                if (resume_co->save_stack.valid_sz >> 4 <= 8UL) {
                  while (1) {
                    switch (resume_co->save_stack.valid_sz >> 4) {
                    case 0UL:
                    break;
                    case 1UL:
                    xmm0___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 0);
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 0) = xmm0___0;
                    break;
                    case 2UL:
                    xmm0___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 0);
                    xmm1___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 1);
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 0) = xmm0___0;
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 1) = xmm1___0;
                    break;
                    case 3UL:
                    xmm0___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 0);
                    xmm1___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 1);
                    xmm2___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 2);
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 0) = xmm0___0;
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 1) = xmm1___0;
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 2) = xmm2___0;
                    break;
                    case 4UL:
                    xmm0___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 0);
                    xmm1___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 1);
                    xmm2___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 2);
                    xmm3___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 3);
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 0) = xmm0___0;
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 1) = xmm1___0;
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 2) = xmm2___0;
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 3) = xmm3___0;
                    break;
                    case 5UL:
                    xmm0___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 0);
                    xmm1___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 1);
                    xmm2___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 2);
                    xmm3___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 3);
                    xmm4___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 4);
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 0) = xmm0___0;
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 1) = xmm1___0;
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 2) = xmm2___0;
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 3) = xmm3___0;
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 4) = xmm4___0;
                    break;
                    case 6UL:
                    xmm0___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 0);
                    xmm1___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 1);
                    xmm2___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 2);
                    xmm3___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 3);
                    xmm4___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 4);
                    xmm5___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 5);
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 0) = xmm0___0;
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 1) = xmm1___0;
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 2) = xmm2___0;
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 3) = xmm3___0;
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 4) = xmm4___0;
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 5) = xmm5___0;
                    break;
                    case 7UL:
                    xmm0___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 0);
                    xmm1___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 1);
                    xmm2___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 2);
                    xmm3___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 3);
                    xmm4___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 4);
                    xmm5___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 5);
                    xmm6___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 6);
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 0) = xmm0___0;
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 1) = xmm1___0;
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 2) = xmm2___0;
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 3) = xmm3___0;
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 4) = xmm4___0;
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 5) = xmm5___0;
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 6) = xmm6___0;
                    break;
                    case 8UL:
                    xmm0___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 0);
                    xmm1___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 1);
                    xmm2___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 2);
                    xmm3___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 3);
                    xmm4___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 4);
                    xmm5___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 5);
                    xmm6___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 6);
                    xmm7___0 = *((unsigned __int128 *)resume_co->save_stack.ptr + 7);
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 0) = xmm0___0;
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 1) = xmm1___0;
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 2) = xmm2___0;
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 3) = xmm3___0;
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 4) = xmm4___0;
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 5) = xmm5___0;
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 6) = xmm6___0;
                    *((unsigned __int128 *)((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + 7) = xmm7___0;
                    break;
                    }
                    *((uint64_t *)(((uintptr_t )((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)) + resume_co->save_stack.valid_sz) - 8UL)) = *((uint64_t *)(((uintptr_t )resume_co->save_stack.ptr + resume_co->save_stack.valid_sz) - 8UL));
                    break;
                  }
                } else {
                  memcpy((void * __restrict  )((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)),
                         (void const   * __restrict  )resume_co->save_stack.ptr, resume_co->save_stack.valid_sz);
                }
              } else {
                memcpy((void * __restrict  )((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)),
                       (void const   * __restrict  )resume_co->save_stack.ptr, resume_co->save_stack.valid_sz);
              }
            } else {
              memcpy((void * __restrict  )((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)),
                     (void const   * __restrict  )resume_co->save_stack.ptr, resume_co->save_stack.valid_sz);
            }
          } else {
            memcpy((void * __restrict  )((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)),
                   (void const   * __restrict  )resume_co->save_stack.ptr, resume_co->save_stack.valid_sz);
          }
        } else {
          memcpy((void * __restrict  )((void *)((uintptr_t )(resume_co->share_stack)->align_retptr - resume_co->save_stack.valid_sz)),
                 (void const   * __restrict  )resume_co->save_stack.ptr, resume_co->save_stack.valid_sz);
        }
        break;
      }
      (resume_co->save_stack.ct_restore) ++;
    }
    if (resume_co->save_stack.valid_sz > resume_co->save_stack.max_cpsz) {
      resume_co->save_stack.max_cpsz = resume_co->save_stack.valid_sz;
    }
    (resume_co->share_stack)->align_validsz = resume_co->save_stack.valid_sz + sizeof(void *);
    (resume_co->share_stack)->owner = resume_co;
  }
  aco_gtls_co = resume_co;
  acosw(resume_co->main_co, resume_co);
  aco_gtls_co = resume_co->main_co;
  return;
}
}
void aco_destroy(aco_t *co )
{
  long tmp ;

  {
  tmp = __builtin_expect((long )(! (! ((unsigned long )co != (unsigned long )((void *)0)))),
                         1L);
  if (! tmp) {
    abort();
  }
  if ((unsigned long )co->main_co == (unsigned long )((void *)0)) {
    free((void *)co);
  } else {
    if ((unsigned long )(co->share_stack)->owner == (unsigned long )co) {
      (co->share_stack)->owner = (aco_t *)((void *)0);
      (co->share_stack)->align_validsz = (size_t )0;
    }
    free(co->save_stack.ptr);
    co->save_stack.ptr = (void *)0;
    free((void *)co);
  }
  return;
}
}
#pragma merger("0","/tmp/cil-nPWrDbU1.i","")
extern int printf(char const   * __restrict  __format  , ...) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
extern  __attribute__((__nothrow__)) pthread_t pthread_self(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
uint64_t gl_race_aco_yield_ct  =    (uint64_t )0;
pthread_mutex_t gl_race_aco_yield_ct_mutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
void foo(int ct )
{
  long tmp ;
  long tmp___0 ;

  {
  printf((char const   * __restrict  )"co:%p save_stack:%p share_stack:%p yield_ct:%d\n",
         aco_gtls_co, aco_gtls_co->save_stack.ptr, (aco_gtls_co->share_stack)->ptr,
         ct);
  pthread_mutex_lock(& gl_race_aco_yield_ct_mutex);
  gl_race_aco_yield_ct ++;
  pthread_mutex_unlock(& gl_race_aco_yield_ct_mutex);
  while (1) {
    while (1) {
      tmp = __builtin_expect((long )(! (! ((unsigned long )aco_gtls_co != (unsigned long )((void *)0)))),
                             1L);
      if (! tmp) {
        abort();
      }
      tmp___0 = __builtin_expect((long )(! (! ((unsigned long )aco_gtls_co->main_co != (unsigned long )((void *)0)))),
                                 1L);
      if (! tmp___0) {
        abort();
      }
      acosw(aco_gtls_co, aco_gtls_co->main_co);
      break;
    }
    break;
  }
  (*((int *)aco_gtls_co->arg)) ++;
  return;
}
}
void co_fp0(void)
{
  aco_t *this_co ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int ct ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;

  {
  this_co = aco_gtls_co;
  tmp = __builtin_expect((long )(! (! (! ((unsigned long )this_co->main_co == (unsigned long )((void *)0))))),
                         1L);
  if (! tmp) {
    abort();
  }
  tmp___0 = __builtin_expect((long )(! (! ((unsigned long )this_co->fp == (unsigned long )((void *)(& co_fp0))))),
                             1L);
  if (! tmp___0) {
    abort();
  }
  tmp___1 = __builtin_expect((long )(! (! ((int )this_co->is_end == 0))), 1L);
  if (! tmp___1) {
    abort();
  }
  ct = 0;
  while (ct < 6) {
    foo(ct);
    ct ++;
  }
  printf((char const   * __restrict  )"co:%p save_stack:%p share_stack:%p co_exit()\n",
         this_co, this_co->save_stack.ptr, (this_co->share_stack)->ptr);
  pthread_mutex_lock(& gl_race_aco_yield_ct_mutex);
  gl_race_aco_yield_ct ++;
  pthread_mutex_unlock(& gl_race_aco_yield_ct_mutex);
  while (1) {
    while (1) {
      aco_gtls_co->is_end = (char)1;
      tmp___2 = __builtin_expect((long )(! (! ((unsigned long )(aco_gtls_co->share_stack)->owner == (unsigned long )aco_gtls_co))),
                                 1L);
      if (! tmp___2) {
        abort();
      }
      (aco_gtls_co->share_stack)->owner = (aco_t *)((void *)0);
      (aco_gtls_co->share_stack)->align_validsz = (size_t )0;
      while (1) {
        tmp___3 = __builtin_expect((long )(! (! ((unsigned long )aco_gtls_co != (unsigned long )((void *)0)))),
                                   1L);
        if (! tmp___3) {
          abort();
        }
        tmp___4 = __builtin_expect((long )(! (! ((unsigned long )aco_gtls_co->main_co != (unsigned long )((void *)0)))),
                                   1L);
        if (! tmp___4) {
          abort();
        }
        acosw(aco_gtls_co, aco_gtls_co->main_co);
        break;
      }
      tmp___5 = __builtin_expect(0L, 1L);
      if (! tmp___5) {
        abort();
      }
      break;
    }
    break;
  }
  tmp___6 = __builtin_expect(0L, 1L);
  if (! tmp___6) {
    abort();
  }
  return;
}
}
void *pmain(void *pthread_in_arg )
{
  pthread_t t ;
  pthread_t tmp ;
  size_t idx ;
  long tmp___0 ;
  aco_t *main_co ;
  aco_t *tmp___1 ;
  long tmp___2 ;
  aco_share_stack_t *sstk ;
  aco_share_stack_t *tmp___3 ;
  long tmp___4 ;
  aco_share_stack_t *sstk2 ;
  aco_share_stack_t *tmp___5 ;
  long tmp___6 ;
  int co_ct_arg_point_to_me ;
  int co2_ct_arg_point_to_me ;
  int co3_ct_arg_point_to_me ;
  aco_t *co ;
  aco_t *tmp___7 ;
  long tmp___8 ;
  aco_t *co2 ;
  aco_t *tmp___9 ;
  aco_t *co3 ;
  aco_t *tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  int ct ;
  long tmp___13 ;
  long tmp___14 ;
  long tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  long tmp___21 ;
  long tmp___22 ;
  long tmp___23 ;
  long tmp___24 ;
  uint64_t tmp_gl_ct ;

  {
  tmp = pthread_self();
  t = tmp;
  idx = (size_t )0;
  tmp___0 = __builtin_expect((long )(! (! (sizeof(t) > 0UL))), 1L);
  if (! tmp___0) {
    abort();
  }
  printf((char const   * __restrict  )"\ntid:0x");
  while (idx < sizeof(t)) {
    printf((char const   * __restrict  )"%02x", (int )*((uint8_t *)(& t) + idx));
    idx ++;
  }
  printf((char const   * __restrict  )"\n");
  aco_thread_init((void (*)(void))((void *)0));
  tmp___1 = aco_create((aco_t *)((void *)0), (aco_share_stack_t *)((void *)0), (size_t )0,
                       (void (*)(void))((void *)0), (void *)0);
  main_co = tmp___1;
  tmp___2 = __builtin_expect((long )(! (! ((unsigned long )main_co != (unsigned long )((void *)0)))),
                             1L);
  if (! tmp___2) {
    abort();
  }
  tmp___3 = aco_share_stack_new((size_t )0);
  sstk = tmp___3;
  tmp___4 = __builtin_expect((long )(! (! ((unsigned long )sstk != (unsigned long )((void *)0)))),
                             1L);
  if (! tmp___4) {
    abort();
  }
  tmp___5 = aco_share_stack_new((size_t )0);
  sstk2 = tmp___5;
  tmp___6 = __builtin_expect((long )(! (! ((unsigned long )sstk2 != (unsigned long )((void *)0)))),
                             1L);
  if (! tmp___6) {
    abort();
  }
  co_ct_arg_point_to_me = 0;
  co2_ct_arg_point_to_me = 0;
  co3_ct_arg_point_to_me = 0;
  tmp___7 = aco_create(main_co, sstk, (size_t )0, & co_fp0, (void *)(& co_ct_arg_point_to_me));
  co = tmp___7;
  tmp___8 = __builtin_expect((long )(! (! ((unsigned long )co != (unsigned long )((void *)0)))),
                             1L);
  if (! tmp___8) {
    abort();
  }
  tmp___9 = aco_create(main_co, sstk2, (size_t )0, & co_fp0, (void *)(& co2_ct_arg_point_to_me));
  co2 = tmp___9;
  tmp___10 = aco_create(main_co, sstk2, (size_t )0, & co_fp0, (void *)(& co3_ct_arg_point_to_me));
  co3 = tmp___10;
  tmp___11 = __builtin_expect((long )(! (! ((unsigned long )co2 != (unsigned long )((void *)0)))),
                              1L);
  if (! tmp___11) {
    abort();
  }
  tmp___12 = __builtin_expect((long )(! (! ((unsigned long )co3 != (unsigned long )((void *)0)))),
                              1L);
  if (! tmp___12) {
    abort();
  }
  ct = 0;
  while (ct < 6) {
    tmp___13 = __builtin_expect((long )(! (! ((int )co->is_end == 0))), 1L);
    if (! tmp___13) {
      abort();
    }
    aco_resume(co);
    tmp___14 = __builtin_expect((long )(! (! (co_ct_arg_point_to_me == ct))), 1L);
    if (! tmp___14) {
      abort();
    }
    tmp___15 = __builtin_expect((long )(! (! ((int )co2->is_end == 0))), 1L);
    if (! tmp___15) {
      abort();
    }
    aco_resume(co2);
    tmp___16 = __builtin_expect((long )(! (! (co2_ct_arg_point_to_me == ct))), 1L);
    if (! tmp___16) {
      abort();
    }
    tmp___17 = __builtin_expect((long )(! (! ((int )co3->is_end == 0))), 1L);
    if (! tmp___17) {
      abort();
    }
    aco_resume(co3);
    tmp___18 = __builtin_expect((long )(! (! (co3_ct_arg_point_to_me == ct))), 1L);
    if (! tmp___18) {
      abort();
    }
    printf((char const   * __restrict  )"main_co:%p\n", main_co);
    ct ++;
  }
  aco_resume(co);
  tmp___19 = __builtin_expect((long )(! (! (co_ct_arg_point_to_me == ct))), 1L);
  if (! tmp___19) {
    abort();
  }
  tmp___20 = __builtin_expect((long )(! (! co->is_end)), 1L);
  if (! tmp___20) {
    abort();
  }
  aco_resume(co2);
  tmp___21 = __builtin_expect((long )(! (! (co2_ct_arg_point_to_me == ct))), 1L);
  if (! tmp___21) {
    abort();
  }
  tmp___22 = __builtin_expect((long )(! (! co2->is_end)), 1L);
  if (! tmp___22) {
    abort();
  }
  aco_resume(co3);
  tmp___23 = __builtin_expect((long )(! (! (co3_ct_arg_point_to_me == ct))), 1L);
  if (! tmp___23) {
    abort();
  }
  tmp___24 = __builtin_expect((long )(! (! co3->is_end)), 1L);
  if (! tmp___24) {
    abort();
  }
  printf((char const   * __restrict  )"main_co:%p\n", main_co);
  printf((char const   * __restrict  )"\ncopy-stack co:%p:\n    max stack copy size:%zu\n    save (from share stack to save stack) counter of the private save stack:%zu\n    restore (from save stack to share stack) counter of the private save stack:%zu\n",
         co, co->save_stack.max_cpsz, co->save_stack.ct_save, co->save_stack.ct_restore);
  printf((char const   * __restrict  )"\n(Since the share stack used by the co has only one user `co`, so there is no need to save/restore the stack every time during resume & yield execution, thus you can call it a co has \'standalone stack\' which just is a very special case of copy-stack.)\n");
  printf((char const   * __restrict  )"\ncopy-stack co2:%p:\n    max stack copy size:%zu\n    save (from share stack to save stack) counter of the private save stack:%zu\n    restore (from save stack to share stack) counter of the private save stack:%zu\n",
         co2, co2->save_stack.max_cpsz, co2->save_stack.ct_save, co2->save_stack.ct_restore);
  printf((char const   * __restrict  )"\ncopy-stack co3:%p:\n    max stack copy size:%zu\n    save (from share stack to save stack) counter of the private save stack:%zu\n    restore (from save stack to share stack) counter of the private save stack:%zu\n",
         co3, co3->save_stack.max_cpsz, co3->save_stack.ct_save, co3->save_stack.ct_restore);
  printf((char const   * __restrict  )"\n(The co2 & co3 share the share stack sstk2, thus it is necessary to save/restore the stack every time during resume & yield execution, thus it is a ordinary case of copy-stack.)\n");
  pthread_mutex_lock(& gl_race_aco_yield_ct_mutex);
  tmp_gl_ct = gl_race_aco_yield_ct;
  pthread_mutex_unlock(& gl_race_aco_yield_ct_mutex);
  printf((char const   * __restrict  )"\ngl_race_aco_yield_ct:%lu\n", tmp_gl_ct);
  aco_destroy(co);
  co = (aco_t *)((void *)0);
  aco_destroy(co2);
  co2 = (aco_t *)((void *)0);
  aco_destroy(co3);
  co3 = (aco_t *)((void *)0);
  aco_share_stack_destroy(sstk);
  sstk = (aco_share_stack_t *)((void *)0);
  aco_share_stack_destroy(sstk2);
  sstk2 = (aco_share_stack_t *)((void *)0);
  aco_destroy(main_co);
  main_co = (aco_t *)((void *)0);
  return ((void *)0);
}
}
int main(void)
{
  pthread_t t1 ;
  pthread_t t2 ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;

  {
  tmp = pthread_create((pthread_t * __restrict  )(& t1), (pthread_attr_t const   * __restrict  )((void *)0),
                       & pmain, (void * __restrict  )((void *)0));
  if (0 == tmp) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  tmp___1 = __builtin_expect((long )tmp___0, 1L);
  if (! tmp___1) {
    abort();
  }
  tmp___2 = pthread_create((pthread_t * __restrict  )(& t2), (pthread_attr_t const   * __restrict  )((void *)0),
                           & pmain, (void * __restrict  )((void *)0));
  if (0 == tmp___2) {
    tmp___3 = 1;
  } else {
    tmp___3 = 0;
  }
  tmp___4 = __builtin_expect((long )tmp___3, 1L);
  if (! tmp___4) {
    abort();
  }
  tmp___5 = pthread_join(t1, (void **)((void *)0));
  if (0 == tmp___5) {
    tmp___6 = 1;
  } else {
    tmp___6 = 0;
  }
  tmp___7 = __builtin_expect((long )tmp___6, 1L);
  if (! tmp___7) {
    abort();
  }
  tmp___8 = pthread_join(t2, (void **)((void *)0));
  if (0 == tmp___8) {
    tmp___9 = 1;
  } else {
    tmp___9 = 0;
  }
  tmp___10 = __builtin_expect((long )tmp___9, 1L);
  if (! tmp___10) {
    abort();
  }
  return (0);
}
}
