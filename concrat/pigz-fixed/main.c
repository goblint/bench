/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef __builtin_va_list __gnuc_va_list;
typedef unsigned short __uint16_t;
typedef unsigned int __uint32_t;
typedef __uint16_t __uint_least16_t;
typedef unsigned long __uintmax_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned long __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef long __time_t;
typedef long __suseconds_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef __gnuc_va_list va_list___0;
typedef __off64_t off_t;
typedef __ssize_t ssize_t;
typedef __time_t time_t;
typedef unsigned int pthread_key_t;
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long __tm_gmtoff ;
   char const   *__tm_zone ;
};
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
struct __anonstruct___sigset_t_991265788 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___sigset_t_991265788 __sigset_t;
typedef void (*__sighandler_t)(int  );
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
struct dirent {
   __ino64_t d_ino ;
   __off64_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
struct __dirstream ;
typedef struct __dirstream DIR;
typedef __uint32_t uint32_t;
typedef __uint_least16_t uint_least16_t;
typedef __uintmax_t uintmax_t;
typedef uintmax_t length_t;
typedef uint32_t crc_t;
typedef uint_least16_t index_t;
typedef unsigned char Byte;
typedef unsigned int uInt;
typedef unsigned long uLong;
typedef Byte Bytef;
typedef void *voidpf;
typedef unsigned int z_crc_t;
struct internal_state ;
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
typedef struct z_stream_s z_stream;
typedef z_stream *z_streamp;
struct thread_s ;
typedef struct thread_s thread;
struct lock_s ;
typedef struct lock_s lock;
enum twist_op {
    TO = 0,
    BY = 1
} ;
enum wait_op {
    TO_BE = 0,
    NOT_TO_BE = 1,
    TO_BE_MORE_THAN = 2,
    TO_BE_LESS_THAN = 3
} ;
struct ZopfliOptions {
   int verbose ;
   int verbose_more ;
   int numiterations ;
   int blocksplitting ;
   int blocksplittinglast ;
   int blocksplittingmax ;
};
typedef struct ZopfliOptions ZopfliOptions;
typedef long __jmp_buf[8];
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
typedef struct __jmp_buf_tag jmp_buf[1];
struct __anonstruct_try_ball_t__852378850 {
   int ret ;
   int code ;
   int free ;
   char *why ;
};
typedef struct __anonstruct_try_ball_t__852378850 try_ball_t_;
struct try_s_ ;
typedef struct try_s_ try_t_;
struct try_s_ {
   jmp_buf env ;
   try_ball_t_ ball ;
   try_t_ *next ;
};
struct __anonstruct_g_4656454 {
   int ret ;
   char *prog ;
   int ind ;
   int outd ;
   char *inf ;
   size_t inz ;
   char *outf ;
   int verbosity ;
   int headis ;
   int pipeout ;
   int keep ;
   int force ;
   int sync ;
   int form ;
   int magic1 ;
   int recurse ;
   char *sufx ;
   char *name ;
   char *alias ;
   char *comment ;
   time_t mtime ;
   int list ;
   int first ;
   int decode ;
   int level ;
   int strategy ;
   ZopfliOptions zopts ;
   int rsync ;
   int procs ;
   int setdict ;
   size_t block ;
   crc_t shift ;
   time_t stamp ;
   char *hname ;
   char *hcomm ;
   unsigned long zip_crc ;
   length_t zip_clen ;
   length_t zip_ulen ;
   int zip64 ;
   unsigned char in_buf[32810] ;
   unsigned char *in_next ;
   size_t in_left ;
   int in_eof ;
   int in_short ;
   length_t in_tot ;
   length_t out_tot ;
   unsigned long out_check ;
   unsigned char in_buf2[32810] ;
   size_t in_len ;
   int in_which ;
   lock *load_state ;
   thread *load_thread ;
};
typedef length_t val_t;
struct pool ;
struct space {
   lock *use ;
   unsigned char *buf ;
   size_t size ;
   size_t len ;
   struct pool *pool ;
   struct space *next ;
};
struct pool {
   lock *have ;
   struct space *head ;
   size_t size ;
   int limit ;
   int made ;
};
struct job {
   long seq ;
   int more ;
   struct space *in ;
   struct space *out ;
   struct space *lens ;
   unsigned long check ;
   lock *calc ;
   struct job *next ;
};
typedef unsigned long bits_t;
typedef int pthread_once_t;
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
struct __anonstruct___wseq32_112954846 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_419937108 {
   unsigned long long __wseq ;
   struct __anonstruct___wseq32_112954846 __wseq32 ;
};
struct __anonstruct___g1_start32_845759683 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_845759682 {
   unsigned long long __g1_start ;
   struct __anonstruct___g1_start32_845759683 __g1_start32 ;
};
struct __pthread_cond_s {
   union __anonunion____missing_field_name_419937108 __annonCompField1 ;
   union __anonunion____missing_field_name_845759682 __annonCompField2 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
typedef unsigned long pthread_t;
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
union __anonunion_pthread_condattr_t_488594145 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_condattr_t_488594145 pthread_condattr_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
union __anonunion_pthread_cond_t_951761805 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
typedef union __anonunion_pthread_cond_t_951761805 pthread_cond_t;
struct __anonstruct___cancel_jmp_buf_572769531 {
   __jmp_buf __cancel_jmp_buf ;
   int __mask_was_saved ;
};
struct __anonstruct___pthread_unwind_buf_t_348056374 {
   struct __anonstruct___cancel_jmp_buf_572769531 __cancel_jmp_buf[1] ;
   void *__pad[4] ;
};
typedef struct __anonstruct___pthread_unwind_buf_t_348056374  __attribute__((__aligned__)) __pthread_unwind_buf_t;
struct lock_s {
   pthread_mutex_t mutex ;
   pthread_cond_t cond ;
   long value ;
};
struct thread_s {
   pthread_t id ;
   int done ;
   thread *next ;
};
struct capsule {
   void (*probe)(void * ) ;
   void *payload ;
   char const   *file ;
   long line ;
};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#pragma merger("0","/tmp/cil-jc78ApQc.i","")
extern FILE *stdout ;
extern FILE *stderr ;
extern int fflush(FILE *__stream ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
extern int getchar(void) ;
extern int putc(int __c , FILE *__stream ) ;
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
extern int puts(char const   *__s ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
extern  __attribute__((__nothrow__)) int abs(int __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memchr)(void const   *__s ,
                                                                                     int __c ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) )  __asm__("__sysv_signal")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __file ,
                                                                                   struct stat * __restrict  __buf )  __asm__("stat64")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat)(int __fd ,
                                                                                  struct stat *__buf )  __asm__("fstat64")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) lstat)(char const   * __restrict  __file ,
                                                                                    struct stat * __restrict  __buf )  __asm__("lstat64")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chmod)(char const   *__file ,
                                                                                  __mode_t __mode ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) utimes)(char const   *__file ,
                                                                                   struct timeval  const  *__tvp ) ;
extern  __attribute__((__nothrow__)) __off64_t lseek(int __fd , __off64_t __offset ,
                                                     int __whence )  __asm__("lseek64")  ;
extern int close(int __fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chown)(char const   *__file ,
                                                                                  __uid_t __owner ,
                                                                                  __gid_t __group ) ;
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
extern int fsync(int __fd ) ;
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp )  __asm__("readdir64")  ;
extern char const   *zlibVersion(void) ;
extern int deflate(z_streamp strm , int flush ) ;
extern int deflateEnd(z_streamp strm ) ;
extern int deflateSetDictionary(z_streamp strm , Bytef const   *dictionary , uInt dictLength ) ;
extern int deflateReset(z_streamp strm ) ;
extern int deflateParams(z_streamp strm , int level , int strategy ) ;
extern int deflatePending(z_streamp strm , unsigned int *pending , int *bits ) ;
extern int deflatePrime(z_streamp strm , int bits , int value ) ;
extern int inflateBack(z_streamp strm , unsigned int (*in)(void * , unsigned char ** ) ,
                       void *in_desc , int (*out)(void * , unsigned char * , unsigned int  ) ,
                       void *out_desc ) ;
extern int inflateBackEnd(z_streamp strm ) ;
extern uLong adler32(uLong adler , Bytef const   *buf , uInt len ) ;
extern uLong crc32(uLong crc , Bytef const   *buf , uInt len ) ;
extern int deflateInit2_(z_streamp strm , int level , int method , int windowBits ,
                         int memLevel , int strategy , char const   *version , int stream_size ) ;
extern int inflateBackInit_(z_streamp strm , int windowBits , unsigned char *window ,
                            char const   *version , int stream_size ) ;
extern z_crc_t const   *get_crc_table(void) ;
char *yarn_prefix ;
void (*yarn_abort)(int  ) ;
thread *launch_(void (*probe)(void * ) , void *payload , char const   *file , long line ) ;
void join_(thread *ally , char const   *file , long line ) ;
int join_all_(char const   *file , long line ) ;
lock *new_lock_(long initial , char const   *file , long line ) ;
void possess_(lock *bolt , char const   *file , long line ) ;
void release_(lock *bolt , char const   *file , long line ) ;
void twist_(lock *bolt , enum twist_op op , long val , char const   *file , long line ) ;
void wait_for_(lock *bolt , enum wait_op op , long val , char const   *file , long line ) ;
long peek_lock(lock *bolt ) ;
void free_lock_(lock *bolt , char const   *file , long line ) ;
extern void ZopfliInitOptions(ZopfliOptions *options ) ;
extern void ZopfliDeflatePart(ZopfliOptions const   *options , int btype , int final ,
                              unsigned char const   *in , size_t instart , size_t inend ,
                              unsigned char *bp , unsigned char **out , size_t *outsize ) ;
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env ,
                                                                int __val ) ;
extern  __attribute__((__nothrow__)) void *pthread_getspecific(pthread_key_t __key ) ;
extern  __attribute__((__nothrow__)) int pthread_setspecific(pthread_key_t __key ,
                                                             void const   *__pointer ) ;
pthread_key_t try_key_ ;
void try_setup_(void) ;
 __attribute__((__noreturn__)) void try_throw_(int code , char *fmt  , ...) ;
static struct __anonstruct_g_4656454 g  ;
static void message(char *fmt , va_list___0 ap ) 
{ 


  {
  if (g.verbosity > 0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: ", g.prog);
    vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )fmt, ap);
    putc('\n', stderr);
    fflush(stderr);
  }
  return;
}
}
static int complain(char *fmt  , ...) 
{ 
  va_list___0 ap ;

  {
  g.ret = 1;
  __builtin_va_start(ap, fmt);
  message(fmt, ap);
  __builtin_va_end(ap);
  return (0);
}
}
static int grumble(char *fmt  , ...) 
{ 
  va_list___0 ap ;

  {
  __builtin_va_start(ap, fmt);
  message(fmt, ap);
  __builtin_va_end(ap);
  return (0);
}
}
static void *alloc(void *ptr , size_t size ) 
{ 


  {
  ptr = realloc(ptr, size);
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    try_throw_(12, (char *)"not enough memory", (void *)0);
  }
  return (ptr);
}
}
static void cut_short(int sig ) 
{ 
  int tmp ;

  {
  if (g.outd != -1) {
    if (g.outd != 1) {
      unlink((char const   *)g.outf);
      while (1) {
        if ((unsigned long )g.outf != (unsigned long )((void *)0)) {
          free((void *)g.outf);
          g.outf = (char *)((void *)0);
        }
        break;
      }
      g.outd = -1;
    }
  }
  if (sig < 0) {
    tmp = - sig;
  } else {
    tmp = 4;
  }
  _exit(tmp);
}
}
__inline static size_t grow(size_t size ) 
{ 
  size_t was ;
  size_t top ;
  int shift ;

  {
  was = size;
  size += size >> 2;
  top = size;
  shift = 0;
  while (top > 7UL) {
    top >>= 1;
    shift ++;
  }
  if (top == 7UL) {
    size = 1UL << (shift + 3);
  }
  if (size < 16UL) {
    size = (size_t )16;
  }
  if (size <= was) {
    size = 18446744073709551615;
  }
  return (size);
}
}
__inline static size_t vmemcpy(char **mem , size_t *size , size_t off , void *cpy ,
                               size_t len ) 
{ 
  size_t need ;
  void *tmp ;

  {
  need = off + len;
  if (need < off) {
    try_throw_(34, (char *)"overflow", (void *)0);
  }
  if (need > *size) {
    need = grow(need);
    if (off == 0UL) {
      while (1) {
        if ((unsigned long )*mem != (unsigned long )((void *)0)) {
          free((void *)*mem);
          *mem = (char *)((void *)0);
        }
        break;
      }
      *size = (size_t )0;
    }
    tmp = alloc((void *)*mem, need);
    *mem = (char *)tmp;
    *size = need;
  }
  memcpy((void * __restrict  )(*mem + off), (void const   * __restrict  )cpy, len);
  return (off + len);
}
}
__inline static size_t vstrcpy(char **str , size_t *size , size_t off , void *cpy ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
  tmp = strlen((char const   *)cpy);
  tmp___0 = vmemcpy(str, size, off, cpy, tmp + 1UL);
  return (tmp___0);
}
}
static size_t readn(int desc , unsigned char *buf , size_t len ) 
{ 
  ssize_t ret ;
  size_t got ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;

  {
  got = (size_t )0;
  while (len) {
    ret = read(desc, (void *)buf, len);
    if (ret < 0L) {
      tmp = __errno_location();
      tmp___0 = strerror(*tmp);
      tmp___1 = __errno_location();
      try_throw_(*tmp___1, (char *)"read error on %s (%s)", g.inf, tmp___0, (void *)0);
    }
    if (ret == 0L) {
      break;
    }
    buf += ret;
    len -= (size_t )ret;
    got += (size_t )ret;
  }
  return (got);
}
}
static size_t writen(int desc , void const   *buf , size_t len ) 
{ 
  char const   *next___0 ;
  size_t left ;
  size_t max ;
  ssize_t ret ;
  size_t tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
  next___0 = (char const   *)buf;
  left = len;
  while (left) {
    max = (size_t )9223372036854775807L;
    if (left > max) {
      tmp = max;
    } else {
      tmp = left;
    }
    tmp___0 = write(desc, (void const   *)next___0, tmp);
    ret = tmp___0;
    if (ret < 1L) {
      tmp___1 = __errno_location();
      tmp___2 = strerror(*tmp___1);
      tmp___3 = __errno_location();
      try_throw_(*tmp___3, (char *)"write error on %s (%s)", g.outf, tmp___2, (void *)0);
    }
    next___0 += ret;
    left -= (size_t )ret;
  }
  return (len);
}
}
static unsigned long time2dos(time_t t ) 
{ 
  struct tm *tm ;
  unsigned long dos ;

  {
  if (t == 0L) {
    t = time((time_t *)((void *)0));
  }
  tm = localtime((time_t const   *)(& t));
  if (tm->tm_year < 80) {
    return (0UL);
  } else
  if (tm->tm_year > 207) {
    return (0UL);
  }
  dos = (unsigned long )(tm->tm_year - 80) << 25;
  dos += (unsigned long )(tm->tm_mon + 1) << 21;
  dos += (unsigned long )tm->tm_mday << 16;
  dos += (unsigned long )tm->tm_hour << 11;
  dos += (unsigned long )tm->tm_min << 5;
  dos += (unsigned long )(tm->tm_sec + 1) >> 1;
  return (dos);
}
}
static unsigned int put(int out___0  , ...) 
{ 
  unsigned int count ;
  int n ;
  va_list___0 ap ;
  val_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned char *wrap ;
  void *tmp___3 ;
  unsigned char *next___0 ;
  val_t val ;
  val_t tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  int tmp___8 ;

  {
  count = 0U;
  __builtin_va_start(ap, out___0);
  while (1) {
    tmp___2 = __builtin_va_arg(ap, int );
    n = tmp___2;
    if (! (n != 0)) {
      break;
    }
    tmp___0 = __builtin_va_arg(ap, val_t );
    tmp___1 = abs(n);
    count += (unsigned int )tmp___1;
  }
  __builtin_va_end(ap);
  tmp___3 = alloc((void *)0, (size_t )count);
  wrap = (unsigned char *)tmp___3;
  next___0 = wrap;
  __builtin_va_start(ap, out___0);
  while (1) {
    tmp___8 = __builtin_va_arg(ap, int );
    n = tmp___8;
    if (! (n != 0)) {
      break;
    }
    tmp___5 = __builtin_va_arg(ap, val_t );
    val = tmp___5;
    if (n < 0) {
      n = - n << 3;
      while (1) {
        n -= 8;
        tmp___6 = next___0;
        next___0 ++;
        *tmp___6 = (unsigned char )(val >> n);
        if (! n) {
          break;
        }
      }
    } else {
      while (1) {
        tmp___7 = next___0;
        next___0 ++;
        *tmp___7 = (unsigned char )val;
        val >>= 8;
        n --;
        if (! n) {
          break;
        }
      }
    }
  }
  __builtin_va_end(ap);
  writen(out___0, (void const   *)wrap, (size_t )count);
  free((void *)wrap);
  return (count);
}
}
static length_t put_header(void) 
{ 
  length_t len ;
  char *tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int head ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  unsigned int tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;

  {
  if (g.form > 1) {
    if ((unsigned long )g.name == (unsigned long )((void *)0)) {
      tmp = g.alias;
    } else {
      tmp = g.name;
    }
    tmp___0 = strlen((char const   *)tmp);
    tmp___1 = time2dos(g.mtime);
    tmp___2 = put(g.outd, 4, (val_t )67324752, 2, (val_t )45, 2, (val_t )8, 2, (val_t )8,
                  4, tmp___1, 4, (val_t )0, 4, (val_t )4294967295U, 4, (val_t )4294967295U,
                  2, tmp___0, 2, (val_t )29, 0);
    len = (length_t )tmp___2;
    if ((unsigned long )g.name == (unsigned long )((void *)0)) {
      tmp___3 = g.alias;
    } else {
      tmp___3 = g.name;
    }
    tmp___4 = strlen((char const   *)tmp___3);
    if ((unsigned long )g.name == (unsigned long )((void *)0)) {
      tmp___5 = g.alias;
    } else {
      tmp___5 = g.name;
    }
    tmp___6 = writen(g.outd, (void const   *)tmp___5, tmp___4);
    len += tmp___6;
    tmp___7 = put(g.outd, 2, (val_t )1, 2, (val_t )16, 8, (val_t )0, 8, (val_t )0,
                  2, (val_t )21589, 2, (val_t )5, 1, (val_t )1, 4, (val_t )g.mtime,
                  0);
    len += (length_t )tmp___7;
  } else
  if (g.form) {
    if ((unsigned long )g.comment != (unsigned long )((void *)0)) {
      complain((char *)"can\'t store comment in zlib format -- ignoring");
    }
    if (g.level >= 9) {
      tmp___10 = 3 << 6;
    } else {
      if (g.level == 1) {
        tmp___9 = 0;
      } else {
        if (g.level >= 6) {
          tmp___8 = 1 << 6;
        } else
        if (g.level == -1) {
          tmp___8 = 1 << 6;
        } else {
          tmp___8 = 2 << 6;
        }
        tmp___9 = tmp___8;
      }
      tmp___10 = tmp___9;
    }
    head = (unsigned int )((120 << 8) + tmp___10);
    head += 31U - head % 31U;
    tmp___11 = put(g.outd, -2, (val_t )head, 0);
    len = (length_t )tmp___11;
  } else {
    if (g.level >= 9) {
      tmp___13 = 2;
    } else {
      if (g.level == 1) {
        tmp___12 = 4;
      } else {
        tmp___12 = 0;
      }
      tmp___13 = tmp___12;
    }
    if ((unsigned long )g.name != (unsigned long )((void *)0)) {
      tmp___14 = 8;
    } else {
      tmp___14 = 0;
    }
    if ((unsigned long )g.comment != (unsigned long )((void *)0)) {
      tmp___15 = 16;
    } else {
      tmp___15 = 0;
    }
    tmp___16 = put(g.outd, 1, (val_t )31, 1, (val_t )139, 1, (val_t )8, 1, (val_t )(tmp___14 + tmp___15),
                   4, (val_t )g.mtime, 1, (val_t )tmp___13, 1, (val_t )3, 0);
    len = (length_t )tmp___16;
    if ((unsigned long )g.name != (unsigned long )((void *)0)) {
      tmp___17 = strlen((char const   *)g.name);
      tmp___18 = writen(g.outd, (void const   *)g.name, tmp___17 + 1UL);
      len += tmp___18;
    }
    if ((unsigned long )g.comment != (unsigned long )((void *)0)) {
      tmp___19 = strlen((char const   *)g.comment);
      tmp___20 = writen(g.outd, (void const   *)g.comment, tmp___19 + 1UL);
      len += tmp___20;
    }
  }
  return (len);
}
}
static void put_trailer(length_t ulen , length_t clen , unsigned long check , length_t head ) 
{ 
  length_t desc ;
  unsigned int tmp ;
  int zip64 ;
  int tmp___0 ;
  length_t cent ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  length_t tmp___6 ;
  length_t tmp___7 ;
  unsigned long tmp___8 ;
  unsigned int tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  length_t tmp___18 ;
  length_t tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
  if (g.form > 1) {
    tmp = put(g.outd, 4, (val_t )134695760, 4, check, 8, clen, 8, ulen, 0);
    desc = (length_t )tmp;
    if (ulen >= 4294967295UL) {
      tmp___0 = 1;
    } else
    if (clen >= 4294967295UL) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
    zip64 = tmp___0;
    if ((unsigned long )g.comment == (unsigned long )((void *)0)) {
      tmp___2 = (size_t )0;
    } else {
      tmp___1 = strlen((char const   *)g.comment);
      tmp___2 = tmp___1;
    }
    if (zip64) {
      tmp___3 = 29;
    } else {
      tmp___3 = 9;
    }
    if ((unsigned long )g.name == (unsigned long )((void *)0)) {
      tmp___4 = g.alias;
    } else {
      tmp___4 = g.name;
    }
    tmp___5 = strlen((char const   *)tmp___4);
    if (zip64) {
      tmp___6 = (length_t )4294967295U;
    } else {
      tmp___6 = ulen;
    }
    if (zip64) {
      tmp___7 = (length_t )4294967295U;
    } else {
      tmp___7 = clen;
    }
    tmp___8 = time2dos(g.mtime);
    tmp___9 = put(g.outd, 4, (val_t )33639248, 1, (val_t )45, 1, (val_t )255, 2, (val_t )45,
                  2, (val_t )8, 2, (val_t )8, 4, tmp___8, 4, check, 4, tmp___7, 4,
                  tmp___6, 2, tmp___5, 2, (val_t )tmp___3, 2, tmp___2, 2, (val_t )0,
                  2, (val_t )0, 4, (val_t )0, 4, (val_t )0, 0);
    cent = (length_t )tmp___9;
    if ((unsigned long )g.name == (unsigned long )((void *)0)) {
      tmp___10 = g.alias;
    } else {
      tmp___10 = g.name;
    }
    tmp___11 = strlen((char const   *)tmp___10);
    if ((unsigned long )g.name == (unsigned long )((void *)0)) {
      tmp___12 = g.alias;
    } else {
      tmp___12 = g.name;
    }
    tmp___13 = writen(g.outd, (void const   *)tmp___12, tmp___11);
    cent += tmp___13;
    if (zip64) {
      tmp___14 = put(g.outd, 2, (val_t )1, 2, (val_t )16, 8, ulen, 8, clen, 0);
      cent += (length_t )tmp___14;
    }
    tmp___15 = put(g.outd, 2, (val_t )21589, 2, (val_t )5, 1, (val_t )1, 4, (val_t )g.mtime,
                   0);
    cent += (length_t )tmp___15;
    if ((unsigned long )g.comment != (unsigned long )((void *)0)) {
      tmp___16 = strlen((char const   *)g.comment);
      tmp___17 = writen(g.outd, (void const   *)g.comment, tmp___16);
      cent += tmp___17;
    }
    zip64 = (head + clen) + desc >= 4294967295UL;
    if (zip64) {
      put(g.outd, 4, (val_t )101075792, 8, (val_t )44, 2, (val_t )45, 2, (val_t )45,
          4, (val_t )0, 4, (val_t )0, 8, (val_t )1, 8, (val_t )1, 8, cent, 8, (head + clen) + desc,
          4, (val_t )117853008, 4, (val_t )0, 8, ((head + clen) + desc) + cent, 4,
          (val_t )1, 0);
    }
    if (zip64) {
      tmp___18 = (length_t )4294967295U;
    } else {
      tmp___18 = (head + clen) + desc;
    }
    if (zip64) {
      tmp___19 = (length_t )4294967295U;
    } else {
      tmp___19 = cent;
    }
    if (zip64) {
      tmp___20 = 65535;
    } else {
      tmp___20 = 1;
    }
    if (zip64) {
      tmp___21 = 65535;
    } else {
      tmp___21 = 1;
    }
    put(g.outd, 4, (val_t )101010256, 2, (val_t )0, 2, (val_t )0, 2, (val_t )tmp___21,
        2, (val_t )tmp___20, 4, tmp___19, 4, tmp___18, 2, (val_t )0, 0);
  } else
  if (g.form) {
    put(g.outd, -4, check, 0);
  } else {
    put(g.outd, 4, check, 4, ulen, 0);
  }
  return;
}
}
static unsigned long adler32z(unsigned long adler , unsigned char const   *buf , size_t len ) 
{ 
  uLong tmp ;

  {
  while (1) {
    if (len > 4294967295UL) {
      if (! ((unsigned long )buf != (unsigned long )((void *)0))) {
        break;
      }
    } else {
      break;
    }
    adler = adler32(adler, buf, 4294967295U);
    buf += 4294967295U;
    len -= 4294967295UL;
  }
  tmp = adler32(adler, buf, (unsigned int )len);
  return (tmp);
}
}
static unsigned long crc32z(unsigned long crc , unsigned char const   *buf , size_t len ) 
{ 
  uLong tmp ;

  {
  while (1) {
    if (len > 4294967295UL) {
      if (! ((unsigned long )buf != (unsigned long )((void *)0))) {
        break;
      }
    } else {
      break;
    }
    crc = crc32(crc, buf, 4294967295U);
    buf += 4294967295U;
    len -= 4294967295UL;
  }
  tmp = crc32(crc, buf, (unsigned int )len);
  return (tmp);
}
}
static long zlib_vernum(void) 
{ 
  char const   *ver ;
  char const   *tmp ;
  long num___0 ;
  int left ;
  int comp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = zlibVersion();
  ver = tmp;
  num___0 = 0L;
  left = 4;
  comp = 0;
  while (1) {
    if ((int const   )*ver >= 48) {
      if ((int const   )*ver <= 57) {
        comp = (10 * comp + (int )*ver) - 48;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      if (comp > 15) {
        tmp___0 = 15;
      } else {
        tmp___0 = comp;
      }
      num___0 = (num___0 << 4) + (long )tmp___0;
      left --;
      if ((int const   )*ver != 46) {
        break;
      }
      comp = 0;
    }
    ver ++;
    if (! left) {
      break;
    }
  }
  if (left < 2) {
    tmp___1 = num___0 << (left << 2);
  } else {
    tmp___1 = -1L;
  }
  return (tmp___1);
}
}
static crc_t multmodp(crc_t a , crc_t b ) 
{ 
  crc_t m ;
  crc_t p ;

  {
  m = 1U << 31;
  p = (crc_t )0;
  while (1) {
    if (a & m) {
      p ^= b;
      if ((a & (m - 1U)) == 0U) {
        break;
      }
    }
    m >>= 1;
    if (b & 1U) {
      b = (b >> 1) ^ 3988292384U;
    } else {
      b >>= 1;
    }
  }
  return (p);
}
}
static crc_t const   x2n_table[32]  = 
  {      (crc_t const   )1073741824,      (crc_t const   )536870912,      (crc_t const   )134217728,      (crc_t const   )8388608, 
        (crc_t const   )32768,      (crc_t const   )3988292384U,      (crc_t const   )2984685714U,      (crc_t const   )2691310871U, 
        (crc_t const   )3982654894U,      (crc_t const   )2295415911U,      (crc_t const   )3619421802U,      (crc_t const   )3963911953U, 
        (crc_t const   )2390663536U,      (crc_t const   )1680310286,      (crc_t const   )1296546528,      (crc_t const   )167662735, 
        (crc_t const   )2206543119U,      (crc_t const   )808857370,      (crc_t const   )2069535939,      (crc_t const   )838779241, 
        (crc_t const   )2683044394U,      (crc_t const   )1821240772,      (crc_t const   )366380877,      (crc_t const   )1608415822, 
        (crc_t const   )3134787127U,      (crc_t const   )776888047,      (crc_t const   )1319870996,      (crc_t const   )2829349568U, 
        (crc_t const   )1117427358,      (crc_t const   )344797226,      (crc_t const   )3289097936U,      (crc_t const   )3303156796U};
static crc_t x2nmodp(size_t n , unsigned int k ) 
{ 
  crc_t p ;

  {
  p = 1U << 31;
  while (n) {
    if (n & 1UL) {
      p = multmodp((crc_t )x2n_table[k & 31U], p);
    }
    n >>= 1;
    k ++;
  }
  return (p);
}
}
static unsigned long crc32_comb(unsigned long crc1 , unsigned long crc2 , size_t len2 ) 
{ 
  crc_t tmp ;
  crc_t tmp___0 ;
  crc_t tmp___1 ;

  {
  if (len2 == g.block) {
    tmp___0 = g.shift;
  } else {
    tmp = x2nmodp(len2, 3U);
    tmp___0 = tmp;
  }
  tmp___1 = multmodp(tmp___0, (crc_t )crc1);
  return ((unsigned long )tmp___1 ^ crc2);
}
}
static unsigned long adler32_comb(unsigned long adler1 , unsigned long adler2 , size_t len2 ) 
{ 
  unsigned long sum1 ;
  unsigned long sum2 ;
  unsigned int rem ;

  {
  rem = (unsigned int )(len2 % 65521UL);
  sum1 = adler1 & 65535UL;
  sum2 = ((unsigned long )rem * sum1) % 65521UL;
  sum1 += ((adler2 & 65535UL) + 65521UL) - 1UL;
  sum2 += ((((adler1 >> 16) & 65535UL) + ((adler2 >> 16) & 65535UL)) + 65521UL) - (unsigned long )rem;
  if (sum1 >= 65521UL) {
    sum1 -= 65521UL;
  }
  if (sum1 >= 65521UL) {
    sum1 -= 65521UL;
  }
  if (sum2 >= (unsigned long )(65521U << 1)) {
    sum2 -= (unsigned long )(65521U << 1);
  }
  if (sum2 >= 65521UL) {
    sum2 -= 65521UL;
  }
  return (sum1 | (sum2 << 16));
}
}
static void new_pool(struct pool *pool , size_t size , int limit ) 
{ 


  {
  pool->have = new_lock_(0L, "pigz.c", 1457L);
  pool->head = (struct space *)((void *)0);
  pool->size = size;
  pool->limit = limit;
  pool->made = 0;
  return;
}
}
static struct space *get_space(struct pool *pool ) 
{ 
  struct space *space ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  possess_(pool->have, "pigz.c", 1470L);
  if (pool->limit == 0) {
    wait_for_(pool->have, (enum wait_op )1, 0L, "pigz.c", 1472L);
  }
  if ((unsigned long )pool->head != (unsigned long )((void *)0)) {
    space = pool->head;
    pool->head = space->next;
    twist_(pool->have, (enum twist_op )1, -1L, "pigz.c", 1478L);
    possess_(space->use, "pigz.c", 1479L);
    twist_(space->use, (enum twist_op )0, 1L, "pigz.c", 1480L);
    space->len = (size_t )0;
    return (space);
  }
  if (! (pool->limit != 0)) {
    __assert_fail("pool->limit != 0", "pigz.c", 1486U, "get_space");
  }
  if (pool->limit > 0) {
    (pool->limit) --;
  }
  (pool->made) ++;
  release_(pool->have, "pigz.c", 1490L);
  tmp___0 = alloc((void *)0, sizeof(struct space ));
  space = (struct space *)tmp___0;
  space->use = new_lock_(1L, "pigz.c", 1492L);
  tmp___1 = alloc((void *)0, pool->size);
  space->buf = (unsigned char *)tmp___1;
  space->size = pool->size;
  space->len = (size_t )0;
  space->pool = pool;
  return (space);
}
}
static void grow_space(struct space *space ) 
{ 
  size_t more ;
  void *tmp ;

  {
  more = grow(space->size);
  if (more == space->size) {
    try_throw_(34, (char *)"overflow", (void *)0);
  }
  tmp = alloc((void *)space->buf, more);
  space->buf = (unsigned char *)tmp;
  space->size = more;
  return;
}
}
static void use_space(struct space *space ) 
{ 
  long use ;

  {
  possess_(space->use, "pigz.c", 1519L);
  use = peek_lock(space->use);
  if (! (use != 0L)) {
    __assert_fail("use != 0", "pigz.c", 1521U, "use_space");
  }
  twist_(space->use, (enum twist_op )1, 1L, "pigz.c", 1522L);
  return;
}
}
static void drop_space(struct space *space ) 
{ 
  long use ;
  struct pool *pool ;

  {
  if ((unsigned long )space == (unsigned long )((void *)0)) {
    return;
  }
  possess_(space->use, "pigz.c", 1532L);
  use = peek_lock(space->use);
  if (! (use != 0L)) {
    __assert_fail("use != 0", "pigz.c", 1534U, "drop_space");
  }
  twist_(space->use, (enum twist_op )1, -1L, "pigz.c", 1535L);
  if (use == 1L) {
    pool = space->pool;
    possess_(pool->have, "pigz.c", 1538L);
    space->next = pool->head;
    pool->head = space;
    twist_(pool->have, (enum twist_op )1, 1L, "pigz.c", 1541L);
  }
  return;
}
}
static int free_pool(struct pool *pool ) 
{ 
  int count ;
  struct space *space ;

  {
  possess_(pool->have, "pigz.c", 1551L);
  count = 0;
  while (1) {
    space = pool->head;
    if (! ((unsigned long )space != (unsigned long )((void *)0))) {
      break;
    }
    pool->head = space->next;
    free((void *)space->buf);
    free_lock_(space->use, "pigz.c", 1556L);
    free((void *)space);
    count ++;
  }
  if (! (count == pool->made)) {
    __assert_fail("count == pool->made", "pigz.c", 1560U, "free_pool");
  }
  release_(pool->have, "pigz.c", 1561L);
  free_lock_(pool->have, "pigz.c", 1562L);
  return (count);
}
}
static struct pool in_pool  ;
static struct pool out_pool  ;
static struct pool dict_pool  ;
static struct pool lens_pool  ;
static lock *compress_have  =    (lock *)((void *)0);
static struct job *compress_head  ;
static struct job **compress_tail  ;
static lock *write_first  ;
static struct job *write_head  ;
static int cthreads  =    0;
static thread *writeth  =    (thread *)((void *)0);
static void setup_jobs(void) 
{ 


  {
  if ((unsigned long )compress_have != (unsigned long )((void *)0)) {
    return;
  }
  compress_have = new_lock_(0L, "pigz.c", 1609L);
  compress_head = (struct job *)((void *)0);
  compress_tail = & compress_head;
  write_first = new_lock_(-1L, "pigz.c", 1612L);
  write_head = (struct job *)((void *)0);
  new_pool(& in_pool, g.block, (g.procs << 1) + 3);
  new_pool(& out_pool, (g.block + (g.block >> 4)) + 32768UL, -1);
  new_pool(& dict_pool, (size_t )32768U, -1);
  new_pool(& lens_pool, g.block >> 11, -1);
  return;
}
}
static void finish_jobs(void) 
{ 
  struct job job ;
  int caught ;

  {
  if ((unsigned long )compress_have == (unsigned long )((void *)0)) {
    return;
  }
  possess_(compress_have, "pigz.c", 1635L);
  job.seq = -1L;
  job.next = (struct job *)((void *)0);
  compress_head = & job;
  compress_tail = & job.next;
  twist_(compress_have, (enum twist_op )1, 1L, "pigz.c", 1640L);
  caught = join_all_("pigz.c", 1643L);
  if (! (caught == cthreads)) {
    __assert_fail("caught == cthreads", "pigz.c", 1645U, "finish_jobs");
  }
  cthreads = 0;
  caught = free_pool(& lens_pool);
  caught = free_pool(& dict_pool);
  caught = free_pool(& out_pool);
  caught = free_pool(& in_pool);
  free_lock_(write_first, "pigz.c", 1657L);
  free_lock_(compress_have, "pigz.c", 1658L);
  compress_have = (lock *)((void *)0);
  return;
}
}
static void deflate_engine(z_stream *strm___0 , struct space *out___0 , int flush ) 
{ 
  size_t room ;

  {
  while (1) {
    room = out___0->size - out___0->len;
    if (room == 0UL) {
      grow_space(out___0);
      room = out___0->size - out___0->len;
    }
    strm___0->next_out = out___0->buf + out___0->len;
    if (room < 4294967295UL) {
      strm___0->avail_out = (unsigned int )room;
    } else {
      strm___0->avail_out = 4294967295U;
    }
    deflate(strm___0, flush);
    out___0->len = (size_t )(strm___0->next_out - out___0->buf);
    if (! (strm___0->avail_out == 0U)) {
      break;
    }
  }
  if (! (strm___0->avail_in == 0U)) {
    __assert_fail("strm->avail_in == 0", "pigz.c", 1680U, "deflate_engine");
  }
  return;
}
}
static void compress_thread(void *dummy ) 
{ 
  struct job *job ;
  struct job *here ;
  struct job **prior ;
  unsigned long check ;
  unsigned char *next___0 ;
  size_t left ;
  size_t len ;
  int bits ;
  int ret ;
  try_ball_t_ err ;
  try_t_ try_this_ ;
  int volatile   try_pushed_ ;
  void *tmp ;
  int tmp___3 ;
  z_stream strm___0 ;
  struct space *temp ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  long tmp___13 ;
  unsigned char bits___0 ;
  unsigned char *out___0 ;
  size_t outsize ;
  int tmp___14 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  size_t tmp___26 ;
  unsigned long tmp___27 ;
  unsigned long tmp___28 ;
  unsigned long tmp___29 ;
  unsigned long tmp___30 ;
  unsigned long tmp___31 ;
  unsigned long tmp___32 ;
  int tmp___33 ;
  int tmp___37 ;

  {
  while (1) {
    try_pushed_ = (int volatile   )1;
    try_this_.ball.ret = 0;
    try_this_.ball.code = 0;
    try_this_.ball.free = 0;
    try_this_.ball.why = (char *)((void *)0);
    try_setup_();
    tmp = pthread_getspecific(try_key_);
    try_this_.next = (try_t_ *)tmp;
    while (1) {
      tmp___3 = pthread_setspecific(try_key_, (void const   *)(& try_this_));
      if (tmp___3 == 0) {
        if (! "try: pthread_setspecific() failed") {
          __assert_fail("pthread_setspecific(try_key_, &try_this_) == 0 && \"try: pthread_setspecific() failed\"",
                        "pigz.c", 1703U, "compress_thread");
        }
      } else {
        __assert_fail("pthread_setspecific(try_key_, &try_this_) == 0 && \"try: pthread_setspecific() failed\"",
                      "pigz.c", 1703U, "compress_thread");
      }
      break;
    }
    tmp___33 = _setjmp((struct __jmp_buf_tag *)(try_this_.env));
    if (tmp___33 == 0) {
      while (1) {
        temp = (struct space *)((void *)0);
        if (g.level > 9) {
          temp = get_space(& out_pool);
        } else {
          strm___0.zfree = (void (*)(voidpf opaque , voidpf address ))0;
          strm___0.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))0;
          strm___0.opaque = (voidpf )0;
          ret = deflateInit2_(& strm___0, 6, 8, -15, 8, g.strategy, "1.2.11", (int )sizeof(z_stream ));
          if (ret == -4) {
            try_throw_(12, (char *)"not enough memory", (void *)0);
          }
          if (ret != 0) {
            try_throw_(22, (char *)"internal error", (void *)0);
          }
        }
        while (1) {
          possess_(compress_have, "pigz.c", 1727L);
          wait_for_(compress_have, (enum wait_op )1, 0L, "pigz.c", 1728L);
          job = compress_head;
          if (! ((unsigned long )job != (unsigned long )((void *)0))) {
            __assert_fail("job != NULL", "pigz.c", 1730U, "compress_thread");
          }
          if (job->seq == -1L) {
            break;
          }
          compress_head = job->next;
          if ((unsigned long )job->next == (unsigned long )((void *)0)) {
            compress_tail = & compress_head;
          }
          twist_(compress_have, (enum twist_op )1, -1L, "pigz.c", 1736L);
          if (g.level <= 9) {
            deflateReset(& strm___0);
            deflateParams(& strm___0, g.level, g.strategy);
          } else {
            temp->len = (size_t )0;
          }
          if ((unsigned long )job->out != (unsigned long )((void *)0)) {
            len = (job->out)->len;
            if (len < 32768UL) {
              left = len;
            } else {
              left = (size_t )32768U;
            }
            if (g.level <= 9) {
              deflateSetDictionary(& strm___0, (Bytef const   *)((job->out)->buf + (len - left)),
                                   (unsigned int )left);
            } else {
              memcpy((void * __restrict  )temp->buf, (void const   * __restrict  )((job->out)->buf + (len - left)),
                     left);
              temp->len = left;
            }
            drop_space(job->out);
          }
          job->out = get_space(& out_pool);
          if (g.level <= 9) {
            strm___0.next_in = (job->in)->buf;
            strm___0.next_out = (job->out)->buf;
          } else {
            memcpy((void * __restrict  )(temp->buf + temp->len), (void const   * __restrict  )(job->in)->buf,
                   (job->in)->len);
          }
          if ((unsigned long )job->lens == (unsigned long )((void *)0)) {
            next___0 = (unsigned char *)((void *)0);
          } else {
            next___0 = (job->lens)->buf;
          }
          left = (job->in)->len;
          (job->out)->len = (size_t )0;
          while (1) {
            if ((unsigned long )next___0 == (unsigned long )((void *)0)) {
              len = (size_t )128;
            } else {
              tmp___5 = next___0;
              next___0 ++;
              len = (size_t )*tmp___5;
            }
            if (len < 128UL) {
              tmp___6 = next___0;
              next___0 ++;
              len = ((len << 8) + (size_t )*tmp___6) + 64UL;
            } else
            if (len == 128UL) {
              len = left;
            } else
            if (len < 192UL) {
              len &= 63UL;
            } else
            if (len < 224UL) {
              tmp___7 = next___0;
              next___0 ++;
              len = ((len & 31UL) << 16) + ((size_t )*tmp___7 << 8);
              tmp___8 = next___0;
              next___0 ++;
              len += (size_t )((unsigned int )*tmp___8 + 32832U);
            } else {
              tmp___9 = next___0;
              next___0 ++;
              len = ((len & 31UL) << 24) + ((size_t )*tmp___9 << 16);
              tmp___10 = next___0;
              next___0 ++;
              len += (size_t )*tmp___10 << 8;
              tmp___11 = next___0;
              next___0 ++;
              len += (size_t )*tmp___11 + 2129984UL;
            }
            left -= len;
            if (g.level <= 9) {
              while (len > (size_t )(4294967295U - (4294967295U >> 1))) {
                strm___0.avail_in = 4294967295U - (4294967295U >> 1);
                deflate_engine(& strm___0, job->out, 0);
                len -= (size_t )(4294967295U - (4294967295U >> 1));
              }
              strm___0.avail_in = (unsigned int )len;
              if (left) {
                goto _L;
              } else
              if (job->more) {
                _L: /* CIL Label */ 
                tmp___13 = zlib_vernum();
                if (tmp___13 >= 4704L) {
                  deflate_engine(& strm___0, job->out, 5);
                  deflatePending(& strm___0, (unsigned int *)0, & bits);
                  if (bits & 1) {
                    deflate_engine(& strm___0, job->out, 2);
                  } else
                  if (! g.setdict) {
                    deflate_engine(& strm___0, job->out, 2);
                  } else
                  if (bits & 7) {
                    while (1) {
                      bits = deflatePrime(& strm___0, 10, 2);
                      if (! (bits == 0)) {
                        __assert_fail("bits == Z_OK", "pigz.c", 1840U, "compress_thread");
                      }
                      deflatePending(& strm___0, (unsigned int *)0, & bits);
                      if (! (bits & 7)) {
                        break;
                      }
                    }
                    deflate_engine(& strm___0, job->out, 5);
                  }
                } else {
                  deflate_engine(& strm___0, job->out, 2);
                }
                if (! g.setdict) {
                  deflate_engine(& strm___0, job->out, 3);
                }
              } else {
                deflate_engine(& strm___0, job->out, 4);
              }
            } else {
              out___0 = (unsigned char *)((void *)0);
              outsize = (size_t )0;
              bits___0 = (unsigned char)0;
              if (left) {
                tmp___14 = 0;
              } else
              if (job->more) {
                tmp___14 = 0;
              } else {
                tmp___14 = 1;
              }
              ZopfliDeflatePart((ZopfliOptions const   *)(& g.zopts), 2, tmp___14,
                                (unsigned char const   *)temp->buf, temp->len, temp->len + len,
                                & bits___0, & out___0, & outsize);
              if (! (((job->out)->len + outsize) + 5UL <= (job->out)->size)) {
                __assert_fail("job->out->len + outsize + 5 <= job->out->size", "pigz.c",
                              1869U, "compress_thread");
              }
              memcpy((void * __restrict  )((job->out)->buf + (job->out)->len), (void const   * __restrict  )out___0,
                     outsize);
              free((void *)out___0);
              (job->out)->len += outsize;
              if (left) {
                goto _L___1;
              } else
              if (job->more) {
                _L___1: /* CIL Label */ 
                bits___0 = (unsigned char )((int )bits___0 & 7);
                if ((int )bits___0 & 1) {
                  goto _L___0;
                } else
                if (! g.setdict) {
                  _L___0: /* CIL Label */ 
                  if ((int )bits___0 == 0) {
                    tmp___16 = (job->out)->len;
                    ((job->out)->len) ++;
                    *((job->out)->buf + tmp___16) = (unsigned char)0;
                  } else
                  if ((int )bits___0 > 5) {
                    tmp___16 = (job->out)->len;
                    ((job->out)->len) ++;
                    *((job->out)->buf + tmp___16) = (unsigned char)0;
                  }
                  tmp___17 = (job->out)->len;
                  ((job->out)->len) ++;
                  *((job->out)->buf + tmp___17) = (unsigned char)0;
                  tmp___18 = (job->out)->len;
                  ((job->out)->len) ++;
                  *((job->out)->buf + tmp___18) = (unsigned char)0;
                  tmp___19 = (job->out)->len;
                  ((job->out)->len) ++;
                  *((job->out)->buf + tmp___19) = (unsigned char)255;
                  tmp___20 = (job->out)->len;
                  ((job->out)->len) ++;
                  *((job->out)->buf + tmp___20) = (unsigned char)255;
                } else
                if (bits___0) {
                  while (1) {
                    *((job->out)->buf + ((job->out)->len - 1UL)) = (unsigned char )((int )*((job->out)->buf + ((job->out)->len - 1UL)) + (2 << (int )bits___0));
                    tmp___21 = (job->out)->len;
                    ((job->out)->len) ++;
                    *((job->out)->buf + tmp___21) = (unsigned char)0;
                    bits___0 = (unsigned char )((int )bits___0 + 2);
                    if (! ((int )bits___0 < 8)) {
                      break;
                    }
                  }
                }
                if (! g.setdict) {
                  tmp___22 = (job->out)->len;
                  ((job->out)->len) ++;
                  *((job->out)->buf + tmp___22) = (unsigned char)0;
                  tmp___23 = (job->out)->len;
                  ((job->out)->len) ++;
                  *((job->out)->buf + tmp___23) = (unsigned char)0;
                  tmp___24 = (job->out)->len;
                  ((job->out)->len) ++;
                  *((job->out)->buf + tmp___24) = (unsigned char)0;
                  tmp___25 = (job->out)->len;
                  ((job->out)->len) ++;
                  *((job->out)->buf + tmp___25) = (unsigned char)255;
                  tmp___26 = (job->out)->len;
                  ((job->out)->len) ++;
                  *((job->out)->buf + tmp___26) = (unsigned char)255;
                }
              }
              temp->len += len;
            }
            if (! left) {
              break;
            }
          }
          drop_space(job->lens);
          job->lens = (struct space *)((void *)0);
          use_space(job->in);
          possess_(write_first, "pigz.c", 1911L);
          prior = & write_head;
          while (1) {
            here = *prior;
            if (! ((unsigned long )here != (unsigned long )((void *)0))) {
              break;
            }
            if (here->seq > job->seq) {
              break;
            }
            prior = & here->next;
          }
          job->next = here;
          *prior = job;
          twist_(write_first, (enum twist_op )0, write_head->seq, "pigz.c", 1920L);
          len = (job->in)->len;
          next___0 = (job->in)->buf;
          if (g.form == 1) {
            tmp___27 = adler32z(0UL, (unsigned char const   *)0, (size_t )0);
            check = tmp___27;
          } else {
            tmp___28 = crc32z(0UL, (unsigned char const   *)0, (size_t )0);
            check = tmp___28;
          }
          while (len > (size_t )(4294967295U - (4294967295U >> 1))) {
            if (g.form == 1) {
              tmp___29 = adler32z(check, (unsigned char const   *)next___0, (size_t )(4294967295U - (4294967295U >> 1)));
              check = tmp___29;
            } else {
              tmp___30 = crc32z(check, (unsigned char const   *)next___0, (size_t )(4294967295U - (4294967295U >> 1)));
              check = tmp___30;
            }
            len -= (size_t )(4294967295U - (4294967295U >> 1));
            next___0 += 4294967295U - (4294967295U >> 1);
          }
          if (g.form == 1) {
            tmp___31 = adler32z(check, (unsigned char const   *)next___0, (size_t )((unsigned int )len));
            check = tmp___31;
          } else {
            tmp___32 = crc32z(check, (unsigned char const   *)next___0, (size_t )((unsigned int )len));
            check = tmp___32;
          }
          drop_space(job->in);
          job->check = check;
          possess_(job->calc, "pigz.c", 1937L);
          twist_(job->calc, (enum twist_op )0, 1L, "pigz.c", 1938L);
        }
        release_(compress_have, "pigz.c", 1944L);
        if (g.level > 9) {
          drop_space(temp);
        } else {
          deflateEnd(& strm___0);
        }
        break;
      }
    }
    if (try_pushed_) {
      while (1) {
        tmp___37 = pthread_setspecific(try_key_, (void const   *)try_this_.next);
        if (tmp___37 == 0) {
          if (! "try: pthread_setspecific() failed") {
            __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                          "pigz.c", 1954U, "compress_thread");
          }
        } else {
          __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                        "pigz.c", 1954U, "compress_thread");
        }
        break;
      }
      try_pushed_ = (int volatile   )0;
    }
    err = try_this_.ball;
    break;
  }
  if (err.code) {
    while (1) {
      if (err.code != 32) {
        complain((char *)"abort: %s", err.why);
      }
      while (1) {
        if (err.free) {
          free((void *)err.why);
          err.free = 0;
          err.why = (char *)((void *)0);
        }
        break;
      }
      cut_short(- err.code);
      break;
    }
  }
  return;
}
}
static void write_thread(void *dummy ) 
{ 
  long seq ;
  struct job *job ;
  size_t len ;
  int more ;
  length_t head ;
  length_t ulen ;
  length_t clen ;
  unsigned long check ;
  try_ball_t_ err ;
  try_t_ try_this_ ;
  int volatile   try_pushed_ ;
  void *tmp ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  long tmp___6 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  long tmp___12 ;
  int tmp___14 ;
  int tmp___18 ;

  {
  while (1) {
    try_pushed_ = (int volatile   )1;
    try_this_.ball.ret = 0;
    try_this_.ball.code = 0;
    try_this_.ball.free = 0;
    try_this_.ball.why = (char *)((void *)0);
    try_setup_();
    tmp = pthread_getspecific(try_key_);
    try_this_.next = (try_t_ *)tmp;
    while (1) {
      tmp___3 = pthread_setspecific(try_key_, (void const   *)(& try_this_));
      if (tmp___3 == 0) {
        if (! "try: pthread_setspecific() failed") {
          __assert_fail("pthread_setspecific(try_key_, &try_this_) == 0 && \"try: pthread_setspecific() failed\"",
                        "pigz.c", 1975U, "write_thread");
        }
      } else {
        __assert_fail("pthread_setspecific(try_key_, &try_this_) == 0 && \"try: pthread_setspecific() failed\"",
                      "pigz.c", 1975U, "write_thread");
      }
      break;
    }
    tmp___14 = _setjmp((struct __jmp_buf_tag *)(try_this_.env));
    if (tmp___14 == 0) {
      while (1) {
        head = put_header();
        clen = (length_t )0;
        ulen = clen;
        if (g.form == 1) {
          tmp___4 = adler32z(0UL, (unsigned char const   *)0, (size_t )0);
          check = tmp___4;
        } else {
          tmp___5 = crc32z(0UL, (unsigned char const   *)0, (size_t )0);
          check = tmp___5;
        }
        seq = 0L;
        while (1) {
          possess_(write_first, "pigz.c", 1986L);
          wait_for_(write_first, (enum wait_op )0, seq, "pigz.c", 1987L);
          job = write_head;
          write_head = job->next;
          if ((unsigned long )write_head == (unsigned long )((void *)0)) {
            tmp___6 = -1L;
          } else {
            tmp___6 = write_head->seq;
          }
          twist_(write_first, (enum twist_op )0, tmp___6, "pigz.c", 1990L);
          more = job->more;
          len = (job->in)->len;
          drop_space(job->in);
          ulen += len;
          clen += (job->out)->len;
          writen(g.outd, (void const   *)(job->out)->buf, (job->out)->len);
          drop_space(job->out);
          possess_(job->calc, "pigz.c", 2007L);
          wait_for_(job->calc, (enum wait_op )0, 1L, "pigz.c", 2008L);
          release_(job->calc, "pigz.c", 2009L);
          if (g.form == 1) {
            tmp___7 = adler32_comb(check, job->check, len);
            check = tmp___7;
          } else {
            tmp___8 = crc32_comb(check, job->check, len);
            check = tmp___8;
          }
          free_lock_(job->calc, "pigz.c", 2014L);
          free((void *)job);
          seq ++;
          if (! more) {
            break;
          }
        }
        put_trailer(ulen, clen, check, head);
        possess_(compress_have, "pigz.c", 2025L);
        if ((unsigned long )compress_head == (unsigned long )((void *)0)) {
          tmp___12 = peek_lock(compress_have);
          if (! (tmp___12 == 0L)) {
            __assert_fail("compress_head == NULL && peek_lock(compress_have) == 0",
                          "pigz.c", 2026U, "write_thread");
          }
        } else {
          __assert_fail("compress_head == NULL && peek_lock(compress_have) == 0",
                        "pigz.c", 2026U, "write_thread");
        }
        release_(compress_have, "pigz.c", 2027L);
        possess_(write_first, "pigz.c", 2028L);
        if (! ((unsigned long )write_head == (unsigned long )((void *)0))) {
          __assert_fail("write_head == NULL", "pigz.c", 2029U, "write_thread");
        }
        twist_(write_first, (enum twist_op )0, -1L, "pigz.c", 2030L);
        break;
      }
    }
    if (try_pushed_) {
      while (1) {
        tmp___18 = pthread_setspecific(try_key_, (void const   *)try_this_.next);
        if (tmp___18 == 0) {
          if (! "try: pthread_setspecific() failed") {
            __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                          "pigz.c", 2032U, "write_thread");
          }
        } else {
          __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                        "pigz.c", 2032U, "write_thread");
        }
        break;
      }
      try_pushed_ = (int volatile   )0;
    }
    err = try_this_.ball;
    break;
  }
  if (err.code) {
    while (1) {
      if (err.code != 32) {
        complain((char *)"abort: %s", err.why);
      }
      while (1) {
        if (err.free) {
          free((void *)err.why);
          err.free = 0;
          err.why = (char *)((void *)0);
        }
        break;
      }
      cut_short(- err.code);
      break;
    }
  }
  return;
}
}
static void append_len(struct job *job , size_t len ) 
{ 
  struct space *lens ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;

  {
  if (! (len < 539000896UL)) {
    __assert_fail("len < 539000896UL", "pigz.c", 2041U, "append_len");
  }
  if ((unsigned long )job->lens == (unsigned long )((void *)0)) {
    job->lens = get_space(& lens_pool);
  }
  lens = job->lens;
  if (lens->size < lens->len + 3UL) {
    grow_space(lens);
  }
  if (len < 64UL) {
    tmp___0 = lens->len;
    (lens->len) ++;
    *(lens->buf + tmp___0) = (unsigned char )(len + 128UL);
  } else
  if (len < 32832UL) {
    len -= 64UL;
    tmp___1 = lens->len;
    (lens->len) ++;
    *(lens->buf + tmp___1) = (unsigned char )(len >> 8);
    tmp___2 = lens->len;
    (lens->len) ++;
    *(lens->buf + tmp___2) = (unsigned char )len;
  } else
  if (len < 2129984UL) {
    len -= 32832UL;
    tmp___3 = lens->len;
    (lens->len) ++;
    *(lens->buf + tmp___3) = (unsigned char )((len >> 16) + 192UL);
    tmp___4 = lens->len;
    (lens->len) ++;
    *(lens->buf + tmp___4) = (unsigned char )(len >> 8);
    tmp___5 = lens->len;
    (lens->len) ++;
    *(lens->buf + tmp___5) = (unsigned char )len;
  } else {
    len -= 2129984UL;
    tmp___6 = lens->len;
    (lens->len) ++;
    *(lens->buf + tmp___6) = (unsigned char )((len >> 24) + 224UL);
    tmp___7 = lens->len;
    (lens->len) ++;
    *(lens->buf + tmp___7) = (unsigned char )(len >> 16);
    tmp___8 = lens->len;
    (lens->len) ++;
    *(lens->buf + tmp___8) = (unsigned char )(len >> 8);
    tmp___9 = lens->len;
    (lens->len) ++;
    *(lens->buf + tmp___9) = (unsigned char )len;
  }
  return;
}
}
static void parallel_compress(void) 
{ 
  long seq ;
  struct space *curr ;
  struct space *next___0 ;
  struct space *hold ;
  struct space *dict ;
  struct job *job ;
  int more ;
  unsigned int hash ;
  unsigned char *scan ;
  unsigned char *end ;
  unsigned char *last ;
  size_t left ;
  size_t len ;
  void *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;

  {
  setup_jobs();
  writeth = launch_(& write_thread, (void *)0, "pigz.c", 2092L);
  seq = 0L;
  next___0 = get_space(& in_pool);
  next___0->len = readn(g.ind, next___0->buf, next___0->size);
  hold = (struct space *)((void *)0);
  dict = (struct space *)((void *)0);
  scan = next___0->buf;
  hash = ((1U << 12) - 1U) >> 1;
  left = (size_t )0;
  while (1) {
    tmp = alloc((void *)0, sizeof(struct job ));
    job = (struct job *)tmp;
    job->calc = new_lock_(0L, "pigz.c", 2107L);
    curr = next___0;
    next___0 = hold;
    hold = (struct space *)((void *)0);
    if ((unsigned long )next___0 == (unsigned long )((void *)0)) {
      next___0 = get_space(& in_pool);
      next___0->len = readn(g.ind, next___0->buf, next___0->size);
    }
    job->lens = (struct space *)((void *)0);
    if (g.rsync) {
      if (curr->len) {
        if (left == 0UL) {
          last = curr->buf;
          end = curr->buf + curr->len;
          while ((unsigned long )scan < (unsigned long )end) {
            tmp___0 = scan;
            scan ++;
            hash = ((hash << 1) ^ (unsigned int )*tmp___0) & ((1U << 12) - 1U);
            if (hash == ((1U << 12) - 1U) >> 1) {
              len = (size_t )(scan - last);
              append_len(job, len);
              last = scan;
            }
          }
          left = (size_t )(scan - last);
          scan = next___0->buf;
        }
        last = next___0->buf;
        len = curr->size - curr->len;
        if (len > next___0->len) {
          len = next___0->len;
        }
        end = next___0->buf + len;
        while ((unsigned long )scan < (unsigned long )end) {
          tmp___1 = scan;
          scan ++;
          hash = ((hash << 1) ^ (unsigned int )*tmp___1) & ((1U << 12) - 1U);
          if (hash == ((1U << 12) - 1U) >> 1) {
            len = (size_t )(scan - last) + left;
            left = (size_t )0;
            append_len(job, len);
            last = scan;
          }
        }
        append_len(job, (size_t )0);
        if ((job->lens)->len == 1UL) {
          tmp___2 = scan;
        } else {
          tmp___2 = last;
        }
        len = (size_t )(tmp___2 - next___0->buf);
        if (len) {
          memcpy((void * __restrict  )(curr->buf + curr->len), (void const   * __restrict  )next___0->buf,
                 len);
          curr->len += len;
          memmove((void *)next___0->buf, (void const   *)(next___0->buf + len), next___0->len - len);
          next___0->len -= len;
          scan -= len;
          left = (size_t )0;
        } else
        if ((job->lens)->len != 1UL) {
          if (left) {
            if (next___0->len) {
              hold = next___0;
              next___0 = get_space(& in_pool);
              memcpy((void * __restrict  )next___0->buf, (void const   * __restrict  )(curr->buf + (curr->len - left)),
                     left);
              next___0->len = left;
              curr->len -= left;
            } else {
              left = (size_t )0;
            }
          } else {
            left = (size_t )0;
          }
        } else {
          left = (size_t )0;
        }
      }
    }
    job->in = curr;
    more = next___0->len != 0UL;
    job->more = more;
    job->out = dict;
    if (more) {
      if (g.setdict) {
        if (curr->len >= 32768UL) {
          dict = curr;
          use_space(dict);
        } else
        if ((unsigned long )job->out == (unsigned long )((void *)0)) {
          dict = curr;
          use_space(dict);
        } else {
          dict = get_space(& dict_pool);
          len = 32768UL - curr->len;
          memcpy((void * __restrict  )dict->buf, (void const   * __restrict  )((job->out)->buf + ((job->out)->len - len)),
                 len);
          memcpy((void * __restrict  )(dict->buf + len), (void const   * __restrict  )curr->buf,
                 curr->len);
          dict->len = (size_t )32768U;
        }
      }
    }
    job->seq = seq;
    seq ++;
    if (seq < 1L) {
      try_throw_(34, (char *)"overflow", (void *)0);
    }
    if ((long )cthreads < seq) {
      if (cthreads < g.procs) {
        launch_(& compress_thread, (void *)0, "pigz.c", 2228L);
        cthreads ++;
      }
    }
    possess_(compress_have, "pigz.c", 2233L);
    job->next = (struct job *)((void *)0);
    *compress_tail = job;
    compress_tail = & job->next;
    twist_(compress_have, (enum twist_op )1, 1L, "pigz.c", 2237L);
    if (! more) {
      break;
    }
  }
  drop_space(next___0);
  join_(writeth, "pigz.c", 2243L);
  writeth = (thread *)((void *)0);
  return;
}
}
static unsigned int out_size  ;
static unsigned char *in  ;
static unsigned char *next  ;
static unsigned char *out  ;
static void single_compress(int reset ) ;
static z_stream *strm  =    (z_stream *)((void *)0);
static void single_compress(int reset ) 
{ 
  size_t got ;
  size_t more ;
  size_t start ;
  size_t have ;
  size_t hist ;
  int fresh ;
  unsigned int hash ;
  unsigned char *scan ;
  size_t left ;
  unsigned long head ;
  length_t ulen ;
  length_t clen ;
  unsigned long check ;
  int ret ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned long tmp___6 ;
  unsigned long tmp___7 ;
  size_t tmp___8 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  int bits ;
  size_t tmp___12 ;
  size_t tmp___14 ;
  size_t tmp___17 ;
  size_t tmp___19 ;
  long tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___24 ;
  unsigned char bits___0 ;
  unsigned char *def ;
  size_t size ;
  size_t off ;
  int tmp___26 ;
  unsigned long tmp___28 ;
  unsigned long tmp___29 ;
  unsigned long tmp___30 ;
  unsigned long tmp___31 ;

  {
  if (reset) {
    if ((unsigned long )strm != (unsigned long )((void *)0)) {
      deflateEnd(strm);
      free((void *)strm);
      free((void *)out);
      free((void *)next);
      free((void *)in);
      strm = (z_stream *)((void *)0);
    }
    return;
  }
  if ((unsigned long )strm == (unsigned long )((void *)0)) {
    if (g.block > (size_t )(4294967295U - (4294967295U >> 1))) {
      out_size = 4294967295U - (4294967295U >> 1);
    } else {
      out_size = (unsigned int )g.block;
    }
    tmp = alloc((void *)0, g.block + 32768UL);
    in = (unsigned char *)tmp;
    tmp___0 = alloc((void *)0, g.block + 32768UL);
    next = (unsigned char *)tmp___0;
    tmp___1 = alloc((void *)0, (size_t )out_size);
    out = (unsigned char *)tmp___1;
    tmp___2 = alloc((void *)0, sizeof(z_stream ));
    strm = (z_stream *)tmp___2;
    strm->zfree = (void (*)(voidpf opaque , voidpf address ))0;
    strm->zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))0;
    strm->opaque = (voidpf )0;
    ret = deflateInit2_(strm, 6, 8, -15, 8, g.strategy, "1.2.11", (int )sizeof(z_stream ));
    if (ret == -4) {
      try_throw_(12, (char *)"not enough memory", (void *)0);
    }
    if (ret != 0) {
      try_throw_(22, (char *)"internal error", (void *)0);
    }
  }
  head = put_header();
  if (g.level <= 9) {
    deflateReset(strm);
    deflateParams(strm, g.level, g.strategy);
  }
  got = (size_t )0;
  more = readn(g.ind, next, g.block);
  ulen = more;
  start = (size_t )0;
  hist = (size_t )0;
  clen = (length_t )0;
  have = (size_t )0;
  if (g.form == 1) {
    tmp___3 = adler32z(0UL, (unsigned char const   *)0, (size_t )0);
    check = tmp___3;
  } else {
    tmp___4 = crc32z(0UL, (unsigned char const   *)0, (size_t )0);
    check = tmp___4;
  }
  hash = ((1U << 12) - 1U) >> 1;
  while (1) {
    if (got == 0UL) {
      scan = in;
      in = next;
      next = scan;
      strm->next_in = in + start;
      got = more;
      if (g.level > 9) {
        left = (start + more) - hist;
        if (left > 32768UL) {
          left = (size_t )32768U;
        }
        memcpy((void * __restrict  )next, (void const   * __restrict  )(in + ((start + more) - left)),
               left);
        start = left;
        hist = (size_t )0;
      } else {
        start = (size_t )0;
      }
      more = readn(g.ind, next + start, g.block);
      ulen += more;
    }
    left = (size_t )0;
    if (g.rsync) {
      if (got) {
        scan = strm->next_in;
        left = got;
        while (1) {
          if (left == 0UL) {
            if (more == 0UL) {
              break;
            } else
            if (got == g.block) {
              break;
            }
            if (g.level > 9) {
              left = (size_t )(strm->next_in - in) - hist;
              if (left > 32768UL) {
                left = (size_t )32768U;
              }
            }
            memmove((void *)in, (void const   *)(strm->next_in - left), left + got);
            hist = (size_t )0;
            strm->next_in = in + left;
            scan = (in + left) + got;
            if (more > g.block - got) {
              left = g.block - got;
            } else {
              left = more;
            }
            memcpy((void * __restrict  )scan, (void const   * __restrict  )(next + start),
                   left);
            got += left;
            more -= left;
            start += left;
            if (more == 0UL) {
              more = readn(g.ind, next, g.block);
              ulen += more;
              start = (size_t )0;
            }
          }
          left --;
          tmp___5 = scan;
          scan ++;
          hash = ((hash << 1) ^ (unsigned int )*tmp___5) & ((1U << 12) - 1U);
          if (! (hash != ((1U << 12) - 1U) >> 1)) {
            break;
          }
        }
        got -= left;
      }
    }
    fresh = 0;
    if (! g.setdict) {
      have += got;
      if (have > g.block) {
        fresh = 1;
        have = got;
      }
    }
    if (g.level <= 9) {
      if (fresh) {
        deflateReset(strm);
      }
      while (got > (size_t )(4294967295U - (4294967295U >> 1))) {
        strm->avail_in = 4294967295U - (4294967295U >> 1);
        if (g.form == 1) {
          tmp___6 = adler32z(check, (unsigned char const   *)strm->next_in, (size_t )strm->avail_in);
          check = tmp___6;
        } else {
          tmp___7 = crc32z(check, (unsigned char const   *)strm->next_in, (size_t )strm->avail_in);
          check = tmp___7;
        }
        while (1) {
          while (1) {
            strm->avail_out = out_size;
            strm->next_out = out;
            deflate(strm, 0);
            tmp___8 = writen(g.outd, (void const   *)out, (size_t )(out_size - strm->avail_out));
            clen += tmp___8;
            if (! (strm->avail_out == 0U)) {
              break;
            }
          }
          if (! (strm->avail_in == 0U)) {
            __assert_fail("strm->avail_in == 0", "pigz.c", 2421U, "single_compress");
          }
          break;
        }
        got -= (size_t )(4294967295U - (4294967295U >> 1));
      }
      strm->avail_in = (unsigned int )got;
      got = left;
      if (g.form == 1) {
        tmp___10 = adler32z(check, (unsigned char const   *)strm->next_in, (size_t )strm->avail_in);
        check = tmp___10;
      } else {
        tmp___11 = crc32z(check, (unsigned char const   *)strm->next_in, (size_t )strm->avail_in);
        check = tmp___11;
      }
      if (more) {
        goto _L___0;
      } else
      if (got) {
        _L___0: /* CIL Label */ 
        tmp___21 = zlib_vernum();
        if (tmp___21 >= 4704L) {
          while (1) {
            while (1) {
              strm->avail_out = out_size;
              strm->next_out = out;
              deflate(strm, 5);
              tmp___12 = writen(g.outd, (void const   *)out, (size_t )(out_size - strm->avail_out));
              clen += tmp___12;
              if (! (strm->avail_out == 0U)) {
                break;
              }
            }
            if (! (strm->avail_in == 0U)) {
              __assert_fail("strm->avail_in == 0", "pigz.c", 2434U, "single_compress");
            }
            break;
          }
          deflatePending(strm, (unsigned int *)0, & bits);
          if (bits & 1) {
            goto _L;
          } else
          if (! g.setdict) {
            _L: /* CIL Label */ 
            while (1) {
              while (1) {
                strm->avail_out = out_size;
                strm->next_out = out;
                deflate(strm, 2);
                tmp___14 = writen(g.outd, (void const   *)out, (size_t )(out_size - strm->avail_out));
                clen += tmp___14;
                if (! (strm->avail_out == 0U)) {
                  break;
                }
              }
              if (! (strm->avail_in == 0U)) {
                __assert_fail("strm->avail_in == 0", "pigz.c", 2437U, "single_compress");
              }
              break;
            }
          } else
          if (bits & 7) {
            while (1) {
              bits = deflatePrime(strm, 10, 2);
              if (! (bits == 0)) {
                __assert_fail("bits == Z_OK", "pigz.c", 2441U, "single_compress");
              }
              deflatePending(strm, (unsigned int *)0, & bits);
              if (! (bits & 7)) {
                break;
              }
            }
            while (1) {
              while (1) {
                strm->avail_out = out_size;
                strm->next_out = out;
                deflate(strm, 0);
                tmp___17 = writen(g.outd, (void const   *)out, (size_t )(out_size - strm->avail_out));
                clen += tmp___17;
                if (! (strm->avail_out == 0U)) {
                  break;
                }
              }
              if (! (strm->avail_in == 0U)) {
                __assert_fail("strm->avail_in == 0", "pigz.c", 2444U, "single_compress");
              }
              break;
            }
          }
        } else {
          while (1) {
            while (1) {
              strm->avail_out = out_size;
              strm->next_out = out;
              deflate(strm, 2);
              tmp___19 = writen(g.outd, (void const   *)out, (size_t )(out_size - strm->avail_out));
              clen += tmp___19;
              if (! (strm->avail_out == 0U)) {
                break;
              }
            }
            if (! (strm->avail_in == 0U)) {
              __assert_fail("strm->avail_in == 0", "pigz.c", 2448U, "single_compress");
            }
            break;
          }
        }
        if (! g.setdict) {
          while (1) {
            while (1) {
              strm->avail_out = out_size;
              strm->next_out = out;
              deflate(strm, 3);
              tmp___22 = writen(g.outd, (void const   *)out, (size_t )(out_size - strm->avail_out));
              clen += tmp___22;
              if (! (strm->avail_out == 0U)) {
                break;
              }
            }
            if (! (strm->avail_in == 0U)) {
              __assert_fail("strm->avail_in == 0", "pigz.c", 2453U, "single_compress");
            }
            break;
          }
        }
      } else {
        while (1) {
          while (1) {
            strm->avail_out = out_size;
            strm->next_out = out;
            deflate(strm, 4);
            tmp___24 = writen(g.outd, (void const   *)out, (size_t )(out_size - strm->avail_out));
            clen += tmp___24;
            if (! (strm->avail_out == 0U)) {
              break;
            }
          }
          if (! (strm->avail_in == 0U)) {
            __assert_fail("strm->avail_in == 0", "pigz.c", 2456U, "single_compress");
          }
          break;
        }
      }
    } else {
      off = (size_t )(strm->next_in - in);
      if (fresh) {
        hist = off;
      }
      def = (unsigned char *)((void *)0);
      size = (size_t )0;
      bits___0 = (unsigned char)0;
      if (more) {
        tmp___26 = 0;
      } else
      if (left) {
        tmp___26 = 0;
      } else {
        tmp___26 = 1;
      }
      ZopfliDeflatePart((ZopfliOptions const   *)(& g.zopts), 2, tmp___26, (unsigned char const   *)(in + hist),
                        off - hist, (off - hist) + got, & bits___0, & def, & size);
      bits___0 = (unsigned char )((int )bits___0 & 7);
      if (more) {
        goto _L___2;
      } else
      if (left) {
        _L___2: /* CIL Label */ 
        if ((int )bits___0 & 1) {
          goto _L___1;
        } else
        if (! g.setdict) {
          _L___1: /* CIL Label */ 
          writen(g.outd, (void const   *)def, size);
          if ((int )bits___0 == 0) {
            writen(g.outd, (void const   *)((unsigned char *)"\000"), (size_t )1);
          } else
          if ((int )bits___0 > 5) {
            writen(g.outd, (void const   *)((unsigned char *)"\000"), (size_t )1);
          }
          writen(g.outd, (void const   *)((unsigned char *)"\000\000\377\377"), (size_t )4);
        } else {
          if (! (size > 0UL)) {
            __assert_fail("size > 0", "pigz.c", 2484U, "single_compress");
          }
          writen(g.outd, (void const   *)def, size - 1UL);
          if (bits___0) {
            while (1) {
              *(def + (size - 1UL)) = (unsigned char )((int )*(def + (size - 1UL)) + (2 << (int )bits___0));
              writen(g.outd, (void const   *)((def + size) - 1), (size_t )1);
              *(def + (size - 1UL)) = (unsigned char)0;
              bits___0 = (unsigned char )((int )bits___0 + 2);
              if (! ((int )bits___0 < 8)) {
                break;
              }
            }
          }
          writen(g.outd, (void const   *)((def + size) - 1), (size_t )1);
        }
        if (! g.setdict) {
          writen(g.outd, (void const   *)((unsigned char *)"\000\000\000\377\377"),
                 (size_t )5);
        }
      } else {
        writen(g.outd, (void const   *)def, size);
      }
      free((void *)def);
      while (got > (size_t )(4294967295U - (4294967295U >> 1))) {
        if (g.form == 1) {
          tmp___28 = adler32z(check, (unsigned char const   *)strm->next_in, (size_t )(4294967295U - (4294967295U >> 1)));
          check = tmp___28;
        } else {
          tmp___29 = crc32z(check, (unsigned char const   *)strm->next_in, (size_t )(4294967295U - (4294967295U >> 1)));
          check = tmp___29;
        }
        strm->next_in += 4294967295U - (4294967295U >> 1);
        got -= (size_t )(4294967295U - (4294967295U >> 1));
      }
      if (g.form == 1) {
        tmp___30 = adler32z(check, (unsigned char const   *)strm->next_in, (size_t )((unsigned int )got));
        check = tmp___30;
      } else {
        tmp___31 = crc32z(check, (unsigned char const   *)strm->next_in, (size_t )((unsigned int )got));
        check = tmp___31;
      }
      strm->next_in += got;
      got = left;
    }
    if (! more) {
      if (! got) {
        break;
      }
    }
  }
  put_trailer(ulen, clen, check, head);
  return;
}
}
static void load_read(void *dummy ) 
{ 
  size_t len ;
  try_ball_t_ err ;
  try_t_ try_this_ ;
  int volatile   try_pushed_ ;
  void *tmp ;
  int tmp___3 ;
  long tmp___4 ;
  unsigned char *tmp___5 ;
  int tmp___6 ;
  int tmp___10 ;

  {
  while (1) {
    try_pushed_ = (int volatile   )1;
    try_this_.ball.ret = 0;
    try_this_.ball.code = 0;
    try_this_.ball.free = 0;
    try_this_.ball.why = (char *)((void *)0);
    try_setup_();
    tmp = pthread_getspecific(try_key_);
    try_this_.next = (try_t_ *)tmp;
    while (1) {
      tmp___3 = pthread_setspecific(try_key_, (void const   *)(& try_this_));
      if (tmp___3 == 0) {
        if (! "try: pthread_setspecific() failed") {
          __assert_fail("pthread_setspecific(try_key_, &try_this_) == 0 && \"try: pthread_setspecific() failed\"",
                        "pigz.c", 2531U, "load_read");
        }
      } else {
        __assert_fail("pthread_setspecific(try_key_, &try_this_) == 0 && \"try: pthread_setspecific() failed\"",
                      "pigz.c", 2531U, "load_read");
      }
      break;
    }
    tmp___6 = _setjmp((struct __jmp_buf_tag *)(try_this_.env));
    if (tmp___6 == 0) {
      while (1) {
        while (1) {
          possess_(g.load_state, "pigz.c", 2533L);
          wait_for_(g.load_state, (enum wait_op )1, 0L, "pigz.c", 2534L);
          tmp___4 = peek_lock(g.load_state);
          if (tmp___4 > 1L) {
            release_(g.load_state, "pigz.c", 2536L);
            break;
          }
          if (g.in_which) {
            tmp___5 = g.in_buf;
          } else {
            tmp___5 = g.in_buf2;
          }
          len = readn(g.ind, tmp___5, (size_t )32768);
          g.in_len = len;
          twist_(g.load_state, (enum twist_op )0, 0L, "pigz.c", 2542L);
          if (! (len == 32768UL)) {
            break;
          }
        }
        break;
      }
    }
    if (try_pushed_) {
      while (1) {
        tmp___10 = pthread_setspecific(try_key_, (void const   *)try_this_.next);
        if (tmp___10 == 0) {
          if (! "try: pthread_setspecific() failed") {
            __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                          "pigz.c", 2545U, "load_read");
          }
        } else {
          __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                        "pigz.c", 2545U, "load_read");
        }
        break;
      }
      try_pushed_ = (int volatile   )0;
    }
    err = try_this_.ball;
    break;
  }
  if (err.code) {
    while (1) {
      if (err.code != 32) {
        complain((char *)"abort: %s", err.why);
      }
      while (1) {
        if (err.free) {
          free((void *)err.why);
          err.free = 0;
          err.why = (char *)((void *)0);
        }
        break;
      }
      cut_short(- err.code);
      break;
    }
  }
  return;
}
}
static void load_wait(void) 
{ 


  {
  if (g.in_which == -1) {
    return;
  }
  possess_(g.load_state, "pigz.c", 2556L);
  wait_for_(g.load_state, (enum wait_op )0, 0L, "pigz.c", 2557L);
  release_(g.load_state, "pigz.c", 2558L);
  return;
}
}
static size_t load(void) 
{ 


  {
  if (g.in_short) {
    g.in_eof = 1;
    g.in_left = (size_t )0;
    return ((size_t )0);
  }
  if (g.procs > 1) {
    if (g.in_which == -1) {
      g.in_which = 1;
      g.load_state = new_lock_(1L, "pigz.c", 2582L);
      g.load_thread = launch_(& load_read, (void *)0, "pigz.c", 2583L);
    }
    load_wait();
    if (g.in_which) {
      g.in_next = g.in_buf;
    } else {
      g.in_next = g.in_buf2;
    }
    g.in_left = g.in_len;
    if (g.in_len == 32768UL) {
      g.in_which = 1 - g.in_which;
      possess_(g.load_state, "pigz.c", 2597L);
      twist_(g.load_state, (enum twist_op )0, 1L, "pigz.c", 2598L);
    } else {
      join_(g.load_thread, "pigz.c", 2603L);
      free_lock_(g.load_state, "pigz.c", 2604L);
      g.in_which = -1;
    }
  } else {
    g.in_next = g.in_buf;
    g.in_left = readn(g.ind, g.in_next, (size_t )32768);
  }
  if (g.in_left < 32768UL) {
    g.in_short = 1;
    if (g.in_left == 0UL) {
      g.in_eof = 1;
    }
  }
  g.in_tot += g.in_left;
  return (g.in_left);
}
}
static void load_end(void) 
{ 


  {
  if (g.in_which != -1) {
    possess_(g.load_state, "pigz.c", 2637L);
    wait_for_(g.load_state, (enum wait_op )0, 0L, "pigz.c", 2638L);
    twist_(g.load_state, (enum twist_op )0, 2L, "pigz.c", 2639L);
    join_(g.load_thread, "pigz.c", 2642L);
    free_lock_(g.load_state, "pigz.c", 2643L);
    g.in_which = -1;
  }
  g.in_left = (size_t )0;
  g.in_short = 1;
  g.in_eof = 1;
  if (g.ind != 0) {
    close(g.ind);
  }
  while (1) {
    if ((unsigned long )g.hname != (unsigned long )((void *)0)) {
      free((void *)g.hname);
      g.hname = (char *)((void *)0);
    }
    break;
  }
  while (1) {
    if ((unsigned long )g.hcomm != (unsigned long )((void *)0)) {
      free((void *)g.hcomm);
      g.hcomm = (char *)((void *)0);
    }
    break;
  }
  return;
}
}
static void in_init(void) 
{ 


  {
  g.in_left = (size_t )0;
  g.in_eof = 0;
  g.in_short = 0;
  g.in_tot = (length_t )0;
  g.in_which = -1;
  return;
}
}
static time_t dos2time(unsigned long dos ) 
{ 
  struct tm tm ;
  time_t tmp ;
  time_t tmp___0 ;

  {
  if (dos == 0UL) {
    tmp = time((time_t *)((void *)0));
    return (tmp);
  }
  tm.tm_year = ((int )(dos >> 25) & 127) + 80;
  tm.tm_mon = ((int )(dos >> 21) & 15) - 1;
  tm.tm_mday = (int )(dos >> 16) & 31;
  tm.tm_hour = (int )(dos >> 11) & 31;
  tm.tm_min = (int )(dos >> 5) & 63;
  tm.tm_sec = (int )(dos << 1) & 62;
  tm.tm_isdst = -1;
  tmp___0 = mktime(& tm);
  return (tmp___0);
}
}
static long tolong(unsigned long val ) 
{ 


  {
  return ((long )(val & 2147483647UL) - (long )(val & 2147483648UL));
}
}
static int read_extra(unsigned int len , int save ) 
{ 
  unsigned int id ;
  unsigned int size ;
  unsigned int tmp2 ;
  unsigned long tmp4 ;
  unsigned char *tmp___0 ;
  size_t tmp___1 ;
  unsigned char *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  unsigned char *tmp___7 ;
  size_t tmp___8 ;
  unsigned char *tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  unsigned char *tmp___14 ;
  size_t tmp___15 ;
  unsigned char *tmp___17 ;
  int tmp___18 ;
  size_t tmp___19 ;
  unsigned char *tmp___21 ;
  size_t tmp___22 ;
  unsigned char *tmp___24 ;
  int tmp___25 ;
  size_t tmp___26 ;
  size_t togo ;
  size_t tmp___27 ;
  unsigned char *tmp___29 ;
  size_t tmp___30 ;
  unsigned char *tmp___32 ;
  int tmp___33 ;
  size_t tmp___34 ;
  unsigned char *tmp___36 ;
  size_t tmp___37 ;
  unsigned char *tmp___39 ;
  int tmp___40 ;
  size_t tmp___41 ;
  size_t togo___0 ;
  size_t tmp___42 ;
  size_t togo___1 ;
  size_t tmp___43 ;
  unsigned char *tmp___45 ;
  size_t tmp___46 ;
  unsigned char *tmp___48 ;
  int tmp___49 ;
  size_t tmp___50 ;
  unsigned char *tmp___52 ;
  size_t tmp___53 ;
  unsigned char *tmp___55 ;
  int tmp___56 ;
  size_t tmp___57 ;
  unsigned char *tmp___59 ;
  size_t tmp___60 ;
  unsigned char *tmp___62 ;
  int tmp___63 ;
  size_t tmp___64 ;
  unsigned char *tmp___66 ;
  size_t tmp___67 ;
  unsigned char *tmp___69 ;
  int tmp___70 ;
  size_t tmp___71 ;
  unsigned char *tmp___73 ;
  int tmp___74 ;
  size_t tmp___75 ;
  size_t togo___2 ;
  size_t tmp___76 ;
  size_t togo___3 ;
  size_t tmp___77 ;

  {
  while (len >= 4U) {
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp2 = 0U;
      } else {
        tmp___1 = load();
        if (tmp___1 == 0UL) {
          tmp2 = 0U;
        } else {
          (g.in_left) --;
          tmp___0 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___0;
        }
      }
    } else {
      (g.in_left) --;
      tmp___0 = g.in_next;
      (g.in_next) ++;
      tmp2 = (unsigned int )*tmp___0;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp___4 = 0;
      } else {
        tmp___5 = load();
        if (tmp___5 == 0UL) {
          tmp___4 = 0;
        } else {
          (g.in_left) --;
          tmp___3 = g.in_next;
          (g.in_next) ++;
          tmp___4 = (int )*tmp___3;
        }
      }
    } else {
      (g.in_left) --;
      tmp___3 = g.in_next;
      (g.in_next) ++;
      tmp___4 = (int )*tmp___3;
    }
    id = tmp2 + ((unsigned int )tmp___4 << 8);
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp2 = 0U;
      } else {
        tmp___8 = load();
        if (tmp___8 == 0UL) {
          tmp2 = 0U;
        } else {
          (g.in_left) --;
          tmp___7 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___7;
        }
      }
    } else {
      (g.in_left) --;
      tmp___7 = g.in_next;
      (g.in_next) ++;
      tmp2 = (unsigned int )*tmp___7;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp___11 = 0;
      } else {
        tmp___12 = load();
        if (tmp___12 == 0UL) {
          tmp___11 = 0;
        } else {
          (g.in_left) --;
          tmp___10 = g.in_next;
          (g.in_next) ++;
          tmp___11 = (int )*tmp___10;
        }
      }
    } else {
      (g.in_left) --;
      tmp___10 = g.in_next;
      (g.in_next) ++;
      tmp___11 = (int )*tmp___10;
    }
    size = tmp2 + ((unsigned int )tmp___11 << 8);
    if (g.in_eof) {
      return (-1);
    }
    len -= 4U;
    if (size > len) {
      break;
    }
    len -= size;
    if (id == 1U) {
      g.zip64 = 1;
      if (g.zip_ulen == 4294967295UL) {
        if (size >= 8U) {
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp2 = 0U;
            } else {
              tmp___15 = load();
              if (tmp___15 == 0UL) {
                tmp2 = 0U;
              } else {
                (g.in_left) --;
                tmp___14 = g.in_next;
                (g.in_next) ++;
                tmp2 = (unsigned int )*tmp___14;
              }
            }
          } else {
            (g.in_left) --;
            tmp___14 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___14;
          }
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp___18 = 0;
            } else {
              tmp___19 = load();
              if (tmp___19 == 0UL) {
                tmp___18 = 0;
              } else {
                (g.in_left) --;
                tmp___17 = g.in_next;
                (g.in_next) ++;
                tmp___18 = (int )*tmp___17;
              }
            }
          } else {
            (g.in_left) --;
            tmp___17 = g.in_next;
            (g.in_next) ++;
            tmp___18 = (int )*tmp___17;
          }
          tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___18 << 8));
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp2 = 0U;
            } else {
              tmp___22 = load();
              if (tmp___22 == 0UL) {
                tmp2 = 0U;
              } else {
                (g.in_left) --;
                tmp___21 = g.in_next;
                (g.in_next) ++;
                tmp2 = (unsigned int )*tmp___21;
              }
            }
          } else {
            (g.in_left) --;
            tmp___21 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___21;
          }
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp___25 = 0;
            } else {
              tmp___26 = load();
              if (tmp___26 == 0UL) {
                tmp___25 = 0;
              } else {
                (g.in_left) --;
                tmp___24 = g.in_next;
                (g.in_next) ++;
                tmp___25 = (int )*tmp___24;
              }
            }
          } else {
            (g.in_left) --;
            tmp___24 = g.in_next;
            (g.in_next) ++;
            tmp___25 = (int )*tmp___24;
          }
          g.zip_ulen = tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___25 << 8)) << 16);
          while (1) {
            togo = (size_t )4;
            while (togo > g.in_left) {
              togo -= g.in_left;
              tmp___27 = load();
              if (tmp___27 == 0UL) {
                return (-3);
              }
            }
            g.in_left -= togo;
            g.in_next += togo;
            break;
          }
          size -= 8U;
        }
      }
      if (g.zip_clen == 4294967295UL) {
        if (size >= 8U) {
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp2 = 0U;
            } else {
              tmp___30 = load();
              if (tmp___30 == 0UL) {
                tmp2 = 0U;
              } else {
                (g.in_left) --;
                tmp___29 = g.in_next;
                (g.in_next) ++;
                tmp2 = (unsigned int )*tmp___29;
              }
            }
          } else {
            (g.in_left) --;
            tmp___29 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___29;
          }
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp___33 = 0;
            } else {
              tmp___34 = load();
              if (tmp___34 == 0UL) {
                tmp___33 = 0;
              } else {
                (g.in_left) --;
                tmp___32 = g.in_next;
                (g.in_next) ++;
                tmp___33 = (int )*tmp___32;
              }
            }
          } else {
            (g.in_left) --;
            tmp___32 = g.in_next;
            (g.in_next) ++;
            tmp___33 = (int )*tmp___32;
          }
          tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___33 << 8));
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp2 = 0U;
            } else {
              tmp___37 = load();
              if (tmp___37 == 0UL) {
                tmp2 = 0U;
              } else {
                (g.in_left) --;
                tmp___36 = g.in_next;
                (g.in_next) ++;
                tmp2 = (unsigned int )*tmp___36;
              }
            }
          } else {
            (g.in_left) --;
            tmp___36 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___36;
          }
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp___40 = 0;
            } else {
              tmp___41 = load();
              if (tmp___41 == 0UL) {
                tmp___40 = 0;
              } else {
                (g.in_left) --;
                tmp___39 = g.in_next;
                (g.in_next) ++;
                tmp___40 = (int )*tmp___39;
              }
            }
          } else {
            (g.in_left) --;
            tmp___39 = g.in_next;
            (g.in_next) ++;
            tmp___40 = (int )*tmp___39;
          }
          g.zip_clen = tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___40 << 8)) << 16);
          while (1) {
            togo___0 = (size_t )4;
            while (togo___0 > g.in_left) {
              togo___0 -= g.in_left;
              tmp___42 = load();
              if (tmp___42 == 0UL) {
                return (-3);
              }
            }
            g.in_left -= togo___0;
            g.in_next += togo___0;
            break;
          }
          size -= 8U;
        }
      }
    }
    if (save) {
      if (id == 13U) {
        goto _L;
      } else
      if (id == 22613U) {
        _L: /* CIL Label */ 
        if (size >= 8U) {
          while (1) {
            togo___1 = (size_t )4;
            while (togo___1 > g.in_left) {
              togo___1 -= g.in_left;
              tmp___43 = load();
              if (tmp___43 == 0UL) {
                return (-3);
              }
            }
            g.in_left -= togo___1;
            g.in_next += togo___1;
            break;
          }
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp2 = 0U;
            } else {
              tmp___46 = load();
              if (tmp___46 == 0UL) {
                tmp2 = 0U;
              } else {
                (g.in_left) --;
                tmp___45 = g.in_next;
                (g.in_next) ++;
                tmp2 = (unsigned int )*tmp___45;
              }
            }
          } else {
            (g.in_left) --;
            tmp___45 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___45;
          }
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp___49 = 0;
            } else {
              tmp___50 = load();
              if (tmp___50 == 0UL) {
                tmp___49 = 0;
              } else {
                (g.in_left) --;
                tmp___48 = g.in_next;
                (g.in_next) ++;
                tmp___49 = (int )*tmp___48;
              }
            }
          } else {
            (g.in_left) --;
            tmp___48 = g.in_next;
            (g.in_next) ++;
            tmp___49 = (int )*tmp___48;
          }
          tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___49 << 8));
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp2 = 0U;
            } else {
              tmp___53 = load();
              if (tmp___53 == 0UL) {
                tmp2 = 0U;
              } else {
                (g.in_left) --;
                tmp___52 = g.in_next;
                (g.in_next) ++;
                tmp2 = (unsigned int )*tmp___52;
              }
            }
          } else {
            (g.in_left) --;
            tmp___52 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___52;
          }
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp___56 = 0;
            } else {
              tmp___57 = load();
              if (tmp___57 == 0UL) {
                tmp___56 = 0;
              } else {
                (g.in_left) --;
                tmp___55 = g.in_next;
                (g.in_next) ++;
                tmp___56 = (int )*tmp___55;
              }
            }
          } else {
            (g.in_left) --;
            tmp___55 = g.in_next;
            (g.in_next) ++;
            tmp___56 = (int )*tmp___55;
          }
          g.stamp = tolong(tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___56 << 8)) << 16));
          size -= 8U;
        }
      }
      if (id == 21589U) {
        if (size >= 5U) {
          size --;
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp___74 = 0;
            } else {
              tmp___75 = load();
              if (tmp___75 == 0UL) {
                tmp___74 = 0;
              } else {
                (g.in_left) --;
                tmp___73 = g.in_next;
                (g.in_next) ++;
                tmp___74 = (int )*tmp___73;
              }
            }
          } else {
            (g.in_left) --;
            tmp___73 = g.in_next;
            (g.in_next) ++;
            tmp___74 = (int )*tmp___73;
          }
          if (tmp___74 & 1) {
            if (g.in_left == 0UL) {
              if (g.in_eof) {
                tmp2 = 0U;
              } else {
                tmp___60 = load();
                if (tmp___60 == 0UL) {
                  tmp2 = 0U;
                } else {
                  (g.in_left) --;
                  tmp___59 = g.in_next;
                  (g.in_next) ++;
                  tmp2 = (unsigned int )*tmp___59;
                }
              }
            } else {
              (g.in_left) --;
              tmp___59 = g.in_next;
              (g.in_next) ++;
              tmp2 = (unsigned int )*tmp___59;
            }
            if (g.in_left == 0UL) {
              if (g.in_eof) {
                tmp___63 = 0;
              } else {
                tmp___64 = load();
                if (tmp___64 == 0UL) {
                  tmp___63 = 0;
                } else {
                  (g.in_left) --;
                  tmp___62 = g.in_next;
                  (g.in_next) ++;
                  tmp___63 = (int )*tmp___62;
                }
              }
            } else {
              (g.in_left) --;
              tmp___62 = g.in_next;
              (g.in_next) ++;
              tmp___63 = (int )*tmp___62;
            }
            tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___63 << 8));
            if (g.in_left == 0UL) {
              if (g.in_eof) {
                tmp2 = 0U;
              } else {
                tmp___67 = load();
                if (tmp___67 == 0UL) {
                  tmp2 = 0U;
                } else {
                  (g.in_left) --;
                  tmp___66 = g.in_next;
                  (g.in_next) ++;
                  tmp2 = (unsigned int )*tmp___66;
                }
              }
            } else {
              (g.in_left) --;
              tmp___66 = g.in_next;
              (g.in_next) ++;
              tmp2 = (unsigned int )*tmp___66;
            }
            if (g.in_left == 0UL) {
              if (g.in_eof) {
                tmp___70 = 0;
              } else {
                tmp___71 = load();
                if (tmp___71 == 0UL) {
                  tmp___70 = 0;
                } else {
                  (g.in_left) --;
                  tmp___69 = g.in_next;
                  (g.in_next) ++;
                  tmp___70 = (int )*tmp___69;
                }
              }
            } else {
              (g.in_left) --;
              tmp___69 = g.in_next;
              (g.in_next) ++;
              tmp___70 = (int )*tmp___69;
            }
            g.stamp = tolong(tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___70 << 8)) << 16));
            size -= 4U;
          }
        }
      }
    }
    while (1) {
      togo___2 = (size_t )size;
      while (togo___2 > g.in_left) {
        togo___2 -= g.in_left;
        tmp___76 = load();
        if (tmp___76 == 0UL) {
          return (-3);
        }
      }
      g.in_left -= togo___2;
      g.in_next += togo___2;
      break;
    }
  }
  while (1) {
    togo___3 = (size_t )len;
    while (togo___3 > g.in_left) {
      togo___3 -= g.in_left;
      tmp___77 = load();
      if (tmp___77 == 0UL) {
        return (-3);
      }
    }
    g.in_left -= togo___3;
    g.in_next += togo___3;
    break;
  }
  return (0);
}
}
static int get_header(int save ) 
{ 
  unsigned int magic ;
  unsigned int method ;
  unsigned int flags ;
  unsigned int fname ;
  unsigned int extra ;
  unsigned int tmp2 ;
  unsigned long tmp4 ;
  unsigned long crc ;
  unsigned char *tmp___0 ;
  size_t tmp___1 ;
  unsigned char *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  unsigned char *tmp___7 ;
  size_t tmp___8 ;
  unsigned char *tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  size_t togo ;
  size_t tmp___13 ;
  unsigned char *tmp___15 ;
  size_t tmp___16 ;
  unsigned char *tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  unsigned char *tmp___22 ;
  size_t tmp___23 ;
  unsigned char *tmp___25 ;
  int tmp___26 ;
  size_t tmp___27 ;
  unsigned char *tmp___29 ;
  size_t tmp___30 ;
  unsigned char *tmp___32 ;
  int tmp___33 ;
  size_t tmp___34 ;
  unsigned char *tmp___36 ;
  size_t tmp___37 ;
  unsigned char *tmp___39 ;
  int tmp___40 ;
  size_t tmp___41 ;
  size_t togo___0 ;
  size_t tmp___42 ;
  unsigned char *tmp___44 ;
  size_t tmp___45 ;
  unsigned char *tmp___47 ;
  int tmp___48 ;
  size_t tmp___49 ;
  unsigned char *tmp___51 ;
  size_t tmp___52 ;
  unsigned char *tmp___54 ;
  int tmp___55 ;
  size_t tmp___56 ;
  unsigned char *tmp___58 ;
  size_t tmp___59 ;
  unsigned char *tmp___61 ;
  int tmp___62 ;
  size_t tmp___63 ;
  unsigned char *tmp___65 ;
  size_t tmp___66 ;
  unsigned char *tmp___68 ;
  int tmp___69 ;
  size_t tmp___70 ;
  unsigned char *tmp___72 ;
  size_t tmp___73 ;
  unsigned char *tmp___75 ;
  int tmp___76 ;
  size_t tmp___77 ;
  unsigned char *tmp___79 ;
  size_t tmp___80 ;
  unsigned char *tmp___82 ;
  int tmp___83 ;
  size_t tmp___84 ;
  unsigned char *tmp___86 ;
  size_t tmp___87 ;
  unsigned char *tmp___89 ;
  int tmp___90 ;
  size_t tmp___91 ;
  unsigned char *tmp___93 ;
  size_t tmp___94 ;
  unsigned char *tmp___96 ;
  int tmp___97 ;
  size_t tmp___98 ;
  char *next___0 ;
  void *tmp___99 ;
  size_t tmp___100 ;
  size_t togo___1 ;
  size_t tmp___101 ;
  int tmp___102 ;
  unsigned char *tmp___104 ;
  size_t tmp___105 ;
  unsigned char *tmp___107 ;
  size_t tmp___108 ;
  unsigned char *tmp___110 ;
  size_t tmp___111 ;
  unsigned char *tmp___113 ;
  int tmp___114 ;
  size_t tmp___115 ;
  unsigned char *tmp___117 ;
  size_t tmp___118 ;
  unsigned char *tmp___120 ;
  int tmp___121 ;
  size_t tmp___122 ;
  size_t togo___2 ;
  size_t tmp___123 ;
  size_t togo___3 ;
  size_t tmp___124 ;
  size_t togo___4 ;
  unsigned char *tmp___126 ;
  size_t tmp___127 ;
  unsigned char *tmp___129 ;
  int tmp___130 ;
  size_t tmp___131 ;
  size_t tmp___132 ;
  unsigned char *end ;
  size_t copy ;
  size_t have ;
  size_t size ;
  size_t tmp___133 ;
  void *tmp___134 ;
  unsigned char *tmp___136 ;
  int tmp___137 ;
  size_t tmp___138 ;
  unsigned char *end___0 ;
  size_t copy___0 ;
  size_t have___0 ;
  size_t size___0 ;
  size_t tmp___139 ;
  void *tmp___140 ;
  unsigned char *tmp___142 ;
  int tmp___143 ;
  size_t tmp___144 ;
  unsigned char *tmp___146 ;
  size_t tmp___147 ;
  unsigned char *tmp___149 ;
  int tmp___150 ;
  size_t tmp___151 ;
  int tmp___152 ;

  {
  if (save) {
    g.stamp = (time_t )0;
    while (1) {
      if ((unsigned long )g.hname != (unsigned long )((void *)0)) {
        free((void *)g.hname);
        g.hname = (char *)((void *)0);
      }
      break;
    }
    while (1) {
      if ((unsigned long )g.hcomm != (unsigned long )((void *)0)) {
        free((void *)g.hcomm);
        g.hcomm = (char *)((void *)0);
      }
      break;
    }
  }
  if (g.in_left == 0UL) {
    if (g.in_eof) {
      g.magic1 = 0;
    } else {
      tmp___1 = load();
      if (tmp___1 == 0UL) {
        g.magic1 = 0;
      } else {
        (g.in_left) --;
        tmp___0 = g.in_next;
        (g.in_next) ++;
        g.magic1 = (int )*tmp___0;
      }
    }
  } else {
    (g.in_left) --;
    tmp___0 = g.in_next;
    (g.in_next) ++;
    g.magic1 = (int )*tmp___0;
  }
  if (g.in_eof) {
    g.magic1 = -1;
    return (-1);
  }
  magic = (unsigned int )g.magic1 << 8;
  if (g.in_left == 0UL) {
    if (g.in_eof) {
      tmp___4 = 0;
    } else {
      tmp___5 = load();
      if (tmp___5 == 0UL) {
        tmp___4 = 0;
      } else {
        (g.in_left) --;
        tmp___3 = g.in_next;
        (g.in_next) ++;
        tmp___4 = (int )*tmp___3;
      }
    }
  } else {
    (g.in_left) --;
    tmp___3 = g.in_next;
    (g.in_next) ++;
    tmp___4 = (int )*tmp___3;
  }
  magic += (unsigned int )tmp___4;
  if (g.in_eof) {
    return (-2);
  }
  if (magic % 31U == 0U) {
    if ((magic & 36640U) == 2048U) {
      g.form = 1;
      return (8);
    }
  }
  if (magic == 8093U) {
    g.form = -1;
    return (257);
  }
  if (magic == 20555U) {
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp2 = 0U;
      } else {
        tmp___8 = load();
        if (tmp___8 == 0UL) {
          tmp2 = 0U;
        } else {
          (g.in_left) --;
          tmp___7 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___7;
        }
      }
    } else {
      (g.in_left) --;
      tmp___7 = g.in_next;
      (g.in_next) ++;
      tmp2 = (unsigned int )*tmp___7;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp___11 = 0;
      } else {
        tmp___12 = load();
        if (tmp___12 == 0UL) {
          tmp___11 = 0;
        } else {
          (g.in_left) --;
          tmp___10 = g.in_next;
          (g.in_next) ++;
          tmp___11 = (int )*tmp___10;
        }
      }
    } else {
      (g.in_left) --;
      tmp___10 = g.in_next;
      (g.in_next) ++;
      tmp___11 = (int )*tmp___10;
    }
    magic = tmp2 + ((unsigned int )tmp___11 << 8);
    if (g.in_eof) {
      return (-3);
    }
    if (magic == 513U) {
      return (-5);
    } else
    if (magic == 2054U) {
      return (-5);
    }
    if (magic != 1027U) {
      return (-4);
    }
    g.zip64 = 0;
    while (1) {
      togo = (size_t )2;
      while (togo > g.in_left) {
        togo -= g.in_left;
        tmp___13 = load();
        if (tmp___13 == 0UL) {
          return (-3);
        }
      }
      g.in_left -= togo;
      g.in_next += togo;
      break;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp2 = 0U;
      } else {
        tmp___16 = load();
        if (tmp___16 == 0UL) {
          tmp2 = 0U;
        } else {
          (g.in_left) --;
          tmp___15 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___15;
        }
      }
    } else {
      (g.in_left) --;
      tmp___15 = g.in_next;
      (g.in_next) ++;
      tmp2 = (unsigned int )*tmp___15;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp___19 = 0;
      } else {
        tmp___20 = load();
        if (tmp___20 == 0UL) {
          tmp___19 = 0;
        } else {
          (g.in_left) --;
          tmp___18 = g.in_next;
          (g.in_next) ++;
          tmp___19 = (int )*tmp___18;
        }
      }
    } else {
      (g.in_left) --;
      tmp___18 = g.in_next;
      (g.in_next) ++;
      tmp___19 = (int )*tmp___18;
    }
    flags = tmp2 + ((unsigned int )tmp___19 << 8);
    if (flags & 63472U) {
      return (-4);
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        method = 0U;
      } else {
        tmp___23 = load();
        if (tmp___23 == 0UL) {
          method = 0U;
        } else {
          (g.in_left) --;
          tmp___22 = g.in_next;
          (g.in_next) ++;
          method = (unsigned int )*tmp___22;
        }
      }
    } else {
      (g.in_left) --;
      tmp___22 = g.in_next;
      (g.in_next) ++;
      method = (unsigned int )*tmp___22;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp___26 = 0;
      } else {
        tmp___27 = load();
        if (tmp___27 == 0UL) {
          tmp___26 = 0;
        } else {
          (g.in_left) --;
          tmp___25 = g.in_next;
          (g.in_next) ++;
          tmp___26 = (int )*tmp___25;
        }
      }
    } else {
      (g.in_left) --;
      tmp___25 = g.in_next;
      (g.in_next) ++;
      tmp___26 = (int )*tmp___25;
    }
    if (tmp___26 != 0) {
      method = 256U;
    } else
    if (flags & 1U) {
      method = 256U;
    }
    if (save) {
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp2 = 0U;
        } else {
          tmp___30 = load();
          if (tmp___30 == 0UL) {
            tmp2 = 0U;
          } else {
            (g.in_left) --;
            tmp___29 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___29;
          }
        }
      } else {
        (g.in_left) --;
        tmp___29 = g.in_next;
        (g.in_next) ++;
        tmp2 = (unsigned int )*tmp___29;
      }
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp___33 = 0;
        } else {
          tmp___34 = load();
          if (tmp___34 == 0UL) {
            tmp___33 = 0;
          } else {
            (g.in_left) --;
            tmp___32 = g.in_next;
            (g.in_next) ++;
            tmp___33 = (int )*tmp___32;
          }
        }
      } else {
        (g.in_left) --;
        tmp___32 = g.in_next;
        (g.in_next) ++;
        tmp___33 = (int )*tmp___32;
      }
      tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___33 << 8));
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp2 = 0U;
        } else {
          tmp___37 = load();
          if (tmp___37 == 0UL) {
            tmp2 = 0U;
          } else {
            (g.in_left) --;
            tmp___36 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___36;
          }
        }
      } else {
        (g.in_left) --;
        tmp___36 = g.in_next;
        (g.in_next) ++;
        tmp2 = (unsigned int )*tmp___36;
      }
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp___40 = 0;
        } else {
          tmp___41 = load();
          if (tmp___41 == 0UL) {
            tmp___40 = 0;
          } else {
            (g.in_left) --;
            tmp___39 = g.in_next;
            (g.in_next) ++;
            tmp___40 = (int )*tmp___39;
          }
        }
      } else {
        (g.in_left) --;
        tmp___39 = g.in_next;
        (g.in_next) ++;
        tmp___40 = (int )*tmp___39;
      }
      g.stamp = dos2time(tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___40 << 8)) << 16));
    } else {
      while (1) {
        togo___0 = (size_t )4;
        while (togo___0 > g.in_left) {
          togo___0 -= g.in_left;
          tmp___42 = load();
          if (tmp___42 == 0UL) {
            return (-3);
          }
        }
        g.in_left -= togo___0;
        g.in_next += togo___0;
        break;
      }
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp2 = 0U;
      } else {
        tmp___45 = load();
        if (tmp___45 == 0UL) {
          tmp2 = 0U;
        } else {
          (g.in_left) --;
          tmp___44 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___44;
        }
      }
    } else {
      (g.in_left) --;
      tmp___44 = g.in_next;
      (g.in_next) ++;
      tmp2 = (unsigned int )*tmp___44;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp___48 = 0;
      } else {
        tmp___49 = load();
        if (tmp___49 == 0UL) {
          tmp___48 = 0;
        } else {
          (g.in_left) --;
          tmp___47 = g.in_next;
          (g.in_next) ++;
          tmp___48 = (int )*tmp___47;
        }
      }
    } else {
      (g.in_left) --;
      tmp___47 = g.in_next;
      (g.in_next) ++;
      tmp___48 = (int )*tmp___47;
    }
    tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___48 << 8));
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp2 = 0U;
      } else {
        tmp___52 = load();
        if (tmp___52 == 0UL) {
          tmp2 = 0U;
        } else {
          (g.in_left) --;
          tmp___51 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___51;
        }
      }
    } else {
      (g.in_left) --;
      tmp___51 = g.in_next;
      (g.in_next) ++;
      tmp2 = (unsigned int )*tmp___51;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp___55 = 0;
      } else {
        tmp___56 = load();
        if (tmp___56 == 0UL) {
          tmp___55 = 0;
        } else {
          (g.in_left) --;
          tmp___54 = g.in_next;
          (g.in_next) ++;
          tmp___55 = (int )*tmp___54;
        }
      }
    } else {
      (g.in_left) --;
      tmp___54 = g.in_next;
      (g.in_next) ++;
      tmp___55 = (int )*tmp___54;
    }
    g.zip_crc = tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___55 << 8)) << 16);
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp2 = 0U;
      } else {
        tmp___59 = load();
        if (tmp___59 == 0UL) {
          tmp2 = 0U;
        } else {
          (g.in_left) --;
          tmp___58 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___58;
        }
      }
    } else {
      (g.in_left) --;
      tmp___58 = g.in_next;
      (g.in_next) ++;
      tmp2 = (unsigned int )*tmp___58;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp___62 = 0;
      } else {
        tmp___63 = load();
        if (tmp___63 == 0UL) {
          tmp___62 = 0;
        } else {
          (g.in_left) --;
          tmp___61 = g.in_next;
          (g.in_next) ++;
          tmp___62 = (int )*tmp___61;
        }
      }
    } else {
      (g.in_left) --;
      tmp___61 = g.in_next;
      (g.in_next) ++;
      tmp___62 = (int )*tmp___61;
    }
    tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___62 << 8));
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp2 = 0U;
      } else {
        tmp___66 = load();
        if (tmp___66 == 0UL) {
          tmp2 = 0U;
        } else {
          (g.in_left) --;
          tmp___65 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___65;
        }
      }
    } else {
      (g.in_left) --;
      tmp___65 = g.in_next;
      (g.in_next) ++;
      tmp2 = (unsigned int )*tmp___65;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp___69 = 0;
      } else {
        tmp___70 = load();
        if (tmp___70 == 0UL) {
          tmp___69 = 0;
        } else {
          (g.in_left) --;
          tmp___68 = g.in_next;
          (g.in_next) ++;
          tmp___69 = (int )*tmp___68;
        }
      }
    } else {
      (g.in_left) --;
      tmp___68 = g.in_next;
      (g.in_next) ++;
      tmp___69 = (int )*tmp___68;
    }
    g.zip_clen = tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___69 << 8)) << 16);
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp2 = 0U;
      } else {
        tmp___73 = load();
        if (tmp___73 == 0UL) {
          tmp2 = 0U;
        } else {
          (g.in_left) --;
          tmp___72 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___72;
        }
      }
    } else {
      (g.in_left) --;
      tmp___72 = g.in_next;
      (g.in_next) ++;
      tmp2 = (unsigned int )*tmp___72;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp___76 = 0;
      } else {
        tmp___77 = load();
        if (tmp___77 == 0UL) {
          tmp___76 = 0;
        } else {
          (g.in_left) --;
          tmp___75 = g.in_next;
          (g.in_next) ++;
          tmp___76 = (int )*tmp___75;
        }
      }
    } else {
      (g.in_left) --;
      tmp___75 = g.in_next;
      (g.in_next) ++;
      tmp___76 = (int )*tmp___75;
    }
    tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___76 << 8));
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp2 = 0U;
      } else {
        tmp___80 = load();
        if (tmp___80 == 0UL) {
          tmp2 = 0U;
        } else {
          (g.in_left) --;
          tmp___79 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___79;
        }
      }
    } else {
      (g.in_left) --;
      tmp___79 = g.in_next;
      (g.in_next) ++;
      tmp2 = (unsigned int )*tmp___79;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp___83 = 0;
      } else {
        tmp___84 = load();
        if (tmp___84 == 0UL) {
          tmp___83 = 0;
        } else {
          (g.in_left) --;
          tmp___82 = g.in_next;
          (g.in_next) ++;
          tmp___83 = (int )*tmp___82;
        }
      }
    } else {
      (g.in_left) --;
      tmp___82 = g.in_next;
      (g.in_next) ++;
      tmp___83 = (int )*tmp___82;
    }
    g.zip_ulen = tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___83 << 8)) << 16);
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp2 = 0U;
      } else {
        tmp___87 = load();
        if (tmp___87 == 0UL) {
          tmp2 = 0U;
        } else {
          (g.in_left) --;
          tmp___86 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___86;
        }
      }
    } else {
      (g.in_left) --;
      tmp___86 = g.in_next;
      (g.in_next) ++;
      tmp2 = (unsigned int )*tmp___86;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp___90 = 0;
      } else {
        tmp___91 = load();
        if (tmp___91 == 0UL) {
          tmp___90 = 0;
        } else {
          (g.in_left) --;
          tmp___89 = g.in_next;
          (g.in_next) ++;
          tmp___90 = (int )*tmp___89;
        }
      }
    } else {
      (g.in_left) --;
      tmp___89 = g.in_next;
      (g.in_next) ++;
      tmp___90 = (int )*tmp___89;
    }
    fname = tmp2 + ((unsigned int )tmp___90 << 8);
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp2 = 0U;
      } else {
        tmp___94 = load();
        if (tmp___94 == 0UL) {
          tmp2 = 0U;
        } else {
          (g.in_left) --;
          tmp___93 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___93;
        }
      }
    } else {
      (g.in_left) --;
      tmp___93 = g.in_next;
      (g.in_next) ++;
      tmp2 = (unsigned int )*tmp___93;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp___97 = 0;
      } else {
        tmp___98 = load();
        if (tmp___98 == 0UL) {
          tmp___97 = 0;
        } else {
          (g.in_left) --;
          tmp___96 = g.in_next;
          (g.in_next) ++;
          tmp___97 = (int )*tmp___96;
        }
      }
    } else {
      (g.in_left) --;
      tmp___96 = g.in_next;
      (g.in_next) ++;
      tmp___97 = (int )*tmp___96;
    }
    extra = tmp2 + ((unsigned int )tmp___97 << 8);
    if (save) {
      if (g.in_eof) {
        return (-3);
      }
      tmp___99 = alloc((void *)0, (size_t )(fname + 1U));
      g.hname = (char *)tmp___99;
      next___0 = g.hname;
      while ((size_t )fname > g.in_left) {
        memcpy((void * __restrict  )next___0, (void const   * __restrict  )g.in_next,
               g.in_left);
        fname = (unsigned int )((size_t )fname - g.in_left);
        next___0 += g.in_left;
        tmp___100 = load();
        if (tmp___100 == 0UL) {
          return (-3);
        }
      }
      memcpy((void * __restrict  )next___0, (void const   * __restrict  )g.in_next,
             (size_t )fname);
      g.in_left -= (size_t )fname;
      g.in_next += fname;
      next___0 += fname;
      *next___0 = (char)0;
    } else {
      while (1) {
        togo___1 = (size_t )fname;
        while (togo___1 > g.in_left) {
          togo___1 -= g.in_left;
          tmp___101 = load();
          if (tmp___101 == 0UL) {
            return (-3);
          }
        }
        g.in_left -= togo___1;
        g.in_next += togo___1;
        break;
      }
    }
    read_extra(extra, save);
    g.form = (int )(2U + ((flags & 8U) >> 3));
    if (g.in_eof) {
      tmp___102 = -3;
    } else {
      tmp___102 = (int )method;
    }
    return (tmp___102);
  }
  if (magic != 8075U) {
    (g.in_left) ++;
    (g.in_next) --;
    return (-2);
  }
  crc = 4142483145UL;
  if (g.in_left == 0UL) {
    if (g.in_eof) {
      method = 0U;
    } else {
      tmp___105 = load();
      if (tmp___105 == 0UL) {
        method = 0U;
      } else {
        (g.in_left) --;
        crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
        tmp___104 = g.in_next;
        (g.in_next) ++;
        method = (unsigned int )*tmp___104;
      }
    }
  } else {
    (g.in_left) --;
    crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
    tmp___104 = g.in_next;
    (g.in_next) ++;
    method = (unsigned int )*tmp___104;
  }
  if (g.in_left == 0UL) {
    if (g.in_eof) {
      flags = 0U;
    } else {
      tmp___108 = load();
      if (tmp___108 == 0UL) {
        flags = 0U;
      } else {
        (g.in_left) --;
        crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
        tmp___107 = g.in_next;
        (g.in_next) ++;
        flags = (unsigned int )*tmp___107;
      }
    }
  } else {
    (g.in_left) --;
    crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
    tmp___107 = g.in_next;
    (g.in_next) ++;
    flags = (unsigned int )*tmp___107;
  }
  if (flags & 224U) {
    return (-4);
  }
  if (save) {
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp2 = 0U;
      } else {
        tmp___111 = load();
        if (tmp___111 == 0UL) {
          tmp2 = 0U;
        } else {
          (g.in_left) --;
          crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
          tmp___110 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___110;
        }
      }
    } else {
      (g.in_left) --;
      crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
      tmp___110 = g.in_next;
      (g.in_next) ++;
      tmp2 = (unsigned int )*tmp___110;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp___114 = 0;
      } else {
        tmp___115 = load();
        if (tmp___115 == 0UL) {
          tmp___114 = 0;
        } else {
          (g.in_left) --;
          crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
          tmp___113 = g.in_next;
          (g.in_next) ++;
          tmp___114 = (int )*tmp___113;
        }
      }
    } else {
      (g.in_left) --;
      crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
      tmp___113 = g.in_next;
      (g.in_next) ++;
      tmp___114 = (int )*tmp___113;
    }
    tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___114 << 8));
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp2 = 0U;
      } else {
        tmp___118 = load();
        if (tmp___118 == 0UL) {
          tmp2 = 0U;
        } else {
          (g.in_left) --;
          crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
          tmp___117 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___117;
        }
      }
    } else {
      (g.in_left) --;
      crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
      tmp___117 = g.in_next;
      (g.in_next) ++;
      tmp2 = (unsigned int )*tmp___117;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp___121 = 0;
      } else {
        tmp___122 = load();
        if (tmp___122 == 0UL) {
          tmp___121 = 0;
        } else {
          (g.in_left) --;
          crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
          tmp___120 = g.in_next;
          (g.in_next) ++;
          tmp___121 = (int )*tmp___120;
        }
      }
    } else {
      (g.in_left) --;
      crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
      tmp___120 = g.in_next;
      (g.in_next) ++;
      tmp___121 = (int )*tmp___120;
    }
    g.stamp = tolong(tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___121 << 8)) << 16));
  } else {
    while (1) {
      togo___2 = (size_t )4;
      while (togo___2 > g.in_left) {
        crc = crc32z(crc, (unsigned char const   *)g.in_next, g.in_left);
        togo___2 -= g.in_left;
        tmp___123 = load();
        if (tmp___123 == 0UL) {
          return (-3);
        }
      }
      crc = crc32z(crc, (unsigned char const   *)g.in_next, togo___2);
      g.in_left -= togo___2;
      g.in_next += togo___2;
      break;
    }
  }
  while (1) {
    togo___3 = (size_t )2;
    while (togo___3 > g.in_left) {
      crc = crc32z(crc, (unsigned char const   *)g.in_next, g.in_left);
      togo___3 -= g.in_left;
      tmp___124 = load();
      if (tmp___124 == 0UL) {
        return (-3);
      }
    }
    crc = crc32z(crc, (unsigned char const   *)g.in_next, togo___3);
    g.in_left -= togo___3;
    g.in_next += togo___3;
    break;
  }
  if (flags & 4U) {
    while (1) {
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp2 = 0U;
        } else {
          tmp___127 = load();
          if (tmp___127 == 0UL) {
            tmp2 = 0U;
          } else {
            (g.in_left) --;
            crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
            tmp___126 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___126;
          }
        }
      } else {
        (g.in_left) --;
        crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
        tmp___126 = g.in_next;
        (g.in_next) ++;
        tmp2 = (unsigned int )*tmp___126;
      }
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp___130 = 0;
        } else {
          tmp___131 = load();
          if (tmp___131 == 0UL) {
            tmp___130 = 0;
          } else {
            (g.in_left) --;
            crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
            tmp___129 = g.in_next;
            (g.in_next) ++;
            tmp___130 = (int )*tmp___129;
          }
        }
      } else {
        (g.in_left) --;
        crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
        tmp___129 = g.in_next;
        (g.in_next) ++;
        tmp___130 = (int )*tmp___129;
      }
      togo___4 = (size_t )(tmp2 + ((unsigned int )tmp___130 << 8));
      while (togo___4 > g.in_left) {
        crc = crc32z(crc, (unsigned char const   *)g.in_next, g.in_left);
        togo___4 -= g.in_left;
        tmp___132 = load();
        if (tmp___132 == 0UL) {
          return (-3);
        }
      }
      crc = crc32z(crc, (unsigned char const   *)g.in_next, togo___4);
      g.in_left -= togo___4;
      g.in_next += togo___4;
      break;
    }
  }
  if (flags & 8U) {
    if (save) {
      while (1) {
        size = (size_t )0;
        have = (size_t )0;
        while (1) {
          if (g.in_left == 0UL) {
            tmp___133 = load();
            if (tmp___133 == 0UL) {
              return (-3);
            }
          }
          tmp___134 = memchr((void const   *)g.in_next, 0, g.in_left);
          end = (unsigned char *)tmp___134;
          if ((unsigned long )end == (unsigned long )((void *)0)) {
            copy = g.in_left;
          } else {
            copy = (size_t )(end - g.in_next) + 1UL;
          }
          have = vmemcpy(& g.hname, & size, have, (void *)g.in_next, copy);
          g.in_left -= copy;
          g.in_next += copy;
          if (! ((unsigned long )end == (unsigned long )((void *)0))) {
            break;
          }
        }
        crc = crc32z(crc, (unsigned char const   *)((unsigned char *)g.hname), have);
        break;
      }
    } else {
      while (1) {
        if (g.in_left == 0UL) {
          if (g.in_eof) {
            tmp___137 = 0;
          } else {
            tmp___138 = load();
            if (tmp___138 == 0UL) {
              tmp___137 = 0;
            } else {
              (g.in_left) --;
              crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
              tmp___136 = g.in_next;
              (g.in_next) ++;
              tmp___137 = (int )*tmp___136;
            }
          }
        } else {
          (g.in_left) --;
          crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
          tmp___136 = g.in_next;
          (g.in_next) ++;
          tmp___137 = (int )*tmp___136;
        }
        if (! (tmp___137 != 0)) {
          break;
        }
      }
    }
  }
  if (flags & 16U) {
    if (save) {
      while (1) {
        size___0 = (size_t )0;
        have___0 = (size_t )0;
        while (1) {
          if (g.in_left == 0UL) {
            tmp___139 = load();
            if (tmp___139 == 0UL) {
              return (-3);
            }
          }
          tmp___140 = memchr((void const   *)g.in_next, 0, g.in_left);
          end___0 = (unsigned char *)tmp___140;
          if ((unsigned long )end___0 == (unsigned long )((void *)0)) {
            copy___0 = g.in_left;
          } else {
            copy___0 = (size_t )(end___0 - g.in_next) + 1UL;
          }
          have___0 = vmemcpy(& g.hcomm, & size___0, have___0, (void *)g.in_next, copy___0);
          g.in_left -= copy___0;
          g.in_next += copy___0;
          if (! ((unsigned long )end___0 == (unsigned long )((void *)0))) {
            break;
          }
        }
        crc = crc32z(crc, (unsigned char const   *)((unsigned char *)g.hcomm), have___0);
        break;
      }
    } else {
      while (1) {
        if (g.in_left == 0UL) {
          if (g.in_eof) {
            tmp___143 = 0;
          } else {
            tmp___144 = load();
            if (tmp___144 == 0UL) {
              tmp___143 = 0;
            } else {
              (g.in_left) --;
              crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
              tmp___142 = g.in_next;
              (g.in_next) ++;
              tmp___143 = (int )*tmp___142;
            }
          }
        } else {
          (g.in_left) --;
          crc = crc32z(crc, (unsigned char const   *)g.in_next, (size_t )1);
          tmp___142 = g.in_next;
          (g.in_next) ++;
          tmp___143 = (int )*tmp___142;
        }
        if (! (tmp___143 != 0)) {
          break;
        }
      }
    }
  }
  if (flags & 2U) {
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp2 = 0U;
      } else {
        tmp___147 = load();
        if (tmp___147 == 0UL) {
          tmp2 = 0U;
        } else {
          (g.in_left) --;
          tmp___146 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___146;
        }
      }
    } else {
      (g.in_left) --;
      tmp___146 = g.in_next;
      (g.in_next) ++;
      tmp2 = (unsigned int )*tmp___146;
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        tmp___150 = 0;
      } else {
        tmp___151 = load();
        if (tmp___151 == 0UL) {
          tmp___150 = 0;
        } else {
          (g.in_left) --;
          tmp___149 = g.in_next;
          (g.in_next) ++;
          tmp___150 = (int )*tmp___149;
        }
      }
    } else {
      (g.in_left) --;
      tmp___149 = g.in_next;
      (g.in_next) ++;
      tmp___150 = (int )*tmp___149;
    }
    if ((unsigned long )(tmp2 + ((unsigned int )tmp___150 << 8)) != (crc & 65535UL)) {
      return (-6);
    }
  }
  g.form = 0;
  if (g.in_eof) {
    tmp___152 = -3;
  } else {
    tmp___152 = (int )method;
  }
  return (tmp___152);
}
}
static int more_zip_entries(void) 
{ 
  unsigned long sig ;
  int ret ;
  int n ;
  unsigned char *first ;
  unsigned int tmp2 ;
  unsigned long tmp4 ;
  unsigned char central[4] ;
  unsigned char *tmp___0 ;
  size_t tmp___1 ;
  unsigned char *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  unsigned char *tmp___7 ;
  size_t tmp___8 ;
  unsigned char *tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  void *tmp___15 ;
  unsigned char head[42] ;
  size_t need ;
  size_t part ;
  size_t len ;
  size_t i ;
  size_t tmp___16 ;
  size_t togo ;
  size_t tmp___17 ;
  void *tmp___18 ;
  size_t tmp___19 ;

  {
  central[0] = (unsigned char)80;
  central[1] = (unsigned char)75;
  central[2] = (unsigned char)1;
  central[3] = (unsigned char)2;
  if (g.in_left == 0UL) {
    if (g.in_eof) {
      tmp2 = 0U;
    } else {
      tmp___1 = load();
      if (tmp___1 == 0UL) {
        tmp2 = 0U;
      } else {
        (g.in_left) --;
        tmp___0 = g.in_next;
        (g.in_next) ++;
        tmp2 = (unsigned int )*tmp___0;
      }
    }
  } else {
    (g.in_left) --;
    tmp___0 = g.in_next;
    (g.in_next) ++;
    tmp2 = (unsigned int )*tmp___0;
  }
  if (g.in_left == 0UL) {
    if (g.in_eof) {
      tmp___4 = 0;
    } else {
      tmp___5 = load();
      if (tmp___5 == 0UL) {
        tmp___4 = 0;
      } else {
        (g.in_left) --;
        tmp___3 = g.in_next;
        (g.in_next) ++;
        tmp___4 = (int )*tmp___3;
      }
    }
  } else {
    (g.in_left) --;
    tmp___3 = g.in_next;
    (g.in_next) ++;
    tmp___4 = (int )*tmp___3;
  }
  tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___4 << 8));
  if (g.in_left == 0UL) {
    if (g.in_eof) {
      tmp2 = 0U;
    } else {
      tmp___8 = load();
      if (tmp___8 == 0UL) {
        tmp2 = 0U;
      } else {
        (g.in_left) --;
        tmp___7 = g.in_next;
        (g.in_next) ++;
        tmp2 = (unsigned int )*tmp___7;
      }
    }
  } else {
    (g.in_left) --;
    tmp___7 = g.in_next;
    (g.in_next) ++;
    tmp2 = (unsigned int )*tmp___7;
  }
  if (g.in_left == 0UL) {
    if (g.in_eof) {
      tmp___11 = 0;
    } else {
      tmp___12 = load();
      if (tmp___12 == 0UL) {
        tmp___11 = 0;
      } else {
        (g.in_left) --;
        tmp___10 = g.in_next;
        (g.in_next) ++;
        tmp___11 = (int )*tmp___10;
      }
    }
  } else {
    (g.in_left) --;
    tmp___10 = g.in_next;
    (g.in_next) ++;
    tmp___11 = (int )*tmp___10;
  }
  sig = tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___11 << 8)) << 16);
  if (! g.in_eof) {
    if (sig == 67324752UL) {
      tmp___13 = 1;
    } else {
      tmp___13 = 0;
    }
  } else {
    tmp___13 = 0;
  }
  ret = tmp___13;
  if (! g.list) {
    return (ret);
  } else
  if (g.verbosity < 2) {
    return (ret);
  }
  if (sig == 33639248UL) {
    n = 4;
  } else {
    n = 0;
  }
  while (1) {
    if (g.in_left == 0UL) {
      tmp___14 = load();
      if (tmp___14 == 0UL) {
        return (ret);
      }
    }
    if (n == 0) {
      tmp___15 = memchr((void const   *)g.in_next, (int )central[0], g.in_left);
      first = (unsigned char *)tmp___15;
      if ((unsigned long )first == (unsigned long )((void *)0)) {
        g.in_left = (size_t )0;
      } else {
        n ++;
        g.in_left -= (size_t )((first - g.in_next) + 1L);
        g.in_next = first + 1;
      }
    } else
    if (n < 4) {
      if ((int )*(g.in_next + 0) == (int )central[n]) {
        n ++;
        (g.in_next) ++;
        (g.in_left) --;
      } else {
        n = 0;
      }
    } else {
      need = (size_t )42;
      part = (size_t )0;
      if (need > g.in_left) {
        part = g.in_left;
        memcpy((void * __restrict  )((head + 42) - need), (void const   * __restrict  )g.in_next,
               part);
        need -= part;
        g.in_left = (size_t )0;
        tmp___16 = load();
        if (tmp___16 == 0UL) {
          return (ret);
        }
      }
      memcpy((void * __restrict  )((head + 42) - need), (void const   * __restrict  )g.in_next,
             need);
      if ((unsigned long )((unsigned int )*((head + 12) + 0) + ((unsigned int )*((head + 12) + 1) << 8)) + ((unsigned long )((unsigned int )*(((head + 12) + 2) + 0) + ((unsigned int )*(((head + 12) + 2) + 1) << 8)) << 16) == g.out_check) {
        if ((unsigned long )((unsigned int )*((head + 38) + 0) + ((unsigned int )*((head + 38) + 1) << 8)) + ((unsigned long )((unsigned int )*(((head + 38) + 2) + 0) + ((unsigned int )*(((head + 38) + 2) + 1) << 8)) << 16) == 0UL) {
          g.in_next += need;
          g.in_left -= need;
          len = (size_t )((unsigned int )*((head + 28) + 0) + ((unsigned int )*((head + 28) + 1) << 8));
          if (len == 0UL) {
            return (ret);
          }
          while (1) {
            togo = (unsigned long )((unsigned int )*((head + 24) + 0) + ((unsigned int )*((head + 24) + 1) << 8)) + (unsigned long )((unsigned int )*((head + 26) + 0) + ((unsigned int )*((head + 26) + 1) << 8));
            while (togo > g.in_left) {
              togo -= g.in_left;
              tmp___17 = load();
              if (tmp___17 == 0UL) {
                return (-3);
              }
            }
            g.in_left -= togo;
            g.in_next += togo;
            break;
          }
          need = len;
          tmp___18 = alloc((void *)0, len + 1UL);
          g.hcomm = (char *)tmp___18;
          while (need > g.in_left) {
            memcpy((void * __restrict  )((g.hcomm + len) - need), (void const   * __restrict  )g.in_next,
                   g.in_left);
            need -= g.in_left;
            g.in_left = (size_t )0;
            tmp___19 = load();
            if (tmp___19 == 0UL) {
              while (1) {
                if ((unsigned long )g.hcomm != (unsigned long )((void *)0)) {
                  free((void *)g.hcomm);
                  g.hcomm = (char *)((void *)0);
                }
                break;
              }
              return (ret);
            }
          }
          memcpy((void * __restrict  )((g.hcomm + len) - need), (void const   * __restrict  )g.in_next,
                 need);
          g.in_next += need;
          g.in_left -= need;
          i = (size_t )0;
          while (i < len) {
            if ((int )*(g.hcomm + i) == 0) {
              *(g.hcomm + i) = (char )' ';
            }
            i ++;
          }
          *(g.hcomm + len) = (char)0;
          return (ret);
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        if (part) {
          memmove((void *)(g.in_next + part), (void const   *)g.in_next, g.in_left);
          memcpy((void * __restrict  )g.in_next, (void const   * __restrict  )(head),
                 part);
          g.in_left += part;
        }
        n = 0;
      }
    }
  }
}
}
static size_t compressed_suffix(char *nm ) 
{ 
  size_t len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  len = strlen((char const   *)nm);
  if (len > 4UL) {
    nm += len - 4UL;
    len = (size_t )4;
    tmp = strcmp((char const   *)nm, ".zip");
    if (tmp == 0) {
      return ((size_t )4);
    } else {
      tmp___0 = strcmp((char const   *)nm, ".ZIP");
      if (tmp___0 == 0) {
        return ((size_t )4);
      } else {
        tmp___1 = strcmp((char const   *)nm, ".tgz");
        if (tmp___1 == 0) {
          return ((size_t )4);
        }
      }
    }
  }
  if (len > 3UL) {
    nm += len - 3UL;
    len = (size_t )3;
    tmp___2 = strcmp((char const   *)nm, ".gz");
    if (tmp___2 == 0) {
      return ((size_t )3);
    } else {
      tmp___3 = strcmp((char const   *)nm, "-gz");
      if (tmp___3 == 0) {
        return ((size_t )3);
      } else {
        tmp___4 = strcmp((char const   *)nm, ".zz");
        if (tmp___4 == 0) {
          return ((size_t )3);
        } else {
          tmp___5 = strcmp((char const   *)nm, "-zz");
          if (tmp___5 == 0) {
            return ((size_t )3);
          }
        }
      }
    }
  }
  if (len > 2UL) {
    nm += len - 2UL;
    tmp___6 = strcmp((char const   *)nm, ".z");
    if (tmp___6 == 0) {
      return ((size_t )2);
    } else {
      tmp___7 = strcmp((char const   *)nm, "-z");
      if (tmp___7 == 0) {
        return ((size_t )2);
      } else {
        tmp___8 = strcmp((char const   *)nm, "_z");
        if (tmp___8 == 0) {
          return ((size_t )2);
        } else {
          tmp___9 = strcmp((char const   *)nm, ".Z");
          if (tmp___9 == 0) {
            return ((size_t )2);
          }
        }
      }
    }
  }
  return ((size_t )0);
}
}
static void show_info(int method , unsigned long check , length_t len , int cont ) 
{ 
  size_t max ;
  size_t n ;
  time_t now ;
  char mod[26] ;
  char tag[49] ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  double red ;

  {
  if (g.verbosity > 1) {
    max = (size_t )16;
  } else {
    max = (size_t )48;
  }
  memset((void *)(tag), 0, max + 1UL);
  if (cont) {
    strncpy((char * __restrict  )(tag), (char const   * __restrict  )"<...>", max + 1UL);
  } else
  if ((unsigned long )g.hname == (unsigned long )((void *)0)) {
    tmp = strlen((char const   *)g.inf);
    tmp___0 = compressed_suffix(g.inf);
    n = tmp - tmp___0;
    if (n > max + 1UL) {
      tmp___1 = max + 1UL;
    } else {
      tmp___1 = n;
    }
    memcpy((void * __restrict  )(tag), (void const   * __restrict  )g.inf, tmp___1);
    tmp___2 = strcmp((char const   *)(g.inf + n), ".tgz");
    if (tmp___2 == 0) {
      if (n < max + 1UL) {
        strncpy((char * __restrict  )(tag + n), (char const   * __restrict  )".tar",
                (max + 1UL) - n);
      }
    }
  } else {
    strncpy((char * __restrict  )(tag), (char const   * __restrict  )g.hname, max + 1UL);
  }
  if (tag[max]) {
    strcpy((char * __restrict  )((tag + max) - 3), (char const   * __restrict  )"...");
  }
  if (g.stamp) {
    if (! cont) {
      tmp___3 = ctime((time_t const   *)(& g.stamp));
      strcpy((char * __restrict  )(mod), (char const   * __restrict  )tmp___3);
      now = time((time_t *)((void *)0));
      tmp___4 = ctime((time_t const   *)(& now));
      tmp___5 = strcmp((char const   *)(mod + 20), (char const   *)(tmp___4 + 20));
      if (tmp___5 != 0) {
        strcpy((char * __restrict  )(mod + 11), (char const   * __restrict  )(mod + 19));
      }
    } else {
      strcpy((char * __restrict  )(mod + 4), (char const   * __restrict  )"------ -----");
    }
  } else {
    strcpy((char * __restrict  )(mod + 4), (char const   * __restrict  )"------ -----");
  }
  mod[16] = (char)0;
  if (g.first) {
    if (g.verbosity > 1) {
      fputs((char const   * __restrict  )"method    check    timestamp    ", (FILE * __restrict  )stdout);
    }
    if (g.verbosity > 0) {
      puts("compressed   original reduced  name");
    }
    g.first = 0;
  }
  if (g.verbosity > 1) {
    if (g.form == 3) {
      if (! g.decode) {
        printf((char const   * __restrict  )"zip%3d  --------  %s  ", method, mod + 4);
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (g.form > 1) {
      printf((char const   * __restrict  )"zip%3d  %08lx  %s  ", method, check, mod + 4);
    } else
    if (g.form == 1) {
      printf((char const   * __restrict  )"zlib%2d  %08lx  %s  ", method, check, mod + 4);
    } else
    if (method == 257) {
      printf((char const   * __restrict  )"lzw     --------  %s  ", mod + 4);
    } else {
      printf((char const   * __restrict  )"gzip%2d  %08lx  %s  ", method, check, mod + 4);
    }
  }
  if (g.verbosity > 0) {
    red = (100. * ((double )len - (double )g.in_tot)) / (double )len;
    if (g.form == 3) {
      if (! g.decode) {
        printf((char const   * __restrict  )"%10ju %10ju?  unk    %s\n", g.in_tot,
               len, tag);
      } else {
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
    if (method == 8) {
      if (g.in_tot > (len + (len >> 10)) + 12UL) {
        printf((char const   * __restrict  )"%10ju %10ju?  unk    %s\n", g.in_tot,
               len, tag);
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (method == 257) {
      if (g.in_tot > (len + (len >> 1)) + 3UL) {
        printf((char const   * __restrict  )"%10ju %10ju?  unk    %s\n", g.in_tot,
               len, tag);
      } else {
        printf((char const   * __restrict  )"%10ju %10ju %6.1f%%  %s\n", g.in_tot,
               len, red, tag);
      }
    } else {
      printf((char const   * __restrict  )"%10ju %10ju %6.1f%%  %s\n", g.in_tot, len,
             red, tag);
    }
  }
  if (g.verbosity > 1) {
    if ((unsigned long )g.hcomm != (unsigned long )((void *)0)) {
      puts((char const   *)g.hcomm);
    }
  }
  return;
}
}
static void list_info(void) 
{ 
  int method ;
  size_t n ;
  off_t at ;
  unsigned char tail[8] ;
  unsigned long check ;
  length_t len ;
  char const   *tmp ;
  char const   *tmp___0 ;
  unsigned char *tmp___1 ;
  length_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
  in_init();
  method = get_header(1);
  if (method < 0) {
    if (method == -6) {
      tmp___0 = "skipping: %s corrupt: header crc error";
    } else {
      if (method == -1) {
        tmp = "skipping: %s empty";
      } else {
        tmp = "skipping: %s unrecognized format";
      }
      tmp___0 = tmp;
    }
    complain((char *)tmp___0, g.inf);
    return;
  }
  load_wait();
  if (g.form > 1) {
    more_zip_entries();
    g.in_tot = g.zip_clen;
    show_info(method, g.zip_crc, g.zip_ulen, 0);
    return;
  }
  if (g.form == 1) {
    at = lseek(g.ind, (__off64_t )0, 2);
    if (at == -1L) {
      check = 0UL;
      while (1) {
        if (g.in_left < 4UL) {
          len = g.in_left;
        } else {
          len = (length_t )4;
        }
        g.in_next += g.in_left - len;
        while (1) {
          tmp___2 = len;
          len --;
          if (! tmp___2) {
            break;
          }
          tmp___1 = g.in_next;
          (g.in_next) ++;
          check = (check << 8) + (unsigned long )*tmp___1;
        }
        tmp___3 = load();
        if (! (tmp___3 != 0UL)) {
          break;
        }
      }
      check &= 4294967295UL;
    } else {
      g.in_tot = (length_t )at;
      lseek(g.ind, (__off64_t )-4, 2);
      readn(g.ind, tail, (size_t )4);
      check = ((unsigned long )(((unsigned int )tail[0] << 8) + (unsigned int )tail[1]) << 16) + (unsigned long )(((unsigned int )*((tail + 2) + 0) << 8) + (unsigned int )*((tail + 2) + 1));
    }
    g.in_tot -= 6UL;
    show_info(method, check, (length_t )0, 0);
    return;
  }
  if (method == 257) {
    at = lseek(g.ind, (__off64_t )0, 2);
    if (at == -1L) {
      while (1) {
        tmp___4 = load();
        if (! (tmp___4 != 0UL)) {
          break;
        }
      }
    } else {
      g.in_tot = (length_t )at;
    }
    g.in_tot -= 3UL;
    show_info(method, 0UL, (length_t )0, 0);
    return;
  }
  if (g.in_short) {
    if (g.in_left < 8UL) {
      complain((char *)"skipping: %s not a valid gzip file", g.inf);
      return;
    }
    g.in_tot = g.in_left - 8UL;
    memcpy((void * __restrict  )(tail), (void const   * __restrict  )(g.in_next + (g.in_left - 8UL)),
           (size_t )8);
  } else {
    at = lseek(g.ind, (__off64_t )-8, 2);
    if (at != -1L) {
      g.in_tot = ((length_t )at - g.in_tot) + g.in_left;
      readn(g.ind, tail, (size_t )8);
    } else {
      len = g.in_tot - g.in_left;
      while (1) {
        if (g.in_left < 8UL) {
          n = g.in_left;
        } else {
          n = (size_t )8;
        }
        memcpy((void * __restrict  )(tail), (void const   * __restrict  )(g.in_next + (g.in_left - n)),
               n);
        load();
        if (! (g.in_left == 32768UL)) {
          break;
        }
      }
      if (g.in_left < 8UL) {
        if (n + g.in_left < 8UL) {
          complain((char *)"skipping: %s not a valid gzip file", g.inf);
          return;
        }
        if (g.in_left) {
          if (n + g.in_left > 8UL) {
            memcpy((void * __restrict  )(tail), (void const   * __restrict  )((tail + n) - (8UL - g.in_left)),
                   8UL - g.in_left);
          }
          memcpy((void * __restrict  )((tail + 8) - g.in_left), (void const   * __restrict  )g.in_next,
                 g.in_left);
        }
      } else {
        memcpy((void * __restrict  )(tail), (void const   * __restrict  )(g.in_next + (g.in_left - 8UL)),
               (size_t )8);
      }
      g.in_tot -= len + 8UL;
    }
  }
  if (g.in_tot < 2UL) {
    complain((char *)"skipping: %s not a valid gzip file", g.inf);
    return;
  }
  check = (unsigned long )((unsigned int )tail[0] + ((unsigned int )tail[1] << 8)) + ((unsigned long )((unsigned int )*((tail + 2) + 0) + ((unsigned int )*((tail + 2) + 1) << 8)) << 16);
  len = (unsigned long )((unsigned int )*((tail + 4) + 0) + ((unsigned int )*((tail + 4) + 1) << 8)) + ((unsigned long )((unsigned int )*(((tail + 4) + 2) + 0) + ((unsigned int )*(((tail + 4) + 2) + 1) << 8)) << 16);
  show_info(method, check, len, 0);
  return;
}
}
static void cat(void) 
{ 
  unsigned char buf[1] ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  if (g.magic1 != -1) {
    buf[0] = (unsigned char )g.magic1;
    tmp = writen(g.outd, (void const   *)(buf), (size_t )1);
    g.out_tot += tmp;
  }
  while (g.in_left) {
    tmp___0 = writen(g.outd, (void const   *)g.in_next, g.in_left);
    g.out_tot += tmp___0;
    g.in_left = (size_t )0;
    load();
  }
  return;
}
}
static unsigned int inb(void *desc , unsigned char **buf ) 
{ 
  unsigned int len ;
  unsigned int tmp ;

  {
  if (g.in_left == 0UL) {
    load();
  }
  *buf = g.in_next;
  if (g.in_left > 4294967295UL) {
    tmp = 4294967295U;
  } else {
    tmp = (unsigned int )g.in_left;
  }
  len = tmp;
  g.in_next += len;
  g.in_left -= (size_t )len;
  return (len);
}
}
static unsigned char out_buf[32768U]  ;
static unsigned char out_copy[32768U]  ;
static size_t out_len  ;
static lock *outb_write_more  =    (lock *)((void *)0);
static lock *outb_check_more  ;
static void outb_write(void *dummy ) 
{ 
  size_t len ;
  try_ball_t_ err ;
  try_t_ try_this_ ;
  int volatile   try_pushed_ ;
  void *tmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___8 ;

  {
  while (1) {
    try_pushed_ = (int volatile   )1;
    try_this_.ball.ret = 0;
    try_this_.ball.code = 0;
    try_this_.ball.free = 0;
    try_this_.ball.why = (char *)((void *)0);
    try_setup_();
    tmp = pthread_getspecific(try_key_);
    try_this_.next = (try_t_ *)tmp;
    while (1) {
      tmp___3 = pthread_setspecific(try_key_, (void const   *)(& try_this_));
      if (tmp___3 == 0) {
        if (! "try: pthread_setspecific() failed") {
          __assert_fail("pthread_setspecific(try_key_, &try_this_) == 0 && \"try: pthread_setspecific() failed\"",
                        "pigz.c", 3350U, "outb_write");
        }
      } else {
        __assert_fail("pthread_setspecific(try_key_, &try_this_) == 0 && \"try: pthread_setspecific() failed\"",
                      "pigz.c", 3350U, "outb_write");
      }
      break;
    }
    tmp___4 = _setjmp((struct __jmp_buf_tag *)(try_this_.env));
    if (tmp___4 == 0) {
      while (1) {
        while (1) {
          possess_(outb_write_more, "pigz.c", 3352L);
          wait_for_(outb_write_more, (enum wait_op )0, 1L, "pigz.c", 3353L);
          len = out_len;
          if (len) {
            if (g.decode == 1) {
              writen(g.outd, (void const   *)(out_copy), len);
            }
          }
          twist_(outb_write_more, (enum twist_op )0, 0L, "pigz.c", 3358L);
          if (! len) {
            break;
          }
        }
        break;
      }
    }
    if (try_pushed_) {
      while (1) {
        tmp___8 = pthread_setspecific(try_key_, (void const   *)try_this_.next);
        if (tmp___8 == 0) {
          if (! "try: pthread_setspecific() failed") {
            __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                          "pigz.c", 3361U, "outb_write");
          }
        } else {
          __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                        "pigz.c", 3361U, "outb_write");
        }
        break;
      }
      try_pushed_ = (int volatile   )0;
    }
    err = try_this_.ball;
    break;
  }
  if (err.code) {
    while (1) {
      if (err.code != 32) {
        complain((char *)"abort: %s", err.why);
      }
      while (1) {
        if (err.free) {
          free((void *)err.why);
          err.free = 0;
          err.why = (char *)((void *)0);
        }
        break;
      }
      cut_short(- err.code);
      break;
    }
  }
  return;
}
}
static void outb_check(void *dummy ) 
{ 
  size_t len ;
  try_ball_t_ err ;
  try_t_ try_this_ ;
  int volatile   try_pushed_ ;
  void *tmp ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  int tmp___6 ;
  int tmp___10 ;

  {
  while (1) {
    try_pushed_ = (int volatile   )1;
    try_this_.ball.ret = 0;
    try_this_.ball.code = 0;
    try_this_.ball.free = 0;
    try_this_.ball.why = (char *)((void *)0);
    try_setup_();
    tmp = pthread_getspecific(try_key_);
    try_this_.next = (try_t_ *)tmp;
    while (1) {
      tmp___3 = pthread_setspecific(try_key_, (void const   *)(& try_this_));
      if (tmp___3 == 0) {
        if (! "try: pthread_setspecific() failed") {
          __assert_fail("pthread_setspecific(try_key_, &try_this_) == 0 && \"try: pthread_setspecific() failed\"",
                        "pigz.c", 3375U, "outb_check");
        }
      } else {
        __assert_fail("pthread_setspecific(try_key_, &try_this_) == 0 && \"try: pthread_setspecific() failed\"",
                      "pigz.c", 3375U, "outb_check");
      }
      break;
    }
    tmp___6 = _setjmp((struct __jmp_buf_tag *)(try_this_.env));
    if (tmp___6 == 0) {
      while (1) {
        while (1) {
          possess_(outb_check_more, "pigz.c", 3377L);
          wait_for_(outb_check_more, (enum wait_op )0, 1L, "pigz.c", 3378L);
          len = out_len;
          if (g.form == 1) {
            tmp___4 = adler32z(g.out_check, (unsigned char const   *)(out_copy), len);
            g.out_check = tmp___4;
          } else {
            tmp___5 = crc32z(g.out_check, (unsigned char const   *)(out_copy), len);
            g.out_check = tmp___5;
          }
          twist_(outb_check_more, (enum twist_op )0, 0L, "pigz.c", 3382L);
          if (! len) {
            break;
          }
        }
        break;
      }
    }
    if (try_pushed_) {
      while (1) {
        tmp___10 = pthread_setspecific(try_key_, (void const   *)try_this_.next);
        if (tmp___10 == 0) {
          if (! "try: pthread_setspecific() failed") {
            __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                          "pigz.c", 3385U, "outb_check");
          }
        } else {
          __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                        "pigz.c", 3385U, "outb_check");
        }
        break;
      }
      try_pushed_ = (int volatile   )0;
    }
    err = try_this_.ball;
    break;
  }
  if (err.code) {
    while (1) {
      if (err.code != 32) {
        complain((char *)"abort: %s", err.why);
      }
      while (1) {
        if (err.free) {
          free((void *)err.why);
          err.free = 0;
          err.why = (char *)((void *)0);
        }
        break;
      }
      cut_short(- err.code);
      break;
    }
  }
  return;
}
}
static thread *wr  ;
static thread *ch  ;
static int outb(void *desc , unsigned char *buf , unsigned int len ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;

  {
  if (g.procs > 1) {
    if ((unsigned long )outb_write_more == (unsigned long )((void *)0)) {
      outb_write_more = new_lock_(0L, "pigz.c", 3405L);
      outb_check_more = new_lock_(0L, "pigz.c", 3406L);
      wr = launch_(& outb_write, (void *)0, "pigz.c", 3407L);
      ch = launch_(& outb_check, (void *)0, "pigz.c", 3408L);
    }
    possess_(outb_check_more, "pigz.c", 3412L);
    wait_for_(outb_check_more, (enum wait_op )0, 0L, "pigz.c", 3413L);
    possess_(outb_write_more, "pigz.c", 3414L);
    wait_for_(outb_write_more, (enum wait_op )0, 0L, "pigz.c", 3415L);
    out_len = (size_t )len;
    g.out_tot += (length_t )len;
    memcpy((void * __restrict  )(out_copy), (void const   * __restrict  )buf, (size_t )len);
    twist_(outb_write_more, (enum twist_op )0, 1L, "pigz.c", 3421L);
    twist_(outb_check_more, (enum twist_op )0, 1L, "pigz.c", 3422L);
    if (len == 0U) {
      if ((unsigned long )outb_write_more != (unsigned long )((void *)0)) {
        join_(ch, "pigz.c", 3427L);
        join_(wr, "pigz.c", 3428L);
        free_lock_(outb_check_more, "pigz.c", 3429L);
        free_lock_(outb_write_more, "pigz.c", 3430L);
        outb_write_more = (lock *)((void *)0);
      }
    }
    return (0);
  }
  if (len) {
    if (g.decode == 1) {
      writen(g.outd, (void const   *)buf, (size_t )len);
    }
    if (g.form == 1) {
      tmp = adler32z(g.out_check, (unsigned char const   *)buf, (size_t )len);
      g.out_check = tmp;
    } else {
      tmp___0 = crc32z(g.out_check, (unsigned char const   *)buf, (size_t )len);
      g.out_check = tmp___0;
    }
    g.out_tot += (length_t )len;
  }
  return (0);
}
}
static void infchk(void) 
{ 
  int ret ;
  int cont ;
  int more ;
  unsigned long check ;
  unsigned long len ;
  unsigned long ktot ;
  z_stream strm___0 ;
  unsigned int tmp2 ;
  unsigned long tmp4 ;
  length_t clen ;
  length_t ctot ;
  length_t utot ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned char *tmp___4 ;
  size_t tmp___5 ;
  unsigned char *tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  unsigned char *tmp___11 ;
  size_t tmp___12 ;
  unsigned char *tmp___14 ;
  int tmp___15 ;
  size_t tmp___16 ;
  unsigned char *tmp___18 ;
  size_t tmp___19 ;
  unsigned char *tmp___21 ;
  int tmp___22 ;
  size_t tmp___23 ;
  unsigned char *tmp___25 ;
  size_t tmp___26 ;
  unsigned char *tmp___28 ;
  int tmp___29 ;
  size_t tmp___30 ;
  unsigned char *tmp___32 ;
  size_t tmp___33 ;
  unsigned char *tmp___35 ;
  int tmp___36 ;
  size_t tmp___37 ;
  unsigned char *tmp___39 ;
  size_t tmp___40 ;
  unsigned char *tmp___42 ;
  int tmp___43 ;
  size_t tmp___44 ;
  unsigned char *tmp___46 ;
  size_t tmp___47 ;
  unsigned char *tmp___49 ;
  int tmp___50 ;
  size_t tmp___51 ;
  unsigned char *tmp___53 ;
  size_t tmp___54 ;
  unsigned char *tmp___56 ;
  int tmp___57 ;
  size_t tmp___58 ;
  length_t tmp___59 ;
  unsigned char *tmp___61 ;
  size_t tmp___62 ;
  unsigned char *tmp___64 ;
  int tmp___65 ;
  size_t tmp___66 ;
  unsigned char *tmp___68 ;
  size_t tmp___69 ;
  unsigned char *tmp___71 ;
  int tmp___72 ;
  size_t tmp___73 ;
  unsigned char *tmp___75 ;
  size_t tmp___76 ;
  unsigned char *tmp___78 ;
  int tmp___79 ;
  size_t tmp___80 ;
  unsigned char *tmp___82 ;
  size_t tmp___83 ;
  unsigned char *tmp___85 ;
  int tmp___86 ;
  size_t tmp___87 ;
  unsigned char *tmp___89 ;
  int tmp___90 ;
  size_t tmp___91 ;
  unsigned char *tmp___93 ;
  int tmp___94 ;
  size_t tmp___95 ;
  unsigned char *tmp___97 ;
  int tmp___98 ;
  size_t tmp___99 ;
  unsigned char *tmp___101 ;
  int tmp___102 ;
  size_t tmp___103 ;
  unsigned char *tmp___105 ;
  size_t tmp___106 ;
  unsigned char *tmp___108 ;
  int tmp___109 ;
  size_t tmp___110 ;
  unsigned char *tmp___112 ;
  size_t tmp___113 ;
  unsigned char *tmp___115 ;
  int tmp___116 ;
  size_t tmp___117 ;
  unsigned char *tmp___119 ;
  size_t tmp___120 ;
  unsigned char *tmp___122 ;
  int tmp___123 ;
  size_t tmp___124 ;
  unsigned char *tmp___126 ;
  size_t tmp___127 ;
  unsigned char *tmp___129 ;
  int tmp___130 ;
  size_t tmp___131 ;
  unsigned long tmp___132 ;
  unsigned long tmp___133 ;
  unsigned char *tmp___134 ;
  size_t tmp___135 ;

  {
  utot = (length_t )0;
  ctot = utot;
  if (g.form == 1) {
    tmp = adler32z(0UL, (unsigned char const   *)0, (size_t )0);
    ktot = tmp;
  } else {
    tmp___0 = crc32z(0UL, (unsigned char const   *)0, (size_t )0);
    ktot = tmp___0;
  }
  more = 0;
  cont = more;
  while (1) {
    g.in_tot = g.in_left;
    g.out_tot = (length_t )0;
    if (g.form == 1) {
      tmp___1 = adler32z(0UL, (unsigned char const   *)0, (size_t )0);
      g.out_check = tmp___1;
    } else {
      tmp___2 = crc32z(0UL, (unsigned char const   *)0, (size_t )0);
      g.out_check = tmp___2;
    }
    strm___0.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))0;
    strm___0.zfree = (void (*)(voidpf opaque , voidpf address ))0;
    strm___0.opaque = (voidpf )0;
    ret = inflateBackInit_(& strm___0, 15, out_buf, "1.2.11", (int )sizeof(z_stream ));
    if (ret == -4) {
      try_throw_(12, (char *)"not enough memory", (void *)0);
    }
    if (ret != 0) {
      try_throw_(22, (char *)"internal error", (void *)0);
    }
    strm___0.avail_in = (uInt )0;
    strm___0.next_in = (Bytef *)0;
    ret = inflateBack(& strm___0, & inb, (void *)0, & outb, (void *)0);
    inflateBackEnd(& strm___0);
    if (ret == -3) {
      try_throw_(33, (char *)"%s: corrupted -- invalid deflate data (%s)", g.inf,
                 strm___0.msg, (void *)0);
    }
    if (ret == -5) {
      try_throw_(33, (char *)"%s: corrupted -- incomplete deflate data", g.inf, (void *)0);
    }
    if (ret != 1) {
      try_throw_(22, (char *)"internal error", (void *)0);
    }
    g.in_left += (size_t )strm___0.avail_in;
    g.in_next = strm___0.next_in;
    outb((void *)0, (unsigned char *)((void *)0), 0U);
    clen = g.in_tot - g.in_left;
    if (g.form > 1) {
      if (g.form == 3) {
        if (g.in_left == 0UL) {
          if (g.in_eof) {
            tmp2 = 0U;
          } else {
            tmp___5 = load();
            if (tmp___5 == 0UL) {
              tmp2 = 0U;
            } else {
              (g.in_left) --;
              tmp___4 = g.in_next;
              (g.in_next) ++;
              tmp2 = (unsigned int )*tmp___4;
            }
          }
        } else {
          (g.in_left) --;
          tmp___4 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___4;
        }
        if (g.in_left == 0UL) {
          if (g.in_eof) {
            tmp___8 = 0;
          } else {
            tmp___9 = load();
            if (tmp___9 == 0UL) {
              tmp___8 = 0;
            } else {
              (g.in_left) --;
              tmp___7 = g.in_next;
              (g.in_next) ++;
              tmp___8 = (int )*tmp___7;
            }
          }
        } else {
          (g.in_left) --;
          tmp___7 = g.in_next;
          (g.in_next) ++;
          tmp___8 = (int )*tmp___7;
        }
        tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___8 << 8));
        if (g.in_left == 0UL) {
          if (g.in_eof) {
            tmp2 = 0U;
          } else {
            tmp___12 = load();
            if (tmp___12 == 0UL) {
              tmp2 = 0U;
            } else {
              (g.in_left) --;
              tmp___11 = g.in_next;
              (g.in_next) ++;
              tmp2 = (unsigned int )*tmp___11;
            }
          }
        } else {
          (g.in_left) --;
          tmp___11 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___11;
        }
        if (g.in_left == 0UL) {
          if (g.in_eof) {
            tmp___15 = 0;
          } else {
            tmp___16 = load();
            if (tmp___16 == 0UL) {
              tmp___15 = 0;
            } else {
              (g.in_left) --;
              tmp___14 = g.in_next;
              (g.in_next) ++;
              tmp___15 = (int )*tmp___14;
            }
          }
        } else {
          (g.in_left) --;
          tmp___14 = g.in_next;
          (g.in_next) ++;
          tmp___15 = (int )*tmp___14;
        }
        g.zip_crc = tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___15 << 8)) << 16);
        if (g.in_left == 0UL) {
          if (g.in_eof) {
            tmp2 = 0U;
          } else {
            tmp___19 = load();
            if (tmp___19 == 0UL) {
              tmp2 = 0U;
            } else {
              (g.in_left) --;
              tmp___18 = g.in_next;
              (g.in_next) ++;
              tmp2 = (unsigned int )*tmp___18;
            }
          }
        } else {
          (g.in_left) --;
          tmp___18 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___18;
        }
        if (g.in_left == 0UL) {
          if (g.in_eof) {
            tmp___22 = 0;
          } else {
            tmp___23 = load();
            if (tmp___23 == 0UL) {
              tmp___22 = 0;
            } else {
              (g.in_left) --;
              tmp___21 = g.in_next;
              (g.in_next) ++;
              tmp___22 = (int )*tmp___21;
            }
          }
        } else {
          (g.in_left) --;
          tmp___21 = g.in_next;
          (g.in_next) ++;
          tmp___22 = (int )*tmp___21;
        }
        tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___22 << 8));
        if (g.in_left == 0UL) {
          if (g.in_eof) {
            tmp2 = 0U;
          } else {
            tmp___26 = load();
            if (tmp___26 == 0UL) {
              tmp2 = 0U;
            } else {
              (g.in_left) --;
              tmp___25 = g.in_next;
              (g.in_next) ++;
              tmp2 = (unsigned int )*tmp___25;
            }
          }
        } else {
          (g.in_left) --;
          tmp___25 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___25;
        }
        if (g.in_left == 0UL) {
          if (g.in_eof) {
            tmp___29 = 0;
          } else {
            tmp___30 = load();
            if (tmp___30 == 0UL) {
              tmp___29 = 0;
            } else {
              (g.in_left) --;
              tmp___28 = g.in_next;
              (g.in_next) ++;
              tmp___29 = (int )*tmp___28;
            }
          }
        } else {
          (g.in_left) --;
          tmp___28 = g.in_next;
          (g.in_next) ++;
          tmp___29 = (int )*tmp___28;
        }
        g.zip_clen = tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___29 << 8)) << 16);
        if (g.in_left == 0UL) {
          if (g.in_eof) {
            tmp2 = 0U;
          } else {
            tmp___33 = load();
            if (tmp___33 == 0UL) {
              tmp2 = 0U;
            } else {
              (g.in_left) --;
              tmp___32 = g.in_next;
              (g.in_next) ++;
              tmp2 = (unsigned int )*tmp___32;
            }
          }
        } else {
          (g.in_left) --;
          tmp___32 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___32;
        }
        if (g.in_left == 0UL) {
          if (g.in_eof) {
            tmp___36 = 0;
          } else {
            tmp___37 = load();
            if (tmp___37 == 0UL) {
              tmp___36 = 0;
            } else {
              (g.in_left) --;
              tmp___35 = g.in_next;
              (g.in_next) ++;
              tmp___36 = (int )*tmp___35;
            }
          }
        } else {
          (g.in_left) --;
          tmp___35 = g.in_next;
          (g.in_next) ++;
          tmp___36 = (int )*tmp___35;
        }
        tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___36 << 8));
        if (g.in_left == 0UL) {
          if (g.in_eof) {
            tmp2 = 0U;
          } else {
            tmp___40 = load();
            if (tmp___40 == 0UL) {
              tmp2 = 0U;
            } else {
              (g.in_left) --;
              tmp___39 = g.in_next;
              (g.in_next) ++;
              tmp2 = (unsigned int )*tmp___39;
            }
          }
        } else {
          (g.in_left) --;
          tmp___39 = g.in_next;
          (g.in_next) ++;
          tmp2 = (unsigned int )*tmp___39;
        }
        if (g.in_left == 0UL) {
          if (g.in_eof) {
            tmp___43 = 0;
          } else {
            tmp___44 = load();
            if (tmp___44 == 0UL) {
              tmp___43 = 0;
            } else {
              (g.in_left) --;
              tmp___42 = g.in_next;
              (g.in_next) ++;
              tmp___43 = (int )*tmp___42;
            }
          }
        } else {
          (g.in_left) --;
          tmp___42 = g.in_next;
          (g.in_next) ++;
          tmp___43 = (int )*tmp___42;
        }
        g.zip_ulen = tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___43 << 8)) << 16);
        if (g.zip_crc == 134695760UL) {
          if (g.out_check != 134695760UL) {
            goto _L___0;
          } else
          if (g.zip_clen == 134695760UL) {
            if ((clen & 4294967295UL) != 134695760UL) {
              goto _L___0;
            } else
            if (g.zip_ulen == 134695760UL) {
              if (g.zip64) {
                tmp___59 = clen >> 32;
              } else {
                tmp___59 = g.out_tot;
              }
              if (tmp___59 != 134695760UL) {
                _L___0: /* CIL Label */ 
                g.zip_crc = g.zip_clen;
                g.zip_clen = g.zip_ulen;
                if (g.in_left == 0UL) {
                  if (g.in_eof) {
                    tmp2 = 0U;
                  } else {
                    tmp___47 = load();
                    if (tmp___47 == 0UL) {
                      tmp2 = 0U;
                    } else {
                      (g.in_left) --;
                      tmp___46 = g.in_next;
                      (g.in_next) ++;
                      tmp2 = (unsigned int )*tmp___46;
                    }
                  }
                } else {
                  (g.in_left) --;
                  tmp___46 = g.in_next;
                  (g.in_next) ++;
                  tmp2 = (unsigned int )*tmp___46;
                }
                if (g.in_left == 0UL) {
                  if (g.in_eof) {
                    tmp___50 = 0;
                  } else {
                    tmp___51 = load();
                    if (tmp___51 == 0UL) {
                      tmp___50 = 0;
                    } else {
                      (g.in_left) --;
                      tmp___49 = g.in_next;
                      (g.in_next) ++;
                      tmp___50 = (int )*tmp___49;
                    }
                  }
                } else {
                  (g.in_left) --;
                  tmp___49 = g.in_next;
                  (g.in_next) ++;
                  tmp___50 = (int )*tmp___49;
                }
                tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___50 << 8));
                if (g.in_left == 0UL) {
                  if (g.in_eof) {
                    tmp2 = 0U;
                  } else {
                    tmp___54 = load();
                    if (tmp___54 == 0UL) {
                      tmp2 = 0U;
                    } else {
                      (g.in_left) --;
                      tmp___53 = g.in_next;
                      (g.in_next) ++;
                      tmp2 = (unsigned int )*tmp___53;
                    }
                  }
                } else {
                  (g.in_left) --;
                  tmp___53 = g.in_next;
                  (g.in_next) ++;
                  tmp2 = (unsigned int )*tmp___53;
                }
                if (g.in_left == 0UL) {
                  if (g.in_eof) {
                    tmp___57 = 0;
                  } else {
                    tmp___58 = load();
                    if (tmp___58 == 0UL) {
                      tmp___57 = 0;
                    } else {
                      (g.in_left) --;
                      tmp___56 = g.in_next;
                      (g.in_next) ++;
                      tmp___57 = (int )*tmp___56;
                    }
                  }
                } else {
                  (g.in_left) --;
                  tmp___56 = g.in_next;
                  (g.in_next) ++;
                  tmp___57 = (int )*tmp___56;
                }
                g.zip_ulen = tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___57 << 8)) << 16);
              }
            }
          }
        }
        if (g.zip64) {
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp2 = 0U;
            } else {
              tmp___62 = load();
              if (tmp___62 == 0UL) {
                tmp2 = 0U;
              } else {
                (g.in_left) --;
                tmp___61 = g.in_next;
                (g.in_next) ++;
                tmp2 = (unsigned int )*tmp___61;
              }
            }
          } else {
            (g.in_left) --;
            tmp___61 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___61;
          }
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp___65 = 0;
            } else {
              tmp___66 = load();
              if (tmp___66 == 0UL) {
                tmp___65 = 0;
              } else {
                (g.in_left) --;
                tmp___64 = g.in_next;
                (g.in_next) ++;
                tmp___65 = (int )*tmp___64;
              }
            }
          } else {
            (g.in_left) --;
            tmp___64 = g.in_next;
            (g.in_next) ++;
            tmp___65 = (int )*tmp___64;
          }
          tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___65 << 8));
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp2 = 0U;
            } else {
              tmp___69 = load();
              if (tmp___69 == 0UL) {
                tmp2 = 0U;
              } else {
                (g.in_left) --;
                tmp___68 = g.in_next;
                (g.in_next) ++;
                tmp2 = (unsigned int )*tmp___68;
              }
            }
          } else {
            (g.in_left) --;
            tmp___68 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___68;
          }
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp___72 = 0;
            } else {
              tmp___73 = load();
              if (tmp___73 == 0UL) {
                tmp___72 = 0;
              } else {
                (g.in_left) --;
                tmp___71 = g.in_next;
                (g.in_next) ++;
                tmp___72 = (int )*tmp___71;
              }
            }
          } else {
            (g.in_left) --;
            tmp___71 = g.in_next;
            (g.in_next) ++;
            tmp___72 = (int )*tmp___71;
          }
          g.zip_ulen = tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___72 << 8)) << 16);
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp2 = 0U;
            } else {
              tmp___76 = load();
              if (tmp___76 == 0UL) {
                tmp2 = 0U;
              } else {
                (g.in_left) --;
                tmp___75 = g.in_next;
                (g.in_next) ++;
                tmp2 = (unsigned int )*tmp___75;
              }
            }
          } else {
            (g.in_left) --;
            tmp___75 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___75;
          }
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp___79 = 0;
            } else {
              tmp___80 = load();
              if (tmp___80 == 0UL) {
                tmp___79 = 0;
              } else {
                (g.in_left) --;
                tmp___78 = g.in_next;
                (g.in_next) ++;
                tmp___79 = (int )*tmp___78;
              }
            }
          } else {
            (g.in_left) --;
            tmp___78 = g.in_next;
            (g.in_next) ++;
            tmp___79 = (int )*tmp___78;
          }
          tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___79 << 8));
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp2 = 0U;
            } else {
              tmp___83 = load();
              if (tmp___83 == 0UL) {
                tmp2 = 0U;
              } else {
                (g.in_left) --;
                tmp___82 = g.in_next;
                (g.in_next) ++;
                tmp2 = (unsigned int )*tmp___82;
              }
            }
          } else {
            (g.in_left) --;
            tmp___82 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___82;
          }
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              tmp___86 = 0;
            } else {
              tmp___87 = load();
              if (tmp___87 == 0UL) {
                tmp___86 = 0;
              } else {
                (g.in_left) --;
                tmp___85 = g.in_next;
                (g.in_next) ++;
                tmp___86 = (int )*tmp___85;
              }
            }
          } else {
            (g.in_left) --;
            tmp___85 = g.in_next;
            (g.in_next) ++;
            tmp___86 = (int )*tmp___85;
          }
        }
        if (g.in_eof) {
          try_throw_(33, (char *)"%s: corrupted entry -- missing trailer", g.inf,
                     (void *)0);
        }
      }
      check = g.zip_crc;
      if (check != g.out_check) {
        try_throw_(33, (char *)"%s: corrupted entry -- crc32 mismatch", g.inf, (void *)0);
      }
      if (g.zip_clen != (clen & 4294967295UL)) {
        try_throw_(33, (char *)"%s: corrupted entry -- length mismatch", g.inf, (void *)0);
      } else
      if (g.zip_ulen != (g.out_tot & 4294967295UL)) {
        try_throw_(33, (char *)"%s: corrupted entry -- length mismatch", g.inf, (void *)0);
      }
      more = more_zip_entries();
    } else
    if (g.form == 1) {
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp___90 = 0;
        } else {
          tmp___91 = load();
          if (tmp___91 == 0UL) {
            tmp___90 = 0;
          } else {
            (g.in_left) --;
            tmp___89 = g.in_next;
            (g.in_next) ++;
            tmp___90 = (int )*tmp___89;
          }
        }
      } else {
        (g.in_left) --;
        tmp___89 = g.in_next;
        (g.in_next) ++;
        tmp___90 = (int )*tmp___89;
      }
      check = (unsigned long )tmp___90 << 24;
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp___94 = 0;
        } else {
          tmp___95 = load();
          if (tmp___95 == 0UL) {
            tmp___94 = 0;
          } else {
            (g.in_left) --;
            tmp___93 = g.in_next;
            (g.in_next) ++;
            tmp___94 = (int )*tmp___93;
          }
        }
      } else {
        (g.in_left) --;
        tmp___93 = g.in_next;
        (g.in_next) ++;
        tmp___94 = (int )*tmp___93;
      }
      check += (unsigned long )tmp___94 << 16;
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp___98 = 0;
        } else {
          tmp___99 = load();
          if (tmp___99 == 0UL) {
            tmp___98 = 0;
          } else {
            (g.in_left) --;
            tmp___97 = g.in_next;
            (g.in_next) ++;
            tmp___98 = (int )*tmp___97;
          }
        }
      } else {
        (g.in_left) --;
        tmp___97 = g.in_next;
        (g.in_next) ++;
        tmp___98 = (int )*tmp___97;
      }
      check += (unsigned long )((unsigned int )tmp___98 << 8);
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp___102 = 0;
        } else {
          tmp___103 = load();
          if (tmp___103 == 0UL) {
            tmp___102 = 0;
          } else {
            (g.in_left) --;
            tmp___101 = g.in_next;
            (g.in_next) ++;
            tmp___102 = (int )*tmp___101;
          }
        }
      } else {
        (g.in_left) --;
        tmp___101 = g.in_next;
        (g.in_next) ++;
        tmp___102 = (int )*tmp___101;
      }
      check += (unsigned long )tmp___102;
      if (g.in_eof) {
        try_throw_(33, (char *)"%s: corrupted -- missing trailer", g.inf, (void *)0);
      }
      if (check != g.out_check) {
        try_throw_(33, (char *)"%s: corrupted -- adler32 mismatch", g.inf, (void *)0);
      }
    } else {
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp2 = 0U;
        } else {
          tmp___106 = load();
          if (tmp___106 == 0UL) {
            tmp2 = 0U;
          } else {
            (g.in_left) --;
            tmp___105 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___105;
          }
        }
      } else {
        (g.in_left) --;
        tmp___105 = g.in_next;
        (g.in_next) ++;
        tmp2 = (unsigned int )*tmp___105;
      }
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp___109 = 0;
        } else {
          tmp___110 = load();
          if (tmp___110 == 0UL) {
            tmp___109 = 0;
          } else {
            (g.in_left) --;
            tmp___108 = g.in_next;
            (g.in_next) ++;
            tmp___109 = (int )*tmp___108;
          }
        }
      } else {
        (g.in_left) --;
        tmp___108 = g.in_next;
        (g.in_next) ++;
        tmp___109 = (int )*tmp___108;
      }
      tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___109 << 8));
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp2 = 0U;
        } else {
          tmp___113 = load();
          if (tmp___113 == 0UL) {
            tmp2 = 0U;
          } else {
            (g.in_left) --;
            tmp___112 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___112;
          }
        }
      } else {
        (g.in_left) --;
        tmp___112 = g.in_next;
        (g.in_next) ++;
        tmp2 = (unsigned int )*tmp___112;
      }
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp___116 = 0;
        } else {
          tmp___117 = load();
          if (tmp___117 == 0UL) {
            tmp___116 = 0;
          } else {
            (g.in_left) --;
            tmp___115 = g.in_next;
            (g.in_next) ++;
            tmp___116 = (int )*tmp___115;
          }
        }
      } else {
        (g.in_left) --;
        tmp___115 = g.in_next;
        (g.in_next) ++;
        tmp___116 = (int )*tmp___115;
      }
      check = tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___116 << 8)) << 16);
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp2 = 0U;
        } else {
          tmp___120 = load();
          if (tmp___120 == 0UL) {
            tmp2 = 0U;
          } else {
            (g.in_left) --;
            tmp___119 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___119;
          }
        }
      } else {
        (g.in_left) --;
        tmp___119 = g.in_next;
        (g.in_next) ++;
        tmp2 = (unsigned int )*tmp___119;
      }
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp___123 = 0;
        } else {
          tmp___124 = load();
          if (tmp___124 == 0UL) {
            tmp___123 = 0;
          } else {
            (g.in_left) --;
            tmp___122 = g.in_next;
            (g.in_next) ++;
            tmp___123 = (int )*tmp___122;
          }
        }
      } else {
        (g.in_left) --;
        tmp___122 = g.in_next;
        (g.in_next) ++;
        tmp___123 = (int )*tmp___122;
      }
      tmp4 = (unsigned long )(tmp2 + ((unsigned int )tmp___123 << 8));
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp2 = 0U;
        } else {
          tmp___127 = load();
          if (tmp___127 == 0UL) {
            tmp2 = 0U;
          } else {
            (g.in_left) --;
            tmp___126 = g.in_next;
            (g.in_next) ++;
            tmp2 = (unsigned int )*tmp___126;
          }
        }
      } else {
        (g.in_left) --;
        tmp___126 = g.in_next;
        (g.in_next) ++;
        tmp2 = (unsigned int )*tmp___126;
      }
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          tmp___130 = 0;
        } else {
          tmp___131 = load();
          if (tmp___131 == 0UL) {
            tmp___130 = 0;
          } else {
            (g.in_left) --;
            tmp___129 = g.in_next;
            (g.in_next) ++;
            tmp___130 = (int )*tmp___129;
          }
        }
      } else {
        (g.in_left) --;
        tmp___129 = g.in_next;
        (g.in_next) ++;
        tmp___130 = (int )*tmp___129;
      }
      len = tmp4 + ((unsigned long )(tmp2 + ((unsigned int )tmp___130 << 8)) << 16);
      if (g.in_eof) {
        try_throw_(33, (char *)"%s: corrupted -- missing trailer", g.inf, (void *)0);
      }
      if (check != g.out_check) {
        try_throw_(33, (char *)"%s: corrupted -- crc32 mismatch", g.inf, (void *)0);
      }
      if (len != (g.out_tot & 4294967295UL)) {
        try_throw_(33, (char *)"%s: corrupted -- length mismatch", g.inf, (void *)0);
      }
    }
    if (g.list) {
      ctot += clen;
      utot += g.out_tot;
      if (g.form == 1) {
        tmp___132 = adler32_comb(ktot, check, g.out_tot);
        ktot = tmp___132;
      } else {
        tmp___133 = crc32_comb(ktot, check, g.out_tot);
        ktot = tmp___133;
      }
      g.in_tot = clen;
      show_info(8, check, g.out_tot, cont);
      if (cont) {
        cont = 2;
      } else {
        cont = 1;
      }
    }
    if (g.form == 0) {
      ret = get_header(0);
      if (! (ret == 8)) {
        break;
      }
    } else {
      break;
    }
  }
  if (cont > 1) {
    if (g.verbosity > 0) {
      if (g.verbosity > 1) {
        printf((char const   * __restrict  )"        %08lx                ", ktot);
      }
      printf((char const   * __restrict  )"%10ju %10ju %6.1f%%  (total)\n", ctot,
             utot, (100. * ((double )utot - (double )ctot)) / (double )utot);
    }
  }
  if (g.form == 0) {
    if (ret == -2) {
      if (g.force) {
        if (g.pipeout) {
          if (g.decode != 2) {
            if (! g.list) {
              cat();
            } else {
              goto _L___7;
            }
          } else {
            goto _L___7;
          }
        } else {
          goto _L___7;
        }
      } else {
        goto _L___7;
      }
    } else {
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
  if (more) {
    complain((char *)"warning: %s: entries after the first were ignored", g.inf);
    g.keep = 1;
  } else
  if (g.verbosity > 1) {
    if (g.form == 0) {
      if (ret != -1) {
        complain((char *)"warning: %s: trailing junk was ignored", g.inf);
      } else {
        goto _L___2;
      }
    } else {
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
  if (g.form == 1) {
    if (g.in_left == 0UL) {
      if (! g.in_eof) {
        tmp___135 = load();
        if (! (tmp___135 == 0UL)) {
          (g.in_left) --;
          tmp___134 = g.in_next;
          (g.in_next) ++;
        }
      }
    } else {
      (g.in_left) --;
      tmp___134 = g.in_next;
      (g.in_next) ++;
    }
    if (! g.in_eof) {
      complain((char *)"warning: %s: trailing junk was ignored", g.inf);
    }
  }
  return;
}
}
static void unlzw(void) 
{ 
  unsigned int bits ;
  unsigned int mask ;
  bits_t buf ;
  unsigned int left ;
  length_t mark ;
  unsigned int code ;
  unsigned int max ;
  unsigned int flags ;
  unsigned int end ;
  unsigned int prev ;
  unsigned int final ;
  unsigned int stack ;
  unsigned int outcnt ;
  index_t prefix[65536] ;
  unsigned char suffix[65536] ;
  unsigned char match[65282] ;
  size_t tmp ;
  unsigned char *tmp___0 ;
  size_t tmp___1 ;
  unsigned char *tmp___2 ;
  size_t tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned int rem ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  unsigned char *tmp___8 ;
  size_t tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned int rem___0 ;
  size_t tmp___11 ;
  unsigned int temp ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  unsigned int tmp___16 ;

  {
  g.out_tot = (length_t )0;
  if (g.in_left == 0UL) {
    if (g.in_eof) {
      try_throw_(33, (char *)"%s: lzw premature end", g.inf, (void *)0);
    } else {
      tmp = load();
      if (tmp == 0UL) {
        try_throw_(33, (char *)"%s: lzw premature end", g.inf, (void *)0);
      }
    }
  }
  (g.in_left) --;
  tmp___0 = g.in_next;
  (g.in_next) ++;
  flags = (unsigned int )*tmp___0;
  if (flags & 96U) {
    try_throw_(33, (char *)"%s: unknown lzw flags set", g.inf, (void *)0);
  }
  max = flags & 31U;
  if (max < 9U) {
    try_throw_(33, (char *)"%s: lzw bits out of range", g.inf, (void *)0);
  } else
  if (max > 16U) {
    try_throw_(33, (char *)"%s: lzw bits out of range", g.inf, (void *)0);
  }
  if (max == 9U) {
    max = 10U;
  }
  flags &= 128U;
  mark = g.in_tot - g.in_left;
  bits = 9U;
  mask = 511U;
  if (flags) {
    end = 256U;
  } else {
    end = 255U;
  }
  if (g.in_left == 0UL) {
    if (g.in_eof) {
      return;
    } else {
      tmp___1 = load();
      if (tmp___1 == 0UL) {
        return;
      }
    }
  }
  (g.in_left) --;
  tmp___2 = g.in_next;
  (g.in_next) ++;
  buf = (bits_t )((unsigned int )*tmp___2);
  if (g.in_left == 0UL) {
    if (g.in_eof) {
      try_throw_(33, (char *)"%s: lzw premature end", g.inf, (void *)0);
    } else {
      tmp___3 = load();
      if (tmp___3 == 0UL) {
        try_throw_(33, (char *)"%s: lzw premature end", g.inf, (void *)0);
      }
    }
  }
  (g.in_left) --;
  tmp___4 = g.in_next;
  (g.in_next) ++;
  buf += (bits_t )((unsigned int )*tmp___4 << 8);
  prev = (unsigned int )(buf & (unsigned long )mask);
  final = prev;
  buf >>= bits;
  left = 16U - bits;
  if (prev > 255U) {
    try_throw_(33, (char *)"%s: invalid lzw code", g.inf, (void *)0);
  }
  out_buf[0] = (unsigned char )final;
  outcnt = 1U;
  stack = 0U;
  while (1) {
    if (end >= mask) {
      if (bits < max) {
        rem = (unsigned int )(((g.in_tot - g.in_left) - mark) % (unsigned long )bits);
        if (rem) {
          rem = bits - rem;
          if (g.in_left == 0UL) {
            if (g.in_eof) {
              break;
            } else {
              tmp___5 = load();
              if (tmp___5 == 0UL) {
                break;
              }
            }
          }
          while ((size_t )rem > g.in_left) {
            rem = (unsigned int )((size_t )rem - g.in_left);
            tmp___6 = load();
            if (tmp___6 == 0UL) {
              try_throw_(33, (char *)"%s: lzw premature end", g.inf, (void *)0);
            }
          }
          g.in_left -= (size_t )rem;
          g.in_next += rem;
        }
        buf = (bits_t )0;
        left = 0U;
        mark = g.in_tot - g.in_left;
        bits ++;
        mask <<= 1;
        mask ++;
      }
    }
    if (g.in_left == 0UL) {
      if (g.in_eof) {
        break;
      } else {
        tmp___7 = load();
        if (tmp___7 == 0UL) {
          break;
        }
      }
    }
    (g.in_left) --;
    tmp___8 = g.in_next;
    (g.in_next) ++;
    buf += (bits_t )((unsigned int )*tmp___8) << left;
    left += 8U;
    if (left < bits) {
      if (g.in_left == 0UL) {
        if (g.in_eof) {
          try_throw_(33, (char *)"%s: lzw premature end", g.inf, (void *)0);
        } else {
          tmp___9 = load();
          if (tmp___9 == 0UL) {
            try_throw_(33, (char *)"%s: lzw premature end", g.inf, (void *)0);
          }
        }
      }
      (g.in_left) --;
      tmp___10 = g.in_next;
      (g.in_next) ++;
      buf += (bits_t )((unsigned int )*tmp___10) << left;
      left += 8U;
    }
    code = (unsigned int )(buf & (unsigned long )mask);
    buf >>= bits;
    left -= bits;
    if (code == 256U) {
      if (flags) {
        rem___0 = (unsigned int )(((g.in_tot - g.in_left) - mark) % (unsigned long )bits);
        if (rem___0) {
          rem___0 = bits - rem___0;
          while ((size_t )rem___0 > g.in_left) {
            rem___0 = (unsigned int )((size_t )rem___0 - g.in_left);
            tmp___11 = load();
            if (tmp___11 == 0UL) {
              try_throw_(33, (char *)"%s: lzw premature end", g.inf, (void *)0);
            }
          }
          g.in_left -= (size_t )rem___0;
          g.in_next += rem___0;
        }
        buf = (bits_t )0;
        left = 0U;
        mark = g.in_tot - g.in_left;
        bits = 9U;
        mask = 511U;
        end = 255U;
        goto __Cont;
      }
    }
    temp = code;
    if (code > end) {
      if (code != end + 1U) {
        try_throw_(33, (char *)"%s: invalid lzw code", g.inf, (void *)0);
      } else
      if (prev > end) {
        try_throw_(33, (char *)"%s: invalid lzw code", g.inf, (void *)0);
      }
      tmp___12 = stack;
      stack ++;
      match[tmp___12] = (unsigned char )final;
      code = prev;
    }
    while (code >= 256U) {
      tmp___13 = stack;
      stack ++;
      match[tmp___13] = suffix[code];
      code = (unsigned int )prefix[code];
    }
    tmp___14 = stack;
    stack ++;
    match[tmp___14] = (unsigned char )code;
    final = code;
    if (end < mask) {
      end ++;
      prefix[end] = (index_t )prev;
      suffix[end] = (unsigned char )final;
    }
    prev = temp;
    while (stack > 32768U - outcnt) {
      while (outcnt < 32768U) {
        tmp___15 = outcnt;
        outcnt ++;
        stack --;
        out_buf[tmp___15] = match[stack];
      }
      g.out_tot += (length_t )outcnt;
      if (g.decode == 1) {
        writen(g.outd, (void const   *)(out_buf), (size_t )outcnt);
      }
      outcnt = 0U;
    }
    while (1) {
      tmp___16 = outcnt;
      outcnt ++;
      stack --;
      out_buf[tmp___16] = match[stack];
      if (! stack) {
        break;
      }
    }
    __Cont: /* CIL Label */ ;
  }
  g.out_tot += (length_t )outcnt;
  if (outcnt) {
    if (g.decode == 1) {
      writen(g.outd, (void const   *)(out_buf), (size_t )outcnt);
    }
  }
  return;
}
}
static char *justname(char *path ) 
{ 
  char *p ;
  char *tmp ;

  {
  p = strrchr((char const   *)path, '/');
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    tmp = path;
  } else {
    tmp = p + 1;
  }
  return (tmp);
}
}
static int copymeta(char *from , char *to ) 
{ 
  struct stat st ;
  struct timeval times[2] ;
  int tmp ;
  int ret ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = stat((char const   * __restrict  )from, (struct stat * __restrict  )(& st));
  if (tmp != 0) {
    return (-4);
  } else
  if ((st.st_mode & 61440U) != 32768U) {
    return (-4);
  }
  tmp___0 = chmod((char const   *)to, st.st_mode & 4095U);
  ret = tmp___0;
  tmp___1 = chown((char const   *)to, st.st_uid, st.st_gid);
  ret += tmp___1;
  times[0].tv_sec = st.st_atim.tv_sec;
  times[0].tv_usec = (__suseconds_t )0;
  times[1].tv_sec = st.st_mtim.tv_sec;
  times[1].tv_usec = (__suseconds_t )0;
  tmp___2 = utimes((char const   *)to, (struct timeval  const  *)(times));
  ret += tmp___2;
  return (ret);
}
}
static void touch(char *path , time_t t ) 
{ 
  struct timeval times[2] ;

  {
  times[0].tv_sec = t;
  times[0].tv_usec = (__suseconds_t )0;
  times[1].tv_sec = t;
  times[1].tv_usec = (__suseconds_t )0;
  utimes((char const   *)path, (struct timeval  const  *)(times));
  return;
}
}
static void out_push(void) 
{ 
  int ret ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;

  {
  if (g.outd == -1) {
    return;
  }
  tmp = fsync(g.outd);
  ret = tmp;
  if (ret == -1) {
    tmp___0 = __errno_location();
    tmp___1 = strerror(*tmp___0);
    tmp___2 = __errno_location();
    try_throw_(*tmp___2, (char *)"sync error on %s (%s)", g.outf, tmp___1, (void *)0);
  }
  return;
}
}
static void process(char *path ) ;
static char *sufs[12]  = 
  {      (char *)".z",      (char *)"-z",      (char *)"_z",      (char *)".Z", 
        (char *)".gz",      (char *)"-gz",      (char *)".zz",      (char *)"-zz", 
        (char *)".zip",      (char *)".ZIP",      (char *)".tgz",      (char *)((void *)0)};
static void process(char *path ) 
{ 
  int volatile   method ;
  size_t len ;
  struct stat st ;
  try_ball_t_ err ;
  time_t tmp___0 ;
  time_t tmp___1 ;
  int tmp___2 ;
  char **sufx ;
  char **tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  char *roll ;
  size_t size ;
  size_t off ;
  size_t base ;
  DIR *here ;
  struct dirent *next___0 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  size_t suf ;
  size_t tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  char const   *tmp___23 ;
  char const   *tmp___24 ;
  char const   *tmp___25 ;
  try_t_ try_this_ ;
  int volatile   try_pushed_ ;
  void *tmp___26 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___35 ;
  void *tmp___39 ;
  void *tmp___40 ;
  void *tmp___41 ;
  size_t tmp___42 ;
  void *tmp___43 ;
  int tmp___44 ;
  char *to ;
  char *sufx___0 ;
  size_t pre ;
  char *tmp___45 ;
  int tmp___46 ;
  size_t tmp___47 ;
  void *tmp___48 ;
  int tmp___49 ;
  int overwrite ;
  int ch___0 ;
  int first ;
  int tmp___50 ;
  int *tmp___51 ;
  int *tmp___52 ;
  char *tmp___53 ;
  int *tmp___54 ;
  try_t_ try_this____0 ;
  int volatile   try_pushed____0 ;
  void *tmp___55 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___64 ;
  void *tmp___68 ;
  void *tmp___69 ;
  void *tmp___70 ;
  int *tmp___71 ;
  char *tmp___72 ;
  int *tmp___73 ;
  int tmp___74 ;

  {
  method = (int volatile   )-1;
  if ((unsigned long )path == (unsigned long )((void *)0)) {
    vstrcpy(& g.inf, & g.inz, (size_t )0, (void *)"<stdin>");
    g.ind = 0;
    g.name = (char *)((void *)0);
    if (g.headis & 2) {
      tmp___2 = fstat(g.ind, & st);
      if (tmp___2) {
        tmp___0 = time((time_t *)((void *)0));
        tmp___1 = tmp___0;
      } else {
        tmp___1 = st.st_mtim.tv_sec;
      }
      g.mtime = tmp___1;
    } else {
      g.mtime = (time_t )0;
    }
    len = (size_t )0;
  } else {
    if ((unsigned long )path != (unsigned long )g.inf) {
      vstrcpy(& g.inf, & g.inz, (size_t )0, (void *)path);
    }
    len = strlen((char const   *)g.inf);
    tmp___11 = lstat((char const   * __restrict  )g.inf, (struct stat * __restrict  )(& st));
    if (tmp___11) {
      tmp___7 = __errno_location();
      if (*tmp___7 == 2) {
        if (g.list) {
          goto _L;
        } else
        if (g.decode) {
          _L: /* CIL Label */ 
          sufx = sufs;
          while (! ((unsigned long )*sufx == (unsigned long )((void *)0))) {
            tmp___3 = sufx;
            sufx ++;
            vstrcpy(& g.inf, & g.inz, len, (void *)*tmp___3);
            tmp___4 = __errno_location();
            *tmp___4 = 0;
            tmp___5 = lstat((char const   * __restrict  )g.inf, (struct stat * __restrict  )(& st));
            if (tmp___5) {
              tmp___6 = __errno_location();
              if (! (*tmp___6 == 2)) {
                break;
              }
            } else {
              break;
            }
          }
        }
      }
      tmp___8 = __errno_location();
      if (*tmp___8 == 75) {
        try_throw_(33, (char *)"%s too large -- not compiled with large file support",
                   g.inf, (void *)0);
      } else {
        tmp___9 = __errno_location();
        if (*tmp___9 == 27) {
          try_throw_(33, (char *)"%s too large -- not compiled with large file support",
                     g.inf, (void *)0);
        }
      }
      tmp___10 = __errno_location();
      if (*tmp___10) {
        *(g.inf + len) = (char)0;
        complain((char *)"skipping: %s does not exist", g.inf);
        return;
      }
      len = strlen((char const   *)g.inf);
    }
    if ((st.st_mode & 61440U) != 32768U) {
      if ((st.st_mode & 61440U) != 4096U) {
        if ((st.st_mode & 61440U) != 40960U) {
          if ((st.st_mode & 61440U) != 16384U) {
            complain((char *)"skipping: %s is a special file or device", g.inf);
            return;
          }
        }
      }
    }
    if ((st.st_mode & 61440U) == 40960U) {
      if (! g.force) {
        if (! g.pipeout) {
          complain((char *)"skipping: %s is a symbolic link", g.inf);
          return;
        }
      }
    }
    if ((st.st_mode & 61440U) == 16384U) {
      if (! g.recurse) {
        complain((char *)"skipping: %s is a directory", g.inf);
        return;
      }
    }
    if ((st.st_mode & 61440U) == 16384U) {
      roll = (char *)((void *)0);
      size = (size_t )0;
      off = (size_t )0;
      here = opendir((char const   *)g.inf);
      if ((unsigned long )here == (unsigned long )((void *)0)) {
        return;
      }
      while (1) {
        next___0 = readdir(here);
        if (! ((unsigned long )next___0 != (unsigned long )((void *)0))) {
          break;
        }
        if ((int )next___0->d_name[0] == 0) {
          continue;
        } else
        if ((int )next___0->d_name[0] == 46) {
          if ((int )next___0->d_name[1] == 0) {
            continue;
          } else
          if ((int )next___0->d_name[1] == 46) {
            if ((int )next___0->d_name[2] == 0) {
              continue;
            }
          }
        }
        off = vstrcpy(& roll, & size, off, (void *)(next___0->d_name));
      }
      closedir(here);
      vstrcpy(& roll, & size, off, (void *)"");
      if (len) {
        if ((int )*(g.inf + (len - 1UL)) != 47) {
          tmp___12 = vstrcpy(& g.inf, & g.inz, len, (void *)"/");
          base = tmp___12 - 1UL;
        } else {
          base = len;
        }
      } else {
        base = len;
      }
      off = (size_t )0;
      while (*(roll + off)) {
        vstrcpy(& g.inf, & g.inz, base, (void *)(roll + off));
        process(g.inf);
        tmp___13 = strlen((char const   *)(roll + off));
        off += tmp___13 + 1UL;
      }
      *(g.inf + len) = (char)0;
      free((void *)roll);
      return;
    }
    if (! g.force) {
      if (! g.list) {
        if (! g.decode) {
          tmp___14 = strlen((char const   *)g.sufx);
          if (len >= tmp___14) {
            tmp___15 = strlen((char const   *)g.sufx);
            tmp___16 = strcmp((char const   *)((g.inf + len) - tmp___15), (char const   *)g.sufx);
            if (tmp___16 == 0) {
              grumble((char *)"skipping: %s ends with %s", g.inf, g.sufx);
              return;
            }
          }
        }
      }
    }
    if (g.decode == 1) {
      if (! g.pipeout) {
        if (! g.list) {
          tmp___17 = compressed_suffix(g.inf);
          suf = tmp___17;
          if (suf == 0UL) {
            complain((char *)"skipping: %s does not have compressed suffix", g.inf);
            return;
          }
          len -= suf;
        }
      }
    }
    g.ind = open((char const   *)g.inf, 0, 0);
    if (g.ind < 0) {
      tmp___18 = __errno_location();
      tmp___19 = strerror(*tmp___18);
      tmp___20 = __errno_location();
      try_throw_(*tmp___20, (char *)"read error on %s (%s)", g.inf, tmp___19, (void *)0);
    }
    if (g.headis & 1) {
      tmp___21 = justname(g.inf);
      g.name = tmp___21;
    } else {
      g.name = (char *)((void *)0);
    }
    if (g.headis & 2) {
      g.mtime = st.st_mtim.tv_sec;
    } else {
      g.mtime = (time_t )0;
    }
  }
  if (g.list) {
    if (g.decode != 2) {
      list_info();
      load_end();
      return;
    }
  }
  if (g.decode) {
    in_init();
    tmp___22 = get_header(1);
    method = (int volatile   )tmp___22;
    if (method != (int volatile   )8) {
      if (method != (int volatile   )257) {
        if (method == (int volatile   )-1) {
          goto _L___4;
        } else
        if (method == (int volatile   )-2) {
          _L___4: /* CIL Label */ 
          if (g.force) {
            if (g.pipeout) {
              if (g.decode != 2) {
                if (! (! g.list)) {
                  goto _L___3;
                }
              } else {
                goto _L___3;
              }
            } else {
              goto _L___3;
            }
          } else {
            goto _L___3;
          }
        } else {
          _L___3: /* CIL Label */ 
          load_end();
          if (method == (int volatile   )-6) {
            tmp___25 = "skipping: %s corrupt: header crc error";
          } else {
            if (method == (int volatile   )-1) {
              tmp___24 = "skipping: %s empty";
            } else {
              if (method < (int volatile   )0) {
                tmp___23 = "skipping: %s unrecognized format";
              } else {
                tmp___23 = "skipping: %s unknown compression method";
              }
              tmp___24 = tmp___23;
            }
            tmp___25 = tmp___24;
          }
          complain((char *)tmp___25, g.inf);
          return;
        }
      }
    }
    if (g.decode == 2) {
      while (1) {
        try_pushed_ = (int volatile   )1;
        try_this_.ball.ret = 0;
        try_this_.ball.code = 0;
        try_this_.ball.free = 0;
        try_this_.ball.why = (char *)((void *)0);
        try_setup_();
        tmp___26 = pthread_getspecific(try_key_);
        try_this_.next = (try_t_ *)tmp___26;
        while (1) {
          tmp___30 = pthread_setspecific(try_key_, (void const   *)(& try_this_));
          if (tmp___30 == 0) {
            if (! "try: pthread_setspecific() failed") {
              __assert_fail("pthread_setspecific(try_key_, &try_this_) == 0 && \"try: pthread_setspecific() failed\"",
                            "pigz.c", 4068U, "process");
            }
          } else {
            __assert_fail("pthread_setspecific(try_key_, &try_this_) == 0 && \"try: pthread_setspecific() failed\"",
                          "pigz.c", 4068U, "process");
          }
          break;
        }
        tmp___31 = _setjmp((struct __jmp_buf_tag *)(try_this_.env));
        if (tmp___31 == 0) {
          while (1) {
            if (method == (int volatile   )8) {
              infchk();
            } else {
              unlzw();
              if (g.list) {
                g.in_tot -= 3UL;
                show_info((int )method, 0UL, g.out_tot, 0);
              }
            }
            break;
          }
        }
        if (try_pushed_) {
          while (1) {
            tmp___35 = pthread_setspecific(try_key_, (void const   *)try_this_.next);
            if (tmp___35 == 0) {
              if (! "try: pthread_setspecific() failed") {
                __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                              "pigz.c", 4079U, "process");
              }
            } else {
              __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                            "pigz.c", 4079U, "process");
            }
            break;
          }
          try_pushed_ = (int volatile   )0;
        }
        err = try_this_.ball;
        break;
      }
      if (err.code) {
        if (err.code != 33) {
          while (1) {
            try_setup_();
            tmp___39 = pthread_getspecific(try_key_);
            if ((unsigned long )((try_t_ *)tmp___39) != (unsigned long )((void *)0)) {
              if (! "try: naked punt") {
                __assert_fail("try_stack_ != NULL && \"try: naked punt\"", "pigz.c",
                              4081U, "process");
              }
            } else {
              __assert_fail("try_stack_ != NULL && \"try: naked punt\"", "pigz.c",
                            4081U, "process");
            }
            tmp___40 = pthread_getspecific(try_key_);
            ((try_t_ *)tmp___40)->ball = err;
            tmp___41 = pthread_getspecific(try_key_);
            longjmp((struct __jmp_buf_tag *)(((try_t_ *)tmp___41)->env), 1);
            break;
          }
        }
        complain((char *)"skipping: %s", err.why);
        while (1) {
          if (err.free) {
            free((void *)err.why);
            err.free = 0;
            err.why = (char *)((void *)0);
          }
          break;
        }
        outb((void *)0, (unsigned char *)((void *)0), 0U);
      }
      load_end();
      return;
    }
  }
  if ((unsigned long )path == (unsigned long )((void *)0)) {
    goto _L___6;
  } else
  if (g.pipeout) {
    _L___6: /* CIL Label */ 
    tmp___42 = strlen("<stdout>");
    tmp___43 = alloc((void *)0, tmp___42 + 1UL);
    g.outf = (char *)tmp___43;
    strcpy((char * __restrict  )g.outf, (char const   * __restrict  )"<stdout>");
    g.outd = 1;
    if (! g.decode) {
      if (! g.force) {
        tmp___44 = isatty(g.outd);
        if (tmp___44) {
          try_throw_(22, (char *)"trying to write compressed data to a terminal (use -f to force)",
                     (void *)0);
        }
      }
    }
  } else {
    to = g.inf;
    sufx___0 = (char *)"";
    pre = (size_t )0;
    if (g.decode) {
      if ((g.headis & 1) != 0) {
        if ((unsigned long )g.hname != (unsigned long )((void *)0)) {
          tmp___45 = justname(g.inf);
          pre = (size_t )(tmp___45 - g.inf);
          to = justname(g.hname);
          len = strlen((char const   *)to);
        } else {
          goto _L___5;
        }
      } else {
        _L___5: /* CIL Label */ 
        tmp___46 = strcmp((char const   *)(to + len), ".tgz");
        if (tmp___46 == 0) {
          sufx___0 = (char *)".tar";
        }
      }
    } else {
      sufx___0 = g.sufx;
    }
    tmp___47 = strlen((char const   *)sufx___0);
    tmp___48 = alloc((void *)0, ((pre + len) + tmp___47) + 1UL);
    g.outf = (char *)tmp___48;
    memcpy((void * __restrict  )g.outf, (void const   * __restrict  )g.inf, pre);
    memcpy((void * __restrict  )(g.outf + pre), (void const   * __restrict  )to, len);
    strcpy((char * __restrict  )((g.outf + pre) + len), (char const   * __restrict  )sufx___0);
    if (g.force) {
      tmp___49 = 0;
    } else {
      tmp___49 = 128;
    }
    g.outd = open((char const   *)g.outf, 577 | tmp___49, 384);
    if (g.outd < 0) {
      tmp___51 = __errno_location();
      if (*tmp___51 == 17) {
        overwrite = 0;
        tmp___50 = isatty(0);
        if (tmp___50) {
          if (g.verbosity) {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s exists -- overwrite (y/n)? ",
                    g.outf);
            fflush(stderr);
            first = 1;
            while (1) {
              ch___0 = getchar();
              if (first == 1) {
                if (ch___0 == 32) {
                  goto __Cont;
                } else
                if (ch___0 == 9) {
                  goto __Cont;
                }
                if (ch___0 == 121) {
                  overwrite = 1;
                } else
                if (ch___0 == 89) {
                  overwrite = 1;
                }
                first = 0;
              }
              __Cont: /* CIL Label */ 
              if (ch___0 != -1) {
                if (ch___0 != 10) {
                  if (! (ch___0 != 13)) {
                    break;
                  }
                } else {
                  break;
                }
              } else {
                break;
              }
            }
          }
        }
        if (! overwrite) {
          complain((char *)"skipping: %s exists", g.outf);
          while (1) {
            if ((unsigned long )g.outf != (unsigned long )((void *)0)) {
              free((void *)g.outf);
              g.outf = (char *)((void *)0);
            }
            break;
          }
          load_end();
          return;
        }
        g.outd = open((char const   *)g.outf, 577, 384);
      }
    }
    if (g.outd < 0) {
      tmp___52 = __errno_location();
      tmp___53 = strerror(*tmp___52);
      tmp___54 = __errno_location();
      try_throw_(*tmp___54, (char *)"write error on %s (%s)", g.outf, tmp___53, (void *)0);
    }
  }
  if (g.verbosity > 1) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s to %s ",
            g.inf, g.outf);
  }
  if (g.decode) {
    while (1) {
      try_pushed____0 = (int volatile   )1;
      try_this____0.ball.ret = 0;
      try_this____0.ball.code = 0;
      try_this____0.ball.free = 0;
      try_this____0.ball.why = (char *)((void *)0);
      try_setup_();
      tmp___55 = pthread_getspecific(try_key_);
      try_this____0.next = (try_t_ *)tmp___55;
      while (1) {
        tmp___59 = pthread_setspecific(try_key_, (void const   *)(& try_this____0));
        if (tmp___59 == 0) {
          if (! "try: pthread_setspecific() failed") {
            __assert_fail("pthread_setspecific(try_key_, &try_this_) == 0 && \"try: pthread_setspecific() failed\"",
                          "pigz.c", 4170U, "process");
          }
        } else {
          __assert_fail("pthread_setspecific(try_key_, &try_this_) == 0 && \"try: pthread_setspecific() failed\"",
                        "pigz.c", 4170U, "process");
        }
        break;
      }
      tmp___60 = _setjmp((struct __jmp_buf_tag *)(try_this____0.env));
      if (tmp___60 == 0) {
        while (1) {
          if (method == (int volatile   )8) {
            infchk();
          } else
          if (method == (int volatile   )257) {
            unlzw();
          } else {
            cat();
          }
          break;
        }
      }
      if (try_pushed____0) {
        while (1) {
          tmp___64 = pthread_setspecific(try_key_, (void const   *)try_this____0.next);
          if (tmp___64 == 0) {
            if (! "try: pthread_setspecific() failed") {
              __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                            "pigz.c", 4178U, "process");
            }
          } else {
            __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                          "pigz.c", 4178U, "process");
          }
          break;
        }
        try_pushed____0 = (int volatile   )0;
      }
      err = try_this____0.ball;
      break;
    }
    if (err.code) {
      if (err.code != 33) {
        while (1) {
          try_setup_();
          tmp___68 = pthread_getspecific(try_key_);
          if ((unsigned long )((try_t_ *)tmp___68) != (unsigned long )((void *)0)) {
            if (! "try: naked punt") {
              __assert_fail("try_stack_ != NULL && \"try: naked punt\"", "pigz.c",
                            4180U, "process");
            }
          } else {
            __assert_fail("try_stack_ != NULL && \"try: naked punt\"", "pigz.c", 4180U,
                          "process");
          }
          tmp___69 = pthread_getspecific(try_key_);
          ((try_t_ *)tmp___69)->ball = err;
          tmp___70 = pthread_getspecific(try_key_);
          longjmp((struct __jmp_buf_tag *)(((try_t_ *)tmp___70)->env), 1);
          break;
        }
      }
      complain((char *)"skipping: %s", err.why);
      while (1) {
        if (err.free) {
          free((void *)err.why);
          err.free = 0;
          err.why = (char *)((void *)0);
        }
        break;
      }
      outb((void *)0, (unsigned char *)((void *)0), 0U);
      if (g.outd != -1) {
        if (g.outd != 1) {
          close(g.outd);
          g.outd = -1;
          unlink((char const   *)g.outf);
          while (1) {
            if ((unsigned long )g.outf != (unsigned long )((void *)0)) {
              free((void *)g.outf);
              g.outf = (char *)((void *)0);
            }
            break;
          }
        }
      }
    }
  } else
  if (g.procs > 1) {
    parallel_compress();
  } else {
    single_compress(0);
  }
  if (g.verbosity > 1) {
    putc('\n', stderr);
    fflush(stderr);
  }
  load_end();
  if (g.outd != -1) {
    if (g.outd != 1) {
      if (g.sync) {
        out_push();
      }
      tmp___74 = close(g.outd);
      if (tmp___74) {
        tmp___71 = __errno_location();
        tmp___72 = strerror(*tmp___71);
        tmp___73 = __errno_location();
        try_throw_(*tmp___73, (char *)"write error on %s (%s)", g.outf, tmp___72,
                   (void *)0);
      }
      g.outd = -1;
      if (g.ind != 0) {
        copymeta(g.inf, g.outf);
        if (! g.keep) {
          if (st.st_nlink > 1UL) {
            if (! g.force) {
              complain((char *)"%s has hard links -- not unlinking", g.inf);
            } else {
              unlink((char const   *)g.inf);
            }
          } else {
            unlink((char const   *)g.inf);
          }
        }
      }
      if (g.decode) {
        if ((g.headis & 2) != 0) {
          if (g.stamp) {
            touch(g.outf, g.stamp);
          }
        }
      }
    }
  }
  while (1) {
    if ((unsigned long )g.outf != (unsigned long )((void *)0)) {
      free((void *)g.outf);
      g.outf = (char *)((void *)0);
    }
    break;
  }
  return;
}
}
static char *helptext[42]  = 
  {      (char *)"Usage: pigz [options] [files ...]",      (char *)"  will compress files in place, adding the suffix \'.gz\'. If no files are",      (char *)"  specified, stdin will be compressed to stdout. pigz does what gzip does,",      (char *)"  but spreads the work over multiple processors and cores when compressing.", 
        (char *)"",      (char *)"Options:",      (char *)"  -0 to -9, -11        Compression level (level 11, zopfli, is much slower)",      (char *)"  --fast, --best       Compression levels 1 and 9 respectively", 
        (char *)"  -A, --alias xxx      Use xxx as the name for any --zip entry from stdin",      (char *)"  -b, --blocksize mmm  Set compression block size to mmmK (default 128K)",      (char *)"  -c, --stdout         Write all processed output to stdout (won\'t delete)",      (char *)"  -C, --comment ccc    Put comment ccc in the gzip or zip header", 
        (char *)"  -d, --decompress     Decompress the compressed input",      (char *)"  -f, --force          Force overwrite, compress .gz, links, and to terminal",      (char *)"  -F  --first          Do iterations first, before block split for -11",      (char *)"  -h, --help           Display a help screen and quit", 
        (char *)"  -H, --huffman        Use only Huffman coding for compression",      (char *)"  -i, --independent    Compress blocks independently for damage recovery",      (char *)"  -I, --iterations n   Number of iterations for -11 optimization",      (char *)"  -J, --maxsplits n    Maximum number of split blocks for -11", 
        (char *)"  -k, --keep           Do not delete original file after processing",      (char *)"  -K, --zip            Compress to PKWare zip (.zip) single entry format",      (char *)"  -l, --list           List the contents of the compressed input",      (char *)"  -L, --license        Display the pigz license and quit", 
        (char *)"  -m, --no-time        Do not store or restore mod time",      (char *)"  -M, --time           Store or restore mod time",      (char *)"  -n, --no-name        Do not store or restore file name or mod time",      (char *)"  -N, --name           Store or restore file name and mod time", 
        (char *)"  -O  --oneblock       Do not split into smaller blocks for -11",      (char *)"  -p, --processes n    Allow up to n compression threads (default is the",      (char *)"                       number of online processors, or 8 if unknown)",      (char *)"  -q, --quiet          Print no messages, even on error", 
        (char *)"  -r, --recursive      Process the contents of all subdirectories",      (char *)"  -R, --rsyncable      Input-determined block locations for rsync",      (char *)"  -S, --suffix .sss    Use suffix .sss instead of .gz (for compression)",      (char *)"  -t, --test           Test the integrity of the compressed input", 
        (char *)"  -U, --rle            Use run-length encoding for compression",      (char *)"  -v, --verbose        Provide more verbose output",      (char *)"  -V  --version        Show the version of pigz",      (char *)"  -Y  --synchronous    Force output file write to permanent storage", 
        (char *)"  -z, --zlib           Compress to zlib (.zz) instead of gzip format",      (char *)"  --                   All arguments after \"--\" are treated as files"};
static void help(void) 
{ 
  int n ;

  {
  if (g.verbosity == 0) {
    return;
  }
  n = 0;
  while (n < (int )(sizeof(helptext) / sizeof(char *))) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n", helptext[n]);
    n ++;
  }
  fflush(stderr);
  exit(0);
}
}
static int nprocs(int n ) 
{ 
  long tmp ;

  {
  tmp = sysconf(84);
  n = (int )tmp;
  return (n);
}
}
static void defaults(void) 
{ 


  {
  g.level = -1;
  g.strategy = 0;
  ZopfliInitOptions(& g.zopts);
  g.block = 131072UL;
  g.procs = nprocs(8);
  g.shift = x2nmodp(g.block, 3U);
  g.rsync = 0;
  g.setdict = 1;
  g.verbosity = 1;
  g.headis = 3;
  g.pipeout = 0;
  g.sufx = (char *)".gz";
  g.comment = (char *)((void *)0);
  g.decode = 0;
  g.list = 0;
  g.keep = 0;
  g.force = 0;
  g.sync = 0;
  g.recurse = 0;
  g.form = 0;
  return;
}
}
static char *longopts[41][2]  = 
  { {        (char *)"LZW",        (char *)"Z"}, 
   {        (char *)"lzw",        (char *)"Z"}, 
   {        (char *)"alias",        (char *)"A"}, 
   {        (char *)"ascii",        (char *)"a"}, 
   {        (char *)"best",        (char *)"9"}, 
   {        (char *)"bits",        (char *)"Z"}, 
   {        (char *)"blocksize",        (char *)"b"}, 
   {        (char *)"decompress",        (char *)"d"}, 
   {        (char *)"fast",        (char *)"1"}, 
   {        (char *)"force",        (char *)"f"}, 
   {        (char *)"comment",        (char *)"C"}, 
   {        (char *)"first",        (char *)"F"}, 
   {        (char *)"iterations",        (char *)"I"}, 
   {        (char *)"maxsplits",        (char *)"J"}, 
   {        (char *)"oneblock",        (char *)"O"}, 
   {        (char *)"help",        (char *)"h"}, 
   {        (char *)"independent",        (char *)"i"}, 
   {        (char *)"keep",        (char *)"k"}, 
   {        (char *)"license",        (char *)"L"}, 
   {        (char *)"list",        (char *)"l"}, 
   {        (char *)"name",        (char *)"N"}, 
   {        (char *)"no-name",        (char *)"n"}, 
   {        (char *)"no-time",        (char *)"m"}, 
   {        (char *)"processes",        (char *)"p"}, 
   {        (char *)"quiet",        (char *)"q"}, 
   {        (char *)"recursive",        (char *)"r"}, 
   {        (char *)"rsyncable",        (char *)"R"}, 
   {        (char *)"silent",        (char *)"q"}, 
   {        (char *)"stdout",        (char *)"c"}, 
   {        (char *)"suffix",        (char *)"S"}, 
   {        (char *)"synchronous",        (char *)"Y"}, 
   {        (char *)"test",        (char *)"t"}, 
   {        (char *)"time",        (char *)"M"}, 
   {        (char *)"to-stdout",        (char *)"c"}, 
   {        (char *)"uncompress",        (char *)"d"}, 
   {        (char *)"verbose",        (char *)"v"}, 
   {        (char *)"version",        (char *)"V"}, 
   {        (char *)"zip",        (char *)"K"}, 
   {        (char *)"zlib",        (char *)"z"}, 
   {        (char *)"huffman",        (char *)"H"}, 
   {        (char *)"rle",        (char *)"U"}};
static void new_opts(void) 
{ 


  {
  single_compress(1);
  finish_jobs();
  return;
}
}
static size_t num(char *arg ) 
{ 
  char *str ;
  size_t val ;

  {
  str = arg;
  val = (size_t )0;
  if ((int )*str == 0) {
    try_throw_(22, (char *)"internal error: empty parameter", (void *)0);
  }
  while (1) {
    if ((int )*str < 48) {
      try_throw_(22, (char *)"invalid numeric parameter: %s", arg, (void *)0);
    } else
    if ((int )*str > 57) {
      try_throw_(22, (char *)"invalid numeric parameter: %s", arg, (void *)0);
    } else
    if (val) {
      if ((18446744073709551615 - (size_t )((int )*str - 48)) / val < 10UL) {
        try_throw_(22, (char *)"invalid numeric parameter: %s", arg, (void *)0);
      }
    }
    val = val * 10UL + (size_t )((int )*str - 48);
    str ++;
    if (! *str) {
      break;
    }
  }
  return (val);
}
}
static int option(char *arg ) ;
static int get  =    0;
static int option(char *arg ) 
{ 
  char bad[3] ;
  int j ;
  int tmp ;
  char const   *tmp___0 ;
  size_t n ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  bad[0] = (char )'-';
  bad[1] = (char )'X';
  bad[2] = (char )'\000';
  if (get) {
    if ((unsigned long )arg == (unsigned long )((void *)0)) {
      bad[1] = (char )*("bpSIJAC" + (get - 1));
      try_throw_(22, (char *)"missing parameter after %s", bad, (void *)0);
    } else
    if ((int )*arg == 45) {
      bad[1] = (char )*("bpSIJAC" + (get - 1));
      try_throw_(22, (char *)"missing parameter after %s", bad, (void *)0);
    }
  }
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
    return (1);
  }
  if ((int )*arg == 45) {
    arg ++;
    if ((int )*arg == 0) {
      return (0);
    }
    if ((int )*arg == 45) {
      arg ++;
      j = (int )(sizeof(longopts) / (sizeof(char *) << 1) - 1UL);
      while (j >= 0) {
        tmp = strcmp((char const   *)arg, (char const   *)longopts[j][0]);
        if (tmp == 0) {
          arg = longopts[j][1];
          break;
        }
        j --;
      }
      if (j < 0) {
        try_throw_(22, (char *)"invalid option: %s", arg - 2, (void *)0);
      }
    }
    while (1) {
      if (get) {
        if (get == 3) {
          try_throw_(22, (char *)"invalid usage: -S must be followed by space", (void *)0);
        }
        if (get == 7) {
          try_throw_(22, (char *)"invalid usage: -C must be followed by space", (void *)0);
        }
        break;
      }
      bad[1] = *arg;
      switch ((int )*arg) {
      case 57: 
      case 56: 
      case 55: 
      case 54: 
      case 53: 
      case 52: 
      case 51: 
      case 50: 
      case 49: 
      case 48: 
      g.level = (int )*arg - 48;
      while (1) {
        if ((int )*(arg + 1) >= 48) {
          if (! ((int )*(arg + 1) <= 57)) {
            break;
          }
        } else {
          break;
        }
        if (g.level) {
          if ((2147483647 - ((int )*(arg + 1) - 48)) / g.level < 10) {
            try_throw_(22, (char *)"only levels 0..9 and 11 are allowed", (void *)0);
          }
        }
        arg ++;
        g.level = (g.level * 10 + (int )*arg) - 48;
      }
      if (g.level == 10) {
        try_throw_(22, (char *)"only levels 0..9 and 11 are allowed", (void *)0);
      } else
      if (g.level > 11) {
        try_throw_(22, (char *)"only levels 0..9 and 11 are allowed", (void *)0);
      }
      break;
      case 65: 
      get = 6;
      break;
      case 67: 
      get = 7;
      break;
      case 70: 
      g.zopts.blocksplittinglast = 1;
      break;
      case 72: 
      g.strategy = 2;
      break;
      case 73: 
      get = 4;
      break;
      case 74: 
      get = 5;
      break;
      case 75: 
      g.form = 2;
      g.sufx = (char *)".zip";
      break;
      case 76: 
      puts("pigz 2.7");
      puts("Copyright (C) 2007-2022 Mark Adler");
      puts("Subject to the terms of the zlib license.");
      puts("No warranty is provided or implied.");
      exit(0);
      break;
      case 77: 
      g.headis |= 10;
      break;
      case 78: 
      g.headis = 15;
      break;
      case 79: 
      g.zopts.blocksplitting = 0;
      break;
      case 82: 
      g.rsync = 1;
      break;
      case 83: 
      get = 3;
      break;
      case 86: 
      puts("pigz 2.7");
      if (g.verbosity > 1) {
        tmp___0 = zlibVersion();
        printf((char const   * __restrict  )"zlib %s\n", tmp___0);
      }
      exit(0);
      break;
      case 89: 
      g.sync = 1;
      break;
      case 90: 
      try_throw_(22, (char *)"invalid option: LZW output not supported: %s", bad,
                 (void *)0);
      break;
      case 97: 
      try_throw_(22, (char *)"invalid option: no ascii conversion: %s", bad, (void *)0);
      break;
      case 98: 
      get = 1;
      break;
      case 99: 
      g.pipeout = 1;
      break;
      case 100: 
      if (! g.decode) {
        g.headis >>= 2;
      }
      g.decode = 1;
      break;
      case 102: 
      g.force = 1;
      break;
      case 104: 
      help();
      break;
      case 105: 
      g.setdict = 0;
      break;
      case 107: 
      g.keep = 1;
      break;
      case 108: 
      g.list = 1;
      break;
      case 110: 
      g.headis = 0;
      break;
      case 109: 
      case 84: 
      g.headis &= -11;
      break;
      case 112: 
      get = 2;
      break;
      case 113: 
      g.verbosity = 0;
      break;
      case 114: 
      g.recurse = 1;
      break;
      case 116: 
      g.decode = 2;
      break;
      case 85: 
      g.strategy = 3;
      break;
      case 118: 
      (g.verbosity) ++;
      break;
      case 122: 
      g.form = 1;
      g.sufx = (char *)".zz";
      break;
      default: 
      try_throw_(22, (char *)"invalid option: %s", bad, (void *)0);
      }
      arg ++;
      if (! *arg) {
        break;
      }
    }
    if ((int )*arg == 0) {
      return (1);
    }
  }
  if (get) {
    if (get == 1) {
      n = num(arg);
      g.block = n << 10;
      g.shift = x2nmodp(g.block, 3U);
      if (g.block < 32768UL) {
        try_throw_(22, (char *)"block size too small (must be >= 32K)", (void *)0);
      }
      if (n != g.block >> 10) {
        try_throw_(22, (char *)"block size too large: %s", arg, (void *)0);
      } else
      if ((g.block + (g.block >> 4)) + 32768UL < g.block) {
        try_throw_(22, (char *)"block size too large: %s", arg, (void *)0);
      } else
      if ((ssize_t )((g.block + (g.block >> 4)) + 32768UL) < 0L) {
        try_throw_(22, (char *)"block size too large: %s", arg, (void *)0);
      } else
      if (g.block > 1UL << 29) {
        try_throw_(22, (char *)"block size too large: %s", arg, (void *)0);
      }
    } else
    if (get == 2) {
      n = num(arg);
      g.procs = (int )n;
      if (g.procs < 1) {
        try_throw_(22, (char *)"invalid number of processes: %s", arg, (void *)0);
      }
      if ((size_t )g.procs != n) {
        try_throw_(22, (char *)"too many processes: %s", arg, (void *)0);
      } else
      if ((g.procs << 1) + 3 < 1) {
        try_throw_(22, (char *)"too many processes: %s", arg, (void *)0);
      }
    } else
    if (get == 3) {
      if ((int )*arg == 0) {
        try_throw_(22, (char *)"suffix cannot be empty", (void *)0);
      }
      g.sufx = arg;
    } else
    if (get == 4) {
      tmp___1 = num(arg);
      g.zopts.numiterations = (int )tmp___1;
    } else
    if (get == 5) {
      tmp___2 = num(arg);
      g.zopts.blocksplittingmax = (int )tmp___2;
    } else
    if (get == 6) {
      g.alias = arg;
    } else
    if (get == 7) {
      g.comment = arg;
    }
    get = 0;
    return (1);
  }
  return (0);
}
}
static void cut_yarn(int err ) 
{ 


  {
  try_throw_(err, (char *)"internal threads error", (void *)0);
}
}
int main(int argc , char **argv ) 
{ 
  int n ;
  int nop ;
  int done ;
  size_t k ;
  char *opts ;
  char *p ;
  try_ball_t_ err ;
  try_t_ try_this_ ;
  int volatile   try_pushed_ ;
  void *tmp ;
  int tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___23 ;
  int tmp___27 ;

  {
  g.ret = 0;
  while (1) {
    try_pushed_ = (int volatile   )1;
    try_this_.ball.ret = 0;
    try_this_.ball.code = 0;
    try_this_.ball.free = 0;
    try_this_.ball.why = (char *)((void *)0);
    try_setup_();
    tmp = pthread_getspecific(try_key_);
    try_this_.next = (try_t_ *)tmp;
    while (1) {
      tmp___3 = pthread_setspecific(try_key_, (void const   *)(& try_this_));
      if (tmp___3 == 0) {
        if (! "try: pthread_setspecific() failed") {
          __assert_fail("pthread_setspecific(try_key_, &try_this_) == 0 && \"try: pthread_setspecific() failed\"",
                        "pigz.c", 4605U, "main");
        }
      } else {
        __assert_fail("pthread_setspecific(try_key_, &try_this_) == 0 && \"try: pthread_setspecific() failed\"",
                      "pigz.c", 4605U, "main");
      }
      break;
    }
    tmp___19 = _setjmp((struct __jmp_buf_tag *)(try_this_.env));
    if (tmp___19 == 0) {
      while (1) {
        g.inf = (char *)((void *)0);
        g.inz = (size_t )0;
        g.in_which = -1;
        g.alias = (char *)"-";
        g.outf = (char *)((void *)0);
        g.first = 1;
        g.hname = (char *)((void *)0);
        g.hcomm = (char *)((void *)0);
        p = strrchr((char const   *)*(argv + 0), '/');
        if ((unsigned long )p == (unsigned long )((void *)0)) {
          p = *(argv + 0);
        } else {
          p ++;
        }
        if (*p) {
          g.prog = p;
        } else {
          g.prog = (char *)"pigz";
        }
        signal(2, & cut_short);
        yarn_prefix = g.prog;
        yarn_abort = & cut_yarn;
        defaults();
        tmp___4 = zlib_vernum();
        if (tmp___4 < 4656L) {
          try_throw_(22, (char *)"zlib version less than 1.2.3", (void *)0);
        }
        get_crc_table();
        opts = getenv("GZIP");
        if ((unsigned long )opts != (unsigned long )((void *)0)) {
          while (*opts) {
            while (1) {
              if (! ((int )*opts == 32)) {
                if (! ((int )*opts == 9)) {
                  break;
                }
              }
              opts ++;
            }
            p = opts;
            while (1) {
              if (*p) {
                if ((int )*p != 32) {
                  if (! ((int )*p != 9)) {
                    break;
                  }
                } else {
                  break;
                }
              } else {
                break;
              }
              p ++;
            }
            n = (int )*p;
            *p = (char)0;
            tmp___5 = option(opts);
            if (! tmp___5) {
              try_throw_(22, (char *)"cannot provide files in GZIP environment variable",
                         (void *)0);
            }
            if (n) {
              tmp___6 = 1;
            } else {
              tmp___6 = 0;
            }
            opts = p + tmp___6;
          }
          option((char *)((void *)0));
        }
        opts = getenv("PIGZ");
        if ((unsigned long )opts != (unsigned long )((void *)0)) {
          while (*opts) {
            while (1) {
              if (! ((int )*opts == 32)) {
                if (! ((int )*opts == 9)) {
                  break;
                }
              }
              opts ++;
            }
            p = opts;
            while (1) {
              if (*p) {
                if ((int )*p != 32) {
                  if (! ((int )*p != 9)) {
                    break;
                  }
                } else {
                  break;
                }
              } else {
                break;
              }
              p ++;
            }
            n = (int )*p;
            *p = (char)0;
            tmp___7 = option(opts);
            if (! tmp___7) {
              try_throw_(22, (char *)"cannot provide files in PIGZ environment variable",
                         (void *)0);
            }
            if (n) {
              tmp___8 = 1;
            } else {
              tmp___8 = 0;
            }
            opts = p + tmp___8;
          }
          option((char *)((void *)0));
        }
        tmp___9 = strcmp((char const   *)g.prog, "unpigz");
        if (tmp___9 == 0) {
          goto _L;
        } else {
          tmp___10 = strcmp((char const   *)g.prog, "gunzip");
          if (tmp___10 == 0) {
            _L: /* CIL Label */ 
            if (! g.decode) {
              g.headis >>= 2;
            }
            g.decode = 1;
          }
        }
        k = strlen((char const   *)g.prog);
        if (k > 2UL) {
          tmp___11 = strcmp((char const   *)((g.prog + k) - 3), "cat");
          if (tmp___11 == 0) {
            if (! g.decode) {
              g.headis >>= 2;
            }
            g.decode = 1;
            g.pipeout = 1;
          }
        }
        if (argc < 2) {
          if (g.decode) {
            tmp___12 = 0;
          } else {
            tmp___12 = 1;
          }
          tmp___13 = isatty(tmp___12);
          if (tmp___13) {
            help();
          }
        }
        nop = argc;
        n = 1;
        while (n < argc) {
          tmp___15 = strcmp((char const   *)*(argv + n), "--");
          if (tmp___15 == 0) {
            nop = n;
            *(argv + n) = (char *)((void *)0);
            break;
          } else {
            tmp___14 = option(*(argv + n));
            if (tmp___14) {
              *(argv + n) = (char *)((void *)0);
            }
          }
          n ++;
        }
        option((char *)((void *)0));
        done = 0;
        n = 1;
        while (n < argc) {
          if ((unsigned long )*(argv + n) != (unsigned long )((void *)0)) {
            if (done == 1) {
              if (g.pipeout) {
                if (! g.decode) {
                  if (! g.list) {
                    if (g.form > 1) {
                      complain((char *)"warning: output will be concatenated zip files -- %s will not be able to extract",
                               g.prog);
                    }
                  }
                }
              }
            }
            if (n < nop) {
              tmp___18 = strcmp((char const   *)*(argv + n), "-");
              if (tmp___18 == 0) {
                tmp___17 = (char *)((void *)0);
              } else {
                tmp___17 = *(argv + n);
              }
            } else {
              tmp___17 = *(argv + n);
            }
            process(tmp___17);
            done ++;
          }
          n ++;
        }
        if (done == 0) {
          process((char *)((void *)0));
        }
        break;
      }
    }
    if (try_pushed_) {
      while (1) {
        tmp___23 = pthread_setspecific(try_key_, (void const   *)try_this_.next);
        if (tmp___23 == 0) {
          if (! "try: pthread_setspecific() failed") {
            __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                          "pigz.c", 4727U, "main");
          }
        } else {
          __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                        "pigz.c", 4727U, "main");
        }
        break;
      }
      try_pushed_ = (int volatile   )0;
    }
    while (1) {
      while (1) {
        if ((unsigned long )g.inf != (unsigned long )((void *)0)) {
          free((void *)g.inf);
          g.inf = (char *)((void *)0);
        }
        break;
      }
      g.inz = (size_t )0;
      new_opts();
      break;
    }
    if (try_pushed_) {
      while (1) {
        tmp___27 = pthread_setspecific(try_key_, (void const   *)try_this_.next);
        if (tmp___27 == 0) {
          if (! "try: pthread_setspecific() failed") {
            __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                          "pigz.c", 4733U, "main");
          }
        } else {
          __assert_fail("pthread_setspecific(try_key_, try_this_.next) == 0 && \"try: pthread_setspecific() failed\"",
                        "pigz.c", 4733U, "main");
        }
        break;
      }
      try_pushed_ = (int volatile   )0;
    }
    err = try_this_.ball;
    break;
  }
  if (err.code) {
    while (1) {
      if (err.code != 32) {
        complain((char *)"abort: %s", err.why);
      }
      while (1) {
        if (err.free) {
          free((void *)err.why);
          err.free = 0;
          err.why = (char *)((void *)0);
        }
        break;
      }
      cut_short(- err.code);
      break;
    }
  }
  return (g.ret);
}
}
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
#pragma merger("0","/tmp/cil-AhYNB4Kh.i","")
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
extern int ( __attribute__((__nonnull__(1,2))) pthread_once)(pthread_once_t *__once_control ,
                                                             void (*__init_routine)(void) ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_key_create)(pthread_key_t *__key ,
                                                                                               void (*__destr_function)(void * ) ) ;
pthread_key_t try_key_  ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
static pthread_once_t try_once_  =    0;
static void try_create_(void) 
{ 
  int ret ;
  int tmp ;

  {
  tmp = pthread_key_create(& try_key_, (void (*)(void * ))((void *)0));
  ret = tmp;
  if (ret == 0) {
    if (! "try: pthread_key_create() failed") {
      __assert_fail("ret == 0 && \"try: pthread_key_create() failed\"", "try.c", 22U,
                    "try_create_");
    }
  } else {
    __assert_fail("ret == 0 && \"try: pthread_key_create() failed\"", "try.c", 22U,
                  "try_create_");
  }
  return;
}
}
void try_setup_(void) 
{ 
  int ret ;
  int tmp ;

  {
  tmp = pthread_once(& try_once_, & try_create_);
  ret = tmp;
  if (ret == 0) {
    if (! "try: pthread_once() failed") {
      __assert_fail("ret == 0 && \"try: pthread_once() failed\"", "try.c", 27U, "try_setup_");
    }
  } else {
    __assert_fail("ret == 0 && \"try: pthread_once() failed\"", "try.c", 27U, "try_setup_");
  }
  return;
}
}
 __attribute__((__noreturn__)) void try_throw_(int code , char *fmt  , ...) ;
void try_throw_(int code , char *fmt  , ...) 
{ 
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  char *why ;
  char nul[1] ;
  size_t len ;
  va_list___0 ap1 ;
  va_list___0 ap2 ;
  int tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  char *tmp___12 ;
  void *tmp___13 ;

  {
  try_setup_();
  tmp___2 = pthread_getspecific(try_key_);
  if ((unsigned long )((try_t_ *)tmp___2) != (unsigned long )((void *)0)) {
    if (! "try: naked throw") {
      __assert_fail("try_stack_ != NULL && \"try: naked throw\"", "try.c", 40U, "try_throw_");
    }
  } else {
    __assert_fail("try_stack_ != NULL && \"try: naked throw\"", "try.c", 40U, "try_throw_");
  }
  tmp___3 = pthread_getspecific(try_key_);
  ((try_t_ *)tmp___3)->ball.ret = 1;
  tmp___4 = pthread_getspecific(try_key_);
  ((try_t_ *)tmp___4)->ball.code = code;
  tmp___5 = pthread_getspecific(try_key_);
  ((try_t_ *)tmp___5)->ball.free = 0;
  tmp___6 = pthread_getspecific(try_key_);
  ((try_t_ *)tmp___6)->ball.why = fmt;
  if ((unsigned long )fmt != (unsigned long )((void *)0)) {
    tmp___12 = strchr((char const   *)fmt, '%');
    if ((unsigned long )tmp___12 != (unsigned long )((void *)0)) {
      __builtin_va_start(ap1, fmt);
      __builtin_va_copy(ap2, ap1);
      tmp___7 = vsnprintf((char * __restrict  )(nul), (size_t )1, (char const   * __restrict  )fmt,
                          ap1);
      len = (size_t )tmp___7;
      __builtin_va_end(ap1);
      tmp___8 = malloc(len + 1UL);
      why = (char *)tmp___8;
      if ((unsigned long )why == (unsigned long )((void *)0)) {
        tmp___9 = pthread_getspecific(try_key_);
        ((try_t_ *)tmp___9)->ball.why = (char *)"try: out of memory";
      } else {
        vsnprintf((char * __restrict  )why, len + 1UL, (char const   * __restrict  )fmt,
                  ap2);
        __builtin_va_end(ap2);
        tmp___10 = pthread_getspecific(try_key_);
        ((try_t_ *)tmp___10)->ball.free = 1;
        tmp___11 = pthread_getspecific(try_key_);
        ((try_t_ *)tmp___11)->ball.why = why;
      }
    }
  }
  tmp___13 = pthread_getspecific(try_key_);
  longjmp((struct __jmp_buf_tag *)(((try_t_ *)tmp___13)->env), 1);
}
}
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#pragma merger("0","/tmp/cil-bxSttHr1.i","")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
extern  __attribute__((__nothrow__)) pthread_t pthread_self(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int pthread_equal(pthread_t __thread1 , pthread_t __thread2 )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_attr_init)(pthread_attr_t *__attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_attr_destroy)(pthread_attr_t *__attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_attr_setdetachstate)(pthread_attr_t *__attr ,
                                                                                                        int __detachstate ) ;
extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf ) ;
extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf ) ;
extern  __attribute__((__noreturn__)) void __pthread_unwind_next(__pthread_unwind_buf_t *__buf )  __attribute__((__weak__)) ;
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                                              pthread_condattr_t const   * __restrict  __cond_attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_destroy)(pthread_cond_t *__cond ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_broadcast)(pthread_cond_t *__cond ) ;
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
void yarn_mem(void *(*lease)(size_t  ) , void (*vacate)(void * ) ) ;
char *yarn_prefix  =    (char *)"yarn";
void (*yarn_abort)(int  )  =    (void (*)(int  ))((void *)0);
static void fail(int err , char const   *file , long line , char const   *func ) 
{ 


  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: ", yarn_prefix);
  switch (err) {
  case 1: 
  fputs((char const   * __restrict  )"already unlocked", (FILE * __restrict  )stderr);
  break;
  case 3: 
  fputs((char const   * __restrict  )"no such thread", (FILE * __restrict  )stderr);
  break;
  case 35: 
  fputs((char const   * __restrict  )"resource deadlock", (FILE * __restrict  )stderr);
  break;
  case 12: 
  fputs((char const   * __restrict  )"out of memory", (FILE * __restrict  )stderr);
  break;
  case 16: 
  fputs((char const   * __restrict  )"can\'t destroy locked resource", (FILE * __restrict  )stderr);
  break;
  case 22: 
  fputs((char const   * __restrict  )"invalid request", (FILE * __restrict  )stderr);
  break;
  case 11: 
  fputs((char const   * __restrict  )"resource unavailable", (FILE * __restrict  )stderr);
  break;
  default: 
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"internal error %d",
          err);
  }
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" (%s:%ld:%s)\n",
          file, line, func);
  if ((unsigned long )yarn_abort != (unsigned long )((void *)0)) {
    (*yarn_abort)(err);
  }
  exit(err);
}
}
static void *(*my_malloc_f)(size_t  )  =    & malloc;
static void (*my_free)(void * )  =    & free;
void yarn_mem(void *(*lease)(size_t  ) , void (*vacate)(void * ) ) 
{ 


  {
  my_malloc_f = lease;
  my_free = vacate;
  return;
}
}
static void *my_malloc(size_t size , char const   *file , long line ) 
{ 
  void *block ;

  {
  block = (*my_malloc_f)(size);
  if ((unsigned long )block == (unsigned long )((void *)0)) {
    fail(12, file, line, "malloc");
  }
  return (block);
}
}
lock *new_lock_(long initial , char const   *file , long line ) 
{ 
  lock *bolt ;
  void *tmp ;
  int ret ;
  int tmp___0 ;

  {
  tmp = my_malloc(sizeof(struct lock_s ), file, line);
  bolt = (lock *)tmp;
  tmp___0 = pthread_mutex_init(& bolt->mutex, (pthread_mutexattr_t const   *)((void *)0));
  ret = tmp___0;
  if (ret) {
    fail(ret, file, line, "mutex_init");
  }
  ret = pthread_cond_init((pthread_cond_t * __restrict  )(& bolt->cond), (pthread_condattr_t const   * __restrict  )((void *)0));
  if (ret) {
    fail(ret, file, line, "cond_init");
  }
  bolt->value = initial;
  return (bolt);
}
}
void possess_(lock *bolt , char const   *file , long line ) 
{ 
  int ret ;
  int tmp ;

  {
  tmp = pthread_mutex_lock(& bolt->mutex);
  ret = tmp;
  if (ret) {
    fail(ret, file, line, "mutex_lock");
  }
  return;
}
}
void release_(lock *bolt , char const   *file , long line ) 
{ 
  int ret ;
  int tmp ;

  {
  tmp = pthread_mutex_unlock(& bolt->mutex);
  ret = tmp;
  if (ret) {
    fail(ret, file, line, "mutex_unlock");
  }
  return;
}
}
void twist_(lock *bolt , enum twist_op op , long val , char const   *file , long line ) 
{ 
  int ret ;
  int tmp ;

  {
  if ((unsigned int )op == 0U) {
    bolt->value = val;
  } else
  if ((unsigned int )op == 1U) {
    bolt->value += val;
  }
  tmp = pthread_cond_broadcast(& bolt->cond);
  ret = tmp;
  if (ret) {
    fail(ret, file, line, "cond_broadcast");
  }
  ret = pthread_mutex_unlock(& bolt->mutex);
  if (ret) {
    fail(ret, file, line, "mutex_unlock");
  }
  return;
}
}
void wait_for_(lock *bolt , enum wait_op op , long val , char const   *file , long line ) 
{ 
  int ret ;
  int tmp ;
  int ret___0 ;
  int tmp___0 ;
  int ret___1 ;
  int tmp___1 ;
  int ret___2 ;
  int tmp___2 ;

  {
  switch ((unsigned int )op) {
  case 0U: 
  while (! (bolt->value == val)) {
    tmp = pthread_cond_wait((pthread_cond_t * __restrict  )(& bolt->cond), (pthread_mutex_t * __restrict  )(& bolt->mutex));
    ret = tmp;
    if (ret) {
      fail(ret, file, line, "cond_wait");
    }
  }
  break;
  case 1U: 
  while (! (bolt->value != val)) {
    tmp___0 = pthread_cond_wait((pthread_cond_t * __restrict  )(& bolt->cond), (pthread_mutex_t * __restrict  )(& bolt->mutex));
    ret___0 = tmp___0;
    if (ret___0) {
      fail(ret___0, file, line, "cond_wait");
    }
  }
  break;
  case 2U: 
  while (! (bolt->value > val)) {
    tmp___1 = pthread_cond_wait((pthread_cond_t * __restrict  )(& bolt->cond), (pthread_mutex_t * __restrict  )(& bolt->mutex));
    ret___1 = tmp___1;
    if (ret___1) {
      fail(ret___1, file, line, "cond_wait");
    }
  }
  break;
  case 3U: 
  while (! (bolt->value < val)) {
    tmp___2 = pthread_cond_wait((pthread_cond_t * __restrict  )(& bolt->cond), (pthread_mutex_t * __restrict  )(& bolt->mutex));
    ret___2 = tmp___2;
    if (ret___2) {
      fail(ret___2, file, line, "cond_wait");
    }
  }
  }
  return;
}
}
long peek_lock(lock *bolt ) 
{ 


  {
  return (bolt->value);
}
}
void free_lock_(lock *bolt , char const   *file , long line ) 
{ 
  int ret ;
  int tmp ;

  {
  if ((unsigned long )bolt == (unsigned long )((void *)0)) {
    return;
  }
  tmp = pthread_cond_destroy(& bolt->cond);
  ret = tmp;
  if (ret) {
    fail(ret, file, line, "cond_destroy");
  }
  ret = pthread_mutex_destroy(& bolt->mutex);
  if (ret) {
    fail(ret, file, line, "mutex_destroy");
  }
  (*my_free)((void *)bolt);
  return;
}
}
static lock threads_lock  =    {{{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}},
    {{{0ULL}, {0ULL}, {0U, 0U}, {0U, 0U}, 0U, 0U, {0U, 0U}}}, 0L};
static thread *threads  =    (thread *)((void *)0);
static void reenter(void *arg ) 
{ 
  struct capsule *capsule ;
  pthread_t me ;
  pthread_t tmp ;
  thread **prior ;
  thread *match ;
  int tmp___0 ;

  {
  capsule = (struct capsule *)arg;
  tmp = pthread_self();
  me = tmp;
  possess_(& threads_lock, capsule->file, capsule->line);
  prior = & threads;
  while (1) {
    match = *prior;
    if (! ((unsigned long )match != (unsigned long )((void *)0))) {
      break;
    }
    tmp___0 = pthread_equal(match->id, me);
    if (tmp___0) {
      break;
    }
    prior = & match->next;
  }
  if ((unsigned long )match == (unsigned long )((void *)0)) {
    fail(3, capsule->file, capsule->line, "reenter lost");
  }
  match->done = 1;
  if ((unsigned long )threads != (unsigned long )match) {
    *prior = match->next;
    match->next = threads;
    threads = match;
  }
  twist_(& threads_lock, (enum twist_op )1, 1L, capsule->file, capsule->line);
  (*my_free)((void *)capsule);
  return;
}
}
static void *ignition(void *arg ) 
{ 
  struct capsule *capsule ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int __not_first_call ;
  int tmp ;
  long tmp___0 ;

  {
  capsule = (struct capsule *)arg;
  while (1) {
    __cancel_routine = & reenter;
    __cancel_arg = arg;
    tmp = __sigsetjmp((struct __jmp_buf_tag *)((void *)(__cancel_buf.__cancel_jmp_buf)),
                      0);
    __not_first_call = tmp;
    tmp___0 = __builtin_expect((long )__not_first_call, 0L);
    if (tmp___0) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      (*(capsule->probe))(capsule->payload);
      while (1) {
        break;
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return ((void *)0);
}
}
thread *launch_(void (*probe)(void * ) , void *payload , char const   *file , long line ) 
{ 
  struct capsule *capsule ;
  void *tmp ;
  thread *th ;
  void *tmp___0 ;
  pthread_attr_t attr ;
  int ret ;
  int tmp___1 ;

  {
  tmp = my_malloc(sizeof(struct capsule ), file, line);
  capsule = (struct capsule *)tmp;
  capsule->probe = probe;
  capsule->payload = payload;
  capsule->file = file;
  capsule->line = line;
  possess_(& threads_lock, file, line);
  tmp___0 = my_malloc(sizeof(struct thread_s ), file, line);
  th = (thread *)tmp___0;
  tmp___1 = pthread_attr_init(& attr);
  ret = tmp___1;
  if (ret) {
    fail(ret, file, line, "attr_init");
  }
  ret = pthread_attr_setdetachstate(& attr, 0);
  if (ret) {
    fail(ret, file, line, "attr_setdetachstate");
  }
  ret = pthread_create((pthread_t * __restrict  )(& th->id), (pthread_attr_t const   * __restrict  )(& attr),
                       & ignition, (void * __restrict  )capsule);
  if (ret) {
    fail(ret, file, line, "create");
  }
  ret = pthread_attr_destroy(& attr);
  if (ret) {
    fail(ret, file, line, "attr_destroy");
  }
  th->done = 0;
  th->next = threads;
  threads = th;
  release_(& threads_lock, file, line);
  return (th);
}
}
void join_(thread *ally , char const   *file , long line ) 
{ 
  int ret ;
  int tmp ;
  thread **prior ;
  thread *match ;

  {
  tmp = pthread_join(ally->id, (void **)((void *)0));
  ret = tmp;
  if (ret) {
    fail(ret, file, line, "join");
  }
  possess_(& threads_lock, file, line);
  prior = & threads;
  while (1) {
    match = *prior;
    if (! ((unsigned long )match != (unsigned long )((void *)0))) {
      break;
    }
    if ((unsigned long )match == (unsigned long )ally) {
      break;
    }
    prior = & match->next;
  }
  if ((unsigned long )match == (unsigned long )((void *)0)) {
    fail(3, file, line, "join lost");
  }
  if (match->done) {
    (threads_lock.value) --;
  }
  *prior = match->next;
  release_(& threads_lock, file, line);
  (*my_free)((void *)ally);
  return;
}
}
int join_all_(char const   *file , long line ) 
{ 
  int count ;
  thread **prior ;
  thread *match ;
  int ret ;
  int tmp ;

  {
  count = 0;
  possess_(& threads_lock, file, line);
  while ((unsigned long )threads != (unsigned long )((void *)0)) {
    wait_for_(& threads_lock, (enum wait_op )1, 0L, file, line);
    prior = & threads;
    while (1) {
      match = *prior;
      if (! ((unsigned long )match != (unsigned long )((void *)0))) {
        break;
      }
      if (match->done) {
        break;
      }
      prior = & match->next;
    }
    if ((unsigned long )match == (unsigned long )((void *)0)) {
      fail(3, file, line, "join_all lost");
    }
    tmp = pthread_join(match->id, (void **)((void *)0));
    ret = tmp;
    if (ret) {
      fail(ret, file, line, "join");
    }
    (threads_lock.value) --;
    *prior = match->next;
    (*my_free)((void *)match);
    count ++;
  }
  release_(& threads_lock, file, line);
  return (count);
}
}
