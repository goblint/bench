/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef long __int64_t;
typedef unsigned long size_t;
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
struct __anonstruct___wseq32_112954846 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_127042150 {
   unsigned long long __wseq ;
   struct __anonstruct___wseq32_112954846 __wseq32 ;
};
struct __anonstruct___g1_start32_571951528 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_571951527 {
   unsigned long long __g1_start ;
   struct __anonstruct___g1_start32_571951528 __g1_start32 ;
};
struct __pthread_cond_s {
   union __anonunion____missing_field_name_127042150 __annonCompField1 ;
   union __anonunion____missing_field_name_571951527 __annonCompField2 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
typedef unsigned long pthread_t;
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
union __anonunion_pthread_condattr_t_488594145 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_condattr_t_488594145 pthread_condattr_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
union __anonunion_pthread_cond_t_951761805 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
typedef union __anonunion_pthread_cond_t_951761805 pthread_cond_t;
typedef __int64_t int64_t;
struct kt_for_t ;
struct __anonstruct_ktf_worker_t_495033186 {
   struct kt_for_t *t ;
   long i ;
};
typedef struct __anonstruct_ktf_worker_t_495033186 ktf_worker_t;
struct kt_for_t {
   int n_threads ;
   long n ;
   ktf_worker_t *w ;
   void (*func)(void * , long  , int  ) ;
   void *data ;
};
typedef struct kt_for_t kt_for_t;
struct kt_forpool_t ;
struct __anonstruct_kto_worker_t_407073300 {
   struct kt_forpool_t *t ;
   long i ;
   int action ;
};
typedef struct __anonstruct_kto_worker_t_407073300 kto_worker_t;
struct kt_forpool_t {
   int n_threads ;
   int n_pending ;
   long n ;
   pthread_t *tid ;
   kto_worker_t *w ;
   void (*func)(void * , long  , int  ) ;
   void *data ;
   pthread_mutex_t mutex ;
   pthread_cond_t cv_m ;
   pthread_cond_t cv_s ;
};
typedef struct kt_forpool_t kt_forpool_t;
struct ktp_t ;
struct __anonstruct_ktp_worker_t_323515798 {
   struct ktp_t *pl ;
   int64_t index ;
   int step ;
   void *data ;
};
typedef struct __anonstruct_ktp_worker_t_323515798 ktp_worker_t;
struct ktp_t {
   void *shared ;
   void *(*func)(void * , int  , void * ) ;
   int64_t index ;
   int n_workers ;
   int n_steps ;
   ktp_worker_t *workers ;
   pthread_mutex_t mutex ;
   pthread_cond_t cv ;
};
typedef struct ktp_t ktp_t;
typedef long __off_t;
typedef long __off64_t;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
struct __anonstruct_pipeline_t_503116822 {
   FILE *fp ;
   int max_lines ;
   int buf_size ;
   int n_threads ;
   char *buf ;
};
typedef struct __anonstruct_pipeline_t_503116822 pipeline_t;
struct __anonstruct_step_t_216488822 {
   int n_lines ;
   char **lines ;
};
typedef struct __anonstruct_step_t_216488822 step_t;
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_add(...) ;  */
#pragma merger("0","/tmp/cil-1TYbd7QA.i","-pthread")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern  __attribute__((__noreturn__)) void pthread_exit(void *__retval ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                                              pthread_condattr_t const   * __restrict  __cond_attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_destroy)(pthread_cond_t *__cond ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_signal)(pthread_cond_t *__cond ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_broadcast)(pthread_cond_t *__cond ) ;
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
__inline static long steal_work(kt_for_t *t ) 
{ 
  int i ;
  int min_i ;
  long k ;
  long min ;
  long tmp ;

  {
  min_i = -1;
  min = 9223372036854775807L;
  i = 0;
  while (i < t->n_threads) {
    if (min > (t->w + i)->i) {
      min = (t->w + i)->i;
      min_i = i;
    }
    i ++;
  }
  k = (long )__sync_fetch_and_add(& (t->w + min_i)->i, t->n_threads);
  if (k >= t->n) {
    tmp = -1L;
  } else {
    tmp = k;
  }
  return (tmp);
}
}
static void *ktf_worker(void *data ) 
{ 
  ktf_worker_t *w ;
  long i ;

  {
  w = (ktf_worker_t *)data;
  while (1) {
    i = (long )__sync_fetch_and_add(& w->i, (w->t)->n_threads);
    if (i >= (w->t)->n) {
      break;
    }
    (*((w->t)->func))((w->t)->data, i, (int )(w - (w->t)->w));
  }
  while (1) {
    i = steal_work(w->t);
    if (! (i >= 0L)) {
      break;
    }
    (*((w->t)->func))((w->t)->data, i, (int )(w - (w->t)->w));
  }
  pthread_exit((void *)0);
}
}
void kt_for(int n_threads , void (*func)(void * , long  , int  ) , void *data , long n ) 
{ 
  int i ;
  kt_for_t t ;
  pthread_t *tid ;
  void *tmp ;
  void *tmp___0 ;
  long j ;

  {
  if (n_threads > 1) {
    t.func = func;
    t.data = data;
    t.n_threads = n_threads;
    t.n = n;
    tmp = __builtin_alloca((unsigned long )n_threads * sizeof(ktf_worker_t ));
    t.w = (ktf_worker_t *)tmp;
    tmp___0 = __builtin_alloca((unsigned long )n_threads * sizeof(pthread_t ));
    tid = (pthread_t *)tmp___0;
    i = 0;
    while (i < n_threads) {
      (t.w + i)->t = & t;
      (t.w + i)->i = (long )i;
      i ++;
    }
    i = 0;
    while (i < n_threads) {
      pthread_create((pthread_t * __restrict  )(tid + i), (pthread_attr_t const   * __restrict  )0,
                     & ktf_worker, (void * __restrict  )(t.w + i));
      i ++;
    }
    i = 0;
    while (i < n_threads) {
      pthread_join(*(tid + i), (void **)0);
      i ++;
    }
  } else {
    j = 0L;
    while (j < n) {
      (*func)(data, j, 0);
      j ++;
    }
  }
  return;
}
}
__inline static long kt_fp_steal_work(kt_forpool_t *t ) 
{ 
  int i ;
  int min_i ;
  long k ;
  long min ;
  long tmp ;

  {
  min_i = -1;
  min = 9223372036854775807L;
  i = 0;
  while (i < t->n_threads) {
    if (min > (t->w + i)->i) {
      min = (t->w + i)->i;
      min_i = i;
    }
    i ++;
  }
  k = (long )__sync_fetch_and_add(& (t->w + min_i)->i, t->n_threads);
  if (k >= t->n) {
    tmp = -1L;
  } else {
    tmp = k;
  }
  return (tmp);
}
}
static void *kt_fp_worker(void *data ) 
{ 
  kto_worker_t *w ;
  kt_forpool_t *fp ;
  long i ;
  int action ;

  {
  w = (kto_worker_t *)data;
  fp = w->t;
  while (1) {
    pthread_mutex_lock(& fp->mutex);
    (fp->n_pending) --;
    if (fp->n_pending == 0) {
      pthread_cond_signal(& fp->cv_m);
    }
    w->action = 0;
    while (w->action == 0) {
      pthread_cond_wait((pthread_cond_t * __restrict  )(& fp->cv_s), (pthread_mutex_t * __restrict  )(& fp->mutex));
    }
    action = w->action;
    pthread_mutex_unlock(& fp->mutex);
    if (action < 0) {
      break;
    }
    while (1) {
      i = (long )__sync_fetch_and_add(& w->i, fp->n_threads);
      if (i >= fp->n) {
        break;
      }
      (*(fp->func))(fp->data, i, (int )(w - fp->w));
    }
    while (1) {
      i = kt_fp_steal_work(fp);
      if (! (i >= 0L)) {
        break;
      }
      (*(fp->func))(fp->data, i, (int )(w - fp->w));
    }
  }
  pthread_exit((void *)0);
}
}
void *kt_forpool_init(int n_threads ) 
{ 
  kt_forpool_t *fp ;
  int i ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  tmp = calloc((size_t )1, sizeof(kt_forpool_t ));
  fp = (kt_forpool_t *)tmp;
  tmp___0 = n_threads;
  fp->n_pending = tmp___0;
  fp->n_threads = tmp___0;
  tmp___1 = calloc((size_t )fp->n_threads, sizeof(pthread_t ));
  fp->tid = (pthread_t *)tmp___1;
  tmp___2 = calloc((size_t )fp->n_threads, sizeof(kto_worker_t ));
  fp->w = (kto_worker_t *)tmp___2;
  i = 0;
  while (i < fp->n_threads) {
    (fp->w + i)->t = fp;
    i ++;
  }
  pthread_mutex_init(& fp->mutex, (pthread_mutexattr_t const   *)0);
  pthread_cond_init((pthread_cond_t * __restrict  )(& fp->cv_m), (pthread_condattr_t const   * __restrict  )0);
  pthread_cond_init((pthread_cond_t * __restrict  )(& fp->cv_s), (pthread_condattr_t const   * __restrict  )0);
  i = 0;
  while (i < fp->n_threads) {
    pthread_create((pthread_t * __restrict  )(fp->tid + i), (pthread_attr_t const   * __restrict  )0,
                   & kt_fp_worker, (void * __restrict  )(fp->w + i));
    i ++;
  }
  pthread_mutex_lock(& fp->mutex);
  while (fp->n_pending) {
    pthread_cond_wait((pthread_cond_t * __restrict  )(& fp->cv_m), (pthread_mutex_t * __restrict  )(& fp->mutex));
  }
  pthread_mutex_unlock(& fp->mutex);
  return ((void *)fp);
}
}
void kt_forpool_destroy(void *_fp ) 
{ 
  kt_forpool_t *fp ;
  int i ;

  {
  fp = (kt_forpool_t *)_fp;
  i = 0;
  while (i < fp->n_threads) {
    (fp->w + i)->action = -1;
    i ++;
  }
  pthread_cond_broadcast(& fp->cv_s);
  i = 0;
  while (i < fp->n_threads) {
    pthread_join(*(fp->tid + i), (void **)0);
    i ++;
  }
  pthread_cond_destroy(& fp->cv_s);
  pthread_cond_destroy(& fp->cv_m);
  pthread_mutex_destroy(& fp->mutex);
  free((void *)fp->w);
  free((void *)fp->tid);
  free((void *)fp);
  return;
}
}
void kt_forpool(void *_fp , void (*func)(void * , long  , int  ) , void *data , long n ) 
{ 
  kt_forpool_t *fp ;
  long i ;

  {
  fp = (kt_forpool_t *)_fp;
  if (fp) {
    if (fp->n_threads > 1) {
      fp->n = n;
      fp->func = func;
      fp->data = data;
      fp->n_pending = fp->n_threads;
      i = 0L;
      while (i < (long )fp->n_threads) {
        (fp->w + i)->i = i;
        (fp->w + i)->action = 1;
        i ++;
      }
      pthread_mutex_lock(& fp->mutex);
      pthread_cond_broadcast(& fp->cv_s);
      while (fp->n_pending) {
        pthread_cond_wait((pthread_cond_t * __restrict  )(& fp->cv_m), (pthread_mutex_t * __restrict  )(& fp->mutex));
      }
      pthread_mutex_unlock(& fp->mutex);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    i = 0L;
    while (i < n) {
      (*func)(data, i, 0);
      i ++;
    }
  }
  return;
}
}
static void *ktp_worker(void *data ) 
{ 
  ktp_worker_t *w ;
  ktp_t *p ;
  int i ;
  void *tmp ;
  int64_t tmp___0 ;

  {
  w = (ktp_worker_t *)data;
  p = w->pl;
  while (w->step < p->n_steps) {
    pthread_mutex_lock(& p->mutex);
    while (1) {
      i = 0;
      while (i < p->n_workers) {
        if ((unsigned long )w == (unsigned long )(p->workers + i)) {
          goto __Cont;
        }
        if ((p->workers + i)->step <= w->step) {
          if ((p->workers + i)->index < w->index) {
            break;
          }
        }
        __Cont: /* CIL Label */ 
        i ++;
      }
      if (i == p->n_workers) {
        break;
      }
      pthread_cond_wait((pthread_cond_t * __restrict  )(& p->cv), (pthread_mutex_t * __restrict  )(& p->mutex));
    }
    pthread_mutex_unlock(& p->mutex);
    if (w->step) {
      tmp = w->data;
    } else {
      tmp = (void *)0;
    }
    w->data = (*(p->func))(p->shared, w->step, tmp);
    pthread_mutex_lock(& p->mutex);
    if (w->step == p->n_steps - 1) {
      w->step = (w->step + 1) % p->n_steps;
    } else
    if (w->data) {
      w->step = (w->step + 1) % p->n_steps;
    } else {
      w->step = p->n_steps;
    }
    if (w->step == 0) {
      tmp___0 = p->index;
      (p->index) ++;
      w->index = tmp___0;
    }
    pthread_cond_broadcast(& p->cv);
    pthread_mutex_unlock(& p->mutex);
  }
  pthread_exit((void *)0);
}
}
void kt_pipeline(int n_threads , void *(*func)(void * , int  , void * ) , void *shared_data ,
                 int n_steps ) 
{ 
  ktp_t aux ;
  pthread_t *tid ;
  int i ;
  void *tmp ;
  ktp_worker_t *w ;
  int64_t tmp___0 ;
  void *tmp___1 ;

  {
  if (n_threads < 1) {
    n_threads = 1;
  }
  aux.n_workers = n_threads;
  aux.n_steps = n_steps;
  aux.func = func;
  aux.shared = shared_data;
  aux.index = (int64_t )0;
  pthread_mutex_init(& aux.mutex, (pthread_mutexattr_t const   *)0);
  pthread_cond_init((pthread_cond_t * __restrict  )(& aux.cv), (pthread_condattr_t const   * __restrict  )0);
  tmp = __builtin_alloca((unsigned long )n_threads * sizeof(ktp_worker_t ));
  aux.workers = (ktp_worker_t *)tmp;
  i = 0;
  while (i < n_threads) {
    w = aux.workers + i;
    w->step = 0;
    w->pl = & aux;
    w->data = (void *)0;
    tmp___0 = aux.index;
    (aux.index) ++;
    w->index = tmp___0;
    i ++;
  }
  tmp___1 = __builtin_alloca((unsigned long )n_threads * sizeof(pthread_t ));
  tid = (pthread_t *)tmp___1;
  i = 0;
  while (i < n_threads) {
    pthread_create((pthread_t * __restrict  )(tid + i), (pthread_attr_t const   * __restrict  )0,
                   & ktp_worker, (void * __restrict  )(aux.workers + i));
    i ++;
  }
  i = 0;
  while (i < n_threads) {
    pthread_join(*(tid + i), (void **)0);
    i ++;
  }
  pthread_mutex_destroy(& aux.mutex);
  pthread_cond_destroy(& aux.cv);
  return;
}
}
#pragma merger("0","/tmp/cil-wdG9Wuqd.i","-pthread")
extern FILE *stdin ;
extern FILE *stdout ;
extern FILE *stderr ;
extern int fclose(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
static void worker_for(void *_data , long i , int tid ) 
{ 
  step_t *step ;
  char *s ;
  int t ;
  int l ;
  int j ;
  size_t tmp ;

  {
  step = (step_t *)_data;
  s = *(step->lines + i);
  tmp = strlen((char const   *)s);
  l = (int )(tmp - 1UL);
  if (! ((int )*(s + l) == 10)) {
    __assert_fail("s[l] == \'\\n\'", "test/kthread_test2.c", 26U, "worker_for");
  }
  j = 0;
  while (j < l >> 1) {
    t = (int )*(s + j);
    *(s + j) = *(s + ((l - 1) - j));
    *(s + ((l - 1) - j)) = (char )t;
    j ++;
  }
  return;
}
}
static void *worker_pipeline(void *shared , int step , void *in ) 
{ 
  pipeline_t *p ;
  step_t *s ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  step_t *s___0 ;

  {
  p = (pipeline_t *)shared;
  if (step == 0) {
    tmp = calloc((size_t )1, sizeof(step_t ));
    s = (step_t *)tmp;
    tmp___0 = calloc((size_t )p->max_lines, sizeof(char *));
    s->lines = (char **)tmp___0;
    while (1) {
      tmp___1 = fgets((char * __restrict  )p->buf, p->buf_size, (FILE * __restrict  )p->fp);
      if (! ((unsigned long )tmp___1 != (unsigned long )((char *)0))) {
        break;
      }
      *(s->lines + s->n_lines) = strdup((char const   *)p->buf);
      (s->n_lines) ++;
      if (s->n_lines >= p->max_lines) {
        break;
      }
    }
    if (s->n_lines) {
      return ((void *)s);
    }
  } else
  if (step == 1) {
    kt_for(p->n_threads, & worker_for, in, (long )((step_t *)in)->n_lines);
    return (in);
  } else
  if (step == 2) {
    s___0 = (step_t *)in;
    while (s___0->n_lines > 0) {
      (s___0->n_lines) --;
      fputs((char const   * __restrict  )*(s___0->lines + s___0->n_lines), (FILE * __restrict  )stdout);
      free((void *)*(s___0->lines + s___0->n_lines));
    }
    free((void *)s___0->lines);
    free((void *)s___0);
  }
  return ((void *)0);
}
}
int main(int argc , char **argv ) 
{ 
  pipeline_t pl ;
  int pl_threads ;
  FILE *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;

  {
  if (argc == 1) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: reverse <in.txt> [pipeline_threads [for_threads]]\n");
    return (1);
  }
  tmp___1 = strcmp((char const   *)*(argv + 1), "-");
  if (tmp___1) {
    tmp___0 = fopen((char const   * __restrict  )*(argv + 1), (char const   * __restrict  )"r");
    pl.fp = tmp___0;
  } else {
    pl.fp = stdin;
  }
  if ((unsigned long )pl.fp == (unsigned long )((FILE *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: failed to open the input file.\n");
    return (1);
  }
  if (argc > 2) {
    tmp___2 = atoi((char const   *)*(argv + 2));
    pl_threads = tmp___2;
  } else {
    pl_threads = 3;
  }
  pl.max_lines = 4096;
  pl.buf_size = 65536;
  if (argc > 3) {
    tmp___3 = atoi((char const   *)*(argv + 3));
    pl.n_threads = tmp___3;
  } else {
    pl.n_threads = 1;
  }
  tmp___4 = calloc((size_t )pl.buf_size, (size_t )1);
  pl.buf = (char *)tmp___4;
  kt_pipeline(pl_threads, & worker_pipeline, (void *)(& pl), 3);
  free((void *)pl.buf);
  if ((unsigned long )pl.fp != (unsigned long )stdin) {
    fclose(pl.fp);
  }
  return (0);
}
}
