/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
struct __anonstruct_div_t_773697287 {
   int quot ;
   int rem ;
};
typedef struct __anonstruct_div_t_773697287 div_t;
typedef unsigned char __uint8_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef unsigned long __uint64_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned long __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef long __time_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __blkcnt64_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
typedef unsigned int __socklen_t;
typedef __int32_t int32_t;
typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
typedef unsigned long pthread_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
typedef __socklen_t socklen_t;
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
typedef __builtin_va_list __gnuc_va_list;
typedef u_int8_t u8_t;
typedef u_int16_t u16_t;
typedef u_int32_t u32_t;
typedef u_int64_t u64_t;
typedef int32_t s32_t;
typedef int BOOL;
enum __anonenum_IXML_NODE_TYPE_562787448 {
    eINVALID_NODE = 0,
    eELEMENT_NODE = 1,
    eATTRIBUTE_NODE = 2,
    eTEXT_NODE = 3,
    eCDATA_SECTION_NODE = 4,
    eENTITY_REFERENCE_NODE = 5,
    eENTITY_NODE = 6,
    ePROCESSING_INSTRUCTION_NODE = 7,
    eCOMMENT_NODE = 8,
    eDOCUMENT_NODE = 9,
    eDOCUMENT_TYPE_NODE = 10,
    eDOCUMENT_FRAGMENT_NODE = 11,
    eNOTATION_NODE = 12
} ;
typedef enum __anonenum_IXML_NODE_TYPE_562787448 IXML_NODE_TYPE;
struct _IXML_Document ;
typedef struct _IXML_Document *Docptr;
struct _IXML_Node ;
typedef struct _IXML_Node *Nodeptr;
struct _IXML_Node {
   char *nodeName ;
   char *nodeValue ;
   IXML_NODE_TYPE nodeType ;
   char *namespaceURI ;
   char *prefix ;
   char *localName ;
   BOOL readOnly ;
   Nodeptr parentNode ;
   Nodeptr firstChild ;
   Nodeptr prevSibling ;
   Nodeptr nextSibling ;
   Nodeptr firstAttr ;
   Docptr ownerDocument ;
};
typedef struct _IXML_Node IXML_Node;
struct _IXML_Document {
   IXML_Node n ;
};
typedef struct _IXML_Document IXML_Document;
typedef int UpnpClient_Handle;
enum Upnp_EventType_e {
    UPNP_CONTROL_ACTION_REQUEST = 0,
    UPNP_CONTROL_ACTION_COMPLETE = 1,
    UPNP_CONTROL_GET_VAR_REQUEST = 2,
    UPNP_CONTROL_GET_VAR_COMPLETE = 3,
    UPNP_DISCOVERY_ADVERTISEMENT_ALIVE = 4,
    UPNP_DISCOVERY_ADVERTISEMENT_BYEBYE = 5,
    UPNP_DISCOVERY_SEARCH_RESULT = 6,
    UPNP_DISCOVERY_SEARCH_TIMEOUT = 7,
    UPNP_EVENT_SUBSCRIPTION_REQUEST = 8,
    UPNP_EVENT_RECEIVED = 9,
    UPNP_EVENT_RENEWAL_COMPLETE = 10,
    UPNP_EVENT_SUBSCRIBE_COMPLETE = 11,
    UPNP_EVENT_UNSUBSCRIBE_COMPLETE = 12,
    UPNP_EVENT_AUTORENEWAL_FAILED = 13,
    UPNP_EVENT_SUBSCRIPTION_EXPIRED = 14
} ;
typedef enum Upnp_EventType_e Upnp_EventType;
typedef char Upnp_SID[44];
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
struct sQueue_e {
   struct sQueue_e *next ;
   void *item ;
};
struct __anonstruct_tQueue_157918770 {
   pthread_mutex_t *mutex ;
   void (*cleanup)(void * ) ;
   struct sQueue_e list ;
};
typedef struct __anonstruct_tQueue_157918770 tQueue;
struct metadata_s {
   char *artist ;
   char *album ;
   char *title ;
   char *genre ;
   char *path ;
   char *artwork ;
   char *remote_title ;
   u32_t track ;
   u32_t duration ;
   u32_t track_hash ;
   u32_t sample_rate ;
   u8_t sample_size ;
   u8_t channels ;
};
typedef struct metadata_s metadata_t;
enum __anonenum_raop_event_t_164395424 {
    RAOP_STREAM = 0,
    RAOP_PLAY = 1,
    RAOP_FLUSH = 2,
    RAOP_PAUSE = 3,
    RAOP_STOP = 4,
    RAOP_VOLUME = 5
} ;
typedef enum __anonenum_raop_event_t_164395424 raop_event_t;
struct raop_ctx_s ;
enum eMRstate {
    UNKNOWN = 0,
    STOPPED = 1,
    PLAYING = 2,
    PAUSED = 3,
    TRANSITIONING = 4
} ;
struct sService {
   char Id[250] ;
   char Type[250] ;
   char EventURL[250] ;
   char ControlURL[250] ;
   Upnp_SID SID ;
   s32_t TimeOut ;
   u32_t Failed ;
};
struct __anonstruct_ProtocolInfo_343724373 {
   char pcm[256] ;
   char wav[256] ;
   char flac[256] ;
   char mp3[256] ;
};
struct sMRConfig {
   int HTTPLength ;
   _Bool Enabled ;
   char Name[256] ;
   int UPnPMax ;
   _Bool SendMetaData ;
   _Bool SendCoverArt ;
   _Bool Flush ;
   int MaxVolume ;
   char Codec[256] ;
   _Bool Metadata ;
   char Latency[256] ;
   _Bool Drift ;
   u8_t mac[6] ;
   char ArtWork[1024] ;
   struct __anonstruct_ProtocolInfo_343724373 ProtocolInfo ;
};
typedef struct sMRConfig tMRConfig;
struct sAction ;
struct sMR {
   u32_t Magic ;
   _Bool Running ;
   tMRConfig Config ;
   char UDN[250] ;
   char DescDocURL[250] ;
   char friendlyName[256] ;
   enum eMRstate State ;
   _Bool ExpectStop ;
   struct raop_ctx_s *Raop ;
   metadata_t MetaData ;
   raop_event_t RaopState ;
   u32_t Elapsed ;
   u32_t LastSeen ;
   u8_t *seqN ;
   void *WaitCookie ;
   void *StartCookie ;
   tQueue ActionQueue ;
   unsigned int TrackPoll ;
   unsigned int StatePoll ;
   struct sService Service[5] ;
   struct sAction *Actions ;
   struct sMR *Master ;
   pthread_mutex_t Mutex ;
   pthread_t Thread ;
   double Volume ;
   u32_t VolumeStampRx ;
   u32_t VolumeStampTx ;
   u16_t ErrorCount ;
   _Bool TimeOut ;
   char *ProtocolInfo ;
};
enum __anonenum_log_level_750577654 {
    lERROR = 0,
    lWARN = 1,
    lINFO = 2,
    lDEBUG = 3,
    lSDEBUG = 4
} ;
typedef enum __anonenum_log_level_750577654 log_level;
union __anonunion_Param_339046624 {
   u8_t Volume ;
};
struct sAction {
   struct sMR *Device ;
   void *ActionNode ;
   union __anonunion_Param_339046624 Param ;
};
typedef struct sAction tAction;
typedef int __pid_t;
struct __anonstruct___wseq32_112954846 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_750625702 {
   unsigned long long __wseq ;
   struct __anonstruct___wseq32_112954846 __wseq32 ;
};
struct __anonstruct___g1_start32_170565821 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_170565820 {
   unsigned long long __g1_start ;
   struct __anonstruct___g1_start32_170565821 __g1_start32 ;
};
struct __pthread_cond_s {
   union __anonunion____missing_field_name_750625702 __annonCompField1 ;
   union __anonunion____missing_field_name_170565820 __annonCompField2 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
union __anonunion_pthread_condattr_t_488594145 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_condattr_t_488594145 pthread_condattr_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
union __anonunion_pthread_cond_t_951761805 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
typedef union __anonunion_pthread_cond_t_951761805 pthread_cond_t;
typedef void (*__sighandler_t)(int  );
typedef __uint32_t uint32_t;
typedef unsigned short sa_family_t;
struct sockaddr_storage {
   sa_family_t ss_family ;
   char __ss_padding[(128UL - sizeof(unsigned short )) - sizeof(unsigned long )] ;
   unsigned long __ss_align ;
};
typedef uint32_t in_addr_t;
struct in_addr {
   in_addr_t s_addr ;
};
struct mdnsd ;
struct key_data_s {
   char *key ;
   char *data ;
};
typedef struct key_data_s key_data_t;
struct Upnp_Action_Complete {
   int ErrCode ;
   char CtrlUrl[(size_t )256] ;
   IXML_Document *ActionRequest ;
   IXML_Document *ActionResult ;
};
struct Upnp_Event {
   Upnp_SID Sid ;
   int EventKey ;
   IXML_Document *ChangedVariables ;
};
struct Upnp_Discovery {
   int ErrCode ;
   int Expires ;
   char DeviceId[(size_t )180] ;
   char DeviceType[(size_t )180] ;
   char ServiceType[(size_t )180] ;
   char ServiceVer[(size_t )180] ;
   char Location[(size_t )180] ;
   char Os[(size_t )180] ;
   char Date[(size_t )180] ;
   char Ext[(size_t )180] ;
   struct sockaddr_storage DestAddr ;
};
struct Upnp_Event_Subscribe {
   Upnp_SID Sid ;
   int ErrCode ;
   char PublisherUrl[(size_t )256] ;
   int TimeOut ;
};
enum Upnp_LogLevel_e {
    UPNP_CRITICAL = 0,
    UPNP_PACKET = 1,
    UPNP_INFO = 2,
    UPNP_ALL = 3
} ;
typedef enum Upnp_LogLevel_e Upnp_LogLevel;
enum __anonenum_Type_248025457 {
    DISCOVERY = 0,
    BYE_BYE = 1,
    SEARCH_TIMEOUT = 2
} ;
struct sUpdate {
   enum __anonenum_Type_248025457 Type ;
   char *Data ;
};
typedef struct sUpdate tUpdate;
struct cSearchedSRV_s {
   char name[250] ;
   int idx ;
   u32_t TimeOut ;
};
struct _IXML_Element {
   IXML_Node n ;
   char *tagName ;
};
typedef struct _IXML_Element IXML_Element;
struct _IXML_NodeList {
   IXML_Node *nodeItem ;
   struct _IXML_NodeList *next ;
};
typedef struct _IXML_NodeList IXML_NodeList;
struct _IXML_NamedNodeMap {
   IXML_Node *nodeItem ;
   struct _IXML_NamedNodeMap *next ;
};
typedef struct _IXML_NamedNodeMap IXML_NamedNodeMap;
typedef short __int16_t;
typedef __int16_t int16_t;
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
struct alac_file ;
typedef struct alac_file alac_file;
struct alac_file {
   unsigned char *input_buffer ;
   int input_buffer_bitaccumulator ;
   int samplesize ;
   int numchannels ;
   int bytespersample ;
   int32_t *predicterror_buffer_a ;
   int32_t *predicterror_buffer_b ;
   int32_t *outputsamples_buffer_a ;
   int32_t *outputsamples_buffer_b ;
   int32_t *uncompressed_bytes_buffer_a ;
   int32_t *uncompressed_bytes_buffer_b ;
   uint32_t setinfo_max_samples_per_frame ;
   uint8_t setinfo_7a ;
   uint8_t setinfo_sample_size ;
   uint8_t setinfo_rice_historymult ;
   uint8_t setinfo_rice_initialhistory ;
   uint8_t setinfo_rice_kmodifier ;
   uint8_t setinfo_7f ;
   uint16_t setinfo_80 ;
   uint32_t setinfo_82 ;
   uint32_t setinfo_86 ;
   uint32_t setinfo_8a_rate ;
};
struct __anonstruct_se_struct_24_422959015 {
   int x : 24 ;
};
typedef long __int64_t;
typedef long __suseconds_t;
typedef __ssize_t ssize_t;
typedef __int64_t int64_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
typedef long __fd_mask;
struct __anonstruct_fd_set_356711149 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
typedef struct __anonstruct_fd_set_356711149 fd_set;
struct aes_key_st {
   unsigned int rd_key[60] ;
   int rounds ;
};
typedef struct aes_key_st AES_KEY;
typedef __uint64_t uint64_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct sockaddr_in ;
typedef uint16_t in_port_t;
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
typedef int16_t s16_t;
typedef int64_t s64_t;
struct hairtunes_s ;
struct __anonstruct_hairtunes_resp_t_422214079 {
   unsigned short cport ;
   unsigned short tport ;
   unsigned short aport ;
   unsigned short hport ;
   struct hairtunes_s *ctx ;
};
typedef struct __anonstruct_hairtunes_resp_t_422214079 hairtunes_resp_t;
enum __anonenum_codec_812345935 {
    CODEC_MP3 = 0,
    CODEC_FLAC = 1,
    CODEC_PCM = 2,
    CODEC_WAV = 3
} ;
struct __anonstruct_mp3_266379400 {
   int bitrate ;
   _Bool icy ;
};
struct __anonstruct_flac_1037408948 {
   int level ;
};
union __anonunion____missing_field_name_960959629 {
   struct __anonstruct_mp3_266379400 mp3 ;
   struct __anonstruct_flac_1037408948 flac ;
};
struct __anonstruct_encode_t_239194442 {
   enum __anonenum_codec_812345935 codec ;
   union __anonunion____missing_field_name_960959629 __annonCompField8 ;
};
typedef struct __anonstruct_encode_t_239194442 encode_t;
enum __anonenum_hairtunes_event_t_112117092 {
    HAIRTUNES_PLAY = 0
} ;
typedef enum __anonenum_hairtunes_event_t_112117092 hairtunes_event_t;
typedef uint8_t FLAC__uint8;
typedef int32_t FLAC__int32;
typedef uint32_t FLAC__uint32;
typedef uint64_t FLAC__uint64;
typedef int FLAC__bool;
typedef FLAC__uint8 FLAC__byte;
enum __anonenum_FLAC__MetadataType_822905234 {
    FLAC__METADATA_TYPE_STREAMINFO = 0,
    FLAC__METADATA_TYPE_PADDING = 1,
    FLAC__METADATA_TYPE_APPLICATION = 2,
    FLAC__METADATA_TYPE_SEEKTABLE = 3,
    FLAC__METADATA_TYPE_VORBIS_COMMENT = 4,
    FLAC__METADATA_TYPE_CUESHEET = 5,
    FLAC__METADATA_TYPE_PICTURE = 6,
    FLAC__METADATA_TYPE_UNDEFINED = 7,
    FLAC__MAX_METADATA_TYPE = 126
} ;
typedef enum __anonenum_FLAC__MetadataType_822905234 FLAC__MetadataType;
struct __anonstruct_FLAC__StreamMetadata_StreamInfo_396494791 {
   uint32_t min_blocksize ;
   uint32_t max_blocksize ;
   uint32_t min_framesize ;
   uint32_t max_framesize ;
   uint32_t sample_rate ;
   uint32_t channels ;
   uint32_t bits_per_sample ;
   FLAC__uint64 total_samples ;
   FLAC__byte md5sum[16] ;
};
typedef struct __anonstruct_FLAC__StreamMetadata_StreamInfo_396494791 FLAC__StreamMetadata_StreamInfo;
struct __anonstruct_FLAC__StreamMetadata_Padding_1037408949 {
   int dummy ;
};
typedef struct __anonstruct_FLAC__StreamMetadata_Padding_1037408949 FLAC__StreamMetadata_Padding;
struct __anonstruct_FLAC__StreamMetadata_Application_933084990 {
   FLAC__byte id[4] ;
   FLAC__byte *data ;
};
typedef struct __anonstruct_FLAC__StreamMetadata_Application_933084990 FLAC__StreamMetadata_Application;
struct __anonstruct_FLAC__StreamMetadata_SeekPoint_665542223 {
   FLAC__uint64 sample_number ;
   FLAC__uint64 stream_offset ;
   uint32_t frame_samples ;
};
typedef struct __anonstruct_FLAC__StreamMetadata_SeekPoint_665542223 FLAC__StreamMetadata_SeekPoint;
struct __anonstruct_FLAC__StreamMetadata_SeekTable_430183476 {
   uint32_t num_points ;
   FLAC__StreamMetadata_SeekPoint *points ;
};
typedef struct __anonstruct_FLAC__StreamMetadata_SeekTable_430183476 FLAC__StreamMetadata_SeekTable;
struct __anonstruct_FLAC__StreamMetadata_VorbisComment_Entry_431082649 {
   FLAC__uint32 length ;
   FLAC__byte *entry ;
};
typedef struct __anonstruct_FLAC__StreamMetadata_VorbisComment_Entry_431082649 FLAC__StreamMetadata_VorbisComment_Entry;
struct __anonstruct_FLAC__StreamMetadata_VorbisComment_149760624 {
   FLAC__StreamMetadata_VorbisComment_Entry vendor_string ;
   FLAC__uint32 num_comments ;
   FLAC__StreamMetadata_VorbisComment_Entry *comments ;
};
typedef struct __anonstruct_FLAC__StreamMetadata_VorbisComment_149760624 FLAC__StreamMetadata_VorbisComment;
struct __anonstruct_FLAC__StreamMetadata_CueSheet_Index_485252243 {
   FLAC__uint64 offset ;
   FLAC__byte number ;
};
typedef struct __anonstruct_FLAC__StreamMetadata_CueSheet_Index_485252243 FLAC__StreamMetadata_CueSheet_Index;
struct __anonstruct_FLAC__StreamMetadata_CueSheet_Track_46655545 {
   FLAC__uint64 offset ;
   FLAC__byte number ;
   char isrc[13] ;
   uint32_t type : 1 ;
   uint32_t pre_emphasis : 1 ;
   FLAC__byte num_indices ;
   FLAC__StreamMetadata_CueSheet_Index *indices ;
};
typedef struct __anonstruct_FLAC__StreamMetadata_CueSheet_Track_46655545 FLAC__StreamMetadata_CueSheet_Track;
struct __anonstruct_FLAC__StreamMetadata_CueSheet_959825136 {
   char media_catalog_number[129] ;
   FLAC__uint64 lead_in ;
   FLAC__bool is_cd ;
   uint32_t num_tracks ;
   FLAC__StreamMetadata_CueSheet_Track *tracks ;
};
typedef struct __anonstruct_FLAC__StreamMetadata_CueSheet_959825136 FLAC__StreamMetadata_CueSheet;
enum __anonenum_FLAC__StreamMetadata_Picture_Type_722181312 {
    FLAC__STREAM_METADATA_PICTURE_TYPE_OTHER = 0,
    FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD = 1,
    FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON = 2,
    FLAC__STREAM_METADATA_PICTURE_TYPE_FRONT_COVER = 3,
    FLAC__STREAM_METADATA_PICTURE_TYPE_BACK_COVER = 4,
    FLAC__STREAM_METADATA_PICTURE_TYPE_LEAFLET_PAGE = 5,
    FLAC__STREAM_METADATA_PICTURE_TYPE_MEDIA = 6,
    FLAC__STREAM_METADATA_PICTURE_TYPE_LEAD_ARTIST = 7,
    FLAC__STREAM_METADATA_PICTURE_TYPE_ARTIST = 8,
    FLAC__STREAM_METADATA_PICTURE_TYPE_CONDUCTOR = 9,
    FLAC__STREAM_METADATA_PICTURE_TYPE_BAND = 10,
    FLAC__STREAM_METADATA_PICTURE_TYPE_COMPOSER = 11,
    FLAC__STREAM_METADATA_PICTURE_TYPE_LYRICIST = 12,
    FLAC__STREAM_METADATA_PICTURE_TYPE_RECORDING_LOCATION = 13,
    FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_RECORDING = 14,
    FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_PERFORMANCE = 15,
    FLAC__STREAM_METADATA_PICTURE_TYPE_VIDEO_SCREEN_CAPTURE = 16,
    FLAC__STREAM_METADATA_PICTURE_TYPE_FISH = 17,
    FLAC__STREAM_METADATA_PICTURE_TYPE_ILLUSTRATION = 18,
    FLAC__STREAM_METADATA_PICTURE_TYPE_BAND_LOGOTYPE = 19,
    FLAC__STREAM_METADATA_PICTURE_TYPE_PUBLISHER_LOGOTYPE = 20,
    FLAC__STREAM_METADATA_PICTURE_TYPE_UNDEFINED = 21
} ;
typedef enum __anonenum_FLAC__StreamMetadata_Picture_Type_722181312 FLAC__StreamMetadata_Picture_Type;
struct __anonstruct_FLAC__StreamMetadata_Picture_949245910 {
   FLAC__StreamMetadata_Picture_Type type ;
   char *mime_type ;
   FLAC__byte *description ;
   FLAC__uint32 width ;
   FLAC__uint32 height ;
   FLAC__uint32 depth ;
   FLAC__uint32 colors ;
   FLAC__uint32 data_length ;
   FLAC__byte *data ;
};
typedef struct __anonstruct_FLAC__StreamMetadata_Picture_949245910 FLAC__StreamMetadata_Picture;
struct __anonstruct_FLAC__StreamMetadata_Unknown_409514583 {
   FLAC__byte *data ;
};
typedef struct __anonstruct_FLAC__StreamMetadata_Unknown_409514583 FLAC__StreamMetadata_Unknown;
union __anonunion_data_646410294 {
   FLAC__StreamMetadata_StreamInfo stream_info ;
   FLAC__StreamMetadata_Padding padding ;
   FLAC__StreamMetadata_Application application ;
   FLAC__StreamMetadata_SeekTable seek_table ;
   FLAC__StreamMetadata_VorbisComment vorbis_comment ;
   FLAC__StreamMetadata_CueSheet cue_sheet ;
   FLAC__StreamMetadata_Picture picture ;
   FLAC__StreamMetadata_Unknown unknown ;
};
struct __anonstruct_FLAC__StreamMetadata_912216532 {
   FLAC__MetadataType type ;
   FLAC__bool is_last ;
   uint32_t length ;
   union __anonunion_data_646410294 data ;
};
typedef struct __anonstruct_FLAC__StreamMetadata_912216532 FLAC__StreamMetadata;
enum __anonenum_FLAC__StreamEncoderInitStatus_423082740 {
    FLAC__STREAM_ENCODER_INIT_STATUS_OK = 0,
    FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR = 1,
    FLAC__STREAM_ENCODER_INIT_STATUS_UNSUPPORTED_CONTAINER = 2,
    FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_CALLBACKS = 3,
    FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_NUMBER_OF_CHANNELS = 4,
    FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BITS_PER_SAMPLE = 5,
    FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_SAMPLE_RATE = 6,
    FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BLOCK_SIZE = 7,
    FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_MAX_LPC_ORDER = 8,
    FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_QLP_COEFF_PRECISION = 9,
    FLAC__STREAM_ENCODER_INIT_STATUS_BLOCK_SIZE_TOO_SMALL_FOR_LPC_ORDER = 10,
    FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE = 11,
    FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA = 12,
    FLAC__STREAM_ENCODER_INIT_STATUS_ALREADY_INITIALIZED = 13
} ;
typedef enum __anonenum_FLAC__StreamEncoderInitStatus_423082740 FLAC__StreamEncoderInitStatus;
enum __anonenum_FLAC__StreamEncoderWriteStatus_240045189 {
    FLAC__STREAM_ENCODER_WRITE_STATUS_OK = 0,
    FLAC__STREAM_ENCODER_WRITE_STATUS_FATAL_ERROR = 1
} ;
typedef enum __anonenum_FLAC__StreamEncoderWriteStatus_240045189 FLAC__StreamEncoderWriteStatus;
enum __anonenum_FLAC__StreamEncoderSeekStatus_483072504 {
    FLAC__STREAM_ENCODER_SEEK_STATUS_OK = 0,
    FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR = 1,
    FLAC__STREAM_ENCODER_SEEK_STATUS_UNSUPPORTED = 2
} ;
typedef enum __anonenum_FLAC__StreamEncoderSeekStatus_483072504 FLAC__StreamEncoderSeekStatus;
enum __anonenum_FLAC__StreamEncoderTellStatus_853679927 {
    FLAC__STREAM_ENCODER_TELL_STATUS_OK = 0,
    FLAC__STREAM_ENCODER_TELL_STATUS_ERROR = 1,
    FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED = 2
} ;
typedef enum __anonenum_FLAC__StreamEncoderTellStatus_853679927 FLAC__StreamEncoderTellStatus;
struct FLAC__StreamEncoderProtected ;
struct FLAC__StreamEncoderPrivate ;
struct __anonstruct_FLAC__StreamEncoder_294495691 {
   struct FLAC__StreamEncoderProtected *protected_ ;
   struct FLAC__StreamEncoderPrivate *private_ ;
};
typedef struct __anonstruct_FLAC__StreamEncoder_294495691 FLAC__StreamEncoder;
enum channels {
    PCM_MONO = 1,
    PCM_STEREO = 2
} ;
struct __anonstruct_shine_wave_t_932429307 {
   enum channels channels ;
   int samplerate ;
};
typedef struct __anonstruct_shine_wave_t_932429307 shine_wave_t;
enum modes {
    STEREO = 0,
    JOINT_STEREO = 1,
    DUAL_CHANNEL = 2,
    MONO = 3
} ;
enum emph {
    NONE = 0,
    MU50_15 = 1,
    CITT = 3
} ;
struct __anonstruct_shine_mpeg_t_269278397 {
   enum modes mode ;
   int bitr ;
   enum emph emph ;
   int copyright ;
   int original ;
};
typedef struct __anonstruct_shine_mpeg_t_269278397 shine_mpeg_t;
struct __anonstruct_shine_config_t_328299085 {
   shine_wave_t wave ;
   shine_mpeg_t mpeg ;
};
typedef struct __anonstruct_shine_config_t_328299085 shine_config_t;
struct shine_global_flags ;
typedef struct shine_global_flags *shine_t;
struct wave_header_s {
   u8_t chunk_id[4] ;
   u8_t chunk_size[4] ;
   u8_t format[4] ;
   u8_t subchunk1_id[4] ;
   u8_t subchunk1_size[4] ;
   u8_t audio_format[2] ;
   u8_t channels[2] ;
   u8_t sample_rate[4] ;
   u8_t byte_rate[4] ;
   u8_t block_align[2] ;
   u8_t bits_per_sample[2] ;
   u8_t subchunk2_id[4] ;
   u8_t subchunk2_size[4] ;
};
typedef u16_t seq_t;
struct audio_buffer_entry {
   int ready ;
   u32_t rtptime ;
   u32_t last_resend ;
   s16_t *data ;
   int len ;
};
typedef struct audio_buffer_entry abuf_t;
struct __anonstruct_rtp_sockets_660642390 {
   unsigned short rport ;
   unsigned short lport ;
   int sock ;
};
struct timing_s {
   _Bool drift ;
   u64_t local ;
   u64_t remote ;
   u32_t count ;
   u32_t gap_count ;
   s64_t gap_sum ;
   s64_t gap_adjust ;
};
struct __anonstruct_synchro_126477707 {
   u32_t rtp ;
   u32_t time ;
   u8_t status ;
   _Bool first ;
   _Bool required ;
};
struct __anonstruct_record_382962036 {
   u32_t time ;
   seq_t seqno ;
   u32_t rtptime ;
};
struct __anonstruct_encode_755591885 {
   char buffer[9216] ;
   void *codec ;
   encode_t config ;
   int len ;
   _Bool header ;
};
struct __anonstruct_icy_978631765 {
   size_t interval ;
   size_t remain ;
   _Bool updated ;
};
struct hairtunes_s {
   _Bool running ;
   unsigned char aesiv[16] ;
   AES_KEY aes ;
   _Bool decrypt ;
   _Bool range ;
   int frame_size ;
   int in_frames ;
   int out_frames ;
   struct in_addr host ;
   struct sockaddr_in rtp_host ;
   struct __anonstruct_rtp_sockets_660642390 rtp_sockets[3] ;
   struct timing_s timing ;
   struct __anonstruct_synchro_126477707 synchro ;
   struct __anonstruct_record_382962036 record ;
   int latency ;
   int delay ;
   u32_t resent_frames ;
   u32_t silent_frames ;
   u32_t silence_count ;
   u32_t filled_frames ;
   _Bool http_fill ;
   _Bool pause ;
   int skip ;
   abuf_t audio_buffer[1024] ;
   int http_listener ;
   seq_t ab_read ;
   seq_t ab_write ;
   pthread_mutex_t ab_mutex ;
   pthread_t http_thread ;
   pthread_t rtp_thread ;
   struct __anonstruct_encode_755591885 encode ;
   struct __anonstruct_icy_978631765 icy ;
   struct metadata_s metadata ;
   char *silence_frame ;
   alac_file *alac_codec ;
   int flush_seqno ;
   _Bool playing ;
   _Bool silence ;
   _Bool http_ready ;
   void (*event_cb)(void *owner , hairtunes_event_t event ) ;
   void (*http_cb)(void *owner , struct key_data_s *headers , struct key_data_s *response ) ;
   void *owner ;
   char *http_tail ;
   size_t http_count ;
   int http_length ;
};
typedef struct hairtunes_s hairtunes_t;
struct __anonstruct_port_213969425 {
   unsigned short count ;
   unsigned short offset ;
};
typedef long __intmax_t;
typedef unsigned long __uintmax_t;
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
typedef int __gwchar_t;
struct bio_st ;
typedef struct bio_st BIO;
struct rsa_st ;
typedef struct rsa_st RSA;
typedef int pem_password_cb(char *buf , int size , int rwflag , void *userdata );
struct mdns_service ;
struct txt_attr_s {
   char *name ;
   char *value ;
};
typedef struct txt_attr_s txt_attr_t;
struct mDNSservice_s {
   struct mDNSservice_s *next ;
   struct in_addr host ;
   char *name ;
   char *hostname ;
   struct in_addr addr ;
   unsigned short port ;
   unsigned int since ;
   _Bool expired ;
   txt_attr_t *attr ;
   int attr_count ;
};
typedef struct mDNSservice_s mDNSservice_t;
struct mDNShandle_s ;
typedef _Bool mdns_callback_t(mDNSservice_t *services , void *cookie , _Bool *stop );
struct __anonstruct_dmap_settings_779894284 {
   void (*on_dict_start)(void *ctx , char const   *code , char const   *name ) ;
   void (*on_dict_end)(void *ctx , char const   *code , char const   *name ) ;
   void (*on_int32)(void *ctx , char const   *code , char const   *name , int32_t value ) ;
   void (*on_int64)(void *ctx , char const   *code , char const   *name , int64_t value ) ;
   void (*on_uint32)(void *ctx , char const   *code , char const   *name , uint32_t value ) ;
   void (*on_uint64)(void *ctx , char const   *code , char const   *name , uint64_t value ) ;
   void (*on_date)(void *ctx , char const   *code , char const   *name , uint32_t value ) ;
   void (*on_string)(void *ctx , char const   *code , char const   *name , char const   *buf ,
                     size_t len ) ;
   void (*on_data)(void *ctx , char const   *code , char const   *name , char const   *buf ,
                   size_t len ) ;
   void *ctx ;
};
typedef struct __anonstruct_dmap_settings_779894284 dmap_settings;
struct __anonstruct_rtsp_476363767 {
   char *aesiv ;
   char *aeskey ;
   char *fmtp ;
};
struct __anonstruct_active_remote_822481794 {
   char DACPid[32] ;
   char id[32] ;
   struct in_addr host ;
   u16_t port ;
   struct mDNShandle_s *handle ;
};
struct __anonstruct_ports_376111945 {
   u16_t base ;
   u16_t range ;
};
struct raop_ctx_s {
   struct mdns_service *svc ;
   struct mdnsd *svr ;
   struct in_addr host ;
   unsigned short port ;
   int sock ;
   unsigned short hport ;
   struct in_addr peer ;
   char *latencies ;
   _Bool running ;
   encode_t encode ;
   _Bool drift ;
   _Bool flush ;
   pthread_t thread ;
   pthread_t search_thread ;
   unsigned char mac[6] ;
   struct __anonstruct_rtsp_476363767 rtsp ;
   struct hairtunes_s *ht ;
   void (*raop_cb)(void *owner , raop_event_t event , void *param ) ;
   void (*http_cb)(void *owner , struct key_data_s *headers , struct key_data_s *response ) ;
   struct __anonstruct_active_remote_822481794 active_remote ;
   void *owner ;
   struct __anonstruct_ports_376111945 ports ;
   int http_length ;
};
typedef struct raop_ctx_s raop_ctx_t;
struct __anonstruct_port_213969425___0 {
   unsigned short count ;
   unsigned short offset ;
};
typedef int __clockid_t;
typedef char *__caddr_t;
typedef __caddr_t caddr_t;
typedef __clockid_t clockid_t;
typedef unsigned long nfds_t;
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
union __anonunion_ifr_ifrn_352126815 {
   char ifrn_name[16] ;
};
union __anonunion_ifr_ifru_537349870 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
struct ifreq {
   union __anonunion_ifr_ifrn_352126815 ifr_ifrn ;
   union __anonunion_ifr_ifru_537349870 ifr_ifru ;
};
union __anonunion_ifc_ifcu_753034691 {
   __caddr_t ifcu_buf ;
   struct ifreq *ifcu_req ;
};
struct ifconf {
   int ifc_len ;
   union __anonunion_ifc_ifcu_753034691 ifc_ifcu ;
};
struct arpreq {
   struct sockaddr arp_pa ;
   struct sockaddr arp_ha ;
   int arp_flags ;
   struct sockaddr arp_netmask ;
   char arp_dev[16] ;
};
typedef __gnuc_va_list va_list___0;
struct list_s {
   struct list_s *next ;
};
typedef struct list_s list_t;
typedef __time_t time_t;
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
enum __anonenum_DMAP_TYPE_89445397 {
    DMAP_UNKNOWN = 0,
    DMAP_UINT = 1,
    DMAP_INT = 2,
    DMAP_STR = 3,
    DMAP_DATA = 4,
    DMAP_DATE = 5,
    DMAP_VERS = 6,
    DMAP_DICT = 7,
    DMAP_ITEM = 8
} ;
typedef enum __anonenum_DMAP_TYPE_89445397 DMAP_TYPE;
struct __anonstruct_dmap_field_217118876 {
   char const   *code ;
   DMAP_TYPE type ;
   DMAP_TYPE list_item_type ;
   char const   *name ;
};
typedef struct __anonstruct_dmap_field_217118876 dmap_field;
struct ip_mreq {
   struct in_addr imr_multiaddr ;
   struct in_addr imr_interface ;
};
enum __anonenum_mDNScontrol_e_242194298 {
    MDNS_NONE = 0,
    MDNS_RESET = 1,
    MDNS_SUSPEND = 2
} ;
typedef enum __anonenum_mDNScontrol_e_242194298 mDNScontrol_e;
struct mDNSMessageStruct {
   uint16_t id ;
   uint16_t flags ;
   uint16_t qd_count ;
   uint16_t an_count ;
   uint16_t ns_count ;
   uint16_t ar_count ;
   char *data ;
   size_t data_size ;
};
typedef struct mDNSMessageStruct mDNSMessage;
struct __anonstruct_mDNSFlags_485089013 {
   int qr ;
   int opcode ;
   int aa ;
   int tc ;
   int rd ;
   int ra ;
   int zero ;
   int ad ;
   int cd ;
   int rcode ;
};
typedef struct __anonstruct_mDNSFlags_485089013 mDNSFlags;
struct __anonstruct_mDNSQuestion_1021182219 {
   char *qname ;
   uint16_t qtype ;
   uint16_t qclass ;
   int prefer_unicast_response ;
};
typedef struct __anonstruct_mDNSQuestion_1021182219 mDNSQuestion;
struct __anonstruct_mDNSResourceRecord_782783891 {
   char *name ;
   uint16_t type ;
   uint16_t class ;
   uint32_t ttl ;
   uint16_t rdata_length ;
   void *rdata ;
};
typedef struct __anonstruct_mDNSResourceRecord_782783891 mDNSResourceRecord;
enum __anonenum_status_277728880 {
    MDNS_CURRENT = 0,
    MDNS_UPDATED = 1,
    MDNS_EXPIRED = 2
} ;
struct slist_s {
   struct slist_s *next ;
   enum __anonenum_status_277728880 status ;
   uint32_t eol[3] ;
   uint32_t seen ;
   char *name ;
   char *hostname ;
   struct in_addr addr ;
   struct in_addr host ;
   uint16_t port ;
   int txt_length ;
   char *txt ;
};
typedef struct slist_s slist_t;
struct alist_s {
   struct alist_s *next ;
   uint32_t eol ;
   char *name ;
   struct in_addr addr ;
};
typedef struct alist_s alist_t;
enum __anonenum_state_567020907 {
    MDNS_IDLE = 0,
    MDNS_RUNNING = 1
} ;
struct context_s {
   char *query ;
   uint32_t ttl ;
   slist_t *slist ;
   alist_t *alist ;
};
struct mDNShandle_s {
   int sock ;
   enum __anonenum_state_567020907 state ;
   mDNScontrol_e control ;
   uint32_t last ;
   struct context_s context ;
};
typedef struct mDNShandle_s mDNShandle_t;
struct item_s {
   struct item_s *next ;
};
typedef struct item_s item_t;
union __anonunion___in6_u_979734923 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
struct in6_addr {
   union __anonunion___in6_u_979734923 __in6_u ;
};
struct rr_data_srv {
   uint16_t priority ;
   uint16_t weight ;
   uint16_t port ;
   uint8_t *target ;
};
struct rr_data_txt {
   struct rr_data_txt *next ;
   uint8_t *txt ;
};
struct rr_data_nsec {
   uint8_t bitmap[5] ;
};
struct rr_entry ;
struct rr_data_ptr {
   uint8_t *name ;
   struct rr_entry *entry ;
};
struct rr_data_a {
   uint32_t addr ;
};
struct rr_data_aaaa {
   struct in6_addr *addr ;
};
enum rr_type {
    RR_A = 1,
    RR_PTR = 12,
    RR_TXT = 16,
    RR_AAAA = 28,
    RR_SRV = 33,
    RR_NSEC = 47,
    RR_ANY = 255
} ;
union __anonunion_data_487002723 {
   struct rr_data_nsec NSEC ;
   struct rr_data_srv SRV ;
   struct rr_data_txt TXT ;
   struct rr_data_ptr PTR ;
   struct rr_data_a A ;
   struct rr_data_aaaa AAAA ;
};
struct rr_entry {
   uint8_t *name ;
   enum rr_type type ;
   uint32_t ttl ;
   char unicast_query ;
   char cache_flush ;
   uint16_t rr_class ;
   union __anonunion_data_487002723 data ;
};
struct rr_list {
   struct rr_entry *e ;
   struct rr_list *next ;
};
struct rr_group {
   uint8_t *name ;
   struct rr_list *rr ;
   struct rr_group *next ;
};
struct mdns_pkt {
   uint16_t id ;
   uint16_t flags ;
   uint16_t num_qn ;
   uint16_t num_ans_rr ;
   uint16_t num_auth_rr ;
   uint16_t num_add_rr ;
   struct rr_list *rr_qn ;
   struct rr_list *rr_ans ;
   struct rr_list *rr_auth ;
   struct rr_list *rr_add ;
};
struct name_comp {
   uint8_t *label ;
   size_t pos ;
   struct name_comp *next ;
};
struct mdnsd {
   pthread_mutex_t data_lock ;
   int sockfd ;
   int notify_pipe[2] ;
   int stop_flag ;
   struct rr_group *group ;
   struct rr_list *announce ;
   struct rr_list *services ;
   struct rr_list *leave ;
   uint8_t *hostname ;
};
struct mdns_service {
   struct rr_list *entries ;
};
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#pragma merger("0","/tmp/cil-r9pYXAbE.i","-Wall,-fPIC,-ggdb,-O2,-m64,-fdata-sections,-ffunction-sections")
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1))) strtoll)(char const   * __restrict  __nptr ,
                                                                                          char ** __restrict  __endptr ,
                                                                                          int __base ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) atoi)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return ((int )tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long ( __attribute__((__nonnull__(1), __gnu_inline__)) atol)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long long ( __attribute__((__nonnull__(1), __gnu_inline__)) atoll)(char const   *__nptr ) 
{ 
  long long tmp ;

  {
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
  __l = (size_t )0;
  __u = __nmemb;
  while (__l < __u) {
    __idx = (__l + __u) / 2UL;
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
    __comparison = (*__compar)(__key, __p);
    if (__comparison < 0) {
      __u = __idx;
    } else
    if (__comparison > 0) {
      __l = __idx + 1UL;
    } else {
      return ((void *)__p);
    }
  }
  return ((void *)0);
}
}
extern  __attribute__((__nothrow__)) div_t div(int __numer , int __denom )  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern double ( __attribute__((__nonnull__(1), __gnu_inline__)) atof)(char const   *__nptr ) 
{ 
  double tmp ;

  {
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf )  __asm__("stat64")  ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf )  __asm__("fstat64")  ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat64)(int __fd , struct stat64 *__statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag )  __asm__("fstatat64")  ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat64)(int __fd , char const   * __restrict  __filename , struct stat64 * __restrict  __statbuf ,
                            int __flag ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf )  __asm__("lstat64")  ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat)(int __ver ,
                                                                                     int __fildes ,
                                                                                     struct stat *__stat_buf )  __asm__("__fxstat64")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat)(int __ver ,
                                                                                      char const   *__filename ,
                                                                                      struct stat *__stat_buf )  __asm__("__xstat64")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat)(int __ver ,
                                                                                       char const   *__filename ,
                                                                                       struct stat *__stat_buf )  __asm__("__lxstat64")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4))) __fxstatat)(int __ver ,
                                                                                         int __fildes ,
                                                                                         char const   *__filename ,
                                                                                         struct stat *__stat_buf ,
                                                                                         int __flag )  __asm__("__fxstatat64")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat64)(int __ver ,
                                                                                       int __fildes ,
                                                                                       struct stat64 *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat64)(int __ver ,
                                                                                        char const   *__filename ,
                                                                                        struct stat64 *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat64)(int __ver ,
                                                                                         char const   *__filename ,
                                                                                         struct stat64 *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4))) __fxstatat64)(int __ver ,
                                                                                           int __fildes ,
                                                                                           char const   *__filename ,
                                                                                           struct stat64 *__stat_buf ,
                                                                                           int __flag ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4))) __xmknod)(int __ver ,
                                                                                       char const   *__path ,
                                                                                       __mode_t __mode ,
                                                                                       __dev_t *__dev ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,5))) __xmknodat)(int __ver ,
                                                                                         int __fd ,
                                                                                         char const   *__path ,
                                                                                         __mode_t __mode ,
                                                                                         __dev_t *__dev ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf )  __asm__("stat64")  ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) stat)(char const   * __restrict  __path ,
                                                                              struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __xstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf )  __asm__("lstat64")  ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) lstat)(char const   * __restrict  __path ,
                                                                               struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __lxstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf )  __asm__("fstat64")  ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) fstat)(int __fd ,
                                                                             struct stat *__statbuf ) 
{ 
  int tmp ;

  {
  tmp = __fxstat(1, __fd, __statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag )  __asm__("fstatat64")  ;
__inline extern int ( __attribute__((__nonnull__(2,3), __gnu_inline__)) fstatat)(int __fd ,
                                                                                 char const   * __restrict  __filename ,
                                                                                 struct stat * __restrict  __statbuf ,
                                                                                 int __flag ) 
{ 
  int tmp ;

  {
  tmp = __fxstatat(1, __fd, (char const   *)__filename, (struct stat *)__statbuf,
                   __flag);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) mknod)(char const   *__path ,
                                                                             __mode_t __mode ,
                                                                             __dev_t __dev ) 
{ 
  int tmp ;

  {
  tmp = __xmknod(0, __path, __mode, & __dev);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) mknodat)(int __fd ,
                                                                               char const   *__path ,
                                                                               __mode_t __mode ,
                                                                               __dev_t __dev ) 
{ 
  int tmp ;

  {
  tmp = __xmknodat(0, __fd, __path, __mode, & __dev);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) stat64)(char const   * __restrict  __path ,
                                                                                struct stat64 * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __xstat64(1, (char const   *)__path, (struct stat64 *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) lstat64)(char const   * __restrict  __path ,
                                                                                 struct stat64 * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __lxstat64(1, (char const   *)__path, (struct stat64 *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat64)(int __fd , struct stat64 *__statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) fstat64)(int __fd ,
                                                                               struct stat64 *__statbuf ) 
{ 
  int tmp ;

  {
  tmp = __fxstat64(1, __fd, __statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat64)(int __fd , char const   * __restrict  __filename , struct stat64 * __restrict  __statbuf ,
                            int __flag ) ;
__inline extern int ( __attribute__((__nonnull__(2,3), __gnu_inline__)) fstatat64)(int __fd ,
                                                                                   char const   * __restrict  __filename ,
                                                                                   struct stat64 * __restrict  __statbuf ,
                                                                                   int __flag ) 
{ 
  int tmp ;

  {
  tmp = __fxstatat64(1, __fd, (char const   *)__filename, (struct stat64 *)__statbuf,
                     __flag);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                               struct cmsghdr *__cmsg ) ;
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                               struct cmsghdr *__cmsg ) ;
__inline extern struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                 struct cmsghdr *__cmsg ) 
{ 


  {
  if (__cmsg->cmsg_len < sizeof(struct cmsghdr )) {
    return ((struct cmsghdr *)0);
  }
  __cmsg = (struct cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)));
  if ((unsigned long )((unsigned char *)(__cmsg + 1)) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  } else
  if ((unsigned long )((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  }
  return (__cmsg);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                     pthread_t __thread2 ) 
{ 


  {
  return (__thread1 == __thread2);
}
}
extern IXML_Document *ixmlDocument_createDocument(void) ;
extern void ixmlDocument_free(IXML_Document *doc ) ;
extern char *ixmlNodetoString(IXML_Node *doc ) ;
extern IXML_Document *UpnpMakeAction(char const   *ActionName , char const   *ServType ,
                                     int NumArg , char const   *Arg  , ...) ;
extern int UpnpAddToAction(IXML_Document **ActionDoc , char const   *ActionName ,
                           char const   *ServType , char const   *ArgName , char const   *ArgVal ) ;
extern int UpnpSendAction(UpnpClient_Handle Hnd , char const   *ActionURL , char const   *ServiceType ,
                          char const   *DevUDN , IXML_Document *Action , IXML_Document **RespNode ) ;
extern int UpnpSendActionAsync(UpnpClient_Handle Hnd , char const   *ActionURL , char const   *ServiceType ,
                               char const   *DevUDN , IXML_Document *Action , int (*Fun)(Upnp_EventType EventType ,
                                                                                         void *Event ,
                                                                                         void *Cookie ) ,
                               void const   *Cookie ) ;
extern FILE *stdin ;
extern FILE *stdout ;
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) ;
extern int getc(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
extern int putc(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
extern __ssize_t __getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                            int __delimiter , FILE * __restrict  __stream ) ;
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                     size_t * __restrict  __n ,
                                                                     FILE * __restrict  __stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
extern int __uflow(FILE * ) ;
extern int __overflow(FILE * , int  ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) 
{ 
  int tmp ;

  {
  tmp = vfprintf((FILE * __restrict  )stdout, __fmt, __arg);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) 
{ 
  int tmp ;

  {
  tmp = getc(stdin);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(__fp);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = __fp->_IO_read_ptr;
    (__fp->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(stdin);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = stdin->_IO_read_ptr;
    (stdin->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) 
{ 
  int tmp ;

  {
  tmp = putc(__c, stdout);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = __stream->_IO_write_ptr;
    (__stream->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = stdout->_IO_write_ptr;
    (stdout->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                     size_t * __restrict  __n ,
                                                                     FILE * __restrict  __stream ) 
{ 
  __ssize_t tmp ;

  {
  tmp = __getdelim(__lineptr, __n, '\n', __stream);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 16) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 32) != 0);
}
}
void QueueInsert(tQueue *queue , void *item ) ;
void *QueueExtract(tQueue *queue ) ;
IXML_Node *XMLAddNode(IXML_Document *doc , IXML_Node *parent , char *name , char *fmt 
                      , ...) ;
int XMLAddAttribute(IXML_Document *doc , IXML_Node *parent , char *name , char *fmt 
                    , ...) ;
char *XMLGetFirstDocumentItem(IXML_Document *doc , char const   *item , _Bool strict ) ;
UpnpClient_Handle glControlPointHandle ;
int ActionHandler(Upnp_EventType EventType , void *Event , void *Cookie ) ;
char const   *logtime(void) ;
void logprint(char const   *fmt  , ...) ;
_Bool AVTSetURI(struct sMR *Device , char *URI , struct metadata_s *MetaData , char *ProtoInfo ) ;
_Bool AVTSetNextURI(struct sMR *Device , char *URI , struct metadata_s *MetaData ,
                    char *ProtoInfo ) ;
int AVTCallAction(struct sMR *Device , char *Action , void *Cookie ) ;
_Bool AVTPlay(struct sMR *Device ) ;
_Bool AVTSetPlayMode(struct sMR *Device ) ;
_Bool AVTSeek(struct sMR *Device , unsigned int Interval ) ;
_Bool AVTBasic(struct sMR *Device , char *Action ) ;
_Bool AVTStop(struct sMR *Device ) ;
void AVTActionFlush(tQueue *Queue ) ;
int CtrlSetVolume(struct sMR *Device , u8_t Volume , void *Cookie ) ;
int CtrlSetMute(struct sMR *Device , _Bool Mute , void *Cookie ) ;
int CtrlGetVolume(struct sMR *Device ) ;
int CtrlGetGroupVolume(struct sMR *Device ) ;
char *GetProtocolInfo(struct sMR *Device ) ;
log_level upnp_loglevel ;
static log_level *loglevel  =    & upnp_loglevel;
static char *CreateDIDL(char *URI , char *ProtoInfo , struct metadata_s *MetaData ,
                        struct sMRConfig *Config ) ;
_Bool SubmitTransportAction(struct sMR *Device , IXML_Document *ActionNode ) 
{ 
  struct sService *Service ;
  int rc ;
  u8_t *tmp ;
  char const   *tmp___0 ;
  tAction *Action ;
  void *tmp___1 ;

  {
  Service = & Device->Service[0];
  rc = 0;
  if (! Device->WaitCookie) {
    tmp = Device->seqN;
    (Device->seqN) ++;
    Device->WaitCookie = (void *)tmp;
    rc = UpnpSendActionAsync(glControlPointHandle, (char const   *)(Service->ControlURL),
                             (char const   *)(Service->Type), (char const   *)((void *)0),
                             ActionNode, & ActionHandler, (void const   *)Device->WaitCookie);
    if (rc != 0) {
      tmp___0 = logtime();
      logprint("%s %s:%d [%p]: Error in UpnpSendActionAsync -- %d\n", tmp___0, "SubmitTransportAction",
               54, Device, rc);
    }
    ixmlDocument_free(ActionNode);
  } else {
    tmp___1 = malloc(sizeof(tAction ));
    Action = (tAction *)tmp___1;
    Action->Device = Device;
    Action->ActionNode = (void *)ActionNode;
    QueueInsert(& Device->ActionQueue, (void *)Action);
  }
  return ((_Bool )(rc == 0));
}
}
void AVTActionFlush(tQueue *Queue ) 
{ 
  tAction *Action ;
  void *tmp ;

  {
  while (1) {
    tmp = QueueExtract(Queue);
    Action = (tAction *)tmp;
    if (! ((unsigned long )Action != (unsigned long )((void *)0))) {
      break;
    }
    free((void *)Action);
  }
  return;
}
}
_Bool AVTSetURI(struct sMR *Device , char *URI , struct metadata_s *MetaData , char *ProtoInfo ) 
{ 
  IXML_Document *ActionNode ;
  struct sService *Service ;
  char *DIDLData ;
  char const   *tmp ;
  char const   *tmp___0 ;
  _Bool tmp___1 ;

  {
  ActionNode = (IXML_Document *)((void *)0);
  Service = & Device->Service[0];
  DIDLData = CreateDIDL(URI, ProtoInfo, MetaData, & Device->Config);
  if ((unsigned int )*loglevel >= 3U) {
    tmp = logtime();
    logprint("%s %s:%d [%p]: DIDL header: %s\n", tmp, "AVTSetURI", 89, Device, DIDLData);
  }
  if ((unsigned int )*loglevel >= 2U) {
    tmp___0 = logtime();
    logprint("%s %s:%d [%p]: uPNP setURI %s (cookie %p)\n", tmp___0, "AVTSetURI",
             91, Device, URI, Device->seqN);
  }
  ActionNode = UpnpMakeAction("SetAVTransportURI", (char const   *)(Service->Type),
                              0, (char const   *)((void *)0));
  if ((unsigned long )ActionNode == (unsigned long )((void *)0)) {
    return ((_Bool)0);
  }
  UpnpAddToAction(& ActionNode, "SetAVTransportURI", (char const   *)(Service->Type),
                  "InstanceID", "0");
  UpnpAddToAction(& ActionNode, "SetAVTransportURI", (char const   *)(Service->Type),
                  "CurrentURI", (char const   *)URI);
  UpnpAddToAction(& ActionNode, "SetAVTransportURI", (char const   *)(Service->Type),
                  "CurrentURIMetaData", (char const   *)DIDLData);
  free((void *)DIDLData);
  tmp___1 = SubmitTransportAction(Device, ActionNode);
  return (tmp___1);
}
}
_Bool AVTSetNextURI(struct sMR *Device , char *URI , struct metadata_s *MetaData ,
                    char *ProtoInfo ) 
{ 
  IXML_Document *ActionNode ;
  struct sService *Service ;
  char *DIDLData ;
  char const   *tmp ;
  char const   *tmp___0 ;
  _Bool tmp___1 ;

  {
  ActionNode = (IXML_Document *)((void *)0);
  Service = & Device->Service[0];
  DIDLData = CreateDIDL(URI, ProtoInfo, MetaData, & Device->Config);
  if ((unsigned int )*loglevel >= 3U) {
    tmp = logtime();
    logprint("%s %s:%d [%p]: DIDL header: %s\n", tmp, "AVTSetNextURI", 110, Device,
             DIDLData);
  }
  if ((unsigned int )*loglevel >= 2U) {
    tmp___0 = logtime();
    logprint("%s %s:%d [%p]: uPNP setNextURI %s (cookie %p)\n", tmp___0, "AVTSetNextURI",
             112, Device, URI, Device->seqN);
  }
  ActionNode = UpnpMakeAction("SetNextAVTransportURI", (char const   *)(Service->Type),
                              0, (char const   *)((void *)0));
  if ((unsigned long )ActionNode == (unsigned long )((void *)0)) {
    return ((_Bool)0);
  }
  UpnpAddToAction(& ActionNode, "SetNextAVTransportURI", (char const   *)(Service->Type),
                  "InstanceID", "0");
  UpnpAddToAction(& ActionNode, "SetNextAVTransportURI", (char const   *)(Service->Type),
                  "NextURI", (char const   *)URI);
  UpnpAddToAction(& ActionNode, "SetNextAVTransportURI", (char const   *)(Service->Type),
                  "NextURIMetaData", (char const   *)DIDLData);
  free((void *)DIDLData);
  tmp___1 = SubmitTransportAction(Device, ActionNode);
  return (tmp___1);
}
}
int AVTCallAction(struct sMR *Device , char *Action , void *Cookie ) 
{ 
  IXML_Document *ActionNode ;
  struct sService *Service ;
  int rc ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  ActionNode = (IXML_Document *)((void *)0);
  Service = & Device->Service[0];
  if ((unsigned int )*loglevel >= 4U) {
    tmp = logtime();
    logprint("%s %s:%d [%p]: uPNP %s (cookie %p)\n", tmp, "AVTCallAction", 130, Device,
             Action, Cookie);
  }
  ActionNode = UpnpMakeAction((char const   *)Action, (char const   *)(Service->Type),
                              0, (char const   *)((void *)0));
  if ((unsigned long )ActionNode == (unsigned long )((void *)0)) {
    return (0);
  }
  UpnpAddToAction(& ActionNode, (char const   *)Action, (char const   *)(Service->Type),
                  "InstanceID", "0");
  rc = UpnpSendActionAsync(glControlPointHandle, (char const   *)(Service->ControlURL),
                           (char const   *)(Service->Type), (char const   *)((void *)0),
                           ActionNode, & ActionHandler, (void const   *)Cookie);
  if (rc != 0) {
    tmp___0 = logtime();
    logprint("%s %s:%d [%p]: Error in UpnpSendActionAsync -- %d\n", tmp___0, "AVTCallAction",
             138, Device, rc);
  }
  ixmlDocument_free(ActionNode);
  return (rc);
}
}
_Bool AVTPlay(struct sMR *Device ) 
{ 
  struct sService *Service ;
  IXML_Document *ActionNode ;
  char const   *tmp ;
  _Bool tmp___0 ;

  {
  Service = & Device->Service[0];
  ActionNode = (IXML_Document *)((void *)0);
  if ((unsigned int )*loglevel >= 2U) {
    tmp = logtime();
    logprint("%s %s:%d [%p]: uPNP play (cookie %p)\n", tmp, "AVTPlay", 151, Device,
             Device->seqN);
  }
  ActionNode = UpnpMakeAction("Play", (char const   *)(Service->Type), 0, (char const   *)((void *)0));
  if ((unsigned long )ActionNode == (unsigned long )((void *)0)) {
    return ((_Bool)0);
  }
  UpnpAddToAction(& ActionNode, "Play", (char const   *)(Service->Type), "InstanceID",
                  "0");
  UpnpAddToAction(& ActionNode, "Play", (char const   *)(Service->Type), "Speed",
                  "1");
  tmp___0 = SubmitTransportAction(Device, ActionNode);
  return (tmp___0);
}
}
_Bool AVTSetPlayMode(struct sMR *Device ) 
{ 
  struct sService *Service ;
  IXML_Document *ActionNode ;
  char const   *tmp ;
  _Bool tmp___0 ;

  {
  Service = & Device->Service[0];
  ActionNode = (IXML_Document *)((void *)0);
  if ((unsigned int )*loglevel >= 2U) {
    tmp = logtime();
    logprint("%s %s:%d [%p]: uPNP set play mode (cookie %p)\n", tmp, "AVTSetPlayMode",
             167, Device, Device->seqN);
  }
  ActionNode = UpnpMakeAction("SetPlayMode", (char const   *)(Service->Type), 0, (char const   *)((void *)0));
  if ((unsigned long )ActionNode == (unsigned long )((void *)0)) {
    return ((_Bool)0);
  }
  UpnpAddToAction(& ActionNode, "SetPlayMode", (char const   *)(Service->Type), "InstanceID",
                  "0");
  UpnpAddToAction(& ActionNode, "SetPlayMode", (char const   *)(Service->Type), "NewPlayMode",
                  "NORMAL");
  tmp___0 = SubmitTransportAction(Device, ActionNode);
  return (tmp___0);
}
}
_Bool AVTSeek(struct sMR *Device , unsigned int Interval ) 
{ 
  struct sService *Service ;
  IXML_Document *ActionNode ;
  char params[128] ;
  char const   *tmp ;
  _Bool tmp___0 ;

  {
  Service = & Device->Service[0];
  ActionNode = (IXML_Document *)((void *)0);
  if ((unsigned int )*loglevel >= 2U) {
    tmp = logtime();
    logprint("%s %s:%d [%p]: uPNP seek (%ds) (cookie %p)\n", tmp, "AVTSeek", 183,
             Device, Interval, Device->seqN);
  }
  ActionNode = UpnpMakeAction("Seek", (char const   *)(Service->Type), 0, (char const   *)((void *)0));
  if ((unsigned long )ActionNode == (unsigned long )((void *)0)) {
    return ((_Bool)0);
  }
  UpnpAddToAction(& ActionNode, "Seek", (char const   *)(Service->Type), "InstanceID",
                  "0");
  sprintf((char * __restrict  )(params), (char const   * __restrict  )"%d", (int )((double )(Interval / 1000U) + 0.5));
  UpnpAddToAction(& ActionNode, "Seek", (char const   *)(Service->Type), "Unit", (char const   *)(params));
  UpnpAddToAction(& ActionNode, "Seek", (char const   *)(Service->Type), "Target",
                  "REL_TIME");
  tmp___0 = SubmitTransportAction(Device, ActionNode);
  return (tmp___0);
}
}
_Bool AVTBasic(struct sMR *Device , char *Action ) 
{ 
  struct sService *Service ;
  IXML_Document *ActionNode ;
  char const   *tmp ;
  _Bool tmp___0 ;

  {
  Service = & Device->Service[0];
  ActionNode = (IXML_Document *)((void *)0);
  if ((unsigned int )*loglevel >= 2U) {
    tmp = logtime();
    logprint("%s %s:%d [%p]: uPNP %s (cookie %p)\n", tmp, "AVTBasic", 201, Device,
             Action, Device->seqN);
  }
  ActionNode = UpnpMakeAction((char const   *)Action, (char const   *)(Service->Type),
                              0, (char const   *)((void *)0));
  if ((unsigned long )ActionNode == (unsigned long )((void *)0)) {
    return ((_Bool)0);
  }
  UpnpAddToAction(& ActionNode, (char const   *)Action, (char const   *)(Service->Type),
                  "InstanceID", "0");
  tmp___0 = SubmitTransportAction(Device, ActionNode);
  return (tmp___0);
}
}
_Bool AVTStop(struct sMR *Device ) 
{ 
  struct sService *Service ;
  IXML_Document *ActionNode ;
  int rc ;
  char const   *tmp ;
  u8_t *tmp___0 ;
  char const   *tmp___1 ;

  {
  Service = & Device->Service[0];
  ActionNode = (IXML_Document *)((void *)0);
  if ((unsigned int )*loglevel >= 2U) {
    tmp = logtime();
    logprint("%s %s:%d [%p]: uPNP stop (cookie %p)\n", tmp, "AVTStop", 217, Device,
             Device->seqN);
  }
  ActionNode = UpnpMakeAction("Stop", (char const   *)(Service->Type), 0, (char const   *)((void *)0));
  if ((unsigned long )ActionNode == (unsigned long )((void *)0)) {
    return ((_Bool)0);
  }
  UpnpAddToAction(& ActionNode, "Stop", (char const   *)(Service->Type), "InstanceID",
                  "0");
  AVTActionFlush(& Device->ActionQueue);
  tmp___0 = Device->seqN;
  (Device->seqN) ++;
  Device->WaitCookie = (void *)tmp___0;
  rc = UpnpSendActionAsync(glControlPointHandle, (char const   *)(Service->ControlURL),
                           (char const   *)(Service->Type), (char const   *)((void *)0),
                           ActionNode, & ActionHandler, (void const   *)Device->WaitCookie);
  ixmlDocument_free(ActionNode);
  if (rc != 0) {
    tmp___1 = logtime();
    logprint("%s %s:%d [%p]: Error in UpnpSendActionAsync -- %d\n", tmp___1, "AVTStop",
             230, Device, rc);
  }
  return ((_Bool )(rc == 0));
}
}
int CtrlSetVolume(struct sMR *Device , u8_t Volume , void *Cookie ) 
{ 
  IXML_Document *ActionNode ;
  struct sService *Service ;
  char params[8] ;
  int rc ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  ActionNode = (IXML_Document *)((void *)0);
  Service = & Device->Service[1];
  if ((unsigned int )*loglevel >= 2U) {
    tmp = logtime();
    logprint("%s %s:%d [%p]: uPNP volume %d (cookie %p)\n", tmp, "CtrlSetVolume",
             245, Device, (int )Volume, Cookie);
  }
  ActionNode = UpnpMakeAction("SetVolume", (char const   *)(Service->Type), 0, (char const   *)((void *)0));
  UpnpAddToAction(& ActionNode, "SetVolume", (char const   *)(Service->Type), "InstanceID",
                  "0");
  UpnpAddToAction(& ActionNode, "SetVolume", (char const   *)(Service->Type), "Channel",
                  "Master");
  sprintf((char * __restrict  )(params), (char const   * __restrict  )"%d", (int )Volume);
  UpnpAddToAction(& ActionNode, "SetVolume", (char const   *)(Service->Type), "DesiredVolume",
                  (char const   *)(params));
  rc = UpnpSendActionAsync(glControlPointHandle, (char const   *)(Service->ControlURL),
                           (char const   *)(Service->Type), (char const   *)((void *)0),
                           ActionNode, & ActionHandler, (void const   *)Cookie);
  if (rc != 0) {
    tmp___0 = logtime();
    logprint("%s %s:%d [%p]: Error in UpnpSendActionAsync -- %d\n", tmp___0, "CtrlSetVolume",
             256, Device, rc);
  }
  if (ActionNode) {
    ixmlDocument_free(ActionNode);
  }
  return (rc);
}
}
int CtrlSetMute(struct sMR *Device , _Bool Mute , void *Cookie ) 
{ 
  IXML_Document *ActionNode ;
  struct sService *Service ;
  int rc ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  ActionNode = (IXML_Document *)((void *)0);
  Service = & Device->Service[1];
  if ((unsigned int )*loglevel >= 2U) {
    tmp = logtime();
    logprint("%s %s:%d [%p]: uPNP mute %d (cookie %p)\n", tmp, "CtrlSetMute", 272,
             Device, (int )Mute, Cookie);
  }
  ActionNode = UpnpMakeAction("SetMute", (char const   *)(Service->Type), 0, (char const   *)((void *)0));
  UpnpAddToAction(& ActionNode, "SetMute", (char const   *)(Service->Type), "InstanceID",
                  "0");
  UpnpAddToAction(& ActionNode, "SetMute", (char const   *)(Service->Type), "Channel",
                  "Master");
  if (Mute) {
    tmp___0 = "1";
  } else {
    tmp___0 = "0";
  }
  UpnpAddToAction(& ActionNode, "SetMute", (char const   *)(Service->Type), "DesiredMute",
                  tmp___0);
  rc = UpnpSendActionAsync(glControlPointHandle, (char const   *)(Service->ControlURL),
                           (char const   *)(Service->Type), (char const   *)((void *)0),
                           ActionNode, & ActionHandler, (void const   *)Cookie);
  if (ActionNode) {
    ixmlDocument_free(ActionNode);
  }
  if (rc != 0) {
    tmp___1 = logtime();
    logprint("%s %s:%d [%p]: Error in UpnpSendActionAsync -- %d\n", tmp___1, "CtrlSetMute",
             284, Device, rc);
  }
  return (rc);
}
}
int CtrlGetGroupVolume(struct sMR *Device ) 
{ 
  IXML_Document *ActionNode ;
  IXML_Document *Response ;
  struct sService *Service ;
  char *Item ;
  int Volume ;

  {
  Response = (IXML_Document *)((void *)0);
  Service = & Device->Service[4];
  Volume = -1;
  if (! (Service->ControlURL)) {
    return (Volume);
  }
  ActionNode = UpnpMakeAction("GetGroupVolume", (char const   *)(Service->Type), 0,
                              (char const   *)((void *)0));
  UpnpAddToAction(& ActionNode, "GetGroupVolume", (char const   *)(Service->Type),
                  "InstanceID", "0");
  UpnpSendAction(glControlPointHandle, (char const   *)(Service->ControlURL), (char const   *)(Service->Type),
                 (char const   *)((void *)0), ActionNode, & Response);
  if (ActionNode) {
    ixmlDocument_free(ActionNode);
  }
  Item = XMLGetFirstDocumentItem(Response, "CurrentVolume", (_Bool)1);
  if (Response) {
    ixmlDocument_free(Response);
  }
  if (Item) {
    Volume = atoi((char const   *)Item);
    free((void *)Item);
  }
  return (Volume);
}
}
int CtrlGetVolume(struct sMR *Device ) 
{ 
  IXML_Document *ActionNode ;
  IXML_Document *Response ;
  struct sService *Service ;
  char *Item ;
  int Volume ;

  {
  Response = (IXML_Document *)((void *)0);
  Service = & Device->Service[1];
  Volume = -1;
  if (! (Service->ControlURL)) {
    return (Volume);
  }
  ActionNode = UpnpMakeAction("GetVolume", (char const   *)(Service->Type), 0, (char const   *)((void *)0));
  UpnpAddToAction(& ActionNode, "GetVolume", (char const   *)(Service->Type), "InstanceID",
                  "0");
  UpnpAddToAction(& ActionNode, "GetVolume", (char const   *)(Service->Type), "Channel",
                  "Master");
  UpnpSendAction(glControlPointHandle, (char const   *)(Service->ControlURL), (char const   *)(Service->Type),
                 (char const   *)((void *)0), ActionNode, & Response);
  if (ActionNode) {
    ixmlDocument_free(ActionNode);
  }
  if (Response) {
    Item = XMLGetFirstDocumentItem(Response, "CurrentVolume", (_Bool)1);
    if (Item) {
      Volume = atoi((char const   *)Item);
      free((void *)Item);
    }
    ixmlDocument_free(Response);
  }
  return (Volume);
}
}
char *GetProtocolInfo(struct sMR *Device ) 
{ 
  IXML_Document *ActionNode ;
  IXML_Document *Response ;
  struct sService *Service ;
  char *ProtocolInfo ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  Response = (IXML_Document *)((void *)0);
  Service = & Device->Service[2];
  ProtocolInfo = (char *)((void *)0);
  if ((unsigned int )*loglevel >= 3U) {
    tmp = logtime();
    logprint("%s %s:%d [%p]: uPNP GetProtocolInfo\n", tmp, "GetProtocolInfo", 359,
             Device);
  }
  ActionNode = UpnpMakeAction("GetProtocolInfo", (char const   *)(Service->Type),
                              0, (char const   *)((void *)0));
  UpnpSendAction(glControlPointHandle, (char const   *)(Service->ControlURL), (char const   *)(Service->Type),
                 (char const   *)((void *)0), ActionNode, & Response);
  if (ActionNode) {
    ixmlDocument_free(ActionNode);
  }
  if (Response) {
    ProtocolInfo = XMLGetFirstDocumentItem(Response, "Sink", (_Bool)0);
    ixmlDocument_free(Response);
    if ((unsigned int )*loglevel >= 3U) {
      tmp___0 = logtime();
      logprint("%s %s:%d [%p]: ProtocolInfo %s\n", tmp___0, "GetProtocolInfo", 370,
               Device, ProtocolInfo);
    }
  }
  return (ProtocolInfo);
}
}
static char *CreateDIDL(char *URI , char *ProtoInfo , struct metadata_s *MetaData ,
                        struct sMRConfig *Config ) 
{ 
  char *s ;
  IXML_Document *doc ;
  IXML_Document *tmp ;
  IXML_Node *node ;
  IXML_Node *root ;
  div_t duration ;
  div_t tmp___0 ;

  {
  tmp = ixmlDocument_createDocument();
  doc = tmp;
  root = XMLAddNode(doc, (IXML_Node *)((void *)0), (char *)"DIDL-Lite", (char *)((void *)0));
  XMLAddAttribute(doc, root, (char *)"xmlns:dc", (char *)"http://purl.org/dc/elements/1.1/");
  XMLAddAttribute(doc, root, (char *)"xmlns:upnp", (char *)"urn:schemas-upnp-org:metadata-1-0/upnp/");
  XMLAddAttribute(doc, root, (char *)"xmlns", (char *)"urn:schemas-upnp-org:metadata-1-0/DIDL-Lite/");
  XMLAddAttribute(doc, root, (char *)"xmlns:dlna", (char *)"urn:schemas-dlna-org:metadata-1-0/");
  node = XMLAddNode(doc, root, (char *)"item", (char *)((void *)0));
  XMLAddAttribute(doc, node, (char *)"id", (char *)"1");
  XMLAddAttribute(doc, node, (char *)"parentID", (char *)"0");
  XMLAddAttribute(doc, node, (char *)"restricted", (char *)"1");
  if (MetaData->duration) {
    tmp___0 = div((int )MetaData->duration, 1000);
    duration = tmp___0;
    if (Config->SendMetaData) {
      XMLAddNode(doc, node, (char *)"dc:title", MetaData->title);
      XMLAddNode(doc, node, (char *)"dc:creator", MetaData->artist);
      XMLAddNode(doc, node, (char *)"upnp:genre", MetaData->genre);
      XMLAddNode(doc, node, (char *)"upnp:artist", MetaData->artist);
      XMLAddNode(doc, node, (char *)"upnp:album", MetaData->album);
      XMLAddNode(doc, node, (char *)"upnp:originalTrackNumber", (char *)"%d", MetaData->track);
      if (MetaData->artwork) {
        XMLAddNode(doc, node, (char *)"upnp:albumArtURI", (char *)"%s", MetaData->artwork);
      }
    }
    XMLAddNode(doc, node, (char *)"upnp:class", (char *)"object.item.audioItem.musicTrack");
    node = XMLAddNode(doc, node, (char *)"res", URI);
    XMLAddAttribute(doc, node, (char *)"duration", (char *)"%1d:%02d:%02d.%03d", duration.quot / 3600,
                    (duration.quot % 3600) / 60, duration.quot % 60, duration.rem);
  } else {
    if (Config->SendMetaData) {
      XMLAddNode(doc, node, (char *)"dc:title", MetaData->remote_title);
      XMLAddNode(doc, node, (char *)"dc:creator", (char *)"");
      XMLAddNode(doc, node, (char *)"upnp:album", (char *)"");
      XMLAddNode(doc, node, (char *)"upnp:channelName", MetaData->remote_title);
      XMLAddNode(doc, node, (char *)"upnp:channelNr", (char *)"%d", MetaData->track);
      if (MetaData->artwork) {
        XMLAddNode(doc, node, (char *)"upnp:albumArtURI", (char *)"%s", MetaData->artwork);
      }
    }
    XMLAddNode(doc, node, (char *)"upnp:class", (char *)"object.item.audioItem.audioBroadcast");
    node = XMLAddNode(doc, node, (char *)"res", URI);
  }
  XMLAddAttribute(doc, node, (char *)"protocolInfo", ProtoInfo);
  if (MetaData->sample_rate) {
    if (MetaData->sample_size) {
      if (MetaData->channels) {
        XMLAddAttribute(doc, node, (char *)"sampleFrequency", (char *)"%u", MetaData->sample_rate);
        XMLAddAttribute(doc, node, (char *)"bitsPerSample", (char *)"%hhu", (int )MetaData->sample_size);
        XMLAddAttribute(doc, node, (char *)"nrAudioChannels", (char *)"%hhu", (int )MetaData->channels);
        if (MetaData->duration) {
          XMLAddAttribute(doc, node, (char *)"size", (char *)"%u", (u32_t )(((u64_t )(((MetaData->sample_rate * (u32_t )MetaData->sample_size) / 8U) * (u32_t )MetaData->channels) * (u64_t )MetaData->duration) / 1000UL));
        }
      }
    }
  }
  s = ixmlNodetoString((IXML_Node *)doc);
  ixmlDocument_free(doc);
  return (s);
}
}
#pragma merger("0","/tmp/cil-zYyZBIiB.i","-Wall,-fPIC,-ggdb,-O2,-m64,-fdata-sections,-ffunction-sections")
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
extern unsigned int sleep(unsigned int __seconds ) ;
extern int pause(void) ;
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gethostname)(char *__name ,
                                                                                        size_t __len ) ;
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off64_t __length )  __asm__("ftruncate64")  ;
extern  __attribute__((__nothrow__)) in_addr_t inet_addr(char const   *__cp ) ;
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_trylock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                                              pthread_condattr_t const   * __restrict  __cond_attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_destroy)(pthread_cond_t *__cond ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_signal)(pthread_cond_t *__cond ) ;
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
int SendARP(in_addr_t src , in_addr_t dst , u8_t *mac , unsigned long *size ) ;
u32_t gettime_ms(void) ;
extern FILE *stderr ;
extern int fclose(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream )  __asm__("freopen64")  ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
extern int scanf(char const   * __restrict  __format  , ...)  __asm__("__isoc99_scanf")  ;
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...)  __asm__("__isoc99_sscanf")  ;
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
extern int fseek(FILE *__stream , long __off , int __whence ) ;
extern long ftell(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
struct mdnsd *mdnsd_start(struct in_addr host ) ;
void mdnsd_stop(struct mdnsd *s ) ;
void mdnsd_set_hostname(struct mdnsd *svr , char const   *hostname , struct in_addr addr ) ;
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2))) strtok)(char * __restrict  __s ,
                                                                                     char const   * __restrict  __delim ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcasestr)(char const   *__haystack ,
                                                                                           char const   *__needle )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
void InitUtils(void) ;
void EndUtils(void) ;
void WakeableSleep(u32_t ms ) ;
void WakeAll(void) ;
void QueueInit(tQueue *queue , _Bool mutex , void (*cleanup)(void * ) ) ;
void QueueFlush(tQueue *queue ) ;
char const   *XMLGetLocalName(IXML_Document *doc , int Depth ) ;
_Bool XMLMatchDocumentItem(IXML_Document *doc , char const   *item , char const   *s ,
                           _Bool match ) ;
u32_t hash32(char *str___0 ) ;
in_addr_t get_localhost(char **name ) ;
char *kd_lookup(key_data_t *kd , char *key ) ;
_Bool kd_add(key_data_t *kd , char *key , char *data ) ;
struct raop_ctx_s *raop_create(struct in_addr host , struct mdnsd *svr , char *name ,
                               char *model , unsigned char *mac , char *codec , _Bool metadata ,
                               _Bool drift , _Bool flush , char *latencies , void *owner ,
                               void (*raop_cb)(void *owner , raop_event_t event ,
                                               void *param ) , void (*http_cb___0)(void *owner ,
                                                                                   struct key_data_s *headers ,
                                                                                   struct key_data_s *response ) ,
                               unsigned short port_base , unsigned short port_range ,
                               int http_length ) ;
void raop_update(struct raop_ctx_s *ctx , char *name , char *model ) ;
void raop_delete(struct raop_ctx_s *ctx ) ;
void raop_notify(struct raop_ctx_s *ctx , raop_event_t event , void *param ) ;
extern int UpnpInit(char const   *HostIP , unsigned short DestPort ) ;
extern int UpnpFinish(void) ;
extern unsigned short UpnpGetServerPort(void) ;
extern int UpnpRegisterClient(int (*Callback)(Upnp_EventType EventType , void *Event ,
                                              void *Cookie ) , void const   *Cookie ,
                              UpnpClient_Handle *Hnd ) ;
extern int UpnpUnRegisterClient(UpnpClient_Handle Hnd ) ;
extern int UpnpSetMaxContentLength(size_t contentLength ) ;
extern int UpnpSearchAsync(UpnpClient_Handle Hnd , int Mx , char const   *TTarget_constarget_const ,
                           void const   *Cookie_const ) ;
extern int UpnpSubscribeAsync(UpnpClient_Handle Hnd , char const   *PublisherUrl ,
                              int TimeOut , int (*Fun)(Upnp_EventType EventType ,
                                                       void *Event , void *Cookie ) ,
                              void const   *Cookie ) ;
extern int UpnpDownloadXmlDoc(char const   *url , IXML_Document **xmlDoc ) ;
UpnpClient_Handle glControlPointHandle  ;
s32_t glLogLimit ;
tMRConfig glMRConfig ;
struct sMR *glMRDevices  ;
int glMaxDevices ;
char glBinding[128] ;
unsigned short glPortBase  ;
unsigned short glPortRange  ;
int MasterHandler(Upnp_EventType EventType , void *_Event , void *Cookie ) ;
__inline static void UpnpSetLogLevel(Upnp_LogLevel log_level ) 
{ 


  {
  return;
  log_level = log_level;
}
}
log_level debug2level(char *level ) ;
void SaveConfig(char *name , void *ref , _Bool full ) ;
void *LoadConfig(char *name , struct sMRConfig *Conf ) ;
void *LoadMRConfig(void *ref , char *UDN , struct sMRConfig *Conf ) ;
void FlushMRDevices(void) ;
void DelMRDevice(struct sMR *p ) ;
struct sMR *GetMaster(struct sMR *Device , char **Name ) ;
int CalcGroupVolume(struct sMR *Device ) ;
_Bool CheckAndLock(struct sMR *Device ) ;
struct sMR *SID2Device(char *SID ) ;
struct sMR *CURL2Device(char *CtrlURL ) ;
struct sMR *UDN2Device(char *UDN ) ;
struct sService *EventURL2Service(char *URL , struct sService *s ) ;
void MakeMacUnique(struct sMR *Device ) ;
in_addr_t ExtractIP(char const   *URL ) ;
int XMLFindAndParseService(IXML_Document *DescDoc , char const   *location , char const   *serviceTypeBase ,
                           char **serviceType , char **serviceId , char **eventURL ,
                           char **controlURL ) ;
char *XMLGetChangeItem(IXML_Document *doc , char *Tag , char *SearchAttr , char *SearchVal ,
                       char *RetAttr ) ;
char *uPNPEvent2String(Upnp_EventType S ) ;
_Bool load_ssl_symbols(void) ;
void free_ssl_symbols(void) ;
s32_t glLogLimit  =    -1;
int glMaxDevices  =    32;
char glBinding[128]  = {      (char )'?',      (char )'\000'};
log_level main_loglevel  =    (log_level )2;
log_level raop_loglevel  =    (log_level )2;
log_level util_loglevel  =    (log_level )1;
log_level upnp_loglevel  =    (log_level )2;
tMRConfig glMRConfig  = 
     {-1, (_Bool)1, {(char )'\000'}, 1, (_Bool)1, (_Bool)0, (_Bool)1, 100, {(char )'f',
                                                                          (char )'l',
                                                                          (char )'c',
                                                                          (char )'\000'},
    (_Bool)1, {(char )'\000'}, (_Bool)0, {(u8_t )0, (u8_t )0, (u8_t )0, (u8_t )0,
                                          (u8_t )0, (u8_t )0}, {(char )'\000'}, {{(char )'h',
                                                                                  (char )'t',
                                                                                  (char )'t',
                                                                                  (char )'p',
                                                                                  (char )'-',
                                                                                  (char )'g',
                                                                                  (char )'e',
                                                                                  (char )'t',
                                                                                  (char )':',
                                                                                  (char )'*',
                                                                                  (char )':',
                                                                                  (char )'a',
                                                                                  (char )'u',
                                                                                  (char )'d',
                                                                                  (char )'i',
                                                                                  (char )'o',
                                                                                  (char )'/',
                                                                                  (char )'L',
                                                                                  (char )'1',
                                                                                  (char )'6',
                                                                                  (char )';',
                                                                                  (char )'r',
                                                                                  (char )'a',
                                                                                  (char )'t',
                                                                                  (char )'e',
                                                                                  (char )'=',
                                                                                  (char )'4',
                                                                                  (char )'4',
                                                                                  (char )'1',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )';',
                                                                                  (char )'c',
                                                                                  (char )'h',
                                                                                  (char )'a',
                                                                                  (char )'n',
                                                                                  (char )'n',
                                                                                  (char )'e',
                                                                                  (char )'l',
                                                                                  (char )'s',
                                                                                  (char )'=',
                                                                                  (char )'2',
                                                                                  (char )':',
                                                                                  (char )'D',
                                                                                  (char )'L',
                                                                                  (char )'N',
                                                                                  (char )'A',
                                                                                  (char )'.',
                                                                                  (char )'O',
                                                                                  (char )'R',
                                                                                  (char )'G',
                                                                                  (char )'_',
                                                                                  (char )'P',
                                                                                  (char )'N',
                                                                                  (char )'=',
                                                                                  (char )'L',
                                                                                  (char )'P',
                                                                                  (char )'C',
                                                                                  (char )'M',
                                                                                  (char )';',
                                                                                  (char )'D',
                                                                                  (char )'L',
                                                                                  (char )'N',
                                                                                  (char )'A',
                                                                                  (char )'.',
                                                                                  (char )'O',
                                                                                  (char )'R',
                                                                                  (char )'G',
                                                                                  (char )'_',
                                                                                  (char )'O',
                                                                                  (char )'P',
                                                                                  (char )'=',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )';',
                                                                                  (char )'D',
                                                                                  (char )'L',
                                                                                  (char )'N',
                                                                                  (char )'A',
                                                                                  (char )'.',
                                                                                  (char )'O',
                                                                                  (char )'R',
                                                                                  (char )'G',
                                                                                  (char )'_',
                                                                                  (char )'C',
                                                                                  (char )'I',
                                                                                  (char )'=',
                                                                                  (char )'0',
                                                                                  (char )';',
                                                                                  (char )'D',
                                                                                  (char )'L',
                                                                                  (char )'N',
                                                                                  (char )'A',
                                                                                  (char )'.',
                                                                                  (char )'O',
                                                                                  (char )'R',
                                                                                  (char )'G',
                                                                                  (char )'_',
                                                                                  (char )'F',
                                                                                  (char )'L',
                                                                                  (char )'A',
                                                                                  (char )'G',
                                                                                  (char )'S',
                                                                                  (char )'=',
                                                                                  (char )'0',
                                                                                  (char )'d',
                                                                                  (char )'5',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'\000'},
                                                                                 {(char )'h',
                                                                                  (char )'t',
                                                                                  (char )'t',
                                                                                  (char )'p',
                                                                                  (char )'-',
                                                                                  (char )'g',
                                                                                  (char )'e',
                                                                                  (char )'t',
                                                                                  (char )':',
                                                                                  (char )'*',
                                                                                  (char )':',
                                                                                  (char )'a',
                                                                                  (char )'u',
                                                                                  (char )'d',
                                                                                  (char )'i',
                                                                                  (char )'o',
                                                                                  (char )'/',
                                                                                  (char )'w',
                                                                                  (char )'a',
                                                                                  (char )'v',
                                                                                  (char )':',
                                                                                  (char )'D',
                                                                                  (char )'L',
                                                                                  (char )'N',
                                                                                  (char )'A',
                                                                                  (char )'.',
                                                                                  (char )'O',
                                                                                  (char )'R',
                                                                                  (char )'G',
                                                                                  (char )'_',
                                                                                  (char )'O',
                                                                                  (char )'P',
                                                                                  (char )'=',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )';',
                                                                                  (char )'D',
                                                                                  (char )'L',
                                                                                  (char )'N',
                                                                                  (char )'A',
                                                                                  (char )'.',
                                                                                  (char )'O',
                                                                                  (char )'R',
                                                                                  (char )'G',
                                                                                  (char )'_',
                                                                                  (char )'C',
                                                                                  (char )'I',
                                                                                  (char )'=',
                                                                                  (char )'0',
                                                                                  (char )';',
                                                                                  (char )'D',
                                                                                  (char )'L',
                                                                                  (char )'N',
                                                                                  (char )'A',
                                                                                  (char )'.',
                                                                                  (char )'O',
                                                                                  (char )'R',
                                                                                  (char )'G',
                                                                                  (char )'_',
                                                                                  (char )'F',
                                                                                  (char )'L',
                                                                                  (char )'A',
                                                                                  (char )'G',
                                                                                  (char )'S',
                                                                                  (char )'=',
                                                                                  (char )'0',
                                                                                  (char )'d',
                                                                                  (char )'5',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'\000'},
                                                                                 {(char )'h',
                                                                                  (char )'t',
                                                                                  (char )'t',
                                                                                  (char )'p',
                                                                                  (char )'-',
                                                                                  (char )'g',
                                                                                  (char )'e',
                                                                                  (char )'t',
                                                                                  (char )':',
                                                                                  (char )'*',
                                                                                  (char )':',
                                                                                  (char )'a',
                                                                                  (char )'u',
                                                                                  (char )'d',
                                                                                  (char )'i',
                                                                                  (char )'o',
                                                                                  (char )'/',
                                                                                  (char )'f',
                                                                                  (char )'l',
                                                                                  (char )'a',
                                                                                  (char )'c',
                                                                                  (char )':',
                                                                                  (char )'D',
                                                                                  (char )'L',
                                                                                  (char )'N',
                                                                                  (char )'A',
                                                                                  (char )'.',
                                                                                  (char )'O',
                                                                                  (char )'R',
                                                                                  (char )'G',
                                                                                  (char )'_',
                                                                                  (char )'O',
                                                                                  (char )'P',
                                                                                  (char )'=',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )';',
                                                                                  (char )'D',
                                                                                  (char )'L',
                                                                                  (char )'N',
                                                                                  (char )'A',
                                                                                  (char )'.',
                                                                                  (char )'O',
                                                                                  (char )'R',
                                                                                  (char )'G',
                                                                                  (char )'_',
                                                                                  (char )'C',
                                                                                  (char )'I',
                                                                                  (char )'=',
                                                                                  (char )'0',
                                                                                  (char )';',
                                                                                  (char )'D',
                                                                                  (char )'L',
                                                                                  (char )'N',
                                                                                  (char )'A',
                                                                                  (char )'.',
                                                                                  (char )'O',
                                                                                  (char )'R',
                                                                                  (char )'G',
                                                                                  (char )'_',
                                                                                  (char )'F',
                                                                                  (char )'L',
                                                                                  (char )'A',
                                                                                  (char )'G',
                                                                                  (char )'S',
                                                                                  (char )'=',
                                                                                  (char )'0',
                                                                                  (char )'d',
                                                                                  (char )'5',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'\000'},
                                                                                 {(char )'h',
                                                                                  (char )'t',
                                                                                  (char )'t',
                                                                                  (char )'p',
                                                                                  (char )'-',
                                                                                  (char )'g',
                                                                                  (char )'e',
                                                                                  (char )'t',
                                                                                  (char )':',
                                                                                  (char )'*',
                                                                                  (char )':',
                                                                                  (char )'a',
                                                                                  (char )'u',
                                                                                  (char )'d',
                                                                                  (char )'i',
                                                                                  (char )'o',
                                                                                  (char )'/',
                                                                                  (char )'m',
                                                                                  (char )'p',
                                                                                  (char )'e',
                                                                                  (char )'g',
                                                                                  (char )':',
                                                                                  (char )'D',
                                                                                  (char )'L',
                                                                                  (char )'N',
                                                                                  (char )'A',
                                                                                  (char )'.',
                                                                                  (char )'O',
                                                                                  (char )'R',
                                                                                  (char )'G',
                                                                                  (char )'_',
                                                                                  (char )'P',
                                                                                  (char )'N',
                                                                                  (char )'=',
                                                                                  (char )'M',
                                                                                  (char )'P',
                                                                                  (char )'3',
                                                                                  (char )';',
                                                                                  (char )'D',
                                                                                  (char )'L',
                                                                                  (char )'N',
                                                                                  (char )'A',
                                                                                  (char )'.',
                                                                                  (char )'O',
                                                                                  (char )'R',
                                                                                  (char )'G',
                                                                                  (char )'_',
                                                                                  (char )'O',
                                                                                  (char )'P',
                                                                                  (char )'=',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )';',
                                                                                  (char )'D',
                                                                                  (char )'L',
                                                                                  (char )'N',
                                                                                  (char )'A',
                                                                                  (char )'.',
                                                                                  (char )'O',
                                                                                  (char )'R',
                                                                                  (char )'G',
                                                                                  (char )'_',
                                                                                  (char )'C',
                                                                                  (char )'I',
                                                                                  (char )'=',
                                                                                  (char )'0',
                                                                                  (char )';',
                                                                                  (char )'D',
                                                                                  (char )'L',
                                                                                  (char )'N',
                                                                                  (char )'A',
                                                                                  (char )'.',
                                                                                  (char )'O',
                                                                                  (char )'R',
                                                                                  (char )'G',
                                                                                  (char )'_',
                                                                                  (char )'F',
                                                                                  (char )'L',
                                                                                  (char )'A',
                                                                                  (char )'G',
                                                                                  (char )'S',
                                                                                  (char )'=',
                                                                                  (char )'0',
                                                                                  (char )'d',
                                                                                  (char )'5',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'0',
                                                                                  (char )'\000'}}};
static struct cSearchedSRV_s  const  cSearchedSRV[5]  = {      {{(char )'u',
       (char )'r', (char )'n', (char )':', (char )'s', (char )'c', (char )'h', (char )'e',
       (char )'m', (char )'a', (char )'s', (char )'-', (char )'u', (char )'p', (char )'n',
       (char )'p', (char )'-', (char )'o', (char )'r', (char )'g', (char )':', (char )'s',
       (char )'e', (char )'r', (char )'v', (char )'i', (char )'c', (char )'e', (char )':',
       (char )'A', (char )'V', (char )'T', (char )'r', (char )'a', (char )'n', (char )'s',
       (char )'p', (char )'o', (char )'r', (char )'t', (char )'\000'}, 0, (u32_t )0}, 
        {{(char )'u',
       (char )'r', (char )'n', (char )':', (char )'s', (char )'c', (char )'h', (char )'e',
       (char )'m', (char )'a', (char )'s', (char )'-', (char )'u', (char )'p', (char )'n',
       (char )'p', (char )'-', (char )'o', (char )'r', (char )'g', (char )':', (char )'s',
       (char )'e', (char )'r', (char )'v', (char )'i', (char )'c', (char )'e', (char )':',
       (char )'R', (char )'e', (char )'n', (char )'d', (char )'e', (char )'r', (char )'i',
       (char )'n', (char )'g', (char )'C', (char )'o', (char )'n', (char )'t', (char )'r',
       (char )'o', (char )'l', (char )'\000'}, 1, (u32_t )30}, 
        {{(char )'u', (char )'r', (char )'n', (char )':', (char )'s', (char )'c', (char )'h',
       (char )'e', (char )'m', (char )'a', (char )'s', (char )'-', (char )'u', (char )'p',
       (char )'n', (char )'p', (char )'-', (char )'o', (char )'r', (char )'g', (char )':',
       (char )'s', (char )'e', (char )'r', (char )'v', (char )'i', (char )'c', (char )'e',
       (char )':', (char )'C', (char )'o', (char )'n', (char )'n', (char )'e', (char )'c',
       (char )'t', (char )'i', (char )'o', (char )'n', (char )'M', (char )'a', (char )'n',
       (char )'a', (char )'g', (char )'e', (char )'r', (char )'\000'}, 2, (u32_t )0}, 
        {{(char )'u',
       (char )'r', (char )'n', (char )':', (char )'s', (char )'c', (char )'h', (char )'e',
       (char )'m', (char )'a', (char )'s', (char )'-', (char )'u', (char )'p', (char )'n',
       (char )'p', (char )'-', (char )'o', (char )'r', (char )'g', (char )':', (char )'s',
       (char )'e', (char )'r', (char )'v', (char )'i', (char )'c', (char )'e', (char )':',
       (char )'Z', (char )'o', (char )'n', (char )'e', (char )'G', (char )'r', (char )'o',
       (char )'u', (char )'p', (char )'T', (char )'o', (char )'p', (char )'o', (char )'l',
       (char )'o', (char )'g', (char )'y', (char )'\000'}, 3, (u32_t )0}, 
        {{(char )'u', (char )'r', (char )'n', (char )':', (char )'s', (char )'c', (char )'h',
       (char )'e', (char )'m', (char )'a', (char )'s', (char )'-', (char )'u', (char )'p',
       (char )'n', (char )'p', (char )'-', (char )'o', (char )'r', (char )'g', (char )':',
       (char )'s', (char )'e', (char )'r', (char )'v', (char )'i', (char )'c', (char )'e',
       (char )':', (char )'G', (char )'r', (char )'o', (char )'u', (char )'p', (char )'R',
       (char )'e', (char )'n', (char )'d', (char )'e', (char )'r', (char )'i', (char )'n',
       (char )'g', (char )'C', (char )'o', (char )'n', (char )'t', (char )'r', (char )'o',
       (char )'l', (char )'\000'}, 4, (u32_t )0}};
static log_level *loglevel___0  =    & main_loglevel;
static _Bool glDaemonize  =    (_Bool)0;
static _Bool glMainRunning  =    (_Bool)1;
static struct in_addr glHost  ;
static char glHostName[256]  ;
static struct mdnsd *glmDNSServer  =    (struct mdnsd *)((void *)0);
static char *glExcluded  =    (char *)((void *)0);
static char *glExcludedModelNumber  =    (char *)((void *)0);
static char *glIncludedModelNumbers  =    (char *)((void *)0);
static char *glPidFile  =    (char *)((void *)0);
static _Bool glAutoSaveConfigFile  =    (_Bool)0;
static _Bool glGracefullShutdown  =    (_Bool)1;
static _Bool glDiscovery  =    (_Bool)0;
static pthread_mutex_t glUpdateMutex  ;
static pthread_cond_t glUpdateCond  ;
static pthread_t glMainThread  ;
static pthread_t glUpdateThread  ;
static tQueue glUpdateQueue  ;
static _Bool glInteractive  =    (_Bool)1;
static char *glLogFile  ;
static u32_t glPort  ;
static void *glConfigID  =    (void *)0;
static char glConfigName[256]  = 
  {      (char )'.',      (char )'/',      (char )'c',      (char )'o', 
        (char )'n',      (char )'f',      (char )'i',      (char )'g', 
        (char )'.',      (char )'x',      (char )'m',      (char )'l', 
        (char )'\000'};
static char usage[1312]  = 
  {      (char )'v',      (char )'0',      (char )'.',      (char )'2', 
        (char )'.',      (char )'5',      (char )'1',      (char )'.', 
        (char )'2',      (char )' ',      (char )'(',      (char )'A', 
        (char )'u',      (char )'g',      (char )' ',      (char )' ', 
        (char )'3',      (char )' ',      (char )'2',      (char )'0', 
        (char )'2',      (char )'2',      (char )' ',      (char )'@', 
        (char )' ',      (char )'1',      (char )'7',      (char )':', 
        (char )'2',      (char )'3',      (char )':',      (char )'4', 
        (char )'6',      (char )')',      (char )'\n',      (char )'S', 
        (char )'e',      (char )'e',      (char )' ',      (char )'-', 
        (char )'t',      (char )' ',      (char )'f',      (char )'o', 
        (char )'r',      (char )' ',      (char )'l',      (char )'i', 
        (char )'c',      (char )'e',      (char )'n',      (char )'s', 
        (char )'e',      (char )' ',      (char )'t',      (char )'e', 
        (char )'r',      (char )'m',      (char )'s',      (char )'\n', 
        (char )'U',      (char )'s',      (char )'a',      (char )'g', 
        (char )'e',      (char )':',      (char )' ',      (char )'[', 
        (char )'o',      (char )'p',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )'s',      (char )']', 
        (char )'\n',      (char )' ',      (char )' ',      (char )'-', 
        (char )'b',      (char )' ',      (char )'<',      (char )'i', 
        (char )'p',      (char )'>',      (char )'[',      (char )':', 
        (char )'<',      (char )'p',      (char )'o',      (char )'r', 
        (char )'t',      (char )'>',      (char )']',      (char )'\t', 
        (char )'n',      (char )'e',      (char )'t',      (char )'w', 
        (char )'o',      (char )'r',      (char )'k',      (char )' ', 
        (char )'i',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'f',      (char )'a',      (char )'c', 
        (char )'e',      (char )' ',      (char )'a',      (char )'n', 
        (char )'d',      (char )' ',      (char )'U',      (char )'P', 
        (char )'n',      (char )'P',      (char )' ',      (char )'p', 
        (char )'o',      (char )'r',      (char )'t',      (char )' ', 
        (char )'t',      (char )'o',      (char )' ',      (char )'u', 
        (char )'s',      (char )'e',      (char )'\n',      (char )' ', 
        (char )' ',      (char )'-',      (char )'a',      (char )' ', 
        (char )'<',      (char )'p',      (char )'o',      (char )'r', 
        (char )'t',      (char )'>',      (char )'[',      (char )':', 
        (char )'<',      (char )'c',      (char )'o',      (char )'u', 
        (char )'n',      (char )'t',      (char )'>',      (char )']', 
        (char )'\t',      (char )'s',      (char )'e',      (char )'t', 
        (char )' ',      (char )'i',      (char )'n',      (char )'b', 
        (char )'o',      (char )'u',      (char )'n',      (char )'d', 
        (char )' ',      (char )'p',      (char )'o',      (char )'r', 
        (char )'t',      (char )' ',      (char )'a',      (char )'n', 
        (char )'d',      (char )' ',      (char )'r',      (char )'a', 
        (char )'n',      (char )'g',      (char )'e',      (char )' ', 
        (char )'f',      (char )'o',      (char )'r',      (char )' ', 
        (char )'R',      (char )'T',      (char )'P',      (char )' ', 
        (char )'a',      (char )'n',      (char )'d',      (char )' ', 
        (char )'H',      (char )'T',      (char )'T',      (char )'P', 
        (char )'\n',      (char )' ',      (char )' ',      (char )'-', 
        (char )'c',      (char )' ',      (char )'<',      (char )'m', 
        (char )'p',      (char )'3',      (char )'[',      (char )':', 
        (char )'<',      (char )'r',      (char )'a',      (char )'t', 
        (char )'e',      (char )'>',      (char )']',      (char )'|', 
        (char )'f',      (char )'l',      (char )'c',      (char )'[', 
        (char )':',      (char )'0',      (char )'.',      (char )'.', 
        (char )'9',      (char )']',      (char )'|',      (char )'w', 
        (char )'a',      (char )'v',      (char )'|',      (char )'p', 
        (char )'c',      (char )'m',      (char )'>',      (char )'\t', 
        (char )'a',      (char )'u',      (char )'d',      (char )'i', 
        (char )'o',      (char )' ',      (char )'f',      (char )'o', 
        (char )'r',      (char )'m',      (char )'a',      (char )'t', 
        (char )' ',      (char )'s',      (char )'e',      (char )'n', 
        (char )'d',      (char )' ',      (char )'t',      (char )'o', 
        (char )' ',      (char )'p',      (char )'l',      (char )'a', 
        (char )'y',      (char )'e',      (char )'r',      (char )'\n', 
        (char )' ',      (char )' ',      (char )'-',      (char )'g', 
        (char )' ',      (char )'<',      (char )'-',      (char )'3', 
        (char )'|',      (char )'-',      (char )'1',      (char )'|', 
        (char )'0',      (char )'>',      (char )'\t',      (char )'\t', 
        (char )'H',      (char )'T',      (char )'T',      (char )'P', 
        (char )' ',      (char )'c',      (char )'o',      (char )'n', 
        (char )'t',      (char )'e',      (char )'n',      (char )'t', 
        (char )'-',      (char )'l',      (char )'e',      (char )'n', 
        (char )'g',      (char )'t',      (char )'h',      (char )' ', 
        (char )'m',      (char )'o',      (char )'d',      (char )'e', 
        (char )' ',      (char )'(',      (char )'-',      (char )'3', 
        (char )':',      (char )'c',      (char )'h',      (char )'u', 
        (char )'n',      (char )'k',      (char )'e',      (char )'d', 
        (char )',',      (char )' ',      (char )'-',      (char )'1', 
        (char )':',      (char )'n',      (char )'o',      (char )'n', 
        (char )'e',      (char )',',      (char )' ',      (char )'0', 
        (char )':',      (char )'f',      (char )'i',      (char )'x', 
        (char )'e',      (char )'d',      (char )')',      (char )'\n', 
        (char )' ',      (char )' ',      (char )'-',      (char )'u', 
        (char )' ',      (char )'<',      (char )'v',      (char )'e', 
        (char )'r',      (char )'s',      (char )'i',      (char )'o', 
        (char )'n',      (char )'>',      (char )'\t',      (char )'s', 
        (char )'e',      (char )'t',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'m', 
        (char )'a',      (char )'x',      (char )'i',      (char )'m', 
        (char )'u',      (char )'m',      (char )' ',      (char )'U', 
        (char )'P',      (char )'n',      (char )'P',      (char )' ', 
        (char )'v',      (char )'e',      (char )'r',      (char )'s', 
        (char )'i',      (char )'o',      (char )'n',      (char )' ', 
        (char )'f',      (char )'o',      (char )'r',      (char )' ', 
        (char )'s',      (char )'e',      (char )'a',      (char )'r', 
        (char )'c',      (char )'h',      (char )' ',      (char )'(', 
        (char )'d',      (char )'e',      (char )'f',      (char )'a', 
        (char )'u',      (char )'l',      (char )'t',      (char )' ', 
        (char )'1',      (char )')',      (char )'\n',      (char )' ', 
        (char )' ',      (char )'-',      (char )'x',      (char )' ', 
        (char )'<',      (char )'c',      (char )'o',      (char )'n', 
        (char )'f',      (char )'i',      (char )'g',      (char )' ', 
        (char )'f',      (char )'i',      (char )'l',      (char )'e', 
        (char )'>',      (char )'\t',      (char )'r',      (char )'e', 
        (char )'a',      (char )'d',      (char )' ',      (char )'c', 
        (char )'o',      (char )'n',      (char )'f',      (char )'i', 
        (char )'g',      (char )' ',      (char )'f',      (char )'r', 
        (char )'o',      (char )'m',      (char )' ',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )' ', 
        (char )'(',      (char )'d',      (char )'e',      (char )'f', 
        (char )'a',      (char )'u',      (char )'l',      (char )'t', 
        (char )' ',      (char )'i',      (char )'s',      (char )' ', 
        (char )'.',      (char )'/',      (char )'c',      (char )'o', 
        (char )'n',      (char )'f',      (char )'i',      (char )'g', 
        (char )'.',      (char )'x',      (char )'m',      (char )'l', 
        (char )')',      (char )'\n',      (char )' ',      (char )' ', 
        (char )'-',      (char )'i',      (char )' ',      (char )'<', 
        (char )'c',      (char )'o',      (char )'n',      (char )'f', 
        (char )'i',      (char )'g',      (char )' ',      (char )'f', 
        (char )'i',      (char )'l',      (char )'e',      (char )'>', 
        (char )'\t',      (char )'d',      (char )'i',      (char )'s', 
        (char )'c',      (char )'o',      (char )'v',      (char )'e', 
        (char )'r',      (char )' ',      (char )'p',      (char )'l', 
        (char )'a',      (char )'y',      (char )'e',      (char )'r', 
        (char )'s',      (char )',',      (char )' ',      (char )'s', 
        (char )'a',      (char )'v',      (char )'e',      (char )' ', 
        (char )'<',      (char )'c',      (char )'o',      (char )'n', 
        (char )'f',      (char )'i',      (char )'g',      (char )' ', 
        (char )'f',      (char )'i',      (char )'l',      (char )'e', 
        (char )'>',      (char )' ',      (char )'a',      (char )'n', 
        (char )'d',      (char )' ',      (char )'e',      (char )'x', 
        (char )'i',      (char )'t',      (char )'\n',      (char )' ', 
        (char )' ',      (char )'-',      (char )'I',      (char )' ', 
        (char )'\t',      (char )'\t',      (char )'\t',      (char )'a', 
        (char )'u',      (char )'t',      (char )'o',      (char )' ', 
        (char )'s',      (char )'a',      (char )'v',      (char )'e', 
        (char )' ',      (char )'c',      (char )'o',      (char )'n', 
        (char )'f',      (char )'i',      (char )'g',      (char )' ', 
        (char )'a',      (char )'t',      (char )' ',      (char )'e', 
        (char )'v',      (char )'e',      (char )'r',      (char )'y', 
        (char )' ',      (char )'n',      (char )'e',      (char )'t', 
        (char )'w',      (char )'o',      (char )'r',      (char )'k', 
        (char )' ',      (char )'s',      (char )'c',      (char )'a', 
        (char )'n',      (char )'\n',      (char )' ',      (char )' ', 
        (char )'-',      (char )'l',      (char )' ',      (char )'<', 
        (char )'[',      (char )'r',      (char )'t',      (char )'p', 
        (char )']',      (char )'[',      (char )':',      (char )'h', 
        (char )'t',      (char )'t',      (char )'p',      (char )']', 
        (char )'[',      (char )':',      (char )'f',      (char )']', 
        (char )'>',      (char )'\t',      (char )'R',      (char )'T', 
        (char )'P',      (char )' ',      (char )'a',      (char )'n', 
        (char )'d',      (char )' ',      (char )'H',      (char )'T', 
        (char )'T',      (char )'P',      (char )' ',      (char )'l', 
        (char )'a',      (char )'t',      (char )'e',      (char )'n', 
        (char )'c',      (char )'y',      (char )' ',      (char )'(', 
        (char )'m',      (char )'s',      (char )')',      (char )',', 
        (char )' ',      (char )'\'',      (char )':',      (char )'f', 
        (char )'\'',      (char )' ',      (char )'f',      (char )'o', 
        (char )'r',      (char )'c',      (char )'e',      (char )'s', 
        (char )' ',      (char )'s',      (char )'i',      (char )'l', 
        (char )'e',      (char )'n',      (char )'c',      (char )'e', 
        (char )' ',      (char )'f',      (char )'i',      (char )'l', 
        (char )'l',      (char )'\n',      (char )' ',      (char )' ', 
        (char )'-',      (char )'r',      (char )' ',      (char )'\t', 
        (char )'\t',      (char )'\t',      (char )'l',      (char )'e', 
        (char )'t',      (char )' ',      (char )'t',      (char )'i', 
        (char )'m',      (char )'i',      (char )'n',      (char )'g', 
        (char )' ',      (char )'r',      (char )'e',      (char )'f', 
        (char )'e',      (char )'r',      (char )'e',      (char )'n', 
        (char )'c',      (char )'e',      (char )' ',      (char )'d', 
        (char )'r',      (char )'i',      (char )'f',      (char )'t', 
        (char )' ',      (char )'(',      (char )'n',      (char )'o', 
        (char )' ',      (char )'c',      (char )'l',      (char )'i', 
        (char )'c',      (char )'k',      (char )')',      (char )'\n', 
        (char )' ',      (char )' ',      (char )'-',      (char )'f', 
        (char )' ',      (char )'<',      (char )'l',      (char )'o', 
        (char )'g',      (char )'f',      (char )'i',      (char )'l', 
        (char )'e',      (char )'>',      (char )'\t',      (char )'\t', 
        (char )'w',      (char )'r',      (char )'i',      (char )'t', 
        (char )'e',      (char )' ',      (char )'d',      (char )'e', 
        (char )'b',      (char )'u',      (char )'g',      (char )' ', 
        (char )'t',      (char )'o',      (char )' ',      (char )'l', 
        (char )'o',      (char )'g',      (char )'f',      (char )'i', 
        (char )'l',      (char )'e',      (char )'\n',      (char )' ', 
        (char )' ',      (char )'-',      (char )'p',      (char )' ', 
        (char )'<',      (char )'p',      (char )'i',      (char )'d', 
        (char )' ',      (char )'f',      (char )'i',      (char )'l', 
        (char )'e',      (char )'>',      (char )'\t',      (char )'\t', 
        (char )'w',      (char )'r',      (char )'i',      (char )'t', 
        (char )'e',      (char )' ',      (char )'P',      (char )'I', 
        (char )'D',      (char )' ',      (char )'i',      (char )'n', 
        (char )' ',      (char )'f',      (char )'i',      (char )'l', 
        (char )'e',      (char )'\n',      (char )' ',      (char )' ', 
        (char )'-',      (char )'m',      (char )' ',      (char )'<', 
        (char )'n',      (char )'1',      (char )',',      (char )'n', 
        (char )'2',      (char )'.',      (char )'.',      (char )'.', 
        (char )'>',      (char )'\t',      (char )'\t',      (char )'e', 
        (char )'x',      (char )'c',      (char )'l',      (char )'u', 
        (char )'d',      (char )'e',      (char )' ',      (char )'d', 
        (char )'e',      (char )'v',      (char )'i',      (char )'c', 
        (char )'e',      (char )'s',      (char )' ',      (char )'w', 
        (char )'h',      (char )'o',      (char )'s',      (char )'e', 
        (char )' ',      (char )'m',      (char )'o',      (char )'d', 
        (char )'e',      (char )'l',      (char )' ',      (char )'i', 
        (char )'n',      (char )'c',      (char )'l',      (char )'u', 
        (char )'d',      (char )'e',      (char )' ',      (char )'t', 
        (char )'o',      (char )'k',      (char )'e',      (char )'n', 
        (char )'s',      (char )'\n',      (char )' ',      (char )' ', 
        (char )'-',      (char )'n',      (char )' ',      (char )'<', 
        (char )'m',      (char )'1',      (char )',',      (char )'m', 
        (char )'2',      (char )',',      (char )'.',      (char )'.', 
        (char )'.',      (char )'>',      (char )'\t',      (char )'e', 
        (char )'x',      (char )'c',      (char )'l',      (char )'u', 
        (char )'d',      (char )'e',      (char )' ',      (char )'d', 
        (char )'e',      (char )'v',      (char )'i',      (char )'c', 
        (char )'e',      (char )'s',      (char )' ',      (char )'w', 
        (char )'h',      (char )'o',      (char )'s',      (char )'e', 
        (char )' ',      (char )'n',      (char )'a',      (char )'m', 
        (char )'e',      (char )' ',      (char )'i',      (char )'n', 
        (char )'c',      (char )'l',      (char )'u',      (char )'d', 
        (char )'e',      (char )'s',      (char )' ',      (char )'t', 
        (char )'o',      (char )'k',      (char )'e',      (char )'n', 
        (char )'s',      (char )'\n',      (char )' ',      (char )' ', 
        (char )'-',      (char )'o',      (char )' ',      (char )'<', 
        (char )'m',      (char )'1',      (char )',',      (char )'m', 
        (char )'2',      (char )',',      (char )'.',      (char )'.', 
        (char )'.',      (char )'>',      (char )'\t',      (char )'i', 
        (char )'n',      (char )'c',      (char )'l',      (char )'u', 
        (char )'d',      (char )'e',      (char )' ',      (char )'o', 
        (char )'n',      (char )'l',      (char )'y',      (char )' ', 
        (char )'l',      (char )'i',      (char )'s',      (char )'t', 
        (char )'e',      (char )'d',      (char )' ',      (char )'m', 
        (char )'o',      (char )'d',      (char )'e',      (char )'l', 
        (char )'s',      (char )';',      (char )' ',      (char )'o', 
        (char )'v',      (char )'e',      (char )'r',      (char )'r', 
        (char )'i',      (char )'d',      (char )'e',      (char )'s', 
        (char )' ',      (char )'-',      (char )'m',      (char )' ', 
        (char )'a',      (char )'n',      (char )'d',      (char )' ', 
        (char )'-',      (char )'n',      (char )' ',      (char )'(', 
        (char )'u',      (char )'s',      (char )'e',      (char )' ', 
        (char )'<',      (char )'N',      (char )'U',      (char )'L', 
        (char )'L',      (char )'>',      (char )' ',      (char )'i', 
        (char )'f',      (char )' ',      (char )'p',      (char )'l', 
        (char )'a',      (char )'y',      (char )'e',      (char )'r', 
        (char )' ',      (char )'d',      (char )'o',      (char )'n', 
        (char )'\'',      (char )'t',      (char )' ',      (char )'r', 
        (char )'e',      (char )'t',      (char )'u',      (char )'r', 
        (char )'n',      (char )' ',      (char )'a',      (char )' ', 
        (char )'m',      (char )'o',      (char )'d',      (char )'e', 
        (char )'l',      (char )')',      (char )'\n',      (char )' ', 
        (char )' ',      (char )'-',      (char )'d',      (char )' ', 
        (char )'<',      (char )'l',      (char )'o',      (char )'g', 
        (char )'>',      (char )'=',      (char )'<',      (char )'l', 
        (char )'e',      (char )'v',      (char )'e',      (char )'l', 
        (char )'>',      (char )'\t',      (char )'S',      (char )'e', 
        (char )'t',      (char )' ',      (char )'l',      (char )'o', 
        (char )'g',      (char )'g',      (char )'i',      (char )'n', 
        (char )'g',      (char )' ',      (char )'l',      (char )'e', 
        (char )'v',      (char )'e',      (char )'l',      (char )',', 
        (char )' ',      (char )'l',      (char )'o',      (char )'g', 
        (char )'s',      (char )':',      (char )' ',      (char )'a', 
        (char )'l',      (char )'l',      (char )'|',      (char )'r', 
        (char )'a',      (char )'o',      (char )'p',      (char )'|', 
        (char )'m',      (char )'a',      (char )'i',      (char )'n', 
        (char )'|',      (char )'u',      (char )'t',      (char )'i', 
        (char )'l',      (char )'|',      (char )'u',      (char )'p', 
        (char )'n',      (char )'p',      (char )',',      (char )' ', 
        (char )'l',      (char )'e',      (char )'v',      (char )'e', 
        (char )'l',      (char )':',      (char )' ',      (char )'e', 
        (char )'r',      (char )'r',      (char )'o',      (char )'r', 
        (char )'|',      (char )'w',      (char )'a',      (char )'r', 
        (char )'n',      (char )'|',      (char )'i',      (char )'n', 
        (char )'f',      (char )'o',      (char )'|',      (char )'d', 
        (char )'e',      (char )'b',      (char )'u',      (char )'g', 
        (char )'|',      (char )'s',      (char )'d',      (char )'e', 
        (char )'b',      (char )'u',      (char )'g',      (char )'\n', 
        (char )' ',      (char )' ',      (char )'-',      (char )'z', 
        (char )' ',      (char )'\t',      (char )'\t',      (char )'\t', 
        (char )'D',      (char )'a',      (char )'e',      (char )'m', 
        (char )'o',      (char )'n',      (char )'i',      (char )'z', 
        (char )'e',      (char )'\n',      (char )' ',      (char )' ', 
        (char )'-',      (char )'Z',      (char )' ',      (char )'\t', 
        (char )'\t',      (char )'\t',      (char )'N',      (char )'O', 
        (char )'T',      (char )' ',      (char )'i',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'a', 
        (char )'c',      (char )'t',      (char )'i',      (char )'v', 
        (char )'e',      (char )'\n',      (char )' ',      (char )' ', 
        (char )'-',      (char )'k',      (char )' ',      (char )'\t', 
        (char )'\t',      (char )'\t',      (char )'I',      (char )'m', 
        (char )'m',      (char )'e',      (char )'d',      (char )'i', 
        (char )'a',      (char )'t',      (char )'e',      (char )' ', 
        (char )'e',      (char )'x',      (char )'i',      (char )'t', 
        (char )' ',      (char )'o',      (char )'n',      (char )' ', 
        (char )'S',      (char )'I',      (char )'G',      (char )'Q', 
        (char )'U',      (char )'I',      (char )'T',      (char )' ', 
        (char )'a',      (char )'n',      (char )'d',      (char )' ', 
        (char )'S',      (char )'I',      (char )'G',      (char )'T', 
        (char )'E',      (char )'R',      (char )'M',      (char )'\n', 
        (char )' ',      (char )' ',      (char )'-',      (char )'t', 
        (char )' ',      (char )'\t',      (char )'\t',      (char )'\t', 
        (char )'L',      (char )'i',      (char )'c',      (char )'e', 
        (char )'n',      (char )'s',      (char )'e',      (char )' ', 
        (char )'t',      (char )'e',      (char )'r',      (char )'m', 
        (char )'s',      (char )'\n',      (char )' ',      (char )' ', 
        (char )'-',      (char )'-',      (char )'n',      (char )'o', 
        (char )'f',      (char )'l',      (char )'u',      (char )'s', 
        (char )'h',      (char )'\t',      (char )'\t',      (char )'i', 
        (char )'g',      (char )'n',      (char )'o',      (char )'r', 
        (char )'e',      (char )' ',      (char )'f',      (char )'l', 
        (char )'u',      (char )'s',      (char )'h',      (char )' ', 
        (char )'c',      (char )'o',      (char )'m',      (char )'m', 
        (char )'a',      (char )'n',      (char )'d',      (char )' ', 
        (char )'(',      (char )'w',      (char )'a',      (char )'i', 
        (char )'t',      (char )' ',      (char )'f',      (char )'o', 
        (char )'r',      (char )' ',      (char )'t',      (char )'e', 
        (char )'a',      (char )'r',      (char )'d',      (char )'o', 
        (char )'w',      (char )'n',      (char )' ',      (char )'t', 
        (char )'o',      (char )' ',      (char )'s',      (char )'t', 
        (char )'o',      (char )'p',      (char )')',      (char )'\n', 
        (char )'\n',      (char )'B',      (char )'u',      (char )'i', 
        (char )'l',      (char )'d',      (char )' ',      (char )'o', 
        (char )'p',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )'s',      (char )':',      (char )' ', 
        (char )'L',      (char )'I',      (char )'N',      (char )'U', 
        (char )'X',      (char )'\n',      (char )'\n',      (char )'\000'};
static char license[614]  = 
  {      (char )'T',      (char )'h',      (char )'i',      (char )'s', 
        (char )' ',      (char )'p',      (char )'r',      (char )'o', 
        (char )'g',      (char )'r',      (char )'a',      (char )'m', 
        (char )' ',      (char )'i',      (char )'s',      (char )' ', 
        (char )'f',      (char )'r',      (char )'e',      (char )'e', 
        (char )' ',      (char )'s',      (char )'o',      (char )'f', 
        (char )'t',      (char )'w',      (char )'a',      (char )'r', 
        (char )'e',      (char )':',      (char )' ',      (char )'y', 
        (char )'o',      (char )'u',      (char )' ',      (char )'c', 
        (char )'a',      (char )'n',      (char )' ',      (char )'r', 
        (char )'e',      (char )'d',      (char )'i',      (char )'s', 
        (char )'t',      (char )'r',      (char )'i',      (char )'b', 
        (char )'u',      (char )'t',      (char )'e',      (char )' ', 
        (char )'i',      (char )'t',      (char )' ',      (char )'a', 
        (char )'n',      (char )'d',      (char )'/',      (char )'o', 
        (char )'r',      (char )' ',      (char )'m',      (char )'o', 
        (char )'d',      (char )'i',      (char )'f',      (char )'y', 
        (char )'\n',      (char )'i',      (char )'t',      (char )' ', 
        (char )'u',      (char )'n',      (char )'d',      (char )'e', 
        (char )'r',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'t',      (char )'e', 
        (char )'r',      (char )'m',      (char )'s',      (char )' ', 
        (char )'o',      (char )'f',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'G', 
        (char )'N',      (char )'U',      (char )' ',      (char )'G', 
        (char )'e',      (char )'n',      (char )'e',      (char )'r', 
        (char )'a',      (char )'l',      (char )' ',      (char )'P', 
        (char )'u',      (char )'b',      (char )'l',      (char )'i', 
        (char )'c',      (char )' ',      (char )'L',      (char )'i', 
        (char )'c',      (char )'e',      (char )'n',      (char )'s', 
        (char )'e',      (char )' ',      (char )'a',      (char )'s', 
        (char )' ',      (char )'p',      (char )'u',      (char )'b', 
        (char )'l',      (char )'i',      (char )'s',      (char )'h', 
        (char )'e',      (char )'d',      (char )' ',      (char )'b', 
        (char )'y',      (char )'\n',      (char )'t',      (char )'h', 
        (char )'e',      (char )' ',      (char )'F',      (char )'r', 
        (char )'e',      (char )'e',      (char )' ',      (char )'S', 
        (char )'o',      (char )'f',      (char )'t',      (char )'w', 
        (char )'a',      (char )'r',      (char )'e',      (char )' ', 
        (char )'F',      (char )'o',      (char )'u',      (char )'n', 
        (char )'d',      (char )'a',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )',',      (char )' ', 
        (char )'e',      (char )'i',      (char )'t',      (char )'h', 
        (char )'e',      (char )'r',      (char )' ',      (char )'v', 
        (char )'e',      (char )'r',      (char )'s',      (char )'i', 
        (char )'o',      (char )'n',      (char )' ',      (char )'3', 
        (char )' ',      (char )'o',      (char )'f',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'L',      (char )'i',      (char )'c',      (char )'e', 
        (char )'n',      (char )'s',      (char )'e',      (char )',', 
        (char )' ',      (char )'o',      (char )'r',      (char )'\n', 
        (char )'(',      (char )'a',      (char )'t',      (char )' ', 
        (char )'y',      (char )'o',      (char )'u',      (char )'r', 
        (char )' ',      (char )'o',      (char )'p',      (char )'t', 
        (char )'i',      (char )'o',      (char )'n',      (char )')', 
        (char )' ',      (char )'a',      (char )'n',      (char )'y', 
        (char )' ',      (char )'l',      (char )'a',      (char )'t', 
        (char )'e',      (char )'r',      (char )' ',      (char )'v', 
        (char )'e',      (char )'r',      (char )'s',      (char )'i', 
        (char )'o',      (char )'n',      (char )'.',      (char )'\n', 
        (char )'\n',      (char )'T',      (char )'h',      (char )'i', 
        (char )'s',      (char )' ',      (char )'p',      (char )'r', 
        (char )'o',      (char )'g',      (char )'r',      (char )'a', 
        (char )'m',      (char )' ',      (char )'i',      (char )'s', 
        (char )' ',      (char )'d',      (char )'i',      (char )'s', 
        (char )'t',      (char )'r',      (char )'i',      (char )'b', 
        (char )'u',      (char )'t',      (char )'e',      (char )'d', 
        (char )' ',      (char )'i',      (char )'n',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'h',      (char )'o',      (char )'p',      (char )'e', 
        (char )' ',      (char )'t',      (char )'h',      (char )'a', 
        (char )'t',      (char )' ',      (char )'i',      (char )'t', 
        (char )' ',      (char )'w',      (char )'i',      (char )'l', 
        (char )'l',      (char )' ',      (char )'b',      (char )'e', 
        (char )' ',      (char )'u',      (char )'s',      (char )'e', 
        (char )'f',      (char )'u',      (char )'l',      (char )',', 
        (char )'\n',      (char )'b',      (char )'u',      (char )'t', 
        (char )' ',      (char )'W',      (char )'I',      (char )'T', 
        (char )'H',      (char )'O',      (char )'U',      (char )'T', 
        (char )' ',      (char )'A',      (char )'N',      (char )'Y', 
        (char )' ',      (char )'W',      (char )'A',      (char )'R', 
        (char )'R',      (char )'A',      (char )'N',      (char )'T', 
        (char )'Y',      (char )';',      (char )' ',      (char )'w', 
        (char )'i',      (char )'t',      (char )'h',      (char )'o', 
        (char )'u',      (char )'t',      (char )' ',      (char )'e', 
        (char )'v',      (char )'e',      (char )'n',      (char )' ', 
        (char )'t',      (char )'h',      (char )'e',      (char )' ', 
        (char )'i',      (char )'m',      (char )'p',      (char )'l', 
        (char )'i',      (char )'e',      (char )'d',      (char )' ', 
        (char )'w',      (char )'a',      (char )'r',      (char )'r', 
        (char )'a',      (char )'n',      (char )'t',      (char )'y', 
        (char )' ',      (char )'o',      (char )'f',      (char )'\n', 
        (char )'M',      (char )'E',      (char )'R',      (char )'C', 
        (char )'H',      (char )'A',      (char )'N',      (char )'T', 
        (char )'A',      (char )'B',      (char )'I',      (char )'L', 
        (char )'I',      (char )'T',      (char )'Y',      (char )' ', 
        (char )'o',      (char )'r',      (char )' ',      (char )'F', 
        (char )'I',      (char )'T',      (char )'N',      (char )'E', 
        (char )'S',      (char )'S',      (char )' ',      (char )'F', 
        (char )'O',      (char )'R',      (char )' ',      (char )'A', 
        (char )' ',      (char )'P',      (char )'A',      (char )'R', 
        (char )'T',      (char )'I',      (char )'C',      (char )'U', 
        (char )'L',      (char )'A',      (char )'R',      (char )' ', 
        (char )'P',      (char )'U',      (char )'R',      (char )'P', 
        (char )'O',      (char )'S',      (char )'E',      (char )'.', 
        (char )' ',      (char )' ',      (char )'S',      (char )'e', 
        (char )'e',      (char )' ',      (char )'t',      (char )'h', 
        (char )'e',      (char )'\n',      (char )'G',      (char )'N', 
        (char )'U',      (char )' ',      (char )'G',      (char )'e', 
        (char )'n',      (char )'e',      (char )'r',      (char )'a', 
        (char )'l',      (char )' ',      (char )'P',      (char )'u', 
        (char )'b',      (char )'l',      (char )'i',      (char )'c', 
        (char )' ',      (char )'L',      (char )'i',      (char )'c', 
        (char )'e',      (char )'n',      (char )'s',      (char )'e', 
        (char )' ',      (char )'f',      (char )'o',      (char )'r', 
        (char )' ',      (char )'m',      (char )'o',      (char )'r', 
        (char )'e',      (char )' ',      (char )'d',      (char )'e', 
        (char )'t',      (char )'a',      (char )'i',      (char )'l', 
        (char )'s',      (char )'.',      (char )'\n',      (char )'\n', 
        (char )'Y',      (char )'o',      (char )'u',      (char )' ', 
        (char )'s',      (char )'h',      (char )'o',      (char )'u', 
        (char )'l',      (char )'d',      (char )' ',      (char )'h', 
        (char )'a',      (char )'v',      (char )'e',      (char )' ', 
        (char )'r',      (char )'e',      (char )'c',      (char )'e', 
        (char )'i',      (char )'v',      (char )'e',      (char )'d', 
        (char )' ',      (char )'a',      (char )' ',      (char )'c', 
        (char )'o',      (char )'p',      (char )'y',      (char )' ', 
        (char )'o',      (char )'f',      (char )' ',      (char )'t', 
        (char )'h',      (char )'e',      (char )' ',      (char )'G', 
        (char )'N',      (char )'U',      (char )' ',      (char )'G', 
        (char )'e',      (char )'n',      (char )'e',      (char )'r', 
        (char )'a',      (char )'l',      (char )' ',      (char )'P', 
        (char )'u',      (char )'b',      (char )'l',      (char )'i', 
        (char )'c',      (char )' ',      (char )'L',      (char )'i', 
        (char )'c',      (char )'e',      (char )'n',      (char )'s', 
        (char )'e',      (char )'\n',      (char )'a',      (char )'l', 
        (char )'o',      (char )'n',      (char )'g',      (char )' ', 
        (char )'w',      (char )'i',      (char )'t',      (char )'h', 
        (char )' ',      (char )'t',      (char )'h',      (char )'i', 
        (char )'s',      (char )' ',      (char )'p',      (char )'r', 
        (char )'o',      (char )'g',      (char )'r',      (char )'a', 
        (char )'m',      (char )'.',      (char )' ',      (char )' ', 
        (char )'I',      (char )'f',      (char )' ',      (char )'n', 
        (char )'o',      (char )'t',      (char )',',      (char )' ', 
        (char )'s',      (char )'e',      (char )'e',      (char )' ', 
        (char )'<',      (char )'h',      (char )'t',      (char )'t', 
        (char )'p',      (char )':',      (char )'/',      (char )'/', 
        (char )'w',      (char )'w',      (char )'w',      (char )'.', 
        (char )'g',      (char )'n',      (char )'u',      (char )'.', 
        (char )'o',      (char )'r',      (char )'g',      (char )'/', 
        (char )'l',      (char )'i',      (char )'c',      (char )'e', 
        (char )'n',      (char )'s',      (char )'e',      (char )'s', 
        (char )'/',      (char )'>',      (char )'.',      (char )'\n', 
        (char )'\n',      (char )'\000'};
static void *MRThread(void *args ) ;
static void *UpdateThread(void *args ) ;
static _Bool AddMRDevice(struct sMR *Device , char *UDN , IXML_Document *DescDoc ,
                         char const   *location ) ;
static _Bool isExcluded(char *Model , char *ModelNumber ) ;
static _Bool Start(_Bool cold ) ;
static _Bool Stop(_Bool exit___0 ) ;
static _Bool _ProcessQueue(struct sMR *Device ) ;
static void *MRThread(void *args ) 
{ 
  int elapsed ;
  int wakeTimer ;
  unsigned int last ;
  struct sMR *p ;
  u32_t tmp ;
  char const   *tmp___0 ;
  u8_t *tmp___1 ;
  u8_t *tmp___2 ;

  {
  wakeTimer = 500;
  p = (struct sMR *)args;
  last = gettime_ms();
  while (p->Running) {
    tmp = gettime_ms();
    elapsed = (int )(tmp - last);
    pthread_mutex_lock(& p->Mutex);
    if ((unsigned int )p->State != 1U) {
      wakeTimer = 500;
    } else {
      wakeTimer = 5000;
    }
    if ((unsigned int )*loglevel___0 >= 4U) {
      tmp___0 = logtime();
      logprint("%s %s:%d [%p]: UPnP thread timer %d %d\n", tmp___0, "MRThread", 255,
               p, elapsed, wakeTimer);
    }
    p->StatePoll += (unsigned int )elapsed;
    p->TrackPoll += (unsigned int )elapsed;
    if (p->Master) {
      goto sleep;
    } else
    if ((unsigned int )p->RaopState != 1U) {
      if ((unsigned int )p->State == 1U) {
        goto sleep;
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if ((int )p->ErrorCount > 5) {
      goto sleep;
    } else
    if (p->WaitCookie) {
      goto sleep;
    }
    if (p->TrackPoll > 1000U) {
      p->TrackPoll = 0U;
      if ((unsigned int )p->State != 1U) {
        if ((unsigned int )p->State != 3U) {
          tmp___1 = p->seqN;
          (p->seqN) ++;
          AVTCallAction(p, (char *)"GetPositionInfo", (void *)tmp___1);
        }
      }
    }
    if (p->StatePoll > 500U) {
      p->StatePoll = 0U;
      tmp___2 = p->seqN;
      (p->seqN) ++;
      AVTCallAction(p, (char *)"GetTransportInfo", (void *)tmp___2);
    }
    sleep: 
    last = gettime_ms();
    pthread_mutex_unlock(& p->Mutex);
    WakeableSleep((u32_t )wakeTimer);
  }
  return ((void *)0);
}
}
static int count  ;
void HandleRAOP(void *owner , raop_event_t event , void *param ) 
{ 
  struct sMR *Device ;
  _Bool tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char *uri ;
  char *mp3radio ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  double RaopVolume ;
  int GroupVolume ;
  int i ;
  u32_t now ;
  u32_t tmp___9 ;
  u8_t *tmp___10 ;
  char const   *tmp___11 ;
  double Ratio ;
  double tmp___12 ;
  struct sMR *p ;
  u8_t *tmp___13 ;
  char const   *tmp___14 ;

  {
  Device = (struct sMR *)owner;
  tmp = CheckAndLock((struct sMR *)owner);
  if (! tmp) {
    return;
  }
  switch ((unsigned int )event) {
  case 0U: 
  if ((unsigned int )*loglevel___0 >= 2U) {
    tmp___0 = logtime();
    logprint("%s %s:%d [%p]: Stream\n", tmp___0, "HandleRAOP", 300, Device);
  }
  Device->RaopState = event;
  break;
  case 4U: 
  if ((unsigned int )*loglevel___0 >= 2U) {
    tmp___1 = logtime();
    logprint("%s %s:%d [%p]: Stop\n", tmp___1, "HandleRAOP", 305, Device);
  }
  if ((unsigned int )Device->RaopState == 1U) {
    AVTStop(Device);
    Device->ExpectStop = (_Bool)1;
  }
  Device->RaopState = event;
  break;
  case 2U: 
  if (Device->Config.Flush) {
    if ((unsigned int )*loglevel___0 >= 2U) {
      tmp___2 = logtime();
      logprint("%s %s:%d [%p]: Flush\n", tmp___2, "HandleRAOP", 314, Device);
    }
    AVTStop(Device);
    Device->ExpectStop = (_Bool)1;
    Device->RaopState = event;
  }
  break;
  case 1U: 
  mp3radio = (char *)"";
  if ((unsigned int )Device->RaopState != 1U) {
    tmp___4 = strcasestr((char const   *)(Device->Config.Codec), "mp3");
    if (tmp___4) {
      if (Device->Service[3].ControlURL[0]) {
        mp3radio = (char *)"x-rincon-mp3radio://";
        if ((unsigned int )*loglevel___0 >= 2U) {
          tmp___3 = logtime();
          logprint("%s %s:%d [%p]: Sonos live stream\n", tmp___3, "HandleRAOP", 327,
                   Device);
        }
      }
    }
    tmp___5 = count;
    count ++;
    tmp___6 = inet_ntoa(glHost);
    tmp___7 = asprintf((char ** __restrict  )(& uri), (char const   * __restrict  )"%shttp://%s:%u/stream-%u.%s",
                       mp3radio, tmp___6, (int )*((unsigned short *)param), tmp___5,
                       Device->Config.Codec);
    if (tmp___7) {
      tmp___8 = 0;
    } else {
      tmp___8 = 1;
    }
    AVTSetURI(Device, uri, & Device->MetaData, Device->ProtocolInfo);
    if (uri) {
      free((void *)uri);
      uri = (char *)((void *)0);
    }
  }
  AVTPlay(Device);
  Device->RaopState = event;
  break;
  case 5U: 
  RaopVolume = *((double *)param);
  tmp___9 = gettime_ms();
  now = tmp___9;
  if (now < Device->VolumeStampRx + 1000U) {
    break;
  }
  Device->VolumeStampTx = now;
  GroupVolume = CalcGroupVolume(Device);
  if (GroupVolume < 0) {
    Device->Volume = RaopVolume * (double )Device->Config.MaxVolume;
    tmp___10 = Device->seqN;
    (Device->seqN) ++;
    CtrlSetVolume(Device, (u8_t )(Device->Volume + 0.5), (void *)tmp___10);
    if ((unsigned int )*loglevel___0 >= 2U) {
      tmp___11 = logtime();
      logprint("%s %s:%d [%p]: Volume[0..100] %d\n", tmp___11, "HandleRAOP", 363,
               Device, (int )Device->Volume);
    }
  } else {
    if (GroupVolume) {
      tmp___12 = (RaopVolume * (double )Device->Config.MaxVolume) / (double )GroupVolume;
    } else {
      tmp___12 = (double )0;
    }
    Ratio = tmp___12;
    i = 0;
    while (i < glMaxDevices) {
      p = glMRDevices + i;
      if (! p->Running) {
        goto __Cont;
      } else
      if ((unsigned long )p != (unsigned long )Device) {
        if ((unsigned long )p->Master != (unsigned long )Device) {
          goto __Cont;
        }
      }
      if (GroupVolume) {
        if (p->Volume * Ratio < (double )p->Config.MaxVolume) {
          p->Volume *= Ratio;
        } else {
          p->Volume = (double )p->Config.MaxVolume;
        }
      } else {
        p->Volume = RaopVolume * (double )p->Config.MaxVolume;
      }
      tmp___13 = p->seqN;
      (p->seqN) ++;
      CtrlSetVolume(p, (u8_t )(p->Volume + 0.5), (void *)tmp___13);
      if ((unsigned int )*loglevel___0 >= 2U) {
        tmp___14 = logtime();
        logprint("%s %s:%d [%p]: Volume[0..100] %d:%d\n", tmp___14, "HandleRAOP",
                 377, p, (int )p->Volume, GroupVolume);
      }
      __Cont: /* CIL Label */ 
      i ++;
    }
  }
  break;
  default: 
  break;
  }
  pthread_mutex_unlock(& Device->Mutex);
  return;
}
}
void HandleHTTP(void *owner , struct key_data_s *headers , struct key_data_s *response ) 
{ 
  struct sMR *Device ;
  char *p ;
  char *tmp ;

  {
  Device = (struct sMR *)owner;
  tmp = kd_lookup(headers, (char *)"getcontentFeatures.dlna.org");
  if (tmp) {
    p = strcasestr((char const   *)Device->ProtocolInfo, "DLNA.ORG");
    if ((unsigned long )p != (unsigned long )((void *)0)) {
      kd_add(response, (char *)"contentFeatures.dlna.org", p);
    }
  }
  p = kd_lookup(headers, (char *)"transferMode.dlna.org");
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    kd_add(response, (char *)"transferMode.dlna.org", p);
  }
  return;
}
}
static _Bool _ProcessQueue(struct sMR *Device ) 
{ 
  struct sService *Service ;
  tAction *Action ;
  int rc ;
  void *tmp ;
  u8_t *tmp___0 ;
  char const   *tmp___1 ;

  {
  Service = & Device->Service[0];
  rc = 0;
  Device->WaitCookie = (void *)0;
  tmp = QueueExtract(& Device->ActionQueue);
  Action = (tAction *)tmp;
  if ((unsigned long )Action == (unsigned long )((void *)0)) {
    return ((_Bool)0);
  }
  tmp___0 = Device->seqN;
  (Device->seqN) ++;
  Device->WaitCookie = (void *)tmp___0;
  rc = UpnpSendActionAsync(glControlPointHandle, (char const   *)(Service->ControlURL),
                           (char const   *)(Service->Type), (char const   *)((void *)0),
                           (IXML_Document *)Action->ActionNode, & ActionHandler, (void const   *)Device->WaitCookie);
  if (rc != 0) {
    tmp___1 = logtime();
    logprint("%s %s:%d Error in queued UpnpSendActionAsync -- %d\n", tmp___1, "_ProcessQueue",
             422, rc);
  }
  ixmlDocument_free((IXML_Document *)Action->ActionNode);
  free((void *)Action);
  return ((_Bool )(rc == 0));
}
}
static void ProcessEvent(Upnp_EventType EventType , void *_Event , void *Cookie ) 
{ 
  struct Upnp_Event *Event ;
  struct sMR *Device ;
  struct sMR *tmp ;
  IXML_Document *VarDoc ;
  char *r ;
  char *LastChange ;
  _Bool tmp___0 ;
  char const   *tmp___1 ;
  struct sMR *Master ;
  struct sMR *tmp___2 ;
  double Volume ;
  int tmp___3 ;
  double GroupVolume ;
  u32_t now ;
  u32_t tmp___4 ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;

  {
  Event = (struct Upnp_Event *)_Event;
  tmp = SID2Device((char *)(Event->Sid));
  Device = tmp;
  VarDoc = Event->ChangedVariables;
  r = (char *)((void *)0);
  LastChange = (char *)((void *)0);
  tmp___0 = CheckAndLock(Device);
  if (! tmp___0) {
    return;
  }
  LastChange = XMLGetFirstDocumentItem(VarDoc, "LastChange", (_Bool)1);
  if (! Device->Raop) {
    if (! Device->Master) {
      goto _L;
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if (! LastChange) {
    _L: /* CIL Label */ 
    if ((unsigned int )*loglevel___0 >= 4U) {
      tmp___1 = logtime();
      logprint("%s %s:%d no RAOP device (yet) or not change for %s\n", tmp___1, "ProcessEvent",
               447, Event->Sid);
    }
    pthread_mutex_unlock(& Device->Mutex);
    if (LastChange) {
      free((void *)LastChange);
      LastChange = (char *)((void *)0);
    }
    return;
  }
  r = XMLGetChangeItem(VarDoc, (char *)"Volume", (char *)"channel", (char *)"Master",
                       (char *)"val");
  if (r) {
    if (Device->Master) {
      tmp___2 = Device->Master;
    } else {
      tmp___2 = Device;
    }
    Master = tmp___2;
    tmp___3 = atoi((char const   *)r);
    Volume = (double )tmp___3;
    tmp___4 = gettime_ms();
    now = tmp___4;
    if (Volume != (double )((int )Device->Volume)) {
      if (now > Master->VolumeStampTx + 1000U) {
        Device->Volume = Volume;
        Master->VolumeStampRx = now;
        tmp___5 = CalcGroupVolume(Master);
        GroupVolume = (double )tmp___5;
        if ((unsigned int )*loglevel___0 >= 2U) {
          if (Device->Master) {
            tmp___6 = "slave";
          } else {
            tmp___6 = "master";
          }
          tmp___7 = logtime();
          logprint("%s %s:%d [%p]: UPnP Volume local change %d:%d (%s)\n", tmp___7,
                   "ProcessEvent", 464, Device, (int )Volume, (int )GroupVolume, tmp___6);
        }
        if (GroupVolume < (double )0) {
          Volume /= (double )Device->Config.MaxVolume;
        } else {
          Volume = GroupVolume / (double )100;
        }
        raop_notify(Master->Raop, (raop_event_t )5, (void *)(& Volume));
      }
    }
  }
  if (r) {
    free((void *)r);
    r = (char *)((void *)0);
  }
  if (LastChange) {
    free((void *)LastChange);
    LastChange = (char *)((void *)0);
  }
  pthread_mutex_unlock(& Device->Mutex);
  return;
}
}
static int recurse  =    0;
int ActionHandler(Upnp_EventType EventType , void *Event , void *Cookie ) 
{ 
  struct sMR *p ;
  char *tmp ;
  char const   *tmp___0 ;
  struct Upnp_Action_Complete *Action ;
  char *r ;
  _Bool tmp___1 ;
  char const   *tmp___2 ;
  char const   *Resp ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;

  {
  p = (struct sMR *)((void *)0);
  if ((unsigned int )*loglevel___0 >= 4U) {
    tmp = uPNPEvent2String(EventType);
    tmp___0 = logtime();
    logprint("%s %s:%d action: %i [%s] [%p] [%u]\n", tmp___0, "ActionHandler", 483,
             (unsigned int )EventType, tmp, Cookie, recurse);
  }
  recurse ++;
  switch ((unsigned int )EventType) {
  case 1U: 
  Action = (struct Upnp_Action_Complete *)Event;
  p = CURL2Device(Action->CtrlUrl);
  tmp___1 = CheckAndLock(p);
  if (! tmp___1) {
    return (0);
  }
  if ((unsigned int )*loglevel___0 >= 4U) {
    tmp___2 = logtime();
    logprint("%s %s:%d [%p]: ac %i %s (cookie %p)\n", tmp___2, "ActionHandler", 495,
             p, (unsigned int )EventType, Action->CtrlUrl, Cookie);
  }
  if (p->WaitCookie) {
    tmp___3 = XMLGetLocalName(Action->ActionResult, 1);
    Resp = tmp___3;
    if ((unsigned int )*loglevel___0 >= 3U) {
      if (Resp) {
        tmp___4 = Resp;
      } else {
        tmp___4 = "<none>";
      }
      tmp___5 = logtime();
      logprint("%s %s:%d [%p]: Waited action %s\n", tmp___5, "ActionHandler", 501,
               p, tmp___4);
    }
    if ((unsigned long )Cookie != (unsigned long )p->WaitCookie) {
      break;
    }
    p->StartCookie = p->WaitCookie;
    _ProcessQueue(p);
    if (Resp) {
      tmp___6 = strcasecmp(Resp, "StopResponse");
      if (tmp___6) {
        tmp___7 = strcasecmp(Resp, "PlayResponse");
        if (tmp___7) {
          tmp___8 = strcasecmp(Resp, "PauseResponse");
          if (! tmp___8) {
            p->State = (enum eMRstate )0;
          }
        } else {
          p->State = (enum eMRstate )0;
        }
      } else {
        p->State = (enum eMRstate )0;
      }
    }
    break;
  }
  if ((unsigned long )Cookie < (unsigned long )p->StartCookie) {
    break;
  }
  r = XMLGetFirstDocumentItem(Action->ActionResult, "CurrentTransportState", (_Bool)1);
  if ((unsigned long )r != (unsigned long )((void *)0)) {
    tmp___16 = strcmp((char const   *)r, "TRANSITIONING");
    if (tmp___16) {
      _L___1: /* CIL Label */ 
      tmp___15 = strcmp((char const   *)r, "STOPPED");
      if (tmp___15) {
        _L___0: /* CIL Label */ 
        tmp___14 = strcmp((char const   *)r, "PLAYING");
        if (tmp___14) {
          _L: /* CIL Label */ 
          tmp___13 = strcmp((char const   *)r, "PAUSED_PLAYBACK");
          if (! tmp___13) {
            if ((unsigned int )p->State != 3U) {
              p->State = (enum eMRstate )3;
              if ((unsigned int )p->RaopState == 1U) {
                raop_notify(p->Raop, (raop_event_t )3, (void *)0);
              }
              if ((unsigned int )*loglevel___0 >= 2U) {
                tmp___12 = logtime();
                logprint("%s %s:%d [%p]: uPNP pause\n", tmp___12, "ActionHandler",
                         544, p);
              }
            }
          }
        } else
        if ((unsigned int )p->State != 2U) {
          p->State = (enum eMRstate )2;
          if ((unsigned int )p->RaopState != 1U) {
            raop_notify(p->Raop, (raop_event_t )1, (void *)0);
          }
          if ((unsigned int )*loglevel___0 >= 2U) {
            tmp___11 = logtime();
            logprint("%s %s:%d [%p]: uPNP playing\n", tmp___11, "ActionHandler", 540,
                     p);
          }
        } else {
          goto _L;
        }
      } else
      if ((unsigned int )p->State != 1U) {
        if ((unsigned int )p->RaopState == 1U) {
          if (! p->ExpectStop) {
            raop_notify(p->Raop, (raop_event_t )4, (void *)0);
          }
        }
        p->State = (enum eMRstate )1;
        p->ExpectStop = (_Bool)0;
        if ((unsigned int )*loglevel___0 >= 2U) {
          tmp___10 = logtime();
          logprint("%s %s:%d [%p]: uPNP stopped\n", tmp___10, "ActionHandler", 536,
                   p);
        }
      } else {
        goto _L___0;
      }
    } else
    if ((unsigned int )p->State != 4U) {
      p->State = (enum eMRstate )4;
      if ((unsigned int )*loglevel___0 >= 2U) {
        tmp___9 = logtime();
        logprint("%s %s:%d [%p]: uPNP transition\n", tmp___9, "ActionHandler", 531,
                 p);
      }
    } else {
      goto _L___1;
    }
  }
  if (r) {
    free((void *)r);
    r = (char *)((void *)0);
  }
  if ((unsigned int )*loglevel___0 >= 4U) {
    tmp___17 = logtime();
    logprint("%s %s:%d Action complete : %i (cookie %p)\n", tmp___17, "ActionHandler",
             550, (unsigned int )EventType, Cookie);
  }
  if (Action->ErrCode != 0) {
    p->ErrorCount = (u16_t )((int )p->ErrorCount + 1);
    tmp___18 = logtime();
    logprint("%s %s:%d Error in action callback -- %d (cookie %p)\n", tmp___18, "ActionHandler",
             554, Action->ErrCode, Cookie);
  } else {
    p->ErrorCount = (u16_t )0;
  }
  break;
  default: 
  break;
  }
  if (p) {
    pthread_mutex_unlock(& p->Mutex);
  }
  recurse --;
  return (0);
}
}
static int recurse___0  =    0;
static int Version  ;
int MasterHandler(Upnp_EventType EventType , void *_Event , void *Cookie ) 
{ 
  char *tmp ;
  char const   *tmp___0 ;
  struct Upnp_Discovery *Event ;
  tUpdate *Update ;
  void *tmp___1 ;
  struct Upnp_Discovery *Event___0 ;
  tUpdate *Update___0 ;
  void *tmp___2 ;
  tUpdate *Update___1 ;
  void *tmp___3 ;
  char SearchTopic[sizeof("urn:schemas-upnp-org:device:MediaRenderer") + 2UL] ;
  int tmp___4 ;
  struct Upnp_Event_Subscribe *Event___1 ;
  struct sService *s ;
  struct sMR *Device ;
  struct sMR *tmp___5 ;
  _Bool tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  struct Upnp_Event_Subscribe *Event___2 ;
  struct sMR *Device___0 ;
  struct sMR *tmp___9 ;
  struct sService *s___0 ;
  _Bool tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;
  char const   *tmp___14 ;
  u32_t tmp___15 ;

  {
  if ((unsigned int )*loglevel___0 >= 4U) {
    tmp = uPNPEvent2String(EventType);
    tmp___0 = logtime();
    logprint("%s %s:%d event: %i [%s] [%p] (recurse %u)\n", tmp___0, "MasterHandler",
             582, (unsigned int )EventType, tmp, Cookie, recurse___0);
  }
  if (! glMainRunning) {
    return (0);
  }
  recurse___0 ++;
  switch ((unsigned int )EventType) {
  case 4U: 
  break;
  case 6U: 
  Event = (struct Upnp_Discovery *)_Event;
  tmp___1 = malloc(sizeof(tUpdate ));
  Update = (tUpdate *)tmp___1;
  Update->Type = (enum __anonenum_Type_248025457 )0;
  Update->Data = strdup((char const   *)(Event->Location));
  QueueInsert(& glUpdateQueue, (void *)Update);
  pthread_cond_signal(& glUpdateCond);
  break;
  case 5U: 
  Event___0 = (struct Upnp_Discovery *)_Event;
  tmp___2 = malloc(sizeof(tUpdate ));
  Update___0 = (tUpdate *)tmp___2;
  Update___0->Type = (enum __anonenum_Type_248025457 )1;
  Update___0->Data = strdup((char const   *)(Event___0->DeviceId));
  QueueInsert(& glUpdateQueue, (void *)Update___0);
  pthread_cond_signal(& glUpdateCond);
  break;
  case 7U: 
  tmp___3 = malloc(sizeof(tUpdate ));
  Update___1 = (tUpdate *)tmp___3;
  Update___1->Type = (enum __anonenum_Type_248025457 )2;
  Update___1->Data = (char *)((void *)0);
  QueueInsert(& glUpdateQueue, (void *)Update___1);
  pthread_cond_signal(& glUpdateCond);
  if (! Cookie) {
    tmp___4 = Version;
    Version ++;
    sprintf((char * __restrict  )(SearchTopic), (char const   * __restrict  )"%s:%i",
            "urn:schemas-upnp-org:device:MediaRenderer", tmp___4 % glMRConfig.UPnPMax + 1);
    UpnpSearchAsync(glControlPointHandle, 20, (char const   *)(SearchTopic), (void const   *)((void *)0));
  }
  break;
  case 9U: 
  ProcessEvent(EventType, _Event, Cookie);
  break;
  case 13U: 
  case 14U: 
  Event___1 = (struct Upnp_Event_Subscribe *)_Event;
  tmp___5 = SID2Device((char *)(Event___1->Sid));
  Device = tmp___5;
  tmp___6 = CheckAndLock(Device);
  if (! tmp___6) {
    break;
  }
  s = EventURL2Service(Event___1->PublisherUrl, Device->Service);
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    tmp___7 = strdup((char const   *)(Device->UDN));
    UpnpSubscribeAsync(glControlPointHandle, (char const   *)(s->EventURL), s->TimeOut,
                       & MasterHandler, (void const   *)((void *)tmp___7));
    if ((unsigned int )*loglevel___0 >= 2U) {
      tmp___8 = logtime();
      logprint("%s %s:%d [%p]: Auto-renewal failed, re-subscribing\n", tmp___8, "MasterHandler",
               646, Device);
    }
  }
  pthread_mutex_unlock(& Device->Mutex);
  break;
  case 11U: 
  case 10U: 
  Event___2 = (struct Upnp_Event_Subscribe *)_Event;
  tmp___9 = UDN2Device((char *)Cookie);
  Device___0 = tmp___9;
  free(Cookie);
  tmp___10 = CheckAndLock(Device___0);
  if (! tmp___10) {
    break;
  }
  s___0 = EventURL2Service(Event___2->PublisherUrl, Device___0->Service);
  if ((unsigned long )s___0 != (unsigned long )((void *)0)) {
    if (Event___2->ErrCode == 0) {
      s___0->Failed = (u32_t )0;
      strcpy((char * __restrict  )(s___0->SID), (char const   * __restrict  )(Event___2->Sid));
      s___0->TimeOut = Event___2->TimeOut;
      if ((unsigned int )*loglevel___0 >= 2U) {
        tmp___11 = logtime();
        logprint("%s %s:%d [%p]: subscribe success\n", tmp___11, "MasterHandler",
                 669, Device___0);
      }
    } else {
      tmp___15 = s___0->Failed;
      (s___0->Failed) ++;
      if (tmp___15 < 3U) {
        if ((unsigned int )*loglevel___0 >= 2U) {
          tmp___12 = logtime();
          logprint("%s %s:%d [%p]: subscribe fail, re-trying %u\n", tmp___12, "MasterHandler",
                   671, Device___0, s___0->Failed);
        }
        tmp___13 = strdup((char const   *)(Device___0->UDN));
        UpnpSubscribeAsync(glControlPointHandle, (char const   *)(s___0->EventURL),
                           s___0->TimeOut, & MasterHandler, (void const   *)((void *)tmp___13));
      } else
      if ((unsigned int )*loglevel___0 >= 1U) {
        tmp___14 = logtime();
        logprint("%s %s:%d [%p]: subscribe fail, volume feedback will not work\n",
                 tmp___14, "MasterHandler", 675, Device___0);
      }
    }
  }
  pthread_mutex_unlock(& Device___0->Mutex);
  break;
  case 3U: 
  case 1U: 
  case 2U: 
  case 12U: 
  case 0U: 
  case 8U: 
  break;
  }
  recurse___0 --;
  return (0);
}
}
static void FreeUpdate(void *_Item ) 
{ 
  tUpdate *Item ;

  {
  Item = (tUpdate *)_Item;
  if (Item->Data) {
    free((void *)Item->Data);
    Item->Data = (char *)((void *)0);
  }
  free((void *)Item);
  return;
}
}
static void *UpdateThread(void *args ) 
{ 
  tUpdate *Update ;
  _Bool Updated ;
  struct sMR *Device ;
  int i ;
  u32_t now ;
  u32_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  _Bool tmp___2 ;
  char const   *tmp___3 ;
  IXML_Document *DescDoc ;
  char *UDN ;
  char *ModelName ;
  char *ModelNumber ;
  int i___0 ;
  int rc ;
  char *tmp___4 ;
  char *friendlyName ;
  struct sMR *Master ;
  struct sMR *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  char const   *tmp___14 ;
  int tmp___15 ;
  char const   *tmp___16 ;
  _Bool tmp___17 ;
  _Bool tmp___18 ;
  char const   *tmp___19 ;
  int tmp___20 ;
  char const   *tmp___21 ;
  _Bool tmp___22 ;
  char const   *tmp___23 ;
  void *tmp___24 ;

  {
  while (glMainRunning) {
    Updated = (_Bool)0;
    pthread_mutex_lock(& glUpdateMutex);
    pthread_cond_wait((pthread_cond_t * __restrict  )(& glUpdateCond), (pthread_mutex_t * __restrict  )(& glUpdateMutex));
    pthread_mutex_unlock(& glUpdateMutex);
    while (1) {
      if (glMainRunning) {
        tmp___24 = QueueExtract(& glUpdateQueue);
        Update = (tUpdate *)tmp___24;
        if (! ((unsigned long )Update != (unsigned long )((void *)0))) {
          break;
        }
      } else {
        break;
      }
      tmp = gettime_ms();
      now = tmp / 1000U;
      if ((unsigned int )Update->Type == 2U) {
        if ((unsigned int )*loglevel___0 >= 3U) {
          tmp___0 = logtime();
          logprint("%s %s:%d Presence checking\n", tmp___0, "UpdateThread", 726, (void *)0);
        }
        i = 0;
        while (i < glMaxDevices) {
          Device = glMRDevices + i;
          if (Device->Running) {
            if ((unsigned int )Device->State != 2U) {
              goto _L___0;
            } else
            if ((unsigned int )Device->RaopState != 1U) {
              _L___0: /* CIL Label */ 
              if ((Device->LastSeen + 120U) - now > 120U) {
                goto _L;
              } else
              if ((int )Device->ErrorCount > 5) {
                _L: /* CIL Label */ 
                pthread_mutex_lock(& Device->Mutex);
                if ((unsigned int )*loglevel___0 >= 2U) {
                  tmp___1 = logtime();
                  logprint("%s %s:%d [%p]: removing unresponsive player (%s)\n", tmp___1,
                           "UpdateThread", 735, Device, Device->Config.Name);
                }
                raop_delete(Device->Raop);
                DelMRDevice(Device);
              }
            }
          }
          i ++;
        }
      } else
      if ((unsigned int )Update->Type == 1U) {
        Device = UDN2Device(Update->Data);
        tmp___2 = CheckAndLock(Device);
        if (! tmp___2) {
          goto __Cont;
        }
        if ((unsigned int )*loglevel___0 >= 2U) {
          tmp___3 = logtime();
          logprint("%s %s:%d [%p]: renderer bye-bye: %s\n", tmp___3, "UpdateThread",
                   750, Device, Device->Config.Name);
        }
        raop_delete(Device->Raop);
        DelMRDevice(Device);
      } else
      if ((unsigned int )Update->Type == 0U) {
        DescDoc = (IXML_Document *)((void *)0);
        UDN = (char *)((void *)0);
        ModelName = (char *)((void *)0);
        ModelNumber = (char *)((void *)0);
        tmp___4 = strstr((char const   *)Update->Data, "group_description");
        if (tmp___4) {
          i___0 = 0;
          while (i___0 < glMaxDevices) {
            Device = glMRDevices + i___0;
            if (Device->Running) {
              if (Device->Service[3].ControlURL[0]) {
                UpnpSearchAsync(glControlPointHandle, 5, (char const   *)(Device->UDN),
                                (void const   *)Device);
              }
            }
            i___0 ++;
          }
          goto __Cont;
        }
        i___0 = 0;
        while (i___0 < glMaxDevices) {
          Device = glMRDevices + i___0;
          if (Device->Running) {
            tmp___15 = strcmp((char const   *)(Device->DescDocURL), (char const   *)Update->Data);
            if (! tmp___15) {
              friendlyName = (char *)((void *)0);
              tmp___5 = GetMaster(Device, & friendlyName);
              Master = tmp___5;
              Device->LastSeen = now;
              if ((unsigned int )*loglevel___0 >= 3U) {
                tmp___6 = logtime();
                logprint("%s %s:%d [%p] UPnP keep alive: %s\n", tmp___6, "UpdateThread",
                         779, Device, Device->Config.Name);
              }
              UpnpDownloadXmlDoc((char const   *)Update->Data, & DescDoc);
              if (! friendlyName) {
                friendlyName = XMLGetFirstDocumentItem(DescDoc, "friendlyName", (_Bool)1);
              }
              if (friendlyName) {
                tmp___8 = strcmp((char const   *)friendlyName, (char const   *)(Device->friendlyName));
                if (tmp___8) {
                  tmp___9 = strlen((char const   *)(Device->friendlyName));
                  tmp___10 = strncmp((char const   *)(Device->friendlyName), (char const   *)(Device->Config.Name),
                                     tmp___9);
                  if (! tmp___10) {
                    tmp___11 = strlen((char const   *)(Device->Config.Name));
                    if ((int )Device->Config.Name[tmp___11 - 1UL] == 43) {
                      if ((unsigned int )*loglevel___0 >= 2U) {
                        tmp___7 = logtime();
                        logprint("%s %s:%d [%p]: Device name change %s %s\n", tmp___7,
                                 "UpdateThread", 788, Device, friendlyName, Device->friendlyName);
                      }
                      strcpy((char * __restrict  )(Device->friendlyName), (char const   * __restrict  )friendlyName);
                      sprintf((char * __restrict  )(Device->Config.Name), (char const   * __restrict  )"%s+",
                              friendlyName);
                      raop_update(Device->Raop, Device->Config.Name, (char *)"airupnp");
                      Updated = (_Bool)1;
                    }
                  }
                }
              }
              if (! Master) {
                if (Device->Master) {
                  if ((unsigned int )*loglevel___0 >= 2U) {
                    tmp___12 = logtime();
                    logprint("%s %s:%d [%p]: Sonos %s is now master\n", tmp___12,
                             "UpdateThread", 798, Device, Device->Config.Name);
                  }
                  pthread_mutex_lock(& Device->Mutex);
                  Device->Master = (struct sMR *)((void *)0);
                  if (Device->Config.HTTPLength) {
                    tmp___13 = Device->Config.HTTPLength;
                  } else {
                    tmp___13 = 2147483647;
                  }
                  Device->Raop = raop_create(glHost, glmDNSServer, Device->Config.Name,
                                             (char *)"airupnp", (unsigned char *)(Device->Config.mac),
                                             Device->Config.Codec, Device->Config.Metadata,
                                             Device->Config.Drift, Device->Config.Flush,
                                             Device->Config.Latency, (void *)Device,
                                             & HandleRAOP, & HandleHTTP, glPortBase,
                                             glPortRange, tmp___13);
                  pthread_mutex_unlock(& Device->Mutex);
                } else {
                  goto _L___2;
                }
              } else
              _L___2: /* CIL Label */ 
              if (Master) {
                if (! Device->Master) {
                  goto _L___1;
                } else
                if ((unsigned long )Device->Master == (unsigned long )Device) {
                  _L___1: /* CIL Label */ 
                  pthread_mutex_lock(& Device->Mutex);
                  if ((unsigned int )*loglevel___0 >= 2U) {
                    tmp___14 = logtime();
                    logprint("%s %s:%d [%p]: Sonos %s is now slave\n", tmp___14, "UpdateThread",
                             810, Device, Device->Config.Name);
                  }
                  Device->Master = Master;
                  raop_delete(Device->Raop);
                  Device->Raop = (struct raop_ctx_s *)((void *)0);
                  pthread_mutex_unlock(& Device->Mutex);
                }
              }
              if (friendlyName) {
                free((void *)friendlyName);
                friendlyName = (char *)((void *)0);
              }
              goto cleanup;
            }
          }
          i___0 ++;
        }
        rc = UpnpDownloadXmlDoc((char const   *)Update->Data, & DescDoc);
        if (rc != 0) {
          if ((unsigned int )*loglevel___0 >= 2U) {
            tmp___16 = logtime();
            logprint("%s %s:%d Error obtaining description %s -- error = %d\n\n",
                     tmp___16, "UpdateThread", 824, Update->Data, rc);
          }
          goto cleanup;
        }
        tmp___17 = XMLMatchDocumentItem(DescDoc, "deviceType", "urn:schemas-upnp-org:device:MediaRenderer",
                                        (_Bool)0);
        if (! tmp___17) {
          goto cleanup;
        }
        ModelName = XMLGetFirstDocumentItem(DescDoc, "modelName", (_Bool)1);
        ModelNumber = XMLGetFirstDocumentItem(DescDoc, "modelNumber", (_Bool)1);
        UDN = XMLGetFirstDocumentItem(DescDoc, "UDN", (_Bool)1);
        tmp___18 = isExcluded(ModelName, ModelNumber);
        if (tmp___18) {
          goto cleanup;
        }
        i___0 = 0;
        while (1) {
          if (i___0 < glMaxDevices) {
            if (! (glMRDevices + i___0)->Running) {
              break;
            }
          } else {
            break;
          }
          i___0 ++;
        }
        if (i___0 == glMaxDevices) {
          tmp___19 = logtime();
          logprint("%s %s:%d Too many uPNP devices (max:%u)\n", tmp___19, "UpdateThread",
                   848, glMaxDevices);
          goto cleanup;
        }
        Device = glMRDevices + i___0;
        Updated = (_Bool)1;
        tmp___22 = AddMRDevice(Device, UDN, DescDoc, (char const   *)Update->Data);
        if (tmp___22) {
          if (! glDiscovery) {
            if (Device->Config.HTTPLength) {
              tmp___20 = Device->Config.HTTPLength;
            } else {
              tmp___20 = 2147483647;
            }
            Device->Raop = raop_create(glHost, glmDNSServer, Device->Config.Name,
                                       (char *)"airupnp", (unsigned char *)(Device->Config.mac),
                                       Device->Config.Codec, Device->Config.Metadata,
                                       Device->Config.Drift, Device->Config.Flush,
                                       Device->Config.Latency, (void *)Device, & HandleRAOP,
                                       & HandleHTTP, glPortBase, glPortRange, tmp___20);
            if (! Device->Raop) {
              tmp___21 = logtime();
              logprint("%s %s:%d [%p]: cannot create RAOP instance (%s)\n", tmp___21,
                       "UpdateThread", 864, Device, Device->Config.Name);
              DelMRDevice(Device);
            }
          }
        }
        cleanup: 
        if (Updated) {
          if (glAutoSaveConfigFile) {
            goto _L___3;
          } else
          if (glDiscovery) {
            _L___3: /* CIL Label */ 
            if ((unsigned int )*loglevel___0 >= 3U) {
              tmp___23 = logtime();
              logprint("%s %s:%d Updating configuration %s\n", tmp___23, "UpdateThread",
                       871, glConfigName);
            }
            SaveConfig(glConfigName, glConfigID, (_Bool)0);
          }
        }
        if (UDN) {
          free((void *)UDN);
          UDN = (char *)((void *)0);
        }
        if (ModelName) {
          free((void *)ModelName);
          ModelName = (char *)((void *)0);
        }
        if (ModelNumber) {
          free((void *)ModelNumber);
          ModelNumber = (char *)((void *)0);
        }
        if (DescDoc) {
          ixmlDocument_free(DescDoc);
        }
      }
      __Cont: /* CIL Label */ 
      FreeUpdate((void *)Update);
    }
  }
  return ((void *)0);
}
}
static void *MainThread(void *args ) 
{ 
  u32_t size ;
  long tmp ;
  u32_t Sum ;
  u32_t BufSize ;
  u8_t *buf___0 ;
  void *tmp___0 ;
  FILE *rlog ;
  FILE *tmp___1 ;
  FILE *wlog ;
  FILE *tmp___2 ;
  char const   *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  FILE *tmp___8 ;
  struct in_addr Host ;
  char *tmp___9 ;
  char const   *tmp___10 ;
  char *tmp___11 ;

  {
  while (glMainRunning) {
    WakeableSleep((u32_t )30000);
    if (! glMainRunning) {
      break;
    }
    if (glLogFile) {
      if (glLogLimit != -1) {
        tmp = ftell(stderr);
        size = (u32_t )tmp;
        if (size > (u32_t )((glLogLimit * 1024) * 1024)) {
          BufSize = (u32_t )16384;
          tmp___0 = malloc((size_t )BufSize);
          buf___0 = (u8_t *)tmp___0;
          tmp___1 = fopen((char const   * __restrict  )glLogFile, (char const   * __restrict  )"rb");
          rlog = tmp___1;
          tmp___2 = fopen((char const   * __restrict  )glLogFile, (char const   * __restrict  )"r+b");
          wlog = tmp___2;
          if ((unsigned int )*loglevel___0 >= 3U) {
            tmp___3 = logtime();
            logprint("%s %s:%d Resizing log\n", tmp___3, "MainThread", 904, (void *)0);
          }
          Sum = (u32_t )0;
          fseek(rlog, (long )(size - (u32_t )(((glLogLimit * 1024) * 1024) / 2)),
                0);
          while (1) {
            tmp___4 = fread((void * __restrict  )buf___0, (size_t )1, (size_t )BufSize,
                            (FILE * __restrict  )rlog);
            BufSize = (u32_t )tmp___4;
            if (! (BufSize != 0U)) {
              break;
            }
            Sum += BufSize;
            fwrite((void const   * __restrict  )buf___0, (size_t )1, (size_t )BufSize,
                   (FILE * __restrict  )wlog);
          }
          tmp___5 = fileno(wlog);
          tmp___6 = ftruncate(tmp___5, (__off64_t )Sum);
          Sum = (u32_t )tmp___6;
          fclose(wlog);
          fclose(rlog);
          if (buf___0) {
            free((void *)buf___0);
            buf___0 = (u8_t *)((void *)0);
          }
          tmp___8 = freopen((char const   * __restrict  )glLogFile, (char const   * __restrict  )"a",
                            (FILE * __restrict  )stderr);
          if (! tmp___8) {
            tmp___7 = logtime();
            logprint("%s %s:%d re-open error while truncating log\n", tmp___7, "MainThread",
                     914, (void *)0);
          }
        }
      }
    }
    tmp___11 = strstr((char const   *)(glBinding), "?");
    if (tmp___11) {
      Host.s_addr = get_localhost((char **)((void *)0));
      if (Host.s_addr != 0U) {
        if (Host.s_addr != glHost.s_addr) {
          if ((unsigned int )*loglevel___0 >= 2U) {
            tmp___9 = inet_ntoa(glHost);
            tmp___10 = logtime();
            logprint("%s %s:%d IP change detected %s\n", tmp___10, "MainThread", 924,
                     tmp___9);
          }
          Stop((_Bool)0);
          glMainRunning = (_Bool)1;
          Start((_Bool)0);
        }
      }
    }
  }
  return ((void *)0);
}
}
static _Bool AddMRDevice(struct sMR *Device , char *UDN , IXML_Document *DescDoc ,
                         char const   *location ) 
{ 
  char *friendlyName ;
  int i ;
  unsigned long mac_size ;
  in_addr_t ip ;
  u32_t now ;
  u32_t tmp ;
  char const   *tmp___0 ;
  u32_t tmp___1 ;
  void *tmp___2 ;
  unsigned int tmp___3 ;
  char *ServiceId ;
  char *ServiceType ;
  char *EventURL ;
  char *ControlURL ;
  struct sService *s ;
  char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  u32_t hash ;
  u32_t tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;

  {
  friendlyName = (char *)((void *)0);
  mac_size = 6UL;
  tmp = gettime_ms();
  now = tmp;
  memcpy((void * __restrict  )(& Device->Config), (void const   * __restrict  )(& glMRConfig),
         sizeof(tMRConfig ));
  LoadMRConfig(glConfigID, UDN, & Device->Config);
  if (! Device->Config.Enabled) {
    return ((_Bool)0);
  }
  friendlyName = XMLGetFirstDocumentItem(DescDoc, "friendlyName", (_Bool)1);
  if (friendlyName) {
    strcpy((char * __restrict  )(Device->friendlyName), (char const   * __restrict  )friendlyName);
  }
  if (! friendlyName) {
    friendlyName = strdup((char const   *)UDN);
  } else
  if (! *friendlyName) {
    friendlyName = strdup((char const   *)UDN);
  }
  if ((unsigned int )*loglevel___0 >= 4U) {
    tmp___0 = logtime();
    logprint("%s %s:%d UDN:\t%s\nFriendlyName:\t%s\n", tmp___0, "AddMRDevice", 955,
             UDN, friendlyName);
  }
  Device->Magic = 2864434397U;
  Device->RaopState = (raop_event_t )4;
  Device->State = (enum eMRstate )1;
  Device->LastSeen = now / 1000U;
  tmp___1 = now - 2000U;
  Device->VolumeStampTx = tmp___1;
  Device->VolumeStampRx = tmp___1;
  Device->ExpectStop = (_Bool)0;
  Device->TimeOut = (_Bool)0;
  tmp___2 = (void *)0;
  Device->StartCookie = tmp___2;
  Device->WaitCookie = tmp___2;
  Device->Raop = (struct raop_ctx_s *)((void *)0);
  Device->Elapsed = (u32_t )0;
  Device->seqN = (u8_t *)((void *)0);
  tmp___3 = 0U;
  Device->StatePoll = tmp___3;
  Device->TrackPoll = tmp___3;
  Device->Volume = (double )0;
  Device->Actions = (struct sAction *)((void *)0);
  Device->Master = (struct sMR *)((void *)0);
  strcpy((char * __restrict  )(Device->UDN), (char const   * __restrict  )UDN);
  strcpy((char * __restrict  )(Device->DescDocURL), (char const   * __restrict  )location);
  memset((void *)(& Device->MetaData), 0, sizeof(metadata_t ));
  memset((void *)(& Device->Service), 0, sizeof(struct sService ) * 5UL);
  i = 0;
  while (i < 5) {
    ServiceId = (char *)((void *)0);
    ServiceType = (char *)((void *)0);
    EventURL = (char *)((void *)0);
    ControlURL = (char *)((void *)0);
    strcpy((char * __restrict  )(Device->Service[i].Id), (char const   * __restrict  )"");
    tmp___5 = XMLFindAndParseService(DescDoc, location, (char const   *)(cSearchedSRV[i].name),
                                     & ServiceType, & ServiceId, & EventURL, & ControlURL);
    if (tmp___5) {
      s = & Device->Service[cSearchedSRV[i].idx];
      if ((unsigned int )*loglevel___0 >= 4U) {
        tmp___4 = logtime();
        logprint("%s %s:%d \tservice [%s] %s %s, %s, %s\n", tmp___4, "AddMRDevice",
                 987, cSearchedSRV[i].name, ServiceType, ServiceId, EventURL, ControlURL);
      }
      strncpy((char * __restrict  )(s->Id), (char const   * __restrict  )ServiceId,
              (size_t )249);
      strncpy((char * __restrict  )(s->ControlURL), (char const   * __restrict  )ControlURL,
              (size_t )249);
      strncpy((char * __restrict  )(s->EventURL), (char const   * __restrict  )EventURL,
              (size_t )249);
      strncpy((char * __restrict  )(s->Type), (char const   * __restrict  )ServiceType,
              (size_t )249);
      s->TimeOut = (s32_t )cSearchedSRV[i].TimeOut;
    }
    if (ServiceId) {
      free((void *)ServiceId);
      ServiceId = (char *)((void *)0);
    }
    if (ServiceType) {
      free((void *)ServiceType);
      ServiceType = (char *)((void *)0);
    }
    if (EventURL) {
      free((void *)EventURL);
      EventURL = (char *)((void *)0);
    }
    if (ControlURL) {
      free((void *)ControlURL);
      ControlURL = (char *)((void *)0);
    }
    i ++;
  }
  Device->Master = GetMaster(Device, & friendlyName);
  tmp___6 = CtrlGetVolume(Device);
  Device->Volume = (double )tmp___6;
  if (Device->Master) {
    if ((unsigned int )*loglevel___0 >= 2U) {
      tmp___7 = logtime();
      logprint("%s %s:%d [%p] skipping Sonos slave %s\n", tmp___7, "AddMRDevice",
               1006, Device, friendlyName);
    }
  } else
  if ((unsigned int )*loglevel___0 >= 2U) {
    tmp___8 = logtime();
    logprint("%s %s:%d [%p]: adding renderer (%s)\n", tmp___8, "AddMRDevice", 1008,
             Device, friendlyName);
  }
  if (Device->Service[3].ControlURL[0]) {
    Device->MetaData.duration = (u32_t )1;
    Device->MetaData.title = strdup("Streaming from AirConnect");
  } else {
    Device->MetaData.remote_title = strdup("Streaming from AirConnect");
  }
  if (Device->Config.ArtWork[0]) {
    Device->MetaData.artwork = strdup((char const   *)(Device->Config.ArtWork));
  }
  Device->Running = (_Bool)1;
  if (friendlyName) {
    strcpy((char * __restrict  )(Device->friendlyName), (char const   * __restrict  )friendlyName);
  }
  if (! Device->Config.Name[0]) {
    sprintf((char * __restrict  )(Device->Config.Name), (char const   * __restrict  )"%s+",
            friendlyName);
  }
  QueueInit(& Device->ActionQueue, (_Bool)0, (void (*)(void * ))((void *)0));
  tmp___11 = strcasecmp((char const   *)(Device->Config.Codec), "pcm");
  if (tmp___11) {
    tmp___10 = strcasecmp((char const   *)(Device->Config.Codec), "wav");
    if (tmp___10) {
      tmp___9 = strcasestr((char const   *)(Device->Config.Codec), "mp3");
      if (tmp___9) {
        Device->ProtocolInfo = Device->Config.ProtocolInfo.mp3;
      } else {
        Device->ProtocolInfo = Device->Config.ProtocolInfo.flac;
      }
    } else {
      Device->ProtocolInfo = Device->Config.ProtocolInfo.wav;
    }
  } else {
    Device->ProtocolInfo = Device->Config.ProtocolInfo.pcm;
  }
  ip = ExtractIP(location);
  tmp___15 = memcmp((void const   *)(Device->Config.mac), (void const   *)"\000\000\000\000\000\000",
                    mac_size);
  if (! tmp___15) {
    tmp___14 = SendARP(ip, (in_addr_t )0, Device->Config.mac, & mac_size);
    if (tmp___14) {
      tmp___12 = hash32(UDN);
      hash = tmp___12;
      tmp___13 = logtime();
      logprint("%s %s:%d [%p]: cannot get mac %s, creating fake %x\n", tmp___13, "AddMRDevice",
               1035, Device, Device->Config.Name, hash);
      memcpy((void * __restrict  )(Device->Config.mac + 2), (void const   * __restrict  )(& hash),
             (size_t )4);
    }
    memset((void *)(Device->Config.mac), 187, (size_t )2);
  }
  MakeMacUnique(Device);
  if (friendlyName) {
    free((void *)friendlyName);
    friendlyName = (char *)((void *)0);
  }
  pthread_create((pthread_t * __restrict  )(& Device->Thread), (pthread_attr_t const   * __restrict  )((void *)0),
                 & MRThread, (void * __restrict  )Device);
  i = 0;
  while (i < 5) {
    if (Device->Service[i].TimeOut) {
      tmp___16 = strdup((char const   *)UDN);
      UpnpSubscribeAsync(glControlPointHandle, (char const   *)(Device->Service[i].EventURL),
                         Device->Service[i].TimeOut, & MasterHandler, (void const   *)((void *)tmp___16));
    }
    i ++;
  }
  return ((_Bool )((unsigned long )Device->Master == (unsigned long )((void *)0)));
}
}
static _Bool isExcluded(char *Model , char *ModelNumber ) 
{ 
  char item[256] ;
  char *p ;
  char *q ;
  char *o ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;

  {
  p = glExcluded;
  q = glExcludedModelNumber;
  o = glIncludedModelNumbers;
  if (glIncludedModelNumbers) {
    if (! ModelNumber) {
      tmp = strcasestr((char const   *)glIncludedModelNumbers, "<NULL>");
      if (tmp) {
        return ((_Bool)0);
      } else {
        return ((_Bool)1);
      }
    }
    while (1) {
      sscanf((char const   * __restrict  )o, (char const   * __restrict  )"%[^,]",
             item);
      tmp___0 = strcmp((char const   *)ModelNumber, (char const   *)(item));
      if (! tmp___0) {
        return ((_Bool)0);
      }
      tmp___1 = strlen((char const   *)(item));
      o += tmp___1;
      tmp___2 = o;
      o ++;
      if (! *tmp___2) {
        break;
      }
    }
    return ((_Bool)1);
  }
  if (glExcluded) {
    if (Model) {
      while (1) {
        sscanf((char const   * __restrict  )p, (char const   * __restrict  )"%[^,]",
               item);
        tmp___3 = strcasestr((char const   *)Model, (char const   *)(item));
        if (tmp___3) {
          return ((_Bool)1);
        }
        tmp___4 = strlen((char const   *)(item));
        p += tmp___4;
        tmp___5 = p;
        p ++;
        if (! *tmp___5) {
          break;
        }
      }
    }
  }
  if (glExcludedModelNumber) {
    if (ModelNumber) {
      while (1) {
        sscanf((char const   * __restrict  )q, (char const   * __restrict  )"%[^,]",
               item);
        tmp___6 = strcasestr((char const   *)ModelNumber, (char const   *)(item));
        if (tmp___6) {
          return ((_Bool)1);
        }
        tmp___7 = strlen((char const   *)(item));
        q += tmp___7;
        tmp___8 = q;
        q ++;
        if (! *tmp___8) {
          break;
        }
      }
    }
  }
  return ((_Bool)0);
}
}
static _Bool Start(_Bool cold ) 
{ 
  char hostname[256] ;
  int i ;
  int rc ;
  char IP[16] ;
  unsigned int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  struct in_addr host ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  unsigned short tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  _Bool tmp___7 ;
  void *tmp___8 ;
  char const   *tmp___9 ;
  char SearchTopic[sizeof("urn:schemas-upnp-org:device:MediaRenderer") + 2UL] ;

  {
  IP[0] = (char )'\000';
  tmp = 1U;
  while (! (tmp >= 16U)) {
    IP[tmp] = (char)0;
    tmp ++;
  }
  glHost.s_addr = (in_addr_t )0;
  tmp___0 = strstr((char const   *)(glBinding), "?");
  if (! tmp___0) {
    tmp___1 = sscanf((char const   * __restrict  )(glBinding), (char const   * __restrict  )"%[^:]:%u",
                     IP, & glPort);
    if (! tmp___1) {
      sscanf((char const   * __restrict  )(glBinding), (char const   * __restrict  )":%u",
             & glPort);
    }
  }
  if (! IP[0]) {
    host.s_addr = get_localhost((char **)((void *)0));
    tmp___2 = inet_ntoa(host);
    strcpy((char * __restrict  )(IP), (char const   * __restrict  )tmp___2);
  }
  UpnpSetLogLevel((Upnp_LogLevel )3);
  rc = UpnpInit((char const   *)(IP), (unsigned short )glPort);
  if (rc != 0) {
    tmp___3 = logtime();
    logprint("%s %s:%d UPnP init failed: %d\n", tmp___3, "Start", 1120, rc);
    goto Error;
  }
  UpnpSetMaxContentLength((size_t )60000);
  glHost.s_addr = inet_addr((char const   *)(IP));
  gethostname(glHostName, (size_t )256);
  tmp___4 = UpnpGetServerPort();
  glPort = (u32_t )tmp___4;
  if ((unsigned int )*loglevel___0 >= 2U) {
    tmp___5 = logtime();
    logprint("%s %s:%d Binding to %s:%d\n", tmp___5, "Start", 1130, IP, glPort);
  }
  if (cold) {
    tmp___7 = load_ssl_symbols();
    if (! tmp___7) {
      tmp___6 = logtime();
      logprint("%s %s:%d Cannot load SSL libraries\n", tmp___6, "Start", 1135, (void *)0);
      goto Error;
    }
    InitUtils();
    tmp___8 = calloc((size_t )glMaxDevices, sizeof(struct sMR ));
    glMRDevices = (struct sMR *)tmp___8;
    i = 0;
    while (i < glMaxDevices) {
      pthread_mutex_init(& (glMRDevices + i)->Mutex, (pthread_mutexattr_t const   *)0);
      i ++;
    }
    pthread_create((pthread_t * __restrict  )(& glMainThread), (pthread_attr_t const   * __restrict  )((void *)0),
                   & MainThread, (void * __restrict  )((void *)0));
  }
  if (glHost.s_addr != 0U) {
    pthread_mutex_init(& glUpdateMutex, (pthread_mutexattr_t const   *)0);
    pthread_cond_init((pthread_cond_t * __restrict  )(& glUpdateCond), (pthread_condattr_t const   * __restrict  )0);
    QueueInit(& glUpdateQueue, (_Bool)1, & FreeUpdate);
    pthread_create((pthread_t * __restrict  )(& glUpdateThread), (pthread_attr_t const   * __restrict  )((void *)0),
                   & UpdateThread, (void * __restrict  )((void *)0));
    rc = UpnpRegisterClient(& MasterHandler, (void const   *)((void *)0), & glControlPointHandle);
    if (rc != 0) {
      tmp___9 = logtime();
      logprint("%s %s:%d Error registering ControlPoint: %d\n", tmp___9, "Start",
               1159, rc);
      goto Error;
    }
    snprintf((char * __restrict  )(hostname), (size_t )256, (char const   * __restrict  )"%s.local",
             glHostName);
    glmDNSServer = mdnsd_start(glHost);
    if ((unsigned long )glmDNSServer == (unsigned long )((void *)0)) {
      goto Error;
    }
    mdnsd_set_hostname(glmDNSServer, (char const   *)(hostname), glHost);
    i = 0;
    while (i < glMRConfig.UPnPMax) {
      sprintf((char * __restrict  )(SearchTopic), (char const   * __restrict  )"%s:%i",
              "urn:schemas-upnp-org:device:MediaRenderer", i + 1);
      UpnpSearchAsync(glControlPointHandle, 20, (char const   *)(SearchTopic), (void const   *)((void *)0));
      i ++;
    }
  }
  return ((_Bool)1);
  Error: 
  UpnpFinish();
  return ((_Bool)0);
}
}
static _Bool Stop(_Bool exit___0 ) 
{ 
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
  glMainRunning = (_Bool)0;
  if (glHost.s_addr != 0U) {
    if ((unsigned int )*loglevel___0 >= 2U) {
      tmp = logtime();
      logprint("%s %s:%d terminate update thread ...\n", tmp, "Stop", 1193, (void *)0);
    }
    pthread_cond_signal(& glUpdateCond);
    pthread_join(glUpdateThread, (void **)((void *)0));
    if ((unsigned int )*loglevel___0 >= 2U) {
      tmp___0 = logtime();
      logprint("%s %s:%d flush renderers ...\n", tmp___0, "Stop", 1198, (void *)0);
    }
    FlushMRDevices();
    if ((unsigned int )*loglevel___0 >= 2U) {
      tmp___1 = logtime();
      logprint("%s %s:%d terminate libupnp\n", tmp___1, "Stop", 1201, (void *)0);
    }
    UpnpUnRegisterClient(glControlPointHandle);
    UpnpFinish();
    pthread_mutex_destroy(& glUpdateMutex);
    pthread_cond_destroy(& glUpdateCond);
    QueueFlush(& glUpdateQueue);
    mdnsd_stop(glmDNSServer);
  } else {
    if ((unsigned int )*loglevel___0 >= 2U) {
      tmp___2 = logtime();
      logprint("%s %s:%d terminate libupnp\n", tmp___2, "Stop", 1214, (void *)0);
    }
    UpnpFinish();
  }
  if (exit___0) {
    if ((unsigned int )*loglevel___0 >= 2U) {
      tmp___3 = logtime();
      logprint("%s %s:%d terminate main thread ...\n", tmp___3, "Stop", 1220, (void *)0);
    }
    WakeAll();
    pthread_join(glMainThread, (void **)((void *)0));
    i = 0;
    while (i < glMaxDevices) {
      pthread_mutex_destroy(& (glMRDevices + i)->Mutex);
      i ++;
    }
    EndUtils();
    if (glConfigID) {
      ixmlDocument_free((IXML_Document *)glConfigID);
    }
    free_ssl_symbols();
  }
  return ((_Bool)1);
}
}
static void sighandler(int signum ) 
{ 
  int i ;
  struct sMR *p ;
  char const   *tmp ;

  {
  if (! glGracefullShutdown) {
    i = 0;
    while (i < glMaxDevices) {
      p = glMRDevices + i;
      if (p->Running) {
        if ((unsigned int )p->State == 2U) {
          AVTStop(p);
        }
      }
      i ++;
    }
    if ((unsigned int )*loglevel___0 >= 2U) {
      tmp = logtime();
      logprint("%s %s:%d forced exit\n", tmp, "sighandler", 1250, (void *)0);
    }
    exit(0);
  }
  Stop((_Bool)1);
  exit(0);
}
}
_Bool ParseArgs(int argc , char **argv ) 
{ 
  char *optarg___0 ;
  int i ;
  int optind___0 ;
  char cmdline[256] ;
  unsigned int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *opt ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *l ;
  char *tmp___4 ;
  char *v ;
  char *tmp___5 ;
  log_level new ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;

  {
  optarg___0 = (char *)((void *)0);
  optind___0 = 1;
  cmdline[0] = (char )'\000';
  tmp = 1U;
  while (! (tmp >= 256U)) {
    cmdline[tmp] = (char)0;
    tmp ++;
  }
  i = 0;
  while (1) {
    if (i < argc) {
      tmp___0 = strlen((char const   *)*(argv + i));
      tmp___1 = strlen((char const   *)(cmdline));
      if (! ((tmp___0 + tmp___1) + 2UL < sizeof(cmdline))) {
        break;
      }
    } else {
      break;
    }
    strcat((char * __restrict  )(cmdline), (char const   * __restrict  )*(argv + i));
    strcat((char * __restrict  )(cmdline), (char const   * __restrict  )" ");
    i ++;
  }
  while (1) {
    if (optind___0 < argc) {
      tmp___20 = strlen((char const   *)*(argv + optind___0));
      if (tmp___20 >= 2UL) {
        if (! ((int )*(*(argv + optind___0) + 0) == 45)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    opt = *(argv + optind___0) + 1;
    tmp___3 = strstr("abxdpifmnolcug", (char const   *)opt);
    if (tmp___3) {
      if (optind___0 < argc - 1) {
        optarg___0 = *(argv + (optind___0 + 1));
        optind___0 += 2;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      tmp___2 = strstr("tzZIkr", (char const   *)opt);
      if (tmp___2) {
        optarg___0 = (char *)((void *)0);
        optind___0 ++;
      } else
      if ((int )*(opt + 0) == 45) {
        optarg___0 = (char *)((void *)0);
        optind___0 ++;
      } else {
        printf((char const   * __restrict  )"%s", usage);
        return ((_Bool)0);
      }
    }
    switch ((int )*(opt + 0)) {
    case 98: 
    strcpy((char * __restrict  )(glBinding), (char const   * __restrict  )optarg___0);
    break;
    case 97: 
    sscanf((char const   * __restrict  )optarg___0, (char const   * __restrict  )"%hu:%hu",
           & glPortBase, & glPortRange);
    break;
    case 102: 
    glLogFile = optarg___0;
    break;
    case 99: 
    strcpy((char * __restrict  )(glMRConfig.Codec), (char const   * __restrict  )optarg___0);
    break;
    case 117: 
    glMRConfig.UPnPMax = atoi((char const   *)optarg___0);
    break;
    case 105: 
    strcpy((char * __restrict  )(glConfigName), (char const   * __restrict  )optarg___0);
    glDiscovery = (_Bool)1;
    break;
    case 73: 
    glAutoSaveConfigFile = (_Bool)1;
    break;
    case 112: 
    glPidFile = optarg___0;
    break;
    case 90: 
    glInteractive = (_Bool)0;
    break;
    case 107: 
    glGracefullShutdown = (_Bool)0;
    break;
    case 114: 
    glMRConfig.Drift = (_Bool)1;
    break;
    case 109: 
    glExcluded = optarg___0;
    break;
    case 110: 
    glExcludedModelNumber = optarg___0;
    break;
    case 111: 
    glIncludedModelNumbers = optarg___0;
    break;
    case 108: 
    strcpy((char * __restrict  )(glMRConfig.Latency), (char const   * __restrict  )optarg___0);
    break;
    case 103: 
    glMRConfig.HTTPLength = atoi((char const   *)optarg___0);
    break;
    case 122: 
    glDaemonize = (_Bool)1;
    break;
    case 100: 
    tmp___4 = strtok((char * __restrict  )optarg___0, (char const   * __restrict  )"=");
    l = tmp___4;
    tmp___5 = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )"=");
    v = tmp___5;
    new = (log_level )1;
    if (l) {
      if (v) {
        tmp___6 = strcmp((char const   *)v, "error");
        if (! tmp___6) {
          new = (log_level )0;
        }
        tmp___7 = strcmp((char const   *)v, "warn");
        if (! tmp___7) {
          new = (log_level )1;
        }
        tmp___8 = strcmp((char const   *)v, "info");
        if (! tmp___8) {
          new = (log_level )2;
        }
        tmp___9 = strcmp((char const   *)v, "debug");
        if (! tmp___9) {
          new = (log_level )3;
        }
        tmp___10 = strcmp((char const   *)v, "sdebug");
        if (! tmp___10) {
          new = (log_level )4;
        }
        tmp___11 = strcmp((char const   *)l, "all");
        if (tmp___11) {
          tmp___12 = strcmp((char const   *)l, "raop");
          if (! tmp___12) {
            raop_loglevel = new;
          }
        } else {
          raop_loglevel = new;
        }
        tmp___13 = strcmp((char const   *)l, "all");
        if (tmp___13) {
          tmp___14 = strcmp((char const   *)l, "main");
          if (! tmp___14) {
            main_loglevel = new;
          }
        } else {
          main_loglevel = new;
        }
        tmp___15 = strcmp((char const   *)l, "all");
        if (tmp___15) {
          tmp___16 = strcmp((char const   *)l, "util");
          if (! tmp___16) {
            util_loglevel = new;
          }
        } else {
          util_loglevel = new;
        }
        tmp___17 = strcmp((char const   *)l, "all");
        if (tmp___17) {
          tmp___18 = strcmp((char const   *)l, "upnp");
          if (! tmp___18) {
            upnp_loglevel = new;
          }
        } else {
          upnp_loglevel = new;
        }
      } else {
        printf((char const   * __restrict  )"%s", usage);
        return ((_Bool)0);
      }
    } else {
      printf((char const   * __restrict  )"%s", usage);
      return ((_Bool)0);
    }
    break;
    case 116: 
    printf((char const   * __restrict  )"%s", license);
    return ((_Bool)0);
    case 45: 
    tmp___19 = strcmp((char const   *)(opt + 1), "noflush");
    if (! tmp___19) {
      glMRConfig.Flush = (_Bool)0;
    }
    break;
    default: 
    break;
    }
  }
  return ((_Bool)1);
}
}
int main(int argc , char **argv ) 
{ 
  int i ;
  char resp[20] ;
  unsigned int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  _Bool tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  FILE *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  double tmp___8 ;
  char const   *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  FILE *pid_file ;
  __pid_t tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  _Bool tmp___17 ;
  char level[20] ;
  int tmp___18 ;
  char level___0[20] ;
  int tmp___19 ;
  char level___1[20] ;
  int tmp___20 ;
  char level___2[20] ;
  int tmp___21 ;
  char name[128] ;
  int tmp___22 ;
  u32_t now ;
  u32_t tmp___23 ;
  _Bool all ;
  int tmp___24 ;
  int tmp___25 ;
  struct sMR *p ;
  _Bool Locked ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  char const   *tmp___30 ;
  char const   *tmp___31 ;

  {
  resp[0] = (char )'\000';
  tmp = 1U;
  while (! (tmp >= 20U)) {
    resp[tmp] = (char)0;
    tmp ++;
  }
  signal(2, & sighandler);
  signal(15, & sighandler);
  signal(3, & sighandler);
  signal(1, & sighandler);
  signal(13, (void (*)(int  ))1);
  i = 1;
  while (i < argc) {
    tmp___0 = strcmp((char const   *)*(argv + i), "-x");
    if (! tmp___0) {
      strcpy((char * __restrict  )(glConfigName), (char const   * __restrict  )*(argv + (i + 1)));
    }
    i ++;
  }
  tmp___1 = LoadConfig(glConfigName, & glMRConfig);
  glConfigID = tmp___1;
  tmp___2 = ParseArgs(argc, argv);
  if (! tmp___2) {
    exit(1);
  }
  if (glPortBase) {
    if (! glPortRange) {
      glPortRange = (unsigned short )(glMaxDevices * 4);
    }
  }
  if (glLogFile) {
    tmp___5 = freopen((char const   * __restrict  )glLogFile, (char const   * __restrict  )"a",
                      (FILE * __restrict  )stderr);
    if (! tmp___5) {
      tmp___3 = __errno_location();
      tmp___4 = strerror(*tmp___3);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"error opening logfile %s: %s\n",
              glLogFile, tmp___4);
    }
  }
  tmp___6 = logtime();
  logprint("%s %s:%d Starting airupnp version: %s\n", tmp___6, "main", 1420, "v0.2.51.2 (Aug  3 2022 @ 17:23:46)");
  tmp___8 = strtod((char const   * __restrict  )"0.30", (char ** __restrict  )((void *)0));
  if (tmp___8 != 0.30) {
    tmp___7 = logtime();
    logprint("%s %s:%d Wrong GLIBC version, use -static build\n", tmp___7, "main",
             1423, (void *)0);
    exit(1);
  }
  if (! glConfigID) {
    if ((unsigned int )*loglevel___0 >= 1U) {
      tmp___9 = logtime();
      logprint("%s %s:%d no config file, using defaults\n", tmp___9, "main", 1428,
               (void *)0);
    }
  }
  if (glDiscovery) {
    Start((_Bool)1);
    sleep(21U);
    Stop((_Bool)1);
    return (0);
  }
  if (glDaemonize) {
    if (glLogFile) {
      tmp___12 = 1;
    } else {
      tmp___12 = 0;
    }
    tmp___13 = daemon(1, tmp___12);
    if (tmp___13) {
      tmp___10 = __errno_location();
      tmp___11 = strerror(*tmp___10);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"error daemonizing: %s\n",
              tmp___11);
    }
  }
  if (glPidFile) {
    pid_file = fopen((char const   * __restrict  )glPidFile, (char const   * __restrict  )"wb");
    if (pid_file) {
      tmp___14 = getpid();
      fprintf((FILE * __restrict  )pid_file, (char const   * __restrict  )"%ld", (long )tmp___14);
      fclose(pid_file);
    } else {
      tmp___15 = logtime();
      logprint("%s %s:%d Cannot open PID file %s\n", tmp___15, "main", 1455, glPidFile);
    }
  }
  tmp___17 = Start((_Bool)1);
  if (! tmp___17) {
    tmp___16 = logtime();
    logprint("%s %s:%d Cannot start\n", tmp___16, "main", 1461, (void *)0);
    exit(1);
  }
  while (1) {
    tmp___29 = strcmp((char const   *)(resp), "exit");
    if (! tmp___29) {
      break;
    }
    if (! glDaemonize) {
      if (glInteractive) {
        i = scanf((char const   * __restrict  )"%s", resp);
      } else {
        pause();
      }
    } else {
      pause();
    }
    tmp___18 = strcmp((char const   *)(resp), "raopdbg");
    if (! tmp___18) {
      i = scanf((char const   * __restrict  )"%s", level);
      raop_loglevel = debug2level(level);
    }
    tmp___19 = strcmp((char const   *)(resp), "maindbg");
    if (! tmp___19) {
      i = scanf((char const   * __restrict  )"%s", level___0);
      main_loglevel = debug2level(level___0);
    }
    tmp___20 = strcmp((char const   *)(resp), "utildbg");
    if (! tmp___20) {
      i = scanf((char const   * __restrict  )"%s", level___1);
      util_loglevel = debug2level(level___1);
    }
    tmp___21 = strcmp((char const   *)(resp), "upnpdbg");
    if (! tmp___21) {
      i = scanf((char const   * __restrict  )"%s", level___2);
      upnp_loglevel = debug2level(level___2);
    }
    tmp___22 = strcmp((char const   *)(resp), "save");
    if (! tmp___22) {
      i = scanf((char const   * __restrict  )"%s", name);
      SaveConfig(name, glConfigID, (_Bool)1);
    }
    tmp___27 = strcmp((char const   *)(resp), "dump");
    if (tmp___27) {
      tmp___28 = strcmp((char const   *)(resp), "dumpall");
      if (! tmp___28) {
        _L: /* CIL Label */ 
        tmp___23 = gettime_ms();
        now = tmp___23 / 1000U;
        tmp___24 = strcmp((char const   *)(resp), "dumpall");
        if (tmp___24) {
          tmp___25 = 0;
        } else {
          tmp___25 = 1;
        }
        all = (_Bool )tmp___25;
        i = 0;
        while (i < glMaxDevices) {
          p = glMRDevices + i;
          tmp___26 = pthread_mutex_trylock(& p->Mutex);
          Locked = (_Bool )tmp___26;
          if (! Locked) {
            pthread_mutex_unlock(& p->Mutex);
          }
          if (! p->Running) {
            if (! all) {
              goto __Cont;
            }
          }
          printf((char const   * __restrict  )"%20.20s [r:%u] [l:%u] [s:%u] Last:%u eCnt:%u\n",
                 p->Config.Name, (int )p->Running, (int )Locked, (unsigned int )p->State,
                 now - p->LastSeen, (int )p->ErrorCount);
          __Cont: /* CIL Label */ 
          i ++;
        }
      }
    } else {
      goto _L;
    }
  }
  if ((unsigned int )*loglevel___0 >= 2U) {
    tmp___30 = logtime();
    logprint("%s %s:%d stopping devices ...\n", tmp___30, "main", 1532, (void *)0);
  }
  Stop((_Bool)1);
  if ((unsigned int )*loglevel___0 >= 2U) {
    tmp___31 = logtime();
    logprint("%s %s:%d all done\n", tmp___31, "main", 1534, (void *)0);
  }
  return (1);
}
}
#pragma merger("0","/tmp/cil-DNMVW7sN.i","-Wall,-fPIC,-ggdb,-O2,-m64,-fdata-sections,-ffunction-sections")
extern char const   *ixmlNode_getNodeName(IXML_Node *nodeptr ) ;
extern char const   *ixmlNode_getNodeValue(IXML_Node *nodeptr ) ;
extern IXML_Node *ixmlNode_getFirstChild(IXML_Node *nodeptr ) ;
extern IXML_Node *ixmlNode_getPreviousSibling(IXML_Node *nodeptr ) ;
extern IXML_Node *ixmlNode_getNextSibling(IXML_Node *nodeptr ) ;
extern IXML_NamedNodeMap *ixmlNode_getAttributes(IXML_Node *nodeptr ) ;
extern IXML_NodeList *ixmlDocument_getElementsByTagName(IXML_Document *doc , char const   *tagName ) ;
extern IXML_Element *ixmlDocument_getElementById(IXML_Document *doc , char const   *tagName ) ;
extern char const   *ixmlElement_getAttribute(IXML_Element *element , char const   *name ) ;
extern IXML_NodeList *ixmlElement_getElementsByTagName(IXML_Element *element , char const   *tagName ) ;
extern unsigned long ixmlNamedNodeMap_getLength(IXML_NamedNodeMap *nnMap ) ;
extern IXML_Node *ixmlNamedNodeMap_item(IXML_NamedNodeMap *nnMap , unsigned long index ) ;
extern void ixmlNamedNodeMap_free(IXML_NamedNodeMap *nnMap ) ;
extern IXML_Node *ixmlNodeList_item(IXML_NodeList *nList , unsigned long index ) ;
extern unsigned long ixmlNodeList_length(IXML_NodeList *nList ) ;
extern void ixmlNodeList_free(IXML_NodeList *nList ) ;
extern IXML_Document *ixmlParseBuffer(char const   *buffer ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
void free_metadata(struct metadata_s *metadata ) ;
char *XMLGetFirstElementItem(IXML_Element *element , char const   *item ) ;
extern int UpnpUnSubscribeAsync(UpnpClient_Handle Hnd , char *SubsId , int (*Fun)(Upnp_EventType EventType ,
                                                                                  void *Event ,
                                                                                  void *Cookie ) ,
                                void const   *Cookie ) ;
extern int UpnpResolveURL(char const   *BaseURL , char const   *RelURL , char *AbsURL ) ;
static log_level *loglevel___1  =    & util_loglevel;
static IXML_Node *_getAttributeNode(IXML_Node *node , char *SearchAttr ) ;
int _voidHandler(Upnp_EventType EventType , void *_Event , void *Cookie ) 
{ 


  {
  return (0);
}
}
int CalcGroupVolume(struct sMR *Device ) 
{ 
  int i ;
  int n ;
  double GroupVolume ;
  struct sMR *p ;
  int tmp ;

  {
  n = 0;
  GroupVolume = (double )0;
  if (! Device->Service[4].ControlURL[0]) {
    return (-1);
  }
  i = 0;
  while (i < glMaxDevices) {
    p = glMRDevices + i;
    if (p->Running) {
      if ((unsigned long )p == (unsigned long )Device) {
        goto _L;
      } else
      if ((unsigned long )p->Master == (unsigned long )Device) {
        _L: /* CIL Label */ 
        if (p->Volume == (double )-1) {
          tmp = CtrlGetVolume(p);
          p->Volume = (double )tmp;
        }
        GroupVolume += p->Volume;
        n ++;
      }
    }
    i ++;
  }
  return ((int )(GroupVolume / (double )n));
}
}
struct sMR *GetMaster(struct sMR *Device , char **Name ) 
{ 
  IXML_Document *ActionNode ;
  IXML_Document *Response ;
  char *Body ;
  struct sMR *Master ;
  struct sService *Service ;
  _Bool done ;
  char myUUID[250] ;
  unsigned int tmp ;
  IXML_NodeList *GroupList ;
  IXML_NodeList *tmp___0 ;
  int i ;
  IXML_Node *Group ;
  IXML_Node *tmp___1 ;
  char const   *Coordinator ;
  char const   *tmp___2 ;
  IXML_NodeList *MemberList ;
  IXML_NodeList *tmp___3 ;
  int j ;
  IXML_Node *Member ;
  IXML_Node *tmp___4 ;
  char const   *UUID ;
  char const   *tmp___5 ;
  int k ;
  char const   *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;
  char const   *tmp___13 ;

  {
  ActionNode = (IXML_Document *)((void *)0);
  Master = (struct sMR *)((void *)0);
  Service = & Device->Service[3];
  done = (_Bool)0;
  if (! Service->ControlURL[0]) {
    return ((struct sMR *)((void *)0));
  }
  ActionNode = UpnpMakeAction("GetZoneGroupState", (char const   *)(Service->Type),
                              0, (char const   *)((void *)0));
  UpnpSendAction(glControlPointHandle, (char const   *)(Service->ControlURL), (char const   *)(Service->Type),
                 (char const   *)((void *)0), ActionNode, & Response);
  if (ActionNode) {
    ixmlDocument_free(ActionNode);
  }
  Body = XMLGetFirstDocumentItem(Response, "ZoneGroupState", (_Bool)1);
  if (Response) {
    ixmlDocument_free(Response);
  }
  Response = ixmlParseBuffer((char const   *)Body);
  if (Body) {
    free((void *)Body);
    Body = (char *)((void *)0);
  }
  if (Response) {
    myUUID[0] = (char )'\000';
    tmp = 1U;
    while (! (tmp >= 250U)) {
      myUUID[tmp] = (char)0;
      tmp ++;
    }
    tmp___0 = ixmlDocument_getElementsByTagName(Response, "ZoneGroup");
    GroupList = tmp___0;
    sscanf((char const   * __restrict  )(Device->UDN), (char const   * __restrict  )"uuid:%s",
           myUUID);
    i = 0;
    while (1) {
      if (! done) {
        if (GroupList) {
          tmp___12 = ixmlNodeList_length(GroupList);
          if (! (i < (int )tmp___12)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      tmp___1 = ixmlNodeList_item(GroupList, (unsigned long )i);
      Group = tmp___1;
      tmp___2 = ixmlElement_getAttribute((IXML_Element *)Group, "Coordinator");
      Coordinator = tmp___2;
      tmp___3 = ixmlDocument_getElementsByTagName((IXML_Document *)Group, "ZoneGroupMember");
      MemberList = tmp___3;
      j = 0;
      while (1) {
        if (! done) {
          tmp___11 = ixmlNodeList_length(MemberList);
          if (! (j < (int )tmp___11)) {
            break;
          }
        } else {
          break;
        }
        tmp___4 = ixmlNodeList_item(MemberList, (unsigned long )j);
        Member = tmp___4;
        tmp___5 = ixmlElement_getAttribute((IXML_Element *)Member, "UUID");
        UUID = tmp___5;
        tmp___8 = strcasecmp((char const   *)(myUUID), UUID);
        if (! tmp___8) {
          if (*Name) {
            free((void *)*Name);
            *Name = (char *)((void *)0);
          }
          tmp___6 = ixmlElement_getAttribute((IXML_Element *)Member, "ZoneName");
          *Name = strdup(tmp___6);
          tmp___7 = strcasecmp((char const   *)(myUUID), Coordinator);
          if (! tmp___7) {
            done = (_Bool)1;
          }
        }
        k = 0;
        while (1) {
          if (! done) {
            if (! (k < glMaxDevices)) {
              break;
            }
          } else {
            break;
          }
          if ((glMRDevices + k)->Running) {
            tmp___10 = strcasestr((char const   *)((glMRDevices + k)->UDN), (char const   *)((char *)Coordinator));
            if (tmp___10) {
              Master = glMRDevices + k;
              if ((unsigned int )*loglevel___1 >= 3U) {
                tmp___9 = logtime();
                logprint("%s %s:%d Found Master %s %s\n", tmp___9, "GetMaster", 115,
                         myUUID, Master->UDN);
              }
              done = (_Bool)1;
            }
          }
          k ++;
        }
        j ++;
      }
      ixmlNodeList_free(MemberList);
      i ++;
    }
    if (! done) {
      Master = Device;
      if ((unsigned int )*loglevel___1 >= 2U) {
        tmp___13 = logtime();
        logprint("%s %s:%d [%p]: Master not discovered yet, assigning to self\n",
                 tmp___13, "GetMaster", 127, Device);
      }
    }
    ixmlNodeList_free(GroupList);
    ixmlDocument_free(Response);
  }
  return (Master);
}
}
void FlushMRDevices(void) 
{ 
  int i ;
  struct sMR *p ;

  {
  i = 0;
  while (i < glMaxDevices) {
    p = glMRDevices + i;
    pthread_mutex_lock(& p->Mutex);
    if (p->Running) {
      if ((unsigned int )p->RaopState == 1U) {
        AVTStop(p);
      }
      raop_delete(p->Raop);
      DelMRDevice(p);
    } else {
      pthread_mutex_unlock(& p->Mutex);
    }
    i ++;
  }
  return;
}
}
void DelMRDevice(struct sMR *p ) 
{ 
  int i ;

  {
  pthread_mutex_trylock(& p->Mutex);
  i = 0;
  while (i < 5) {
    if (p->Service[i].TimeOut) {
      UpnpUnSubscribeAsync(glControlPointHandle, (char *)(p->Service[i].SID), & _voidHandler,
                           (void const   *)((void *)0));
    }
    i ++;
  }
  p->Running = (_Bool)0;
  WakeAll();
  pthread_mutex_unlock(& p->Mutex);
  pthread_join(p->Thread, (void **)((void *)0));
  AVTActionFlush(& p->ActionQueue);
  free_metadata(& p->MetaData);
  return;
}
}
struct sMR *CURL2Device(char *CtrlURL ) 
{ 
  int i ;
  int j ;
  int tmp ;

  {
  i = 0;
  while (i < glMaxDevices) {
    if (! (glMRDevices + i)->Running) {
      goto __Cont;
    }
    j = 0;
    while (j < 5) {
      tmp = strcmp((char const   *)((glMRDevices + i)->Service[j].ControlURL), (char const   *)CtrlURL);
      if (! tmp) {
        return (glMRDevices + i);
      }
      j ++;
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  return ((struct sMR *)((void *)0));
}
}
struct sMR *SID2Device(char *SID ) 
{ 
  int i ;
  int j ;
  int tmp ;

  {
  i = 0;
  while (i < glMaxDevices) {
    if (! (glMRDevices + i)->Running) {
      goto __Cont;
    }
    j = 0;
    while (j < 5) {
      tmp = strcmp((char const   *)((glMRDevices + i)->Service[j].SID), (char const   *)SID);
      if (! tmp) {
        return (glMRDevices + i);
      }
      j ++;
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  return ((struct sMR *)((void *)0));
}
}
struct sService *EventURL2Service(char *URL , struct sService *s ) 
{ 
  int i ;
  int tmp ;

  {
  i = 0;
  while (i < 5) {
    tmp = strcmp((char const   *)(s->EventURL), (char const   *)URL);
    if (tmp) {
      goto __Cont;
    }
    return (s);
    __Cont: /* CIL Label */ 
    s ++;
    i ++;
  }
  return ((struct sService *)((void *)0));
}
}
struct sMR *UDN2Device(char *UDN ) 
{ 
  int i ;
  int tmp ;

  {
  i = 0;
  while (i < glMaxDevices) {
    if (! (glMRDevices + i)->Running) {
      goto __Cont;
    }
    tmp = strcmp((char const   *)((glMRDevices + i)->UDN), (char const   *)UDN);
    if (! tmp) {
      return (glMRDevices + i);
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  return ((struct sMR *)((void *)0));
}
}
_Bool CheckAndLock(struct sMR *Device ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  if (! Device) {
    if ((unsigned int )*loglevel___1 >= 2U) {
      tmp = logtime();
      logprint("%s %s:%d device is NULL\n", tmp, "CheckAndLock", 259, (void *)0);
    }
    return ((_Bool)0);
  }
  pthread_mutex_lock(& Device->Mutex);
  if (Device->Running) {
    return ((_Bool)1);
  }
  if ((unsigned int )*loglevel___1 >= 2U) {
    tmp___0 = logtime();
    logprint("%s %s:%d [%p]: device has been removed\n", tmp___0, "CheckAndLock",
             267, Device);
  }
  pthread_mutex_unlock(& Device->Mutex);
  return ((_Bool)0);
}
}
void MakeMacUnique(struct sMR *Device ) 
{ 
  int i ;
  u32_t hash ;
  u32_t tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
  i = 0;
  while (i < glMaxDevices) {
    if (! (glMRDevices + i)->Running) {
      goto __Cont;
    } else
    if ((unsigned long )Device == (unsigned long )(glMRDevices + i)) {
      goto __Cont;
    }
    tmp___1 = memcmp((void const   *)(& (glMRDevices + i)->Config.mac), (void const   *)(& Device->Config.mac),
                     (size_t )6);
    if (! tmp___1) {
      tmp = hash32(Device->UDN);
      hash = tmp;
      if ((unsigned int )*loglevel___1 >= 2U) {
        tmp___0 = logtime();
        logprint("%s %s:%d [%p]: duplicated mac ... updating\n", tmp___0, "MakeMacUnique",
                 285, Device);
      }
      memset((void *)(& Device->Config.mac[0]), 204, (size_t )2);
      memcpy((void * __restrict  )(& Device->Config.mac[0] + 2), (void const   * __restrict  )(& hash),
             (size_t )4);
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  return;
}
}
in_addr_t ExtractIP(char const   *URL ) 
{ 
  char *p1 ;
  char ip[32] ;
  in_addr_t tmp ;

  {
  sscanf((char const   * __restrict  )URL, (char const   * __restrict  )"http://%31s",
         ip);
  ip[31] = (char )'\000';
  p1 = strchr((char const   *)(ip), ':');
  if (p1) {
    *p1 = (char )'\000';
  }
  tmp = inet_addr((char const   *)(ip));
  return (tmp);
}
}
static IXML_NodeList *XMLGetNthServiceList(IXML_Document *doc , unsigned int n , _Bool *contd ) 
{ 
  IXML_NodeList *ServiceList ;
  IXML_NodeList *servlistnodelist ;
  IXML_Node *servlistnode ;
  char const   *tmp ;
  char const   *tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
  ServiceList = (IXML_NodeList *)((void *)0);
  servlistnodelist = (IXML_NodeList *)((void *)0);
  servlistnode = (IXML_Node *)((void *)0);
  *contd = (_Bool)0;
  if ((unsigned int )*loglevel___1 >= 4U) {
    tmp = logtime();
    logprint("%s %s:%d GetNthServiceList called : n = %d\n", tmp, "XMLGetNthServiceList",
             328, n);
  }
  servlistnodelist = ixmlDocument_getElementsByTagName(doc, "serviceList");
  if (servlistnodelist) {
    tmp___1 = ixmlNodeList_length(servlistnodelist);
    if (tmp___1) {
      tmp___2 = ixmlNodeList_length(servlistnodelist);
      if ((unsigned long )n < tmp___2) {
        servlistnode = ixmlNodeList_item(servlistnodelist, (unsigned long )n);
        if (servlistnode) {
          ServiceList = ixmlElement_getElementsByTagName((IXML_Element *)servlistnode,
                                                         "service");
          *contd = (_Bool)1;
        } else
        if ((unsigned int )*loglevel___1 >= 1U) {
          tmp___0 = logtime();
          logprint("%s %s:%d ixmlNodeList_item(nodeList, n) returned NULL\n", tmp___0,
                   "XMLGetNthServiceList", 345, (void *)0);
        }
      }
    }
  }
  if (servlistnodelist) {
    ixmlNodeList_free(servlistnodelist);
  }
  return (ServiceList);
}
}
int XMLFindAndParseService(IXML_Document *DescDoc , char const   *location , char const   *serviceTypeBase ,
                           char **serviceType , char **serviceId , char **eventURL ,
                           char **controlURL ) 
{ 
  unsigned int i ;
  unsigned long length ;
  int found ;
  int ret ;
  unsigned int sindex ;
  char *tempServiceType ;
  char *baseURL ;
  char const   *base ;
  char *relcontrolURL ;
  char *releventURL ;
  IXML_NodeList *serviceList ;
  IXML_Element *service ;
  _Bool contd ;
  IXML_Node *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char const   *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  char const   *tmp___10 ;
  int tmp___11 ;

  {
  found = 0;
  sindex = 0U;
  tempServiceType = (char *)((void *)0);
  baseURL = (char *)((void *)0);
  base = (char const   *)((void *)0);
  relcontrolURL = (char *)((void *)0);
  releventURL = (char *)((void *)0);
  serviceList = (IXML_NodeList *)((void *)0);
  service = (IXML_Element *)((void *)0);
  contd = (_Bool)1;
  baseURL = XMLGetFirstDocumentItem(DescDoc, "URLBase", (_Bool)1);
  if (baseURL) {
    base = (char const   *)baseURL;
  } else {
    base = location;
  }
  sindex = 0U;
  while (contd) {
    tempServiceType = (char *)((void *)0);
    relcontrolURL = (char *)((void *)0);
    releventURL = (char *)((void *)0);
    service = (IXML_Element *)((void *)0);
    serviceList = XMLGetNthServiceList(DescDoc, sindex, & contd);
    if ((unsigned long )serviceList == (unsigned long )((void *)0)) {
      goto __Cont;
    }
    length = ixmlNodeList_length(serviceList);
    i = 0U;
    while ((unsigned long )i < length) {
      tmp = ixmlNodeList_item(serviceList, (unsigned long )i);
      service = (IXML_Element *)tmp;
      tempServiceType = XMLGetFirstElementItem(service, "serviceType");
      if ((unsigned int )*loglevel___1 >= 4U) {
        tmp___0 = logtime();
        logprint("%s %s:%d serviceType %s\n", tmp___0, "XMLFindAndParseService", 386,
                 tempServiceType);
      }
      tmp___1 = strrchr((char const   *)tempServiceType, ':');
      *tmp___1 = (char )'\000';
      if (tempServiceType) {
        tmp___11 = strcmp((char const   *)tempServiceType, serviceTypeBase);
        if (tmp___11 == 0) {
          if (*serviceType) {
            free((void *)*serviceType);
            *serviceType = (char *)((void *)0);
          }
          *serviceType = XMLGetFirstElementItem(service, "serviceType");
          if (*serviceId) {
            free((void *)*serviceId);
            *serviceId = (char *)((void *)0);
          }
          *serviceId = XMLGetFirstElementItem(service, "serviceId");
          if ((unsigned int )*loglevel___1 >= 4U) {
            tmp___2 = logtime();
            logprint("%s %s:%d Service %s, serviceId: %s\n", tmp___2, "XMLFindAndParseService",
                     395, serviceType, *serviceId);
          }
          relcontrolURL = XMLGetFirstElementItem(service, "controlURL");
          releventURL = XMLGetFirstElementItem(service, "eventSubURL");
          if (*controlURL) {
            free((void *)*controlURL);
            *controlURL = (char *)((void *)0);
          }
          tmp___3 = strlen(base);
          tmp___4 = strlen((char const   *)relcontrolURL);
          tmp___5 = malloc((tmp___3 + tmp___4) + 1UL);
          *controlURL = (char *)tmp___5;
          if (*controlURL) {
            ret = UpnpResolveURL(base, (char const   *)relcontrolURL, *controlURL);
            if (ret != 0) {
              tmp___6 = logtime();
              logprint("%s %s:%d Error generating controlURL from %s + %s\n", tmp___6,
                       "XMLFindAndParseService", 402, base, relcontrolURL);
            }
          }
          if (*eventURL) {
            free((void *)*eventURL);
            *eventURL = (char *)((void *)0);
          }
          tmp___7 = strlen(base);
          tmp___8 = strlen((char const   *)releventURL);
          tmp___9 = malloc((tmp___7 + tmp___8) + 1UL);
          *eventURL = (char *)tmp___9;
          if (*eventURL) {
            ret = UpnpResolveURL(base, (char const   *)releventURL, *eventURL);
            if (ret != 0) {
              tmp___10 = logtime();
              logprint("%s %s:%d Error generating eventURL from %s + %s\n", tmp___10,
                       "XMLFindAndParseService", 408, base, releventURL);
            }
          }
          free((void *)relcontrolURL);
          free((void *)releventURL);
          relcontrolURL = (char *)((void *)0);
          releventURL = (char *)((void *)0);
          found = 1;
          break;
        }
      }
      free((void *)tempServiceType);
      tempServiceType = (char *)((void *)0);
      i ++;
    }
    free((void *)tempServiceType);
    tempServiceType = (char *)((void *)0);
    if (serviceList) {
      ixmlNodeList_free(serviceList);
    }
    serviceList = (IXML_NodeList *)((void *)0);
    __Cont: /* CIL Label */ 
    sindex ++;
  }
  free((void *)baseURL);
  return (found);
}
}
char *XMLGetChangeItem(IXML_Document *doc , char *Tag , char *SearchAttr , char *SearchVal ,
                       char *RetAttr ) 
{ 
  IXML_Node *node ;
  IXML_Document *ItemDoc ;
  IXML_Element *LastChange ;
  IXML_NodeList *List ;
  char *buf___0 ;
  char *ret ;
  u32_t i ;
  char const   *tmp ;
  IXML_Node *node___0 ;
  IXML_Node *tmp___0 ;
  IXML_Node *attr ;
  IXML_Node *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  unsigned long tmp___7 ;

  {
  ret = (char *)((void *)0);
  LastChange = ixmlDocument_getElementById(doc, "LastChange");
  if (! LastChange) {
    return ((char *)((void *)0));
  }
  node = ixmlNode_getFirstChild((IXML_Node *)LastChange);
  if (! node) {
    return ((char *)((void *)0));
  }
  tmp = ixmlNode_getNodeValue(node);
  buf___0 = (char *)tmp;
  if (! buf___0) {
    return ((char *)((void *)0));
  }
  ItemDoc = ixmlParseBuffer((char const   *)buf___0);
  if (! ItemDoc) {
    return ((char *)((void *)0));
  }
  List = ixmlDocument_getElementsByTagName(ItemDoc, (char const   *)Tag);
  if (! List) {
    ixmlDocument_free(ItemDoc);
    return ((char *)((void *)0));
  }
  i = (u32_t )0;
  while (1) {
    tmp___7 = ixmlNodeList_length(List);
    if (! ((unsigned long )i < tmp___7)) {
      break;
    }
    tmp___0 = ixmlNodeList_item(List, (unsigned long )i);
    node___0 = tmp___0;
    tmp___1 = _getAttributeNode(node___0, SearchAttr);
    attr = tmp___1;
    if (! attr) {
      goto __Cont;
    }
    tmp___5 = ixmlNode_getNodeValue(attr);
    tmp___6 = strcasecmp(tmp___5, (char const   *)SearchVal);
    if (! tmp___6) {
      node___0 = ixmlNode_getNextSibling(attr);
      if ((unsigned long )node___0 == (unsigned long )((void *)0)) {
        node___0 = ixmlNode_getPreviousSibling(attr);
        if ((unsigned long )node___0 == (unsigned long )((void *)0)) {
          goto __Cont;
        }
      }
      tmp___3 = ixmlNode_getNodeName(node___0);
      tmp___4 = strcasecmp(tmp___3, "val");
      if (! tmp___4) {
        tmp___2 = ixmlNode_getNodeValue(node___0);
        ret = strdup(tmp___2);
        break;
      }
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  ixmlNodeList_free(List);
  ixmlDocument_free(ItemDoc);
  return (ret);
}
}
static IXML_Node *_getAttributeNode(IXML_Node *node , char *SearchAttr ) 
{ 
  IXML_Node *ret ;
  IXML_NamedNodeMap *map ;
  IXML_NamedNodeMap *tmp ;
  int i ;
  char const   *tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;

  {
  tmp = ixmlNode_getAttributes(node);
  map = tmp;
  i = 0;
  while (1) {
    tmp___2 = ixmlNamedNodeMap_getLength(map);
    if (! ((unsigned long )i < tmp___2)) {
      break;
    }
    ret = ixmlNamedNodeMap_item(map, (unsigned long )i);
    tmp___0 = ixmlNode_getNodeName(ret);
    tmp___1 = strcasecmp(tmp___0, (char const   *)SearchAttr);
    if (tmp___1) {
      ret = (IXML_Node *)((void *)0);
    } else {
      break;
    }
    i ++;
  }
  ixmlNamedNodeMap_free(map);
  return (ret);
}
}
char *uPNPEvent2String(Upnp_EventType S ) 
{ 


  {
  switch ((unsigned int )S) {
  case 4U: 
  return ((char *)"UPNP_DISCOVERY_ADVERTISEMENT_ALIVE");
  case 5U: 
  return ((char *)"UPNP_DISCOVERY_ADVERTISEMENT_BYEBYE");
  case 6U: 
  return ((char *)"UPNP_DISCOVERY_SEARCH_RESULT");
  case 7U: 
  return ((char *)"UPNP_DISCOVERY_SEARCH_TIMEOUT");
  case 0U: 
  return ((char *)"UPNP_CONTROL_ACTION_REQUEST");
  case 1U: 
  return ((char *)"UPNP_CONTROL_ACTION_COMPLETE");
  case 2U: 
  return ((char *)"UPNP_CONTROL_GET_VAR_REQUEST");
  case 3U: 
  return ((char *)"UPNP_CONTROL_GET_VAR_COMPLETE");
  case 8U: 
  return ((char *)"UPNP_EVENT_SUBSCRIPTION_REQUEST");
  case 9U: 
  return ((char *)"UPNP_EVENT_RECEIVED");
  case 10U: 
  return ((char *)"UPNP_EVENT_RENEWAL_COMPLETE");
  case 11U: 
  return ((char *)"UPNP_EVENT_SUBSCRIBE_COMPLETE");
  case 12U: 
  return ((char *)"UPNP_EVENT_UNSUBSCRIBE_COMPLETE");
  case 13U: 
  return ((char *)"UPNP_EVENT_AUTORENEWAL_FAILED");
  case 14U: 
  return ((char *)"UPNP_EVENT_SUBSCRIPTION_EXPIRED");
  }
  return ((char *)"");
}
}
#pragma merger("0","/tmp/cil-gAACJIkM.i","-Wall,-fPIC,-ggdb,-O2,-m64,-fdata-sections,-ffunction-sections")
extern IXML_Node *ixmlNode_getParentNode(IXML_Node *nodeptr ) ;
extern IXML_NodeList *ixmlNode_getChildNodes(IXML_Node *nodeptr ) ;
extern int ixmlNode_removeChild(IXML_Node *nodeptr , IXML_Node *oldChild , IXML_Node **returnNode ) ;
extern int ixmlNode_appendChild(IXML_Node *nodeptr , IXML_Node *newChild ) ;
extern void ixmlNode_free(IXML_Node *nodeptr ) ;
extern int ixmlDocument_importNode(IXML_Document *doc , IXML_Node *importNode , BOOL deep ,
                                   IXML_Node **rtNode ) ;
extern char *ixmlDocumenttoString(IXML_Document *doc ) ;
extern IXML_Document *ixmlLoadDocument(char const   *xmlFile ) ;
IXML_Node *XMLUpdateNode(IXML_Document *doc , IXML_Node *parent , _Bool refresh ,
                         char *name , char *fmt  , ...) ;
void *FindMRConfig(void *ref , char *UDN ) ;
char *level2debug(log_level level ) ;
void SaveConfig(char *name , void *ref , _Bool full ) 
{ 
  struct sMR *p ;
  IXML_Document *doc ;
  IXML_Document *tmp ;
  IXML_Document *old_doc ;
  IXML_Node *root ;
  IXML_Node *common ;
  IXML_Node *proto ;
  IXML_NodeList *list ;
  IXML_Element *old_root ;
  char *s ;
  FILE *file ;
  int i ;
  IXML_Node *device ;
  unsigned long tmp___0 ;
  IXML_Element *tmp___1 ;
  IXML_Element *tmp___2 ;
  IXML_Node *tmp___3 ;
  IXML_Node *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  IXML_Node *dev_node ;
  void *tmp___9 ;
  char *udn ;
  IXML_Node *device___0 ;
  IXML_Node *node ;
  IXML_Element *tmp___10 ;
  char const   *tmp___11 ;
  void *tmp___12 ;
  unsigned long tmp___13 ;
  size_t tmp___14 ;

  {
  tmp = ixmlDocument_createDocument();
  doc = tmp;
  old_doc = (IXML_Document *)ref;
  old_root = ixmlDocument_getElementById(old_doc, "airupnp");
  if (! full) {
    if (old_doc) {
      ixmlDocument_importNode(doc, (IXML_Node *)old_root, 1, & root);
      ixmlNode_appendChild((IXML_Node *)doc, root);
      list = ixmlDocument_getElementsByTagName((IXML_Document *)root, "device");
      i = 0;
      while (1) {
        tmp___0 = ixmlNodeList_length(list);
        if (! (i < (int )tmp___0)) {
          break;
        }
        device = ixmlNodeList_item(list, (unsigned long )i);
        ixmlNode_removeChild(root, device, & device);
        ixmlNode_free(device);
        i ++;
      }
      if (list) {
        ixmlNodeList_free(list);
      }
      tmp___1 = ixmlDocument_getElementById((IXML_Document *)root, "common");
      common = (IXML_Node *)tmp___1;
      tmp___2 = ixmlDocument_getElementById((IXML_Document *)common, "protocolInfo");
      proto = (IXML_Node *)tmp___2;
    } else {
      root = XMLAddNode(doc, (IXML_Node *)((void *)0), (char *)"airupnp", (char *)((void *)0));
      tmp___3 = XMLAddNode(doc, root, (char *)"common", (char *)((void *)0));
      common = tmp___3;
      tmp___4 = XMLAddNode(doc, common, (char *)"protocolInfo", (char *)((void *)0));
      proto = tmp___4;
    }
  } else {
    root = XMLAddNode(doc, (IXML_Node *)((void *)0), (char *)"airupnp", (char *)((void *)0));
    tmp___3 = XMLAddNode(doc, root, (char *)"common", (char *)((void *)0));
    common = tmp___3;
    tmp___4 = XMLAddNode(doc, common, (char *)"protocolInfo", (char *)((void *)0));
    proto = tmp___4;
  }
  tmp___5 = level2debug(main_loglevel);
  XMLUpdateNode(doc, root, (_Bool)0, (char *)"main_log", tmp___5);
  tmp___6 = level2debug(upnp_loglevel);
  XMLUpdateNode(doc, root, (_Bool)0, (char *)"upnp_log", tmp___6);
  tmp___7 = level2debug(util_loglevel);
  XMLUpdateNode(doc, root, (_Bool)0, (char *)"util_log", tmp___7);
  tmp___8 = level2debug(raop_loglevel);
  XMLUpdateNode(doc, root, (_Bool)0, (char *)"raop_log", tmp___8);
  XMLUpdateNode(doc, root, (_Bool)0, (char *)"log_limit", (char *)"%d", glLogLimit);
  XMLUpdateNode(doc, root, (_Bool)0, (char *)"max_players", (char *)"%d", glMaxDevices);
  XMLUpdateNode(doc, root, (_Bool)0, (char *)"binding", glBinding);
  XMLUpdateNode(doc, root, (_Bool)0, (char *)"ports", (char *)"%hu:%hu", (int )glPortBase,
                (int )glPortRange);
  XMLUpdateNode(doc, common, (_Bool)0, (char *)"enabled", (char *)"%d", (int )glMRConfig.Enabled);
  XMLUpdateNode(doc, common, (_Bool)0, (char *)"max_volume", (char *)"%d", glMRConfig.MaxVolume);
  XMLUpdateNode(doc, common, (_Bool)0, (char *)"http_length", (char *)"%d", glMRConfig.HTTPLength);
  XMLUpdateNode(doc, common, (_Bool)0, (char *)"upnp_max", (char *)"%d", glMRConfig.UPnPMax);
  XMLUpdateNode(doc, common, (_Bool)0, (char *)"codec", glMRConfig.Codec);
  XMLUpdateNode(doc, common, (_Bool)0, (char *)"metadata", (char *)"%d", (int )glMRConfig.Metadata);
  XMLUpdateNode(doc, common, (_Bool)0, (char *)"flush", (char *)"%d", (int )glMRConfig.Flush);
  XMLUpdateNode(doc, common, (_Bool)0, (char *)"artwork", (char *)"%s", glMRConfig.ArtWork);
  XMLUpdateNode(doc, common, (_Bool)0, (char *)"latency", glMRConfig.Latency);
  XMLUpdateNode(doc, common, (_Bool)0, (char *)"drift", (char *)"%d", (int )glMRConfig.Drift);
  XMLUpdateNode(doc, proto, (_Bool)0, (char *)"pcm", glMRConfig.ProtocolInfo.pcm);
  XMLUpdateNode(doc, proto, (_Bool)0, (char *)"wav", glMRConfig.ProtocolInfo.wav);
  XMLUpdateNode(doc, proto, (_Bool)0, (char *)"flac", glMRConfig.ProtocolInfo.flac);
  XMLUpdateNode(doc, proto, (_Bool)0, (char *)"mp3", glMRConfig.ProtocolInfo.mp3);
  i = 0;
  while (i < glMaxDevices) {
    if (! (glMRDevices + i)->Running) {
      goto __Cont;
    } else {
      p = glMRDevices + i;
    }
    if (! old_doc) {
      dev_node = XMLAddNode(doc, root, (char *)"device", (char *)((void *)0));
      XMLAddNode(doc, dev_node, (char *)"udn", p->UDN);
      XMLAddNode(doc, dev_node, (char *)"name", p->Config.Name);
      XMLAddNode(doc, dev_node, (char *)"mac", (char *)"%02x:%02x:%02x:%02x:%02x:%02x",
                 (int )p->Config.mac[0], (int )p->Config.mac[1], (int )p->Config.mac[2],
                 (int )p->Config.mac[3], (int )p->Config.mac[4], (int )p->Config.mac[5]);
      XMLAddNode(doc, dev_node, (char *)"enabled", (char *)"%d", (int )p->Config.Enabled);
    } else {
      tmp___9 = FindMRConfig((void *)old_doc, p->UDN);
      if (! tmp___9) {
        dev_node = XMLAddNode(doc, root, (char *)"device", (char *)((void *)0));
        XMLAddNode(doc, dev_node, (char *)"udn", p->UDN);
        XMLAddNode(doc, dev_node, (char *)"name", p->Config.Name);
        XMLAddNode(doc, dev_node, (char *)"mac", (char *)"%02x:%02x:%02x:%02x:%02x:%02x",
                   (int )p->Config.mac[0], (int )p->Config.mac[1], (int )p->Config.mac[2],
                   (int )p->Config.mac[3], (int )p->Config.mac[4], (int )p->Config.mac[5]);
        XMLAddNode(doc, dev_node, (char *)"enabled", (char *)"%d", (int )p->Config.Enabled);
      }
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  list = ixmlDocument_getElementsByTagName((IXML_Document *)old_root, "device");
  i = 0;
  while (1) {
    tmp___13 = ixmlNodeList_length(list);
    if (! (i < (int )tmp___13)) {
      break;
    }
    device___0 = ixmlNodeList_item(list, (unsigned long )i);
    tmp___10 = ixmlDocument_getElementById((IXML_Document *)device___0, "udn");
    node = (IXML_Node *)tmp___10;
    node = ixmlNode_getFirstChild(node);
    tmp___11 = ixmlNode_getNodeValue(node);
    udn = (char *)tmp___11;
    tmp___12 = FindMRConfig((void *)doc, udn);
    if (! tmp___12) {
      ixmlDocument_importNode(doc, device___0, 1, & device___0);
      ixmlNode_appendChild(root, device___0);
    }
    i ++;
  }
  if (list) {
    ixmlNodeList_free(list);
  }
  file = fopen((char const   * __restrict  )name, (char const   * __restrict  )"wb");
  s = ixmlDocumenttoString(doc);
  tmp___14 = strlen((char const   *)s);
  fwrite((void const   * __restrict  )s, (size_t )1, tmp___14, (FILE * __restrict  )file);
  fclose(file);
  free((void *)s);
  ixmlDocument_free(doc);
  return;
}
}
static void LoadConfigItem(tMRConfig *Conf , char *name , char *val ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  unsigned int mac[6] ;
  int i ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
  if (! val) {
    return;
  }
  tmp___0 = strcmp((char const   *)name, "enabled");
  if (! tmp___0) {
    tmp = atoi((char const   *)val);
    Conf->Enabled = (_Bool )tmp;
  }
  tmp___1 = strcmp((char const   *)name, "max_volume");
  if (! tmp___1) {
    Conf->MaxVolume = atoi((char const   *)val);
  }
  tmp___2 = strcmp((char const   *)name, "http_length");
  if (! tmp___2) {
    Conf->HTTPLength = atoi((char const   *)val);
  }
  tmp___3 = strcmp((char const   *)name, "upnp_max");
  if (! tmp___3) {
    Conf->UPnPMax = atoi((char const   *)val);
  }
  tmp___4 = strcmp((char const   *)name, "use_flac");
  if (! tmp___4) {
    strcpy((char * __restrict  )(Conf->Codec), (char const   * __restrict  )"flac");
  }
  tmp___5 = strcmp((char const   *)name, "codec");
  if (! tmp___5) {
    strcpy((char * __restrict  )(Conf->Codec), (char const   * __restrict  )val);
  }
  tmp___7 = strcmp((char const   *)name, "metadata");
  if (! tmp___7) {
    tmp___6 = atoi((char const   *)val);
    Conf->Metadata = (_Bool )tmp___6;
  }
  tmp___9 = strcmp((char const   *)name, "flush");
  if (! tmp___9) {
    tmp___8 = atoi((char const   *)val);
    Conf->Flush = (_Bool )tmp___8;
  }
  tmp___10 = strcmp((char const   *)name, "artwork");
  if (! tmp___10) {
    strcpy((char * __restrict  )(Conf->ArtWork), (char const   * __restrict  )val);
  }
  tmp___11 = strcmp((char const   *)name, "latency");
  if (! tmp___11) {
    strcpy((char * __restrict  )(Conf->Latency), (char const   * __restrict  )val);
  }
  tmp___13 = strcmp((char const   *)name, "drift");
  if (! tmp___13) {
    tmp___12 = atoi((char const   *)val);
    Conf->Drift = (_Bool )tmp___12;
  }
  tmp___14 = strcmp((char const   *)name, "name");
  if (! tmp___14) {
    strcpy((char * __restrict  )(Conf->Name), (char const   * __restrict  )val);
  }
  tmp___15 = strcmp((char const   *)name, "mac");
  if (! tmp___15) {
    sscanf((char const   * __restrict  )val, (char const   * __restrict  )"%2x:%2x:%2x:%2x:%2x:%2x",
           & mac[0], & mac[1], & mac[2], & mac[3], & mac[4], & mac[5]);
    i = 0;
    while (i < 6) {
      Conf->mac[i] = (u8_t )mac[i];
      i ++;
    }
  }
  tmp___16 = strcmp((char const   *)name, "pcm");
  if (! tmp___16) {
    strcpy((char * __restrict  )(Conf->ProtocolInfo.pcm), (char const   * __restrict  )val);
  }
  tmp___17 = strcmp((char const   *)name, "wav");
  if (! tmp___17) {
    strcpy((char * __restrict  )(Conf->ProtocolInfo.wav), (char const   * __restrict  )val);
  }
  tmp___18 = strcmp((char const   *)name, "flac");
  if (! tmp___18) {
    strcpy((char * __restrict  )(Conf->ProtocolInfo.flac), (char const   * __restrict  )val);
  }
  tmp___19 = strcmp((char const   *)name, "mp3");
  if (! tmp___19) {
    strcpy((char * __restrict  )(Conf->ProtocolInfo.mp3), (char const   * __restrict  )val);
  }
  return;
}
}
static void LoadGlobalItem(char *name , char *val ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  if (! val) {
    return;
  }
  tmp = strcmp((char const   *)name, "main_log");
  if (! tmp) {
    main_loglevel = debug2level(val);
  }
  tmp___0 = strcmp((char const   *)name, "upnp_log");
  if (! tmp___0) {
    upnp_loglevel = debug2level(val);
  }
  tmp___1 = strcmp((char const   *)name, "util_log");
  if (! tmp___1) {
    util_loglevel = debug2level(val);
  }
  tmp___2 = strcmp((char const   *)name, "raop_log");
  if (! tmp___2) {
    raop_loglevel = debug2level(val);
  }
  tmp___4 = strcmp((char const   *)name, "log_limit");
  if (! tmp___4) {
    tmp___3 = atol((char const   *)val);
    glLogLimit = (s32_t )tmp___3;
  }
  tmp___6 = strcmp((char const   *)name, "max_players");
  if (! tmp___6) {
    tmp___5 = atol((char const   *)val);
    glMaxDevices = (int )tmp___5;
  }
  tmp___7 = strcmp((char const   *)name, "binding");
  if (! tmp___7) {
    strcpy((char * __restrict  )(glBinding), (char const   * __restrict  )val);
  }
  tmp___8 = strcmp((char const   *)name, "ports");
  if (! tmp___8) {
    sscanf((char const   * __restrict  )val, (char const   * __restrict  )"%hu:%hu",
           & glPortBase, & glPortRange);
  }
  return;
}
}
void *FindMRConfig(void *ref , char *UDN ) 
{ 
  IXML_Element *elm ;
  IXML_Node *device ;
  IXML_NodeList *l1_node_list ;
  IXML_Document *doc ;
  char *v ;
  unsigned int i ;
  IXML_Node *l1_node ;
  IXML_Node *l1_1_node ;
  char const   *tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;

  {
  device = (IXML_Node *)((void *)0);
  doc = (IXML_Document *)ref;
  elm = ixmlDocument_getElementById(doc, "airupnp");
  l1_node_list = ixmlDocument_getElementsByTagName((IXML_Document *)elm, "udn");
  i = 0U;
  while (1) {
    tmp___1 = ixmlNodeList_length(l1_node_list);
    if (! ((unsigned long )i < tmp___1)) {
      break;
    }
    l1_node = ixmlNodeList_item(l1_node_list, (unsigned long )i);
    l1_1_node = ixmlNode_getFirstChild(l1_node);
    tmp = ixmlNode_getNodeValue(l1_1_node);
    v = (char *)tmp;
    if (v) {
      tmp___0 = strcmp((char const   *)v, (char const   *)UDN);
      if (! tmp___0) {
        device = ixmlNode_getParentNode(l1_node);
        break;
      }
    }
    i ++;
  }
  if (l1_node_list) {
    ixmlNodeList_free(l1_node_list);
  }
  return ((void *)device);
}
}
void *LoadMRConfig(void *ref , char *UDN , struct sMRConfig *Conf ) 
{ 
  IXML_NodeList *node_list ;
  IXML_Document *doc ;
  IXML_Node *node ;
  char *n ;
  char *v ;
  unsigned int i ;
  void *tmp ;
  IXML_Node *l1_node ;
  IXML_Node *l1_1_node ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  unsigned long tmp___2 ;

  {
  doc = (IXML_Document *)ref;
  tmp = FindMRConfig((void *)doc, UDN);
  node = (IXML_Node *)tmp;
  if (node) {
    node_list = ixmlNode_getChildNodes(node);
    i = 0U;
    while (1) {
      tmp___2 = ixmlNodeList_length(node_list);
      if (! ((unsigned long )i < tmp___2)) {
        break;
      }
      l1_node = ixmlNodeList_item(node_list, (unsigned long )i);
      tmp___0 = ixmlNode_getNodeName(l1_node);
      n = (char *)tmp___0;
      l1_1_node = ixmlNode_getFirstChild(l1_node);
      tmp___1 = ixmlNode_getNodeValue(l1_1_node);
      v = (char *)tmp___1;
      LoadConfigItem(Conf, n, v);
      i ++;
    }
    if (node_list) {
      ixmlNodeList_free(node_list);
    }
  }
  return ((void *)node);
}
}
void *LoadConfig(char *name , struct sMRConfig *Conf ) 
{ 
  IXML_Element *elm ;
  IXML_Document *doc ;
  unsigned int i ;
  char *n ;
  char *v ;
  IXML_NodeList *l1_node_list ;
  IXML_Node *l1_node ;
  IXML_Node *l1_1_node ;
  char const   *tmp ;
  char const   *tmp___0 ;
  unsigned long tmp___1 ;
  char *n___0 ;
  char *v___0 ;
  IXML_NodeList *l1_node_list___0 ;
  unsigned int i___0 ;
  IXML_Node *l1_node___0 ;
  IXML_Node *l1_1_node___0 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  unsigned long tmp___4 ;
  char *n___1 ;
  char *v___1 ;
  IXML_NodeList *l1_node_list___1 ;
  unsigned int i___1 ;
  IXML_Node *l1_node___1 ;
  IXML_Node *l1_1_node___1 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  unsigned long tmp___7 ;

  {
  doc = ixmlLoadDocument((char const   *)name);
  if (! doc) {
    return ((void *)0);
  }
  elm = ixmlDocument_getElementById(doc, "airupnp");
  if (elm) {
    l1_node_list = ixmlNode_getChildNodes((IXML_Node *)elm);
    i = 0U;
    while (1) {
      tmp___1 = ixmlNodeList_length(l1_node_list);
      if (! ((unsigned long )i < tmp___1)) {
        break;
      }
      l1_node = ixmlNodeList_item(l1_node_list, (unsigned long )i);
      tmp = ixmlNode_getNodeName(l1_node);
      n = (char *)tmp;
      l1_1_node = ixmlNode_getFirstChild(l1_node);
      tmp___0 = ixmlNode_getNodeValue(l1_1_node);
      v = (char *)tmp___0;
      LoadGlobalItem(n, v);
      i ++;
    }
    if (l1_node_list) {
      ixmlNodeList_free(l1_node_list);
    }
  }
  elm = ixmlDocument_getElementById((IXML_Document *)elm, "common");
  if (elm) {
    l1_node_list___0 = ixmlNode_getChildNodes((IXML_Node *)elm);
    i___0 = 0U;
    while (1) {
      tmp___4 = ixmlNodeList_length(l1_node_list___0);
      if (! ((unsigned long )i___0 < tmp___4)) {
        break;
      }
      l1_node___0 = ixmlNodeList_item(l1_node_list___0, (unsigned long )i___0);
      tmp___2 = ixmlNode_getNodeName(l1_node___0);
      n___0 = (char *)tmp___2;
      l1_1_node___0 = ixmlNode_getFirstChild(l1_node___0);
      tmp___3 = ixmlNode_getNodeValue(l1_1_node___0);
      v___0 = (char *)tmp___3;
      LoadConfigItem(& glMRConfig, n___0, v___0);
      i___0 ++;
    }
    if (l1_node_list___0) {
      ixmlNodeList_free(l1_node_list___0);
    }
  }
  elm = ixmlDocument_getElementById((IXML_Document *)elm, "protocolInfo");
  if (elm) {
    l1_node_list___1 = ixmlNode_getChildNodes((IXML_Node *)elm);
    i___1 = 0U;
    while (1) {
      tmp___7 = ixmlNodeList_length(l1_node_list___1);
      if (! ((unsigned long )i___1 < tmp___7)) {
        break;
      }
      l1_node___1 = ixmlNodeList_item(l1_node_list___1, (unsigned long )i___1);
      tmp___5 = ixmlNode_getNodeName(l1_node___1);
      n___1 = (char *)tmp___5;
      l1_1_node___1 = ixmlNode_getFirstChild(l1_node___1);
      tmp___6 = ixmlNode_getNodeValue(l1_1_node___1);
      v___1 = (char *)tmp___6;
      LoadConfigItem(& glMRConfig, n___1, v___1);
      i___1 ++;
    }
    if (l1_node_list___1) {
      ixmlNodeList_free(l1_node_list___1);
    }
  }
  return ((void *)doc);
}
}
/* compiler builtin: 
   int __builtin_clz(unsigned int  ) ;  */
#pragma merger("0","/tmp/cil-I6X7tGy5.i","-Wall,-fPIC,-ggdb,-O2,-m64,-fdata-sections,-ffunction-sections")
static int const   host_bigendian  =    (int const   )0;
alac_file *create_alac(int samplesize , int numchannels ) ;
void delete_alac(alac_file *alac ) ;
void decode_frame(alac_file *alac , unsigned char *inbuffer , void *outbuffer , int *outputsize ) ;
void alac_set_info(alac_file *alac , char *inputbuffer ) ;
void allocate_buffers(alac_file *alac ) ;
int _fprintf(FILE *file  , ...) ;
struct __anonstruct_se_struct_24_422959015 se_struct_24  ;
void allocate_buffers(alac_file *alac ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  tmp = malloc((size_t )(alac->setinfo_max_samples_per_frame * 4U));
  alac->predicterror_buffer_a = (int32_t *)tmp;
  tmp___0 = malloc((size_t )(alac->setinfo_max_samples_per_frame * 4U));
  alac->predicterror_buffer_b = (int32_t *)tmp___0;
  tmp___1 = malloc((size_t )(alac->setinfo_max_samples_per_frame * 4U));
  alac->outputsamples_buffer_a = (int32_t *)tmp___1;
  tmp___2 = malloc((size_t )(alac->setinfo_max_samples_per_frame * 4U));
  alac->outputsamples_buffer_b = (int32_t *)tmp___2;
  tmp___3 = malloc((size_t )(alac->setinfo_max_samples_per_frame * 4U));
  alac->uncompressed_bytes_buffer_a = (int32_t *)tmp___3;
  tmp___4 = malloc((size_t )(alac->setinfo_max_samples_per_frame * 4U));
  alac->uncompressed_bytes_buffer_b = (int32_t *)tmp___4;
  return;
}
}
void alac_set_info(alac_file *alac , char *inputbuffer ) 
{ 
  char *ptr ;

  {
  ptr = inputbuffer;
  ptr += 4;
  ptr += 4;
  ptr += 4;
  ptr += 4;
  ptr += 4;
  ptr += 4;
  alac->setinfo_max_samples_per_frame = *((uint32_t *)ptr);
  if (! host_bigendian) {
    while (1) {
      alac->setinfo_max_samples_per_frame = ((((alac->setinfo_max_samples_per_frame & 255U) << 24) | ((alac->setinfo_max_samples_per_frame & 65280U) << 8)) | ((alac->setinfo_max_samples_per_frame & 16711680U) >> 8)) | ((alac->setinfo_max_samples_per_frame & 4278190080U) >> 24);
      break;
    }
  }
  ptr += 4;
  alac->setinfo_7a = *((uint8_t *)ptr);
  ptr ++;
  alac->setinfo_sample_size = *((uint8_t *)ptr);
  ptr ++;
  alac->setinfo_rice_historymult = *((uint8_t *)ptr);
  ptr ++;
  alac->setinfo_rice_initialhistory = *((uint8_t *)ptr);
  ptr ++;
  alac->setinfo_rice_kmodifier = *((uint8_t *)ptr);
  ptr ++;
  alac->setinfo_7f = *((uint8_t *)ptr);
  ptr ++;
  alac->setinfo_80 = *((uint16_t *)ptr);
  if (! host_bigendian) {
    while (1) {
      alac->setinfo_80 = (uint16_t )((((int )alac->setinfo_80 & 255) << 8) | (((int )alac->setinfo_80 & 65280) >> 8));
      break;
    }
  }
  ptr += 2;
  alac->setinfo_82 = *((uint32_t *)ptr);
  if (! host_bigendian) {
    while (1) {
      alac->setinfo_82 = ((((alac->setinfo_82 & 255U) << 24) | ((alac->setinfo_82 & 65280U) << 8)) | ((alac->setinfo_82 & 16711680U) >> 8)) | ((alac->setinfo_82 & 4278190080U) >> 24);
      break;
    }
  }
  ptr += 4;
  alac->setinfo_86 = *((uint32_t *)ptr);
  if (! host_bigendian) {
    while (1) {
      alac->setinfo_86 = ((((alac->setinfo_86 & 255U) << 24) | ((alac->setinfo_86 & 65280U) << 8)) | ((alac->setinfo_86 & 16711680U) >> 8)) | ((alac->setinfo_86 & 4278190080U) >> 24);
      break;
    }
  }
  ptr += 4;
  alac->setinfo_8a_rate = *((uint32_t *)ptr);
  if (! host_bigendian) {
    while (1) {
      alac->setinfo_8a_rate = ((((alac->setinfo_8a_rate & 255U) << 24) | ((alac->setinfo_8a_rate & 65280U) << 8)) | ((alac->setinfo_8a_rate & 16711680U) >> 8)) | ((alac->setinfo_8a_rate & 4278190080U) >> 24);
      break;
    }
  }
  allocate_buffers(alac);
  return;
}
}
static uint32_t readbits_16(alac_file *alac , int bits ) 
{ 
  uint32_t result ;
  int new_accumulator ;

  {
  result = (uint32_t )((((int )*(alac->input_buffer + 0) << 16) | ((int )*(alac->input_buffer + 1) << 8)) | (int )*(alac->input_buffer + 2));
  result <<= alac->input_buffer_bitaccumulator;
  result &= 16777215U;
  result >>= 24 - bits;
  new_accumulator = alac->input_buffer_bitaccumulator + bits;
  alac->input_buffer += new_accumulator >> 3;
  alac->input_buffer_bitaccumulator = new_accumulator & 7;
  return (result);
}
}
static uint32_t readbits(alac_file *alac , int bits ) 
{ 
  int32_t result ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  result = 0;
  if (bits > 16) {
    bits -= 16;
    tmp = readbits_16(alac, 16);
    result = (int32_t )(tmp << bits);
  }
  tmp___0 = readbits_16(alac, bits);
  result = (int32_t )((unsigned int )result | tmp___0);
  return ((uint32_t )result);
}
}
static int readbit(alac_file *alac ) 
{ 
  int result ;
  int new_accumulator ;

  {
  result = (int )*(alac->input_buffer + 0);
  result <<= alac->input_buffer_bitaccumulator;
  result = (result >> 7) & 1;
  new_accumulator = alac->input_buffer_bitaccumulator + 1;
  alac->input_buffer += new_accumulator / 8;
  alac->input_buffer_bitaccumulator = new_accumulator % 8;
  return (result);
}
}
static void unreadbits(alac_file *alac , int bits ) 
{ 
  int new_accumulator ;

  {
  new_accumulator = alac->input_buffer_bitaccumulator - bits;
  alac->input_buffer += new_accumulator >> 3;
  alac->input_buffer_bitaccumulator = new_accumulator & 7;
  if (alac->input_buffer_bitaccumulator < 0) {
    alac->input_buffer_bitaccumulator *= -1;
  }
  return;
}
}
static int count_leading_zeros(int input ) 
{ 
  int tmp ;

  {
  tmp = __builtin_clz((unsigned int )input);
  return (tmp);
}
}
static int32_t entropy_decode_value(alac_file *alac , int readSampleSize , int k ,
                                    int rice_kmodifier_mask ) 
{ 
  int32_t x ;
  int tmp ;
  int32_t value ;
  uint32_t tmp___0 ;
  int extraBits ;
  uint32_t tmp___1 ;

  {
  x = 0;
  while (1) {
    if (x <= 8) {
      tmp = readbit(alac);
      if (! tmp) {
        break;
      }
    } else {
      break;
    }
    x ++;
  }
  if (x > 8) {
    tmp___0 = readbits(alac, readSampleSize);
    value = (int32_t )tmp___0;
    value = (int32_t )((unsigned int )value & (4294967295U >> (32 - readSampleSize)));
    x = value;
  } else
  if (k != 1) {
    tmp___1 = readbits(alac, k);
    extraBits = (int )tmp___1;
    x *= ((1 << k) - 1) & rice_kmodifier_mask;
    if (extraBits > 1) {
      x += extraBits - 1;
    } else {
      unreadbits(alac, 1);
    }
  }
  return (x);
}
}
static void entropy_rice_decode(alac_file *alac , int32_t *outputBuffer , int outputSize ,
                                int readSampleSize , int rice_initialhistory , int rice_kmodifier ,
                                int rice_historymult , int rice_kmodifier_mask ) 
{ 
  int outputCount ;
  int history ;
  int signModifier ;
  int32_t decodedValue ;
  int32_t finalValue ;
  int32_t k ;
  int tmp ;
  int32_t blockSize ;
  int tmp___0 ;

  {
  history = rice_initialhistory;
  signModifier = 0;
  outputCount = 0;
  while (outputCount < outputSize) {
    tmp = count_leading_zeros((history >> 9) + 3);
    k = (31 - rice_kmodifier) - tmp;
    if (k < 0) {
      k += rice_kmodifier;
    } else {
      k = rice_kmodifier;
    }
    decodedValue = entropy_decode_value(alac, readSampleSize, k, -1);
    decodedValue += signModifier;
    finalValue = (decodedValue + 1) / 2;
    if (decodedValue & 1) {
      finalValue *= -1;
    }
    *(outputBuffer + outputCount) = finalValue;
    signModifier = 0;
    history += decodedValue * rice_historymult - (history * rice_historymult >> 9);
    if (decodedValue > 65535) {
      history = 65535;
    }
    if (history < 128) {
      if (outputCount + 1 < outputSize) {
        signModifier = 1;
        tmp___0 = count_leading_zeros(history);
        k = (tmp___0 + (history + 16) / 64) - 24;
        blockSize = entropy_decode_value(alac, 16, k, rice_kmodifier_mask);
        if (blockSize > 0) {
          memset((void *)(outputBuffer + (outputCount + 1)), 0, (unsigned long )blockSize * sizeof(*outputBuffer));
          outputCount += blockSize;
        }
        if (blockSize > 65535) {
          signModifier = 0;
        }
        history = 0;
      }
    }
    outputCount ++;
  }
  return;
}
}
static void predictor_decompress_fir_adapt(int32_t *error_buffer , int32_t *buffer_out ,
                                           int output_size , int readsamplesize ,
                                           int16_t *predictor_coef_table , int predictor_coef_num ,
                                           int predictor_quantitization ) 
{ 
  int i ;
  int32_t prev_value ;
  int32_t error_value ;
  int i___0 ;
  int32_t val ;
  int j ;
  int sum ;
  int outval ;
  int error_val ;
  int predictor_num ;
  int val___0 ;
  int sign ;
  int tmp ;
  int tmp___0 ;
  int predictor_num___0 ;
  int val___1 ;
  int sign___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  *buffer_out = *error_buffer;
  if (! predictor_coef_num) {
    if (output_size <= 1) {
      return;
    }
    memcpy((void * __restrict  )(buffer_out + 1), (void const   * __restrict  )(error_buffer + 1),
           (size_t )((output_size - 1) * 4));
    return;
  }
  if (predictor_coef_num == 31) {
    if (output_size <= 1) {
      return;
    }
    i = 0;
    while (i < output_size - 1) {
      prev_value = *(buffer_out + i);
      error_value = *(error_buffer + (i + 1));
      *(buffer_out + (i + 1)) = ((prev_value + error_value) << (32 - readsamplesize)) >> (32 - readsamplesize);
      i ++;
    }
    return;
  }
  if (predictor_coef_num > 0) {
    i___0 = 0;
    while (i___0 < predictor_coef_num) {
      val = *(buffer_out + i___0) + *(error_buffer + (i___0 + 1));
      val = (val << (32 - readsamplesize)) >> (32 - readsamplesize);
      *(buffer_out + (i___0 + 1)) = val;
      i___0 ++;
    }
  }
  if (predictor_coef_num > 0) {
    i = predictor_coef_num + 1;
    while (i < output_size) {
      sum = 0;
      error_val = *(error_buffer + i);
      j = 0;
      while (j < predictor_coef_num) {
        sum += (*(buffer_out + (predictor_coef_num - j)) - *(buffer_out + 0)) * (int32_t )*(predictor_coef_table + j);
        j ++;
      }
      outval = (1 << (predictor_quantitization - 1)) + sum;
      outval >>= predictor_quantitization;
      outval = (outval + *(buffer_out + 0)) + error_val;
      outval = (outval << (32 - readsamplesize)) >> (32 - readsamplesize);
      *(buffer_out + (predictor_coef_num + 1)) = outval;
      if (error_val > 0) {
        predictor_num = predictor_coef_num - 1;
        while (1) {
          if (predictor_num >= 0) {
            if (! (error_val > 0)) {
              break;
            }
          } else {
            break;
          }
          val___0 = *(buffer_out + 0) - *(buffer_out + (predictor_coef_num - predictor_num));
          if (val___0 < 0) {
            tmp___0 = -1;
          } else {
            if (val___0 > 0) {
              tmp = 1;
            } else {
              tmp = 0;
            }
            tmp___0 = tmp;
          }
          sign = tmp___0;
          *(predictor_coef_table + predictor_num) = (int16_t )((int )*(predictor_coef_table + predictor_num) - sign);
          val___0 *= sign;
          error_val -= (val___0 >> predictor_quantitization) * (predictor_coef_num - predictor_num);
          predictor_num --;
        }
      } else
      if (error_val < 0) {
        predictor_num___0 = predictor_coef_num - 1;
        while (1) {
          if (predictor_num___0 >= 0) {
            if (! (error_val < 0)) {
              break;
            }
          } else {
            break;
          }
          val___1 = *(buffer_out + 0) - *(buffer_out + (predictor_coef_num - predictor_num___0));
          if (val___1 < 0) {
            tmp___2 = -1;
          } else {
            if (val___1 > 0) {
              tmp___1 = 1;
            } else {
              tmp___1 = 0;
            }
            tmp___2 = tmp___1;
          }
          sign___0 = - tmp___2;
          *(predictor_coef_table + predictor_num___0) = (int16_t )((int )*(predictor_coef_table + predictor_num___0) - sign___0);
          val___1 *= sign___0;
          error_val -= (val___1 >> predictor_quantitization) * (predictor_coef_num - predictor_num___0);
          predictor_num___0 --;
        }
      }
      buffer_out ++;
      i ++;
    }
  }
  return;
}
}
static void deinterlace_16(int32_t *buffer_a , int32_t *buffer_b , int16_t *buffer_out ,
                           int numchannels , int numsamples , uint8_t interlacing_shift ,
                           uint8_t interlacing_leftweight ) 
{ 
  int i ;
  int32_t difference ;
  int32_t midright ;
  int16_t left ;
  int16_t right ;
  int16_t left___0 ;
  int16_t right___0 ;

  {
  if (numsamples <= 0) {
    return;
  }
  if (interlacing_leftweight) {
    i = 0;
    while (i < numsamples) {
      midright = *(buffer_a + i);
      difference = *(buffer_b + i);
      right = (int16_t )(midright - (difference * (int32_t )interlacing_leftweight >> (int )interlacing_shift));
      left = (int16_t )((int )right + difference);
      if (host_bigendian) {
        while (1) {
          left = (int16_t )((((int )left & 255) << 8) | (((int )left & 65280) >> 8));
          break;
        }
        while (1) {
          right = (int16_t )((((int )right & 255) << 8) | (((int )right & 65280) >> 8));
          break;
        }
      }
      *(buffer_out + i * numchannels) = left;
      *(buffer_out + (i * numchannels + 1)) = right;
      i ++;
    }
    return;
  }
  i = 0;
  while (i < numsamples) {
    left___0 = (int16_t )*(buffer_a + i);
    right___0 = (int16_t )*(buffer_b + i);
    if (host_bigendian) {
      while (1) {
        left___0 = (int16_t )((((int )left___0 & 255) << 8) | (((int )left___0 & 65280) >> 8));
        break;
      }
      while (1) {
        right___0 = (int16_t )((((int )right___0 & 255) << 8) | (((int )right___0 & 65280) >> 8));
        break;
      }
    }
    *(buffer_out + i * numchannels) = left___0;
    *(buffer_out + (i * numchannels + 1)) = right___0;
    i ++;
  }
  return;
}
}
static void deinterlace_24(int32_t *buffer_a , int32_t *buffer_b , int uncompressed_bytes ,
                           int32_t *uncompressed_bytes_buffer_a , int32_t *uncompressed_bytes_buffer_b ,
                           void *buffer_out , int numchannels , int numsamples , uint8_t interlacing_shift ,
                           uint8_t interlacing_leftweight ) 
{ 
  int i ;
  int32_t difference ;
  int32_t midright ;
  int32_t left ;
  int32_t right ;
  uint32_t mask ;
  int32_t left___0 ;
  int32_t right___0 ;
  uint32_t mask___0 ;

  {
  if (numsamples <= 0) {
    return;
  }
  if (interlacing_leftweight) {
    i = 0;
    while (i < numsamples) {
      midright = *(buffer_a + i);
      difference = *(buffer_b + i);
      right = midright - (difference * (int32_t )interlacing_leftweight >> (int )interlacing_shift);
      left = right + difference;
      if (uncompressed_bytes) {
        mask = ~ (4294967295U << uncompressed_bytes * 8);
        left <<= uncompressed_bytes * 8;
        right <<= uncompressed_bytes * 8;
        left = (int32_t )((unsigned int )left | ((unsigned int )*(uncompressed_bytes_buffer_a + i) & mask));
        right = (int32_t )((unsigned int )right | ((unsigned int )*(uncompressed_bytes_buffer_b + i) & mask));
      }
      *((uint8_t *)buffer_out + (i * numchannels) * 3) = (uint8_t )(left & 255);
      *((uint8_t *)buffer_out + ((i * numchannels) * 3 + 1)) = (uint8_t )((left >> 8) & 255);
      *((uint8_t *)buffer_out + ((i * numchannels) * 3 + 2)) = (uint8_t )((left >> 16) & 255);
      *((uint8_t *)buffer_out + ((i * numchannels) * 3 + 3)) = (uint8_t )(right & 255);
      *((uint8_t *)buffer_out + ((i * numchannels) * 3 + 4)) = (uint8_t )((right >> 8) & 255);
      *((uint8_t *)buffer_out + ((i * numchannels) * 3 + 5)) = (uint8_t )((right >> 16) & 255);
      i ++;
    }
    return;
  }
  i = 0;
  while (i < numsamples) {
    left___0 = *(buffer_a + i);
    right___0 = *(buffer_b + i);
    if (uncompressed_bytes) {
      mask___0 = ~ (4294967295U << uncompressed_bytes * 8);
      left___0 <<= uncompressed_bytes * 8;
      right___0 <<= uncompressed_bytes * 8;
      left___0 = (int32_t )((unsigned int )left___0 | ((unsigned int )*(uncompressed_bytes_buffer_a + i) & mask___0));
      right___0 = (int32_t )((unsigned int )right___0 | ((unsigned int )*(uncompressed_bytes_buffer_b + i) & mask___0));
    }
    *((uint8_t *)buffer_out + (i * numchannels) * 3) = (uint8_t )(left___0 & 255);
    *((uint8_t *)buffer_out + ((i * numchannels) * 3 + 1)) = (uint8_t )((left___0 >> 8) & 255);
    *((uint8_t *)buffer_out + ((i * numchannels) * 3 + 2)) = (uint8_t )((left___0 >> 16) & 255);
    *((uint8_t *)buffer_out + ((i * numchannels) * 3 + 3)) = (uint8_t )(right___0 & 255);
    *((uint8_t *)buffer_out + ((i * numchannels) * 3 + 4)) = (uint8_t )((right___0 >> 8) & 255);
    *((uint8_t *)buffer_out + ((i * numchannels) * 3 + 5)) = (uint8_t )((right___0 >> 16) & 255);
    i ++;
  }
  return;
}
}
void decode_frame(alac_file *alac , unsigned char *inbuffer , void *outbuffer , int *outputsize ) 
{ 
  int channels ;
  int32_t outputsamples ;
  uint32_t tmp ;
  int hassize ;
  int isnotcompressed ;
  int readsamplesize ;
  int uncompressed_bytes ;
  int ricemodifier ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  int16_t predictor_coef_table[32] ;
  int predictor_coef_num ;
  int prediction_type ;
  int prediction_quantitization ;
  int i ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t tmp___7 ;
  uint32_t tmp___8 ;
  int i___0 ;
  uint32_t tmp___9 ;
  int i___1 ;
  int32_t audiobits ;
  uint32_t tmp___10 ;
  int i___2 ;
  int32_t audiobits___0 ;
  uint32_t tmp___11 ;
  uint32_t tmp___12 ;
  int i___3 ;
  int16_t sample ;
  int i___4 ;
  int32_t sample___0 ;
  uint32_t mask ;
  int hassize___0 ;
  int isnotcompressed___0 ;
  int readsamplesize___0 ;
  int uncompressed_bytes___0 ;
  uint8_t interlacing_shift ;
  uint8_t interlacing_leftweight ;
  uint32_t tmp___13 ;
  uint32_t tmp___14 ;
  uint32_t tmp___15 ;
  uint32_t tmp___16 ;
  int16_t predictor_coef_table_a[32] ;
  int predictor_coef_num_a ;
  int prediction_type_a ;
  int prediction_quantitization_a ;
  int ricemodifier_a ;
  int16_t predictor_coef_table_b[32] ;
  int predictor_coef_num_b ;
  int prediction_type_b ;
  int prediction_quantitization_b ;
  int ricemodifier_b ;
  int i___5 ;
  uint32_t tmp___17 ;
  uint32_t tmp___18 ;
  uint32_t tmp___19 ;
  uint32_t tmp___20 ;
  uint32_t tmp___21 ;
  uint32_t tmp___22 ;
  uint32_t tmp___23 ;
  uint32_t tmp___24 ;
  uint32_t tmp___25 ;
  uint32_t tmp___26 ;
  uint32_t tmp___27 ;
  uint32_t tmp___28 ;
  int i___6 ;
  uint32_t tmp___29 ;
  uint32_t tmp___30 ;
  int i___7 ;
  int32_t audiobits_a ;
  int32_t audiobits_b ;
  uint32_t tmp___31 ;
  uint32_t tmp___32 ;
  int i___8 ;
  int32_t audiobits_a___0 ;
  int32_t audiobits_b___0 ;
  uint32_t tmp___33 ;
  uint32_t tmp___34 ;
  uint32_t tmp___35 ;
  uint32_t tmp___36 ;

  {
  outputsamples = (int32_t )alac->setinfo_max_samples_per_frame;
  alac->input_buffer = inbuffer;
  alac->input_buffer_bitaccumulator = 0;
  tmp = readbits(alac, 3);
  channels = (int )tmp;
  *outputsize = outputsamples * alac->bytespersample;
  switch (channels) {
  case 0: 
  readbits(alac, 4);
  readbits(alac, 12);
  tmp___0 = readbits(alac, 1);
  hassize = (int )tmp___0;
  tmp___1 = readbits(alac, 2);
  uncompressed_bytes = (int )tmp___1;
  tmp___2 = readbits(alac, 1);
  isnotcompressed = (int )tmp___2;
  if (hassize) {
    tmp___3 = readbits(alac, 32);
    outputsamples = (int32_t )tmp___3;
    *outputsize = outputsamples * alac->bytespersample;
  }
  readsamplesize = (int )alac->setinfo_sample_size - uncompressed_bytes * 8;
  if (! isnotcompressed) {
    readbits(alac, 8);
    readbits(alac, 8);
    tmp___4 = readbits(alac, 4);
    prediction_type = (int )tmp___4;
    tmp___5 = readbits(alac, 4);
    prediction_quantitization = (int )tmp___5;
    tmp___6 = readbits(alac, 3);
    ricemodifier = (int )tmp___6;
    tmp___7 = readbits(alac, 5);
    predictor_coef_num = (int )tmp___7;
    i = 0;
    while (i < predictor_coef_num) {
      tmp___8 = readbits(alac, 16);
      predictor_coef_table[i] = (int16_t )tmp___8;
      i ++;
    }
    if (uncompressed_bytes) {
      i___0 = 0;
      while (i___0 < outputsamples) {
        tmp___9 = readbits(alac, uncompressed_bytes * 8);
        *(alac->uncompressed_bytes_buffer_a + i___0) = (int32_t )tmp___9;
        i___0 ++;
      }
    }
    entropy_rice_decode(alac, alac->predicterror_buffer_a, outputsamples, readsamplesize,
                        (int )alac->setinfo_rice_initialhistory, (int )alac->setinfo_rice_kmodifier,
                        (ricemodifier * (int )alac->setinfo_rice_historymult) / 4,
                        (1 << (int )alac->setinfo_rice_kmodifier) - 1);
    if (prediction_type == 0) {
      predictor_decompress_fir_adapt(alac->predicterror_buffer_a, alac->outputsamples_buffer_a,
                                     outputsamples, readsamplesize, predictor_coef_table,
                                     predictor_coef_num, prediction_quantitization);
    } else {
      _fprintf(stderr, "FIXME: unhandled predicition type: %i\n", prediction_type);
    }
  } else {
    if ((int )alac->setinfo_sample_size <= 16) {
      i___1 = 0;
      while (i___1 < outputsamples) {
        tmp___10 = readbits(alac, (int )alac->setinfo_sample_size);
        audiobits = (int32_t )tmp___10;
        audiobits = (audiobits << (32 - (int )alac->setinfo_sample_size)) >> (32 - (int )alac->setinfo_sample_size);
        *(alac->outputsamples_buffer_a + i___1) = audiobits;
        i___1 ++;
      }
    } else {
      i___2 = 0;
      while (i___2 < outputsamples) {
        tmp___11 = readbits(alac, 16);
        audiobits___0 = (int32_t )tmp___11;
        audiobits___0 <<= (int )alac->setinfo_sample_size - 16;
        tmp___12 = readbits(alac, (int )alac->setinfo_sample_size - 16);
        audiobits___0 = (int32_t )((unsigned int )audiobits___0 | tmp___12);
        se_struct_24.x = audiobits___0;
        audiobits___0 = se_struct_24.x;
        *(alac->outputsamples_buffer_a + i___2) = audiobits___0;
        i___2 ++;
      }
    }
    uncompressed_bytes = 0;
  }
  switch ((int )alac->setinfo_sample_size) {
  case 16: 
  i___3 = 0;
  while (i___3 < outputsamples) {
    sample = (int16_t )*(alac->outputsamples_buffer_a + i___3);
    if (host_bigendian) {
      while (1) {
        sample = (int16_t )((((int )sample & 255) << 8) | (((int )sample & 65280) >> 8));
        break;
      }
    }
    *((int16_t *)outbuffer + i___3 * alac->numchannels) = sample;
    i___3 ++;
  }
  break;
  case 24: 
  i___4 = 0;
  while (i___4 < outputsamples) {
    sample___0 = *(alac->outputsamples_buffer_a + i___4);
    if (uncompressed_bytes) {
      sample___0 <<= uncompressed_bytes * 8;
      mask = ~ (4294967295U << uncompressed_bytes * 8);
      sample___0 = (int32_t )((unsigned int )sample___0 | ((unsigned int )*(alac->uncompressed_bytes_buffer_a + i___4) & mask));
    }
    *((uint8_t *)outbuffer + (i___4 * alac->numchannels) * 3) = (uint8_t )(sample___0 & 255);
    *((uint8_t *)outbuffer + ((i___4 * alac->numchannels) * 3 + 1)) = (uint8_t )((sample___0 >> 8) & 255);
    *((uint8_t *)outbuffer + ((i___4 * alac->numchannels) * 3 + 2)) = (uint8_t )((sample___0 >> 16) & 255);
    i___4 ++;
  }
  break;
  case 32: 
  case 20: 
  _fprintf(stderr, "FIXME: unimplemented sample size %i\n", (int )alac->setinfo_sample_size);
  break;
  default: 
  break;
  }
  break;
  case 1: 
  readbits(alac, 4);
  readbits(alac, 12);
  tmp___13 = readbits(alac, 1);
  hassize___0 = (int )tmp___13;
  tmp___14 = readbits(alac, 2);
  uncompressed_bytes___0 = (int )tmp___14;
  tmp___15 = readbits(alac, 1);
  isnotcompressed___0 = (int )tmp___15;
  if (hassize___0) {
    tmp___16 = readbits(alac, 32);
    outputsamples = (int32_t )tmp___16;
    *outputsize = outputsamples * alac->bytespersample;
  }
  readsamplesize___0 = ((int )alac->setinfo_sample_size - uncompressed_bytes___0 * 8) + 1;
  if (! isnotcompressed___0) {
    tmp___17 = readbits(alac, 8);
    interlacing_shift = (uint8_t )tmp___17;
    tmp___18 = readbits(alac, 8);
    interlacing_leftweight = (uint8_t )tmp___18;
    tmp___19 = readbits(alac, 4);
    prediction_type_a = (int )tmp___19;
    tmp___20 = readbits(alac, 4);
    prediction_quantitization_a = (int )tmp___20;
    tmp___21 = readbits(alac, 3);
    ricemodifier_a = (int )tmp___21;
    tmp___22 = readbits(alac, 5);
    predictor_coef_num_a = (int )tmp___22;
    i___5 = 0;
    while (i___5 < predictor_coef_num_a) {
      tmp___23 = readbits(alac, 16);
      predictor_coef_table_a[i___5] = (int16_t )tmp___23;
      i___5 ++;
    }
    tmp___24 = readbits(alac, 4);
    prediction_type_b = (int )tmp___24;
    tmp___25 = readbits(alac, 4);
    prediction_quantitization_b = (int )tmp___25;
    tmp___26 = readbits(alac, 3);
    ricemodifier_b = (int )tmp___26;
    tmp___27 = readbits(alac, 5);
    predictor_coef_num_b = (int )tmp___27;
    i___5 = 0;
    while (i___5 < predictor_coef_num_b) {
      tmp___28 = readbits(alac, 16);
      predictor_coef_table_b[i___5] = (int16_t )tmp___28;
      i___5 ++;
    }
    if (uncompressed_bytes___0) {
      i___6 = 0;
      while (i___6 < outputsamples) {
        tmp___29 = readbits(alac, uncompressed_bytes___0 * 8);
        *(alac->uncompressed_bytes_buffer_a + i___6) = (int32_t )tmp___29;
        tmp___30 = readbits(alac, uncompressed_bytes___0 * 8);
        *(alac->uncompressed_bytes_buffer_b + i___6) = (int32_t )tmp___30;
        i___6 ++;
      }
    }
    entropy_rice_decode(alac, alac->predicterror_buffer_a, outputsamples, readsamplesize___0,
                        (int )alac->setinfo_rice_initialhistory, (int )alac->setinfo_rice_kmodifier,
                        (ricemodifier_a * (int )alac->setinfo_rice_historymult) / 4,
                        (1 << (int )alac->setinfo_rice_kmodifier) - 1);
    if (prediction_type_a == 0) {
      predictor_decompress_fir_adapt(alac->predicterror_buffer_a, alac->outputsamples_buffer_a,
                                     outputsamples, readsamplesize___0, predictor_coef_table_a,
                                     predictor_coef_num_a, prediction_quantitization_a);
    } else {
      _fprintf(stderr, "FIXME: unhandled predicition type: %i\n", prediction_type_a);
    }
    entropy_rice_decode(alac, alac->predicterror_buffer_b, outputsamples, readsamplesize___0,
                        (int )alac->setinfo_rice_initialhistory, (int )alac->setinfo_rice_kmodifier,
                        (ricemodifier_b * (int )alac->setinfo_rice_historymult) / 4,
                        (1 << (int )alac->setinfo_rice_kmodifier) - 1);
    if (prediction_type_b == 0) {
      predictor_decompress_fir_adapt(alac->predicterror_buffer_b, alac->outputsamples_buffer_b,
                                     outputsamples, readsamplesize___0, predictor_coef_table_b,
                                     predictor_coef_num_b, prediction_quantitization_b);
    } else {
      _fprintf(stderr, "FIXME: unhandled predicition type: %i\n", prediction_type_b);
    }
  } else {
    if ((int )alac->setinfo_sample_size <= 16) {
      i___7 = 0;
      while (i___7 < outputsamples) {
        tmp___31 = readbits(alac, (int )alac->setinfo_sample_size);
        audiobits_a = (int32_t )tmp___31;
        tmp___32 = readbits(alac, (int )alac->setinfo_sample_size);
        audiobits_b = (int32_t )tmp___32;
        audiobits_a = (audiobits_a << (32 - (int )alac->setinfo_sample_size)) >> (32 - (int )alac->setinfo_sample_size);
        audiobits_b = (audiobits_b << (32 - (int )alac->setinfo_sample_size)) >> (32 - (int )alac->setinfo_sample_size);
        *(alac->outputsamples_buffer_a + i___7) = audiobits_a;
        *(alac->outputsamples_buffer_b + i___7) = audiobits_b;
        i___7 ++;
      }
    } else {
      i___8 = 0;
      while (i___8 < outputsamples) {
        tmp___33 = readbits(alac, 16);
        audiobits_a___0 = (int32_t )tmp___33;
        audiobits_a___0 <<= (int )alac->setinfo_sample_size - 16;
        tmp___34 = readbits(alac, (int )alac->setinfo_sample_size - 16);
        audiobits_a___0 = (int32_t )((unsigned int )audiobits_a___0 | tmp___34);
        se_struct_24.x = audiobits_a___0;
        audiobits_a___0 = se_struct_24.x;
        tmp___35 = readbits(alac, 16);
        audiobits_b___0 = (int32_t )tmp___35;
        audiobits_b___0 <<= (int )alac->setinfo_sample_size - 16;
        tmp___36 = readbits(alac, (int )alac->setinfo_sample_size - 16);
        audiobits_b___0 = (int32_t )((unsigned int )audiobits_b___0 | tmp___36);
        se_struct_24.x = audiobits_b___0;
        audiobits_b___0 = se_struct_24.x;
        *(alac->outputsamples_buffer_a + i___8) = audiobits_a___0;
        *(alac->outputsamples_buffer_b + i___8) = audiobits_b___0;
        i___8 ++;
      }
    }
    uncompressed_bytes___0 = 0;
    interlacing_shift = (uint8_t )0;
    interlacing_leftweight = (uint8_t )0;
  }
  switch ((int )alac->setinfo_sample_size) {
  case 16: 
  deinterlace_16(alac->outputsamples_buffer_a, alac->outputsamples_buffer_b, (int16_t *)outbuffer,
                 alac->numchannels, outputsamples, interlacing_shift, interlacing_leftweight);
  break;
  case 24: 
  deinterlace_24(alac->outputsamples_buffer_a, alac->outputsamples_buffer_b, uncompressed_bytes___0,
                 alac->uncompressed_bytes_buffer_a, alac->uncompressed_bytes_buffer_b,
                 (void *)((int16_t *)outbuffer), alac->numchannels, outputsamples,
                 interlacing_shift, interlacing_leftweight);
  break;
  case 32: 
  case 20: 
  _fprintf(stderr, "FIXME: unimplemented sample size %i\n", (int )alac->setinfo_sample_size);
  break;
  default: 
  break;
  }
  break;
  }
  return;
}
}
alac_file *create_alac(int samplesize , int numchannels ) 
{ 
  alac_file *newfile ;
  void *tmp ;

  {
  tmp = malloc(sizeof(alac_file ));
  newfile = (alac_file *)tmp;
  newfile->samplesize = samplesize;
  newfile->numchannels = numchannels;
  newfile->bytespersample = (samplesize / 8) * numchannels;
  return (newfile);
}
}
void delete_alac(alac_file *alac ) 
{ 


  {
  free((void *)alac->predicterror_buffer_a);
  free((void *)alac->predicterror_buffer_b);
  free((void *)alac->outputsamples_buffer_a);
  free((void *)alac->outputsamples_buffer_b);
  free((void *)alac->uncompressed_bytes_buffer_a);
  free((void *)alac->uncompressed_bytes_buffer_b);
  free((void *)alac);
  return;
}
}
#pragma merger("0","/tmp/cil-MvKFQAZh.i","-Wall,-fPIC,-ggdb,-O2,-m64,-fdata-sections,-ffunction-sections")
int base64_encode(void const   *data , int size , char **str___0 ) ;
int base64_decode(char const   *str___0 , void *data ) ;
static char base64_chars[65]  = 
  {      (char )'A',      (char )'B',      (char )'C',      (char )'D', 
        (char )'E',      (char )'F',      (char )'G',      (char )'H', 
        (char )'I',      (char )'J',      (char )'K',      (char )'L', 
        (char )'M',      (char )'N',      (char )'O',      (char )'P', 
        (char )'Q',      (char )'R',      (char )'S',      (char )'T', 
        (char )'U',      (char )'V',      (char )'W',      (char )'X', 
        (char )'Y',      (char )'Z',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'g',      (char )'h',      (char )'i',      (char )'j', 
        (char )'k',      (char )'l',      (char )'m',      (char )'n', 
        (char )'o',      (char )'p',      (char )'q',      (char )'r', 
        (char )'s',      (char )'t',      (char )'u',      (char )'v', 
        (char )'w',      (char )'x',      (char )'y',      (char )'z', 
        (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'+',      (char )'/', 
        (char )'\000'};
static int pos(char c ) 
{ 
  char *p ;

  {
  p = base64_chars;
  while (*p) {
    if ((int )*p == (int )c) {
      return ((int )(p - base64_chars));
    }
    p ++;
  }
  return (-1);
}
}
int base64_encode(void const   *data , int size , char **str___0 ) 
{ 
  char *s ;
  char *p ;
  int i ;
  int c ;
  unsigned char const   *q ;
  void *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  tmp = malloc((size_t )((size * 4) / 3 + 4));
  s = (char *)tmp;
  p = s;
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    return (-1);
  }
  q = (unsigned char const   *)data;
  i = 0;
  i = 0;
  while (i < size) {
    tmp___0 = i;
    i ++;
    c = (int )*(q + tmp___0);
    c *= 256;
    if (i < size) {
      c += (int )*(q + i);
    }
    i ++;
    c *= 256;
    if (i < size) {
      c += (int )*(q + i);
    }
    i ++;
    *(p + 0) = base64_chars[(c & 16515072) >> 18];
    *(p + 1) = base64_chars[(c & 258048) >> 12];
    *(p + 2) = base64_chars[(c & 4032) >> 6];
    *(p + 3) = base64_chars[c & 63];
    if (i > size) {
      *(p + 3) = (char )'=';
    }
    if (i > size + 1) {
      *(p + 2) = (char )'=';
    }
    p += 4;
  }
  *p = (char)0;
  *str___0 = s;
  tmp___1 = strlen((char const   *)s);
  return ((int )tmp___1);
}
}
static unsigned int token_decode(char const   *token ) 
{ 
  int i ;
  unsigned int val ;
  int marker ;
  size_t tmp ;
  int tmp___0 ;

  {
  val = 0U;
  marker = 0;
  tmp = strlen(token);
  if (tmp < 4UL) {
    return (4294967295U);
  }
  i = 0;
  while (i < 4) {
    val *= 64U;
    if ((int const   )*(token + i) == 61) {
      marker ++;
    } else
    if (marker > 0) {
      return (4294967295U);
    } else {
      tmp___0 = pos((char )*(token + i));
      val += (unsigned int )tmp___0;
    }
    i ++;
  }
  if (marker > 2) {
    return (4294967295U);
  }
  return ((unsigned int )(marker << 24) | val);
}
}
int base64_decode(char const   *str___0 , void *data ) 
{ 
  char const   *p ;
  unsigned char *q ;
  unsigned int val ;
  unsigned int tmp ;
  unsigned int marker ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  char *tmp___3 ;

  {
  q = (unsigned char *)data;
  p = str___0;
  while (1) {
    if (*p) {
      if (! ((int const   )*p == 61)) {
        tmp___3 = strchr((char const   *)(base64_chars), (int )*p);
        if (! tmp___3) {
          break;
        }
      }
    } else {
      break;
    }
    tmp = token_decode(p);
    val = tmp;
    marker = (val >> 24) & 255U;
    if (val == 4294967295U) {
      return (-1);
    }
    tmp___0 = q;
    q ++;
    *tmp___0 = (unsigned char )((val >> 16) & 255U);
    if (marker < 2U) {
      tmp___1 = q;
      q ++;
      *tmp___1 = (unsigned char )((val >> 8) & 255U);
    }
    if (marker < 1U) {
      tmp___2 = q;
      q ++;
      *tmp___2 = (unsigned char )(val & 255U);
    }
    p += 4;
  }
  return ((int )(q - (unsigned char *)data));
}
}
#pragma merger("0","/tmp/cil-3ST77D3k.i","-Wall,-fPIC,-ggdb,-O2,-m64,-fdata-sections,-ffunction-sections")
__inline static __uint16_t __bswap_16(__uint16_t __bsx ) 
{ 


  {
  return ((__uint16_t )((((int )__bsx >> 8) & 255) | (((int )__bsx & 255) << 8)));
}
}
__inline static __uint32_t __bswap_32(__uint32_t __bsx ) 
{ 


  {
  return (((((__bsx & 4278190080U) >> 24) | ((__bsx & 16711680U) >> 8)) | ((__bsx & 65280U) << 8)) | ((__bsx & 255U) << 24));
}
}
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
extern  __attribute__((__nothrow__)) int rand(void) ;
extern  __attribute__((__nothrow__)) long long llabs(long long __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strsep)(char ** __restrict  __stringp ,
                                                                                       char const   * __restrict  __delim ) ;
extern int AES_set_decrypt_key(unsigned char const   *userKey , int const   bits ,
                               AES_KEY *key ) ;
extern void AES_cbc_encrypt(unsigned char const   *in , unsigned char *out , size_t length ,
                            AES_KEY const   *key , unsigned char *ivec , int const   enc ) ;
extern int close(int __fd ) ;
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  * __restrict  __addr , socklen_t __addr_len ) ;
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
void dup_metadata(struct metadata_s *dst , struct metadata_s *src ) ;
char *itoa(int value , char *str___0 , int radix ) ;
int shutdown_socket(int sd ) ;
int bind_socket(unsigned short *port , int mode ) ;
_Bool http_parse(int sock , char *method , char *resource , char *proto , key_data_t *rkd ,
                 char **body , int *len ) ;
char *http_send(int sock , char *method , key_data_t *rkd ) ;
_Bool kd_vadd(key_data_t *kd , char *key , char *fmt  , ...) ;
char *kd_dump(key_data_t *kd ) ;
void kd_free(key_data_t *kd ) ;
hairtunes_resp_t hairtunes_init(struct in_addr host , encode_t codec , _Bool sync___0 ,
                                _Bool drift , _Bool range , char *latencies , char *aeskey ,
                                char *aesiv , char *fmtpstr , unsigned short pCtrlPort ,
                                unsigned short pTimingPort , void *owner , void (*event_cb___0)(void *owner ,
                                                                                                hairtunes_event_t event ) ,
                                void (*http_cb___0)(void *owner , struct key_data_s *headers ,
                                                    struct key_data_s *response ) ,
                                unsigned short port_base , unsigned short port_range ,
                                int http_length ) ;
void hairtunes_end(struct hairtunes_s *ctx ) ;
_Bool hairtunes_flush(struct hairtunes_s *ctx , unsigned short seqno , unsigned int rtptime ,
                      _Bool exit_locked , _Bool silence ) ;
void hairtunes_flush_release(struct hairtunes_s *ctx ) ;
void hairtunes_record(struct hairtunes_s *ctx , unsigned short seqno , unsigned int rtptime ) ;
void hairtunes_metadata(struct hairtunes_s *ctx , struct metadata_s *metadata ) ;
extern FLAC__StreamEncoder *FLAC__stream_encoder_new(void) ;
extern void FLAC__stream_encoder_delete(FLAC__StreamEncoder *encoder ) ;
extern FLAC__bool FLAC__stream_encoder_set_verify(FLAC__StreamEncoder *encoder , FLAC__bool value ) ;
extern FLAC__bool FLAC__stream_encoder_set_streamable_subset(FLAC__StreamEncoder *encoder ,
                                                             FLAC__bool value ) ;
extern FLAC__bool FLAC__stream_encoder_set_channels(FLAC__StreamEncoder *encoder ,
                                                    uint32_t value ) ;
extern FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder ,
                                                           uint32_t value ) ;
extern FLAC__bool FLAC__stream_encoder_set_sample_rate(FLAC__StreamEncoder *encoder ,
                                                       uint32_t value ) ;
extern FLAC__bool FLAC__stream_encoder_set_compression_level(FLAC__StreamEncoder *encoder ,
                                                             uint32_t value ) ;
extern FLAC__bool FLAC__stream_encoder_set_blocksize(FLAC__StreamEncoder *encoder ,
                                                     uint32_t value ) ;
extern FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_stream(FLAC__StreamEncoder *encoder ,
                                                                      FLAC__StreamEncoderWriteStatus (*write_callback)(FLAC__StreamEncoder const   *encoder ,
                                                                                                                       FLAC__byte const   *buffer ,
                                                                                                                       size_t bytes ,
                                                                                                                       uint32_t samples ,
                                                                                                                       uint32_t current_frame ,
                                                                                                                       void *client_data ) ,
                                                                      FLAC__StreamEncoderSeekStatus (*seek_callback)(FLAC__StreamEncoder const   *encoder ,
                                                                                                                     FLAC__uint64 absolute_byte_offset ,
                                                                                                                     void *client_data ) ,
                                                                      FLAC__StreamEncoderTellStatus (*tell_callback)(FLAC__StreamEncoder const   *encoder ,
                                                                                                                     FLAC__uint64 *absolute_byte_offset ,
                                                                                                                     void *client_data ) ,
                                                                      void (*metadata_callback)(FLAC__StreamEncoder const   *encoder ,
                                                                                                FLAC__StreamMetadata const   *metadata ,
                                                                                                void *client_data ) ,
                                                                      void *client_data ) ;
extern FLAC__bool FLAC__stream_encoder_finish(FLAC__StreamEncoder *encoder ) ;
extern FLAC__bool FLAC__stream_encoder_process_interleaved(FLAC__StreamEncoder *encoder ,
                                                           FLAC__int32 const   *buffer ,
                                                           uint32_t samples ) ;
extern void shine_set_config_mpeg_defaults(shine_mpeg_t *mpeg ) ;
extern shine_t shine_initialise(shine_config_t *config ) ;
extern int shine_samples_per_pass(shine_t s ) ;
extern unsigned char *shine_encode_buffer_interleaved(shine_t s , int16_t *data ,
                                                      int *written ) ;
extern unsigned char *shine_flush(shine_t s , int *written ) ;
extern void shine_close(shine_t s ) ;
static log_level *loglevel___2  =    & raop_loglevel;
static char *mime_types[4]  = {      (char *)"audio/mpeg",      (char *)"audio/flac",      (char *)"audio/L16;rate=44100;channels=2",      (char *)"audio/wav"};
static struct wave_header_s wave_header  = 
     {{(u8_t )'R', (u8_t )'I', (u8_t )'F', (u8_t )'F'}, {(u8_t )36, (u8_t )255, (u8_t )255,
                                                       (u8_t )255}, {(u8_t )'W', (u8_t )'A',
                                                                     (u8_t )'V', (u8_t )'E'},
    {(u8_t )'f', (u8_t )'m', (u8_t )'t', (u8_t )' '}, {(u8_t )16, (u8_t )0, (u8_t )0,
                                                       (u8_t )0}, {(u8_t )1, (u8_t )0},
    {(u8_t )2, (u8_t )0}, {(u8_t )68, (u8_t )172, (u8_t )0, (u8_t )0}, {(u8_t )16,
                                                                        (u8_t )177,
                                                                        (u8_t )2,
                                                                        (u8_t )0},
    {(u8_t )4, (u8_t )0}, {(u8_t )16, (u8_t )0}, {(u8_t )'d', (u8_t )'a', (u8_t )'t',
                                                  (u8_t )'a'}, {(u8_t )0, (u8_t )255,
                                                                (u8_t )255, (u8_t )255}};
static void buffer_alloc(abuf_t *audio_buffer ,
                         int size ) ;
static void buffer_release(abuf_t *audio_buffer ) ;
static void buffer_reset(abuf_t *audio_buffer ) ;
static void flac_init(hairtunes_t *ctx ) ;
static _Bool rtp_request_resend(hairtunes_t *ctx , seq_t first , seq_t last ) ;
static _Bool rtp_request_timing(hairtunes_t *ctx ) ;
static void *rtp_thread_func(void *arg ) ;
static void *http_thread_func(void *arg ) ;
static _Bool handle_http(hairtunes_t *ctx , int sock ) ;
static int seq_order(seq_t a , seq_t b ) ;
static FLAC__StreamEncoderWriteStatus flac_write_callback(FLAC__StreamEncoder const   *encoder ,
                                                          FLAC__byte const   *buffer ,
                                                          size_t bytes , unsigned int samples ,
                                                          unsigned int current_frame ,
                                                          void *client_data ) ;
static void flac_init(hairtunes_t *ctx ) 
{ 
  _Bool ok ;
  FLAC__StreamEncoder *codec ;
  FLAC__StreamEncoder *tmp ;
  char const   *tmp___0 ;
  FLAC__bool tmp___1 ;
  FLAC__bool tmp___2 ;
  FLAC__bool tmp___3 ;
  FLAC__bool tmp___4 ;
  FLAC__bool tmp___5 ;
  FLAC__bool tmp___6 ;
  FLAC__bool tmp___7 ;
  FLAC__StreamEncoderInitStatus tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;

  {
  ok = (_Bool)1;
  ctx->encode.len = 0;
  ctx->encode.header = (_Bool)1;
  tmp = FLAC__stream_encoder_new();
  ctx->encode.codec = (void *)tmp;
  codec = (FLAC__StreamEncoder *)ctx->encode.codec;
  if ((unsigned int )*loglevel___2 >= 2U) {
    tmp___0 = logtime();
    logprint("%s %s:%d [%p]: Using FLAC-%u (%p)\n", tmp___0, "flac_init", 220, ctx,
             ctx->encode.config.__annonCompField8.flac.level, ctx->encode.codec);
  }
  tmp___1 = FLAC__stream_encoder_set_verify(codec, 0);
  ok = (_Bool )((int )ok & tmp___1);
  tmp___2 = FLAC__stream_encoder_set_compression_level(codec, (uint32_t )ctx->encode.config.__annonCompField8.flac.level);
  ok = (_Bool )((int )ok & tmp___2);
  tmp___3 = FLAC__stream_encoder_set_channels(codec, (uint32_t )2);
  ok = (_Bool )((int )ok & tmp___3);
  tmp___4 = FLAC__stream_encoder_set_bits_per_sample(codec, (uint32_t )16);
  ok = (_Bool )((int )ok & tmp___4);
  tmp___5 = FLAC__stream_encoder_set_sample_rate(codec, (uint32_t )44100);
  ok = (_Bool )((int )ok & tmp___5);
  tmp___6 = FLAC__stream_encoder_set_blocksize(codec, (uint32_t )1024);
  ok = (_Bool )((int )ok & tmp___6);
  tmp___7 = FLAC__stream_encoder_set_streamable_subset(codec, 1);
  ok = (_Bool )((int )ok & tmp___7);
  tmp___8 = FLAC__stream_encoder_init_stream(codec, & flac_write_callback, (FLAC__StreamEncoderSeekStatus (*)(FLAC__StreamEncoder const   *encoder ,
                                                                                                              FLAC__uint64 absolute_byte_offset ,
                                                                                                              void *client_data ))((void *)0),
                                             (FLAC__StreamEncoderTellStatus (*)(FLAC__StreamEncoder const   *encoder ,
                                                                                FLAC__uint64 *absolute_byte_offset ,
                                                                                void *client_data ))((void *)0),
                                             (void (*)(FLAC__StreamEncoder const   *encoder ,
                                                       FLAC__StreamMetadata const   *metadata ,
                                                       void *client_data ))((void *)0),
                                             (void *)ctx);
  if (tmp___8) {
    tmp___9 = 0;
  } else {
    tmp___9 = 1;
  }
  ok = (_Bool )((int )ok & tmp___9);
  if (! ok) {
    tmp___10 = logtime();
    logprint("%s %s:%d {%p]: Cannot set FLAC parameters\n", tmp___10, "flac_init",
             232, ctx);
  }
  return;
}
}
static FLAC__StreamEncoderWriteStatus flac_write_callback(FLAC__StreamEncoder const   *encoder ,
                                                          FLAC__byte const   *buffer ,
                                                          size_t bytes , unsigned int samples ,
                                                          unsigned int current_frame ,
                                                          void *client_data ) 
{ 
  hairtunes_t *ctx ;
  char const   *tmp ;

  {
  ctx = (hairtunes_t *)client_data;
  if ((size_t )ctx->encode.len + bytes <= 5120UL) {
    memcpy((void * __restrict  )(ctx->encode.buffer + ctx->encode.len), (void const   * __restrict  )buffer,
           bytes);
    ctx->encode.len = (int )((size_t )ctx->encode.len + bytes);
  } else
  if ((unsigned int )*loglevel___2 >= 1U) {
    tmp = logtime();
    logprint("%s %s:%d [%p]: flac coded buffer too big %u\n", tmp, "flac_write_callback",
             244, ctx, bytes);
  }
  return ((FLAC__StreamEncoderWriteStatus )0);
}
}
static void mp3_init(hairtunes_t *ctx ) 
{ 
  shine_config_t config ;
  shine_t tmp ;
  char const   *tmp___0 ;

  {
  ctx->encode.len = 0;
  shine_set_config_mpeg_defaults(& config.mpeg);
  config.wave.samplerate = 44100;
  config.wave.channels = (enum channels )2;
  if (ctx->encode.config.__annonCompField8.mp3.bitrate) {
    config.mpeg.bitr = ctx->encode.config.__annonCompField8.mp3.bitrate;
  } else {
    config.mpeg.bitr = 128;
  }
  config.mpeg.mode = (enum modes )0;
  tmp = shine_initialise(& config);
  ctx->encode.codec = (void *)tmp;
  if ((unsigned int )*loglevel___2 >= 2U) {
    tmp___0 = logtime();
    logprint("%s %s:%d [%p]: Using shine MP3-%u (%p)\n", tmp___0, "mp3_init", 263,
             ctx, ctx->encode.config.__annonCompField8.mp3.bitrate, ctx->encode.codec);
  }
  return;
}
}
static void encoder_close(hairtunes_t *ctx ) 
{ 
  int len ;

  {
  if (! ctx->encode.codec) {
    return;
  }
  if ((unsigned int )ctx->encode.config.codec == 1U) {
    FLAC__stream_encoder_finish((FLAC__StreamEncoder *)ctx->encode.codec);
    FLAC__stream_encoder_delete((FLAC__StreamEncoder *)ctx->encode.codec);
  } else
  if ((unsigned int )ctx->encode.config.codec == 0U) {
    shine_flush((shine_t )ctx->encode.codec, & len);
    shine_close((shine_t )ctx->encode.codec);
  }
  ctx->encode.codec = (void *)0;
  return;
}
}
static alac_file *alac_init(int *fmtp ) 
{ 
  alac_file *alac ;
  int sample_size ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  sample_size = *(fmtp + 3);
  if (sample_size != 16) {
    tmp = logtime();
    logprint("%s %s:%d sample size must be 16 %d\n", tmp, "alac_init", 288, sample_size);
    return ((alac_file *)0);
  }
  alac = create_alac(sample_size, 2);
  if (! alac) {
    tmp___0 = logtime();
    logprint("%s %s:%d cannot create alac codec\n", tmp___0, "alac_init", 295, (void *)0);
    return ((alac_file *)((void *)0));
  }
  alac->setinfo_max_samples_per_frame = (uint32_t )*(fmtp + 1);
  alac->setinfo_7a = (uint8_t )*(fmtp + 2);
  alac->setinfo_sample_size = (uint8_t )sample_size;
  alac->setinfo_rice_historymult = (uint8_t )*(fmtp + 4);
  alac->setinfo_rice_initialhistory = (uint8_t )*(fmtp + 5);
  alac->setinfo_rice_kmodifier = (uint8_t )*(fmtp + 6);
  alac->setinfo_7f = (uint8_t )*(fmtp + 7);
  alac->setinfo_80 = (uint16_t )*(fmtp + 8);
  alac->setinfo_82 = (uint32_t )*(fmtp + 9);
  alac->setinfo_86 = (uint32_t )*(fmtp + 10);
  alac->setinfo_8a_rate = (uint32_t )*(fmtp + 11);
  allocate_buffers(alac);
  return (alac);
}
}
hairtunes_resp_t hairtunes_init(struct in_addr host , encode_t codec , _Bool sync___0 ,
                                _Bool drift , _Bool range , char *latencies , char *aeskey ,
                                char *aesiv , char *fmtpstr , unsigned short pCtrlPort ,
                                unsigned short pTimingPort , void *owner , void (*event_cb___0)(void *owner ,
                                                                                                hairtunes_event_t event ) ,
                                void (*http_cb___0)(void *owner , struct key_data_s *headers ,
                                                    struct key_data_s *response ) ,
                                unsigned short port_base , unsigned short port_range ,
                                int http_length ) 
{ 
  int i ;
  char *arg ;
  char *p ;
  int fmtp[12] ;
  _Bool rc ;
  hairtunes_t *ctx ;
  void *tmp ;
  hairtunes_resp_t resp ;
  struct __anonstruct_port_213969425 port ;
  int tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  unsigned short tmp___5 ;
  char const   *tmp___6 ;
  unsigned short tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;

  {
  i = 0;
  rc = (_Bool)1;
  tmp = calloc((size_t )1, sizeof(hairtunes_t ));
  ctx = (hairtunes_t *)tmp;
  resp.cport = (unsigned short)0;
  resp.tport = (unsigned short)0;
  resp.aport = (unsigned short)0;
  resp.hport = (unsigned short)0;
  resp.ctx = (struct hairtunes_s *)((void *)0);
  port.count = (unsigned short)0;
  port.offset = (unsigned short)0;
  if (! port_base) {
    port_range = (unsigned short)1;
  }
  tmp___0 = rand();
  port.offset = (unsigned short )(tmp___0 % (int )port_range);
  if (! ctx) {
    return (resp);
  }
  tmp___1 = malloc((size_t )2097152);
  ctx->http_tail = (char *)tmp___1;
  if (! ctx->http_tail) {
    free((void *)ctx);
    return (resp);
  }
  ctx->http_length = http_length;
  ctx->host = host;
  ctx->rtp_host.sin_family = (sa_family_t )2;
  ctx->rtp_host.sin_addr.s_addr = (in_addr_t )0;
  pthread_mutex_init(& ctx->ab_mutex, (pthread_mutexattr_t const   *)0);
  ctx->flush_seqno = -1;
  ctx->encode.config = codec;
  ctx->encode.header = (_Bool)0;
  ctx->latency = atoi((char const   *)latencies);
  ctx->latency = (ctx->latency * 44100) / 1000;
  tmp___2 = strstr((char const   *)latencies, ":f");
  if (tmp___2) {
    ctx->http_fill = (_Bool)1;
  }
  ctx->event_cb = event_cb___0;
  ctx->http_cb = http_cb___0;
  ctx->owner = owner;
  ctx->synchro.required = sync___0;
  ctx->timing.drift = drift;
  ctx->range = range;
  ctx->ab_read = (seq_t )((int )ctx->ab_write + 1);
  ctx->rtp_sockets[1].rport = pCtrlPort;
  ctx->rtp_sockets[2].rport = pTimingPort;
  if (aesiv) {
    if (aeskey) {
      memcpy((void * __restrict  )(ctx->aesiv), (void const   * __restrict  )aesiv,
             (size_t )16);
      AES_set_decrypt_key((unsigned char const   *)((unsigned char *)aeskey), (int const   )128,
                          & ctx->aes);
      ctx->decrypt = (_Bool)1;
    }
  }
  memset((void *)(fmtp), 0, sizeof(fmtp));
  while (1) {
    arg = strsep((char ** __restrict  )(& fmtpstr), (char const   * __restrict  )" \t");
    if (! ((unsigned long )arg != (unsigned long )((void *)0))) {
      break;
    }
    tmp___3 = i;
    i ++;
    fmtp[tmp___3] = atoi((char const   *)arg);
  }
  ctx->frame_size = fmtp[1];
  tmp___4 = calloc((size_t )ctx->frame_size, (size_t )4);
  ctx->silence_frame = (char *)tmp___4;
  p = strchr((char const   *)latencies, ':');
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    ctx->delay = atoi((char const   *)(p + 1));
    ctx->delay = (ctx->delay * 44100) / (ctx->frame_size * 1000);
  }
  ctx->alac_codec = alac_init((int *)(fmtp));
  rc = (_Bool )((int )rc & ((unsigned long )ctx->alac_codec != (unsigned long )((void *)0)));
  buffer_alloc(ctx->audio_buffer, ctx->frame_size * 4);
  i = 0;
  while (1) {
    if (rc) {
      if (! (i < 3)) {
        break;
      }
    } else {
      break;
    }
    while (1) {
      tmp___5 = port.count;
      port.count = (unsigned short )((int )port.count + 1);
      ctx->rtp_sockets[i].lport = (unsigned short )((int )port_base + ((int )port.offset + (int )tmp___5) % (int )port_range);
      ctx->rtp_sockets[i].sock = bind_socket(& ctx->rtp_sockets[i].lport, 2);
      if (ctx->rtp_sockets[i].sock < 0) {
        if (! ((int )port.count < (int )port_range)) {
          break;
        }
      } else {
        break;
      }
    }
    rc = (_Bool )((int )rc & (ctx->rtp_sockets[i].sock > 0));
    if ((unsigned int )*loglevel___2 >= 2U) {
      tmp___6 = logtime();
      logprint("%s %s:%d [%p]: UDP port-%d %hu\n", tmp___6, "hairtunes_init", 404,
               ctx, i, (int )ctx->rtp_sockets[i].lport);
    }
    i ++;
  }
  while (1) {
    tmp___7 = port.count;
    port.count = (unsigned short )((int )port.count + 1);
    resp.hport = (unsigned short )((int )port_base + ((int )port.offset + (int )tmp___7) % (int )port_range);
    ctx->http_listener = bind_socket(& resp.hport, 1);
    if (ctx->http_listener < 0) {
      if (! ((int )port.count < (int )port_range)) {
        break;
      }
    } else {
      break;
    }
  }
  i = 131072;
  setsockopt(ctx->http_listener, 1, 7, (void const   *)((void *)(& i)), (socklen_t )sizeof(i));
  rc = (_Bool )((int )rc & (ctx->http_listener > 0));
  tmp___8 = listen(ctx->http_listener, 1);
  rc = (_Bool )((int )rc & (tmp___8 == 0));
  resp.cport = ctx->rtp_sockets[1].lport;
  resp.tport = ctx->rtp_sockets[2].lport;
  resp.aport = ctx->rtp_sockets[0].lport;
  if ((unsigned int )*loglevel___2 >= 2U) {
    tmp___9 = logtime();
    logprint("%s %s:%d [%p]: HTTP listening port %hu\n", tmp___9, "hairtunes_init",
             422, ctx, (int )resp.hport);
  }
  if (rc) {
    ctx->running = (_Bool)1;
    pthread_create((pthread_t * __restrict  )(& ctx->rtp_thread), (pthread_attr_t const   * __restrict  )((void *)0),
                   & rtp_thread_func, (void * __restrict  )((void *)ctx));
    pthread_create((pthread_t * __restrict  )(& ctx->http_thread), (pthread_attr_t const   * __restrict  )((void *)0),
                   & http_thread_func, (void * __restrict  )((void *)ctx));
  } else {
    hairtunes_end(ctx);
    ctx = (hairtunes_t *)((void *)0);
  }
  resp.ctx = ctx;
  return (resp);
}
}
void hairtunes_metadata(struct hairtunes_s *ctx , struct metadata_s *metadata ) 
{ 


  {
  pthread_mutex_lock(& ctx->ab_mutex);
  free_metadata(& ctx->metadata);
  dup_metadata(& ctx->metadata, metadata);
  ctx->icy.updated = (_Bool)1;
  pthread_mutex_unlock(& ctx->ab_mutex);
  return;
}
}
void hairtunes_end(struct hairtunes_s *ctx ) 
{ 
  int i ;

  {
  if (! ctx) {
    return;
  }
  if (ctx->running) {
    ctx->running = (_Bool)0;
    pthread_join(ctx->rtp_thread, (void **)((void *)0));
    pthread_join(ctx->http_thread, (void **)((void *)0));
  }
  shutdown_socket(ctx->http_listener);
  i = 0;
  while (i < 3) {
    if (ctx->rtp_sockets[i].sock > 0) {
      close(ctx->rtp_sockets[i].sock);
    }
    i ++;
  }
  delete_alac(ctx->alac_codec);
  if (ctx->encode.codec) {
    if ((unsigned int )ctx->encode.config.codec == 1U) {
      FLAC__stream_encoder_finish((FLAC__StreamEncoder *)ctx->encode.codec);
      FLAC__stream_encoder_delete((FLAC__StreamEncoder *)ctx->encode.codec);
    } else
    if ((unsigned int )ctx->encode.config.codec == 0U) {
      shine_close((shine_t )ctx->encode.codec);
    }
  }
  pthread_mutex_destroy(& ctx->ab_mutex);
  buffer_release(ctx->audio_buffer);
  free((void *)ctx->silence_frame);
  free((void *)ctx->http_tail);
  free_metadata(& ctx->metadata);
  free((void *)ctx);
  return;
}
}
_Bool hairtunes_flush(struct hairtunes_s *ctx , unsigned short seqno , unsigned int rtptime ,
                      _Bool exit_locked , _Bool silence ) 
{ 
  _Bool rc ;
  u32_t now ;
  u32_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  rc = (_Bool)1;
  tmp = gettime_ms();
  now = tmp;
  if (now < ctx->record.time + 250U) {
    rc = (_Bool)0;
    tmp___0 = logtime();
    logprint("%s %s:%d [%p]: FLUSH ignored as same as RECORD (%hu - %u)\n", tmp___0,
             "hairtunes_flush", 495, ctx, (int )seqno, rtptime);
  } else
  if ((int )ctx->record.seqno == (int )seqno) {
    if (ctx->record.rtptime == rtptime) {
      rc = (_Bool)0;
      tmp___0 = logtime();
      logprint("%s %s:%d [%p]: FLUSH ignored as same as RECORD (%hu - %u)\n", tmp___0,
               "hairtunes_flush", 495, ctx, (int )seqno, rtptime);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    pthread_mutex_lock(& ctx->ab_mutex);
    buffer_reset(ctx->audio_buffer);
    ctx->flush_seqno = (int )seqno;
    if (silence) {
      ctx->pause = (_Bool)1;
    } else {
      ctx->playing = (_Bool)0;
      ctx->synchro.first = (_Bool)0;
      ctx->http_ready = (_Bool)0;
      encoder_close(ctx);
    }
    if (! exit_locked) {
      pthread_mutex_unlock(& ctx->ab_mutex);
    }
  }
  if ((unsigned int )*loglevel___2 >= 2U) {
    tmp___1 = logtime();
    logprint("%s %s:%d [%p]: flush %hu %u\n", tmp___1, "hairtunes_flush", 511, ctx,
             (int )seqno, rtptime);
  }
  return (rc);
}
}
void hairtunes_flush_release(struct hairtunes_s *ctx ) 
{ 


  {
  pthread_mutex_unlock(& ctx->ab_mutex);
  return;
}
}
void hairtunes_record(struct hairtunes_s *ctx , unsigned short seqno , unsigned int rtptime ) 
{ 
  char const   *tmp ;

  {
  ctx->record.seqno = seqno;
  ctx->record.rtptime = rtptime;
  ctx->record.time = gettime_ms();
  if ((unsigned int )*loglevel___2 >= 2U) {
    tmp = logtime();
    logprint("%s %s:%d [%p]: record %hu %u\n", tmp, "hairtunes_record", 529, ctx,
             (int )seqno, rtptime);
  }
  return;
}
}
static void buffer_alloc(abuf_t *audio_buffer , int size ) 
{ 
  int i ;
  void *tmp ;

  {
  i = 0;
  while (i < 1024) {
    tmp = malloc((size_t )size);
    (audio_buffer + i)->data = (s16_t *)tmp;
    (audio_buffer + i)->ready = 0;
    i ++;
  }
  return;
}
}
static void buffer_release(abuf_t *audio_buffer ) 
{ 
  int i ;

  {
  i = 0;
  while (i < 1024) {
    free((void *)(audio_buffer + i)->data);
    i ++;
  }
  return;
}
}
static void buffer_reset(abuf_t *audio_buffer ) 
{ 
  int i ;

  {
  i = 0;
  while (i < 1024) {
    (audio_buffer + i)->ready = 0;
    i ++;
  }
  return;
}
}
static int seq_order(seq_t a , seq_t b ) 
{ 
  s16_t d ;

  {
  d = (s16_t )((int )b - (int )a);
  return ((int )d > 0);
}
}
static void alac_decode(hairtunes_t *ctx , s16_t *dest , char *buf___0 , int len ,
                        int *outsize ) 
{ 
  unsigned char packet[2048] ;
  unsigned char iv[16] ;
  int aeslen ;

  {
  if (ctx->decrypt) {
    aeslen = len & -16;
    memcpy((void * __restrict  )(iv), (void const   * __restrict  )(ctx->aesiv), sizeof(iv));
    AES_cbc_encrypt((unsigned char const   *)((unsigned char *)buf___0), packet, (size_t )aeslen,
                    (AES_KEY const   *)(& ctx->aes), iv, (int const   )0);
    memcpy((void * __restrict  )(packet + aeslen), (void const   * __restrict  )(buf___0 + aeslen),
           (size_t )(len - aeslen));
    decode_frame(ctx->alac_codec, packet, (void *)dest, outsize);
  } else {
    decode_frame(ctx->alac_codec, (unsigned char *)buf___0, (void *)dest, outsize);
  }
  return;
}
}
static void buffer_put_packet(hairtunes_t *ctx , seq_t seqno , unsigned int rtptime ,
                              _Bool first , char *data , int len ) 
{ 
  abuf_t *abuf ;
  u32_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  seq_t i ;
  u32_t now ;
  u32_t tmp___7 ;
  int tmp___8 ;
  _Bool tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char const   *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  abuf = (abuf_t *)((void *)0);
  pthread_mutex_lock(& ctx->ab_mutex);
  if (! ctx->playing) {
    if (ctx->flush_seqno == -1) {
      goto _L___1;
    } else {
      tmp___0 = seq_order((seq_t )ctx->flush_seqno, seqno);
      if (tmp___0) {
        _L___1: /* CIL Label */ 
        if (ctx->synchro.required) {
          if (ctx->synchro.first) {
            goto _L;
          } else {
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
        if (! ctx->synchro.required) {
          _L: /* CIL Label */ 
          ctx->ab_write = (seq_t )((int )seqno - 1);
          ctx->ab_read = seqno;
          ctx->skip = 0;
          ctx->flush_seqno = -1;
          ctx->playing = (_Bool)1;
          ctx->silence = (_Bool)1;
          ctx->synchro.first = (_Bool)0;
          tmp = (u32_t )0;
          ctx->silent_frames = tmp;
          ctx->resent_frames = tmp;
          ctx->http_count = (size_t )0;
          if ((unsigned int )ctx->encode.config.codec == 1U) {
            flac_init(ctx);
          } else
          if ((unsigned int )ctx->encode.config.codec == 0U) {
            mp3_init(ctx);
          } else
          if ((unsigned int )ctx->encode.config.codec == 3U) {
            ctx->encode.header = (_Bool)1;
          }
        } else {
          pthread_mutex_unlock(& ctx->ab_mutex);
          return;
        }
      } else {
        pthread_mutex_unlock(& ctx->ab_mutex);
        return;
      }
    }
  }
  if (ctx->pause) {
    tmp___1 = seq_order((seq_t )ctx->flush_seqno, seqno);
    if (tmp___1) {
      ctx->pause = (_Bool)0;
    }
  }
  if ((int )seqno == (int )((u16_t )((int )ctx->ab_write + 1))) {
    abuf = ctx->audio_buffer + (int )seqno % 1024;
    ctx->ab_write = seqno;
    if ((unsigned int )*loglevel___2 >= 4U) {
      tmp___2 = logtime();
      logprint("%s %s:%d [%p]: packet expected seqno:%hu rtptime:%u (W:%hu R:%hu)\n",
               tmp___2, "buffer_put_packet", 614, ctx, (int )seqno, rtptime, (int )ctx->ab_write,
               (int )ctx->ab_read);
    }
  } else {
    tmp___14 = seq_order(ctx->ab_write, seqno);
    if (tmp___14) {
      if (ctx->latency) {
        tmp___4 = seq_order((seq_t )(ctx->latency / ctx->frame_size), (seq_t )(((int )seqno - (int )ctx->ab_write) - 1));
        if (tmp___4) {
          if ((unsigned int )*loglevel___2 >= 1U) {
            tmp___3 = logtime();
            logprint("%s %s:%d [%p] too many missing frames %hu\n", tmp___3, "buffer_put_packet",
                     619, ctx, ((int )seqno - (int )ctx->ab_write) - 1);
          }
          ctx->ab_write = (seq_t )((int )seqno - ctx->latency / ctx->frame_size);
        }
      }
      if (ctx->delay) {
        tmp___6 = seq_order((seq_t )ctx->delay, (seq_t )((int )seqno - (int )ctx->ab_read));
        if (tmp___6) {
          if ((unsigned int )*loglevel___2 >= 1U) {
            tmp___5 = logtime();
            logprint("%s %s:%d [%p] on hold for too long %hu\n", tmp___5, "buffer_put_packet",
                     624, ctx, ((int )seqno - (int )ctx->ab_read) + 1);
          }
          ctx->ab_read = (seq_t )(((int )seqno - ctx->delay) + 1);
        }
      }
      tmp___9 = rtp_request_resend(ctx, (seq_t )((int )ctx->ab_write + 1), (seq_t )((int )seqno - 1));
      if (tmp___9) {
        tmp___7 = gettime_ms();
        now = tmp___7;
        i = (seq_t )((int )ctx->ab_write + 1);
        while (1) {
          tmp___8 = seq_order(i, seqno);
          if (! tmp___8) {
            break;
          }
          ctx->audio_buffer[(int )i % 1024].rtptime = rtptime - (unsigned int )(((int )seqno - (int )i) * ctx->frame_size);
          ctx->audio_buffer[(int )i % 1024].last_resend = now;
          i = (seq_t )((int )i + 1);
        }
      }
      if ((unsigned int )*loglevel___2 >= 3U) {
        tmp___10 = logtime();
        logprint("%s %s:%d [%p]: packet newer seqno:%hu rtptime:%u (W:%hu R:%hu)\n",
                 tmp___10, "buffer_put_packet", 635, ctx, (int )seqno, rtptime, (int )ctx->ab_write,
                 (int )ctx->ab_read);
      }
      abuf = ctx->audio_buffer + (int )seqno % 1024;
      ctx->ab_write = seqno;
    } else {
      tmp___13 = seq_order(ctx->ab_read, (seq_t )((int )seqno + 1));
      if (tmp___13) {
        abuf = ctx->audio_buffer + (int )seqno % 1024;
        if ((unsigned int )*loglevel___2 >= 3U) {
          tmp___11 = logtime();
          logprint("%s %s:%d [%p]: packet recovered seqno:%hu rtptime:%u (W:%hu R:%hu)\n",
                   tmp___11, "buffer_put_packet", 641, ctx, (int )seqno, rtptime,
                   (int )ctx->ab_write, (int )ctx->ab_read);
        }
      } else
      if ((unsigned int )*loglevel___2 >= 3U) {
        tmp___12 = logtime();
        logprint("%s %s:%d [%p]: packet too late seqno:%hu rtptime:%u (W:%hu R:%hu)\n",
                 tmp___12, "buffer_put_packet", 644, ctx, (int )seqno, rtptime, (int )ctx->ab_write,
                 (int )ctx->ab_read);
      }
    }
  }
  tmp___16 = ctx->in_frames;
  (ctx->in_frames) ++;
  if (! (tmp___16 & 511)) {
    if ((unsigned int )*loglevel___2 >= 2U) {
      tmp___15 = logtime();
      logprint("%s %s:%d [%p]: fill [level:%hu] [W:%hu R:%hu]\n", tmp___15, "buffer_put_packet",
               648, ctx, ((int )ctx->ab_write - (int )ctx->ab_read) + 1, (int )ctx->ab_write,
               (int )ctx->ab_read);
    }
  }
  if (abuf) {
    alac_decode(ctx, abuf->data, data, len, & abuf->len);
    abuf->ready = 1;
    abuf->rtptime = rtptime;
    if (ctx->silence) {
      tmp___17 = memcmp((void const   *)abuf->data, (void const   *)ctx->silence_frame,
                        (size_t )abuf->len);
      if (tmp___17) {
        (*(ctx->event_cb))(ctx->owner, (hairtunes_event_t )0);
        ctx->silence = (_Bool)0;
      }
    }
  }
  pthread_mutex_unlock(& ctx->ab_mutex);
  return;
}
}
static void *rtp_thread_func(void *arg ) 
{ 
  fd_set fds ;
  int i ;
  int sock ;
  int count___0 ;
  _Bool ntp_sent ;
  hairtunes_t *ctx ;
  ssize_t plen ;
  char type ;
  char packet[2048] ;
  socklen_t rtp_client_len ;
  int idx ;
  char *pktp ;
  struct timeval timeout ;
  int __d0 ;
  int __d1 ;
  int tmp ;
  char const   *tmp___0 ;
  seq_t seqno ;
  unsigned int rtptime ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  u32_t rtp_now_latency ;
  __uint32_t tmp___3 ;
  u64_t remote ;
  __uint32_t tmp___4 ;
  __uint32_t tmp___5 ;
  u32_t rtp_now ;
  __uint32_t tmp___6 ;
  char const   *tmp___7 ;
  u32_t tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  u64_t expected ;
  s64_t delta ;
  u32_t reference ;
  __uint32_t tmp___11 ;
  u64_t remote___0 ;
  __uint32_t tmp___12 ;
  __uint32_t tmp___13 ;
  u32_t roundtrip ;
  u32_t tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  int tmp___17 ;
  char const   *tmp___18 ;
  u32_t tmp___19 ;
  u32_t tmp___20 ;
  long long tmp___21 ;
  char const   *tmp___22 ;
  char const   *tmp___23 ;

  {
  sock = -1;
  count___0 = 0;
  ctx = (hairtunes_t *)arg;
  i = 0;
  while (i < 3) {
    if (ctx->rtp_sockets[i].sock > sock) {
      sock = ctx->rtp_sockets[i].sock;
    }
    ntp_sent = rtp_request_timing(ctx);
    i ++;
  }
  while (ctx->running) {
    rtp_client_len = (socklen_t )sizeof(struct sockaddr_storage );
    idx = 0;
    pktp = packet;
    timeout.tv_sec = (__time_t )0;
    timeout.tv_usec = (__suseconds_t )50000;
    while (1) {
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fds.fds_bits[0]): "memory");
      break;
    }
    i = 0;
    while (i < 3) {
      fds.fds_bits[ctx->rtp_sockets[i].sock / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << ctx->rtp_sockets[i].sock % (8 * (int )sizeof(__fd_mask )));
      i ++;
    }
    tmp = select(sock + 1, (fd_set * __restrict  )(& fds), (fd_set * __restrict  )((void *)0),
                 (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )(& timeout));
    if (tmp <= 0) {
      continue;
    }
    i = 0;
    while (i < 3) {
      if ((fds.fds_bits[ctx->rtp_sockets[i].sock / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << ctx->rtp_sockets[i].sock % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        idx = i;
      }
      i ++;
    }
    plen = recvfrom(ctx->rtp_sockets[idx].sock, (void * __restrict  )(packet), sizeof(packet),
                    0, (struct sockaddr * __restrict  )((struct sockaddr *)(& ctx->rtp_host)),
                    (socklen_t * __restrict  )(& rtp_client_len));
    if (! ntp_sent) {
      if ((unsigned int )*loglevel___2 >= 1U) {
        tmp___0 = logtime();
        logprint("%s %s:%d [%p]: NTP request not send yet\n", tmp___0, "rtp_thread_func",
                 702, ctx);
      }
      ntp_sent = rtp_request_timing(ctx);
    }
    if (plen < 0L) {
      continue;
    }
    type = (char )((int )packet[1] & -129);
    pktp = packet;
    switch ((int )type) {
    case 86: 
    pktp += 4;
    plen -= 4L;
    case 96: 
    seqno = __bswap_16(*((u16_t *)(pktp + 2)));
    rtptime = __bswap_32(*((u32_t *)(pktp + 4)));
    pktp += 12;
    plen -= 12L;
    if ((unsigned int )*loglevel___2 >= 4U) {
      tmp___1 = logtime();
      logprint("%s %s:%d [%p]: seqno:%hu rtp:%u (type: %x, first: %u)\n", tmp___1,
               "rtp_thread_func", 731, ctx, (int )seqno, rtptime, (int )type, (int )packet[1] & 128);
    }
    if (plen < 16L) {
      break;
    }
    if ((int )packet[1] & 128) {
      if ((int )type != 86) {
        if ((unsigned int )*loglevel___2 >= 2U) {
          tmp___2 = logtime();
          logprint("%s %s:%d [%p]: 1st audio packet received\n", tmp___2, "rtp_thread_func",
                   737, ctx);
        }
      }
    }
    buffer_put_packet(ctx, seqno, rtptime, (_Bool )((int )packet[1] & 128), pktp,
                      (int )plen);
    break;
    case 84: 
    tmp___3 = __bswap_32(*((u32_t *)(pktp + 4)));
    rtp_now_latency = tmp___3;
    tmp___4 = __bswap_32(*((u32_t *)(pktp + 8)));
    tmp___5 = __bswap_32(*((u32_t *)(pktp + 12)));
    remote = ((u64_t )tmp___4 << 32) + (u64_t )tmp___5;
    tmp___6 = __bswap_32(*((u32_t *)(pktp + 16)));
    rtp_now = tmp___6;
    pthread_mutex_lock(& ctx->ab_mutex);
    if (! ctx->latency) {
      ctx->latency = (int )(rtp_now - rtp_now_latency);
    }
    ctx->synchro.rtp = rtp_now - (u32_t )ctx->latency;
    ctx->synchro.time = (u32_t )(ctx->timing.local + (u64_t )((u32_t )(((remote - ctx->timing.remote) >> 10) * 1000UL >> 22)));
    ctx->synchro.status = (u8_t )((int )ctx->synchro.status | 1);
    if ((int )packet[0] & 16) {
      ctx->synchro.first = (_Bool)1;
      if ((unsigned int )*loglevel___2 >= 2U) {
        tmp___7 = logtime();
        logprint("%s %s:%d [%p]: 1st sync packet received\n", tmp___7, "rtp_thread_func",
                 764, ctx);
      }
    }
    pthread_mutex_unlock(& ctx->ab_mutex);
    if ((unsigned int )*loglevel___2 >= 3U) {
      tmp___8 = gettime_ms();
      tmp___9 = logtime();
      logprint("%s %s:%d [%p]: sync packet rtp_latency:%u rtp:%u remote ntp:%Lx, local time %u (now:%u)\n",
               tmp___9, "rtp_thread_func", 770, ctx, rtp_now_latency, rtp_now, remote,
               ctx->synchro.time, tmp___8);
    }
    tmp___10 = count___0;
    count___0 --;
    if (! tmp___10) {
      rtp_request_timing(ctx);
      count___0 = 3;
    }
    break;
    case 83: 
    delta = (s64_t )0;
    tmp___11 = __bswap_32(*((u32_t *)(pktp + 12)));
    reference = tmp___11;
    tmp___12 = __bswap_32(*((u32_t *)(pktp + 16)));
    tmp___13 = __bswap_32(*((u32_t *)(pktp + 20)));
    remote___0 = ((u64_t )tmp___12 << 32) + (u64_t )tmp___13;
    tmp___14 = gettime_ms();
    roundtrip = tmp___14 - reference;
    if (roundtrip > 100U) {
      if ((unsigned int )*loglevel___2 >= 1U) {
        tmp___15 = logtime();
        logprint("%s %s:%d [%p]: discarding NTP roundtrip of %u ms\n", tmp___15, "rtp_thread_func",
                 790, ctx, roundtrip);
      }
      break;
    }
    expected = ctx->timing.remote + ((((u64_t )reference - ctx->timing.local) << 22) / 1000UL << 10);
    ctx->timing.remote = remote___0;
    ctx->timing.local = (u64_t )reference;
    (ctx->timing.count) ++;
    if (! ctx->timing.drift) {
      if ((int )ctx->synchro.status & 2) {
        delta = (((s64_t )expected - (s64_t )ctx->timing.remote) >> 10) * 1000L >> 22;
        ctx->timing.gap_sum += delta;
        pthread_mutex_lock(& ctx->ab_mutex);
        if (ctx->timing.gap_sum > 8L) {
          tmp___20 = ctx->timing.gap_count;
          (ctx->timing.gap_count) ++;
          if (tmp___20 > 20U) {
            if ((unsigned int )*loglevel___2 >= 2U) {
              tmp___16 = logtime();
              logprint("%s %s:%d [%p]: Sending packets too fast %Ld [W:%hu R:%hu]\n",
                       tmp___16, "rtp_thread_func", 817, ctx, ctx->timing.gap_sum,
                       (int )ctx->ab_write, (int )ctx->ab_read);
            }
            ctx->ab_read = (seq_t )((int )ctx->ab_read - 1);
            ctx->audio_buffer[(int )ctx->ab_read % 1024].ready = 1;
            ctx->timing.gap_sum -= 8L;
            ctx->timing.gap_adjust -= 8L;
          } else {
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
        if (ctx->timing.gap_sum < -8L) {
          tmp___19 = ctx->timing.gap_count;
          (ctx->timing.gap_count) ++;
          if (tmp___19 > 20U) {
            tmp___17 = seq_order(ctx->ab_read, ctx->ab_write);
            if (tmp___17) {
              ctx->audio_buffer[(int )ctx->ab_read % 1024].ready = 0;
              ctx->ab_read = (seq_t )((int )ctx->ab_read + 1);
            } else {
              (ctx->skip) ++;
            }
            ctx->timing.gap_sum += 8L;
            ctx->timing.gap_adjust += 8L;
            if ((unsigned int )*loglevel___2 >= 2U) {
              tmp___18 = logtime();
              logprint("%s %s:%d [%p]: Sending packets too slow %Ld (skip: %d)  [W:%hu R:%hu]\n",
                       tmp___18, "rtp_thread_func", 834, ctx, ctx->timing.gap_sum,
                       ctx->skip, (int )ctx->ab_write, (int )ctx->ab_read);
            }
          }
        }
        tmp___21 = llabs((long long )ctx->timing.gap_sum);
        if (tmp___21 < 8LL) {
          ctx->timing.gap_count = (u32_t )0;
        }
        pthread_mutex_unlock(& ctx->ab_mutex);
      }
    }
    ctx->synchro.status = (u8_t )((int )ctx->synchro.status | 2);
    if ((unsigned int )*loglevel___2 >= 3U) {
      tmp___22 = logtime();
      logprint("%s %s:%d [%p]: Timing references local:%Lu, remote:%Lx (delta:%Ld, sum:%Ld, adjust:%Ld, gaps:%d)\n",
               tmp___22, "rtp_thread_func", 846, ctx, ctx->timing.local, ctx->timing.remote,
               delta, ctx->timing.gap_sum, ctx->timing.gap_adjust, ctx->timing.gap_count);
    }
    break;
    }
  }
  if ((unsigned int )*loglevel___2 >= 2U) {
    tmp___23 = logtime();
    logprint("%s %s:%d [%p]: terminating\n", tmp___23, "rtp_thread_func", 853, ctx);
  }
  return ((void *)0);
}
}
static _Bool rtp_request_timing(hairtunes_t *ctx ) 
{ 
  unsigned char req[32] ;
  u32_t now ;
  u32_t tmp ;
  int i ;
  struct sockaddr_in host ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  ssize_t tmp___4 ;

  {
  tmp = gettime_ms();
  now = tmp;
  if ((unsigned int )*loglevel___2 >= 3U) {
    tmp___0 = logtime();
    logprint("%s %s:%d [%p]: timing request now:%u (port: %hu)\n", tmp___0, "rtp_request_timing",
             865, ctx, now, (int )ctx->rtp_sockets[2].rport);
  }
  req[0] = (unsigned char)128;
  req[1] = (unsigned char)210;
  *((u16_t *)(req + 2)) = __bswap_16((__uint16_t )7);
  *((u32_t *)(req + 4)) = __bswap_32((__uint32_t )0);
  i = 0;
  while (i < 16) {
    req[i + 8] = (unsigned char)0;
    i ++;
  }
  *((u32_t *)(req + 24)) = (u32_t )0;
  *((u32_t *)(req + 28)) = __bswap_32(now);
  if (ctx->host.s_addr != 0U) {
    host.sin_family = (sa_family_t )2;
    host.sin_addr = ctx->host;
  } else {
    host = ctx->rtp_host;
  }
  if (host.sin_addr.s_addr == 0U) {
    return ((_Bool)0);
  }
  host.sin_port = __bswap_16(ctx->rtp_sockets[2].rport);
  tmp___4 = sendto(ctx->rtp_sockets[2].sock, (void const   *)(req), sizeof(req), 0,
                   (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& host)),
                   (socklen_t )sizeof(host));
  if (sizeof(req) != (unsigned long )tmp___4) {
    if ((unsigned int )*loglevel___2 >= 1U) {
      tmp___1 = __errno_location();
      tmp___2 = strerror(*tmp___1);
      tmp___3 = logtime();
      logprint("%s %s:%d [%p]: SENDTO failed (%s)\n", tmp___3, "rtp_request_timing",
               886, ctx, tmp___2);
    }
  }
  return ((_Bool)1);
}
}
static _Bool rtp_request_resend(hairtunes_t *ctx , seq_t first , seq_t last ) 
{ 
  unsigned char req[8] ;
  int tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  ssize_t tmp___4 ;

  {
  tmp = seq_order(last, first);
  if (tmp) {
    return ((_Bool)0);
  } else
  if ((int )last - (int )first > 512) {
    return ((_Bool)0);
  }
  ctx->resent_frames += (u32_t )((int )((seq_t )((int )last - (int )first)) + 1);
  if ((unsigned int )*loglevel___2 >= 3U) {
    tmp___0 = logtime();
    logprint("%s %s:%d resend request [W:%hu R:%hu first=%hu last=%hu]\n", tmp___0,
             "rtp_request_resend", 901, (int )ctx->ab_write, (int )ctx->ab_read, (int )first,
             (int )last);
  }
  req[0] = (unsigned char)128;
  req[1] = (unsigned char)213;
  *((u16_t *)(req + 2)) = __bswap_16((__uint16_t )1);
  *((u16_t *)(req + 4)) = __bswap_16(first);
  *((u16_t *)(req + 6)) = __bswap_16((__uint16_t )((int )((seq_t )((int )last - (int )first)) + 1));
  ctx->rtp_host.sin_port = __bswap_16(ctx->rtp_sockets[1].rport);
  tmp___4 = sendto(ctx->rtp_sockets[1].sock, (void const   *)(req), sizeof(req), 0,
                   (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& ctx->rtp_host)),
                   (socklen_t )sizeof(ctx->rtp_host));
  if (sizeof(req) != (unsigned long )tmp___4) {
    if ((unsigned int )*loglevel___2 >= 1U) {
      tmp___1 = __errno_location();
      tmp___2 = strerror(*tmp___1);
      tmp___3 = logtime();
      logprint("%s %s:%d [%p]: SENDTO failed (%s)\n", tmp___3, "rtp_request_resend",
               912, ctx, tmp___2);
    }
  }
  return ((_Bool)1);
}
}
static short *_buffer_get_frame(hairtunes_t *ctx , int *len ) 
{ 
  short buf_fill ;
  abuf_t *curframe ;
  int i ;
  u32_t now ;
  u32_t playtime ;
  u32_t tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  abuf_t *frame ;
  int tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  abuf_t *frame___0 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;

  {
  curframe = (abuf_t *)0;
  if (! ctx->playing) {
    return ((short *)((void *)0));
  }
  if (ctx->silence_count) {
    tmp = ctx->silence_count;
    (ctx->silence_count) --;
    if (tmp) {
      *len = ctx->frame_size * 4;
      return ((short *)ctx->silence_frame);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (ctx->pause) {
    *len = ctx->frame_size * 4;
    return ((short *)ctx->silence_frame);
  }
  while (1) {
    if (ctx->skip) {
      tmp___1 = seq_order(ctx->ab_read, ctx->ab_write);
      if (! tmp___1) {
        break;
      }
    } else {
      break;
    }
    ctx->audio_buffer[(int )ctx->ab_read % 1024].ready = 0;
    ctx->ab_read = (seq_t )((int )ctx->ab_read + 1);
    (ctx->skip) --;
    if ((unsigned int )*loglevel___2 >= 2U) {
      tmp___0 = logtime();
      logprint("%s %s:%d [%p]: Sending packets too slow (skip: %d) [W:%hu R:%hu]\n",
               tmp___0, "_buffer_get_frame", 940, ctx, ctx->skip, (int )ctx->ab_write,
               (int )ctx->ab_read);
    }
  }
  buf_fill = (short )(((int )ctx->ab_write - (int )ctx->ab_read) + 1);
  if ((int )buf_fill >= 1024) {
    tmp___2 = logtime();
    logprint("%s %s:%d [%p]: Buffer overrun %hu\n", tmp___2, "_buffer_get_frame",
             946, ctx, (int )buf_fill);
    ctx->ab_read = (seq_t )((int )ctx->ab_write - 960);
    buf_fill = (short )(((int )ctx->ab_write - (int )ctx->ab_read) + 1);
  }
  now = gettime_ms();
  curframe = ctx->audio_buffer + (int )ctx->ab_read % 1024;
  if (! buf_fill) {
    curframe->rtptime = ctx->audio_buffer[(int )((seq_t )((int )ctx->ab_read - 1)) % 1024].rtptime + (u32_t )ctx->frame_size;
  }
  playtime = ctx->synchro.time + (u32_t )(((s32_t )(curframe->rtptime - ctx->synchro.rtp) * 1000) / 44100);
  if ((unsigned int )*loglevel___2 >= 4U) {
    tmp___3 = logtime();
    logprint("%s %s:%d playtime %u %d [W:%hu R:%hu] %d\n", tmp___3, "_buffer_get_frame",
             960, playtime, playtime - now, (int )ctx->ab_write, (int )ctx->ab_read,
             curframe->ready);
  }
  if (! buf_fill) {
    if (! ctx->http_fill) {
      goto _L___0;
    } else {
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
  if ((int )ctx->synchro.status != 3) {
    goto _L___0;
  } else
  if (now < playtime) {
    if (! curframe->ready) {
      _L___0: /* CIL Label */ 
      if ((unsigned int )*loglevel___2 >= 4U) {
        tmp___4 = logtime();
        logprint("%s %s:%d [%p]: waiting (fill:%hd, W:%hu R:%hu) now:%u, playtime:%u, wait:%d\n",
                 tmp___4, "_buffer_get_frame", 964, ctx, (int )buf_fill, (int )ctx->ab_write,
                 (int )ctx->ab_read, now, playtime, playtime - now);
      }
      i = 0;
      while (1) {
        if (16 < (int )buf_fill) {
          tmp___5 = 16;
        } else {
          tmp___5 = (int )buf_fill;
        }
        if (! (i < tmp___5)) {
          break;
        }
        frame = ctx->audio_buffer + (int )((seq_t )((int )ctx->ab_read + i)) % 1024;
        if (! frame->ready) {
          if (now - frame->last_resend > 200U) {
            rtp_request_resend(ctx, (seq_t )((int )ctx->ab_read + i), (seq_t )((int )ctx->ab_read + i));
            frame->last_resend = now;
          }
        }
        i ++;
      }
      return ((short *)((void *)0));
    }
  }
  if (! buf_fill) {
    if (! ctx->filled_frames) {
      if ((unsigned int )*loglevel___2 >= 1U) {
        tmp___6 = logtime();
        logprint("%s %s:%d [%p]: start silence (late %d ms) [W:%hu R:%hu]\n", tmp___6,
                 "_buffer_get_frame", 979, ctx, now - playtime, (int )ctx->ab_write,
                 (int )ctx->ab_read);
      }
    }
    ctx->ab_write = (seq_t )((int )ctx->ab_write + 1);
    (ctx->filled_frames) ++;
  } else {
    ctx->filled_frames = (u32_t )0;
  }
  tmp___8 = ctx->out_frames;
  (ctx->out_frames) ++;
  if (! (tmp___8 & 511)) {
    if ((unsigned int )*loglevel___2 >= 2U) {
      tmp___7 = logtime();
      logprint("%s %s:%d [%p]: drain [level:%hd gap:%d] [W:%hu R:%hu] [R:%u S:%u F:%u]\n",
               tmp___7, "_buffer_get_frame", 988, ctx, (int )buf_fill - 1, playtime - now,
               (int )ctx->ab_write, (int )ctx->ab_read, ctx->resent_frames, ctx->silent_frames,
               ctx->filled_frames);
    }
  }
  i = 16;
  while (1) {
    tmp___9 = seq_order((seq_t )((int )ctx->ab_read + i), ctx->ab_write);
    if (! tmp___9) {
      break;
    }
    frame___0 = ctx->audio_buffer + (int )((seq_t )((int )ctx->ab_read + i)) % 1024;
    if (! frame___0->ready) {
      if (now - frame___0->last_resend > 200U) {
        rtp_request_resend(ctx, (seq_t )((int )ctx->ab_read + i), (seq_t )((int )ctx->ab_read + i));
        frame___0->last_resend = now;
      }
    }
    i += 16;
  }
  if (! curframe->ready) {
    if ((unsigned int )*loglevel___2 >= 3U) {
      tmp___10 = logtime();
      logprint("%s %s:%d [%p]: created zero frame (W:%hu R:%hu)\n", tmp___10, "_buffer_get_frame",
               1002, ctx, (int )ctx->ab_write, (int )ctx->ab_read);
    }
    memset((void *)curframe->data, 0, (size_t )(ctx->frame_size * 4));
    curframe->len = ctx->frame_size * 4;
    (ctx->silent_frames) ++;
  } else
  if ((unsigned int )*loglevel___2 >= 4U) {
    tmp___11 = logtime();
    logprint("%s %s:%d [%p]: prepared frame (fill:%hd, W:%hu R:%hu)\n", tmp___11,
             "_buffer_get_frame", 1007, ctx, (int )buf_fill - 1, (int )ctx->ab_write,
             (int )ctx->ab_read);
  }
  *len = curframe->len;
  curframe->ready = 0;
  ctx->ab_read = (seq_t )((int )ctx->ab_read + 1);
  return (curframe->data);
}
}
int send_data(_Bool chunked , int sock , void *data , int len , int flags ) 
{ 
  char chunk[16] ;
  int bytes ;
  size_t tmp ;
  int sent ;
  ssize_t tmp___0 ;
  char const   *tmp___1 ;

  {
  bytes = len;
  if (chunked) {
    itoa(len, chunk, 16);
    strcat((char * __restrict  )(chunk), (char const   * __restrict  )"\r\n");
    tmp = strlen((char const   *)(chunk));
    send(sock, (void const   *)(chunk), tmp, flags);
  }
  while (bytes) {
    tmp___0 = send(sock, (void const   *)(((u8_t *)data + len) - bytes), (size_t )bytes,
                   flags);
    sent = (int )tmp___0;
    if (sent < 0) {
      tmp___1 = logtime();
      logprint("%s %s:%d Error sending data %u\n", tmp___1, "send_data", 1031, len);
      return (-1);
    }
    bytes -= sent;
  }
  if (chunked) {
    send(sock, (void const   *)"\r\n", (size_t )2, flags);
  }
  return (len);
}
}
static void *http_thread_func(void *arg ) 
{ 
  s16_t *inbuf ;
  int frame_count ;
  FLAC__int32 *flac_samples ;
  hairtunes_t *ctx ;
  int sock ;
  struct timeval timeout ;
  char const   *tmp ;
  void *tmp___0 ;
  ssize_t sent ;
  fd_set rfds ;
  int n ;
  _Bool res ;
  int size ;
  struct timeval timeout___0 ;
  int __d0 ;
  int __d1 ;
  int tmp___1 ;
  int on ;
  short buf_fill ;
  u32_t tmp___2 ;
  char const   *tmp___3 ;
  int __d0___0 ;
  int __d1___0 ;
  char const   *tmp___4 ;
  int len ;
  int block ;
  int tmp___5 ;
  unsigned char *tmp___6 ;
  s16_t *p ;
  u32_t space ;
  u32_t gap ;
  u32_t tmp___7 ;
  int offset ;
  int len_16 ;
  char buffer[4081] ;
  char *format ;
  char const   *tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  u32_t tmp___15 ;
  char const   *tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;

  {
  frame_count = 0;
  flac_samples = (FLAC__int32 *)((void *)0);
  ctx = (hairtunes_t *)arg;
  sock = -1;
  timeout.tv_sec = (__time_t )0;
  timeout.tv_usec = (__suseconds_t )0;
  if ((unsigned int )ctx->encode.config.codec == 1U) {
    tmp___0 = malloc((unsigned long )(2 * ctx->frame_size) * sizeof(FLAC__int32 ));
    flac_samples = (FLAC__int32 *)tmp___0;
    if ((unsigned long )flac_samples == (unsigned long )((void *)0)) {
      tmp = logtime();
      logprint("%s %s:%d [%p]: Cannot allocate FLAC sample buffer %u\n", tmp, "http_thread_func",
               1052, ctx, ctx->frame_size);
    }
  }
  while (ctx->running) {
    res = (_Bool)1;
    size = 0;
    if (sock == -1) {
      timeout___0.tv_sec = (__time_t )0;
      timeout___0.tv_usec = (__suseconds_t )50000;
      while (1) {
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& rfds.fds_bits[0]): "memory");
        break;
      }
      rfds.fds_bits[ctx->http_listener / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << ctx->http_listener % (8 * (int )sizeof(__fd_mask )));
      tmp___1 = select(ctx->http_listener + 1, (fd_set * __restrict  )(& rfds), (fd_set * __restrict  )((void *)0),
                       (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )(& timeout___0));
      if (tmp___1 > 0) {
        sock = accept(ctx->http_listener, (struct sockaddr * __restrict  )((void *)0),
                      (socklen_t * __restrict  )((void *)0));
      }
      if (sock != -1) {
        if (ctx->running) {
          on = 1;
          setsockopt(sock, 6, 1, (void const   *)((char *)(& on)), (socklen_t )sizeof(on));
          ctx->silence_count = (u32_t )ctx->delay;
          pthread_mutex_lock(& ctx->ab_mutex);
          if (ctx->playing) {
            buf_fill = (short )(((int )ctx->ab_write - (int )ctx->ab_read) + 1);
            if ((int )buf_fill > 0) {
              if (ctx->silence_count < (u32_t )buf_fill) {
                tmp___2 = ctx->silence_count;
              } else {
                tmp___2 = (u32_t )buf_fill;
              }
              ctx->silence_count -= tmp___2;
            } else {
              ctx->silence_count = (u32_t )0;
            }
          }
          pthread_mutex_unlock(& ctx->ab_mutex);
          if ((unsigned int )*loglevel___2 >= 2U) {
            tmp___3 = logtime();
            logprint("%s %s:%d [%p]: got HTTP connection %u (silent frames %d)\n",
                     tmp___3, "http_thread_func", 1087, ctx, sock, ctx->silence_count);
          }
        } else {
          continue;
        }
      } else {
        continue;
      }
    }
    while (1) {
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& rfds.fds_bits[0]): "memory");
      break;
    }
    rfds.fds_bits[sock / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << sock % (8 * (int )sizeof(__fd_mask )));
    n = select(sock + 1, (fd_set * __restrict  )(& rfds), (fd_set * __restrict  )((void *)0),
               (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )(& timeout));
    pthread_mutex_lock(& ctx->ab_mutex);
    if (n > 0) {
      res = handle_http(ctx, sock);
      ctx->http_ready = res;
    }
    if (n < 0) {
      goto _L;
    } else
    if (! res) {
      _L: /* CIL Label */ 
      close(sock);
      if ((unsigned int )*loglevel___2 >= 2U) {
        tmp___4 = logtime();
        logprint("%s %s:%d HTTP close %u\n", tmp___4, "http_thread_func", 1106, sock);
      }
      sock = -1;
      ctx->http_ready = (_Bool)0;
    }
    if (ctx->http_ready) {
      inbuf = _buffer_get_frame(ctx, & size);
      if ((unsigned long )inbuf != (unsigned long )((void *)0)) {
        if ((unsigned int )ctx->encode.config.codec == 1U) {
          if (ctx->encode.header) {
            if (ctx->encode.len) {
              memcpy((void * __restrict  )ctx->http_tail, (void const   * __restrict  )(ctx->encode.buffer),
                     (size_t )ctx->encode.len);
              ctx->http_count = (size_t )ctx->encode.len;
              send_data((_Bool )(ctx->http_length == -3), sock, (void *)(ctx->encode.buffer),
                        ctx->encode.len, 0);
              ctx->encode.len = 0;
              ctx->encode.header = (_Bool)0;
            }
          }
          len = 0;
          while (len < (2 * size) / 4) {
            *(flac_samples + len) = (FLAC__int32 )*(inbuf + len);
            len ++;
          }
          FLAC__stream_encoder_process_interleaved((FLAC__StreamEncoder *)ctx->encode.codec,
                                                   (FLAC__int32 const   *)flac_samples,
                                                   (uint32_t )(size / 4));
          inbuf = (s16_t *)((void *)(ctx->encode.buffer));
          len = ctx->encode.len;
          ctx->encode.len = 0;
        } else
        if ((unsigned int )ctx->encode.config.codec == 0U) {
          tmp___5 = shine_samples_per_pass((shine_t )ctx->encode.codec);
          block = tmp___5 * 4;
          memcpy((void * __restrict  )(ctx->encode.buffer + ctx->encode.len), (void const   * __restrict  )inbuf,
                 (size_t )size);
          ctx->encode.len += size;
          if (ctx->encode.len >= block) {
            tmp___6 = shine_encode_buffer_interleaved((shine_t )ctx->encode.codec,
                                                      (s16_t *)(ctx->encode.buffer),
                                                      & len);
            inbuf = (s16_t *)tmp___6;
            ctx->encode.len -= block;
            memcpy((void * __restrict  )(ctx->encode.buffer), (void const   * __restrict  )(ctx->encode.buffer + block),
                   (size_t )ctx->encode.len);
          } else {
            len = 0;
          }
        } else {
          if ((unsigned int )ctx->encode.config.codec == 2U) {
            p = inbuf;
            len = (size * 2) / 4;
            while (len > 0) {
              *p = (s16_t )(((int )((u8_t )*p) << 8) | (int )((u8_t )((int )*p >> 8)));
              len --;
              p ++;
            }
          } else
          if (ctx->encode.header) {
            ctx->http_count = sizeof(wave_header);
            memcpy((void * __restrict  )ctx->http_tail, (void const   * __restrict  )(& wave_header),
                   sizeof(wave_header));
            send_data((_Bool )(ctx->http_length == -3), sock, (void *)(& wave_header),
                      (int )sizeof(wave_header), 0);
            ctx->encode.header = (_Bool)0;
          }
          len = size;
        }
        if (len) {
          tmp___7 = gettime_ms();
          gap = tmp___7;
          if ((unsigned long )len < 2097152UL - ctx->http_count % 2097152UL) {
            space = (u32_t )len;
          } else {
            space = (u32_t )(2097152UL - ctx->http_count % 2097152UL);
          }
          memcpy((void * __restrict  )(ctx->http_tail + ctx->http_count % 2097152UL),
                 (void const   * __restrict  )inbuf, (size_t )space);
          memcpy((void * __restrict  )ctx->http_tail, (void const   * __restrict  )(inbuf + space),
                 (size_t )((u32_t )len - space));
          ctx->http_count += (size_t )len;
          if (ctx->icy.interval) {
            if ((size_t )len > ctx->icy.remain) {
              len_16 = 0;
              if (ctx->icy.updated) {
                if (ctx->metadata.artwork) {
                  format = (char *)"NStreamTitle=\'%s%s%s\';StreamURL=\'%s\';";
                } else {
                  format = (char *)"NStreamTitle=\'%s%s%s\';";
                }
                if (*(ctx->metadata.artist)) {
                  tmp___8 = " - ";
                } else {
                  tmp___8 = "";
                }
                tmp___9 = sprintf((char * __restrict  )(buffer), (char const   * __restrict  )format,
                                  ctx->metadata.artist, tmp___8, ctx->metadata.title,
                                  ctx->metadata.artwork);
                len_16 = tmp___9 - 1;
                if ((unsigned int )*loglevel___2 >= 2U) {
                  tmp___10 = logtime();
                  logprint("%s %s:%d [%p]: ICY update %s\n", tmp___10, "http_thread_func",
                           1188, ctx, buffer + 1);
                }
                len_16 = (len_16 + 15) / 16;
                ctx->icy.updated = (_Bool)0;
              }
              buffer[0] = (char )len_16;
              pthread_mutex_unlock(& ctx->ab_mutex);
              offset = (int )ctx->icy.remain;
              if (offset) {
                send_data((_Bool )(ctx->http_length == -3), sock, (void *)inbuf, offset,
                          0);
              }
              len -= offset;
              send_data((_Bool )(ctx->http_length == -3), sock, (void *)(buffer),
                        len_16 * 16 + 1, 0);
              ctx->icy.remain = ctx->icy.interval;
              if ((unsigned int )*loglevel___2 >= 4U) {
                tmp___11 = logtime();
                logprint("%s %s:%d [%p]: ICY checked %u\n", tmp___11, "http_thread_func",
                         1207, ctx, ctx->icy.remain);
              }
            } else {
              offset = 0;
              pthread_mutex_unlock(& ctx->ab_mutex);
            }
          } else {
            offset = 0;
            pthread_mutex_unlock(& ctx->ab_mutex);
          }
          if ((unsigned int )*loglevel___2 >= 4U) {
            tmp___12 = frame_count;
            frame_count ++;
            tmp___13 = logtime();
            logprint("%s %s:%d [%p]: HTTP sent frame count:%u bytes:%u (W:%hu R:%hu)\n",
                     tmp___13, "http_thread_func", 1213, ctx, tmp___12, len + offset,
                     (int )ctx->ab_write, (int )ctx->ab_read);
          }
          tmp___14 = send_data((_Bool )(ctx->http_length == -3), sock, (void *)((u8_t *)inbuf + offset),
                               len, 0);
          sent = (ssize_t )tmp___14;
          if (ctx->icy.interval) {
            ctx->icy.remain -= (size_t )len;
          }
          tmp___15 = gettime_ms();
          gap = tmp___15 - gap;
          if (gap > 50U) {
            tmp___16 = logtime();
            logprint("%s %s:%d [%p]: spent %u ms in send for %u bytes (sent %zd)!\n",
                     tmp___16, "http_thread_func", 1222, ctx, gap, len, sent);
          }
          if (sent != (ssize_t )len) {
            if ((unsigned int )*loglevel___2 >= 1U) {
              tmp___17 = __errno_location();
              tmp___18 = strerror(*tmp___17);
              tmp___19 = logtime();
              logprint("%s %s:%d [%p]: HTTP send() unexpected response: %li (data=%i): %s\n",
                       tmp___19, "http_thread_func", 1226, ctx, sent, len, tmp___18);
            }
          }
        } else {
          pthread_mutex_unlock(& ctx->ab_mutex);
        }
        if (ctx->pause) {
          timeout.tv_usec = (__suseconds_t )((ctx->frame_size * 1000000) / 44100);
        } else {
          timeout.tv_usec = (__suseconds_t )0;
        }
      } else {
        timeout.tv_usec = (__suseconds_t )(((2 * ctx->frame_size) * 1000000) / 44100);
        pthread_mutex_unlock(& ctx->ab_mutex);
      }
    } else {
      timeout.tv_usec = (__suseconds_t )(((2 * ctx->frame_size) * 1000000) / 44100);
      pthread_mutex_unlock(& ctx->ab_mutex);
    }
  }
  if (sock != -1) {
    shutdown_socket(sock);
  }
  if ((unsigned int )ctx->encode.config.codec == 1U) {
    if (flac_samples) {
      free((void *)flac_samples);
    }
  }
  if ((unsigned int )*loglevel___2 >= 2U) {
    tmp___20 = logtime();
    logprint("%s %s:%d [%p]: terminating\n", tmp___20, "http_thread_func", 1243, ctx);
  }
  return ((void *)0);
}
}
static _Bool handle_http(hairtunes_t *ctx , int sock ) 
{ 
  char *body ;
  char method[16] ;
  unsigned int tmp ;
  char proto[16] ;
  unsigned int tmp___0 ;
  char *str___0 ;
  char *head ;
  key_data_t headers[64] ;
  key_data_t resp[16] ;
  unsigned int tmp___1 ;
  size_t offset ;
  int len ;
  _Bool HTTP_11 ;
  _Bool tmp___2 ;
  char *tmp___3 ;
  char *p ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  char *value ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  size_t count___0 ;
  char const   *tmp___16 ;
  size_t bytes ;
  size_t tmp___17 ;
  int sent ;
  char const   *tmp___18 ;

  {
  body = (char *)((void *)0);
  method[0] = (char )'\000';
  tmp = 1U;
  while (! (tmp >= 16U)) {
    method[tmp] = (char)0;
    tmp ++;
  }
  proto[0] = (char )'\000';
  tmp___0 = 1U;
  while (! (tmp___0 >= 16U)) {
    proto[tmp___0] = (char)0;
    tmp___0 ++;
  }
  head = (char *)((void *)0);
  resp[0].key = (char *)((void *)0);
  resp[0].data = (char *)((void *)0);
  tmp___1 = 1U;
  while (! (tmp___1 >= 16U)) {
    resp[tmp___1].key = (char *)0;
    resp[tmp___1].data = (char *)0;
    tmp___1 ++;
  }
  offset = (size_t )0;
  tmp___2 = http_parse(sock, method, (char *)((void *)0), proto, headers, & body,
                       & len);
  if (! tmp___2) {
    return ((_Bool)0);
  }
  tmp___3 = strstr((char const   *)(proto), "1.1");
  HTTP_11 = (_Bool )((unsigned long )tmp___3 != (unsigned long )((void *)0));
  if ((unsigned int )*loglevel___2 >= 2U) {
    tmp___4 = kd_dump(headers);
    p = tmp___4;
    if ((unsigned int )*loglevel___2 >= 2U) {
      tmp___5 = logtime();
      logprint("%s %s:%d [%p]: received %s %s\n%s\n", tmp___5, "handle_http", 1262,
               ctx, method, proto, p);
    }
    if (p) {
      free((void *)p);
      p = (char *)((void *)0);
    }
  }
  kd_add(resp, (char *)"Server", (char *)"HairTunes");
  kd_add(resp, (char *)"Content-Type", mime_types[ctx->encode.config.codec]);
  if (ctx->range) {
    str___0 = kd_lookup(headers, (char *)"Range");
    if ((unsigned long )str___0 != (unsigned long )((void *)0)) {
      sscanf((char const   * __restrict  )str___0, (char const   * __restrict  )"bytes=%zu",
             & offset);
      if (ctx->http_count) {
        if (ctx->http_count > 2097152UL) {
          if (offset < (ctx->http_count - 2097152UL) - 1UL) {
            tmp___6 = offset;
          } else {
            tmp___6 = (ctx->http_count - 2097152UL) - 1UL;
          }
          offset = tmp___6;
        } else {
          offset = (size_t )0;
        }
      } else {
        offset = (size_t )0;
      }
      if (offset) {
        if (ctx->http_length == -3) {
          if (HTTP_11) {
            head = (char *)"HTTP/1.1 206 Partial Content";
          } else {
            head = (char *)"HTTP/1.0 206 Partial Content";
          }
        } else {
          head = (char *)"HTTP/1.0 206 Partial Content";
        }
        kd_vadd(resp, (char *)"Content-Range", (char *)"bytes %zu-%zu/*", offset,
                ctx->http_count);
      }
    }
  }
  if ((unsigned int )ctx->encode.config.codec == 0U) {
    if (ctx->encode.config.__annonCompField8.mp3.icy) {
      str___0 = kd_lookup(headers, (char *)"Icy-MetaData");
      if ((unsigned long )str___0 != (unsigned long )((void *)0)) {
        tmp___8 = atoi((char const   *)str___0);
        if (tmp___8) {
          kd_vadd(resp, (char *)"icy-metaint", (char *)"%u", 16384);
          tmp___7 = (size_t )16384;
          ctx->icy.remain = tmp___7;
          ctx->icy.interval = tmp___7;
        } else {
          ctx->icy.interval = (size_t )0;
        }
      } else {
        ctx->icy.interval = (size_t )0;
      }
    } else {
      ctx->icy.interval = (size_t )0;
    }
  } else {
    ctx->icy.interval = (size_t )0;
  }
  if (ctx->http_cb) {
    (*(ctx->http_cb))(ctx->owner, headers, resp);
  }
  if (ctx->http_length == -3) {
    if (HTTP_11) {
      tmp___9 = kd_lookup(headers, (char *)"Connection");
      value = tmp___9;
      if (value) {
        tmp___10 = strcasecmp((char const   *)value, "close");
        if (tmp___10) {
          tmp___11 = strcasecmp((char const   *)value, "keep-alive");
          if (tmp___11) {
            kd_add(resp, (char *)"Connection", (char *)"close");
          } else {
            kd_add(resp, (char *)"Connection", value);
          }
        } else {
          kd_add(resp, (char *)"Connection", value);
        }
      } else {
        kd_add(resp, (char *)"Connection", (char *)"close");
      }
      kd_add(resp, (char *)"Transfer-Encoding", (char *)"chunked");
      if (head) {
        tmp___12 = (char const   *)head;
      } else {
        tmp___12 = "HTTP/1.1 200 OK";
      }
      str___0 = http_send(sock, (char *)tmp___12, resp);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (ctx->http_length > 0) {
      kd_vadd(resp, (char *)"Content-Length", (char *)"%d", ctx->http_length);
    }
    kd_add(resp, (char *)"Connection", (char *)"close");
    if (head) {
      tmp___13 = (char const   *)head;
    } else {
      tmp___13 = "HTTP/1.0 200 OK";
    }
    str___0 = http_send(sock, (char *)tmp___13, resp);
  }
  if ((unsigned int )*loglevel___2 >= 2U) {
    tmp___14 = logtime();
    logprint("%s %s:%d [%p]: responding: %s\n", tmp___14, "handle_http", 1308, ctx,
             str___0);
  }
  if (body) {
    free((void *)body);
    body = (char *)((void *)0);
  }
  kd_free(resp);
  kd_free(headers);
  tmp___15 = strstr((char const   *)(method), "HEAD");
  if (tmp___15) {
    return ((_Bool)0);
  }
  if (offset) {
    count___0 = (size_t )0;
    if ((unsigned int )*loglevel___2 >= 2U) {
      tmp___16 = logtime();
      logprint("%s %s:%d [%p] re-sending offset %zu/%zu\n", tmp___16, "handle_http",
               1321, ctx, offset, ctx->http_count);
    }
    ctx->silence_count = (u32_t )0;
    while (count___0 != ctx->http_count - offset) {
      if (ctx->icy.interval) {
        tmp___17 = ctx->icy.remain;
      } else {
        tmp___17 = (size_t )16384;
      }
      bytes = tmp___17;
      if (bytes < (ctx->http_count - offset) - count___0) {
        bytes = bytes;
      } else {
        bytes = (ctx->http_count - offset) - count___0;
      }
      sent = send_data((_Bool )(ctx->http_length == -3), sock, (void *)(ctx->http_tail + (offset + count___0) % 2097152UL),
                       (int )bytes, 0);
      if (sent < 0) {
        tmp___18 = logtime();
        logprint("%s %s:%d [%p]: error re-sending range %u\n", tmp___18, "handle_http",
                 1331, ctx, offset);
        break;
      }
      count___0 += (size_t )sent;
      if (ctx->icy.interval) {
        ctx->icy.remain -= (size_t )sent;
        if (! ctx->icy.remain) {
          send_data((_Bool )(ctx->http_length == -3), sock, (void *)"\001", 1, 0);
          ctx->icy.remain = ctx->icy.interval;
        }
      }
    }
  }
  return ((_Bool)1);
}
}
#pragma merger("0","/tmp/cil-vaMzyA9S.i","-Wall,-fPIC,-ggdb,-O2,-m64,-fdata-sections,-ffunction-sections")
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
extern  __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   * __restrict  nptr ,
                                                                                                    char ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   * __restrict  nptr ,
                                                                                                     char ** __restrict  endptr ,
                                                                                                     int base ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                    __gwchar_t ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                     __gwchar_t ** __restrict  endptr ,
                                                                                                     int base ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) __strtol_internal)(char const   * __restrict  __nptr ,
                                                                                               char ** __restrict  __endptr ,
                                                                                               int __base ,
                                                                                               int __group ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   * __restrict  nptr ,
                                                                                                    char ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   * __restrict  nptr ,
                                                                      char ** __restrict  endptr ,
                                                                      int base ) 
{ 
  long tmp ;

  {
  tmp = __strtol_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) __strtoul_internal)(char const   * __restrict  __nptr ,
                                                                                                         char ** __restrict  __endptr ,
                                                                                                         int __base ,
                                                                                                         int __group ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   * __restrict  nptr ,
                                                                                                     char ** __restrict  endptr ,
                                                                                                     int base ) ;
__inline extern uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   * __restrict  nptr ,
                                                                       char ** __restrict  endptr ,
                                                                       int base ) 
{ 
  unsigned long tmp ;

  {
  tmp = __strtoul_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) __wcstol_internal)(__gwchar_t const   * __restrict  __nptr ,
                                                                                               __gwchar_t ** __restrict  __endptr ,
                                                                                               int __base ,
                                                                                               int __group ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                    __gwchar_t ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t const   * __restrict  nptr ,
                                                                      __gwchar_t ** __restrict  endptr ,
                                                                      int base ) 
{ 
  long tmp ;

  {
  tmp = __wcstol_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) __wcstoul_internal)(__gwchar_t const   * __restrict  __nptr ,
                                                                                                         __gwchar_t ** __restrict  __endptr ,
                                                                                                         int __base ,
                                                                                                         int __group ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                     __gwchar_t ** __restrict  endptr ,
                                                                                                     int base ) ;
__inline extern uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t const   * __restrict  nptr ,
                                                                       __gwchar_t ** __restrict  endptr ,
                                                                       int base ) 
{ 
  unsigned long tmp ;

  {
  tmp = __wcstoul_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern int BIO_free(BIO *a ) ;
extern BIO *BIO_new_mem_buf(void const   *buf , int len ) ;
extern int RSA_size(RSA const   *rsa ) ;
extern int RSA_private_encrypt(int flen , unsigned char const   *from , unsigned char *to ,
                               RSA *rsa , int padding ) ;
extern int RSA_private_decrypt(int flen , unsigned char const   *from , unsigned char *to ,
                               RSA *rsa , int padding ) ;
extern void RSA_free(RSA *r ) ;
extern RSA *PEM_read_bio_RSAPrivateKey(BIO *bp , RSA **x , pem_password_cb *cb , void *u ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strndup)(char const   *__string ,
                                                                                      size_t __n )  __attribute__((__malloc__)) ;
struct mdns_service *mdnsd_register_svc(struct mdnsd *svr , char const   *instance_name ,
                                        char const   *type , uint16_t port , char const   *hostname ,
                                        char const   **txt ) ;
void mdns_service_remove(struct mdnsd *svr , struct mdns_service *svc ) ;
_Bool query_mDNS(struct mDNShandle_s *handle , char *query , int ttl , int runtime ,
                 mdns_callback_t *callback , void *cookie ) ;
struct mDNShandle_s *init_mDNS(int dbg , struct in_addr host ) ;
void close_mDNS(struct mDNShandle_s *handle ) ;
char *strextract(char *s1 , char *beg , char *end ) ;
int dmap_parse(dmap_settings const   *settings , char const   *buf___0 , size_t len ) ;
static log_level *loglevel___3  =    & raop_loglevel;
static void *rtsp_thread(void *arg ) ;
static _Bool handle_rtsp(raop_ctx_t *ctx , int sock ) ;
static char *rsa_apply(unsigned char *input , int inlen , int *outlen , int mode ) ;
static int base64_pad(char *src , char **padded ) ;
static void event_cb(void *owner , hairtunes_event_t event ) ;
static void http_cb(void *owner , struct key_data_s *headers , struct key_data_s *response ) ;
static void *search_remote(void *args ) ;
static void on_dmap_string(void *ctx , char const   *code , char const   *name , char const   *buf___0 ,
                           size_t len ) ;
struct raop_ctx_s *raop_create(struct in_addr host , struct mdnsd *svr , char *name ,
                               char *model , unsigned char *mac , char *codec , _Bool metadata ,
                               _Bool drift , _Bool flush , char *latencies , void *owner ,
                               void (*raop_cb)(void *owner , raop_event_t event ,
                                               void *param ) , void (*http_cb___0)(void *owner ,
                                                                                   struct key_data_s *headers ,
                                                                                   struct key_data_s *response ) ,
                               unsigned short port_base , unsigned short port_range ,
                               int http_length ) 
{ 
  struct raop_ctx_s *ctx ;
  void *tmp ;
  char *id ;
  int i ;
  struct __anonstruct_port_213969425___0 port ;
  char *txt[14] ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned short tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  void *tmp___16 ;
  size_t tmp___17 ;

  {
  tmp = malloc(sizeof(struct raop_ctx_s ));
  ctx = (struct raop_ctx_s *)tmp;
  port.count = (unsigned short)0;
  port.offset = (unsigned short)0;
  txt[0] = (char *)((void *)0);
  txt[1] = (char *)"tp=UDP";
  txt[2] = (char *)"sm=false";
  txt[3] = (char *)"sv=false";
  txt[4] = (char *)"ek=1";
  txt[5] = (char *)"et=0,1";
  txt[6] = (char *)"md=0,1,2";
  txt[7] = (char *)"cn=0,1";
  txt[8] = (char *)"ch=2";
  txt[9] = (char *)"ss=16";
  txt[10] = (char *)"sr=44100";
  txt[11] = (char *)"vn=3";
  txt[12] = (char *)"txtvers=1";
  txt[13] = (char *)((void *)0);
  if (! ctx) {
    return ((struct raop_ctx_s *)((void *)0));
  }
  memset((void *)ctx, 0, sizeof(raop_ctx_t ));
  ctx->http_length = http_length;
  ctx->ports.base = port_base;
  ctx->ports.range = port_range;
  ctx->host = host;
  ctx->raop_cb = raop_cb;
  ctx->http_cb = http_cb___0;
  ctx->flush = flush;
  ctx->latencies = strdup((char const   *)latencies);
  ctx->owner = owner;
  ctx->drift = drift;
  tmp___6 = strcasecmp((char const   *)codec, "pcm");
  if (tmp___6) {
    tmp___5 = strcasecmp((char const   *)codec, "wav");
    if (tmp___5) {
      tmp___4 = strcasestr((char const   *)codec, "mp3");
      if (tmp___4) {
        ctx->encode.codec = (enum __anonenum_codec_812345935 )0;
        ctx->encode.__annonCompField8.mp3.icy = metadata;
        tmp___1 = strchr((char const   *)codec, ':');
        if (tmp___1) {
          tmp___0 = strchr((char const   *)codec, ':');
          ctx->encode.__annonCompField8.mp3.bitrate = atoi((char const   *)(tmp___0 + 1));
        }
      } else {
        ctx->encode.codec = (enum __anonenum_codec_812345935 )1;
        tmp___3 = strchr((char const   *)codec, ':');
        if (tmp___3) {
          tmp___2 = strchr((char const   *)codec, ':');
          ctx->encode.__annonCompField8.flac.level = atoi((char const   *)(tmp___2 + 1));
        }
      }
    } else {
      ctx->encode.codec = (enum __anonenum_codec_812345935 )3;
    }
  } else {
    ctx->encode.codec = (enum __anonenum_codec_812345935 )2;
  }
  if (! port_base) {
    port_range = (unsigned short)1;
  }
  tmp___7 = rand();
  port.offset = (unsigned short )(tmp___7 % (int )port_range);
  while (1) {
    tmp___8 = port.count;
    port.count = (unsigned short )((int )port.count + 1);
    ctx->port = (unsigned short )((int )port_base + ((int )port.offset + (int )tmp___8) % (int )port_range);
    ctx->sock = bind_socket(& ctx->port, 1);
    if (ctx->sock < 0) {
      if (! ((int )port.count < (int )port_range)) {
        break;
      }
    } else {
      break;
    }
  }
  if (ctx->sock < 0) {
    goto _L;
  } else {
    tmp___12 = listen(ctx->sock, 1);
    if (tmp___12) {
      _L: /* CIL Label */ 
      tmp___9 = __errno_location();
      tmp___10 = strerror(*tmp___9);
      tmp___11 = logtime();
      logprint("%s %s:%d Cannot bind or listen RTSP listener: %s\n", tmp___11, "raop_create",
               151, tmp___10);
      close(ctx->sock);
      free((void *)ctx);
      return ((struct raop_ctx_s *)((void *)0));
    }
  }
  tmp___13 = asprintf((char ** __restrict  )(& txt[0]), (char const   * __restrict  )"am=%s",
                      model);
  if (tmp___13) {
    tmp___14 = 0;
  } else {
    tmp___14 = 1;
  }
  tmp___15 = strlen((char const   *)name);
  tmp___16 = malloc(((tmp___15 + 12UL) + 1UL) + 1UL);
  id = (char *)tmp___16;
  memcpy((void * __restrict  )(ctx->mac), (void const   * __restrict  )mac, (size_t )6);
  i = 0;
  while (i < 6) {
    sprintf((char * __restrict  )(id + i * 2), (char const   * __restrict  )"%02X",
            (int )*(mac + i));
    i ++;
  }
  sprintf((char * __restrict  )(id + 12), (char const   * __restrict  )"@%s", name);
  tmp___17 = strlen((char const   *)id);
  if (tmp___17 > 63UL) {
    *(id + 63) = (char )'\000';
  }
  ctx->svr = svr;
  ctx->svc = mdnsd_register_svc(svr, (char const   *)id, "_raop._tcp.local", ctx->port,
                                (char const   *)((void *)0), (char const   **)(txt));
  free((void *)txt[0]);
  free((void *)id);
  ctx->running = (_Bool)1;
  pthread_create((pthread_t * __restrict  )(& ctx->thread), (pthread_attr_t const   * __restrict  )((void *)0),
                 & rtsp_thread, (void * __restrict  )ctx);
  return (ctx);
}
}
void raop_update(struct raop_ctx_s *ctx , char *name , char *model ) 
{ 
  char *id ;
  int i ;
  char *txt[14] ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;

  {
  txt[0] = (char *)((void *)0);
  txt[1] = (char *)"tp=UDP";
  txt[2] = (char *)"sm=false";
  txt[3] = (char *)"sv=false";
  txt[4] = (char *)"ek=1";
  txt[5] = (char *)"et=0,1";
  txt[6] = (char *)"md=0,1,2";
  txt[7] = (char *)"cn=0,1";
  txt[8] = (char *)"ch=2";
  txt[9] = (char *)"ss=16";
  txt[10] = (char *)"sr=44100";
  txt[11] = (char *)"vn=3";
  txt[12] = (char *)"txtvers=1";
  txt[13] = (char *)((void *)0);
  if (! ctx) {
    return;
  }
  mdns_service_remove(ctx->svr, ctx->svc);
  tmp = asprintf((char ** __restrict  )(& txt[0]), (char const   * __restrict  )"am=%s",
                 model);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  tmp___1 = strlen((char const   *)name);
  tmp___2 = malloc(((tmp___1 + 12UL) + 1UL) + 1UL);
  id = (char *)tmp___2;
  i = 0;
  while (i < 6) {
    sprintf((char * __restrict  )(id + i * 2), (char const   * __restrict  )"%02X",
            (int )ctx->mac[i]);
    i ++;
  }
  sprintf((char * __restrict  )(id + 12), (char const   * __restrict  )"@%s", name);
  tmp___3 = strlen((char const   *)id);
  if (tmp___3 > 63UL) {
    *(id + 63) = (char )'\000';
  }
  ctx->svc = mdnsd_register_svc(ctx->svr, (char const   *)id, "_raop._tcp.local",
                                ctx->port, (char const   *)((void *)0), (char const   **)(txt));
  free((void *)txt[0]);
  free((void *)id);
  return;
}
}
void raop_delete(struct raop_ctx_s *ctx ) 
{ 
  int sock ;
  struct sockaddr addr ;
  socklen_t nlen ;

  {
  nlen = (socklen_t )sizeof(struct sockaddr );
  if (! ctx) {
    return;
  }
  ctx->running = (_Bool)0;
  sock = socket(2, 1, 0);
  getsockname(ctx->sock, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& nlen));
  connect(sock, (struct sockaddr  const  * __restrict  )(& addr), (socklen_t )sizeof(addr));
  close(sock);
  pthread_join(ctx->thread, (void **)((void *)0));
  hairtunes_end(ctx->ht);
  shutdown(ctx->sock, 2);
  close(ctx->sock);
  if (ctx->active_remote.handle) {
    close_mDNS(ctx->active_remote.handle);
    pthread_join(ctx->search_thread, (void **)((void *)0));
  }
  if (ctx->rtsp.aeskey) {
    free((void *)ctx->rtsp.aeskey);
    ctx->rtsp.aeskey = (char *)((void *)0);
  }
  if (ctx->rtsp.aesiv) {
    free((void *)ctx->rtsp.aesiv);
    ctx->rtsp.aesiv = (char *)((void *)0);
  }
  if (ctx->rtsp.fmtp) {
    free((void *)ctx->rtsp.fmtp);
    ctx->rtsp.fmtp = (char *)((void *)0);
  }
  free((void *)ctx->latencies);
  mdns_service_remove(ctx->svr, ctx->svc);
  free((void *)ctx);
  return;
}
}
void raop_notify(struct raop_ctx_s *ctx , raop_event_t event , void *param ) 
{ 
  struct sockaddr_in addr ;
  int sock ;
  char *command ;
  double Volume ;
  int tmp ;
  int tmp___0 ;
  char *method ;
  char *buf___0 ;
  char resp[512] ;
  unsigned int tmp___1 ;
  int len ;
  key_data_t headers[4] ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  ssize_t tmp___5 ;
  char const   *tmp___6 ;
  int tmp___7 ;

  {
  command = (char *)((void *)0);
  if (! ctx) {
    return;
  }
  switch ((unsigned int )event) {
  case 3U: 
  command = strdup("pause");
  break;
  case 1U: 
  command = strdup("play");
  break;
  case 4U: 
  command = strdup("stop");
  break;
  case 5U: 
  Volume = *((double *)param);
  if (Volume) {
    Volume = (Volume - (double )1) * (double )30;
  } else {
    Volume = (double )-144;
  }
  tmp = asprintf((char ** __restrict  )(& command), (char const   * __restrict  )"setproperty?dmcp.device-volume=%0.4lf",
                 Volume);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  break;
  default: 
  break;
  }
  if (! command) {
    goto _L;
  } else
  if (! ctx->active_remote.port) {
    _L: /* CIL Label */ 
    if (command) {
      free((void *)command);
      command = (char *)((void *)0);
    }
    return;
  }
  sock = socket(2, 1, 0);
  memset((void *)(& addr), 0, sizeof(addr));
  addr.sin_family = (sa_family_t )2;
  addr.sin_addr.s_addr = ctx->active_remote.host.s_addr;
  addr.sin_port = __bswap_16(ctx->active_remote.port);
  tmp___7 = connect(sock, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& addr)),
                    (socklen_t )sizeof(addr));
  if (! tmp___7) {
    resp[0] = (char )'\000';
    tmp___1 = 1U;
    while (! (tmp___1 >= 512U)) {
      resp[tmp___1] = (char)0;
      tmp___1 ++;
    }
    headers[0].key = (char *)((void *)0);
    headers[0].data = (char *)((void *)0);
    tmp___2 = 1U;
    while (! (tmp___2 >= 4U)) {
      headers[tmp___2].key = (char *)0;
      headers[tmp___2].data = (char *)0;
      tmp___2 ++;
    }
    tmp___3 = asprintf((char ** __restrict  )(& method), (char const   * __restrict  )"GET /ctrl-int/1/%s HTTP/1.0",
                       command);
    if (tmp___3) {
      tmp___4 = 0;
    } else {
      tmp___4 = 1;
    }
    kd_add(headers, (char *)"Active-Remote", ctx->active_remote.id);
    kd_add(headers, (char *)"Connection", (char *)"close");
    buf___0 = http_send(sock, method, headers);
    tmp___5 = recv(sock, (void *)(resp), (size_t )512, 0);
    len = (int )tmp___5;
    if (len > 0) {
      resp[len - 1] = (char )'\000';
    }
    if ((unsigned int )*loglevel___3 >= 2U) {
      tmp___6 = logtime();
      logprint("%s %s:%d [%p]: sending airplay remote\n%s<== received ==>\n%s\n",
               tmp___6, "raop_notify", 316, ctx, buf___0, resp);
    }
    if (method) {
      free((void *)method);
      method = (char *)((void *)0);
    }
    if (buf___0) {
      free((void *)buf___0);
      buf___0 = (char *)((void *)0);
    }
    kd_free(headers);
  }
  free((void *)command);
  close(sock);
  return;
}
}
static void *rtsp_thread(void *arg ) 
{ 
  raop_ctx_t *ctx ;
  int sock ;
  fd_set rfds ;
  struct timeval timeout ;
  int n ;
  _Bool res ;
  struct sockaddr_in peer ;
  socklen_t addrlen ;
  char const   *tmp ;
  int __d0 ;
  int __d1 ;
  char const   *tmp___0 ;

  {
  ctx = (raop_ctx_t *)arg;
  sock = -1;
  while (ctx->running) {
    timeout.tv_sec = (__time_t )0;
    timeout.tv_usec = (__suseconds_t )100000;
    res = (_Bool)0;
    if (sock == -1) {
      addrlen = (socklen_t )sizeof(struct sockaddr_in );
      sock = accept(ctx->sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& peer)),
                    (socklen_t * __restrict  )(& addrlen));
      ctx->peer.s_addr = peer.sin_addr.s_addr;
      if (sock != -1) {
        if (ctx->running) {
          if ((unsigned int )*loglevel___3 >= 2U) {
            tmp = logtime();
            logprint("%s %s:%d got RTSP connection %u\n", tmp, "rtsp_thread", 347,
                     sock);
          }
        } else {
          continue;
        }
      } else {
        continue;
      }
    }
    while (1) {
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& rfds.fds_bits[0]): "memory");
      break;
    }
    rfds.fds_bits[sock / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << sock % (8 * (int )sizeof(__fd_mask )));
    n = select(sock + 1, (fd_set * __restrict  )(& rfds), (fd_set * __restrict  )((void *)0),
               (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )(& timeout));
    if (! n) {
      continue;
    }
    if (n > 0) {
      res = handle_rtsp(ctx, sock);
    }
    if (n < 0) {
      goto _L;
    } else
    if (! res) {
      _L: /* CIL Label */ 
      close(sock);
      if ((unsigned int )*loglevel___3 >= 2U) {
        tmp___0 = logtime();
        logprint("%s %s:%d RTSP close %u\n", tmp___0, "rtsp_thread", 362, sock);
      }
      sock = -1;
    }
  }
  if (sock != -1) {
    close(sock);
  }
  return ((void *)0);
}
}
static _Bool handle_rtsp(raop_ctx_t *ctx , int sock ) 
{ 
  char *buf___0 ;
  char *body ;
  char method[16] ;
  unsigned int tmp ;
  key_data_t headers[64] ;
  key_data_t resp[16] ;
  unsigned int tmp___0 ;
  int len ;
  _Bool success ;
  _Bool tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int n ;
  char *buf_pad ;
  char *p ;
  char *data_b64 ;
  char data[32] ;
  char const   *tmp___4 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  char *padded ;
  char *p___0 ;
  unsigned char *aeskey ;
  int len___0 ;
  int outlen ;
  size_t tmp___13 ;
  void *tmp___14 ;
  size_t tmp___15 ;
  void *tmp___16 ;
  char *p___1 ;
  hairtunes_resp_t ht ;
  unsigned short tport ;
  unsigned short cport ;
  char *transport ;
  int tmp___17 ;
  int tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  unsigned short seqno ;
  unsigned int rtptime ;
  char *p___2 ;
  char latency[6] ;
  int tmp___21 ;
  int tmp___22 ;
  unsigned short seqno___0 ;
  unsigned int rtptime___0 ;
  char *p___3 ;
  _Bool tmp___23 ;
  char *p___4 ;
  double volume ;
  char const   *tmp___24 ;
  struct metadata_s metadata ;
  dmap_settings settings ;
  char const   *tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  char const   *tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  char *tmp___36 ;
  char const   *tmp___37 ;
  char const   *tmp___38 ;
  int tmp___39 ;

  {
  buf___0 = (char *)((void *)0);
  body = (char *)((void *)0);
  method[0] = (char )'\000';
  tmp = 1U;
  while (! (tmp >= 16U)) {
    method[tmp] = (char)0;
    tmp ++;
  }
  resp[0].key = (char *)((void *)0);
  resp[0].data = (char *)((void *)0);
  tmp___0 = 1U;
  while (! (tmp___0 >= 16U)) {
    resp[tmp___0].key = (char *)0;
    resp[tmp___0].data = (char *)0;
    tmp___0 ++;
  }
  success = (_Bool)1;
  tmp___1 = http_parse(sock, method, (char *)((void *)0), (char *)((void *)0), headers,
                       & body, & len);
  if (! tmp___1) {
    if (body) {
      free((void *)body);
      body = (char *)((void *)0);
    }
    kd_free(headers);
    return ((_Bool)0);
  }
  tmp___3 = strcmp((char const   *)(method), "OPTIONS");
  if (tmp___3) {
    if ((unsigned int )*loglevel___3 >= 2U) {
      tmp___2 = logtime();
      logprint("%s %s:%d [%p]: received %s\n", tmp___2, "handle_rtsp", 388, ctx, method);
    }
  }
  buf___0 = kd_lookup(headers, (char *)"Apple-Challenge");
  if ((unsigned long )buf___0 != (unsigned long )((void *)0)) {
    data_b64 = (char *)((void *)0);
    if ((unsigned int )*loglevel___3 >= 2U) {
      tmp___4 = logtime();
      logprint("%s %s:%d [%p]: challenge %s\n", tmp___4, "handle_rtsp", 395, ctx,
               buf___0);
    }
    base64_pad(buf___0, & buf_pad);
    tmp___8 = base64_decode((char const   *)buf_pad, (void *)(data));
    if (tmp___8 < 22) {
      tmp___6 = base64_decode((char const   *)buf_pad, (void *)(data));
      tmp___7 = tmp___6;
    } else {
      tmp___7 = 22;
    }
    p = data + tmp___7;
    tmp___9 = memcpy((void * __restrict  )p, (void const   * __restrict  )(& ctx->host.s_addr),
                     (size_t )4);
    p = (char *)tmp___9 + 4;
    tmp___10 = memcpy((void * __restrict  )p, (void const   * __restrict  )(ctx->mac),
                      (size_t )6);
    p = (char *)tmp___10 + 6;
    memset((void *)p, 0, (size_t )(32L - (p - data)));
    p = rsa_apply((unsigned char *)(data), 32, & n, 1);
    n = base64_encode((void const   *)p, n, & data_b64);
    tmp___11 = strlen((char const   *)data_b64);
    n = (int )(tmp___11 - 1UL);
    while (1) {
      if (n > 0) {
        if (! ((int )*(data_b64 + n) == 61)) {
          break;
        }
      } else {
        break;
      }
      tmp___12 = n;
      n --;
      *(data_b64 + tmp___12) = (char )'\000';
    }
    kd_add(resp, (char *)"Apple-Response", data_b64);
    if (p) {
      free((void *)p);
      p = (char *)((void *)0);
    }
    if (buf_pad) {
      free((void *)buf_pad);
      buf_pad = (char *)((void *)0);
    }
    if (data_b64) {
      free((void *)data_b64);
      data_b64 = (char *)((void *)0);
    }
  }
  tmp___35 = strcmp((char const   *)(method), "OPTIONS");
  if (tmp___35) {
    tmp___34 = strcmp((char const   *)(method), "ANNOUNCE");
    if (tmp___34) {
      _L___1: /* CIL Label */ 
      tmp___33 = strcmp((char const   *)(method), "SETUP");
      if (tmp___33) {
        _L___0: /* CIL Label */ 
        tmp___32 = strcmp((char const   *)(method), "RECORD");
        if (tmp___32) {
          tmp___31 = strcmp((char const   *)(method), "FLUSH");
          if (tmp___31) {
            tmp___30 = strcmp((char const   *)(method), "TEARDOWN");
            if (tmp___30) {
              tmp___29 = strcmp((char const   *)(method), "SET_PARAMETER");
              if (tmp___29) {
                success = (_Bool)0;
                tmp___28 = logtime();
                logprint("%s %s:%d [%p]: unknown/unhandled method %s\n", tmp___28,
                         "handle_rtsp", 580, ctx, method);
              } else {
                if (body) {
                  p___4 = strcasestr((char const   *)body, "volume");
                  if ((unsigned long )p___4 != (unsigned long )((void *)0)) {
                    sscanf((char const   * __restrict  )p___4, (char const   * __restrict  )"%*[^:]:%lf",
                           & volume);
                    if ((unsigned int )*loglevel___3 >= 2U) {
                      tmp___24 = logtime();
                      logprint("%s %s:%d [%p]: SET PARAMETER volume %lf\n", tmp___24,
                               "handle_rtsp", 555, ctx, volume);
                    }
                    if (volume == - 144.0) {
                      volume = (double )0;
                    } else {
                      volume = (double )1 + volume / (double )30;
                    }
                    (*(ctx->raop_cb))(ctx->owner, (raop_event_t )5, (void *)(& volume));
                  }
                }
                p___4 = kd_lookup(headers, (char *)"Content-Type");
                if ((unsigned long )p___4 != (unsigned long )((void *)0)) {
                  tmp___27 = strcasecmp((char const   *)p___4, "application/x-dmap-tagged");
                  if (! tmp___27) {
                    settings.on_dict_start = (void (*)(void *ctx , char const   *code ,
                                                       char const   *name ))((void *)0);
                    settings.on_dict_end = (void (*)(void *ctx , char const   *code ,
                                                     char const   *name ))((void *)0);
                    settings.on_int32 = (void (*)(void *ctx , char const   *code ,
                                                  char const   *name , int32_t value ))((void *)0);
                    settings.on_int64 = (void (*)(void *ctx , char const   *code ,
                                                  char const   *name , int64_t value ))((void *)0);
                    settings.on_uint32 = (void (*)(void *ctx , char const   *code ,
                                                   char const   *name , uint32_t value ))((void *)0);
                    settings.on_uint64 = (void (*)(void *ctx , char const   *code ,
                                                   char const   *name , uint64_t value ))((void *)0);
                    settings.on_date = (void (*)(void *ctx , char const   *code ,
                                                 char const   *name , uint32_t value ))((void *)0);
                    settings.on_string = & on_dmap_string;
                    settings.on_data = (void (*)(void *ctx , char const   *code ,
                                                 char const   *name , char const   *buf ,
                                                 size_t len ))((void *)0);
                    settings.ctx = (void *)0;
                    settings.ctx = (void *)(& metadata);
                    memset((void *)(& metadata), 0, sizeof(struct metadata_s ));
                    tmp___26 = dmap_parse((dmap_settings const   *)(& settings), (char const   *)body,
                                          (size_t )len);
                    if (! tmp___26) {
                      hairtunes_metadata(ctx->ht, & metadata);
                      if ((unsigned int )*loglevel___3 >= 2U) {
                        tmp___25 = logtime();
                        logprint("%s %s:%d [%p]: received metadata\n\tartist: %s\n\talbum:  %s\n\ttitle:  %s\n",
                                 tmp___25, "handle_rtsp", 572, ctx, metadata.artist,
                                 metadata.album, metadata.title);
                      }
                      free_metadata(& metadata);
                    }
                  }
                }
              }
            } else {
              (*(ctx->raop_cb))(ctx->owner, (raop_event_t )4, (void *)(& ctx->hport));
              hairtunes_end(ctx->ht);
              ctx->ht = (struct hairtunes_s *)((void *)0);
              ctx->hport = (unsigned short)65535;
              if (ctx->active_remote.handle) {
                close_mDNS(ctx->active_remote.handle);
              }
              pthread_join(ctx->search_thread, (void **)((void *)0));
              memset((void *)(& ctx->active_remote), 0, sizeof(ctx->active_remote));
              if (ctx->rtsp.aeskey) {
                free((void *)ctx->rtsp.aeskey);
                ctx->rtsp.aeskey = (char *)((void *)0);
              }
              if (ctx->rtsp.aesiv) {
                free((void *)ctx->rtsp.aesiv);
                ctx->rtsp.aesiv = (char *)((void *)0);
              }
              if (ctx->rtsp.fmtp) {
                free((void *)ctx->rtsp.fmtp);
                ctx->rtsp.fmtp = (char *)((void *)0);
              }
            }
          } else {
            seqno___0 = (unsigned short)0;
            rtptime___0 = 0U;
            buf___0 = kd_lookup(headers, (char *)"RTP-Info");
            if ((unsigned long )buf___0 != (unsigned long )((void *)0)) {
              p___3 = strcasestr((char const   *)buf___0, "seq");
              if ((unsigned long )p___3 != (unsigned long )((void *)0)) {
                sscanf((char const   * __restrict  )p___3, (char const   * __restrict  )"%*[^=]=%hu",
                       & seqno___0);
              }
              p___3 = strcasestr((char const   *)buf___0, "rtptime");
              if ((unsigned long )p___3 != (unsigned long )((void *)0)) {
                sscanf((char const   * __restrict  )p___3, (char const   * __restrict  )"%*[^=]=%u",
                       & rtptime___0);
              }
            }
            if (ctx->ht) {
              tmp___23 = hairtunes_flush(ctx->ht, seqno___0, rtptime___0, (_Bool)1,
                                         (_Bool )(! ctx->flush));
              if (tmp___23) {
                (*(ctx->raop_cb))(ctx->owner, (raop_event_t )2, (void *)(& ctx->hport));
                hairtunes_flush_release(ctx->ht);
              }
            }
          }
        } else {
          seqno = (unsigned short)0;
          rtptime = 0U;
          tmp___22 = atoi((char const   *)ctx->latencies);
          if (tmp___22) {
            tmp___21 = atoi((char const   *)ctx->latencies);
            snprintf((char * __restrict  )(latency), (size_t )6, (char const   * __restrict  )"%u",
                     (tmp___21 * 44100) / 1000);
            kd_add(resp, (char *)"Audio-Latency", latency);
          }
          buf___0 = kd_lookup(headers, (char *)"RTP-Info");
          if ((unsigned long )buf___0 != (unsigned long )((void *)0)) {
            p___2 = strcasestr((char const   *)buf___0, "seq");
            if ((unsigned long )p___2 != (unsigned long )((void *)0)) {
              sscanf((char const   * __restrict  )p___2, (char const   * __restrict  )"%*[^=]=%hu",
                     & seqno);
            }
            p___2 = strcasestr((char const   *)buf___0, "rtptime");
            if ((unsigned long )p___2 != (unsigned long )((void *)0)) {
              sscanf((char const   * __restrict  )p___2, (char const   * __restrict  )"%*[^=]=%u",
                     & rtptime);
            }
          }
          if (ctx->ht) {
            hairtunes_record(ctx->ht, seqno, rtptime);
          }
          (*(ctx->raop_cb))(ctx->owner, (raop_event_t )0, (void *)(& ctx->hport));
        }
      } else {
        buf___0 = kd_lookup(headers, (char *)"Transport");
        if ((unsigned long )buf___0 != (unsigned long )((void *)0)) {
          tport = (unsigned short)0;
          cport = (unsigned short)0;
          p___1 = strcasestr((char const   *)buf___0, "timing_port");
          if ((unsigned long )p___1 != (unsigned long )((void *)0)) {
            sscanf((char const   * __restrict  )p___1, (char const   * __restrict  )"%*[^=]=%hu",
                   & tport);
          }
          p___1 = strcasestr((char const   *)buf___0, "control_port");
          if ((unsigned long )p___1 != (unsigned long )((void *)0)) {
            sscanf((char const   * __restrict  )p___1, (char const   * __restrict  )"%*[^=]=%hu",
                   & cport);
          }
          ht = hairtunes_init(ctx->peer, ctx->encode, (_Bool)0, ctx->drift, (_Bool)1,
                              ctx->latencies, ctx->rtsp.aeskey, ctx->rtsp.aesiv, ctx->rtsp.fmtp,
                              cport, tport, (void *)ctx, & event_cb, & http_cb, ctx->ports.base,
                              ctx->ports.range, ctx->http_length);
          ctx->hport = ht.hport;
          ctx->ht = ht.ctx;
          if ((((((int )cport * (int )tport) * (int )ht.cport) * (int )ht.tport) * (int )ht.aport) * (int )ht.hport) {
            if (ht.ctx) {
              tmp___17 = asprintf((char ** __restrict  )(& transport), (char const   * __restrict  )"RTP/AVP/UDP;unicast;mode=record;control_port=%u;timing_port=%u;server_port=%u",
                                  (int )ht.cport, (int )ht.tport, (int )ht.aport);
              if (tmp___17) {
                tmp___18 = 0;
              } else {
                tmp___18 = 1;
              }
              if ((unsigned int )*loglevel___3 >= 3U) {
                tmp___19 = logtime();
                logprint("%s %s:%d [%p]: http=(%hu) audio=(%hu:%hu), timing=(%hu:%hu), control=(%hu:%hu)\n",
                         tmp___19, "handle_rtsp", 485, ctx, (int )ht.hport, 0, (int )ht.aport,
                         (int )tport, (int )ht.tport, (int )cport, (int )ht.cport);
              }
              kd_add(resp, (char *)"Transport", transport);
              kd_add(resp, (char *)"Session", (char *)"DEADBEEF");
              free((void *)transport);
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
            success = (_Bool)0;
            if ((unsigned int )*loglevel___3 >= 2U) {
              tmp___20 = logtime();
              logprint("%s %s:%d [%p]: cannot start session, missing ports\n", tmp___20,
                       "handle_rtsp", 491, ctx);
            }
          }
        } else {
          goto _L___0;
        }
      }
    } else
    if (body) {
      if (ctx->rtsp.aeskey) {
        free((void *)ctx->rtsp.aeskey);
        ctx->rtsp.aeskey = (char *)((void *)0);
      }
      if (ctx->rtsp.aesiv) {
        free((void *)ctx->rtsp.aesiv);
        ctx->rtsp.aesiv = (char *)((void *)0);
      }
      if (ctx->rtsp.fmtp) {
        free((void *)ctx->rtsp.fmtp);
        ctx->rtsp.fmtp = (char *)((void *)0);
      }
      p___0 = strcasestr((char const   *)body, "rsaaeskey");
      if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
        p___0 = strextract(p___0, (char *)":", (char *)"\r\n");
        base64_pad(p___0, & padded);
        tmp___13 = strlen((char const   *)padded);
        tmp___14 = malloc(tmp___13);
        aeskey = (unsigned char *)tmp___14;
        len___0 = base64_decode((char const   *)padded, (void *)aeskey);
        ctx->rtsp.aeskey = rsa_apply(aeskey, len___0, & outlen, 0);
        if (p___0) {
          free((void *)p___0);
          p___0 = (char *)((void *)0);
        }
        if (aeskey) {
          free((void *)aeskey);
          aeskey = (unsigned char *)((void *)0);
        }
        if (padded) {
          free((void *)padded);
          padded = (char *)((void *)0);
        }
      }
      p___0 = strcasestr((char const   *)body, "aesiv");
      if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
        p___0 = strextract(p___0, (char *)":", (char *)"\r\n");
        base64_pad(p___0, & padded);
        tmp___15 = strlen((char const   *)padded);
        tmp___16 = malloc(tmp___15);
        ctx->rtsp.aesiv = (char *)tmp___16;
        base64_decode((char const   *)padded, (void *)ctx->rtsp.aesiv);
        if (p___0) {
          free((void *)p___0);
          p___0 = (char *)((void *)0);
        }
        if (padded) {
          free((void *)padded);
          padded = (char *)((void *)0);
        }
      }
      p___0 = strcasestr((char const   *)body, "fmtp");
      if ((unsigned long )p___0 != (unsigned long )((void *)0)) {
        p___0 = strextract(p___0, (char *)":", (char *)"\r\n");
        ctx->rtsp.fmtp = strdup((char const   *)p___0);
        if (p___0) {
          free((void *)p___0);
          p___0 = (char *)((void *)0);
        }
      }
      buf___0 = kd_lookup(headers, (char *)"DACP-ID");
      if ((unsigned long )buf___0 != (unsigned long )((void *)0)) {
        strcpy((char * __restrict  )(ctx->active_remote.DACPid), (char const   * __restrict  )buf___0);
      }
      buf___0 = kd_lookup(headers, (char *)"Active-Remote");
      if ((unsigned long )buf___0 != (unsigned long )((void *)0)) {
        strcpy((char * __restrict  )(ctx->active_remote.id), (char const   * __restrict  )buf___0);
      }
      ctx->active_remote.handle = init_mDNS(0, ctx->host);
      pthread_create((pthread_t * __restrict  )(& ctx->search_thread), (pthread_attr_t const   * __restrict  )((void *)0),
                     & search_remote, (void * __restrict  )ctx);
    } else {
      goto _L___1;
    }
  } else {
    kd_add(resp, (char *)"Public", (char *)"ANNOUNCE, SETUP, RECORD, PAUSE, FLUSH, TEARDOWN, OPTIONS, GET_PARAMETER, SET_PARAMETER");
  }
  kd_add(resp, (char *)"Audio-Jack-Status", (char *)"connected; type=analog");
  tmp___36 = kd_lookup(headers, (char *)"CSeq");
  kd_add(resp, (char *)"CSeq", tmp___36);
  if (success) {
    buf___0 = http_send(sock, (char *)"RTSP/1.0 200 OK", resp);
  } else {
    buf___0 = http_send(sock, (char *)"RTSP/1.0 500 ERROR", (key_data_t *)((void *)0));
  }
  tmp___39 = strcmp((char const   *)(method), "OPTIONS");
  if (tmp___39) {
    if ((unsigned int )*loglevel___3 >= 2U) {
      if (buf___0) {
        tmp___37 = (char const   *)buf___0;
      } else {
        tmp___37 = "<void>";
      }
      tmp___38 = logtime();
      logprint("%s %s:%d [%p]: responding:\n%s\n", tmp___38, "handle_rtsp", 592, ctx,
               tmp___37);
    }
  }
  if (body) {
    free((void *)body);
    body = (char *)((void *)0);
  }
  if (buf___0) {
    free((void *)buf___0);
    buf___0 = (char *)((void *)0);
  }
  kd_free(resp);
  kd_free(headers);
  return ((_Bool)1);
}
}
static void event_cb(void *owner , hairtunes_event_t event ) 
{ 
  raop_ctx_t *ctx ;
  char const   *tmp ;

  {
  ctx = (raop_ctx_t *)owner;
  switch ((unsigned int )event) {
  case 0U: 
  (*(ctx->raop_cb))(ctx->owner, (raop_event_t )1, (void *)(& ctx->hport));
  break;
  default: 
  tmp = logtime();
  logprint("%s %s:%d [%p]: unknown hairtunes event\n", tmp, "event_cb", 613, ctx,
           (unsigned int )event);
  break;
  }
  return;
}
}
static void http_cb(void *owner , struct key_data_s *headers , struct key_data_s *response ) 
{ 
  raop_ctx_t *ctx ;

  {
  ctx = (raop_ctx_t *)owner;
  if (ctx->http_cb) {
    (*(ctx->http_cb))(ctx->owner, headers, response);
  }
  return;
}
}
_Bool search_remote_cb(mDNSservice_t *slist , void *cookie , _Bool *stop ) 
{ 
  mDNSservice_t *s ;
  raop_ctx_t *ctx ;
  char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;

  {
  ctx = (raop_ctx_t *)cookie;
  s = slist;
  while (s) {
    tmp___1 = strcasestr((char const   *)s->name, (char const   *)(ctx->active_remote.DACPid));
    if (tmp___1) {
      ctx->active_remote.host = s->addr;
      ctx->active_remote.port = s->port;
      if ((unsigned int )*loglevel___3 >= 2U) {
        tmp = inet_ntoa(ctx->active_remote.host);
        tmp___0 = logtime();
        logprint("%s %s:%d [%p]: found ActiveRemote for %s at %s:%u\n", tmp___0, "search_remote_cb",
                 638, ctx, ctx->active_remote.DACPid, tmp, (int )ctx->active_remote.port);
      }
      *stop = (_Bool)1;
      break;
    }
    s = s->next;
  }
  return ((_Bool)0);
}
}
static void *search_remote(void *args ) 
{ 
  raop_ctx_t *ctx ;

  {
  ctx = (raop_ctx_t *)args;
  query_mDNS(ctx->active_remote.handle, (char *)"_dacp._tcp.local", 0, 0, & search_remote_cb,
             (void *)ctx);
  return ((void *)0);
}
}
static char super_secret_key[1675]  = 
  {      (char )'-',      (char )'-',      (char )'-',      (char )'-', 
        (char )'-',      (char )'B',      (char )'E',      (char )'G', 
        (char )'I',      (char )'N',      (char )' ',      (char )'R', 
        (char )'S',      (char )'A',      (char )' ',      (char )'P', 
        (char )'R',      (char )'I',      (char )'V',      (char )'A', 
        (char )'T',      (char )'E',      (char )' ',      (char )'K', 
        (char )'E',      (char )'Y',      (char )'-',      (char )'-', 
        (char )'-',      (char )'-',      (char )'-',      (char )'\n', 
        (char )'M',      (char )'I',      (char )'I',      (char )'E', 
        (char )'p',      (char )'Q',      (char )'I',      (char )'B', 
        (char )'A',      (char )'A',      (char )'K',      (char )'C', 
        (char )'A',      (char )'Q',      (char )'E',      (char )'A', 
        (char )'5',      (char )'9',      (char )'d',      (char )'E', 
        (char )'8',      (char )'q',      (char )'L',      (char )'i', 
        (char )'e',      (char )'I',      (char )'t',      (char )'s', 
        (char )'H',      (char )'1',      (char )'W',      (char )'g', 
        (char )'j',      (char )'r',      (char )'c',      (char )'F', 
        (char )'R',      (char )'K',      (char )'j',      (char )'6', 
        (char )'e',      (char )'U',      (char )'W',      (char )'q', 
        (char )'i',      (char )'+',      (char )'b',      (char )'G', 
        (char )'L',      (char )'O',      (char )'X',      (char )'1', 
        (char )'H',      (char )'L',      (char )'3',      (char )'U', 
        (char )'3',      (char )'G',      (char )'h',      (char )'C', 
        (char )'/',      (char )'j',      (char )'0',      (char )'Q', 
        (char )'g',      (char )'9',      (char )'0',      (char )'u', 
        (char )'3',      (char )'s',      (char )'G',      (char )'/', 
        (char )'1',      (char )'C',      (char )'U',      (char )'t', 
        (char )'\n',      (char )'w',      (char )'C',      (char )'5', 
        (char )'v',      (char )'O',      (char )'Y',      (char )'v', 
        (char )'f',      (char )'D',      (char )'m',      (char )'F', 
        (char )'I',      (char )'6',      (char )'o',      (char )'S', 
        (char )'F',      (char )'X',      (char )'i',      (char )'5', 
        (char )'E',      (char )'L',      (char )'a',      (char )'b', 
        (char )'W',      (char )'J',      (char )'m',      (char )'T', 
        (char )'2',      (char )'d',      (char )'K',      (char )'H', 
        (char )'z',      (char )'B',      (char )'J',      (char )'K', 
        (char )'a',      (char )'3',      (char )'k',      (char )'9', 
        (char )'o',      (char )'k',      (char )'+',      (char )'8', 
        (char )'t',      (char )'9',      (char )'u',      (char )'c', 
        (char )'R',      (char )'q',      (char )'M',      (char )'d', 
        (char )'6',      (char )'D',      (char )'Z',      (char )'H', 
        (char )'J',      (char )'2',      (char )'Y',      (char )'C', 
        (char )'C',      (char )'L',      (char )'l',      (char )'D', 
        (char )'R',      (char )'K',      (char )'S',      (char )'K', 
        (char )'v',      (char )'6',      (char )'k',      (char )'D', 
        (char )'q',      (char )'n',      (char )'w',      (char )'4', 
        (char )'U',      (char )'\n',      (char )'w',      (char )'P', 
        (char )'d',      (char )'p',      (char )'O',      (char )'M', 
        (char )'X',      (char )'z',      (char )'i',      (char )'C', 
        (char )'/',      (char )'A',      (char )'M',      (char )'j', 
        (char )'3',      (char )'Z',      (char )'/',      (char )'l', 
        (char )'U',      (char )'V',      (char )'X',      (char )'1', 
        (char )'G',      (char )'7',      (char )'W',      (char )'S', 
        (char )'H',      (char )'C',      (char )'A',      (char )'W', 
        (char )'K',      (char )'f',      (char )'1',      (char )'z', 
        (char )'N',      (char )'S',      (char )'1',      (char )'e', 
        (char )'L',      (char )'v',      (char )'q',      (char )'r', 
        (char )'+',      (char )'b',      (char )'o',      (char )'E', 
        (char )'j',      (char )'X',      (char )'u',      (char )'B', 
        (char )'O',      (char )'i',      (char )'t',      (char )'n', 
        (char )'Z',      (char )'/',      (char )'b',      (char )'D', 
        (char )'z',      (char )'P',      (char )'H',      (char )'r', 
        (char )'T',      (char )'O',      (char )'Z',      (char )'z', 
        (char )'0',      (char )'D',      (char )'e',      (char )'w', 
        (char )'0',      (char )'u',      (char )'o',      (char )'w', 
        (char )'x',      (char )'f',      (char )'\n',      (char )'/', 
        (char )'+',      (char )'s',      (char )'G',      (char )'+', 
        (char )'N',      (char )'C',      (char )'K',      (char )'3', 
        (char )'e',      (char )'Q',      (char )'J',      (char )'V', 
        (char )'x',      (char )'q',      (char )'c',      (char )'a', 
        (char )'J',      (char )'/',      (char )'v',      (char )'E', 
        (char )'H',      (char )'K',      (char )'I',      (char )'V', 
        (char )'d',      (char )'2',      (char )'M',      (char )'+', 
        (char )'5',      (char )'q',      (char )'L',      (char )'7', 
        (char )'1',      (char )'y',      (char )'J',      (char )'Q', 
        (char )'+',      (char )'8',      (char )'7',      (char )'X', 
        (char )'6',      (char )'o',      (char )'V',      (char )'3', 
        (char )'e',      (char )'a',      (char )'Y',      (char )'v', 
        (char )'t',      (char )'3',      (char )'z',      (char )'W', 
        (char )'Z',      (char )'Y',      (char )'D',      (char )'6', 
        (char )'z',      (char )'5',      (char )'v',      (char )'Y', 
        (char )'T',      (char )'c',      (char )'r',      (char )'t', 
        (char )'i',      (char )'j',      (char )'2',      (char )'V', 
        (char )'Z',      (char )'9',      (char )'Z',      (char )'m', 
        (char )'n',      (char )'i',      (char )'/',      (char )'\n', 
        (char )'U',      (char )'A',      (char )'a',      (char )'H', 
        (char )'q',      (char )'n',      (char )'9',      (char )'J', 
        (char )'d',      (char )'s',      (char )'B',      (char )'W', 
        (char )'L',      (char )'U',      (char )'E',      (char )'p', 
        (char )'V',      (char )'v',      (char )'i',      (char )'Y', 
        (char )'n',      (char )'h',      (char )'i',      (char )'m', 
        (char )'N',      (char )'V',      (char )'v',      (char )'Y', 
        (char )'F',      (char )'Z',      (char )'e',      (char )'C', 
        (char )'X',      (char )'g',      (char )'/',      (char )'I', 
        (char )'d',      (char )'T',      (char )'Q',      (char )'+', 
        (char )'x',      (char )'4',      (char )'I',      (char )'R', 
        (char )'d',      (char )'i',      (char )'X',      (char )'N', 
        (char )'v',      (char )'5',      (char )'h',      (char )'E', 
        (char )'e',      (char )'w',      (char )'I',      (char )'D', 
        (char )'A',      (char )'Q',      (char )'A',      (char )'B', 
        (char )'A',      (char )'o',      (char )'I',      (char )'B', 
        (char )'A',      (char )'Q',      (char )'D',      (char )'l', 
        (char )'8',      (char )'A',      (char )'x',      (char )'y', 
        (char )'9',      (char )'X',      (char )'f',      (char )'W', 
        (char )'\n',      (char )'B',      (char )'L',      (char )'m', 
        (char )'k',      (char )'z',      (char )'k',      (char )'E', 
        (char )'i',      (char )'q',      (char )'o',      (char )'S', 
        (char )'w',      (char )'F',      (char )'0',      (char )'P', 
        (char )'s',      (char )'m',      (char )'V',      (char )'r', 
        (char )'P',      (char )'z',      (char )'H',      (char )'9', 
        (char )'K',      (char )'s',      (char )'n',      (char )'w', 
        (char )'L',      (char )'G',      (char )'H',      (char )'+', 
        (char )'Q',      (char )'Z',      (char )'l',      (char )'v', 
        (char )'j',      (char )'W',      (char )'d',      (char )'8', 
        (char )'S',      (char )'W',      (char )'Y',      (char )'G', 
        (char )'N',      (char )'7',      (char )'u',      (char )'1', 
        (char )'5',      (char )'0',      (char )'7',      (char )'H', 
        (char )'v',      (char )'h',      (char )'F',      (char )'5', 
        (char )'N',      (char )'3',      (char )'d',      (char )'r', 
        (char )'J',      (char )'o',      (char )'V',      (char )'U', 
        (char )'3',      (char )'O',      (char )'1',      (char )'4', 
        (char )'n',      (char )'D',      (char )'Y',      (char )'4', 
        (char )'T',      (char )'F',      (char )'Q',      (char )'A', 
        (char )'a',      (char )'\n',      (char )'L',      (char )'l', 
        (char )'J',      (char )'9',      (char )'V',      (char )'M', 
        (char )'3',      (char )'5',      (char )'A',      (char )'A', 
        (char )'p',      (char )'X',      (char )'a',      (char )'L', 
        (char )'y',      (char )'Y',      (char )'1',      (char )'E', 
        (char )'R',      (char )'r',      (char )'N',      (char )'7', 
        (char )'u',      (char )'9',      (char )'A',      (char )'L', 
        (char )'K',      (char )'d',      (char )'2',      (char )'L', 
        (char )'U',      (char )'w',      (char )'Y',      (char )'h', 
        (char )'M',      (char )'7',      (char )'K',      (char )'m', 
        (char )'5',      (char )'3',      (char )'9',      (char )'O', 
        (char )'4',      (char )'y',      (char )'U',      (char )'F', 
        (char )'Y',      (char )'i',      (char )'k',      (char )'E', 
        (char )'2',      (char )'n',      (char )'I',      (char )'P', 
        (char )'s',      (char )'c',      (char )'E',      (char )'s', 
        (char )'A',      (char )'5',      (char )'l',      (char )'t', 
        (char )'p',      (char )'x',      (char )'O',      (char )'g', 
        (char )'U',      (char )'G',      (char )'C',      (char )'Y', 
        (char )'7',      (char )'b',      (char )'7',      (char )'e', 
        (char )'z',      (char )'5',      (char )'\n',      (char )'N', 
        (char )'t',      (char )'D',      (char )'6',      (char )'n', 
        (char )'L',      (char )'1',      (char )'Z',      (char )'K', 
        (char )'a',      (char )'u',      (char )'w',      (char )'7', 
        (char )'a',      (char )'N',      (char )'X',      (char )'m', 
        (char )'V',      (char )'A',      (char )'v',      (char )'m', 
        (char )'J',      (char )'T',      (char )'c',      (char )'u', 
        (char )'P',      (char )'x',      (char )'W',      (char )'m', 
        (char )'o',      (char )'k',      (char )'t',      (char )'F', 
        (char )'3',      (char )'g',      (char )'D',      (char )'J', 
        (char )'K',      (char )'K',      (char )'2',      (char )'w', 
        (char )'x',      (char )'Z',      (char )'u',      (char )'N', 
        (char )'G',      (char )'c',      (char )'J',      (char )'E', 
        (char )'0',      (char )'u',      (char )'F',      (char )'Q', 
        (char )'E',      (char )'G',      (char )'4',      (char )'Z', 
        (char )'3',      (char )'B',      (char )'r',      (char )'W', 
        (char )'P',      (char )'7',      (char )'y',      (char )'o', 
        (char )'N',      (char )'u',      (char )'S',      (char )'K', 
        (char )'3',      (char )'d',      (char )'i',      (char )'i', 
        (char )'2',      (char )'j',      (char )'m',      (char )'\n', 
        (char )'l',      (char )'p',      (char )'P',      (char )'H', 
        (char )'r',      (char )'0',      (char )'O',      (char )'/', 
        (char )'K',      (char )'n',      (char )'P',      (char )'Q', 
        (char )'t',      (char )'z',      (char )'I',      (char )'3', 
        (char )'e',      (char )'g',      (char )'u',      (char )'h', 
        (char )'e',      (char )'0',      (char )'T',      (char )'w', 
        (char )'U',      (char )'e',      (char )'m',      (char )'/', 
        (char )'e',      (char )'Y',      (char )'S',      (char )'d', 
        (char )'y',      (char )'z',      (char )'M',      (char )'y', 
        (char )'V',      (char )'x',      (char )'/',      (char )'Y', 
        (char )'p',      (char )'w',      (char )'k',      (char )'z', 
        (char )'w',      (char )'t',      (char )'Y',      (char )'L', 
        (char )'3',      (char )'s',      (char )'R',      (char )'5', 
        (char )'k',      (char )'0',      (char )'o',      (char )'9', 
        (char )'r',      (char )'K',      (char )'Q',      (char )'L', 
        (char )'t',      (char )'v',      (char )'L',      (char )'z', 
        (char )'f',      (char )'A',      (char )'q',      (char )'d', 
        (char )'B',      (char )'x',      (char )'B',      (char )'u', 
        (char )'r',      (char )'c',      (char )'i',      (char )'z', 
        (char )'\n',      (char )'a',      (char )'a',      (char )'A', 
        (char )'/',      (char )'L',      (char )'0',      (char )'H', 
        (char )'I',      (char )'g',      (char )'A',      (char )'m', 
        (char )'O',      (char )'i',      (char )'t',      (char )'1', 
        (char )'G',      (char )'J',      (char )'A',      (char )'2', 
        (char )'s',      (char )'a',      (char )'M',      (char )'x', 
        (char )'T',      (char )'V',      (char )'P',      (char )'N', 
        (char )'h',      (char )'A',      (char )'o',      (char )'G', 
        (char )'B',      (char )'A',      (char )'P',      (char )'f', 
        (char )'g',      (char )'v',      (char )'1',      (char )'o', 
        (char )'e',      (char )'Z',      (char )'x',      (char )'g', 
        (char )'x',      (char )'m',      (char )'o',      (char )'t', 
        (char )'i',      (char )'C',      (char )'c',      (char )'M', 
        (char )'X',      (char )'F',      (char )'E',      (char )'Q', 
        (char )'E',      (char )'W',      (char )'f',      (char )'l', 
        (char )'z',      (char )'h',      (char )'W',      (char )'Y', 
        (char )'T',      (char )'s',      (char )'X',      (char )'r', 
        (char )'h',      (char )'U',      (char )'I',      (char )'u', 
        (char )'z',      (char )'5',      (char )'j',      (char )'F', 
        (char )'u',      (char )'\n',      (char )'a',      (char )'3', 
        (char )'9',      (char )'G',      (char )'L',      (char )'S', 
        (char )'9',      (char )'9',      (char )'Z',      (char )'E', 
        (char )'E',      (char )'r',      (char )'h',      (char )'L', 
        (char )'d',      (char )'r',      (char )'w',      (char )'j', 
        (char )'8',      (char )'r',      (char )'D',      (char )'D', 
        (char )'V',      (char )'i',      (char )'R',      (char )'V', 
        (char )'J',      (char )'5',      (char )'s',      (char )'k', 
        (char )'O',      (char )'p',      (char )'9',      (char )'z', 
        (char )'F',      (char )'v',      (char )'l',      (char )'Y', 
        (char )'A',      (char )'H',      (char )'s',      (char )'0', 
        (char )'x',      (char )'h',      (char )'9',      (char )'2', 
        (char )'j',      (char )'i',      (char )'1',      (char )'E', 
        (char )'7',      (char )'V',      (char )'/',      (char )'y', 
        (char )'s',      (char )'n',      (char )'K',      (char )'B', 
        (char )'f',      (char )'s',      (char )'M',      (char )'r', 
        (char )'P',      (char )'k',      (char )'k',      (char )'5', 
        (char )'K',      (char )'S',      (char )'K',      (char )'P', 
        (char )'r',      (char )'n',      (char )'j',      (char )'n', 
        (char )'d',      (char )'M',      (char )'\n',      (char )'o', 
        (char )'P',      (char )'d',      (char )'e',      (char )'v', 
        (char )'W',      (char )'n',      (char )'V',      (char )'k', 
        (char )'g',      (char )'J',      (char )'5',      (char )'j', 
        (char )'x',      (char )'F',      (char )'u',      (char )'N', 
        (char )'g',      (char )'x',      (char )'k',      (char )'O', 
        (char )'L',      (char )'M',      (char )'u',      (char )'G', 
        (char )'9',      (char )'i',      (char )'5',      (char )'3', 
        (char )'B',      (char )'4',      (char )'y',      (char )'M', 
        (char )'v',      (char )'D',      (char )'T',      (char )'C', 
        (char )'R',      (char )'i',      (char )'I',      (char )'P', 
        (char )'M',      (char )'Q',      (char )'+',      (char )'+', 
        (char )'N',      (char )'2',      (char )'i',      (char )'L', 
        (char )'D',      (char )'a',      (char )'R',      (char )'A', 
        (char )'o',      (char )'G',      (char )'B',      (char )'A', 
        (char )'O',      (char )'9',      (char )'v',      (char )'/', 
        (char )'/',      (char )'m',      (char )'U',      (char )'8', 
        (char )'e',      (char )'V',      (char )'k',      (char )'Q', 
        (char )'a',      (char )'o',      (char )'A',      (char )'N', 
        (char )'f',      (char )'0',      (char )'Z',      (char )'\n', 
        (char )'o',      (char )'M',      (char )'j',      (char )'W', 
        (char )'8',      (char )'C',      (char )'N',      (char )'4', 
        (char )'x',      (char )'w',      (char )'W',      (char )'A', 
        (char )'2',      (char )'c',      (char )'S',      (char )'E', 
        (char )'I',      (char )'H',      (char )'k',      (char )'d', 
        (char )'9',      (char )'A',      (char )'f',      (char )'F', 
        (char )'k',      (char )'f',      (char )'t',      (char )'u', 
        (char )'v',      (char )'8',      (char )'o',      (char )'y', 
        (char )'L',      (char )'D',      (char )'C',      (char )'G', 
        (char )'3',      (char )'Z',      (char )'A',      (char )'f', 
        (char )'0',      (char )'v',      (char )'r',      (char )'h', 
        (char )'r',      (char )'r',      (char )'t',      (char )'k', 
        (char )'r',      (char )'f',      (char )'a',      (char )'7', 
        (char )'e',      (char )'f',      (char )'+',      (char )'A', 
        (char )'U',      (char )'b',      (char )'6',      (char )'9', 
        (char )'D',      (char )'N',      (char )'g',      (char )'g', 
        (char )'q',      (char )'4',      (char )'m',      (char )'H', 
        (char )'Q',      (char )'A',      (char )'Y',      (char )'B', 
        (char )'p',      (char )'7',      (char )'L',      (char )'+', 
        (char )'\n',      (char )'k',      (char )'5',      (char )'D', 
        (char )'K',      (char )'z',      (char )'J',      (char )'r', 
        (char )'K',      (char )'u',      (char )'O',      (char )'0', 
        (char )'r',      (char )'+',      (char )'R',      (char )'0', 
        (char )'Y',      (char )'b',      (char )'Y',      (char )'9', 
        (char )'p',      (char )'Z',      (char )'D',      (char )'1', 
        (char )'+',      (char )'/',      (char )'g',      (char )'9', 
        (char )'d',      (char )'V',      (char )'t',      (char )'9', 
        (char )'1',      (char )'d',      (char )'6',      (char )'L', 
        (char )'Q',      (char )'N',      (char )'e',      (char )'p', 
        (char )'U',      (char )'E',      (char )'/',      (char )'y', 
        (char )'Y',      (char )'2',      (char )'P',      (char )'P', 
        (char )'5',      (char )'C',      (char )'N',      (char )'o', 
        (char )'F',      (char )'m',      (char )'j',      (char )'e', 
        (char )'d',      (char )'p',      (char )'L',      (char )'H', 
        (char )'M',      (char )'O',      (char )'P',      (char )'F', 
        (char )'d',      (char )'V',      (char )'g',      (char )'q', 
        (char )'D',      (char )'z',      (char )'D',      (char )'F', 
        (char )'x',      (char )'U',      (char )'8',      (char )'h', 
        (char )'L',      (char )'\n',      (char )'A',      (char )'o', 
        (char )'G',      (char )'B',      (char )'A',      (char )'N', 
        (char )'D',      (char )'r',      (char )'r',      (char )'7', 
        (char )'x',      (char )'A',      (char )'J',      (char )'b', 
        (char )'q',      (char )'B',      (char )'j',      (char )'H', 
        (char )'V',      (char )'w',      (char )'I',      (char )'z', 
        (char )'Q',      (char )'4',      (char )'T',      (char )'o', 
        (char )'9',      (char )'p',      (char )'b',      (char )'4', 
        (char )'B',      (char )'N',      (char )'e',      (char )'q', 
        (char )'D',      (char )'n',      (char )'d',      (char )'k', 
        (char )'5',      (char )'Q',      (char )'e',      (char )'7', 
        (char )'f',      (char )'T',      (char )'3',      (char )'+', 
        (char )'/',      (char )'H',      (char )'1',      (char )'n', 
        (char )'j',      (char )'G',      (char )'a',      (char )'C', 
        (char )'0',      (char )'/',      (char )'r',      (char )'X', 
        (char )'E',      (char )'0',      (char )'Q',      (char )'b', 
        (char )'7',      (char )'q',      (char )'5',      (char )'y', 
        (char )'S',      (char )'g',      (char )'n',      (char )'s', 
        (char )'C',      (char )'b',      (char )'3',      (char )'D', 
        (char )'v',      (char )'A',      (char )'\n',      (char )'c', 
        (char )'J',      (char )'y',      (char )'R',      (char )'M', 
        (char )'9',      (char )'S',      (char )'J',      (char )'7', 
        (char )'O',      (char )'K',      (char )'l',      (char )'G', 
        (char )'t',      (char )'0',      (char )'F',      (char )'M', 
        (char )'S',      (char )'d',      (char )'J',      (char )'D', 
        (char )'5',      (char )'K',      (char )'G',      (char )'0', 
        (char )'X',      (char )'P',      (char )'I',      (char )'p', 
        (char )'A',      (char )'V',      (char )'N',      (char )'w', 
        (char )'g',      (char )'p',      (char )'X',      (char )'X', 
        (char )'H',      (char )'5',      (char )'M',      (char )'D', 
        (char )'J',      (char )'g',      (char )'0',      (char )'9', 
        (char )'K',      (char )'H',      (char )'e',      (char )'h', 
        (char )'0',      (char )'k',      (char )'X',      (char )'o', 
        (char )'+',      (char )'Q',      (char )'A',      (char )'6', 
        (char )'v',      (char )'i',      (char )'F',      (char )'B', 
        (char )'i',      (char )'2',      (char )'1',      (char )'y', 
        (char )'3',      (char )'4',      (char )'0',      (char )'N', 
        (char )'o',      (char )'n',      (char )'n',      (char )'E', 
        (char )'f',      (char )'d',      (char )'f',      (char )'\n', 
        (char )'5',      (char )'4',      (char )'P',      (char )'X', 
        (char )'4',      (char )'Z',      (char )'G',      (char )'S', 
        (char )'/',      (char )'X',      (char )'a',      (char )'c', 
        (char )'1',      (char )'U',      (char )'K',      (char )'+', 
        (char )'p',      (char )'L',      (char )'k',      (char )'B', 
        (char )'B',      (char )'+',      (char )'z',      (char )'R', 
        (char )'A',      (char )'o',      (char )'G',      (char )'A', 
        (char )'f',      (char )'0',      (char )'A',      (char )'Y', 
        (char )'3',      (char )'H',      (char )'3',      (char )'q', 
        (char )'K',      (char )'S',      (char )'2',      (char )'l', 
        (char )'M',      (char )'E',      (char )'I',      (char )'4', 
        (char )'b',      (char )'z',      (char )'E',      (char )'F', 
        (char )'o',      (char )'H',      (char )'e',      (char )'K', 
        (char )'3',      (char )'G',      (char )'8',      (char )'9', 
        (char )'5',      (char )'p',      (char )'D',      (char )'a', 
        (char )'K',      (char )'3',      (char )'T',      (char )'F', 
        (char )'B',      (char )'V',      (char )'m',      (char )'D', 
        (char )'7',      (char )'f',      (char )'V',      (char )'0', 
        (char )'Z',      (char )'h',      (char )'o',      (char )'v', 
        (char )'\n',      (char )'1',      (char )'7',      (char )'f', 
        (char )'e',      (char )'g',      (char )'F',      (char )'P', 
        (char )'M',      (char )'w',      (char )'O',      (char )'I', 
        (char )'I',      (char )'8',      (char )'M',      (char )'i', 
        (char )'s',      (char )'Y',      (char )'m',      (char )'9', 
        (char )'Z',      (char )'f',      (char )'T',      (char )'2', 
        (char )'Z',      (char )'0',      (char )'s',      (char )'5', 
        (char )'R',      (char )'o',      (char )'3',      (char )'s', 
        (char )'5',      (char )'r',      (char )'k',      (char )'t', 
        (char )'+',      (char )'n',      (char )'v',      (char )'L', 
        (char )'A',      (char )'d',      (char )'f',      (char )'C', 
        (char )'/',      (char )'P',      (char )'Y',      (char )'P', 
        (char )'K',      (char )'z',      (char )'T',      (char )'L', 
        (char )'a',      (char )'l',      (char )'p',      (char )'G', 
        (char )'S',      (char )'w',      (char )'o',      (char )'m', 
        (char )'S',      (char )'N',      (char )'Y',      (char )'J', 
        (char )'c',      (char )'B',      (char )'9',      (char )'H', 
        (char )'N',      (char )'M',      (char )'l',      (char )'m', 
        (char )'h',      (char )'k',      (char )'G',      (char )'z', 
        (char )'c',      (char )'\n',      (char )'1',      (char )'J', 
        (char )'n',      (char )'L',      (char )'Y',      (char )'T', 
        (char )'4',      (char )'i',      (char )'y',      (char )'U', 
        (char )'y',      (char )'x',      (char )'6',      (char )'p', 
        (char )'c',      (char )'Z',      (char )'B',      (char )'m', 
        (char )'C',      (char )'d',      (char )'8',      (char )'b', 
        (char )'D',      (char )'0',      (char )'i',      (char )'w', 
        (char )'Y',      (char )'/',      (char )'F',      (char )'z', 
        (char )'c',      (char )'g',      (char )'N',      (char )'D', 
        (char )'a',      (char )'U',      (char )'m',      (char )'b', 
        (char )'X',      (char )'9',      (char )'+',      (char )'X', 
        (char )'D',      (char )'v',      (char )'R',      (char )'A', 
        (char )'0',      (char )'C',      (char )'g',      (char )'Y', 
        (char )'E',      (char )'A',      (char )'k',      (char )'E', 
        (char )'7',      (char )'p',      (char )'I',      (char )'P', 
        (char )'l',      (char )'E',      (char )'7',      (char )'1', 
        (char )'q',      (char )'v',      (char )'f',      (char )'J', 
        (char )'Q',      (char )'g',      (char )'o',      (char )'A', 
        (char )'9',      (char )'e',      (char )'m',      (char )'0', 
        (char )'g',      (char )'I',      (char )'\n',      (char )'L', 
        (char )'A',      (char )'u',      (char )'E',      (char )'4', 
        (char )'P',      (char )'u',      (char )'1',      (char )'3', 
        (char )'a',      (char )'K',      (char )'i',      (char )'J', 
        (char )'n',      (char )'f',      (char )'f',      (char )'t', 
        (char )'7',      (char )'h',      (char )'I',      (char )'j', 
        (char )'b',      (char )'K',      (char )'+',      (char )'5', 
        (char )'k',      (char )'y',      (char )'b',      (char )'3', 
        (char )'T',      (char )'y',      (char )'s',      (char )'Z', 
        (char )'v',      (char )'o',      (char )'y',      (char )'D', 
        (char )'n',      (char )'b',      (char )'3',      (char )'H', 
        (char )'O',      (char )'K',      (char )'v',      (char )'I', 
        (char )'n',      (char )'K',      (char )'7',      (char )'v', 
        (char )'X',      (char )'b',      (char )'K',      (char )'u', 
        (char )'U',      (char )'4',      (char )'I',      (char )'S', 
        (char )'g',      (char )'x',      (char )'B',      (char )'2', 
        (char )'b',      (char )'B',      (char )'3',      (char )'H', 
        (char )'c',      (char )'Y',      (char )'z',      (char )'Q', 
        (char )'M',      (char )'G',      (char )'s',      (char )'z', 
        (char )'1',      (char )'q',      (char )'J',      (char )'\n', 
        (char )'2',      (char )'g',      (char )'G',      (char )'0', 
        (char )'N',      (char )'5',      (char )'h',      (char )'v', 
        (char )'J',      (char )'p',      (char )'z',      (char )'w', 
        (char )'w',      (char )'h',      (char )'b',      (char )'h', 
        (char )'X',      (char )'q',      (char )'F',      (char )'K', 
        (char )'A',      (char )'4',      (char )'z',      (char )'a', 
        (char )'a',      (char )'S',      (char )'r',      (char )'w', 
        (char )'6',      (char )'2',      (char )'2',      (char )'w', 
        (char )'D',      (char )'n',      (char )'i',      (char )'A', 
        (char )'K',      (char )'5',      (char )'M',      (char )'l', 
        (char )'I',      (char )'E',      (char )'0',      (char )'t', 
        (char )'I',      (char )'A',      (char )'K',      (char )'K', 
        (char )'P',      (char )'4',      (char )'y',      (char )'x', 
        (char )'N',      (char )'G',      (char )'j',      (char )'o', 
        (char )'D',      (char )'2',      (char )'Q',      (char )'Y', 
        (char )'j',      (char )'h',      (char )'B',      (char )'G', 
        (char )'u',      (char )'h',      (char )'v',      (char )'k', 
        (char )'W',      (char )'K',      (char )'Y',      (char )'=', 
        (char )'\n',      (char )'-',      (char )'-',      (char )'-', 
        (char )'-',      (char )'-',      (char )'E',      (char )'N', 
        (char )'D',      (char )' ',      (char )'R',      (char )'S', 
        (char )'A',      (char )' ',      (char )'P',      (char )'R', 
        (char )'I',      (char )'V',      (char )'A',      (char )'T', 
        (char )'E',      (char )' ',      (char )'K',      (char )'E', 
        (char )'Y',      (char )'-',      (char )'-',      (char )'-', 
        (char )'-',      (char )'-',      (char )'\000'};
static char *rsa_apply(unsigned char *input , int inlen , int *outlen , int mode ) 
{ 
  unsigned char *out ;
  RSA *rsa ;
  BIO *bmem ;
  BIO *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  tmp = BIO_new_mem_buf((void const   *)(super_secret_key), -1);
  bmem = tmp;
  rsa = PEM_read_bio_RSAPrivateKey(bmem, (RSA **)((void *)0), (pem_password_cb *)((void *)0),
                                   (void *)0);
  BIO_free(bmem);
  tmp___0 = RSA_size((RSA const   *)rsa);
  tmp___1 = malloc((size_t )tmp___0);
  out = (unsigned char *)tmp___1;
  switch (mode) {
  case 1: 
  *outlen = RSA_private_encrypt(inlen, (unsigned char const   *)input, out, rsa, 1);
  break;
  case 0: 
  *outlen = RSA_private_decrypt(inlen, (unsigned char const   *)input, out, rsa, 4);
  break;
  }
  RSA_free(rsa);
  return ((char *)out);
}
}
static int base64_pad(char *src , char **padded ) 
{ 
  int n ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
  tmp = strlen((char const   *)src);
  tmp___0 = strlen((char const   *)src);
  n = (int )(tmp + tmp___0 % 4UL);
  tmp___1 = malloc((size_t )(n + 1));
  *padded = (char *)tmp___1;
  memset((void *)*padded, '=', (size_t )n);
  tmp___2 = strlen((char const   *)src);
  memcpy((void * __restrict  )*padded, (void const   * __restrict  )src, tmp___2);
  *(*padded + n) = (char )'\000';
  tmp___3 = strlen((char const   *)*padded);
  return ((int )tmp___3);
}
}
static void on_dmap_string(void *ctx , char const   *code , char const   *name , char const   *buf___0 ,
                           size_t len ) 
{ 
  struct metadata_s *metadata ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  metadata = (struct metadata_s *)ctx;
  tmp___1 = strcasecmp(code, "asar");
  if (tmp___1) {
    tmp___0 = strcasecmp(code, "asal");
    if (tmp___0) {
      tmp = strcasecmp(code, "minm");
      if (! tmp) {
        metadata->title = strndup(buf___0, len);
      }
    } else {
      metadata->album = strndup(buf___0, len);
    }
  } else {
    metadata->artist = strndup(buf___0, len);
  }
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#pragma merger("0","/tmp/cil-ow6wwqLu.i","-Wall,-fPIC,-ggdb,-O2,-m64,-fdata-sections,-ffunction-sections")
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  * __restrict  __addr ,
                                              socklen_t __len ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         void * __restrict  __tz ) ;
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) pthread_mutex_timedlock)(pthread_mutex_t * __restrict  __mutex ,
                                                                                                      struct timespec  const  * __restrict  __abstime ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_broadcast)(pthread_cond_t *__cond ) ;
extern int ( __attribute__((__nonnull__(1,2,3))) pthread_cond_timedwait)(pthread_cond_t * __restrict  __cond ,
                                                                         pthread_mutex_t * __restrict  __mutex ,
                                                                         struct timespec  const  * __restrict  __abstime ) ;
char *strlwr(char *str___0 ) ;
u64_t gettime_ms64(void) ;
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) tolower)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_tolower_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
    tmp___0 = (__int32_t const   )__c;
  }
  return ((int )tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) toupper)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_toupper_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
    tmp___0 = (__int32_t const   )__c;
  }
  return ((int )tmp___0);
}
}
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vasprintf)(char ** __restrict  __ptr ,
                                                                              char const   * __restrict  __f ,
                                                                              __gnuc_va_list __arg ) ;
extern int ixmlNode_setNodeValue(IXML_Node *nodeptr , char const   *newNodeValue ) ;
extern char const   *ixmlNode_getLocalName(IXML_Node *nodeptr ) ;
extern IXML_Element *ixmlDocument_createElement(IXML_Document *doc , char const   *tagName ) ;
extern IXML_Node *ixmlDocument_createTextNode(IXML_Document *doc , char const   *data ) ;
extern int ixmlElement_setAttribute(IXML_Element *element , char const   *name , char const   *value ) ;
list_t *push_item(list_t *item , list_t **list ) ;
list_t *add_tail_item(list_t *item , list_t **list ) ;
list_t *add_ordered_item(list_t *item , list_t **list , int (*compare)(void *a , void *b ) ) ;
list_t *pop_item(list_t **list ) ;
list_t *remove_item(list_t *item , list_t **list ) ;
void clear_list(list_t **list , void (*free_func)(void * ) ) ;
int pthread_cond_reltimedwait(pthread_cond_t *cond , pthread_mutex_t *mutex , u32_t msWait ) ;
char *ltrim(char *s ) ;
char *rtrim(char *s ) ;
char *trim(char *s ) ;
_Bool get_interface(struct in_addr *addr ) ;
void get_mac(u8_t *mac ) ;
int conn_socket(unsigned short port ) ;
int read_line(int fd , char *line , int maxlen , int timeout ) ;
static log_level *loglevel___4  =    & util_loglevel;
static pthread_mutex_t wakeMutex  ;
static pthread_cond_t wakeCond  ;
void InitUtils(void) 
{ 


  {
  pthread_mutex_init(& wakeMutex, (pthread_mutexattr_t const   *)0);
  pthread_cond_init((pthread_cond_t * __restrict  )(& wakeCond), (pthread_condattr_t const   * __restrict  )0);
  return;
}
}
void EndUtils(void) 
{ 


  {
  pthread_mutex_destroy(& wakeMutex);
  pthread_cond_destroy(& wakeCond);
  return;
}
}
void WakeableSleep(u32_t ms ) 
{ 


  {
  pthread_mutex_lock(& wakeMutex);
  if (ms) {
    pthread_cond_reltimedwait(& wakeCond, & wakeMutex, ms);
  } else {
    pthread_cond_wait((pthread_cond_t * __restrict  )(& wakeCond), (pthread_mutex_t * __restrict  )(& wakeMutex));
  }
  pthread_mutex_unlock(& wakeMutex);
  return;
}
}
void WakeAll(void) 
{ 


  {
  pthread_mutex_lock(& wakeMutex);
  pthread_cond_broadcast(& wakeCond);
  pthread_mutex_unlock(& wakeMutex);
  return;
}
}
int pthread_cond_reltimedwait(pthread_cond_t *cond , pthread_mutex_t *mutex , u32_t msWait ) 
{ 
  struct timespec ts ;
  u32_t nsec ;
  int tmp ;
  int tmp___0 ;

  {
  clock_gettime(0, & ts);
  if (! msWait) {
    tmp = pthread_cond_wait((pthread_cond_t * __restrict  )cond, (pthread_mutex_t * __restrict  )mutex);
    return (tmp);
  }
  nsec = (u32_t )(ts.tv_nsec + (__syscall_slong_t )((msWait % 1000U) * 1000000U));
  ts.tv_sec += (__time_t )(msWait / 1000U + nsec / 1000000000U);
  ts.tv_nsec = (__syscall_slong_t )(nsec % 1000000000U);
  tmp___0 = pthread_cond_timedwait((pthread_cond_t * __restrict  )cond, (pthread_mutex_t * __restrict  )mutex,
                                   (struct timespec  const  * __restrict  )(& ts));
  return (tmp___0);
}
}
int _mutex_timedlock(pthread_mutex_t *m , u32_t ms_wait ) 
{ 
  int rc ;
  struct timespec ts ;
  int tmp ;

  {
  rc = -1;
  tmp = clock_gettime(0, & ts);
  if (! tmp) {
    ts.tv_nsec += (__syscall_slong_t )((ms_wait % 1000U) * 1000000U);
    ts.tv_sec += (__syscall_slong_t )(ms_wait / 1000U) + ts.tv_nsec / 1000000000L;
    ts.tv_nsec %= 1000000000L;
    rc = pthread_mutex_timedlock((pthread_mutex_t * __restrict  )m, (struct timespec  const  * __restrict  )(& ts));
  }
  return (rc);
}
}
void QueueInit(tQueue *queue , _Bool mutex , void (*cleanup)(void * ) ) 
{ 
  void *tmp ;

  {
  queue->cleanup = cleanup;
  queue->list.item = (void *)0;
  if (mutex) {
    tmp = malloc(sizeof(pthread_mutex_t ));
    queue->mutex = (pthread_mutex_t *)tmp;
    pthread_mutex_init(queue->mutex, (pthread_mutexattr_t const   *)((void *)0));
  } else {
    queue->mutex = (pthread_mutex_t *)((void *)0);
  }
  return;
}
}
void QueueInsert(tQueue *queue , void *item ) 
{ 
  struct sQueue_e *list ;
  void *tmp ;

  {
  if (queue->mutex) {
    pthread_mutex_lock(queue->mutex);
  }
  list = & queue->list;
  while (list->item) {
    list = list->next;
  }
  list->item = item;
  tmp = malloc(sizeof(struct sQueue_e ));
  list->next = (struct sQueue_e *)tmp;
  (list->next)->item = (void *)0;
  if (queue->mutex) {
    pthread_mutex_unlock(queue->mutex);
  }
  return;
}
}
void *QueueExtract(tQueue *queue ) 
{ 
  void *item ;
  struct sQueue_e *list ;
  struct sQueue_e *next ;

  {
  if (queue->mutex) {
    pthread_mutex_lock(queue->mutex);
  }
  list = & queue->list;
  item = list->item;
  if (item) {
    next = list->next;
    if (next->item) {
      list->item = next->item;
      list->next = next->next;
    } else {
      list->item = (void *)0;
    }
    if (next) {
      free((void *)next);
      next = (struct sQueue_e *)((void *)0);
    }
  }
  if (queue->mutex) {
    pthread_mutex_unlock(queue->mutex);
  }
  return (item);
}
}
void QueueFlush(tQueue *queue ) 
{ 
  struct sQueue_e *list ;
  struct sQueue_e *next ;

  {
  if (queue->mutex) {
    pthread_mutex_lock(queue->mutex);
  }
  list = & queue->list;
  while (list->item) {
    next = list->next;
    if (queue->cleanup) {
      (*(queue->cleanup))(list->item);
    }
    if ((unsigned long )list != (unsigned long )(& queue->list)) {
      if (list) {
        free((void *)list);
        list = (struct sQueue_e *)((void *)0);
      }
    }
    list = next;
  }
  if ((unsigned long )list != (unsigned long )(& queue->list)) {
    if (list) {
      free((void *)list);
      list = (struct sQueue_e *)((void *)0);
    }
  }
  queue->list.item = (void *)0;
  if (queue->mutex) {
    pthread_mutex_unlock(queue->mutex);
    pthread_mutex_destroy(queue->mutex);
    free((void *)queue->mutex);
  }
  return;
}
}
list_t *push_item(list_t *item , list_t **list ) 
{ 


  {
  if (*list) {
    item->next = *list;
  } else {
    item->next = (struct list_s *)((void *)0);
  }
  *list = item;
  return (item);
}
}
list_t *add_tail_item(list_t *item , list_t **list ) 
{ 
  struct list_s *p ;

  {
  if (*list) {
    p = *list;
    while (p->next) {
      p = p->next;
    }
    item->next = p->next;
    p->next = item;
  } else {
    item->next = (struct list_s *)((void *)0);
    *list = item;
  }
  return (item);
}
}
list_t *add_ordered_item(list_t *item , list_t **list , int (*compare)(void *a , void *b ) ) 
{ 
  struct list_s *p ;
  int tmp ;

  {
  if (*list) {
    p = *list;
    while (1) {
      if (p->next) {
        tmp = (*compare)((void *)p->next, (void *)item);
        if (! (tmp <= 0)) {
          break;
        }
      } else {
        break;
      }
      p = p->next;
    }
    item->next = p->next;
    p->next = item;
  } else {
    item->next = (struct list_s *)((void *)0);
    *list = item;
  }
  return (item);
}
}
list_t *pop_item(list_t **list ) 
{ 
  list_t *item ;

  {
  if (*list) {
    item = *list;
    *list = item->next;
    return (item);
  } else {
    return ((list_t *)((void *)0));
  }
}
}
list_t *remove_item(list_t *item , list_t **list ) 
{ 
  struct list_s *p ;

  {
  if ((unsigned long )item != (unsigned long )*list) {
    p = *list;
    while (1) {
      if (p) {
        if (! ((unsigned long )p->next != (unsigned long )item)) {
          break;
        }
      } else {
        break;
      }
      p = p->next;
    }
    if (p) {
      p->next = item->next;
    }
    item->next = (struct list_s *)((void *)0);
  } else {
    *list = (*list)->next;
  }
  return (item);
}
}
void clear_list(list_t **list , void (*free_func)(void * ) ) 
{ 
  struct list_s *next ;

  {
  if (! *list) {
    return;
  }
  while (*list) {
    next = (*list)->next;
    if (free_func) {
      (*free_func)((void *)*list);
    } else {
      free((void *)*list);
    }
    *list = next;
  }
  *list = (list_t *)((void *)0);
  return;
}
}
void get_mac(u8_t *mac ) 
{ 
  struct ifconf ifc ;
  struct ifreq *ifr ;
  struct ifreq *ifend ;
  struct ifreq ifreq ;
  struct ifreq ifs[4] ;
  u8_t tmp ;
  u8_t tmp___0 ;
  u8_t tmp___1 ;
  u8_t tmp___2 ;
  u8_t tmp___3 ;
  int s ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  tmp___3 = (u8_t )0;
  *(mac + 5) = tmp___3;
  tmp___2 = tmp___3;
  *(mac + 4) = tmp___2;
  tmp___1 = tmp___2;
  *(mac + 3) = tmp___1;
  tmp___0 = tmp___1;
  *(mac + 2) = tmp___0;
  tmp = tmp___0;
  *(mac + 1) = tmp;
  *(mac + 0) = tmp;
  tmp___4 = socket(2, 2, 0);
  s = tmp___4;
  ifc.ifc_len = (int )sizeof(ifs);
  ifc.ifc_ifcu.ifcu_req = ifs;
  tmp___6 = ioctl(s, 35090UL, & ifc);
  if (tmp___6 == 0) {
    ifend = ifs + (unsigned long )ifc.ifc_len / sizeof(struct ifreq );
    ifr = ifc.ifc_ifcu.ifcu_req;
    while ((unsigned long )ifr < (unsigned long )ifend) {
      if ((int )ifr->ifr_ifru.ifru_addr.sa_family == 2) {
        strncpy((char * __restrict  )(ifreq.ifr_ifrn.ifrn_name), (char const   * __restrict  )(ifr->ifr_ifrn.ifrn_name),
                sizeof(ifreq.ifr_ifrn.ifrn_name));
        tmp___5 = ioctl(s, 35111UL, & ifreq);
        if (tmp___5 == 0) {
          memcpy((void * __restrict  )mac, (void const   * __restrict  )(ifreq.ifr_ifru.ifru_hwaddr.sa_data),
                 (size_t )6);
          if (((int )*(mac + 0) + (int )*(mac + 1)) + (int )*(mac + 2) != 0) {
            break;
          }
        }
      }
      ifr ++;
    }
  }
  close(s);
  return;
}
}
int SendARP(in_addr_t src , in_addr_t dst , u8_t *mac , unsigned long *size ) 
{ 
  int s ;
  struct arpreq areq ;
  struct sockaddr_in *sin ;
  int tmp ;

  {
  s = socket(2, 2, 0);
  if (s == -1) {
    return (-1);
  }
  memset((void *)(& areq), 0, sizeof(areq));
  sin = (struct sockaddr_in *)(& areq.arp_pa);
  sin->sin_family = (sa_family_t )2;
  sin->sin_addr.s_addr = src;
  sin = (struct sockaddr_in *)(& areq.arp_ha);
  sin->sin_family = (sa_family_t )1;
  strncpy((char * __restrict  )(areq.arp_dev), (char const   * __restrict  )"eth0",
          (size_t )15);
  tmp = ioctl(s, 35156UL, (caddr_t )(& areq));
  if (tmp == -1) {
    return (-1);
  }
  memcpy((void * __restrict  )mac, (void const   * __restrict  )(& areq.arp_ha.sa_data),
         *size);
  return (0);
}
}
_Bool get_interface(struct in_addr *addr ) 
{ 
  struct ifreq *ifreq ;
  struct ifconf ifconf ;
  char buf___0[512] ;
  unsigned int i ;
  unsigned int nb ;
  int fd ;
  _Bool valid ;
  int tmp ;

  {
  valid = (_Bool)0;
  fd = socket(2, 2, 0);
  ifconf.ifc_len = (int )sizeof(buf___0);
  ifconf.ifc_ifcu.ifcu_buf = buf___0;
  tmp = ioctl(fd, 35090UL, & ifconf);
  if (tmp != 0) {
    return ((_Bool)0);
  }
  ifreq = ifconf.ifc_ifcu.ifcu_req;
  nb = (unsigned int )((unsigned long )ifconf.ifc_len / sizeof(struct ifreq ));
  i = 0U;
  while (i < nb) {
    ioctl(fd, 35091UL, ifreq + i);
    if ((int )(ifreq + i)->ifr_ifru.ifru_flags & 1) {
      if (! ((int )(ifreq + i)->ifr_ifru.ifru_flags & 8)) {
        if ((int )(ifreq + i)->ifr_ifru.ifru_flags & 4096) {
          *addr = ((struct sockaddr_in *)(& (ifreq + i)->ifr_ifru.ifru_addr))->sin_addr;
          valid = (_Bool)1;
          break;
        }
      }
    }
    i ++;
  }
  close(fd);
  return (valid);
}
}
in_addr_t get_localhost(char **name ) 
{ 
  char szBuffer[256UL * sizeof(struct ifreq )] ;
  struct ifconf ifConf ;
  struct ifreq ifReq ;
  int nResult ;
  unsigned long i ;
  int LocalSock ;
  struct sockaddr_in LocalAddr ;
  int j ;
  void *tmp ;
  struct ifreq *pifReq ;
  __uint32_t tmp___0 ;

  {
  j = 0;
  if (name) {
    tmp = malloc((size_t )256);
    *name = (char *)tmp;
    gethostname(*name, (size_t )256);
  }
  memset((void *)(& ifConf), 0, sizeof(ifConf));
  memset((void *)(& ifReq), 0, sizeof(ifReq));
  memset((void *)(szBuffer), 0, sizeof(szBuffer));
  memset((void *)(& LocalAddr), 0, sizeof(LocalAddr));
  LocalSock = socket(2, 2, 17);
  if (LocalSock == -1) {
    return ((in_addr_t )0);
  }
  ifConf.ifc_len = (int )sizeof(szBuffer);
  ifConf.ifc_ifcu.ifcu_buf = szBuffer;
  nResult = ioctl(LocalSock, 35090UL, & ifConf);
  if (nResult < 0) {
    close(LocalSock);
    return ((in_addr_t )0);
  }
  i = 0UL;
  while (1) {
    if (i < (unsigned long )ifConf.ifc_len) {
      if (! (j < 1)) {
        break;
      }
    } else {
      break;
    }
    pifReq = (struct ifreq *)((caddr_t )ifConf.ifc_ifcu.ifcu_req + i);
    i += sizeof(*pifReq);
    memset((void *)(ifReq.ifr_ifrn.ifrn_name), 0, sizeof(ifReq.ifr_ifrn.ifrn_name));
    strncpy((char * __restrict  )(ifReq.ifr_ifrn.ifrn_name), (char const   * __restrict  )(pifReq->ifr_ifrn.ifrn_name),
            sizeof(ifReq.ifr_ifrn.ifrn_name) - 1UL);
    ioctl(LocalSock, 35091UL, & ifReq);
    if ((int )ifReq.ifr_ifru.ifru_flags & 8) {
      goto __Cont;
    } else
    if (! ((int )ifReq.ifr_ifru.ifru_flags & 1)) {
      goto __Cont;
    }
    if ((int )pifReq->ifr_ifru.ifru_addr.sa_family == 2) {
      memcpy((void * __restrict  )(& LocalAddr), (void const   * __restrict  )(& pifReq->ifr_ifru.ifru_addr),
             sizeof(pifReq->ifr_ifru.ifru_addr));
      tmp___0 = __bswap_32((in_addr_t )2130706433);
      if (LocalAddr.sin_addr.s_addr == tmp___0) {
        goto __Cont;
      }
    }
    j ++;
    __Cont: /* CIL Label */ ;
  }
  close(LocalSock);
  return (LocalAddr.sin_addr.s_addr);
}
}
int shutdown_socket(int sd ) 
{ 
  char const   *tmp ;
  int tmp___0 ;

  {
  if (sd <= 0) {
    return (-1);
  }
  shutdown(sd, 2);
  if ((unsigned int )*loglevel___4 >= 2U) {
    tmp = logtime();
    logprint("%s %s:%d closed socket %d\n", tmp, "shutdown_socket", 753, sd);
  }
  tmp___0 = close(sd);
  return (tmp___0);
}
}
int bind_socket(unsigned short *port , int mode ) 
{ 
  int sock ;
  socklen_t len ;
  struct sockaddr_in addr ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;

  {
  len = (socklen_t )sizeof(struct sockaddr );
  sock = socket(2, mode, 0);
  if (sock < 0) {
    tmp = logtime();
    logprint("%s %s:%d cannot create socket %d\n", tmp, "bind_socket", 767, sock);
    return (sock);
  }
  memset((void *)(& addr), 0, sizeof(addr));
  addr.sin_family = (sa_family_t )2;
  addr.sin_addr.s_addr = __bswap_32((in_addr_t )0);
  addr.sin_port = __bswap_16(*port);
  tmp___1 = bind(sock, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& addr)),
                 (socklen_t )sizeof(addr));
  if (tmp___1 < 0) {
    close(sock);
    tmp___0 = logtime();
    logprint("%s %s:%d cannot bind socket %d\n", tmp___0, "bind_socket", 782, sock);
    return (-1);
  }
  if (! *port) {
    getsockname(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& addr)),
                (socklen_t * __restrict  )(& len));
    *port = __bswap_16(addr.sin_port);
  }
  if ((unsigned int )*loglevel___4 >= 2U) {
    tmp___2 = logtime();
    logprint("%s %s:%d socket binding %d on port %d\n", tmp___2, "bind_socket", 791,
             sock, (int )*port);
  }
  return (sock);
}
}
int conn_socket(unsigned short port ) 
{ 
  struct sockaddr_in addr ;
  int sd ;
  int tmp ;
  char const   *tmp___0 ;

  {
  sd = socket(2, 1, 0);
  addr.sin_family = (sa_family_t )2;
  addr.sin_addr.s_addr = __bswap_32((in_addr_t )2130706433);
  addr.sin_port = __bswap_16(port);
  if (sd < 0) {
    close(sd);
    return (-1);
  } else {
    tmp = connect(sd, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& addr)),
                  (socklen_t )sizeof(addr));
    if (tmp < 0) {
      close(sd);
      return (-1);
    }
  }
  if ((unsigned int )*loglevel___4 >= 3U) {
    tmp___0 = logtime();
    logprint("%s %s:%d created socket %d\n", tmp___0, "conn_socket", 814, sd);
  }
  return (sd);
}
}
void touch_memory(u8_t *buf___0 , size_t size ) 
{ 
  u8_t *ptr ;
  long tmp ;

  {
  ptr = buf___0;
  while ((unsigned long )ptr < (unsigned long )(buf___0 + size)) {
    *ptr = (u8_t )0;
    tmp = sysconf(30);
    ptr += tmp;
  }
  return;
}
}
char *GetTempPath(u16_t size , char *path ) 
{ 
  size_t tmp ;

  {
  strncpy((char * __restrict  )path, (char const   * __restrict  )"/tmp", (size_t )size);
  tmp = strlen((char const   *)path);
  if (! tmp) {
    strncpy((char * __restrict  )path, (char const   * __restrict  )"/var/tmp", (size_t )size);
  }
  *(path + ((int )size - 1)) = (char )'\000';
  return (path);
}
}
char *next_param(char *src , char c ) ;
static char *str  =    (char *)((void *)0);
char *next_param(char *src , char c ) 
{ 
  char *ptr ;
  char *ret ;
  char *tmp ;

  {
  if (src) {
    str = src;
  }
  if (str) {
    ptr = strchr((char const   *)str, (int )c);
    if (ptr) {
      ret = str;
      *ptr = (char )'\000';
      str = ptr + 1;
    } else {
      ret = str;
      str = (char *)((void *)0);
    }
  } else {
    ret = str;
    str = (char *)((void *)0);
  }
  if (ret) {
    if (*(ret + 0)) {
      tmp = ret;
    } else {
      tmp = (char *)((void *)0);
    }
  } else {
    tmp = (char *)((void *)0);
  }
  return (tmp);
}
}
u32_t gettime_ms(void) 
{ 
  struct timespec ts ;
  int tmp ;
  struct timeval tv ;

  {
  tmp = clock_gettime(1, & ts);
  if (! tmp) {
    return ((u32_t )(ts.tv_sec * 1000L + ts.tv_nsec / 1000000L));
  }
  gettimeofday((struct timeval * __restrict  )(& tv), (void * __restrict  )((void *)0));
  return ((u32_t )(tv.tv_sec * 1000L + tv.tv_usec / 1000L));
}
}
u64_t gettime_ms64(void) 
{ 
  struct timeval tv ;

  {
  gettimeofday((struct timeval * __restrict  )(& tv), (void * __restrict  )((void *)0));
  return ((u64_t )(tv.tv_sec + 2208988800L) * 1000UL + (u64_t )(tv.tv_usec / 1000L));
}
}
char *strlwr(char *str___0 ) 
{ 
  char *p ;
  int __res ;
  __int32_t const   **tmp___0 ;

  {
  p = str___0;
  while (*p) {
    if (sizeof(*p) > 1UL) {
      __res = tolower((int )*p);
    } else {
      tmp___0 = __ctype_tolower_loc();
      __res = (int )*(*tmp___0 + (int )*p);
    }
    *p = (char )__res;
    p ++;
  }
  return (str___0);
}
}
char *strextract(char *s1 , char *beg , char *end ) 
{ 
  char *p1 ;
  char *p2 ;
  char *res ;
  size_t tmp ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
  p1 = strcasestr((char const   *)s1, (char const   *)beg);
  if (! p1) {
    return ((char *)((void *)0));
  }
  tmp = strlen((char const   *)beg);
  p1 += tmp;
  p2 = strcasestr((char const   *)p1, (char const   *)end);
  if (! p2) {
    tmp___0 = strdup((char const   *)p1);
    return (tmp___0);
  }
  tmp___1 = malloc((size_t )((p2 - p1) + 1L));
  res = (char *)tmp___1;
  memcpy((void * __restrict  )res, (void const   * __restrict  )p1, (size_t )(p2 - p1));
  *(res + (p2 - p1)) = (char )'\000';
  return (res);
}
}
static char dig[37]  = 
  {      (char )'0',      (char )'1',      (char )'2',      (char )'3', 
        (char )'4',      (char )'5',      (char )'6',      (char )'7', 
        (char )'8',      (char )'9',      (char )'a',      (char )'b', 
        (char )'c',      (char )'d',      (char )'e',      (char )'f', 
        (char )'g',      (char )'h',      (char )'i',      (char )'j', 
        (char )'k',      (char )'l',      (char )'m',      (char )'n', 
        (char )'o',      (char )'p',      (char )'q',      (char )'r', 
        (char )'s',      (char )'t',      (char )'u',      (char )'v', 
        (char )'w',      (char )'x',      (char )'y',      (char )'z', 
        (char )'\000'};
char *itoa(int value , char *str___0 , int radix ) 
{ 
  int n ;
  int neg ;
  unsigned int v ;
  char *p ;
  char *q ;
  char c ;
  int tmp ;
  int tmp___0 ;

  {
  n = 0;
  neg = 0;
  if (radix == 10) {
    if (value < 0) {
      value = - value;
      neg = 1;
    }
  }
  v = (unsigned int )value;
  while (1) {
    tmp = n;
    n ++;
    *(str___0 + tmp) = dig[v % (unsigned int )radix];
    v /= (unsigned int )radix;
    if (! v) {
      break;
    }
  }
  if (neg) {
    tmp___0 = n;
    n ++;
    *(str___0 + tmp___0) = (char )'-';
  }
  *(str___0 + n) = (char )'\000';
  p = str___0;
  q = p + (n - 1);
  while ((unsigned long )p < (unsigned long )q) {
    c = *p;
    *p = *q;
    *q = c;
    p ++;
    q --;
  }
  return (str___0);
}
}
u32_t hash32(char *str___0 ) 
{ 
  u32_t hash ;
  s32_t c ;
  char *tmp ;

  {
  hash = (u32_t )5381;
  if (! str___0) {
    return ((u32_t )0);
  }
  while (1) {
    tmp = str___0;
    str___0 ++;
    c = (s32_t )*tmp;
    if (! (c != 0)) {
      break;
    }
    hash = ((hash << 5) + hash) + (u32_t )c;
  }
  return (hash);
}
}
char *ltrim(char *s ) 
{ 
  unsigned short const   **tmp ;

  {
  while (1) {
    tmp = __ctype_b_loc();
    if (! ((int const   )*(*tmp + (int )*s) & 8192)) {
      break;
    }
    s ++;
  }
  return (s);
}
}
char *rtrim(char *s ) 
{ 
  char *back ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;

  {
  tmp = strlen((char const   *)s);
  back = s + tmp;
  while (1) {
    tmp___0 = __ctype_b_loc();
    back --;
    if (! ((int const   )*(*tmp___0 + (int )*back) & 8192)) {
      break;
    }
  }
  *(back + 1) = (char )'\000';
  return (s);
}
}
char *trim(char *s ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  tmp = ltrim(s);
  tmp___0 = rtrim(tmp);
  return (tmp___0);
}
}
_Bool http_parse(int sock , char *method , char *resource , char *proto , key_data_t *rkd ,
                 char **body , int *len ) 
{ 
  char line[512] ;
  char *dp ;
  unsigned int j ;
  int i ;
  int timeout ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  long tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int size ;
  void *tmp___13 ;
  int bytes ;
  ssize_t tmp___14 ;
  char const   *tmp___15 ;

  {
  timeout = 100;
  (rkd + 0)->key = (char *)((void *)0);
  i = read_line(sock, line, (int )sizeof(line), timeout);
  if (i <= 0) {
    if (i < 0) {
      tmp = logtime();
      logprint("%s %s:%d cannot read method\n", tmp, "http_parse", 1130, (void *)0);
    }
    return ((_Bool)0);
  }
  tmp___1 = sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%s",
                   method);
  if (! tmp___1) {
    tmp___0 = logtime();
    logprint("%s %s:%d missing method\n", tmp___0, "http_parse", 1136, (void *)0);
    return ((_Bool)0);
  }
  if (resource) {
    sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%*s%s",
           resource);
  }
  if (proto) {
    sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%*s%*s%s",
           proto);
  }
  tmp___2 = 0;
  *len = tmp___2;
  i = tmp___2;
  while (1) {
    tmp___12 = read_line(sock, line, (int )sizeof(line), timeout);
    if (! (tmp___12 > 0)) {
      break;
    }
    if ((unsigned int )*loglevel___4 >= 3U) {
      tmp___3 = logtime();
      logprint("%s %s:%d sock: %u, received %s\n", tmp___3, "http_parse", 1147, sock,
               line);
    }
    if (i) {
      if ((rkd + i)->key) {
        if ((int )line[0] == 32) {
          goto _L;
        } else
        if ((int )line[0] == 9) {
          _L: /* CIL Label */ 
          j = 0U;
          while (1) {
            tmp___4 = strlen((char const   *)(line));
            if (! ((size_t )j < tmp___4)) {
              break;
            }
            if ((int )line[j] != 32) {
              if ((int )line[j] != 9) {
                break;
              }
            }
            j ++;
          }
          tmp___5 = strlen((char const   *)(rkd + i)->data);
          tmp___6 = strlen((char const   *)(line + j));
          tmp___7 = realloc((void *)(rkd + i)->data, (tmp___5 + tmp___6) + 1UL);
          (rkd + i)->data = (char *)tmp___7;
          strcat((char * __restrict  )(rkd + i)->data, (char const   * __restrict  )(line + j));
          continue;
        }
      }
    }
    dp = strstr((char const   *)(line), ":");
    if (! dp) {
      tmp___8 = logtime();
      logprint("%s %s:%d Request failed, bad header\n", tmp___8, "http_parse", 1160,
               (void *)0);
      kd_free(rkd);
      return ((_Bool)0);
    }
    *dp = (char)0;
    (rkd + i)->key = strdup((char const   *)(line));
    tmp___9 = ltrim(dp + 1);
    (rkd + i)->data = strdup((char const   *)tmp___9);
    tmp___11 = strcasecmp((char const   *)(rkd + i)->key, "Content-Length");
    if (! tmp___11) {
      tmp___10 = atol((char const   *)(rkd + i)->data);
      *len = (int )tmp___10;
    }
    i ++;
    (rkd + i)->key = (char *)((void *)0);
  }
  if (*len) {
    size = 0;
    tmp___13 = malloc((size_t )(*len + 1));
    *body = (char *)tmp___13;
    while (1) {
      if (*body) {
        if (! (size < *len)) {
          break;
        }
      } else {
        break;
      }
      tmp___14 = recv(sock, (void *)(*body + size), (size_t )(*len - size), 0);
      bytes = (int )tmp___14;
      if (bytes <= 0) {
        break;
      }
      size += bytes;
    }
    *(*body + *len) = (char )'\000';
    if (! *body) {
      tmp___15 = logtime();
      logprint("%s %s:%d content length receive error %d %d\n", tmp___15, "http_parse",
               1188, *len, size);
    } else
    if (size != *len) {
      tmp___15 = logtime();
      logprint("%s %s:%d content length receive error %d %d\n", tmp___15, "http_parse",
               1188, *len, size);
    }
  }
  return ((_Bool)1);
}
}
int read_line(int fd , char *line , int maxlen , int timeout ) 
{ 
  int i ;
  int rval ;
  int count___0 ;
  struct pollfd pfds ;
  char ch ;
  ssize_t tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;

  {
  count___0 = 0;
  *line = (char)0;
  pfds.fd = fd;
  pfds.events = (short)1;
  i = 0;
  while (i < maxlen) {
    tmp___0 = poll(& pfds, (nfds_t )1, timeout);
    if (tmp___0) {
      tmp = recv(fd, (void *)(& ch), (size_t )1, 0);
      rval = (int )tmp;
    } else {
      return (0);
    }
    if (rval == -1) {
      tmp___1 = __errno_location();
      if (*tmp___1 == 11) {
        return (0);
      }
      tmp___2 = __errno_location();
      tmp___3 = strerror(*tmp___2);
      tmp___4 = logtime();
      logprint("%s %s:%d fd: %d read error: %s\n", tmp___4, "read_line", 1214, fd,
               tmp___3);
      return (-1);
    }
    if (rval == 0) {
      if ((unsigned int )*loglevel___4 >= 2U) {
        tmp___5 = logtime();
        logprint("%s %s:%d disconnected on the other end %u\n", tmp___5, "read_line",
                 1219, fd);
      }
      return (0);
    }
    if ((int )ch == 10) {
      *line = (char)0;
      return (count___0);
    }
    if ((int )ch == 13) {
      goto __Cont;
    }
    tmp___6 = line;
    line ++;
    *tmp___6 = ch;
    count___0 ++;
    if (count___0 >= maxlen - 1) {
      break;
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  *line = (char)0;
  return (count___0);
}
}
char *http_send(int sock , char *method , key_data_t *rkd ) 
{ 
  unsigned int sent ;
  unsigned int len ;
  char *resp ;
  char *tmp ;
  char *data ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  char const   *tmp___5 ;

  {
  tmp = kd_dump(rkd);
  resp = tmp;
  tmp___0 = strlen((char const   *)method);
  tmp___1 = strlen((char const   *)resp);
  tmp___2 = malloc((((tmp___0 + 2UL) + tmp___1) + 2UL) + 1UL);
  data = (char *)tmp___2;
  tmp___3 = sprintf((char * __restrict  )data, (char const   * __restrict  )"%s\r\n%s\r\n",
                    method, resp);
  len = (unsigned int )tmp___3;
  if (resp) {
    free((void *)resp);
    resp = (char *)((void *)0);
  }
  tmp___4 = send(sock, (void const   *)data, (size_t )len, 0);
  sent = (unsigned int )tmp___4;
  if (sent != len) {
    tmp___5 = logtime();
    logprint("%s %s:%d HTTP send() error:%s %u (strlen=%u)\n", tmp___5, "http_send",
             1253, data, sent, len);
    if (data) {
      free((void *)data);
      data = (char *)((void *)0);
    }
  }
  return (data);
}
}
char *kd_lookup(key_data_t *kd , char *key ) 
{ 
  int i ;
  int tmp ;

  {
  i = 0;
  while (1) {
    if (kd) {
      if (! (kd + i)->key) {
        break;
      }
    } else {
      break;
    }
    tmp = strcasecmp((char const   *)(kd + i)->key, (char const   *)key);
    if (! tmp) {
      return ((kd + i)->data);
    }
    i ++;
  }
  return ((char *)((void *)0));
}
}
_Bool kd_add(key_data_t *kd , char *key , char *data ) 
{ 
  int i ;

  {
  i = 0;
  while (1) {
    if (kd) {
      if (! (kd + i)->key) {
        break;
      }
    } else {
      break;
    }
    i ++;
  }
  (kd + i)->key = strdup((char const   *)key);
  (kd + i)->data = strdup((char const   *)data);
  (kd + (i + 1))->key = (char *)((void *)0);
  return ((_Bool)1);
}
}
_Bool kd_vadd(key_data_t *kd , char *key , char *fmt  , ...) 
{ 
  int i ;
  va_list___0 args ;
  int tmp ;

  {
  i = 0;
  while (1) {
    if (kd) {
      if (! (kd + i)->key) {
        break;
      }
    } else {
      break;
    }
    i ++;
  }
  __builtin_va_start(args, fmt);
  tmp = vasprintf((char ** __restrict  )(& (kd + i)->data), (char const   * __restrict  )fmt,
                  args);
  if (tmp) {
    (kd + i)->key = strdup((char const   *)key);
    (kd + (i + 1))->key = (char *)((void *)0);
    __builtin_va_end(args);
    return ((_Bool)1);
  }
  __builtin_va_end(args);
  return ((_Bool)0);
}
}
void kd_free(key_data_t *kd ) 
{ 
  int i ;

  {
  i = 0;
  while (1) {
    if (kd) {
      if (! (kd + i)->key) {
        break;
      }
    } else {
      break;
    }
    free((void *)(kd + i)->key);
    if ((kd + i)->data) {
      free((void *)(kd + i)->data);
    }
    i ++;
  }
  (kd + 0)->key = (char *)((void *)0);
  return;
}
}
char *kd_dump(key_data_t *kd ) 
{ 
  int i ;
  int pos___0 ;
  int size ;
  char *str___0 ;
  char *tmp ;
  char *buf___0 ;
  int len ;
  void *p ;
  void *tmp___0 ;

  {
  i = 0;
  pos___0 = 0;
  size = 0;
  str___0 = (char *)((void *)0);
  if (! kd) {
    tmp = strdup("\r\n");
    return (tmp);
  } else
  if (! (kd + 0)->key) {
    tmp = strdup("\r\n");
    return (tmp);
  }
  while (1) {
    if (kd) {
      if (! (kd + i)->key) {
        break;
      }
    } else {
      break;
    }
    len = asprintf((char ** __restrict  )(& buf___0), (char const   * __restrict  )"%s: %s\r\n",
                   (kd + i)->key, (kd + i)->data);
    while (pos___0 + len >= size) {
      tmp___0 = realloc((void *)str___0, (size_t )(size + 1024));
      p = tmp___0;
      size += 1024;
      if (! p) {
        free((void *)str___0);
        return ((char *)((void *)0));
      }
      str___0 = (char *)p;
    }
    memcpy((void * __restrict  )(str___0 + pos___0), (void const   * __restrict  )buf___0,
           (size_t )len);
    pos___0 += len;
    free((void *)buf___0);
    i ++;
  }
  *(str___0 + pos___0) = (char )'\000';
  return (str___0);
}
}
IXML_Node *XMLAddNode(IXML_Document *doc , IXML_Node *parent , char *name , char *fmt 
                      , ...) 
{ 
  IXML_Node *node ;
  IXML_Node *elm ;
  char buf___0[256] ;
  va_list___0 args ;
  IXML_Element *tmp ;

  {
  tmp = ixmlDocument_createElement(doc, (char const   *)name);
  elm = (IXML_Node *)tmp;
  if (parent) {
    ixmlNode_appendChild(parent, elm);
  } else {
    ixmlNode_appendChild((IXML_Node *)doc, elm);
  }
  if (fmt) {
    __builtin_va_start(args, fmt);
    vsprintf((char * __restrict  )(buf___0), (char const   * __restrict  )fmt, args);
    node = ixmlDocument_createTextNode(doc, (char const   *)(buf___0));
    ixmlNode_appendChild(elm, node);
    __builtin_va_end(args);
  }
  return (elm);
}
}
IXML_Node *XMLUpdateNode(IXML_Document *doc , IXML_Node *parent , _Bool refresh ,
                         char *name , char *fmt  , ...) 
{ 
  char buf___0[256] ;
  va_list___0 args ;
  IXML_Node *node ;
  IXML_Element *tmp ;

  {
  tmp = ixmlDocument_getElementById((IXML_Document *)parent, (char const   *)name);
  node = (IXML_Node *)tmp;
  __builtin_va_start(args, fmt);
  vsprintf((char * __restrict  )(buf___0), (char const   * __restrict  )fmt, args);
  if (! node) {
    XMLAddNode(doc, parent, name, buf___0);
  } else
  if (refresh) {
    node = ixmlNode_getFirstChild(node);
    ixmlNode_setNodeValue(node, (char const   *)(buf___0));
  }
  __builtin_va_end(args);
  return (node);
}
}
char *XMLGetFirstDocumentItem(IXML_Document *doc , char const   *item , _Bool strict ) 
{ 
  IXML_NodeList *nodeList ;
  IXML_Node *textNode ;
  IXML_Node *tmpNode ;
  char *ret ;
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  unsigned long tmp___3 ;
  char const   *tmp___4 ;

  {
  nodeList = (IXML_NodeList *)((void *)0);
  textNode = (IXML_Node *)((void *)0);
  tmpNode = (IXML_Node *)((void *)0);
  ret = (char *)((void *)0);
  nodeList = ixmlDocument_getElementsByTagName(doc, (char const   *)((char *)item));
  i = 0;
  while (1) {
    if (nodeList) {
      tmp___3 = ixmlNodeList_length(nodeList);
      if (! (i < (int )tmp___3)) {
        break;
      }
    } else {
      break;
    }
    tmpNode = ixmlNodeList_item(nodeList, (unsigned long )i);
    if (tmpNode) {
      textNode = ixmlNode_getFirstChild(tmpNode);
      if (textNode) {
        tmp = ixmlNode_getNodeValue(textNode);
        ret = (char *)tmp;
        if (ret) {
          ret = strdup((char const   *)ret);
          break;
        } else
        if ((unsigned int )*loglevel___4 >= 1U) {
          tmp___0 = logtime();
          logprint("%s %s:%d ixmlNode_getNodeValue returned NULL\n", tmp___0, "XMLGetFirstDocumentItem",
                   1435, (void *)0);
        }
      } else
      if ((unsigned int )*loglevel___4 >= 1U) {
        tmp___1 = logtime();
        logprint("%s %s:%d (BUG) ixmlNode_getFirstChild(tmpNode) returned NULL\n",
                 tmp___1, "XMLGetFirstDocumentItem", 1438, (void *)0);
      }
    } else
    if ((unsigned int )*loglevel___4 >= 1U) {
      tmp___2 = logtime();
      logprint("%s %s:%d ixmlNodeList_item(nodeList, %d) returned NULL\n", tmp___2,
               "XMLGetFirstDocumentItem", 1441, i, (void *)0);
    }
    if (strict) {
      break;
    }
    i ++;
  }
  if (nodeList) {
    ixmlNodeList_free(nodeList);
  } else
  if ((unsigned int )*loglevel___4 >= 4U) {
    tmp___4 = logtime();
    logprint("%s %s:%d Error finding %s in XML Node\n", tmp___4, "XMLGetFirstDocumentItem",
             1450, item);
  }
  return (ret);
}
}
_Bool XMLMatchDocumentItem(IXML_Document *doc , char const   *item , char const   *s ,
                           _Bool match ) 
{ 
  IXML_NodeList *nodeList ;
  IXML_Node *textNode ;
  IXML_Node *tmpNode ;
  int i ;
  _Bool ret ;
  char const   *value ;
  int tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;

  {
  nodeList = (IXML_NodeList *)((void *)0);
  textNode = (IXML_Node *)((void *)0);
  tmpNode = (IXML_Node *)((void *)0);
  ret = (_Bool)0;
  nodeList = ixmlDocument_getElementsByTagName(doc, (char const   *)((char *)item));
  i = 0;
  while (1) {
    if (nodeList) {
      tmp___1 = ixmlNodeList_length(nodeList);
      if (! (i < (int )tmp___1)) {
        break;
      }
    } else {
      break;
    }
    tmpNode = ixmlNodeList_item(nodeList, (unsigned long )i);
    if (! tmpNode) {
      goto __Cont;
    }
    textNode = ixmlNode_getFirstChild(tmpNode);
    if (! textNode) {
      goto __Cont;
    }
    value = ixmlNode_getNodeValue(textNode);
    if (match) {
      tmp = strcmp(value, s);
      if (tmp) {
        goto _L;
      } else {
        ret = (_Bool)1;
        break;
      }
    } else
    _L: /* CIL Label */ 
    if (! match) {
      if (value) {
        tmp___0 = strcasestr(value, s);
        if (tmp___0) {
          ret = (_Bool)1;
          break;
        }
      }
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  if (nodeList) {
    ixmlNodeList_free(nodeList);
  }
  return (ret);
}
}
char *XMLGetFirstElementItem(IXML_Element *element , char const   *item ) 
{ 
  IXML_NodeList *nodeList ;
  IXML_Node *textNode ;
  IXML_Node *tmpNode ;
  char *ret ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  nodeList = (IXML_NodeList *)((void *)0);
  textNode = (IXML_Node *)((void *)0);
  tmpNode = (IXML_Node *)((void *)0);
  ret = (char *)((void *)0);
  nodeList = ixmlElement_getElementsByTagName(element, (char const   *)((char *)item));
  if ((unsigned long )nodeList == (unsigned long )((void *)0)) {
    if ((unsigned int )*loglevel___4 >= 1U) {
      tmp = logtime();
      logprint("%s %s:%d Error finding %s in XML Node\n", tmp, "XMLGetFirstElementItem",
               1497, item);
    }
    return ((char *)((void *)0));
  }
  tmpNode = ixmlNodeList_item(nodeList, 0UL);
  if (! tmpNode) {
    if ((unsigned int )*loglevel___4 >= 1U) {
      tmp___0 = logtime();
      logprint("%s %s:%d Error finding %s value in XML Node\n", tmp___0, "XMLGetFirstElementItem",
               1502, item);
    }
    ixmlNodeList_free(nodeList);
    return ((char *)((void *)0));
  }
  textNode = ixmlNode_getFirstChild(tmpNode);
  tmp___1 = ixmlNode_getNodeValue(textNode);
  ret = strdup(tmp___1);
  if (! ret) {
    tmp___2 = logtime();
    logprint("%s %s:%d Error allocating memory for %s in XML Node\n", tmp___2, "XMLGetFirstElementItem",
             1509, item);
    ixmlNodeList_free(nodeList);
    return ((char *)((void *)0));
  }
  ixmlNodeList_free(nodeList);
  return (ret);
}
}
int XMLAddAttribute(IXML_Document *doc , IXML_Node *parent , char *name , char *fmt 
                    , ...) 
{ 
  char buf___0[256] ;
  int ret ;
  va_list___0 args ;

  {
  __builtin_va_start(args, fmt);
  vsnprintf((char * __restrict  )(buf___0), (size_t )256, (char const   * __restrict  )fmt,
            args);
  ret = ixmlElement_setAttribute((IXML_Element *)parent, (char const   *)name, (char const   *)(buf___0));
  __builtin_va_end(args);
  return (ret);
}
}
char const   *XMLGetLocalName(IXML_Document *doc , int Depth ) 
{ 
  IXML_Node *node ;
  int tmp ;
  char const   *tmp___0 ;

  {
  node = (IXML_Node *)doc;
  while (1) {
    tmp = Depth;
    Depth --;
    if (! tmp) {
      break;
    }
    node = ixmlNode_getFirstChild(node);
    if (! node) {
      return ((char const   *)((void *)0));
    }
  }
  tmp___0 = ixmlNode_getLocalName(node);
  return (tmp___0);
}
}
void free_metadata(struct metadata_s *metadata ) 
{ 


  {
  if (metadata->artist) {
    free((void *)metadata->artist);
    metadata->artist = (char *)((void *)0);
  }
  if (metadata->album) {
    free((void *)metadata->album);
    metadata->album = (char *)((void *)0);
  }
  if (metadata->title) {
    free((void *)metadata->title);
    metadata->title = (char *)((void *)0);
  }
  if (metadata->genre) {
    free((void *)metadata->genre);
    metadata->genre = (char *)((void *)0);
  }
  if (metadata->path) {
    free((void *)metadata->path);
    metadata->path = (char *)((void *)0);
  }
  if (metadata->artwork) {
    free((void *)metadata->artwork);
    metadata->artwork = (char *)((void *)0);
  }
  if (metadata->remote_title) {
    free((void *)metadata->remote_title);
    metadata->remote_title = (char *)((void *)0);
  }
  return;
}
}
void dup_metadata(struct metadata_s *dst , struct metadata_s *src ) 
{ 


  {
  free_metadata(dst);
  if (src->artist) {
    dst->artist = strdup((char const   *)src->artist);
  }
  if (src->album) {
    dst->album = strdup((char const   *)src->album);
  }
  if (src->title) {
    dst->title = strdup((char const   *)src->title);
  }
  if (src->genre) {
    dst->genre = strdup((char const   *)src->genre);
  }
  if (src->path) {
    dst->path = strdup((char const   *)src->path);
  }
  if (src->artwork) {
    dst->artwork = strdup((char const   *)src->artwork);
  }
  if (src->remote_title) {
    dst->remote_title = strdup((char const   *)src->remote_title);
  }
  dst->duration = src->duration;
  dst->track = src->track;
  dst->track_hash = src->track_hash;
  return;
}
}
int _fprintf(FILE *file  , ...) 
{ 
  va_list___0 args ;
  char *fmt ;
  int n ;
  char *tmp ;

  {
  __builtin_va_start(args, file);
  tmp = __builtin_va_arg(args, char *);
  fmt = tmp;
  n = vfprintf((FILE * __restrict  )file, (char const   * __restrict  )fmt, args);
  __builtin_va_end(args);
  return (n);
}
}
#pragma merger("0","/tmp/cil-DaUwXH6r.i","-Wall,-fPIC,-ggdb,-O2,-m64,-fdata-sections,-ffunction-sections")
extern int fflush(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) size_t strftime(char * __restrict  __s , size_t __maxsize ,
                                                     char const   * __restrict  __format ,
                                                     struct tm  const  * __restrict  __tp ) ;
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
static char buf[100]  ;
char const   *logtime(void) 
{ 
  struct timeval tv ;
  struct tm *tmp ;
  size_t tmp___0 ;

  {
  gettimeofday((struct timeval * __restrict  )(& tv), (void * __restrict  )((void *)0));
  tmp = localtime((time_t const   *)(& tv.tv_sec));
  strftime((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"[%T.",
           (struct tm  const  * __restrict  )tmp);
  tmp___0 = strlen((char const   *)(buf));
  sprintf((char * __restrict  )(buf + tmp___0), (char const   * __restrict  )"%06ld]",
          tv.tv_usec);
  return ((char const   *)(buf));
}
}
void logprint(char const   *fmt  , ...) 
{ 
  va_list___0 args ;

  {
  __builtin_va_start(args, fmt);
  vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )fmt, args);
  __builtin_va_end(args);
  fflush(stderr);
  return;
}
}
log_level debug2level(char *level ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp = strcmp((char const   *)level, "error");
  if (! tmp) {
    return ((log_level )0);
  }
  tmp___0 = strcmp((char const   *)level, "warn");
  if (! tmp___0) {
    return ((log_level )1);
  }
  tmp___1 = strcmp((char const   *)level, "info");
  if (! tmp___1) {
    return ((log_level )2);
  }
  tmp___2 = strcmp((char const   *)level, "debug");
  if (! tmp___2) {
    return ((log_level )3);
  }
  tmp___3 = strcmp((char const   *)level, "sdebug");
  if (! tmp___3) {
    return ((log_level )4);
  }
  return ((log_level )1);
}
}
char *level2debug(log_level level ) 
{ 


  {
  switch ((unsigned int )level) {
  case 0U: 
  return ((char *)"error");
  case 1U: 
  return ((char *)"warn");
  case 2U: 
  return ((char *)"info");
  case 3U: 
  return ((char *)"debug");
  case 4U: 
  return ((char *)"debug");
  default: 
  return ((char *)"warn");
  }
}
}
#pragma merger("0","/tmp/cil-n0HVmqos.i","-Wall,-fPIC,-ggdb,-O2,-m64,-fdata-sections,-ffunction-sections")
int dmap_version(void) ;
char const   *dmap_version_string(void) ;
char const   *dmap_name_from_code(char const   *code ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
static dmap_field const   dmap_fields[268]  = 
  {      {"abal", (DMAP_TYPE )7, (DMAP_TYPE )3, "daap.browsealbumlisting"}, 
        {"abar", (DMAP_TYPE )7, (DMAP_TYPE )3, "daap.browseartistlisting"}, 
        {"abcp", (DMAP_TYPE )7, (DMAP_TYPE )3, "daap.browsecomposerlisting"}, 
        {"abgn", (DMAP_TYPE )7, (DMAP_TYPE )3, "daap.browsegenrelisting"}, 
        {"abpl", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.baseplaylist"}, 
        {"abro", (DMAP_TYPE )7, (DMAP_TYPE )0, "daap.databasebrowse"}, 
        {"adbs", (DMAP_TYPE )7, (DMAP_TYPE )0, "daap.databasesongs"}, 
        {"aeAD", (DMAP_TYPE )7, (DMAP_TYPE )0, "com.apple.itunes.adam-ids-array"}, 
        {"aeAI", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.itms-artistid"}, 
        {"aeCD", (DMAP_TYPE )4, (DMAP_TYPE )0, "com.apple.itunes.flat-chapter-data"}, 
        {"aeCF",
      (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.cloud-flavor-id"}, 
        {"aeCI", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.itms-composerid"}, 
        {"aeCK", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.cloud-library-kind"}, 
        {"aeCM",
      (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.cloud-match-type"}, 
        {"aeCR", (DMAP_TYPE )3, (DMAP_TYPE )0, "com.apple.itunes.content-rating"}, 
        {"aeCS", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.artworkchecksum"}, 
        {"aeCU", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.cloud-user-id"}, 
        {"aeCd", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.cloud-id"}, 
        {"aeDE", (DMAP_TYPE )3, (DMAP_TYPE )0, "com.apple.itunes.longest-content-description"}, 
        {"aeDL",
      (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.drm-downloader-user-id"}, 
        {"aeDP", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.drm-platform-id"}, 
        {"aeDR", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.drm-user-id"}, 
        {"aeDV", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.drm-versions"}, 
        {"aeEN", (DMAP_TYPE )3, (DMAP_TYPE )0, "com.apple.itunes.episode-num-str"}, 
        {"aeES", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.episode-sort"}, 
        {"aeFA", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.drm-family-id"}, 
        {"aeGD", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.gapless-enc-dr"}, 
        {"aeGE", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.gapless-enc-del"}, 
        {"aeGH", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.gapless-heur"}, 
        {"aeGI", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.itms-genreid"}, 
        {"aeGR", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.gapless-resy"}, 
        {"aeGU", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.gapless-dur"}, 
        {"aeGs", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.can-be-genius-seed"}, 
        {"aeHC",
      (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.has-chapter-data"}, 
        {"aeHD", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.is-hd-video"}, 
        {"aeHV", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.has-video"}, 
        {"aeK1", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.drm-key1-id"}, 
        {"aeK2", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.drm-key2-id"}, 
        {"aeMC", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.playlist-contains-media-type-count"}, 
        {"aeMK",
      (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.mediakind"}, 
        {"aeMX", (DMAP_TYPE )3, (DMAP_TYPE )0, "com.apple.itunes.movie-info-xml"}, 
        {"aeMk", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.extended-media-kind"}, 
        {"aeND",
      (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.non-drm-user-id"}, 
        {"aeNN", (DMAP_TYPE )3, (DMAP_TYPE )0, "com.apple.itunes.network-name"}, 
        {"aeNV", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.norm-volume"}, 
        {"aePC", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.is-podcast"}, 
        {"aePI", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.itms-playlistid"}, 
        {"aePP", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.is-podcast-playlist"}, 
        {"aePS",
      (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.special-playlist"}, 
        {"aeRD", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.rental-duration"}, 
        {"aeRP", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.rental-pb-start"}, 
        {"aeRS", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.rental-start"}, 
        {"aeRU", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.rental-pb-duration"}, 
        {"aeRf",
      (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.is-featured"}, 
        {"aeSE", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.store-pers-id"}, 
        {"aeSF", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.itms-storefrontid"}, 
        {"aeSG",
      (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.saved-genius"}, 
        {"aeSI", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.itms-songid"}, 
        {"aeSN", (DMAP_TYPE )3, (DMAP_TYPE )0, "com.apple.itunes.series-name"}, 
        {"aeSP", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.smart-playlist"}, 
        {"aeSU", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.season-num"}, 
        {"aeSV", (DMAP_TYPE )6, (DMAP_TYPE )0, "com.apple.itunes.music-sharing-version"}, 
        {"aeXD",
      (DMAP_TYPE )3, (DMAP_TYPE )0, "com.apple.itunes.xid"}, 
        {"aecp", (DMAP_TYPE )3, (DMAP_TYPE )0, "com.apple.itunes.collection-description"}, 
        {"aels",
      (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.liked-state"}, 
        {"aemi", (DMAP_TYPE )7, (DMAP_TYPE )0, "com.apple.itunes.media-kind-listing-item"}, 
        {"aeml",
      (DMAP_TYPE )7, (DMAP_TYPE )0, "com.apple.itunes.media-kind-listing"}, 
        {"agac", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.groupalbumcount"}, 
        {"agma", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.groupmatchedqueryalbumcount"}, 
        {"agmi", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.groupmatchedqueryitemcount"}, 
        {"agrp", (DMAP_TYPE )3, (DMAP_TYPE )0, "daap.songgrouping"}, 
        {"ajAE", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.store.ams-episode-type"}, 
        {"ajAS",
      (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.store.ams-episode-sort-order"}, 
        {"ajAT",
      (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.store.ams-show-type"}, 
        {"ajAV", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.store.is-ams-video"}, 
        {"ajal",
      (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.store.album-liked-state"}, 
        {"ajcA", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.store.show-composer-as-artist"}, 
        {"ajca",
      (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.store.show-composer-as-artist"}, 
        {"ajuw",
      (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.store.use-work-name-as-display-name"}, 
        {"amvc",
      (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songmovementcount"}, 
        {"amvm", (DMAP_TYPE )3, (DMAP_TYPE )0, "daap.songmovementname"}, 
        {"amvn", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songmovementnumber"}, 
        {"aply", (DMAP_TYPE )7, (DMAP_TYPE )0, "daap.databaseplaylists"}, 
        {"aprm", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.playlistrepeatmode"}, 
        {"apro", (DMAP_TYPE )6, (DMAP_TYPE )0, "daap.protocolversion"}, 
        {"apsm", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.playlistshufflemode"}, 
        {"apso", (DMAP_TYPE )7, (DMAP_TYPE )0, "daap.playlistsongs"}, 
        {"arif", (DMAP_TYPE )7, (DMAP_TYPE )0, "daap.resolveinfo"}, 
        {"arsv", (DMAP_TYPE )7, (DMAP_TYPE )0, "daap.resolve"}, 
        {"asaa", (DMAP_TYPE )3, (DMAP_TYPE )0, "daap.songalbumartist"}, 
        {"asac", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songartworkcount"}, 
        {"asai", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songalbumid"}, 
        {"asal", (DMAP_TYPE )3, (DMAP_TYPE )0, "daap.songalbum"}, 
        {"asar", (DMAP_TYPE )3, (DMAP_TYPE )0, "daap.songartist"}, 
        {"asas", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songalbumuserratingstatus"}, 
        {"asbk", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.bookmarkable"}, 
        {"asbo", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songbookmark"}, 
        {"asbr", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songbitrate"}, 
        {"asbt", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songbeatsperminute"}, 
        {"ascd", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songcodectype"}, 
        {"ascm", (DMAP_TYPE )3, (DMAP_TYPE )0, "daap.songcomment"}, 
        {"ascn", (DMAP_TYPE )3, (DMAP_TYPE )0, "daap.songcontentdescription"}, 
        {"asco", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songcompilation"}, 
        {"ascp", (DMAP_TYPE )3, (DMAP_TYPE )0, "daap.songcomposer"}, 
        {"ascr", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songcontentrating"}, 
        {"ascs", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songcodecsubtype"}, 
        {"asct", (DMAP_TYPE )3, (DMAP_TYPE )0, "daap.songcategory"}, 
        {"asda", (DMAP_TYPE )5, (DMAP_TYPE )0, "daap.songdateadded"}, 
        {"asdb", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songdisabled"}, 
        {"asdc", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songdisccount"}, 
        {"asdk", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songdatakind"}, 
        {"asdm", (DMAP_TYPE )5, (DMAP_TYPE )0, "daap.songdatemodified"}, 
        {"asdn", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songdiscnumber"}, 
        {"asdp", (DMAP_TYPE )5, (DMAP_TYPE )0, "daap.songdatepurchased"}, 
        {"asdr", (DMAP_TYPE )5, (DMAP_TYPE )0, "daap.songdatereleased"}, 
        {"asdt", (DMAP_TYPE )3, (DMAP_TYPE )0, "daap.songdescription"}, 
        {"ased", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songextradata"}, 
        {"aseq", (DMAP_TYPE )3, (DMAP_TYPE )0, "daap.songeqpreset"}, 
        {"ases", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songexcludefromshuffle"}, 
        {"asfm", (DMAP_TYPE )3, (DMAP_TYPE )0, "daap.songformat"}, 
        {"asgn", (DMAP_TYPE )3, (DMAP_TYPE )0, "daap.songgenre"}, 
        {"asgp", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songgapless"}, 
        {"asgr", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.supportsgroups"}, 
        {"ashp", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songhasbeenplayed"}, 
        {"askd", (DMAP_TYPE )5, (DMAP_TYPE )0, "daap.songlastskipdate"}, 
        {"askp", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songuserskipcount"}, 
        {"asky", (DMAP_TYPE )3, (DMAP_TYPE )0, "daap.songkeywords"}, 
        {"aslc", (DMAP_TYPE )3, (DMAP_TYPE )0, "daap.songlongcontentdescription"}, 
        {"aslr", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songalbumuserrating"}, 
        {"asls", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songlongsize"}, 
        {"aspc", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songuserplaycount"}, 
        {"aspl", (DMAP_TYPE )5, (DMAP_TYPE )0, "daap.songdateplayed"}, 
        {"aspu", (DMAP_TYPE )3, (DMAP_TYPE )0, "daap.songpodcasturl"}, 
        {"asri", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songartistid"}, 
        {"asrs", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songuserratingstatus"}, 
        {"asrv", (DMAP_TYPE )2, (DMAP_TYPE )0, "daap.songrelativevolume"}, 
        {"assa", (DMAP_TYPE )3, (DMAP_TYPE )0, "daap.sortartist"}, 
        {"assc", (DMAP_TYPE )3, (DMAP_TYPE )0, "daap.sortcomposer"}, 
        {"assl", (DMAP_TYPE )3, (DMAP_TYPE )0, "daap.sortalbumartist"}, 
        {"assn", (DMAP_TYPE )3, (DMAP_TYPE )0, "daap.sortname"}, 
        {"assp", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songstoptime"}, 
        {"assr", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songsamplerate"}, 
        {"asss", (DMAP_TYPE )3, (DMAP_TYPE )0, "daap.sortseriesname"}, 
        {"asst", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songstarttime"}, 
        {"assu", (DMAP_TYPE )3, (DMAP_TYPE )0, "daap.sortalbum"}, 
        {"assz", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songsize"}, 
        {"astc", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songtrackcount"}, 
        {"astm", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songtime"}, 
        {"astn", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songtracknumber"}, 
        {"asul", (DMAP_TYPE )3, (DMAP_TYPE )0, "daap.songdataurl"}, 
        {"asur", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songuserrating"}, 
        {"asvc", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songprimaryvideocodec"}, 
        {"asyr", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.songyear"}, 
        {"ated", (DMAP_TYPE )1, (DMAP_TYPE )0, "daap.supportsextradata"}, 
        {"avdb", (DMAP_TYPE )7, (DMAP_TYPE )0, "daap.serverdatabases"}, 
        {"awrk", (DMAP_TYPE )3, (DMAP_TYPE )0, "daap.songwork"}, 
        {"caar", (DMAP_TYPE )1, (DMAP_TYPE )0, "dacp.availablerepeatstates"}, 
        {"caas", (DMAP_TYPE )1, (DMAP_TYPE )0, "dacp.availableshufflestates"}, 
        {"caci", (DMAP_TYPE )7, (DMAP_TYPE )0, "caci"}, 
        {"cafe", (DMAP_TYPE )1, (DMAP_TYPE )0, "dacp.fullscreenenabled"}, 
        {"cafs", (DMAP_TYPE )1, (DMAP_TYPE )0, "dacp.fullscreen"}, 
        {"caia", (DMAP_TYPE )1, (DMAP_TYPE )0, "dacp.isactive"}, 
        {"cana", (DMAP_TYPE )3, (DMAP_TYPE )0, "dacp.nowplayingartist"}, 
        {"cang", (DMAP_TYPE )3, (DMAP_TYPE )0, "dacp.nowplayinggenre"}, 
        {"canl", (DMAP_TYPE )3, (DMAP_TYPE )0, "dacp.nowplayingalbum"}, 
        {"cann", (DMAP_TYPE )3, (DMAP_TYPE )0, "dacp.nowplayingname"}, 
        {"canp", (DMAP_TYPE )1, (DMAP_TYPE )0, "dacp.nowplayingids"}, 
        {"cant", (DMAP_TYPE )1, (DMAP_TYPE )0, "dacp.nowplayingtime"}, 
        {"capr", (DMAP_TYPE )6, (DMAP_TYPE )0, "dacp.protocolversion"}, 
        {"caps", (DMAP_TYPE )1, (DMAP_TYPE )0, "dacp.playerstate"}, 
        {"carp", (DMAP_TYPE )1, (DMAP_TYPE )0, "dacp.repeatstate"}, 
        {"cash", (DMAP_TYPE )1, (DMAP_TYPE )0, "dacp.shufflestate"}, 
        {"casp", (DMAP_TYPE )7, (DMAP_TYPE )0, "dacp.speakers"}, 
        {"cast", (DMAP_TYPE )1, (DMAP_TYPE )0, "dacp.songtime"}, 
        {"cavc", (DMAP_TYPE )1, (DMAP_TYPE )0, "dacp.volumecontrollable"}, 
        {"cave", (DMAP_TYPE )1, (DMAP_TYPE )0, "dacp.visualizerenabled"}, 
        {"cavs", (DMAP_TYPE )1, (DMAP_TYPE )0, "dacp.visualizer"}, 
        {"ceJC", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.jukebox-client-vote"}, 
        {"ceJI",
      (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.jukebox-current"}, 
        {"ceJS", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.jukebox-score"}, 
        {"ceJV", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.jukebox-vote"}, 
        {"ceQR", (DMAP_TYPE )7, (DMAP_TYPE )0, "com.apple.itunes.playqueue-contents-response"}, 
        {"ceQa",
      (DMAP_TYPE )3, (DMAP_TYPE )0, "com.apple.itunes.playqueue-album"}, 
        {"ceQg", (DMAP_TYPE )3, (DMAP_TYPE )0, "com.apple.itunes.playqueue-genre"}, 
        {"ceQn", (DMAP_TYPE )3, (DMAP_TYPE )0, "com.apple.itunes.playqueue-name"}, 
        {"ceQr", (DMAP_TYPE )3, (DMAP_TYPE )0, "com.apple.itunes.playqueue-artist"}, 
        {"cmgt", (DMAP_TYPE )7, (DMAP_TYPE )0, "dmcp.getpropertyresponse"}, 
        {"cmmk", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmcp.mediakind"}, 
        {"cmpr", (DMAP_TYPE )6, (DMAP_TYPE )0, "dmcp.protocolversion"}, 
        {"cmsr", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmcp.serverrevision"}, 
        {"cmst", (DMAP_TYPE )7, (DMAP_TYPE )0, "dmcp.playstatus"}, 
        {"cmvo", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmcp.volume"}, 
        {"f\215ch", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.haschildcontainers"}, 
        {"ipsa", (DMAP_TYPE )7, (DMAP_TYPE )0, "dpap.iphotoslideshowadvancedoptions"}, 
        {"ipsl",
      (DMAP_TYPE )7, (DMAP_TYPE )0, "dpap.iphotoslideshowoptions"}, 
        {"mbcl", (DMAP_TYPE )7, (DMAP_TYPE )0, "dmap.bag"}, 
        {"mccr", (DMAP_TYPE )7, (DMAP_TYPE )0, "dmap.contentcodesresponse"}, 
        {"mcna", (DMAP_TYPE )3, (DMAP_TYPE )0, "dmap.contentcodesname"}, 
        {"mcnm", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.contentcodesnumber"}, 
        {"mcon", (DMAP_TYPE )7, (DMAP_TYPE )0, "dmap.container"}, 
        {"mctc", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.containercount"}, 
        {"mcti", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.containeritemid"}, 
        {"mcty", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.contentcodestype"}, 
        {"mdbk", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.databasekind"}, 
        {"mdcl", (DMAP_TYPE )7, (DMAP_TYPE )0, "dmap.dictionary"}, 
        {"mdst", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.downloadstatus"}, 
        {"meds", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.editcommandssupported"}, 
        {"meia", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.itemdateadded"}, 
        {"meip", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.itemdateplayed"}, 
        {"mext", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.objectextradata"}, 
        {"miid", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.itemid"}, 
        {"mikd", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.itemkind"}, 
        {"mimc", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.itemcount"}, 
        {"minm", (DMAP_TYPE )3, (DMAP_TYPE )0, "dmap.itemname"}, 
        {"mlcl", (DMAP_TYPE )7, (DMAP_TYPE )7, "dmap.listing"}, 
        {"mlid", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.sessionid"}, 
        {"mlit", (DMAP_TYPE )8, (DMAP_TYPE )0, "dmap.listingitem"}, 
        {"mlog", (DMAP_TYPE )7, (DMAP_TYPE )0, "dmap.loginresponse"}, 
        {"mpco", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.parentcontainerid"}, 
        {"mper", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.persistentid"}, 
        {"mpro", (DMAP_TYPE )6, (DMAP_TYPE )0, "dmap.protocolversion"}, 
        {"mrco", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.returnedcount"}, 
        {"mrpr", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.remotepersistentid"}, 
        {"msal", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.supportsautologout"}, 
        {"msas", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.authenticationschemes"}, 
        {"msau", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.authenticationmethod"}, 
        {"msbr", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.supportsbrowse"}, 
        {"msdc", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.databasescount"}, 
        {"msex", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.supportsextensions"}, 
        {"msix", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.supportsindex"}, 
        {"mslr", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.loginrequired"}, 
        {"msma", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.machineaddress"}, 
        {"msml", (DMAP_TYPE )7, (DMAP_TYPE )0, "msml"}, 
        {"mspi", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.supportspersistentids"}, 
        {"msqy", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.supportsquery"}, 
        {"msrs", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.supportsresolve"}, 
        {"msrv", (DMAP_TYPE )7, (DMAP_TYPE )0, "dmap.serverinforesponse"}, 
        {"mstc", (DMAP_TYPE )5, (DMAP_TYPE )0, "dmap.utctime"}, 
        {"mstm", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.timeoutinterval"}, 
        {"msto", (DMAP_TYPE )2, (DMAP_TYPE )0, "dmap.utcoffset"}, 
        {"msts", (DMAP_TYPE )3, (DMAP_TYPE )0, "dmap.statusstring"}, 
        {"mstt", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.status"}, 
        {"msup", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.supportsupdate"}, 
        {"mtco", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.specifiedtotalcount"}, 
        {"mudl", (DMAP_TYPE )7, (DMAP_TYPE )0, "dmap.deletedidlisting"}, 
        {"mupd", (DMAP_TYPE )7, (DMAP_TYPE )0, "dmap.updateresponse"}, 
        {"musr", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.serverrevision"}, 
        {"muty", (DMAP_TYPE )1, (DMAP_TYPE )0, "dmap.updatetype"}, 
        {"pasp", (DMAP_TYPE )3, (DMAP_TYPE )0, "dpap.aspectratio"}, 
        {"pcmt", (DMAP_TYPE )3, (DMAP_TYPE )0, "dpap.imagecomments"}, 
        {"peak", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.photos.album-kind"}, 
        {"peed",
      (DMAP_TYPE )5, (DMAP_TYPE )0, "com.apple.itunes.photos.exposure-date"}, 
        {"pefc", (DMAP_TYPE )7, (DMAP_TYPE )0, "com.apple.itunes.photos.faces"}, 
        {"peki", (DMAP_TYPE )1, (DMAP_TYPE )0, "com.apple.itunes.photos.key-image-id"}, 
        {"pekm",
      (DMAP_TYPE )7, (DMAP_TYPE )0, "com.apple.itunes.photos.key-image"}, 
        {"pemd", (DMAP_TYPE )5, (DMAP_TYPE )0, "com.apple.itunes.photos.modification-date"}, 
        {"pfai",
      (DMAP_TYPE )7, (DMAP_TYPE )0, "dpap.failureids"}, 
        {"pfdt", (DMAP_TYPE )7, (DMAP_TYPE )0, "dpap.filedata"}, 
        {"pfmt", (DMAP_TYPE )3, (DMAP_TYPE )0, "dpap.imageformat"}, 
        {"phgt", (DMAP_TYPE )1, (DMAP_TYPE )0, "dpap.imagepixelheight"}, 
        {"picd", (DMAP_TYPE )5, (DMAP_TYPE )0, "dpap.creationdate"}, 
        {"pifs", (DMAP_TYPE )1, (DMAP_TYPE )0, "dpap.imagefilesize"}, 
        {"pimf", (DMAP_TYPE )3, (DMAP_TYPE )0, "dpap.imagefilename"}, 
        {"plsz", (DMAP_TYPE )1, (DMAP_TYPE )0, "dpap.imagelargefilesize"}, 
        {"ppro", (DMAP_TYPE )6, (DMAP_TYPE )0, "dpap.protocolversion"}, 
        {"prat", (DMAP_TYPE )1, (DMAP_TYPE )0, "dpap.imagerating"}, 
        {"pret", (DMAP_TYPE )7, (DMAP_TYPE )0, "dpap.retryids"}, 
        {"pwth", (DMAP_TYPE )1, (DMAP_TYPE )0, "dpap.imagepixelwidth"}};
static unsigned long const   dmap_field_count  =    (size_t const   )(sizeof(dmap_fields) / sizeof(dmap_field ));
int dmap_version(void) 
{ 


  {
  return (1002001);
}
}
char const   *dmap_version_string(void) 
{ 


  {
  return ("1.2.1");
}
}
static int dmap_field_sort(dmap_field const   *a , dmap_field const   *b ) 
{ 
  int tmp ;

  {
  tmp = memcmp((void const   *)a->code, (void const   *)b->code, (size_t )4);
  return (tmp);
}
}
static dmap_field const   *dmap_field_from_code(char const   *code ) 
{ 
  dmap_field key ;
  void *tmp ;

  {
  key.code = code;
  tmp = bsearch((void const   *)(& key), (void const   *)(dmap_fields), (size_t )dmap_field_count,
                sizeof(dmap_field ), (int (*)(void const   * , void const   * ))(& dmap_field_sort));
  return ((dmap_field const   *)tmp);
}
}
char const   *dmap_name_from_code(char const   *code ) 
{ 
  dmap_field const   *field ;
  char const   *tmp ;

  {
  if (! code) {
    return ((char const   *)((void *)0));
  }
  field = dmap_field_from_code(code);
  if (field) {
    tmp = field->name;
  } else {
    tmp = (char const   * const  )((void *)0);
  }
  return ((char const   *)tmp);
}
}
static uint16_t dmap_read_u16(char const   *buf___0 ) 
{ 


  {
  return ((uint16_t )((((int const   )*(buf___0 + 0) & 255) << 8) | ((int const   )*(buf___0 + 1) & 255)));
}
}
static int16_t dmap_read_i16(char const   *buf___0 ) 
{ 
  uint16_t tmp ;

  {
  tmp = dmap_read_u16(buf___0);
  return ((int16_t )tmp);
}
}
static uint32_t dmap_read_u32(char const   *buf___0 ) 
{ 


  {
  return (((((uint32_t )((int const   )*(buf___0 + 0) & 255) << 24) | ((uint32_t )((int const   )*(buf___0 + 1) & 255) << 16)) | ((uint32_t )((int const   )*(buf___0 + 2) & 255) << 8)) | (uint32_t )((int const   )*(buf___0 + 3) & 255));
}
}
static int32_t dmap_read_i32(char const   *buf___0 ) 
{ 
  uint32_t tmp ;

  {
  tmp = dmap_read_u32(buf___0);
  return ((int32_t )tmp);
}
}
static uint64_t dmap_read_u64(char const   *buf___0 ) 
{ 


  {
  return (((((((((uint64_t )((int const   )*(buf___0 + 0) & 255) << 56) | ((uint64_t )((int const   )*(buf___0 + 1) & 255) << 48)) | ((uint64_t )((int const   )*(buf___0 + 2) & 255) << 40)) | ((uint64_t )((int const   )*(buf___0 + 3) & 255) << 32)) | ((uint64_t )((int const   )*(buf___0 + 4) & 255) << 24)) | ((uint64_t )((int const   )*(buf___0 + 5) & 255) << 16)) | ((uint64_t )((int const   )*(buf___0 + 6) & 255) << 8)) | (uint64_t )((int const   )*(buf___0 + 7) & 255));
}
}
static int64_t dmap_read_i64(char const   *buf___0 ) 
{ 
  uint64_t tmp ;

  {
  tmp = dmap_read_u64(buf___0);
  return ((int64_t )tmp);
}
}
static int dmap_parse_internal(dmap_settings const   *settings , char const   *buf___0 ,
                               size_t len , dmap_field const   *parent ) 
{ 
  dmap_field const   *field ;
  DMAP_TYPE field_type ;
  size_t field_len ;
  char const   *field_name ;
  char const   *p ;
  char const   *end ;
  char code[5] ;
  unsigned int tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  size_t i ;
  int is_string ;
  unsigned short const   **tmp___6 ;
  uint16_t tmp___7 ;
  uint32_t tmp___8 ;
  uint64_t tmp___9 ;
  int16_t tmp___10 ;
  int32_t tmp___11 ;
  int64_t tmp___12 ;
  uint32_t tmp___13 ;
  char version[20] ;
  uint16_t tmp___14 ;
  uint16_t tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;

  {
  p = buf___0;
  end = buf___0 + len;
  code[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 5U)) {
    code[tmp] = (char)0;
    tmp ++;
  }
  if (! settings) {
    return (-1);
  } else
  if (! buf___0) {
    return (-1);
  }
  while (end - p >= 8L) {
    memcpy((void * __restrict  )(code), (void const   * __restrict  )p, (size_t )4);
    field = dmap_field_from_code((char const   *)(code));
    p += 4;
    tmp___0 = dmap_read_u32(p);
    field_len = (size_t )tmp___0;
    p += 4;
    if ((unsigned long )(p + field_len) > (unsigned long )end) {
      return (-1);
    }
    if (field) {
      field_type = (DMAP_TYPE )field->type;
      field_name = (char const   *)field->name;
      if ((unsigned int )field_type == 8U) {
        if ((unsigned long )parent != (unsigned long )((void *)0)) {
          if (parent->list_item_type) {
            field_type = (DMAP_TYPE )parent->list_item_type;
          } else {
            field_type = (DMAP_TYPE )7;
          }
        } else {
          field_type = (DMAP_TYPE )7;
        }
      }
    } else {
      field_type = (DMAP_TYPE )0;
      field_name = (char const   *)(code);
      if (field_len >= 8UL) {
        tmp___2 = __ctype_b_loc();
        if ((int const   )*(*tmp___2 + (int )((int const   )*(p + 0) & 255)) & 1024) {
          tmp___3 = __ctype_b_loc();
          if ((int const   )*(*tmp___3 + (int )((int const   )*(p + 1) & 255)) & 1024) {
            tmp___4 = __ctype_b_loc();
            if ((int const   )*(*tmp___4 + (int )((int const   )*(p + 2) & 255)) & 1024) {
              tmp___5 = __ctype_b_loc();
              if ((int const   )*(*tmp___5 + (int )((int const   )*(p + 3) & 255)) & 1024) {
                tmp___1 = dmap_read_u32(p + 4);
                if ((size_t )tmp___1 < field_len) {
                  field_type = (DMAP_TYPE )7;
                }
              }
            }
          }
        }
      }
      if ((unsigned int )field_type == 0U) {
        is_string = 1;
        i = (size_t )0;
        while (i < field_len) {
          tmp___6 = __ctype_b_loc();
          if (! ((int const   )*(*tmp___6 + (int )((int const   )*(p + i) & 255)) & 16384)) {
            is_string = 0;
            break;
          }
          i ++;
        }
        if (is_string) {
          field_type = (DMAP_TYPE )3;
        } else {
          field_type = (DMAP_TYPE )1;
        }
      }
    }
    switch ((unsigned int )field_type) {
    case 1U: 
    switch (field_len) {
    case 1UL: 
    if (settings->on_uint32) {
      (*(settings->on_uint32))((void *)settings->ctx, (char const   *)(code), field_name,
                               (uint32_t )((unsigned char )*p));
    }
    break;
    case 2UL: 
    if (settings->on_uint32) {
      tmp___7 = dmap_read_u16(p);
      (*(settings->on_uint32))((void *)settings->ctx, (char const   *)(code), field_name,
                               (uint32_t )tmp___7);
    }
    break;
    case 4UL: 
    if (settings->on_uint32) {
      tmp___8 = dmap_read_u32(p);
      (*(settings->on_uint32))((void *)settings->ctx, (char const   *)(code), field_name,
                               tmp___8);
    }
    break;
    case 8UL: 
    if (settings->on_uint64) {
      tmp___9 = dmap_read_u64(p);
      (*(settings->on_uint64))((void *)settings->ctx, (char const   *)(code), field_name,
                               tmp___9);
    }
    break;
    default: 
    if (settings->on_data) {
      (*(settings->on_data))((void *)settings->ctx, (char const   *)(code), field_name,
                             p, field_len);
    }
    break;
    }
    break;
    case 2U: 
    switch (field_len) {
    case 1UL: 
    if (settings->on_int32) {
      (*(settings->on_int32))((void *)settings->ctx, (char const   *)(code), field_name,
                              (int32_t )*p);
    }
    break;
    case 2UL: 
    if (settings->on_int32) {
      tmp___10 = dmap_read_i16(p);
      (*(settings->on_int32))((void *)settings->ctx, (char const   *)(code), field_name,
                              (int32_t )tmp___10);
    }
    break;
    case 4UL: 
    if (settings->on_int32) {
      tmp___11 = dmap_read_i32(p);
      (*(settings->on_int32))((void *)settings->ctx, (char const   *)(code), field_name,
                              tmp___11);
    }
    break;
    case 8UL: 
    if (settings->on_int64) {
      tmp___12 = dmap_read_i64(p);
      (*(settings->on_int64))((void *)settings->ctx, (char const   *)(code), field_name,
                              tmp___12);
    }
    break;
    default: 
    if (settings->on_data) {
      (*(settings->on_data))((void *)settings->ctx, (char const   *)(code), field_name,
                             p, field_len);
    }
    break;
    }
    break;
    case 3U: 
    if (settings->on_string) {
      (*(settings->on_string))((void *)settings->ctx, (char const   *)(code), field_name,
                               p, field_len);
    }
    break;
    case 4U: 
    if (settings->on_data) {
      (*(settings->on_data))((void *)settings->ctx, (char const   *)(code), field_name,
                             p, field_len);
    }
    break;
    case 5U: 
    if (settings->on_date) {
      tmp___13 = dmap_read_u32(p);
      (*(settings->on_date))((void *)settings->ctx, (char const   *)(code), field_name,
                             tmp___13);
    }
    break;
    case 6U: 
    if (settings->on_string) {
      if (field_len >= 4UL) {
        tmp___14 = dmap_read_u16(p + 2);
        tmp___15 = dmap_read_u16(p);
        sprintf((char * __restrict  )(version), (char const   * __restrict  )"%u.%u",
                (int )tmp___15, (int )tmp___14);
        tmp___16 = strlen((char const   *)(version));
        (*(settings->on_string))((void *)settings->ctx, (char const   *)(code), field_name,
                                 (char const   *)(version), tmp___16);
      }
    }
    break;
    case 7U: 
    if (settings->on_dict_start) {
      (*(settings->on_dict_start))((void *)settings->ctx, (char const   *)(code),
                                   field_name);
    }
    tmp___17 = dmap_parse_internal(settings, p, field_len, field);
    if (tmp___17 != 0) {
      return (-1);
    }
    if (settings->on_dict_end) {
      (*(settings->on_dict_end))((void *)settings->ctx, (char const   *)(code), field_name);
    }
    break;
    case 8U: 
    abort();
    case 0U: 
    break;
    }
    p += field_len;
  }
  if ((unsigned long )p != (unsigned long )end) {
    return (-1);
  }
  return (0);
}
}
int dmap_parse(dmap_settings const   *settings , char const   *buf___0 , size_t len ) 
{ 
  int tmp ;

  {
  tmp = dmap_parse_internal(settings, buf___0, len, (dmap_field const   *)((void *)0));
  return (tmp);
}
}
#pragma merger("0","/tmp/cil-0S8K_V_K.i","-Wall,-fPIC,-ggdb,-O2,-m64,-fdata-sections,-ffunction-sections")
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memchr)(void const   *__s ,
                                                                                     int __c ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
void control_mDNS(struct mDNShandle_s *handle , mDNScontrol_e request ) ;
void free_list_mDNS(mDNSservice_t *slist ) ;
mDNSservice_t *get_list_mDNS(struct mDNShandle_s *handle ) ;
static item_t *remove_item___0(item_t *item , item_t **list ) ;
static item_t *insert_item(item_t *item , item_t **list ) ;
static void clear_list___0(item_t *list , void (*free_func)(void * ) ) ;
static void store_a(struct context_s *context , mDNSResourceRecord *rr ) ;
static void store_other(struct in_addr host , struct context_s *context , char *message ,
                        mDNSResourceRecord *rr ) ;
static int debug(char const   *format  , ...) ;
static mDNSFlags *mdns_parse_header_flags(uint16_t data ) ;
static uint16_t mdns_pack_header_flags(mDNSFlags flags ) ;
static char *mdns_pack_question(mDNSQuestion *q , size_t *size ) ;
static void mdns_message_print(mDNSMessage *msg ) ;
static mDNSMessage *mdns_build_query_message(char *query_str , uint16_t query_type ) ;
static char *mdns_pack_message(mDNSMessage *msg , size_t *pack_length ) ;
static int mdns_parse_question(char *message , char *data , int size ) ;
static int mdns_parse_rr_a(char *data , struct in_addr *addr ) ;
static int mdns_parse_rr_ptr(char *message , char *data , char **name ) ;
static int mdns_parse_rr_srv(char *message , char *data , char **hostname , unsigned short *port ) ;
static void mdns_parse_rr_txt(char *message , mDNSResourceRecord *rr , char **txt ,
                              int *length ) ;
static int mdns_parse_rr(struct in_addr host , struct context_s *context , char *message ,
                         char *rrdata , int size , int is_answer ) ;
static int mdns_parse_message_net(struct in_addr host , struct context_s *context ,
                                  char *data , int size , mDNSMessage *msg ) ;
static char *parse_rr_name(char *message , char *name , int *parsed ) ;
static uint16_t get_offset(char *data ) ;
static void free_resource_record(mDNSResourceRecord *rr ) ;
static void clear_context(struct context_s *context ) ;
static char *prepare_query_string(char *name ) ;
static int send_query(int sock , char *query_arg , uint16_t query_type ) ;
static int debug_mode  ;
static int debug(char const   *format  , ...) 
{ 
  va_list___0 args ;
  int ret ;

  {
  if (! debug_mode) {
    return (0);
  }
  __builtin_va_start(args, format);
  ret = vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )format,
                 args);
  __builtin_va_end(args);
  return (ret);
}
}
static uint32_t gettime(void) 
{ 
  struct timespec ts ;
  int tmp ;
  struct timeval tv ;

  {
  tmp = clock_gettime(1, & ts);
  if (! tmp) {
    return ((uint32_t )ts.tv_sec);
  }
  gettimeofday((struct timeval * __restrict  )(& tv), (void * __restrict  )((void *)0));
  return ((uint32_t )tv.tv_sec);
}
}
static item_t *insert_item(item_t *item , item_t **list ) 
{ 


  {
  if (*list) {
    item->next = *list;
  } else {
    item->next = (struct item_s *)((void *)0);
  }
  *list = item;
  return (item);
}
}
static item_t *remove_item___0(item_t *item , item_t **list ) 
{ 
  struct item_s *p ;

  {
  if ((unsigned long )item != (unsigned long )*list) {
    p = *list;
    while (1) {
      if (p) {
        if (! ((unsigned long )p->next != (unsigned long )item)) {
          break;
        }
      } else {
        break;
      }
      p = p->next;
    }
    if (p) {
      p->next = item->next;
    }
    item->next = (struct item_s *)((void *)0);
  } else {
    *list = (*list)->next;
  }
  return (item);
}
}
static void clear_list___0(item_t *list , void (*free_func)(void * ) ) 
{ 
  struct item_s *next ;

  {
  if (! list) {
    return;
  }
  while (list) {
    next = list->next;
    if (free_func) {
      (*free_func)((void *)list);
    } else {
      free((void *)list);
    }
    list = next;
  }
  return;
}
}
static void free_a(alist_t *a ) 
{ 


  {
  if (a->name) {
    free((void *)a->name);
  }
  free((void *)a);
  return;
}
}
static void free_s(slist_t *s ) 
{ 


  {
  if (s->name) {
    free((void *)s->name);
  }
  if (s->hostname) {
    free((void *)s->hostname);
  }
  if (s->txt) {
    free((void *)s->txt);
  }
  free((void *)s);
  return;
}
}
static char *prepare_query_string(char *name ) 
{ 
  int i ;
  int count___0 ;
  int lastdot ;
  int len ;
  size_t tmp ;
  char *result ;
  void *tmp___0 ;

  {
  lastdot = 0;
  tmp = strlen((char const   *)name);
  len = (int )tmp;
  tmp___0 = malloc((size_t )(len + 2));
  result = (char *)tmp___0;
  if (! result) {
    debug("failed to allocate memory for parsed hostname");
    return ((char *)((void *)0));
  }
  count___0 = 0;
  i = 0;
  while (i < len + 1) {
    if ((int )*(name + i) == 46) {
      *(result + lastdot) = (char )count___0;
      count___0 = 0;
      lastdot = i + 1;
      goto __Cont;
    } else
    if ((int )*(name + i) == 0) {
      *(result + lastdot) = (char )count___0;
      count___0 = 0;
      lastdot = i + 1;
      goto __Cont;
    }
    *(result + (i + 1)) = *(name + i);
    count___0 ++;
    __Cont: /* CIL Label */ 
    i ++;
  }
  *(result + (len + 1)) = (char )'\000';
  return (result);
}
}
static mDNSFlags *mdns_parse_header_flags(uint16_t data ) 
{ 
  mDNSFlags *flags ;
  void *tmp ;

  {
  tmp = malloc(sizeof(mDNSFlags ));
  flags = (mDNSFlags *)tmp;
  if (! flags) {
    debug("could not allocate memory for parsing header flags");
    return ((mDNSFlags *)((void *)0));
  }
  flags->rcode = (int )data & 15;
  flags->cd = ((int )data >> 4) & 1;
  flags->ad = ((int )data >> 5) & 1;
  flags->zero = ((int )data >> 6) & 1;
  flags->ra = ((int )data >> 7) & 1;
  flags->rd = ((int )data >> 8) & 1;
  flags->tc = ((int )data >> 9) & 1;
  flags->aa = ((int )data >> 10) & 1;
  flags->opcode = ((int )data >> 14) & 15;
  flags->qr = ((int )data >> 15) & 1;
  return (flags);
}
}
static uint16_t mdns_pack_header_flags(mDNSFlags flags ) 
{ 
  uint16_t packed ;

  {
  packed = (uint16_t )0;
  packed = (uint16_t )((int )packed | (flags.rcode & 65520));
  packed = (uint16_t )((int )packed | ((flags.cd & 65534) << 4));
  packed = (uint16_t )((int )packed | ((flags.ad & 65534) << 5));
  packed = (uint16_t )((int )packed | ((flags.zero & 65534) << 6));
  packed = (uint16_t )((int )packed | ((flags.ra & 65534) << 7));
  packed = (uint16_t )((int )packed | ((flags.rd & 65534) << 8));
  packed = (uint16_t )((int )packed | ((flags.tc & 65534) << 9));
  packed = (uint16_t )((int )packed | ((flags.aa & 65534) << 10));
  packed = (uint16_t )((int )packed | ((flags.opcode & 65520) << 14));
  packed = (uint16_t )((int )packed | ((flags.qr & 65534) << 15));
  return (packed);
}
}
static char *mdns_pack_question(mDNSQuestion *q , size_t *size ) 
{ 
  char *packed ;
  size_t name_length ;
  uint16_t qtype ;
  uint16_t qclass ;
  size_t tmp ;
  void *tmp___0 ;

  {
  tmp = strlen((char const   *)q->qname);
  name_length = tmp + 1UL;
  if (name_length > 253UL) {
    debug("domain name too long");
    return ((char *)((void *)0));
  }
  debug("name length: %u\n", name_length);
  *size = (name_length + 2UL) + 2UL;
  tmp___0 = malloc(*size);
  packed = (char *)tmp___0;
  if (! packed) {
    debug("could not allocate memory for DNS question");
    return ((char *)((void *)0));
  }
  memcpy((void * __restrict  )packed, (void const   * __restrict  )q->qname, name_length);
  if (q->prefer_unicast_response) {
    q->qclass = (uint16_t )((int )q->qclass | (1 << 15));
  }
  qtype = __bswap_16(q->qtype);
  qclass = __bswap_16(q->qclass);
  memcpy((void * __restrict  )(packed + name_length), (void const   * __restrict  )(& qtype),
         (size_t )2);
  memcpy((void * __restrict  )((packed + name_length) + 2), (void const   * __restrict  )(& qclass),
         (size_t )2);
  return (packed);
}
}
static int mdns_parse_question(char *message , char *data , int size ) 
{ 
  mDNSQuestion q ;
  char *cur ;
  int parsed ;

  {
  parsed = 0;
  cur = data;
  q.qname = parse_rr_name(message, data, & parsed);
  free((void *)q.qname);
  cur += parsed;
  if (parsed > size) {
    debug("qname is too long");
    return (0);
  }
  memcpy((void * __restrict  )(& q.qtype), (void const   * __restrict  )cur, (size_t )2);
  q.qtype = __bswap_16(q.qtype);
  cur += 2;
  parsed += 2;
  if (parsed > size) {
    return (0);
  }
  memcpy((void * __restrict  )(& q.qclass), (void const   * __restrict  )cur, (size_t )2);
  q.qclass = __bswap_16(q.qclass);
  cur += 2;
  parsed += 2;
  if (parsed > size) {
    return (0);
  }
  return (parsed);
}
}
static void mdns_message_print(mDNSMessage *msg ) 
{ 
  mDNSFlags *flags ;
  mDNSFlags *tmp ;

  {
  tmp = mdns_parse_header_flags(msg->flags);
  flags = tmp;
  if (! flags) {
    return;
  }
  free((void *)flags);
  return;
}
}
static int mdns_parse_rr_a(char *data , struct in_addr *addr ) 
{ 
  char *tmp ;

  {
  addr->s_addr = (in_addr_t )0;
  if ((int )*(data + 0) == -87) {
    if ((int )*(data + 1) == -2) {
      return (4);
    }
  }
  memcpy((void * __restrict  )(& addr->s_addr), (void const   * __restrict  )data,
         (size_t )4);
  tmp = inet_ntoa(*addr);
  debug("        A: %s\n", tmp);
  return (4);
}
}
static int mdns_parse_rr_ptr(char *message , char *data , char **name ) 
{ 
  int parsed ;

  {
  parsed = 0;
  *name = parse_rr_name(message, data, & parsed);
  debug("        PTR: %s\n", *name);
  return (parsed);
}
}
static int mdns_parse_rr_srv(char *message , char *data , char **hostname , unsigned short *port ) 
{ 
  uint16_t priority ;
  uint16_t weight ;
  int parsed ;

  {
  parsed = 0;
  memcpy((void * __restrict  )(& priority), (void const   * __restrict  )data, (size_t )2);
  priority = __bswap_16(priority);
  data += 2;
  parsed += 2;
  memcpy((void * __restrict  )(& weight), (void const   * __restrict  )data, (size_t )2);
  weight = __bswap_16(weight);
  data += 2;
  parsed += 2;
  memcpy((void * __restrict  )port, (void const   * __restrict  )data, (size_t )2);
  *port = __bswap_16(*port);
  data += 2;
  parsed += 2;
  *hostname = parse_rr_name(message, data, & parsed);
  debug("        SRV target: %s\n", *hostname);
  debug("        SRV port: %u\n", (int )*port);
  return (parsed);
}
}
static void mdns_parse_rr_txt(char *message , mDNSResourceRecord *rr , char **txt ,
                              int *length ) 
{ 
  char *tmp ;
  void *tmp___0 ;

  {
  tmp___0 = malloc((size_t )rr->rdata_length);
  tmp = (char *)tmp___0;
  *txt = tmp;
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
    memcpy((void * __restrict  )*txt, (void const   * __restrict  )rr->rdata, (size_t )rr->rdata_length);
    *length = (int )rr->rdata_length;
  }
  return;
}
}
static uint16_t get_offset(char *data ) 
{ 
  uint16_t offset ;

  {
  memcpy((void * __restrict  )(& offset), (void const   * __restrict  )data, (size_t )2);
  offset = __bswap_16(offset);
  if (((int )offset >> 14) & 3) {
    offset = (uint16_t )((int )offset & 16383);
    return (offset);
  }
  return ((uint16_t )0);
}
}
static char *parse_rr_name(char *message , char *name , int *parsed ) 
{ 
  int dereference_count ;
  uint16_t offset ;
  int label_len___0 ;
  char *out ;
  int out_i ;
  int i ;
  int did_jump ;
  int pars ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  dereference_count = 0;
  out_i = 0;
  i = 0;
  did_jump = 0;
  pars = 0;
  tmp = malloc((size_t )256);
  out = (char *)tmp;
  if (! out) {
    debug("could not allocate memory for resource record name");
    return ((char *)((void *)0));
  }
  while (1) {
    offset = get_offset(name);
    if (offset) {
      if (! did_jump) {
        pars += 2;
      }
      did_jump = 1;
      name = message + (int )offset;
      dereference_count ++;
      if (dereference_count >= 40) {
        free((void *)out);
        return ((char *)((void *)0));
      }
      continue;
    }
    if (out_i > 0) {
      tmp___0 = out_i;
      out_i ++;
      *(out + tmp___0) = (char )'.';
      if (out_i + 1 >= 256) {
        free((void *)out);
        return ((char *)((void *)0));
      }
    }
    label_len___0 = (int )*(name + 0);
    name ++;
    if (! did_jump) {
      pars ++;
    }
    i = 0;
    while (i < label_len___0) {
      tmp___1 = out_i;
      out_i ++;
      *(out + tmp___1) = *(name + i);
      if (out_i + 1 >= 256) {
        free((void *)out);
        return ((char *)((void *)0));
      }
      if (! did_jump) {
        pars ++;
      }
      i ++;
    }
    name += label_len___0;
    if ((int )*(name + 0) == 0) {
      *(out + out_i) = (char )'\000';
      if (! did_jump) {
        if (label_len___0) {
          pars ++;
        }
      }
      *parsed += pars;
      return (out);
    }
  }
}
}
static void free_resource_record(mDNSResourceRecord *rr ) 
{ 


  {
  if (rr->name) {
    free((void *)rr->name);
    rr->name = (char *)((void *)0);
  }
  return;
}
}
static int mdns_parse_rr(struct in_addr host , struct context_s *context , char *message ,
                         char *rrdata , int size , int is_answer ) 
{ 
  mDNSResourceRecord rr ;
  int parsed ;
  char *cur ;

  {
  parsed = 0;
  cur = rrdata;
  rr.name = (char *)((void *)0);
  rr.name = parse_rr_name(message, rrdata, & parsed);
  if (! rr.name) {
    free_resource_record(& rr);
    debug("parsing resource record name failed\n");
    return (0);
  }
  cur += parsed;
  if (parsed + 10 > size) {
    free_resource_record(& rr);
    return (0);
  }
  debug("      Resource Record Name: %s\n", rr.name);
  memcpy((void * __restrict  )(& rr.type), (void const   * __restrict  )cur, (size_t )2);
  rr.type = __bswap_16(rr.type);
  cur += 2;
  parsed += 2;
  debug("      Resource Record Type: %u\n", (int )rr.type);
  memcpy((void * __restrict  )(& rr.class), (void const   * __restrict  )cur, (size_t )2);
  rr.class = __bswap_16(rr.class);
  cur += 2;
  parsed += 2;
  memcpy((void * __restrict  )(& rr.ttl), (void const   * __restrict  )cur, (size_t )4);
  rr.ttl = __bswap_32(rr.ttl);
  cur += 4;
  parsed += 4;
  debug("      ttl: %u\n", rr.ttl);
  memcpy((void * __restrict  )(& rr.rdata_length), (void const   * __restrict  )cur,
         (size_t )2);
  rr.rdata_length = __bswap_16(rr.rdata_length);
  cur += 2;
  parsed += 2;
  if (parsed > size) {
    free_resource_record(& rr);
    return (0);
  }
  rr.rdata = (void *)cur;
  parsed += (int )rr.rdata_length;
  if (is_answer) {
    if ((int )rr.type == 1) {
      store_a(context, & rr);
    } else {
      store_other(host, context, message, & rr);
    }
  }
  free_resource_record(& rr);
  debug("    ------------------------------\n");
  return (parsed);
}
}
static int mdns_parse_message_net(struct in_addr host , struct context_s *context ,
                                  char *data , int size , mDNSMessage *msg ) 
{ 
  int parsed ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  parsed = 0;
  if (size < 12) {
    return (0);
  }
  memcpy((void * __restrict  )msg, (void const   * __restrict  )data, (size_t )12);
  msg->id = __bswap_16(msg->id);
  msg->flags = __bswap_16(msg->flags);
  msg->qd_count = __bswap_16(msg->qd_count);
  msg->an_count = __bswap_16(msg->an_count);
  msg->ns_count = __bswap_16(msg->ns_count);
  msg->ar_count = __bswap_16(msg->ar_count);
  parsed += 12;
  mdns_message_print(msg);
  debug("  Question records [%u] (not shown)\n", (int )msg->qd_count);
  i = 0;
  while (i < (int )msg->qd_count) {
    tmp = mdns_parse_question(data, data + parsed, size - parsed);
    parsed += tmp;
    i ++;
  }
  debug("  Answer records [%u]\n", (int )msg->an_count);
  i = 0;
  while (i < (int )msg->an_count) {
    tmp___0 = mdns_parse_rr(host, context, data, data + parsed, size - parsed, 1);
    parsed += tmp___0;
    i ++;
  }
  debug("  Nameserver records [%u] (not shown)\n", (int )msg->ns_count);
  i = 0;
  while (i < (int )msg->ns_count) {
    tmp___1 = mdns_parse_rr(host, context, data, data + parsed, size - parsed, 0);
    parsed += tmp___1;
    i ++;
  }
  debug("  Additional records [%u] (not shown)\n", (int )msg->ns_count);
  i = 0;
  while (i < (int )msg->ar_count) {
    tmp___2 = mdns_parse_rr(host, context, data, data + parsed, size - parsed, 1);
    parsed += tmp___2;
    i ++;
  }
  return (parsed);
}
}
static mDNSMessage *mdns_build_query_message(char *query_str , uint16_t query_type ) 
{ 
  mDNSMessage *msg ;
  mDNSQuestion question ;
  mDNSFlags flags ;
  void *tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;
  uint16_t tmp___2 ;
  char *tmp___3 ;

  {
  tmp = malloc(sizeof(mDNSMessage ));
  msg = (mDNSMessage *)tmp;
  if (! msg) {
    debug("failed to allocate memory for mDNS message");
    return ((mDNSMessage *)((void *)0));
  }
  flags.qr = 0;
  flags.opcode = 0;
  flags.aa = 0;
  flags.tc = 0;
  flags.rd = 0;
  flags.ra = 0;
  flags.zero = 0;
  flags.ad = 0;
  flags.cd = 0;
  flags.rcode = 0;
  msg->id = (uint16_t )0;
  tmp___0 = mdns_pack_header_flags(flags);
  msg->flags = __bswap_16(tmp___0);
  msg->qd_count = __bswap_16((__uint16_t )1);
  tmp___2 = (uint16_t )0;
  msg->ar_count = tmp___2;
  tmp___1 = tmp___2;
  msg->ns_count = tmp___1;
  msg->an_count = tmp___1;
  question.qname = query_str;
  if (! question.qname) {
    return ((mDNSMessage *)((void *)0));
  }
  question.prefer_unicast_response = 0;
  question.qtype = query_type;
  question.qclass = (uint16_t )1;
  tmp___3 = mdns_pack_question(& question, & msg->data_size);
  msg->data = tmp___3;
  if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
    free((void *)msg);
    return ((mDNSMessage *)((void *)0));
  }
  return (msg);
}
}
static char *mdns_pack_message(mDNSMessage *msg , size_t *pack_length ) 
{ 
  char *pack ;
  void *tmp ;

  {
  *pack_length = 12UL + msg->data_size;
  if (*pack_length > 4096UL) {
    debug("mDNS message too large");
    return ((char *)((void *)0));
  }
  tmp = malloc(*pack_length);
  pack = (char *)tmp;
  if (! pack) {
    debug("failed to allocate data for packed mDNS message");
    return ((char *)((void *)0));
  }
  memcpy((void * __restrict  )pack, (void const   * __restrict  )msg, (size_t )12);
  memcpy((void * __restrict  )(pack + 12), (void const   * __restrict  )msg->data,
         msg->data_size);
  return (pack);
}
}
static void mdns_parse_txt(char *txt , int txt_length , mDNSservice_t *s ) 
{ 
  int len ;
  int count___0 ;
  char *p ;
  int i ;
  void *tmp ;
  char *value ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  len = 0;
  count___0 = 0;
  if (! txt) {
    return;
  }
  while (len + count___0 < txt_length) {
    len += (int )*((txt + len) + count___0);
    count___0 ++;
  }
  s->attr_count = count___0;
  tmp = malloc((unsigned long )count___0 * sizeof(txt_attr_t ));
  s->attr = (txt_attr_t *)tmp;
  p = txt;
  i = 0;
  while (i < count___0) {
    tmp___0 = memchr((void const   *)(p + 1), '=', (size_t )*p);
    value = (char *)tmp___0;
    if (value) {
      len = (int )(((long )*p - (value - (p + 1))) - 1L);
      tmp___1 = malloc((size_t )(len + 1));
      (s->attr + i)->value = (char *)tmp___1;
      memcpy((void * __restrict  )(s->attr + i)->value, (void const   * __restrict  )(value + 1),
             (size_t )len);
      *((s->attr + i)->value + len) = (char )'\000';
      len = (int )(value - (p + 1));
      tmp___2 = malloc((size_t )(len + 1));
      (s->attr + i)->name = (char *)tmp___2;
      memcpy((void * __restrict  )(s->attr + i)->name, (void const   * __restrict  )(p + 1),
             (size_t )len);
      *((s->attr + i)->name + len) = (char )'\000';
    } else {
      len = (int )*p;
      tmp___3 = malloc((size_t )(len + 1));
      (s->attr + i)->name = (char *)tmp___3;
      memcpy((void * __restrict  )(s->attr + i)->name, (void const   * __restrict  )(p + 1),
             (size_t )len);
      *((s->attr + i)->name + len) = (char )'\000';
      (s->attr + i)->value = (char *)((void *)0);
    }
    p += (int )*p + 1;
    i ++;
  }
  return;
}
}
static int send_query(int sock , char *query_arg , uint16_t query_type ) 
{ 
  mDNSMessage *msg ;
  char *data ;
  size_t data_size ;
  int res ;
  struct sockaddr_in addr ;
  socklen_t addrlen ;
  char *query_str ;
  ssize_t tmp ;

  {
  query_str = prepare_query_string(query_arg);
  if ((unsigned long )query_str == (unsigned long )((void *)0)) {
    return (-1);
  }
  addr.sin_family = (sa_family_t )2;
  addr.sin_port = __bswap_16((__uint16_t )5353);
  addr.sin_addr.s_addr = inet_addr("224.0.0.251");
  addrlen = (socklen_t )sizeof(addr);
  msg = mdns_build_query_message(query_str, query_type);
  free((void *)query_str);
  if (! msg) {
    return (-1);
  }
  data = mdns_pack_message(msg, & data_size);
  free((void *)msg->data);
  free((void *)msg);
  if (! data) {
    return (-1);
  }
  debug("Sending DNS message with length: %u\n", data_size);
  tmp = sendto(sock, (void const   *)data, data_size, 0, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& addr)),
               addrlen);
  res = (int )tmp;
  free((void *)data);
  return (res);
}
}
static int is_complete(slist_t *s ) 
{ 


  {
  if (s->addr.s_addr) {
    if (s->hostname) {
      if (s->port) {
        if (s->txt) {
          return (1);
        } else {
          return (0);
        }
      } else {
        return (0);
      }
    } else {
      return (0);
    }
  } else {
    return (0);
  }
}
}
static void store_a(struct context_s *context , mDNSResourceRecord *rr ) 
{ 
  alist_t *b ;
  struct in_addr addr ;
  uint32_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  uint32_t tmp___2 ;

  {
  mdns_parse_rr_a((char *)rr->rdata, & addr);
  b = context->alist;
  while (b) {
    tmp___0 = strcmp((char const   *)b->name, (char const   *)rr->name);
    if (! tmp___0) {
      if (addr.s_addr) {
        b->addr = addr;
      }
      tmp = gettime();
      b->eol = tmp + rr->ttl;
      return;
    }
    b = b->next;
  }
  tmp___1 = malloc(sizeof(alist_t ));
  b = (alist_t *)tmp___1;
  b->addr = addr;
  b->name = strdup((char const   *)rr->name);
  tmp___2 = gettime();
  b->eol = tmp___2 + rr->ttl;
  insert_item((item_t *)b, (item_t **)(& context->alist));
  return;
}
}
static slist_t *create_s(struct in_addr host , char *name , slist_t **list ) 
{ 
  slist_t *s ;
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(slist_t ));
  s = (slist_t *)tmp;
  s->name = strdup((char const   *)name);
  s->host = host;
  insert_item((item_t *)s, (item_t **)list);
  return (s);
}
}
static void store_other(struct in_addr host , struct context_s *context , char *message ,
                        mDNSResourceRecord *rr ) 
{ 
  slist_t *b ;
  char *name ;
  uint32_t now ;
  uint32_t ttl ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned short port ;
  char *hostname ;
  int tmp___2 ;
  int tmp___3 ;
  char *txt ;
  int length ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;

  {
  b = (slist_t *)((void *)0);
  name = (char *)((void *)0);
  if ((int )rr->type == 12) {
    tmp = strcmp((char const   *)rr->name, (char const   *)context->query);
    if (tmp) {
      return;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    tmp___0 = strstr((char const   *)rr->name, (char const   *)context->query);
    if (! tmp___0) {
      return;
    }
  }
  now = gettime();
  if (context->ttl) {
    if (context->ttl < rr->ttl) {
      ttl = context->ttl;
    } else {
      ttl = rr->ttl;
    }
  } else {
    ttl = rr->ttl;
  }
  switch ((int )rr->type) {
  case 12: 
  mdns_parse_rr_ptr(message, (char *)rr->rdata, & name);
  b = context->slist;
  while (1) {
    if (b) {
      tmp___1 = strcmp((char const   *)b->name, (char const   *)name);
      if (! tmp___1) {
        if (! (b->host.s_addr != host.s_addr)) {
          break;
        }
      }
    } else {
      break;
    }
    b = b->next;
  }
  if (! b) {
    if (rr->ttl) {
      b = create_s(host, name, & context->slist);
    }
  }
  if (b) {
    b->eol[0] = now + ttl;
  }
  free((void *)name);
  break;
  case 33: 
  hostname = (char *)((void *)0);
  mdns_parse_rr_srv(message, (char *)rr->rdata, & hostname, & port);
  b = context->slist;
  while (1) {
    if (b) {
      tmp___2 = strcmp((char const   *)b->name, (char const   *)rr->name);
      if (! tmp___2) {
        if (! (b->host.s_addr != host.s_addr)) {
          break;
        }
      }
    } else {
      break;
    }
    b = b->next;
  }
  if (! b) {
    if (rr->ttl) {
      b = create_s(host, rr->name, & context->slist);
    }
  }
  if (b) {
    if (port) {
      if ((int )b->port != (int )port) {
        b->port = port;
        b->status = (enum __anonenum_status_277728880 )1;
      }
    }
    if (! b->hostname) {
      goto _L___0;
    } else {
      tmp___3 = strcmp((char const   *)b->hostname, (char const   *)hostname);
      if (tmp___3) {
        _L___0: /* CIL Label */ 
        if (b->hostname) {
          free((void *)b->hostname);
        }
        b->status = (enum __anonenum_status_277728880 )1;
        b->hostname = strdup((char const   *)hostname);
      }
    }
    b->eol[1] = now + ttl;
  }
  free((void *)hostname);
  break;
  case 16: 
  txt = (char *)((void *)0);
  length = 0;
  mdns_parse_rr_txt(message, rr, & txt, & length);
  b = context->slist;
  while (1) {
    if (b) {
      tmp___4 = strcmp((char const   *)b->name, (char const   *)rr->name);
      if (! tmp___4) {
        if (! (b->host.s_addr != host.s_addr)) {
          break;
        }
      }
    } else {
      break;
    }
    b = b->next;
  }
  if (! b) {
    if (rr->ttl) {
      b = create_s(host, rr->name, & context->slist);
    }
  }
  if (b) {
    if (! b->txt) {
      goto _L___1;
    } else {
      tmp___6 = memcmp((void const   *)b->txt, (void const   *)txt, (size_t )length);
      if (tmp___6) {
        _L___1: /* CIL Label */ 
        if (b->txt) {
          free((void *)b->txt);
        }
        tmp___5 = malloc((size_t )length);
        b->txt = (char *)tmp___5;
        b->txt_length = length;
        memcpy((void * __restrict  )b->txt, (void const   * __restrict  )txt, (size_t )length);
        b->status = (enum __anonenum_status_277728880 )1;
      }
    }
    b->eol[2] = now + ttl;
  }
  free((void *)txt);
  break;
  }
  if (b) {
    if (rr->ttl) {
      b->seen = now;
    }
  }
  return;
}
}
static mDNSservice_t *build_update(struct context_s *context , _Bool build ) 
{ 
  mDNSservice_t *services ;
  uint32_t now ;
  uint32_t tmp ;
  alist_t *a ;
  slist_t *s ;
  alist_t *next ;
  slist_t *next___0 ;
  _Bool ptr_expired ;
  _Bool srv_expired ;
  _Bool txt_expired ;
  _Bool a_expired ;
  int tmp___0 ;
  mDNSservice_t *p ;
  void *tmp___1 ;
  int tmp___2 ;
  mDNSservice_t *p___0 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
  services = (mDNSservice_t *)((void *)0);
  tmp = gettime();
  now = tmp;
  a = context->alist;
  while (a) {
    next = a->next;
    if (a->eol - now > 2147483647U) {
      remove_item___0((item_t *)a, (item_t **)(& context->alist));
      free_a(a);
    }
    a = next;
  }
  s = context->slist;
  while (s) {
    next___0 = s->next;
    a_expired = (_Bool)1;
    if (s->hostname) {
      if (s->port) {
        if (s->txt) {
          a = context->alist;
          while (a) {
            tmp___0 = strcmp((char const   *)s->hostname, (char const   *)a->name);
            if (tmp___0) {
              goto __Cont;
            }
            if (s->addr.s_addr != a->addr.s_addr) {
              s->addr.s_addr = a->addr.s_addr;
              s->status = (enum __anonenum_status_277728880 )1;
            }
            a_expired = (_Bool)0;
            break;
            __Cont: /* CIL Label */ 
            a = a->next;
          }
        }
      }
    }
    ptr_expired = (_Bool )(s->eol[0] - now > 2147483647U);
    srv_expired = (_Bool )(s->eol[1] - now > 2147483647U);
    txt_expired = (_Bool )(s->eol[2] - now > 2147483647U);
    if (ptr_expired) {
      goto _L;
    } else
    if (srv_expired) {
      goto _L;
    } else
    if (txt_expired) {
      goto _L;
    } else
    if (a_expired) {
      _L: /* CIL Label */ 
      if (build) {
        tmp___2 = is_complete(s);
        if (tmp___2) {
          tmp___1 = malloc(sizeof(mDNSservice_t ));
          p = (mDNSservice_t *)tmp___1;
          p->host = s->host;
          p->name = strdup((char const   *)s->name);
          p->hostname = strdup((char const   *)s->hostname);
          p->addr = s->addr;
          p->port = s->port;
          p->since = now - s->seen;
          p->expired = (_Bool)1;
          mdns_parse_txt(s->txt, s->txt_length, p);
          insert_item((item_t *)p, (item_t **)(& services));
        }
      }
    }
    if (build) {
      tmp___4 = is_complete(s);
      if (tmp___4) {
        if ((unsigned int )s->status != 0U) {
          tmp___3 = malloc(sizeof(mDNSservice_t ));
          p___0 = (mDNSservice_t *)tmp___3;
          p___0->host = s->host;
          p___0->name = strdup((char const   *)s->name);
          p___0->hostname = strdup((char const   *)s->hostname);
          p___0->addr = s->addr;
          p___0->port = s->port;
          p___0->since = now - s->seen;
          p___0->expired = (_Bool)0;
          mdns_parse_txt(s->txt, s->txt_length, p___0);
          insert_item((item_t *)p___0, (item_t **)(& services));
          s->status = (enum __anonenum_status_277728880 )0;
        }
      }
    }
    if (ptr_expired) {
      if (srv_expired) {
        if (txt_expired) {
          remove_item___0((item_t *)s, (item_t **)(& context->slist));
          free_s(s);
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      if (ptr_expired) {
        if (s->eol[0]) {
          s->eol[0] = (uint32_t )0;
          s->status = (enum __anonenum_status_277728880 )2;
        }
      }
      if (srv_expired) {
        if (s->eol[1]) {
          s->eol[1] = (uint32_t )0;
          if (s->hostname) {
            free((void *)s->hostname);
          }
          s->port = (uint16_t )0;
          s->hostname = (char *)((void *)0);
          s->status = (enum __anonenum_status_277728880 )2;
        }
      }
      if (txt_expired) {
        if (s->eol[2]) {
          s->eol[2] = (uint32_t )0;
          if (s->txt) {
            free((void *)s->txt);
          }
          s->txt_length = 0;
          s->txt = (char *)((void *)0);
          s->status = (enum __anonenum_status_277728880 )2;
        }
      }
      if (a_expired) {
        s->addr.s_addr = (in_addr_t )0;
        s->status = (enum __anonenum_status_277728880 )2;
      }
    }
    s = next___0;
  }
  return (services);
}
}
struct mDNShandle_s *init_mDNS(int dbg , struct in_addr host ) 
{ 
  int sock ;
  int res ;
  struct ip_mreq mreq ;
  struct sockaddr_in addr ;
  socklen_t addrlen ;
  int enable ;
  char param ;
  mDNShandle_t *handle ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  uint32_t tmp___7 ;

  {
  enable = 1;
  debug_mode = dbg;
  debug("Opening socket\n");
  sock = socket(2, 2, 0);
  if (sock < 0) {
    debug("error opening socket");
    return ((struct mDNShandle_s *)((void *)0));
  }
  param = (char)32;
  tmp = setsockopt(sock, 0, 33, (void const   *)((void *)(& param)), (socklen_t )sizeof(param));
  if (tmp < 0) {
    printf((char const   * __restrict  )"error setting multicast TTL");
    return ((struct mDNShandle_s *)((void *)0));
  }
  tmp___0 = setsockopt(sock, 1, 2, (void const   *)((void *)(& enable)), (socklen_t )sizeof(enable));
  if (tmp___0 < 0) {
    debug("error setting reuseaddr");
    return ((struct mDNShandle_s *)((void *)0));
  }
  param = (char)1;
  tmp___1 = setsockopt(sock, 0, 34, (void const   *)((void *)(& param)), (socklen_t )sizeof(param));
  if (tmp___1 < 0) {
    debug("error seeting multicast_loop");
    return ((struct mDNShandle_s *)((void *)0));
  }
  enable = (int )sizeof(enable);
  tmp___3 = getsockopt(sock, 1, 15, (void * __restrict  )((void *)(& enable)), (socklen_t * __restrict  )((void *)(& enable)));
  if (! tmp___3) {
    enable = 1;
    tmp___2 = setsockopt(sock, 1, 15, (void const   *)((void *)(& enable)), (socklen_t )sizeof(enable));
    if (tmp___2 < 0) {
      debug("error setting reuseport");
    }
  }
  memset((void *)(& addr), 0, sizeof(addr));
  addr.sin_family = (sa_family_t )2;
  addr.sin_port = __bswap_16((__uint16_t )5353);
  addr.sin_addr.s_addr = (in_addr_t )0;
  addrlen = (socklen_t )sizeof(addr);
  res = bind(sock, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& addr)),
             addrlen);
  if (res < 0) {
    debug("error binding socket");
    return ((struct mDNShandle_s *)((void *)0));
  }
  memset((void *)(& mreq), 0, sizeof(mreq));
  mreq.imr_multiaddr.s_addr = inet_addr("224.0.0.251");
  mreq.imr_interface.s_addr = host.s_addr;
  tmp___4 = setsockopt(sock, 0, 32, (void const   *)((void *)(& mreq.imr_interface.s_addr)),
                       (socklen_t )sizeof(mreq.imr_interface.s_addr));
  if (tmp___4 < 0) {
    debug("bound to if failed");
    return ((struct mDNShandle_s *)((void *)0));
  }
  debug("Setting socket options for multicast\n");
  tmp___5 = setsockopt(sock, 0, 35, (void const   *)((void *)(& mreq)), (socklen_t )sizeof(mreq));
  if (tmp___5 < 0) {
    debug("setsockopt failed");
    return ((struct mDNShandle_s *)((void *)0));
  }
  tmp___6 = calloc((size_t )1, sizeof(mDNShandle_t ));
  handle = (mDNShandle_t *)tmp___6;
  handle->sock = sock;
  handle->state = (enum __anonenum_state_567020907 )0;
  tmp___7 = gettime();
  handle->last = tmp___7 - 3600U;
  return (handle);
}
}
void control_mDNS(struct mDNShandle_s *handle , mDNScontrol_e request ) 
{ 


  {
  if (! handle) {
    return;
  }
  if ((unsigned int )handle->state == 1U) {
    handle->control = request;
  } else
  if ((unsigned int )request == 1U) {
    clear_context(& handle->context);
  }
  return;
}
}
void close_mDNS(struct mDNShandle_s *handle ) 
{ 


  {
  if (! handle) {
    return;
  }
  if ((unsigned int )handle->state == 0U) {
    clear_context(& handle->context);
    close(handle->sock);
    handle->sock = -1;
    free((void *)handle);
  } else {
    handle->state = (enum __anonenum_state_567020907 )0;
  }
  return;
}
}
static void clear_context(struct context_s *context ) 
{ 


  {
  clear_list___0((item_t *)((void *)context->alist), (void (*)(void * ))(& free_a));
  clear_list___0((item_t *)((void *)context->slist), (void (*)(void * ))(& free_s));
  context->slist = (slist_t *)((void *)0);
  context->alist = (alist_t *)((void *)0);
  return;
}
}
static void free_item_mDNS(mDNSservice_t *slist ) 
{ 
  int i ;

  {
  free((void *)slist->name);
  free((void *)slist->hostname);
  i = 0;
  while (i < slist->attr_count) {
    if ((slist->attr + i)->name) {
      free((void *)(slist->attr + i)->name);
    }
    if ((slist->attr + i)->value) {
      free((void *)(slist->attr + i)->value);
    }
    i ++;
  }
  free((void *)slist->attr);
  free((void *)slist);
  return;
}
}
void free_list_mDNS(mDNSservice_t *slist ) 
{ 


  {
  clear_list___0((item_t *)((void *)slist), (void (*)(void * ))(& free_item_mDNS));
  return;
}
}
mDNSservice_t *get_list_mDNS(struct mDNShandle_s *handle ) 
{ 
  slist_t *s ;
  mDNSservice_t *services ;
  mDNSservice_t *p ;
  void *tmp ;
  int tmp___0 ;

  {
  services = (mDNSservice_t *)((void *)0);
  s = handle->context.slist;
  while (s) {
    tmp___0 = is_complete(s);
    if (tmp___0) {
      tmp = malloc(sizeof(mDNSservice_t ));
      p = (mDNSservice_t *)tmp;
      p->name = strdup((char const   *)s->name);
      p->hostname = strdup((char const   *)s->hostname);
      p->addr = s->addr;
      p->port = s->port;
      p->expired = (_Bool)0;
      mdns_parse_txt(s->txt, s->txt_length, p);
      insert_item((item_t *)s, (item_t **)(& services));
    }
    s = s->next;
  }
  return (services);
}
}
_Bool query_mDNS(struct mDNShandle_s *handle , char *query , int ttl , int runtime ,
                 mdns_callback_t *callback , void *cookie ) 
{ 
  struct sockaddr_in addr ;
  socklen_t addrlen ;
  int res ;
  int parsed ;
  char *recvdata ;
  fd_set active_fd_set ;
  fd_set read_fd_set ;
  fd_set except_fd_set ;
  mDNSservice_t *slist ;
  uint32_t now ;
  _Bool stop ;
  _Bool rc ;
  uint32_t tmp ;
  void *tmp___0 ;
  int __d0 ;
  int __d1 ;
  struct timeval sel_time ;
  ssize_t tmp___1 ;
  char *tmp___2 ;
  int resp ;
  mDNSMessage msg ;
  _Bool tmp___3 ;

  {
  stop = (_Bool)0;
  rc = (_Bool)1;
  if (! handle) {
    return ((_Bool)0);
  } else
  if (handle->sock < 0) {
    return ((_Bool)0);
  }
  if ((int )*(query + 0) != 95) {
    debug("only service queries currently supported");
    return ((_Bool)0);
  }
  if (runtime) {
    tmp = gettime();
    runtime = (int )((uint32_t )runtime + tmp);
  }
  addr.sin_family = (sa_family_t )2;
  addr.sin_port = __bswap_16((__uint16_t )5353);
  addr.sin_addr.s_addr = inet_addr("224.0.0.251");
  addrlen = (socklen_t )sizeof(addr);
  tmp___0 = malloc((size_t )32768);
  recvdata = (char *)tmp___0;
  if (! recvdata) {
    return ((_Bool)0);
  }
  while (1) {
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& active_fd_set.fds_bits[0]): "memory");
    break;
  }
  active_fd_set.fds_bits[handle->sock / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << handle->sock % (8 * (int )sizeof(__fd_mask )));
  debug("Entering main loop\n");
  handle->context.query = query;
  handle->context.ttl = (uint32_t )ttl;
  handle->state = (enum __anonenum_state_567020907 )1;
  while (1) {
    sel_time.tv_sec = (__time_t )0;
    sel_time.tv_usec = (__suseconds_t )50000;
    now = gettime();
    if ((handle->last + 20U) - now > 2147483647U) {
      send_query(handle->sock, handle->context.query, (uint16_t )12);
      handle->last = now;
    }
    read_fd_set = active_fd_set;
    except_fd_set = active_fd_set;
    res = select(handle->sock + 1, (fd_set * __restrict  )(& read_fd_set), (fd_set * __restrict  )((void *)0),
                 (fd_set * __restrict  )(& except_fd_set), (struct timeval * __restrict  )(& sel_time));
    if ((unsigned int )handle->state == 0U) {
      break;
    } else
    if ((unsigned int )handle->control == 2U) {
      break;
    } else
    if (runtime) {
      if (now > (uint32_t )runtime) {
        break;
      }
    }
    if ((unsigned int )handle->control == 1U) {
      clear_context(& handle->context);
      handle->control = (mDNScontrol_e )0;
      handle->last = now - 3600U;
    }
    if (res < 0) {
      rc = (_Bool)0;
      debug("Select error\n");
      break;
    }
    if (res == 0) {
      continue;
    }
    if ((except_fd_set.fds_bits[handle->sock / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << handle->sock % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      rc = (_Bool)0;
      debug("exception on socket");
      break;
    }
    debug("Receiving data\n");
    tmp___1 = recvfrom(handle->sock, (void * __restrict  )recvdata, (size_t )32768,
                       0, (struct sockaddr * __restrict  )((struct sockaddr *)(& addr)),
                       (socklen_t * __restrict  )(& addrlen));
    res = (int )tmp___1;
    if (res < 0) {
      rc = (_Bool)0;
      debug("error receiving");
      break;
    } else
    if (res == 0) {
      rc = (_Bool)0;
      debug("unknown error");
    }
    tmp___2 = inet_ntoa(addr.sin_addr);
    debug("Received %u bytes from %s\n", res, tmp___2);
    parsed = 0;
    debug("Attempting to parse received data\n");
    while (1) {
      resp = mdns_parse_message_net(addr.sin_addr, & handle->context, recvdata + parsed,
                                    res, & msg);
      if (resp <= 0) {
        break;
      }
      parsed += resp;
      debug("--Parsed %u bytes of %u received bytes\n", parsed, res);
      if (! (parsed < res)) {
        break;
      }
    }
    debug("Finished parsing received data\n");
    slist = build_update(& handle->context, (_Bool )((unsigned long )callback != (unsigned long )((void *)0)));
    if (slist) {
      if (callback) {
        tmp___3 = (*callback)(slist, cookie, & stop);
        if (! tmp___3) {
          free_list_mDNS(slist);
        }
      }
    }
    if (stop) {
      break;
    }
  }
  free((void *)recvdata);
  if ((unsigned int )handle->state == 0U) {
    clear_context(& handle->context);
    close(handle->sock);
    handle->sock = -1;
    free((void *)handle);
  } else {
    handle->control = (mDNScontrol_e )0;
    handle->state = (enum __anonenum_state_567020907 )0;
  }
  return (rc);
}
}
#pragma merger("0","/tmp/cil-kVzQMUbS.i","-Wall,-fPIC,-ggdb,-O2,-m64,-fdata-sections,-ffunction-sections")
struct mdns_pkt *mdns_parse_pkt(uint8_t *pkt_buf , size_t pkt_len ) ;
void mdns_init_reply(struct mdns_pkt *pkt , uint16_t id ) ;
size_t mdns_encode_pkt(struct mdns_pkt *answer , uint8_t *pkt_buf , size_t pkt_len ) ;
void mdns_pkt_destroy(struct mdns_pkt *p ) ;
void rr_group_destroy(struct rr_group *group ) ;
struct rr_group *rr_group_find(struct rr_group *g , uint8_t *name ) ;
struct rr_entry *rr_entry_find(struct rr_list *rr_list , uint8_t *name , uint16_t type ) ;
struct rr_entry *rr_entry_match(struct rr_list *rr_list , struct rr_entry *entry ) ;
void rr_entry_destroy(struct rr_entry *rr ) ;
struct rr_entry *rr_entry_remove(struct rr_group *group , struct rr_entry *entry ,
                                 enum rr_type type ) ;
void rr_group_add(struct rr_group **group , struct rr_entry *rr ) ;
void rr_group_clean(struct rr_group **head ) ;
int rr_list_count(struct rr_list *rr ) ;
int rr_list_append(struct rr_list **rr_head , struct rr_entry *rr ) ;
struct rr_entry *rr_list_remove(struct rr_list **rr_head , struct rr_entry *rr ) ;
void rr_list_destroy(struct rr_list *rr , char destroy_items ) ;
struct rr_entry *rr_create_ptr(uint8_t *name , struct rr_entry *d_rr ) ;
struct rr_entry *rr_create_srv(uint8_t *name , uint16_t port , uint8_t *target ) ;
struct rr_entry *rr_create_aaaa(uint8_t *name , struct in6_addr *addr ) ;
struct rr_entry *rr_create_a(uint8_t *name , struct in_addr addr ) ;
struct rr_entry *rr_create(uint8_t *name , enum rr_type type ) ;
void rr_set_nsec(struct rr_entry *rr_nsec , enum rr_type type ) ;
void rr_add_txt(struct rr_entry *rr_txt , char const   *txt ) ;
char const   *rr_get_type_name(enum rr_type type ) ;
uint8_t *create_label(char const   *txt ) ;
uint8_t *create_nlabel(char const   *name ) ;
char *nlabel_to_str(uint8_t const   *name ) ;
uint8_t *dup_label(uint8_t const   *label ) ;
uint8_t *dup_nlabel(uint8_t const   *n ) ;
uint8_t *join_nlabel(uint8_t const   *n1 , uint8_t const   *n2 ) ;
__inline static int cmp_nlabel(uint8_t const   *L1 , uint8_t const   *L2 ) 
{ 
  int tmp ;

  {
  tmp = strcmp((char const   *)((char *)L1), (char const   *)((char *)L2));
  return (tmp);
}
}
uint8_t *dup_nlabel(uint8_t const   *n ) 
{ 
  char *tmp ;

  {
  tmp = strdup((char const   *)((char *)n));
  return ((uint8_t *)tmp);
}
}
uint8_t *dup_label(uint8_t const   *label ) 
{ 
  int len ;
  uint8_t *newlabel ;
  void *tmp ;

  {
  len = (int )((int const   )*label + 1);
  if (len > 63) {
    return ((uint8_t *)((void *)0));
  }
  tmp = malloc((size_t )(len + 1));
  newlabel = (uint8_t *)tmp;
  strncpy((char * __restrict  )((char *)newlabel), (char const   * __restrict  )((char *)label),
          (size_t )len);
  *(newlabel + len) = (uint8_t )'\000';
  return (newlabel);
}
}
uint8_t *join_nlabel(uint8_t const   *n1 , uint8_t const   *n2 ) 
{ 
  int len1 ;
  int len2 ;
  uint8_t *s ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  tmp = strlen((char const   *)((char *)n1));
  len1 = (int )tmp;
  tmp___0 = strlen((char const   *)((char *)n2));
  len2 = (int )tmp___0;
  tmp___1 = malloc((size_t )((len1 + len2) + 1));
  s = (uint8_t *)tmp___1;
  strncpy((char * __restrict  )((char *)s), (char const   * __restrict  )((char *)n1),
          (size_t )len1);
  strncpy((char * __restrict  )((char *)s + len1), (char const   * __restrict  )((char *)n2),
          (size_t )len2);
  *(s + (len1 + len2)) = (uint8_t )'\000';
  return (s);
}
}
char *nlabel_to_str(uint8_t const   *name ) 
{ 
  char *label ;
  char *labelp ;
  uint8_t const   *p ;
  size_t buf_len ;
  void *tmp ;
  uint8_t label_len___0 ;

  {
  buf_len = (size_t )256;
  tmp = malloc(buf_len);
  labelp = (char *)tmp;
  label = labelp;
  p = name;
  while (*p) {
    label_len___0 = (uint8_t )*p;
    if (buf_len <= (size_t )label_len___0) {
      break;
    }
    strncpy((char * __restrict  )labelp, (char const   * __restrict  )((char *)p + 1),
            (size_t )label_len___0);
    labelp += (int )label_len___0;
    *labelp = (char )'.';
    labelp ++;
    buf_len -= (size_t )((int )label_len___0 + 1);
    p += (int )label_len___0;
    p ++;
  }
  if (buf_len == 0UL) {
    labelp --;
  }
  *labelp = (char )'\000';
  return (label);
}
}
static size_t label_len(uint8_t *pkt_buf , size_t pkt_len , size_t off ) 
{ 
  uint8_t *p ;
  uint8_t *e ;
  size_t len ;

  {
  e = pkt_buf + pkt_len;
  len = (size_t )0;
  p = pkt_buf + off;
  while ((unsigned long )p < (unsigned long )e) {
    if ((int )*p == 0) {
      return (len + 1UL);
    } else
    if (((int )*p & 192) == 192) {
      return (len + 2UL);
    } else {
      len += (size_t )((int )*p + 1);
      p += (int )*p;
    }
    p ++;
  }
  return (len);
}
}
uint8_t *create_label(char const   *txt ) 
{ 
  int len ;
  uint8_t *s ;
  size_t tmp ;
  void *tmp___0 ;

  {
  tmp = strlen(txt);
  len = (int )tmp;
  if (len > 63) {
    return ((uint8_t *)((void *)0));
  }
  tmp___0 = malloc((size_t )(len + 2));
  s = (uint8_t *)tmp___0;
  *(s + 0) = (uint8_t )len;
  strncpy((char * __restrict  )((char *)s + 1), (char const   * __restrict  )txt,
          (size_t )len);
  *(s + (len + 1)) = (uint8_t )'\000';
  return (s);
}
}
uint8_t *create_nlabel(char const   *name ) 
{ 
  char *label ;
  char *p ;
  char *e ;
  char *lenpos ;
  int len ;
  size_t tmp ;
  void *tmp___0 ;
  char *dot ;
  void *tmp___1 ;

  {
  len = 0;
  tmp = strlen(name);
  len = (int )tmp;
  tmp___0 = malloc((size_t )((len + 1) + 1));
  label = (char *)tmp___0;
  if ((unsigned long )label == (unsigned long )((void *)0)) {
    return ((uint8_t *)((void *)0));
  }
  strncpy((char * __restrict  )(label + 1), (char const   * __restrict  )name, (size_t )len);
  *(label + (len + 1)) = (char )'\000';
  p = label;
  e = p + len;
  lenpos = p;
  while ((unsigned long )p < (unsigned long )e) {
    tmp___1 = memchr((void const   *)(p + 1), '.', (size_t )((e - p) - 1L));
    dot = (char *)tmp___1;
    *lenpos = (char)0;
    if ((unsigned long )dot == (unsigned long )((void *)0)) {
      dot = e + 1;
    }
    *lenpos = (char )((dot - p) - 1L);
    p = dot;
    lenpos = dot;
  }
  return ((uint8_t *)label);
}
}
static uint8_t *copy_label(uint8_t *pkt_buf , size_t pkt_len , size_t off ) 
{ 
  int len ;
  uint8_t *tmp ;

  {
  if (off > pkt_len) {
    return ((uint8_t *)((void *)0));
  }
  len = (int )*(pkt_buf + off) + 1;
  if (off + (size_t )len > pkt_len) {
    return ((uint8_t *)((void *)0));
  }
  tmp = dup_label((uint8_t const   *)(pkt_buf + off));
  return (tmp);
}
}
static uint8_t *uncompress_nlabel(uint8_t *pkt_buf , size_t pkt_len , size_t off ) 
{ 
  uint8_t *p ;
  uint8_t *e ;
  size_t len ;
  char *str___0 ;
  char *sp ;
  size_t llen ;
  uint8_t *p2 ;
  void *tmp ;
  size_t llen___0 ;
  uint8_t *p2___0 ;

  {
  e = pkt_buf + pkt_len;
  len = (size_t )0;
  if (off >= pkt_len) {
    return ((uint8_t *)((void *)0));
  }
  p = pkt_buf + off;
  while (1) {
    if (*p) {
      if (! ((unsigned long )p < (unsigned long )e)) {
        break;
      }
    } else {
      break;
    }
    llen = (size_t )0;
    if (((int )*p & 192) == 192) {
      p2 = pkt_buf + ((((int )*(p + 0) & -193) << 8) | (int )*(p + 1));
      llen = (size_t )((int )*p2 + 1);
      p = (p2 + llen) - 1;
    } else {
      llen = (size_t )((int )*p + 1);
      p += llen - 1UL;
    }
    len += llen;
    p ++;
  }
  tmp = malloc(len + 1UL);
  sp = (char *)tmp;
  str___0 = sp;
  if ((unsigned long )str___0 == (unsigned long )((void *)0)) {
    return ((uint8_t *)((void *)0));
  }
  p = pkt_buf + off;
  while (1) {
    if (*p) {
      if (! ((unsigned long )p < (unsigned long )e)) {
        break;
      }
    } else {
      break;
    }
    llen___0 = (size_t )0;
    if (((int )*p & 192) == 192) {
      p2___0 = pkt_buf + ((((int )*(p + 0) & -193) << 8) | (int )*(p + 1));
      llen___0 = (size_t )((int )*p2___0 + 1);
      strncpy((char * __restrict  )sp, (char const   * __restrict  )((char *)p2___0),
              llen___0);
      p = (p2___0 + llen___0) - 1;
    } else {
      llen___0 = (size_t )((int )*p + 1);
      strncpy((char * __restrict  )sp, (char const   * __restrict  )((char *)p), llen___0);
      p += llen___0 - 1UL;
    }
    sp += llen___0;
    p ++;
  }
  *sp = (char )'\000';
  return ((uint8_t *)str___0);
}
}
char const   *rr_get_type_name(enum rr_type type ) 
{ 


  {
  switch ((unsigned int )type) {
  case 1U: 
  return ("A");
  case 12U: 
  return ("PTR");
  case 16U: 
  return ("TXT");
  case 28U: 
  return ("AAAA");
  case 33U: 
  return ("SRV");
  case 47U: 
  return ("NSEC");
  case 255U: 
  return ("ANY");
  }
  return ((char const   *)((void *)0));
}
}
void rr_entry_destroy(struct rr_entry *rr ) 
{ 
  struct rr_data_txt *txt_rec ;
  struct rr_data_txt *next ;

  {
  switch ((unsigned int )rr->type) {
  case 12U: 
  if (rr->data.PTR.name) {
    free((void *)rr->data.PTR.name);
  }
  break;
  case 16U: 
  txt_rec = & rr->data.TXT;
  while (txt_rec) {
    next = txt_rec->next;
    if (txt_rec->txt) {
      free((void *)txt_rec->txt);
    }
    if ((unsigned long )txt_rec != (unsigned long )(& rr->data.TXT)) {
      free((void *)txt_rec);
    }
    txt_rec = next;
  }
  break;
  case 33U: 
  if (rr->data.SRV.target) {
    free((void *)rr->data.SRV.target);
  }
  break;
  case 28U: 
  if (rr->data.AAAA.addr) {
    free((void *)rr->data.AAAA.addr);
  }
  break;
  default: 
  break;
  }
  free((void *)rr->name);
  free((void *)rr);
  return;
}
}
void rr_list_destroy(struct rr_list *rr , char destroy_items ) 
{ 
  struct rr_list *rr_next ;

  {
  while (rr) {
    rr_next = rr->next;
    if (destroy_items) {
      rr_entry_destroy(rr->e);
    }
    free((void *)rr);
    rr = rr_next;
  }
  return;
}
}
int rr_list_count(struct rr_list *rr ) 
{ 
  int i ;

  {
  i = 0;
  while (rr) {
    i ++;
    rr = rr->next;
  }
  return (i);
}
}
struct rr_entry *rr_entry_remove(struct rr_group *group , struct rr_entry *entry ,
                                 enum rr_type type ) 
{ 
  struct rr_group *g ;
  struct rr_list *lrr ;
  struct rr_list *prr ;
  struct rr_entry *e ;

  {
  g = group;
  while (g) {
    lrr = g->rr;
    prr = (struct rr_list *)((void *)0);
    while (lrr) {
      if ((unsigned int )(lrr->e)->type == (unsigned int )type) {
        switch ((unsigned int )type) {
        case 12U: 
        if ((unsigned long )(lrr->e)->data.PTR.entry == (unsigned long )entry) {
          e = lrr->e;
          if ((unsigned long )prr == (unsigned long )((void *)0)) {
            g->rr = lrr->next;
          } else {
            prr->next = lrr->next;
          }
          free((void *)lrr);
          return (e);
        }
        break;
        default: 
        break;
        }
      }
      prr = lrr;
      lrr = lrr->next;
    }
    g = g->next;
  }
  return ((struct rr_entry *)((void *)0));
}
}
struct rr_entry *rr_list_remove(struct rr_list **rr_head , struct rr_entry *rr ) 
{ 
  struct rr_list *le ;
  struct rr_list *pe ;

  {
  le = *rr_head;
  pe = (struct rr_list *)((void *)0);
  while (le) {
    if ((unsigned long )le->e == (unsigned long )rr) {
      if ((unsigned long )pe == (unsigned long )((void *)0)) {
        *rr_head = le->next;
        free((void *)le);
        return (rr);
      } else {
        pe->next = le->next;
        free((void *)le);
        return (rr);
      }
    }
    pe = le;
    le = le->next;
  }
  return ((struct rr_entry *)((void *)0));
}
}
void rr_group_clean(struct rr_group **head ) 
{ 
  struct rr_group *le ;
  struct rr_group *pe ;

  {
  le = *head;
  pe = (struct rr_group *)((void *)0);
  while (le) {
    if ((unsigned long )le->rr == (unsigned long )((void *)0)) {
      free((void *)le->name);
      if ((unsigned long )pe == (unsigned long )((void *)0)) {
        *head = le->next;
        free((void *)le);
        le = *head;
      } else {
        pe->next = le->next;
        free((void *)le);
        le = pe->next;
      }
    } else {
      pe = le;
      le = le->next;
    }
  }
  return;
}
}
int rr_list_append(struct rr_list **rr_head , struct rr_entry *rr ) 
{ 
  struct rr_list *node ;
  void *tmp ;
  struct rr_list *e ;
  struct rr_list *taile ;

  {
  tmp = malloc(sizeof(struct rr_list ));
  node = (struct rr_list *)tmp;
  node->e = rr;
  node->next = (struct rr_list *)((void *)0);
  if ((unsigned long )*rr_head == (unsigned long )((void *)0)) {
    *rr_head = node;
  } else {
    e = *rr_head;
    while (e) {
      if ((unsigned long )e->e == (unsigned long )rr) {
        free((void *)node);
        return (0);
      }
      if ((unsigned long )e->next == (unsigned long )((void *)0)) {
        taile = e;
      }
      e = e->next;
    }
    taile->next = node;
  }
  return (1);
}
}
struct rr_entry *rr_create_a(uint8_t *name , struct in_addr addr ) 
{ 
  struct rr_entry *rr ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct rr_entry ));
  rr = (struct rr_entry *)tmp;
  memset((void *)rr, 0, sizeof(struct rr_entry ));
  rr->name = name;
  rr->type = (enum rr_type )1;
  rr->ttl = (uint32_t )4500;
  rr->cache_flush = (char)1;
  rr->rr_class = (uint16_t )1;
  rr->data.A.addr = addr.s_addr;
  rr->ttl = (uint32_t )120;
  return (rr);
}
}
struct rr_entry *rr_create_aaaa(uint8_t *name , struct in6_addr *addr ) 
{ 
  struct rr_entry *rr ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct rr_entry ));
  rr = (struct rr_entry *)tmp;
  memset((void *)rr, 0, sizeof(struct rr_entry ));
  rr->name = name;
  rr->type = (enum rr_type )28;
  rr->ttl = (uint32_t )4500;
  rr->cache_flush = (char)1;
  rr->rr_class = (uint16_t )1;
  rr->data.AAAA.addr = addr;
  rr->ttl = (uint32_t )120;
  return (rr);
}
}
struct rr_entry *rr_create_srv(uint8_t *name , uint16_t port , uint8_t *target ) 
{ 
  struct rr_entry *rr ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct rr_entry ));
  rr = (struct rr_entry *)tmp;
  memset((void *)rr, 0, sizeof(struct rr_entry ));
  rr->name = name;
  rr->type = (enum rr_type )33;
  rr->ttl = (uint32_t )4500;
  rr->cache_flush = (char)1;
  rr->rr_class = (uint16_t )1;
  rr->data.SRV.port = port;
  rr->data.SRV.target = target;
  rr->ttl = (uint32_t )120;
  return (rr);
}
}
struct rr_entry *rr_create_ptr(uint8_t *name , struct rr_entry *d_rr ) 
{ 
  struct rr_entry *rr ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct rr_entry ));
  rr = (struct rr_entry *)tmp;
  memset((void *)rr, 0, sizeof(struct rr_entry ));
  rr->name = name;
  rr->type = (enum rr_type )12;
  rr->ttl = (uint32_t )4500;
  rr->cache_flush = (char)1;
  rr->rr_class = (uint16_t )1;
  rr->cache_flush = (char)0;
  rr->data.PTR.entry = d_rr;
  rr->ttl = (uint32_t )120;
  return (rr);
}
}
struct rr_entry *rr_create(uint8_t *name , enum rr_type type ) 
{ 
  struct rr_entry *rr ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct rr_entry ));
  rr = (struct rr_entry *)tmp;
  memset((void *)rr, 0, sizeof(struct rr_entry ));
  rr->name = name;
  rr->type = type;
  rr->ttl = (uint32_t )4500;
  rr->cache_flush = (char)1;
  rr->rr_class = (uint16_t )1;
  return (rr);
}
}
void rr_set_nsec(struct rr_entry *rr_nsec , enum rr_type type ) 
{ 


  {
  rr_nsec->data.NSEC.bitmap[(unsigned int )type / 8U] = (uint8_t )(1 << (7U - (unsigned int )type % 8U));
  return;
}
}
void rr_add_txt(struct rr_entry *rr_txt , char const   *txt ) 
{ 
  struct rr_data_txt *txt_rec ;
  void *tmp ;

  {
  txt_rec = & rr_txt->data.TXT;
  if ((unsigned long )txt_rec->txt == (unsigned long )((void *)0)) {
    txt_rec->txt = create_label(txt);
    return;
  }
  while (txt_rec->next) {
    txt_rec = txt_rec->next;
  }
  tmp = malloc(sizeof(struct rr_data_txt ));
  txt_rec->next = (struct rr_data_txt *)tmp;
  txt_rec = txt_rec->next;
  txt_rec->txt = create_label(txt);
  txt_rec->next = (struct rr_data_txt *)((void *)0);
  return;
}
}
void rr_group_add(struct rr_group **group , struct rr_entry *rr ) 
{ 
  struct rr_group *g ;
  void *tmp ;

  {
  if (*group) {
    g = rr_group_find(*group, rr->name);
    if (g) {
      rr_list_append(& g->rr, rr);
      return;
    }
  }
  tmp = malloc(sizeof(struct rr_group ));
  g = (struct rr_group *)tmp;
  memset((void *)g, 0, sizeof(struct rr_group ));
  g->name = dup_nlabel((uint8_t const   *)rr->name);
  rr_list_append(& g->rr, rr);
  g->next = *group;
  *group = g;
  return;
}
}
struct rr_group *rr_group_find(struct rr_group *g , uint8_t *name ) 
{ 
  int tmp ;

  {
  while (g) {
    tmp = cmp_nlabel((uint8_t const   *)g->name, (uint8_t const   *)name);
    if (tmp == 0) {
      return (g);
    }
    g = g->next;
  }
  return ((struct rr_group *)((void *)0));
}
}
struct rr_entry *rr_entry_find(struct rr_list *rr_list , uint8_t *name , uint16_t type ) 
{ 
  struct rr_list *rr ;
  int tmp ;

  {
  rr = rr_list;
  while (rr) {
    if ((unsigned int )(rr->e)->type == (unsigned int )type) {
      tmp = cmp_nlabel((uint8_t const   *)(rr->e)->name, (uint8_t const   *)name);
      if (tmp == 0) {
        return (rr->e);
      }
    }
    rr = rr->next;
  }
  return ((struct rr_entry *)((void *)0));
}
}
struct rr_entry *rr_entry_match(struct rr_list *rr_list , struct rr_entry *entry ) 
{ 
  struct rr_list *rr ;
  uint8_t *tmp ;
  uint8_t *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  rr = rr_list;
  while (rr) {
    if ((unsigned int )(rr->e)->type == (unsigned int )entry->type) {
      tmp___2 = cmp_nlabel((uint8_t const   *)(rr->e)->name, (uint8_t const   *)entry->name);
      if (tmp___2 == 0) {
        if ((unsigned int )entry->type != 12U) {
          return (rr->e);
        } else {
          if ((unsigned long )(rr->e)->data.PTR.name != (unsigned long )((void *)0)) {
            tmp = (rr->e)->data.PTR.name;
          } else {
            tmp = ((rr->e)->data.PTR.entry)->name;
          }
          if ((unsigned long )entry->data.PTR.name != (unsigned long )((void *)0)) {
            tmp___0 = entry->data.PTR.name;
          } else {
            tmp___0 = (entry->data.PTR.entry)->name;
          }
          tmp___1 = cmp_nlabel((uint8_t const   *)tmp___0, (uint8_t const   *)tmp);
          if (tmp___1 == 0) {
            return (rr->e);
          }
        }
      }
    }
    rr = rr->next;
  }
  return ((struct rr_entry *)((void *)0));
}
}
void rr_group_destroy(struct rr_group *group ) 
{ 
  struct rr_group *g ;
  struct rr_group *nextg ;

  {
  g = group;
  while (g) {
    nextg = g->next;
    free((void *)g->name);
    rr_list_destroy(g->rr, (char)1);
    free((void *)g);
    g = nextg;
  }
  return;
}
}
uint8_t *mdns_write_u16(uint8_t *ptr , uint16_t const   v ) 
{ 
  uint8_t *tmp ;
  uint8_t *tmp___0 ;

  {
  tmp = ptr;
  ptr ++;
  *tmp = (uint8_t )((int )((uint8_t )((int const   )v >> 8)) & 255);
  tmp___0 = ptr;
  ptr ++;
  *tmp___0 = (uint8_t )((int )((uint8_t )((int const   )v)) & 255);
  return (ptr);
}
}
uint8_t *mdns_write_u32(uint8_t *ptr , uint32_t const   v ) 
{ 
  uint8_t *tmp ;
  uint8_t *tmp___0 ;
  uint8_t *tmp___1 ;
  uint8_t *tmp___2 ;

  {
  tmp = ptr;
  ptr ++;
  *tmp = (uint8_t )((int )((uint8_t )(v >> 24)) & 255);
  tmp___0 = ptr;
  ptr ++;
  *tmp___0 = (uint8_t )((int )((uint8_t )(v >> 16)) & 255);
  tmp___1 = ptr;
  ptr ++;
  *tmp___1 = (uint8_t )((int )((uint8_t )(v >> 8)) & 255);
  tmp___2 = ptr;
  ptr ++;
  *tmp___2 = (uint8_t )((int )((uint8_t )v) & 255);
  return (ptr);
}
}
uint16_t mdns_read_u16(uint8_t const   *ptr ) 
{ 


  {
  return ((uint16_t )((((int const   )*(ptr + 0) & 255) << 8) | ((int const   )*(ptr + 1) & 255)));
}
}
uint32_t mdns_read_u32(uint8_t const   *ptr ) 
{ 


  {
  return ((uint32_t )((((((int const   )*(ptr + 0) & 255) << 24) | (((int const   )*(ptr + 1) & 255) << 16)) | (((int const   )*(ptr + 2) & 255) << 8)) | ((int const   )*(ptr + 3) & 255)));
}
}
void mdns_init_reply(struct mdns_pkt *pkt , uint16_t id ) 
{ 


  {
  pkt->id = id;
  pkt->flags = (uint16_t )((1 << 15) | (1 << 10));
  rr_list_destroy(pkt->rr_qn, (char)0);
  rr_list_destroy(pkt->rr_ans, (char)0);
  rr_list_destroy(pkt->rr_auth, (char)0);
  rr_list_destroy(pkt->rr_add, (char)0);
  pkt->rr_qn = (struct rr_list *)((void *)0);
  pkt->rr_ans = (struct rr_list *)((void *)0);
  pkt->rr_auth = (struct rr_list *)((void *)0);
  pkt->rr_add = (struct rr_list *)((void *)0);
  pkt->num_qn = (uint16_t )0;
  pkt->num_ans_rr = (uint16_t )0;
  pkt->num_auth_rr = (uint16_t )0;
  pkt->num_add_rr = (uint16_t )0;
  return;
}
}
void mdns_pkt_destroy(struct mdns_pkt *p ) 
{ 


  {
  rr_list_destroy(p->rr_qn, (char)1);
  rr_list_destroy(p->rr_ans, (char)1);
  rr_list_destroy(p->rr_auth, (char)1);
  rr_list_destroy(p->rr_add, (char)1);
  free((void *)p);
  return;
}
}
static size_t mdns_parse_qn(uint8_t *pkt_buf , size_t pkt_len , size_t off , struct mdns_pkt *pkt ) 
{ 
  uint8_t const   *p ;
  struct rr_entry *rr ;
  uint8_t *name ;
  void *tmp ;
  size_t tmp___0 ;
  uint16_t tmp___1 ;
  uint16_t tmp___2 ;

  {
  p = (uint8_t const   *)(pkt_buf + off);
  tmp = malloc(sizeof(struct rr_entry ));
  rr = (struct rr_entry *)tmp;
  memset((void *)rr, 0, sizeof(struct rr_entry ));
  name = uncompress_nlabel(pkt_buf, pkt_len, off);
  tmp___0 = label_len(pkt_buf, pkt_len, off);
  p += tmp___0;
  rr->name = name;
  tmp___1 = mdns_read_u16(p);
  rr->type = (enum rr_type )tmp___1;
  p += sizeof(uint16_t );
  rr->unicast_query = (char )(((int const   )*p & 128) == 128);
  tmp___2 = mdns_read_u16(p);
  rr->rr_class = (uint16_t )((int )tmp___2 & -129);
  p += sizeof(uint16_t );
  rr_list_append(& pkt->rr_qn, rr);
  return ((size_t )(p - (uint8_t const   *)(pkt_buf + off)));
}
}
static size_t mdns_parse_rr___0(uint8_t *pkt_buf , size_t pkt_len , size_t off , struct mdns_pkt *pkt ) 
{ 
  uint8_t const   *p ;
  uint8_t const   *e ;
  struct rr_entry *rr ;
  uint8_t *name ;
  size_t rr_data_len ;
  struct rr_data_txt *txt_rec ;
  int parse_error ;
  void *tmp ;
  size_t tmp___0 ;
  uint16_t tmp___1 ;
  uint16_t tmp___2 ;
  uint16_t tmp___3 ;
  uint32_t tmp___4 ;
  int i ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
  p = (uint8_t const   *)(pkt_buf + off);
  e = (uint8_t const   *)(pkt_buf + pkt_len);
  rr_data_len = (size_t )0;
  parse_error = 0;
  if (off > pkt_len) {
    return ((size_t )0);
  }
  tmp = malloc(sizeof(struct rr_entry ));
  rr = (struct rr_entry *)tmp;
  memset((void *)rr, 0, sizeof(struct rr_entry ));
  name = uncompress_nlabel(pkt_buf, pkt_len, off);
  tmp___0 = label_len(pkt_buf, pkt_len, off);
  p += tmp___0;
  rr->name = name;
  tmp___1 = mdns_read_u16(p);
  rr->type = (enum rr_type )tmp___1;
  p += sizeof(uint16_t );
  rr->cache_flush = (char )(((int const   )*p & 128) == 128);
  tmp___2 = mdns_read_u16(p);
  rr->rr_class = (uint16_t )((int )tmp___2 & -129);
  p += sizeof(uint16_t );
  rr->ttl = mdns_read_u32(p);
  p += sizeof(uint32_t );
  tmp___3 = mdns_read_u16(p);
  rr_data_len = (size_t )tmp___3;
  p += sizeof(uint16_t );
  if ((unsigned long )(p + rr_data_len) > (unsigned long )e) {
    rr_entry_destroy(rr);
    return ((size_t )0);
  }
  e = p + rr_data_len;
  switch ((unsigned int )rr->type) {
  case 1U: 
  if (rr_data_len < sizeof(uint32_t )) {
    parse_error = 1;
    break;
  }
  tmp___4 = mdns_read_u32(p);
  rr->data.A.addr = __bswap_32(tmp___4);
  p += sizeof(uint32_t );
  break;
  case 28U: 
  if (rr_data_len < sizeof(struct in6_addr )) {
    parse_error = 1;
    break;
  }
  tmp___5 = malloc(sizeof(struct in6_addr ));
  rr->data.AAAA.addr = (struct in6_addr *)tmp___5;
  i = 0;
  while ((unsigned long )i < sizeof(struct in6_addr )) {
    (rr->data.AAAA.addr)->__in6_u.__u6_addr8[i] = (uint8_t )*(p + i);
    i ++;
  }
  p += sizeof(struct in6_addr );
  break;
  case 12U: 
  rr->data.PTR.name = uncompress_nlabel(pkt_buf, pkt_len, (size_t )(p - (uint8_t const   *)pkt_buf));
  if ((unsigned long )rr->data.PTR.name == (unsigned long )((void *)0)) {
    parse_error = 1;
    break;
  }
  p += rr_data_len;
  break;
  case 16U: 
  txt_rec = & rr->data.TXT;
  if (rr_data_len == 0UL) {
    txt_rec->txt = create_label("");
    break;
  }
  while (1) {
    txt_rec->txt = copy_label(pkt_buf, pkt_len, (size_t )(p - (uint8_t const   *)pkt_buf));
    if ((unsigned long )txt_rec->txt == (unsigned long )((void *)0)) {
      parse_error = 1;
      break;
    }
    p += (int )*(txt_rec->txt + 0) + 1;
    if ((unsigned long )p >= (unsigned long )e) {
      break;
    }
    tmp___6 = malloc(sizeof(struct rr_data_txt ));
    txt_rec->next = (struct rr_data_txt *)tmp___6;
    txt_rec = txt_rec->next;
    txt_rec->next = (struct rr_data_txt *)((void *)0);
  }
  break;
  default: 
  p = e;
  }
  if (parse_error) {
    rr_entry_destroy(rr);
    return ((size_t )0);
  }
  rr_list_append(& pkt->rr_ans, rr);
  return ((size_t )(p - (uint8_t const   *)(pkt_buf + off)));
}
}
struct mdns_pkt *mdns_parse_pkt(uint8_t *pkt_buf , size_t pkt_len ) 
{ 
  uint8_t *p ;
  size_t off ;
  struct mdns_pkt *pkt ;
  int i ;
  void *tmp ;
  size_t l ;
  size_t tmp___0 ;
  size_t l___0 ;
  size_t tmp___1 ;

  {
  p = pkt_buf;
  if (pkt_len < 12UL) {
    return ((struct mdns_pkt *)((void *)0));
  }
  tmp = malloc(sizeof(struct mdns_pkt ));
  pkt = (struct mdns_pkt *)tmp;
  memset((void *)pkt, 0, sizeof(struct mdns_pkt ));
  pkt->id = mdns_read_u16((uint8_t const   *)p);
  p += sizeof(uint16_t );
  pkt->flags = mdns_read_u16((uint8_t const   *)p);
  p += sizeof(uint16_t );
  pkt->num_qn = mdns_read_u16((uint8_t const   *)p);
  p += sizeof(uint16_t );
  pkt->num_ans_rr = mdns_read_u16((uint8_t const   *)p);
  p += sizeof(uint16_t );
  pkt->num_auth_rr = mdns_read_u16((uint8_t const   *)p);
  p += sizeof(uint16_t );
  pkt->num_add_rr = mdns_read_u16((uint8_t const   *)p);
  p += sizeof(uint16_t );
  off = (size_t )(p - pkt_buf);
  i = 0;
  while (i < (int )pkt->num_qn) {
    tmp___0 = mdns_parse_qn(pkt_buf, pkt_len, off, pkt);
    l = tmp___0;
    if (! l) {
      mdns_pkt_destroy(pkt);
      return ((struct mdns_pkt *)((void *)0));
    }
    off += l;
    i ++;
  }
  i = 0;
  while (i < (int )pkt->num_ans_rr) {
    tmp___1 = mdns_parse_rr___0(pkt_buf, pkt_len, off, pkt);
    l___0 = tmp___1;
    if (! l___0) {
      mdns_pkt_destroy(pkt);
      return ((struct mdns_pkt *)((void *)0));
    }
    off += l___0;
    i ++;
  }
  return (pkt);
}
}
static size_t mdns_encode_name(uint8_t *pkt_buf , size_t pkt_len , size_t off , uint8_t const   *name ,
                               struct name_comp *comp ) 
{ 
  struct name_comp *c ;
  struct name_comp *c_tail ;
  uint8_t *p ;
  size_t len ;
  int segment_len ;
  struct name_comp *new_c ;
  int tmp ;
  void *tmp___0 ;

  {
  c_tail = (struct name_comp *)((void *)0);
  p = pkt_buf + off;
  len = (size_t )0;
  if (name) {
    while (*name) {
      c = comp;
      while (c) {
        tmp = cmp_nlabel(name, (uint8_t const   *)c->label);
        if (tmp == 0) {
          mdns_write_u16(p, (uint16_t const   )(49152UL | (c->pos & 0xffffffffffff3fffUL)));
          return (len + sizeof(uint16_t ));
        }
        if ((unsigned long )c->next == (unsigned long )((void *)0)) {
          c_tail = c;
        }
        c = c->next;
      }
      segment_len = (int )((int const   )*name + 1);
      strncpy((char * __restrict  )((char *)p), (char const   * __restrict  )((char *)name),
              (size_t )segment_len);
      tmp___0 = malloc(sizeof(struct name_comp ));
      new_c = (struct name_comp *)tmp___0;
      memset((void *)new_c, 0, sizeof(struct name_comp ));
      new_c->label = (uint8_t *)name;
      new_c->pos = (size_t )(p - pkt_buf);
      c_tail->next = new_c;
      p += segment_len;
      len += (size_t )segment_len;
      name += segment_len;
    }
  }
  *p = (uint8_t )'\000';
  len ++;
  return (len);
}
}
static size_t mdns_encode_rr(uint8_t *pkt_buf , size_t pkt_len , size_t off , struct rr_entry *rr ,
                             struct name_comp *comp ) 
{ 
  uint8_t *p ;
  uint8_t *p_data ;
  size_t l ;
  struct rr_data_txt *txt_rec ;
  uint8_t *label ;
  int i ;
  __uint32_t tmp ;
  uint8_t *tmp___0 ;
  size_t tmp___1 ;
  int len ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  uint8_t *tmp___4 ;
  uint8_t *tmp___5 ;
  uint8_t *tmp___6 ;

  {
  p = pkt_buf + off;
  l = mdns_encode_name(pkt_buf, pkt_len, off, (uint8_t const   *)rr->name, comp);
  p += l;
  p = mdns_write_u16(p, (uint16_t const   )rr->type);
  p = mdns_write_u16(p, (uint16_t const   )(((int )rr->rr_class & -32769) | ((int )rr->cache_flush << 15)));
  p = mdns_write_u32(p, (uint32_t const   )rr->ttl);
  p += sizeof(uint16_t );
  p_data = p;
  switch ((unsigned int )rr->type) {
  case 1U: 
  tmp = __bswap_32(rr->data.A.addr);
  p = mdns_write_u32(p, (uint32_t const   )tmp);
  break;
  case 28U: 
  i = 0;
  while ((unsigned long )i < sizeof(struct in6_addr )) {
    tmp___0 = p;
    p ++;
    *tmp___0 = (rr->data.AAAA.addr)->__in6_u.__u6_addr8[i];
    i ++;
  }
  break;
  case 12U: 
  if (rr->data.PTR.name) {
    label = rr->data.PTR.name;
  } else {
    label = (rr->data.PTR.entry)->name;
  }
  tmp___1 = mdns_encode_name(pkt_buf, pkt_len, (size_t )(p - pkt_buf), (uint8_t const   *)label,
                             comp);
  p += tmp___1;
  break;
  case 16U: 
  txt_rec = & rr->data.TXT;
  while (txt_rec) {
    len = (int )*(txt_rec->txt + 0) + 1;
    strncpy((char * __restrict  )((char *)p), (char const   * __restrict  )((char *)txt_rec->txt),
            (size_t )len);
    p += len;
    txt_rec = txt_rec->next;
  }
  break;
  case 33U: 
  p = mdns_write_u16(p, (uint16_t const   )rr->data.SRV.priority);
  p = mdns_write_u16(p, (uint16_t const   )rr->data.SRV.weight);
  p = mdns_write_u16(p, (uint16_t const   )rr->data.SRV.port);
  tmp___2 = mdns_encode_name(pkt_buf, pkt_len, (size_t )(p - pkt_buf), (uint8_t const   *)rr->data.SRV.target,
                             comp);
  p += tmp___2;
  break;
  case 47U: 
  tmp___3 = mdns_encode_name(pkt_buf, pkt_len, (size_t )(p - pkt_buf), (uint8_t const   *)rr->name,
                             comp);
  p += tmp___3;
  tmp___4 = p;
  p ++;
  *tmp___4 = (uint8_t )0;
  tmp___5 = p;
  p ++;
  *tmp___5 = (uint8_t )sizeof(rr->data.NSEC.bitmap);
  i = 0;
  while ((unsigned long )i < sizeof(rr->data.NSEC.bitmap)) {
    tmp___6 = p;
    p ++;
    *tmp___6 = rr->data.NSEC.bitmap[i];
    i ++;
  }
  break;
  default: ;
  }
  l = (size_t )(p - p_data);
  mdns_write_u16((p - l) - sizeof(uint16_t ), (uint16_t const   )l);
  return ((size_t )(p - pkt_buf) - off);
}
}
size_t mdns_encode_pkt(struct mdns_pkt *answer , uint8_t *pkt_buf , size_t pkt_len ) 
{ 
  struct name_comp *comp ;
  uint8_t *p ;
  size_t off ;
  int i ;
  struct rr_list *rr_set[3] ;
  void *tmp ;
  struct rr_list *rr ;
  size_t l ;
  size_t tmp___0 ;
  struct name_comp *c ;

  {
  p = pkt_buf;
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    return ((size_t )-1);
  }
  p = mdns_write_u16(p, (uint16_t const   )answer->id);
  p = mdns_write_u16(p, (uint16_t const   )answer->flags);
  p = mdns_write_u16(p, (uint16_t const   )answer->num_qn);
  p = mdns_write_u16(p, (uint16_t const   )answer->num_ans_rr);
  p = mdns_write_u16(p, (uint16_t const   )answer->num_auth_rr);
  p = mdns_write_u16(p, (uint16_t const   )answer->num_add_rr);
  off = (size_t )(p - pkt_buf);
  tmp = malloc(sizeof(struct name_comp ));
  comp = (struct name_comp *)tmp;
  if ((unsigned long )comp == (unsigned long )((void *)0)) {
    return ((size_t )-1);
  }
  memset((void *)comp, 0, sizeof(struct name_comp ));
  comp->label = (uint8_t *)"";
  comp->pos = (size_t )0;
  rr_set[0] = answer->rr_ans;
  rr_set[1] = answer->rr_auth;
  rr_set[2] = answer->rr_add;
  i = 0;
  while ((unsigned long )i < sizeof(rr_set) / sizeof(rr_set[0])) {
    rr = rr_set[i];
    while (rr) {
      tmp___0 = mdns_encode_rr(pkt_buf, pkt_len, off, rr->e, comp);
      l = tmp___0;
      off += l;
      if (off >= pkt_len) {
        return ((size_t )-1);
      }
      rr = rr->next;
    }
    i ++;
  }
  while (comp) {
    c = comp->next;
    free((void *)comp);
    comp = c;
  }
  return (off);
}
}
#pragma merger("0","/tmp/cil-ONsR7DSt.i","-Wall,-fPIC,-ggdb,-O2,-m64,-fdata-sections,-ffunction-sections")
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_attr_init)(pthread_attr_t *__attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_attr_setdetachstate)(pthread_attr_t *__attr ,
                                                                                                        int __detachstate ) ;
void mdns_service_destroy(struct mdns_service *srv ) ;
static void log_message(int loglevel___5 , char *fmt_str  , ...) 
{ 
  va_list___0 ap ;
  char buf___0[2048] ;

  {
  __builtin_va_start(ap, fmt_str);
  vsnprintf((char * __restrict  )(buf___0), (size_t )2047, (char const   * __restrict  )fmt_str,
            ap);
  __builtin_va_end(ap);
  buf___0[2047] = (char)0;
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n", buf___0);
  return;
}
}
static int create_recv_sock(uint32_t host ) 
{ 
  int sd ;
  int tmp ;
  int r ;
  int on ;
  char onChar ;
  struct sockaddr_in serveraddr ;
  struct ip_mreq mreq ;
  unsigned char ttl ;
  int tmp___0 ;

  {
  tmp = socket(2, 2, 0);
  sd = tmp;
  r = -1;
  on = 1;
  onChar = (char)1;
  ttl = (unsigned char)255;
  if (sd < 0) {
    log_message(3, (char *)"recv socket(): %m");
    return (sd);
  }
  r = setsockopt(sd, 1, 2, (void const   *)((char *)(& on)), (socklen_t )sizeof(on));
  if (r < 0) {
    log_message(3, (char *)"recv setsockopt(SO_REUSEADDR): %m");
    return (r);
  }
  on = (int )sizeof(on);
  tmp___0 = getsockopt(sd, 1, 15, (void * __restrict  )((char *)(& on)), (socklen_t * __restrict  )((void *)(& on)));
  if (! tmp___0) {
    on = 1;
    r = setsockopt(sd, 1, 15, (void const   *)((char *)(& on)), (socklen_t )sizeof(on));
    if (r < 0) {
      log_message(3, (char *)"recv setsockopt(SO_REUSEPORT): %m", r);
    }
  }
  memset((void *)(& serveraddr), 0, sizeof(serveraddr));
  serveraddr.sin_family = (sa_family_t )2;
  serveraddr.sin_port = __bswap_16((__uint16_t )5353);
  serveraddr.sin_addr.s_addr = __bswap_32((in_addr_t )0);
  r = bind(sd, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& serveraddr)),
           (socklen_t )sizeof(serveraddr));
  if (r < 0) {
    log_message(3, (char *)"recv bind(): %m");
    return (r);
  }
  memset((void *)(& mreq), 0, sizeof(struct ip_mreq ));
  mreq.imr_interface.s_addr = host;
  r = setsockopt(sd, 0, 32, (void const   *)((char *)(& mreq.imr_interface.s_addr)),
                 (socklen_t )sizeof(mreq.imr_interface.s_addr));
  if (r < 0) {
    log_message(3, (char *)"recv setsockopt(IP_PROTO_IP): %m");
    return (r);
  }
  r = setsockopt(sd, 0, 33, (void const   *)((void *)(& ttl)), (socklen_t )sizeof(ttl));
  if (r < 0) {
    log_message(3, (char *)"recv setsockopt(IP_MULTICAST_IP): %m");
    return (r);
  }
  mreq.imr_multiaddr.s_addr = inet_addr("224.0.0.251");
  r = setsockopt(sd, 0, 35, (void const   *)((char *)(& mreq)), (socklen_t )sizeof(mreq));
  if (r < 0) {
    log_message(3, (char *)"recv setsockopt(IP_ADD_MEMBERSHIP): %m");
    return (r);
  }
  r = setsockopt(sd, 0, 34, (void const   *)(& onChar), (socklen_t )sizeof(onChar));
  if (r < 0) {
    log_message(3, (char *)"recv setsockopt(IP_MULTICAST_LOOP): %m");
    return (r);
  }
  on = 1;
  r = setsockopt(sd, 0, 8, (void const   *)((char *)(& on)), (socklen_t )sizeof(on));
  if (r < 0) {
    log_message(3, (char *)"recv setsockopt(IP_PKTINFO): %m");
    return (r);
  }
  return (sd);
}
}
static struct sockaddr_in toaddr  ;
static ssize_t send_packet(int fd , void const   *data , size_t len ) 
{ 
  ssize_t tmp ;

  {
  if ((int )toaddr.sin_family != 2) {
    memset((void *)(& toaddr), 0, sizeof(struct sockaddr_in ));
    toaddr.sin_family = (sa_family_t )2;
    toaddr.sin_port = __bswap_16((__uint16_t )5353);
    toaddr.sin_addr.s_addr = inet_addr("224.0.0.251");
  }
  tmp = sendto(fd, data, len, 0, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& toaddr)),
               (socklen_t )sizeof(struct sockaddr_in ));
  return (tmp);
}
}
static int populate_answers(struct mdnsd *svr , struct rr_list **rr_head , uint8_t *name ,
                            enum rr_type type ) 
{ 
  int num_ans ;
  struct rr_group *ans_grp ;
  struct rr_list *n ;
  int tmp ;
  int tmp___0 ;

  {
  num_ans = 0;
  pthread_mutex_lock(& svr->data_lock);
  ans_grp = rr_group_find(svr->group, name);
  if ((unsigned long )ans_grp == (unsigned long )((void *)0)) {
    pthread_mutex_unlock(& svr->data_lock);
    return (num_ans);
  }
  n = ans_grp->rr;
  while (n) {
    if ((unsigned int )type == 255U) {
      if ((unsigned int )(n->e)->type == 47U) {
        goto __Cont;
      }
    }
    if ((unsigned int )type == (unsigned int )(n->e)->type) {
      goto _L;
    } else
    if ((unsigned int )type == 255U) {
      _L: /* CIL Label */ 
      tmp___0 = cmp_nlabel((uint8_t const   *)name, (uint8_t const   *)(n->e)->name);
      if (tmp___0 == 0) {
        tmp = rr_list_append(rr_head, n->e);
        num_ans += tmp;
      }
    }
    __Cont: /* CIL Label */ 
    n = n->next;
  }
  pthread_mutex_unlock(& svr->data_lock);
  return (num_ans);
}
}
static void add_related_rr(struct mdnsd *svr , struct rr_list *list , struct mdns_pkt *reply ) 
{ 
  struct rr_entry *ans ;
  uint8_t *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  while (list) {
    ans = list->e;
    switch ((unsigned int )ans->type) {
    case 12U: 
    if ((unsigned long )ans->data.PTR.name != (unsigned long )((void *)0)) {
      tmp = ans->data.PTR.name;
    } else {
      tmp = (ans->data.PTR.entry)->name;
    }
    tmp___0 = populate_answers(svr, & reply->rr_add, tmp, (enum rr_type )255);
    reply->num_add_rr = (uint16_t )((int )reply->num_add_rr + tmp___0);
    break;
    case 33U: 
    tmp___1 = populate_answers(svr, & reply->rr_add, ans->data.SRV.target, (enum rr_type )255);
    reply->num_add_rr = (uint16_t )((int )reply->num_add_rr + tmp___1);
    tmp___2 = populate_answers(svr, & reply->rr_add, ans->name, (enum rr_type )16);
    reply->num_add_rr = (uint16_t )((int )reply->num_add_rr + tmp___2);
    break;
    case 28U: 
    case 1U: 
    tmp___3 = populate_answers(svr, & reply->rr_add, ans->name, (enum rr_type )47);
    reply->num_add_rr = (uint16_t )((int )reply->num_add_rr + tmp___3);
    break;
    default: 
    break;
    }
    list = list->next;
  }
  return;
}
}
static void announce_srv(struct mdnsd *svr , struct mdns_pkt *reply , uint8_t *name ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  mdns_init_reply(reply, (uint16_t )0);
  tmp = populate_answers(svr, & reply->rr_ans, name, (enum rr_type )12);
  reply->num_ans_rr = (uint16_t )((int )reply->num_ans_rr + tmp);
  tmp___0 = populate_answers(svr, & reply->rr_ans, (uint8_t *)"\t_services\a_dns-sd\004_udp\005local",
                             (enum rr_type )12);
  reply->num_ans_rr = (uint16_t )((int )reply->num_ans_rr + tmp___0);
  add_related_rr(svr, reply->rr_ans, reply);
  add_related_rr(svr, reply->rr_add, reply);
  return;
}
}
static int process_mdns_pkt(struct mdnsd *svr , struct mdns_pkt *pkt , struct mdns_pkt *reply ) 
{ 
  int i ;
  struct rr_list *qnl ;
  struct rr_list *ans ;
  struct rr_list *prev_ans ;
  struct rr_entry *qn ;
  int num_ans_added ;
  char *namestr ;
  char *tmp ;
  struct rr_list *next_ans ;
  struct rr_entry *known_ans ;
  struct rr_entry *tmp___0 ;
  char *namestr___0 ;
  char *tmp___1 ;

  {
  if (((int )pkt->flags & (1 << 15)) == 0) {
    if ((((int )pkt->flags >> 11) & 15) == 0) {
      mdns_init_reply(reply, pkt->id);
      qnl = pkt->rr_qn;
      i = 0;
      while (i < (int )pkt->num_qn) {
        qn = qnl->e;
        num_ans_added = 0;
        tmp = nlabel_to_str((uint8_t const   *)qn->name);
        namestr = tmp;
        free((void *)namestr);
        if (qn->unicast_query) {
          goto __Cont;
        }
        num_ans_added = populate_answers(svr, & reply->rr_ans, qn->name, qn->type);
        reply->num_ans_rr = (uint16_t )((int )reply->num_ans_rr + num_ans_added);
        __Cont: /* CIL Label */ 
        i ++;
        qnl = qnl->next;
      }
      ans = (struct rr_list *)((void *)0);
      prev_ans = (struct rr_list *)((void *)0);
      ans = reply->rr_ans;
      while (ans) {
        next_ans = ans->next;
        tmp___0 = rr_entry_match(pkt->rr_ans, ans->e);
        known_ans = tmp___0;
        if ((unsigned long )known_ans != (unsigned long )((void *)0)) {
          if (known_ans->ttl >= (ans->e)->ttl / 2U) {
            tmp___1 = nlabel_to_str((uint8_t const   *)(ans->e)->name);
            namestr___0 = tmp___1;
            free((void *)namestr___0);
            if ((unsigned long )prev_ans == (unsigned long )((void *)0)) {
              reply->rr_ans = ans->next;
            } else {
              prev_ans->next = ans->next;
            }
            free((void *)ans);
            ans = prev_ans;
            reply->num_ans_rr = (uint16_t )((int )reply->num_ans_rr - 1);
          }
        }
        prev_ans = ans;
        ans = next_ans;
      }
      add_related_rr(svr, reply->rr_ans, reply);
      add_related_rr(svr, reply->rr_add, reply);
      return ((int )reply->num_ans_rr);
    }
  }
  return (0);
}
}
int create_pipe(int *handles ) 
{ 
  int tmp ;

  {
  tmp = pipe(handles);
  return (tmp);
}
}
int read_pipe(int s , char *buf___0 , int len ) 
{ 
  ssize_t tmp ;

  {
  tmp = read(s, (void *)buf___0, (size_t )len);
  return ((int )tmp);
}
}
int write_pipe(int s , char *buf___0 , int len ) 
{ 
  ssize_t tmp ;

  {
  tmp = write(s, (void const   *)buf___0, (size_t )len);
  return ((int )tmp);
}
}
int close_pipe(int s ) 
{ 
  int tmp ;

  {
  tmp = close(s);
  return (tmp);
}
}
static void main_loop(struct mdnsd *svr ) 
{ 
  fd_set sockfd_set ;
  int max_fd ;
  char notify_buf[2] ;
  struct mdns_pkt *mdns_reply ;
  struct mdns_pkt *mdns ;
  struct rr_list *svc_le ;
  void *pkt_buffer ;
  void *tmp ;
  void *tmp___0 ;
  int __d0 ;
  int __d1 ;
  struct sockaddr_in fromaddr ;
  socklen_t sockaddr_size ;
  ssize_t recvsize ;
  ssize_t tmp___1 ;
  size_t replylen ;
  size_t tmp___2 ;
  int tmp___3 ;
  struct rr_entry *ann_e ;
  char *namestr ;
  size_t replylen___0 ;
  size_t tmp___4 ;
  struct rr_entry *leave_e ;
  char *namestr___0 ;
  int tmp___5 ;
  size_t replylen___1 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t replylen___2 ;
  size_t tmp___8 ;

  {
  max_fd = svr->sockfd;
  tmp = malloc((size_t )65536);
  pkt_buffer = tmp;
  if (svr->notify_pipe[0] > max_fd) {
    max_fd = svr->notify_pipe[0];
  }
  tmp___0 = malloc(sizeof(struct mdns_pkt ));
  mdns_reply = (struct mdns_pkt *)tmp___0;
  memset((void *)mdns_reply, 0, sizeof(struct mdns_pkt ));
  while (! svr->stop_flag) {
    while (1) {
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& sockfd_set.fds_bits[0]): "memory");
      break;
    }
    sockfd_set.fds_bits[svr->sockfd / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << svr->sockfd % (8 * (int )sizeof(__fd_mask )));
    sockfd_set.fds_bits[svr->notify_pipe[0] / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << svr->notify_pipe[0] % (8 * (int )sizeof(__fd_mask )));
    select(max_fd + 1, (fd_set * __restrict  )(& sockfd_set), (fd_set * __restrict  )((void *)0),
           (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
    if ((sockfd_set.fds_bits[svr->notify_pipe[0] / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << svr->notify_pipe[0] % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      read_pipe(svr->notify_pipe[0], (char *)(& notify_buf), 1);
    } else
    if ((sockfd_set.fds_bits[svr->sockfd / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << svr->sockfd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      sockaddr_size = (socklen_t )sizeof(struct sockaddr_in );
      tmp___1 = recvfrom(svr->sockfd, (void * __restrict  )pkt_buffer, (size_t )65536,
                         0, (struct sockaddr * __restrict  )((struct sockaddr *)(& fromaddr)),
                         (socklen_t * __restrict  )(& sockaddr_size));
      recvsize = tmp___1;
      if (recvsize < 0L) {
        log_message(3, (char *)"recv(): %m");
      }
      mdns = mdns_parse_pkt((uint8_t *)pkt_buffer, (size_t )recvsize);
      if ((unsigned long )mdns != (unsigned long )((void *)0)) {
        tmp___3 = process_mdns_pkt(svr, mdns, mdns_reply);
        if (tmp___3) {
          tmp___2 = mdns_encode_pkt(mdns_reply, (uint8_t *)pkt_buffer, (size_t )65536);
          replylen = tmp___2;
          send_packet(svr->sockfd, (void const   *)pkt_buffer, replylen);
        }
        mdns_pkt_destroy(mdns);
      }
    }
    while (1) {
      ann_e = (struct rr_entry *)((void *)0);
      pthread_mutex_lock(& svr->data_lock);
      if (svr->announce) {
        ann_e = rr_list_remove(& svr->announce, (svr->announce)->e);
      }
      pthread_mutex_unlock(& svr->data_lock);
      if (! ann_e) {
        break;
      }
      namestr = nlabel_to_str((uint8_t const   *)ann_e->name);
      free((void *)namestr);
      announce_srv(svr, mdns_reply, ann_e->name);
      if ((int )mdns_reply->num_ans_rr > 0) {
        tmp___4 = mdns_encode_pkt(mdns_reply, (uint8_t *)pkt_buffer, (size_t )65536);
        replylen___0 = tmp___4;
        send_packet(svr->sockfd, (void const   *)pkt_buffer, replylen___0);
      }
    }
    while (1) {
      leave_e = (struct rr_entry *)((void *)0);
      pthread_mutex_lock(& svr->data_lock);
      if (svr->leave) {
        leave_e = rr_list_remove(& svr->leave, (svr->leave)->e);
      }
      pthread_mutex_unlock(& svr->data_lock);
      if (! leave_e) {
        break;
      }
      mdns_init_reply(mdns_reply, (uint16_t )0);
      namestr___0 = nlabel_to_str((uint8_t const   *)leave_e->name);
      free((void *)namestr___0);
      leave_e->ttl = (uint32_t )0;
      tmp___5 = rr_list_append(& mdns_reply->rr_ans, leave_e);
      mdns_reply->num_ans_rr = (uint16_t )((int )mdns_reply->num_ans_rr + tmp___5);
      if ((int )mdns_reply->num_ans_rr > 0) {
        tmp___6 = mdns_encode_pkt(mdns_reply, (uint8_t *)pkt_buffer, (size_t )65536);
        replylen___1 = tmp___6;
        send_packet(svr->sockfd, (void const   *)pkt_buffer, replylen___1);
      }
      rr_entry_destroy(leave_e->data.PTR.entry);
      rr_entry_destroy(leave_e);
    }
  }
  mdns_init_reply(mdns_reply, (uint16_t )0);
  pthread_mutex_lock(& svr->data_lock);
  svc_le = svr->services;
  while (svc_le) {
    (svc_le->e)->ttl = (uint32_t )0;
    tmp___7 = rr_list_append(& mdns_reply->rr_ans, svc_le->e);
    mdns_reply->num_ans_rr = (uint16_t )((int )mdns_reply->num_ans_rr + tmp___7);
    svc_le = svc_le->next;
  }
  pthread_mutex_unlock(& svr->data_lock);
  if ((int )mdns_reply->num_ans_rr > 0) {
    tmp___8 = mdns_encode_pkt(mdns_reply, (uint8_t *)pkt_buffer, (size_t )65536);
    replylen___2 = tmp___8;
    send_packet(svr->sockfd, (void const   *)pkt_buffer, replylen___2);
  }
  mdns_init_reply(mdns_reply, (uint16_t )0);
  free((void *)mdns_reply);
  free(pkt_buffer);
  close_pipe(svr->sockfd);
  svr->stop_flag = 2;
  return;
}
}
void mdnsd_set_hostname(struct mdnsd *svr , char const   *hostname , struct in_addr addr ) 
{ 
  struct rr_entry *a_e ;
  struct rr_entry *nsec_e ;
  uint8_t *tmp ;
  uint8_t *tmp___0 ;

  {
  a_e = (struct rr_entry *)((void *)0);
  nsec_e = (struct rr_entry *)((void *)0);
  tmp = create_nlabel(hostname);
  a_e = rr_create_a(tmp, addr);
  tmp___0 = create_nlabel(hostname);
  nsec_e = rr_create(tmp___0, (enum rr_type )47);
  nsec_e->ttl = (uint32_t )120;
  rr_set_nsec(nsec_e, (enum rr_type )1);
  pthread_mutex_lock(& svr->data_lock);
  svr->hostname = create_nlabel(hostname);
  rr_group_add(& svr->group, a_e);
  rr_group_add(& svr->group, nsec_e);
  pthread_mutex_unlock(& svr->data_lock);
  return;
}
}
void mdnsd_set_hostname_v6(struct mdnsd *svr , char const   *hostname , struct in6_addr *addr ) 
{ 
  struct rr_entry *aaaa_e ;
  struct rr_entry *nsec_e ;
  uint8_t *tmp ;
  uint8_t *tmp___0 ;

  {
  aaaa_e = (struct rr_entry *)((void *)0);
  nsec_e = (struct rr_entry *)((void *)0);
  tmp = create_nlabel(hostname);
  aaaa_e = rr_create_aaaa(tmp, addr);
  tmp___0 = create_nlabel(hostname);
  nsec_e = rr_create(tmp___0, (enum rr_type )47);
  nsec_e->ttl = (uint32_t )120;
  rr_set_nsec(nsec_e, (enum rr_type )28);
  pthread_mutex_lock(& svr->data_lock);
  svr->hostname = create_nlabel(hostname);
  rr_group_add(& svr->group, aaaa_e);
  rr_group_add(& svr->group, nsec_e);
  pthread_mutex_unlock(& svr->data_lock);
  return;
}
}
void mdnsd_add_rr(struct mdnsd *svr , struct rr_entry *rr ) 
{ 


  {
  pthread_mutex_lock(& svr->data_lock);
  rr_group_add(& svr->group, rr);
  pthread_mutex_unlock(& svr->data_lock);
  return;
}
}
struct mdns_service *mdnsd_register_svc(struct mdnsd *svr , char const   *instance_name ,
                                        char const   *type , uint16_t port , char const   *hostname ,
                                        char const   **txt ) 
{ 
  struct rr_entry *txt_e ;
  struct rr_entry *srv_e ;
  struct rr_entry *ptr_e ;
  struct rr_entry *bptr_e ;
  uint8_t *target ;
  uint8_t *inst_nlabel ;
  uint8_t *type_nlabel ;
  uint8_t *nlabel ;
  struct mdns_service *service ;
  void *tmp ;
  uint8_t *tmp___0 ;
  uint8_t *tmp___1 ;
  uint8_t *tmp___2 ;
  uint8_t *tmp___3 ;
  uint8_t *tmp___4 ;

  {
  txt_e = (struct rr_entry *)((void *)0);
  srv_e = (struct rr_entry *)((void *)0);
  ptr_e = (struct rr_entry *)((void *)0);
  bptr_e = (struct rr_entry *)((void *)0);
  tmp = malloc(sizeof(struct mdns_service ));
  service = (struct mdns_service *)tmp;
  memset((void *)service, 0, sizeof(struct mdns_service ));
  type_nlabel = create_nlabel(type);
  inst_nlabel = create_label(instance_name);
  nlabel = join_nlabel((uint8_t const   *)inst_nlabel, (uint8_t const   *)type_nlabel);
  if (txt) {
    if (*txt) {
      tmp___0 = dup_nlabel((uint8_t const   *)nlabel);
      txt_e = rr_create(tmp___0, (enum rr_type )16);
      rr_list_append(& service->entries, txt_e);
      while (*txt) {
        rr_add_txt(txt_e, *txt);
        txt ++;
      }
    }
  }
  if (hostname) {
    tmp___1 = create_nlabel(hostname);
    target = tmp___1;
  } else {
    tmp___2 = dup_nlabel((uint8_t const   *)svr->hostname);
    target = tmp___2;
  }
  tmp___3 = dup_nlabel((uint8_t const   *)nlabel);
  srv_e = rr_create_srv(tmp___3, port, target);
  rr_list_append(& service->entries, srv_e);
  ptr_e = rr_create_ptr(type_nlabel, srv_e);
  tmp___4 = dup_nlabel((uint8_t const   *)((uint8_t *)"\t_services\a_dns-sd\004_udp\005local"));
  bptr_e = rr_create_ptr(tmp___4, ptr_e);
  pthread_mutex_lock(& svr->data_lock);
  if (txt_e) {
    rr_group_add(& svr->group, txt_e);
  }
  rr_group_add(& svr->group, srv_e);
  rr_group_add(& svr->group, ptr_e);
  rr_group_add(& svr->group, bptr_e);
  rr_list_append(& svr->announce, ptr_e);
  rr_list_append(& svr->services, ptr_e);
  pthread_mutex_unlock(& svr->data_lock);
  free((void *)nlabel);
  free((void *)inst_nlabel);
  write_pipe(svr->notify_pipe[1], (char *)".", 1);
  return (service);
}
}
void mdns_service_remove(struct mdnsd *svr , struct mdns_service *svc ) 
{ 
  struct rr_list *rr ;
  struct rr_group *g ;
  struct rr_entry *ptr_e ;
  struct rr_entry *bptr_e ;

  {
  pthread_mutex_lock(& svr->data_lock);
  rr = svc->entries;
  while (rr) {
    g = rr_group_find(svr->group, (rr->e)->name);
    if ((unsigned long )g != (unsigned long )((void *)0)) {
      rr_list_remove(& g->rr, rr->e);
    }
    ptr_e = rr_entry_remove(svr->group, rr->e, (enum rr_type )12);
    if ((unsigned long )ptr_e != (unsigned long )((void *)0)) {
      rr_list_remove(& svr->announce, ptr_e);
      rr_list_remove(& svr->services, ptr_e);
      bptr_e = rr_entry_remove(svr->group, ptr_e, (enum rr_type )12);
      rr_entry_destroy(bptr_e);
      rr_list_append(& svr->leave, ptr_e);
    } else {
      rr_entry_destroy(rr->e);
    }
    rr = rr->next;
  }
  rr_group_clean(& svr->group);
  rr_list_destroy(svc->entries, (char)0);
  free((void *)svc);
  pthread_mutex_unlock(& svr->data_lock);
  return;
}
}
void mdns_service_destroy(struct mdns_service *srv ) 
{ 


  {
  rr_list_destroy(srv->entries, (char)0);
  free((void *)srv);
  return;
}
}
struct mdnsd *mdnsd_start(struct in_addr host ) 
{ 
  pthread_t tid ;
  pthread_attr_t attr ;
  struct mdnsd *server ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = malloc(sizeof(struct mdnsd ));
  server = (struct mdnsd *)tmp;
  memset((void *)server, 0, sizeof(struct mdnsd ));
  tmp___0 = create_pipe((int *)(server->notify_pipe));
  if (tmp___0 != 0) {
    log_message(3, (char *)"pipe(): %m\n");
    free((void *)server);
    return ((struct mdnsd *)((void *)0));
  }
  server->sockfd = create_recv_sock(host.s_addr);
  if (server->sockfd < 0) {
    log_message(3, (char *)"unable to create recv socket");
    free((void *)server);
    return ((struct mdnsd *)((void *)0));
  }
  pthread_mutex_init(& server->data_lock, (pthread_mutexattr_t const   *)((void *)0));
  pthread_attr_init(& attr);
  pthread_attr_setdetachstate(& attr, 1);
  tmp___1 = pthread_create((pthread_t * __restrict  )(& tid), (pthread_attr_t const   * __restrict  )(& attr),
                           (void *(*)(void * ))(& main_loop), (void * __restrict  )((void *)server));
  if (tmp___1 != 0) {
    pthread_mutex_destroy(& server->data_lock);
    free((void *)server);
    return ((struct mdnsd *)((void *)0));
  }
  return (server);
}
}
void mdnsd_stop(struct mdnsd *s ) 
{ 
  struct timeval tv ;

  {
  if (! s) {
    return;
  }
  tv.tv_sec = (__time_t )0;
  tv.tv_usec = (__suseconds_t )500000;
  s->stop_flag = 1;
  write_pipe(s->notify_pipe[1], (char *)".", 1);
  while (s->stop_flag != 2) {
    select(0, (fd_set * __restrict  )((void *)0), (fd_set * __restrict  )((void *)0),
           (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )(& tv));
  }
  close_pipe(s->notify_pipe[0]);
  close_pipe(s->notify_pipe[1]);
  pthread_mutex_destroy(& s->data_lock);
  rr_group_destroy(s->group);
  rr_list_destroy(s->announce, (char)0);
  rr_list_destroy(s->services, (char)0);
  rr_list_destroy(s->leave, (char)0);
  if (s->hostname) {
    free((void *)s->hostname);
  }
  free((void *)s);
  return;
}
}
#pragma merger("0","/tmp/cil-o9fd9CMI.i","-Wall,-fPIC,-ggdb,-O2,-m64,-fdata-sections,-ffunction-sections")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) dlclose)(void *__handle ) ;
static void *SSLhandle  =    (void *)0;
static void *CRYPThandle  =    (void *)0;
_Bool load_ssl_symbols(void) 
{ 


  {
  return ((_Bool)1);
}
}
void free_ssl_symbols(void) 
{ 


  {
  if (SSLhandle) {
    dlclose(SSLhandle);
  }
  if (CRYPThandle) {
    dlclose(CRYPThandle);
  }
  return;
}
}
