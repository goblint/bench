/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef long __int64_t;
typedef unsigned long __uint64_t;
typedef __int64_t int64_t;
typedef __uint64_t uint64_t;
typedef void *var;
struct Header {
   var type ;
   var alloc ;
   var magic ;
};
struct Int {
   int64_t val ;
};
struct Tuple {
   var *items ;
};
struct Example {
   char const   *name ;
   char const   *body ;
};
struct Method {
   char const   *name ;
   char const   *definition ;
   char const   *description ;
};
struct Doc {
   char const   *(*name)(void) ;
   char const   *(*brief)(void) ;
   char const   *(*description)(void) ;
   char const   *(*definition)(void) ;
   struct Example *(*examples)(void) ;
   struct Method *(*methods)(void) ;
};
struct New {
   void (*construct_with)(var  , var  ) ;
   void (*destruct)(var  ) ;
};
struct Assign {
   void (*assign)(var  , var  ) ;
};
struct Cmp {
   int (*cmp)(var  , var  ) ;
};
struct Hash {
   uint64_t (*hash)(var  ) ;
};
struct Len {
   size_t (*len)(var  ) ;
};
struct Get {
   var (*get)(var  , var  ) ;
   void (*set)(var  , var  , var  ) ;
   _Bool (*mem)(var  , var  ) ;
   void (*rem)(var  , var  ) ;
   var (*key_type)(var  ) ;
   var (*val_type)(var  ) ;
};
struct Iter {
   var (*iter_init)(var  ) ;
   var (*iter_next)(var  , var  ) ;
   var (*iter_last)(var  ) ;
   var (*iter_prev)(var  , var  ) ;
   var (*iter_type)(var  ) ;
};
struct Resize {
   void (*resize)(var  , size_t  ) ;
};
struct Show {
   int (*show)(var  , var  , int  ) ;
   int (*look)(var  , var  , int  ) ;
};
struct Mark {
   void (*mark)(var  , var  , void (*)(var  , void * ) ) ;
};
struct Table {
   var data ;
   var ktype ;
   var vtype ;
   size_t ksize ;
   size_t vsize ;
   size_t nslots ;
   size_t nitems ;
   var sspace0 ;
   var sspace1 ;
};
struct Range {
   var value ;
   int64_t start ;
   int64_t stop ;
   int64_t step ;
};
struct Slice {
   var iter ;
   var range ;
};
struct Zip {
   var iters ;
   var values ;
};
struct Filter {
   var iter ;
   var func ;
};
struct Map {
   var iter ;
   var curr ;
   var func ;
};
struct Call {
   var (*call_with)(var  , var  ) ;
};
struct Swap {
   void (*swap)(var  , var  ) ;
};
struct Push {
   void (*push)(var  , var  ) ;
   void (*pop)(var  ) ;
   void (*push_at)(var  , var  , var  ) ;
   void (*pop_at)(var  , var  ) ;
};
typedef long __off_t;
typedef long __off64_t;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
struct __anonstruct___sigset_t_991265788 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___sigset_t_991265788 __sigset_t;
typedef long __jmp_buf[8];
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
typedef struct __jmp_buf_tag jmp_buf[1];
typedef void (*__sighandler_t)(int  );
struct String {
   char *val ;
};
struct File {
   FILE *file ;
};
struct Current {
   var (*current)(void) ;
};
struct Start {
   void (*start)(var  ) ;
   void (*stop)(var  ) ;
   void (*join)(var  ) ;
   _Bool (*running)(var  ) ;
};
struct Exception {
   var obj ;
   var msg ;
   size_t depth ;
   _Bool active ;
   jmp_buf *buffers[2048] ;
};
struct Help {
   int (*help_to)(var  , var  , int  ) ;
};
typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list___0;
struct Concat {
   void (*concat)(var  , var  ) ;
   void (*append)(var  , var  ) ;
};
struct C_Str {
   char *(*c_str)(var  ) ;
};
struct Format {
   int (*format_to)(var  , int  , char const   * , va_list___0  ) ;
   int (*format_from)(var  , int  , char const   * , va_list___0  ) ;
};
typedef unsigned long uintptr_t;
struct Type {
   var cls ;
   var name ;
   var inst ;
};
struct Cast {
   var (*cast)(var  , var  ) ;
};
struct Size {
   size_t (*size)(void) ;
};
struct Alloc {
   var (*alloc)(void) ;
   void (*dealloc)(var  ) ;
};
struct Copy {
   var (*copy)(var  ) ;
};
struct List {
   var type ;
   var head ;
   var tail ;
   size_t tsize ;
   size_t nitems ;
};
struct Sort {
   void (*sort_by)(var  , _Bool (*f)(var  , var  ) ) ;
};
struct Ref {
   var val ;
};
struct Box {
   var val ;
};
struct Pointer {
   void (*ref)(var  , var  ) ;
   var (*deref)(var  ) ;
};
struct Tree {
   var root ;
   var ktype ;
   var vtype ;
   size_t ksize ;
   size_t vsize ;
   size_t nitems ;
};
struct Float {
   double val ;
};
struct Function {
   var (*func)(var  ) ;
};
typedef long intptr_t;
struct C_Int {
   int64_t (*c_int)(var  ) ;
};
struct C_Float {
   double (*c_float)(var  ) ;
};
union interp_cast {
   double as_flt ;
   uint64_t as_int ;
};
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
typedef unsigned long pthread_t;
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
typedef unsigned int pthread_key_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
struct Lock {
   void (*lock)(var  ) ;
   void (*unlock)(var  ) ;
   _Bool (*trylock)(var  ) ;
};
struct Thread {
   var func ;
   var args ;
   var tls ;
   _Bool is_main ;
   _Bool is_running ;
   pthread_t thread ;
};
struct GC ;
struct Mutex {
   pthread_mutex_t mutex ;
};
struct GCEntry {
   var ptr ;
   uint64_t hash ;
   _Bool root ;
   _Bool marked ;
};
struct GC {
   struct GCEntry *entries ;
   size_t nslots ;
   size_t nitems ;
   size_t mitems ;
   uintptr_t maxptr ;
   uintptr_t minptr ;
   var bottom ;
   _Bool running ;
   uintptr_t freenum ;
   var *freelist ;
};
struct Array {
   var type ;
   var data ;
   size_t tsize ;
   size_t nitems ;
   size_t nslots ;
};
struct Process {
   FILE *proc ;
};
struct Stream {
   var (*sopen)(var  , var  , var  ) ;
   void (*sclose)(var  ) ;
   void (*sseek)(var  , int64_t  , int  ) ;
   int64_t (*stell)(var  ) ;
   void (*sflush)(var  ) ;
   _Bool (*seof)(var  ) ;
   size_t (*sread)(var  , void * , size_t  ) ;
   size_t (*swrite)(var  , void * , size_t  ) ;
};
#pragma merger("0","/tmp/cil-rW7O4Oa5.i","-std=gnu99,-Wall,-Wno-unused,-g,-ggdb,-fPIC")
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
var Type ;
var Tuple ;
var Ref ;
var Int ;
var Table ;
var Terminal ;
var KeyError ;
var FormatError ;
var OutOfMemoryError ;
var Iter ;
var Get ;
var cast(var self , var type ) ;
var instance(var self , var cls ) ;
_Bool implements_method_at_offset(var self , var cls , size_t offset ) ;
var header_init(var head , var type , int alloc___0 ) ;
size_t size(var type ) ;
var destruct(var self ) ;
var assign(var self , var obj ) ;
int cmp(var self , var obj ) ;
_Bool eq(var self , var obj ) ;
uint64_t hash(var self ) ;
var iter_init(var self ) ;
var iter_next(var self , var curr ) ;
var get(var self , var key ) ;
var key_type(var self ) ;
var val_type(var self ) ;
size_t len(var self ) ;
int print_to_with(var out , int pos , char const   *fmt , var args ) ;
var exception_throw(var obj , char const   *fmt , var args ) ;
static char const   *Table_Name(void) 
{ 


  {
  return ("Table");
}
}
static char const   *Table_Brief(void) 
{ 


  {
  return ("Hash table");
}
}
static char const   *Table_Description(void) 
{ 


  {
  return ("The `Table` type is a hash table data structure that maps keys to values. It uses an open-addressing robin-hood hashing scheme which requires `Hash` and `Cmp` to be defined on the key type. Keys and values are copied into the collection using the `Assign` class and intially have zero\'d memory.\n\nHash tables provide `O(1)` lookup, insertion and removal can but require long pauses when the table must be _rehashed_ and all entries processed.\n\nThis is largely equivalent to the C++ construct [std::unordered_map](http://www.cplusplus.com/reference/unordered_map/unordered_map/)");
}
}
static struct Example *Table_Examples(void) ;
static struct Example examples[3]  = {      {"Usage", "var prices = new(Table, String, Int);\nset(prices, $S(\"Apple\"),  $I(12));\nset(prices, $S(\"Banana\"), $I( 6));\nset(prices, $S(\"Pear\"),   $I(55));\n\nforeach (key in prices) {\n  var price = get(prices, key);\n  println(\"Price of %$ is %$\", key, price);\n}\n"}, 
        {"Manipulation",
      "var t = new(Table, String, Int);\nset(t, $S(\"Hello\"), $I(2));\nset(t, $S(\"There\"), $I(5));\n\nshow($I(len(t))); /* 2 */\nshow($I(mem(t, $S(\"Hello\")))); /* 1 */\n\nrem(t, $S(\"Hello\"));\n\nshow($I(len(t))); /* 1 */\nshow($I(mem(t, $S(\"Hello\")))); /* 0 */\nshow($I(mem(t, $S(\"There\")))); /* 1 */\n\nresize(t, 0);\n\nshow($I(len(t))); /* 0 */\nshow($I(mem(t, $S(\"Hello\")))); /* 0 */\nshow($I(mem(t, $S(\"There\")))); /* 0 */\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Table_Examples(void) 
{ 


  {
  return (examples);
}
}
static size_t const   Table_Primes[24]  = 
  {      (size_t const   )0,      (size_t const   )1,      (size_t const   )5,      (size_t const   )11, 
        (size_t const   )23,      (size_t const   )53,      (size_t const   )101,      (size_t const   )197, 
        (size_t const   )389,      (size_t const   )683,      (size_t const   )1259,      (size_t const   )2417, 
        (size_t const   )4733,      (size_t const   )9371,      (size_t const   )18617,      (size_t const   )37097, 
        (size_t const   )74093,      (size_t const   )148073,      (size_t const   )296099,      (size_t const   )592019, 
        (size_t const   )1100009,      (size_t const   )2200013,      (size_t const   )4400021,      (size_t const   )8800019};
static double const   Table_Load_Factor  =    (double const   )0.9;
static size_t Table_Ideal_Size(size_t size___0 ) 
{ 
  size_t i ;
  size_t last ;
  size_t i___0 ;

  {
  size___0 = (size_t )((double )(size___0 + 1UL) / (double )Table_Load_Factor);
  i = (size_t )0;
  while (i < 24UL) {
    if (Table_Primes[i] >= (size_t const   )size___0) {
      return ((size_t )Table_Primes[i]);
    }
    i ++;
  }
  last = (size_t )Table_Primes[23];
  i___0 = (size_t )0;
  while (1) {
    if (last * i___0 >= size___0) {
      return (last * i___0);
    }
    i___0 ++;
  }
}
}
static size_t Table_Step(struct Table *t ) 
{ 


  {
  return ((((sizeof(uint64_t ) + sizeof(struct Header )) + t->ksize) + sizeof(struct Header )) + t->vsize);
}
}
static uint64_t Table_Key_Hash(struct Table *t , uint64_t i ) 
{ 
  size_t tmp ;

  {
  tmp = Table_Step(t);
  return (*((uint64_t *)((char *)t->data + i * tmp)));
}
}
static var Table_Key(struct Table *t , uint64_t i ) 
{ 
  size_t tmp ;

  {
  tmp = Table_Step(t);
  return ((var )((((char *)t->data + i * tmp) + sizeof(uint64_t )) + sizeof(struct Header )));
}
}
static var Table_Val(struct Table *t , uint64_t i ) 
{ 
  size_t tmp ;

  {
  tmp = Table_Step(t);
  return ((var )((((((char *)t->data + i * tmp) + sizeof(uint64_t )) + sizeof(struct Header )) + t->ksize) + sizeof(struct Header )));
}
}
static uint64_t Table_Probe(struct Table *t , uint64_t i , uint64_t h ) 
{ 
  int64_t v ;

  {
  v = (int64_t )(i - (h - 1UL));
  if (v < 0L) {
    v = (int64_t )(t->nslots + (size_t )v);
  }
  return ((uint64_t )v);
}
}
static void Table_Set(var self , var key , var val ) ;
static void Table_Set_Move(var self , var key , var val , _Bool move ) ;
static size_t Table_Size_Round(size_t s ) 
{ 


  {
  return ((((s + sizeof(var )) - 1UL) / sizeof(var )) * sizeof(var ));
}
}
static void Table_New(var self , var args ) 
{ 
  struct Table *t ;
  struct Int __constr_expr_0 ;
  char __constr_expr_1[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  var tmp___2 ;
  struct Int __constr_expr_2 ;
  char __constr_expr_3[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;
  var tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t nargs ;
  size_t tmp___9 ;
  struct Tuple __constr_expr_4 ;
  var __constr_expr_5[1] ;
  char __constr_expr_6[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___10 ;
  var tmp___11 ;
  void *tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  struct Tuple __constr_expr_7 ;
  var __constr_expr_8[1] ;
  char __constr_expr_9[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___16 ;
  var tmp___17 ;
  void *tmp___18 ;
  size_t i ;
  var key ;
  struct Int __constr_expr_10 ;
  char __constr_expr_11[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___19 ;
  var tmp___20 ;
  void *tmp___21 ;
  var tmp___22 ;
  var val ;
  struct Int __constr_expr_12 ;
  char __constr_expr_13[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___23 ;
  var tmp___24 ;
  void *tmp___25 ;
  var tmp___26 ;

  {
  t = (struct Table *)self;
  __constr_expr_0.val = (int64_t )0;
  __constr_expr_1[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_1[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_1), Int, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Int *)tmp___0), (void const   * __restrict  )(& __constr_expr_0),
                   sizeof(struct Int ));
  tmp___2 = get(args, (var )((struct Int *)tmp___1));
  t->ktype = cast(tmp___2, Type);
  __constr_expr_2.val = (int64_t )1;
  __constr_expr_3[0] = (char)0;
  tmp___3 = 1U;
  while (! (tmp___3 >= 32U)) {
    __constr_expr_3[tmp___3] = (char)0;
    tmp___3 ++;
  }
  tmp___4 = header_init((var )(__constr_expr_3), Int, 2);
  tmp___5 = memcpy((void * __restrict  )((struct Int *)tmp___4), (void const   * __restrict  )(& __constr_expr_2),
                   sizeof(struct Int ));
  tmp___6 = get(args, (var )((struct Int *)tmp___5));
  t->vtype = cast(tmp___6, Type);
  tmp___7 = size(t->ktype);
  t->ksize = Table_Size_Round(tmp___7);
  tmp___8 = size(t->vtype);
  t->vsize = Table_Size_Round(tmp___8);
  tmp___9 = len(args);
  nargs = tmp___9;
  if (nargs % 2UL != 0UL) {
    __constr_expr_5[0] = Terminal;
    __constr_expr_4.items = __constr_expr_5;
    __constr_expr_6[0] = (char)0;
    tmp___10 = 1U;
    while (! (tmp___10 >= 32U)) {
      __constr_expr_6[tmp___10] = (char)0;
      tmp___10 ++;
    }
    tmp___11 = header_init((var )(__constr_expr_6), Tuple, 2);
    tmp___12 = memcpy((void * __restrict  )((struct Tuple *)tmp___11), (void const   * __restrict  )(& __constr_expr_4),
                      sizeof(struct Tuple ));
    exception_throw(FormatError, "Received non multiple of two argument count to Table constructor.",
                    (var )((struct Tuple *)tmp___12));
  }
  t->nslots = Table_Ideal_Size((nargs - 2UL) / 2UL);
  t->nitems = (size_t )0;
  if (t->nslots == 0UL) {
    t->data = (void *)0;
    return;
  }
  tmp___13 = Table_Step(t);
  t->data = calloc(t->nslots, tmp___13);
  tmp___14 = Table_Step(t);
  t->sspace0 = calloc((size_t )1, tmp___14);
  tmp___15 = Table_Step(t);
  t->sspace1 = calloc((size_t )1, tmp___15);
  if ((unsigned long )t->data == (unsigned long )((void *)0)) {
    goto _L;
  } else
  if ((unsigned long )t->sspace0 == (unsigned long )((void *)0)) {
    goto _L;
  } else
  if ((unsigned long )t->sspace1 == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
    __constr_expr_8[0] = Terminal;
    __constr_expr_7.items = __constr_expr_8;
    __constr_expr_9[0] = (char)0;
    tmp___16 = 1U;
    while (! (tmp___16 >= 32U)) {
      __constr_expr_9[tmp___16] = (char)0;
      tmp___16 ++;
    }
    tmp___17 = header_init((var )(__constr_expr_9), Tuple, 2);
    tmp___18 = memcpy((void * __restrict  )((struct Tuple *)tmp___17), (void const   * __restrict  )(& __constr_expr_7),
                      sizeof(struct Tuple ));
    exception_throw(OutOfMemoryError, "Cannot allocate Table, out of memory!", (var )((struct Tuple *)tmp___18));
  }
  i = (size_t )0;
  while (i < (nargs - 2UL) / 2UL) {
    __constr_expr_10.val = (int64_t )(2UL + i * 2UL);
    __constr_expr_11[0] = (char)0;
    tmp___19 = 1U;
    while (! (tmp___19 >= 32U)) {
      __constr_expr_11[tmp___19] = (char)0;
      tmp___19 ++;
    }
    tmp___20 = header_init((var )(__constr_expr_11), Int, 2);
    tmp___21 = memcpy((void * __restrict  )((struct Int *)tmp___20), (void const   * __restrict  )(& __constr_expr_10),
                      sizeof(struct Int ));
    tmp___22 = get(args, (var )((struct Int *)tmp___21));
    key = tmp___22;
    __constr_expr_12.val = (int64_t )((2UL + i * 2UL) + 1UL);
    __constr_expr_13[0] = (char)0;
    tmp___23 = 1U;
    while (! (tmp___23 >= 32U)) {
      __constr_expr_13[tmp___23] = (char)0;
      tmp___23 ++;
    }
    tmp___24 = header_init((var )(__constr_expr_13), Int, 2);
    tmp___25 = memcpy((void * __restrict  )((struct Int *)tmp___24), (void const   * __restrict  )(& __constr_expr_12),
                      sizeof(struct Int ));
    tmp___26 = get(args, (var )((struct Int *)tmp___25));
    val = tmp___26;
    Table_Set_Move((var )t, key, val, (_Bool)0);
    i ++;
  }
  return;
}
}
static void Table_Del(var self ) 
{ 
  struct Table *t ;
  size_t i ;
  var tmp ;
  var tmp___0 ;
  uint64_t tmp___1 ;

  {
  t = (struct Table *)self;
  i = (size_t )0;
  while (i < t->nslots) {
    tmp___1 = Table_Key_Hash(t, i);
    if (tmp___1 != 0UL) {
      tmp = Table_Key(t, i);
      destruct(tmp);
      tmp___0 = Table_Val(t, i);
      destruct(tmp___0);
    }
    i ++;
  }
  free(t->data);
  free(t->sspace0);
  free(t->sspace1);
  return;
}
}
static var Table_Key_Type(var self ) 
{ 
  struct Table *t ;

  {
  t = (struct Table *)self;
  return (t->ktype);
}
}
static var Table_Val_Type(var self ) 
{ 
  struct Table *t ;

  {
  t = (struct Table *)self;
  return (t->vtype);
}
}
static void Table_Clear(var self ) 
{ 
  struct Table *t ;
  size_t i ;
  var tmp ;
  var tmp___0 ;
  uint64_t tmp___1 ;

  {
  t = (struct Table *)self;
  i = (size_t )0;
  while (i < t->nslots) {
    tmp___1 = Table_Key_Hash(t, i);
    if (tmp___1 != 0UL) {
      tmp = Table_Key(t, i);
      destruct(tmp);
      tmp___0 = Table_Val(t, i);
      destruct(tmp___0);
    }
    i ++;
  }
  free(t->data);
  t->nslots = (size_t )0;
  t->nitems = (size_t )0;
  t->data = (void *)0;
  return;
}
}
static void Table_Assign(var self , var obj ) 
{ 
  struct Table *t ;
  var tmp___0 ;
  _Bool tmp___1 ;
  var tmp___3 ;
  _Bool tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  struct Tuple __constr_expr_14 ;
  var __constr_expr_15[1] ;
  char __constr_expr_16[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___11 ;
  var tmp___12 ;
  void *tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  var __key ;
  var __Iterkey ;
  var tmp___16 ;
  var key ;
  var tmp___17 ;
  var tmp___18 ;

  {
  t = (struct Table *)self;
  Table_Clear((var )t);
  tmp___1 = implements_method_at_offset(obj, Get, (unsigned long )(& ((struct Get *)0)->key_type));
  if (tmp___1) {
    tmp___0 = key_type(obj);
    t->ktype = tmp___0;
  } else {
    t->ktype = Ref;
  }
  tmp___4 = implements_method_at_offset(obj, Get, (unsigned long )(& ((struct Get *)0)->val_type));
  if (tmp___4) {
    tmp___3 = val_type(obj);
    t->vtype = tmp___3;
  } else {
    t->vtype = Ref;
  }
  tmp___5 = size(t->ktype);
  t->ksize = Table_Size_Round(tmp___5);
  tmp___6 = size(t->vtype);
  t->vsize = Table_Size_Round(tmp___6);
  t->nitems = (size_t )0;
  tmp___7 = len(obj);
  t->nslots = Table_Ideal_Size(tmp___7);
  if (t->nslots == 0UL) {
    t->data = (void *)0;
    return;
  }
  tmp___8 = Table_Step(t);
  t->data = calloc(t->nslots, tmp___8);
  tmp___9 = Table_Step(t);
  t->sspace0 = realloc(t->sspace0, tmp___9);
  tmp___10 = Table_Step(t);
  t->sspace1 = realloc(t->sspace1, tmp___10);
  if ((unsigned long )t->data == (unsigned long )((void *)0)) {
    goto _L;
  } else
  if ((unsigned long )t->sspace0 == (unsigned long )((void *)0)) {
    goto _L;
  } else
  if ((unsigned long )t->sspace1 == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
    __constr_expr_15[0] = Terminal;
    __constr_expr_14.items = __constr_expr_15;
    __constr_expr_16[0] = (char)0;
    tmp___11 = 1U;
    while (! (tmp___11 >= 32U)) {
      __constr_expr_16[tmp___11] = (char)0;
      tmp___11 ++;
    }
    tmp___12 = header_init((var )(__constr_expr_16), Tuple, 2);
    tmp___13 = memcpy((void * __restrict  )((struct Tuple *)tmp___12), (void const   * __restrict  )(& __constr_expr_14),
                      sizeof(struct Tuple ));
    exception_throw(OutOfMemoryError, "Cannot allocate Table, out of memory!", (var )((struct Tuple *)tmp___13));
  }
  tmp___14 = Table_Step(t);
  memset(t->sspace0, 0, tmp___14);
  tmp___15 = Table_Step(t);
  memset(t->sspace1, 0, tmp___15);
  __key = obj;
  tmp___16 = instance(__key, Iter);
  __Iterkey = tmp___16;
  tmp___17 = (*(((struct Iter *)__Iterkey)->iter_init))(__key);
  key = tmp___17;
  while ((unsigned long )key != (unsigned long )Terminal) {
    tmp___18 = get(obj, key);
    Table_Set_Move((var )t, key, tmp___18, (_Bool)0);
    key = (*(((struct Iter *)__Iterkey)->iter_next))(__key, key);
  }
  return;
}
}
static var Table_Iter_Init(var self ) ;
static var Table_Iter_Next(var self , var curr ) ;
static _Bool Table_Mem(var self , var key ) ;
static var Table_Get(var self , var key ) ;
static int Table_Cmp(var self , var obj ) 
{ 
  int c ;
  var item0 ;
  var tmp ;
  var item1 ;
  var tmp___0 ;
  var tmp___1 ;
  var tmp___2 ;

  {
  tmp = Table_Iter_Init(self);
  item0 = tmp;
  tmp___0 = iter_init(obj);
  item1 = tmp___0;
  while (1) {
    if ((unsigned long )item0 == (unsigned long )Terminal) {
      if ((unsigned long )item1 == (unsigned long )Terminal) {
        return (0);
      }
    }
    if ((unsigned long )item0 == (unsigned long )Terminal) {
      return (-1);
    }
    if ((unsigned long )item1 == (unsigned long )Terminal) {
      return (1);
    }
    c = cmp(item0, item1);
    if (c < 0) {
      return (-1);
    }
    if (c > 0) {
      return (1);
    }
    tmp___1 = get(obj, item1);
    tmp___2 = Table_Get(self, item0);
    c = cmp(tmp___2, tmp___1);
    if (c < 0) {
      return (-1);
    }
    if (c > 0) {
      return (1);
    }
    item0 = Table_Iter_Next(self, item0);
    item1 = iter_next(obj, item1);
  }
  return (0);
}
}
static uint64_t Table_Hash(var self ) 
{ 
  struct Table *t ;
  uint64_t h ;
  var curr ;
  var tmp ;
  var vurr ;
  uint64_t tmp___0 ;
  uint64_t tmp___1 ;

  {
  t = (struct Table *)self;
  h = (uint64_t )0;
  tmp = Table_Iter_Init(self);
  curr = tmp;
  while ((unsigned long )curr != (unsigned long )Terminal) {
    vurr = (var )(((char *)curr + t->ksize) + sizeof(struct Header ));
    tmp___0 = hash(curr);
    tmp___1 = hash(vurr);
    h = (h ^ tmp___0) ^ tmp___1;
    curr = Table_Iter_Next(self, curr);
  }
  return (h);
}
}
static size_t Table_Len(var self ) 
{ 
  struct Table *t ;

  {
  t = (struct Table *)self;
  return (t->nitems);
}
}
static var Table_Swapspace_Key(struct Table *t , var space ) 
{ 


  {
  return ((var )(((char *)space + sizeof(uint64_t )) + sizeof(struct Header )));
}
}
static void Table_Set_Move(var self , var key , var val , _Bool move ) 
{ 
  struct Table *t ;
  uint64_t i ;
  uint64_t tmp ;
  uint64_t j ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  uint64_t ihash ;
  struct Header *khead ;
  struct Header *vhead ;
  uint64_t ihash___0 ;
  uint64_t h ;
  uint64_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  var tmp___5 ;
  var tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  var tmp___9 ;
  var tmp___10 ;
  _Bool tmp___11 ;
  uint64_t p ;
  uint64_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;

  {
  t = (struct Table *)self;
  key = cast(key, t->ktype);
  val = cast(val, t->vtype);
  tmp = hash(key);
  i = tmp % t->nslots;
  j = (uint64_t )0;
  tmp___0 = Table_Step(t);
  memset(t->sspace0, 0, tmp___0);
  tmp___1 = Table_Step(t);
  memset(t->sspace1, 0, tmp___1);
  if (move) {
    ihash = i + 1UL;
    memcpy((void * __restrict  )((char *)t->sspace0), (void const   * __restrict  )(& ihash),
           sizeof(uint64_t ));
    memcpy((void * __restrict  )((char *)t->sspace0 + sizeof(uint64_t )), (void const   * __restrict  )((char *)key - sizeof(struct Header )),
           t->ksize + sizeof(struct Header ));
    memcpy((void * __restrict  )((((char *)t->sspace0 + sizeof(uint64_t )) + sizeof(struct Header )) + t->ksize),
           (void const   * __restrict  )((char *)val - sizeof(struct Header )), t->vsize + sizeof(struct Header ));
  } else {
    khead = (struct Header *)((char *)t->sspace0 + sizeof(uint64_t ));
    vhead = (struct Header *)((((char *)t->sspace0 + sizeof(uint64_t )) + sizeof(struct Header )) + t->ksize);
    header_init((var )khead, t->ktype, 4);
    header_init((var )vhead, t->vtype, 4);
    ihash___0 = i + 1UL;
    memcpy((void * __restrict  )((char *)t->sspace0), (void const   * __restrict  )(& ihash___0),
           sizeof(uint64_t ));
    assign((var )(((char *)t->sspace0 + sizeof(uint64_t )) + sizeof(struct Header )),
           key);
    assign((var )(((((char *)t->sspace0 + sizeof(uint64_t )) + sizeof(struct Header )) + t->ksize) + sizeof(struct Header )),
           val);
  }
  while (1) {
    tmp___2 = Table_Key_Hash(t, i);
    h = tmp___2;
    if (h == 0UL) {
      tmp___3 = Table_Step(t);
      tmp___4 = Table_Step(t);
      memcpy((void * __restrict  )((char *)t->data + i * tmp___4), (void const   * __restrict  )t->sspace0,
             tmp___3);
      (t->nitems) ++;
      return;
    }
    tmp___9 = Table_Swapspace_Key(t, t->sspace0);
    tmp___10 = Table_Key(t, i);
    tmp___11 = eq(tmp___10, tmp___9);
    if (tmp___11) {
      tmp___5 = Table_Key(t, i);
      destruct(tmp___5);
      tmp___6 = Table_Val(t, i);
      destruct(tmp___6);
      tmp___7 = Table_Step(t);
      tmp___8 = Table_Step(t);
      memcpy((void * __restrict  )((char *)t->data + i * tmp___8), (void const   * __restrict  )t->sspace0,
             tmp___7);
      return;
    }
    tmp___12 = Table_Probe(t, i, h);
    p = tmp___12;
    if (j >= p) {
      tmp___13 = Table_Step(t);
      tmp___14 = Table_Step(t);
      memcpy((void * __restrict  )((char *)t->sspace1), (void const   * __restrict  )((char *)t->data + i * tmp___14),
             tmp___13);
      tmp___15 = Table_Step(t);
      tmp___16 = Table_Step(t);
      memcpy((void * __restrict  )((char *)t->data + i * tmp___16), (void const   * __restrict  )((char *)t->sspace0),
             tmp___15);
      tmp___17 = Table_Step(t);
      memcpy((void * __restrict  )((char *)t->sspace0), (void const   * __restrict  )((char *)t->sspace1),
             tmp___17);
      j = p;
    }
    i = (i + 1UL) % t->nslots;
    j ++;
  }
}
}
static void Table_Rehash(struct Table *t , size_t new_size ) 
{ 
  var old_data ;
  size_t old_size ;
  size_t tmp ;
  struct Tuple __constr_expr_17 ;
  var __constr_expr_18[1] ;
  char __constr_expr_19[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;
  size_t i ;
  uint64_t h ;
  size_t tmp___3 ;
  var key ;
  size_t tmp___4 ;
  var val ;
  size_t tmp___5 ;

  {
  old_data = t->data;
  old_size = t->nslots;
  t->nslots = new_size;
  t->nitems = (size_t )0;
  tmp = Table_Step(t);
  t->data = calloc(t->nslots, tmp);
  if ((unsigned long )t->data == (unsigned long )((void *)0)) {
    __constr_expr_18[0] = Terminal;
    __constr_expr_17.items = __constr_expr_18;
    __constr_expr_19[0] = (char)0;
    tmp___0 = 1U;
    while (! (tmp___0 >= 32U)) {
      __constr_expr_19[tmp___0] = (char)0;
      tmp___0 ++;
    }
    tmp___1 = header_init((var )(__constr_expr_19), Tuple, 2);
    tmp___2 = memcpy((void * __restrict  )((struct Tuple *)tmp___1), (void const   * __restrict  )(& __constr_expr_17),
                     sizeof(struct Tuple ));
    exception_throw(OutOfMemoryError, "Cannot allocate Table, out of memory!", (var )((struct Tuple *)tmp___2));
  }
  i = (size_t )0;
  while (i < old_size) {
    tmp___3 = Table_Step(t);
    h = *((uint64_t *)((char *)old_data + i * tmp___3));
    if (h != 0UL) {
      tmp___4 = Table_Step(t);
      key = (var )((((char *)old_data + i * tmp___4) + sizeof(uint64_t )) + sizeof(struct Header ));
      tmp___5 = Table_Step(t);
      val = (var )((((((char *)old_data + i * tmp___5) + sizeof(uint64_t )) + sizeof(struct Header )) + t->ksize) + sizeof(struct Header ));
      Table_Set_Move((var )t, key, val, (_Bool)1);
    }
    i ++;
  }
  free(old_data);
  return;
}
}
static void Table_Resize_More(struct Table *t ) 
{ 
  size_t new_size ;
  size_t tmp ;
  size_t old_size ;

  {
  tmp = Table_Ideal_Size(t->nitems);
  new_size = tmp;
  old_size = t->nslots;
  if (new_size > old_size) {
    Table_Rehash(t, new_size);
  }
  return;
}
}
static void Table_Resize_Less(struct Table *t ) 
{ 
  size_t new_size ;
  size_t tmp ;
  size_t old_size ;

  {
  tmp = Table_Ideal_Size(t->nitems);
  new_size = tmp;
  old_size = t->nslots;
  if (new_size < old_size) {
    Table_Rehash(t, new_size);
  }
  return;
}
}
static _Bool Table_Mem(var self , var key ) 
{ 
  struct Table *t ;
  uint64_t i ;
  uint64_t tmp ;
  uint64_t j ;
  uint64_t h ;
  uint64_t tmp___0 ;
  uint64_t tmp___1 ;
  var tmp___2 ;
  _Bool tmp___3 ;

  {
  t = (struct Table *)self;
  key = cast(key, t->ktype);
  if (t->nslots == 0UL) {
    return ((_Bool)0);
  }
  tmp = hash(key);
  i = tmp % t->nslots;
  j = (uint64_t )0;
  while (1) {
    tmp___0 = Table_Key_Hash(t, i);
    h = tmp___0;
    if (h == 0UL) {
      return ((_Bool)0);
    } else {
      tmp___1 = Table_Probe(t, i, h);
      if (j > tmp___1) {
        return ((_Bool)0);
      }
    }
    tmp___2 = Table_Key(t, i);
    tmp___3 = eq(tmp___2, key);
    if (tmp___3) {
      return ((_Bool)1);
    }
    i = (i + 1UL) % t->nslots;
    j ++;
  }
  return ((_Bool)0);
}
}
static void Table_Rem(var self , var key ) 
{ 
  struct Table *t ;
  struct Tuple __constr_expr_20 ;
  var __constr_expr_21[2] ;
  char __constr_expr_22[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  uint64_t i ;
  uint64_t tmp___2 ;
  uint64_t j ;
  uint64_t h ;
  uint64_t tmp___3 ;
  struct Tuple __constr_expr_23 ;
  var __constr_expr_24[2] ;
  char __constr_expr_25[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___4 ;
  var tmp___5 ;
  void *tmp___6 ;
  uint64_t tmp___7 ;
  var tmp___8 ;
  var tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  uint64_t ni ;
  uint64_t nh ;
  uint64_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  uint64_t tmp___18 ;
  var tmp___19 ;
  _Bool tmp___20 ;

  {
  t = (struct Table *)self;
  key = cast(key, t->ktype);
  if (t->nslots == 0UL) {
    __constr_expr_21[0] = key;
    __constr_expr_21[1] = Terminal;
    __constr_expr_20.items = __constr_expr_21;
    __constr_expr_22[0] = (char)0;
    tmp = 1U;
    while (! (tmp >= 32U)) {
      __constr_expr_22[tmp] = (char)0;
      tmp ++;
    }
    tmp___0 = header_init((var )(__constr_expr_22), Tuple, 2);
    tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_20),
                     sizeof(struct Tuple ));
    exception_throw(KeyError, "Key %$ not in Table!", (var )((struct Tuple *)tmp___1));
  }
  tmp___2 = hash(key);
  i = tmp___2 % t->nslots;
  j = (uint64_t )0;
  while (1) {
    tmp___3 = Table_Key_Hash(t, i);
    h = tmp___3;
    if (h == 0UL) {
      goto _L;
    } else {
      tmp___7 = Table_Probe(t, i, h);
      if (j > tmp___7) {
        _L: /* CIL Label */ 
        __constr_expr_24[0] = key;
        __constr_expr_24[1] = Terminal;
        __constr_expr_23.items = __constr_expr_24;
        __constr_expr_25[0] = (char)0;
        tmp___4 = 1U;
        while (! (tmp___4 >= 32U)) {
          __constr_expr_25[tmp___4] = (char)0;
          tmp___4 ++;
        }
        tmp___5 = header_init((var )(__constr_expr_25), Tuple, 2);
        tmp___6 = memcpy((void * __restrict  )((struct Tuple *)tmp___5), (void const   * __restrict  )(& __constr_expr_23),
                         sizeof(struct Tuple ));
        exception_throw(KeyError, "Key %$ not in Table!", (var )((struct Tuple *)tmp___6));
      }
    }
    tmp___19 = Table_Key(t, i);
    tmp___20 = eq(tmp___19, key);
    if (tmp___20) {
      tmp___8 = Table_Key(t, i);
      destruct(tmp___8);
      tmp___9 = Table_Val(t, i);
      destruct(tmp___9);
      tmp___10 = Table_Step(t);
      tmp___11 = Table_Step(t);
      memset((void *)((char *)t->data + i * tmp___11), 0, tmp___10);
      while (1) {
        ni = (i + 1UL) % t->nslots;
        tmp___12 = Table_Key_Hash(t, ni);
        nh = tmp___12;
        if (nh != 0UL) {
          tmp___18 = Table_Probe(t, ni, nh);
          if (tmp___18 > 0UL) {
            tmp___13 = Table_Step(t);
            tmp___14 = Table_Step(t);
            tmp___15 = Table_Step(t);
            memcpy((void * __restrict  )((char *)t->data + i * tmp___15), (void const   * __restrict  )((char *)t->data + ni * tmp___14),
                   tmp___13);
            tmp___16 = Table_Step(t);
            tmp___17 = Table_Step(t);
            memset((void *)((char *)t->data + ni * tmp___17), 0, tmp___16);
            i = ni;
          } else {
            break;
          }
        } else {
          break;
        }
      }
      (t->nitems) --;
      Table_Resize_Less(t);
      return;
    }
    i = (i + 1UL) % t->nslots;
    j ++;
  }
}
}
static var Table_Get(var self , var key ) 
{ 
  struct Table *t ;
  size_t tmp ;
  var tmp___0 ;
  size_t tmp___1 ;
  struct Tuple __constr_expr_26 ;
  var __constr_expr_27[2] ;
  char __constr_expr_28[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___2 ;
  var tmp___3 ;
  void *tmp___4 ;
  uint64_t i ;
  uint64_t tmp___5 ;
  uint64_t j ;
  uint64_t h ;
  uint64_t tmp___6 ;
  struct Tuple __constr_expr_29 ;
  var __constr_expr_30[2] ;
  char __constr_expr_31[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___7 ;
  var tmp___8 ;
  void *tmp___9 ;
  uint64_t tmp___10 ;
  var tmp___11 ;
  var tmp___12 ;
  _Bool tmp___13 ;

  {
  t = (struct Table *)self;
  if ((unsigned long )key >= (unsigned long )t->data) {
    tmp___1 = Table_Step((struct Table *)self);
    if ((unsigned long )((char *)key) < (unsigned long )((char *)t->data + t->nslots * tmp___1)) {
      tmp = Table_Step((struct Table *)self);
      tmp___0 = Table_Val((struct Table *)self, (size_t )((char *)key - (char *)t->data) / tmp);
      return (tmp___0);
    }
  }
  key = cast(key, t->ktype);
  if (t->nslots == 0UL) {
    __constr_expr_27[0] = key;
    __constr_expr_27[1] = Terminal;
    __constr_expr_26.items = __constr_expr_27;
    __constr_expr_28[0] = (char)0;
    tmp___2 = 1U;
    while (! (tmp___2 >= 32U)) {
      __constr_expr_28[tmp___2] = (char)0;
      tmp___2 ++;
    }
    tmp___3 = header_init((var )(__constr_expr_28), Tuple, 2);
    tmp___4 = memcpy((void * __restrict  )((struct Tuple *)tmp___3), (void const   * __restrict  )(& __constr_expr_26),
                     sizeof(struct Tuple ));
    exception_throw(KeyError, "Key %$ not in Table!", (var )((struct Tuple *)tmp___4));
  }
  tmp___5 = hash(key);
  i = tmp___5 % t->nslots;
  j = (uint64_t )0;
  while (1) {
    tmp___6 = Table_Key_Hash(t, i);
    h = tmp___6;
    if (h == 0UL) {
      goto _L;
    } else {
      tmp___10 = Table_Probe(t, i, h);
      if (j > tmp___10) {
        _L: /* CIL Label */ 
        __constr_expr_30[0] = key;
        __constr_expr_30[1] = Terminal;
        __constr_expr_29.items = __constr_expr_30;
        __constr_expr_31[0] = (char)0;
        tmp___7 = 1U;
        while (! (tmp___7 >= 32U)) {
          __constr_expr_31[tmp___7] = (char)0;
          tmp___7 ++;
        }
        tmp___8 = header_init((var )(__constr_expr_31), Tuple, 2);
        tmp___9 = memcpy((void * __restrict  )((struct Tuple *)tmp___8), (void const   * __restrict  )(& __constr_expr_29),
                         sizeof(struct Tuple ));
        exception_throw(KeyError, "Key %$ not in Table!", (var )((struct Tuple *)tmp___9));
      }
    }
    tmp___12 = Table_Key(t, i);
    tmp___13 = eq(tmp___12, key);
    if (tmp___13) {
      tmp___11 = Table_Val(t, i);
      return (tmp___11);
    }
    i = (i + 1UL) % t->nslots;
    j ++;
  }
  return ((void *)0);
}
}
static void Table_Set(var self , var key , var val ) 
{ 


  {
  Table_Set_Move(self, key, val, (_Bool)0);
  Table_Resize_More((struct Table *)self);
  return;
}
}
static var Table_Iter_Init(var self ) 
{ 
  struct Table *t ;
  size_t i ;
  var tmp ;
  uint64_t tmp___0 ;

  {
  t = (struct Table *)self;
  if (t->nitems == 0UL) {
    return (Terminal);
  }
  i = (size_t )0;
  while (i < t->nslots) {
    tmp___0 = Table_Key_Hash(t, i);
    if (tmp___0 != 0UL) {
      tmp = Table_Key(t, i);
      return (tmp);
    }
    i ++;
  }
  return (Terminal);
}
}
static var Table_Iter_Next(var self , var curr ) 
{ 
  struct Table *t ;
  size_t tmp ;
  var tmp___0 ;
  uint64_t h ;
  size_t tmp___1 ;

  {
  t = (struct Table *)self;
  tmp = Table_Step(t);
  curr = (var )((char *)curr + tmp);
  while (1) {
    tmp___0 = Table_Key(t, t->nslots - 1UL);
    if ((unsigned long )curr > (unsigned long )tmp___0) {
      return (Terminal);
    }
    h = *((uint64_t *)(((char *)curr - sizeof(struct Header )) - sizeof(uint64_t )));
    if (h != 0UL) {
      return (curr);
    }
    tmp___1 = Table_Step(t);
    curr = (var )((char *)curr + tmp___1);
  }
  return (Terminal);
}
}
static var Table_Iter_Last(var self ) 
{ 
  struct Table *t ;
  size_t i ;
  var tmp ;
  uint64_t tmp___0 ;

  {
  t = (struct Table *)self;
  if (t->nitems == 0UL) {
    return (Terminal);
  }
  i = t->nslots - 1UL;
  while (1) {
    tmp___0 = Table_Key_Hash(t, i);
    if (tmp___0 != 0UL) {
      tmp = Table_Key(t, i);
      return (tmp);
    }
    if (i == 0UL) {
      break;
    }
    i --;
  }
  return (Terminal);
}
}
static var Table_Iter_Prev(var self , var curr ) 
{ 
  struct Table *t ;
  size_t tmp ;
  var tmp___0 ;
  uint64_t h ;
  size_t tmp___1 ;

  {
  t = (struct Table *)self;
  tmp = Table_Step(t);
  curr = (var )((char *)curr - tmp);
  while (1) {
    tmp___0 = Table_Key(t, (uint64_t )0);
    if ((unsigned long )curr < (unsigned long )tmp___0) {
      return (Terminal);
    }
    h = *((uint64_t *)(((char *)curr - sizeof(struct Header )) - sizeof(uint64_t )));
    if (h != 0UL) {
      return (curr);
    }
    tmp___1 = Table_Step(t);
    curr = (var )((char *)curr - tmp___1);
  }
  return (Terminal);
}
}
static var Table_Iter_Type(var self ) 
{ 
  struct Table *t ;

  {
  t = (struct Table *)self;
  return (t->ktype);
}
}
static int Table_Show(var self , var output , int pos ) 
{ 
  struct Table *t ;
  struct Tuple __constr_expr_32 ;
  var __constr_expr_33[2] ;
  char __constr_expr_34[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  size_t j ;
  size_t i ;
  struct Tuple __constr_expr_35 ;
  var __constr_expr_36[3] ;
  var tmp___2 ;
  var tmp___3 ;
  char __constr_expr_37[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___4 ;
  var tmp___5 ;
  void *tmp___6 ;
  struct Tuple __constr_expr_38 ;
  var __constr_expr_39[1] ;
  char __constr_expr_40[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___7 ;
  var tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  uint64_t tmp___11 ;
  struct Tuple __constr_expr_41 ;
  var __constr_expr_42[1] ;
  char __constr_expr_43[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___12 ;
  var tmp___13 ;
  void *tmp___14 ;
  int tmp___15 ;

  {
  t = (struct Table *)self;
  __constr_expr_33[0] = self;
  __constr_expr_33[1] = Terminal;
  __constr_expr_32.items = __constr_expr_33;
  __constr_expr_34[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_34[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_34), Tuple, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_32),
                   sizeof(struct Tuple ));
  pos = print_to_with(output, pos, "<\'Table\' At 0x%p {", (var )((struct Tuple *)tmp___1));
  j = (size_t )0;
  i = (size_t )0;
  while (i < t->nslots) {
    tmp___11 = Table_Key_Hash(t, i);
    if (tmp___11 != 0UL) {
      tmp___2 = Table_Key(t, i);
      tmp___3 = Table_Val(t, i);
      __constr_expr_36[0] = tmp___2;
      __constr_expr_36[1] = tmp___3;
      __constr_expr_36[2] = Terminal;
      __constr_expr_35.items = __constr_expr_36;
      __constr_expr_37[0] = (char)0;
      tmp___4 = 1U;
      while (! (tmp___4 >= 32U)) {
        __constr_expr_37[tmp___4] = (char)0;
        tmp___4 ++;
      }
      tmp___5 = header_init((var )(__constr_expr_37), Tuple, 2);
      tmp___6 = memcpy((void * __restrict  )((struct Tuple *)tmp___5), (void const   * __restrict  )(& __constr_expr_35),
                       sizeof(struct Tuple ));
      pos = print_to_with(output, pos, "%$:%$", (var )((struct Tuple *)tmp___6));
      tmp___10 = Table_Len((var )t);
      if (j < tmp___10 - 1UL) {
        __constr_expr_39[0] = Terminal;
        __constr_expr_38.items = __constr_expr_39;
        __constr_expr_40[0] = (char)0;
        tmp___7 = 1U;
        while (! (tmp___7 >= 32U)) {
          __constr_expr_40[tmp___7] = (char)0;
          tmp___7 ++;
        }
        tmp___8 = header_init((var )(__constr_expr_40), Tuple, 2);
        tmp___9 = memcpy((void * __restrict  )((struct Tuple *)tmp___8), (void const   * __restrict  )(& __constr_expr_38),
                         sizeof(struct Tuple ));
        pos = print_to_with(output, pos, ", ", (var )((struct Tuple *)tmp___9));
      }
      j ++;
    }
    i ++;
  }
  __constr_expr_42[0] = Terminal;
  __constr_expr_41.items = __constr_expr_42;
  __constr_expr_43[0] = (char)0;
  tmp___12 = 1U;
  while (! (tmp___12 >= 32U)) {
    __constr_expr_43[tmp___12] = (char)0;
    tmp___12 ++;
  }
  tmp___13 = header_init((var )(__constr_expr_43), Tuple, 2);
  tmp___14 = memcpy((void * __restrict  )((struct Tuple *)tmp___13), (void const   * __restrict  )(& __constr_expr_41),
                    sizeof(struct Tuple ));
  tmp___15 = print_to_with(output, pos, "}>", (var )((struct Tuple *)tmp___14));
  return (tmp___15);
}
}
static void Table_Resize(var self , size_t n ) 
{ 
  struct Table *t ;
  struct Tuple __constr_expr_44 ;
  var __constr_expr_45[2] ;
  struct Int __constr_expr_46 ;
  char __constr_expr_47[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  char __constr_expr_48[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___2 ;
  var tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;

  {
  t = (struct Table *)self;
  if (n == 0UL) {
    Table_Clear((var )t);
    return;
  }
  if (n < t->nitems) {
    __constr_expr_46.val = (int64_t )t->nitems;
    __constr_expr_47[0] = (char)0;
    tmp = 1U;
    while (! (tmp >= 32U)) {
      __constr_expr_47[tmp] = (char)0;
      tmp ++;
    }
    tmp___0 = header_init((var )(__constr_expr_47), Int, 2);
    tmp___1 = memcpy((void * __restrict  )((struct Int *)tmp___0), (void const   * __restrict  )(& __constr_expr_46),
                     sizeof(struct Int ));
    __constr_expr_45[0] = (var )((struct Int *)tmp___1);
    __constr_expr_45[1] = Terminal;
    __constr_expr_44.items = __constr_expr_45;
    __constr_expr_48[0] = (char)0;
    tmp___2 = 1U;
    while (! (tmp___2 >= 32U)) {
      __constr_expr_48[tmp___2] = (char)0;
      tmp___2 ++;
    }
    tmp___3 = header_init((var )(__constr_expr_48), Tuple, 2);
    tmp___4 = memcpy((void * __restrict  )((struct Tuple *)tmp___3), (void const   * __restrict  )(& __constr_expr_44),
                     sizeof(struct Tuple ));
    exception_throw(FormatError, "Cannot resize Table to make it smaller than %li items",
                    (var )((struct Tuple *)tmp___4));
  }
  tmp___5 = Table_Ideal_Size(n);
  Table_Rehash(t, tmp___5);
  return;
}
}
static void Table_Mark(var self , var gc , void (*f)(var  , void * ) ) 
{ 
  struct Table *t ;
  size_t i ;
  var tmp ;
  var tmp___0 ;
  uint64_t tmp___1 ;

  {
  t = (struct Table *)self;
  i = (size_t )0;
  while (i < t->nslots) {
    tmp___1 = Table_Key_Hash(t, i);
    if (tmp___1 != 0UL) {
      tmp = Table_Key(t, i);
      (*f)(gc, tmp);
      tmp___0 = Table_Val(t, i);
      (*f)(gc, tmp___0);
    }
    i ++;
  }
  return;
}
}
static struct Doc __constr_expr_50  =    {& Table_Name, & Table_Brief, & Table_Description, (char const   *(*)(void))((void *)0),
    & Table_Examples, (struct Method *(*)(void))((void *)0)};
static struct New __constr_expr_51  =    {& Table_New, & Table_Del};
static struct Assign __constr_expr_52  =    {& Table_Assign};
static struct Mark __constr_expr_53  =    {& Table_Mark};
static struct Cmp __constr_expr_54  =    {& Table_Cmp};
static struct Hash __constr_expr_55  =    {& Table_Hash};
static struct Len __constr_expr_56  =    {& Table_Len};
static struct Get __constr_expr_57  =    {& Table_Get, & Table_Set, & Table_Mem, & Table_Rem, & Table_Key_Type, & Table_Val_Type};
static struct Iter __constr_expr_58  =    {& Table_Iter_Init,
    & Table_Iter_Next, & Table_Iter_Last, & Table_Iter_Prev, & Table_Iter_Type};
static struct Show __constr_expr_59  =    {& Table_Show, (int (*)(var  , var  , int  ))((void *)0)};
static struct Resize __constr_expr_60  =    {& Table_Resize};
static var __constr_expr_49[63]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Table", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Table ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_50),      (void *)0,      (var )"New", 
        (var )(& __constr_expr_51),      (void *)0,      (var )"Assign",      (var )(& __constr_expr_52), 
        (void *)0,      (var )"Mark",      (var )(& __constr_expr_53),      (void *)0, 
        (var )"Cmp",      (var )(& __constr_expr_54),      (void *)0,      (var )"Hash", 
        (var )(& __constr_expr_55),      (void *)0,      (var )"Len",      (var )(& __constr_expr_56), 
        (void *)0,      (var )"Get",      (var )(& __constr_expr_57),      (void *)0, 
        (var )"Iter",      (var )(& __constr_expr_58),      (void *)0,      (var )"Show", 
        (var )(& __constr_expr_59),      (void *)0,      (var )"Resize",      (var )(& __constr_expr_60), 
        (void *)0,      (void *)0,      (void *)0};
var Table  =    (var )((char *)(__constr_expr_49) + sizeof(struct Header ));
#pragma merger("0","/tmp/cil-c_Fnod7q.i","-std=gnu99,-Wall,-Wno-unused,-g,-ggdb,-fPIC")
var Resize ;
var method_at_offset(var self , var cls , size_t offset , char const   *method_name ) ;
void resize(var self , size_t n ) ;
static char const   *Resize_Name(void) 
{ 


  {
  return ("Reserve");
}
}
static char const   *Resize_Brief(void) 
{ 


  {
  return ("Object can be resized");
}
}
static char const   *Resize_Description(void) 
{ 


  {
  return ("The `Resize` class can be implemented by objects which can be resized in some way. Resizing to a larger size than the current may allow for some resource or other to be preallocated or reserved. For example this class is implemented by `Array` and `Table` to either remove a number of items quickly or to preallocate memory space if it is known that many items are going to be added at a later date.");
}
}
static char const   *Resize_Definition(void) 
{ 


  {
  return ("struct Resize {\n  void (*resize)(var, size_t);\n};\n");
}
}
static struct Method *Resize_Methods(void) ;
static struct Method methods[2]  = {      {"resize", "void resize(var self, size_t n);", "Resize to some size `n`, perhaps reserving some resource for object `self`."}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Resize_Methods(void) 
{ 


  {
  return (methods);
}
}
static struct Example *Resize_Examples(void) ;
static struct Example examples___0[3]  = {      {"Usage", "var x = new(Array, Int);\nresize(x, 10000); /* Reserve space in Array */ \nfor (size_t i = 0; i < 10000; i++) {\n  push(x, $I(i));\n}\n"}, 
        {"Usage 2",
      "var x = new(Array, Int, $I(0), $I(1), $I(2));\nresize(x, 0); /* Clear Array of items */\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Resize_Examples(void) 
{ 


  {
  return (examples___0);
}
}
static struct Doc __constr_expr_62  =    {& Resize_Name, & Resize_Brief, & Resize_Description, & Resize_Definition, & Resize_Examples,
    & Resize_Methods};
static var __constr_expr_61[33]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Resize", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Resize ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_62),      (void *)0,      (void *)0, 
        (void *)0};
var Resize  =    (var )((char *)(__constr_expr_61) + sizeof(struct Header ));
void resize(var self , size_t n ) 
{ 
  var tmp ;

  {
  tmp = method_at_offset(self, Resize, (unsigned long )(& ((struct Resize *)0)->resize),
                         "resize");
  (*(((struct Resize *)tmp)->resize))(self, n);
  return;
}
}
#pragma merger("0","/tmp/cil-qTCL7FaA.i","-std=gnu99,-Wall,-Wno-unused,-g,-ggdb,-fPIC")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
var Range ;
var Slice ;
var Zip ;
var Filter ;
var Map ;
var _ ;
var IndexOutOfBoundsError ;
var new_with(var type , var args ) ;
void del(var self ) ;
var iter_prev(var self , var curr ) ;
var iter_last(var self ) ;
var iter_type(var self ) ;
void push(var self , var val ) ;
int64_t c_int(var self ) ;
var range_stack(var self , var args ) ;
var slice_stack(var self , var args ) ;
var zip_stack(var self ) ;
var enumerate_stack(var self ) ;
var call_with(var self , var args ) ;
static var __constr_expr_63[30]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"_", 
        (void *)0,      (var )"__Size",      (var )0,      (void *)0, 
        (void *)0,      (void *)0};
var _  =    (var )((char *)(__constr_expr_63) + sizeof(struct Header ));
static var __constr_expr_64[30]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Terminal", 
        (void *)0,      (var )"__Size",      (var )0,      (void *)0, 
        (void *)0,      (void *)0};
var Terminal  =    (var )((char *)(__constr_expr_64) + sizeof(struct Header ));
static char const   *Iter_Name(void) 
{ 


  {
  return ("Iter");
}
}
static char const   *Iter_Brief(void) 
{ 


  {
  return ("Iterable");
}
}
static char const   *Iter_Description(void) 
{ 


  {
  return ("The `Iter` class is implemented by types which can be looped over. This allows them to be used in conjunction with the `foreach` macro as well as various other components of Cello.\n\nTo signal that an interation has finished an iteration should return the Cello object `Terminal`. Due to this - the `Terminal` object cannot be placed inside of Tuples because it artificially shortens their length.");
}
}
static char const   *Iter_Definition(void) 
{ 


  {
  return ("struct Iter {\n  var (*iter_init)(var);\n  var (*iter_next)(var, var);\n  var (*iter_prev)(var, var);\n  var (*iter_last)(var);\n  var (*iter_type)(var);\n};\n");
}
}
static struct Example *Iter_Examples(void) ;
static struct Example examples___1[3]  = {      {"Usage", "var x = new(Array, Int, $I(1), $I(2), $I(5));\n\nforeach(o in x) {\n  show(o); /* 1, 2, 5 */\n}\n"}, 
        {"Table",
      "var prices = new(Table, String, Int);\nset(prices, $S(\"Apple\"),  $I(12));\nset(prices, $S(\"Banana\"), $I( 6));\nset(prices, $S(\"Pear\"),   $I(55));\n\nforeach(key in prices) {\n  var price = get(prices, key);\n  print(\"Price of %$ is %$\\n\", key, price);\n}\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Iter_Examples(void) 
{ 


  {
  return (examples___1);
}
}
static struct Method *Iter_Methods(void) ;
static struct Method methods___0[5]  = {      {"foreach", "#define foreach(...)\n", "Iterate over elements in a loop."}, 
        {"iter_init", "var iter_init(var self);\nvar iter_last(var self);", "Return the initial item (or final item) in the iteration over `self`."}, 
        {"iter_next",
      "var iter_next(var self, var curr);\nvar iter_prev(var self, var curr);", "Given the current item `curr`, return the next (or previous) item in the iteration over `self`."}, 
        {"iter_type",
      "var iter_type(var self);", "Returns the type of item that can be expected to be returned by the iterable."}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Iter_Methods(void) 
{ 


  {
  return (methods___0);
}
}
static struct Doc __constr_expr_66  =    {& Iter_Name, & Iter_Brief, & Iter_Description, & Iter_Definition, & Iter_Examples,
    & Iter_Methods};
static var __constr_expr_65[33]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Iter", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Iter ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_66),      (void *)0,      (void *)0, 
        (void *)0};
var Iter  =    (var )((char *)(__constr_expr_65) + sizeof(struct Header ));
var iter_init(var self ) 
{ 
  var tmp ;
  var tmp___0 ;

  {
  tmp = method_at_offset(self, Iter, (unsigned long )(& ((struct Iter *)0)->iter_init),
                         "iter_init");
  tmp___0 = (*(((struct Iter *)tmp)->iter_init))(self);
  return (tmp___0);
}
}
var iter_next(var self , var curr ) 
{ 
  var tmp ;
  var tmp___0 ;

  {
  tmp = method_at_offset(self, Iter, (unsigned long )(& ((struct Iter *)0)->iter_next),
                         "iter_next");
  tmp___0 = (*(((struct Iter *)tmp)->iter_next))(self, curr);
  return (tmp___0);
}
}
var iter_last(var self ) 
{ 
  var tmp ;
  var tmp___0 ;

  {
  tmp = method_at_offset(self, Iter, (unsigned long )(& ((struct Iter *)0)->iter_last),
                         "iter_last");
  tmp___0 = (*(((struct Iter *)tmp)->iter_last))(self);
  return (tmp___0);
}
}
var iter_prev(var self , var curr ) 
{ 
  var tmp ;
  var tmp___0 ;

  {
  tmp = method_at_offset(self, Iter, (unsigned long )(& ((struct Iter *)0)->iter_prev),
                         "iter_prev");
  tmp___0 = (*(((struct Iter *)tmp)->iter_prev))(self, curr);
  return (tmp___0);
}
}
var iter_type(var self ) 
{ 
  var tmp ;
  var tmp___0 ;

  {
  tmp = method_at_offset(self, Iter, (unsigned long )(& ((struct Iter *)0)->iter_type),
                         "iter_type");
  tmp___0 = (*(((struct Iter *)tmp)->iter_type))(self);
  return (tmp___0);
}
}
static char const   *Range_Name(void) 
{ 


  {
  return ("Range");
}
}
static char const   *Range_Brief(void) 
{ 


  {
  return ("Integer Sequence");
}
}
static char const   *Range_Description(void) 
{ 


  {
  return ("The `Range` type is a basic iterable which acts as a virtual sequence of integers, starting from some value, stopping at some value and incrementing by some step.\n\nThis can be a useful replacement for the standard C `for` loop with decent performance but returning a Cello `Int`. It is constructable on the stack with the `range` macro which makes it practical and easy to use.");
}
}
static char const   *Range_Definition(void) 
{ 


  {
  return ("struct Range {\n  var value;\n  int64_t start;\n  int64_t stop;\n  int64_t step;\n};\n");
}
}
static struct Example *Range_Examples(void) ;
static struct Example examples___2[2]  = {      {"Usage", "/* Iterate 0 to 10 */\nforeach (i in range($I(10))) {\n  print(\"%i\\n\", i);\n}\n\n/* Iterate 10 to 20 */\nforeach (i in range($I(10), $I(20))) {\n  print(\"%i\\n\", i);\n}\n\n/* Iterate 10 to 20 with a step of 5 */\nforeach (i in range($I(10), $I(20), $I(5))) {\n  print(\"%i\\n\", i);\n}\n\n/* Iterate 20 to 10 */\nforeach (i in range($I(10), $I(20), $I(-1))) {\n  print(\"%i\\n\", i);\n}\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Range_Examples(void) 
{ 


  {
  return (examples___2);
}
}
static struct Method *Range_Methods(void) ;
static struct Method methods___1[2]  = {      {"range", "#define range(...)", "Construct a `Range` object on the stack."}, 
        {(char const   *)((void *)0), (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Range_Methods(void) 
{ 


  {
  return (methods___1);
}
}
var range_stack(var self , var args ) 
{ 
  struct Range *r ;
  size_t nargs ;
  size_t tmp ;
  struct Tuple __constr_expr_67 ;
  var __constr_expr_68[1] ;
  char __constr_expr_69[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;
  struct Int __constr_expr_70 ;
  char __constr_expr_71[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;
  var tmp___6 ;
  struct Int __constr_expr_74 ;
  char __constr_expr_75[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___11 ;
  var tmp___12 ;
  void *tmp___13 ;
  var tmp___14 ;
  int64_t tmp___15 ;
  struct Int __constr_expr_76 ;
  char __constr_expr_77[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___16 ;
  var tmp___17 ;
  void *tmp___18 ;
  var tmp___19 ;
  struct Int __constr_expr_78 ;
  char __constr_expr_79[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___20 ;
  var tmp___21 ;
  void *tmp___22 ;
  var tmp___23 ;
  struct Int __constr_expr_82 ;
  char __constr_expr_83[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___28 ;
  var tmp___29 ;
  void *tmp___30 ;
  var tmp___31 ;
  int64_t tmp___32 ;
  struct Int __constr_expr_84 ;
  char __constr_expr_85[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___33 ;
  var tmp___34 ;
  void *tmp___35 ;
  var tmp___36 ;
  struct Int __constr_expr_86 ;
  char __constr_expr_87[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___37 ;
  var tmp___38 ;
  void *tmp___39 ;
  var tmp___40 ;
  struct Int __constr_expr_90 ;
  char __constr_expr_91[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___45 ;
  var tmp___46 ;
  void *tmp___47 ;
  var tmp___48 ;
  int64_t tmp___49 ;
  struct Int __constr_expr_92 ;
  char __constr_expr_93[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___50 ;
  var tmp___51 ;
  void *tmp___52 ;
  var tmp___53 ;

  {
  r = (struct Range *)self;
  tmp = len(args);
  nargs = tmp;
  if (nargs > 3UL) {
    __constr_expr_68[0] = Terminal;
    __constr_expr_67.items = __constr_expr_68;
    __constr_expr_69[0] = (char)0;
    tmp___0 = 1U;
    while (! (tmp___0 >= 32U)) {
      __constr_expr_69[tmp___0] = (char)0;
      tmp___0 ++;
    }
    tmp___1 = header_init((var )(__constr_expr_69), Tuple, 2);
    tmp___2 = memcpy((void * __restrict  )((struct Tuple *)tmp___1), (void const   * __restrict  )(& __constr_expr_67),
                     sizeof(struct Tuple ));
    exception_throw(FormatError, "Received too many arguments to Range constructor",
                    (var )((struct Tuple *)tmp___2));
  }
  switch (nargs) {
  case 0UL: 
  r->start = (int64_t )0;
  r->stop = (int64_t )0;
  r->step = (int64_t )1;
  break;
  case 1UL: 
  r->start = (int64_t )0;
  __constr_expr_70.val = (int64_t )0;
  __constr_expr_71[0] = (char)0;
  tmp___3 = 1U;
  while (! (tmp___3 >= 32U)) {
    __constr_expr_71[tmp___3] = (char)0;
    tmp___3 ++;
  }
  tmp___4 = header_init((var )(__constr_expr_71), Int, 2);
  tmp___5 = memcpy((void * __restrict  )((struct Int *)tmp___4), (void const   * __restrict  )(& __constr_expr_70),
                   sizeof(struct Int ));
  tmp___6 = get(args, (var )((struct Int *)tmp___5));
  r->stop = c_int(tmp___6);
  r->step = (int64_t )1;
  break;
  case 2UL: 
  __constr_expr_76.val = (int64_t )0;
  __constr_expr_77[0] = (char)0;
  tmp___16 = 1U;
  while (! (tmp___16 >= 32U)) {
    __constr_expr_77[tmp___16] = (char)0;
    tmp___16 ++;
  }
  tmp___17 = header_init((var )(__constr_expr_77), Int, 2);
  tmp___18 = memcpy((void * __restrict  )((struct Int *)tmp___17), (void const   * __restrict  )(& __constr_expr_76),
                    sizeof(struct Int ));
  tmp___19 = get(args, (var )((struct Int *)tmp___18));
  if ((unsigned long )tmp___19 == (unsigned long )_) {
    r->start = (int64_t )0;
  } else {
    __constr_expr_74.val = (int64_t )0;
    __constr_expr_75[0] = (char)0;
    tmp___11 = 1U;
    while (! (tmp___11 >= 32U)) {
      __constr_expr_75[tmp___11] = (char)0;
      tmp___11 ++;
    }
    tmp___12 = header_init((var )(__constr_expr_75), Int, 2);
    tmp___13 = memcpy((void * __restrict  )((struct Int *)tmp___12), (void const   * __restrict  )(& __constr_expr_74),
                      sizeof(struct Int ));
    tmp___14 = get(args, (var )((struct Int *)tmp___13));
    tmp___15 = c_int(tmp___14);
    r->start = tmp___15;
  }
  __constr_expr_78.val = (int64_t )1;
  __constr_expr_79[0] = (char)0;
  tmp___20 = 1U;
  while (! (tmp___20 >= 32U)) {
    __constr_expr_79[tmp___20] = (char)0;
    tmp___20 ++;
  }
  tmp___21 = header_init((var )(__constr_expr_79), Int, 2);
  tmp___22 = memcpy((void * __restrict  )((struct Int *)tmp___21), (void const   * __restrict  )(& __constr_expr_78),
                    sizeof(struct Int ));
  tmp___23 = get(args, (var )((struct Int *)tmp___22));
  r->stop = c_int(tmp___23);
  r->step = (int64_t )1;
  break;
  case 3UL: 
  __constr_expr_84.val = (int64_t )0;
  __constr_expr_85[0] = (char)0;
  tmp___33 = 1U;
  while (! (tmp___33 >= 32U)) {
    __constr_expr_85[tmp___33] = (char)0;
    tmp___33 ++;
  }
  tmp___34 = header_init((var )(__constr_expr_85), Int, 2);
  tmp___35 = memcpy((void * __restrict  )((struct Int *)tmp___34), (void const   * __restrict  )(& __constr_expr_84),
                    sizeof(struct Int ));
  tmp___36 = get(args, (var )((struct Int *)tmp___35));
  if ((unsigned long )tmp___36 == (unsigned long )_) {
    r->start = (int64_t )0;
  } else {
    __constr_expr_82.val = (int64_t )0;
    __constr_expr_83[0] = (char)0;
    tmp___28 = 1U;
    while (! (tmp___28 >= 32U)) {
      __constr_expr_83[tmp___28] = (char)0;
      tmp___28 ++;
    }
    tmp___29 = header_init((var )(__constr_expr_83), Int, 2);
    tmp___30 = memcpy((void * __restrict  )((struct Int *)tmp___29), (void const   * __restrict  )(& __constr_expr_82),
                      sizeof(struct Int ));
    tmp___31 = get(args, (var )((struct Int *)tmp___30));
    tmp___32 = c_int(tmp___31);
    r->start = tmp___32;
  }
  __constr_expr_86.val = (int64_t )1;
  __constr_expr_87[0] = (char)0;
  tmp___37 = 1U;
  while (! (tmp___37 >= 32U)) {
    __constr_expr_87[tmp___37] = (char)0;
    tmp___37 ++;
  }
  tmp___38 = header_init((var )(__constr_expr_87), Int, 2);
  tmp___39 = memcpy((void * __restrict  )((struct Int *)tmp___38), (void const   * __restrict  )(& __constr_expr_86),
                    sizeof(struct Int ));
  tmp___40 = get(args, (var )((struct Int *)tmp___39));
  r->stop = c_int(tmp___40);
  __constr_expr_92.val = (int64_t )2;
  __constr_expr_93[0] = (char)0;
  tmp___50 = 1U;
  while (! (tmp___50 >= 32U)) {
    __constr_expr_93[tmp___50] = (char)0;
    tmp___50 ++;
  }
  tmp___51 = header_init((var )(__constr_expr_93), Int, 2);
  tmp___52 = memcpy((void * __restrict  )((struct Int *)tmp___51), (void const   * __restrict  )(& __constr_expr_92),
                    sizeof(struct Int ));
  tmp___53 = get(args, (var )((struct Int *)tmp___52));
  if ((unsigned long )tmp___53 == (unsigned long )_) {
    r->step = (int64_t )1;
  } else {
    __constr_expr_90.val = (int64_t )2;
    __constr_expr_91[0] = (char)0;
    tmp___45 = 1U;
    while (! (tmp___45 >= 32U)) {
      __constr_expr_91[tmp___45] = (char)0;
      tmp___45 ++;
    }
    tmp___46 = header_init((var )(__constr_expr_91), Int, 2);
    tmp___47 = memcpy((void * __restrict  )((struct Int *)tmp___46), (void const   * __restrict  )(& __constr_expr_90),
                      sizeof(struct Int ));
    tmp___48 = get(args, (var )((struct Int *)tmp___47));
    tmp___49 = c_int(tmp___48);
    r->step = tmp___49;
  }
  break;
  }
  return (self);
}
}
static void Range_New(var self , var args ) 
{ 
  struct Range *r ;
  struct Tuple __constr_expr_94 ;
  var __constr_expr_95[1] ;
  char __constr_expr_96[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  var tmp___2 ;

  {
  r = (struct Range *)self;
  __constr_expr_95[0] = Terminal;
  __constr_expr_94.items = __constr_expr_95;
  __constr_expr_96[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_96[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_96), Tuple, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_94),
                   sizeof(struct Tuple ));
  tmp___2 = new_with(Int, (var )((struct Tuple *)tmp___1));
  r->value = (var )((struct Int *)tmp___2);
  range_stack(self, args);
  return;
}
}
static void Range_Del(var self ) 
{ 
  struct Range *r ;

  {
  r = (struct Range *)self;
  del(r->value);
  return;
}
}
static void Range_Assign(var self , var obj ) 
{ 
  struct Range *r ;
  struct Range *o ;
  var tmp ;

  {
  r = (struct Range *)self;
  tmp = cast(obj, Range);
  o = (struct Range *)tmp;
  assign(r->value, o->value);
  r->start = o->start;
  r->stop = o->stop;
  r->step = o->step;
  return;
}
}
static int Range_Cmp(var self , var obj ) 
{ 
  struct Range *r ;
  struct Range *o ;
  var tmp ;
  int tmp___0 ;

  {
  r = (struct Range *)self;
  tmp = cast(obj, Range);
  o = (struct Range *)tmp;
  tmp___0 = memcmp((void const   *)(& r->start), (void const   *)(& o->start), sizeof(int64_t ) * 3UL);
  return (tmp___0);
}
}
static var Range_Iter_Init(var self ) 
{ 
  struct Range *r ;
  struct Int *i ;

  {
  r = (struct Range *)self;
  i = (struct Int *)r->value;
  if (r->step == 0L) {
    return (Terminal);
  }
  if (r->step > 0L) {
    i->val = r->start;
  }
  if (r->step < 0L) {
    i->val = r->stop - 1L;
  }
  if (r->step > 0L) {
    if (i->val >= r->stop) {
      return (Terminal);
    }
  }
  if (r->step < 0L) {
    if (i->val < r->start) {
      return (Terminal);
    }
  }
  return ((var )i);
}
}
static var Range_Iter_Last(var self ) 
{ 
  struct Range *r ;
  struct Int *i ;

  {
  r = (struct Range *)self;
  i = (struct Int *)r->value;
  if (r->step == 0L) {
    return (Terminal);
  }
  if (r->step > 0L) {
    i->val = r->stop - 1L;
  }
  if (r->step < 0L) {
    i->val = r->start;
  }
  if (r->step > 0L) {
    if (i->val < r->start) {
      return (Terminal);
    }
  }
  if (r->step < 0L) {
    if (i->val >= r->stop) {
      return (Terminal);
    }
  }
  return ((var )i);
}
}
static var Range_Iter_Next(var self , var curr ) 
{ 
  struct Range *r ;
  struct Int *i ;

  {
  r = (struct Range *)self;
  i = (struct Int *)r->value;
  i->val += r->step;
  if (r->step == 0L) {
    return (Terminal);
  }
  if (r->step > 0L) {
    if (i->val >= r->stop) {
      return (Terminal);
    }
  }
  if (r->step < 0L) {
    if (i->val < r->start) {
      return (Terminal);
    }
  }
  return ((var )i);
}
}
static var Range_Iter_Prev(var self , var curr ) 
{ 
  struct Range *r ;
  struct Int *i ;

  {
  r = (struct Range *)self;
  i = (struct Int *)r->value;
  i->val -= r->step;
  if (r->step == 0L) {
    return (Terminal);
  }
  if (r->step > 0L) {
    if (i->val < r->start) {
      return (Terminal);
    }
  }
  if (r->step < 0L) {
    if (i->val >= r->stop) {
      return (Terminal);
    }
  }
  return ((var )i);
}
}
static var Range_Iter_Type(var self ) 
{ 


  {
  return (Int);
}
}
static size_t Range_Len(var self ) 
{ 
  struct Range *r ;

  {
  r = (struct Range *)self;
  if (r->step == 0L) {
    return ((size_t )0);
  }
  if (r->step > 0L) {
    return ((size_t )(((r->stop - 1L) - r->start) / r->step + 1L));
  }
  if (r->step < 0L) {
    return ((size_t )(((r->stop - 1L) - r->start) / - r->step + 1L));
  }
  return ((size_t )0);
}
}
static var Range_Get(var self , var key ) 
{ 
  struct Range *r ;
  struct Int *x ;
  int64_t i ;
  int64_t tmp ;
  size_t tmp___0 ;
  struct Tuple __constr_expr_97 ;
  var __constr_expr_98[5] ;
  struct Int __constr_expr_99 ;
  char __constr_expr_100[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___1 ;
  var tmp___2 ;
  void *tmp___3 ;
  struct Int __constr_expr_101 ;
  char __constr_expr_102[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___4 ;
  var tmp___5 ;
  void *tmp___6 ;
  struct Int __constr_expr_103 ;
  char __constr_expr_104[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___7 ;
  var tmp___8 ;
  void *tmp___9 ;
  char __constr_expr_105[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___10 ;
  var tmp___11 ;
  void *tmp___12 ;
  var tmp___13 ;

  {
  r = (struct Range *)self;
  x = (struct Int *)r->value;
  tmp = c_int(key);
  i = tmp;
  if (i < 0L) {
    tmp___0 = Range_Len((var )r);
    i = (int64_t )(tmp___0 + (size_t )i);
  } else {
    i = i;
  }
  if (r->step == 0L) {
    x->val = (int64_t )0;
    return ((var )x);
  }
  if (r->step > 0L) {
    if (r->start + r->step * i < r->stop) {
      x->val = r->start + r->step * i;
      return ((var )x);
    }
  }
  if (r->step < 0L) {
    if ((r->stop - 1L) + r->step * i >= r->start) {
      x->val = (r->stop - 1L) + r->step * i;
      return ((var )x);
    }
  }
  __constr_expr_99.val = r->start;
  __constr_expr_100[0] = (char)0;
  tmp___1 = 1U;
  while (! (tmp___1 >= 32U)) {
    __constr_expr_100[tmp___1] = (char)0;
    tmp___1 ++;
  }
  tmp___2 = header_init((var )(__constr_expr_100), Int, 2);
  tmp___3 = memcpy((void * __restrict  )((struct Int *)tmp___2), (void const   * __restrict  )(& __constr_expr_99),
                   sizeof(struct Int ));
  __constr_expr_101.val = r->stop;
  __constr_expr_102[0] = (char)0;
  tmp___4 = 1U;
  while (! (tmp___4 >= 32U)) {
    __constr_expr_102[tmp___4] = (char)0;
    tmp___4 ++;
  }
  tmp___5 = header_init((var )(__constr_expr_102), Int, 2);
  tmp___6 = memcpy((void * __restrict  )((struct Int *)tmp___5), (void const   * __restrict  )(& __constr_expr_101),
                   sizeof(struct Int ));
  __constr_expr_103.val = r->step;
  __constr_expr_104[0] = (char)0;
  tmp___7 = 1U;
  while (! (tmp___7 >= 32U)) {
    __constr_expr_104[tmp___7] = (char)0;
    tmp___7 ++;
  }
  tmp___8 = header_init((var )(__constr_expr_104), Int, 2);
  tmp___9 = memcpy((void * __restrict  )((struct Int *)tmp___8), (void const   * __restrict  )(& __constr_expr_103),
                   sizeof(struct Int ));
  __constr_expr_98[0] = key;
  __constr_expr_98[1] = (var )((struct Int *)tmp___3);
  __constr_expr_98[2] = (var )((struct Int *)tmp___6);
  __constr_expr_98[3] = (var )((struct Int *)tmp___9);
  __constr_expr_98[4] = Terminal;
  __constr_expr_97.items = __constr_expr_98;
  __constr_expr_105[0] = (char)0;
  tmp___10 = 1U;
  while (! (tmp___10 >= 32U)) {
    __constr_expr_105[tmp___10] = (char)0;
    tmp___10 ++;
  }
  tmp___11 = header_init((var )(__constr_expr_105), Tuple, 2);
  tmp___12 = memcpy((void * __restrict  )((struct Tuple *)tmp___11), (void const   * __restrict  )(& __constr_expr_97),
                    sizeof(struct Tuple ));
  tmp___13 = exception_throw(IndexOutOfBoundsError, "Index \'%i\' out of bounds for Range of start %i, stop %i and step %i.",
                             (var )((struct Tuple *)tmp___12));
  return (tmp___13);
}
}
static _Bool Range_Mem(var self , var key ) 
{ 
  struct Range *r ;
  int64_t i ;
  int64_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  r = (struct Range *)self;
  tmp = c_int(key);
  i = tmp;
  if (i < 0L) {
    tmp___0 = Range_Len((var )r);
    i = (int64_t )(tmp___0 + (size_t )i);
  } else {
    i = i;
  }
  if (r->step == 0L) {
    return ((_Bool)0);
  }
  if (r->step > 0L) {
    if (i >= r->start) {
      if (i < r->stop) {
        if ((i - r->start) % r->step == 0L) {
          tmp___1 = 1;
        } else {
          tmp___1 = 0;
        }
      } else {
        tmp___1 = 0;
      }
    } else {
      tmp___1 = 0;
    }
    return ((_Bool )tmp___1);
  }
  if (r->step < 0L) {
    if (i >= r->start) {
      if (i < r->stop) {
        if ((i - (r->stop - 1L)) % - r->step == 0L) {
          tmp___2 = 1;
        } else {
          tmp___2 = 0;
        }
      } else {
        tmp___2 = 0;
      }
    } else {
      tmp___2 = 0;
    }
    return ((_Bool )tmp___2);
  }
  return ((_Bool)0);
}
}
static int Range_Show(var self , var output , int pos ) 
{ 
  struct Range *r ;
  struct Tuple __constr_expr_106 ;
  var __constr_expr_107[2] ;
  char __constr_expr_108[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  var curr ;
  var tmp___2 ;
  struct Tuple __constr_expr_109 ;
  var __constr_expr_110[2] ;
  char __constr_expr_111[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;
  struct Tuple __constr_expr_112 ;
  var __constr_expr_113[1] ;
  char __constr_expr_114[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___6 ;
  var tmp___7 ;
  void *tmp___8 ;
  struct Tuple __constr_expr_115 ;
  var __constr_expr_116[1] ;
  char __constr_expr_117[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___9 ;
  var tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;

  {
  r = (struct Range *)self;
  __constr_expr_107[0] = self;
  __constr_expr_107[1] = Terminal;
  __constr_expr_106.items = __constr_expr_107;
  __constr_expr_108[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_108[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_108), Tuple, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_106),
                   sizeof(struct Tuple ));
  pos = print_to_with(output, pos, "<\'Range\' At 0x%p [", (var )((struct Tuple *)tmp___1));
  tmp___2 = Range_Iter_Init(self);
  curr = tmp___2;
  while ((unsigned long )curr != (unsigned long )Terminal) {
    __constr_expr_110[0] = curr;
    __constr_expr_110[1] = Terminal;
    __constr_expr_109.items = __constr_expr_110;
    __constr_expr_111[0] = (char)0;
    tmp___3 = 1U;
    while (! (tmp___3 >= 32U)) {
      __constr_expr_111[tmp___3] = (char)0;
      tmp___3 ++;
    }
    tmp___4 = header_init((var )(__constr_expr_111), Tuple, 2);
    tmp___5 = memcpy((void * __restrict  )((struct Tuple *)tmp___4), (void const   * __restrict  )(& __constr_expr_109),
                     sizeof(struct Tuple ));
    pos = print_to_with(output, pos, "%i", (var )((struct Tuple *)tmp___5));
    curr = Range_Iter_Next(self, curr);
    if ((unsigned long )curr != (unsigned long )Terminal) {
      __constr_expr_113[0] = Terminal;
      __constr_expr_112.items = __constr_expr_113;
      __constr_expr_114[0] = (char)0;
      tmp___6 = 1U;
      while (! (tmp___6 >= 32U)) {
        __constr_expr_114[tmp___6] = (char)0;
        tmp___6 ++;
      }
      tmp___7 = header_init((var )(__constr_expr_114), Tuple, 2);
      tmp___8 = memcpy((void * __restrict  )((struct Tuple *)tmp___7), (void const   * __restrict  )(& __constr_expr_112),
                       sizeof(struct Tuple ));
      pos = print_to_with(output, pos, ", ", (var )((struct Tuple *)tmp___8));
    }
  }
  __constr_expr_116[0] = Terminal;
  __constr_expr_115.items = __constr_expr_116;
  __constr_expr_117[0] = (char)0;
  tmp___9 = 1U;
  while (! (tmp___9 >= 32U)) {
    __constr_expr_117[tmp___9] = (char)0;
    tmp___9 ++;
  }
  tmp___10 = header_init((var )(__constr_expr_117), Tuple, 2);
  tmp___11 = memcpy((void * __restrict  )((struct Tuple *)tmp___10), (void const   * __restrict  )(& __constr_expr_115),
                    sizeof(struct Tuple ));
  tmp___12 = print_to_with(output, pos, "]>", (var )((struct Tuple *)tmp___11));
  return (tmp___12);
}
}
static struct Doc __constr_expr_119  =    {& Range_Name, & Range_Brief, & Range_Description, & Range_Definition, & Range_Examples,
    & Range_Methods};
static struct New __constr_expr_120  =    {& Range_New, & Range_Del};
static struct Assign __constr_expr_121  =    {& Range_Assign};
static struct Cmp __constr_expr_122  =    {& Range_Cmp};
static struct Len __constr_expr_123  =    {& Range_Len};
static struct Get __constr_expr_124  =    {& Range_Get, (void (*)(var  , var  , var  ))((void *)0), & Range_Mem, (void (*)(var  ,
                                                                                    var  ))((void *)0),
    (var (*)(var  ))0, (var (*)(var  ))0};
static struct Show __constr_expr_125  =    {& Range_Show, (int (*)(var  , var  , int  ))((void *)0)};
static struct Iter __constr_expr_126  =    {& Range_Iter_Init, & Range_Iter_Next, & Range_Iter_Last, & Range_Iter_Prev, & Range_Iter_Type};
static var __constr_expr_118[54]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Range", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Range ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_119),      (void *)0,      (var )"New", 
        (var )(& __constr_expr_120),      (void *)0,      (var )"Assign",      (var )(& __constr_expr_121), 
        (void *)0,      (var )"Cmp",      (var )(& __constr_expr_122),      (void *)0, 
        (var )"Len",      (var )(& __constr_expr_123),      (void *)0,      (var )"Get", 
        (var )(& __constr_expr_124),      (void *)0,      (var )"Show",      (var )(& __constr_expr_125), 
        (void *)0,      (var )"Iter",      (var )(& __constr_expr_126),      (void *)0, 
        (void *)0,      (void *)0};
var Range  =    (var )((char *)(__constr_expr_118) + sizeof(struct Header ));
static char const   *Slice_Name(void) 
{ 


  {
  return ("Slice");
}
}
static char const   *Slice_Brief(void) 
{ 


  {
  return ("Partial Iterable");
}
}
static char const   *Slice_Description(void) 
{ 


  {
  return ("The `Slice` type is an iterable that allows one to only iterate over part of another iterable. Given some start, stop and step, only those entries described by the `Slice` are returned in the iteration.\n\nUnder the hood the `Slice` object still iterates over the whole iterable but it only returns those values in the range given.");
}
}
static char const   *Slice_Definition(void) 
{ 


  {
  return ("struct Slice {\n  var iter;\n  var range;\n};\n");
}
}
static struct Example *Slice_Examples(void) ;
static struct Example examples___3[2]  = {      {"Usage", "var x = tuple(\n  $S(\"Hello\"), $S(\"There\"), $S(\"World\"), $S(\"!\"));\n\n/* Iterate over elements 0 to 2 */\nforeach (s in slice(x, $I(2))) {\n  print(\"%s\\n\", s);\n}\n\n/* Iterate over elements 1 to 2 */\nforeach (s in slice(x, $I(1), $I(2))) {\n  print(\"%s\\n\", s);\n}\n\n/* Iterate over every other element */\nforeach (s in slice(x, _, _, $I(2))) {\n  print(\"%s\\n\", s);\n}\n\n/* Iterate backwards, starting from element 3 */\nforeach (s in slice(x, _, $I(2), $I(-1))) {\n  print(\"%s\\n\", s);\n}\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Slice_Examples(void) 
{ 


  {
  return (examples___3);
}
}
static struct Method *Slice_Methods(void) ;
static struct Method methods___2[3]  = {      {"slice", "#define slice(I, ...)", "Construct a `Slice` object on the stack over iterable `I`."}, 
        {"reverse",
      "#define reverse(I)", "Construct a `Slice` object that iterates over iterable `I` in reverse order."}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Slice_Methods(void) 
{ 


  {
  return (methods___2);
}
}
static int64_t Slice_Arg(int part , size_t n , var arg ) 
{ 
  int64_t a ;
  int64_t tmp ;

  {
  if ((unsigned long )arg == (unsigned long )_) {
    if (part == 0) {
      return ((int64_t )0);
    }
    if (part == 1) {
      return ((int64_t )n);
    }
    if (part == 2) {
      return ((int64_t )1);
    }
  }
  tmp = c_int(arg);
  a = tmp;
  if (part != 2) {
    if (a < 0L) {
      a = (int64_t )(n + (size_t )a);
    } else {
      a = a;
    }
    if ((size_t )a > n) {
      a = (int64_t )n;
    } else {
      a = a;
    }
    if (a < 0L) {
      a = (int64_t )0;
    } else {
      a = a;
    }
  }
  return (a);
}
}
var slice_stack(var self , var args ) 
{ 
  size_t nargs ;
  size_t tmp ;
  struct Tuple __constr_expr_127 ;
  var __constr_expr_128[1] ;
  char __constr_expr_129[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;
  struct Tuple __constr_expr_130 ;
  var __constr_expr_131[1] ;
  char __constr_expr_132[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;
  struct Slice *s ;
  struct Int __constr_expr_133 ;
  char __constr_expr_134[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___6 ;
  var tmp___7 ;
  void *tmp___8 ;
  struct Range *r ;
  size_t n ;
  size_t tmp___9 ;
  struct Int __constr_expr_135 ;
  char __constr_expr_136[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___10 ;
  var tmp___11 ;
  void *tmp___12 ;
  var tmp___13 ;
  struct Int __constr_expr_137 ;
  char __constr_expr_138[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___14 ;
  var tmp___15 ;
  void *tmp___16 ;
  var tmp___17 ;
  struct Int __constr_expr_139 ;
  char __constr_expr_140[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___18 ;
  var tmp___19 ;
  void *tmp___20 ;
  var tmp___21 ;
  struct Int __constr_expr_141 ;
  char __constr_expr_142[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___22 ;
  var tmp___23 ;
  void *tmp___24 ;
  var tmp___25 ;
  struct Int __constr_expr_143 ;
  char __constr_expr_144[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___26 ;
  var tmp___27 ;
  void *tmp___28 ;
  var tmp___29 ;
  struct Int __constr_expr_145 ;
  char __constr_expr_146[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___30 ;
  var tmp___31 ;
  void *tmp___32 ;
  var tmp___33 ;

  {
  tmp = len(args);
  nargs = tmp;
  if (nargs > 4UL) {
    __constr_expr_128[0] = Terminal;
    __constr_expr_127.items = __constr_expr_128;
    __constr_expr_129[0] = (char)0;
    tmp___0 = 1U;
    while (! (tmp___0 >= 32U)) {
      __constr_expr_129[tmp___0] = (char)0;
      tmp___0 ++;
    }
    tmp___1 = header_init((var )(__constr_expr_129), Tuple, 2);
    tmp___2 = memcpy((void * __restrict  )((struct Tuple *)tmp___1), (void const   * __restrict  )(& __constr_expr_127),
                     sizeof(struct Tuple ));
    exception_throw(FormatError, "Received too many arguments to Slice constructor",
                    (var )((struct Tuple *)tmp___2));
  }
  if (nargs < 1UL) {
    __constr_expr_131[0] = Terminal;
    __constr_expr_130.items = __constr_expr_131;
    __constr_expr_132[0] = (char)0;
    tmp___3 = 1U;
    while (! (tmp___3 >= 32U)) {
      __constr_expr_132[tmp___3] = (char)0;
      tmp___3 ++;
    }
    tmp___4 = header_init((var )(__constr_expr_132), Tuple, 2);
    tmp___5 = memcpy((void * __restrict  )((struct Tuple *)tmp___4), (void const   * __restrict  )(& __constr_expr_130),
                     sizeof(struct Tuple ));
    exception_throw(FormatError, "Received too few arguments to Slice constructor",
                    (var )((struct Tuple *)tmp___5));
  }
  s = (struct Slice *)self;
  __constr_expr_133.val = (int64_t )0;
  __constr_expr_134[0] = (char)0;
  tmp___6 = 1U;
  while (! (tmp___6 >= 32U)) {
    __constr_expr_134[tmp___6] = (char)0;
    tmp___6 ++;
  }
  tmp___7 = header_init((var )(__constr_expr_134), Int, 2);
  tmp___8 = memcpy((void * __restrict  )((struct Int *)tmp___7), (void const   * __restrict  )(& __constr_expr_133),
                   sizeof(struct Int ));
  s->iter = get(args, (var )((struct Int *)tmp___8));
  r = (struct Range *)s->range;
  tmp___9 = len(s->iter);
  n = tmp___9;
  switch (nargs) {
  case 1UL: 
  r->start = (int64_t )0;
  r->stop = (int64_t )n;
  r->step = (int64_t )1;
  break;
  case 2UL: 
  r->start = (int64_t )0;
  __constr_expr_135.val = (int64_t )1;
  __constr_expr_136[0] = (char)0;
  tmp___10 = 1U;
  while (! (tmp___10 >= 32U)) {
    __constr_expr_136[tmp___10] = (char)0;
    tmp___10 ++;
  }
  tmp___11 = header_init((var )(__constr_expr_136), Int, 2);
  tmp___12 = memcpy((void * __restrict  )((struct Int *)tmp___11), (void const   * __restrict  )(& __constr_expr_135),
                    sizeof(struct Int ));
  tmp___13 = get(args, (var )((struct Int *)tmp___12));
  r->stop = Slice_Arg(1, n, tmp___13);
  r->step = (int64_t )1;
  break;
  case 3UL: 
  __constr_expr_137.val = (int64_t )1;
  __constr_expr_138[0] = (char)0;
  tmp___14 = 1U;
  while (! (tmp___14 >= 32U)) {
    __constr_expr_138[tmp___14] = (char)0;
    tmp___14 ++;
  }
  tmp___15 = header_init((var )(__constr_expr_138), Int, 2);
  tmp___16 = memcpy((void * __restrict  )((struct Int *)tmp___15), (void const   * __restrict  )(& __constr_expr_137),
                    sizeof(struct Int ));
  tmp___17 = get(args, (var )((struct Int *)tmp___16));
  r->start = Slice_Arg(0, n, tmp___17);
  __constr_expr_139.val = (int64_t )2;
  __constr_expr_140[0] = (char)0;
  tmp___18 = 1U;
  while (! (tmp___18 >= 32U)) {
    __constr_expr_140[tmp___18] = (char)0;
    tmp___18 ++;
  }
  tmp___19 = header_init((var )(__constr_expr_140), Int, 2);
  tmp___20 = memcpy((void * __restrict  )((struct Int *)tmp___19), (void const   * __restrict  )(& __constr_expr_139),
                    sizeof(struct Int ));
  tmp___21 = get(args, (var )((struct Int *)tmp___20));
  r->stop = Slice_Arg(1, n, tmp___21);
  r->step = (int64_t )1;
  break;
  case 4UL: 
  __constr_expr_141.val = (int64_t )1;
  __constr_expr_142[0] = (char)0;
  tmp___22 = 1U;
  while (! (tmp___22 >= 32U)) {
    __constr_expr_142[tmp___22] = (char)0;
    tmp___22 ++;
  }
  tmp___23 = header_init((var )(__constr_expr_142), Int, 2);
  tmp___24 = memcpy((void * __restrict  )((struct Int *)tmp___23), (void const   * __restrict  )(& __constr_expr_141),
                    sizeof(struct Int ));
  tmp___25 = get(args, (var )((struct Int *)tmp___24));
  r->start = Slice_Arg(0, n, tmp___25);
  __constr_expr_143.val = (int64_t )2;
  __constr_expr_144[0] = (char)0;
  tmp___26 = 1U;
  while (! (tmp___26 >= 32U)) {
    __constr_expr_144[tmp___26] = (char)0;
    tmp___26 ++;
  }
  tmp___27 = header_init((var )(__constr_expr_144), Int, 2);
  tmp___28 = memcpy((void * __restrict  )((struct Int *)tmp___27), (void const   * __restrict  )(& __constr_expr_143),
                    sizeof(struct Int ));
  tmp___29 = get(args, (var )((struct Int *)tmp___28));
  r->stop = Slice_Arg(1, n, tmp___29);
  __constr_expr_145.val = (int64_t )3;
  __constr_expr_146[0] = (char)0;
  tmp___30 = 1U;
  while (! (tmp___30 >= 32U)) {
    __constr_expr_146[tmp___30] = (char)0;
    tmp___30 ++;
  }
  tmp___31 = header_init((var )(__constr_expr_146), Int, 2);
  tmp___32 = memcpy((void * __restrict  )((struct Int *)tmp___31), (void const   * __restrict  )(& __constr_expr_145),
                    sizeof(struct Int ));
  tmp___33 = get(args, (var )((struct Int *)tmp___32));
  r->step = Slice_Arg(2, n, tmp___33);
  break;
  }
  return (self);
}
}
static void Slice_New(var self , var args ) 
{ 
  struct Slice *s ;
  struct Tuple __constr_expr_147 ;
  var __constr_expr_148[1] ;
  char __constr_expr_149[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  var tmp___2 ;

  {
  s = (struct Slice *)self;
  __constr_expr_148[0] = Terminal;
  __constr_expr_147.items = __constr_expr_148;
  __constr_expr_149[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_149[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_149), Tuple, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_147),
                   sizeof(struct Tuple ));
  tmp___2 = new_with(Range, (var )((struct Tuple *)tmp___1));
  s->range = (var )((struct Range *)tmp___2);
  slice_stack(self, args);
  return;
}
}
static void Slice_Del(var self ) 
{ 
  struct Slice *s ;

  {
  s = (struct Slice *)self;
  del(s->range);
  return;
}
}
static void Slice_Assign(var self , var obj ) 
{ 
  struct Slice *s ;
  struct Slice *o ;
  var tmp ;

  {
  s = (struct Slice *)self;
  tmp = cast(obj, Slice);
  o = (struct Slice *)tmp;
  s->iter = o->iter;
  assign(s->range, o->range);
  return;
}
}
static int Slice_Cmp(var self , var obj ) 
{ 
  struct Slice *s ;
  struct Slice *o ;
  var tmp ;
  int tmp___0 ;

  {
  s = (struct Slice *)self;
  tmp = cast(obj, Slice);
  o = (struct Slice *)tmp;
  if ((unsigned long )s->iter > (unsigned long )o->iter) {
    return (1);
  }
  if ((unsigned long )s->iter < (unsigned long )o->iter) {
    return (-1);
  }
  tmp___0 = cmp(s->range, o->range);
  return (tmp___0);
}
}
static var Slice_Iter_Init(var self ) 
{ 
  struct Slice *s ;
  struct Range *r ;
  var curr ;
  var tmp ;
  int64_t i ;
  var curr___0 ;
  var tmp___0 ;
  int64_t i___0 ;
  size_t tmp___1 ;

  {
  s = (struct Slice *)self;
  r = (struct Range *)s->range;
  if (r->step > 0L) {
    tmp = iter_init(s->iter);
    curr = tmp;
    i = (int64_t )0;
    while (i < r->start) {
      curr = iter_next(s->iter, curr);
      i ++;
    }
    return (curr);
  }
  if (r->step < 0L) {
    tmp___0 = iter_last(s->iter);
    curr___0 = tmp___0;
    i___0 = (int64_t )0;
    while (1) {
      tmp___1 = len(s->iter);
      if (! (i___0 < (int64_t )tmp___1 - r->stop)) {
        break;
      }
      curr___0 = iter_prev(s->iter, curr___0);
      i___0 ++;
    }
    return (curr___0);
  }
  return (Terminal);
}
}
static var Slice_Iter_Next(var self , var curr ) 
{ 
  struct Slice *s ;
  struct Range *r ;
  int64_t i ;
  int64_t i___0 ;

  {
  s = (struct Slice *)self;
  r = (struct Range *)s->range;
  if (r->step > 0L) {
    i = (int64_t )0;
    while (i < r->step) {
      curr = iter_next(s->iter, curr);
      i ++;
    }
  }
  if (r->step < 0L) {
    i___0 = (int64_t )0;
    while (i___0 < - r->step) {
      curr = iter_prev(s->iter, curr);
      i___0 ++;
    }
  }
  return (curr);
}
}
static var Slice_Iter_Type(var self ) 
{ 
  struct Slice *s ;
  var tmp ;

  {
  s = (struct Slice *)self;
  tmp = iter_type(s->iter);
  return (tmp);
}
}
static var Slice_Iter_Last(var self ) 
{ 
  struct Slice *s ;
  struct Range *r ;
  var curr ;
  var tmp ;
  int64_t i ;
  size_t tmp___0 ;
  var curr___0 ;
  var tmp___1 ;
  int64_t i___0 ;

  {
  s = (struct Slice *)self;
  r = (struct Range *)s->range;
  if (r->step > 0L) {
    tmp = iter_last(s->iter);
    curr = tmp;
    i = (int64_t )0;
    while (1) {
      tmp___0 = len(s->iter);
      if (! (i < (int64_t )tmp___0 - r->stop)) {
        break;
      }
      curr = iter_prev(s->iter, curr);
      i ++;
    }
    return (curr);
  }
  if (r->step < 0L) {
    tmp___1 = iter_init(s->iter);
    curr___0 = tmp___1;
    i___0 = (int64_t )0;
    while (i___0 < r->start) {
      curr___0 = iter_next(s->iter, curr___0);
      i___0 ++;
    }
    return (curr___0);
  }
  return (Terminal);
}
}
static var Slice_Iter_Prev(var self , var curr ) 
{ 
  struct Slice *s ;
  struct Range *r ;
  int64_t i ;
  int64_t i___0 ;

  {
  s = (struct Slice *)self;
  r = (struct Range *)s->range;
  if (r->step > 0L) {
    i = (int64_t )0;
    while (i < r->step) {
      curr = iter_prev(s->iter, curr);
      i ++;
    }
  }
  if (r->step < 0L) {
    i___0 = (int64_t )0;
    while (i___0 < - r->step) {
      curr = iter_next(s->iter, curr);
      i___0 ++;
    }
  }
  return (curr);
}
}
static size_t Slice_Len(var self ) 
{ 
  struct Slice *s ;
  size_t tmp ;

  {
  s = (struct Slice *)self;
  tmp = Range_Len(s->range);
  return (tmp);
}
}
static var Slice_Get(var self , var key ) 
{ 
  struct Slice *s ;
  var tmp ;
  var tmp___0 ;

  {
  s = (struct Slice *)self;
  tmp = Range_Get(s->range, key);
  tmp___0 = get(s->iter, tmp);
  return (tmp___0);
}
}
static _Bool Slice_Mem(var self , var key ) 
{ 
  var curr ;
  var tmp ;
  _Bool tmp___0 ;

  {
  tmp = Slice_Iter_Init(self);
  curr = tmp;
  while (curr) {
    tmp___0 = eq(curr, key);
    if (tmp___0) {
      return ((_Bool)1);
    }
    curr = Slice_Iter_Next(self, curr);
  }
  return ((_Bool)0);
}
}
static int Slice_Show(var self , var output , int pos ) 
{ 
  struct Slice *s ;
  struct Tuple __constr_expr_150 ;
  var __constr_expr_151[2] ;
  char __constr_expr_152[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  var curr ;
  var tmp___2 ;
  struct Tuple __constr_expr_153 ;
  var __constr_expr_154[2] ;
  char __constr_expr_155[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;
  struct Tuple __constr_expr_156 ;
  var __constr_expr_157[1] ;
  char __constr_expr_158[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___6 ;
  var tmp___7 ;
  void *tmp___8 ;
  struct Tuple __constr_expr_159 ;
  var __constr_expr_160[1] ;
  char __constr_expr_161[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___9 ;
  var tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;

  {
  s = (struct Slice *)self;
  __constr_expr_151[0] = self;
  __constr_expr_151[1] = Terminal;
  __constr_expr_150.items = __constr_expr_151;
  __constr_expr_152[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_152[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_152), Tuple, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_150),
                   sizeof(struct Tuple ));
  pos = print_to_with(output, pos, "<\'Slice\' At 0x%p [", (var )((struct Tuple *)tmp___1));
  tmp___2 = Slice_Iter_Init(self);
  curr = tmp___2;
  while ((unsigned long )curr != (unsigned long )Terminal) {
    __constr_expr_154[0] = curr;
    __constr_expr_154[1] = Terminal;
    __constr_expr_153.items = __constr_expr_154;
    __constr_expr_155[0] = (char)0;
    tmp___3 = 1U;
    while (! (tmp___3 >= 32U)) {
      __constr_expr_155[tmp___3] = (char)0;
      tmp___3 ++;
    }
    tmp___4 = header_init((var )(__constr_expr_155), Tuple, 2);
    tmp___5 = memcpy((void * __restrict  )((struct Tuple *)tmp___4), (void const   * __restrict  )(& __constr_expr_153),
                     sizeof(struct Tuple ));
    pos = print_to_with(output, pos, "%$", (var )((struct Tuple *)tmp___5));
    curr = Slice_Iter_Next(self, curr);
    if ((unsigned long )curr != (unsigned long )Terminal) {
      __constr_expr_157[0] = Terminal;
      __constr_expr_156.items = __constr_expr_157;
      __constr_expr_158[0] = (char)0;
      tmp___6 = 1U;
      while (! (tmp___6 >= 32U)) {
        __constr_expr_158[tmp___6] = (char)0;
        tmp___6 ++;
      }
      tmp___7 = header_init((var )(__constr_expr_158), Tuple, 2);
      tmp___8 = memcpy((void * __restrict  )((struct Tuple *)tmp___7), (void const   * __restrict  )(& __constr_expr_156),
                       sizeof(struct Tuple ));
      pos = print_to_with(output, pos, ", ", (var )((struct Tuple *)tmp___8));
    }
  }
  __constr_expr_160[0] = Terminal;
  __constr_expr_159.items = __constr_expr_160;
  __constr_expr_161[0] = (char)0;
  tmp___9 = 1U;
  while (! (tmp___9 >= 32U)) {
    __constr_expr_161[tmp___9] = (char)0;
    tmp___9 ++;
  }
  tmp___10 = header_init((var )(__constr_expr_161), Tuple, 2);
  tmp___11 = memcpy((void * __restrict  )((struct Tuple *)tmp___10), (void const   * __restrict  )(& __constr_expr_159),
                    sizeof(struct Tuple ));
  tmp___12 = print_to_with(output, pos, "]>", (var )((struct Tuple *)tmp___11));
  return (tmp___12);
}
}
static struct Doc __constr_expr_163  =    {& Slice_Name, & Slice_Brief, & Slice_Description, & Slice_Definition, & Slice_Examples,
    & Slice_Methods};
static struct New __constr_expr_164  =    {& Slice_New, & Slice_Del};
static struct Assign __constr_expr_165  =    {& Slice_Assign};
static struct Cmp __constr_expr_166  =    {& Slice_Cmp};
static struct Len __constr_expr_167  =    {& Slice_Len};
static struct Get __constr_expr_168  =    {& Slice_Get, (void (*)(var  , var  , var  ))((void *)0), & Slice_Mem, (void (*)(var  ,
                                                                                    var  ))((void *)0),
    (var (*)(var  ))0, (var (*)(var  ))0};
static struct Iter __constr_expr_169  =    {& Slice_Iter_Init, & Slice_Iter_Next, & Slice_Iter_Last, & Slice_Iter_Prev, & Slice_Iter_Type};
static struct Show __constr_expr_170  =    {& Slice_Show,
    (int (*)(var  , var  , int  ))((void *)0)};
static var __constr_expr_162[54]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Slice", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Slice ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_163),      (void *)0,      (var )"New", 
        (var )(& __constr_expr_164),      (void *)0,      (var )"Assign",      (var )(& __constr_expr_165), 
        (void *)0,      (var )"Cmp",      (var )(& __constr_expr_166),      (void *)0, 
        (var )"Len",      (var )(& __constr_expr_167),      (void *)0,      (var )"Get", 
        (var )(& __constr_expr_168),      (void *)0,      (var )"Iter",      (var )(& __constr_expr_169), 
        (void *)0,      (var )"Show",      (var )(& __constr_expr_170),      (void *)0, 
        (void *)0,      (void *)0};
var Slice  =    (var )((char *)(__constr_expr_162) + sizeof(struct Header ));
static char const   *Zip_Name(void) 
{ 


  {
  return ("Zip");
}
}
static char const   *Zip_Brief(void) 
{ 


  {
  return ("Multiple Iterator");
}
}
static char const   *Zip_Description(void) 
{ 


  {
  return ("The `Zip` type can be used to combine multiple iterables into one which is then iterated over all at once and returned as a Tuple. The Zip object only iterates when all of it\'s sub iterators have valid items. More specifically the Zip iteration will terminate if _any_ of the sub iterators terminate.");
}
}
static char const   *Zip_Definition(void) 
{ 


  {
  return ("struct Zip {\n  var iters;\n  var values;\n};\n");
}
}
static struct Example *Zip_Examples(void) ;
static struct Example examples___4[2]  = {      {"Usage", "/* Iterate over two iterables at once */\nvar x = new(Array, Int, $I(100), $I(200), $I(130));\nvar y = new(Array, Float, $F(0.1), $F(0.2), $F(1.3));\nforeach (pair in zip(x, y)) {\n  print(\"x: %$\\n\", get(pair, $I(0)));\n  print(\"y: %$\\n\", get(pair, $I(1)));\n}\n\n/* Iterate over iterable with count */\nforeach (pair in enumerate(x)) {\n  print(\"%i: %$\\n\", get(pair, $I(0)), get(pair, $I(1)));\n}\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Zip_Examples(void) 
{ 


  {
  return (examples___4);
}
}
static struct Method *Zip_Methods(void) ;
static struct Method methods___3[3]  = {      {"zip", "#define zip(...)", "Construct a `Zip` object on the stack."}, 
        {"enumerate", "#define enumerate(I)", "Zip the iterable `I` with a `Range` object of the same length."}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Zip_Methods(void) 
{ 


  {
  return (methods___3);
}
}
var zip_stack(var self ) 
{ 
  struct Zip *z ;
  size_t nargs ;
  size_t tmp ;
  struct Tuple *t ;
  size_t i ;

  {
  z = (struct Zip *)self;
  tmp = len(z->iters);
  nargs = tmp;
  t = (struct Tuple *)z->values;
  i = (size_t )0;
  while (i < nargs) {
    *(t->items + i) = _;
    i ++;
  }
  *(t->items + nargs) = Terminal;
  return ((var )z);
}
}
static void Zip_New(var self , var args ) 
{ 
  struct Zip *z ;
  struct Tuple __constr_expr_171 ;
  var __constr_expr_172[1] ;
  char __constr_expr_173[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  var tmp___2 ;
  struct Tuple __constr_expr_174 ;
  var __constr_expr_175[1] ;
  char __constr_expr_176[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;
  var tmp___6 ;
  size_t i ;
  size_t tmp___7 ;

  {
  z = (struct Zip *)self;
  __constr_expr_172[0] = Terminal;
  __constr_expr_171.items = __constr_expr_172;
  __constr_expr_173[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_173[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_173), Tuple, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_171),
                   sizeof(struct Tuple ));
  tmp___2 = new_with(Tuple, (var )((struct Tuple *)tmp___1));
  z->iters = (var )((struct Tuple *)tmp___2);
  __constr_expr_175[0] = Terminal;
  __constr_expr_174.items = __constr_expr_175;
  __constr_expr_176[0] = (char)0;
  tmp___3 = 1U;
  while (! (tmp___3 >= 32U)) {
    __constr_expr_176[tmp___3] = (char)0;
    tmp___3 ++;
  }
  tmp___4 = header_init((var )(__constr_expr_176), Tuple, 2);
  tmp___5 = memcpy((void * __restrict  )((struct Tuple *)tmp___4), (void const   * __restrict  )(& __constr_expr_174),
                   sizeof(struct Tuple ));
  tmp___6 = new_with(Tuple, (var )((struct Tuple *)tmp___5));
  z->values = (var )((struct Tuple *)tmp___6);
  assign(z->iters, args);
  i = (size_t )0;
  while (1) {
    tmp___7 = len(args);
    if (! (i < tmp___7)) {
      break;
    }
    push(z->values, _);
    i ++;
  }
  return;
}
}
static void Zip_Del(var self ) 
{ 
  struct Zip *z ;

  {
  z = (struct Zip *)self;
  del(z->iters);
  del(z->values);
  return;
}
}
static void Zip_Assign(var self , var obj ) 
{ 
  struct Zip *z ;
  struct Zip *o ;
  var tmp ;

  {
  z = (struct Zip *)self;
  tmp = cast(obj, Zip);
  o = (struct Zip *)tmp;
  assign(z->iters, o->iters);
  assign(z->values, o->values);
  return;
}
}
static var Zip_Iter_Init(var self ) 
{ 
  struct Zip *z ;
  struct Tuple *values ;
  struct Tuple *iters ;
  size_t num ;
  size_t tmp ;
  size_t i ;
  var init ;
  var tmp___0 ;

  {
  z = (struct Zip *)self;
  values = (struct Tuple *)z->values;
  iters = (struct Tuple *)z->iters;
  tmp = len((var )iters);
  num = tmp;
  if (num == 0UL) {
    return (Terminal);
  }
  i = (size_t )0;
  while (i < num) {
    tmp___0 = iter_init(*(iters->items + i));
    init = tmp___0;
    if ((unsigned long )init == (unsigned long )Terminal) {
      return (Terminal);
    }
    *(values->items + i) = init;
    i ++;
  }
  return ((var )values);
}
}
static var Zip_Iter_Last(var self ) 
{ 
  struct Zip *z ;
  struct Tuple *values ;
  struct Tuple *iters ;
  size_t num ;
  size_t tmp ;
  size_t i ;
  var last ;
  var tmp___0 ;

  {
  z = (struct Zip *)self;
  values = (struct Tuple *)z->values;
  iters = (struct Tuple *)z->iters;
  tmp = len((var )iters);
  num = tmp;
  if (num == 0UL) {
    return (Terminal);
  }
  i = (size_t )0;
  while (i < num) {
    tmp___0 = iter_last(*(iters->items + i));
    last = tmp___0;
    if ((unsigned long )last == (unsigned long )Terminal) {
      return (Terminal);
    }
    *(values->items + i) = last;
    i ++;
  }
  return ((var )values);
}
}
static var Zip_Iter_Next(var self , var curr ) 
{ 
  struct Zip *z ;
  struct Tuple *values ;
  struct Tuple *iters ;
  size_t num ;
  size_t tmp ;
  size_t i ;
  var next ;
  struct Int __constr_expr_177 ;
  char __constr_expr_178[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;
  var tmp___3 ;
  var tmp___4 ;

  {
  z = (struct Zip *)self;
  values = (struct Tuple *)z->values;
  iters = (struct Tuple *)z->iters;
  tmp = len((var )iters);
  num = tmp;
  if (num == 0UL) {
    return (Terminal);
  }
  i = (size_t )0;
  while (i < num) {
    __constr_expr_177.val = (int64_t )i;
    __constr_expr_178[0] = (char)0;
    tmp___0 = 1U;
    while (! (tmp___0 >= 32U)) {
      __constr_expr_178[tmp___0] = (char)0;
      tmp___0 ++;
    }
    tmp___1 = header_init((var )(__constr_expr_178), Int, 2);
    tmp___2 = memcpy((void * __restrict  )((struct Int *)tmp___1), (void const   * __restrict  )(& __constr_expr_177),
                     sizeof(struct Int ));
    tmp___3 = get(curr, (var )((struct Int *)tmp___2));
    tmp___4 = iter_next(*(iters->items + i), tmp___3);
    next = tmp___4;
    if ((unsigned long )next == (unsigned long )Terminal) {
      return (Terminal);
    }
    *(values->items + i) = next;
    i ++;
  }
  return ((var )values);
}
}
static var Zip_Iter_Prev(var self , var curr ) 
{ 
  struct Zip *z ;
  struct Tuple *values ;
  struct Tuple *iters ;
  size_t num ;
  size_t tmp ;
  size_t i ;
  var prev ;
  struct Int __constr_expr_179 ;
  char __constr_expr_180[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;
  var tmp___3 ;
  var tmp___4 ;

  {
  z = (struct Zip *)self;
  values = (struct Tuple *)z->values;
  iters = (struct Tuple *)z->iters;
  tmp = len((var )iters);
  num = tmp;
  if (num == 0UL) {
    return (Terminal);
  }
  i = (size_t )0;
  while (i < num) {
    __constr_expr_179.val = (int64_t )i;
    __constr_expr_180[0] = (char)0;
    tmp___0 = 1U;
    while (! (tmp___0 >= 32U)) {
      __constr_expr_180[tmp___0] = (char)0;
      tmp___0 ++;
    }
    tmp___1 = header_init((var )(__constr_expr_180), Int, 2);
    tmp___2 = memcpy((void * __restrict  )((struct Int *)tmp___1), (void const   * __restrict  )(& __constr_expr_179),
                     sizeof(struct Int ));
    tmp___3 = get(curr, (var )((struct Int *)tmp___2));
    tmp___4 = iter_prev(*(iters->items + i), tmp___3);
    prev = tmp___4;
    if ((unsigned long )prev == (unsigned long )Terminal) {
      return (Terminal);
    }
    *(values->items + i) = prev;
    i ++;
  }
  return ((var )values);
}
}
static var Zip_Iter_Type(var self ) 
{ 


  {
  return (Tuple);
}
}
static size_t Zip_Len(var self ) 
{ 
  struct Zip *z ;
  struct Tuple *values ;
  struct Tuple *iters ;
  size_t num ;
  size_t tmp ;
  size_t mlen ;
  size_t tmp___0 ;
  size_t i ;
  size_t num___0 ;
  size_t tmp___1 ;

  {
  z = (struct Zip *)self;
  values = (struct Tuple *)z->values;
  iters = (struct Tuple *)z->iters;
  tmp = len((var )iters);
  num = tmp;
  if (num == 0UL) {
    return ((size_t )0);
  }
  tmp___0 = len(*(iters->items + 0));
  mlen = tmp___0;
  i = (size_t )1;
  while (i < num) {
    tmp___1 = len(*(iters->items + i));
    num___0 = tmp___1;
    if (num___0 < mlen) {
      mlen = num___0;
    } else {
      mlen = mlen;
    }
    i ++;
  }
  return (mlen);
}
}
static var Zip_Get(var self , var key ) 
{ 
  struct Zip *z ;
  struct Tuple *values ;
  struct Tuple *iters ;
  size_t num ;
  size_t tmp ;
  size_t i ;

  {
  z = (struct Zip *)self;
  values = (struct Tuple *)z->values;
  iters = (struct Tuple *)z->iters;
  tmp = len((var )iters);
  num = tmp;
  i = (size_t )0;
  while (i < num) {
    *(values->items + i) = get(*(iters->items + i), key);
    i ++;
  }
  return ((var )values);
}
}
static _Bool Zip_Mem(var self , var key ) 
{ 
  var __item ;
  var __Iteritem ;
  var tmp ;
  var item ;
  var tmp___0 ;
  _Bool tmp___1 ;

  {
  __item = self;
  tmp = instance(__item, Iter);
  __Iteritem = tmp;
  tmp___0 = (*(((struct Iter *)__Iteritem)->iter_init))(__item);
  item = tmp___0;
  while ((unsigned long )item != (unsigned long )Terminal) {
    tmp___1 = eq(item, key);
    if (tmp___1) {
      return ((_Bool)1);
    }
    item = (*(((struct Iter *)__Iteritem)->iter_next))(__item, item);
  }
  return ((_Bool)0);
}
}
static struct Doc __constr_expr_182  =    {& Zip_Name, & Zip_Brief, & Zip_Description, & Zip_Definition, & Zip_Examples,
    & Zip_Methods};
static struct New __constr_expr_183  =    {& Zip_New, & Zip_Del};
static struct Assign __constr_expr_184  =    {& Zip_Assign};
static struct Len __constr_expr_185  =    {& Zip_Len};
static struct Get __constr_expr_186  =    {& Zip_Get, (void (*)(var  , var  , var  ))((void *)0), & Zip_Mem, (void (*)(var  ,
                                                                                var  ))((void *)0),
    (var (*)(var  ))0, (var (*)(var  ))0};
static struct Iter __constr_expr_187  =    {& Zip_Iter_Init, & Zip_Iter_Next, & Zip_Iter_Last, & Zip_Iter_Prev, & Zip_Iter_Type};
static var __constr_expr_181[48]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Zip", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Zip ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_182),      (void *)0,      (var )"New", 
        (var )(& __constr_expr_183),      (void *)0,      (var )"Assign",      (var )(& __constr_expr_184), 
        (void *)0,      (var )"Len",      (var )(& __constr_expr_185),      (void *)0, 
        (var )"Get",      (var )(& __constr_expr_186),      (void *)0,      (var )"Iter", 
        (var )(& __constr_expr_187),      (void *)0,      (void *)0,      (void *)0};
var Zip  =    (var )((char *)(__constr_expr_181) + sizeof(struct Header ));
var enumerate_stack(var self ) 
{ 
  struct Zip *z ;
  struct Range *r ;
  struct Int __constr_expr_188 ;
  char __constr_expr_189[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  var tmp___2 ;
  struct Int __constr_expr_190 ;
  char __constr_expr_191[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;
  var tmp___6 ;
  size_t tmp___7 ;

  {
  z = (struct Zip *)self;
  __constr_expr_188.val = (int64_t )0;
  __constr_expr_189[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_189[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_189), Int, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Int *)tmp___0), (void const   * __restrict  )(& __constr_expr_188),
                   sizeof(struct Int ));
  tmp___2 = get(z->iters, (var )((struct Int *)tmp___1));
  r = (struct Range *)tmp___2;
  __constr_expr_190.val = (int64_t )1;
  __constr_expr_191[0] = (char)0;
  tmp___3 = 1U;
  while (! (tmp___3 >= 32U)) {
    __constr_expr_191[tmp___3] = (char)0;
    tmp___3 ++;
  }
  tmp___4 = header_init((var )(__constr_expr_191), Int, 2);
  tmp___5 = memcpy((void * __restrict  )((struct Int *)tmp___4), (void const   * __restrict  )(& __constr_expr_190),
                   sizeof(struct Int ));
  tmp___6 = get(z->iters, (var )((struct Int *)tmp___5));
  tmp___7 = len(tmp___6);
  r->stop = (int64_t )tmp___7;
  return (self);
}
}
static char const   *Filter_Name(void) 
{ 


  {
  return ("Filter");
}
}
static char const   *Filter_Brief(void) 
{ 


  {
  return ("Filtered Iterable");
}
}
static char const   *Filter_Description(void) 
{ 


  {
  return ("The `Filter` type can be used to filter the results of some iterable. Given a callable object `Filter` iterable returns only those items in the original iterable for where calling the function returns a non-`NULL` value.");
}
}
static char const   *Filter_Definition(void) 
{ 


  {
  return ("struct Filter {\n  var iter;\n  var func;\n};\n");
}
}
static struct Example *Filter_Examples(void) ;
static struct Example examples___5[3]  = {      {"Usage", "var greater_than_two(var x) {\n  return c_int(x) > 2 ? x : NULL;\n}\n\nvar x = new(Array, Int, $I(0), $I(5), $I(2), $I(9));\n\nforeach (n in filter(x, $(Function, greater_than_two))) {\n  show(n); /* 5, 9 */\n}\n"}, 
        {"Usage 2",
      "var mem_hello(var x) {\n  return mem(x, $S(\"Hello\")) ? x : NULL;\n}\n\nvar x = new(Tuple, \n  $S(\"Hello World\"), $S(\"Hello Dan\"), \n  $S(\"Bonjour\"));\n\nvar y = new(Tuple);\nassign(y, filter(x, $(Function, mem_hello)));\nshow(y); /* tuple(\"Hello World\", \"Hello Dan\") */\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Filter_Examples(void) 
{ 


  {
  return (examples___5);
}
}
static struct Method *Filter_Methods(void) ;
static struct Method methods___4[2]  = {      {"filter", "#define filter(I, F)", "Construct a `Filter` object on the stack over iterable `I` with filter function `F`."}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Filter_Methods(void) 
{ 


  {
  return (methods___4);
}
}
static void Filter_New(var self , var args ) 
{ 
  struct Filter *f ;
  struct Int __constr_expr_192 ;
  char __constr_expr_193[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  struct Int __constr_expr_194 ;
  char __constr_expr_195[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___2 ;
  var tmp___3 ;
  void *tmp___4 ;

  {
  f = (struct Filter *)self;
  __constr_expr_192.val = (int64_t )0;
  __constr_expr_193[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_193[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_193), Int, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Int *)tmp___0), (void const   * __restrict  )(& __constr_expr_192),
                   sizeof(struct Int ));
  f->iter = get(args, (var )((struct Int *)tmp___1));
  __constr_expr_194.val = (int64_t )1;
  __constr_expr_195[0] = (char)0;
  tmp___2 = 1U;
  while (! (tmp___2 >= 32U)) {
    __constr_expr_195[tmp___2] = (char)0;
    tmp___2 ++;
  }
  tmp___3 = header_init((var )(__constr_expr_195), Int, 2);
  tmp___4 = memcpy((void * __restrict  )((struct Int *)tmp___3), (void const   * __restrict  )(& __constr_expr_194),
                   sizeof(struct Int ));
  f->func = get(args, (var )((struct Int *)tmp___4));
  return;
}
}
static var Filter_Iter_Init(var self ) 
{ 
  struct Filter *f ;
  var curr ;
  var tmp ;
  var tmp___0 ;

  {
  f = (struct Filter *)self;
  tmp = iter_init(f->iter);
  curr = tmp;
  while (1) {
    if ((unsigned long )curr == (unsigned long )Terminal) {
      return (curr);
    } else {
      tmp___0 = call_with(f->func, curr);
      if (tmp___0) {
        return (curr);
      } else {
        curr = iter_next(f->iter, curr);
      }
    }
  }
  return (Terminal);
}
}
static var Filter_Iter_Last(var self ) 
{ 
  struct Filter *f ;
  var curr ;
  var tmp ;
  var tmp___0 ;

  {
  f = (struct Filter *)self;
  tmp = iter_last(f->iter);
  curr = tmp;
  while (1) {
    if ((unsigned long )curr == (unsigned long )Terminal) {
      return (curr);
    } else {
      tmp___0 = call_with(f->func, curr);
      if (tmp___0) {
        return (curr);
      } else {
        curr = iter_prev(f->iter, curr);
      }
    }
  }
  return (Terminal);
}
}
static var Filter_Iter_Next(var self , var curr ) 
{ 
  struct Filter *f ;
  var tmp ;

  {
  f = (struct Filter *)self;
  curr = iter_next(f->iter, curr);
  while (1) {
    if ((unsigned long )curr == (unsigned long )Terminal) {
      return (curr);
    } else {
      tmp = call_with(f->func, curr);
      if (tmp) {
        return (curr);
      } else {
        curr = iter_next(f->iter, curr);
      }
    }
  }
  return (Terminal);
}
}
static var Filter_Iter_Prev(var self , var curr ) 
{ 
  struct Filter *f ;
  var tmp ;

  {
  f = (struct Filter *)self;
  curr = iter_prev(f->iter, curr);
  while (1) {
    if ((unsigned long )curr == (unsigned long )Terminal) {
      return (curr);
    } else {
      tmp = call_with(f->func, curr);
      if (tmp) {
        return (curr);
      } else {
        curr = iter_prev(f->iter, curr);
      }
    }
  }
  return (Terminal);
}
}
static var Filter_Iter_Type(var self ) 
{ 
  struct Filter *f ;
  var tmp ;

  {
  f = (struct Filter *)self;
  tmp = iter_type(f->iter);
  return (tmp);
}
}
static _Bool Filter_Mem(var self , var key ) 
{ 
  var __item ;
  var __Iteritem ;
  var tmp ;
  var item ;
  var tmp___0 ;
  _Bool tmp___1 ;

  {
  __item = self;
  tmp = instance(__item, Iter);
  __Iteritem = tmp;
  tmp___0 = (*(((struct Iter *)__Iteritem)->iter_init))(__item);
  item = tmp___0;
  while ((unsigned long )item != (unsigned long )Terminal) {
    tmp___1 = eq(item, key);
    if (tmp___1) {
      return ((_Bool)1);
    }
    item = (*(((struct Iter *)__Iteritem)->iter_next))(__item, item);
  }
  return ((_Bool)0);
}
}
static struct Doc __constr_expr_197  =    {& Filter_Name, & Filter_Brief, & Filter_Description, & Filter_Definition, & Filter_Examples,
    & Filter_Methods};
static struct New __constr_expr_198  =    {& Filter_New, (void (*)(var  ))((void *)0)};
static struct Get __constr_expr_199  =    {(var (*)(var  , var  ))((void *)0), (void (*)(var  , var  , var  ))((void *)0),
    & Filter_Mem, (void (*)(var  , var  ))((void *)0), (var (*)(var  ))0, (var (*)(var  ))0};
static struct Iter __constr_expr_200  =    {& Filter_Iter_Init,
    & Filter_Iter_Next, & Filter_Iter_Last, & Filter_Iter_Prev, & Filter_Iter_Type};
static var __constr_expr_196[42]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Filter", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Filter ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_197),      (void *)0,      (var )"New", 
        (var )(& __constr_expr_198),      (void *)0,      (var )"Get",      (var )(& __constr_expr_199), 
        (void *)0,      (var )"Iter",      (var )(& __constr_expr_200),      (void *)0, 
        (void *)0,      (void *)0};
var Filter  =    (var )((char *)(__constr_expr_196) + sizeof(struct Header ));
static char const   *Map_Name(void) 
{ 


  {
  return ("Map");
}
}
static char const   *Map_Brief(void) 
{ 


  {
  return ("Apply Function to Iterable");
}
}
static char const   *Map_Description(void) 
{ 


  {
  return ("The `Map` type is an iterable that applies some callable to to each item in another iterable and returns the result. This can be useful to make more concise iteration when there are callback functions available.\n\nIf the mapping callable is a purely side-effect callable it is possible to use the `call` function on the `Map` object directly for a quick way to perform the iteration.\n\nOne downside of `Map` is that the `iter_type` becomes unknown (there is no way to know what type the callable will return so some objects such as `Array`s may revert to using `Ref` as the object type when assigned a `Map`.");
}
}
static char const   *Map_Definition(void) 
{ 


  {
  return ("struct Map {\n  var iter;\n  var curr;\n  var func;\n};\n");
}
}
static struct Method *Map_Methods(void) ;
static struct Method methods___5[2]  = {      {"map", "#define map(I, F)", "Construct a `Map` object on the stack over iterable `I` applying function `F`."}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Map_Methods(void) 
{ 


  {
  return (methods___5);
}
}
static struct Example *Map_Examples(void) ;
static struct Example examples___6[3]  = {      {"Usage", "var convert_to_int(var x) {\n  var y = new(Int);\n  look_from(y, x, 0);\n  return y;\n}\n\nvar x = tuple($S(\"1\"), $S(\"2\"), $S(\"3\"));\n\nforeach (y in map(x, $(Function, convert_to_int))) {\n  show(y); /* 1, 2, 3 */\n};\n"}, 
        {"Usage 2",
      "var print_object(var x) {\n  println(\"Object %$ is of type %$\", x, type_of(x));\n  return NULL;\n}\n\nvar x = tuple($I(0), $S(\"Hello!\"), $F(2.4));\n\ncall(map(x, $(Function, print_object)));\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Map_Examples(void) 
{ 


  {
  return (examples___6);
}
}
static void Map_New(var self , var args ) 
{ 
  struct Map *m ;
  struct Int __constr_expr_201 ;
  char __constr_expr_202[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  struct Int __constr_expr_203 ;
  char __constr_expr_204[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___2 ;
  var tmp___3 ;
  void *tmp___4 ;

  {
  m = (struct Map *)self;
  __constr_expr_201.val = (int64_t )0;
  __constr_expr_202[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_202[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_202), Int, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Int *)tmp___0), (void const   * __restrict  )(& __constr_expr_201),
                   sizeof(struct Int ));
  m->iter = get(args, (var )((struct Int *)tmp___1));
  __constr_expr_203.val = (int64_t )1;
  __constr_expr_204[0] = (char)0;
  tmp___2 = 1U;
  while (! (tmp___2 >= 32U)) {
    __constr_expr_204[tmp___2] = (char)0;
    tmp___2 ++;
  }
  tmp___3 = header_init((var )(__constr_expr_204), Int, 2);
  tmp___4 = memcpy((void * __restrict  )((struct Int *)tmp___3), (void const   * __restrict  )(& __constr_expr_203),
                   sizeof(struct Int ));
  m->func = get(args, (var )((struct Int *)tmp___4));
  return;
}
}
static var Map_Iter_Init(var self ) 
{ 
  struct Map *m ;
  var tmp ;

  {
  m = (struct Map *)self;
  m->curr = iter_init(m->iter);
  if ((unsigned long )m->curr == (unsigned long )Terminal) {
    return (m->curr);
  } else {
    tmp = call_with(m->func, m->curr);
    return (tmp);
  }
}
}
static var Map_Iter_Last(var self ) 
{ 
  struct Map *m ;
  var tmp ;

  {
  m = (struct Map *)self;
  m->curr = iter_last(m->iter);
  if ((unsigned long )m->curr == (unsigned long )Terminal) {
    return (m->curr);
  } else {
    tmp = call_with(m->func, m->curr);
    return (tmp);
  }
}
}
static var Map_Iter_Next(var self , var curr ) 
{ 
  struct Map *m ;
  var tmp ;

  {
  m = (struct Map *)self;
  m->curr = iter_next(m->iter, m->curr);
  if ((unsigned long )m->curr == (unsigned long )Terminal) {
    return (m->curr);
  } else {
    tmp = call_with(m->func, m->curr);
    return (tmp);
  }
}
}
static var Map_Iter_Prev(var self , var curr ) 
{ 
  struct Map *m ;
  var tmp ;

  {
  m = (struct Map *)self;
  m->curr = iter_prev(m->iter, m->curr);
  if ((unsigned long )m->curr == (unsigned long )Terminal) {
    return (m->curr);
  } else {
    tmp = call_with(m->func, m->curr);
    return (tmp);
  }
}
}
static size_t Map_Len(var self ) 
{ 
  struct Map *m ;
  size_t tmp ;

  {
  m = (struct Map *)self;
  tmp = len(m->iter);
  return (tmp);
}
}
static var Map_Get(var self , var key ) 
{ 
  struct Map *m ;
  var tmp ;

  {
  m = (struct Map *)self;
  m->curr = get(m->iter, key);
  if ((unsigned long )m->curr == (unsigned long )Terminal) {
    return (m->curr);
  } else {
    tmp = call_with(m->func, m->curr);
    return (tmp);
  }
}
}
static _Bool Map_Mem(var self , var key ) 
{ 
  var __item ;
  var __Iteritem ;
  var tmp ;
  var item ;
  var tmp___0 ;
  _Bool tmp___1 ;

  {
  __item = self;
  tmp = instance(__item, Iter);
  __Iteritem = tmp;
  tmp___0 = (*(((struct Iter *)__Iteritem)->iter_init))(__item);
  item = tmp___0;
  while ((unsigned long )item != (unsigned long )Terminal) {
    tmp___1 = eq(item, key);
    if (tmp___1) {
      return ((_Bool)1);
    }
    item = (*(((struct Iter *)__Iteritem)->iter_next))(__item, item);
  }
  return ((_Bool)0);
}
}
static var Map_Call(var self , var args ) 
{ 
  var __item ;
  var __Iteritem ;
  var tmp ;
  var item ;
  var tmp___0 ;

  {
  __item = self;
  tmp = instance(__item, Iter);
  __Iteritem = tmp;
  tmp___0 = (*(((struct Iter *)__Iteritem)->iter_init))(__item);
  item = tmp___0;
  while ((unsigned long )item != (unsigned long )Terminal) {
    item = (*(((struct Iter *)__Iteritem)->iter_next))(__item, item);
  }
  return (Terminal);
}
}
static struct Doc __constr_expr_206  =    {& Map_Name, & Map_Brief, & Map_Description, & Map_Definition, & Map_Examples,
    & Map_Methods};
static struct New __constr_expr_207  =    {& Map_New, (void (*)(var  ))((void *)0)};
static struct Len __constr_expr_208  =    {& Map_Len};
static struct Get __constr_expr_209  =    {& Map_Get, (void (*)(var  , var  , var  ))((void *)0), & Map_Mem, (void (*)(var  ,
                                                                                var  ))((void *)0),
    (var (*)(var  ))0, (var (*)(var  ))0};
static struct Call __constr_expr_210  =    {& Map_Call};
static struct Iter __constr_expr_211  =    {& Map_Iter_Init, & Map_Iter_Next, & Map_Iter_Last, & Map_Iter_Prev, (var (*)(var  ))((void *)0)};
static var __constr_expr_205[48]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Map", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Map ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_206),      (void *)0,      (var )"New", 
        (var )(& __constr_expr_207),      (void *)0,      (var )"Len",      (var )(& __constr_expr_208), 
        (void *)0,      (var )"Get",      (var )(& __constr_expr_209),      (void *)0, 
        (var )"Call",      (var )(& __constr_expr_210),      (void *)0,      (var )"Iter", 
        (var )(& __constr_expr_211),      (void *)0,      (void *)0,      (void *)0};
var Map  =    (var )((char *)(__constr_expr_205) + sizeof(struct Header ));
#pragma merger("0","/tmp/cil-pw3NeVtE.i","-std=gnu99,-Wall,-Wno-unused,-g,-ggdb,-fPIC")
var TypeError ;
var Assign ;
var Swap ;
var type_of(var self ) ;
void swap(var self , var obj ) ;
static char const   *Assign_Name(void) 
{ 


  {
  return ("Assign");
}
}
static char const   *Assign_Brief(void) 
{ 


  {
  return ("Assignment");
}
}
static char const   *Assign_Description(void) 
{ 


  {
  return ("`Assign` is potentially the most important class in Cello. It is used throughout Cello to initialise objects using other objects. In C++ this is called the _copy constructor_ and it is used to assign the value of one object to another.\n\nBy default the `Assign` class uses the `Size` class to copy the memory from one object to another. But for more complex objects which maintain their own behaviours and state this may need to be overridden.\n\nThe most important thing about the `Assign` class is that it must work on the assumption that the target object may not have had it\'s constructor called and could be uninitialised with just zero\'d memory. This is often the case when copying contents into containers.");
}
}
static char const   *Assign_Definition(void) 
{ 


  {
  return ("struct Assign {\n  void (*assign)(var, var);\n};\n");
}
}
static struct Example *Assign_Examples(void) ;
static struct Example examples___7[2]  = {      {"Usage", "var x = new(Int, $I(10));\nvar y = new(Int, $I(20));\n\nshow(x); /* 10 */\nshow(y); /* 20 */\n\nassign(x, y);\n\nshow(x); /* 20 */\nshow(y); /* 20 */\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Assign_Examples(void) 
{ 


  {
  return (examples___7);
}
}
static struct Method *Assign_Methods(void) ;
static struct Method methods___6[2]  = {      {"assign", "var assign(var self, var obj);", "Assign the object `obj` to the object `self`. The assigned object `self` is returned."}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Assign_Methods(void) 
{ 


  {
  return (methods___6);
}
}
static struct Doc __constr_expr_213  =    {& Assign_Name, & Assign_Brief, & Assign_Description, & Assign_Definition, & Assign_Examples,
    & Assign_Methods};
static var __constr_expr_212[33]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Assign", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Assign ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_213),      (void *)0,      (void *)0, 
        (void *)0};
var Assign  =    (var )((char *)(__constr_expr_212) + sizeof(struct Header ));
var assign(var self , var obj ) 
{ 
  struct Assign *a ;
  var tmp ;
  size_t s ;
  var tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  var tmp___3 ;
  var tmp___4 ;
  struct Tuple __constr_expr_214 ;
  var __constr_expr_215[3] ;
  var tmp___5 ;
  var tmp___6 ;
  char __constr_expr_216[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___7 ;
  var tmp___8 ;
  void *tmp___9 ;
  var tmp___10 ;

  {
  tmp = instance(self, Assign);
  a = (struct Assign *)tmp;
  if (a) {
    if (a->assign) {
      (*(a->assign))(self, obj);
      return (self);
    }
  }
  tmp___0 = type_of(self);
  tmp___1 = size(tmp___0);
  s = tmp___1;
  tmp___3 = type_of(self);
  tmp___4 = type_of(obj);
  if ((unsigned long )tmp___3 == (unsigned long )tmp___4) {
    if (s) {
      tmp___2 = memcpy((void * __restrict  )self, (void const   * __restrict  )obj,
                       s);
      return (tmp___2);
    }
  }
  tmp___5 = type_of(obj);
  tmp___6 = type_of(self);
  __constr_expr_215[0] = tmp___5;
  __constr_expr_215[1] = tmp___6;
  __constr_expr_215[2] = Terminal;
  __constr_expr_214.items = __constr_expr_215;
  __constr_expr_216[0] = (char)0;
  tmp___7 = 1U;
  while (! (tmp___7 >= 32U)) {
    __constr_expr_216[tmp___7] = (char)0;
    tmp___7 ++;
  }
  tmp___8 = header_init((var )(__constr_expr_216), Tuple, 2);
  tmp___9 = memcpy((void * __restrict  )((struct Tuple *)tmp___8), (void const   * __restrict  )(& __constr_expr_214),
                   sizeof(struct Tuple ));
  tmp___10 = exception_throw(TypeError, "Cannot assign type %s to type %s", (var )((struct Tuple *)tmp___9));
  return (tmp___10);
}
}
static char const   *Swap_Name(void) 
{ 


  {
  return ("Swap");
}
}
static char const   *Swap_Brief(void) 
{ 


  {
  return ("Swapable");
}
}
static char const   *Swap_Description(void) 
{ 


  {
  return ("The `Swap` class can be used to override the behaviour of swapping two objects. By default the `Swap` class simply swaps the memory of the two objects passed in as parameters making use of the `Size` class. In almost all cases this default behaviour should be fine, even if the objects have custom assignment functions.\n\nSwapping can be used internally by various collections and algorithms.");
}
}
static char const   *Swap_Definition(void) 
{ 


  {
  return ("struct Swap {\n  void (*swap)(var, var);\n};\n");
}
}
static struct Example *Swap_Examples(void) ;
static struct Example examples___8[2]  = {      {"Usage", "var x = $S(\"Hello\");\nvar y = $S(\"World\");\nshow(x); /* Hello */\nshow(y); /* World */\nswap(x, y);\nshow(x); /* World */\nshow(y); /* Hello */\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Swap_Examples(void) 
{ 


  {
  return (examples___8);
}
}
static struct Method *Swap_Methods(void) ;
static struct Method methods___7[2]  = {      {"swap", "void swap(var self, var obj);", "Swap the object `self` for the object `obj`."}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Swap_Methods(void) 
{ 


  {
  return (methods___7);
}
}
static struct Doc __constr_expr_218  =    {& Swap_Name, & Swap_Brief, & Swap_Description, & Swap_Definition, & Swap_Examples,
    & Swap_Methods};
static var __constr_expr_217[33]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Swap", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Swap ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_218),      (void *)0,      (void *)0, 
        (void *)0};
var Swap  =    (var )((char *)(__constr_expr_217) + sizeof(struct Header ));
static void memswap(void *p0 , void *p1 , size_t s ) 
{ 
  size_t i ;
  char t ;

  {
  if ((unsigned long )p0 == (unsigned long )p1) {
    return;
  }
  i = (size_t )0;
  while (i < s) {
    t = *((char *)p0 + i);
    *((char *)p0 + i) = *((char *)p1 + i);
    *((char *)p1 + i) = t;
    i ++;
  }
  return;
}
}
void swap(var self , var obj ) 
{ 
  struct Swap *s ;
  var tmp ;
  size_t n ;
  var tmp___0 ;
  size_t tmp___1 ;
  var tmp___2 ;
  var tmp___3 ;
  struct Tuple __constr_expr_219 ;
  var __constr_expr_220[3] ;
  var tmp___4 ;
  var tmp___5 ;
  char __constr_expr_221[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___6 ;
  var tmp___7 ;
  void *tmp___8 ;

  {
  tmp = instance(self, Swap);
  s = (struct Swap *)tmp;
  if (s) {
    if (s->swap) {
      (*(s->swap))(self, obj);
      return;
    }
  }
  tmp___0 = type_of(self);
  tmp___1 = size(tmp___0);
  n = tmp___1;
  tmp___2 = type_of(self);
  tmp___3 = type_of(obj);
  if ((unsigned long )tmp___2 == (unsigned long )tmp___3) {
    if (n) {
      memswap(self, obj, n);
      return;
    }
  }
  tmp___4 = type_of(obj);
  tmp___5 = type_of(self);
  __constr_expr_220[0] = tmp___4;
  __constr_expr_220[1] = tmp___5;
  __constr_expr_220[2] = Terminal;
  __constr_expr_219.items = __constr_expr_220;
  __constr_expr_221[0] = (char)0;
  tmp___6 = 1U;
  while (! (tmp___6 >= 32U)) {
    __constr_expr_221[tmp___6] = (char)0;
    tmp___6 ++;
  }
  tmp___7 = header_init((var )(__constr_expr_221), Tuple, 2);
  tmp___8 = memcpy((void * __restrict  )((struct Tuple *)tmp___7), (void const   * __restrict  )(& __constr_expr_219),
                   sizeof(struct Tuple ));
  exception_throw(TypeError, "Cannot swap type %s and type %s", (var )((struct Tuple *)tmp___8));
  return;
}
}
#pragma merger("0","/tmp/cil-CRwN5bIw.i","-std=gnu99,-Wall,-Wno-unused,-g,-ggdb,-fPIC")
var Hash ;
uint64_t hash_data(void const   *data , size_t size___0 ) ;
static char const   *Hash_Name(void) 
{ 


  {
  return ("Hash");
}
}
static char const   *Hash_Brief(void) 
{ 


  {
  return ("Hashable");
}
}
static char const   *Hash_Description(void) 
{ 


  {
  return ("The `Hash` class provides a mechanism for hashing an object. This hash value should remain the same across objects that are also considered equal by the `Cmp` class. For objects that are not considered equal this value should aim to be evenly distributed across integers.\n\nThis is not a cryptographic hash. It is used for various objects or data structures that require fast hashing such as the `Table` type. Due to this it should not be used for cryptography or security.\n\nBy default an object is hashed by using its raw memory with the [Murmurhash](http://en.wikipedia.org/wiki/MurmurHash) algorithm. Due to the link between them it is recommended to only override `Hash` and `Cmp` in conjunction.");
}
}
static char const   *Hash_Definition(void) 
{ 


  {
  return ("struct Hash {\n  uint64_t (*hash)(var);\n};\n");
}
}
static struct Example *Hash_Examples(void) ;
static struct Example examples___9[2]  = {      {"Usage", "println(\"%li\", $I(hash($I(  1)))); /*   1 */\nprintln(\"%li\", $I(hash($I(123)))); /* 123 */\n\n/* 866003103 */\nprintln(\"%li\", $I(hash_data($I(123), size(Int))));\n\nprintln(\"%li\", $I(hash($S(\"Hello\"))));  /* -1838682532 */\nprintln(\"%li\", $I(hash($S(\"There\"))));  /*   961387266 */\nprintln(\"%li\", $I(hash($S(\"People\")))); /*   697467069 */\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Hash_Examples(void) 
{ 


  {
  return (examples___9);
}
}
static struct Method *Hash_Methods(void) ;
static struct Method methods___8[3]  = {      {"hash", "uint64_t hash(var self);", "Get the hash value for the object `self`."}, 
        {"hash_data",
      "uint64_t hash_data(void* data, size_t num);", "Hash `num` bytes pointed to by `data` using [Murmurhash](http://en.wikipedia.org/wiki/MurmurHash)."}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Hash_Methods(void) 
{ 


  {
  return (methods___8);
}
}
static struct Doc __constr_expr_223  =    {& Hash_Name, & Hash_Brief, & Hash_Description, & Hash_Definition, & Hash_Examples,
    & Hash_Methods};
static var __constr_expr_222[33]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Hash", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Hash ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_223),      (void *)0,      (void *)0, 
        (void *)0};
var Hash  =    (var )((char *)(__constr_expr_222) + sizeof(struct Header ));
uint64_t hash_data(void const   *data , size_t size___0 ) 
{ 
  uint64_t m ;
  int r ;
  uint64_t const   *d ;
  uint64_t const   *end ;
  uint64_t h ;
  uint64_t k ;
  uint64_t const   *tmp ;
  unsigned char const   *data2 ;

  {
  m = 14313749767032793493;
  r = 47;
  d = (uint64_t const   *)data;
  end = d + size___0 / 8UL;
  h = 844048UL ^ size___0 * m;
  while ((unsigned long )d != (unsigned long )end) {
    tmp = d;
    d ++;
    k = (uint64_t )*tmp;
    k *= m;
    k ^= k >> r;
    k *= m;
    h ^= k;
    h *= m;
  }
  data2 = (unsigned char const   *)d;
  switch (size___0 & 7UL) {
  case 7UL: 
  h ^= (uint64_t )*(data2 + 6) << 48;
  case 6UL: 
  h ^= (uint64_t )*(data2 + 5) << 40;
  case 5UL: 
  h ^= (uint64_t )*(data2 + 4) << 32;
  case 4UL: 
  h ^= (uint64_t )*(data2 + 3) << 24;
  case 3UL: 
  h ^= (uint64_t )*(data2 + 2) << 16;
  case 2UL: 
  h ^= (uint64_t )*(data2 + 1) << 8;
  case 1UL: 
  h ^= (uint64_t )*(data2 + 0);
  h *= m;
  }
  h ^= h >> r;
  h *= m;
  h ^= h >> r;
  return (h);
}
}
uint64_t hash(var self ) 
{ 
  struct Hash *h ;
  var tmp ;
  uint64_t tmp___0 ;
  var tmp___1 ;
  size_t tmp___2 ;
  uint64_t tmp___3 ;

  {
  tmp = instance(self, Hash);
  h = (struct Hash *)tmp;
  if (h) {
    if (h->hash) {
      tmp___0 = (*(h->hash))(self);
      return (tmp___0);
    }
  }
  tmp___1 = type_of(self);
  tmp___2 = size(tmp___1);
  tmp___3 = hash_data((void const   *)self, tmp___2);
  return (tmp___3);
}
}
#pragma merger("0","/tmp/cil-wQInt9T3.i","-std=gnu99,-Wall,-Wno-unused,-g,-ggdb,-fPIC")
var Push ;
void pop(var self ) ;
void push_at(var self , var val , var i ) ;
void pop_at(var self , var i ) ;
static char const   *Push_Name(void) 
{ 


  {
  return ("Push");
}
}
static char const   *Push_Brief(void) 
{ 


  {
  return ("Pushable and Popable object");
}
}
static char const   *Push_Description(void) 
{ 


  {
  return ("The `Push` class provides an interface for the addition and removal of objects from another in a positional sense.\n\n`push` can be used to add new objects to a collection and `pop` to remove them. Usage of `push` can require `assign` to be defined on the argument.");
}
}
static char const   *Push_Definition(void) 
{ 


  {
  return ("struct Push {\n  void (*push)(var, var);\n  void (*pop)(var);\n  void (*push_at)(var, var, var);\n  void (*pop_at)(var, var);\n};\n");
}
}
static struct Example *Push_Examples(void) ;
static struct Example examples___10[2]  = {      {"Usage", "var x = new(Array, Int);\n\npush(x, $I( 0));\npush(x, $I( 5));\npush(x, $I(10));\n\nshow(get(x, $I(0))); /*  0 */\nshow(get(x, $I(1))); /*  5 */\nshow(get(x, $I(2))); /* 10 */\n\npop_at(x, $I(1));\n\nshow(get(x, $I(0))); /*  0 */\nshow(get(x, $I(1))); /* 10 */\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Push_Examples(void) 
{ 


  {
  return (examples___10);
}
}
static struct Method *Push_Methods(void) ;
static struct Method methods___9[5]  = {      {"push", "void push(var self, var obj);", "Push the object `obj` onto the top of object `self`."}, 
        {"pop",
      "void pop(var self);", "Pop the top item from the object `self`."}, 
        {"push_at", "void push_at(var self, var obj, var key);", "Push the object `obj` onto the object `self` at a given `key`."}, 
        {"pop_at",
      "void pop_at(var self, var key);", "Pop the object from the object `self` at a given `key`."}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Push_Methods(void) 
{ 


  {
  return (methods___9);
}
}
static struct Doc __constr_expr_225  =    {& Push_Name, & Push_Brief, & Push_Description, & Push_Definition, & Push_Examples,
    & Push_Methods};
static var __constr_expr_224[33]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Push", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Push ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_225),      (void *)0,      (void *)0, 
        (void *)0};
var Push  =    (var )((char *)(__constr_expr_224) + sizeof(struct Header ));
void push(var self , var val ) 
{ 
  var tmp ;

  {
  tmp = method_at_offset(self, Push, (unsigned long )(& ((struct Push *)0)->push),
                         "push");
  (*(((struct Push *)tmp)->push))(self, val);
  return;
}
}
void push_at(var self , var val , var i ) 
{ 
  var tmp ;

  {
  tmp = method_at_offset(self, Push, (unsigned long )(& ((struct Push *)0)->push_at),
                         "push_at");
  (*(((struct Push *)tmp)->push_at))(self, val, i);
  return;
}
}
void pop(var self ) 
{ 
  var tmp ;

  {
  tmp = method_at_offset(self, Push, (unsigned long )(& ((struct Push *)0)->pop),
                         "pop");
  (*(((struct Push *)tmp)->pop))(self);
  return;
}
}
void pop_at(var self , var i ) 
{ 
  var tmp ;

  {
  tmp = method_at_offset(self, Push, (unsigned long )(& ((struct Push *)0)->pop_at),
                         "pop_at");
  (*(((struct Push *)tmp)->pop_at))(self, i);
  return;
}
}
#pragma merger("0","/tmp/cil-jINHha2n.i","-std=gnu99,-Wall,-Wno-unused,-g,-ggdb,-fPIC")
var Len ;
_Bool empty(var self ) ;
static char const   *Len_Name(void) 
{ 


  {
  return ("Len");
}
}
static char const   *Len_Brief(void) 
{ 


  {
  return ("Has a length");
}
}
static char const   *Len_Description(void) 
{ 


  {
  return ("The `Len` class can be implemented by any type that has a length associated with it. It is typically implemented by collections and is often used in conjunction with `Iter` or `Get`.");
}
}
static char const   *Len_Definition(void) 
{ 


  {
  return ("struct Len {\n  size_t (*len)(var);\n};\n");
}
}
static struct Example *Len_Examples(void) ;
static struct Example examples___11[2]  = {      {"Usage", "var x = new(Array, Int, $I(1), $I(2), $I(5));\nshow($I(len(x))); /* 3 */\nvar y = $S(\"Test\");\nshow($I(len(y))); /* 4 */\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Len_Examples(void) 
{ 


  {
  return (examples___11);
}
}
static struct Method *Len_Methods(void) ;
static struct Method methods___10[2]  = {      {"len", "size_t len(var self);", "Returns the length of object `self`."}, 
        {(char const   *)((void *)0), (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Len_Methods(void) 
{ 


  {
  return (methods___10);
}
}
static struct Doc __constr_expr_227  =    {& Len_Name, & Len_Brief, & Len_Description, & Len_Definition, & Len_Examples,
    & Len_Methods};
static var __constr_expr_226[33]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Len", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Len ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_227),      (void *)0,      (void *)0, 
        (void *)0};
var Len  =    (var )((char *)(__constr_expr_226) + sizeof(struct Header ));
size_t len(var self ) 
{ 
  var tmp ;
  size_t tmp___0 ;

  {
  tmp = method_at_offset(self, Len, (unsigned long )(& ((struct Len *)0)->len), "len");
  tmp___0 = (*(((struct Len *)tmp)->len))(self);
  return (tmp___0);
}
}
_Bool empty(var self ) 
{ 
  size_t tmp ;

  {
  tmp = len(self);
  return ((_Bool )(tmp == 0UL));
}
}
#pragma merger("0","/tmp/cil-IFIxAJ_M.i","-std=gnu99,-Wall,-Wno-unused,-g,-ggdb,-fPIC")
extern FILE *stderr ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env ,
                                                                int __val ) ;
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
var String ;
var File ;
var Thread ;
var Exception ;
var IOError ;
var BusyError ;
var ValueError ;
var ClassError ;
var ResourceError ;
var SegmentationError ;
var ProgramAbortedError ;
var DivisionByZeroError ;
var IllegalInstructionError ;
var ProgramInterruptedError ;
var ProgramTerminationError ;
var new_raw_with(var type , var args ) ;
void del_raw(var self ) ;
void set(var self , var key , var val ) ;
void rem(var self , var key ) ;
var current(var type ) ;
void exception_try(jmp_buf *env ) ;
void exception_try_end(void) ;
void exception_try_fail(void) ;
var exception_catch(var args ) ;
void exception_signals(void) ;
static var __constr_expr_228[30]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"TypeError", 
        (void *)0,      (var )"__Size",      (var )0,      (void *)0, 
        (void *)0,      (void *)0};
var TypeError  =    (var )((char *)(__constr_expr_228) + sizeof(struct Header ));
static var __constr_expr_229[30]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"ValueError", 
        (void *)0,      (var )"__Size",      (var )0,      (void *)0, 
        (void *)0,      (void *)0};
var ValueError  =    (var )((char *)(__constr_expr_229) + sizeof(struct Header ));
static var __constr_expr_230[30]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"ClassError", 
        (void *)0,      (var )"__Size",      (var )0,      (void *)0, 
        (void *)0,      (void *)0};
var ClassError  =    (var )((char *)(__constr_expr_230) + sizeof(struct Header ));
static var __constr_expr_231[30]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"IndexOutOfBoundsError", 
        (void *)0,      (var )"__Size",      (var )0,      (void *)0, 
        (void *)0,      (void *)0};
var IndexOutOfBoundsError  =    (var )((char *)(__constr_expr_231) + sizeof(struct Header ));
static var __constr_expr_232[30]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"KeyError", 
        (void *)0,      (var )"__Size",      (var )0,      (void *)0, 
        (void *)0,      (void *)0};
var KeyError  =    (var )((char *)(__constr_expr_232) + sizeof(struct Header ));
static var __constr_expr_233[30]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"OutOfMemoryError", 
        (void *)0,      (var )"__Size",      (var )0,      (void *)0, 
        (void *)0,      (void *)0};
var OutOfMemoryError  =    (var )((char *)(__constr_expr_233) + sizeof(struct Header ));
static var __constr_expr_234[30]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"IOError", 
        (void *)0,      (var )"__Size",      (var )0,      (void *)0, 
        (void *)0,      (void *)0};
var IOError  =    (var )((char *)(__constr_expr_234) + sizeof(struct Header ));
static var __constr_expr_235[30]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"FormatError", 
        (void *)0,      (var )"__Size",      (var )0,      (void *)0, 
        (void *)0,      (void *)0};
var FormatError  =    (var )((char *)(__constr_expr_235) + sizeof(struct Header ));
static var __constr_expr_236[30]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"BusyError", 
        (void *)0,      (var )"__Size",      (var )0,      (void *)0, 
        (void *)0,      (void *)0};
var BusyError  =    (var )((char *)(__constr_expr_236) + sizeof(struct Header ));
static var __constr_expr_237[30]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"ResourceError", 
        (void *)0,      (var )"__Size",      (var )0,      (void *)0, 
        (void *)0,      (void *)0};
var ResourceError  =    (var )((char *)(__constr_expr_237) + sizeof(struct Header ));
static var __constr_expr_238[30]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"ProgramAbortedError", 
        (void *)0,      (var )"__Size",      (var )0,      (void *)0, 
        (void *)0,      (void *)0};
var ProgramAbortedError  =    (var )((char *)(__constr_expr_238) + sizeof(struct Header ));
static var __constr_expr_239[30]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"DivisionByZeroError", 
        (void *)0,      (var )"__Size",      (var )0,      (void *)0, 
        (void *)0,      (void *)0};
var DivisionByZeroError  =    (var )((char *)(__constr_expr_239) + sizeof(struct Header ));
static var __constr_expr_240[30]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"IllegalInstructionError", 
        (void *)0,      (var )"__Size",      (var )0,      (void *)0, 
        (void *)0,      (void *)0};
var IllegalInstructionError  =    (var )((char *)(__constr_expr_240) + sizeof(struct Header ));
static var __constr_expr_241[30]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"ProgramInterruptedError", 
        (void *)0,      (var )"__Size",      (var )0,      (void *)0, 
        (void *)0,      (void *)0};
var ProgramInterruptedError  =    (var )((char *)(__constr_expr_241) + sizeof(struct Header ));
static var __constr_expr_242[30]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"SegmentationError", 
        (void *)0,      (var )"__Size",      (var )0,      (void *)0, 
        (void *)0,      (void *)0};
var SegmentationError  =    (var )((char *)(__constr_expr_242) + sizeof(struct Header ));
static var __constr_expr_243[30]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"ProgramTerminationError", 
        (void *)0,      (var )"__Size",      (var )0,      (void *)0, 
        (void *)0,      (void *)0};
var ProgramTerminationError  =    (var )((char *)(__constr_expr_243) + sizeof(struct Header ));
static char const   *Exception_Name(void) 
{ 


  {
  return ("Exception");
}
}
static char const   *Exception_Brief(void) 
{ 


  {
  return ("Exception Object");
}
}
static char const   *Exception_Description(void) 
{ 


  {
  return ("The `Exception` type provides an interface to the Cello Exception System. One instance of this type is created for each `Thread` and stores the various bits of data required for the exception system. It can be retrieved using the `current` function, although not much can be done with it.\n\nExceptions are available via the `try`, `catch` and `throw` macros. It is important that the `catch` part of the exception block is always evaluated otherwise the internal state of the exception system can go out of sync. For this reason please never use `return` inside a `try` block. \n\nThe `exception_signals` method can be used to register some exception to be thrown for any of the [standard C signals](https://en.wikipedia.org/wiki/C_signal_handling).\n\nTo get the current exception object or message use the `exception_message` or `exception_object` methods.");
}
}
static struct Method *Exception_Methods(void) ;
static struct Method methods___11[7]  = {      {"try", "#define try", "Start an exception `try` block."}, 
        {"catch", "#define catch(...)", "Start an exception `catch` block, catching any objects listed in `...` as the first name given. To catch any exception object leave argument list empty other than caught variable name."}, 
        {"#define throw",
      "throw(E, F, ...)", "Throw exception object `E` with format string `F` and arguments `...`."}, 
        {"exception_signals",
      "void exception_signals(void);", "Register the standard C signals to throw corresponding exceptions."}, 
        {"exception_object",
      "void exception_object(void);\n", "Retrieve the current exception object."}, 
        {"exception_message",
      "void exception_message(void);\n", "Retrieve the current exception message."}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Exception_Methods(void) 
{ 


  {
  return (methods___11);
}
}
static struct Example *Exception_Examples(void) ;
static struct Example examples___12[2]  = {      {"Usage", "var x = new(Table, String, Int);\nset(x, $S(\"Hello\"), $I(1));\nset(x, $S(\"World\"), $I(2));\n\ntry {\n  get(x, $S(\"Missing\"));\n} catch (e in KeyError) {\n  println(\"Got Exception: %$\", e);\n}\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Exception_Examples(void) 
{ 


  {
  return (examples___12);
}
}
static void Exception_New(var self , var args ) 
{ 
  struct Exception *e ;
  struct Tuple __constr_expr_244 ;
  var __constr_expr_245[1] ;
  char __constr_expr_246[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  var tmp___2 ;
  struct String __constr_expr_247 ;
  char __constr_expr_248[sizeof(struct Header ) + sizeof(struct String )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;
  var tmp___6 ;

  {
  e = (struct Exception *)self;
  e->active = (_Bool)0;
  e->depth = (size_t )0;
  e->obj = (void *)0;
  __constr_expr_245[0] = Terminal;
  __constr_expr_244.items = __constr_expr_245;
  __constr_expr_246[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_246[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_246), Tuple, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_244),
                   sizeof(struct Tuple ));
  tmp___2 = new_raw_with(String, (var )((struct Tuple *)tmp___1));
  e->msg = (var )((struct String *)tmp___2);
  memset((void *)(e->buffers), 0, sizeof(jmp_buf *) * 2048UL);
  __constr_expr_247.val = (char *)"__Exception";
  __constr_expr_248[0] = (char)0;
  tmp___3 = 1U;
  while (! (tmp___3 >= 32U)) {
    __constr_expr_248[tmp___3] = (char)0;
    tmp___3 ++;
  }
  tmp___4 = header_init((var )(__constr_expr_248), String, 2);
  tmp___5 = memcpy((void * __restrict  )((struct String *)tmp___4), (void const   * __restrict  )(& __constr_expr_247),
                   sizeof(struct String ));
  tmp___6 = current(Thread);
  set(tmp___6, (var )((struct String *)tmp___5), self);
  return;
}
}
static void Exception_Del(var self ) 
{ 
  struct Exception *e ;
  struct String __constr_expr_249 ;
  char __constr_expr_250[sizeof(struct Header ) + sizeof(struct String )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  var tmp___2 ;

  {
  e = (struct Exception *)self;
  del_raw(e->msg);
  __constr_expr_249.val = (char *)"__Exception";
  __constr_expr_250[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_250[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_250), String, 2);
  tmp___1 = memcpy((void * __restrict  )((struct String *)tmp___0), (void const   * __restrict  )(& __constr_expr_249),
                   sizeof(struct String ));
  tmp___2 = current(Thread);
  rem(tmp___2, (var )((struct String *)tmp___1));
  return;
}
}
static void Exception_Assign(var self , var obj ) 
{ 
  struct Exception *e ;
  struct Exception *o ;
  var tmp ;

  {
  e = (struct Exception *)self;
  tmp = cast(obj, Exception);
  o = (struct Exception *)tmp;
  e->obj = o->obj;
  assign(e->msg, o->msg);
  e->depth = o->depth;
  e->active = o->active;
  memcpy((void * __restrict  )(e->buffers), (void const   * __restrict  )(o->buffers),
         sizeof(jmp_buf *) * 2048UL);
  return;
}
}
static var Exception_Current(void) 
{ 
  struct String __constr_expr_251 ;
  char __constr_expr_252[sizeof(struct Header ) + sizeof(struct String )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  var tmp___2 ;
  var tmp___3 ;

  {
  __constr_expr_251.val = (char *)"__Exception";
  __constr_expr_252[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_252[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_252), String, 2);
  tmp___1 = memcpy((void * __restrict  )((struct String *)tmp___0), (void const   * __restrict  )(& __constr_expr_251),
                   sizeof(struct String ));
  tmp___2 = current(Thread);
  tmp___3 = get(tmp___2, (var )((struct String *)tmp___1));
  return (tmp___3);
}
}
static void Exception_Signal(int sig ) 
{ 
  struct Tuple __constr_expr_253 ;
  var __constr_expr_254[1] ;
  char __constr_expr_255[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  struct Tuple __constr_expr_256 ;
  var __constr_expr_257[1] ;
  char __constr_expr_258[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___2 ;
  var tmp___3 ;
  void *tmp___4 ;
  struct Tuple __constr_expr_259 ;
  var __constr_expr_260[1] ;
  char __constr_expr_261[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___5 ;
  var tmp___6 ;
  void *tmp___7 ;
  struct Tuple __constr_expr_262 ;
  var __constr_expr_263[1] ;
  char __constr_expr_264[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___8 ;
  var tmp___9 ;
  void *tmp___10 ;
  struct Tuple __constr_expr_265 ;
  var __constr_expr_266[1] ;
  char __constr_expr_267[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___11 ;
  var tmp___12 ;
  void *tmp___13 ;
  struct Tuple __constr_expr_268 ;
  var __constr_expr_269[1] ;
  char __constr_expr_270[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___14 ;
  var tmp___15 ;
  void *tmp___16 ;

  {
  switch (sig) {
  case 6: 
  __constr_expr_254[0] = Terminal;
  __constr_expr_253.items = __constr_expr_254;
  __constr_expr_255[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_255[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_255), Tuple, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_253),
                   sizeof(struct Tuple ));
  exception_throw(ProgramAbortedError, "Program Aborted", (var )((struct Tuple *)tmp___1));
  case 8: 
  __constr_expr_257[0] = Terminal;
  __constr_expr_256.items = __constr_expr_257;
  __constr_expr_258[0] = (char)0;
  tmp___2 = 1U;
  while (! (tmp___2 >= 32U)) {
    __constr_expr_258[tmp___2] = (char)0;
    tmp___2 ++;
  }
  tmp___3 = header_init((var )(__constr_expr_258), Tuple, 2);
  tmp___4 = memcpy((void * __restrict  )((struct Tuple *)tmp___3), (void const   * __restrict  )(& __constr_expr_256),
                   sizeof(struct Tuple ));
  exception_throw(DivisionByZeroError, "Division by Zero", (var )((struct Tuple *)tmp___4));
  case 4: 
  __constr_expr_260[0] = Terminal;
  __constr_expr_259.items = __constr_expr_260;
  __constr_expr_261[0] = (char)0;
  tmp___5 = 1U;
  while (! (tmp___5 >= 32U)) {
    __constr_expr_261[tmp___5] = (char)0;
    tmp___5 ++;
  }
  tmp___6 = header_init((var )(__constr_expr_261), Tuple, 2);
  tmp___7 = memcpy((void * __restrict  )((struct Tuple *)tmp___6), (void const   * __restrict  )(& __constr_expr_259),
                   sizeof(struct Tuple ));
  exception_throw(IllegalInstructionError, "Illegal Instruction", (var )((struct Tuple *)tmp___7));
  case 2: 
  __constr_expr_263[0] = Terminal;
  __constr_expr_262.items = __constr_expr_263;
  __constr_expr_264[0] = (char)0;
  tmp___8 = 1U;
  while (! (tmp___8 >= 32U)) {
    __constr_expr_264[tmp___8] = (char)0;
    tmp___8 ++;
  }
  tmp___9 = header_init((var )(__constr_expr_264), Tuple, 2);
  tmp___10 = memcpy((void * __restrict  )((struct Tuple *)tmp___9), (void const   * __restrict  )(& __constr_expr_262),
                    sizeof(struct Tuple ));
  exception_throw(ProgramInterruptedError, "Program Interrupted", (var )((struct Tuple *)tmp___10));
  case 11: 
  __constr_expr_266[0] = Terminal;
  __constr_expr_265.items = __constr_expr_266;
  __constr_expr_267[0] = (char)0;
  tmp___11 = 1U;
  while (! (tmp___11 >= 32U)) {
    __constr_expr_267[tmp___11] = (char)0;
    tmp___11 ++;
  }
  tmp___12 = header_init((var )(__constr_expr_267), Tuple, 2);
  tmp___13 = memcpy((void * __restrict  )((struct Tuple *)tmp___12), (void const   * __restrict  )(& __constr_expr_265),
                    sizeof(struct Tuple ));
  exception_throw(SegmentationError, "Segmentation fault", (var )((struct Tuple *)tmp___13));
  case 15: 
  __constr_expr_269[0] = Terminal;
  __constr_expr_268.items = __constr_expr_269;
  __constr_expr_270[0] = (char)0;
  tmp___14 = 1U;
  while (! (tmp___14 >= 32U)) {
    __constr_expr_270[tmp___14] = (char)0;
    tmp___14 ++;
  }
  tmp___15 = header_init((var )(__constr_expr_270), Tuple, 2);
  tmp___16 = memcpy((void * __restrict  )((struct Tuple *)tmp___15), (void const   * __restrict  )(& __constr_expr_268),
                    sizeof(struct Tuple ));
  exception_throw(ProgramTerminationError, "Program Terminated", (var )((struct Tuple *)tmp___16));
  }
  return;
}
}
static jmp_buf *Exception_Buffer(struct Exception *e ) 
{ 


  {
  if (e->depth == 0UL) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Cello Fatal Error: Exception Buffer Out of Bounds!\n");
    abort();
  }
  return (e->buffers[e->depth - 1UL]);
}
}
static size_t Exception_Len(var self ) 
{ 
  struct Exception *e ;

  {
  e = (struct Exception *)self;
  return (e->depth);
}
}
static _Bool Exception_Running(var self ) 
{ 
  struct Exception *e ;

  {
  e = (struct Exception *)self;
  return (e->active);
}
}
static void Exception_Backtrace(void) 
{ 


  {
  return;
}
}
static void Exception_Error(struct Exception *e ) 
{ 
  struct Tuple __constr_expr_271 ;
  var __constr_expr_272[1] ;
  char __constr_expr_273[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  struct File __constr_expr_274 ;
  char __constr_expr_275[sizeof(struct Header ) + sizeof(struct File )] ;
  unsigned int tmp___2 ;
  var tmp___3 ;
  void *tmp___4 ;
  struct Tuple __constr_expr_276 ;
  var __constr_expr_277[1] ;
  char __constr_expr_278[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___5 ;
  var tmp___6 ;
  void *tmp___7 ;
  struct File __constr_expr_279 ;
  char __constr_expr_280[sizeof(struct Header ) + sizeof(struct File )] ;
  unsigned int tmp___8 ;
  var tmp___9 ;
  void *tmp___10 ;
  struct Tuple __constr_expr_281 ;
  var __constr_expr_282[2] ;
  char __constr_expr_283[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___11 ;
  var tmp___12 ;
  void *tmp___13 ;
  struct File __constr_expr_284 ;
  char __constr_expr_285[sizeof(struct Header ) + sizeof(struct File )] ;
  unsigned int tmp___14 ;
  var tmp___15 ;
  void *tmp___16 ;
  struct Tuple __constr_expr_286 ;
  var __constr_expr_287[1] ;
  char __constr_expr_288[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___17 ;
  var tmp___18 ;
  void *tmp___19 ;
  struct File __constr_expr_289 ;
  char __constr_expr_290[sizeof(struct Header ) + sizeof(struct File )] ;
  unsigned int tmp___20 ;
  var tmp___21 ;
  void *tmp___22 ;
  struct Tuple __constr_expr_291 ;
  var __constr_expr_292[2] ;
  char __constr_expr_293[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___23 ;
  var tmp___24 ;
  void *tmp___25 ;
  struct File __constr_expr_294 ;
  char __constr_expr_295[sizeof(struct Header ) + sizeof(struct File )] ;
  unsigned int tmp___26 ;
  var tmp___27 ;
  void *tmp___28 ;
  struct Tuple __constr_expr_296 ;
  var __constr_expr_297[1] ;
  char __constr_expr_298[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___29 ;
  var tmp___30 ;
  void *tmp___31 ;
  struct File __constr_expr_299 ;
  char __constr_expr_300[sizeof(struct Header ) + sizeof(struct File )] ;
  unsigned int tmp___32 ;
  var tmp___33 ;
  void *tmp___34 ;

  {
  __constr_expr_272[0] = Terminal;
  __constr_expr_271.items = __constr_expr_272;
  __constr_expr_273[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_273[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_273), Tuple, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_271),
                   sizeof(struct Tuple ));
  __constr_expr_274.file = stderr;
  __constr_expr_275[0] = (char)0;
  tmp___2 = 1U;
  while (! (tmp___2 >= 32U)) {
    __constr_expr_275[tmp___2] = (char)0;
    tmp___2 ++;
  }
  tmp___3 = header_init((var )(__constr_expr_275), File, 2);
  tmp___4 = memcpy((void * __restrict  )((struct File *)tmp___3), (void const   * __restrict  )(& __constr_expr_274),
                   sizeof(struct File ));
  print_to_with((var )((struct File *)tmp___4), 0, "\n", (var )((struct Tuple *)tmp___1));
  __constr_expr_277[0] = Terminal;
  __constr_expr_276.items = __constr_expr_277;
  __constr_expr_278[0] = (char)0;
  tmp___5 = 1U;
  while (! (tmp___5 >= 32U)) {
    __constr_expr_278[tmp___5] = (char)0;
    tmp___5 ++;
  }
  tmp___6 = header_init((var )(__constr_expr_278), Tuple, 2);
  tmp___7 = memcpy((void * __restrict  )((struct Tuple *)tmp___6), (void const   * __restrict  )(& __constr_expr_276),
                   sizeof(struct Tuple ));
  __constr_expr_279.file = stderr;
  __constr_expr_280[0] = (char)0;
  tmp___8 = 1U;
  while (! (tmp___8 >= 32U)) {
    __constr_expr_280[tmp___8] = (char)0;
    tmp___8 ++;
  }
  tmp___9 = header_init((var )(__constr_expr_280), File, 2);
  tmp___10 = memcpy((void * __restrict  )((struct File *)tmp___9), (void const   * __restrict  )(& __constr_expr_279),
                    sizeof(struct File ));
  print_to_with((var )((struct File *)tmp___10), 0, "!!\t\n", (var )((struct Tuple *)tmp___7));
  __constr_expr_282[0] = e->obj;
  __constr_expr_282[1] = Terminal;
  __constr_expr_281.items = __constr_expr_282;
  __constr_expr_283[0] = (char)0;
  tmp___11 = 1U;
  while (! (tmp___11 >= 32U)) {
    __constr_expr_283[tmp___11] = (char)0;
    tmp___11 ++;
  }
  tmp___12 = header_init((var )(__constr_expr_283), Tuple, 2);
  tmp___13 = memcpy((void * __restrict  )((struct Tuple *)tmp___12), (void const   * __restrict  )(& __constr_expr_281),
                    sizeof(struct Tuple ));
  __constr_expr_284.file = stderr;
  __constr_expr_285[0] = (char)0;
  tmp___14 = 1U;
  while (! (tmp___14 >= 32U)) {
    __constr_expr_285[tmp___14] = (char)0;
    tmp___14 ++;
  }
  tmp___15 = header_init((var )(__constr_expr_285), File, 2);
  tmp___16 = memcpy((void * __restrict  )((struct File *)tmp___15), (void const   * __restrict  )(& __constr_expr_284),
                    sizeof(struct File ));
  print_to_with((var )((struct File *)tmp___16), 0, "!!\tUncaught %$\n", (var )((struct Tuple *)tmp___13));
  __constr_expr_287[0] = Terminal;
  __constr_expr_286.items = __constr_expr_287;
  __constr_expr_288[0] = (char)0;
  tmp___17 = 1U;
  while (! (tmp___17 >= 32U)) {
    __constr_expr_288[tmp___17] = (char)0;
    tmp___17 ++;
  }
  tmp___18 = header_init((var )(__constr_expr_288), Tuple, 2);
  tmp___19 = memcpy((void * __restrict  )((struct Tuple *)tmp___18), (void const   * __restrict  )(& __constr_expr_286),
                    sizeof(struct Tuple ));
  __constr_expr_289.file = stderr;
  __constr_expr_290[0] = (char)0;
  tmp___20 = 1U;
  while (! (tmp___20 >= 32U)) {
    __constr_expr_290[tmp___20] = (char)0;
    tmp___20 ++;
  }
  tmp___21 = header_init((var )(__constr_expr_290), File, 2);
  tmp___22 = memcpy((void * __restrict  )((struct File *)tmp___21), (void const   * __restrict  )(& __constr_expr_289),
                    sizeof(struct File ));
  print_to_with((var )((struct File *)tmp___22), 0, "!!\t\n", (var )((struct Tuple *)tmp___19));
  __constr_expr_292[0] = e->msg;
  __constr_expr_292[1] = Terminal;
  __constr_expr_291.items = __constr_expr_292;
  __constr_expr_293[0] = (char)0;
  tmp___23 = 1U;
  while (! (tmp___23 >= 32U)) {
    __constr_expr_293[tmp___23] = (char)0;
    tmp___23 ++;
  }
  tmp___24 = header_init((var )(__constr_expr_293), Tuple, 2);
  tmp___25 = memcpy((void * __restrict  )((struct Tuple *)tmp___24), (void const   * __restrict  )(& __constr_expr_291),
                    sizeof(struct Tuple ));
  __constr_expr_294.file = stderr;
  __constr_expr_295[0] = (char)0;
  tmp___26 = 1U;
  while (! (tmp___26 >= 32U)) {
    __constr_expr_295[tmp___26] = (char)0;
    tmp___26 ++;
  }
  tmp___27 = header_init((var )(__constr_expr_295), File, 2);
  tmp___28 = memcpy((void * __restrict  )((struct File *)tmp___27), (void const   * __restrict  )(& __constr_expr_294),
                    sizeof(struct File ));
  print_to_with((var )((struct File *)tmp___28), 0, "!!\t\t %s\n", (var )((struct Tuple *)tmp___25));
  __constr_expr_297[0] = Terminal;
  __constr_expr_296.items = __constr_expr_297;
  __constr_expr_298[0] = (char)0;
  tmp___29 = 1U;
  while (! (tmp___29 >= 32U)) {
    __constr_expr_298[tmp___29] = (char)0;
    tmp___29 ++;
  }
  tmp___30 = header_init((var )(__constr_expr_298), Tuple, 2);
  tmp___31 = memcpy((void * __restrict  )((struct Tuple *)tmp___30), (void const   * __restrict  )(& __constr_expr_296),
                    sizeof(struct Tuple ));
  __constr_expr_299.file = stderr;
  __constr_expr_300[0] = (char)0;
  tmp___32 = 1U;
  while (! (tmp___32 >= 32U)) {
    __constr_expr_300[tmp___32] = (char)0;
    tmp___32 ++;
  }
  tmp___33 = header_init((var )(__constr_expr_300), File, 2);
  tmp___34 = memcpy((void * __restrict  )((struct File *)tmp___33), (void const   * __restrict  )(& __constr_expr_299),
                    sizeof(struct File ));
  print_to_with((var )((struct File *)tmp___34), 0, "!!\t\n", (var )((struct Tuple *)tmp___31));
  Exception_Backtrace();
  exit(1);
}
}
static int Exception_Show(var self , var out , int pos ) 
{ 
  struct Exception *e ;
  struct Tuple __constr_expr_301 ;
  var __constr_expr_302[4] ;
  char __constr_expr_303[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  e = (struct Exception *)self;
  __constr_expr_302[0] = self;
  __constr_expr_302[1] = e->obj;
  __constr_expr_302[2] = e->msg;
  __constr_expr_302[3] = Terminal;
  __constr_expr_301.items = __constr_expr_302;
  __constr_expr_303[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_303[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_303), Tuple, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_301),
                   sizeof(struct Tuple ));
  tmp___2 = print_to_with(out, pos, "<\'Exception\' At 0x%p %$ - %$>", (var )((struct Tuple *)tmp___1));
  return (tmp___2);
}
}
static struct Doc __constr_expr_305  =    {& Exception_Name, & Exception_Brief, & Exception_Description, (char const   *(*)(void))((void *)0),
    & Exception_Examples, & Exception_Methods};
static struct New __constr_expr_306  =    {& Exception_New, & Exception_Del};
static struct Assign __constr_expr_307  =    {& Exception_Assign};
static struct Len __constr_expr_308  =    {& Exception_Len};
static struct Current __constr_expr_309  =    {& Exception_Current};
static struct Start __constr_expr_310  =    {(void (*)(var  ))((void *)0), (void (*)(var  ))((void *)0), (void (*)(var  ))((void *)0),
    & Exception_Running};
static struct Show __constr_expr_311  =    {& Exception_Show, (int (*)(var  , var  , int  ))((void *)0)};
static var __constr_expr_304[51]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Exception", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Exception ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_305),      (void *)0,      (var )"New", 
        (var )(& __constr_expr_306),      (void *)0,      (var )"Assign",      (var )(& __constr_expr_307), 
        (void *)0,      (var )"Len",      (var )(& __constr_expr_308),      (void *)0, 
        (var )"Current",      (var )(& __constr_expr_309),      (void *)0,      (var )"Start", 
        (var )(& __constr_expr_310),      (void *)0,      (var )"Show",      (var )(& __constr_expr_311), 
        (void *)0,      (void *)0,      (void *)0};
var Exception  =    (var )((char *)(__constr_expr_304) + sizeof(struct Header ));
void exception_signals(void) 
{ 


  {
  signal(6, & Exception_Signal);
  signal(8, & Exception_Signal);
  signal(4, & Exception_Signal);
  signal(2, & Exception_Signal);
  signal(11, & Exception_Signal);
  signal(15, & Exception_Signal);
  return;
}
}
void exception_try(jmp_buf *env ) 
{ 
  struct Exception *e ;
  var tmp ;

  {
  tmp = current(Exception);
  e = (struct Exception *)tmp;
  if (e->depth == 2048UL) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Cello Fatal Error: Exception Buffer Overflow!\n");
    abort();
  }
  (e->depth) ++;
  e->active = (_Bool)0;
  e->buffers[e->depth - 1UL] = env;
  return;
}
}
var exception_throw(var obj , char const   *fmt , var args ) 
{ 
  struct Exception *e ;
  var tmp ;
  jmp_buf *tmp___0 ;
  size_t tmp___1 ;

  {
  tmp = current(Exception);
  e = (struct Exception *)tmp;
  e->obj = obj;
  print_to_with(e->msg, 0, fmt, args);
  tmp___1 = Exception_Len((var )e);
  if (tmp___1 >= 1UL) {
    tmp___0 = Exception_Buffer(e);
    longjmp((struct __jmp_buf_tag *)(*tmp___0), 1);
  } else {
    Exception_Error(e);
  }
  return ((void *)0);
}
}
var exception_catch(var args ) 
{ 
  struct Exception *e ;
  var tmp ;
  size_t tmp___0 ;
  var __arg ;
  var __Iterarg ;
  var tmp___1 ;
  var arg ;
  var tmp___2 ;
  _Bool tmp___3 ;
  jmp_buf *tmp___4 ;

  {
  tmp = current(Exception);
  e = (struct Exception *)tmp;
  if (! e->active) {
    return ((void *)0);
  }
  tmp___0 = len(args);
  if (tmp___0 == 0UL) {
    return (e->obj);
  }
  __arg = args;
  tmp___1 = instance(__arg, Iter);
  __Iterarg = tmp___1;
  tmp___2 = (*(((struct Iter *)__Iterarg)->iter_init))(__arg);
  arg = tmp___2;
  while ((unsigned long )arg != (unsigned long )Terminal) {
    tmp___3 = eq(arg, e->obj);
    if (tmp___3) {
      return (e->obj);
    }
    arg = (*(((struct Iter *)__Iterarg)->iter_next))(__arg, arg);
  }
  if (e->depth >= 1UL) {
    tmp___4 = Exception_Buffer(e);
    longjmp((struct __jmp_buf_tag *)(*tmp___4), 1);
  } else {
    Exception_Error(e);
  }
  return ((void *)0);
}
}
void exception_try_end(void) 
{ 
  struct Exception *e ;
  var tmp ;

  {
  tmp = current(Exception);
  e = (struct Exception *)tmp;
  if (e->depth == 0UL) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Cello Fatal Error: Exception Buffer Underflow!\n");
    abort();
  }
  (e->depth) --;
  return;
}
}
void exception_try_fail(void) 
{ 
  struct Exception *e ;
  var tmp ;

  {
  tmp = current(Exception);
  e = (struct Exception *)tmp;
  e->active = (_Bool)1;
  return;
}
}
#pragma merger("0","/tmp/cil-ACgZowR0.i","-std=gnu99,-Wall,-Wno-unused,-g,-ggdb,-fPIC")
extern FILE *stdout ;
var Doc ;
var Help ;
char const   *name(var type ) ;
char const   *brief(var type ) ;
char const   *description(var type ) ;
char const   *definition(var type ) ;
void help(var self ) ;
int help_to(var out , int pos , var self ) ;
var type_instance(var self , var cls ) ;
var type_method_at_offset(var self , var cls , size_t offset , char const   *method_name ) ;
char *c_str(var self ) ;
static char const   *Doc_Name(void) 
{ 


  {
  return ("Doc");
}
}
static char const   *Doc_Brief(void) 
{ 


  {
  return ("Provides Documentation");
}
}
static char const   *Doc_Description(void) 
{ 


  {
  return ("The `Doc` class can be used to give documentation to a certain class or type. This documentation can then be accessed using the `help` function or by other tools used to generate documentation such as for the Cello website. Documentation can be written in Markdown.\n\nThe `examples` and `methods` entries should be provided as `NULL` terminated arrays allocated statically.");
}
}
static char const   *Doc_Definition(void) 
{ 


  {
  return ("struct Example {\n  const char* name;\n  const char* body;\n};\n\nstruct Method {\n  const char* name;\n  const char* definition;\n  const char* description;\n};\n\nstruct Doc {\n  const char* (*name)(void);\n  const char* (*brief)(void);\n  const char* (*description)(void);\n  const char* (*definition)(void);\n  struct Example* (*examples)(void);\n  struct Method* (*methods)(void);\n};\n");
}
}
static struct Method *Doc_Methods(void) ;
static struct Method methods___12[5]  = {      {"name", "const char* name(var type);", "Return the name of a given `type`."}, 
        {"brief",
      "const char* brief(var type);", "Return a brief description of a given `type`."}, 
        {"description",
      "const char* description(var type);", "Return a longer description of a given `type`."}, 
        {"definition",
      "const char* definition(var type);", "Return the C definition of a given `type`."}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Doc_Methods(void) 
{ 


  {
  return (methods___12);
}
}
static struct Example *Doc_Examples(void) ;
static struct Example examples___13[2]  = {      {"Usage", "show($S(name(Int))); /* Int */\nshow($S(brief(Int))); /* Integer Object */\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Doc_Examples(void) 
{ 


  {
  return (examples___13);
}
}
static struct Doc __constr_expr_313  =    {& Doc_Name, & Doc_Brief, & Doc_Description, & Doc_Definition, & Doc_Examples,
    & Doc_Methods};
static var __constr_expr_312[33]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Doc", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Doc ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_313),      (void *)0,      (void *)0, 
        (void *)0};
var Doc  =    (var )((char *)(__constr_expr_312) + sizeof(struct Header ));
char const   *name(var type ) 
{ 
  struct Doc *doc ;
  var tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;

  {
  tmp = type_instance(type, Doc);
  doc = (struct Doc *)tmp;
  if (doc->name) {
    tmp___0 = (*(doc->name))();
    return (tmp___0);
  }
  tmp___1 = c_str(type);
  return ((char const   *)tmp___1);
}
}
char const   *brief(var type ) 
{ 
  var tmp ;
  char const   *tmp___0 ;

  {
  tmp = type_method_at_offset(type, Doc, (unsigned long )(& ((struct Doc *)0)->brief),
                              "brief");
  tmp___0 = (*(((struct Doc *)tmp)->brief))();
  return (tmp___0);
}
}
char const   *description(var type ) 
{ 
  var tmp ;
  char const   *tmp___0 ;

  {
  tmp = type_method_at_offset(type, Doc, (unsigned long )(& ((struct Doc *)0)->description),
                              "description");
  tmp___0 = (*(((struct Doc *)tmp)->description))();
  return (tmp___0);
}
}
char const   *definition(var type ) 
{ 
  var tmp ;
  char const   *tmp___0 ;

  {
  tmp = type_method_at_offset(type, Doc, (unsigned long )(& ((struct Doc *)0)->definition),
                              "definition");
  tmp___0 = (*(((struct Doc *)tmp)->definition))();
  return (tmp___0);
}
}
static char const   *Help_Name(void) 
{ 


  {
  return ("Help");
}
}
static char const   *Help_Brief(void) 
{ 


  {
  return ("Usage information");
}
}
static char const   *Help_Description(void) 
{ 


  {
  return ("The `Help` class can be implemented to let an object provide helpful information about itself. In the standard library this class is implemented by `Type` and it prints out the documentation provided by the `Doc` class in a friendly way.");
}
}
static char const   *Help_Definition(void) 
{ 


  {
  return ("struct Help {\n  int (*help_to)(var, int);\n};\n");
}
}
static struct Method *Help_Methods(void) ;
static struct Method methods___13[2]  = {      {"help", "void help(var self);\nint help_to(var out, int pos, var self);", "Print help information about the object `self` either to `stdout` or to the object `out` at some position `pos`."}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Help_Methods(void) 
{ 


  {
  return (methods___13);
}
}
static struct Example *Help_Examples(void) ;
static struct Example examples___14[2]  = {      {"Usage", "help(Int);\n"}, 
        {(char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Example *Help_Examples(void) 
{ 


  {
  return (examples___14);
}
}
static struct Doc __constr_expr_315  =    {& Help_Name, & Help_Brief, & Help_Description, & Help_Definition, & Help_Examples,
    & Help_Methods};
static var __constr_expr_314[33]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Help", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Help ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_315),      (void *)0,      (void *)0, 
        (void *)0};
var Help  =    (var )((char *)(__constr_expr_314) + sizeof(struct Header ));
int help_to(var out , int pos , var self ) 
{ 
  var tmp ;
  int tmp___0 ;

  {
  tmp = method_at_offset(self, Help, (unsigned long )(& ((struct Help *)0)->help_to),
                         "help_to");
  tmp___0 = (*(((struct Help *)tmp)->help_to))(self, out, pos);
  return (tmp___0);
}
}
void help(var self ) 
{ 
  struct File __constr_expr_316 ;
  char __constr_expr_317[sizeof(struct Header ) + sizeof(struct File )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;

  {
  __constr_expr_316.file = stdout;
  __constr_expr_317[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_317[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_317), File, 2);
  tmp___1 = memcpy((void * __restrict  )((struct File *)tmp___0), (void const   * __restrict  )(& __constr_expr_316),
                   sizeof(struct File ));
  help_to((var )((struct File *)tmp___1), 0, self);
  return;
}
}
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#pragma merger("0","/tmp/cil-Ml8SCv_4.i","-std=gnu99,-Wall,-Wno-unused,-g,-ggdb,-fPIC")
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsscanf)(char const   * __restrict  __s ,
                                                                            char const   * __restrict  __format ,
                                                                            __gnuc_va_list __arg )  __asm__("__isoc99_vsscanf")  ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
var C_Str ;
struct Header *header(var self ) ;
int scan_from_with(var input , int pos , char const   *fmt , var args ) ;
static char const   *C_Str_Name(void) 
{ 


  {
  return ("C_Str");
}
}
static char const   *C_Str_Brief(void) 
{ 


  {
  return ("Interpret as C String");
}
}
static char const   *C_Str_Description(void) 
{ 


  {
  return ("The `C_Str` class should be overridden by types which are representable as a C style String.");
}
}
static char const   *C_Str_Definition(void) 
{ 


  {
  return ("struct C_Str {\n  char* (*c_str)(var);\n};\n");
}
}
static struct Example *C_Str_Examples(void) ;
static struct Example examples___15[2]  = {      {"Usage", "puts(c_str($S(\"Hello\"))); /* Hello */\nputs(c_str($S(\"There\"))); /* There */\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *C_Str_Examples(void) 
{ 


  {
  return (examples___15);
}
}
static struct Method *C_Str_Methods(void) ;
static struct Method methods___14[2]  = {      {"c_str", "char* c_str(var self);", "Returns the object `self` represented as a `char*`."}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *C_Str_Methods(void) 
{ 


  {
  return (methods___14);
}
}
static struct Doc __constr_expr_319  =    {& C_Str_Name, & C_Str_Brief, & C_Str_Description, & C_Str_Definition, & C_Str_Examples,
    & C_Str_Methods};
static var __constr_expr_318[33]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"C_Str", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct C_Str ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_319),      (void *)0,      (void *)0, 
        (void *)0};
var C_Str  =    (var )((char *)(__constr_expr_318) + sizeof(struct Header ));
char *c_str(var self ) 
{ 
  var tmp ;
  var tmp___0 ;
  char *tmp___1 ;

  {
  tmp = type_of(self);
  if ((unsigned long )tmp == (unsigned long )String) {
    return (((struct String *)self)->val);
  }
  tmp___0 = method_at_offset(self, C_Str, (unsigned long )(& ((struct C_Str *)0)->c_str),
                             "c_str");
  tmp___1 = (*(((struct C_Str *)tmp___0)->c_str))(self);
  return (tmp___1);
}
}
static char const   *String_Name(void) 
{ 


  {
  return ("String");
}
}
static char const   *String_Brief(void) 
{ 


  {
  return ("String Object");
}
}
static char const   *String_Description(void) 
{ 


  {
  return ("The `String` type is a wrapper around the native C string type. This includes strings that are allocated on either the Stack or the Heap.\n\nFor strings allocated on the heap a number of extra operations are provided overs standard C strings such as concatenation.");
}
}
static char const   *String_Definition(void) 
{ 


  {
  return ("struct String {\n  char* val;\n};\n");
}
}
static struct Example *String_Examples(void) ;
static struct Example examples___16[3]  = {      {"Usage", "var s0 = $(String, \"Hello\");\nvar s1 = new(String, $S(\"Hello\"));\nappend(s1, $S(\" There\"));\nshow(s0); /* Hello */\nshow(s1); /* Hello There */\n"}, 
        {"Manipulation",
      "var s0 = new(String, $S(\"Balloons\"));\n\nshow($I(len(s0))); /* 8 */\nshow($I(mem(s0, $S(\"Ball\"))));     /* 1 */\nshow($I(mem(s0, $S(\"oon\"))));      /* 1 */\nshow($I(mem(s0, $S(\"Balloons\")))); /* 1 */\nshow($I(mem(s0, $S(\"l\"))));        /* 1 */\n\nrem(s0, $S(\"oons\"));\n\nshow($I(eq(s0, $S(\"Ball\")))); /* 1 */\n\nresize(s0, 0);\n\nshow($I(len(s0))); /* 0 */\nshow($I(eq(s0, $S(\"\")))); /* 1 */\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *String_Examples(void) 
{ 


  {
  return (examples___16);
}
}
static void String_Assign(var self , var obj ) ;
static void String_New(var self , var args ) 
{ 
  struct String *s ;
  struct Int __constr_expr_320 ;
  char __constr_expr_321[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  var tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  struct Tuple __constr_expr_322 ;
  var __constr_expr_323[1] ;
  char __constr_expr_324[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___5 ;
  var tmp___6 ;
  void *tmp___7 ;

  {
  s = (struct String *)self;
  tmp___4 = len(args);
  if (tmp___4 > 0UL) {
    __constr_expr_320.val = (int64_t )0;
    __constr_expr_321[0] = (char)0;
    tmp = 1U;
    while (! (tmp >= 32U)) {
      __constr_expr_321[tmp] = (char)0;
      tmp ++;
    }
    tmp___0 = header_init((var )(__constr_expr_321), Int, 2);
    tmp___1 = memcpy((void * __restrict  )((struct Int *)tmp___0), (void const   * __restrict  )(& __constr_expr_320),
                     sizeof(struct Int ));
    tmp___2 = get(args, (var )((struct Int *)tmp___1));
    String_Assign(self, tmp___2);
  } else {
    tmp___3 = calloc((size_t )1, (size_t )1);
    s->val = (char *)tmp___3;
  }
  if ((unsigned long )s->val == (unsigned long )((void *)0)) {
    __constr_expr_323[0] = Terminal;
    __constr_expr_322.items = __constr_expr_323;
    __constr_expr_324[0] = (char)0;
    tmp___5 = 1U;
    while (! (tmp___5 >= 32U)) {
      __constr_expr_324[tmp___5] = (char)0;
      tmp___5 ++;
    }
    tmp___6 = header_init((var )(__constr_expr_324), Tuple, 2);
    tmp___7 = memcpy((void * __restrict  )((struct Tuple *)tmp___6), (void const   * __restrict  )(& __constr_expr_322),
                     sizeof(struct Tuple ));
    exception_throw(OutOfMemoryError, "Cannot allocate String, out of memory!", (var )((struct Tuple *)tmp___7));
  }
  return;
}
}
static void String_Del(var self ) 
{ 
  struct String *s ;
  struct Tuple __constr_expr_325 ;
  var __constr_expr_326[1] ;
  char __constr_expr_327[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  struct Header *tmp___2 ;
  struct Header *tmp___3 ;

  {
  s = (struct String *)self;
  tmp___2 = header(self);
  if ((unsigned long )tmp___2->alloc == (unsigned long )((var )2)) {
    goto _L;
  } else {
    tmp___3 = header(self);
    if ((unsigned long )tmp___3->alloc == (unsigned long )((var )1)) {
      _L: /* CIL Label */ 
      __constr_expr_326[0] = Terminal;
      __constr_expr_325.items = __constr_expr_326;
      __constr_expr_327[0] = (char)0;
      tmp = 1U;
      while (! (tmp >= 32U)) {
        __constr_expr_327[tmp] = (char)0;
        tmp ++;
      }
      tmp___0 = header_init((var )(__constr_expr_327), Tuple, 2);
      tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_325),
                       sizeof(struct Tuple ));
      exception_throw(ValueError, "Cannot destruct String, not on heap!", (var )((struct Tuple *)tmp___1));
    }
  }
  free((void *)s->val);
  return;
}
}
static void String_Assign(var self , var obj ) 
{ 
  struct String *s ;
  char *val ;
  char *tmp ;
  struct Tuple __constr_expr_328 ;
  var __constr_expr_329[1] ;
  char __constr_expr_330[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;
  struct Header *tmp___3 ;
  struct Header *tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  struct Tuple __constr_expr_331 ;
  var __constr_expr_332[1] ;
  char __constr_expr_333[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___7 ;
  var tmp___8 ;
  void *tmp___9 ;

  {
  s = (struct String *)self;
  tmp = c_str(obj);
  val = tmp;
  tmp___3 = header(self);
  if ((unsigned long )tmp___3->alloc == (unsigned long )((var )2)) {
    goto _L;
  } else {
    tmp___4 = header(self);
    if ((unsigned long )tmp___4->alloc == (unsigned long )((var )1)) {
      _L: /* CIL Label */ 
      __constr_expr_329[0] = Terminal;
      __constr_expr_328.items = __constr_expr_329;
      __constr_expr_330[0] = (char)0;
      tmp___0 = 1U;
      while (! (tmp___0 >= 32U)) {
        __constr_expr_330[tmp___0] = (char)0;
        tmp___0 ++;
      }
      tmp___1 = header_init((var )(__constr_expr_330), Tuple, 2);
      tmp___2 = memcpy((void * __restrict  )((struct Tuple *)tmp___1), (void const   * __restrict  )(& __constr_expr_328),
                       sizeof(struct Tuple ));
      exception_throw(ValueError, "Cannot reallocate String, not on heap!", (var )((struct Tuple *)tmp___2));
    }
  }
  tmp___5 = strlen((char const   *)val);
  tmp___6 = realloc((void *)s->val, tmp___5 + 1UL);
  s->val = (char *)tmp___6;
  if ((unsigned long )s->val == (unsigned long )((void *)0)) {
    __constr_expr_332[0] = Terminal;
    __constr_expr_331.items = __constr_expr_332;
    __constr_expr_333[0] = (char)0;
    tmp___7 = 1U;
    while (! (tmp___7 >= 32U)) {
      __constr_expr_333[tmp___7] = (char)0;
      tmp___7 ++;
    }
    tmp___8 = header_init((var )(__constr_expr_333), Tuple, 2);
    tmp___9 = memcpy((void * __restrict  )((struct Tuple *)tmp___8), (void const   * __restrict  )(& __constr_expr_331),
                     sizeof(struct Tuple ));
    exception_throw(OutOfMemoryError, "Cannot allocate String, out of memory!", (var )((struct Tuple *)tmp___9));
  }
  strcpy((char * __restrict  )s->val, (char const   * __restrict  )val);
  return;
}
}
static char *String_C_Str(var self ) 
{ 
  struct String *s ;

  {
  s = (struct String *)self;
  return (s->val);
}
}
static int String_Cmp(var self , var obj ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  tmp = c_str(obj);
  tmp___0 = String_C_Str(self);
  tmp___1 = strcmp((char const   *)tmp___0, (char const   *)tmp);
  return (tmp___1);
}
}
static size_t String_Len(var self ) 
{ 
  struct String *s ;
  size_t tmp ;

  {
  s = (struct String *)self;
  tmp = strlen((char const   *)s->val);
  return (tmp);
}
}
static void String_Clear(var self ) 
{ 
  struct String *s ;
  struct Tuple __constr_expr_334 ;
  var __constr_expr_335[1] ;
  char __constr_expr_336[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  struct Header *tmp___2 ;
  struct Header *tmp___3 ;
  void *tmp___4 ;
  struct Tuple __constr_expr_337 ;
  var __constr_expr_338[1] ;
  char __constr_expr_339[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___5 ;
  var tmp___6 ;
  void *tmp___7 ;

  {
  s = (struct String *)self;
  tmp___2 = header(self);
  if ((unsigned long )tmp___2->alloc == (unsigned long )((var )2)) {
    goto _L;
  } else {
    tmp___3 = header(self);
    if ((unsigned long )tmp___3->alloc == (unsigned long )((var )1)) {
      _L: /* CIL Label */ 
      __constr_expr_335[0] = Terminal;
      __constr_expr_334.items = __constr_expr_335;
      __constr_expr_336[0] = (char)0;
      tmp = 1U;
      while (! (tmp >= 32U)) {
        __constr_expr_336[tmp] = (char)0;
        tmp ++;
      }
      tmp___0 = header_init((var )(__constr_expr_336), Tuple, 2);
      tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_334),
                       sizeof(struct Tuple ));
      exception_throw(ValueError, "Cannot reallocate String, not on heap!", (var )((struct Tuple *)tmp___1));
    }
  }
  tmp___4 = realloc((void *)s->val, (size_t )1);
  s->val = (char *)tmp___4;
  if ((unsigned long )s->val == (unsigned long )((void *)0)) {
    __constr_expr_338[0] = Terminal;
    __constr_expr_337.items = __constr_expr_338;
    __constr_expr_339[0] = (char)0;
    tmp___5 = 1U;
    while (! (tmp___5 >= 32U)) {
      __constr_expr_339[tmp___5] = (char)0;
      tmp___5 ++;
    }
    tmp___6 = header_init((var )(__constr_expr_339), Tuple, 2);
    tmp___7 = memcpy((void * __restrict  )((struct Tuple *)tmp___6), (void const   * __restrict  )(& __constr_expr_337),
                     sizeof(struct Tuple ));
    exception_throw(OutOfMemoryError, "Cannot allocate String, out of memory!", (var )((struct Tuple *)tmp___7));
  }
  *(s->val + 0) = (char )'\000';
  return;
}
}
static _Bool String_Mem(var self , var obj ) 
{ 
  struct C_Str *c ;
  var tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  tmp = instance(obj, C_Str);
  c = (struct C_Str *)tmp;
  if (c) {
    if (c->c_str) {
      tmp___0 = (*(c->c_str))(obj);
      tmp___1 = String_C_Str(self);
      tmp___2 = strstr((char const   *)tmp___1, (char const   *)tmp___0);
      return ((_Bool )tmp___2);
    }
  }
  return ((_Bool)0);
}
}
static void String_Rem(var self , var obj ) 
{ 
  struct C_Str *c ;
  var tmp ;
  char *pos ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t count ;
  char *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;

  {
  tmp = instance(obj, C_Str);
  c = (struct C_Str *)tmp;
  if (c) {
    if (c->c_str) {
      tmp___0 = (*(c->c_str))(obj);
      tmp___1 = String_C_Str(self);
      tmp___2 = strstr((char const   *)tmp___1, (char const   *)tmp___0);
      pos = tmp___2;
      tmp___3 = String_C_Str(self);
      tmp___4 = strlen((char const   *)tmp___3);
      tmp___5 = strlen((char const   *)pos);
      tmp___6 = (*(c->c_str))(obj);
      tmp___7 = strlen((char const   *)tmp___6);
      count = ((tmp___4 - tmp___5) - tmp___7) + 1UL;
      tmp___8 = (*(c->c_str))(obj);
      tmp___9 = strlen((char const   *)tmp___8);
      memmove((void *)pos, (void const   *)(pos + tmp___9), count);
    }
  }
  return;
}
}
static uint64_t String_Hash(var self ) 
{ 
  struct String *s ;
  size_t tmp ;
  uint64_t tmp___0 ;

  {
  s = (struct String *)self;
  tmp = strlen((char const   *)s->val);
  tmp___0 = hash_data((void const   *)s->val, tmp);
  return (tmp___0);
}
}
static void String_Concat(var self , var obj ) 
{ 
  struct String *s ;
  struct Tuple __constr_expr_340 ;
  var __constr_expr_341[1] ;
  char __constr_expr_342[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  struct Header *tmp___2 ;
  struct Header *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  struct Tuple __constr_expr_343 ;
  var __constr_expr_344[1] ;
  char __constr_expr_345[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___8 ;
  var tmp___9 ;
  void *tmp___10 ;
  char *tmp___11 ;

  {
  s = (struct String *)self;
  tmp___2 = header(self);
  if ((unsigned long )tmp___2->alloc == (unsigned long )((var )2)) {
    goto _L;
  } else {
    tmp___3 = header(self);
    if ((unsigned long )tmp___3->alloc == (unsigned long )((var )1)) {
      _L: /* CIL Label */ 
      __constr_expr_341[0] = Terminal;
      __constr_expr_340.items = __constr_expr_341;
      __constr_expr_342[0] = (char)0;
      tmp = 1U;
      while (! (tmp >= 32U)) {
        __constr_expr_342[tmp] = (char)0;
        tmp ++;
      }
      tmp___0 = header_init((var )(__constr_expr_342), Tuple, 2);
      tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_340),
                       sizeof(struct Tuple ));
      exception_throw(ValueError, "Cannot reallocate String, not on heap!", (var )((struct Tuple *)tmp___1));
    }
  }
  tmp___4 = strlen((char const   *)s->val);
  tmp___5 = c_str(obj);
  tmp___6 = strlen((char const   *)tmp___5);
  tmp___7 = realloc((void *)s->val, (tmp___4 + tmp___6) + 1UL);
  s->val = (char *)tmp___7;
  if ((unsigned long )s->val == (unsigned long )((void *)0)) {
    __constr_expr_344[0] = Terminal;
    __constr_expr_343.items = __constr_expr_344;
    __constr_expr_345[0] = (char)0;
    tmp___8 = 1U;
    while (! (tmp___8 >= 32U)) {
      __constr_expr_345[tmp___8] = (char)0;
      tmp___8 ++;
    }
    tmp___9 = header_init((var )(__constr_expr_345), Tuple, 2);
    tmp___10 = memcpy((void * __restrict  )((struct Tuple *)tmp___9), (void const   * __restrict  )(& __constr_expr_343),
                      sizeof(struct Tuple ));
    exception_throw(OutOfMemoryError, "Cannot allocate String, out of memory!", (var )((struct Tuple *)tmp___10));
  }
  tmp___11 = c_str(obj);
  strcat((char * __restrict  )s->val, (char const   * __restrict  )tmp___11);
  return;
}
}
static void String_Resize(var self , size_t n ) 
{ 
  struct String *s ;
  struct Tuple __constr_expr_346 ;
  var __constr_expr_347[1] ;
  char __constr_expr_348[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  struct Header *tmp___2 ;
  struct Header *tmp___3 ;
  size_t m ;
  size_t tmp___4 ;
  void *tmp___5 ;
  struct Tuple __constr_expr_349 ;
  var __constr_expr_350[1] ;
  char __constr_expr_351[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___6 ;
  var tmp___7 ;
  void *tmp___8 ;

  {
  s = (struct String *)self;
  tmp___2 = header(self);
  if ((unsigned long )tmp___2->alloc == (unsigned long )((var )2)) {
    goto _L;
  } else {
    tmp___3 = header(self);
    if ((unsigned long )tmp___3->alloc == (unsigned long )((var )1)) {
      _L: /* CIL Label */ 
      __constr_expr_347[0] = Terminal;
      __constr_expr_346.items = __constr_expr_347;
      __constr_expr_348[0] = (char)0;
      tmp = 1U;
      while (! (tmp >= 32U)) {
        __constr_expr_348[tmp] = (char)0;
        tmp ++;
      }
      tmp___0 = header_init((var )(__constr_expr_348), Tuple, 2);
      tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_346),
                       sizeof(struct Tuple ));
      exception_throw(ValueError, "Cannot reallocate String, not on heap!", (var )((struct Tuple *)tmp___1));
    }
  }
  tmp___4 = String_Len(self);
  m = tmp___4;
  tmp___5 = realloc((void *)s->val, n + 1UL);
  s->val = (char *)tmp___5;
  if (n > m) {
    memset((void *)(s->val + m), 0, n - m);
  } else {
    *(s->val + n) = (char )'\000';
  }
  if ((unsigned long )s->val == (unsigned long )((void *)0)) {
    __constr_expr_350[0] = Terminal;
    __constr_expr_349.items = __constr_expr_350;
    __constr_expr_351[0] = (char)0;
    tmp___6 = 1U;
    while (! (tmp___6 >= 32U)) {
      __constr_expr_351[tmp___6] = (char)0;
      tmp___6 ++;
    }
    tmp___7 = header_init((var )(__constr_expr_351), Tuple, 2);
    tmp___8 = memcpy((void * __restrict  )((struct Tuple *)tmp___7), (void const   * __restrict  )(& __constr_expr_349),
                     sizeof(struct Tuple ));
    exception_throw(OutOfMemoryError, "Cannot allocate String, out of memory!", (var )((struct Tuple *)tmp___8));
  }
  return;
}
}
static int String_Format_To(var self , int pos , char const   *fmt , va_list___0 va ) 
{ 
  struct String *s ;
  va_list___0 va_tmp ;
  int size___0 ;
  int tmp ;
  struct Tuple __constr_expr_352 ;
  var __constr_expr_353[1] ;
  char __constr_expr_354[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;
  struct Header *tmp___3 ;
  struct Header *tmp___4 ;
  void *tmp___5 ;
  struct Tuple __constr_expr_355 ;
  var __constr_expr_356[1] ;
  char __constr_expr_357[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___6 ;
  var tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;

  {
  s = (struct String *)self;
  __builtin_va_copy(va_tmp, va);
  tmp = vsnprintf((char * __restrict  )((void *)0), (size_t )0, (char const   * __restrict  )fmt,
                  va_tmp);
  size___0 = tmp;
  __builtin_va_end(va_tmp);
  tmp___3 = header(self);
  if ((unsigned long )tmp___3->alloc == (unsigned long )((var )2)) {
    goto _L;
  } else {
    tmp___4 = header(self);
    if ((unsigned long )tmp___4->alloc == (unsigned long )((var )1)) {
      _L: /* CIL Label */ 
      __constr_expr_353[0] = Terminal;
      __constr_expr_352.items = __constr_expr_353;
      __constr_expr_354[0] = (char)0;
      tmp___0 = 1U;
      while (! (tmp___0 >= 32U)) {
        __constr_expr_354[tmp___0] = (char)0;
        tmp___0 ++;
      }
      tmp___1 = header_init((var )(__constr_expr_354), Tuple, 2);
      tmp___2 = memcpy((void * __restrict  )((struct Tuple *)tmp___1), (void const   * __restrict  )(& __constr_expr_352),
                       sizeof(struct Tuple ));
      exception_throw(ValueError, "Cannot reallocate String, not on heap!", (var )((struct Tuple *)tmp___2));
    }
  }
  tmp___5 = realloc((void *)s->val, (size_t )((pos + size___0) + 1));
  s->val = (char *)tmp___5;
  if ((unsigned long )s->val == (unsigned long )((void *)0)) {
    __constr_expr_356[0] = Terminal;
    __constr_expr_355.items = __constr_expr_356;
    __constr_expr_357[0] = (char)0;
    tmp___6 = 1U;
    while (! (tmp___6 >= 32U)) {
      __constr_expr_357[tmp___6] = (char)0;
      tmp___6 ++;
    }
    tmp___7 = header_init((var )(__constr_expr_357), Tuple, 2);
    tmp___8 = memcpy((void * __restrict  )((struct Tuple *)tmp___7), (void const   * __restrict  )(& __constr_expr_355),
                     sizeof(struct Tuple ));
    exception_throw(OutOfMemoryError, "Cannot allocate String, out of memory!", (var )((struct Tuple *)tmp___8));
  }
  tmp___9 = vsprintf((char * __restrict  )(s->val + pos), (char const   * __restrict  )fmt,
                     va);
  return (tmp___9);
}
}
static int String_Format_From(var self , int pos , char const   *fmt , va_list___0 va ) 
{ 
  struct String *s ;
  int tmp ;

  {
  s = (struct String *)self;
  tmp = vsscanf((char const   * __restrict  )(s->val + pos), (char const   * __restrict  )fmt,
                va);
  return (tmp);
}
}
static int String_Show(var self , var out , int pos ) 
{ 
  struct String *s ;
  struct Tuple __constr_expr_358 ;
  var __constr_expr_359[2] ;
  char __constr_expr_360[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  char *v ;
  struct Tuple __constr_expr_361 ;
  var __constr_expr_362[1] ;
  char __constr_expr_363[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___2 ;
  var tmp___3 ;
  void *tmp___4 ;
  struct Tuple __constr_expr_364 ;
  var __constr_expr_365[1] ;
  char __constr_expr_366[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___5 ;
  var tmp___6 ;
  void *tmp___7 ;
  struct Tuple __constr_expr_367 ;
  var __constr_expr_368[1] ;
  char __constr_expr_369[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___8 ;
  var tmp___9 ;
  void *tmp___10 ;
  struct Tuple __constr_expr_370 ;
  var __constr_expr_371[1] ;
  char __constr_expr_372[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___11 ;
  var tmp___12 ;
  void *tmp___13 ;
  struct Tuple __constr_expr_373 ;
  var __constr_expr_374[1] ;
  char __constr_expr_375[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___14 ;
  var tmp___15 ;
  void *tmp___16 ;
  struct Tuple __constr_expr_376 ;
  var __constr_expr_377[1] ;
  char __constr_expr_378[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___17 ;
  var tmp___18 ;
  void *tmp___19 ;
  struct Tuple __constr_expr_379 ;
  var __constr_expr_380[1] ;
  char __constr_expr_381[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___20 ;
  var tmp___21 ;
  void *tmp___22 ;
  struct Tuple __constr_expr_382 ;
  var __constr_expr_383[1] ;
  char __constr_expr_384[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___23 ;
  var tmp___24 ;
  void *tmp___25 ;
  struct Tuple __constr_expr_385 ;
  var __constr_expr_386[1] ;
  char __constr_expr_387[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___26 ;
  var tmp___27 ;
  void *tmp___28 ;
  struct Tuple __constr_expr_388 ;
  var __constr_expr_389[1] ;
  char __constr_expr_390[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___29 ;
  var tmp___30 ;
  void *tmp___31 ;
  struct Tuple __constr_expr_391 ;
  var __constr_expr_392[1] ;
  char __constr_expr_393[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___32 ;
  var tmp___33 ;
  void *tmp___34 ;
  struct Tuple __constr_expr_394 ;
  var __constr_expr_395[2] ;
  struct Int __constr_expr_396 ;
  char __constr_expr_397[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___35 ;
  var tmp___36 ;
  void *tmp___37 ;
  char __constr_expr_398[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___38 ;
  var tmp___39 ;
  void *tmp___40 ;
  struct Tuple __constr_expr_399 ;
  var __constr_expr_400[2] ;
  char __constr_expr_401[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___41 ;
  var tmp___42 ;
  void *tmp___43 ;
  int tmp___44 ;

  {
  s = (struct String *)self;
  __constr_expr_359[0] = self;
  __constr_expr_359[1] = Terminal;
  __constr_expr_358.items = __constr_expr_359;
  __constr_expr_360[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_360[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_360), Tuple, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_358),
                   sizeof(struct Tuple ));
  pos = print_to_with(out, pos, "\"", (var )((struct Tuple *)tmp___1));
  v = s->val;
  while (*v) {
    switch ((int )*v) {
    case 7: 
    __constr_expr_362[0] = Terminal;
    __constr_expr_361.items = __constr_expr_362;
    __constr_expr_363[0] = (char)0;
    tmp___2 = 1U;
    while (! (tmp___2 >= 32U)) {
      __constr_expr_363[tmp___2] = (char)0;
      tmp___2 ++;
    }
    tmp___3 = header_init((var )(__constr_expr_363), Tuple, 2);
    tmp___4 = memcpy((void * __restrict  )((struct Tuple *)tmp___3), (void const   * __restrict  )(& __constr_expr_361),
                     sizeof(struct Tuple ));
    pos = print_to_with(out, pos, "\\a", (var )((struct Tuple *)tmp___4));
    break;
    case 8: 
    __constr_expr_365[0] = Terminal;
    __constr_expr_364.items = __constr_expr_365;
    __constr_expr_366[0] = (char)0;
    tmp___5 = 1U;
    while (! (tmp___5 >= 32U)) {
      __constr_expr_366[tmp___5] = (char)0;
      tmp___5 ++;
    }
    tmp___6 = header_init((var )(__constr_expr_366), Tuple, 2);
    tmp___7 = memcpy((void * __restrict  )((struct Tuple *)tmp___6), (void const   * __restrict  )(& __constr_expr_364),
                     sizeof(struct Tuple ));
    pos = print_to_with(out, pos, "\\b", (var )((struct Tuple *)tmp___7));
    break;
    case 12: 
    __constr_expr_368[0] = Terminal;
    __constr_expr_367.items = __constr_expr_368;
    __constr_expr_369[0] = (char)0;
    tmp___8 = 1U;
    while (! (tmp___8 >= 32U)) {
      __constr_expr_369[tmp___8] = (char)0;
      tmp___8 ++;
    }
    tmp___9 = header_init((var )(__constr_expr_369), Tuple, 2);
    tmp___10 = memcpy((void * __restrict  )((struct Tuple *)tmp___9), (void const   * __restrict  )(& __constr_expr_367),
                      sizeof(struct Tuple ));
    pos = print_to_with(out, pos, "\\f", (var )((struct Tuple *)tmp___10));
    break;
    case 10: 
    __constr_expr_371[0] = Terminal;
    __constr_expr_370.items = __constr_expr_371;
    __constr_expr_372[0] = (char)0;
    tmp___11 = 1U;
    while (! (tmp___11 >= 32U)) {
      __constr_expr_372[tmp___11] = (char)0;
      tmp___11 ++;
    }
    tmp___12 = header_init((var )(__constr_expr_372), Tuple, 2);
    tmp___13 = memcpy((void * __restrict  )((struct Tuple *)tmp___12), (void const   * __restrict  )(& __constr_expr_370),
                      sizeof(struct Tuple ));
    pos = print_to_with(out, pos, "\\n", (var )((struct Tuple *)tmp___13));
    break;
    case 13: 
    __constr_expr_374[0] = Terminal;
    __constr_expr_373.items = __constr_expr_374;
    __constr_expr_375[0] = (char)0;
    tmp___14 = 1U;
    while (! (tmp___14 >= 32U)) {
      __constr_expr_375[tmp___14] = (char)0;
      tmp___14 ++;
    }
    tmp___15 = header_init((var )(__constr_expr_375), Tuple, 2);
    tmp___16 = memcpy((void * __restrict  )((struct Tuple *)tmp___15), (void const   * __restrict  )(& __constr_expr_373),
                      sizeof(struct Tuple ));
    pos = print_to_with(out, pos, "\\r", (var )((struct Tuple *)tmp___16));
    break;
    case 9: 
    __constr_expr_377[0] = Terminal;
    __constr_expr_376.items = __constr_expr_377;
    __constr_expr_378[0] = (char)0;
    tmp___17 = 1U;
    while (! (tmp___17 >= 32U)) {
      __constr_expr_378[tmp___17] = (char)0;
      tmp___17 ++;
    }
    tmp___18 = header_init((var )(__constr_expr_378), Tuple, 2);
    tmp___19 = memcpy((void * __restrict  )((struct Tuple *)tmp___18), (void const   * __restrict  )(& __constr_expr_376),
                      sizeof(struct Tuple ));
    pos = print_to_with(out, pos, "\\t", (var )((struct Tuple *)tmp___19));
    break;
    case 11: 
    __constr_expr_380[0] = Terminal;
    __constr_expr_379.items = __constr_expr_380;
    __constr_expr_381[0] = (char)0;
    tmp___20 = 1U;
    while (! (tmp___20 >= 32U)) {
      __constr_expr_381[tmp___20] = (char)0;
      tmp___20 ++;
    }
    tmp___21 = header_init((var )(__constr_expr_381), Tuple, 2);
    tmp___22 = memcpy((void * __restrict  )((struct Tuple *)tmp___21), (void const   * __restrict  )(& __constr_expr_379),
                      sizeof(struct Tuple ));
    pos = print_to_with(out, pos, "\\v", (var )((struct Tuple *)tmp___22));
    break;
    case 92: 
    __constr_expr_383[0] = Terminal;
    __constr_expr_382.items = __constr_expr_383;
    __constr_expr_384[0] = (char)0;
    tmp___23 = 1U;
    while (! (tmp___23 >= 32U)) {
      __constr_expr_384[tmp___23] = (char)0;
      tmp___23 ++;
    }
    tmp___24 = header_init((var )(__constr_expr_384), Tuple, 2);
    tmp___25 = memcpy((void * __restrict  )((struct Tuple *)tmp___24), (void const   * __restrict  )(& __constr_expr_382),
                      sizeof(struct Tuple ));
    pos = print_to_with(out, pos, "\\\\", (var )((struct Tuple *)tmp___25));
    break;
    case 39: 
    __constr_expr_386[0] = Terminal;
    __constr_expr_385.items = __constr_expr_386;
    __constr_expr_387[0] = (char)0;
    tmp___26 = 1U;
    while (! (tmp___26 >= 32U)) {
      __constr_expr_387[tmp___26] = (char)0;
      tmp___26 ++;
    }
    tmp___27 = header_init((var )(__constr_expr_387), Tuple, 2);
    tmp___28 = memcpy((void * __restrict  )((struct Tuple *)tmp___27), (void const   * __restrict  )(& __constr_expr_385),
                      sizeof(struct Tuple ));
    pos = print_to_with(out, pos, "\\\'", (var )((struct Tuple *)tmp___28));
    break;
    case 34: 
    __constr_expr_389[0] = Terminal;
    __constr_expr_388.items = __constr_expr_389;
    __constr_expr_390[0] = (char)0;
    tmp___29 = 1U;
    while (! (tmp___29 >= 32U)) {
      __constr_expr_390[tmp___29] = (char)0;
      tmp___29 ++;
    }
    tmp___30 = header_init((var )(__constr_expr_390), Tuple, 2);
    tmp___31 = memcpy((void * __restrict  )((struct Tuple *)tmp___30), (void const   * __restrict  )(& __constr_expr_388),
                      sizeof(struct Tuple ));
    pos = print_to_with(out, pos, "\\\"", (var )((struct Tuple *)tmp___31));
    break;
    case 63: 
    __constr_expr_392[0] = Terminal;
    __constr_expr_391.items = __constr_expr_392;
    __constr_expr_393[0] = (char)0;
    tmp___32 = 1U;
    while (! (tmp___32 >= 32U)) {
      __constr_expr_393[tmp___32] = (char)0;
      tmp___32 ++;
    }
    tmp___33 = header_init((var )(__constr_expr_393), Tuple, 2);
    tmp___34 = memcpy((void * __restrict  )((struct Tuple *)tmp___33), (void const   * __restrict  )(& __constr_expr_391),
                      sizeof(struct Tuple ));
    pos = print_to_with(out, pos, "\\?", (var )((struct Tuple *)tmp___34));
    break;
    default: 
    __constr_expr_396.val = (int64_t )*v;
    __constr_expr_397[0] = (char)0;
    tmp___35 = 1U;
    while (! (tmp___35 >= 32U)) {
      __constr_expr_397[tmp___35] = (char)0;
      tmp___35 ++;
    }
    tmp___36 = header_init((var )(__constr_expr_397), Int, 2);
    tmp___37 = memcpy((void * __restrict  )((struct Int *)tmp___36), (void const   * __restrict  )(& __constr_expr_396),
                      sizeof(struct Int ));
    __constr_expr_395[0] = (var )((struct Int *)tmp___37);
    __constr_expr_395[1] = Terminal;
    __constr_expr_394.items = __constr_expr_395;
    __constr_expr_398[0] = (char)0;
    tmp___38 = 1U;
    while (! (tmp___38 >= 32U)) {
      __constr_expr_398[tmp___38] = (char)0;
      tmp___38 ++;
    }
    tmp___39 = header_init((var )(__constr_expr_398), Tuple, 2);
    tmp___40 = memcpy((void * __restrict  )((struct Tuple *)tmp___39), (void const   * __restrict  )(& __constr_expr_394),
                      sizeof(struct Tuple ));
    pos = print_to_with(out, pos, "%c", (var )((struct Tuple *)tmp___40));
    }
    v ++;
  }
  __constr_expr_400[0] = self;
  __constr_expr_400[1] = Terminal;
  __constr_expr_399.items = __constr_expr_400;
  __constr_expr_401[0] = (char)0;
  tmp___41 = 1U;
  while (! (tmp___41 >= 32U)) {
    __constr_expr_401[tmp___41] = (char)0;
    tmp___41 ++;
  }
  tmp___42 = header_init((var )(__constr_expr_401), Tuple, 2);
  tmp___43 = memcpy((void * __restrict  )((struct Tuple *)tmp___42), (void const   * __restrict  )(& __constr_expr_399),
                    sizeof(struct Tuple ));
  tmp___44 = print_to_with(out, pos, "\"", (var )((struct Tuple *)tmp___43));
  return (tmp___44);
}
}
static int String_Look(var self , var input , int pos ) 
{ 
  var chr ;
  struct Int __constr_expr_402 ;
  char __constr_expr_403[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  struct Tuple __constr_expr_404 ;
  var __constr_expr_405[2] ;
  char __constr_expr_406[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___2 ;
  var tmp___3 ;
  void *tmp___4 ;
  struct Tuple __constr_expr_407 ;
  var __constr_expr_408[1] ;
  char __constr_expr_409[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___5 ;
  var tmp___6 ;
  void *tmp___7 ;
  int64_t tmp___8 ;
  struct Tuple __constr_expr_410 ;
  var __constr_expr_411[2] ;
  char __constr_expr_412[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___9 ;
  var tmp___10 ;
  void *tmp___11 ;
  int64_t tmp___12 ;
  struct Tuple __constr_expr_413 ;
  var __constr_expr_414[2] ;
  char __constr_expr_415[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___13 ;
  var tmp___14 ;
  void *tmp___15 ;
  int64_t tmp___16 ;
  struct String __constr_expr_416 ;
  char __constr_expr_417[sizeof(struct Header ) + sizeof(struct String )] ;
  unsigned int tmp___17 ;
  var tmp___18 ;
  void *tmp___19 ;
  struct String __constr_expr_418 ;
  char __constr_expr_419[sizeof(struct Header ) + sizeof(struct String )] ;
  unsigned int tmp___20 ;
  var tmp___21 ;
  void *tmp___22 ;
  struct String __constr_expr_420 ;
  char __constr_expr_421[sizeof(struct Header ) + sizeof(struct String )] ;
  unsigned int tmp___23 ;
  var tmp___24 ;
  void *tmp___25 ;
  struct String __constr_expr_422 ;
  char __constr_expr_423[sizeof(struct Header ) + sizeof(struct String )] ;
  unsigned int tmp___26 ;
  var tmp___27 ;
  void *tmp___28 ;
  struct String __constr_expr_424 ;
  char __constr_expr_425[sizeof(struct Header ) + sizeof(struct String )] ;
  unsigned int tmp___29 ;
  var tmp___30 ;
  void *tmp___31 ;
  struct String __constr_expr_426 ;
  char __constr_expr_427[sizeof(struct Header ) + sizeof(struct String )] ;
  unsigned int tmp___32 ;
  var tmp___33 ;
  void *tmp___34 ;
  struct String __constr_expr_428 ;
  char __constr_expr_429[sizeof(struct Header ) + sizeof(struct String )] ;
  unsigned int tmp___35 ;
  var tmp___36 ;
  void *tmp___37 ;
  struct String __constr_expr_430 ;
  char __constr_expr_431[sizeof(struct Header ) + sizeof(struct String )] ;
  unsigned int tmp___38 ;
  var tmp___39 ;
  void *tmp___40 ;
  struct String __constr_expr_432 ;
  char __constr_expr_433[sizeof(struct Header ) + sizeof(struct String )] ;
  unsigned int tmp___41 ;
  var tmp___42 ;
  void *tmp___43 ;
  struct String __constr_expr_434 ;
  char __constr_expr_435[sizeof(struct Header ) + sizeof(struct String )] ;
  unsigned int tmp___44 ;
  var tmp___45 ;
  void *tmp___46 ;
  struct String __constr_expr_436 ;
  char __constr_expr_437[sizeof(struct Header ) + sizeof(struct String )] ;
  unsigned int tmp___47 ;
  var tmp___48 ;
  void *tmp___49 ;
  struct Tuple __constr_expr_438 ;
  var __constr_expr_439[2] ;
  char __constr_expr_440[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___50 ;
  var tmp___51 ;
  void *tmp___52 ;
  int64_t tmp___53 ;
  char buffer[2] ;
  int64_t tmp___54 ;
  struct String __constr_expr_441 ;
  char __constr_expr_442[sizeof(struct Header ) + sizeof(struct String )] ;
  unsigned int tmp___55 ;
  var tmp___56 ;
  void *tmp___57 ;

  {
  String_Clear(self);
  __constr_expr_402.val = (int64_t )0;
  __constr_expr_403[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_403[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_403), Int, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Int *)tmp___0), (void const   * __restrict  )(& __constr_expr_402),
                   sizeof(struct Int ));
  chr = (var )((struct Int *)tmp___1);
  __constr_expr_405[0] = chr;
  __constr_expr_405[1] = Terminal;
  __constr_expr_404.items = __constr_expr_405;
  __constr_expr_406[0] = (char)0;
  tmp___2 = 1U;
  while (! (tmp___2 >= 32U)) {
    __constr_expr_406[tmp___2] = (char)0;
    tmp___2 ++;
  }
  tmp___3 = header_init((var )(__constr_expr_406), Tuple, 2);
  tmp___4 = memcpy((void * __restrict  )((struct Tuple *)tmp___3), (void const   * __restrict  )(& __constr_expr_404),
                   sizeof(struct Tuple ));
  pos = scan_from_with(input, pos, "%c", (var )((struct Tuple *)tmp___4));
  tmp___8 = c_int(chr);
  if (tmp___8 != 34L) {
    __constr_expr_408[0] = Terminal;
    __constr_expr_407.items = __constr_expr_408;
    __constr_expr_409[0] = (char)0;
    tmp___5 = 1U;
    while (! (tmp___5 >= 32U)) {
      __constr_expr_409[tmp___5] = (char)0;
      tmp___5 ++;
    }
    tmp___6 = header_init((var )(__constr_expr_409), Tuple, 2);
    tmp___7 = memcpy((void * __restrict  )((struct Tuple *)tmp___6), (void const   * __restrict  )(& __constr_expr_407),
                     sizeof(struct Tuple ));
    exception_throw(FormatError, "String literal does not start with quotation marks!",
                    (var )((struct Tuple *)tmp___7));
  }
  while (1) {
    __constr_expr_411[0] = chr;
    __constr_expr_411[1] = Terminal;
    __constr_expr_410.items = __constr_expr_411;
    __constr_expr_412[0] = (char)0;
    tmp___9 = 1U;
    while (! (tmp___9 >= 32U)) {
      __constr_expr_412[tmp___9] = (char)0;
      tmp___9 ++;
    }
    tmp___10 = header_init((var )(__constr_expr_412), Tuple, 2);
    tmp___11 = memcpy((void * __restrict  )((struct Tuple *)tmp___10), (void const   * __restrict  )(& __constr_expr_410),
                      sizeof(struct Tuple ));
    pos = scan_from_with(input, pos, "%c", (var )((struct Tuple *)tmp___11));
    tmp___12 = c_int(chr);
    if (tmp___12 == 34L) {
      break;
    }
    tmp___53 = c_int(chr);
    if (tmp___53 == 92L) {
      __constr_expr_414[0] = chr;
      __constr_expr_414[1] = Terminal;
      __constr_expr_413.items = __constr_expr_414;
      __constr_expr_415[0] = (char)0;
      tmp___13 = 1U;
      while (! (tmp___13 >= 32U)) {
        __constr_expr_415[tmp___13] = (char)0;
        tmp___13 ++;
      }
      tmp___14 = header_init((var )(__constr_expr_415), Tuple, 2);
      tmp___15 = memcpy((void * __restrict  )((struct Tuple *)tmp___14), (void const   * __restrict  )(& __constr_expr_413),
                        sizeof(struct Tuple ));
      pos = scan_from_with(input, pos, "%c", (var )((struct Tuple *)tmp___15));
      tmp___16 = c_int(chr);
      switch (tmp___16) {
      case 97L: 
      __constr_expr_416.val = (char *)"\a";
      __constr_expr_417[0] = (char)0;
      tmp___17 = 1U;
      while (! (tmp___17 >= 32U)) {
        __constr_expr_417[tmp___17] = (char)0;
        tmp___17 ++;
      }
      tmp___18 = header_init((var )(__constr_expr_417), String, 2);
      tmp___19 = memcpy((void * __restrict  )((struct String *)tmp___18), (void const   * __restrict  )(& __constr_expr_416),
                        sizeof(struct String ));
      String_Concat(self, (var )((struct String *)tmp___19));
      break;
      case 98L: 
      __constr_expr_418.val = (char *)"\b";
      __constr_expr_419[0] = (char)0;
      tmp___20 = 1U;
      while (! (tmp___20 >= 32U)) {
        __constr_expr_419[tmp___20] = (char)0;
        tmp___20 ++;
      }
      tmp___21 = header_init((var )(__constr_expr_419), String, 2);
      tmp___22 = memcpy((void * __restrict  )((struct String *)tmp___21), (void const   * __restrict  )(& __constr_expr_418),
                        sizeof(struct String ));
      String_Concat(self, (var )((struct String *)tmp___22));
      break;
      case 102L: 
      __constr_expr_420.val = (char *)"\f";
      __constr_expr_421[0] = (char)0;
      tmp___23 = 1U;
      while (! (tmp___23 >= 32U)) {
        __constr_expr_421[tmp___23] = (char)0;
        tmp___23 ++;
      }
      tmp___24 = header_init((var )(__constr_expr_421), String, 2);
      tmp___25 = memcpy((void * __restrict  )((struct String *)tmp___24), (void const   * __restrict  )(& __constr_expr_420),
                        sizeof(struct String ));
      String_Concat(self, (var )((struct String *)tmp___25));
      break;
      case 110L: 
      __constr_expr_422.val = (char *)"\n";
      __constr_expr_423[0] = (char)0;
      tmp___26 = 1U;
      while (! (tmp___26 >= 32U)) {
        __constr_expr_423[tmp___26] = (char)0;
        tmp___26 ++;
      }
      tmp___27 = header_init((var )(__constr_expr_423), String, 2);
      tmp___28 = memcpy((void * __restrict  )((struct String *)tmp___27), (void const   * __restrict  )(& __constr_expr_422),
                        sizeof(struct String ));
      String_Concat(self, (var )((struct String *)tmp___28));
      break;
      case 114L: 
      __constr_expr_424.val = (char *)"\r";
      __constr_expr_425[0] = (char)0;
      tmp___29 = 1U;
      while (! (tmp___29 >= 32U)) {
        __constr_expr_425[tmp___29] = (char)0;
        tmp___29 ++;
      }
      tmp___30 = header_init((var )(__constr_expr_425), String, 2);
      tmp___31 = memcpy((void * __restrict  )((struct String *)tmp___30), (void const   * __restrict  )(& __constr_expr_424),
                        sizeof(struct String ));
      String_Concat(self, (var )((struct String *)tmp___31));
      break;
      case 116L: 
      __constr_expr_426.val = (char *)"\t";
      __constr_expr_427[0] = (char)0;
      tmp___32 = 1U;
      while (! (tmp___32 >= 32U)) {
        __constr_expr_427[tmp___32] = (char)0;
        tmp___32 ++;
      }
      tmp___33 = header_init((var )(__constr_expr_427), String, 2);
      tmp___34 = memcpy((void * __restrict  )((struct String *)tmp___33), (void const   * __restrict  )(& __constr_expr_426),
                        sizeof(struct String ));
      String_Concat(self, (var )((struct String *)tmp___34));
      break;
      case 118L: 
      __constr_expr_428.val = (char *)"\v";
      __constr_expr_429[0] = (char)0;
      tmp___35 = 1U;
      while (! (tmp___35 >= 32U)) {
        __constr_expr_429[tmp___35] = (char)0;
        tmp___35 ++;
      }
      tmp___36 = header_init((var )(__constr_expr_429), String, 2);
      tmp___37 = memcpy((void * __restrict  )((struct String *)tmp___36), (void const   * __restrict  )(& __constr_expr_428),
                        sizeof(struct String ));
      String_Concat(self, (var )((struct String *)tmp___37));
      break;
      case 92L: 
      __constr_expr_430.val = (char *)"\\";
      __constr_expr_431[0] = (char)0;
      tmp___38 = 1U;
      while (! (tmp___38 >= 32U)) {
        __constr_expr_431[tmp___38] = (char)0;
        tmp___38 ++;
      }
      tmp___39 = header_init((var )(__constr_expr_431), String, 2);
      tmp___40 = memcpy((void * __restrict  )((struct String *)tmp___39), (void const   * __restrict  )(& __constr_expr_430),
                        sizeof(struct String ));
      String_Concat(self, (var )((struct String *)tmp___40));
      break;
      case 39L: 
      __constr_expr_432.val = (char *)"\'";
      __constr_expr_433[0] = (char)0;
      tmp___41 = 1U;
      while (! (tmp___41 >= 32U)) {
        __constr_expr_433[tmp___41] = (char)0;
        tmp___41 ++;
      }
      tmp___42 = header_init((var )(__constr_expr_433), String, 2);
      tmp___43 = memcpy((void * __restrict  )((struct String *)tmp___42), (void const   * __restrict  )(& __constr_expr_432),
                        sizeof(struct String ));
      String_Concat(self, (var )((struct String *)tmp___43));
      break;
      case 34L: 
      __constr_expr_434.val = (char *)"\"";
      __constr_expr_435[0] = (char)0;
      tmp___44 = 1U;
      while (! (tmp___44 >= 32U)) {
        __constr_expr_435[tmp___44] = (char)0;
        tmp___44 ++;
      }
      tmp___45 = header_init((var )(__constr_expr_435), String, 2);
      tmp___46 = memcpy((void * __restrict  )((struct String *)tmp___45), (void const   * __restrict  )(& __constr_expr_434),
                        sizeof(struct String ));
      String_Concat(self, (var )((struct String *)tmp___46));
      break;
      case 63L: 
      __constr_expr_436.val = (char *)"?";
      __constr_expr_437[0] = (char)0;
      tmp___47 = 1U;
      while (! (tmp___47 >= 32U)) {
        __constr_expr_437[tmp___47] = (char)0;
        tmp___47 ++;
      }
      tmp___48 = header_init((var )(__constr_expr_437), String, 2);
      tmp___49 = memcpy((void * __restrict  )((struct String *)tmp___48), (void const   * __restrict  )(& __constr_expr_436),
                        sizeof(struct String ));
      String_Concat(self, (var )((struct String *)tmp___49));
      break;
      default: 
      __constr_expr_439[0] = chr;
      __constr_expr_439[1] = Terminal;
      __constr_expr_438.items = __constr_expr_439;
      __constr_expr_440[0] = (char)0;
      tmp___50 = 1U;
      while (! (tmp___50 >= 32U)) {
        __constr_expr_440[tmp___50] = (char)0;
        tmp___50 ++;
      }
      tmp___51 = header_init((var )(__constr_expr_440), Tuple, 2);
      tmp___52 = memcpy((void * __restrict  )((struct Tuple *)tmp___51), (void const   * __restrict  )(& __constr_expr_438),
                        sizeof(struct Tuple ));
      exception_throw(FormatError, "Unknown Escape Sequence \'\\%c\'!", (var )((struct Tuple *)tmp___52));
      }
    }
    tmp___54 = c_int(chr);
    buffer[0] = (char )tmp___54;
    buffer[1] = (char )'\000';
    __constr_expr_441.val = buffer;
    __constr_expr_442[0] = (char)0;
    tmp___55 = 1U;
    while (! (tmp___55 >= 32U)) {
      __constr_expr_442[tmp___55] = (char)0;
      tmp___55 ++;
    }
    tmp___56 = header_init((var )(__constr_expr_442), String, 2);
    tmp___57 = memcpy((void * __restrict  )((struct String *)tmp___56), (void const   * __restrict  )(& __constr_expr_441),
                      sizeof(struct String ));
    String_Concat(self, (var )((struct String *)tmp___57));
  }
  return (pos);
}
}
static struct Doc __constr_expr_444  =    {& String_Name, & String_Brief, & String_Description, & String_Definition, & String_Examples,
    (struct Method *(*)(void))((void *)0)};
static struct New __constr_expr_445  =    {& String_New, & String_Del};
static struct Assign __constr_expr_446  =    {& String_Assign};
static struct Cmp __constr_expr_447  =    {& String_Cmp};
static struct Hash __constr_expr_448  =    {& String_Hash};
static struct Len __constr_expr_449  =    {& String_Len};
static struct Get __constr_expr_450  =    {(var (*)(var  , var  ))((void *)0), (void (*)(var  , var  , var  ))((void *)0),
    & String_Mem, & String_Rem, (var (*)(var  ))0, (var (*)(var  ))0};
static struct Resize __constr_expr_451  =    {& String_Resize};
static struct Concat __constr_expr_452  =    {& String_Concat, & String_Concat};
static struct C_Str __constr_expr_453  =    {& String_C_Str};
static struct Format __constr_expr_454  =    {& String_Format_To, & String_Format_From};
static struct Show __constr_expr_455  =    {& String_Show, & String_Look};
static var __constr_expr_443[66]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"String", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct String ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_444),      (void *)0,      (var )"New", 
        (var )(& __constr_expr_445),      (void *)0,      (var )"Assign",      (var )(& __constr_expr_446), 
        (void *)0,      (var )"Cmp",      (var )(& __constr_expr_447),      (void *)0, 
        (var )"Hash",      (var )(& __constr_expr_448),      (void *)0,      (var )"Len", 
        (var )(& __constr_expr_449),      (void *)0,      (var )"Get",      (var )(& __constr_expr_450), 
        (void *)0,      (var )"Resize",      (var )(& __constr_expr_451),      (void *)0, 
        (var )"Concat",      (var )(& __constr_expr_452),      (void *)0,      (var )"C_Str", 
        (var )(& __constr_expr_453),      (void *)0,      (var )"Format",      (var )(& __constr_expr_454), 
        (void *)0,      (var )"Show",      (var )(& __constr_expr_455),      (void *)0, 
        (void *)0,      (void *)0};
var String  =    (var )((char *)(__constr_expr_443) + sizeof(struct Header ));
#pragma merger("0","/tmp/cil-xn44w7YR.i","-std=gnu99,-Wall,-Wno-unused,-g,-ggdb,-fPIC")
var Cast ;
var Size ;
var Alloc ;
var New ;
var Cmp ;
var Concat ;
var C_Int ;
var C_Float ;
var Pointer ;
var Current ;
var Mark ;
_Bool implements(var self , var cls ) ;
_Bool type_implements(var self , var cls ) ;
_Bool type_implements_method_at_offset(var self , var cls , size_t offset ) ;
int format_to(var self , int pos , char const   *fmt  , ...) ;
static char const   *Cast_Name(void) 
{ 


  {
  return ("Cast");
}
}
static char const   *Cast_Brief(void) 
{ 


  {
  return ("Runtime Type Checking");
}
}
static char const   *Cast_Description(void) 
{ 


  {
  return ("The `Cast` class provides a rudimentary run-time type checking. By default it simply checks that the passed in object is of a given type but it can be overridden by types which have to do more complex checking to ensure the types are correct.");
}
}
static char const   *Cast_Definition(void) 
{ 


  {
  return ("struct Cast {\n  var (*cast)(var, var);\n};\n");
}
}
static struct Example *Cast_Examples(void) ;
static struct Example examples___17[2]  = {      {"Usage", "var x = $I(100);\nstruct Int* y = cast(x, Int);\nshow(y);\n"}, 
        {(char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Example *Cast_Examples(void) 
{ 


  {
  return (examples___17);
}
}
static struct Method *Cast_Methods(void) ;
static struct Method methods___15[2]  = {      {"cast", "var cast(var self, var type);", "Ensures the object `self` is of the given `type` and returns it if it is."}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Cast_Methods(void) 
{ 


  {
  return (methods___15);
}
}
static struct Doc __constr_expr_457  =    {& Cast_Name, & Cast_Brief, & Cast_Description, & Cast_Definition, & Cast_Examples,
    & Cast_Methods};
static var __constr_expr_456[33]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Cast", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Cast ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_457),      (void *)0,      (void *)0, 
        (void *)0};
var Cast  =    (var )((char *)(__constr_expr_456) + sizeof(struct Header ));
var cast(var self , var type ) 
{ 
  struct Cast *c ;
  var tmp ;
  var tmp___0 ;
  struct Tuple __constr_expr_458 ;
  var __constr_expr_459[3] ;
  var tmp___1 ;
  char __constr_expr_460[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___2 ;
  var tmp___3 ;
  void *tmp___4 ;
  var tmp___5 ;
  var tmp___6 ;

  {
  tmp = instance(self, Cast);
  c = (struct Cast *)tmp;
  if (c) {
    if (c->cast) {
      tmp___0 = (*(c->cast))(self, type);
      return (tmp___0);
    }
  }
  tmp___6 = type_of(self);
  if ((unsigned long )tmp___6 == (unsigned long )type) {
    return (self);
  } else {
    tmp___1 = type_of(self);
    __constr_expr_459[0] = tmp___1;
    __constr_expr_459[1] = type;
    __constr_expr_459[2] = Terminal;
    __constr_expr_458.items = __constr_expr_459;
    __constr_expr_460[0] = (char)0;
    tmp___2 = 1U;
    while (! (tmp___2 >= 32U)) {
      __constr_expr_460[tmp___2] = (char)0;
      tmp___2 ++;
    }
    tmp___3 = header_init((var )(__constr_expr_460), Tuple, 2);
    tmp___4 = memcpy((void * __restrict  )((struct Tuple *)tmp___3), (void const   * __restrict  )(& __constr_expr_458),
                     sizeof(struct Tuple ));
    tmp___5 = exception_throw(ValueError, "cast expected type %s, got type %s", (var )((struct Tuple *)tmp___4));
    return (tmp___5);
  }
}
}
static char const   *Type_Name(void) 
{ 


  {
  return ("Type");
}
}
static char const   *Type_Brief(void) 
{ 


  {
  return ("Metadata Object");
}
}
static char const   *Type_Description(void) 
{ 


  {
  return ("The `Type` type is one of the most important types in Cello. It is the object which specifies the meta-data associated with a particular object. Most importantly this says what classes an object implements and what their instances are.\n\nOne can get the type of an object using the `type_of` function.\n\nTo see if an object implements a class `implements` can be used. To call a member of a class with an object `method` can be used.\n\nTo see if a type implements a class `type_implements` can be used. To call a member of a class, implemented `type_method` can be used.");
}
}
static struct Example *Type_Examples(void) ;
static struct Example examples___18[2]  = {      {"Usage", "var t = type_of($I(5));\nshow(t); /* Int */\n\nshow($I(type_implements(t, New)));  /* 1 */\nshow($I(type_implements(t, Cmp)));  /* 1 */\nshow($I(type_implements(t, Hash))); /* 1 */\n\nshow($I(type_method(t, Cmp, cmp, $I(5), $I(6))));\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Type_Examples(void) 
{ 


  {
  return (examples___18);
}
}
static struct Method *Type_Methods(void) ;
static struct Method methods___16[6]  = {      {"type_of", "var type_of(var self);", "Returns the `Type` of an object `self`."}, 
        {"instance",
      "var instance(var self, var cls);\nvar type_instance(var type, var cls);", "Returns the instance of class `cls` implemented by object `self` or type `type`. If class is not implemented then returns `NULL`."}, 
        {"implements",
      "bool implements(var self, var cls);\nbool type_implements(var type, var cls);",
      "Returns if the object `self` or type `type` implements the class `cls`."}, 
        {"method", "#define method(X, C, M, ...)\n#define type_method(T, C, M, ...)",
      "Returns the result of the call to method `M` of class `C` for object `X`or type `T`. If class is not implemented then an error is thrown."}, 
        {"implements_method",
      "#define implements_method(X, C, M)\n#define type_implements_method(T, C, M)",
      "Returns if the type `T` or object `X` implements the method `M` of class C."}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Type_Methods(void) 
{ 


  {
  return (methods___16);
}
}
static var Type_Alloc(void) 
{ 
  struct Header *head ;
  void *tmp ;
  struct Tuple __constr_expr_461 ;
  var __constr_expr_462[1] ;
  char __constr_expr_463[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;
  var tmp___3 ;

  {
  tmp = calloc((size_t )1, sizeof(struct Header ) + sizeof(struct Type ) * 265UL);
  head = (struct Header *)tmp;
  if ((unsigned long )head == (unsigned long )((void *)0)) {
    __constr_expr_462[0] = Terminal;
    __constr_expr_461.items = __constr_expr_462;
    __constr_expr_463[0] = (char)0;
    tmp___0 = 1U;
    while (! (tmp___0 >= 32U)) {
      __constr_expr_463[tmp___0] = (char)0;
      tmp___0 ++;
    }
    tmp___1 = header_init((var )(__constr_expr_463), Tuple, 2);
    tmp___2 = memcpy((void * __restrict  )((struct Tuple *)tmp___1), (void const   * __restrict  )(& __constr_expr_461),
                     sizeof(struct Tuple ));
    exception_throw(OutOfMemoryError, "Cannot create new \'Type\', out of memory!",
                    (var )((struct Tuple *)tmp___2));
  }
  tmp___3 = header_init((var )head, Type, 3);
  return (tmp___3);
}
}
static void Type_New(var self , var args ) 
{ 
  struct Type *t ;
  var name___0 ;
  struct Int __constr_expr_464 ;
  char __constr_expr_465[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  var tmp___2 ;
  var size___0 ;
  struct Int __constr_expr_466 ;
  char __constr_expr_467[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;
  var tmp___6 ;
  struct Tuple __constr_expr_468 ;
  var __constr_expr_469[3] ;
  struct Int __constr_expr_470 ;
  size_t tmp___7 ;
  char __constr_expr_471[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___8 ;
  var tmp___9 ;
  void *tmp___10 ;
  struct Int __constr_expr_472 ;
  char __constr_expr_473[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___11 ;
  var tmp___12 ;
  void *tmp___13 ;
  char __constr_expr_474[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___14 ;
  var tmp___15 ;
  void *tmp___16 ;
  size_t tmp___17 ;
  size_t cache_entries ;
  size_t i ;
  struct Type __constr_expr_475 ;
  struct Type __constr_expr_476 ;
  char *tmp___18 ;
  struct Type __constr_expr_477 ;
  int64_t tmp___19 ;
  size_t i___0 ;
  var ins ;
  struct Int __constr_expr_478 ;
  char __constr_expr_479[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___20 ;
  var tmp___21 ;
  void *tmp___22 ;
  var tmp___23 ;
  struct Type __constr_expr_480 ;
  var tmp___24 ;
  char *tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  struct Type __constr_expr_481 ;

  {
  t = (struct Type *)self;
  __constr_expr_464.val = (int64_t )0;
  __constr_expr_465[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_465[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_465), Int, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Int *)tmp___0), (void const   * __restrict  )(& __constr_expr_464),
                   sizeof(struct Int ));
  tmp___2 = get(args, (var )((struct Int *)tmp___1));
  name___0 = tmp___2;
  __constr_expr_466.val = (int64_t )1;
  __constr_expr_467[0] = (char)0;
  tmp___3 = 1U;
  while (! (tmp___3 >= 32U)) {
    __constr_expr_467[tmp___3] = (char)0;
    tmp___3 ++;
  }
  tmp___4 = header_init((var )(__constr_expr_467), Int, 2);
  tmp___5 = memcpy((void * __restrict  )((struct Int *)tmp___4), (void const   * __restrict  )(& __constr_expr_466),
                   sizeof(struct Int ));
  tmp___6 = get(args, (var )((struct Int *)tmp___5));
  size___0 = tmp___6;
  tmp___17 = len(args);
  if (tmp___17 - 2UL > 256UL) {
    tmp___7 = len(args);
    __constr_expr_470.val = (int64_t )tmp___7;
    __constr_expr_471[0] = (char)0;
    tmp___8 = 1U;
    while (! (tmp___8 >= 32U)) {
      __constr_expr_471[tmp___8] = (char)0;
      tmp___8 ++;
    }
    tmp___9 = header_init((var )(__constr_expr_471), Int, 2);
    tmp___10 = memcpy((void * __restrict  )((struct Int *)tmp___9), (void const   * __restrict  )(& __constr_expr_470),
                      sizeof(struct Int ));
    __constr_expr_472.val = (int64_t )256;
    __constr_expr_473[0] = (char)0;
    tmp___11 = 1U;
    while (! (tmp___11 >= 32U)) {
      __constr_expr_473[tmp___11] = (char)0;
      tmp___11 ++;
    }
    tmp___12 = header_init((var )(__constr_expr_473), Int, 2);
    tmp___13 = memcpy((void * __restrict  )((struct Int *)tmp___12), (void const   * __restrict  )(& __constr_expr_472),
                      sizeof(struct Int ));
    __constr_expr_469[0] = (var )((struct Int *)tmp___10);
    __constr_expr_469[1] = (var )((struct Int *)tmp___13);
    __constr_expr_469[2] = Terminal;
    __constr_expr_468.items = __constr_expr_469;
    __constr_expr_474[0] = (char)0;
    tmp___14 = 1U;
    while (! (tmp___14 >= 32U)) {
      __constr_expr_474[tmp___14] = (char)0;
      tmp___14 ++;
    }
    tmp___15 = header_init((var )(__constr_expr_474), Tuple, 2);
    tmp___16 = memcpy((void * __restrict  )((struct Tuple *)tmp___15), (void const   * __restrict  )(& __constr_expr_468),
                      sizeof(struct Tuple ));
    exception_throw(OutOfMemoryError, "Cannot construct \'Type\' with %i instances, maximum is %i.",
                    (var )((struct Tuple *)tmp___16));
  }
  cache_entries = (size_t )6;
  i = (size_t )0;
  while (i < cache_entries) {
    __constr_expr_475.cls = (void *)0;
    __constr_expr_475.name = (void *)0;
    __constr_expr_475.inst = (void *)0;
    *(t + i) = __constr_expr_475;
    i ++;
  }
  tmp___18 = c_str(name___0);
  __constr_expr_476.cls = (void *)0;
  __constr_expr_476.name = (var )"__Name";
  __constr_expr_476.inst = (var )tmp___18;
  *(t + cache_entries) = __constr_expr_476;
  tmp___19 = c_int(size___0);
  __constr_expr_477.cls = (void *)0;
  __constr_expr_477.name = (var )"__Size";
  __constr_expr_477.inst = (var )((uintptr_t )tmp___19);
  *(t + (cache_entries + 1UL)) = __constr_expr_477;
  i___0 = (size_t )2;
  while (1) {
    tmp___26 = len(args);
    if (! (i___0 < tmp___26)) {
      break;
    }
    __constr_expr_478.val = (int64_t )i___0;
    __constr_expr_479[0] = (char)0;
    tmp___20 = 1U;
    while (! (tmp___20 >= 32U)) {
      __constr_expr_479[tmp___20] = (char)0;
      tmp___20 ++;
    }
    tmp___21 = header_init((var )(__constr_expr_479), Int, 2);
    tmp___22 = memcpy((void * __restrict  )((struct Int *)tmp___21), (void const   * __restrict  )(& __constr_expr_478),
                      sizeof(struct Int ));
    tmp___23 = get(args, (var )((struct Int *)tmp___22));
    ins = tmp___23;
    tmp___24 = type_of(ins);
    tmp___25 = c_str(tmp___24);
    __constr_expr_480.cls = (void *)0;
    __constr_expr_480.name = (var )tmp___25;
    __constr_expr_480.inst = ins;
    *(t + (6UL + i___0)) = __constr_expr_480;
    i___0 ++;
  }
  tmp___27 = len(args);
  __constr_expr_481.cls = (void *)0;
  __constr_expr_481.name = (void *)0;
  __constr_expr_481.inst = (void *)0;
  *(t + ((8UL + tmp___27) - 2UL)) = __constr_expr_481;
  return;
}
}
static char *Type_Builtin_Name(struct Type *t ) 
{ 


  {
  return ((char *)(t + 6)->inst);
}
}
static size_t Type_Builtin_Size(struct Type *t ) 
{ 


  {
  return ((size_t )(t + 7)->inst);
}
}
static int Type_Show(var self , var output , int pos ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
  tmp = Type_Builtin_Name((struct Type *)self);
  tmp___0 = format_to(output, pos, "%s", tmp);
  return (tmp___0);
}
}
static int Type_Cmp(var self , var obj ) 
{ 
  struct Type *objt ;
  var tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  tmp = cast(obj, Type);
  objt = (struct Type *)tmp;
  tmp___0 = Type_Builtin_Name(objt);
  tmp___1 = Type_Builtin_Name((struct Type *)self);
  tmp___2 = strcmp((char const   *)tmp___1, (char const   *)tmp___0);
  return (tmp___2);
}
}
static uint64_t Type_Hash(var self ) 
{ 
  char const   *name___0 ;
  char *tmp ;
  size_t tmp___0 ;
  uint64_t tmp___1 ;

  {
  tmp = Type_Builtin_Name((struct Type *)self);
  name___0 = (char const   *)tmp;
  tmp___0 = strlen(name___0);
  tmp___1 = hash_data((void const   *)name___0, tmp___0);
  return (tmp___1);
}
}
static char *Type_C_Str(var self ) 
{ 
  char *tmp ;

  {
  tmp = Type_Builtin_Name((struct Type *)self);
  return (tmp);
}
}
static void Type_Assign(var self , var obj ) 
{ 
  struct Tuple __constr_expr_482 ;
  var __constr_expr_483[1] ;
  char __constr_expr_484[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;

  {
  __constr_expr_483[0] = Terminal;
  __constr_expr_482.items = __constr_expr_483;
  __constr_expr_484[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_484[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_484), Tuple, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_482),
                   sizeof(struct Tuple ));
  exception_throw(ValueError, "Type objects cannot be assigned.", (var )((struct Tuple *)tmp___1));
  return;
}
}
static var Type_Copy(var self ) 
{ 
  struct Tuple __constr_expr_485 ;
  var __constr_expr_486[1] ;
  char __constr_expr_487[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  var tmp___2 ;

  {
  __constr_expr_486[0] = Terminal;
  __constr_expr_485.items = __constr_expr_486;
  __constr_expr_487[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_487[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_487), Tuple, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_485),
                   sizeof(struct Tuple ));
  tmp___2 = exception_throw(ValueError, "Type objects cannot be copied.", (var )((struct Tuple *)tmp___1));
  return (tmp___2);
}
}
static int print_indent(var out , int pos , char const   *str ) 
{ 
  struct Tuple __constr_expr_488 ;
  var __constr_expr_489[1] ;
  char __constr_expr_490[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  struct Tuple __constr_expr_491 ;
  var __constr_expr_492[1] ;
  char __constr_expr_493[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___2 ;
  var tmp___3 ;
  void *tmp___4 ;
  struct Tuple __constr_expr_494 ;
  var __constr_expr_495[2] ;
  struct Int __constr_expr_496 ;
  char __constr_expr_497[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___5 ;
  var tmp___6 ;
  void *tmp___7 ;
  char __constr_expr_498[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___8 ;
  var tmp___9 ;
  void *tmp___10 ;

  {
  __constr_expr_489[0] = Terminal;
  __constr_expr_488.items = __constr_expr_489;
  __constr_expr_490[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_490[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_490), Tuple, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_488),
                   sizeof(struct Tuple ));
  pos = print_to_with(out, pos, "    ", (var )((struct Tuple *)tmp___1));
  while (*str) {
    if ((int const   )*str == 10) {
      __constr_expr_492[0] = Terminal;
      __constr_expr_491.items = __constr_expr_492;
      __constr_expr_493[0] = (char)0;
      tmp___2 = 1U;
      while (! (tmp___2 >= 32U)) {
        __constr_expr_493[tmp___2] = (char)0;
        tmp___2 ++;
      }
      tmp___3 = header_init((var )(__constr_expr_493), Tuple, 2);
      tmp___4 = memcpy((void * __restrict  )((struct Tuple *)tmp___3), (void const   * __restrict  )(& __constr_expr_491),
                       sizeof(struct Tuple ));
      pos = print_to_with(out, pos, "\n    ", (var )((struct Tuple *)tmp___4));
    } else {
      __constr_expr_496.val = (int64_t )*str;
      __constr_expr_497[0] = (char)0;
      tmp___5 = 1U;
      while (! (tmp___5 >= 32U)) {
        __constr_expr_497[tmp___5] = (char)0;
        tmp___5 ++;
      }
      tmp___6 = header_init((var )(__constr_expr_497), Int, 2);
      tmp___7 = memcpy((void * __restrict  )((struct Int *)tmp___6), (void const   * __restrict  )(& __constr_expr_496),
                       sizeof(struct Int ));
      __constr_expr_495[0] = (var )((struct Int *)tmp___7);
      __constr_expr_495[1] = Terminal;
      __constr_expr_494.items = __constr_expr_495;
      __constr_expr_498[0] = (char)0;
      tmp___8 = 1U;
      while (! (tmp___8 >= 32U)) {
        __constr_expr_498[tmp___8] = (char)0;
        tmp___8 ++;
      }
      tmp___9 = header_init((var )(__constr_expr_498), Tuple, 2);
      tmp___10 = memcpy((void * __restrict  )((struct Tuple *)tmp___9), (void const   * __restrict  )(& __constr_expr_494),
                        sizeof(struct Tuple ));
      pos = print_to_with(out, pos, "%c", (var )((struct Tuple *)tmp___10));
    }
    str ++;
  }
  return (pos);
}
}
static int Type_Help_To(var self , var out , int pos ) 
{ 
  struct Doc *doc ;
  var tmp ;
  struct Tuple __constr_expr_499 ;
  var __constr_expr_500[2] ;
  char __constr_expr_501[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  struct Tuple __constr_expr_502 ;
  var __constr_expr_503[1] ;
  char __constr_expr_504[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___4 ;
  var tmp___5 ;
  void *tmp___6 ;
  struct Tuple __constr_expr_505 ;
  var __constr_expr_506[2] ;
  char __constr_expr_507[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___7 ;
  var tmp___8 ;
  void *tmp___9 ;
  struct Tuple __constr_expr_508 ;
  var __constr_expr_509[2] ;
  struct String __constr_expr_510 ;
  char const   *tmp___10 ;
  char __constr_expr_511[sizeof(struct Header ) + sizeof(struct String )] ;
  unsigned int tmp___11 ;
  var tmp___12 ;
  void *tmp___13 ;
  char __constr_expr_512[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___14 ;
  var tmp___15 ;
  void *tmp___16 ;
  struct Tuple __constr_expr_513 ;
  var __constr_expr_514[2] ;
  struct String __constr_expr_515 ;
  char const   *tmp___17 ;
  char __constr_expr_516[sizeof(struct Header ) + sizeof(struct String )] ;
  unsigned int tmp___18 ;
  var tmp___19 ;
  void *tmp___20 ;
  char __constr_expr_517[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___21 ;
  var tmp___22 ;
  void *tmp___23 ;
  struct Tuple __constr_expr_518 ;
  var __constr_expr_519[1] ;
  char __constr_expr_520[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___24 ;
  var tmp___25 ;
  void *tmp___26 ;
  char const   *tmp___27 ;
  struct Tuple __constr_expr_521 ;
  var __constr_expr_522[1] ;
  char __constr_expr_523[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___28 ;
  var tmp___29 ;
  void *tmp___30 ;
  struct Tuple __constr_expr_524 ;
  var __constr_expr_525[1] ;
  char __constr_expr_526[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___31 ;
  var tmp___32 ;
  void *tmp___33 ;
  struct Method *methods___37 ;
  struct Method *tmp___34 ;
  struct Tuple __constr_expr_527 ;
  var __constr_expr_528[2] ;
  struct String __constr_expr_529 ;
  char __constr_expr_530[sizeof(struct Header ) + sizeof(struct String )] ;
  unsigned int tmp___35 ;
  var tmp___36 ;
  void *tmp___37 ;
  char __constr_expr_531[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___38 ;
  var tmp___39 ;
  void *tmp___40 ;
  struct Tuple __constr_expr_532 ;
  var __constr_expr_533[2] ;
  struct String __constr_expr_534 ;
  char __constr_expr_535[sizeof(struct Header ) + sizeof(struct String )] ;
  unsigned int tmp___41 ;
  var tmp___42 ;
  void *tmp___43 ;
  char __constr_expr_536[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___44 ;
  var tmp___45 ;
  void *tmp___46 ;
  struct Tuple __constr_expr_537 ;
  var __constr_expr_538[1] ;
  char __constr_expr_539[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___47 ;
  var tmp___48 ;
  void *tmp___49 ;
  struct Example *examples___51 ;
  struct Example *tmp___50 ;
  struct Tuple __constr_expr_540 ;
  var __constr_expr_541[2] ;
  struct String __constr_expr_542 ;
  char __constr_expr_543[sizeof(struct Header ) + sizeof(struct String )] ;
  unsigned int tmp___51 ;
  var tmp___52 ;
  void *tmp___53 ;
  char __constr_expr_544[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___54 ;
  var tmp___55 ;
  void *tmp___56 ;
  struct Tuple __constr_expr_545 ;
  var __constr_expr_546[1] ;
  char __constr_expr_547[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___57 ;
  var tmp___58 ;
  void *tmp___59 ;
  struct Tuple __constr_expr_548 ;
  var __constr_expr_549[1] ;
  char __constr_expr_550[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___60 ;
  var tmp___61 ;
  void *tmp___62 ;

  {
  tmp = type_instance(self, Doc);
  doc = (struct Doc *)tmp;
  if ((unsigned long )doc == (unsigned long )((void *)0)) {
    __constr_expr_500[0] = self;
    __constr_expr_500[1] = Terminal;
    __constr_expr_499.items = __constr_expr_500;
    __constr_expr_501[0] = (char)0;
    tmp___0 = 1U;
    while (! (tmp___0 >= 32U)) {
      __constr_expr_501[tmp___0] = (char)0;
      tmp___0 ++;
    }
    tmp___1 = header_init((var )(__constr_expr_501), Tuple, 2);
    tmp___2 = memcpy((void * __restrict  )((struct Tuple *)tmp___1), (void const   * __restrict  )(& __constr_expr_499),
                     sizeof(struct Tuple ));
    tmp___3 = print_to_with(out, pos, "\nNo Documentation Found for Type %s\n", (var )((struct Tuple *)tmp___2));
    return (tmp___3);
  }
  __constr_expr_503[0] = Terminal;
  __constr_expr_502.items = __constr_expr_503;
  __constr_expr_504[0] = (char)0;
  tmp___4 = 1U;
  while (! (tmp___4 >= 32U)) {
    __constr_expr_504[tmp___4] = (char)0;
    tmp___4 ++;
  }
  tmp___5 = header_init((var )(__constr_expr_504), Tuple, 2);
  tmp___6 = memcpy((void * __restrict  )((struct Tuple *)tmp___5), (void const   * __restrict  )(& __constr_expr_502),
                   sizeof(struct Tuple ));
  pos = print_to_with(out, pos, "\n", (var )((struct Tuple *)tmp___6));
  __constr_expr_506[0] = self;
  __constr_expr_506[1] = Terminal;
  __constr_expr_505.items = __constr_expr_506;
  __constr_expr_507[0] = (char)0;
  tmp___7 = 1U;
  while (! (tmp___7 >= 32U)) {
    __constr_expr_507[tmp___7] = (char)0;
    tmp___7 ++;
  }
  tmp___8 = header_init((var )(__constr_expr_507), Tuple, 2);
  tmp___9 = memcpy((void * __restrict  )((struct Tuple *)tmp___8), (void const   * __restrict  )(& __constr_expr_505),
                   sizeof(struct Tuple ));
  pos = print_to_with(out, pos, "# %s ", (var )((struct Tuple *)tmp___9));
  if (doc->brief) {
    tmp___10 = (*(doc->brief))();
    __constr_expr_510.val = (char *)tmp___10;
    __constr_expr_511[0] = (char)0;
    tmp___11 = 1U;
    while (! (tmp___11 >= 32U)) {
      __constr_expr_511[tmp___11] = (char)0;
      tmp___11 ++;
    }
    tmp___12 = header_init((var )(__constr_expr_511), String, 2);
    tmp___13 = memcpy((void * __restrict  )((struct String *)tmp___12), (void const   * __restrict  )(& __constr_expr_510),
                      sizeof(struct String ));
    __constr_expr_509[0] = (var )((struct String *)tmp___13);
    __constr_expr_509[1] = Terminal;
    __constr_expr_508.items = __constr_expr_509;
    __constr_expr_512[0] = (char)0;
    tmp___14 = 1U;
    while (! (tmp___14 >= 32U)) {
      __constr_expr_512[tmp___14] = (char)0;
      tmp___14 ++;
    }
    tmp___15 = header_init((var )(__constr_expr_512), Tuple, 2);
    tmp___16 = memcpy((void * __restrict  )((struct Tuple *)tmp___15), (void const   * __restrict  )(& __constr_expr_508),
                      sizeof(struct Tuple ));
    pos = print_to_with(out, pos, " - %s\n\n", (var )((struct Tuple *)tmp___16));
  }
  if (doc->description) {
    tmp___17 = (*(doc->description))();
    __constr_expr_515.val = (char *)tmp___17;
    __constr_expr_516[0] = (char)0;
    tmp___18 = 1U;
    while (! (tmp___18 >= 32U)) {
      __constr_expr_516[tmp___18] = (char)0;
      tmp___18 ++;
    }
    tmp___19 = header_init((var )(__constr_expr_516), String, 2);
    tmp___20 = memcpy((void * __restrict  )((struct String *)tmp___19), (void const   * __restrict  )(& __constr_expr_515),
                      sizeof(struct String ));
    __constr_expr_514[0] = (var )((struct String *)tmp___20);
    __constr_expr_514[1] = Terminal;
    __constr_expr_513.items = __constr_expr_514;
    __constr_expr_517[0] = (char)0;
    tmp___21 = 1U;
    while (! (tmp___21 >= 32U)) {
      __constr_expr_517[tmp___21] = (char)0;
      tmp___21 ++;
    }
    tmp___22 = header_init((var )(__constr_expr_517), Tuple, 2);
    tmp___23 = memcpy((void * __restrict  )((struct Tuple *)tmp___22), (void const   * __restrict  )(& __constr_expr_513),
                      sizeof(struct Tuple ));
    pos = print_to_with(out, pos, "%s\n\n", (var )((struct Tuple *)tmp___23));
  }
  if (doc->definition) {
    __constr_expr_519[0] = Terminal;
    __constr_expr_518.items = __constr_expr_519;
    __constr_expr_520[0] = (char)0;
    tmp___24 = 1U;
    while (! (tmp___24 >= 32U)) {
      __constr_expr_520[tmp___24] = (char)0;
      tmp___24 ++;
    }
    tmp___25 = header_init((var )(__constr_expr_520), Tuple, 2);
    tmp___26 = memcpy((void * __restrict  )((struct Tuple *)tmp___25), (void const   * __restrict  )(& __constr_expr_518),
                      sizeof(struct Tuple ));
    pos = print_to_with(out, pos, "\n### Definition\n\n", (var )((struct Tuple *)tmp___26));
    tmp___27 = (*(doc->definition))();
    pos = print_indent(out, pos, tmp___27);
    __constr_expr_522[0] = Terminal;
    __constr_expr_521.items = __constr_expr_522;
    __constr_expr_523[0] = (char)0;
    tmp___28 = 1U;
    while (! (tmp___28 >= 32U)) {
      __constr_expr_523[tmp___28] = (char)0;
      tmp___28 ++;
    }
    tmp___29 = header_init((var )(__constr_expr_523), Tuple, 2);
    tmp___30 = memcpy((void * __restrict  )((struct Tuple *)tmp___29), (void const   * __restrict  )(& __constr_expr_521),
                      sizeof(struct Tuple ));
    pos = print_to_with(out, pos, "\n\n", (var )((struct Tuple *)tmp___30));
  }
  if (doc->methods) {
    __constr_expr_525[0] = Terminal;
    __constr_expr_524.items = __constr_expr_525;
    __constr_expr_526[0] = (char)0;
    tmp___31 = 1U;
    while (! (tmp___31 >= 32U)) {
      __constr_expr_526[tmp___31] = (char)0;
      tmp___31 ++;
    }
    tmp___32 = header_init((var )(__constr_expr_526), Tuple, 2);
    tmp___33 = memcpy((void * __restrict  )((struct Tuple *)tmp___32), (void const   * __restrict  )(& __constr_expr_524),
                      sizeof(struct Tuple ));
    pos = print_to_with(out, pos, "\n### Methods\n\n", (var )((struct Tuple *)tmp___33));
    tmp___34 = (*(doc->methods))();
    methods___37 = tmp___34;
    while ((methods___37 + 0)->name) {
      __constr_expr_529.val = (char *)(methods___37 + 0)->name;
      __constr_expr_530[0] = (char)0;
      tmp___35 = 1U;
      while (! (tmp___35 >= 32U)) {
        __constr_expr_530[tmp___35] = (char)0;
        tmp___35 ++;
      }
      tmp___36 = header_init((var )(__constr_expr_530), String, 2);
      tmp___37 = memcpy((void * __restrict  )((struct String *)tmp___36), (void const   * __restrict  )(& __constr_expr_529),
                        sizeof(struct String ));
      __constr_expr_528[0] = (var )((struct String *)tmp___37);
      __constr_expr_528[1] = Terminal;
      __constr_expr_527.items = __constr_expr_528;
      __constr_expr_531[0] = (char)0;
      tmp___38 = 1U;
      while (! (tmp___38 >= 32U)) {
        __constr_expr_531[tmp___38] = (char)0;
        tmp___38 ++;
      }
      tmp___39 = header_init((var )(__constr_expr_531), Tuple, 2);
      tmp___40 = memcpy((void * __restrict  )((struct Tuple *)tmp___39), (void const   * __restrict  )(& __constr_expr_527),
                        sizeof(struct Tuple ));
      pos = print_to_with(out, pos, "__%s__\n\n", (var )((struct Tuple *)tmp___40));
      pos = print_indent(out, pos, (methods___37 + 0)->definition);
      __constr_expr_534.val = (char *)(methods___37 + 0)->description;
      __constr_expr_535[0] = (char)0;
      tmp___41 = 1U;
      while (! (tmp___41 >= 32U)) {
        __constr_expr_535[tmp___41] = (char)0;
        tmp___41 ++;
      }
      tmp___42 = header_init((var )(__constr_expr_535), String, 2);
      tmp___43 = memcpy((void * __restrict  )((struct String *)tmp___42), (void const   * __restrict  )(& __constr_expr_534),
                        sizeof(struct String ));
      __constr_expr_533[0] = (var )((struct String *)tmp___43);
      __constr_expr_533[1] = Terminal;
      __constr_expr_532.items = __constr_expr_533;
      __constr_expr_536[0] = (char)0;
      tmp___44 = 1U;
      while (! (tmp___44 >= 32U)) {
        __constr_expr_536[tmp___44] = (char)0;
        tmp___44 ++;
      }
      tmp___45 = header_init((var )(__constr_expr_536), Tuple, 2);
      tmp___46 = memcpy((void * __restrict  )((struct Tuple *)tmp___45), (void const   * __restrict  )(& __constr_expr_532),
                        sizeof(struct Tuple ));
      pos = print_to_with(out, pos, "\n\n%s\n\n", (var )((struct Tuple *)tmp___46));
      methods___37 ++;
    }
  }
  if (doc->examples) {
    __constr_expr_538[0] = Terminal;
    __constr_expr_537.items = __constr_expr_538;
    __constr_expr_539[0] = (char)0;
    tmp___47 = 1U;
    while (! (tmp___47 >= 32U)) {
      __constr_expr_539[tmp___47] = (char)0;
      tmp___47 ++;
    }
    tmp___48 = header_init((var )(__constr_expr_539), Tuple, 2);
    tmp___49 = memcpy((void * __restrict  )((struct Tuple *)tmp___48), (void const   * __restrict  )(& __constr_expr_537),
                      sizeof(struct Tuple ));
    pos = print_to_with(out, pos, "\n### Examples\n\n", (var )((struct Tuple *)tmp___49));
    tmp___50 = (*(doc->examples))();
    examples___51 = tmp___50;
    while ((examples___51 + 0)->name) {
      __constr_expr_542.val = (char *)(examples___51 + 0)->name;
      __constr_expr_543[0] = (char)0;
      tmp___51 = 1U;
      while (! (tmp___51 >= 32U)) {
        __constr_expr_543[tmp___51] = (char)0;
        tmp___51 ++;
      }
      tmp___52 = header_init((var )(__constr_expr_543), String, 2);
      tmp___53 = memcpy((void * __restrict  )((struct String *)tmp___52), (void const   * __restrict  )(& __constr_expr_542),
                        sizeof(struct String ));
      __constr_expr_541[0] = (var )((struct String *)tmp___53);
      __constr_expr_541[1] = Terminal;
      __constr_expr_540.items = __constr_expr_541;
      __constr_expr_544[0] = (char)0;
      tmp___54 = 1U;
      while (! (tmp___54 >= 32U)) {
        __constr_expr_544[tmp___54] = (char)0;
        tmp___54 ++;
      }
      tmp___55 = header_init((var )(__constr_expr_544), Tuple, 2);
      tmp___56 = memcpy((void * __restrict  )((struct Tuple *)tmp___55), (void const   * __restrict  )(& __constr_expr_540),
                        sizeof(struct Tuple ));
      pos = print_to_with(out, pos, "__%s__\n\n", (var )((struct Tuple *)tmp___56));
      pos = print_indent(out, pos, (examples___51 + 0)->body);
      __constr_expr_546[0] = Terminal;
      __constr_expr_545.items = __constr_expr_546;
      __constr_expr_547[0] = (char)0;
      tmp___57 = 1U;
      while (! (tmp___57 >= 32U)) {
        __constr_expr_547[tmp___57] = (char)0;
        tmp___57 ++;
      }
      tmp___58 = header_init((var )(__constr_expr_547), Tuple, 2);
      tmp___59 = memcpy((void * __restrict  )((struct Tuple *)tmp___58), (void const   * __restrict  )(& __constr_expr_545),
                        sizeof(struct Tuple ));
      pos = print_to_with(out, pos, "\n\n", (var )((struct Tuple *)tmp___59));
      examples___51 ++;
    }
    __constr_expr_549[0] = Terminal;
    __constr_expr_548.items = __constr_expr_549;
    __constr_expr_550[0] = (char)0;
    tmp___60 = 1U;
    while (! (tmp___60 >= 32U)) {
      __constr_expr_550[tmp___60] = (char)0;
      tmp___60 ++;
    }
    tmp___61 = header_init((var )(__constr_expr_550), Tuple, 2);
    tmp___62 = memcpy((void * __restrict  )((struct Tuple *)tmp___61), (void const   * __restrict  )(& __constr_expr_548),
                      sizeof(struct Tuple ));
    pos = print_to_with(out, pos, "\n\n", (var )((struct Tuple *)tmp___62));
  }
  return (pos);
}
}
static struct Doc __constr_expr_552  =    {& Type_Name, & Type_Brief, & Type_Description, (char const   *(*)(void))((void *)0),
    & Type_Examples, & Type_Methods};
static struct Assign __constr_expr_553  =    {& Type_Assign};
static struct Copy __constr_expr_554  =    {& Type_Copy};
static struct Alloc __constr_expr_555  =    {& Type_Alloc, (void (*)(var  ))((void *)0)};
static struct New __constr_expr_556  =    {& Type_New, (void (*)(var  ))((void *)0)};
static struct Cmp __constr_expr_557  =    {& Type_Cmp};
static struct Hash __constr_expr_558  =    {& Type_Hash};
static struct Show __constr_expr_559  =    {& Type_Show, (int (*)(var  , var  , int  ))((void *)0)};
static struct C_Str __constr_expr_560  =    {& Type_C_Str};
static struct Help __constr_expr_561  =    {& Type_Help_To};
static var __constr_expr_551[60]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Type", 
        (void *)0,      (var )"__Size",      (var )0,      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_552),      (void *)0,      (var )"Assign", 
        (var )(& __constr_expr_553),      (void *)0,      (var )"Copy",      (var )(& __constr_expr_554), 
        (void *)0,      (var )"Alloc",      (var )(& __constr_expr_555),      (void *)0, 
        (var )"New",      (var )(& __constr_expr_556),      (void *)0,      (var )"Cmp", 
        (var )(& __constr_expr_557),      (void *)0,      (var )"Hash",      (var )(& __constr_expr_558), 
        (void *)0,      (var )"Show",      (var )(& __constr_expr_559),      (void *)0, 
        (var )"C_Str",      (var )(& __constr_expr_560),      (void *)0,      (var )"Help", 
        (var )(& __constr_expr_561),      (void *)0,      (void *)0,      (void *)0};
var Type  =    (var )((char *)(__constr_expr_551) + sizeof(struct Header ));
static var Type_Scan(var self , var cls ) 
{ 
  struct Tuple __constr_expr_562 ;
  var __constr_expr_563[2] ;
  var tmp ;
  char __constr_expr_564[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;
  var tmp___3 ;
  var tmp___4 ;
  struct Type *t ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  tmp___4 = type_of(self);
  if ((unsigned long )tmp___4 != (unsigned long )Type) {
    tmp = type_of(self);
    __constr_expr_563[0] = tmp;
    __constr_expr_563[1] = Terminal;
    __constr_expr_562.items = __constr_expr_563;
    __constr_expr_564[0] = (char)0;
    tmp___0 = 1U;
    while (! (tmp___0 >= 32U)) {
      __constr_expr_564[tmp___0] = (char)0;
      tmp___0 ++;
    }
    tmp___1 = header_init((var )(__constr_expr_564), Tuple, 2);
    tmp___2 = memcpy((void * __restrict  )((struct Tuple *)tmp___1), (void const   * __restrict  )(& __constr_expr_562),
                     sizeof(struct Tuple ));
    tmp___3 = exception_throw(TypeError, "Method call got non type \'%s\'", (var )((struct Tuple *)tmp___2));
    return (tmp___3);
  }
  t = (struct Type *)self + 8;
  while (t->name) {
    if ((unsigned long )t->cls == (unsigned long )cls) {
      return (t->inst);
    }
    t ++;
  }
  t = (struct Type *)self + 8;
  while (t->name) {
    tmp___5 = Type_Builtin_Name((struct Type *)cls);
    tmp___6 = strcmp((char const   *)t->name, (char const   *)tmp___5);
    if (tmp___6 == 0) {
      t->cls = cls;
      return (t->inst);
    }
    t ++;
  }
  return ((void *)0);
}
}
static _Bool Type_Implements(var self , var cls ) 
{ 
  var tmp ;

  {
  tmp = Type_Scan(self, cls);
  return ((_Bool )((unsigned long )tmp != (unsigned long )((void *)0)));
}
}
_Bool type_implements(var self , var cls ) 
{ 
  _Bool tmp ;

  {
  tmp = Type_Implements(self, cls);
  return (tmp);
}
}
static var Type_Instance(var self , var cls ) ;
static var Type_Method_At_Offset(var self , var cls , size_t offset , char const   *method_name ) 
{ 
  var inst ;
  var tmp ;
  struct Tuple __constr_expr_565 ;
  var __constr_expr_566[3] ;
  char __constr_expr_567[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;
  var tmp___3 ;
  var meth ;
  struct Tuple __constr_expr_568 ;
  var __constr_expr_569[4] ;
  struct String __constr_expr_570 ;
  char __constr_expr_571[sizeof(struct Header ) + sizeof(struct String )] ;
  unsigned int tmp___4 ;
  var tmp___5 ;
  void *tmp___6 ;
  char __constr_expr_572[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___7 ;
  var tmp___8 ;
  void *tmp___9 ;
  var tmp___10 ;

  {
  tmp = Type_Instance(self, cls);
  inst = tmp;
  if ((unsigned long )inst == (unsigned long )((void *)0)) {
    __constr_expr_566[0] = self;
    __constr_expr_566[1] = cls;
    __constr_expr_566[2] = Terminal;
    __constr_expr_565.items = __constr_expr_566;
    __constr_expr_567[0] = (char)0;
    tmp___0 = 1U;
    while (! (tmp___0 >= 32U)) {
      __constr_expr_567[tmp___0] = (char)0;
      tmp___0 ++;
    }
    tmp___1 = header_init((var )(__constr_expr_567), Tuple, 2);
    tmp___2 = memcpy((void * __restrict  )((struct Tuple *)tmp___1), (void const   * __restrict  )(& __constr_expr_565),
                     sizeof(struct Tuple ));
    tmp___3 = exception_throw(ClassError, "Type \'%s\' does not implement class \'%s\'",
                              (var )((struct Tuple *)tmp___2));
    return (tmp___3);
  }
  meth = *((var *)((char *)inst + offset));
  if ((unsigned long )meth == (unsigned long )((void *)0)) {
    __constr_expr_570.val = (char *)method_name;
    __constr_expr_571[0] = (char)0;
    tmp___4 = 1U;
    while (! (tmp___4 >= 32U)) {
      __constr_expr_571[tmp___4] = (char)0;
      tmp___4 ++;
    }
    tmp___5 = header_init((var )(__constr_expr_571), String, 2);
    tmp___6 = memcpy((void * __restrict  )((struct String *)tmp___5), (void const   * __restrict  )(& __constr_expr_570),
                     sizeof(struct String ));
    __constr_expr_569[0] = self;
    __constr_expr_569[1] = cls;
    __constr_expr_569[2] = (var )((struct String *)tmp___6);
    __constr_expr_569[3] = Terminal;
    __constr_expr_568.items = __constr_expr_569;
    __constr_expr_572[0] = (char)0;
    tmp___7 = 1U;
    while (! (tmp___7 >= 32U)) {
      __constr_expr_572[tmp___7] = (char)0;
      tmp___7 ++;
    }
    tmp___8 = header_init((var )(__constr_expr_572), Tuple, 2);
    tmp___9 = memcpy((void * __restrict  )((struct Tuple *)tmp___8), (void const   * __restrict  )(& __constr_expr_568),
                     sizeof(struct Tuple ));
    tmp___10 = exception_throw(ClassError, "Type \'%s\' implements class \'%s\' but not the method \'%s\' required",
                               (var )((struct Tuple *)tmp___9));
    return (tmp___10);
  }
  return (inst);
}
}
var type_method_at_offset(var self , var cls , size_t offset , char const   *method_name ) 
{ 
  var tmp ;

  {
  tmp = Type_Method_At_Offset(self, cls, offset, method_name);
  return (tmp);
}
}
static _Bool Type_Implements_Method_At_Offset(var self , var cls , size_t offset ) 
{ 
  var inst ;
  var tmp ;
  var meth ;

  {
  tmp = Type_Scan(self, cls);
  inst = tmp;
  if ((unsigned long )inst == (unsigned long )((void *)0)) {
    return ((_Bool)0);
  }
  meth = *((var *)((char *)inst + offset));
  if ((unsigned long )meth == (unsigned long )((void *)0)) {
    return ((_Bool)0);
  }
  return ((_Bool)1);
}
}
_Bool type_implements_method_at_offset(var self , var cls , size_t offset ) 
{ 
  _Bool tmp ;

  {
  tmp = Type_Implements_Method_At_Offset(self, cls, offset);
  return (tmp);
}
}
static var Type_Instance(var self , var cls ) 
{ 
  var inst ;
  var inst___0 ;
  var inst___1 ;
  var inst___2 ;
  var inst___3 ;
  var inst___4 ;
  var inst___5 ;
  var inst___6 ;
  var inst___7 ;
  var inst___8 ;
  var inst___9 ;
  var inst___10 ;
  var inst___11 ;
  var inst___12 ;
  var inst___13 ;
  var inst___14 ;
  var inst___15 ;
  var inst___16 ;
  var tmp ;

  {
  if ((unsigned long )cls == (unsigned long )Size) {
    inst = *((var *)self + 0);
    if ((unsigned long )inst == (unsigned long )((void *)0)) {
      inst = Type_Scan(self, Size);
      *((var *)self + 0) = inst;
    }
    return (inst);
  }
  if ((unsigned long )cls == (unsigned long )Alloc) {
    inst___0 = *((var *)self + 1);
    if ((unsigned long )inst___0 == (unsigned long )((void *)0)) {
      inst___0 = Type_Scan(self, Alloc);
      *((var *)self + 1) = inst___0;
    }
    return (inst___0);
  }
  if ((unsigned long )cls == (unsigned long )New) {
    inst___1 = *((var *)self + 2);
    if ((unsigned long )inst___1 == (unsigned long )((void *)0)) {
      inst___1 = Type_Scan(self, New);
      *((var *)self + 2) = inst___1;
    }
    return (inst___1);
  }
  if ((unsigned long )cls == (unsigned long )Assign) {
    inst___2 = *((var *)self + 3);
    if ((unsigned long )inst___2 == (unsigned long )((void *)0)) {
      inst___2 = Type_Scan(self, Assign);
      *((var *)self + 3) = inst___2;
    }
    return (inst___2);
  }
  if ((unsigned long )cls == (unsigned long )Cmp) {
    inst___3 = *((var *)self + 4);
    if ((unsigned long )inst___3 == (unsigned long )((void *)0)) {
      inst___3 = Type_Scan(self, Cmp);
      *((var *)self + 4) = inst___3;
    }
    return (inst___3);
  }
  if ((unsigned long )cls == (unsigned long )Mark) {
    inst___4 = *((var *)self + 5);
    if ((unsigned long )inst___4 == (unsigned long )((void *)0)) {
      inst___4 = Type_Scan(self, Mark);
      *((var *)self + 5) = inst___4;
    }
    return (inst___4);
  }
  if ((unsigned long )cls == (unsigned long )Hash) {
    inst___5 = *((var *)self + 6);
    if ((unsigned long )inst___5 == (unsigned long )((void *)0)) {
      inst___5 = Type_Scan(self, Hash);
      *((var *)self + 6) = inst___5;
    }
    return (inst___5);
  }
  if ((unsigned long )cls == (unsigned long )Len) {
    inst___6 = *((var *)self + 7);
    if ((unsigned long )inst___6 == (unsigned long )((void *)0)) {
      inst___6 = Type_Scan(self, Len);
      *((var *)self + 7) = inst___6;
    }
    return (inst___6);
  }
  if ((unsigned long )cls == (unsigned long )Iter) {
    inst___7 = *((var *)self + 8);
    if ((unsigned long )inst___7 == (unsigned long )((void *)0)) {
      inst___7 = Type_Scan(self, Iter);
      *((var *)self + 8) = inst___7;
    }
    return (inst___7);
  }
  if ((unsigned long )cls == (unsigned long )Push) {
    inst___8 = *((var *)self + 9);
    if ((unsigned long )inst___8 == (unsigned long )((void *)0)) {
      inst___8 = Type_Scan(self, Push);
      *((var *)self + 9) = inst___8;
    }
    return (inst___8);
  }
  if ((unsigned long )cls == (unsigned long )Concat) {
    inst___9 = *((var *)self + 10);
    if ((unsigned long )inst___9 == (unsigned long )((void *)0)) {
      inst___9 = Type_Scan(self, Concat);
      *((var *)self + 10) = inst___9;
    }
    return (inst___9);
  }
  if ((unsigned long )cls == (unsigned long )Get) {
    inst___10 = *((var *)self + 11);
    if ((unsigned long )inst___10 == (unsigned long )((void *)0)) {
      inst___10 = Type_Scan(self, Get);
      *((var *)self + 11) = inst___10;
    }
    return (inst___10);
  }
  if ((unsigned long )cls == (unsigned long )C_Str) {
    inst___11 = *((var *)self + 12);
    if ((unsigned long )inst___11 == (unsigned long )((void *)0)) {
      inst___11 = Type_Scan(self, C_Str);
      *((var *)self + 12) = inst___11;
    }
    return (inst___11);
  }
  if ((unsigned long )cls == (unsigned long )C_Int) {
    inst___12 = *((var *)self + 13);
    if ((unsigned long )inst___12 == (unsigned long )((void *)0)) {
      inst___12 = Type_Scan(self, C_Int);
      *((var *)self + 13) = inst___12;
    }
    return (inst___12);
  }
  if ((unsigned long )cls == (unsigned long )C_Float) {
    inst___13 = *((var *)self + 14);
    if ((unsigned long )inst___13 == (unsigned long )((void *)0)) {
      inst___13 = Type_Scan(self, C_Float);
      *((var *)self + 14) = inst___13;
    }
    return (inst___13);
  }
  if ((unsigned long )cls == (unsigned long )Current) {
    inst___14 = *((var *)self + 15);
    if ((unsigned long )inst___14 == (unsigned long )((void *)0)) {
      inst___14 = Type_Scan(self, Current);
      *((var *)self + 15) = inst___14;
    }
    return (inst___14);
  }
  if ((unsigned long )cls == (unsigned long )Cast) {
    inst___15 = *((var *)self + 16);
    if ((unsigned long )inst___15 == (unsigned long )((void *)0)) {
      inst___15 = Type_Scan(self, Cast);
      *((var *)self + 16) = inst___15;
    }
    return (inst___15);
  }
  if ((unsigned long )cls == (unsigned long )Pointer) {
    inst___16 = *((var *)self + 17);
    if ((unsigned long )inst___16 == (unsigned long )((void *)0)) {
      inst___16 = Type_Scan(self, Pointer);
      *((var *)self + 17) = inst___16;
    }
    return (inst___16);
  }
  tmp = Type_Scan(self, cls);
  return (tmp);
}
}
var type_instance(var self , var cls ) 
{ 
  var tmp ;

  {
  tmp = Type_Instance(self, cls);
  return (tmp);
}
}
static var Type_Of(var self ) 
{ 
  struct Tuple __constr_expr_573 ;
  var __constr_expr_574[1] ;
  char __constr_expr_575[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  var tmp___2 ;
  struct Header *head ;
  struct Tuple __constr_expr_576 ;
  var __constr_expr_577[2] ;
  char __constr_expr_578[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;
  struct Tuple __constr_expr_579 ;
  var __constr_expr_580[2] ;
  char __constr_expr_581[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___6 ;
  var tmp___7 ;
  void *tmp___8 ;

  {
  if ((unsigned long )self == (unsigned long )((void *)0)) {
    __constr_expr_574[0] = Terminal;
    __constr_expr_573.items = __constr_expr_574;
    __constr_expr_575[0] = (char)0;
    tmp = 1U;
    while (! (tmp >= 32U)) {
      __constr_expr_575[tmp] = (char)0;
      tmp ++;
    }
    tmp___0 = header_init((var )(__constr_expr_575), Tuple, 2);
    tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_573),
                     sizeof(struct Tuple ));
    tmp___2 = exception_throw(ValueError, "Received NULL as value to \'type_of\'",
                              (var )((struct Tuple *)tmp___1));
    return (tmp___2);
  }
  head = (struct Header *)((char *)self - sizeof(struct Header ));
  if ((unsigned long )head->magic == (unsigned long )((var )59774918928L)) {
    __constr_expr_577[0] = self;
    __constr_expr_577[1] = Terminal;
    __constr_expr_576.items = __constr_expr_577;
    __constr_expr_578[0] = (char)0;
    tmp___3 = 1U;
    while (! (tmp___3 >= 32U)) {
      __constr_expr_578[tmp___3] = (char)0;
      tmp___3 ++;
    }
    tmp___4 = header_init((var )(__constr_expr_578), Tuple, 2);
    tmp___5 = memcpy((void * __restrict  )((struct Tuple *)tmp___4), (void const   * __restrict  )(& __constr_expr_576),
                     sizeof(struct Tuple ));
    exception_throw(ValueError, "Pointer \'%p\' passed to \'type_of\' has bad magic number, it looks like it was already deallocated.",
                    (var )((struct Tuple *)tmp___5));
  }
  if ((unsigned long )head->magic != (unsigned long )((var )844048)) {
    __constr_expr_580[0] = self;
    __constr_expr_580[1] = Terminal;
    __constr_expr_579.items = __constr_expr_580;
    __constr_expr_581[0] = (char)0;
    tmp___6 = 1U;
    while (! (tmp___6 >= 32U)) {
      __constr_expr_581[tmp___6] = (char)0;
      tmp___6 ++;
    }
    tmp___7 = header_init((var )(__constr_expr_581), Tuple, 2);
    tmp___8 = memcpy((void * __restrict  )((struct Tuple *)tmp___7), (void const   * __restrict  )(& __constr_expr_579),
                     sizeof(struct Tuple ));
    exception_throw(ValueError, "Pointer \'%p\' passed to \'type_of\' has bad magic number, perhaps it wasn\'t allocated by Cello.",
                    (var )((struct Tuple *)tmp___8));
  }
  if ((unsigned long )head->type == (unsigned long )((void *)0)) {
    head->type = Type;
  }
  return (head->type);
}
}
var type_of(var self ) 
{ 
  var tmp ;

  {
  tmp = Type_Of(self);
  return (tmp);
}
}
var instance(var self , var cls ) 
{ 
  var tmp ;
  var tmp___0 ;

  {
  tmp = Type_Of(self);
  tmp___0 = Type_Instance(tmp, cls);
  return (tmp___0);
}
}
_Bool implements(var self , var cls ) 
{ 
  var tmp ;
  _Bool tmp___0 ;

  {
  tmp = Type_Of(self);
  tmp___0 = Type_Implements(tmp, cls);
  return (tmp___0);
}
}
var method_at_offset(var self , var cls , size_t offset , char const   *method_name ) 
{ 
  var tmp ;
  var tmp___0 ;

  {
  tmp = Type_Of(self);
  tmp___0 = Type_Method_At_Offset(tmp, cls, offset, method_name);
  return (tmp___0);
}
}
_Bool implements_method_at_offset(var self , var cls , size_t offset ) 
{ 
  var tmp ;
  _Bool tmp___0 ;

  {
  tmp = Type_Of(self);
  tmp___0 = Type_Implements_Method_At_Offset(tmp, cls, offset);
  return (tmp___0);
}
}
static char const   *Size_Name(void) 
{ 


  {
  return ("Size");
}
}
static char const   *Size_Brief(void) 
{ 


  {
  return ("Type Size");
}
}
static char const   *Size_Description(void) 
{ 


  {
  return ("The `Size` class is a very important class in Cello because it gives the size in bytes you can expect an object of a given type to be. This is used by many methods to allocate, assign, or compare various objects.\n\nBy default this size is automatically found and recorded by the `Cello` macro, but if the type does it\'s own allocation, or the size cannot be found naturally then it may be necessary to override this method.");
}
}
static char const   *Size_Definition(void) 
{ 


  {
  return ("struct Size {\n  size_t (*size)(void);\n};\n");
}
}
static struct Example *Size_Examples(void) ;
static struct Example examples___19[2]  = {      {"Usage", "show($I(size(Int)));\nshow($I(size(Float)));\nshow($I(size(Array)));\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Size_Examples(void) 
{ 


  {
  return (examples___19);
}
}
static struct Method *Size_Methods(void) ;
static struct Method methods___17[2]  = {      {"size", "size_t size(var type);", "Returns the associated size of a given `type` in bytes."}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Size_Methods(void) 
{ 


  {
  return (methods___17);
}
}
static struct Doc __constr_expr_583  =    {& Size_Name, & Size_Brief, & Size_Description, & Size_Definition, & Size_Examples,
    & Size_Methods};
static var __constr_expr_582[33]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Size", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Size ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_583),      (void *)0,      (void *)0, 
        (void *)0};
var Size  =    (var )((char *)(__constr_expr_582) + sizeof(struct Header ));
size_t size(var type ) 
{ 
  struct Size *s ;
  var tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
  tmp = type_instance(type, Size);
  s = (struct Size *)tmp;
  if (s) {
    if (s->size) {
      tmp___0 = (*(s->size))();
      return (tmp___0);
    }
  }
  tmp___1 = Type_Builtin_Size((struct Type *)type);
  return (tmp___1);
}
}
#pragma merger("0","/tmp/cil-UeZXtB3T.i","-std=gnu99,-Wall,-Wno-unused,-g,-ggdb,-fPIC")
var List ;
static char const   *List_Name(void) 
{ 


  {
  return ("List");
}
}
static char const   *List_Brief(void) 
{ 


  {
  return ("Linked List");
}
}
static char const   *List_Description(void) 
{ 


  {
  return ("The `List` type is a linked list data structure. Elements can be added and removed from the list and their memory is allocated and deallocated by the structure. Additionally destructors will be called on objects once removed.\n\nElements are copied into the List using `assign` and will initially have zero\'d memory.\n\nLists can provide fast insertion and removal at arbitrary locations although most other operations will be slow due to having to traverse the linked list data structure.\n\nThis is largely equivalent to the C++ construct [std::list](http://www.cplusplus.com/reference/list/list/)");
}
}
static struct Example *List_Examples(void) ;
static struct Example examples___20[5]  = {      {"Construction & Deletion", "var x = new(List, Int);\npush(x, $I(32));\npush(x, $I(6));\n\n/* <\'List\' At 0x0000000000414603 [32, 6]> */\nshow(x);\n"}, 
        {"Element Access",
      "var x = new(List, Float, $F(0.01), $F(5.12));\n\nshow(get(x, $I(0))); /* 0.01 */\nshow(get(x, $I(1))); /* 5.12 */\n\nset(x, $I(0), $F(500.1));\nshow(get(x, $I(0))); /* 500.1 */\n"}, 
        {"Membership",
      "var x = new(List, Int, $I(1), $I(2), $I(3), $I(4));\n\nshow($I(mem(x, $I(1)))); /* 1 */\nshow($I(len(x)));        /* 4 */\n\nrem(x, $I(3));\n\nshow($I(mem(x, $I(3)))); /* 0 */\nshow($I(len(x)));        /* 3 */\nshow($I(empty(x)));      /* 0 */\n\nresize(x, 0);\n\nshow($I(empty(x)));      /* 1 */\n"}, 
        {"Iteration",
      "var greetings = new(List, String, \n  $S(\"Hello\"), $S(\"Bonjour\"), $S(\"Hej\"));\n\nforeach(greet in greetings) {\n  show(greet);\n}\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *List_Examples(void) 
{ 


  {
  return (examples___20);
}
}
static var List_Alloc(struct List *l ) 
{ 
  var item ;
  void *tmp ;
  struct Tuple __constr_expr_584 ;
  var __constr_expr_585[1] ;
  char __constr_expr_586[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;
  var tmp___3 ;

  {
  tmp = calloc((size_t )1, (2UL * sizeof(var ) + sizeof(struct Header )) + l->tsize);
  item = tmp;
  if ((unsigned long )item == (unsigned long )((void *)0)) {
    __constr_expr_585[0] = Terminal;
    __constr_expr_584.items = __constr_expr_585;
    __constr_expr_586[0] = (char)0;
    tmp___0 = 1U;
    while (! (tmp___0 >= 32U)) {
      __constr_expr_586[tmp___0] = (char)0;
      tmp___0 ++;
    }
    tmp___1 = header_init((var )(__constr_expr_586), Tuple, 2);
    tmp___2 = memcpy((void * __restrict  )((struct Tuple *)tmp___1), (void const   * __restrict  )(& __constr_expr_584),
                     sizeof(struct Tuple ));
    exception_throw(OutOfMemoryError, "Cannot allocate List entry, out of memory!",
                    (var )((struct Tuple *)tmp___2));
  }
  tmp___3 = header_init((var )((struct Header *)((char *)item + 2UL * sizeof(var ))),
                        l->type, 4);
  return (tmp___3);
}
}
static void List_Free(struct List *l , var self ) 
{ 


  {
  free((void *)(((char *)self - sizeof(struct Header )) - 2UL * sizeof(var )));
  return;
}
}
static var *List_Next(struct List *l , var self ) 
{ 


  {
  return ((var *)(((char *)self - sizeof(struct Header )) - sizeof(var )));
}
}
static var *List_Prev(struct List *l , var self ) 
{ 


  {
  return ((var *)(((char *)self - sizeof(struct Header )) - 2UL * sizeof(var )));
}
}
static var List_At(struct List *l , int64_t i ) 
{ 
  struct Tuple __constr_expr_587 ;
  var __constr_expr_588[3] ;
  struct Int __constr_expr_589 ;
  char __constr_expr_590[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  struct Int __constr_expr_591 ;
  char __constr_expr_592[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___2 ;
  var tmp___3 ;
  void *tmp___4 ;
  char __constr_expr_593[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___5 ;
  var tmp___6 ;
  void *tmp___7 ;
  var tmp___8 ;
  var item ;
  var *tmp___9 ;
  var *tmp___10 ;

  {
  if (i < 0L) {
    i = (int64_t )(l->nitems + (size_t )i);
  } else {
    i = i;
  }
  if (i < 0L) {
    goto _L;
  } else
  if (i >= (int64_t )l->nitems) {
    _L: /* CIL Label */ 
    __constr_expr_589.val = i;
    __constr_expr_590[0] = (char)0;
    tmp = 1U;
    while (! (tmp >= 32U)) {
      __constr_expr_590[tmp] = (char)0;
      tmp ++;
    }
    tmp___0 = header_init((var )(__constr_expr_590), Int, 2);
    tmp___1 = memcpy((void * __restrict  )((struct Int *)tmp___0), (void const   * __restrict  )(& __constr_expr_589),
                     sizeof(struct Int ));
    __constr_expr_591.val = (int64_t )l->nitems;
    __constr_expr_592[0] = (char)0;
    tmp___2 = 1U;
    while (! (tmp___2 >= 32U)) {
      __constr_expr_592[tmp___2] = (char)0;
      tmp___2 ++;
    }
    tmp___3 = header_init((var )(__constr_expr_592), Int, 2);
    tmp___4 = memcpy((void * __restrict  )((struct Int *)tmp___3), (void const   * __restrict  )(& __constr_expr_591),
                     sizeof(struct Int ));
    __constr_expr_588[0] = (var )((struct Int *)tmp___1);
    __constr_expr_588[1] = (var )((struct Int *)tmp___4);
    __constr_expr_588[2] = Terminal;
    __constr_expr_587.items = __constr_expr_588;
    __constr_expr_593[0] = (char)0;
    tmp___5 = 1U;
    while (! (tmp___5 >= 32U)) {
      __constr_expr_593[tmp___5] = (char)0;
      tmp___5 ++;
    }
    tmp___6 = header_init((var )(__constr_expr_593), Tuple, 2);
    tmp___7 = memcpy((void * __restrict  )((struct Tuple *)tmp___6), (void const   * __restrict  )(& __constr_expr_587),
                     sizeof(struct Tuple ));
    tmp___8 = exception_throw(IndexOutOfBoundsError, "Index \'%i\' out of bounds for List of size %i.",
                              (var )((struct Tuple *)tmp___7));
    return (tmp___8);
  }
  if (i <= (int64_t )(l->nitems / 2UL)) {
    item = l->head;
    while (i) {
      tmp___9 = List_Next(l, item);
      item = *tmp___9;
      i --;
    }
  } else {
    i = (int64_t )((l->nitems - (size_t )i) - 1UL);
    item = l->tail;
    while (i) {
      tmp___10 = List_Prev(l, item);
      item = *tmp___10;
      i --;
    }
  }
  return (item);
}
}
static void List_Push(var self , var obj ) ;
static void List_Rem(var self , var obj ) ;
static void List_New(var self , var args ) 
{ 
  struct List *l ;
  struct Int __constr_expr_594 ;
  char __constr_expr_595[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  var tmp___2 ;
  size_t nargs ;
  size_t tmp___3 ;
  size_t i ;
  struct Int __constr_expr_596 ;
  char __constr_expr_597[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___4 ;
  var tmp___5 ;
  void *tmp___6 ;
  var tmp___7 ;

  {
  l = (struct List *)self;
  __constr_expr_594.val = (int64_t )0;
  __constr_expr_595[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_595[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_595), Int, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Int *)tmp___0), (void const   * __restrict  )(& __constr_expr_594),
                   sizeof(struct Int ));
  tmp___2 = get(args, (var )((struct Int *)tmp___1));
  l->type = cast(tmp___2, Type);
  l->tsize = size(l->type);
  l->nitems = (size_t )0;
  l->head = (void *)0;
  l->tail = (void *)0;
  tmp___3 = len(args);
  nargs = tmp___3;
  i = (size_t )0;
  while (i < nargs - 1UL) {
    __constr_expr_596.val = (int64_t )(i + 1UL);
    __constr_expr_597[0] = (char)0;
    tmp___4 = 1U;
    while (! (tmp___4 >= 32U)) {
      __constr_expr_597[tmp___4] = (char)0;
      tmp___4 ++;
    }
    tmp___5 = header_init((var )(__constr_expr_597), Int, 2);
    tmp___6 = memcpy((void * __restrict  )((struct Int *)tmp___5), (void const   * __restrict  )(& __constr_expr_596),
                     sizeof(struct Int ));
    tmp___7 = get(args, (var )((struct Int *)tmp___6));
    List_Push(self, tmp___7);
    i ++;
  }
  return;
}
}
static void List_Clear(var self ) 
{ 
  struct List *l ;
  var item ;
  var next ;
  var *tmp ;

  {
  l = (struct List *)self;
  item = l->head;
  while (item) {
    tmp = List_Next(l, item);
    next = *tmp;
    destruct(item);
    List_Free(l, item);
    item = next;
  }
  l->tail = (void *)0;
  l->head = (void *)0;
  l->nitems = (size_t )0;
  return;
}
}
static void List_Del(var self ) 
{ 
  struct List *l ;

  {
  l = (struct List *)self;
  List_Clear(self);
  return;
}
}
static void List_Assign(var self , var obj ) 
{ 
  struct List *l ;
  var tmp___0 ;
  _Bool tmp___1 ;
  size_t nargs ;
  size_t tmp___2 ;
  size_t i ;
  struct Int __constr_expr_598 ;
  char __constr_expr_599[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;
  var tmp___6 ;

  {
  l = (struct List *)self;
  List_Clear(self);
  tmp___1 = implements_method_at_offset(obj, Iter, (unsigned long )(& ((struct Iter *)0)->iter_type));
  if (tmp___1) {
    tmp___0 = iter_type(obj);
    l->type = tmp___0;
  } else {
    l->type = Ref;
  }
  l->tsize = size(l->type);
  tmp___2 = len(obj);
  nargs = tmp___2;
  i = (size_t )0;
  while (i < nargs) {
    __constr_expr_598.val = (int64_t )i;
    __constr_expr_599[0] = (char)0;
    tmp___3 = 1U;
    while (! (tmp___3 >= 32U)) {
      __constr_expr_599[tmp___3] = (char)0;
      tmp___3 ++;
    }
    tmp___4 = header_init((var )(__constr_expr_599), Int, 2);
    tmp___5 = memcpy((void * __restrict  )((struct Int *)tmp___4), (void const   * __restrict  )(& __constr_expr_598),
                     sizeof(struct Int ));
    tmp___6 = get(obj, (var )((struct Int *)tmp___5));
    List_Push(self, tmp___6);
    i ++;
  }
  return;
}
}
static void List_Concat(var self , var obj ) 
{ 
  var __item ;
  var __Iteritem ;
  var tmp ;
  var item ;
  var tmp___0 ;

  {
  __item = obj;
  tmp = instance(__item, Iter);
  __Iteritem = tmp;
  tmp___0 = (*(((struct Iter *)__Iteritem)->iter_init))(__item);
  item = tmp___0;
  while ((unsigned long )item != (unsigned long )Terminal) {
    List_Push(self, item);
    item = (*(((struct Iter *)__Iteritem)->iter_next))(__item, item);
  }
  return;
}
}
static var List_Iter_Init(var self ) ;
static var List_Iter_Next(var self , var curr ) ;
static int List_Cmp(var self , var obj ) 
{ 
  var item0 ;
  var tmp ;
  var item1 ;
  var tmp___0 ;
  int c ;
  int tmp___1 ;

  {
  tmp = List_Iter_Init(self);
  item0 = tmp;
  tmp___0 = iter_init(obj);
  item1 = tmp___0;
  while (1) {
    if ((unsigned long )item0 == (unsigned long )Terminal) {
      if ((unsigned long )item1 == (unsigned long )Terminal) {
        return (0);
      }
    }
    if ((unsigned long )item0 == (unsigned long )Terminal) {
      return (-1);
    }
    if ((unsigned long )item1 == (unsigned long )Terminal) {
      return (1);
    }
    tmp___1 = cmp(item0, item1);
    c = tmp___1;
    if (c < 0) {
      return (-1);
    }
    if (c > 0) {
      return (1);
    }
    item0 = List_Iter_Next(self, item0);
    item1 = iter_next(obj, item1);
  }
  return (0);
}
}
static uint64_t List_Hash(var self ) 
{ 
  struct List *l ;
  uint64_t h ;
  var item ;
  size_t i ;
  uint64_t tmp ;
  var *tmp___0 ;

  {
  l = (struct List *)self;
  h = (uint64_t )0;
  item = l->head;
  i = (size_t )0;
  while (i < l->nitems) {
    tmp = hash(item);
    h ^= tmp;
    tmp___0 = List_Next(l, item);
    item = *tmp___0;
    i ++;
  }
  return (h);
}
}
static size_t List_Len(var self ) 
{ 
  struct List *l ;

  {
  l = (struct List *)self;
  return (l->nitems);
}
}
static _Bool List_Mem(var self , var obj ) 
{ 
  struct List *l ;
  var item ;
  _Bool tmp ;
  var *tmp___0 ;

  {
  l = (struct List *)self;
  item = l->head;
  while (item) {
    tmp = eq(item, obj);
    if (tmp) {
      return ((_Bool)1);
    }
    tmp___0 = List_Next(l, item);
    item = *tmp___0;
  }
  return ((_Bool)0);
}
}
static void List_Unlink(struct List *l , var item ) 
{ 
  var next ;
  var *tmp ;
  var prev ;
  var *tmp___0 ;
  var *tmp___1 ;
  var *tmp___2 ;
  var *tmp___3 ;
  var *tmp___4 ;

  {
  tmp = List_Next(l, item);
  next = *tmp;
  tmp___0 = List_Prev(l, item);
  prev = *tmp___0;
  if ((unsigned long )item == (unsigned long )l->head) {
    if ((unsigned long )item == (unsigned long )l->tail) {
      l->head = (void *)0;
      l->tail = (void *)0;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if ((unsigned long )item == (unsigned long )l->head) {
    l->head = next;
    tmp___1 = List_Prev(l, next);
    *tmp___1 = (void *)0;
  } else
  if ((unsigned long )item == (unsigned long )l->tail) {
    l->tail = prev;
    tmp___2 = List_Next(l, prev);
    *tmp___2 = (void *)0;
  } else {
    tmp___3 = List_Next(l, prev);
    *tmp___3 = next;
    tmp___4 = List_Prev(l, next);
    *tmp___4 = prev;
  }
  return;
}
}
static void List_Link(struct List *l , var item , var prev , var next ) 
{ 
  var *tmp ;
  var *tmp___0 ;
  var *tmp___1 ;
  var *tmp___2 ;

  {
  if ((unsigned long )prev == (unsigned long )((void *)0)) {
    l->head = item;
  } else {
    tmp = List_Next(l, prev);
    *tmp = item;
  }
  if ((unsigned long )next == (unsigned long )((void *)0)) {
    l->tail = item;
  } else {
    tmp___0 = List_Prev(l, next);
    *tmp___0 = item;
  }
  tmp___1 = List_Next(l, item);
  *tmp___1 = next;
  tmp___2 = List_Prev(l, item);
  *tmp___2 = prev;
  return;
}
}
static void List_Pop_At(var self , var key ) 
{ 
  struct List *l ;
  int64_t i ;
  int64_t tmp ;
  var item ;
  var tmp___0 ;

  {
  l = (struct List *)self;
  tmp = c_int(key);
  i = tmp;
  tmp___0 = List_At(l, i);
  item = tmp___0;
  List_Unlink(l, item);
  destruct(item);
  List_Free(l, item);
  (l->nitems) --;
  return;
}
}
static void List_Rem(var self , var obj ) 
{ 
  struct List *l ;
  var item ;
  _Bool tmp ;
  var *tmp___0 ;
  struct Tuple __constr_expr_600 ;
  var __constr_expr_601[2] ;
  char __constr_expr_602[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___1 ;
  var tmp___2 ;
  void *tmp___3 ;

  {
  l = (struct List *)self;
  item = l->head;
  while (item) {
    tmp = eq(item, obj);
    if (tmp) {
      List_Unlink(l, item);
      destruct(item);
      List_Free(l, item);
      (l->nitems) --;
      return;
    }
    tmp___0 = List_Next(l, item);
    item = *tmp___0;
  }
  __constr_expr_601[0] = obj;
  __constr_expr_601[1] = Terminal;
  __constr_expr_600.items = __constr_expr_601;
  __constr_expr_602[0] = (char)0;
  tmp___1 = 1U;
  while (! (tmp___1 >= 32U)) {
    __constr_expr_602[tmp___1] = (char)0;
    tmp___1 ++;
  }
  tmp___2 = header_init((var )(__constr_expr_602), Tuple, 2);
  tmp___3 = memcpy((void * __restrict  )((struct Tuple *)tmp___2), (void const   * __restrict  )(& __constr_expr_600),
                   sizeof(struct Tuple ));
  exception_throw(ValueError, "Object %$ not in List!", (var )((struct Tuple *)tmp___3));
  return;
}
}
static void List_Push(var self , var obj ) 
{ 
  struct List *l ;
  var item ;
  var tmp ;

  {
  l = (struct List *)self;
  tmp = List_Alloc(l);
  item = tmp;
  assign(item, obj);
  List_Link(l, item, l->tail, (void *)0);
  (l->nitems) ++;
  return;
}
}
static void List_Push_At(var self , var obj , var key ) 
{ 
  struct List *l ;
  var item ;
  var tmp ;
  int64_t i ;
  int64_t tmp___0 ;
  var curr ;
  var tmp___1 ;
  var *tmp___2 ;

  {
  l = (struct List *)self;
  tmp = List_Alloc(l);
  item = tmp;
  assign(item, obj);
  tmp___0 = c_int(key);
  i = tmp___0;
  if (i == 0L) {
    List_Link(l, item, (void *)0, l->head);
  } else {
    tmp___1 = List_At(l, i);
    curr = tmp___1;
    tmp___2 = List_Prev(l, curr);
    List_Link(l, item, *tmp___2, curr);
  }
  (l->nitems) ++;
  return;
}
}
static void List_Pop(var self ) 
{ 
  struct List *l ;
  struct Tuple __constr_expr_603 ;
  var __constr_expr_604[1] ;
  char __constr_expr_605[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  var item ;

  {
  l = (struct List *)self;
  if (l->nitems == 0UL) {
    __constr_expr_604[0] = Terminal;
    __constr_expr_603.items = __constr_expr_604;
    __constr_expr_605[0] = (char)0;
    tmp = 1U;
    while (! (tmp >= 32U)) {
      __constr_expr_605[tmp] = (char)0;
      tmp ++;
    }
    tmp___0 = header_init((var )(__constr_expr_605), Tuple, 2);
    tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_603),
                     sizeof(struct Tuple ));
    exception_throw(IndexOutOfBoundsError, "Cannot pop. List is empty!", (var )((struct Tuple *)tmp___1));
    return;
  }
  item = l->tail;
  List_Unlink(l, item);
  destruct(item);
  List_Free(l, item);
  (l->nitems) --;
  return;
}
}
static var List_Get(var self , var key ) 
{ 
  struct List *l ;
  int64_t tmp ;
  var tmp___0 ;

  {
  l = (struct List *)self;
  tmp = c_int(key);
  tmp___0 = List_At(l, tmp);
  return (tmp___0);
}
}
static void List_Set(var self , var key , var val ) 
{ 
  struct List *l ;
  int64_t tmp ;
  var tmp___0 ;

  {
  l = (struct List *)self;
  tmp = c_int(key);
  tmp___0 = List_At(l, tmp);
  assign(tmp___0, val);
  return;
}
}
static var List_Iter_Init(var self ) 
{ 
  struct List *l ;

  {
  l = (struct List *)self;
  if (l->nitems == 0UL) {
    return (Terminal);
  }
  return (l->head);
}
}
static var List_Iter_Next(var self , var curr ) 
{ 
  struct List *l ;
  var *tmp ;
  var tmp___0 ;

  {
  l = (struct List *)self;
  tmp = List_Next(l, curr);
  curr = *tmp;
  if (curr) {
    tmp___0 = curr;
  } else {
    tmp___0 = Terminal;
  }
  return (tmp___0);
}
}
static var List_Iter_Last(var self ) 
{ 
  struct List *l ;

  {
  l = (struct List *)self;
  if (l->nitems == 0UL) {
    return (Terminal);
  }
  return (l->tail);
}
}
static var List_Iter_Prev(var self , var curr ) 
{ 
  struct List *l ;
  var *tmp ;
  var tmp___0 ;

  {
  l = (struct List *)self;
  tmp = List_Prev(l, curr);
  curr = *tmp;
  if (curr) {
    tmp___0 = curr;
  } else {
    tmp___0 = Terminal;
  }
  return (tmp___0);
}
}
static var List_Iter_Type(var self ) 
{ 
  struct List *l ;

  {
  l = (struct List *)self;
  return (l->type);
}
}
static int List_Show(var self , var output , int pos ) 
{ 
  struct List *l ;
  struct Tuple __constr_expr_606 ;
  var __constr_expr_607[2] ;
  char __constr_expr_608[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  var item ;
  struct Tuple __constr_expr_609 ;
  var __constr_expr_610[2] ;
  char __constr_expr_611[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___2 ;
  var tmp___3 ;
  void *tmp___4 ;
  var *tmp___5 ;
  struct Tuple __constr_expr_612 ;
  var __constr_expr_613[1] ;
  char __constr_expr_614[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___6 ;
  var tmp___7 ;
  void *tmp___8 ;
  struct Tuple __constr_expr_615 ;
  var __constr_expr_616[1] ;
  char __constr_expr_617[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___9 ;
  var tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;

  {
  l = (struct List *)self;
  __constr_expr_607[0] = self;
  __constr_expr_607[1] = Terminal;
  __constr_expr_606.items = __constr_expr_607;
  __constr_expr_608[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_608[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_608), Tuple, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_606),
                   sizeof(struct Tuple ));
  pos = print_to_with(output, pos, "<\'List\' At 0x%p [", (var )((struct Tuple *)tmp___1));
  item = l->head;
  while (item) {
    __constr_expr_610[0] = item;
    __constr_expr_610[1] = Terminal;
    __constr_expr_609.items = __constr_expr_610;
    __constr_expr_611[0] = (char)0;
    tmp___2 = 1U;
    while (! (tmp___2 >= 32U)) {
      __constr_expr_611[tmp___2] = (char)0;
      tmp___2 ++;
    }
    tmp___3 = header_init((var )(__constr_expr_611), Tuple, 2);
    tmp___4 = memcpy((void * __restrict  )((struct Tuple *)tmp___3), (void const   * __restrict  )(& __constr_expr_609),
                     sizeof(struct Tuple ));
    pos = print_to_with(output, pos, "%$", (var )((struct Tuple *)tmp___4));
    tmp___5 = List_Next(l, item);
    item = *tmp___5;
    if (item) {
      __constr_expr_613[0] = Terminal;
      __constr_expr_612.items = __constr_expr_613;
      __constr_expr_614[0] = (char)0;
      tmp___6 = 1U;
      while (! (tmp___6 >= 32U)) {
        __constr_expr_614[tmp___6] = (char)0;
        tmp___6 ++;
      }
      tmp___7 = header_init((var )(__constr_expr_614), Tuple, 2);
      tmp___8 = memcpy((void * __restrict  )((struct Tuple *)tmp___7), (void const   * __restrict  )(& __constr_expr_612),
                       sizeof(struct Tuple ));
      pos = print_to_with(output, pos, ", ", (var )((struct Tuple *)tmp___8));
    }
  }
  __constr_expr_616[0] = Terminal;
  __constr_expr_615.items = __constr_expr_616;
  __constr_expr_617[0] = (char)0;
  tmp___9 = 1U;
  while (! (tmp___9 >= 32U)) {
    __constr_expr_617[tmp___9] = (char)0;
    tmp___9 ++;
  }
  tmp___10 = header_init((var )(__constr_expr_617), Tuple, 2);
  tmp___11 = memcpy((void * __restrict  )((struct Tuple *)tmp___10), (void const   * __restrict  )(& __constr_expr_615),
                    sizeof(struct Tuple ));
  tmp___12 = print_to_with(output, pos, "]>", (var )((struct Tuple *)tmp___11));
  return (tmp___12);
}
}
static void List_Resize(var self , size_t n ) 
{ 
  struct List *l ;
  var item ;
  var item___0 ;
  var tmp ;

  {
  l = (struct List *)self;
  if (n == 0UL) {
    List_Clear(self);
    return;
  }
  while (n < l->nitems) {
    item = l->tail;
    List_Unlink(l, item);
    destruct(item);
    List_Free(l, item);
    (l->nitems) --;
  }
  while (n > l->nitems) {
    tmp = List_Alloc(l);
    item___0 = tmp;
    List_Link(l, item___0, l->tail, (void *)0);
    (l->nitems) ++;
  }
  return;
}
}
static void List_Mark(var self , var gc , void (*f)(var  , void * ) ) 
{ 
  struct List *l ;
  var item ;
  var *tmp ;

  {
  l = (struct List *)self;
  item = l->head;
  while (item) {
    (*f)(gc, item);
    tmp = List_Next(l, item);
    item = *tmp;
  }
  return;
}
}
static struct Doc __constr_expr_619  =    {& List_Name, & List_Brief, & List_Description, (char const   *(*)(void))((void *)0),
    & List_Examples, (struct Method *(*)(void))((void *)0)};
static struct New __constr_expr_620  =    {& List_New, & List_Del};
static struct Assign __constr_expr_621  =    {& List_Assign};
static struct Mark __constr_expr_622  =    {& List_Mark};
static struct Cmp __constr_expr_623  =    {& List_Cmp};
static struct Hash __constr_expr_624  =    {& List_Hash};
static struct Push __constr_expr_625  =    {& List_Push, & List_Pop, & List_Push_At, & List_Pop_At};
static struct Concat __constr_expr_626  =    {& List_Concat, & List_Push};
static struct Len __constr_expr_627  =    {& List_Len};
static struct Get __constr_expr_628  =    {& List_Get, & List_Set, & List_Mem, & List_Rem, (var (*)(var  ))0, (var (*)(var  ))0};
static struct Iter __constr_expr_629  =    {& List_Iter_Init,
    & List_Iter_Next, & List_Iter_Last, & List_Iter_Prev, & List_Iter_Type};
static struct Show __constr_expr_630  =    {& List_Show, (int (*)(var  , var  , int  ))((void *)0)};
static struct Resize __constr_expr_631  =    {& List_Resize};
static var __constr_expr_618[69]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"List", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct List ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_619),      (void *)0,      (var )"New", 
        (var )(& __constr_expr_620),      (void *)0,      (var )"Assign",      (var )(& __constr_expr_621), 
        (void *)0,      (var )"Mark",      (var )(& __constr_expr_622),      (void *)0, 
        (var )"Cmp",      (var )(& __constr_expr_623),      (void *)0,      (var )"Hash", 
        (var )(& __constr_expr_624),      (void *)0,      (var )"Push",      (var )(& __constr_expr_625), 
        (void *)0,      (var )"Concat",      (var )(& __constr_expr_626),      (void *)0, 
        (var )"Len",      (var )(& __constr_expr_627),      (void *)0,      (var )"Get", 
        (var )(& __constr_expr_628),      (void *)0,      (var )"Iter",      (var )(& __constr_expr_629), 
        (void *)0,      (var )"Show",      (var )(& __constr_expr_630),      (void *)0, 
        (var )"Resize",      (var )(& __constr_expr_631),      (void *)0,      (void *)0, 
        (void *)0};
var List  =    (var )((char *)(__constr_expr_618) + sizeof(struct Header ));
#pragma merger("0","/tmp/cil-b9qCK3M0.i","-std=gnu99,-Wall,-Wno-unused,-g,-ggdb,-fPIC")
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
static char const   *Tuple_Name(void) 
{ 


  {
  return ("Tuple");
}
}
static char const   *Tuple_Brief(void) 
{ 


  {
  return ("Basic Collection");
}
}
static char const   *Tuple_Description(void) 
{ 


  {
  return ("The `Tuple` type provides a basic way to create a simple collection of objects. Its main use is the fact that it can be constructed on the stack using the `tuple` macro. This makes it suitable for a number of purposes such as use in functions that take a variable number of arguments.\n\nTuples can also be constructed on the heap and stored in collections. This makes them also useful as a simple _untyped_ list of objects.\n\nInternally Tuples are just an array of pointers terminated with a pointer to the Cello `Terminal` object. This makes positional access fast, but many other operations slow including iteration and counting the number of elements. Due to this it is only recommended Tuples are used for small collections. \n\nBecause Tuples are terminated with the Cello `Terminal` object this can\'t naturally be included within them. This object should therefore only be returned from iteration functions.");
}
}
static char const   *Tuple_Definition(void) 
{ 


  {
  return ("struct Tuple {\n  var* items;\n};\n");
}
}
static struct Example *Tuple_Examples(void) ;
static struct Example examples___21[2]  = {      {"Usage", "var x = tuple($I(100), $I(200), $S(\"Hello\"));\nshow(x);\nvar y = tuple(Int, $I(10), $I(20));\nvar z = new_with(Array, y);\nshow(z);\n\nforeach (item in x) {\n  println(\"%$\", item);\n}\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Tuple_Examples(void) 
{ 


  {
  return (examples___21);
}
}
static struct Method *Tuple_Methods(void) ;
static struct Method methods___18[2]  = {      {"tuple", "#define tuple(...)", "Construct a `Tuple` object on the stack."}, 
        {(char const   *)((void *)0), (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Tuple_Methods(void) 
{ 


  {
  return (methods___18);
}
}
static void Tuple_New(var self , var args ) 
{ 
  struct Tuple *t ;
  size_t nargs ;
  size_t tmp ;
  void *tmp___0 ;
  struct Tuple __constr_expr_632 ;
  var __constr_expr_633[1] ;
  char __constr_expr_634[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___1 ;
  var tmp___2 ;
  void *tmp___3 ;
  size_t i ;
  struct Int __constr_expr_635 ;
  char __constr_expr_636[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___4 ;
  var tmp___5 ;
  void *tmp___6 ;

  {
  t = (struct Tuple *)self;
  tmp = len(args);
  nargs = tmp;
  tmp___0 = malloc(sizeof(var ) * (nargs + 1UL));
  t->items = (var *)tmp___0;
  if ((unsigned long )t->items == (unsigned long )((void *)0)) {
    __constr_expr_633[0] = Terminal;
    __constr_expr_632.items = __constr_expr_633;
    __constr_expr_634[0] = (char)0;
    tmp___1 = 1U;
    while (! (tmp___1 >= 32U)) {
      __constr_expr_634[tmp___1] = (char)0;
      tmp___1 ++;
    }
    tmp___2 = header_init((var )(__constr_expr_634), Tuple, 2);
    tmp___3 = memcpy((void * __restrict  )((struct Tuple *)tmp___2), (void const   * __restrict  )(& __constr_expr_632),
                     sizeof(struct Tuple ));
    exception_throw(OutOfMemoryError, "Cannot create Tuple, out of memory!", (var )((struct Tuple *)tmp___3));
  }
  i = (size_t )0;
  while (i < nargs) {
    __constr_expr_635.val = (int64_t )i;
    __constr_expr_636[0] = (char)0;
    tmp___4 = 1U;
    while (! (tmp___4 >= 32U)) {
      __constr_expr_636[tmp___4] = (char)0;
      tmp___4 ++;
    }
    tmp___5 = header_init((var )(__constr_expr_636), Int, 2);
    tmp___6 = memcpy((void * __restrict  )((struct Int *)tmp___5), (void const   * __restrict  )(& __constr_expr_635),
                     sizeof(struct Int ));
    *(t->items + i) = get(args, (var )((struct Int *)tmp___6));
    i ++;
  }
  *(t->items + nargs) = Terminal;
  return;
}
}
static void Tuple_Del(var self ) 
{ 
  struct Tuple *t ;
  struct Tuple __constr_expr_637 ;
  var __constr_expr_638[1] ;
  char __constr_expr_639[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  struct Header *tmp___2 ;
  struct Header *tmp___3 ;

  {
  t = (struct Tuple *)self;
  tmp___2 = header(self);
  if ((unsigned long )tmp___2->alloc == (unsigned long )((var )2)) {
    goto _L;
  } else {
    tmp___3 = header(self);
    if ((unsigned long )tmp___3->alloc == (unsigned long )((var )1)) {
      _L: /* CIL Label */ 
      __constr_expr_638[0] = Terminal;
      __constr_expr_637.items = __constr_expr_638;
      __constr_expr_639[0] = (char)0;
      tmp = 1U;
      while (! (tmp >= 32U)) {
        __constr_expr_639[tmp] = (char)0;
        tmp ++;
      }
      tmp___0 = header_init((var )(__constr_expr_639), Tuple, 2);
      tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_637),
                       sizeof(struct Tuple ));
      exception_throw(ValueError, "Cannot destruct Tuple, not on heap!", (var )((struct Tuple *)tmp___1));
    }
  }
  free((void *)t->items);
  return;
}
}
static void Tuple_Push(var self , var obj ) ;
static void Tuple_Assign(var self , var obj ) 
{ 
  struct Tuple *t ;
  size_t nargs ;
  size_t tmp ;
  struct Tuple __constr_expr_640 ;
  var __constr_expr_641[1] ;
  char __constr_expr_642[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;
  struct Header *tmp___3 ;
  struct Header *tmp___4 ;
  void *tmp___5 ;
  struct Tuple __constr_expr_643 ;
  var __constr_expr_644[1] ;
  char __constr_expr_645[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___6 ;
  var tmp___7 ;
  void *tmp___8 ;
  size_t i ;
  struct Int __constr_expr_646 ;
  char __constr_expr_647[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___9 ;
  var tmp___10 ;
  void *tmp___11 ;
  var __item ;
  var __Iteritem ;
  var tmp___12 ;
  var item ;
  var tmp___13 ;
  _Bool tmp___14 ;
  _Bool tmp___15 ;

  {
  t = (struct Tuple *)self;
  tmp___14 = implements_method_at_offset(obj, Len, (unsigned long )(& ((struct Len *)0)->len));
  if (tmp___14) {
    tmp___15 = implements_method_at_offset(obj, Get, (unsigned long )(& ((struct Get *)0)->get));
    if (tmp___15) {
      tmp = len(obj);
      nargs = tmp;
      tmp___3 = header(self);
      if ((unsigned long )tmp___3->alloc == (unsigned long )((var )2)) {
        goto _L;
      } else {
        tmp___4 = header(self);
        if ((unsigned long )tmp___4->alloc == (unsigned long )((var )1)) {
          _L: /* CIL Label */ 
          __constr_expr_641[0] = Terminal;
          __constr_expr_640.items = __constr_expr_641;
          __constr_expr_642[0] = (char)0;
          tmp___0 = 1U;
          while (! (tmp___0 >= 32U)) {
            __constr_expr_642[tmp___0] = (char)0;
            tmp___0 ++;
          }
          tmp___1 = header_init((var )(__constr_expr_642), Tuple, 2);
          tmp___2 = memcpy((void * __restrict  )((struct Tuple *)tmp___1), (void const   * __restrict  )(& __constr_expr_640),
                           sizeof(struct Tuple ));
          exception_throw(ValueError, "Cannot reallocate Tuple, not on heap!", (var )((struct Tuple *)tmp___2));
        }
      }
      tmp___5 = realloc((void *)t->items, sizeof(var ) * (nargs + 1UL));
      t->items = (var *)tmp___5;
      if ((unsigned long )t->items == (unsigned long )((void *)0)) {
        __constr_expr_644[0] = Terminal;
        __constr_expr_643.items = __constr_expr_644;
        __constr_expr_645[0] = (char)0;
        tmp___6 = 1U;
        while (! (tmp___6 >= 32U)) {
          __constr_expr_645[tmp___6] = (char)0;
          tmp___6 ++;
        }
        tmp___7 = header_init((var )(__constr_expr_645), Tuple, 2);
        tmp___8 = memcpy((void * __restrict  )((struct Tuple *)tmp___7), (void const   * __restrict  )(& __constr_expr_643),
                         sizeof(struct Tuple ));
        exception_throw(OutOfMemoryError, "Cannot allocate Tuple, out of memory!",
                        (var )((struct Tuple *)tmp___8));
      }
      i = (size_t )0;
      while (i < nargs) {
        __constr_expr_646.val = (int64_t )i;
        __constr_expr_647[0] = (char)0;
        tmp___9 = 1U;
        while (! (tmp___9 >= 32U)) {
          __constr_expr_647[tmp___9] = (char)0;
          tmp___9 ++;
        }
        tmp___10 = header_init((var )(__constr_expr_647), Int, 2);
        tmp___11 = memcpy((void * __restrict  )((struct Int *)tmp___10), (void const   * __restrict  )(& __constr_expr_646),
                          sizeof(struct Int ));
        *(t->items + i) = get(obj, (var )((struct Int *)tmp___11));
        i ++;
      }
      *(t->items + nargs) = Terminal;
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    __item = obj;
    tmp___12 = instance(__item, Iter);
    __Iteritem = tmp___12;
    tmp___13 = (*(((struct Iter *)__Iteritem)->iter_init))(__item);
    item = tmp___13;
    while ((unsigned long )item != (unsigned long )Terminal) {
      Tuple_Push(self, item);
      item = (*(((struct Iter *)__Iteritem)->iter_next))(__item, item);
    }
  }
  return;
}
}
static size_t Tuple_Len(var self ) 
{ 
  struct Tuple *t ;
  size_t i ;

  {
  t = (struct Tuple *)self;
  i = (size_t )0;
  while (1) {
    if (t->items) {
      if (! ((unsigned long )*(t->items + i) != (unsigned long )Terminal)) {
        break;
      }
    } else {
      break;
    }
    i ++;
  }
  return (i);
}
}
static var Tuple_Iter_Init(var self ) 
{ 
  struct Tuple *t ;

  {
  t = (struct Tuple *)self;
  return (*(t->items + 0));
}
}
static var Tuple_Iter_Next(var self , var curr ) 
{ 
  struct Tuple *t ;
  size_t i ;

  {
  t = (struct Tuple *)self;
  i = (size_t )0;
  while ((unsigned long )*(t->items + i) != (unsigned long )Terminal) {
    if ((unsigned long )*(t->items + i) == (unsigned long )curr) {
      return (*(t->items + (i + 1UL)));
    }
    i ++;
  }
  return (Terminal);
}
}
static var Tuple_Iter_Last(var self ) 
{ 
  struct Tuple *t ;
  size_t tmp ;

  {
  t = (struct Tuple *)self;
  tmp = Tuple_Len((var )t);
  return (*(t->items + (tmp - 1UL)));
}
}
static var Tuple_Iter_Prev(var self , var curr ) 
{ 
  struct Tuple *t ;
  size_t i ;

  {
  t = (struct Tuple *)self;
  if ((unsigned long )curr == (unsigned long )*(t->items + 0)) {
    return (Terminal);
  }
  i = (size_t )0;
  while ((unsigned long )*(t->items + i) != (unsigned long )Terminal) {
    if ((unsigned long )*(t->items + i) == (unsigned long )curr) {
      return (*(t->items + (i - 1UL)));
    }
    i ++;
  }
  return (Terminal);
}
}
static var Tuple_Get(var self , var key ) 
{ 
  struct Tuple *t ;
  size_t nitems ;
  size_t tmp ;
  int64_t i ;
  int64_t tmp___0 ;
  struct Tuple __constr_expr_648 ;
  var __constr_expr_649[3] ;
  struct Int __constr_expr_650 ;
  size_t tmp___1 ;
  char __constr_expr_651[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___2 ;
  var tmp___3 ;
  void *tmp___4 ;
  char __constr_expr_652[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___5 ;
  var tmp___6 ;
  void *tmp___7 ;
  var tmp___8 ;

  {
  t = (struct Tuple *)self;
  tmp = Tuple_Len((var )t);
  nitems = tmp;
  tmp___0 = c_int(key);
  i = tmp___0;
  if (i < 0L) {
    i = (int64_t )(nitems + (size_t )i);
  } else {
    i = i;
  }
  if (i < 0L) {
    goto _L;
  } else
  if (i >= (int64_t )nitems) {
    _L: /* CIL Label */ 
    tmp___1 = Tuple_Len((var )t);
    __constr_expr_650.val = (int64_t )tmp___1;
    __constr_expr_651[0] = (char)0;
    tmp___2 = 1U;
    while (! (tmp___2 >= 32U)) {
      __constr_expr_651[tmp___2] = (char)0;
      tmp___2 ++;
    }
    tmp___3 = header_init((var )(__constr_expr_651), Int, 2);
    tmp___4 = memcpy((void * __restrict  )((struct Int *)tmp___3), (void const   * __restrict  )(& __constr_expr_650),
                     sizeof(struct Int ));
    __constr_expr_649[0] = key;
    __constr_expr_649[1] = (var )((struct Int *)tmp___4);
    __constr_expr_649[2] = Terminal;
    __constr_expr_648.items = __constr_expr_649;
    __constr_expr_652[0] = (char)0;
    tmp___5 = 1U;
    while (! (tmp___5 >= 32U)) {
      __constr_expr_652[tmp___5] = (char)0;
      tmp___5 ++;
    }
    tmp___6 = header_init((var )(__constr_expr_652), Tuple, 2);
    tmp___7 = memcpy((void * __restrict  )((struct Tuple *)tmp___6), (void const   * __restrict  )(& __constr_expr_648),
                     sizeof(struct Tuple ));
    tmp___8 = exception_throw(IndexOutOfBoundsError, "Index \'%i\' out of bounds for Tuple of size %i.",
                              (var )((struct Tuple *)tmp___7));
    return (tmp___8);
  }
  return (*(t->items + i));
}
}
static void Tuple_Set(var self , var key , var val ) 
{ 
  struct Tuple *t ;
  size_t nitems ;
  size_t tmp ;
  int64_t i ;
  int64_t tmp___0 ;
  struct Tuple __constr_expr_653 ;
  var __constr_expr_654[3] ;
  struct Int __constr_expr_655 ;
  size_t tmp___1 ;
  char __constr_expr_656[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___2 ;
  var tmp___3 ;
  void *tmp___4 ;
  char __constr_expr_657[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___5 ;
  var tmp___6 ;
  void *tmp___7 ;

  {
  t = (struct Tuple *)self;
  tmp = Tuple_Len((var )t);
  nitems = tmp;
  tmp___0 = c_int(key);
  i = tmp___0;
  if (i < 0L) {
    i = (int64_t )(nitems + (size_t )i);
  } else {
    i = i;
  }
  if (i < 0L) {
    goto _L;
  } else
  if (i >= (int64_t )nitems) {
    _L: /* CIL Label */ 
    tmp___1 = Tuple_Len((var )t);
    __constr_expr_655.val = (int64_t )tmp___1;
    __constr_expr_656[0] = (char)0;
    tmp___2 = 1U;
    while (! (tmp___2 >= 32U)) {
      __constr_expr_656[tmp___2] = (char)0;
      tmp___2 ++;
    }
    tmp___3 = header_init((var )(__constr_expr_656), Int, 2);
    tmp___4 = memcpy((void * __restrict  )((struct Int *)tmp___3), (void const   * __restrict  )(& __constr_expr_655),
                     sizeof(struct Int ));
    __constr_expr_654[0] = key;
    __constr_expr_654[1] = (var )((struct Int *)tmp___4);
    __constr_expr_654[2] = Terminal;
    __constr_expr_653.items = __constr_expr_654;
    __constr_expr_657[0] = (char)0;
    tmp___5 = 1U;
    while (! (tmp___5 >= 32U)) {
      __constr_expr_657[tmp___5] = (char)0;
      tmp___5 ++;
    }
    tmp___6 = header_init((var )(__constr_expr_657), Tuple, 2);
    tmp___7 = memcpy((void * __restrict  )((struct Tuple *)tmp___6), (void const   * __restrict  )(& __constr_expr_653),
                     sizeof(struct Tuple ));
    exception_throw(IndexOutOfBoundsError, "Index \'%i\' out of bounds for Tuple of size %i.",
                    (var )((struct Tuple *)tmp___7));
    return;
  }
  *(t->items + i) = val;
  return;
}
}
static _Bool Tuple_Mem(var self , var item ) 
{ 
  var __obj ;
  var __Iterobj ;
  var tmp ;
  var obj ;
  var tmp___0 ;
  _Bool tmp___1 ;

  {
  __obj = self;
  tmp = instance(__obj, Iter);
  __Iterobj = tmp;
  tmp___0 = (*(((struct Iter *)__Iterobj)->iter_init))(__obj);
  obj = tmp___0;
  while ((unsigned long )obj != (unsigned long )Terminal) {
    tmp___1 = eq(obj, item);
    if (tmp___1) {
      return ((_Bool)1);
    }
    obj = (*(((struct Iter *)__Iterobj)->iter_next))(__obj, obj);
  }
  return ((_Bool)0);
}
}
static void Tuple_Pop_At(var self , var key ) ;
static void Tuple_Rem(var self , var item ) 
{ 
  struct Tuple *t ;
  size_t i ;
  struct Int __constr_expr_658 ;
  char __constr_expr_659[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  _Bool tmp___2 ;

  {
  t = (struct Tuple *)self;
  i = (size_t )0;
  while ((unsigned long )*(t->items + i) != (unsigned long )Terminal) {
    tmp___2 = eq(item, *(t->items + i));
    if (tmp___2) {
      __constr_expr_658.val = (int64_t )i;
      __constr_expr_659[0] = (char)0;
      tmp = 1U;
      while (! (tmp >= 32U)) {
        __constr_expr_659[tmp] = (char)0;
        tmp ++;
      }
      tmp___0 = header_init((var )(__constr_expr_659), Int, 2);
      tmp___1 = memcpy((void * __restrict  )((struct Int *)tmp___0), (void const   * __restrict  )(& __constr_expr_658),
                       sizeof(struct Int ));
      Tuple_Pop_At(self, (var )((struct Int *)tmp___1));
      return;
    }
    i ++;
  }
  return;
}
}
static int Tuple_Show(var self , var output , int pos ) 
{ 
  struct Tuple *t ;
  struct Tuple __constr_expr_660 ;
  var __constr_expr_661[2] ;
  char __constr_expr_662[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  size_t i ;
  struct Tuple __constr_expr_663 ;
  var __constr_expr_664[2] ;
  char __constr_expr_665[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___2 ;
  var tmp___3 ;
  void *tmp___4 ;
  struct Tuple __constr_expr_666 ;
  var __constr_expr_667[1] ;
  char __constr_expr_668[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___5 ;
  var tmp___6 ;
  void *tmp___7 ;
  struct Tuple __constr_expr_669 ;
  var __constr_expr_670[1] ;
  char __constr_expr_671[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___8 ;
  var tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;

  {
  t = (struct Tuple *)self;
  __constr_expr_661[0] = self;
  __constr_expr_661[1] = Terminal;
  __constr_expr_660.items = __constr_expr_661;
  __constr_expr_662[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_662[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_662), Tuple, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_660),
                   sizeof(struct Tuple ));
  pos = print_to_with(output, pos, "tuple(", (var )((struct Tuple *)tmp___1));
  i = (size_t )0;
  while ((unsigned long )*(t->items + i) != (unsigned long )Terminal) {
    __constr_expr_664[0] = *(t->items + i);
    __constr_expr_664[1] = Terminal;
    __constr_expr_663.items = __constr_expr_664;
    __constr_expr_665[0] = (char)0;
    tmp___2 = 1U;
    while (! (tmp___2 >= 32U)) {
      __constr_expr_665[tmp___2] = (char)0;
      tmp___2 ++;
    }
    tmp___3 = header_init((var )(__constr_expr_665), Tuple, 2);
    tmp___4 = memcpy((void * __restrict  )((struct Tuple *)tmp___3), (void const   * __restrict  )(& __constr_expr_663),
                     sizeof(struct Tuple ));
    pos = print_to_with(output, pos, "%$", (var )((struct Tuple *)tmp___4));
    if ((unsigned long )*(t->items + (i + 1UL)) != (unsigned long )Terminal) {
      __constr_expr_667[0] = Terminal;
      __constr_expr_666.items = __constr_expr_667;
      __constr_expr_668[0] = (char)0;
      tmp___5 = 1U;
      while (! (tmp___5 >= 32U)) {
        __constr_expr_668[tmp___5] = (char)0;
        tmp___5 ++;
      }
      tmp___6 = header_init((var )(__constr_expr_668), Tuple, 2);
      tmp___7 = memcpy((void * __restrict  )((struct Tuple *)tmp___6), (void const   * __restrict  )(& __constr_expr_666),
                       sizeof(struct Tuple ));
      pos = print_to_with(output, pos, ", ", (var )((struct Tuple *)tmp___7));
    }
    i ++;
  }
  __constr_expr_670[0] = Terminal;
  __constr_expr_669.items = __constr_expr_670;
  __constr_expr_671[0] = (char)0;
  tmp___8 = 1U;
  while (! (tmp___8 >= 32U)) {
    __constr_expr_671[tmp___8] = (char)0;
    tmp___8 ++;
  }
  tmp___9 = header_init((var )(__constr_expr_671), Tuple, 2);
  tmp___10 = memcpy((void * __restrict  )((struct Tuple *)tmp___9), (void const   * __restrict  )(& __constr_expr_669),
                    sizeof(struct Tuple ));
  tmp___11 = print_to_with(output, pos, ")", (var )((struct Tuple *)tmp___10));
  return (tmp___11);
}
}
static void Tuple_Push(var self , var obj ) 
{ 
  struct Tuple *t ;
  size_t nitems ;
  size_t tmp ;
  struct Tuple __constr_expr_672 ;
  var __constr_expr_673[1] ;
  char __constr_expr_674[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;
  struct Header *tmp___3 ;
  struct Header *tmp___4 ;
  void *tmp___5 ;
  struct Tuple __constr_expr_675 ;
  var __constr_expr_676[1] ;
  char __constr_expr_677[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___6 ;
  var tmp___7 ;
  void *tmp___8 ;

  {
  t = (struct Tuple *)self;
  tmp = Tuple_Len((var )t);
  nitems = tmp;
  tmp___3 = header(self);
  if ((unsigned long )tmp___3->alloc == (unsigned long )((var )2)) {
    goto _L;
  } else {
    tmp___4 = header(self);
    if ((unsigned long )tmp___4->alloc == (unsigned long )((var )1)) {
      _L: /* CIL Label */ 
      __constr_expr_673[0] = Terminal;
      __constr_expr_672.items = __constr_expr_673;
      __constr_expr_674[0] = (char)0;
      tmp___0 = 1U;
      while (! (tmp___0 >= 32U)) {
        __constr_expr_674[tmp___0] = (char)0;
        tmp___0 ++;
      }
      tmp___1 = header_init((var )(__constr_expr_674), Tuple, 2);
      tmp___2 = memcpy((void * __restrict  )((struct Tuple *)tmp___1), (void const   * __restrict  )(& __constr_expr_672),
                       sizeof(struct Tuple ));
      exception_throw(ValueError, "Cannot reallocate Tuple, not on heap!", (var )((struct Tuple *)tmp___2));
    }
  }
  tmp___5 = realloc((void *)t->items, sizeof(var ) * (nitems + 2UL));
  t->items = (var *)tmp___5;
  if ((unsigned long )t->items == (unsigned long )((void *)0)) {
    __constr_expr_676[0] = Terminal;
    __constr_expr_675.items = __constr_expr_676;
    __constr_expr_677[0] = (char)0;
    tmp___6 = 1U;
    while (! (tmp___6 >= 32U)) {
      __constr_expr_677[tmp___6] = (char)0;
      tmp___6 ++;
    }
    tmp___7 = header_init((var )(__constr_expr_677), Tuple, 2);
    tmp___8 = memcpy((void * __restrict  )((struct Tuple *)tmp___7), (void const   * __restrict  )(& __constr_expr_675),
                     sizeof(struct Tuple ));
    exception_throw(OutOfMemoryError, "Cannot grow Tuple, out of memory!", (var )((struct Tuple *)tmp___8));
  }
  *(t->items + nitems) = obj;
  *(t->items + (nitems + 1UL)) = Terminal;
  return;
}
}
static void Tuple_Pop(var self ) 
{ 
  struct Tuple *t ;
  size_t nitems ;
  size_t tmp ;
  struct Tuple __constr_expr_678 ;
  var __constr_expr_679[1] ;
  char __constr_expr_680[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;
  struct Tuple __constr_expr_681 ;
  var __constr_expr_682[1] ;
  char __constr_expr_683[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;
  struct Header *tmp___6 ;
  struct Header *tmp___7 ;
  void *tmp___8 ;

  {
  t = (struct Tuple *)self;
  tmp = Tuple_Len((var )t);
  nitems = tmp;
  if (nitems == 0UL) {
    __constr_expr_679[0] = Terminal;
    __constr_expr_678.items = __constr_expr_679;
    __constr_expr_680[0] = (char)0;
    tmp___0 = 1U;
    while (! (tmp___0 >= 32U)) {
      __constr_expr_680[tmp___0] = (char)0;
      tmp___0 ++;
    }
    tmp___1 = header_init((var )(__constr_expr_680), Tuple, 2);
    tmp___2 = memcpy((void * __restrict  )((struct Tuple *)tmp___1), (void const   * __restrict  )(& __constr_expr_678),
                     sizeof(struct Tuple ));
    exception_throw(IndexOutOfBoundsError, "Cannot pop. Tuple is empty!", (var )((struct Tuple *)tmp___2));
    return;
  }
  tmp___6 = header(self);
  if ((unsigned long )tmp___6->alloc == (unsigned long )((var )2)) {
    goto _L;
  } else {
    tmp___7 = header(self);
    if ((unsigned long )tmp___7->alloc == (unsigned long )((var )1)) {
      _L: /* CIL Label */ 
      __constr_expr_682[0] = Terminal;
      __constr_expr_681.items = __constr_expr_682;
      __constr_expr_683[0] = (char)0;
      tmp___3 = 1U;
      while (! (tmp___3 >= 32U)) {
        __constr_expr_683[tmp___3] = (char)0;
        tmp___3 ++;
      }
      tmp___4 = header_init((var )(__constr_expr_683), Tuple, 2);
      tmp___5 = memcpy((void * __restrict  )((struct Tuple *)tmp___4), (void const   * __restrict  )(& __constr_expr_681),
                       sizeof(struct Tuple ));
      exception_throw(ValueError, "Cannot reallocate Tuple, not on heap!", (var )((struct Tuple *)tmp___5));
    }
  }
  tmp___8 = realloc((void *)t->items, sizeof(var ) * nitems);
  t->items = (var *)tmp___8;
  *(t->items + (nitems - 1UL)) = Terminal;
  return;
}
}
static void Tuple_Push_At(var self , var obj , var key ) 
{ 
  struct Tuple *t ;
  size_t nitems ;
  size_t tmp ;
  int64_t i ;
  int64_t tmp___0 ;
  struct Tuple __constr_expr_684 ;
  var __constr_expr_685[3] ;
  struct Int __constr_expr_686 ;
  char __constr_expr_687[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___1 ;
  var tmp___2 ;
  void *tmp___3 ;
  char __constr_expr_688[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___4 ;
  var tmp___5 ;
  void *tmp___6 ;
  struct Tuple __constr_expr_689 ;
  var __constr_expr_690[1] ;
  char __constr_expr_691[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___7 ;
  var tmp___8 ;
  void *tmp___9 ;
  struct Header *tmp___10 ;
  struct Header *tmp___11 ;
  void *tmp___12 ;
  struct Tuple __constr_expr_692 ;
  var __constr_expr_693[1] ;
  char __constr_expr_694[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___13 ;
  var tmp___14 ;
  void *tmp___15 ;

  {
  t = (struct Tuple *)self;
  tmp = Tuple_Len((var )t);
  nitems = tmp;
  tmp___0 = c_int(key);
  i = tmp___0;
  if (i < 0L) {
    i = (int64_t )(nitems + (size_t )i);
  } else {
    i = i;
  }
  if (i < 0L) {
    goto _L;
  } else
  if (i >= (int64_t )nitems) {
    _L: /* CIL Label */ 
    __constr_expr_686.val = (int64_t )nitems;
    __constr_expr_687[0] = (char)0;
    tmp___1 = 1U;
    while (! (tmp___1 >= 32U)) {
      __constr_expr_687[tmp___1] = (char)0;
      tmp___1 ++;
    }
    tmp___2 = header_init((var )(__constr_expr_687), Int, 2);
    tmp___3 = memcpy((void * __restrict  )((struct Int *)tmp___2), (void const   * __restrict  )(& __constr_expr_686),
                     sizeof(struct Int ));
    __constr_expr_685[0] = key;
    __constr_expr_685[1] = (var )((struct Int *)tmp___3);
    __constr_expr_685[2] = Terminal;
    __constr_expr_684.items = __constr_expr_685;
    __constr_expr_688[0] = (char)0;
    tmp___4 = 1U;
    while (! (tmp___4 >= 32U)) {
      __constr_expr_688[tmp___4] = (char)0;
      tmp___4 ++;
    }
    tmp___5 = header_init((var )(__constr_expr_688), Tuple, 2);
    tmp___6 = memcpy((void * __restrict  )((struct Tuple *)tmp___5), (void const   * __restrict  )(& __constr_expr_684),
                     sizeof(struct Tuple ));
    exception_throw(IndexOutOfBoundsError, "Index \'%i\' out of bounds for Tuple of size %i.",
                    (var )((struct Tuple *)tmp___6));
  }
  tmp___10 = header(self);
  if ((unsigned long )tmp___10->alloc == (unsigned long )((var )2)) {
    goto _L___0;
  } else {
    tmp___11 = header(self);
    if ((unsigned long )tmp___11->alloc == (unsigned long )((var )1)) {
      _L___0: /* CIL Label */ 
      __constr_expr_690[0] = Terminal;
      __constr_expr_689.items = __constr_expr_690;
      __constr_expr_691[0] = (char)0;
      tmp___7 = 1U;
      while (! (tmp___7 >= 32U)) {
        __constr_expr_691[tmp___7] = (char)0;
        tmp___7 ++;
      }
      tmp___8 = header_init((var )(__constr_expr_691), Tuple, 2);
      tmp___9 = memcpy((void * __restrict  )((struct Tuple *)tmp___8), (void const   * __restrict  )(& __constr_expr_689),
                       sizeof(struct Tuple ));
      exception_throw(ValueError, "Cannot reallocate Tuple, not on heap!", (var )((struct Tuple *)tmp___9));
    }
  }
  tmp___12 = realloc((void *)t->items, sizeof(var ) * (nitems + 2UL));
  t->items = (var *)tmp___12;
  if ((unsigned long )t->items == (unsigned long )((void *)0)) {
    __constr_expr_693[0] = Terminal;
    __constr_expr_692.items = __constr_expr_693;
    __constr_expr_694[0] = (char)0;
    tmp___13 = 1U;
    while (! (tmp___13 >= 32U)) {
      __constr_expr_694[tmp___13] = (char)0;
      tmp___13 ++;
    }
    tmp___14 = header_init((var )(__constr_expr_694), Tuple, 2);
    tmp___15 = memcpy((void * __restrict  )((struct Tuple *)tmp___14), (void const   * __restrict  )(& __constr_expr_692),
                      sizeof(struct Tuple ));
    exception_throw(OutOfMemoryError, "Cannot grow Tuple, out of memory!", (var )((struct Tuple *)tmp___15));
  }
  memmove((void *)(t->items + (i + 1L)), (void const   *)(t->items + i), sizeof(var ) * ((nitems - (size_t )i) + 1UL));
  *(t->items + i) = obj;
  return;
}
}
static void Tuple_Pop_At(var self , var key ) 
{ 
  struct Tuple *t ;
  size_t nitems ;
  size_t tmp ;
  int64_t i ;
  int64_t tmp___0 ;
  struct Tuple __constr_expr_695 ;
  var __constr_expr_696[3] ;
  struct Int __constr_expr_697 ;
  char __constr_expr_698[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___1 ;
  var tmp___2 ;
  void *tmp___3 ;
  char __constr_expr_699[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___4 ;
  var tmp___5 ;
  void *tmp___6 ;
  struct Tuple __constr_expr_700 ;
  var __constr_expr_701[1] ;
  char __constr_expr_702[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___7 ;
  var tmp___8 ;
  void *tmp___9 ;
  struct Header *tmp___10 ;
  struct Header *tmp___11 ;
  void *tmp___12 ;

  {
  t = (struct Tuple *)self;
  tmp = Tuple_Len((var )t);
  nitems = tmp;
  tmp___0 = c_int(key);
  i = tmp___0;
  if (i < 0L) {
    i = (int64_t )(nitems + (size_t )i);
  } else {
    i = i;
  }
  if (i < 0L) {
    goto _L;
  } else
  if (i >= (int64_t )nitems) {
    _L: /* CIL Label */ 
    __constr_expr_697.val = (int64_t )nitems;
    __constr_expr_698[0] = (char)0;
    tmp___1 = 1U;
    while (! (tmp___1 >= 32U)) {
      __constr_expr_698[tmp___1] = (char)0;
      tmp___1 ++;
    }
    tmp___2 = header_init((var )(__constr_expr_698), Int, 2);
    tmp___3 = memcpy((void * __restrict  )((struct Int *)tmp___2), (void const   * __restrict  )(& __constr_expr_697),
                     sizeof(struct Int ));
    __constr_expr_696[0] = key;
    __constr_expr_696[1] = (var )((struct Int *)tmp___3);
    __constr_expr_696[2] = Terminal;
    __constr_expr_695.items = __constr_expr_696;
    __constr_expr_699[0] = (char)0;
    tmp___4 = 1U;
    while (! (tmp___4 >= 32U)) {
      __constr_expr_699[tmp___4] = (char)0;
      tmp___4 ++;
    }
    tmp___5 = header_init((var )(__constr_expr_699), Tuple, 2);
    tmp___6 = memcpy((void * __restrict  )((struct Tuple *)tmp___5), (void const   * __restrict  )(& __constr_expr_695),
                     sizeof(struct Tuple ));
    exception_throw(IndexOutOfBoundsError, "Index \'%i\' out of bounds for Tuple of size %i.",
                    (var )((struct Tuple *)tmp___6));
  }
  memmove((void *)(t->items + i), (void const   *)(t->items + (i + 1L)), sizeof(var ) * (nitems - (size_t )i));
  tmp___10 = header(self);
  if ((unsigned long )tmp___10->alloc == (unsigned long )((var )2)) {
    goto _L___0;
  } else {
    tmp___11 = header(self);
    if ((unsigned long )tmp___11->alloc == (unsigned long )((var )1)) {
      _L___0: /* CIL Label */ 
      __constr_expr_701[0] = Terminal;
      __constr_expr_700.items = __constr_expr_701;
      __constr_expr_702[0] = (char)0;
      tmp___7 = 1U;
      while (! (tmp___7 >= 32U)) {
        __constr_expr_702[tmp___7] = (char)0;
        tmp___7 ++;
      }
      tmp___8 = header_init((var )(__constr_expr_702), Tuple, 2);
      tmp___9 = memcpy((void * __restrict  )((struct Tuple *)tmp___8), (void const   * __restrict  )(& __constr_expr_700),
                       sizeof(struct Tuple ));
      exception_throw(ValueError, "Cannot reallocate Tuple, not on heap!", (var )((struct Tuple *)tmp___9));
    }
  }
  tmp___12 = realloc((void *)t->items, sizeof(var ) * nitems);
  t->items = (var *)tmp___12;
  return;
}
}
static void Tuple_Concat(var self , var obj ) 
{ 
  struct Tuple *t ;
  size_t nitems ;
  size_t tmp ;
  size_t objlen ;
  size_t tmp___0 ;
  struct Tuple __constr_expr_703 ;
  var __constr_expr_704[1] ;
  char __constr_expr_705[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___1 ;
  var tmp___2 ;
  void *tmp___3 ;
  struct Header *tmp___4 ;
  struct Header *tmp___5 ;
  void *tmp___6 ;
  struct Tuple __constr_expr_706 ;
  var __constr_expr_707[1] ;
  char __constr_expr_708[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___7 ;
  var tmp___8 ;
  void *tmp___9 ;
  size_t i ;
  var __item ;
  var __Iteritem ;
  var tmp___10 ;
  var item ;
  var tmp___11 ;

  {
  t = (struct Tuple *)self;
  tmp = Tuple_Len((var )t);
  nitems = tmp;
  tmp___0 = len(obj);
  objlen = tmp___0;
  tmp___4 = header(self);
  if ((unsigned long )tmp___4->alloc == (unsigned long )((var )2)) {
    goto _L;
  } else {
    tmp___5 = header(self);
    if ((unsigned long )tmp___5->alloc == (unsigned long )((var )1)) {
      _L: /* CIL Label */ 
      __constr_expr_704[0] = Terminal;
      __constr_expr_703.items = __constr_expr_704;
      __constr_expr_705[0] = (char)0;
      tmp___1 = 1U;
      while (! (tmp___1 >= 32U)) {
        __constr_expr_705[tmp___1] = (char)0;
        tmp___1 ++;
      }
      tmp___2 = header_init((var )(__constr_expr_705), Tuple, 2);
      tmp___3 = memcpy((void * __restrict  )((struct Tuple *)tmp___2), (void const   * __restrict  )(& __constr_expr_703),
                       sizeof(struct Tuple ));
      exception_throw(ValueError, "Cannot reallocate Tuple, not on heap!", (var )((struct Tuple *)tmp___3));
    }
  }
  tmp___6 = realloc((void *)t->items, sizeof(var ) * ((nitems + 1UL) + objlen));
  t->items = (var *)tmp___6;
  if ((unsigned long )t->items == (unsigned long )((void *)0)) {
    __constr_expr_707[0] = Terminal;
    __constr_expr_706.items = __constr_expr_707;
    __constr_expr_708[0] = (char)0;
    tmp___7 = 1U;
    while (! (tmp___7 >= 32U)) {
      __constr_expr_708[tmp___7] = (char)0;
      tmp___7 ++;
    }
    tmp___8 = header_init((var )(__constr_expr_708), Tuple, 2);
    tmp___9 = memcpy((void * __restrict  )((struct Tuple *)tmp___8), (void const   * __restrict  )(& __constr_expr_706),
                     sizeof(struct Tuple ));
    exception_throw(OutOfMemoryError, "Cannot grow Tuple, out of memory!", (var )((struct Tuple *)tmp___9));
  }
  i = nitems;
  __item = obj;
  tmp___10 = instance(__item, Iter);
  __Iteritem = tmp___10;
  tmp___11 = (*(((struct Iter *)__Iteritem)->iter_init))(__item);
  item = tmp___11;
  while ((unsigned long )item != (unsigned long )Terminal) {
    *(t->items + i) = item;
    i ++;
    item = (*(((struct Iter *)__Iteritem)->iter_next))(__item, item);
  }
  *(t->items + (nitems + objlen)) = Terminal;
  return;
}
}
static void Tuple_Resize(var self , size_t n ) 
{ 
  struct Tuple *t ;
  struct Tuple __constr_expr_709 ;
  var __constr_expr_710[1] ;
  char __constr_expr_711[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  struct Header *tmp___2 ;
  struct Header *tmp___3 ;
  size_t m ;
  size_t tmp___4 ;
  void *tmp___5 ;
  struct Tuple __constr_expr_712 ;
  var __constr_expr_713[3] ;
  struct Int __constr_expr_714 ;
  char __constr_expr_715[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___6 ;
  var tmp___7 ;
  void *tmp___8 ;
  struct Int __constr_expr_716 ;
  char __constr_expr_717[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___9 ;
  var tmp___10 ;
  void *tmp___11 ;
  char __constr_expr_718[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___12 ;
  var tmp___13 ;
  void *tmp___14 ;

  {
  t = (struct Tuple *)self;
  tmp___2 = header(self);
  if ((unsigned long )tmp___2->alloc == (unsigned long )((var )2)) {
    goto _L;
  } else {
    tmp___3 = header(self);
    if ((unsigned long )tmp___3->alloc == (unsigned long )((var )1)) {
      _L: /* CIL Label */ 
      __constr_expr_710[0] = Terminal;
      __constr_expr_709.items = __constr_expr_710;
      __constr_expr_711[0] = (char)0;
      tmp = 1U;
      while (! (tmp >= 32U)) {
        __constr_expr_711[tmp] = (char)0;
        tmp ++;
      }
      tmp___0 = header_init((var )(__constr_expr_711), Tuple, 2);
      tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_709),
                       sizeof(struct Tuple ));
      exception_throw(ValueError, "Cannot reallocate Tuple, not on heap!", (var )((struct Tuple *)tmp___1));
    }
  }
  tmp___4 = Tuple_Len(self);
  m = tmp___4;
  if (n < m) {
    tmp___5 = realloc((void *)t->items, sizeof(var ) * (n + 1UL));
    t->items = (var *)tmp___5;
    *(t->items + n) = Terminal;
  } else {
    __constr_expr_714.val = (int64_t )n;
    __constr_expr_715[0] = (char)0;
    tmp___6 = 1U;
    while (! (tmp___6 >= 32U)) {
      __constr_expr_715[tmp___6] = (char)0;
      tmp___6 ++;
    }
    tmp___7 = header_init((var )(__constr_expr_715), Int, 2);
    tmp___8 = memcpy((void * __restrict  )((struct Int *)tmp___7), (void const   * __restrict  )(& __constr_expr_714),
                     sizeof(struct Int ));
    __constr_expr_716.val = (int64_t )m;
    __constr_expr_717[0] = (char)0;
    tmp___9 = 1U;
    while (! (tmp___9 >= 32U)) {
      __constr_expr_717[tmp___9] = (char)0;
      tmp___9 ++;
    }
    tmp___10 = header_init((var )(__constr_expr_717), Int, 2);
    tmp___11 = memcpy((void * __restrict  )((struct Int *)tmp___10), (void const   * __restrict  )(& __constr_expr_716),
                      sizeof(struct Int ));
    __constr_expr_713[0] = (var )((struct Int *)tmp___8);
    __constr_expr_713[1] = (var )((struct Int *)tmp___11);
    __constr_expr_713[2] = Terminal;
    __constr_expr_712.items = __constr_expr_713;
    __constr_expr_718[0] = (char)0;
    tmp___12 = 1U;
    while (! (tmp___12 >= 32U)) {
      __constr_expr_718[tmp___12] = (char)0;
      tmp___12 ++;
    }
    tmp___13 = header_init((var )(__constr_expr_718), Tuple, 2);
    tmp___14 = memcpy((void * __restrict  )((struct Tuple *)tmp___13), (void const   * __restrict  )(& __constr_expr_712),
                      sizeof(struct Tuple ));
    exception_throw(FormatError, "Cannot resize Tuple to %li as it only contains %li items",
                    (var )((struct Tuple *)tmp___14));
  }
  return;
}
}
static void Tuple_Mark(var self , var gc , void (*f)(var  , void * ) ) 
{ 
  struct Tuple *t ;
  size_t i ;

  {
  t = (struct Tuple *)self;
  i = (size_t )0;
  if ((unsigned long )t->items == (unsigned long )((void *)0)) {
    return;
  }
  while ((unsigned long )*(t->items + i) != (unsigned long )Terminal) {
    (*f)(gc, *(t->items + i));
    i ++;
  }
  return;
}
}
static void Tuple_Swap(struct Tuple *t , size_t i , size_t j ) 
{ 
  var tmp ;

  {
  tmp = *(t->items + i);
  *(t->items + i) = *(t->items + j);
  *(t->items + j) = tmp;
  return;
}
}
static size_t Tuple_Sort_Partition(struct Tuple *t , int64_t l , int64_t r , _Bool (*f)(var  ,
                                                                                        var  ) ) 
{ 
  int64_t p ;
  int64_t s ;
  int64_t i ;
  _Bool tmp ;

  {
  p = l + (r - l) / 2L;
  Tuple_Swap(t, (size_t )p, (size_t )r);
  s = l;
  i = l;
  while (i < r) {
    tmp = (*f)(*(t->items + i), *(t->items + r));
    if (tmp) {
      Tuple_Swap(t, (size_t )i, (size_t )s);
      s ++;
    }
    i ++;
  }
  Tuple_Swap(t, (size_t )s, (size_t )r);
  return ((size_t )s);
}
}
static void Tuple_Sort_Part(struct Tuple *t , int64_t l , int64_t r , _Bool (*f)(var  ,
                                                                                 var  ) ) 
{ 
  int64_t s ;
  size_t tmp ;

  {
  if (l < r) {
    tmp = Tuple_Sort_Partition(t, l, r, f);
    s = (int64_t )tmp;
    Tuple_Sort_Part(t, l, s - 1L, f);
    Tuple_Sort_Part(t, s + 1L, r, f);
  }
  return;
}
}
static void Tuple_Sort_By(var self , _Bool (*f)(var  , var  ) ) 
{ 
  size_t tmp ;

  {
  tmp = Tuple_Len(self);
  Tuple_Sort_Part((struct Tuple *)self, (int64_t )0, (int64_t )(tmp - 1UL), f);
  return;
}
}
static int Tuple_Cmp(var self , var obj ) 
{ 
  struct Tuple *t ;
  size_t i ;
  var item0 ;
  var item1 ;
  var tmp ;
  int c ;
  int tmp___0 ;

  {
  t = (struct Tuple *)self;
  i = (size_t )0;
  item0 = *(t->items + i);
  tmp = iter_init(obj);
  item1 = tmp;
  while (1) {
    if ((unsigned long )item0 == (unsigned long )Terminal) {
      if ((unsigned long )item1 == (unsigned long )Terminal) {
        return (0);
      }
    }
    if ((unsigned long )item0 == (unsigned long )Terminal) {
      return (-1);
    }
    if ((unsigned long )item1 == (unsigned long )Terminal) {
      return (1);
    }
    tmp___0 = cmp(item0, item1);
    c = tmp___0;
    if (c < 0) {
      return (-1);
    }
    if (c > 0) {
      return (1);
    }
    i ++;
    item0 = *(t->items + i);
    item1 = iter_next(obj, item1);
  }
  return (0);
}
}
static uint64_t Tuple_Hash(var self ) 
{ 
  struct Tuple *t ;
  uint64_t h ;
  size_t n ;
  size_t tmp ;
  size_t i ;
  uint64_t tmp___0 ;

  {
  t = (struct Tuple *)self;
  h = (uint64_t )0;
  tmp = Tuple_Len(self);
  n = tmp;
  i = (size_t )0;
  while (i < n) {
    tmp___0 = hash(*(t->items + i));
    h ^= tmp___0;
    i ++;
  }
  return (h);
}
}
static struct Doc __constr_expr_720  =    {& Tuple_Name, & Tuple_Brief, & Tuple_Description, & Tuple_Definition, & Tuple_Examples,
    & Tuple_Methods};
static struct New __constr_expr_721  =    {& Tuple_New, & Tuple_Del};
static struct Assign __constr_expr_722  =    {& Tuple_Assign};
static struct Cmp __constr_expr_723  =    {& Tuple_Cmp};
static struct Hash __constr_expr_724  =    {& Tuple_Hash};
static struct Len __constr_expr_725  =    {& Tuple_Len};
static struct Get __constr_expr_726  =    {& Tuple_Get, & Tuple_Set, & Tuple_Mem, & Tuple_Rem, (var (*)(var  ))0, (var (*)(var  ))0};
static struct Push __constr_expr_727  =    {& Tuple_Push,
    & Tuple_Pop, & Tuple_Push_At, & Tuple_Pop_At};
static struct Concat __constr_expr_728  =    {& Tuple_Concat, & Tuple_Push};
static struct Resize __constr_expr_729  =    {& Tuple_Resize};
static struct Iter __constr_expr_730  =    {& Tuple_Iter_Init, & Tuple_Iter_Next, & Tuple_Iter_Last, & Tuple_Iter_Prev, (var (*)(var  ))((void *)0)};
static struct Mark __constr_expr_731  =    {& Tuple_Mark};
static struct Sort __constr_expr_732  =    {& Tuple_Sort_By};
static struct Show __constr_expr_733  =    {& Tuple_Show,
    (int (*)(var  , var  , int  ))((void *)0)};
static var __constr_expr_719[72]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Tuple", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Tuple ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_720),      (void *)0,      (var )"New", 
        (var )(& __constr_expr_721),      (void *)0,      (var )"Assign",      (var )(& __constr_expr_722), 
        (void *)0,      (var )"Cmp",      (var )(& __constr_expr_723),      (void *)0, 
        (var )"Hash",      (var )(& __constr_expr_724),      (void *)0,      (var )"Len", 
        (var )(& __constr_expr_725),      (void *)0,      (var )"Get",      (var )(& __constr_expr_726), 
        (void *)0,      (var )"Push",      (var )(& __constr_expr_727),      (void *)0, 
        (var )"Concat",      (var )(& __constr_expr_728),      (void *)0,      (var )"Resize", 
        (var )(& __constr_expr_729),      (void *)0,      (var )"Iter",      (var )(& __constr_expr_730), 
        (void *)0,      (var )"Mark",      (var )(& __constr_expr_731),      (void *)0, 
        (var )"Sort",      (var )(& __constr_expr_732),      (void *)0,      (var )"Show", 
        (var )(& __constr_expr_733),      (void *)0,      (void *)0,      (void *)0};
var Tuple  =    (var )((char *)(__constr_expr_719) + sizeof(struct Header ));
#pragma merger("0","/tmp/cil-mzPdoEq8.i","-std=gnu99,-Wall,-Wno-unused,-g,-ggdb,-fPIC")
var Box ;
void ref(var self , var item ) ;
var deref(var self ) ;
static char const   *Pointer_Name(void) 
{ 


  {
  return ("Pointer");
}
}
static char const   *Pointer_Brief(void) 
{ 


  {
  return ("Reference to other object");
}
}
static char const   *Pointer_Description(void) 
{ 


  {
  return ("The `Pointer` class is implemented by types which act as references to other objects. Primarily this class is implemented by `Ref` and `Box` which provide the two main pointer types in Cello.");
}
}
static char const   *Pointer_Definition(void) 
{ 


  {
  return ("struct Pointer {\n  void (*ref)(var, var);\n  var (*deref)(var);\n};\n");
}
}
static struct Example *Pointer_Examples(void) ;
static struct Example examples___22[2]  = {      {"Usage", "var obj0 = $F(1.0), obj1 = $F(2.0);\nvar r = $(Ref, obj0);\nshow(r);\nshow(deref(r)); /* 1.0 */\nref(r, obj1);\nshow(deref(r)); /* 2.0 */\nassign(r, obj0);\nshow(deref(r)); /* 1.0 */\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Pointer_Examples(void) 
{ 


  {
  return (examples___22);
}
}
static struct Method *Pointer_Methods(void) ;
static struct Method methods___19[3]  = {      {"ref", "void ref(var self, var item);", "Set the object `self` to reference the object `item`."}, 
        {"deref",
      "var deref(var self);", "Get the object referenced by `self`."}, 
        {(char const   *)((void *)0), (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Pointer_Methods(void) 
{ 


  {
  return (methods___19);
}
}
static struct Doc __constr_expr_735  =    {& Pointer_Name, & Pointer_Brief, & Pointer_Description, & Pointer_Definition,
    & Pointer_Examples, & Pointer_Methods};
static var __constr_expr_734[33]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Pointer", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Pointer ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_735),      (void *)0,      (void *)0, 
        (void *)0};
var Pointer  =    (var )((char *)(__constr_expr_734) + sizeof(struct Header ));
void ref(var self , var item ) 
{ 
  var tmp ;

  {
  tmp = method_at_offset(self, Pointer, (unsigned long )(& ((struct Pointer *)0)->ref),
                         "ref");
  (*(((struct Pointer *)tmp)->ref))(self, item);
  return;
}
}
var deref(var self ) 
{ 
  var tmp ;
  var tmp___0 ;

  {
  tmp = method_at_offset(self, Pointer, (unsigned long )(& ((struct Pointer *)0)->deref),
                         "deref");
  tmp___0 = (*(((struct Pointer *)tmp)->deref))(self);
  return (tmp___0);
}
}
static char const   *Ref_Name(void) 
{ 


  {
  return ("Ref");
}
}
static char const   *Ref_Brief(void) 
{ 


  {
  return ("Shared Pointer");
}
}
static char const   *Ref_Description(void) 
{ 


  {
  return ("The `Ref` type is a basic wrapper around a C pointer. It can be used as a type argument to collections to allow them to store generic types. It may also be useful in various circumstances where another level of indirection or mutability is required.");
}
}
static char const   *Ref_Definition(void) 
{ 


  {
  return ("struct Ref {\n  var val;\n};\n");
}
}
static struct Example *Ref_Examples(void) ;
static struct Example examples___23[3]  = {      {"Usage", "var obj0 = $F(1.0), obj1 = $F(2.0);\nvar r = $(Ref, obj0);\nshow(r);\nshow(deref(r)); /* 1.0 */\nref(r, obj1);\nshow(deref(r)); /* 2.0 */\nassign(r, obj0);\nshow(deref(r)); /* 1.0 */\n"}, 
        {"Collections",
      "var i0 = new(Int, $I(100));\nvar i1 = new(Int, $I(200));\nvar x = new(Array, Ref, i0, i1);\n\nprint(deref(get(x, $I(0)))); /* 100 */\ndel(x); /* Contents of `x` still alive */\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Ref_Examples(void) 
{ 


  {
  return (examples___23);
}
}
static void Ref_Ref(var self , var val ) ;
static var Ref_Deref(var self ) ;
static void Ref_Assign(var self , var obj ) ;
static void Ref_Assign(var self , var obj ) 
{ 
  struct Pointer *p ;
  var tmp ;
  var tmp___0 ;

  {
  tmp = instance(obj, Pointer);
  p = (struct Pointer *)tmp;
  if (p) {
    if (p->deref) {
      tmp___0 = (*(p->deref))(obj);
      Ref_Ref(self, tmp___0);
    } else {
      Ref_Ref(self, obj);
    }
  } else {
    Ref_Ref(self, obj);
  }
  return;
}
}
static void Ref_Ref(var self , var val ) 
{ 
  struct Ref *r ;

  {
  r = (struct Ref *)self;
  r->val = val;
  return;
}
}
static var Ref_Deref(var self ) 
{ 
  struct Ref *r ;

  {
  r = (struct Ref *)self;
  return (r->val);
}
}
static struct Doc __constr_expr_737  =    {& Ref_Name, & Ref_Brief, & Ref_Description, & Ref_Definition, & Ref_Examples,
    (struct Method *(*)(void))((void *)0)};
static struct Assign __constr_expr_738  =    {& Ref_Assign};
static struct Pointer __constr_expr_739  =    {& Ref_Ref, & Ref_Deref};
static var __constr_expr_736[39]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Ref", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Ref ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_737),      (void *)0,      (var )"Assign", 
        (var )(& __constr_expr_738),      (void *)0,      (var )"Pointer",      (var )(& __constr_expr_739), 
        (void *)0,      (void *)0,      (void *)0};
var Ref  =    (var )((char *)(__constr_expr_736) + sizeof(struct Header ));
static char const   *Box_Name(void) 
{ 


  {
  return ("Box");
}
}
static char const   *Box_Brief(void) 
{ 


  {
  return ("Unique Pointer");
}
}
static char const   *Box_Description(void) 
{ 


  {
  return ("The `Box` type is another wrapper around a C pointer with one additional behaviour as compared to `Ref`. When a `Box` object is deleted it will also call `del` on the object it points to. The means a `Box` is considered a pointer type that _owns_ the object it points to, and so is responsible for it\'s destruction. Due to this `Box`s must point to valid Cello objects and so can\'t be initalised with `NULL` or anything else invalid. \n\nWhile this might not seem that useful when there is Garbage Collection this can be very useful when Garbage Collection is turned off, and when used in conjunction with collections.");
}
}
static char const   *Box_Definition(void) 
{ 


  {
  return ("struct Box {\n  var val;\n};\n");
}
}
static struct Example *Box_Examples(void) ;
static struct Example examples___24[4]  = {      {"Usage", "var obj0 = $F(1.0), obj1 = $F(2.0);\nvar r = $(Box, obj0);\nshow(r);\nshow(deref(r)); /* 1.0 */\nref(r, obj1);\nshow(deref(r)); /* 2.0 */\nassign(r, obj0);\nshow(deref(r)); /* 1.0 */\n"}, 
        {"Lifetimes",
      "var quote = $S(\"Life is long\");\n\nwith (r in $B(new(String, quote))) {\n  println(\"This reference is: %$\", r);\n  println(\"This string is alive: \'%s\'\", deref(r));\n}\n\nprint(\"Now it has been cleared up!\\n\");\n"}, 
        {"Collection",
      "/* Multiple Types in one Collection */\nvar x = new(Array, Box, \n  new(String, $S(\"Hello\")), \n  new(String, $S(\"There\")), \n  new(Int, $I(10)));\n\nprint(deref(get(x, $I(0)))); /* Hello */ \n\ndel(x); /* Contents of `x` deleted with it */\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Box_Examples(void) 
{ 


  {
  return (examples___24);
}
}
static void Box_Ref(var self , var val ) ;
static var Box_Deref(var self ) ;
static void Box_Assign(var self , var obj ) ;
static void Box_New(var self , var args ) 
{ 
  struct Int __constr_expr_740 ;
  char __constr_expr_741[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  var tmp___2 ;

  {
  __constr_expr_740.val = (int64_t )0;
  __constr_expr_741[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_741[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_741), Int, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Int *)tmp___0), (void const   * __restrict  )(& __constr_expr_740),
                   sizeof(struct Int ));
  tmp___2 = get(args, (var )((struct Int *)tmp___1));
  Box_Assign(self, tmp___2);
  return;
}
}
static void Box_Del(var self ) 
{ 
  var obj ;
  var tmp ;

  {
  tmp = Box_Deref(self);
  obj = tmp;
  if (obj) {
    del(obj);
  }
  Box_Ref(self, (void *)0);
  return;
}
}
static void Box_Assign(var self , var obj ) 
{ 
  struct Pointer *p ;
  var tmp ;
  var tmp___0 ;

  {
  tmp = instance(obj, Pointer);
  p = (struct Pointer *)tmp;
  if (p) {
    if (p->deref) {
      tmp___0 = (*(p->deref))(obj);
      Box_Ref(self, tmp___0);
    } else {
      Box_Ref(self, obj);
    }
  } else {
    Box_Ref(self, obj);
  }
  return;
}
}
static int Box_Show(var self , var output , int pos ) 
{ 
  struct Tuple __constr_expr_742 ;
  var __constr_expr_743[3] ;
  var tmp ;
  char __constr_expr_744[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
  tmp = Box_Deref(self);
  __constr_expr_743[0] = self;
  __constr_expr_743[1] = tmp;
  __constr_expr_743[2] = Terminal;
  __constr_expr_742.items = __constr_expr_743;
  __constr_expr_744[0] = (char)0;
  tmp___0 = 1U;
  while (! (tmp___0 >= 32U)) {
    __constr_expr_744[tmp___0] = (char)0;
    tmp___0 ++;
  }
  tmp___1 = header_init((var )(__constr_expr_744), Tuple, 2);
  tmp___2 = memcpy((void * __restrict  )((struct Tuple *)tmp___1), (void const   * __restrict  )(& __constr_expr_742),
                   sizeof(struct Tuple ));
  tmp___3 = print_to_with(output, pos, "<\'Box\' at 0x%p (%$)>", (var )((struct Tuple *)tmp___2));
  return (tmp___3);
}
}
static void Box_Ref(var self , var val ) 
{ 
  struct Box *b ;

  {
  b = (struct Box *)self;
  b->val = val;
  return;
}
}
static var Box_Deref(var self ) 
{ 
  struct Box *b ;

  {
  b = (struct Box *)self;
  return (b->val);
}
}
static struct Doc __constr_expr_746  =    {& Box_Name, & Box_Brief, & Box_Description, & Box_Definition, & Box_Examples,
    (struct Method *(*)(void))((void *)0)};
static struct New __constr_expr_747  =    {& Box_New, & Box_Del};
static struct Assign __constr_expr_748  =    {& Box_Assign};
static struct Show __constr_expr_749  =    {& Box_Show, (int (*)(var  , var  , int  ))((void *)0)};
static struct Pointer __constr_expr_750  =    {& Box_Ref, & Box_Deref};
static var __constr_expr_745[45]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Box", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Box ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_746),      (void *)0,      (var )"New", 
        (var )(& __constr_expr_747),      (void *)0,      (var )"Assign",      (var )(& __constr_expr_748), 
        (void *)0,      (var )"Show",      (var )(& __constr_expr_749),      (void *)0, 
        (var )"Pointer",      (var )(& __constr_expr_750),      (void *)0,      (void *)0, 
        (void *)0};
var Box  =    (var )((char *)(__constr_expr_745) + sizeof(struct Header ));
#pragma merger("0","/tmp/cil-TtygmVp0.i","-std=gnu99,-Wall,-Wno-unused,-g,-ggdb,-fPIC")
var Tree ;
static char const   *Tree_Name(void) 
{ 


  {
  return ("Tree");
}
}
static char const   *Tree_Brief(void) 
{ 


  {
  return ("Balanced Binary Tree");
}
}
static char const   *Tree_Description(void) 
{ 


  {
  return ("The `Tree` type is a self balancing binary tree implemented as a red-black tree. It provides key-value access and requires the `Cmp` class to be defined on the key type.\n\nElement lookup and insertion are provided as an `O(log(n))` operation. This means in general a `Tree` is slower than a `Table` but it has several other nice properties such as being able to iterate over the items in order and not having large pauses for rehashing on some insertions.\n\nThis is largely equivalent to the C++ construct [std::map](http://www.cplusplus.com/reference/map/map/)");
}
}
static struct Example *Tree_Examples(void) ;
static struct Example examples___25[3]  = {      {"Usage", "var prices = new(Tree, String, Int);\nset(prices, $S(\"Apple\"),  $I(12));\nset(prices, $S(\"Banana\"), $I( 6));\nset(prices, $S(\"Pear\"),   $I(55));\n\nforeach (key in prices) {\n  var price = get(prices, key);\n  println(\"Price of %$ is %$\", key, price);\n}\n"}, 
        {"Manipulation",
      "var t = new(Tree, String, Int);\nset(t, $S(\"Hello\"), $I(2));\nset(t, $S(\"There\"), $I(5));\n\nshow($I(len(t))); /* 2 */\nshow($I(mem(t, $S(\"Hello\")))); /* 1 */\n\nrem(t, $S(\"Hello\"));\n\nshow($I(len(t))); /* 1 */\nshow($I(mem(t, $S(\"Hello\")))); /* 0 */\nshow($I(mem(t, $S(\"There\")))); /* 1 */\n\nresize(t, 0);\n\nshow($I(len(t))); /* 0 */\nshow($I(mem(t, $S(\"Hello\")))); /* 0 */\nshow($I(mem(t, $S(\"There\")))); /* 0 */\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Tree_Examples(void) 
{ 


  {
  return (examples___25);
}
}
static _Bool Tree_Is_Red(struct Tree *m , var node ) ;
static var *Tree_Left(struct Tree *m , var node ) 
{ 


  {
  return ((var *)((char *)node + 0UL));
}
}
static var *Tree_Right(struct Tree *m , var node ) 
{ 


  {
  return ((var *)((char *)node + sizeof(var )));
}
}
static var Tree_Get_Parent(struct Tree *m , var node ) 
{ 
  var ptr ;

  {
  ptr = *((var *)((char *)node + 2UL * sizeof(var )));
  return ((var )((uintptr_t )ptr & 0xfffffffffffffffeUL));
}
}
static void Tree_Set_Parent(struct Tree *m , var node , var ptr ) 
{ 
  _Bool tmp ;

  {
  tmp = Tree_Is_Red(m, node);
  if (tmp) {
    *((var *)((char *)node + 2UL * sizeof(var ))) = (var )((uintptr_t )ptr | 1UL);
  } else {
    *((var *)((char *)node + 2UL * sizeof(var ))) = ptr;
  }
  return;
}
}
static var Tree_Key(struct Tree *m , var node ) 
{ 


  {
  return ((var )(((char *)node + 3UL * sizeof(var )) + sizeof(struct Header )));
}
}
static var Tree_Val(struct Tree *m , var node ) 
{ 


  {
  return ((var )(((((char *)node + 3UL * sizeof(var )) + sizeof(struct Header )) + m->ksize) + sizeof(struct Header )));
}
}
static void Tree_Set_Color(struct Tree *m , var node , _Bool col ) 
{ 
  var ptr ;
  var tmp ;

  {
  tmp = Tree_Get_Parent(m, node);
  ptr = tmp;
  if (col) {
    *((var *)((char *)node + 2UL * sizeof(var ))) = (var )((uintptr_t )ptr | 1UL);
  } else {
    *((var *)((char *)node + 2UL * sizeof(var ))) = ptr;
  }
  return;
}
}
static _Bool Tree_Get_Color(struct Tree *m , var node ) 
{ 
  var ptr ;

  {
  if ((unsigned long )node == (unsigned long )((void *)0)) {
    return ((_Bool)0);
  }
  ptr = *((var *)((char *)node + 2UL * sizeof(var )));
  return ((_Bool )((uintptr_t )ptr & 1UL));
}
}
static void Tree_Set_Black(struct Tree *m , var node ) 
{ 


  {
  Tree_Set_Color(m, node, (_Bool)0);
  return;
}
}
static void Tree_Set_Red(struct Tree *m , var node ) 
{ 


  {
  Tree_Set_Color(m, node, (_Bool)1);
  return;
}
}
static _Bool Tree_Is_Red(struct Tree *m , var node ) 
{ 
  _Bool tmp ;

  {
  tmp = Tree_Get_Color(m, node);
  return (tmp);
}
}
static _Bool Tree_Is_Black(struct Tree *m , var node ) 
{ 
  _Bool tmp ;
  int tmp___0 ;

  {
  tmp = Tree_Get_Color(m, node);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  return ((_Bool )tmp___0);
}
}
static var Tree_Alloc(struct Tree *m ) 
{ 
  var node ;
  void *tmp ;
  struct Tuple __constr_expr_751 ;
  var __constr_expr_752[1] ;
  char __constr_expr_753[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;
  var key ;
  var tmp___3 ;
  var val ;
  var tmp___4 ;
  var *tmp___5 ;
  var *tmp___6 ;

  {
  tmp = calloc((size_t )1, (((3UL * sizeof(var ) + sizeof(struct Header )) + m->ksize) + sizeof(struct Header )) + m->vsize);
  node = tmp;
  if ((unsigned long )node == (unsigned long )((void *)0)) {
    __constr_expr_752[0] = Terminal;
    __constr_expr_751.items = __constr_expr_752;
    __constr_expr_753[0] = (char)0;
    tmp___0 = 1U;
    while (! (tmp___0 >= 32U)) {
      __constr_expr_753[tmp___0] = (char)0;
      tmp___0 ++;
    }
    tmp___1 = header_init((var )(__constr_expr_753), Tuple, 2);
    tmp___2 = memcpy((void * __restrict  )((struct Tuple *)tmp___1), (void const   * __restrict  )(& __constr_expr_751),
                     sizeof(struct Tuple ));
    exception_throw(OutOfMemoryError, "Cannot allocate Tree entry, out of memory!",
                    (var )((struct Tuple *)tmp___2));
  }
  tmp___3 = header_init((var )((struct Header *)((char *)node + 3UL * sizeof(var ))),
                        m->ktype, 4);
  key = tmp___3;
  tmp___4 = header_init((var )((struct Header *)((((char *)node + 3UL * sizeof(var )) + sizeof(struct Header )) + m->ksize)),
                        m->vtype, 4);
  val = tmp___4;
  tmp___5 = Tree_Left(m, node);
  *tmp___5 = (void *)0;
  tmp___6 = Tree_Right(m, node);
  *tmp___6 = (void *)0;
  Tree_Set_Parent(m, node, (void *)0);
  Tree_Set_Red(m, node);
  return (node);
}
}
static void Tree_Set(var self , var key , var val ) ;
static void Tree_New(var self , var args ) 
{ 
  struct Tree *m ;
  struct Int __constr_expr_754 ;
  char __constr_expr_755[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  struct Int __constr_expr_756 ;
  char __constr_expr_757[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___2 ;
  var tmp___3 ;
  void *tmp___4 ;
  size_t nargs ;
  size_t tmp___5 ;
  struct Tuple __constr_expr_758 ;
  var __constr_expr_759[1] ;
  char __constr_expr_760[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___6 ;
  var tmp___7 ;
  void *tmp___8 ;
  size_t i ;
  var key ;
  struct Int __constr_expr_761 ;
  char __constr_expr_762[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___9 ;
  var tmp___10 ;
  void *tmp___11 ;
  var tmp___12 ;
  var val ;
  struct Int __constr_expr_763 ;
  char __constr_expr_764[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___13 ;
  var tmp___14 ;
  void *tmp___15 ;
  var tmp___16 ;

  {
  m = (struct Tree *)self;
  __constr_expr_754.val = (int64_t )0;
  __constr_expr_755[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_755[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_755), Int, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Int *)tmp___0), (void const   * __restrict  )(& __constr_expr_754),
                   sizeof(struct Int ));
  m->ktype = get(args, (var )((struct Int *)tmp___1));
  __constr_expr_756.val = (int64_t )1;
  __constr_expr_757[0] = (char)0;
  tmp___2 = 1U;
  while (! (tmp___2 >= 32U)) {
    __constr_expr_757[tmp___2] = (char)0;
    tmp___2 ++;
  }
  tmp___3 = header_init((var )(__constr_expr_757), Int, 2);
  tmp___4 = memcpy((void * __restrict  )((struct Int *)tmp___3), (void const   * __restrict  )(& __constr_expr_756),
                   sizeof(struct Int ));
  m->vtype = get(args, (var )((struct Int *)tmp___4));
  m->ksize = size(m->ktype);
  m->vsize = size(m->vtype);
  m->nitems = (size_t )0;
  m->root = (void *)0;
  tmp___5 = len(args);
  nargs = tmp___5;
  if (nargs % 2UL != 0UL) {
    __constr_expr_759[0] = Terminal;
    __constr_expr_758.items = __constr_expr_759;
    __constr_expr_760[0] = (char)0;
    tmp___6 = 1U;
    while (! (tmp___6 >= 32U)) {
      __constr_expr_760[tmp___6] = (char)0;
      tmp___6 ++;
    }
    tmp___7 = header_init((var )(__constr_expr_760), Tuple, 2);
    tmp___8 = memcpy((void * __restrict  )((struct Tuple *)tmp___7), (void const   * __restrict  )(& __constr_expr_758),
                     sizeof(struct Tuple ));
    exception_throw(FormatError, "Received non multiple of two argument count to Tree constructor.",
                    (var )((struct Tuple *)tmp___8));
  }
  i = (size_t )0;
  while (i < (nargs - 2UL) / 2UL) {
    __constr_expr_761.val = (int64_t )(2UL + i * 2UL);
    __constr_expr_762[0] = (char)0;
    tmp___9 = 1U;
    while (! (tmp___9 >= 32U)) {
      __constr_expr_762[tmp___9] = (char)0;
      tmp___9 ++;
    }
    tmp___10 = header_init((var )(__constr_expr_762), Int, 2);
    tmp___11 = memcpy((void * __restrict  )((struct Int *)tmp___10), (void const   * __restrict  )(& __constr_expr_761),
                      sizeof(struct Int ));
    tmp___12 = get(args, (var )((struct Int *)tmp___11));
    key = tmp___12;
    __constr_expr_763.val = (int64_t )((2UL + i * 2UL) + 1UL);
    __constr_expr_764[0] = (char)0;
    tmp___13 = 1U;
    while (! (tmp___13 >= 32U)) {
      __constr_expr_764[tmp___13] = (char)0;
      tmp___13 ++;
    }
    tmp___14 = header_init((var )(__constr_expr_764), Int, 2);
    tmp___15 = memcpy((void * __restrict  )((struct Int *)tmp___14), (void const   * __restrict  )(& __constr_expr_763),
                      sizeof(struct Int ));
    tmp___16 = get(args, (var )((struct Int *)tmp___15));
    val = tmp___16;
    Tree_Set((var )m, key, val);
    i ++;
  }
  return;
}
}
static void Tree_Clear_Entry(struct Tree *m , var node ) 
{ 
  var *tmp ;
  var *tmp___0 ;
  var tmp___1 ;
  var tmp___2 ;

  {
  if ((unsigned long )node != (unsigned long )((void *)0)) {
    tmp = Tree_Left(m, node);
    Tree_Clear_Entry(m, *tmp);
    tmp___0 = Tree_Right(m, node);
    Tree_Clear_Entry(m, *tmp___0);
    tmp___1 = Tree_Key(m, node);
    destruct(tmp___1);
    tmp___2 = Tree_Val(m, node);
    destruct(tmp___2);
    free(node);
  }
  return;
}
}
static void Tree_Clear(var self ) 
{ 
  struct Tree *m ;

  {
  m = (struct Tree *)self;
  Tree_Clear_Entry(m, m->root);
  m->nitems = (size_t )0;
  m->root = (void *)0;
  return;
}
}
static void Tree_Del(var self ) 
{ 
  struct Tree *m ;

  {
  m = (struct Tree *)self;
  Tree_Clear(self);
  return;
}
}
static void Tree_Assign(var self , var obj ) 
{ 
  struct Tree *m ;
  var tmp___0 ;
  _Bool tmp___1 ;
  var tmp___3 ;
  _Bool tmp___4 ;
  var __key ;
  var __Iterkey ;
  var tmp___5 ;
  var key ;
  var tmp___6 ;
  var tmp___7 ;

  {
  m = (struct Tree *)self;
  Tree_Clear(self);
  tmp___1 = implements_method_at_offset(obj, Get, (unsigned long )(& ((struct Get *)0)->key_type));
  if (tmp___1) {
    tmp___0 = key_type(obj);
    m->ktype = tmp___0;
  } else {
    m->ktype = Ref;
  }
  tmp___4 = implements_method_at_offset(obj, Get, (unsigned long )(& ((struct Get *)0)->val_type));
  if (tmp___4) {
    tmp___3 = val_type(obj);
    m->vtype = tmp___3;
  } else {
    m->vtype = Ref;
  }
  m->ksize = size(m->ktype);
  m->vsize = size(m->vtype);
  __key = obj;
  tmp___5 = instance(__key, Iter);
  __Iterkey = tmp___5;
  tmp___6 = (*(((struct Iter *)__Iterkey)->iter_init))(__key);
  key = tmp___6;
  while ((unsigned long )key != (unsigned long )Terminal) {
    tmp___7 = get(obj, key);
    Tree_Set(self, key, tmp___7);
    key = (*(((struct Iter *)__Iterkey)->iter_next))(__key, key);
  }
  return;
}
}
static var Tree_Iter_Init(var self ) ;
static var Tree_Iter_Next(var self , var curr ) ;
static _Bool Tree_Mem(var self , var key ) ;
static var Tree_Get(var self , var key ) ;
static int Tree_Cmp(var self , var obj ) 
{ 
  int c ;
  var item0 ;
  var tmp ;
  var item1 ;
  var tmp___0 ;
  var tmp___1 ;
  var tmp___2 ;

  {
  tmp = Tree_Iter_Init(self);
  item0 = tmp;
  tmp___0 = iter_init(obj);
  item1 = tmp___0;
  while (1) {
    if ((unsigned long )item0 == (unsigned long )Terminal) {
      if ((unsigned long )item1 == (unsigned long )Terminal) {
        return (0);
      }
    }
    if ((unsigned long )item0 == (unsigned long )Terminal) {
      return (-1);
    }
    if ((unsigned long )item1 == (unsigned long )Terminal) {
      return (1);
    }
    c = cmp(item0, item1);
    if (c < 0) {
      return (-1);
    }
    if (c > 0) {
      return (1);
    }
    tmp___1 = get(obj, item1);
    tmp___2 = Tree_Get(self, item0);
    c = cmp(tmp___2, tmp___1);
    if (c < 0) {
      return (-1);
    }
    if (c > 0) {
      return (1);
    }
    item0 = Tree_Iter_Next(self, item0);
    item1 = iter_next(obj, item1);
  }
  return (0);
}
}
static uint64_t Tree_Hash(var self ) 
{ 
  struct Tree *m ;
  uint64_t h ;
  var curr ;
  var tmp ;
  var node ;
  var tmp___0 ;
  uint64_t tmp___1 ;
  var tmp___2 ;
  uint64_t tmp___3 ;

  {
  m = (struct Tree *)self;
  h = (uint64_t )0;
  tmp = Tree_Iter_Init(self);
  curr = tmp;
  while ((unsigned long )curr != (unsigned long )Terminal) {
    node = (var )(((char *)curr - sizeof(struct Header )) - 3UL * sizeof(var ));
    tmp___0 = Tree_Key(m, node);
    tmp___1 = hash(tmp___0);
    tmp___2 = Tree_Val(m, node);
    tmp___3 = hash(tmp___2);
    h = (h ^ tmp___1) ^ tmp___3;
    curr = Tree_Iter_Next(self, curr);
  }
  return (h);
}
}
static size_t Tree_Len(var self ) 
{ 
  struct Tree *m ;

  {
  m = (struct Tree *)self;
  return (m->nitems);
}
}
static _Bool Tree_Mem(var self , var key ) 
{ 
  struct Tree *m ;
  var node ;
  int c ;
  var tmp ;
  int tmp___0 ;
  var *tmp___1 ;
  var *tmp___2 ;

  {
  m = (struct Tree *)self;
  key = cast(key, m->ktype);
  node = m->root;
  while ((unsigned long )node != (unsigned long )((void *)0)) {
    tmp = Tree_Key(m, node);
    tmp___0 = cmp(tmp, key);
    c = tmp___0;
    if (c == 0) {
      return ((_Bool)1);
    }
    if (c < 0) {
      tmp___1 = Tree_Left(m, node);
      node = *tmp___1;
    } else {
      tmp___2 = Tree_Right(m, node);
      node = *tmp___2;
    }
  }
  return ((_Bool)0);
}
}
static var Tree_Get(var self , var key ) 
{ 
  struct Tree *m ;
  var node ;
  int c ;
  var tmp ;
  int tmp___0 ;
  var tmp___1 ;
  var *tmp___2 ;
  var *tmp___3 ;
  struct Tuple __constr_expr_765 ;
  var __constr_expr_766[2] ;
  char __constr_expr_767[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___4 ;
  var tmp___5 ;
  void *tmp___6 ;
  var tmp___7 ;

  {
  m = (struct Tree *)self;
  key = cast(key, m->ktype);
  node = m->root;
  while ((unsigned long )node != (unsigned long )((void *)0)) {
    tmp = Tree_Key(m, node);
    tmp___0 = cmp(tmp, key);
    c = tmp___0;
    if (c == 0) {
      tmp___1 = Tree_Val(m, node);
      return (tmp___1);
    }
    if (c < 0) {
      tmp___2 = Tree_Left(m, node);
      node = *tmp___2;
    } else {
      tmp___3 = Tree_Right(m, node);
      node = *tmp___3;
    }
  }
  __constr_expr_766[0] = key;
  __constr_expr_766[1] = Terminal;
  __constr_expr_765.items = __constr_expr_766;
  __constr_expr_767[0] = (char)0;
  tmp___4 = 1U;
  while (! (tmp___4 >= 32U)) {
    __constr_expr_767[tmp___4] = (char)0;
    tmp___4 ++;
  }
  tmp___5 = header_init((var )(__constr_expr_767), Tuple, 2);
  tmp___6 = memcpy((void * __restrict  )((struct Tuple *)tmp___5), (void const   * __restrict  )(& __constr_expr_765),
                   sizeof(struct Tuple ));
  tmp___7 = exception_throw(KeyError, "Key %$ not in Tree!", (var )((struct Tuple *)tmp___6));
  return (tmp___7);
}
}
static var Tree_Key_Type(var self ) 
{ 
  struct Tree *m ;

  {
  m = (struct Tree *)self;
  return (m->ktype);
}
}
static var Tree_Val_Type(var self ) 
{ 
  struct Tree *m ;

  {
  m = (struct Tree *)self;
  return (m->vtype);
}
}
static var Tree_Maximum(struct Tree *m , var node ) 
{ 
  var *tmp ;
  var *tmp___0 ;

  {
  while (1) {
    tmp___0 = Tree_Right(m, node);
    if (! ((unsigned long )*tmp___0 != (unsigned long )((void *)0))) {
      break;
    }
    tmp = Tree_Right(m, node);
    node = *tmp;
  }
  return (node);
}
}
static var Tree_Sibling(struct Tree *m , var node ) 
{ 
  var tmp ;
  var tmp___0 ;
  var *tmp___1 ;
  var tmp___2 ;
  var *tmp___3 ;
  var tmp___4 ;
  var *tmp___5 ;

  {
  if ((unsigned long )node == (unsigned long )((void *)0)) {
    return ((void *)0);
  } else {
    tmp = Tree_Get_Parent(m, node);
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      return ((void *)0);
    }
  }
  tmp___4 = Tree_Get_Parent(m, node);
  tmp___5 = Tree_Left(m, tmp___4);
  if ((unsigned long )node == (unsigned long )*tmp___5) {
    tmp___0 = Tree_Get_Parent(m, node);
    tmp___1 = Tree_Right(m, tmp___0);
    return (*tmp___1);
  } else {
    tmp___2 = Tree_Get_Parent(m, node);
    tmp___3 = Tree_Left(m, tmp___2);
    return (*tmp___3);
  }
}
}
static var Tree_Grandparent(struct Tree *m , var node ) 
{ 
  var tmp ;
  var tmp___0 ;
  var tmp___1 ;

  {
  if ((unsigned long )node != (unsigned long )((void *)0)) {
    tmp___1 = Tree_Get_Parent(m, node);
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
      tmp = Tree_Get_Parent(m, node);
      tmp___0 = Tree_Get_Parent(m, tmp);
      return (tmp___0);
    } else {
      return ((void *)0);
    }
  } else {
    return ((void *)0);
  }
}
}
static var Tree_Uncle(struct Tree *m , var node ) 
{ 
  var gpar ;
  var tmp ;
  var *tmp___0 ;
  var *tmp___1 ;
  var tmp___2 ;
  var *tmp___3 ;

  {
  tmp = Tree_Grandparent(m, node);
  gpar = tmp;
  if ((unsigned long )gpar == (unsigned long )((void *)0)) {
    return ((void *)0);
  }
  tmp___2 = Tree_Get_Parent(m, node);
  tmp___3 = Tree_Left(m, gpar);
  if ((unsigned long )tmp___2 == (unsigned long )*tmp___3) {
    tmp___0 = Tree_Right(m, gpar);
    return (*tmp___0);
  } else {
    tmp___1 = Tree_Left(m, gpar);
    return (*tmp___1);
  }
}
}
void Tree_Replace(struct Tree *m , var oldn , var newn ) 
{ 
  var tmp ;
  var *tmp___0 ;
  var tmp___1 ;
  var *tmp___2 ;
  var tmp___3 ;
  var *tmp___4 ;
  var tmp___5 ;
  var tmp___6 ;

  {
  tmp___5 = Tree_Get_Parent(m, oldn);
  if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
    m->root = newn;
  } else {
    tmp___3 = Tree_Get_Parent(m, oldn);
    tmp___4 = Tree_Left(m, tmp___3);
    if ((unsigned long )oldn == (unsigned long )*tmp___4) {
      tmp = Tree_Get_Parent(m, oldn);
      tmp___0 = Tree_Left(m, tmp);
      *tmp___0 = newn;
    } else {
      tmp___1 = Tree_Get_Parent(m, oldn);
      tmp___2 = Tree_Right(m, tmp___1);
      *tmp___2 = newn;
    }
  }
  if ((unsigned long )newn != (unsigned long )((void *)0)) {
    tmp___6 = Tree_Get_Parent(m, oldn);
    Tree_Set_Parent(m, newn, tmp___6);
  }
  return;
}
}
static void Tree_Rotate_Left(struct Tree *m , var node ) 
{ 
  var r ;
  var *tmp ;
  var *tmp___0 ;
  var *tmp___1 ;
  var *tmp___2 ;
  var *tmp___3 ;
  var *tmp___4 ;

  {
  tmp = Tree_Right(m, node);
  r = *tmp;
  Tree_Replace(m, node, r);
  tmp___0 = Tree_Right(m, node);
  tmp___1 = Tree_Left(m, r);
  *tmp___0 = *tmp___1;
  tmp___3 = Tree_Left(m, r);
  if ((unsigned long )*tmp___3 != (unsigned long )((void *)0)) {
    tmp___2 = Tree_Left(m, r);
    Tree_Set_Parent(m, *tmp___2, node);
  }
  tmp___4 = Tree_Left(m, r);
  *tmp___4 = node;
  Tree_Set_Parent(m, node, r);
  return;
}
}
static void Tree_Rotate_Right(struct Tree *m , var node ) 
{ 
  var l ;
  var *tmp ;
  var *tmp___0 ;
  var *tmp___1 ;
  var *tmp___2 ;
  var *tmp___3 ;
  var *tmp___4 ;

  {
  tmp = Tree_Left(m, node);
  l = *tmp;
  Tree_Replace(m, node, l);
  tmp___0 = Tree_Left(m, node);
  tmp___1 = Tree_Right(m, l);
  *tmp___0 = *tmp___1;
  tmp___3 = Tree_Right(m, l);
  if ((unsigned long )*tmp___3 != (unsigned long )((void *)0)) {
    tmp___2 = Tree_Right(m, l);
    Tree_Set_Parent(m, *tmp___2, node);
  }
  tmp___4 = Tree_Right(m, l);
  *tmp___4 = node;
  Tree_Set_Parent(m, node, l);
  return;
}
}
static void Tree_Set_Fix(struct Tree *m , var node ) 
{ 
  var tmp ;
  var tmp___0 ;
  _Bool tmp___1 ;
  var tmp___2 ;
  var tmp___3 ;
  var tmp___4 ;
  var tmp___5 ;
  var tmp___6 ;
  _Bool tmp___7 ;
  var tmp___8 ;
  var *tmp___9 ;
  var tmp___10 ;
  var *tmp___11 ;
  var tmp___12 ;
  var *tmp___13 ;
  var tmp___14 ;
  var tmp___15 ;
  var *tmp___16 ;
  var tmp___17 ;
  var *tmp___18 ;
  var tmp___19 ;
  var tmp___20 ;
  var *tmp___21 ;
  var tmp___22 ;
  var tmp___23 ;
  var tmp___24 ;
  var tmp___25 ;
  var tmp___26 ;
  var *tmp___27 ;

  {
  while (1) {
    tmp = Tree_Get_Parent(m, node);
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      Tree_Set_Black(m, node);
      return;
    }
    tmp___0 = Tree_Get_Parent(m, node);
    tmp___1 = Tree_Is_Black(m, tmp___0);
    if (tmp___1) {
      return;
    }
    tmp___5 = Tree_Uncle(m, node);
    if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
      tmp___6 = Tree_Uncle(m, node);
      tmp___7 = Tree_Is_Red(m, tmp___6);
      if (tmp___7) {
        tmp___2 = Tree_Get_Parent(m, node);
        Tree_Set_Black(m, tmp___2);
        tmp___3 = Tree_Uncle(m, node);
        Tree_Set_Black(m, tmp___3);
        tmp___4 = Tree_Grandparent(m, node);
        Tree_Set_Red(m, tmp___4);
        node = Tree_Grandparent(m, node);
        continue;
      }
    }
    tmp___17 = Tree_Get_Parent(m, node);
    tmp___18 = Tree_Right(m, tmp___17);
    if ((unsigned long )node == (unsigned long )*tmp___18) {
      tmp___19 = Tree_Get_Parent(m, node);
      tmp___20 = Tree_Grandparent(m, node);
      tmp___21 = Tree_Left(m, tmp___20);
      if ((unsigned long )tmp___19 == (unsigned long )*tmp___21) {
        tmp___8 = Tree_Get_Parent(m, node);
        Tree_Rotate_Left(m, tmp___8);
        tmp___9 = Tree_Left(m, node);
        node = *tmp___9;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      tmp___12 = Tree_Get_Parent(m, node);
      tmp___13 = Tree_Left(m, tmp___12);
      if ((unsigned long )node == (unsigned long )*tmp___13) {
        tmp___14 = Tree_Get_Parent(m, node);
        tmp___15 = Tree_Grandparent(m, node);
        tmp___16 = Tree_Right(m, tmp___15);
        if ((unsigned long )tmp___14 == (unsigned long )*tmp___16) {
          tmp___10 = Tree_Get_Parent(m, node);
          Tree_Rotate_Right(m, tmp___10);
          tmp___11 = Tree_Right(m, node);
          node = *tmp___11;
        }
      }
    }
    tmp___22 = Tree_Get_Parent(m, node);
    Tree_Set_Black(m, tmp___22);
    tmp___23 = Tree_Grandparent(m, node);
    Tree_Set_Red(m, tmp___23);
    tmp___26 = Tree_Get_Parent(m, node);
    tmp___27 = Tree_Left(m, tmp___26);
    if ((unsigned long )node == (unsigned long )*tmp___27) {
      tmp___24 = Tree_Grandparent(m, node);
      Tree_Rotate_Right(m, tmp___24);
    } else {
      tmp___25 = Tree_Grandparent(m, node);
      Tree_Rotate_Left(m, tmp___25);
    }
    return;
  }
}
}
static void Tree_Set(var self , var key , var val ) 
{ 
  struct Tree *m ;
  var node ;
  var node___0 ;
  var tmp ;
  var tmp___0 ;
  var tmp___1 ;
  int c ;
  var tmp___2 ;
  int tmp___3 ;
  var tmp___4 ;
  var tmp___5 ;
  var newn ;
  var tmp___6 ;
  var tmp___7 ;
  var tmp___8 ;
  var *tmp___9 ;
  var *tmp___10 ;
  var *tmp___11 ;
  var newn___0 ;
  var tmp___12 ;
  var tmp___13 ;
  var tmp___14 ;
  var *tmp___15 ;
  var *tmp___16 ;
  var *tmp___17 ;

  {
  m = (struct Tree *)self;
  key = cast(key, m->ktype);
  val = cast(val, m->vtype);
  node = m->root;
  if ((unsigned long )node == (unsigned long )((void *)0)) {
    tmp = Tree_Alloc(m);
    node___0 = tmp;
    tmp___0 = Tree_Key(m, node___0);
    assign(tmp___0, key);
    tmp___1 = Tree_Val(m, node___0);
    assign(tmp___1, val);
    m->root = node___0;
    (m->nitems) ++;
    Tree_Set_Fix(m, node___0);
    return;
  }
  while (1) {
    tmp___2 = Tree_Key(m, node);
    tmp___3 = cmp(tmp___2, key);
    c = tmp___3;
    if (c == 0) {
      tmp___4 = Tree_Key(m, node);
      assign(tmp___4, key);
      tmp___5 = Tree_Val(m, node);
      assign(tmp___5, val);
      return;
    }
    if (c < 0) {
      tmp___10 = Tree_Left(m, node);
      if ((unsigned long )*tmp___10 == (unsigned long )((void *)0)) {
        tmp___6 = Tree_Alloc(m);
        newn = tmp___6;
        tmp___7 = Tree_Key(m, newn);
        assign(tmp___7, key);
        tmp___8 = Tree_Val(m, newn);
        assign(tmp___8, val);
        tmp___9 = Tree_Left(m, node);
        *tmp___9 = newn;
        Tree_Set_Parent(m, newn, node);
        Tree_Set_Fix(m, newn);
        (m->nitems) ++;
        return;
      }
      tmp___11 = Tree_Left(m, node);
      node = *tmp___11;
    }
    if (c > 0) {
      tmp___16 = Tree_Right(m, node);
      if ((unsigned long )*tmp___16 == (unsigned long )((void *)0)) {
        tmp___12 = Tree_Alloc(m);
        newn___0 = tmp___12;
        tmp___13 = Tree_Key(m, newn___0);
        assign(tmp___13, key);
        tmp___14 = Tree_Val(m, newn___0);
        assign(tmp___14, val);
        tmp___15 = Tree_Right(m, node);
        *tmp___15 = newn___0;
        Tree_Set_Parent(m, newn___0, node);
        Tree_Set_Fix(m, newn___0);
        (m->nitems) ++;
        return;
      }
      tmp___17 = Tree_Right(m, node);
      node = *tmp___17;
    }
  }
}
}
static void Tree_Rem_Fix(struct Tree *m , var node ) 
{ 
  var tmp ;
  var tmp___0 ;
  var tmp___1 ;
  var tmp___2 ;
  var tmp___3 ;
  var tmp___4 ;
  var *tmp___5 ;
  var tmp___6 ;
  _Bool tmp___7 ;
  var tmp___8 ;
  var tmp___9 ;
  _Bool tmp___10 ;
  var tmp___11 ;
  _Bool tmp___12 ;
  var tmp___13 ;
  var *tmp___14 ;
  _Bool tmp___15 ;
  var tmp___16 ;
  var *tmp___17 ;
  _Bool tmp___18 ;
  var tmp___19 ;
  var tmp___20 ;
  var tmp___21 ;
  _Bool tmp___22 ;
  var tmp___23 ;
  _Bool tmp___24 ;
  var tmp___25 ;
  var *tmp___26 ;
  _Bool tmp___27 ;
  var tmp___28 ;
  var *tmp___29 ;
  _Bool tmp___30 ;
  var tmp___31 ;
  var tmp___32 ;
  var *tmp___33 ;
  var tmp___34 ;
  var tmp___35 ;
  var tmp___36 ;
  var *tmp___37 ;
  var tmp___38 ;
  var tmp___39 ;
  var *tmp___40 ;
  var tmp___41 ;
  var *tmp___42 ;
  _Bool tmp___43 ;
  var tmp___44 ;
  var *tmp___45 ;
  _Bool tmp___46 ;
  var tmp___47 ;
  var *tmp___48 ;
  var tmp___49 ;
  var *tmp___50 ;
  _Bool tmp___51 ;
  var tmp___52 ;
  var *tmp___53 ;
  _Bool tmp___54 ;
  var tmp___55 ;
  _Bool tmp___56 ;
  var tmp___57 ;
  _Bool tmp___58 ;
  var tmp___59 ;
  var tmp___60 ;
  var tmp___61 ;
  var *tmp___62 ;
  var tmp___63 ;
  var tmp___64 ;
  var *tmp___65 ;
  var tmp___66 ;
  var tmp___67 ;
  var *tmp___68 ;

  {
  while (1) {
    tmp = Tree_Get_Parent(m, node);
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      return;
    }
    tmp___6 = Tree_Sibling(m, node);
    tmp___7 = Tree_Is_Red(m, tmp___6);
    if (tmp___7) {
      tmp___0 = Tree_Get_Parent(m, node);
      Tree_Set_Red(m, tmp___0);
      tmp___1 = Tree_Sibling(m, node);
      Tree_Set_Black(m, tmp___1);
      tmp___4 = Tree_Get_Parent(m, node);
      tmp___5 = Tree_Left(m, tmp___4);
      if ((unsigned long )node == (unsigned long )*tmp___5) {
        tmp___2 = Tree_Get_Parent(m, node);
        Tree_Rotate_Left(m, tmp___2);
      } else {
        tmp___3 = Tree_Get_Parent(m, node);
        Tree_Rotate_Right(m, tmp___3);
      }
    }
    tmp___9 = Tree_Get_Parent(m, node);
    tmp___10 = Tree_Is_Black(m, tmp___9);
    if (tmp___10) {
      tmp___11 = Tree_Sibling(m, node);
      tmp___12 = Tree_Is_Black(m, tmp___11);
      if (tmp___12) {
        tmp___13 = Tree_Sibling(m, node);
        tmp___14 = Tree_Left(m, tmp___13);
        tmp___15 = Tree_Is_Black(m, *tmp___14);
        if (tmp___15) {
          tmp___16 = Tree_Sibling(m, node);
          tmp___17 = Tree_Right(m, tmp___16);
          tmp___18 = Tree_Is_Black(m, *tmp___17);
          if (tmp___18) {
            tmp___8 = Tree_Sibling(m, node);
            Tree_Set_Red(m, tmp___8);
            node = Tree_Get_Parent(m, node);
            continue;
          }
        }
      }
    }
    tmp___21 = Tree_Get_Parent(m, node);
    tmp___22 = Tree_Is_Red(m, tmp___21);
    if (tmp___22) {
      tmp___23 = Tree_Sibling(m, node);
      tmp___24 = Tree_Is_Black(m, tmp___23);
      if (tmp___24) {
        tmp___25 = Tree_Sibling(m, node);
        tmp___26 = Tree_Left(m, tmp___25);
        tmp___27 = Tree_Is_Black(m, *tmp___26);
        if (tmp___27) {
          tmp___28 = Tree_Sibling(m, node);
          tmp___29 = Tree_Right(m, tmp___28);
          tmp___30 = Tree_Is_Black(m, *tmp___29);
          if (tmp___30) {
            tmp___19 = Tree_Sibling(m, node);
            Tree_Set_Red(m, tmp___19);
            tmp___20 = Tree_Get_Parent(m, node);
            Tree_Set_Black(m, tmp___20);
            return;
          }
        }
      }
    }
    tmp___55 = Tree_Sibling(m, node);
    tmp___56 = Tree_Is_Black(m, tmp___55);
    if (tmp___56) {
      tmp___47 = Tree_Get_Parent(m, node);
      tmp___48 = Tree_Left(m, tmp___47);
      if ((unsigned long )node == (unsigned long )*tmp___48) {
        tmp___49 = Tree_Sibling(m, node);
        tmp___50 = Tree_Left(m, tmp___49);
        tmp___51 = Tree_Is_Red(m, *tmp___50);
        if (tmp___51) {
          tmp___52 = Tree_Sibling(m, node);
          tmp___53 = Tree_Right(m, tmp___52);
          tmp___54 = Tree_Is_Black(m, *tmp___53);
          if (tmp___54) {
            tmp___31 = Tree_Sibling(m, node);
            Tree_Set_Red(m, tmp___31);
            tmp___32 = Tree_Sibling(m, node);
            tmp___33 = Tree_Left(m, tmp___32);
            Tree_Set_Black(m, *tmp___33);
            tmp___34 = Tree_Sibling(m, node);
            Tree_Rotate_Right(m, tmp___34);
          } else {
            goto _L___0;
          }
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        tmp___39 = Tree_Get_Parent(m, node);
        tmp___40 = Tree_Right(m, tmp___39);
        if ((unsigned long )node == (unsigned long )*tmp___40) {
          tmp___41 = Tree_Sibling(m, node);
          tmp___42 = Tree_Right(m, tmp___41);
          tmp___43 = Tree_Is_Red(m, *tmp___42);
          if (tmp___43) {
            tmp___44 = Tree_Sibling(m, node);
            tmp___45 = Tree_Left(m, tmp___44);
            tmp___46 = Tree_Is_Black(m, *tmp___45);
            if (tmp___46) {
              tmp___35 = Tree_Sibling(m, node);
              Tree_Set_Red(m, tmp___35);
              tmp___36 = Tree_Sibling(m, node);
              tmp___37 = Tree_Right(m, tmp___36);
              Tree_Set_Black(m, *tmp___37);
              tmp___38 = Tree_Sibling(m, node);
              Tree_Rotate_Left(m, tmp___38);
            }
          }
        }
      }
    }
    tmp___57 = Tree_Get_Parent(m, node);
    tmp___58 = Tree_Get_Color(m, tmp___57);
    tmp___59 = Tree_Sibling(m, node);
    Tree_Set_Color(m, tmp___59, tmp___58);
    tmp___60 = Tree_Get_Parent(m, node);
    Tree_Set_Black(m, tmp___60);
    tmp___67 = Tree_Get_Parent(m, node);
    tmp___68 = Tree_Left(m, tmp___67);
    if ((unsigned long )node == (unsigned long )*tmp___68) {
      tmp___61 = Tree_Sibling(m, node);
      tmp___62 = Tree_Right(m, tmp___61);
      Tree_Set_Black(m, *tmp___62);
      tmp___63 = Tree_Get_Parent(m, node);
      Tree_Rotate_Left(m, tmp___63);
    } else {
      tmp___64 = Tree_Sibling(m, node);
      tmp___65 = Tree_Left(m, tmp___64);
      Tree_Set_Black(m, *tmp___65);
      tmp___66 = Tree_Get_Parent(m, node);
      Tree_Rotate_Right(m, tmp___66);
    }
    return;
  }
}
}
static void Tree_Rem(var self , var key ) 
{ 
  struct Tree *m ;
  _Bool found ;
  var node ;
  int c ;
  var tmp ;
  int tmp___0 ;
  var *tmp___1 ;
  var *tmp___2 ;
  struct Tuple __constr_expr_768 ;
  var __constr_expr_769[2] ;
  char __constr_expr_770[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;
  var tmp___6 ;
  var tmp___7 ;
  var pred ;
  var *tmp___8 ;
  var tmp___9 ;
  _Bool ncol ;
  _Bool tmp___10 ;
  var *tmp___11 ;
  var *tmp___12 ;
  var chld ;
  var *tmp___14 ;
  var *tmp___15 ;
  var tmp___16 ;
  var *tmp___17 ;
  _Bool tmp___18 ;
  _Bool tmp___19 ;
  var tmp___20 ;

  {
  m = (struct Tree *)self;
  key = cast(key, m->ktype);
  found = (_Bool)0;
  node = m->root;
  while ((unsigned long )node != (unsigned long )((void *)0)) {
    tmp = Tree_Key(m, node);
    tmp___0 = cmp(tmp, key);
    c = tmp___0;
    if (c == 0) {
      found = (_Bool)1;
      break;
    }
    if (c < 0) {
      tmp___1 = Tree_Left(m, node);
      node = *tmp___1;
    } else {
      tmp___2 = Tree_Right(m, node);
      node = *tmp___2;
    }
  }
  if (! found) {
    __constr_expr_769[0] = key;
    __constr_expr_769[1] = Terminal;
    __constr_expr_768.items = __constr_expr_769;
    __constr_expr_770[0] = (char)0;
    tmp___3 = 1U;
    while (! (tmp___3 >= 32U)) {
      __constr_expr_770[tmp___3] = (char)0;
      tmp___3 ++;
    }
    tmp___4 = header_init((var )(__constr_expr_770), Tuple, 2);
    tmp___5 = memcpy((void * __restrict  )((struct Tuple *)tmp___4), (void const   * __restrict  )(& __constr_expr_768),
                     sizeof(struct Tuple ));
    exception_throw(KeyError, "Key %$ not in Tree!", (var )((struct Tuple *)tmp___5));
    return;
  }
  tmp___6 = Tree_Key(m, node);
  destruct(tmp___6);
  tmp___7 = Tree_Val(m, node);
  destruct(tmp___7);
  tmp___11 = Tree_Left(m, node);
  if ((unsigned long )*tmp___11 != (unsigned long )((void *)0)) {
    tmp___12 = Tree_Right(m, node);
    if ((unsigned long )*tmp___12 != (unsigned long )((void *)0)) {
      tmp___8 = Tree_Left(m, node);
      tmp___9 = Tree_Maximum(m, *tmp___8);
      pred = tmp___9;
      tmp___10 = Tree_Get_Color(m, node);
      ncol = tmp___10;
      memcpy((void * __restrict  )((char *)node + 3UL * sizeof(var )), (void const   * __restrict  )((char *)pred + 3UL * sizeof(var )),
             ((sizeof(struct Header ) + m->ksize) + sizeof(struct Header )) + m->vsize);
      Tree_Set_Color(m, node, ncol);
      node = pred;
    }
  }
  tmp___17 = Tree_Right(m, node);
  if ((unsigned long )*tmp___17 == (unsigned long )((void *)0)) {
    tmp___14 = Tree_Left(m, node);
    tmp___16 = *tmp___14;
  } else {
    tmp___15 = Tree_Right(m, node);
    tmp___16 = *tmp___15;
  }
  chld = tmp___16;
  tmp___19 = Tree_Is_Black(m, node);
  if (tmp___19) {
    tmp___18 = Tree_Get_Color(m, chld);
    Tree_Set_Color(m, node, tmp___18);
    Tree_Rem_Fix(m, node);
  }
  Tree_Replace(m, node, chld);
  tmp___20 = Tree_Get_Parent(m, node);
  if ((unsigned long )tmp___20 == (unsigned long )((void *)0)) {
    if ((unsigned long )chld != (unsigned long )((void *)0)) {
      Tree_Set_Black(m, chld);
    }
  }
  (m->nitems) --;
  free(node);
  return;
}
}
static var Tree_Iter_Init(var self ) 
{ 
  struct Tree *m ;
  var node ;
  var *tmp ;
  var *tmp___0 ;
  var tmp___1 ;

  {
  m = (struct Tree *)self;
  if (m->nitems == 0UL) {
    return (Terminal);
  }
  node = m->root;
  while (1) {
    tmp___0 = Tree_Left(m, node);
    if (! ((unsigned long )*tmp___0 != (unsigned long )((void *)0))) {
      break;
    }
    tmp = Tree_Left(m, node);
    node = *tmp;
  }
  tmp___1 = Tree_Key(m, node);
  return (tmp___1);
}
}
static var Tree_Iter_Next(var self , var curr ) 
{ 
  struct Tree *m ;
  var node ;
  var prnt ;
  var tmp ;
  var *tmp___0 ;
  var *tmp___1 ;
  var *tmp___2 ;
  var tmp___3 ;
  var *tmp___4 ;
  var tmp___5 ;
  var *tmp___6 ;
  var *tmp___7 ;

  {
  m = (struct Tree *)self;
  node = (var )(((char *)curr - sizeof(struct Header )) - 3UL * sizeof(var ));
  tmp = Tree_Get_Parent(m, node);
  prnt = tmp;
  tmp___4 = Tree_Right(m, node);
  if ((unsigned long )*tmp___4 != (unsigned long )((void *)0)) {
    tmp___0 = Tree_Right(m, node);
    node = *tmp___0;
    while (1) {
      tmp___2 = Tree_Left(m, node);
      if (! ((unsigned long )*tmp___2 != (unsigned long )((void *)0))) {
        break;
      }
      tmp___1 = Tree_Left(m, node);
      node = *tmp___1;
    }
    tmp___3 = Tree_Key(m, node);
    return (tmp___3);
  }
  while (1) {
    if ((unsigned long )prnt == (unsigned long )((void *)0)) {
      return (Terminal);
    }
    tmp___6 = Tree_Left(m, prnt);
    if ((unsigned long )node == (unsigned long )*tmp___6) {
      tmp___5 = Tree_Key(m, prnt);
      return (tmp___5);
    }
    tmp___7 = Tree_Right(m, prnt);
    if ((unsigned long )node == (unsigned long )*tmp___7) {
      prnt = Tree_Get_Parent(m, prnt);
      node = Tree_Get_Parent(m, node);
    }
  }
  return (Terminal);
}
}
static var Tree_Iter_Last(var self ) 
{ 
  struct Tree *m ;
  var node ;
  var *tmp ;
  var *tmp___0 ;
  var tmp___1 ;

  {
  m = (struct Tree *)self;
  if (m->nitems == 0UL) {
    return (Terminal);
  }
  node = m->root;
  while (1) {
    tmp___0 = Tree_Right(m, node);
    if (! ((unsigned long )*tmp___0 != (unsigned long )((void *)0))) {
      break;
    }
    tmp = Tree_Right(m, node);
    node = *tmp;
  }
  tmp___1 = Tree_Key(m, node);
  return (tmp___1);
}
}
static var Tree_Iter_Prev(var self , var curr ) 
{ 
  struct Tree *m ;
  var node ;
  var prnt ;
  var tmp ;
  var *tmp___0 ;
  var *tmp___1 ;
  var *tmp___2 ;
  var tmp___3 ;
  var *tmp___4 ;
  var tmp___5 ;
  var *tmp___6 ;
  var *tmp___7 ;

  {
  m = (struct Tree *)self;
  node = (var )(((char *)curr - sizeof(struct Header )) - 3UL * sizeof(var ));
  tmp = Tree_Get_Parent(m, node);
  prnt = tmp;
  tmp___4 = Tree_Left(m, node);
  if ((unsigned long )*tmp___4 != (unsigned long )((void *)0)) {
    tmp___0 = Tree_Left(m, node);
    node = *tmp___0;
    while (1) {
      tmp___2 = Tree_Right(m, node);
      if (! ((unsigned long )*tmp___2 != (unsigned long )((void *)0))) {
        break;
      }
      tmp___1 = Tree_Right(m, node);
      node = *tmp___1;
    }
    tmp___3 = Tree_Key(m, node);
    return (tmp___3);
  }
  while (1) {
    if ((unsigned long )prnt == (unsigned long )((void *)0)) {
      return (Terminal);
    }
    tmp___6 = Tree_Right(m, prnt);
    if ((unsigned long )node == (unsigned long )*tmp___6) {
      tmp___5 = Tree_Key(m, prnt);
      return (tmp___5);
    }
    tmp___7 = Tree_Left(m, prnt);
    if ((unsigned long )node == (unsigned long )*tmp___7) {
      prnt = Tree_Get_Parent(m, prnt);
      node = Tree_Get_Parent(m, node);
    }
  }
  return (Terminal);
}
}
static var Tree_Iter_Type(var self ) 
{ 
  struct Tree *m ;

  {
  m = (struct Tree *)self;
  return (m->ktype);
}
}
static int Tree_Show(var self , var output , int pos ) 
{ 
  struct Tree *m ;
  struct Tuple __constr_expr_771 ;
  var __constr_expr_772[2] ;
  char __constr_expr_773[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  var curr ;
  var tmp___2 ;
  var node ;
  struct Tuple __constr_expr_774 ;
  var __constr_expr_775[3] ;
  var tmp___3 ;
  var tmp___4 ;
  char __constr_expr_776[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___5 ;
  var tmp___6 ;
  void *tmp___7 ;
  struct Tuple __constr_expr_777 ;
  var __constr_expr_778[1] ;
  char __constr_expr_779[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___8 ;
  var tmp___9 ;
  void *tmp___10 ;
  struct Tuple __constr_expr_780 ;
  var __constr_expr_781[1] ;
  char __constr_expr_782[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___11 ;
  var tmp___12 ;
  void *tmp___13 ;
  int tmp___14 ;

  {
  m = (struct Tree *)self;
  __constr_expr_772[0] = self;
  __constr_expr_772[1] = Terminal;
  __constr_expr_771.items = __constr_expr_772;
  __constr_expr_773[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_773[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_773), Tuple, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_771),
                   sizeof(struct Tuple ));
  pos = print_to_with(output, pos, "<\'Tree\' At 0x%p {", (var )((struct Tuple *)tmp___1));
  tmp___2 = Tree_Iter_Init(self);
  curr = tmp___2;
  while ((unsigned long )curr != (unsigned long )Terminal) {
    node = (var )(((char *)curr - sizeof(struct Header )) - 3UL * sizeof(var ));
    tmp___3 = Tree_Key(m, node);
    tmp___4 = Tree_Val(m, node);
    __constr_expr_775[0] = tmp___3;
    __constr_expr_775[1] = tmp___4;
    __constr_expr_775[2] = Terminal;
    __constr_expr_774.items = __constr_expr_775;
    __constr_expr_776[0] = (char)0;
    tmp___5 = 1U;
    while (! (tmp___5 >= 32U)) {
      __constr_expr_776[tmp___5] = (char)0;
      tmp___5 ++;
    }
    tmp___6 = header_init((var )(__constr_expr_776), Tuple, 2);
    tmp___7 = memcpy((void * __restrict  )((struct Tuple *)tmp___6), (void const   * __restrict  )(& __constr_expr_774),
                     sizeof(struct Tuple ));
    pos = print_to_with(output, pos, "%$:%$", (var )((struct Tuple *)tmp___7));
    curr = Tree_Iter_Next(self, curr);
    if ((unsigned long )curr != (unsigned long )Terminal) {
      __constr_expr_778[0] = Terminal;
      __constr_expr_777.items = __constr_expr_778;
      __constr_expr_779[0] = (char)0;
      tmp___8 = 1U;
      while (! (tmp___8 >= 32U)) {
        __constr_expr_779[tmp___8] = (char)0;
        tmp___8 ++;
      }
      tmp___9 = header_init((var )(__constr_expr_779), Tuple, 2);
      tmp___10 = memcpy((void * __restrict  )((struct Tuple *)tmp___9), (void const   * __restrict  )(& __constr_expr_777),
                        sizeof(struct Tuple ));
      pos = print_to_with(output, pos, ", ", (var )((struct Tuple *)tmp___10));
    }
  }
  __constr_expr_781[0] = Terminal;
  __constr_expr_780.items = __constr_expr_781;
  __constr_expr_782[0] = (char)0;
  tmp___11 = 1U;
  while (! (tmp___11 >= 32U)) {
    __constr_expr_782[tmp___11] = (char)0;
    tmp___11 ++;
  }
  tmp___12 = header_init((var )(__constr_expr_782), Tuple, 2);
  tmp___13 = memcpy((void * __restrict  )((struct Tuple *)tmp___12), (void const   * __restrict  )(& __constr_expr_780),
                    sizeof(struct Tuple ));
  tmp___14 = print_to_with(output, pos, "}>", (var )((struct Tuple *)tmp___13));
  return (tmp___14);
}
}
static void Tree_Mark(var self , var gc , void (*f)(var  , void * ) ) 
{ 
  struct Tree *m ;
  var curr ;
  var tmp ;
  var node ;
  var tmp___0 ;
  var tmp___1 ;

  {
  m = (struct Tree *)self;
  tmp = Tree_Iter_Init(self);
  curr = tmp;
  while ((unsigned long )curr != (unsigned long )Terminal) {
    node = (var )(((char *)curr - sizeof(struct Header )) - 3UL * sizeof(var ));
    tmp___0 = Tree_Key(m, node);
    (*f)(gc, tmp___0);
    tmp___1 = Tree_Val(m, node);
    (*f)(gc, tmp___1);
    curr = Tree_Iter_Next(self, curr);
  }
  return;
}
}
static void Tree_Resize(var self , size_t n ) 
{ 
  struct Tuple __constr_expr_783 ;
  var __constr_expr_784[2] ;
  struct Int __constr_expr_785 ;
  char __constr_expr_786[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  char __constr_expr_787[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___2 ;
  var tmp___3 ;
  void *tmp___4 ;

  {
  if (n == 0UL) {
    Tree_Clear(self);
  } else {
    __constr_expr_785.val = (int64_t )n;
    __constr_expr_786[0] = (char)0;
    tmp = 1U;
    while (! (tmp >= 32U)) {
      __constr_expr_786[tmp] = (char)0;
      tmp ++;
    }
    tmp___0 = header_init((var )(__constr_expr_786), Int, 2);
    tmp___1 = memcpy((void * __restrict  )((struct Int *)tmp___0), (void const   * __restrict  )(& __constr_expr_785),
                     sizeof(struct Int ));
    __constr_expr_784[0] = (var )((struct Int *)tmp___1);
    __constr_expr_784[1] = Terminal;
    __constr_expr_783.items = __constr_expr_784;
    __constr_expr_787[0] = (char)0;
    tmp___2 = 1U;
    while (! (tmp___2 >= 32U)) {
      __constr_expr_787[tmp___2] = (char)0;
      tmp___2 ++;
    }
    tmp___3 = header_init((var )(__constr_expr_787), Tuple, 2);
    tmp___4 = memcpy((void * __restrict  )((struct Tuple *)tmp___3), (void const   * __restrict  )(& __constr_expr_783),
                     sizeof(struct Tuple ));
    exception_throw(FormatError, "Cannot resize Tree to %li items. Trees can only be resized to 0 items.",
                    (var )((struct Tuple *)tmp___4));
  }
  return;
}
}
static struct Doc __constr_expr_789  =    {& Tree_Name, & Tree_Brief, & Tree_Description, (char const   *(*)(void))((void *)0),
    & Tree_Examples, (struct Method *(*)(void))((void *)0)};
static struct New __constr_expr_790  =    {& Tree_New, & Tree_Del};
static struct Assign __constr_expr_791  =    {& Tree_Assign};
static struct Mark __constr_expr_792  =    {& Tree_Mark};
static struct Cmp __constr_expr_793  =    {& Tree_Cmp};
static struct Hash __constr_expr_794  =    {& Tree_Hash};
static struct Len __constr_expr_795  =    {& Tree_Len};
static struct Get __constr_expr_796  =    {& Tree_Get, & Tree_Set, & Tree_Mem, & Tree_Rem, & Tree_Key_Type, & Tree_Val_Type};
static struct Resize __constr_expr_797  =    {& Tree_Resize};
static struct Iter __constr_expr_798  =    {& Tree_Iter_Init,
    & Tree_Iter_Next, & Tree_Iter_Last, & Tree_Iter_Prev, & Tree_Iter_Type};
static struct Show __constr_expr_799  =    {& Tree_Show, (int (*)(var  , var  , int  ))((void *)0)};
static var __constr_expr_788[63]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Tree", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Tree ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_789),      (void *)0,      (var )"New", 
        (var )(& __constr_expr_790),      (void *)0,      (var )"Assign",      (var )(& __constr_expr_791), 
        (void *)0,      (var )"Mark",      (var )(& __constr_expr_792),      (void *)0, 
        (var )"Cmp",      (var )(& __constr_expr_793),      (void *)0,      (var )"Hash", 
        (var )(& __constr_expr_794),      (void *)0,      (var )"Len",      (var )(& __constr_expr_795), 
        (void *)0,      (var )"Get",      (var )(& __constr_expr_796),      (void *)0, 
        (var )"Resize",      (var )(& __constr_expr_797),      (void *)0,      (var )"Iter", 
        (var )(& __constr_expr_798),      (void *)0,      (var )"Show",      (var )(& __constr_expr_799), 
        (void *)0,      (void *)0,      (void *)0};
var Tree  =    (var )((char *)(__constr_expr_788) + sizeof(struct Header ));
#pragma merger("0","/tmp/cil-22KUMJt_.i","-std=gnu99,-Wall,-Wno-unused,-g,-ggdb,-fPIC")
var Sort ;
_Bool neq(var self , var obj ) ;
_Bool gt(var self , var obj ) ;
_Bool lt(var self , var obj ) ;
_Bool ge(var self , var obj ) ;
_Bool le(var self , var obj ) ;
void sort(var self ) ;
void sort_by(var self , _Bool (*f)(var  , var  ) ) ;
static char const   *Cmp_Name(void) 
{ 


  {
  return ("Cmp");
}
}
static char const   *Cmp_Brief(void) 
{ 


  {
  return ("Comparison");
}
}
static char const   *Cmp_Description(void) 
{ 


  {
  return ("The `Cmp` class is used to define comparison between two object values. This class is important as it is used by many data structures to test equality or ordering of objects.\n\nBy default, if passed two objects of the same type, the `Cmp` class will simply compare the raw memory of both objects, using the `Size` class.\n\nTo implement this class a `cmp` function must be provided which returns `< 0` if the first object is _less than_ the second, `> 0` if the first object is _greater than_ the second, and `0` if they are _equal_. \n\nFor objects that manage their own data this class may need to be overridden to ensure that objects of the same _value_ are still treated as equal. E.G. for string types.\n\nThis class to used to test for _value_ equality between objects, I.E. if they represent the same thing. For _object_ equality the `is` keyword can be used, which will return `true` only if two variables are pointing to the same object in memory.");
}
}
static char const   *Cmp_Definition(void) 
{ 


  {
  return ("struct Cmp {\n  int (*cmp)(var, var);\n};\n");
}
}
static struct Example *Cmp_Examples(void) ;
static struct Example examples___26[3]  = {      {"Usage 1", "show($I( eq($I(1), $I( 1)))); /* 1 */\nshow($I(neq($I(2), $I(20)))); /* 1 */\nshow($I(neq($S(\"Hello\"), $S(\"Hello\")))); /* 0 */\nshow($I( eq($S(\"Hello\"), $S(\"There\")))); /* 0 */\n\nvar a = $I(1); var b = $I(1);\n\nshow($I(eq(a, b))); /* 1 */\nshow($I(a is b));   /* 0 */\nshow($I(a isnt b)); /* 1 */\n"}, 
        {"Usage 2",
      "show($I(gt($I(15), $I(3 )))); /* 1 */\nshow($I(lt($I(70), $I(81)))); /* 1 */\nshow($I(lt($I(71), $I(71)))); /* 0 */\nshow($I(ge($I(78), $I(71)))); /* 1 */\nshow($I(gt($I(32), $I(32)))); /* 0 */\nshow($I(le($I(21), $I(32)))); /* 1 */\n\nshow($I(cmp($I(20), $I(20)))); /*  0 */\nshow($I(cmp($I(21), $I(20)))); /*  1 */\nshow($I(cmp($I(20), $I(21)))); /* -1 */\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Cmp_Examples(void) 
{ 


  {
  return (examples___26);
}
}
static struct Method *Cmp_Methods(void) ;
static struct Method methods___20[8]  = 
  {      {"cmp", "int cmp(var self, var obj);", "The return value of `cmp` is `< 0` if `self` is less than `obj`, `> 0` if `self` is greater than `obj` and `0` if they are equal."}, 
        {"eq",
      "bool eq(var self, var obj);", "Returns true if the object `self` is equal to the object `obj`."}, 
        {"neq",
      "bool neq(var self, var obj);", "Returns false if the object `self` is equal to the object `obj`."}, 
        {"gt",
      "bool gt(var self, var obj);", "Returns true if the object `self` is greater than the object `obj`."}, 
        {"lt",
      "bool lt(var self, var obj);", "Returns false if the object `self` is less than the object `obj`."}, 
        {"ge",
      "bool ge(var self, var obj);", "Returns false if the object `self` is greater than or equal to the object `obj`."}, 
        {"le",
      "bool le(var self, var obj);", "Returns false if the object `self` is less than or equal to the object `obj`."}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Cmp_Methods(void) 
{ 


  {
  return (methods___20);
}
}
static struct Doc __constr_expr_801  =    {& Cmp_Name, & Cmp_Brief, & Cmp_Description, & Cmp_Definition, & Cmp_Examples,
    & Cmp_Methods};
static var __constr_expr_800[33]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Cmp", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Cmp ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_801),      (void *)0,      (void *)0, 
        (void *)0};
var Cmp  =    (var )((char *)(__constr_expr_800) + sizeof(struct Header ));
int cmp(var self , var obj ) 
{ 
  struct Cmp *c ;
  var tmp ;
  int tmp___0 ;
  size_t s ;
  var tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  var tmp___4 ;
  var tmp___5 ;
  struct Tuple __constr_expr_802 ;
  var __constr_expr_803[3] ;
  var tmp___6 ;
  var tmp___7 ;
  char __constr_expr_804[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___8 ;
  var tmp___9 ;
  void *tmp___10 ;

  {
  tmp = instance(self, Cmp);
  c = (struct Cmp *)tmp;
  if (c) {
    if (c->cmp) {
      tmp___0 = (*(c->cmp))(self, obj);
      return (tmp___0);
    }
  }
  tmp___1 = type_of(self);
  tmp___2 = size(tmp___1);
  s = tmp___2;
  tmp___4 = type_of(self);
  tmp___5 = type_of(obj);
  if ((unsigned long )tmp___4 == (unsigned long )tmp___5) {
    if (s) {
      tmp___3 = memcmp((void const   *)self, (void const   *)obj, s);
      return (tmp___3);
    }
  }
  tmp___6 = type_of(obj);
  tmp___7 = type_of(self);
  __constr_expr_803[0] = tmp___6;
  __constr_expr_803[1] = tmp___7;
  __constr_expr_803[2] = Terminal;
  __constr_expr_802.items = __constr_expr_803;
  __constr_expr_804[0] = (char)0;
  tmp___8 = 1U;
  while (! (tmp___8 >= 32U)) {
    __constr_expr_804[tmp___8] = (char)0;
    tmp___8 ++;
  }
  tmp___9 = header_init((var )(__constr_expr_804), Tuple, 2);
  tmp___10 = memcpy((void * __restrict  )((struct Tuple *)tmp___9), (void const   * __restrict  )(& __constr_expr_802),
                    sizeof(struct Tuple ));
  exception_throw(TypeError, "Cannot compare type %s to type %s", (var )((struct Tuple *)tmp___10));
  return (0);
}
}
_Bool eq(var self , var obj ) 
{ 
  int tmp ;

  {
  tmp = cmp(self, obj);
  return ((_Bool )(tmp == 0));
}
}
_Bool neq(var self , var obj ) 
{ 
  _Bool tmp ;
  int tmp___0 ;

  {
  tmp = eq(self, obj);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  return ((_Bool )tmp___0);
}
}
_Bool gt(var self , var obj ) 
{ 
  int tmp ;

  {
  tmp = cmp(self, obj);
  return ((_Bool )(tmp > 0));
}
}
_Bool lt(var self , var obj ) 
{ 
  int tmp ;

  {
  tmp = cmp(self, obj);
  return ((_Bool )(tmp < 0));
}
}
_Bool ge(var self , var obj ) 
{ 
  _Bool tmp ;
  int tmp___0 ;

  {
  tmp = lt(self, obj);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  return ((_Bool )tmp___0);
}
}
_Bool le(var self , var obj ) 
{ 
  _Bool tmp ;
  int tmp___0 ;

  {
  tmp = gt(self, obj);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  return ((_Bool )tmp___0);
}
}
static char const   *Sort_Name(void) 
{ 


  {
  return ("Sort");
}
}
static char const   *Sort_Brief(void) 
{ 


  {
  return ("Sortable");
}
}
static char const   *Sort_Description(void) 
{ 


  {
  return ("The `Sort` class can be implemented by types which can be sorted in some way such as `Array`. By default the sorting function uses the `lt` method to compare elements, but a custom function can also be provided.");
}
}
static char const   *Sort_Definition(void) 
{ 


  {
  return ("struct Sort {\n  void (*sort_by)(var,bool(*f)(var,var));\n};");
}
}
static struct Example *Sort_Examples(void) ;
static struct Example examples___27[2]  = {      {"Usage", "var x = new(Array, Float, \n  $F(5.2), $F(7.1), $F(2.2));\n\nshow(x); /* <\'Array\' At 0x00414603 [5.2, 7.1, 2.2]> */\nsort(x);\nshow(x); /* <\'Array\' At 0x00414603 [2.2, 5.2, 7.1]> */\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Sort_Examples(void) 
{ 


  {
  return (examples___27);
}
}
static struct Method *Sort_Methods(void) ;
static struct Method methods___21[3]  = {      {"sort", "void sort(var self);", "Sorts the object `self`."}, 
        {"sort_by", "void sort_by(var self, bool(*f)(var,var));", "Sorts the object `self` using the function `f`."}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Sort_Methods(void) 
{ 


  {
  return (methods___21);
}
}
static struct Doc __constr_expr_806  =    {& Sort_Name, & Sort_Brief, & Sort_Description, & Sort_Definition, & Sort_Examples,
    & Sort_Methods};
static var __constr_expr_805[33]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Sort", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Sort ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_806),      (void *)0,      (void *)0, 
        (void *)0};
var Sort  =    (var )((char *)(__constr_expr_805) + sizeof(struct Header ));
void sort(var self ) 
{ 
  var tmp ;

  {
  tmp = method_at_offset(self, Sort, (unsigned long )(& ((struct Sort *)0)->sort_by),
                         "sort_by");
  (*(((struct Sort *)tmp)->sort_by))(self, & lt);
  return;
}
}
void sort_by(var self , _Bool (*f)(var  , var  ) ) 
{ 
  var tmp ;

  {
  tmp = method_at_offset(self, Sort, (unsigned long )(& ((struct Sort *)0)->sort_by),
                         "sort_by");
  (*(((struct Sort *)tmp)->sort_by))(self, f);
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#pragma merger("0","/tmp/cil-7Kt41ZIO.i","-std=gnu99,-Wall,-Wno-unused,-g,-ggdb,-fPIC")
extern FILE *stdin ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
var Float ;
var Format ;
var Show ;
double c_float(var self ) ;
int format_to_va(var self , int pos , char const   *fmt , va_list___0 va ) ;
int format_from_va(var self , int pos , char const   *fmt , va_list___0 va ) ;
int format_from(var self , int pos , char const   *fmt  , ...) ;
int show(var self ) ;
int show_to(var self , var out , int pos ) ;
int print_with(char const   *fmt , var args ) ;
int println_with(char const   *fmt , var args ) ;
int look(var self ) ;
int look_from(var self , var input , int pos ) ;
int scan_with(char const   *fmt , var args ) ;
int scanln_with(char const   *fmt , var args ) ;
static char const   *Format_Name(void) 
{ 


  {
  return ("Format");
}
}
static char const   *Format_Brief(void) 
{ 


  {
  return ("Read or Write with Format String");
}
}
static char const   *Format_Description(void) 
{ 


  {
  return ("Format abstracts the class of operations such as `scanf`, `sprintf` and `fprintf` with matching semantics. It provides general `printf` and `scanf` functionality for several different types objects in a uniform way. This class is essentially an in-between class, used by the `Show` class to read and write output.\n\nIt is important to note that the semantics of these operations match `printf` and not the newly defined `Show` class. For example it is perfectly valid to pass a C `int` to these functions, while the `println` function from `Show` must be passed only `var` objects.");
}
}
static char const   *Format_Definition(void) 
{ 


  {
  return ("struct Format {\n  int (*format_to)(var,int,const char*,va_list);\n  int (*format_from)(var,int,const char*,va_list);\n};\n");
}
}
static struct Example *Format_Examples(void) ;
static struct Example examples___28[2]  = {      {"Usage", "/* printf(\"Hello my name is %s, I\'m %i\\n\", \"Dan\", 23); */\nformat_to($(File, stdout), 0, \n  \"Hello my name is %s, I\'m %i\\n\", \"Dan\", 23);\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Format_Examples(void) 
{ 


  {
  return (examples___28);
}
}
static struct Method *Format_Methods(void) ;
static struct Method methods___22[3]  = {      {"format_to", "int format_to(var self, int pos, const char* fmt, ...);\nint format_to_va(var self, int pos, const char* fmt, va_list va);",
      "Write a formatted string `fmt` to the object `self` at position `pos`."}, 
        {"format_from", "int format_from(var self, int pos, const char* fmt, ...);\nint format_from_va(var self, int pos, const char* fmt, va_list va);",
      "Read a formatted string `fmt` from the object `self` at position `pos`."}, 
        {(char const   *)((void *)0), (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Format_Methods(void) 
{ 


  {
  return (methods___22);
}
}
static struct Doc __constr_expr_808  =    {& Format_Name, & Format_Brief, & Format_Description, & Format_Definition, & Format_Examples,
    & Format_Methods};
static var __constr_expr_807[33]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Format", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Format ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_808),      (void *)0,      (void *)0, 
        (void *)0};
var Format  =    (var )((char *)(__constr_expr_807) + sizeof(struct Header ));
int format_to_va(var self , int pos , char const   *fmt , va_list___0 va ) 
{ 
  var tmp ;
  int tmp___0 ;

  {
  tmp = method_at_offset(self, Format, (unsigned long )(& ((struct Format *)0)->format_to),
                         "format_to");
  tmp___0 = (*(((struct Format *)tmp)->format_to))(self, pos, fmt, va);
  return (tmp___0);
}
}
int format_from_va(var self , int pos , char const   *fmt , va_list___0 va ) 
{ 
  var tmp ;
  int tmp___0 ;

  {
  tmp = method_at_offset(self, Format, (unsigned long )(& ((struct Format *)0)->format_from),
                         "format_from");
  tmp___0 = (*(((struct Format *)tmp)->format_from))(self, pos, fmt, va);
  return (tmp___0);
}
}
int format_to(var self , int pos , char const   *fmt  , ...) 
{ 
  va_list___0 va ;
  int ret ;
  int tmp ;

  {
  __builtin_va_start(va, fmt);
  tmp = format_to_va(self, pos, fmt, va);
  ret = tmp;
  __builtin_va_end(va);
  return (ret);
}
}
int format_from(var self , int pos , char const   *fmt  , ...) 
{ 
  va_list___0 va ;
  int ret ;
  int tmp ;

  {
  __builtin_va_start(va, fmt);
  tmp = format_from_va(self, pos, fmt, va);
  ret = tmp;
  __builtin_va_end(va);
  return (ret);
}
}
static char const   *Show_Name(void) 
{ 


  {
  return ("Show");
}
}
static char const   *Show_Brief(void) 
{ 


  {
  return ("Convert To or From String");
}
}
static char const   *Show_Description(void) 
{ 


  {
  return ("The `Show` class is used to convert objects to, and from, a `String` representation. Objects which implement `Show` should expect the input/output object to be one that support the `Format` class, such as `File` or `String`.\n\nThe `print`, `println` and `print_to` functions provide a mechanism for writing formatted strings with Cello objects. To do this they provide a new format specifier `%$` which uses an object\'s `Show` functionality to write that part of the string. All objects which don\'t support `Show` can still be shown via a default implementation.\n\nAll the Show methods which are variable arguments only take `var` objects as input. To print native C types wrap them in Cello types using `$`.\n\nStandard format specifiers such as `%f` and `%d` will call functions such as `c_float` and `c_int` on their passed arguments to convert objects to C types before performing the standard C formatting behaviour.\n\nSee [printf](http://www.cplusplus.com/reference/cstdio/printf/) for more information on format specifiers.");
}
}
static char const   *Show_Definition(void) 
{ 


  {
  return ("struct Show {\n  int (*show)(var, var, int);\n  int (*look)(var, var, int);\n};\n");
}
}
static struct Example *Show_Examples(void) ;
static struct Example examples___29[5]  = {      {"Hello World", "println(\"Hello %s!\", $S(\"World\"));\n"}, 
        {"File Writing", "with (f in new(File, $S(\"prices.txt\"), $S(\"wb\"))) {\n  print_to(f, 0, \"%$ :: %$\\n\", $S(\"Banana\"), $I(57));\n  print_to(f, 0, \"%$ :: %$\\n\", $S(\"Apple\"),  $I(22));\n  print_to(f, 0, \"%$ :: %$\\n\", $S(\"Pear\"),   $I(16));\n}\n"}, 
        {"String Scanning",
      "var input = $S(\"1 and 52 then 78\");\n\nvar i0 = $I(0), i1 = $I(0), i2 = $I(0);\nscan_from(input, 0, \"%i and %i then %i\", i0, i1, i2);\n\n/* i0: 1, i1: 52, i2: 78 */\nprintln(\"i0: %$, i1: %$, i2: %$\", i0, i1, i2);\n"}, 
        {"String Printing",
      "var greeting = new(String);\nprint_to(greeting, 0, \"Hello %s %s, %s?\", \n  $S(\"Mr\"), $S(\"Johnson\"), $S(\"how are you?\"));\n\n/* Hello Mr Johnson, how are you? */\nshow(greeting);\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Show_Examples(void) 
{ 


  {
  return (examples___29);
}
}
static struct Method *Show_Methods(void) ;
static struct Method methods___23[5]  = {      {"show", "int show(var self);\nint show_to(var self, var out, int pos);", "Show the object `self` either to `stdout` or to the object `output`."}, 
        {"look",
      "int look(var self);\nint look_from(var self, var input, int pos);", "Read the object `self` either from `stdout` or from the object `input`."}, 
        {"print",
      "#define print(fmt, ...)\n#define println(fmt, ...)\n#define print_to(out, pos, fmt, ...)\nint print_with(const char* fmt, var args);\nint println_with(const char* fmt, var args);\nint print_to_with(var out, int pos, const char* fmt, var args);",
      "Print the format string `fmt` either to `stdout` or to the object `out` at positions `pos`. Returns new position in output."}, 
        {"scan",
      "#define scan(fmt, ...)\n#define scanln(fmt, ...)\n#define scan_from(input, pos, fmt, ...)\nint scan_with(const char* fmt, var args);\nint scanln_with(const char* fmt, var args);\nint scan_from_with(var input, int pos, const char* fmt, var args);",
      "Scan the format string `fmt` either from `stdin` or from the object `input` at position `pos`. Returns new position in output."}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Show_Methods(void) 
{ 


  {
  return (methods___23);
}
}
static struct Doc __constr_expr_810  =    {& Show_Name, & Show_Brief, & Show_Description, & Show_Definition, & Show_Examples,
    & Show_Methods};
static var __constr_expr_809[33]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Show", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Show ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_810),      (void *)0,      (void *)0, 
        (void *)0};
var Show  =    (var )((char *)(__constr_expr_809) + sizeof(struct Header ));
int show(var self ) 
{ 
  struct File __constr_expr_811 ;
  char __constr_expr_812[sizeof(struct Header ) + sizeof(struct File )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  __constr_expr_811.file = stdout;
  __constr_expr_812[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_812[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_812), File, 2);
  tmp___1 = memcpy((void * __restrict  )((struct File *)tmp___0), (void const   * __restrict  )(& __constr_expr_811),
                   sizeof(struct File ));
  tmp___2 = show_to(self, (var )((struct File *)tmp___1), 0);
  return (tmp___2);
}
}
int show_to(var self , var out , int pos ) 
{ 
  struct Show *s ;
  var tmp ;
  int tmp___0 ;
  struct Tuple __constr_expr_813 ;
  var __constr_expr_814[3] ;
  var tmp___1 ;
  char __constr_expr_815[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___2 ;
  var tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;

  {
  tmp = instance(self, Show);
  s = (struct Show *)tmp;
  if (s) {
    if (s->show) {
      tmp___0 = (*(s->show))(self, out, pos);
      return (tmp___0);
    }
  }
  tmp___1 = type_of(self);
  __constr_expr_814[0] = tmp___1;
  __constr_expr_814[1] = self;
  __constr_expr_814[2] = Terminal;
  __constr_expr_813.items = __constr_expr_814;
  __constr_expr_815[0] = (char)0;
  tmp___2 = 1U;
  while (! (tmp___2 >= 32U)) {
    __constr_expr_815[tmp___2] = (char)0;
    tmp___2 ++;
  }
  tmp___3 = header_init((var )(__constr_expr_815), Tuple, 2);
  tmp___4 = memcpy((void * __restrict  )((struct Tuple *)tmp___3), (void const   * __restrict  )(& __constr_expr_813),
                   sizeof(struct Tuple ));
  tmp___5 = print_to_with(out, pos, "<\'%s\' At 0x%p>", (var )((struct Tuple *)tmp___4));
  return (tmp___5);
}
}
int print_with(char const   *fmt , var args ) 
{ 
  struct File __constr_expr_816 ;
  char __constr_expr_817[sizeof(struct Header ) + sizeof(struct File )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  __constr_expr_816.file = stdout;
  __constr_expr_817[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_817[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_817), File, 2);
  tmp___1 = memcpy((void * __restrict  )((struct File *)tmp___0), (void const   * __restrict  )(& __constr_expr_816),
                   sizeof(struct File ));
  tmp___2 = print_to_with((var )((struct File *)tmp___1), 0, fmt, args);
  return (tmp___2);
}
}
int println_with(char const   *fmt , var args ) 
{ 
  int pos ;
  struct File __constr_expr_818 ;
  char __constr_expr_819[sizeof(struct Header ) + sizeof(struct File )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  struct Tuple __constr_expr_820 ;
  var __constr_expr_821[1] ;
  char __constr_expr_822[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___2 ;
  var tmp___3 ;
  void *tmp___4 ;
  struct File __constr_expr_823 ;
  char __constr_expr_824[sizeof(struct Header ) + sizeof(struct File )] ;
  unsigned int tmp___5 ;
  var tmp___6 ;
  void *tmp___7 ;

  {
  pos = 0;
  __constr_expr_818.file = stdout;
  __constr_expr_819[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_819[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_819), File, 2);
  tmp___1 = memcpy((void * __restrict  )((struct File *)tmp___0), (void const   * __restrict  )(& __constr_expr_818),
                   sizeof(struct File ));
  pos = print_to_with((var )((struct File *)tmp___1), pos, fmt, args);
  __constr_expr_821[0] = Terminal;
  __constr_expr_820.items = __constr_expr_821;
  __constr_expr_822[0] = (char)0;
  tmp___2 = 1U;
  while (! (tmp___2 >= 32U)) {
    __constr_expr_822[tmp___2] = (char)0;
    tmp___2 ++;
  }
  tmp___3 = header_init((var )(__constr_expr_822), Tuple, 2);
  tmp___4 = memcpy((void * __restrict  )((struct Tuple *)tmp___3), (void const   * __restrict  )(& __constr_expr_820),
                   sizeof(struct Tuple ));
  __constr_expr_823.file = stdout;
  __constr_expr_824[0] = (char)0;
  tmp___5 = 1U;
  while (! (tmp___5 >= 32U)) {
    __constr_expr_824[tmp___5] = (char)0;
    tmp___5 ++;
  }
  tmp___6 = header_init((var )(__constr_expr_824), File, 2);
  tmp___7 = memcpy((void * __restrict  )((struct File *)tmp___6), (void const   * __restrict  )(& __constr_expr_823),
                   sizeof(struct File ));
  pos = print_to_with((var )((struct File *)tmp___7), pos, "\n", (var )((struct Tuple *)tmp___4));
  return (pos);
}
}
int print_to_with(var out , int pos , char const   *fmt , var args ) 
{ 
  char *fmt_buf ;
  size_t tmp ;
  void *tmp___0 ;
  size_t index___0 ;
  char const   *start___0 ;
  int off ;
  int tmp___1 ;
  struct Tuple __constr_expr_825 ;
  var __constr_expr_826[1] ;
  char __constr_expr_827[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___2 ;
  var tmp___3 ;
  void *tmp___4 ;
  int off___0 ;
  int tmp___5 ;
  struct Tuple __constr_expr_828 ;
  var __constr_expr_829[1] ;
  char __constr_expr_830[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___6 ;
  var tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  struct Tuple __constr_expr_831 ;
  var __constr_expr_832[1] ;
  char __constr_expr_833[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___10 ;
  var tmp___11 ;
  void *tmp___12 ;
  size_t tmp___13 ;
  var a ;
  struct Int __constr_expr_834 ;
  char __constr_expr_835[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___14 ;
  var tmp___15 ;
  void *tmp___16 ;
  var tmp___17 ;
  int off___1 ;
  char *tmp___18 ;
  int tmp___19 ;
  struct Tuple __constr_expr_836 ;
  var __constr_expr_837[1] ;
  char __constr_expr_838[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___20 ;
  var tmp___21 ;
  void *tmp___22 ;
  int off___2 ;
  int64_t tmp___23 ;
  int tmp___24 ;
  struct Tuple __constr_expr_839 ;
  var __constr_expr_840[1] ;
  char __constr_expr_841[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___25 ;
  var tmp___26 ;
  void *tmp___27 ;
  char *tmp___28 ;
  int off___3 ;
  double tmp___29 ;
  int tmp___30 ;
  struct Tuple __constr_expr_842 ;
  var __constr_expr_843[1] ;
  char __constr_expr_844[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___31 ;
  var tmp___32 ;
  void *tmp___33 ;
  char *tmp___34 ;
  int off___4 ;
  int64_t tmp___35 ;
  int tmp___36 ;
  struct Tuple __constr_expr_845 ;
  var __constr_expr_846[1] ;
  char __constr_expr_847[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___37 ;
  var tmp___38 ;
  void *tmp___39 ;
  int off___5 ;
  int tmp___40 ;
  struct Tuple __constr_expr_848 ;
  var __constr_expr_849[1] ;
  char __constr_expr_850[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___41 ;
  var tmp___42 ;
  void *tmp___43 ;
  struct Tuple __constr_expr_851 ;
  var __constr_expr_852[1] ;
  char __constr_expr_853[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___44 ;
  var tmp___45 ;
  void *tmp___46 ;

  {
  tmp = strlen(fmt);
  tmp___0 = malloc(tmp + 1UL);
  fmt_buf = (char *)tmp___0;
  index___0 = (size_t )0;
  while (! ((int const   )*fmt == 0)) {
    start___0 = fmt;
    while (1) {
      if ((int const   )*fmt != 0) {
        if (! ((int const   )*fmt != 37)) {
          break;
        }
      } else {
        break;
      }
      fmt ++;
    }
    if ((unsigned long )start___0 != (unsigned long )fmt) {
      memcpy((void * __restrict  )fmt_buf, (void const   * __restrict  )start___0,
             (size_t )(fmt - start___0));
      *(fmt_buf + (fmt - start___0)) = (char )'\000';
      tmp___1 = format_to(out, pos, (char const   *)fmt_buf);
      off = tmp___1;
      if (off < 0) {
        __constr_expr_826[0] = Terminal;
        __constr_expr_825.items = __constr_expr_826;
        __constr_expr_827[0] = (char)0;
        tmp___2 = 1U;
        while (! (tmp___2 >= 32U)) {
          __constr_expr_827[tmp___2] = (char)0;
          tmp___2 ++;
        }
        tmp___3 = header_init((var )(__constr_expr_827), Tuple, 2);
        tmp___4 = memcpy((void * __restrict  )((struct Tuple *)tmp___3), (void const   * __restrict  )(& __constr_expr_825),
                         sizeof(struct Tuple ));
        exception_throw(FormatError, "Unable to output format!", (var )((struct Tuple *)tmp___4));
      }
      pos += off;
      continue;
    }
    if ((int const   )*fmt == 37) {
      if ((int const   )*(fmt + 1) == 37) {
        tmp___5 = format_to(out, pos, "%%");
        off___0 = tmp___5;
        if (off___0 < 0) {
          __constr_expr_829[0] = Terminal;
          __constr_expr_828.items = __constr_expr_829;
          __constr_expr_830[0] = (char)0;
          tmp___6 = 1U;
          while (! (tmp___6 >= 32U)) {
            __constr_expr_830[tmp___6] = (char)0;
            tmp___6 ++;
          }
          tmp___7 = header_init((var )(__constr_expr_830), Tuple, 2);
          tmp___8 = memcpy((void * __restrict  )((struct Tuple *)tmp___7), (void const   * __restrict  )(& __constr_expr_828),
                           sizeof(struct Tuple ));
          exception_throw(FormatError, "Unable to output \'%%%%\'!", (var )((struct Tuple *)tmp___8));
        }
        pos += off___0;
        fmt += 2;
        continue;
      }
    }
    while (1) {
      tmp___9 = strchr("diuoxXfFeEgGaAxcsp$", (int )*fmt);
      if (tmp___9) {
        break;
      }
      fmt ++;
    }
    if ((unsigned long )start___0 != (unsigned long )fmt) {
      memcpy((void * __restrict  )fmt_buf, (void const   * __restrict  )start___0,
             (size_t )((fmt - start___0) + 1L));
      *(fmt_buf + ((fmt - start___0) + 1L)) = (char )'\000';
      tmp___13 = len(args);
      if (index___0 >= tmp___13) {
        __constr_expr_832[0] = Terminal;
        __constr_expr_831.items = __constr_expr_832;
        __constr_expr_833[0] = (char)0;
        tmp___10 = 1U;
        while (! (tmp___10 >= 32U)) {
          __constr_expr_833[tmp___10] = (char)0;
          tmp___10 ++;
        }
        tmp___11 = header_init((var )(__constr_expr_833), Tuple, 2);
        tmp___12 = memcpy((void * __restrict  )((struct Tuple *)tmp___11), (void const   * __restrict  )(& __constr_expr_831),
                          sizeof(struct Tuple ));
        exception_throw(FormatError, "Not enough arguments to Format String!", (var )((struct Tuple *)tmp___12));
      }
      __constr_expr_834.val = (int64_t )index___0;
      __constr_expr_835[0] = (char)0;
      tmp___14 = 1U;
      while (! (tmp___14 >= 32U)) {
        __constr_expr_835[tmp___14] = (char)0;
        tmp___14 ++;
      }
      tmp___15 = header_init((var )(__constr_expr_835), Int, 2);
      tmp___16 = memcpy((void * __restrict  )((struct Int *)tmp___15), (void const   * __restrict  )(& __constr_expr_834),
                        sizeof(struct Int ));
      tmp___17 = get(args, (var )((struct Int *)tmp___16));
      a = tmp___17;
      index___0 ++;
      if ((int const   )*fmt == 36) {
        pos = show_to(a, out, pos);
      }
      if ((int const   )*fmt == 115) {
        tmp___18 = c_str(a);
        tmp___19 = format_to(out, pos, (char const   *)fmt_buf, tmp___18);
        off___1 = tmp___19;
        if (off___1 < 0) {
          __constr_expr_837[0] = Terminal;
          __constr_expr_836.items = __constr_expr_837;
          __constr_expr_838[0] = (char)0;
          tmp___20 = 1U;
          while (! (tmp___20 >= 32U)) {
            __constr_expr_838[tmp___20] = (char)0;
            tmp___20 ++;
          }
          tmp___21 = header_init((var )(__constr_expr_838), Tuple, 2);
          tmp___22 = memcpy((void * __restrict  )((struct Tuple *)tmp___21), (void const   * __restrict  )(& __constr_expr_836),
                            sizeof(struct Tuple ));
          exception_throw(FormatError, "Unable to output String!", (var )((struct Tuple *)tmp___22));
        }
        pos += off___1;
      }
      tmp___28 = strchr("diouxX", (int )*fmt);
      if (tmp___28) {
        tmp___23 = c_int(a);
        tmp___24 = format_to(out, pos, (char const   *)fmt_buf, tmp___23);
        off___2 = tmp___24;
        if (off___2 < 0) {
          __constr_expr_840[0] = Terminal;
          __constr_expr_839.items = __constr_expr_840;
          __constr_expr_841[0] = (char)0;
          tmp___25 = 1U;
          while (! (tmp___25 >= 32U)) {
            __constr_expr_841[tmp___25] = (char)0;
            tmp___25 ++;
          }
          tmp___26 = header_init((var )(__constr_expr_841), Tuple, 2);
          tmp___27 = memcpy((void * __restrict  )((struct Tuple *)tmp___26), (void const   * __restrict  )(& __constr_expr_839),
                            sizeof(struct Tuple ));
          exception_throw(FormatError, "Unable to output Int!", (var )((struct Tuple *)tmp___27));
        }
        pos += off___2;
      }
      tmp___34 = strchr("fFeEgGaA", (int )*fmt);
      if (tmp___34) {
        tmp___29 = c_float(a);
        tmp___30 = format_to(out, pos, (char const   *)fmt_buf, tmp___29);
        off___3 = tmp___30;
        if (off___3 < 0) {
          __constr_expr_843[0] = Terminal;
          __constr_expr_842.items = __constr_expr_843;
          __constr_expr_844[0] = (char)0;
          tmp___31 = 1U;
          while (! (tmp___31 >= 32U)) {
            __constr_expr_844[tmp___31] = (char)0;
            tmp___31 ++;
          }
          tmp___32 = header_init((var )(__constr_expr_844), Tuple, 2);
          tmp___33 = memcpy((void * __restrict  )((struct Tuple *)tmp___32), (void const   * __restrict  )(& __constr_expr_842),
                            sizeof(struct Tuple ));
          exception_throw(FormatError, "Unable to output Real!", (var )((struct Tuple *)tmp___33));
        }
        pos += off___3;
      }
      if ((int const   )*fmt == 99) {
        tmp___35 = c_int(a);
        tmp___36 = format_to(out, pos, (char const   *)fmt_buf, tmp___35);
        off___4 = tmp___36;
        if (off___4 < 0) {
          __constr_expr_846[0] = Terminal;
          __constr_expr_845.items = __constr_expr_846;
          __constr_expr_847[0] = (char)0;
          tmp___37 = 1U;
          while (! (tmp___37 >= 32U)) {
            __constr_expr_847[tmp___37] = (char)0;
            tmp___37 ++;
          }
          tmp___38 = header_init((var )(__constr_expr_847), Tuple, 2);
          tmp___39 = memcpy((void * __restrict  )((struct Tuple *)tmp___38), (void const   * __restrict  )(& __constr_expr_845),
                            sizeof(struct Tuple ));
          exception_throw(FormatError, "Unable to output Char!", (var )((struct Tuple *)tmp___39));
        }
        pos += off___4;
      }
      if ((int const   )*fmt == 112) {
        tmp___40 = format_to(out, pos, (char const   *)fmt_buf, a);
        off___5 = tmp___40;
        if (off___5 < 0) {
          __constr_expr_849[0] = Terminal;
          __constr_expr_848.items = __constr_expr_849;
          __constr_expr_850[0] = (char)0;
          tmp___41 = 1U;
          while (! (tmp___41 >= 32U)) {
            __constr_expr_850[tmp___41] = (char)0;
            tmp___41 ++;
          }
          tmp___42 = header_init((var )(__constr_expr_850), Tuple, 2);
          tmp___43 = memcpy((void * __restrict  )((struct Tuple *)tmp___42), (void const   * __restrict  )(& __constr_expr_848),
                            sizeof(struct Tuple ));
          exception_throw(FormatError, "Unable to output Object!", (var )((struct Tuple *)tmp___43));
        }
        pos += off___5;
      }
      fmt ++;
      continue;
    }
    __constr_expr_852[0] = Terminal;
    __constr_expr_851.items = __constr_expr_852;
    __constr_expr_853[0] = (char)0;
    tmp___44 = 1U;
    while (! (tmp___44 >= 32U)) {
      __constr_expr_853[tmp___44] = (char)0;
      tmp___44 ++;
    }
    tmp___45 = header_init((var )(__constr_expr_853), Tuple, 2);
    tmp___46 = memcpy((void * __restrict  )((struct Tuple *)tmp___45), (void const   * __restrict  )(& __constr_expr_851),
                      sizeof(struct Tuple ));
    exception_throw(FormatError, "Invalid Format String!", (var )((struct Tuple *)tmp___46));
  }
  free((void *)fmt_buf);
  return (pos);
}
}
int look(var self ) 
{ 
  struct File __constr_expr_854 ;
  char __constr_expr_855[sizeof(struct Header ) + sizeof(struct File )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  __constr_expr_854.file = stdin;
  __constr_expr_855[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_855[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_855), File, 2);
  tmp___1 = memcpy((void * __restrict  )((struct File *)tmp___0), (void const   * __restrict  )(& __constr_expr_854),
                   sizeof(struct File ));
  tmp___2 = look_from(self, (var )((struct File *)tmp___1), 0);
  return (tmp___2);
}
}
int look_from(var self , var input , int pos ) 
{ 
  var tmp ;
  int tmp___0 ;

  {
  tmp = method_at_offset(self, Show, (unsigned long )(& ((struct Show *)0)->look),
                         "look");
  tmp___0 = (*(((struct Show *)tmp)->look))(self, input, pos);
  return (tmp___0);
}
}
int scan_with(char const   *fmt , var args ) 
{ 
  struct File __constr_expr_856 ;
  char __constr_expr_857[sizeof(struct Header ) + sizeof(struct File )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  __constr_expr_856.file = stdin;
  __constr_expr_857[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_857[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_857), File, 2);
  tmp___1 = memcpy((void * __restrict  )((struct File *)tmp___0), (void const   * __restrict  )(& __constr_expr_856),
                   sizeof(struct File ));
  tmp___2 = scan_from_with((var )((struct File *)tmp___1), 0, fmt, args);
  return (tmp___2);
}
}
int scanln_with(char const   *fmt , var args ) 
{ 
  int pos ;
  struct File __constr_expr_858 ;
  char __constr_expr_859[sizeof(struct Header ) + sizeof(struct File )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  struct Tuple __constr_expr_860 ;
  var __constr_expr_861[1] ;
  char __constr_expr_862[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___2 ;
  var tmp___3 ;
  void *tmp___4 ;
  struct File __constr_expr_863 ;
  char __constr_expr_864[sizeof(struct Header ) + sizeof(struct File )] ;
  unsigned int tmp___5 ;
  var tmp___6 ;
  void *tmp___7 ;

  {
  pos = 0;
  __constr_expr_858.file = stdin;
  __constr_expr_859[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_859[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_859), File, 2);
  tmp___1 = memcpy((void * __restrict  )((struct File *)tmp___0), (void const   * __restrict  )(& __constr_expr_858),
                   sizeof(struct File ));
  pos = scan_from_with((var )((struct File *)tmp___1), pos, fmt, args);
  __constr_expr_861[0] = Terminal;
  __constr_expr_860.items = __constr_expr_861;
  __constr_expr_862[0] = (char)0;
  tmp___2 = 1U;
  while (! (tmp___2 >= 32U)) {
    __constr_expr_862[tmp___2] = (char)0;
    tmp___2 ++;
  }
  tmp___3 = header_init((var )(__constr_expr_862), Tuple, 2);
  tmp___4 = memcpy((void * __restrict  )((struct Tuple *)tmp___3), (void const   * __restrict  )(& __constr_expr_860),
                   sizeof(struct Tuple ));
  __constr_expr_863.file = stdin;
  __constr_expr_864[0] = (char)0;
  tmp___5 = 1U;
  while (! (tmp___5 >= 32U)) {
    __constr_expr_864[tmp___5] = (char)0;
    tmp___5 ++;
  }
  tmp___6 = header_init((var )(__constr_expr_864), File, 2);
  tmp___7 = memcpy((void * __restrict  )((struct File *)tmp___6), (void const   * __restrict  )(& __constr_expr_863),
                   sizeof(struct File ));
  pos = scan_from_with((var )((struct File *)tmp___7), pos, "\n", (var )((struct Tuple *)tmp___4));
  return (pos);
}
}
int scan_from_with(var input , int pos , char const   *fmt , var args ) 
{ 
  char *fmt_buf ;
  size_t tmp ;
  void *tmp___0 ;
  size_t index___0 ;
  char const   *start___0 ;
  int err ;
  int tmp___1 ;
  struct Tuple __constr_expr_865 ;
  var __constr_expr_866[1] ;
  char __constr_expr_867[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___2 ;
  var tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  int off ;
  struct Tuple __constr_expr_868 ;
  var __constr_expr_869[1] ;
  char __constr_expr_870[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___6 ;
  var tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  var a ;
  struct Int __constr_expr_871 ;
  char __constr_expr_872[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___10 ;
  var tmp___11 ;
  void *tmp___12 ;
  var tmp___13 ;
  int err___0 ;
  char *tmp___14 ;
  int tmp___15 ;
  struct Tuple __constr_expr_873 ;
  var __constr_expr_874[1] ;
  char __constr_expr_875[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___16 ;
  var tmp___17 ;
  void *tmp___18 ;
  int err___1 ;
  char *tmp___19 ;
  int tmp___20 ;
  struct Tuple __constr_expr_876 ;
  var __constr_expr_877[1] ;
  char __constr_expr_878[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___21 ;
  var tmp___22 ;
  void *tmp___23 ;
  long tmp___24 ;
  int err___2 ;
  int tmp___25 ;
  struct Tuple __constr_expr_879 ;
  var __constr_expr_880[1] ;
  char __constr_expr_881[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___26 ;
  var tmp___27 ;
  void *tmp___28 ;
  struct Int __constr_expr_882 ;
  char __constr_expr_883[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___29 ;
  var tmp___30 ;
  void *tmp___31 ;
  double tmp___32 ;
  int err___3 ;
  int tmp___33 ;
  struct Tuple __constr_expr_884 ;
  var __constr_expr_885[1] ;
  char __constr_expr_886[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___34 ;
  var tmp___35 ;
  void *tmp___36 ;
  struct Float __constr_expr_887 ;
  char __constr_expr_888[sizeof(struct Header ) + sizeof(struct Float )] ;
  unsigned int tmp___37 ;
  var tmp___38 ;
  void *tmp___39 ;
  float tmp___40 ;
  int err___4 ;
  int tmp___41 ;
  struct Tuple __constr_expr_889 ;
  var __constr_expr_890[1] ;
  char __constr_expr_891[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___42 ;
  var tmp___43 ;
  void *tmp___44 ;
  struct Float __constr_expr_892 ;
  char __constr_expr_893[sizeof(struct Header ) + sizeof(struct Float )] ;
  unsigned int tmp___45 ;
  var tmp___46 ;
  void *tmp___47 ;
  char *tmp___48 ;
  char tmp___49 ;
  int err___5 ;
  int tmp___50 ;
  struct Tuple __constr_expr_894 ;
  var __constr_expr_895[1] ;
  char __constr_expr_896[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___51 ;
  var tmp___52 ;
  void *tmp___53 ;
  struct Int __constr_expr_897 ;
  char __constr_expr_898[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___54 ;
  var tmp___55 ;
  void *tmp___56 ;
  void *tmp___57 ;
  int err___6 ;
  int tmp___58 ;
  struct Tuple __constr_expr_899 ;
  var __constr_expr_900[1] ;
  char __constr_expr_901[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___59 ;
  var tmp___60 ;
  void *tmp___61 ;
  struct Ref __constr_expr_902 ;
  char __constr_expr_903[sizeof(struct Header ) + sizeof(struct Ref )] ;
  unsigned int tmp___62 ;
  var tmp___63 ;
  void *tmp___64 ;
  struct Tuple __constr_expr_904 ;
  var __constr_expr_905[1] ;
  char __constr_expr_906[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___65 ;
  var tmp___66 ;
  void *tmp___67 ;
  char *tmp___68 ;
  char *tmp___69 ;

  {
  tmp = strlen(fmt);
  tmp___0 = malloc(tmp + 4UL);
  fmt_buf = (char *)tmp___0;
  index___0 = (size_t )0;
  while (! ((int const   )*fmt == 0)) {
    start___0 = fmt;
    while (1) {
      if ((int const   )*fmt != 0) {
        if (! ((int const   )*fmt != 37)) {
          break;
        }
      } else {
        break;
      }
      fmt ++;
    }
    if ((unsigned long )start___0 != (unsigned long )fmt) {
      memcpy((void * __restrict  )fmt_buf, (void const   * __restrict  )start___0,
             (size_t )(fmt - start___0));
      *(fmt_buf + (fmt - start___0)) = (char )'\000';
      format_from(input, pos, (char const   *)fmt_buf);
      pos += (int )(fmt - start___0);
      continue;
    }
    if ((int const   )*fmt == 37) {
      if ((int const   )*(fmt + 1) == 37) {
        tmp___1 = format_from(input, pos, "%%");
        err = tmp___1;
        if (err < 0) {
          __constr_expr_866[0] = Terminal;
          __constr_expr_865.items = __constr_expr_866;
          __constr_expr_867[0] = (char)0;
          tmp___2 = 1U;
          while (! (tmp___2 >= 32U)) {
            __constr_expr_867[tmp___2] = (char)0;
            tmp___2 ++;
          }
          tmp___3 = header_init((var )(__constr_expr_867), Tuple, 2);
          tmp___4 = memcpy((void * __restrict  )((struct Tuple *)tmp___3), (void const   * __restrict  )(& __constr_expr_865),
                           sizeof(struct Tuple ));
          exception_throw(FormatError, "Unable to input \'%%%%\'!", (var )((struct Tuple *)tmp___4));
        }
        pos += 2;
        fmt += 2;
        continue;
      }
    }
    while (1) {
      tmp___5 = strchr("diuoxXfFeEgGaAxcsp$[^]", (int )*fmt);
      if (tmp___5) {
        break;
      }
      fmt ++;
    }
    if ((unsigned long )start___0 != (unsigned long )fmt) {
      off = 0;
      memcpy((void * __restrict  )fmt_buf, (void const   * __restrict  )start___0,
             (size_t )((fmt - start___0) + 1L));
      *(fmt_buf + ((fmt - start___0) + 1L)) = (char )'\000';
      strcat((char * __restrict  )fmt_buf, (char const   * __restrict  )"%n");
      tmp___9 = len(args);
      if (index___0 >= tmp___9) {
        __constr_expr_869[0] = Terminal;
        __constr_expr_868.items = __constr_expr_869;
        __constr_expr_870[0] = (char)0;
        tmp___6 = 1U;
        while (! (tmp___6 >= 32U)) {
          __constr_expr_870[tmp___6] = (char)0;
          tmp___6 ++;
        }
        tmp___7 = header_init((var )(__constr_expr_870), Tuple, 2);
        tmp___8 = memcpy((void * __restrict  )((struct Tuple *)tmp___7), (void const   * __restrict  )(& __constr_expr_868),
                         sizeof(struct Tuple ));
        exception_throw(FormatError, "Not enough arguments to Format String!", (var )((struct Tuple *)tmp___8));
      }
      __constr_expr_871.val = (int64_t )index___0;
      __constr_expr_872[0] = (char)0;
      tmp___10 = 1U;
      while (! (tmp___10 >= 32U)) {
        __constr_expr_872[tmp___10] = (char)0;
        tmp___10 ++;
      }
      tmp___11 = header_init((var )(__constr_expr_872), Int, 2);
      tmp___12 = memcpy((void * __restrict  )((struct Int *)tmp___11), (void const   * __restrict  )(& __constr_expr_871),
                        sizeof(struct Int ));
      tmp___13 = get(args, (var )((struct Int *)tmp___12));
      a = tmp___13;
      index___0 ++;
      if ((int const   )*fmt == 36) {
        pos = look_from(a, input, pos);
      } else
      if ((int const   )*fmt == 115) {
        tmp___14 = c_str(a);
        tmp___15 = format_from(input, pos, (char const   *)fmt_buf, tmp___14, & off);
        err___0 = tmp___15;
        if (err___0 < 1) {
          __constr_expr_874[0] = Terminal;
          __constr_expr_873.items = __constr_expr_874;
          __constr_expr_875[0] = (char)0;
          tmp___16 = 1U;
          while (! (tmp___16 >= 32U)) {
            __constr_expr_875[tmp___16] = (char)0;
            tmp___16 ++;
          }
          tmp___17 = header_init((var )(__constr_expr_875), Tuple, 2);
          tmp___18 = memcpy((void * __restrict  )((struct Tuple *)tmp___17), (void const   * __restrict  )(& __constr_expr_873),
                            sizeof(struct Tuple ));
          exception_throw(FormatError, "Unable to input String!", (var )((struct Tuple *)tmp___18));
        }
        pos += off;
      } else
      if ((int const   )*fmt == 93) {
        tmp___19 = c_str(a);
        tmp___20 = format_from(input, pos, (char const   *)fmt_buf, tmp___19, & off);
        err___1 = tmp___20;
        if (err___1 < 1) {
          __constr_expr_877[0] = Terminal;
          __constr_expr_876.items = __constr_expr_877;
          __constr_expr_878[0] = (char)0;
          tmp___21 = 1U;
          while (! (tmp___21 >= 32U)) {
            __constr_expr_878[tmp___21] = (char)0;
            tmp___21 ++;
          }
          tmp___22 = header_init((var )(__constr_expr_878), Tuple, 2);
          tmp___23 = memcpy((void * __restrict  )((struct Tuple *)tmp___22), (void const   * __restrict  )(& __constr_expr_876),
                            sizeof(struct Tuple ));
          exception_throw(FormatError, "Unable to input Scanset!", (var )((struct Tuple *)tmp___23));
        }
        pos += off;
      } else {
        tmp___69 = strchr("diouxX", (int )*fmt);
        if (tmp___69) {
          tmp___24 = 0L;
          tmp___25 = format_from(input, pos, (char const   *)fmt_buf, & tmp___24,
                                 & off);
          err___2 = tmp___25;
          if (err___2 < 1) {
            __constr_expr_880[0] = Terminal;
            __constr_expr_879.items = __constr_expr_880;
            __constr_expr_881[0] = (char)0;
            tmp___26 = 1U;
            while (! (tmp___26 >= 32U)) {
              __constr_expr_881[tmp___26] = (char)0;
              tmp___26 ++;
            }
            tmp___27 = header_init((var )(__constr_expr_881), Tuple, 2);
            tmp___28 = memcpy((void * __restrict  )((struct Tuple *)tmp___27), (void const   * __restrict  )(& __constr_expr_879),
                              sizeof(struct Tuple ));
            exception_throw(FormatError, "Unable to input Int!", (var )((struct Tuple *)tmp___28));
          }
          pos += off;
          __constr_expr_882.val = tmp___24;
          __constr_expr_883[0] = (char)0;
          tmp___29 = 1U;
          while (! (tmp___29 >= 32U)) {
            __constr_expr_883[tmp___29] = (char)0;
            tmp___29 ++;
          }
          tmp___30 = header_init((var )(__constr_expr_883), Int, 2);
          tmp___31 = memcpy((void * __restrict  )((struct Int *)tmp___30), (void const   * __restrict  )(& __constr_expr_882),
                            sizeof(struct Int ));
          assign(a, (var )((struct Int *)tmp___31));
        } else {
          tmp___68 = strchr("fFeEgGaA", (int )*fmt);
          if (tmp___68) {
            tmp___48 = strchr((char const   *)fmt_buf, 'l');
            if (tmp___48) {
              tmp___32 = (double )0;
              tmp___33 = format_from(input, pos, (char const   *)fmt_buf, & tmp___32,
                                     & off);
              err___3 = tmp___33;
              if (err___3 < 1) {
                __constr_expr_885[0] = Terminal;
                __constr_expr_884.items = __constr_expr_885;
                __constr_expr_886[0] = (char)0;
                tmp___34 = 1U;
                while (! (tmp___34 >= 32U)) {
                  __constr_expr_886[tmp___34] = (char)0;
                  tmp___34 ++;
                }
                tmp___35 = header_init((var )(__constr_expr_886), Tuple, 2);
                tmp___36 = memcpy((void * __restrict  )((struct Tuple *)tmp___35),
                                  (void const   * __restrict  )(& __constr_expr_884),
                                  sizeof(struct Tuple ));
                exception_throw(FormatError, "Unable to input Float!", (var )((struct Tuple *)tmp___36));
              }
              pos += off;
              __constr_expr_887.val = tmp___32;
              __constr_expr_888[0] = (char)0;
              tmp___37 = 1U;
              while (! (tmp___37 >= 32U)) {
                __constr_expr_888[tmp___37] = (char)0;
                tmp___37 ++;
              }
              tmp___38 = header_init((var )(__constr_expr_888), Float, 2);
              tmp___39 = memcpy((void * __restrict  )((struct Float *)tmp___38), (void const   * __restrict  )(& __constr_expr_887),
                                sizeof(struct Float ));
              assign(a, (var )((struct Float *)tmp___39));
            } else {
              tmp___40 = (float )0;
              tmp___41 = format_from(input, pos, (char const   *)fmt_buf, & tmp___40,
                                     & off);
              err___4 = tmp___41;
              if (err___4 < 1) {
                __constr_expr_890[0] = Terminal;
                __constr_expr_889.items = __constr_expr_890;
                __constr_expr_891[0] = (char)0;
                tmp___42 = 1U;
                while (! (tmp___42 >= 32U)) {
                  __constr_expr_891[tmp___42] = (char)0;
                  tmp___42 ++;
                }
                tmp___43 = header_init((var )(__constr_expr_891), Tuple, 2);
                tmp___44 = memcpy((void * __restrict  )((struct Tuple *)tmp___43),
                                  (void const   * __restrict  )(& __constr_expr_889),
                                  sizeof(struct Tuple ));
                exception_throw(FormatError, "Unable to input Float!", (var )((struct Tuple *)tmp___44));
              }
              pos += off;
              __constr_expr_892.val = (double )tmp___40;
              __constr_expr_893[0] = (char)0;
              tmp___45 = 1U;
              while (! (tmp___45 >= 32U)) {
                __constr_expr_893[tmp___45] = (char)0;
                tmp___45 ++;
              }
              tmp___46 = header_init((var )(__constr_expr_893), Float, 2);
              tmp___47 = memcpy((void * __restrict  )((struct Float *)tmp___46), (void const   * __restrict  )(& __constr_expr_892),
                                sizeof(struct Float ));
              assign(a, (var )((struct Float *)tmp___47));
            }
          } else
          if ((int const   )*fmt == 99) {
            tmp___49 = (char )'\000';
            tmp___50 = format_from(input, pos, (char const   *)fmt_buf, & tmp___49,
                                   & off);
            err___5 = tmp___50;
            if (err___5 < 1) {
              __constr_expr_895[0] = Terminal;
              __constr_expr_894.items = __constr_expr_895;
              __constr_expr_896[0] = (char)0;
              tmp___51 = 1U;
              while (! (tmp___51 >= 32U)) {
                __constr_expr_896[tmp___51] = (char)0;
                tmp___51 ++;
              }
              tmp___52 = header_init((var )(__constr_expr_896), Tuple, 2);
              tmp___53 = memcpy((void * __restrict  )((struct Tuple *)tmp___52), (void const   * __restrict  )(& __constr_expr_894),
                                sizeof(struct Tuple ));
              exception_throw(FormatError, "Unable to input Char!", (var )((struct Tuple *)tmp___53));
            }
            pos += off;
            __constr_expr_897.val = (int64_t )tmp___49;
            __constr_expr_898[0] = (char)0;
            tmp___54 = 1U;
            while (! (tmp___54 >= 32U)) {
              __constr_expr_898[tmp___54] = (char)0;
              tmp___54 ++;
            }
            tmp___55 = header_init((var )(__constr_expr_898), Int, 2);
            tmp___56 = memcpy((void * __restrict  )((struct Int *)tmp___55), (void const   * __restrict  )(& __constr_expr_897),
                              sizeof(struct Int ));
            assign(a, (var )((struct Int *)tmp___56));
          } else
          if ((int const   )*fmt == 112) {
            tmp___57 = (void *)0;
            tmp___58 = format_from(input, pos, (char const   *)fmt_buf, & tmp___57,
                                   & off);
            err___6 = tmp___58;
            if (err___6 < 1) {
              __constr_expr_900[0] = Terminal;
              __constr_expr_899.items = __constr_expr_900;
              __constr_expr_901[0] = (char)0;
              tmp___59 = 1U;
              while (! (tmp___59 >= 32U)) {
                __constr_expr_901[tmp___59] = (char)0;
                tmp___59 ++;
              }
              tmp___60 = header_init((var )(__constr_expr_901), Tuple, 2);
              tmp___61 = memcpy((void * __restrict  )((struct Tuple *)tmp___60), (void const   * __restrict  )(& __constr_expr_899),
                                sizeof(struct Tuple ));
              exception_throw(FormatError, "Unable to input Ref!", (var )((struct Tuple *)tmp___61));
            }
            pos += off;
            __constr_expr_902.val = tmp___57;
            __constr_expr_903[0] = (char)0;
            tmp___62 = 1U;
            while (! (tmp___62 >= 32U)) {
              __constr_expr_903[tmp___62] = (char)0;
              tmp___62 ++;
            }
            tmp___63 = header_init((var )(__constr_expr_903), Ref, 2);
            tmp___64 = memcpy((void * __restrict  )((struct Ref *)tmp___63), (void const   * __restrict  )(& __constr_expr_902),
                              sizeof(struct Ref ));
            assign(a, (var )((struct Ref *)tmp___64));
          } else {
            __constr_expr_905[0] = Terminal;
            __constr_expr_904.items = __constr_expr_905;
            __constr_expr_906[0] = (char)0;
            tmp___65 = 1U;
            while (! (tmp___65 >= 32U)) {
              __constr_expr_906[tmp___65] = (char)0;
              tmp___65 ++;
            }
            tmp___66 = header_init((var )(__constr_expr_906), Tuple, 2);
            tmp___67 = memcpy((void * __restrict  )((struct Tuple *)tmp___66), (void const   * __restrict  )(& __constr_expr_904),
                              sizeof(struct Tuple ));
            exception_throw(FormatError, "Invalid Format Specifier!", (var )((struct Tuple *)tmp___67));
          }
        }
      }
      fmt ++;
      continue;
    }
  }
  free((void *)fmt_buf);
  return (pos);
}
}
#pragma merger("0","/tmp/cil-R0bUg2Yf.i","-std=gnu99,-Wall,-Wno-unused,-g,-ggdb,-fPIC")
var Function ;
var Call ;
static char const   *Call_Name(void) 
{ 


  {
  return ("Call");
}
}
static char const   *Call_Brief(void) 
{ 


  {
  return ("Callable");
}
}
static char const   *Call_Description(void) 
{ 


  {
  return ("The `Call` class is used by types which can be called as functions.");
}
}
static char const   *Call_Definition(void) 
{ 


  {
  return ("struct Call {\n  var (*call_with)(var, var);\n};\n");
}
}
static struct Example *Call_Examples(void) ;
static struct Example examples___30[2]  = {      {"Usage", "var increment(var args) {\n  struct Int* i = get(args, $I(0));\n  i->val++;\n  return NULL;\n}\n\nvar x = $I(0);\nshow(x); /* 0 */\ncall($(Function, increment), x);\nshow(x); /* 1 */\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Call_Examples(void) 
{ 


  {
  return (examples___30);
}
}
static struct Method *Call_Methods(void) ;
static struct Method methods___24[2]  = {      {"call", "#define call(self, ...)\nvar call_with(var self, var args);", "Call the object `self` with arguments `args`."}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Call_Methods(void) 
{ 


  {
  return (methods___24);
}
}
static struct Doc __constr_expr_908  =    {& Call_Name, & Call_Brief, & Call_Description, & Call_Definition, & Call_Examples,
    & Call_Methods};
static var __constr_expr_907[33]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Call", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Call ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_908),      (void *)0,      (void *)0, 
        (void *)0};
var Call  =    (var )((char *)(__constr_expr_907) + sizeof(struct Header ));
var call_with(var self , var args ) 
{ 
  var tmp ;
  var tmp___0 ;

  {
  tmp = method_at_offset(self, Call, (unsigned long )(& ((struct Call *)0)->call_with),
                         "call_with");
  tmp___0 = (*(((struct Call *)tmp)->call_with))(self, args);
  return (tmp___0);
}
}
static char const   *Function_Name(void) 
{ 


  {
  return ("Function");
}
}
static char const   *Function_Brief(void) 
{ 


  {
  return ("Function Object");
}
}
static char const   *Function_Description(void) 
{ 


  {
  return ("The `Function` type allows C function pointers to be treated as Cello objects. They can be passed around, stored, and manipulated. Only C functions of the type `var(*)(var)` can be stored as a `Function` type and when called the arguments will be wrapped into an iterable and passed as the first argument, typically in the form of a `tuple`.");
}
}
static struct Example *Function_Examples(void) ;
static struct Example examples___31[4]  = {      {"Usage", "var increment(var args) {\n  struct Int* i = get(args, $I(0));\n  i->val++;\n  return NULL;\n}\n\nvar x = $I(0);\nshow(x); /* 0 */\ncall($(Function, increment), x);\nshow(x); /* 1 */\n"}, 
        {"Usage 2",
      "var hello_person(var args) {\n  print(\"Hello %$!\", get(args, $I(0)));\n  return NULL;\n}\n\ncall($(Function, hello_person), $S(\"Dan\"));\n"}, 
        {"Usage 3",
      "var add_print(var args) {\n  int64_t fst = c_int(get(args, $I(0)));\n  int64_t snd = c_int(get(args, $I(1)));\n  println(\"%i + %i = %i\", $I(fst), $I(snd), $I(fst+snd));\n  return NULL;\n}\n\ncall($(Function, add_print), $I(10), $I(21));\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Function_Examples(void) 
{ 


  {
  return (examples___31);
}
}
static char const   *Function_Definition(void) 
{ 


  {
  return ("struct Function {\n  var (*func)(var);\n};\n");
}
}
static var Function_Call(var self , var args ) 
{ 
  struct Function *f ;
  var tmp ;

  {
  f = (struct Function *)self;
  tmp = (*(f->func))(args);
  return (tmp);
}
}
static struct Doc __constr_expr_910  =    {& Function_Name, & Function_Brief, & Function_Description, & Function_Definition,
    & Function_Examples, (struct Method *(*)(void))((void *)0)};
static struct Call __constr_expr_911  =    {& Function_Call};
static var __constr_expr_909[36]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Function", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Function ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_910),      (void *)0,      (var )"Call", 
        (var )(& __constr_expr_911),      (void *)0,      (void *)0,      (void *)0};
var Function  =    (var )((char *)(__constr_expr_909) + sizeof(struct Header ));
#pragma merger("0","/tmp/cil-Dyb0DuOG.i","-std=gnu99,-Wall,-Wno-unused,-g,-ggdb,-fPIC")
var Copy ;
var alloc(var type ) ;
var alloc_raw(var type ) ;
var alloc_root(var type ) ;
void dealloc(var self ) ;
void dealloc_raw(var self ) ;
void dealloc_root(var self ) ;
var construct_with(var self , var args ) ;
var new_root_with(var type , var args ) ;
void del_root(var self ) ;
var copy(var self ) ;
var GC ;
struct Header *header(var self ) 
{ 


  {
  return ((struct Header *)((char *)self - sizeof(struct Header )));
}
}
var header_init(var head , var type , int alloc___0 ) 
{ 
  struct Header *self ;

  {
  self = (struct Header *)head;
  self->type = type;
  self->alloc = (var )((intptr_t )alloc___0);
  self->magic = (var )844048;
  return ((var )((char *)self + sizeof(struct Header )));
}
}
static char const   *Alloc_Name(void) 
{ 


  {
  return ("Alloc");
}
}
static char const   *Alloc_Brief(void) 
{ 


  {
  return ("Memory Allocation");
}
}
static char const   *Alloc_Description(void) 
{ 


  {
  return ("The `Alloc` class can be used to override how memory is allocated for a given data type. By default memory is allocated using `calloc` along with the `Size` class to determine the amount of memory to allocate.\n\nA custom allocator should be careful to also initialise the header for the allocated memory using the function `header_init`. Cello objects without a header wont be recognised as such as so will throw errors when used with Cello functions.\n\nAllocated memory is automatically registered with the garbage collector unless the functions `alloc_raw` and `dealloc_raw` are used.");
}
}
static char const   *Alloc_Definition(void) 
{ 


  {
  return ("struct Alloc {\n  var (*alloc)(void);\n  void (*dealloc)(var);\n};");
}
}
static struct Example *Alloc_Examples(void) ;
static struct Example examples___32[3]  = {      {"Usage", "/* Allocation deallocated by Garbage Collector */\nvar x = alloc(Int);\nconstruct(x, $I(10));\n"}, 
        {"Avoid Garbage Collection",
      "/* Allocation must be manually deallocated */\nvar x = alloc_raw(Int);\nconstruct(x, $I(10));\ndestruct(x);\ndealloc_raw(x);\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Alloc_Examples(void) 
{ 


  {
  return (examples___32);
}
}
static struct Method *Alloc_Methods(void) ;
static struct Method methods___25[4]  = {      {"$", "#define $(T, ...)\n#define $I(X)\n#define $F(X)\n#define $S(X)\n#define $R(X)\n#define $B(X)",
      "Allocate memory for the given type `T` on the stack and copy in the given arguments `...` as struct members. Shorthand constructors exist for native types:\n\n* `$I -> Int` `$F -> Float` `$S -> String`\n* `$R -> Ref` `$B -> Box`\n\n"}, 
        {"alloc",
      "#define alloc_stack(T)\nvar alloc(var type);\nvar alloc_raw(var type);\nvar alloc_root(var type);",
      "Allocate memory for a given `type`. To avoid the Garbage Collector completely use `alloc_raw`, to register the allocation as a root use `alloc_root`. In the case of raw or root allocations the corresponding `dealloc` function should be used when done. Memory allocated with `alloc_stack` is not managed by the Garbage Collector."}, 
        {"dealloc",
      "void dealloc(var self);\nvoid dealloc_raw(var self);\nvoid dealloc_root(var self);",
      "Deallocate memory for object `self` manually. If registered with the Garbage Collector then entry will be removed. If the `raw` variation is used memory will be deallocated without going via the Garbage Collector."}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Alloc_Methods(void) 
{ 


  {
  return (methods___25);
}
}
static struct Doc __constr_expr_913  =    {& Alloc_Name, & Alloc_Brief, & Alloc_Description, & Alloc_Definition, & Alloc_Examples,
    & Alloc_Methods};
static var __constr_expr_912[33]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Alloc", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Alloc ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_913),      (void *)0,      (void *)0, 
        (void *)0};
var Alloc  =    (var )((char *)(__constr_expr_912) + sizeof(struct Header ));
static var alloc_by(var type , int method ) 
{ 
  struct Alloc *a ;
  var tmp ;
  var self ;
  struct Header *head ;
  size_t tmp___0 ;
  void *tmp___1 ;
  struct Tuple __constr_expr_914 ;
  var __constr_expr_915[2] ;
  char __constr_expr_916[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___2 ;
  var tmp___3 ;
  void *tmp___4 ;
  struct Int __constr_expr_917 ;
  char __constr_expr_918[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___5 ;
  var tmp___6 ;
  void *tmp___7 ;
  var tmp___8 ;
  struct Int __constr_expr_919 ;
  char __constr_expr_920[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___9 ;
  var tmp___10 ;
  void *tmp___11 ;
  var tmp___12 ;

  {
  tmp = type_instance(type, Alloc);
  a = (struct Alloc *)tmp;
  if (a) {
    if (a->alloc) {
      self = (*(a->alloc))();
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    tmp___0 = size(type);
    tmp___1 = calloc((size_t )1, sizeof(struct Header ) + tmp___0);
    head = (struct Header *)tmp___1;
    if ((unsigned long )head == (unsigned long )((void *)0)) {
      __constr_expr_915[0] = type;
      __constr_expr_915[1] = Terminal;
      __constr_expr_914.items = __constr_expr_915;
      __constr_expr_916[0] = (char)0;
      tmp___2 = 1U;
      while (! (tmp___2 >= 32U)) {
        __constr_expr_916[tmp___2] = (char)0;
        tmp___2 ++;
      }
      tmp___3 = header_init((var )(__constr_expr_916), Tuple, 2);
      tmp___4 = memcpy((void * __restrict  )((struct Tuple *)tmp___3), (void const   * __restrict  )(& __constr_expr_914),
                       sizeof(struct Tuple ));
      exception_throw(OutOfMemoryError, "Cannot create new \'%s\', out of memory!",
                      (var )((struct Tuple *)tmp___4));
    }
    self = header_init((var )head, type, 3);
  }
  switch (method) {
  case 0: 
  __constr_expr_917.val = (int64_t )0;
  __constr_expr_918[0] = (char)0;
  tmp___5 = 1U;
  while (! (tmp___5 >= 32U)) {
    __constr_expr_918[tmp___5] = (char)0;
    tmp___5 ++;
  }
  tmp___6 = header_init((var )(__constr_expr_918), Int, 2);
  tmp___7 = memcpy((void * __restrict  )((struct Int *)tmp___6), (void const   * __restrict  )(& __constr_expr_917),
                   sizeof(struct Int ));
  tmp___8 = current(GC);
  set(tmp___8, self, (var )((struct Int *)tmp___7));
  break;
  case 1: 
  break;
  case 2: 
  __constr_expr_919.val = (int64_t )1;
  __constr_expr_920[0] = (char)0;
  tmp___9 = 1U;
  while (! (tmp___9 >= 32U)) {
    __constr_expr_920[tmp___9] = (char)0;
    tmp___9 ++;
  }
  tmp___10 = header_init((var )(__constr_expr_920), Int, 2);
  tmp___11 = memcpy((void * __restrict  )((struct Int *)tmp___10), (void const   * __restrict  )(& __constr_expr_919),
                    sizeof(struct Int ));
  tmp___12 = current(GC);
  set(tmp___12, self, (var )((struct Int *)tmp___11));
  break;
  }
  return (self);
}
}
var alloc(var type ) 
{ 
  var tmp ;

  {
  tmp = alloc_by(type, 0);
  return (tmp);
}
}
var alloc_raw(var type ) 
{ 
  var tmp ;

  {
  tmp = alloc_by(type, 1);
  return (tmp);
}
}
var alloc_root(var type ) 
{ 
  var tmp ;

  {
  tmp = alloc_by(type, 2);
  return (tmp);
}
}
void dealloc(var self ) 
{ 
  struct Alloc *a ;
  var tmp ;
  struct Tuple __constr_expr_921 ;
  var __constr_expr_922[1] ;
  char __constr_expr_923[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;
  struct Tuple __constr_expr_924 ;
  var __constr_expr_925[2] ;
  char __constr_expr_926[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;
  struct Header *tmp___6 ;
  struct Tuple __constr_expr_927 ;
  var __constr_expr_928[2] ;
  char __constr_expr_929[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___7 ;
  var tmp___8 ;
  void *tmp___9 ;
  struct Header *tmp___10 ;
  struct Tuple __constr_expr_930 ;
  var __constr_expr_931[2] ;
  char __constr_expr_932[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___11 ;
  var tmp___12 ;
  void *tmp___13 ;
  struct Header *tmp___14 ;
  size_t s ;
  var tmp___15 ;
  size_t tmp___16 ;
  size_t i ;
  struct Header *tmp___17 ;

  {
  tmp = instance(self, Alloc);
  a = (struct Alloc *)tmp;
  if (a) {
    if (a->dealloc) {
      (*(a->dealloc))(self);
      return;
    }
  }
  if ((unsigned long )self == (unsigned long )((void *)0)) {
    __constr_expr_922[0] = Terminal;
    __constr_expr_921.items = __constr_expr_922;
    __constr_expr_923[0] = (char)0;
    tmp___0 = 1U;
    while (! (tmp___0 >= 32U)) {
      __constr_expr_923[tmp___0] = (char)0;
      tmp___0 ++;
    }
    tmp___1 = header_init((var )(__constr_expr_923), Tuple, 2);
    tmp___2 = memcpy((void * __restrict  )((struct Tuple *)tmp___1), (void const   * __restrict  )(& __constr_expr_921),
                     sizeof(struct Tuple ));
    exception_throw(ResourceError, "Attempt to deallocate NULL!", (var )((struct Tuple *)tmp___2));
  }
  tmp___6 = header(self);
  if ((unsigned long )tmp___6->alloc == (unsigned long )((var )1)) {
    __constr_expr_925[0] = self;
    __constr_expr_925[1] = Terminal;
    __constr_expr_924.items = __constr_expr_925;
    __constr_expr_926[0] = (char)0;
    tmp___3 = 1U;
    while (! (tmp___3 >= 32U)) {
      __constr_expr_926[tmp___3] = (char)0;
      tmp___3 ++;
    }
    tmp___4 = header_init((var )(__constr_expr_926), Tuple, 2);
    tmp___5 = memcpy((void * __restrict  )((struct Tuple *)tmp___4), (void const   * __restrict  )(& __constr_expr_924),
                     sizeof(struct Tuple ));
    exception_throw(ResourceError, "Attempt to deallocate %$ which was allocated statically!",
                    (var )((struct Tuple *)tmp___5));
  }
  tmp___10 = header(self);
  if ((unsigned long )tmp___10->alloc == (unsigned long )((var )2)) {
    __constr_expr_928[0] = self;
    __constr_expr_928[1] = Terminal;
    __constr_expr_927.items = __constr_expr_928;
    __constr_expr_929[0] = (char)0;
    tmp___7 = 1U;
    while (! (tmp___7 >= 32U)) {
      __constr_expr_929[tmp___7] = (char)0;
      tmp___7 ++;
    }
    tmp___8 = header_init((var )(__constr_expr_929), Tuple, 2);
    tmp___9 = memcpy((void * __restrict  )((struct Tuple *)tmp___8), (void const   * __restrict  )(& __constr_expr_927),
                     sizeof(struct Tuple ));
    exception_throw(ResourceError, "Attempt to deallocate %$ which was allocated on the stack!",
                    (var )((struct Tuple *)tmp___9));
  }
  tmp___14 = header(self);
  if ((unsigned long )tmp___14->alloc == (unsigned long )((var )4)) {
    __constr_expr_931[0] = self;
    __constr_expr_931[1] = Terminal;
    __constr_expr_930.items = __constr_expr_931;
    __constr_expr_932[0] = (char)0;
    tmp___11 = 1U;
    while (! (tmp___11 >= 32U)) {
      __constr_expr_932[tmp___11] = (char)0;
      tmp___11 ++;
    }
    tmp___12 = header_init((var )(__constr_expr_932), Tuple, 2);
    tmp___13 = memcpy((void * __restrict  )((struct Tuple *)tmp___12), (void const   * __restrict  )(& __constr_expr_930),
                      sizeof(struct Tuple ));
    exception_throw(ResourceError, "Attempt to deallocate %$ which was allocated inside a data structure!",
                    (var )((struct Tuple *)tmp___13));
  }
  tmp___15 = type_of(self);
  tmp___16 = size(tmp___15);
  s = tmp___16;
  i = (size_t )0;
  while (i < (sizeof(struct Header ) + s) / sizeof(var )) {
    tmp___17 = header(self);
    *((var *)tmp___17 + i) = (var )59774918928L;
    i ++;
  }
  free((void *)((char *)self - sizeof(struct Header )));
  return;
}
}
void dealloc_raw(var self ) 
{ 


  {
  dealloc(self);
  return;
}
}
void dealloc_root(var self ) 
{ 


  {
  dealloc(self);
  return;
}
}
static char const   *New_Name(void) 
{ 


  {
  return ("New");
}
}
static char const   *New_Brief(void) 
{ 


  {
  return ("Construction and Destruction");
}
}
static char const   *New_Description(void) 
{ 


  {
  return ("The `New` class allows the user to define constructors and destructors for a type, accessible via `new` and `del`. Objects allocated with `new` are allocated on the heap and also registered with the Garbage Collector this means technically it isn\'t required to call `del` on them as they will be cleaned up at a later date.\n\nThe `new_root` function can be called to register a variable with the Garbage Collector but to indicate that it will be manually destructed with `del_root` by the user. This should be used for variables that wont be reachable by the Garbage Collector such as those in the data segment or only accessible via vanilla C structures.\n\nThe `new_raw` and `del_raw` functions can be called to construct and destruct objects without going via the Garbage Collector.\n\nIt is also possible to simply call the `construct` and `destruct` functions if you wish to construct an already allocated object.\n\nConstructors should assume that memory is zero\'d for an object but nothing else.");
}
}
static char const   *New_Definition(void) 
{ 


  {
  return ("struct New {\n  void (*construct_with)(var, var);\n  void (*destruct)(var);\n};\n");
}
}
static struct Example *New_Examples(void) ;
static struct Example examples___33[2]  = {      {"Usage", "var x = new(Int, $I(1));\nshow(x); /* 1 */\nshow(type_of(x)); /* Int */\n\nvar y = alloc(Float);\nconstruct(y, $F(1.0));\nshow(y); /* 1.0 */\ndestruct(y);\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *New_Examples(void) 
{ 


  {
  return (examples___33);
}
}
static struct Method *New_Methods(void) ;
static struct Method methods___26[5]  = {      {"new", "#define new(T, ...)\n#define new_raw(T, ...)\n#define new_root(T, ...)\nvar new_with(var type, var args);\nvar new_raw_with(var type, var args);\nvar new_root_with(var type, var args);",
      "Construct a new object of a given `type`. Use `new_raw` to avoid the Garbage Collector completely, and `new_root` to register the allocation as a Garbage Collection root. In the case of raw and root allocations they must be destructed with the corresponding deletion functions."}, 
        {"del",
      "void del(var self);\nvoid del_raw(var self);\nvoid del_root(var self);", "Destruct the object `self` manually. If registered with the Garbage Collector then entry will be removed. If `del_raw` is used thenthe destruction will be done without going via the Garbage Collector."}, 
        {"construct",
      "#define construct(self, ...)\nvar construct_with(var self, var args);", "Call the constructor on object `self` which has already been allocated."}, 
        {"destruct",
      "var destruct(var self);", "Call the destructor on object `self` without deallocating the memory for it."}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *New_Methods(void) 
{ 


  {
  return (methods___26);
}
}
static struct Doc __constr_expr_934  =    {& New_Name, & New_Brief, & New_Description, & New_Definition, & New_Examples,
    & New_Methods};
static var __constr_expr_933[33]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"New", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct New ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_934),      (void *)0,      (void *)0, 
        (void *)0};
var New  =    (var )((char *)(__constr_expr_933) + sizeof(struct Header ));
var construct_with(var self , var args ) 
{ 
  struct New *n ;
  var tmp ;
  struct Int __constr_expr_935 ;
  char __constr_expr_936[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;
  var tmp___3 ;
  size_t tmp___4 ;

  {
  tmp = instance(self, New);
  n = (struct New *)tmp;
  if (n) {
    if (n->construct_with) {
      (*(n->construct_with))(self, args);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    tmp___4 = len(args);
    if (tmp___4 == 1UL) {
      __constr_expr_935.val = (int64_t )0;
      __constr_expr_936[0] = (char)0;
      tmp___0 = 1U;
      while (! (tmp___0 >= 32U)) {
        __constr_expr_936[tmp___0] = (char)0;
        tmp___0 ++;
      }
      tmp___1 = header_init((var )(__constr_expr_936), Int, 2);
      tmp___2 = memcpy((void * __restrict  )((struct Int *)tmp___1), (void const   * __restrict  )(& __constr_expr_935),
                       sizeof(struct Int ));
      tmp___3 = get(args, (var )((struct Int *)tmp___2));
      assign(self, tmp___3);
    }
  }
  return (self);
}
}
var destruct(var self ) 
{ 
  struct New *n ;
  var tmp ;

  {
  tmp = instance(self, New);
  n = (struct New *)tmp;
  if (n) {
    if (n->destruct) {
      (*(n->destruct))(self);
    }
  }
  return (self);
}
}
var new_with(var type , var args ) 
{ 
  var tmp ;
  var tmp___0 ;

  {
  tmp = alloc(type);
  tmp___0 = construct_with(tmp, args);
  return (tmp___0);
}
}
var new_raw_with(var type , var args ) 
{ 
  var tmp ;
  var tmp___0 ;

  {
  tmp = alloc_raw(type);
  tmp___0 = construct_with(tmp, args);
  return (tmp___0);
}
}
var new_root_with(var type , var args ) 
{ 
  var tmp ;
  var tmp___0 ;

  {
  tmp = alloc_root(type);
  tmp___0 = construct_with(tmp, args);
  return (tmp___0);
}
}
static void del_by(var self , int method ) 
{ 
  var tmp ;
  var tmp___0 ;

  {
  switch (method) {
  case 2: 
  case 0: 
  tmp = current(GC);
  rem(tmp, self);
  return;
  break;
  case 1: 
  break;
  }
  tmp___0 = destruct(self);
  dealloc(tmp___0);
  return;
}
}
void del(var self ) 
{ 


  {
  del_by(self, 0);
  return;
}
}
void del_raw(var self ) 
{ 


  {
  del_by(self, 1);
  return;
}
}
void del_root(var self ) 
{ 


  {
  del_by(self, 2);
  return;
}
}
static char const   *Copy_Name(void) 
{ 


  {
  return ("Copy");
}
}
static char const   *Copy_Brief(void) 
{ 


  {
  return ("Copyable");
}
}
static char const   *Copy_Description(void) 
{ 


  {
  return ("The `Copy` class can be used to override the behaviour of an object when a copy is made of it. By default the `Copy` class allocates a new empty object of the same type and uses the `Assign` class to set the contents. The copy is then registered with the Garbage Collector as if it had been constructed with `new`. This means when using manual memory management a copy must be deleted manually.\n\nIf the `copy` class is overridden then the implementer may manually have to register the object with the Garbage Collector if they wish for it to be tracked.\n\nBy convention `copy` follows the semantics of `Assign`, which typically means a _deep copy_ should be made, and that an object will create a copy of all of the sub-objects it references or contains - although this could vary depending on the type\'s overridden behaviours.");
}
}
static char const   *Copy_Definition(void) 
{ 


  {
  return ("struct Copy {\n  var (*copy)(var);\n};\n");
}
}
static struct Example *Copy_Examples(void) ;
static struct Example examples___34[2]  = {      {"Usage", "var x = new(String, $S(\"Hello\"));\nvar y = copy(x);\nshow(x); /* Hello */\nshow(y); /* Hello */\nshow($I(eq(x, y))); /* 1 */\nshow($I(x is y)); /* 0 */\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Copy_Examples(void) 
{ 


  {
  return (examples___34);
}
}
static struct Method *Copy_Methods(void) ;
static struct Method methods___27[2]  = {      {"copy", "var copy(var self);", "Make a copy of the object `self`."}, 
        {(char const   *)((void *)0), (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Copy_Methods(void) 
{ 


  {
  return (methods___27);
}
}
static struct Doc __constr_expr_938  =    {& Copy_Name, & Copy_Brief, & Copy_Description, & Copy_Definition, & Copy_Examples,
    & Copy_Methods};
static var __constr_expr_937[33]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Copy", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Copy ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_938),      (void *)0,      (void *)0, 
        (void *)0};
var Copy  =    (var )((char *)(__constr_expr_937) + sizeof(struct Header ));
var copy(var self ) 
{ 
  struct Copy *c ;
  var tmp ;
  var tmp___0 ;
  var tmp___1 ;
  var tmp___2 ;
  var tmp___3 ;

  {
  tmp = instance(self, Copy);
  c = (struct Copy *)tmp;
  if (c) {
    if (c->copy) {
      tmp___0 = (*(c->copy))(self);
      return (tmp___0);
    }
  }
  tmp___1 = type_of(self);
  tmp___2 = alloc(tmp___1);
  tmp___3 = assign(tmp___2, self);
  return (tmp___3);
}
}
#pragma merger("0","/tmp/cil-Zu1Ur_hb.i","-std=gnu99,-Wall,-Wno-unused,-g,-ggdb,-fPIC")
void append(var self , var obj ) ;
void concat(var self , var obj ) ;
static char const   *Concat_Name(void) 
{ 


  {
  return ("Concat");
}
}
static char const   *Concat_Brief(void) 
{ 


  {
  return ("Concatenate Objects");
}
}
static char const   *Concat_Description(void) 
{ 


  {
  return ("The `Concat` class is implemented by objects that can have other objects either _appended_ to their, on _concatenated_ to them. For example collections or strings.");
}
}
static char const   *Concat_Definition(void) 
{ 


  {
  return ("struct Concat {\n  void (*concat)(var, var);\n  void (*append)(var, var);\n};\n");
}
}
static struct Example *Concat_Examples(void) ;
static struct Example examples___35[2]  = {      {"Usage", "var x = new(Array, Float, $F(9.9), $F(2.8));\nvar y = new(Array, Float, $F(1.1), $F(6.5));\n\nshow(x); /* <\'Array\' At 0x00414603 [9.9, 2.8]> */\nshow(y); /* <\'Array\' At 0x00414603 [1.1, 6.5]> */\nappend(x, $F(2.5));\nshow(x); /* <\'Array\' At 0x00414603 [9.9, 2.8, 2.5]> */\nconcat(x, y);\nshow(x); /* <\'Array\' At 0x00414603 [9.9, 2.8, 2.5, 1.1, 6.5]> */\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Concat_Examples(void) 
{ 


  {
  return (examples___35);
}
}
static struct Method *Concat_Methods(void) ;
static struct Method methods___28[3]  = {      {"append", "void append(var self, var obj);", "Append the object `obj` to the object `self`."}, 
        {"concat",
      "void concat(var self, var obj);", "Concatenate the object `obj` to the object `self`."}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Concat_Methods(void) 
{ 


  {
  return (methods___28);
}
}
static struct Doc __constr_expr_940  =    {& Concat_Name, & Concat_Brief, & Concat_Description, & Concat_Definition, & Concat_Examples,
    & Concat_Methods};
static var __constr_expr_939[33]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Concat", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Concat ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_940),      (void *)0,      (void *)0, 
        (void *)0};
var Concat  =    (var )((char *)(__constr_expr_939) + sizeof(struct Header ));
void append(var self , var obj ) 
{ 
  var tmp ;

  {
  tmp = method_at_offset(self, Concat, (unsigned long )(& ((struct Concat *)0)->append),
                         "append");
  (*(((struct Concat *)tmp)->append))(self, obj);
  return;
}
}
void concat(var self , var obj ) 
{ 
  var tmp ;

  {
  tmp = method_at_offset(self, Concat, (unsigned long )(& ((struct Concat *)0)->concat),
                         "concat");
  (*(((struct Concat *)tmp)->concat))(self, obj);
  return;
}
}
#pragma merger("0","/tmp/cil-MkFjjcnL.i","-std=gnu99,-Wall,-Wno-unused,-g,-ggdb,-fPIC")
static char const   *C_Int_Name(void) 
{ 


  {
  return ("C_Int");
}
}
static char const   *C_Int_Brief(void) 
{ 


  {
  return ("Interpret as C Integer");
}
}
static char const   *C_Int_Description(void) 
{ 


  {
  return ("The `C_Int` class should be overridden by types which are representable as a C style Integer of the type `int64_t`.");
}
}
static char const   *C_Int_Definition(void) 
{ 


  {
  return ("struct C_Int {\n  int64_t (*c_int)(var);\n};\n");
}
}
static struct Example *C_Int_Examples(void) ;
static struct Example examples___36[2]  = {      {"Usage", "printf(\"%li\", c_int($I(5))); /* 5 */\nprintf(\"%li\", c_int($I(6))); /* 6 */\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *C_Int_Examples(void) 
{ 


  {
  return (examples___36);
}
}
static struct Method *C_Int_Methods(void) ;
static struct Method methods___29[2]  = {      {"c_int", "int64_t c_int(var self);", "Returns the object `self` represented as a `int64_t`."}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *C_Int_Methods(void) 
{ 


  {
  return (methods___29);
}
}
static struct Doc __constr_expr_942  =    {& C_Int_Name, & C_Int_Brief, & C_Int_Description, & C_Int_Definition, & C_Int_Examples,
    & C_Int_Methods};
static var __constr_expr_941[33]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"C_Int", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct C_Int ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_942),      (void *)0,      (void *)0, 
        (void *)0};
var C_Int  =    (var )((char *)(__constr_expr_941) + sizeof(struct Header ));
static char const   *C_Float_Name(void) 
{ 


  {
  return ("C_Float");
}
}
static char const   *C_Float_Brief(void) 
{ 


  {
  return ("Interpret as C Float");
}
}
static char const   *C_Float_Description(void) 
{ 


  {
  return ("The `C_Float` class should be overridden by types which are representable as a C style Float of the type `double`.");
}
}
static char const   *C_Float_Definition(void) 
{ 


  {
  return ("struct C_Float {\n  double (*c_float)(var);\n};\n");
}
}
static struct Example *C_Float_Examples(void) ;
static struct Example examples___37[2]  = {      {"Usage", "printf(\"%f\", c_float($F(5.1))); /* 5.1 */\nprintf(\"%f\", c_float($F(6.2))); /* 6.2 */\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *C_Float_Examples(void) 
{ 


  {
  return (examples___37);
}
}
static struct Method *C_Float_Methods(void) ;
static struct Method methods___30[2]  = {      {"c_float", "double c_float(var self);", "Returns the object `self` represented as a `double`."}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *C_Float_Methods(void) 
{ 


  {
  return (methods___30);
}
}
static struct Doc __constr_expr_944  =    {& C_Float_Name, & C_Float_Brief, & C_Float_Description, & C_Float_Definition,
    & C_Float_Examples, & C_Float_Methods};
static var __constr_expr_943[33]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"C_Float", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct C_Float ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_944),      (void *)0,      (void *)0, 
        (void *)0};
var C_Float  =    (var )((char *)(__constr_expr_943) + sizeof(struct Header ));
int64_t c_int(var self ) 
{ 
  var tmp ;
  var tmp___0 ;
  int64_t tmp___1 ;

  {
  tmp = type_of(self);
  if ((unsigned long )tmp == (unsigned long )Int) {
    return (((struct Int *)self)->val);
  }
  tmp___0 = method_at_offset(self, C_Int, (unsigned long )(& ((struct C_Int *)0)->c_int),
                             "c_int");
  tmp___1 = (*(((struct C_Int *)tmp___0)->c_int))(self);
  return (tmp___1);
}
}
double c_float(var self ) 
{ 
  var tmp ;
  var tmp___0 ;
  double tmp___1 ;

  {
  tmp = type_of(self);
  if ((unsigned long )tmp == (unsigned long )Float) {
    return (((struct Float *)self)->val);
  }
  tmp___0 = method_at_offset(self, C_Float, (unsigned long )(& ((struct C_Float *)0)->c_float),
                             "c_float");
  tmp___1 = (*(((struct C_Float *)tmp___0)->c_float))(self);
  return (tmp___1);
}
}
static char const   *Int_Name(void) 
{ 


  {
  return ("Int");
}
}
static char const   *Int_Brief(void) 
{ 


  {
  return ("Integer Object");
}
}
static char const   *Int_Description(void) 
{ 


  {
  return ("64-bit signed integer Object.");
}
}
static char const   *Int_Definition(void) 
{ 


  {
  return ("struct Int {\n  int64_t val;\n};\n");
}
}
static struct Example *Int_Examples(void) ;
static struct Example examples___38[2]  = {      {"Usage", "var i0 = $(Int, 1);\nvar i1 = new(Int, $I(24313));\nvar i2 = copy(i0);\n\nshow(i0); /*     1 */\nshow(i1); /* 24313 */\nshow(i2); /*     1 */\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Int_Examples(void) 
{ 


  {
  return (examples___38);
}
}
static void Int_Assign(var self , var obj ) 
{ 
  struct Int *i ;

  {
  i = (struct Int *)self;
  i->val = c_int(obj);
  return;
}
}
static int64_t Int_C_Int(var self ) 
{ 
  struct Int *i ;

  {
  i = (struct Int *)self;
  return (i->val);
}
}
static int Int_Cmp(var self , var obj ) 
{ 
  int64_t tmp ;
  int64_t tmp___0 ;

  {
  tmp = Int_C_Int(self);
  tmp___0 = c_int(obj);
  return ((int )(tmp - tmp___0));
}
}
static uint64_t Int_Hash(var self ) 
{ 
  int64_t tmp ;

  {
  tmp = c_int(self);
  return ((uint64_t )tmp);
}
}
static int Int_Show(var self , var output , int pos ) 
{ 
  struct Tuple __constr_expr_945 ;
  var __constr_expr_946[2] ;
  char __constr_expr_947[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  __constr_expr_946[0] = self;
  __constr_expr_946[1] = Terminal;
  __constr_expr_945.items = __constr_expr_946;
  __constr_expr_947[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_947[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_947), Tuple, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_945),
                   sizeof(struct Tuple ));
  tmp___2 = print_to_with(output, pos, "%li", (var )((struct Tuple *)tmp___1));
  return (tmp___2);
}
}
static int Int_Look(var self , var input , int pos ) 
{ 
  struct Tuple __constr_expr_948 ;
  var __constr_expr_949[2] ;
  char __constr_expr_950[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  __constr_expr_949[0] = self;
  __constr_expr_949[1] = Terminal;
  __constr_expr_948.items = __constr_expr_949;
  __constr_expr_950[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_950[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_950), Tuple, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_948),
                   sizeof(struct Tuple ));
  tmp___2 = scan_from_with(input, pos, "%li", (var )((struct Tuple *)tmp___1));
  return (tmp___2);
}
}
static struct Doc __constr_expr_952  =    {& Int_Name, & Int_Brief, & Int_Description, & Int_Definition, & Int_Examples,
    (struct Method *(*)(void))((void *)0)};
static struct Assign __constr_expr_953  =    {& Int_Assign};
static struct Cmp __constr_expr_954  =    {& Int_Cmp};
static struct Hash __constr_expr_955  =    {& Int_Hash};
static struct C_Int __constr_expr_956  =    {& Int_C_Int};
static struct Show __constr_expr_957  =    {& Int_Show, & Int_Look};
static var __constr_expr_951[48]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Int", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Int ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_952),      (void *)0,      (var )"Assign", 
        (var )(& __constr_expr_953),      (void *)0,      (var )"Cmp",      (var )(& __constr_expr_954), 
        (void *)0,      (var )"Hash",      (var )(& __constr_expr_955),      (void *)0, 
        (var )"C_Int",      (var )(& __constr_expr_956),      (void *)0,      (var )"Show", 
        (var )(& __constr_expr_957),      (void *)0,      (void *)0,      (void *)0};
var Int  =    (var )((char *)(__constr_expr_951) + sizeof(struct Header ));
static char const   *Float_Name(void) 
{ 


  {
  return ("Float");
}
}
static char const   *Float_Brief(void) 
{ 


  {
  return ("Floating Point Object");
}
}
static char const   *Float_Description(void) 
{ 


  {
  return ("64-bit double precision float point Object.");
}
}
static char const   *Float_Definition(void) 
{ 


  {
  return ("struct Float {\n  double val;\n};\n");
}
}
static struct Example *Float_Examples(void) ;
static struct Example examples___39[2]  = {      {"Usage", "var f0 = $(Float, 1.0);\nvar f1 = new(Float, $F(24.313));\nvar f2 = copy(f0);\n\nshow(f0); /*  1.000 */\nshow(f1); /* 24.313 */\nshow(f2); /*  1.000 */\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Float_Examples(void) 
{ 


  {
  return (examples___39);
}
}
static void Float_Assign(var self , var obj ) 
{ 
  struct Float *f ;

  {
  f = (struct Float *)self;
  f->val = c_float(obj);
  return;
}
}
static double Float_C_Float(var self ) 
{ 
  struct Float *f ;

  {
  f = (struct Float *)self;
  return (f->val);
}
}
static int Float_Cmp(var self , var obj ) 
{ 
  double c ;
  double tmp ;
  double tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = Float_C_Float(self);
  tmp___0 = c_float(obj);
  c = tmp - tmp___0;
  if (c > (double )0) {
    tmp___2 = 1;
  } else {
    if (c < (double )0) {
      tmp___1 = -1;
    } else {
      tmp___1 = 0;
    }
    tmp___2 = tmp___1;
  }
  return (tmp___2);
}
}
static uint64_t Float_Hash(var self ) 
{ 
  union interp_cast ic ;

  {
  ic.as_flt = c_float(self);
  return (ic.as_int);
}
}
int Float_Show(var self , var output , int pos ) 
{ 
  struct Tuple __constr_expr_958 ;
  var __constr_expr_959[2] ;
  char __constr_expr_960[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  __constr_expr_959[0] = self;
  __constr_expr_959[1] = Terminal;
  __constr_expr_958.items = __constr_expr_959;
  __constr_expr_960[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_960[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_960), Tuple, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_958),
                   sizeof(struct Tuple ));
  tmp___2 = print_to_with(output, pos, "%f", (var )((struct Tuple *)tmp___1));
  return (tmp___2);
}
}
int Float_Look(var self , var input , int pos ) 
{ 
  struct Tuple __constr_expr_961 ;
  var __constr_expr_962[2] ;
  char __constr_expr_963[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  __constr_expr_962[0] = self;
  __constr_expr_962[1] = Terminal;
  __constr_expr_961.items = __constr_expr_962;
  __constr_expr_963[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_963[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_963), Tuple, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_961),
                   sizeof(struct Tuple ));
  tmp___2 = scan_from_with(input, pos, "%f", (var )((struct Tuple *)tmp___1));
  return (tmp___2);
}
}
static struct Doc __constr_expr_965  =    {& Float_Name, & Float_Brief, & Float_Description, & Float_Definition, & Float_Examples,
    (struct Method *(*)(void))((void *)0)};
static struct Assign __constr_expr_966  =    {& Float_Assign};
static struct Cmp __constr_expr_967  =    {& Float_Cmp};
static struct Hash __constr_expr_968  =    {& Float_Hash};
static struct C_Float __constr_expr_969  =    {& Float_C_Float};
static struct Show __constr_expr_970  =    {& Float_Show, & Float_Look};
static var __constr_expr_964[48]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Float", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Float ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_965),      (void *)0,      (var )"Assign", 
        (var )(& __constr_expr_966),      (void *)0,      (var )"Cmp",      (var )(& __constr_expr_967), 
        (void *)0,      (var )"Hash",      (var )(& __constr_expr_968),      (void *)0, 
        (var )"C_Float",      (var )(& __constr_expr_969),      (void *)0,      (var )"Show", 
        (var )(& __constr_expr_970),      (void *)0,      (void *)0,      (void *)0};
var Float  =    (var )((char *)(__constr_expr_964) + sizeof(struct Header ));
#pragma merger("0","/tmp/cil-BhdHIyaX.i","-std=gnu99,-Wall,-Wno-unused,-g,-ggdb,-fPIC")
var Start ;
void start(var self ) ;
void stop(var self ) ;
void join(var self ) ;
_Bool running(var self ) ;
var start_in(var self ) ;
var stop_in(var self ) ;
static char const   *Start_Name(void) 
{ 


  {
  return ("Start");
}
}
static char const   *Start_Brief(void) 
{ 


  {
  return ("Can be started or stopped");
}
}
static char const   *Start_Description(void) 
{ 


  {
  return ("The `Start` class can be implemented by types which provide an abstract notion of a started and stopped state. This can be real processes such as `Thread`, or something like `File` where the on/off correspond to if the file is open or not.\n\nThe main nicety of the `Start` class is that it allows use of the `with` macro which performs the `start` function at the opening of a scope block and the `stop` function at the end.");
}
}
static char const   *Start_Definition(void) 
{ 


  {
  return ("struct Start {\n  void (*start)(var);\n  void (*stop)(var);\n  void (*join)(var);\n  bool (*running)(var);\n};\n");
}
}
static struct Example *Start_Examples(void) ;
static struct Example examples___40[3]  = {      {"Usage", "var x = new(Mutex);\nstart(x); /* Lock Mutex */ \nprint(\"Inside Mutex!\\n\");\nstop(x); /* unlock Mutex */"}, 
        {"Scoped",
      "var x = new(Mutex);\nwith (mut in x) { /* Lock Mutex */ \n  print(\"Inside Mutex!\\n\");\n} /* unlock Mutex */"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Start_Examples(void) 
{ 


  {
  return (examples___40);
}
}
static struct Method *Start_Methods(void) ;
static struct Method methods___31[6]  = {      {"with", "#define with(...)", "Perform operations in between `start` and `stop`."}, 
        {"start",
      "void start(var self);", "Start the object `self`."}, 
        {"stop", "void stop(var self);", "Stop the object `self`."}, 
        {"join", "void join(var self);", "Block and wait for the object `self` to stop."}, 
        {"running",
      "bool running(var self);", "Check if the object `self` is running."}, 
        {(char const   *)((void *)0), (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Start_Methods(void) 
{ 


  {
  return (methods___31);
}
}
static struct Doc __constr_expr_972  =    {& Start_Name, & Start_Brief, & Start_Description, & Start_Definition, & Start_Examples,
    & Start_Methods};
static var __constr_expr_971[33]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Start", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Start ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_972),      (void *)0,      (void *)0, 
        (void *)0};
var Start  =    (var )((char *)(__constr_expr_971) + sizeof(struct Header ));
void start(var self ) 
{ 
  var tmp ;

  {
  tmp = method_at_offset(self, Start, (unsigned long )(& ((struct Start *)0)->start),
                         "start");
  (*(((struct Start *)tmp)->start))(self);
  return;
}
}
void stop(var self ) 
{ 
  var tmp ;

  {
  tmp = method_at_offset(self, Start, (unsigned long )(& ((struct Start *)0)->stop),
                         "stop");
  (*(((struct Start *)tmp)->stop))(self);
  return;
}
}
void join(var self ) 
{ 
  var tmp ;

  {
  tmp = method_at_offset(self, Start, (unsigned long )(& ((struct Start *)0)->join),
                         "join");
  (*(((struct Start *)tmp)->join))(self);
  return;
}
}
_Bool running(var self ) 
{ 
  var tmp ;
  _Bool tmp___0 ;

  {
  tmp = method_at_offset(self, Start, (unsigned long )(& ((struct Start *)0)->running),
                         "running");
  tmp___0 = (*(((struct Start *)tmp)->running))(self);
  return (tmp___0);
}
}
var start_in(var self ) 
{ 
  struct Start *s ;
  var tmp ;

  {
  tmp = instance(self, Start);
  s = (struct Start *)tmp;
  if (s) {
    if (s->start) {
      (*(s->start))(self);
    }
  }
  return (self);
}
}
var stop_in(var self ) 
{ 
  struct Start *s ;
  var tmp ;

  {
  tmp = instance(self, Start);
  s = (struct Start *)tmp;
  if (s) {
    if (s->stop) {
      (*(s->stop))(self);
    }
  }
  return ((void *)0);
}
}
#pragma merger("0","/tmp/cil-pKtg3ygj.i","-std=gnu99,-Wall,-Wno-unused,-g,-ggdb,-fPIC")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atexit)(void (*__func)(void) ) ;
extern  __attribute__((__nothrow__)) int pthread_kill(pthread_t __threadid , int __signo ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
extern  __attribute__((__nothrow__)) pthread_t pthread_self(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_trylock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_key_create)(pthread_key_t *__key ,
                                                                                               void (*__destr_function)(void * ) ) ;
extern  __attribute__((__nothrow__)) int pthread_key_delete(pthread_key_t __key ) ;
extern  __attribute__((__nothrow__)) void *pthread_getspecific(pthread_key_t __key ) ;
extern  __attribute__((__nothrow__)) int pthread_setspecific(pthread_key_t __key ,
                                                             void const   *__pointer ) ;
var Mutex ;
var Lock ;
_Bool mem(var self , var key ) ;
void lock(var self ) ;
_Bool trylock(var self ) ;
void unlock(var self ) ;
void mark(var self , var gc , void (*f)(var  , void * ) ) ;
static char const   *Current_Name(void) 
{ 


  {
  return ("Current");
}
}
static char const   *Current_Brief(void) 
{ 


  {
  return ("Implicit Object");
}
}
static char const   *Current_Description(void) 
{ 


  {
  return ("The `Current` class can be implemented by types which have implicit instances associated with them. For example it can be used to retrieve the _current_ `Thread`, or it could be used to get the _current_ Garbage Collector.\n\nThis class may be implemented by types which express the [Singleton Design Pattern](http://en.wikipedia.org/wiki/Singleton_pattern)");
}
}
static char const   *Current_Definition(void) 
{ 


  {
  return ("struct Current {\n  var (*current)(void);\n};\n");
}
}
static struct Example *Current_Examples(void) ;
static struct Example examples___41[2]  = {      {"Usage", "var gc = current(GC);\nshow(gc);\nvar thread = current(Thread);\nshow(thread);\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Current_Examples(void) 
{ 


  {
  return (examples___41);
}
}
static struct Method *Current_Methods(void) ;
static struct Method methods___32[2]  = {      {"current", "var current(var type);", "Returns the current active object of the given `type`."}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Current_Methods(void) 
{ 


  {
  return (methods___32);
}
}
static struct Doc __constr_expr_974  =    {& Current_Name, & Current_Brief, & Current_Description, & Current_Definition,
    & Current_Examples, & Current_Methods};
static var __constr_expr_973[33]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Current", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Current ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_974),      (void *)0,      (void *)0, 
        (void *)0};
var Current  =    (var )((char *)(__constr_expr_973) + sizeof(struct Header ));
var current(var type ) 
{ 
  var tmp ;
  var tmp___0 ;

  {
  tmp = type_method_at_offset(type, Current, (unsigned long )(& ((struct Current *)0)->current),
                              "current");
  tmp___0 = (*(((struct Current *)tmp)->current))();
  return (tmp___0);
}
}
static char const   *Thread_Name(void) 
{ 


  {
  return ("Thread");
}
}
static char const   *Thread_Brief(void) 
{ 


  {
  return ("Concurrent Execution");
}
}
static char const   *Thread_Description(void) 
{ 


  {
  return ("The `Thread` type provides a basic primitive for concurrent execution. It acts as a basic wrapper around operating system threads, using WinThreads on Windows and pthreads otherwise.");
}
}
static struct Example *Thread_Examples(void) ;
static struct Example examples___42[3]  = {      {"Usage", "var set_value(var args) {\n  assign(get(args, $I(0)), $I(1));\n  return NULL;\n}\n\nvar i = $I(0);\n\nvar x = new(Thread, $(Function, set_value));\ncall(x, i);\njoin(x);\n\nshow(i); /* 1 */\n"}, 
        {"Exclusive Resource",
      "var increment(var args) {\n  var mut = get(args, $I(0));\n  var tot = get(args, $I(1));\n  lock(mut);\n  assign(tot, $I(c_int(tot)+1));\n  unlock(mut);\n  return NULL;\n}\n\nvar mutex = new(Mutex);\nvar total = $I(0);\n\nvar threads = new(Array, Box,\n  new(Thread, $(Function, increment)),\n  new(Thread, $(Function, increment)),\n  new(Thread, $(Function, increment)));\n\nshow(total); /* 0 */\n\nforeach (t in threads) {\n  call(deref(t), mutex, total);\n}\n\nforeach (t in threads) {\n  join(deref(t));\n}\n\nshow(total); /* 3 */\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Thread_Examples(void) 
{ 


  {
  return (examples___42);
}
}
static void Thread_New(var self , var args ) 
{ 
  struct Thread *t ;
  struct Int __constr_expr_975 ;
  char __constr_expr_976[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;
  var tmp___3 ;
  _Bool tmp___4 ;
  struct Tuple __constr_expr_977 ;
  var __constr_expr_978[3] ;
  char __constr_expr_979[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___5 ;
  var tmp___6 ;
  void *tmp___7 ;
  var tmp___8 ;

  {
  t = (struct Thread *)self;
  tmp___4 = empty(args);
  if (tmp___4) {
    t->func = (void *)0;
  } else {
    __constr_expr_975.val = (int64_t )0;
    __constr_expr_976[0] = (char)0;
    tmp___0 = 1U;
    while (! (tmp___0 >= 32U)) {
      __constr_expr_976[tmp___0] = (char)0;
      tmp___0 ++;
    }
    tmp___1 = header_init((var )(__constr_expr_976), Int, 2);
    tmp___2 = memcpy((void * __restrict  )((struct Int *)tmp___1), (void const   * __restrict  )(& __constr_expr_975),
                     sizeof(struct Int ));
    tmp___3 = get(args, (var )((struct Int *)tmp___2));
    t->func = tmp___3;
  }
  t->args = (void *)0;
  t->is_main = (_Bool)0;
  t->is_running = (_Bool)0;
  __constr_expr_978[0] = String;
  __constr_expr_978[1] = Ref;
  __constr_expr_978[2] = Terminal;
  __constr_expr_977.items = __constr_expr_978;
  __constr_expr_979[0] = (char)0;
  tmp___5 = 1U;
  while (! (tmp___5 >= 32U)) {
    __constr_expr_979[tmp___5] = (char)0;
    tmp___5 ++;
  }
  tmp___6 = header_init((var )(__constr_expr_979), Tuple, 2);
  tmp___7 = memcpy((void * __restrict  )((struct Tuple *)tmp___6), (void const   * __restrict  )(& __constr_expr_977),
                   sizeof(struct Tuple ));
  tmp___8 = new_raw_with(Table, (var )((struct Tuple *)tmp___7));
  t->tls = (var )((struct Table *)tmp___8);
  return;
}
}
static void Thread_Del(var self ) 
{ 
  struct Thread *t ;

  {
  t = (struct Thread *)self;
  if ((unsigned long )t->args != (unsigned long )((void *)0)) {
    del_raw(t->args);
  }
  del_raw(t->tls);
  return;
}
}
static int64_t Thread_C_Int(var self ) 
{ 
  struct Thread *t ;
  struct Tuple __constr_expr_980 ;
  var __constr_expr_981[1] ;
  char __constr_expr_982[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;

  {
  t = (struct Thread *)self;
  if (! t->is_running) {
    __constr_expr_981[0] = Terminal;
    __constr_expr_980.items = __constr_expr_981;
    __constr_expr_982[0] = (char)0;
    tmp = 1U;
    while (! (tmp >= 32U)) {
      __constr_expr_982[tmp] = (char)0;
      tmp ++;
    }
    tmp___0 = header_init((var )(__constr_expr_982), Tuple, 2);
    tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_980),
                     sizeof(struct Tuple ));
    exception_throw(ValueError, "Cannot get thread ID, thread not running!", (var )((struct Tuple *)tmp___1));
  }
  return ((int64_t )t->thread);
}
}
static void Thread_Assign(var self , var obj ) 
{ 
  struct Thread *t ;
  struct Thread *o ;
  var tmp ;
  var tmp___0 ;

  {
  t = (struct Thread *)self;
  tmp = cast(obj, Thread);
  o = (struct Thread *)tmp;
  t->func = o->func;
  if (t->tls) {
    t->tls = t->tls;
  } else {
    tmp___0 = alloc_raw(Table);
    t->tls = tmp___0;
  }
  assign(t->tls, o->tls);
  return;
}
}
static int Thread_Cmp(var self , var obj ) 
{ 
  int64_t tmp ;
  int64_t tmp___0 ;

  {
  tmp = Thread_C_Int(self);
  tmp___0 = c_int(obj);
  return ((int )(tmp - tmp___0));
}
}
static uint64_t Thread_Hash(var self ) 
{ 
  int64_t tmp ;

  {
  tmp = Thread_C_Int(self);
  return ((uint64_t )tmp);
}
}
static _Bool Thread_TLS_Key_Created  =    (_Bool)0;
static pthread_key_t Thread_Key_Wrapper  ;
static void Thread_TLS_Key_Create(void) 
{ 


  {
  pthread_key_create(& Thread_Key_Wrapper, (void (*)(void * ))((void *)0));
  return;
}
}
static void Thread_TLS_Key_Delete(void) 
{ 


  {
  pthread_key_delete(Thread_Key_Wrapper);
  return;
}
}
static var Thread_Init_Run(var self ) 
{ 
  struct Thread *t ;
  var bottom ;
  var gc ;
  struct Tuple __constr_expr_983 ;
  var __constr_expr_984[2] ;
  struct Ref __constr_expr_985 ;
  char __constr_expr_986[sizeof(struct Header ) + sizeof(struct Ref )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  char __constr_expr_987[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___2 ;
  var tmp___3 ;
  void *tmp___4 ;
  var tmp___5 ;
  var exc ;
  struct Tuple __constr_expr_988 ;
  var __constr_expr_989[1] ;
  char __constr_expr_990[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___6 ;
  var tmp___7 ;
  void *tmp___8 ;
  var tmp___9 ;
  var x ;
  var tmp___10 ;

  {
  t = (struct Thread *)self;
  pthread_setspecific(Thread_Key_Wrapper, (void const   *)t);
  t->is_running = (_Bool)1;
  bottom = (void *)0;
  __constr_expr_985.val = (var )(& bottom);
  __constr_expr_986[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_986[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_986), Ref, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Ref *)tmp___0), (void const   * __restrict  )(& __constr_expr_985),
                   sizeof(struct Ref ));
  __constr_expr_984[0] = (var )((struct Ref *)tmp___1);
  __constr_expr_984[1] = Terminal;
  __constr_expr_983.items = __constr_expr_984;
  __constr_expr_987[0] = (char)0;
  tmp___2 = 1U;
  while (! (tmp___2 >= 32U)) {
    __constr_expr_987[tmp___2] = (char)0;
    tmp___2 ++;
  }
  tmp___3 = header_init((var )(__constr_expr_987), Tuple, 2);
  tmp___4 = memcpy((void * __restrict  )((struct Tuple *)tmp___3), (void const   * __restrict  )(& __constr_expr_983),
                   sizeof(struct Tuple ));
  tmp___5 = new_raw_with(GC, (var )((struct Tuple *)tmp___4));
  gc = (var )((struct GC *)tmp___5);
  __constr_expr_989[0] = Terminal;
  __constr_expr_988.items = __constr_expr_989;
  __constr_expr_990[0] = (char)0;
  tmp___6 = 1U;
  while (! (tmp___6 >= 32U)) {
    __constr_expr_990[tmp___6] = (char)0;
    tmp___6 ++;
  }
  tmp___7 = header_init((var )(__constr_expr_990), Tuple, 2);
  tmp___8 = memcpy((void * __restrict  )((struct Tuple *)tmp___7), (void const   * __restrict  )(& __constr_expr_988),
                   sizeof(struct Tuple ));
  tmp___9 = new_raw_with(Exception, (var )((struct Tuple *)tmp___8));
  exc = (var )((struct Exception *)tmp___9);
  tmp___10 = call_with(t->func, t->args);
  x = tmp___10;
  del_raw(t->args);
  t->args = (void *)0;
  del_raw(exc);
  del_raw(gc);
  return (x);
}
}
static var Thread_Call(var self , var args ) 
{ 
  struct Thread *t ;
  var tmp ;
  var tmp___0 ;
  int err ;
  int tmp___1 ;
  struct Tuple __constr_expr_991 ;
  var __constr_expr_992[1] ;
  char __constr_expr_993[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___2 ;
  var tmp___3 ;
  void *tmp___4 ;
  struct Tuple __constr_expr_994 ;
  var __constr_expr_995[1] ;
  char __constr_expr_996[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___5 ;
  var tmp___6 ;
  void *tmp___7 ;
  struct Tuple __constr_expr_997 ;
  var __constr_expr_998[1] ;
  char __constr_expr_999[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___8 ;
  var tmp___9 ;
  void *tmp___10 ;

  {
  t = (struct Thread *)self;
  tmp = type_of(args);
  tmp___0 = alloc_raw(tmp);
  t->args = assign(tmp___0, args);
  if (! Thread_TLS_Key_Created) {
    Thread_TLS_Key_Create();
    Thread_TLS_Key_Created = (_Bool)1;
    atexit(& Thread_TLS_Key_Delete);
  }
  tmp___1 = pthread_create((pthread_t * __restrict  )(& t->thread), (pthread_attr_t const   * __restrict  )((void *)0),
                           & Thread_Init_Run, (void * __restrict  )t);
  err = tmp___1;
  if (err == 22) {
    __constr_expr_992[0] = Terminal;
    __constr_expr_991.items = __constr_expr_992;
    __constr_expr_993[0] = (char)0;
    tmp___2 = 1U;
    while (! (tmp___2 >= 32U)) {
      __constr_expr_993[tmp___2] = (char)0;
      tmp___2 ++;
    }
    tmp___3 = header_init((var )(__constr_expr_993), Tuple, 2);
    tmp___4 = memcpy((void * __restrict  )((struct Tuple *)tmp___3), (void const   * __restrict  )(& __constr_expr_991),
                     sizeof(struct Tuple ));
    exception_throw(ValueError, "Invalid Argument to Thread Creation", (var )((struct Tuple *)tmp___4));
  }
  if (err == 11) {
    __constr_expr_995[0] = Terminal;
    __constr_expr_994.items = __constr_expr_995;
    __constr_expr_996[0] = (char)0;
    tmp___5 = 1U;
    while (! (tmp___5 >= 32U)) {
      __constr_expr_996[tmp___5] = (char)0;
      tmp___5 ++;
    }
    tmp___6 = header_init((var )(__constr_expr_996), Tuple, 2);
    tmp___7 = memcpy((void * __restrict  )((struct Tuple *)tmp___6), (void const   * __restrict  )(& __constr_expr_994),
                     sizeof(struct Tuple ));
    exception_throw(OutOfMemoryError, "Not enough resources to create another Thread",
                    (var )((struct Tuple *)tmp___7));
  }
  if (err == 16) {
    __constr_expr_998[0] = Terminal;
    __constr_expr_997.items = __constr_expr_998;
    __constr_expr_999[0] = (char)0;
    tmp___8 = 1U;
    while (! (tmp___8 >= 32U)) {
      __constr_expr_999[tmp___8] = (char)0;
      tmp___8 ++;
    }
    tmp___9 = header_init((var )(__constr_expr_999), Tuple, 2);
    tmp___10 = memcpy((void * __restrict  )((struct Tuple *)tmp___9), (void const   * __restrict  )(& __constr_expr_997),
                      sizeof(struct Tuple ));
    exception_throw(BusyError, "System is too busy to create thread", (var )((struct Tuple *)tmp___10));
  }
  return (self);
}
}
static var Thread_Main  =    (void *)0;
static var Exception_Main  =    (void *)0;
static void Thread_Main_Del(void) 
{ 


  {
  del_raw(Exception_Main);
  del_raw(Thread_Main);
  return;
}
}
static var Thread_Current(void) 
{ 
  var wrapper ;
  void *tmp ;
  struct Tuple __constr_expr_1000 ;
  var __constr_expr_1001[1] ;
  char __constr_expr_1002[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;
  var tmp___3 ;
  struct Tuple __constr_expr_1003 ;
  var __constr_expr_1004[1] ;
  char __constr_expr_1005[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___4 ;
  var tmp___5 ;
  void *tmp___6 ;
  var tmp___7 ;
  struct Thread *t ;

  {
  if (! Thread_TLS_Key_Created) {
    Thread_TLS_Key_Create();
    Thread_TLS_Key_Created = (_Bool)1;
    atexit(& Thread_TLS_Key_Delete);
  }
  tmp = pthread_getspecific(Thread_Key_Wrapper);
  wrapper = tmp;
  if ((unsigned long )wrapper == (unsigned long )((void *)0)) {
    if ((unsigned long )Thread_Main == (unsigned long )((void *)0)) {
      __constr_expr_1001[0] = Terminal;
      __constr_expr_1000.items = __constr_expr_1001;
      __constr_expr_1002[0] = (char)0;
      tmp___0 = 1U;
      while (! (tmp___0 >= 32U)) {
        __constr_expr_1002[tmp___0] = (char)0;
        tmp___0 ++;
      }
      tmp___1 = header_init((var )(__constr_expr_1002), Tuple, 2);
      tmp___2 = memcpy((void * __restrict  )((struct Tuple *)tmp___1), (void const   * __restrict  )(& __constr_expr_1000),
                       sizeof(struct Tuple ));
      tmp___3 = new_raw_with(Thread, (var )((struct Tuple *)tmp___2));
      Thread_Main = (var )((struct Thread *)tmp___3);
      __constr_expr_1004[0] = Terminal;
      __constr_expr_1003.items = __constr_expr_1004;
      __constr_expr_1005[0] = (char)0;
      tmp___4 = 1U;
      while (! (tmp___4 >= 32U)) {
        __constr_expr_1005[tmp___4] = (char)0;
        tmp___4 ++;
      }
      tmp___5 = header_init((var )(__constr_expr_1005), Tuple, 2);
      tmp___6 = memcpy((void * __restrict  )((struct Tuple *)tmp___5), (void const   * __restrict  )(& __constr_expr_1003),
                       sizeof(struct Tuple ));
      tmp___7 = new_raw_with(Exception, (var )((struct Tuple *)tmp___6));
      Exception_Main = (var )((struct Exception *)tmp___7);
      atexit(& Thread_Main_Del);
    }
    t = (struct Thread *)Thread_Main;
    t->is_main = (_Bool)1;
    t->is_running = (_Bool)1;
    t->thread = pthread_self();
    return (Thread_Main);
  }
  return (wrapper);
}
}
static void Thread_Start(var self ) 
{ 
  struct Tuple __constr_expr_1006 ;
  var __constr_expr_1007[1] ;
  char __constr_expr_1008[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;

  {
  __constr_expr_1007[0] = Terminal;
  __constr_expr_1006.items = __constr_expr_1007;
  __constr_expr_1008[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_1008[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_1008), Tuple, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_1006),
                   sizeof(struct Tuple ));
  call_with(self, (var )((struct Tuple *)tmp___1));
  return;
}
}
static void Thread_Stop(var self ) 
{ 
  struct Thread *t ;
  int err ;
  int tmp ;
  struct Tuple __constr_expr_1009 ;
  var __constr_expr_1010[1] ;
  char __constr_expr_1011[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;
  struct Tuple __constr_expr_1012 ;
  var __constr_expr_1013[1] ;
  char __constr_expr_1014[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;

  {
  t = (struct Thread *)self;
  if (! t->thread) {
    return;
  }
  tmp = pthread_kill(t->thread, 2);
  err = tmp;
  if (err == 22) {
    __constr_expr_1010[0] = Terminal;
    __constr_expr_1009.items = __constr_expr_1010;
    __constr_expr_1011[0] = (char)0;
    tmp___0 = 1U;
    while (! (tmp___0 >= 32U)) {
      __constr_expr_1011[tmp___0] = (char)0;
      tmp___0 ++;
    }
    tmp___1 = header_init((var )(__constr_expr_1011), Tuple, 2);
    tmp___2 = memcpy((void * __restrict  )((struct Tuple *)tmp___1), (void const   * __restrict  )(& __constr_expr_1009),
                     sizeof(struct Tuple ));
    exception_throw(ValueError, "Invalid Argument to Thread Stop", (var )((struct Tuple *)tmp___2));
  }
  if (err == 3) {
    __constr_expr_1013[0] = Terminal;
    __constr_expr_1012.items = __constr_expr_1013;
    __constr_expr_1014[0] = (char)0;
    tmp___3 = 1U;
    while (! (tmp___3 >= 32U)) {
      __constr_expr_1014[tmp___3] = (char)0;
      tmp___3 ++;
    }
    tmp___4 = header_init((var )(__constr_expr_1014), Tuple, 2);
    tmp___5 = memcpy((void * __restrict  )((struct Tuple *)tmp___4), (void const   * __restrict  )(& __constr_expr_1012),
                     sizeof(struct Tuple ));
    exception_throw(ValueError, "Invalid Thread", (var )((struct Tuple *)tmp___5));
  }
  return;
}
}
static void Thread_Join(var self ) 
{ 
  struct Thread *t ;
  int err ;
  int tmp ;
  struct Tuple __constr_expr_1015 ;
  var __constr_expr_1016[1] ;
  char __constr_expr_1017[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;
  struct Tuple __constr_expr_1018 ;
  var __constr_expr_1019[1] ;
  char __constr_expr_1020[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;

  {
  t = (struct Thread *)self;
  if (! t->thread) {
    return;
  }
  tmp = pthread_join(t->thread, (void **)((void *)0));
  err = tmp;
  if (err == 22) {
    __constr_expr_1016[0] = Terminal;
    __constr_expr_1015.items = __constr_expr_1016;
    __constr_expr_1017[0] = (char)0;
    tmp___0 = 1U;
    while (! (tmp___0 >= 32U)) {
      __constr_expr_1017[tmp___0] = (char)0;
      tmp___0 ++;
    }
    tmp___1 = header_init((var )(__constr_expr_1017), Tuple, 2);
    tmp___2 = memcpy((void * __restrict  )((struct Tuple *)tmp___1), (void const   * __restrict  )(& __constr_expr_1015),
                     sizeof(struct Tuple ));
    exception_throw(ValueError, "Invalid Argument to Thread Join", (var )((struct Tuple *)tmp___2));
  }
  if (err == 3) {
    __constr_expr_1019[0] = Terminal;
    __constr_expr_1018.items = __constr_expr_1019;
    __constr_expr_1020[0] = (char)0;
    tmp___3 = 1U;
    while (! (tmp___3 >= 32U)) {
      __constr_expr_1020[tmp___3] = (char)0;
      tmp___3 ++;
    }
    tmp___4 = header_init((var )(__constr_expr_1020), Tuple, 2);
    tmp___5 = memcpy((void * __restrict  )((struct Tuple *)tmp___4), (void const   * __restrict  )(& __constr_expr_1018),
                     sizeof(struct Tuple ));
    exception_throw(ValueError, "Invalid Thread", (var )((struct Tuple *)tmp___5));
  }
  return;
}
}
static _Bool Thread_Running(var self ) 
{ 
  struct Thread *t ;

  {
  t = (struct Thread *)self;
  return (t->is_running);
}
}
static var Thread_Get(var self , var key ) 
{ 
  struct Thread *t ;
  var tmp ;
  var tmp___0 ;

  {
  t = (struct Thread *)self;
  tmp = get(t->tls, key);
  tmp___0 = deref(tmp);
  return (tmp___0);
}
}
static void Thread_Set(var self , var key , var val ) 
{ 
  struct Thread *t ;
  struct Ref __constr_expr_1021 ;
  char __constr_expr_1022[sizeof(struct Header ) + sizeof(struct Ref )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;

  {
  t = (struct Thread *)self;
  __constr_expr_1021.val = val;
  __constr_expr_1022[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_1022[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_1022), Ref, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Ref *)tmp___0), (void const   * __restrict  )(& __constr_expr_1021),
                   sizeof(struct Ref ));
  set(t->tls, key, (var )((struct Ref *)tmp___1));
  return;
}
}
static _Bool Thread_Mem(var self , var key ) 
{ 
  struct Thread *t ;
  _Bool tmp ;

  {
  t = (struct Thread *)self;
  tmp = mem(t->tls, key);
  return (tmp);
}
}
static void Thread_Rem(var self , var key ) 
{ 
  struct Thread *t ;

  {
  t = (struct Thread *)self;
  rem(t->tls, key);
  return;
}
}
static void Thread_Mark(var self , var gc , void (*f)(var  , void * ) ) 
{ 
  struct Thread *t ;

  {
  t = (struct Thread *)self;
  mark(t->tls, gc, f);
  return;
}
}
static struct Doc __constr_expr_1024  =    {& Thread_Name, & Thread_Brief, & Thread_Description, (char const   *(*)(void))((void *)0),
    & Thread_Examples, (struct Method *(*)(void))((void *)0)};
static struct New __constr_expr_1025  =    {& Thread_New, & Thread_Del};
static struct Assign __constr_expr_1026  =    {& Thread_Assign};
static struct Cmp __constr_expr_1027  =    {& Thread_Cmp};
static struct Hash __constr_expr_1028  =    {& Thread_Hash};
static struct Call __constr_expr_1029  =    {& Thread_Call};
static struct Current __constr_expr_1030  =    {& Thread_Current};
static struct Mark __constr_expr_1031  =    {& Thread_Mark};
static struct Start __constr_expr_1032  =    {& Thread_Start, & Thread_Stop, & Thread_Join, & Thread_Running};
static struct C_Int __constr_expr_1033  =    {& Thread_C_Int};
static struct Get __constr_expr_1034  =    {& Thread_Get, & Thread_Set, & Thread_Mem, & Thread_Rem, (var (*)(var  ))0, (var (*)(var  ))0};
static var __constr_expr_1023[63]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Thread", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Thread ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_1024),      (void *)0,      (var )"New", 
        (var )(& __constr_expr_1025),      (void *)0,      (var )"Assign",      (var )(& __constr_expr_1026), 
        (void *)0,      (var )"Cmp",      (var )(& __constr_expr_1027),      (void *)0, 
        (var )"Hash",      (var )(& __constr_expr_1028),      (void *)0,      (var )"Call", 
        (var )(& __constr_expr_1029),      (void *)0,      (var )"Current",      (var )(& __constr_expr_1030), 
        (void *)0,      (var )"Mark",      (var )(& __constr_expr_1031),      (void *)0, 
        (var )"Start",      (var )(& __constr_expr_1032),      (void *)0,      (var )"C_Int", 
        (var )(& __constr_expr_1033),      (void *)0,      (var )"Get",      (var )(& __constr_expr_1034), 
        (void *)0,      (void *)0,      (void *)0};
var Thread  =    (var )((char *)(__constr_expr_1023) + sizeof(struct Header ));
static char const   *Lock_Name(void) 
{ 


  {
  return ("Lock");
}
}
static char const   *Lock_Brief(void) 
{ 


  {
  return ("Exclusive Resource");
}
}
static char const   *Lock_Description(void) 
{ 


  {
  return ("The `Lock` class can be implemented by types to limit the access to them. For example this class is implemented by the `Mutex` type to provide mutual exclusion across Threads.");
}
}
static char const   *Lock_Definition(void) 
{ 


  {
  return ("struct Lock {\n  void (*lock)(var);\n  void (*unlock)(var);\n  bool (*trylock)(var);\n};\n");
}
}
static struct Method *Lock_Methods(void) ;
static struct Method methods___33[4]  = {      {"lock", "void lock(var self);", "Wait until a lock can be aquired on object `self`."}, 
        {"trylock",
      "bool trylock(var self);", "Try to acquire a lock on object `self`. Returns `true` on success and `false` if the resource is busy."}, 
        {"unlock",
      "void unlock(var self);", "Release lock on object `self`."}, 
        {(char const   *)((void *)0), (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Lock_Methods(void) 
{ 


  {
  return (methods___33);
}
}
static struct Example *Lock_Examples(void) ;
static struct Example examples___43[2]  = {      {"Usage", "var x = new(Mutex);\nlock(x);   /* Lock Mutex */ \nprint(\"Inside Mutex!\\n\");\nunlock(x); /* Unlock Mutex */"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Lock_Examples(void) 
{ 


  {
  return (examples___43);
}
}
static struct Doc __constr_expr_1036  =    {& Lock_Name, & Lock_Brief, & Lock_Description, & Lock_Definition, & Lock_Examples,
    & Lock_Methods};
static var __constr_expr_1035[33]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Lock", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Lock ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_1036),      (void *)0,      (void *)0, 
        (void *)0};
var Lock  =    (var )((char *)(__constr_expr_1035) + sizeof(struct Header ));
void lock(var self ) 
{ 
  var tmp ;

  {
  tmp = method_at_offset(self, Lock, (unsigned long )(& ((struct Lock *)0)->lock),
                         "lock");
  (*(((struct Lock *)tmp)->lock))(self);
  return;
}
}
void unlock(var self ) 
{ 
  var tmp ;

  {
  tmp = method_at_offset(self, Lock, (unsigned long )(& ((struct Lock *)0)->unlock),
                         "unlock");
  (*(((struct Lock *)tmp)->unlock))(self);
  return;
}
}
_Bool trylock(var self ) 
{ 
  var tmp ;
  _Bool tmp___0 ;

  {
  tmp = method_at_offset(self, Lock, (unsigned long )(& ((struct Lock *)0)->trylock),
                         "trylock");
  tmp___0 = (*(((struct Lock *)tmp)->trylock))(self);
  return (tmp___0);
}
}
static char const   *Mutex_Name(void) 
{ 


  {
  return ("Mutex");
}
}
static char const   *Mutex_Brief(void) 
{ 


  {
  return ("Mutual Exclusion Lock");
}
}
static char const   *Mutex_Description(void) 
{ 


  {
  return ("The `Mutex` type can be used to gain mutual exclusion across Threads for access to some resource.");
}
}
static struct Example *Mutex_Examples(void) ;
static struct Example examples___44[2]  = {      {"Usage", "var x = new(Mutex);\nwith (mut in x) { /* Lock Mutex */ \n  print(\"Inside Mutex!\\n\");\n} /* Unlock Mutex */"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Mutex_Examples(void) 
{ 


  {
  return (examples___44);
}
}
static void Mutex_New(var self , var args ) 
{ 
  struct Mutex *m ;

  {
  m = (struct Mutex *)self;
  pthread_mutex_init(& m->mutex, (pthread_mutexattr_t const   *)((void *)0));
  return;
}
}
static void Mutex_Del(var self ) 
{ 
  struct Mutex *m ;

  {
  m = (struct Mutex *)self;
  pthread_mutex_destroy(& m->mutex);
  return;
}
}
static void Mutex_Lock(var self ) 
{ 
  struct Mutex *m ;
  int err ;
  int tmp ;
  struct Tuple __constr_expr_1037 ;
  var __constr_expr_1038[1] ;
  char __constr_expr_1039[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;
  struct Tuple __constr_expr_1040 ;
  var __constr_expr_1041[1] ;
  char __constr_expr_1042[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;

  {
  m = (struct Mutex *)self;
  tmp = pthread_mutex_lock(& m->mutex);
  err = tmp;
  if (err == 22) {
    __constr_expr_1038[0] = Terminal;
    __constr_expr_1037.items = __constr_expr_1038;
    __constr_expr_1039[0] = (char)0;
    tmp___0 = 1U;
    while (! (tmp___0 >= 32U)) {
      __constr_expr_1039[tmp___0] = (char)0;
      tmp___0 ++;
    }
    tmp___1 = header_init((var )(__constr_expr_1039), Tuple, 2);
    tmp___2 = memcpy((void * __restrict  )((struct Tuple *)tmp___1), (void const   * __restrict  )(& __constr_expr_1037),
                     sizeof(struct Tuple ));
    exception_throw(ValueError, "Invalid Argument to Mutex Lock", (var )((struct Tuple *)tmp___2));
  }
  if (err == 35) {
    __constr_expr_1041[0] = Terminal;
    __constr_expr_1040.items = __constr_expr_1041;
    __constr_expr_1042[0] = (char)0;
    tmp___3 = 1U;
    while (! (tmp___3 >= 32U)) {
      __constr_expr_1042[tmp___3] = (char)0;
      tmp___3 ++;
    }
    tmp___4 = header_init((var )(__constr_expr_1042), Tuple, 2);
    tmp___5 = memcpy((void * __restrict  )((struct Tuple *)tmp___4), (void const   * __restrict  )(& __constr_expr_1040),
                     sizeof(struct Tuple ));
    exception_throw(ResourceError, "Attempt to relock already held mutex", (var )((struct Tuple *)tmp___5));
  }
  return;
}
}
static _Bool Mutex_Trylock(var self ) 
{ 
  struct Mutex *m ;
  int err ;
  int tmp ;
  struct Tuple __constr_expr_1043 ;
  var __constr_expr_1044[1] ;
  char __constr_expr_1045[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;

  {
  m = (struct Mutex *)self;
  tmp = pthread_mutex_trylock(& m->mutex);
  err = tmp;
  if (err == 16) {
    return ((_Bool)0);
  }
  if (err == 22) {
    __constr_expr_1044[0] = Terminal;
    __constr_expr_1043.items = __constr_expr_1044;
    __constr_expr_1045[0] = (char)0;
    tmp___0 = 1U;
    while (! (tmp___0 >= 32U)) {
      __constr_expr_1045[tmp___0] = (char)0;
      tmp___0 ++;
    }
    tmp___1 = header_init((var )(__constr_expr_1045), Tuple, 2);
    tmp___2 = memcpy((void * __restrict  )((struct Tuple *)tmp___1), (void const   * __restrict  )(& __constr_expr_1043),
                     sizeof(struct Tuple ));
    exception_throw(ValueError, "Invalid Argument to Mutex Lock Try", (var )((struct Tuple *)tmp___2));
  }
  return ((_Bool)1);
}
}
static void Mutex_Unlock(var self ) 
{ 
  struct Mutex *m ;
  var tmp ;
  int err ;
  int tmp___0 ;
  struct Tuple __constr_expr_1046 ;
  var __constr_expr_1047[1] ;
  char __constr_expr_1048[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___1 ;
  var tmp___2 ;
  void *tmp___3 ;
  struct Tuple __constr_expr_1049 ;
  var __constr_expr_1050[1] ;
  char __constr_expr_1051[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___4 ;
  var tmp___5 ;
  void *tmp___6 ;

  {
  tmp = cast(self, Mutex);
  m = (struct Mutex *)tmp;
  tmp___0 = pthread_mutex_unlock(& m->mutex);
  err = tmp___0;
  if (err == 22) {
    __constr_expr_1047[0] = Terminal;
    __constr_expr_1046.items = __constr_expr_1047;
    __constr_expr_1048[0] = (char)0;
    tmp___1 = 1U;
    while (! (tmp___1 >= 32U)) {
      __constr_expr_1048[tmp___1] = (char)0;
      tmp___1 ++;
    }
    tmp___2 = header_init((var )(__constr_expr_1048), Tuple, 2);
    tmp___3 = memcpy((void * __restrict  )((struct Tuple *)tmp___2), (void const   * __restrict  )(& __constr_expr_1046),
                     sizeof(struct Tuple ));
    exception_throw(ValueError, "Invalid Argument to Mutex Unlock", (var )((struct Tuple *)tmp___3));
  }
  if (err == 1) {
    __constr_expr_1050[0] = Terminal;
    __constr_expr_1049.items = __constr_expr_1050;
    __constr_expr_1051[0] = (char)0;
    tmp___4 = 1U;
    while (! (tmp___4 >= 32U)) {
      __constr_expr_1051[tmp___4] = (char)0;
      tmp___4 ++;
    }
    tmp___5 = header_init((var )(__constr_expr_1051), Tuple, 2);
    tmp___6 = memcpy((void * __restrict  )((struct Tuple *)tmp___5), (void const   * __restrict  )(& __constr_expr_1049),
                     sizeof(struct Tuple ));
    exception_throw(ResourceError, "Mutex cannot be held by caller", (var )((struct Tuple *)tmp___6));
  }
  return;
}
}
static struct Doc __constr_expr_1053  =    {& Mutex_Name, & Mutex_Brief, & Mutex_Description, (char const   *(*)(void))((void *)0),
    & Mutex_Examples, (struct Method *(*)(void))((void *)0)};
static struct New __constr_expr_1054  =    {& Mutex_New, & Mutex_Del};
static struct Lock __constr_expr_1055  =    {& Mutex_Lock, & Mutex_Unlock, & Mutex_Trylock};
static struct Start __constr_expr_1056  =    {& Mutex_Lock, & Mutex_Unlock, (void (*)(var  ))((void *)0), (_Bool (*)(var  ))0};
static var __constr_expr_1052[42]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Mutex", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Mutex ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_1053),      (void *)0,      (var )"New", 
        (var )(& __constr_expr_1054),      (void *)0,      (var )"Lock",      (var )(& __constr_expr_1055), 
        (void *)0,      (var )"Start",      (var )(& __constr_expr_1056),      (void *)0, 
        (void *)0,      (void *)0};
var Mutex  =    (var )((char *)(__constr_expr_1052) + sizeof(struct Header ));
#pragma merger("0","/tmp/cil-X8FlL7lo.i","-std=gnu99,-Wall,-Wno-unused,-g,-ggdb,-fPIC")
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
var Process ;
void Cello_Exit(void) ;
static char const   *Mark_Name(void) 
{ 


  {
  return ("Mark");
}
}
static char const   *Mark_Brief(void) 
{ 


  {
  return ("Markable by GC");
}
}
static char const   *Mark_Description(void) 
{ 


  {
  return ("The `Mark` class can be overridden to customize the behaviour of the Cello Garbage Collector on encountering a given type. By default the allocated memory for a structure is scanned for pointers to other Cello objects, but if a type does its own memory allocation it may store pointers to Cello objects in other locations.\n\nIf this is the case the `Mark` class can be overridden and the callback function `f` must be called on all pointers which might be Cello objects which are managed by the class. Alternately the `mark` function can be called on any sub object to start a chain of recursive marking.");
}
}
static char const   *Mark_Definition(void) 
{ 


  {
  return ("struct Mark {\n  void (*mark)(var, var, void(*)(var,void*));\n};\n");
}
}
static struct Method *Mark_Methods(void) ;
static struct Method methods___34[2]  = {      {"mark", "void mark(var self, var gc, void(*f)(var,void*));", "Mark the object `self` with the Garbage Collector `gc` and the callback function `f`."}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Mark_Methods(void) 
{ 


  {
  return (methods___34);
}
}
static struct Doc __constr_expr_1058  =    {& Mark_Name, & Mark_Brief, & Mark_Description, & Mark_Definition, (struct Example *(*)(void))((void *)0),
    & Mark_Methods};
static var __constr_expr_1057[33]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Mark", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Mark ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_1058),      (void *)0,      (void *)0, 
        (void *)0};
var Mark  =    (var )((char *)(__constr_expr_1057) + sizeof(struct Header ));
void mark(var self , var gc , void (*f)(var  , void * ) ) 
{ 
  struct Mark *m ;
  var tmp ;

  {
  if ((unsigned long )self == (unsigned long )((void *)0)) {
    return;
  }
  tmp = instance(self, Mark);
  m = (struct Mark *)tmp;
  if (m) {
    if (m->mark) {
      (*(m->mark))(self, gc, f);
    }
  }
  return;
}
}
static size_t const   GC_Primes[24]  = 
  {      (size_t const   )0,      (size_t const   )1,      (size_t const   )5,      (size_t const   )11, 
        (size_t const   )23,      (size_t const   )53,      (size_t const   )101,      (size_t const   )197, 
        (size_t const   )389,      (size_t const   )683,      (size_t const   )1259,      (size_t const   )2417, 
        (size_t const   )4733,      (size_t const   )9371,      (size_t const   )18617,      (size_t const   )37097, 
        (size_t const   )74093,      (size_t const   )148073,      (size_t const   )296099,      (size_t const   )592019, 
        (size_t const   )1100009,      (size_t const   )2200013,      (size_t const   )4400021,      (size_t const   )8800019};
static char const   *GC_Name(void) 
{ 


  {
  return ("GC");
}
}
static char const   *GC_Brief(void) 
{ 


  {
  return ("Garbage Collector");
}
}
static char const   *GC_Description(void) 
{ 


  {
  return ("The `GC` type provides an interface to the Cello Garbage Collector. One instance of this type is created for each thread and can be retrieved using the `current` function. The Garbage Collector can be stopped and started using `start` and `stop` and objects can be added or removed from the Garbage Collector using `set` and `rem`.");
}
}
static struct Example *GC_Examples(void) ;
static struct Example examples___45[2]  = {      {"Starting & Stopping", "var gc = current(GC);\nstop(gc);\nvar x = new(Int, $I(10)); /* Not added to GC */\nshow($I(running(gc))); /* 0 */\ndel(x); /* Must be deleted when done */\nstart(gc);\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *GC_Examples(void) 
{ 


  {
  return (examples___45);
}
}
static uint64_t GC_Probe(struct GC *gc , uint64_t i , uint64_t h ) 
{ 
  int64_t v ;

  {
  v = (int64_t )(i - (h - 1UL));
  if (v < 0L) {
    v = (int64_t )(gc->nslots + (size_t )v);
  }
  return ((uint64_t )v);
}
}
static double const   GC_Load_Factor  =    (double const   )0.9;
static size_t GC_Ideal_Size(size_t size___0 ) 
{ 
  size_t i ;
  size_t last ;
  size_t i___0 ;

  {
  size___0 = (size_t )((double )(size___0 + 1UL) / (double )GC_Load_Factor);
  i = (size_t )0;
  while (i < 24UL) {
    if (GC_Primes[i] >= (size_t const   )size___0) {
      return ((size_t )GC_Primes[i]);
    }
    i ++;
  }
  last = (size_t )GC_Primes[23];
  i___0 = (size_t )0;
  while (1) {
    if (last * i___0 >= size___0) {
      return (last * i___0);
    }
    i___0 ++;
  }
}
}
static void GC_Set_Ptr(struct GC *gc , var ptr , _Bool root ) ;
static void GC_Rehash(struct GC *gc , size_t new_size ) 
{ 
  struct GCEntry *old_entries ;
  size_t old_size ;
  void *tmp ;
  struct Tuple __constr_expr_1059 ;
  var __constr_expr_1060[1] ;
  char __constr_expr_1061[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;
  size_t i ;

  {
  old_entries = gc->entries;
  old_size = gc->nslots;
  gc->nslots = new_size;
  tmp = calloc(gc->nslots, sizeof(struct GCEntry ));
  gc->entries = (struct GCEntry *)tmp;
  if ((unsigned long )gc->entries == (unsigned long )((void *)0)) {
    __constr_expr_1060[0] = Terminal;
    __constr_expr_1059.items = __constr_expr_1060;
    __constr_expr_1061[0] = (char)0;
    tmp___0 = 1U;
    while (! (tmp___0 >= 32U)) {
      __constr_expr_1061[tmp___0] = (char)0;
      tmp___0 ++;
    }
    tmp___1 = header_init((var )(__constr_expr_1061), Tuple, 2);
    tmp___2 = memcpy((void * __restrict  )((struct Tuple *)tmp___1), (void const   * __restrict  )(& __constr_expr_1059),
                     sizeof(struct Tuple ));
    exception_throw(OutOfMemoryError, "Cannot allocate GC Pointer Table, out of memory!",
                    (var )((struct Tuple *)tmp___2));
    return;
  }
  i = (size_t )0;
  while (i < old_size) {
    if ((old_entries + i)->hash != 0UL) {
      GC_Set_Ptr(gc, (old_entries + i)->ptr, (old_entries + i)->root);
    }
    i ++;
  }
  free((void *)old_entries);
  return;
}
}
static void GC_Resize_More(struct GC *gc ) 
{ 
  size_t new_size ;
  size_t tmp ;
  size_t old_size ;

  {
  tmp = GC_Ideal_Size(gc->nitems);
  new_size = tmp;
  old_size = gc->nslots;
  if (new_size > old_size) {
    GC_Rehash(gc, new_size);
  }
  return;
}
}
static void GC_Resize_Less(struct GC *gc ) 
{ 
  size_t new_size ;
  size_t tmp ;
  size_t old_size ;

  {
  tmp = GC_Ideal_Size(gc->nitems);
  new_size = tmp;
  old_size = gc->nslots;
  if (new_size < old_size) {
    GC_Rehash(gc, new_size);
  }
  return;
}
}
static uint64_t GC_Hash(var ptr ) 
{ 


  {
  return ((uintptr_t )ptr >> 3);
}
}
static void GC_Set_Ptr(struct GC *gc , var ptr , _Bool root ) 
{ 
  uint64_t i ;
  uint64_t tmp ;
  uint64_t j ;
  uint64_t ihash ;
  struct GCEntry entry ;
  uint64_t h ;
  uint64_t p ;
  uint64_t tmp___0 ;
  struct GCEntry tmp___1 ;

  {
  tmp = GC_Hash(ptr);
  i = tmp % gc->nslots;
  j = (uint64_t )0;
  ihash = i + 1UL;
  entry.ptr = ptr;
  entry.hash = ihash;
  entry.root = root;
  entry.marked = (_Bool)0;
  while (1) {
    h = (gc->entries + i)->hash;
    if (h == 0UL) {
      *(gc->entries + i) = entry;
      return;
    }
    if ((unsigned long )(gc->entries + i)->ptr == (unsigned long )entry.ptr) {
      return;
    }
    tmp___0 = GC_Probe(gc, i, h);
    p = tmp___0;
    if (j >= p) {
      tmp___1 = *(gc->entries + i);
      *(gc->entries + i) = entry;
      entry = tmp___1;
      j = p;
    }
    i = (i + 1UL) % gc->nslots;
    j ++;
  }
}
}
static _Bool GC_Mem_Ptr(struct GC *gc , var ptr ) 
{ 
  uint64_t i ;
  uint64_t tmp ;
  uint64_t j ;
  uint64_t h ;
  uint64_t tmp___0 ;

  {
  if (gc->nslots == 0UL) {
    return ((_Bool)0);
  }
  tmp = GC_Hash(ptr);
  i = tmp % gc->nslots;
  j = (uint64_t )0;
  while (1) {
    h = (gc->entries + i)->hash;
    if (h == 0UL) {
      return ((_Bool)0);
    } else {
      tmp___0 = GC_Probe(gc, i, h);
      if (j > tmp___0) {
        return ((_Bool)0);
      }
    }
    if ((unsigned long )(gc->entries + i)->ptr == (unsigned long )ptr) {
      return ((_Bool)1);
    }
    i = (i + 1UL) % gc->nslots;
    j ++;
  }
}
}
static void GC_Rem_Ptr(struct GC *gc , var ptr ) 
{ 
  size_t i ;
  uint64_t i___0 ;
  uint64_t tmp ;
  uint64_t j ;
  uint64_t h ;
  uint64_t tmp___0 ;
  var freeitem ;
  uint64_t nj ;
  uint64_t nh ;
  uint64_t tmp___1 ;
  var tmp___2 ;

  {
  if (gc->nslots == 0UL) {
    return;
  }
  i = (size_t )0;
  while (i < gc->freenum) {
    if ((unsigned long )*(gc->freelist + i) == (unsigned long )ptr) {
      *(gc->freelist + i) = (void *)0;
    }
    i ++;
  }
  tmp = GC_Hash(ptr);
  i___0 = tmp % gc->nslots;
  j = (uint64_t )0;
  while (1) {
    h = (gc->entries + i___0)->hash;
    if (h == 0UL) {
      return;
    } else {
      tmp___0 = GC_Probe(gc, i___0, h);
      if (j > tmp___0) {
        return;
      }
    }
    if ((unsigned long )(gc->entries + i___0)->ptr == (unsigned long )ptr) {
      freeitem = (gc->entries + i___0)->ptr;
      memset((void *)(gc->entries + i___0), 0, sizeof(struct GCEntry ));
      j = i___0;
      while (1) {
        nj = (j + 1UL) % gc->nslots;
        nh = (gc->entries + nj)->hash;
        if (nh != 0UL) {
          tmp___1 = GC_Probe(gc, nj, nh);
          if (tmp___1 > 0UL) {
            memcpy((void * __restrict  )(gc->entries + j), (void const   * __restrict  )(gc->entries + nj),
                   sizeof(struct GCEntry ));
            memset((void *)(gc->entries + nj), 0, sizeof(struct GCEntry ));
            j = nj;
          } else {
            break;
          }
        } else {
          break;
        }
      }
      (gc->nitems) --;
      tmp___2 = destruct(freeitem);
      dealloc(tmp___2);
      return;
    }
    i___0 = (i___0 + 1UL) % gc->nslots;
    j ++;
  }
}
}
static void GC_Mark_Item(struct GC *gc , void *ptr ) ;
static void GC_Recurse(struct GC *gc , var ptr ) ;
static void GC_Mark_And_Recurse(struct GC *gc , void *ptr ) 
{ 


  {
  GC_Mark_Item(gc, ptr);
  GC_Recurse(gc, ptr);
  return;
}
}
static void GC_Recurse(struct GC *gc , var ptr ) 
{ 
  var type ;
  var tmp ;
  struct Mark *m ;
  var tmp___0 ;
  size_t i ;
  var p ;
  size_t tmp___1 ;

  {
  tmp = type_of(ptr);
  type = tmp;
  if ((unsigned long )type == (unsigned long )Int) {
    return;
  } else
  if ((unsigned long )type == (unsigned long )Float) {
    return;
  } else
  if ((unsigned long )type == (unsigned long )String) {
    return;
  } else
  if ((unsigned long )type == (unsigned long )Type) {
    return;
  } else
  if ((unsigned long )type == (unsigned long )File) {
    return;
  } else
  if ((unsigned long )type == (unsigned long )Process) {
    return;
  } else
  if ((unsigned long )type == (unsigned long )Function) {
    return;
  }
  tmp___0 = type_instance(type, Mark);
  m = (struct Mark *)tmp___0;
  if (m) {
    if (m->mark) {
      (*(m->mark))(ptr, (var )gc, (void (*)(var  , void * ))(& GC_Mark_And_Recurse));
      return;
    }
  }
  i = (size_t )0;
  while (1) {
    tmp___1 = size(type);
    if (! (i + sizeof(var ) <= tmp___1)) {
      break;
    }
    p = (var )((char *)ptr + i);
    GC_Mark_Item(gc, *((var *)p));
    i += sizeof(var );
  }
  return;
}
}
static void GC_Mark_Item(struct GC *gc , void *ptr ) 
{ 
  uintptr_t pval ;
  uint64_t i ;
  uint64_t tmp ;
  uint64_t j ;
  uint64_t h ;
  uint64_t tmp___0 ;

  {
  pval = (uintptr_t )ptr;
  if (pval % sizeof(var ) != 0UL) {
    return;
  } else
  if (pval < gc->minptr) {
    return;
  } else
  if (pval > gc->maxptr) {
    return;
  }
  tmp = GC_Hash(ptr);
  i = tmp % gc->nslots;
  j = (uint64_t )0;
  while (1) {
    h = (gc->entries + i)->hash;
    if (h == 0UL) {
      return;
    } else {
      tmp___0 = GC_Probe(gc, i, h);
      if (j > tmp___0) {
        return;
      }
    }
    if ((unsigned long )(gc->entries + i)->ptr == (unsigned long )ptr) {
      if (! (gc->entries + i)->marked) {
        (gc->entries + i)->marked = (_Bool)1;
        GC_Recurse(gc, (gc->entries + i)->ptr);
        return;
      }
    }
    i = (i + 1UL) % gc->nslots;
    j ++;
  }
}
}
static void GC_Mark_Stack(struct GC *gc ) 
{ 
  var stk ;
  var bot ;
  var top ;
  var p ;
  var p___0 ;

  {
  stk = (void *)0;
  bot = gc->bottom;
  top = (var )(& stk);
  if ((unsigned long )bot == (unsigned long )top) {
    return;
  }
  if ((unsigned long )bot < (unsigned long )top) {
    p = top;
    while ((unsigned long )p >= (unsigned long )bot) {
      GC_Mark_Item(gc, *((var *)p));
      p = (var )((char *)p - sizeof(var ));
    }
  }
  if ((unsigned long )bot > (unsigned long )top) {
    p___0 = top;
    while ((unsigned long )p___0 <= (unsigned long )bot) {
      GC_Mark_Item(gc, *((var *)p___0));
      p___0 = (var )((char *)p___0 + sizeof(var ));
    }
  }
  return;
}
}
void GC_Mark(struct GC *gc ) 
{ 
  var tmp ;
  size_t i ;
  int volatile   noinline ;
  jmp_buf env ;
  void (*mark_stack)(struct GC *gc ) ;
  void (*tmp___0)(struct GC *gc ) ;

  {
  if ((unsigned long )gc == (unsigned long )((void *)0)) {
    return;
  } else
  if (gc->nitems == 0UL) {
    return;
  }
  tmp = current(Thread);
  mark(tmp, (var )gc, (void (*)(var  , void * ))(& GC_Mark_Item));
  i = (size_t )0;
  while (i < gc->nslots) {
    if ((gc->entries + i)->hash == 0UL) {
      goto __Cont;
    }
    if ((gc->entries + i)->marked) {
      goto __Cont;
    }
    if ((gc->entries + i)->root) {
      (gc->entries + i)->marked = (_Bool)1;
      GC_Recurse(gc, (gc->entries + i)->ptr);
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  noinline = (int volatile   )1;
  if (noinline) {
    memset((void *)(& env), 0, sizeof(jmp_buf ));
    _setjmp((struct __jmp_buf_tag *)(env));
  }
  if (noinline) {
    tmp___0 = & GC_Mark_Stack;
  } else {
    tmp___0 = (void (*)(struct GC *gc ))((void *)0);
  }
  mark_stack = tmp___0;
  (*mark_stack)(gc);
  return;
}
}
static int GC_Show(var self , var out , int pos ) 
{ 
  struct GC *gc ;
  struct Tuple __constr_expr_1062 ;
  var __constr_expr_1063[2] ;
  char __constr_expr_1064[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  size_t i ;
  struct Tuple __constr_expr_1065 ;
  var __constr_expr_1066[2] ;
  struct Int __constr_expr_1067 ;
  char __constr_expr_1068[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___2 ;
  var tmp___3 ;
  void *tmp___4 ;
  char __constr_expr_1069[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___5 ;
  var tmp___6 ;
  void *tmp___7 ;
  struct Tuple __constr_expr_1070 ;
  var __constr_expr_1071[6] ;
  struct Int __constr_expr_1072 ;
  char __constr_expr_1073[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___8 ;
  var tmp___9 ;
  void *tmp___10 ;
  var tmp___11 ;
  struct String __constr_expr_1074 ;
  char __constr_expr_1075[sizeof(struct Header ) + sizeof(struct String )] ;
  unsigned int tmp___12 ;
  var tmp___13 ;
  void *tmp___14 ;
  struct String __constr_expr_1076 ;
  char __constr_expr_1077[sizeof(struct Header ) + sizeof(struct String )] ;
  unsigned int tmp___15 ;
  var tmp___16 ;
  void *tmp___17 ;
  struct String *tmp___18 ;
  struct String __constr_expr_1078 ;
  char __constr_expr_1079[sizeof(struct Header ) + sizeof(struct String )] ;
  unsigned int tmp___19 ;
  var tmp___20 ;
  void *tmp___21 ;
  struct String __constr_expr_1080 ;
  char __constr_expr_1081[sizeof(struct Header ) + sizeof(struct String )] ;
  unsigned int tmp___22 ;
  var tmp___23 ;
  void *tmp___24 ;
  struct String *tmp___25 ;
  char __constr_expr_1082[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___26 ;
  var tmp___27 ;
  void *tmp___28 ;
  struct Tuple __constr_expr_1083 ;
  var __constr_expr_1084[1] ;
  char __constr_expr_1085[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___29 ;
  var tmp___30 ;
  void *tmp___31 ;
  int tmp___32 ;

  {
  gc = (struct GC *)self;
  __constr_expr_1063[0] = self;
  __constr_expr_1063[1] = Terminal;
  __constr_expr_1062.items = __constr_expr_1063;
  __constr_expr_1064[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_1064[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_1064), Tuple, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_1062),
                   sizeof(struct Tuple ));
  pos = print_to_with(out, pos, "<\'GC\' At 0x%p\n", (var )((struct Tuple *)tmp___1));
  i = (size_t )0;
  while (i < gc->nslots) {
    if ((gc->entries + i)->hash == 0UL) {
      __constr_expr_1067.val = (int64_t )i;
      __constr_expr_1068[0] = (char)0;
      tmp___2 = 1U;
      while (! (tmp___2 >= 32U)) {
        __constr_expr_1068[tmp___2] = (char)0;
        tmp___2 ++;
      }
      tmp___3 = header_init((var )(__constr_expr_1068), Int, 2);
      tmp___4 = memcpy((void * __restrict  )((struct Int *)tmp___3), (void const   * __restrict  )(& __constr_expr_1067),
                       sizeof(struct Int ));
      __constr_expr_1066[0] = (var )((struct Int *)tmp___4);
      __constr_expr_1066[1] = Terminal;
      __constr_expr_1065.items = __constr_expr_1066;
      __constr_expr_1069[0] = (char)0;
      tmp___5 = 1U;
      while (! (tmp___5 >= 32U)) {
        __constr_expr_1069[tmp___5] = (char)0;
        tmp___5 ++;
      }
      tmp___6 = header_init((var )(__constr_expr_1069), Tuple, 2);
      tmp___7 = memcpy((void * __restrict  )((struct Tuple *)tmp___6), (void const   * __restrict  )(& __constr_expr_1065),
                       sizeof(struct Tuple ));
      pos = print_to_with(out, pos, "| %i : \n", (var )((struct Tuple *)tmp___7));
      goto __Cont;
    }
    __constr_expr_1072.val = (int64_t )i;
    __constr_expr_1073[0] = (char)0;
    tmp___8 = 1U;
    while (! (tmp___8 >= 32U)) {
      __constr_expr_1073[tmp___8] = (char)0;
      tmp___8 ++;
    }
    tmp___9 = header_init((var )(__constr_expr_1073), Int, 2);
    tmp___10 = memcpy((void * __restrict  )((struct Int *)tmp___9), (void const   * __restrict  )(& __constr_expr_1072),
                      sizeof(struct Int ));
    tmp___11 = type_of((gc->entries + i)->ptr);
    if ((gc->entries + i)->root) {
      __constr_expr_1074.val = (char *)"root";
      __constr_expr_1075[0] = (char)0;
      tmp___12 = 1U;
      while (! (tmp___12 >= 32U)) {
        __constr_expr_1075[tmp___12] = (char)0;
        tmp___12 ++;
      }
      tmp___13 = header_init((var )(__constr_expr_1075), String, 2);
      tmp___14 = memcpy((void * __restrict  )((struct String *)tmp___13), (void const   * __restrict  )(& __constr_expr_1074),
                        sizeof(struct String ));
      tmp___18 = (struct String *)tmp___14;
    } else {
      __constr_expr_1076.val = (char *)"auto";
      __constr_expr_1077[0] = (char)0;
      tmp___15 = 1U;
      while (! (tmp___15 >= 32U)) {
        __constr_expr_1077[tmp___15] = (char)0;
        tmp___15 ++;
      }
      tmp___16 = header_init((var )(__constr_expr_1077), String, 2);
      tmp___17 = memcpy((void * __restrict  )((struct String *)tmp___16), (void const   * __restrict  )(& __constr_expr_1076),
                        sizeof(struct String ));
      tmp___18 = (struct String *)tmp___17;
    }
    if ((gc->entries + i)->marked) {
      __constr_expr_1078.val = (char *)"*";
      __constr_expr_1079[0] = (char)0;
      tmp___19 = 1U;
      while (! (tmp___19 >= 32U)) {
        __constr_expr_1079[tmp___19] = (char)0;
        tmp___19 ++;
      }
      tmp___20 = header_init((var )(__constr_expr_1079), String, 2);
      tmp___21 = memcpy((void * __restrict  )((struct String *)tmp___20), (void const   * __restrict  )(& __constr_expr_1078),
                        sizeof(struct String ));
      tmp___25 = (struct String *)tmp___21;
    } else {
      __constr_expr_1080.val = (char *)" ";
      __constr_expr_1081[0] = (char)0;
      tmp___22 = 1U;
      while (! (tmp___22 >= 32U)) {
        __constr_expr_1081[tmp___22] = (char)0;
        tmp___22 ++;
      }
      tmp___23 = header_init((var )(__constr_expr_1081), String, 2);
      tmp___24 = memcpy((void * __restrict  )((struct String *)tmp___23), (void const   * __restrict  )(& __constr_expr_1080),
                        sizeof(struct String ));
      tmp___25 = (struct String *)tmp___24;
    }
    __constr_expr_1071[0] = (var )((struct Int *)tmp___10);
    __constr_expr_1071[1] = tmp___11;
    __constr_expr_1071[2] = (gc->entries + i)->ptr;
    __constr_expr_1071[3] = (var )tmp___18;
    __constr_expr_1071[4] = (var )tmp___25;
    __constr_expr_1071[5] = Terminal;
    __constr_expr_1070.items = __constr_expr_1071;
    __constr_expr_1082[0] = (char)0;
    tmp___26 = 1U;
    while (! (tmp___26 >= 32U)) {
      __constr_expr_1082[tmp___26] = (char)0;
      tmp___26 ++;
    }
    tmp___27 = header_init((var )(__constr_expr_1082), Tuple, 2);
    tmp___28 = memcpy((void * __restrict  )((struct Tuple *)tmp___27), (void const   * __restrict  )(& __constr_expr_1070),
                      sizeof(struct Tuple ));
    pos = print_to_with(out, pos, "| %i : %15s %p %s %s\n", (var )((struct Tuple *)tmp___28));
    __Cont: /* CIL Label */ 
    i ++;
  }
  __constr_expr_1084[0] = Terminal;
  __constr_expr_1083.items = __constr_expr_1084;
  __constr_expr_1085[0] = (char)0;
  tmp___29 = 1U;
  while (! (tmp___29 >= 32U)) {
    __constr_expr_1085[tmp___29] = (char)0;
    tmp___29 ++;
  }
  tmp___30 = header_init((var )(__constr_expr_1085), Tuple, 2);
  tmp___31 = memcpy((void * __restrict  )((struct Tuple *)tmp___30), (void const   * __restrict  )(& __constr_expr_1083),
                    sizeof(struct Tuple ));
  tmp___32 = print_to_with(out, pos, "+------------------->\n", (var )((struct Tuple *)tmp___31));
  return (tmp___32);
}
}
void GC_Sweep(struct GC *gc ) 
{ 
  void *tmp ;
  size_t i ;
  uint64_t j ;
  uint64_t nj ;
  uint64_t nh ;
  uint64_t tmp___0 ;
  size_t i___0 ;
  size_t i___1 ;
  var tmp___1 ;

  {
  tmp = realloc((void *)gc->freelist, sizeof(var ) * gc->nitems);
  gc->freelist = (var *)tmp;
  gc->freenum = (uintptr_t )0;
  i = (size_t )0;
  while (i < gc->nslots) {
    if ((gc->entries + i)->hash == 0UL) {
      i ++;
      continue;
    }
    if ((gc->entries + i)->marked) {
      i ++;
      continue;
    }
    if (! (gc->entries + i)->root) {
      if (! (gc->entries + i)->marked) {
        *(gc->freelist + gc->freenum) = (gc->entries + i)->ptr;
        (gc->freenum) ++;
        memset((void *)(gc->entries + i), 0, sizeof(struct GCEntry ));
        j = i;
        while (1) {
          nj = (j + 1UL) % gc->nslots;
          nh = (gc->entries + nj)->hash;
          if (nh != 0UL) {
            tmp___0 = GC_Probe(gc, nj, nh);
            if (tmp___0 > 0UL) {
              memcpy((void * __restrict  )(gc->entries + j), (void const   * __restrict  )(gc->entries + nj),
                     sizeof(struct GCEntry ));
              memset((void *)(gc->entries + nj), 0, sizeof(struct GCEntry ));
              j = nj;
            } else {
              break;
            }
          } else {
            break;
          }
        }
        (gc->nitems) --;
        continue;
      }
    }
    i ++;
  }
  i___0 = (size_t )0;
  while (i___0 < gc->nslots) {
    if ((gc->entries + i___0)->hash == 0UL) {
      goto __Cont;
    }
    if ((gc->entries + i___0)->marked) {
      (gc->entries + i___0)->marked = (_Bool)0;
      goto __Cont;
    }
    __Cont: /* CIL Label */ 
    i___0 ++;
  }
  GC_Resize_Less(gc);
  gc->mitems = (gc->nitems + gc->nitems / 2UL) + 1UL;
  i___1 = (size_t )0;
  while (i___1 < gc->freenum) {
    if (*(gc->freelist + i___1)) {
      tmp___1 = destruct(*(gc->freelist + i___1));
      dealloc(tmp___1);
    }
    i___1 ++;
  }
  free((void *)gc->freelist);
  gc->freelist = (var *)((void *)0);
  gc->freenum = (uintptr_t )0;
  return;
}
}
static var GC_Current(void) 
{ 
  struct String __constr_expr_1086 ;
  char __constr_expr_1087[sizeof(struct Header ) + sizeof(struct String )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  var tmp___2 ;
  var tmp___3 ;

  {
  __constr_expr_1086.val = (char *)"__GC";
  __constr_expr_1087[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_1087[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_1087), String, 2);
  tmp___1 = memcpy((void * __restrict  )((struct String *)tmp___0), (void const   * __restrict  )(& __constr_expr_1086),
                   sizeof(struct String ));
  tmp___2 = current(Thread);
  tmp___3 = get(tmp___2, (var )((struct String *)tmp___1));
  return (tmp___3);
}
}
static void GC_New(var self , var args ) 
{ 
  struct GC *gc ;
  struct Ref *bt ;
  struct Int __constr_expr_1088 ;
  char __constr_expr_1089[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  var tmp___2 ;
  var tmp___3 ;
  struct String __constr_expr_1090 ;
  char __constr_expr_1091[sizeof(struct Header ) + sizeof(struct String )] ;
  unsigned int tmp___4 ;
  var tmp___5 ;
  void *tmp___6 ;
  var tmp___7 ;

  {
  gc = (struct GC *)self;
  __constr_expr_1088.val = (int64_t )0;
  __constr_expr_1089[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_1089[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_1089), Int, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Int *)tmp___0), (void const   * __restrict  )(& __constr_expr_1088),
                   sizeof(struct Int ));
  tmp___2 = get(args, (var )((struct Int *)tmp___1));
  tmp___3 = cast(tmp___2, Ref);
  bt = (struct Ref *)tmp___3;
  gc->bottom = bt->val;
  gc->maxptr = (uintptr_t )0;
  gc->minptr = 18446744073709551615;
  gc->running = (_Bool)1;
  gc->freelist = (var *)((void *)0);
  gc->freenum = (uintptr_t )0;
  __constr_expr_1090.val = (char *)"__GC";
  __constr_expr_1091[0] = (char)0;
  tmp___4 = 1U;
  while (! (tmp___4 >= 32U)) {
    __constr_expr_1091[tmp___4] = (char)0;
    tmp___4 ++;
  }
  tmp___5 = header_init((var )(__constr_expr_1091), String, 2);
  tmp___6 = memcpy((void * __restrict  )((struct String *)tmp___5), (void const   * __restrict  )(& __constr_expr_1090),
                   sizeof(struct String ));
  tmp___7 = current(Thread);
  set(tmp___7, (var )((struct String *)tmp___6), (var )gc);
  return;
}
}
static void GC_Del(var self ) 
{ 
  struct GC *gc ;
  struct String __constr_expr_1092 ;
  char __constr_expr_1093[sizeof(struct Header ) + sizeof(struct String )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  var tmp___2 ;

  {
  gc = (struct GC *)self;
  GC_Sweep(gc);
  free((void *)gc->entries);
  free((void *)gc->freelist);
  __constr_expr_1092.val = (char *)"__GC";
  __constr_expr_1093[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_1093[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_1093), String, 2);
  tmp___1 = memcpy((void * __restrict  )((struct String *)tmp___0), (void const   * __restrict  )(& __constr_expr_1092),
                   sizeof(struct String ));
  tmp___2 = current(Thread);
  rem(tmp___2, (var )((struct String *)tmp___1));
  return;
}
}
static void GC_Set(var self , var key , var val ) 
{ 
  struct GC *gc ;
  int64_t tmp ;

  {
  gc = (struct GC *)self;
  if (! gc->running) {
    return;
  }
  (gc->nitems) ++;
  if ((uintptr_t )key > gc->maxptr) {
    gc->maxptr = (uintptr_t )key;
  } else {
    gc->maxptr = gc->maxptr;
  }
  if ((uintptr_t )key < gc->minptr) {
    gc->minptr = (uintptr_t )key;
  } else {
    gc->minptr = gc->minptr;
  }
  GC_Resize_More(gc);
  tmp = c_int(val);
  GC_Set_Ptr(gc, key, (_Bool )tmp);
  if (gc->nitems > gc->mitems) {
    GC_Mark(gc);
    GC_Sweep(gc);
  }
  return;
}
}
static void GC_Rem(var self , var key ) 
{ 
  struct GC *gc ;

  {
  gc = (struct GC *)self;
  if (! gc->running) {
    return;
  }
  GC_Rem_Ptr(gc, key);
  GC_Resize_Less(gc);
  gc->mitems = (gc->nitems + gc->nitems / 2UL) + 1UL;
  return;
}
}
static _Bool GC_Mem(var self , var key ) 
{ 
  _Bool tmp ;

  {
  tmp = GC_Mem_Ptr((struct GC *)self, key);
  return (tmp);
}
}
static void GC_Start(var self ) 
{ 
  struct GC *gc ;

  {
  gc = (struct GC *)self;
  gc->running = (_Bool)1;
  return;
}
}
static void GC_Stop(var self ) 
{ 
  struct GC *gc ;

  {
  gc = (struct GC *)self;
  gc->running = (_Bool)0;
  return;
}
}
static _Bool GC_Running(var self ) 
{ 
  struct GC *gc ;

  {
  gc = (struct GC *)self;
  return (gc->running);
}
}
static struct Doc __constr_expr_1095  =    {& GC_Name, & GC_Brief, & GC_Description, (char const   *(*)(void))((void *)0),
    & GC_Examples, (struct Method *(*)(void))((void *)0)};
static struct New __constr_expr_1096  =    {& GC_New, & GC_Del};
static struct Get __constr_expr_1097  =    {(var (*)(var  , var  ))((void *)0), & GC_Set, & GC_Mem, & GC_Rem, (var (*)(var  ))0,
    (var (*)(var  ))0};
static struct Start __constr_expr_1098  =    {& GC_Start, & GC_Stop, (void (*)(var  ))((void *)0), & GC_Running};
static struct Show __constr_expr_1099  =    {& GC_Show, (int (*)(var  , var  , int  ))((void *)0)};
static struct Current __constr_expr_1100  =    {& GC_Current};
static var __constr_expr_1094[48]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"GC", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct GC ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_1095),      (void *)0,      (var )"New", 
        (var )(& __constr_expr_1096),      (void *)0,      (var )"Get",      (var )(& __constr_expr_1097), 
        (void *)0,      (var )"Start",      (var )(& __constr_expr_1098),      (void *)0, 
        (var )"Show",      (var )(& __constr_expr_1099),      (void *)0,      (var )"Current", 
        (var )(& __constr_expr_1100),      (void *)0,      (void *)0,      (void *)0};
var GC  =    (var )((char *)(__constr_expr_1094) + sizeof(struct Header ));
void Cello_Exit(void) 
{ 
  var tmp ;

  {
  tmp = current(GC);
  del_raw(tmp);
  return;
}
}
#pragma merger("0","/tmp/cil-ACwHOKE5.i","-std=gnu99,-Wall,-Wno-unused,-g,-ggdb,-fPIC")
var Array ;
static char const   *Array_Name(void) 
{ 


  {
  return ("Array");
}
}
static char const   *Array_Brief(void) 
{ 


  {
  return ("Sequential Container");
}
}
static char const   *Array_Description(void) 
{ 


  {
  return ("The `Array` type is data structure containing a sequence of a single type of object. It can dynamically grow and shrink in size depending on how many elements it contains. It allocates storage for the type specified. It also deallocates and destroys the objects inside upon destruction.\n\nElements are copied into an Array using `assign` and will initially have zero\'d memory.\n\nElements are ordered linearly. Elements are accessed by their position in this sequence directly. Addition and removal of elements at the end of the sequence is fast, with memory movement required for elements in the middle of the sequence.\n\nThis is largely equivalent to the C++ construct [std::vector](http://www.cplusplus.com/reference/vector/vector/)");
}
}
static struct Example *Array_Examples(void) ;
static struct Example examples___46[5]  = {      {"Construction & Deletion", "var x = new(Array, Int);\npush(x, $I(32));\npush(x, $I(6));\n\n/* <\'Array\' At 0x0000000000414603 [32, 6]> */\nshow(x);\n"}, 
        {"Element Access",
      "var x = new(Array, Float, $F(0.01), $F(5.12));\n\nshow(get(x, $I(0))); /* 0.01 */\nshow(get(x, $I(1))); /* 5.12 */\n\nset(x, $I(0), $F(500.1));\nshow(get(x, $I(0))); /* 500.1 */\n"}, 
        {"Membership",
      "var x = new(Array, Int, $I(1), $I(2), $I(3), $I(4));\n\nshow($I(mem(x, $I(1)))); /* 1 */\nshow($I(len(x)));        /* 4 */\n\nrem(x, $I(3));\n\nshow($I(mem(x, $I(3)))); /* 0 */\nshow($I(len(x)));        /* 3 */\nshow($I(empty(x)));      /* 0 */\n\nresize(x, 0);\n\nshow($I(empty(x)));      /* 1 */\n"}, 
        {"Iteration",
      "var greetings = new(Array, String, \n  $S(\"Hello\"), $S(\"Bonjour\"), $S(\"Hej\"));\n\nforeach(greet in greetings) {\n  show(greet);\n}\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Array_Examples(void) 
{ 


  {
  return (examples___46);
}
}
static size_t Array_Step(struct Array *a ) 
{ 


  {
  return (a->tsize + sizeof(struct Header ));
}
}
static var Array_Item(struct Array *a , size_t i ) 
{ 
  size_t tmp ;

  {
  tmp = Array_Step(a);
  return ((var )(((char *)a->data + tmp * i) + sizeof(struct Header )));
}
}
static void Array_Alloc(struct Array *a , size_t i ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  struct Header *head ;
  size_t tmp___1 ;

  {
  tmp = Array_Step(a);
  tmp___0 = Array_Step(a);
  memset((void *)((char *)a->data + tmp___0 * i), 0, tmp);
  tmp___1 = Array_Step(a);
  head = (struct Header *)((char *)a->data + tmp___1 * i);
  header_init((var )head, a->type, 4);
  return;
}
}
static size_t Array_Size_Round(size_t s ) 
{ 


  {
  return ((((s + sizeof(var )) - 1UL) / sizeof(var )) * sizeof(var ));
}
}
static void Array_New(var self , var args ) 
{ 
  struct Array *a ;
  struct Int __constr_expr_1101 ;
  char __constr_expr_1102[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  var tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  struct Tuple __constr_expr_1103 ;
  var __constr_expr_1104[1] ;
  char __constr_expr_1105[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___6 ;
  var tmp___7 ;
  void *tmp___8 ;
  size_t i ;
  struct Int __constr_expr_1106 ;
  char __constr_expr_1107[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___9 ;
  var tmp___10 ;
  void *tmp___11 ;
  var tmp___12 ;
  var tmp___13 ;

  {
  a = (struct Array *)self;
  __constr_expr_1101.val = (int64_t )0;
  __constr_expr_1102[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_1102[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_1102), Int, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Int *)tmp___0), (void const   * __restrict  )(& __constr_expr_1101),
                   sizeof(struct Int ));
  tmp___2 = get(args, (var )((struct Int *)tmp___1));
  a->type = cast(tmp___2, Type);
  tmp___3 = size(a->type);
  a->tsize = Array_Size_Round(tmp___3);
  tmp___4 = len(args);
  a->nitems = tmp___4 - 1UL;
  a->nslots = a->nitems;
  if (a->nslots == 0UL) {
    a->data = (void *)0;
    return;
  }
  tmp___5 = Array_Step(a);
  a->data = malloc(a->nslots * tmp___5);
  if ((unsigned long )a->data == (unsigned long )((void *)0)) {
    __constr_expr_1104[0] = Terminal;
    __constr_expr_1103.items = __constr_expr_1104;
    __constr_expr_1105[0] = (char)0;
    tmp___6 = 1U;
    while (! (tmp___6 >= 32U)) {
      __constr_expr_1105[tmp___6] = (char)0;
      tmp___6 ++;
    }
    tmp___7 = header_init((var )(__constr_expr_1105), Tuple, 2);
    tmp___8 = memcpy((void * __restrict  )((struct Tuple *)tmp___7), (void const   * __restrict  )(& __constr_expr_1103),
                     sizeof(struct Tuple ));
    exception_throw(OutOfMemoryError, "Cannot allocate Array, out of memory!", (var )((struct Tuple *)tmp___8));
  }
  i = (size_t )0;
  while (i < a->nitems) {
    Array_Alloc(a, i);
    __constr_expr_1106.val = (int64_t )(i + 1UL);
    __constr_expr_1107[0] = (char)0;
    tmp___9 = 1U;
    while (! (tmp___9 >= 32U)) {
      __constr_expr_1107[tmp___9] = (char)0;
      tmp___9 ++;
    }
    tmp___10 = header_init((var )(__constr_expr_1107), Int, 2);
    tmp___11 = memcpy((void * __restrict  )((struct Int *)tmp___10), (void const   * __restrict  )(& __constr_expr_1106),
                      sizeof(struct Int ));
    tmp___12 = get(args, (var )((struct Int *)tmp___11));
    tmp___13 = Array_Item(a, i);
    assign(tmp___13, tmp___12);
    i ++;
  }
  return;
}
}
static void Array_Del(var self ) 
{ 
  struct Array *a ;
  size_t i ;
  var tmp ;

  {
  a = (struct Array *)self;
  i = (size_t )0;
  while (i < a->nitems) {
    tmp = Array_Item(a, i);
    destruct(tmp);
    i ++;
  }
  free(a->data);
  return;
}
}
static void Array_Clear(var self ) 
{ 
  struct Array *a ;
  size_t i ;
  var tmp ;

  {
  a = (struct Array *)self;
  i = (size_t )0;
  while (i < a->nitems) {
    tmp = Array_Item(a, i);
    destruct(tmp);
    i ++;
  }
  free(a->data);
  a->data = (void *)0;
  a->nitems = (size_t )0;
  a->nslots = (size_t )0;
  return;
}
}
static void Array_Push(var self , var obj ) ;
static void Array_Assign(var self , var obj ) 
{ 
  struct Array *a ;
  var tmp___0 ;
  _Bool tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  struct Tuple __constr_expr_1108 ;
  var __constr_expr_1109[1] ;
  char __constr_expr_1110[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___4 ;
  var tmp___5 ;
  void *tmp___6 ;
  size_t i ;
  struct Int __constr_expr_1111 ;
  char __constr_expr_1112[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___7 ;
  var tmp___8 ;
  void *tmp___9 ;
  var tmp___10 ;
  var tmp___11 ;
  var __item ;
  var __Iteritem ;
  var tmp___12 ;
  var item ;
  var tmp___13 ;
  _Bool tmp___14 ;
  _Bool tmp___15 ;

  {
  a = (struct Array *)self;
  Array_Clear(self);
  tmp___1 = implements_method_at_offset(obj, Iter, (unsigned long )(& ((struct Iter *)0)->iter_type));
  if (tmp___1) {
    tmp___0 = iter_type(obj);
    a->type = tmp___0;
  } else {
    a->type = Ref;
  }
  tmp___2 = size(a->type);
  a->tsize = Array_Size_Round(tmp___2);
  a->nitems = (size_t )0;
  a->nslots = (size_t )0;
  tmp___14 = implements_method_at_offset(obj, Len, (unsigned long )(& ((struct Len *)0)->len));
  if (tmp___14) {
    tmp___15 = implements_method_at_offset(obj, Get, (unsigned long )(& ((struct Get *)0)->get));
    if (tmp___15) {
      a->nitems = len(obj);
      a->nslots = a->nitems;
      if (a->nslots == 0UL) {
        a->data = (void *)0;
        return;
      }
      tmp___3 = Array_Step(a);
      a->data = malloc(a->nslots * tmp___3);
      if ((unsigned long )a->data == (unsigned long )((void *)0)) {
        __constr_expr_1109[0] = Terminal;
        __constr_expr_1108.items = __constr_expr_1109;
        __constr_expr_1110[0] = (char)0;
        tmp___4 = 1U;
        while (! (tmp___4 >= 32U)) {
          __constr_expr_1110[tmp___4] = (char)0;
          tmp___4 ++;
        }
        tmp___5 = header_init((var )(__constr_expr_1110), Tuple, 2);
        tmp___6 = memcpy((void * __restrict  )((struct Tuple *)tmp___5), (void const   * __restrict  )(& __constr_expr_1108),
                         sizeof(struct Tuple ));
        exception_throw(OutOfMemoryError, "Cannot allocate Array, out of memory!",
                        (var )((struct Tuple *)tmp___6));
      }
      i = (size_t )0;
      while (i < a->nitems) {
        Array_Alloc(a, i);
        __constr_expr_1111.val = (int64_t )i;
        __constr_expr_1112[0] = (char)0;
        tmp___7 = 1U;
        while (! (tmp___7 >= 32U)) {
          __constr_expr_1112[tmp___7] = (char)0;
          tmp___7 ++;
        }
        tmp___8 = header_init((var )(__constr_expr_1112), Int, 2);
        tmp___9 = memcpy((void * __restrict  )((struct Int *)tmp___8), (void const   * __restrict  )(& __constr_expr_1111),
                         sizeof(struct Int ));
        tmp___10 = get(obj, (var )((struct Int *)tmp___9));
        tmp___11 = Array_Item(a, i);
        assign(tmp___11, tmp___10);
        i ++;
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    __item = obj;
    tmp___12 = instance(__item, Iter);
    __Iteritem = tmp___12;
    tmp___13 = (*(((struct Iter *)__Iteritem)->iter_init))(__item);
    item = tmp___13;
    while ((unsigned long )item != (unsigned long )Terminal) {
      Array_Push(self, item);
      item = (*(((struct Iter *)__Iteritem)->iter_next))(__item, item);
    }
  }
  return;
}
}
static void Array_Reserve_More(struct Array *a ) 
{ 
  size_t tmp ;
  struct Tuple __constr_expr_1113 ;
  var __constr_expr_1114[1] ;
  char __constr_expr_1115[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;

  {
  if (a->nitems > a->nslots) {
    a->nslots = a->nitems + a->nitems / 2UL;
    tmp = Array_Step(a);
    a->data = realloc(a->data, tmp * a->nslots);
    if ((unsigned long )a->data == (unsigned long )((void *)0)) {
      __constr_expr_1114[0] = Terminal;
      __constr_expr_1113.items = __constr_expr_1114;
      __constr_expr_1115[0] = (char)0;
      tmp___0 = 1U;
      while (! (tmp___0 >= 32U)) {
        __constr_expr_1115[tmp___0] = (char)0;
        tmp___0 ++;
      }
      tmp___1 = header_init((var )(__constr_expr_1115), Tuple, 2);
      tmp___2 = memcpy((void * __restrict  )((struct Tuple *)tmp___1), (void const   * __restrict  )(& __constr_expr_1113),
                       sizeof(struct Tuple ));
      exception_throw(OutOfMemoryError, "Cannot grow Array, out of memory!", (var )((struct Tuple *)tmp___2));
    }
  }
  return;
}
}
static void Array_Concat(var self , var obj ) 
{ 
  struct Array *a ;
  size_t i ;
  size_t olen ;
  size_t tmp ;
  var __item ;
  var __Iteritem ;
  var tmp___0 ;
  var item ;
  var tmp___1 ;
  var tmp___2 ;

  {
  a = (struct Array *)self;
  i = (size_t )0;
  tmp = len(obj);
  olen = tmp;
  a->nitems += olen;
  Array_Reserve_More(a);
  __item = obj;
  tmp___0 = instance(__item, Iter);
  __Iteritem = tmp___0;
  tmp___1 = (*(((struct Iter *)__Iteritem)->iter_init))(__item);
  item = tmp___1;
  while ((unsigned long )item != (unsigned long )Terminal) {
    Array_Alloc(a, (a->nitems - olen) + i);
    tmp___2 = Array_Item(a, (a->nitems - olen) + i);
    assign(tmp___2, item);
    i ++;
    item = (*(((struct Iter *)__Iteritem)->iter_next))(__item, item);
  }
  return;
}
}
static var Array_Iter_Init(var self ) ;
static var Array_Iter_Next(var self , var curr ) ;
static int Array_Cmp(var self , var obj ) 
{ 
  var item0 ;
  var tmp ;
  var item1 ;
  var tmp___0 ;
  int c ;
  int tmp___1 ;

  {
  tmp = Array_Iter_Init(self);
  item0 = tmp;
  tmp___0 = iter_init(obj);
  item1 = tmp___0;
  while (1) {
    if ((unsigned long )item0 == (unsigned long )Terminal) {
      if ((unsigned long )item1 == (unsigned long )Terminal) {
        return (0);
      }
    }
    if ((unsigned long )item0 == (unsigned long )Terminal) {
      return (-1);
    }
    if ((unsigned long )item1 == (unsigned long )Terminal) {
      return (1);
    }
    tmp___1 = cmp(item0, item1);
    c = tmp___1;
    if (c < 0) {
      return (-1);
    }
    if (c > 0) {
      return (1);
    }
    item0 = Array_Iter_Next(self, item0);
    item1 = iter_next(obj, item1);
  }
  return (0);
}
}
static uint64_t Array_Hash(var self ) 
{ 
  struct Array *a ;
  uint64_t h ;
  size_t i ;
  var tmp ;
  uint64_t tmp___0 ;

  {
  a = (struct Array *)self;
  h = (uint64_t )0;
  i = (size_t )0;
  while (i < a->nitems) {
    tmp = Array_Item(a, i);
    tmp___0 = hash(tmp);
    h ^= tmp___0;
    i ++;
  }
  return (h);
}
}
static size_t Array_Len(var self ) 
{ 
  struct Array *a ;

  {
  a = (struct Array *)self;
  return (a->nitems);
}
}
static _Bool Array_Mem(var self , var obj ) 
{ 
  struct Array *a ;
  size_t i ;
  var tmp ;
  _Bool tmp___0 ;

  {
  a = (struct Array *)self;
  i = (size_t )0;
  while (i < a->nitems) {
    tmp = Array_Item(a, i);
    tmp___0 = eq(tmp, obj);
    if (tmp___0) {
      return ((_Bool)1);
    }
    i ++;
  }
  return ((_Bool)0);
}
}
static void Array_Reserve_Less(struct Array *a ) 
{ 
  size_t tmp ;

  {
  if (a->nslots > a->nitems + a->nitems / 2UL) {
    a->nslots = a->nitems;
    tmp = Array_Step(a);
    a->data = realloc(a->data, tmp * a->nslots);
  }
  return;
}
}
static void Array_Pop_At(var self , var key ) 
{ 
  struct Array *a ;
  int64_t i ;
  int64_t tmp ;
  struct Tuple __constr_expr_1116 ;
  var __constr_expr_1117[3] ;
  struct Int __constr_expr_1118 ;
  char __constr_expr_1119[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;
  char __constr_expr_1120[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;
  var tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;

  {
  a = (struct Array *)self;
  tmp = c_int(key);
  i = tmp;
  if (i < 0L) {
    i = (int64_t )(a->nitems + (size_t )i);
  } else {
    i = i;
  }
  if (i < 0L) {
    goto _L;
  } else
  if (i >= (int64_t )a->nitems) {
    _L: /* CIL Label */ 
    __constr_expr_1118.val = (int64_t )a->nitems;
    __constr_expr_1119[0] = (char)0;
    tmp___0 = 1U;
    while (! (tmp___0 >= 32U)) {
      __constr_expr_1119[tmp___0] = (char)0;
      tmp___0 ++;
    }
    tmp___1 = header_init((var )(__constr_expr_1119), Int, 2);
    tmp___2 = memcpy((void * __restrict  )((struct Int *)tmp___1), (void const   * __restrict  )(& __constr_expr_1118),
                     sizeof(struct Int ));
    __constr_expr_1117[0] = key;
    __constr_expr_1117[1] = (var )((struct Int *)tmp___2);
    __constr_expr_1117[2] = Terminal;
    __constr_expr_1116.items = __constr_expr_1117;
    __constr_expr_1120[0] = (char)0;
    tmp___3 = 1U;
    while (! (tmp___3 >= 32U)) {
      __constr_expr_1120[tmp___3] = (char)0;
      tmp___3 ++;
    }
    tmp___4 = header_init((var )(__constr_expr_1120), Tuple, 2);
    tmp___5 = memcpy((void * __restrict  )((struct Tuple *)tmp___4), (void const   * __restrict  )(& __constr_expr_1116),
                     sizeof(struct Tuple ));
    exception_throw(IndexOutOfBoundsError, "Index \'%i\' out of bounds for Array of size %i.",
                    (var )((struct Tuple *)tmp___5));
    return;
  }
  tmp___6 = Array_Item(a, (size_t )i);
  destruct(tmp___6);
  tmp___7 = Array_Step(a);
  tmp___8 = Array_Step(a);
  tmp___9 = Array_Step(a);
  memmove((void *)((char *)a->data + tmp___9 * (size_t )i), (void const   *)((char *)a->data + tmp___8 * (size_t )(i + 1L)),
          tmp___7 * ((a->nitems - 1UL) - (size_t )i));
  (a->nitems) --;
  Array_Reserve_Less(a);
  return;
}
}
static void Array_Rem(var self , var obj ) 
{ 
  struct Array *a ;
  size_t i ;
  struct Int __constr_expr_1121 ;
  char __constr_expr_1122[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  var tmp___2 ;
  _Bool tmp___3 ;
  struct Tuple __constr_expr_1123 ;
  var __constr_expr_1124[2] ;
  char __constr_expr_1125[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___4 ;
  var tmp___5 ;
  void *tmp___6 ;

  {
  a = (struct Array *)self;
  i = (size_t )0;
  while (i < a->nitems) {
    tmp___2 = Array_Item(a, i);
    tmp___3 = eq(tmp___2, obj);
    if (tmp___3) {
      __constr_expr_1121.val = (int64_t )i;
      __constr_expr_1122[0] = (char)0;
      tmp = 1U;
      while (! (tmp >= 32U)) {
        __constr_expr_1122[tmp] = (char)0;
        tmp ++;
      }
      tmp___0 = header_init((var )(__constr_expr_1122), Int, 2);
      tmp___1 = memcpy((void * __restrict  )((struct Int *)tmp___0), (void const   * __restrict  )(& __constr_expr_1121),
                       sizeof(struct Int ));
      Array_Pop_At((var )a, (var )((struct Int *)tmp___1));
      return;
    }
    i ++;
  }
  __constr_expr_1124[0] = obj;
  __constr_expr_1124[1] = Terminal;
  __constr_expr_1123.items = __constr_expr_1124;
  __constr_expr_1125[0] = (char)0;
  tmp___4 = 1U;
  while (! (tmp___4 >= 32U)) {
    __constr_expr_1125[tmp___4] = (char)0;
    tmp___4 ++;
  }
  tmp___5 = header_init((var )(__constr_expr_1125), Tuple, 2);
  tmp___6 = memcpy((void * __restrict  )((struct Tuple *)tmp___5), (void const   * __restrict  )(& __constr_expr_1123),
                   sizeof(struct Tuple ));
  exception_throw(ValueError, "Object %$ not in Array!", (var )((struct Tuple *)tmp___6));
  return;
}
}
static void Array_Push(var self , var obj ) 
{ 
  struct Array *a ;
  var tmp ;

  {
  a = (struct Array *)self;
  (a->nitems) ++;
  Array_Reserve_More(a);
  Array_Alloc(a, a->nitems - 1UL);
  tmp = Array_Item(a, a->nitems - 1UL);
  assign(tmp, obj);
  return;
}
}
static void Array_Push_At(var self , var obj , var key ) 
{ 
  struct Array *a ;
  int64_t i ;
  int64_t tmp ;
  struct Tuple __constr_expr_1126 ;
  var __constr_expr_1127[3] ;
  struct Int __constr_expr_1128 ;
  char __constr_expr_1129[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;
  char __constr_expr_1130[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  var tmp___9 ;

  {
  a = (struct Array *)self;
  (a->nitems) ++;
  Array_Reserve_More(a);
  tmp = c_int(key);
  i = tmp;
  if (i < 0L) {
    i = (int64_t )(a->nitems + (size_t )i);
  } else {
    i = i;
  }
  if (i < 0L) {
    goto _L;
  } else
  if (i >= (int64_t )a->nitems) {
    _L: /* CIL Label */ 
    __constr_expr_1128.val = (int64_t )a->nitems;
    __constr_expr_1129[0] = (char)0;
    tmp___0 = 1U;
    while (! (tmp___0 >= 32U)) {
      __constr_expr_1129[tmp___0] = (char)0;
      tmp___0 ++;
    }
    tmp___1 = header_init((var )(__constr_expr_1129), Int, 2);
    tmp___2 = memcpy((void * __restrict  )((struct Int *)tmp___1), (void const   * __restrict  )(& __constr_expr_1128),
                     sizeof(struct Int ));
    __constr_expr_1127[0] = key;
    __constr_expr_1127[1] = (var )((struct Int *)tmp___2);
    __constr_expr_1127[2] = Terminal;
    __constr_expr_1126.items = __constr_expr_1127;
    __constr_expr_1130[0] = (char)0;
    tmp___3 = 1U;
    while (! (tmp___3 >= 32U)) {
      __constr_expr_1130[tmp___3] = (char)0;
      tmp___3 ++;
    }
    tmp___4 = header_init((var )(__constr_expr_1130), Tuple, 2);
    tmp___5 = memcpy((void * __restrict  )((struct Tuple *)tmp___4), (void const   * __restrict  )(& __constr_expr_1126),
                     sizeof(struct Tuple ));
    exception_throw(IndexOutOfBoundsError, "Index \'%i\' out of bounds for Array of size %i.",
                    (var )((struct Tuple *)tmp___5));
    return;
  }
  tmp___6 = Array_Step(a);
  tmp___7 = Array_Step(a);
  tmp___8 = Array_Step(a);
  memmove((void *)((char *)a->data + tmp___8 * (size_t )(i + 1L)), (void const   *)((char *)a->data + tmp___7 * (size_t )i),
          tmp___6 * ((a->nitems - 1UL) - (size_t )i));
  Array_Alloc((struct Array *)self, (size_t )i);
  tmp___9 = Array_Item(a, (size_t )i);
  assign(tmp___9, obj);
  return;
}
}
static void Array_Pop(var self ) 
{ 
  struct Array *a ;
  struct Tuple __constr_expr_1131 ;
  var __constr_expr_1132[1] ;
  char __constr_expr_1133[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  var tmp___2 ;

  {
  a = (struct Array *)self;
  if (a->nitems == 0UL) {
    __constr_expr_1132[0] = Terminal;
    __constr_expr_1131.items = __constr_expr_1132;
    __constr_expr_1133[0] = (char)0;
    tmp = 1U;
    while (! (tmp >= 32U)) {
      __constr_expr_1133[tmp] = (char)0;
      tmp ++;
    }
    tmp___0 = header_init((var )(__constr_expr_1133), Tuple, 2);
    tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_1131),
                     sizeof(struct Tuple ));
    exception_throw(IndexOutOfBoundsError, "Cannot pop. Array is empty!", (var )((struct Tuple *)tmp___1));
    return;
  }
  tmp___2 = Array_Item(a, a->nitems - 1UL);
  destruct(tmp___2);
  (a->nitems) --;
  Array_Reserve_Less(a);
  return;
}
}
static var Array_Get(var self , var key ) 
{ 
  struct Array *a ;
  int64_t i ;
  int64_t tmp ;
  struct Tuple __constr_expr_1134 ;
  var __constr_expr_1135[3] ;
  struct Int __constr_expr_1136 ;
  char __constr_expr_1137[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;
  char __constr_expr_1138[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;
  var tmp___6 ;
  var tmp___7 ;

  {
  a = (struct Array *)self;
  tmp = c_int(key);
  i = tmp;
  if (i < 0L) {
    i = (int64_t )(a->nitems + (size_t )i);
  } else {
    i = i;
  }
  if (i < 0L) {
    goto _L;
  } else
  if (i >= (int64_t )a->nitems) {
    _L: /* CIL Label */ 
    __constr_expr_1136.val = (int64_t )a->nitems;
    __constr_expr_1137[0] = (char)0;
    tmp___0 = 1U;
    while (! (tmp___0 >= 32U)) {
      __constr_expr_1137[tmp___0] = (char)0;
      tmp___0 ++;
    }
    tmp___1 = header_init((var )(__constr_expr_1137), Int, 2);
    tmp___2 = memcpy((void * __restrict  )((struct Int *)tmp___1), (void const   * __restrict  )(& __constr_expr_1136),
                     sizeof(struct Int ));
    __constr_expr_1135[0] = key;
    __constr_expr_1135[1] = (var )((struct Int *)tmp___2);
    __constr_expr_1135[2] = Terminal;
    __constr_expr_1134.items = __constr_expr_1135;
    __constr_expr_1138[0] = (char)0;
    tmp___3 = 1U;
    while (! (tmp___3 >= 32U)) {
      __constr_expr_1138[tmp___3] = (char)0;
      tmp___3 ++;
    }
    tmp___4 = header_init((var )(__constr_expr_1138), Tuple, 2);
    tmp___5 = memcpy((void * __restrict  )((struct Tuple *)tmp___4), (void const   * __restrict  )(& __constr_expr_1134),
                     sizeof(struct Tuple ));
    tmp___6 = exception_throw(IndexOutOfBoundsError, "Index \'%i\' out of bounds for Array of size %i.",
                              (var )((struct Tuple *)tmp___5));
    return (tmp___6);
  }
  tmp___7 = Array_Item(a, (size_t )i);
  return (tmp___7);
}
}
static void Array_Set(var self , var key , var val ) 
{ 
  struct Array *a ;
  int64_t i ;
  int64_t tmp ;
  struct Tuple __constr_expr_1139 ;
  var __constr_expr_1140[3] ;
  struct Int __constr_expr_1141 ;
  char __constr_expr_1142[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;
  char __constr_expr_1143[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;
  var tmp___6 ;

  {
  a = (struct Array *)self;
  tmp = c_int(key);
  i = tmp;
  if (i < 0L) {
    i = (int64_t )(a->nitems + (size_t )i);
  } else {
    i = i;
  }
  if (i < 0L) {
    goto _L;
  } else
  if (i >= (int64_t )a->nitems) {
    _L: /* CIL Label */ 
    __constr_expr_1141.val = (int64_t )a->nitems;
    __constr_expr_1142[0] = (char)0;
    tmp___0 = 1U;
    while (! (tmp___0 >= 32U)) {
      __constr_expr_1142[tmp___0] = (char)0;
      tmp___0 ++;
    }
    tmp___1 = header_init((var )(__constr_expr_1142), Int, 2);
    tmp___2 = memcpy((void * __restrict  )((struct Int *)tmp___1), (void const   * __restrict  )(& __constr_expr_1141),
                     sizeof(struct Int ));
    __constr_expr_1140[0] = key;
    __constr_expr_1140[1] = (var )((struct Int *)tmp___2);
    __constr_expr_1140[2] = Terminal;
    __constr_expr_1139.items = __constr_expr_1140;
    __constr_expr_1143[0] = (char)0;
    tmp___3 = 1U;
    while (! (tmp___3 >= 32U)) {
      __constr_expr_1143[tmp___3] = (char)0;
      tmp___3 ++;
    }
    tmp___4 = header_init((var )(__constr_expr_1143), Tuple, 2);
    tmp___5 = memcpy((void * __restrict  )((struct Tuple *)tmp___4), (void const   * __restrict  )(& __constr_expr_1139),
                     sizeof(struct Tuple ));
    exception_throw(IndexOutOfBoundsError, "Index \'%i\' out of bounds for Array of size %i.",
                    (var )((struct Tuple *)tmp___5));
    return;
  }
  tmp___6 = Array_Item(a, (size_t )i);
  assign(tmp___6, val);
  return;
}
}
static var Array_Iter_Init(var self ) 
{ 
  struct Array *a ;
  var tmp ;

  {
  a = (struct Array *)self;
  if (a->nitems == 0UL) {
    return (Terminal);
  }
  tmp = Array_Item(a, (size_t )0);
  return (tmp);
}
}
static var Array_Iter_Next(var self , var curr ) 
{ 
  struct Array *a ;
  size_t tmp ;
  var tmp___0 ;

  {
  a = (struct Array *)self;
  tmp___0 = Array_Item(a, a->nitems - 1UL);
  if ((unsigned long )curr >= (unsigned long )tmp___0) {
    return (Terminal);
  } else {
    tmp = Array_Step(a);
    return ((var )((char *)curr + tmp));
  }
}
}
static var Array_Iter_Last(var self ) 
{ 
  struct Array *a ;
  var tmp ;

  {
  a = (struct Array *)self;
  if (a->nitems == 0UL) {
    return (Terminal);
  }
  tmp = Array_Item(a, a->nitems - 1UL);
  return (tmp);
}
}
static var Array_Iter_Prev(var self , var curr ) 
{ 
  struct Array *a ;
  size_t tmp ;
  var tmp___0 ;

  {
  a = (struct Array *)self;
  tmp___0 = Array_Item(a, (size_t )0);
  if ((unsigned long )curr < (unsigned long )tmp___0) {
    return (Terminal);
  } else {
    tmp = Array_Step(a);
    return ((var )((char *)curr - tmp));
  }
}
}
static var Array_Iter_Type(var self ) 
{ 
  struct Array *a ;

  {
  a = (struct Array *)self;
  return (a->type);
}
}
static size_t Array_Sort_Partition(struct Array *a , int64_t l , int64_t r , _Bool (*f)(var  ,
                                                                                        var  ) ) 
{ 
  int64_t p ;
  var tmp ;
  var tmp___0 ;
  int64_t s ;
  int64_t i ;
  var tmp___1 ;
  var tmp___2 ;
  var tmp___3 ;
  struct Int __constr_expr_1144 ;
  char __constr_expr_1145[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___4 ;
  var tmp___5 ;
  void *tmp___6 ;
  var tmp___7 ;
  _Bool tmp___8 ;
  var tmp___9 ;
  var tmp___10 ;

  {
  p = l + (r - l) / 2L;
  tmp = Array_Item(a, (size_t )r);
  tmp___0 = Array_Item(a, (size_t )p);
  swap(tmp___0, tmp);
  s = l;
  i = l;
  while (i < r) {
    tmp___3 = Array_Item(a, (size_t )r);
    __constr_expr_1144.val = i;
    __constr_expr_1145[0] = (char)0;
    tmp___4 = 1U;
    while (! (tmp___4 >= 32U)) {
      __constr_expr_1145[tmp___4] = (char)0;
      tmp___4 ++;
    }
    tmp___5 = header_init((var )(__constr_expr_1145), Int, 2);
    tmp___6 = memcpy((void * __restrict  )((struct Int *)tmp___5), (void const   * __restrict  )(& __constr_expr_1144),
                     sizeof(struct Int ));
    tmp___7 = Array_Get((var )a, (var )((struct Int *)tmp___6));
    tmp___8 = (*f)(tmp___7, tmp___3);
    if (tmp___8) {
      tmp___1 = Array_Item(a, (size_t )s);
      tmp___2 = Array_Item(a, (size_t )i);
      swap(tmp___2, tmp___1);
      s ++;
    }
    i ++;
  }
  tmp___9 = Array_Item(a, (size_t )r);
  tmp___10 = Array_Item(a, (size_t )s);
  swap(tmp___10, tmp___9);
  return ((size_t )s);
}
}
static void Array_Sort_Part(struct Array *a , int64_t l , int64_t r , _Bool (*f)(var  ,
                                                                                 var  ) ) 
{ 
  int64_t s ;
  size_t tmp ;

  {
  if (l < r) {
    tmp = Array_Sort_Partition(a, l, r, f);
    s = (int64_t )tmp;
    Array_Sort_Part(a, l, s - 1L, f);
    Array_Sort_Part(a, s + 1L, r, f);
  }
  return;
}
}
static void Array_Sort_By(var self , _Bool (*f)(var  , var  ) ) 
{ 
  size_t tmp ;

  {
  tmp = Array_Len(self);
  Array_Sort_Part((struct Array *)self, (int64_t )0, (int64_t )(tmp - 1UL), f);
  return;
}
}
static int Array_Show(var self , var output , int pos ) 
{ 
  struct Array *a ;
  struct Tuple __constr_expr_1146 ;
  var __constr_expr_1147[2] ;
  char __constr_expr_1148[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  size_t i ;
  struct Tuple __constr_expr_1149 ;
  var __constr_expr_1150[2] ;
  var tmp___2 ;
  char __constr_expr_1151[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;
  struct Tuple __constr_expr_1152 ;
  var __constr_expr_1153[1] ;
  char __constr_expr_1154[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___6 ;
  var tmp___7 ;
  void *tmp___8 ;
  struct Tuple __constr_expr_1155 ;
  var __constr_expr_1156[1] ;
  char __constr_expr_1157[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___9 ;
  var tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;

  {
  a = (struct Array *)self;
  __constr_expr_1147[0] = self;
  __constr_expr_1147[1] = Terminal;
  __constr_expr_1146.items = __constr_expr_1147;
  __constr_expr_1148[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_1148[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_1148), Tuple, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_1146),
                   sizeof(struct Tuple ));
  pos = print_to_with(output, pos, "<\'Array\' At 0x%p [", (var )((struct Tuple *)tmp___1));
  i = (size_t )0;
  while (i < a->nitems) {
    tmp___2 = Array_Item(a, i);
    __constr_expr_1150[0] = tmp___2;
    __constr_expr_1150[1] = Terminal;
    __constr_expr_1149.items = __constr_expr_1150;
    __constr_expr_1151[0] = (char)0;
    tmp___3 = 1U;
    while (! (tmp___3 >= 32U)) {
      __constr_expr_1151[tmp___3] = (char)0;
      tmp___3 ++;
    }
    tmp___4 = header_init((var )(__constr_expr_1151), Tuple, 2);
    tmp___5 = memcpy((void * __restrict  )((struct Tuple *)tmp___4), (void const   * __restrict  )(& __constr_expr_1149),
                     sizeof(struct Tuple ));
    pos = print_to_with(output, pos, "%$", (var )((struct Tuple *)tmp___5));
    if (i < a->nitems - 1UL) {
      __constr_expr_1153[0] = Terminal;
      __constr_expr_1152.items = __constr_expr_1153;
      __constr_expr_1154[0] = (char)0;
      tmp___6 = 1U;
      while (! (tmp___6 >= 32U)) {
        __constr_expr_1154[tmp___6] = (char)0;
        tmp___6 ++;
      }
      tmp___7 = header_init((var )(__constr_expr_1154), Tuple, 2);
      tmp___8 = memcpy((void * __restrict  )((struct Tuple *)tmp___7), (void const   * __restrict  )(& __constr_expr_1152),
                       sizeof(struct Tuple ));
      pos = print_to_with(output, pos, ", ", (var )((struct Tuple *)tmp___8));
    }
    i ++;
  }
  __constr_expr_1156[0] = Terminal;
  __constr_expr_1155.items = __constr_expr_1156;
  __constr_expr_1157[0] = (char)0;
  tmp___9 = 1U;
  while (! (tmp___9 >= 32U)) {
    __constr_expr_1157[tmp___9] = (char)0;
    tmp___9 ++;
  }
  tmp___10 = header_init((var )(__constr_expr_1157), Tuple, 2);
  tmp___11 = memcpy((void * __restrict  )((struct Tuple *)tmp___10), (void const   * __restrict  )(& __constr_expr_1155),
                    sizeof(struct Tuple ));
  tmp___12 = print_to_with(output, pos, "]>", (var )((struct Tuple *)tmp___11));
  return (tmp___12);
}
}
static void Array_Resize(var self , size_t n ) 
{ 
  struct Array *a ;
  var tmp ;
  size_t tmp___0 ;
  struct Tuple __constr_expr_1158 ;
  var __constr_expr_1159[1] ;
  char __constr_expr_1160[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___1 ;
  var tmp___2 ;
  void *tmp___3 ;

  {
  a = (struct Array *)self;
  if (n == 0UL) {
    Array_Clear(self);
    return;
  }
  while (n < a->nitems) {
    tmp = Array_Item(a, a->nitems - 1UL);
    destruct(tmp);
    (a->nitems) --;
  }
  a->nslots = n;
  tmp___0 = Array_Step(a);
  a->data = realloc(a->data, tmp___0 * a->nslots);
  if ((unsigned long )a->data == (unsigned long )((void *)0)) {
    __constr_expr_1159[0] = Terminal;
    __constr_expr_1158.items = __constr_expr_1159;
    __constr_expr_1160[0] = (char)0;
    tmp___1 = 1U;
    while (! (tmp___1 >= 32U)) {
      __constr_expr_1160[tmp___1] = (char)0;
      tmp___1 ++;
    }
    tmp___2 = header_init((var )(__constr_expr_1160), Tuple, 2);
    tmp___3 = memcpy((void * __restrict  )((struct Tuple *)tmp___2), (void const   * __restrict  )(& __constr_expr_1158),
                     sizeof(struct Tuple ));
    exception_throw(OutOfMemoryError, "Cannot grow Array, out of memory!", (var )((struct Tuple *)tmp___3));
  }
  return;
}
}
static void Array_Mark(var self , var gc , void (*f)(var  , void * ) ) 
{ 
  struct Array *a ;
  size_t i ;
  var tmp ;

  {
  a = (struct Array *)self;
  i = (size_t )0;
  while (i < a->nitems) {
    tmp = Array_Item(a, i);
    (*f)(gc, tmp);
    i ++;
  }
  return;
}
}
static struct Doc __constr_expr_1162  =    {& Array_Name, & Array_Brief, & Array_Description, (char const   *(*)(void))((void *)0),
    & Array_Examples, (struct Method *(*)(void))((void *)0)};
static struct New __constr_expr_1163  =    {& Array_New, & Array_Del};
static struct Assign __constr_expr_1164  =    {& Array_Assign};
static struct Mark __constr_expr_1165  =    {& Array_Mark};
static struct Cmp __constr_expr_1166  =    {& Array_Cmp};
static struct Hash __constr_expr_1167  =    {& Array_Hash};
static struct Push __constr_expr_1168  =    {& Array_Push, & Array_Pop, & Array_Push_At, & Array_Pop_At};
static struct Concat __constr_expr_1169  =    {& Array_Concat, & Array_Push};
static struct Len __constr_expr_1170  =    {& Array_Len};
static struct Get __constr_expr_1171  =    {& Array_Get, & Array_Set, & Array_Mem, & Array_Rem, (var (*)(var  ))0, (var (*)(var  ))0};
static struct Iter __constr_expr_1172  =    {& Array_Iter_Init,
    & Array_Iter_Next, & Array_Iter_Last, & Array_Iter_Prev, & Array_Iter_Type};
static struct Sort __constr_expr_1173  =    {& Array_Sort_By};
static struct Show __constr_expr_1174  =    {& Array_Show, (int (*)(var  , var  , int  ))((void *)0)};
static struct Resize __constr_expr_1175  =    {& Array_Resize};
static var __constr_expr_1161[72]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Array", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Array ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_1162),      (void *)0,      (var )"New", 
        (var )(& __constr_expr_1163),      (void *)0,      (var )"Assign",      (var )(& __constr_expr_1164), 
        (void *)0,      (var )"Mark",      (var )(& __constr_expr_1165),      (void *)0, 
        (var )"Cmp",      (var )(& __constr_expr_1166),      (void *)0,      (var )"Hash", 
        (var )(& __constr_expr_1167),      (void *)0,      (var )"Push",      (var )(& __constr_expr_1168), 
        (void *)0,      (var )"Concat",      (var )(& __constr_expr_1169),      (void *)0, 
        (var )"Len",      (var )(& __constr_expr_1170),      (void *)0,      (var )"Get", 
        (var )(& __constr_expr_1171),      (void *)0,      (var )"Iter",      (var )(& __constr_expr_1172), 
        (void *)0,      (var )"Sort",      (var )(& __constr_expr_1173),      (void *)0, 
        (var )"Show",      (var )(& __constr_expr_1174),      (void *)0,      (var )"Resize", 
        (var )(& __constr_expr_1175),      (void *)0,      (void *)0,      (void *)0};
var Array  =    (var )((char *)(__constr_expr_1161) + sizeof(struct Header ));
#pragma merger("0","/tmp/cil-NX6Z8ndf.i","-std=gnu99,-Wall,-Wno-unused,-g,-ggdb,-fPIC")
static char const   *Get_Name(void) 
{ 


  {
  return ("Get");
}
}
static char const   *Get_Brief(void) 
{ 


  {
  return ("Gettable or Settable");
}
}
static char const   *Get_Description(void) 
{ 


  {
  return ("The `Get` class provides a method to _get_ or _set_ certain properties of an object using keys and value. Typically it is implemented by data lookup structures such as `Table` or `Map` but it is also used more generally such as using indices to look up items in `Array`, or as thread local storage for the `Thread` object.");
}
}
static char const   *Get_Definition(void) 
{ 


  {
  return ("struct Get {\n  var  (*get)(var, var);\n  void (*set)(var, var, var);\n  bool (*mem)(var, var);\n  void (*rem)(var, var);\n  var (*key_type)(var);\n  var (*val_type)(var);\n};\n");
}
}
static struct Example *Get_Examples(void) ;
static struct Example examples___47[3]  = {      {"Usage 1", "var x = new(Array, String, \n  $S(\"Hello\"), $S(\"There\"));\n\nshow(get(x, $I(0))); /* Hello */\nshow(get(x, $I(1))); /* There */\nset(x, $I(1), $S(\"Blah\"));\nshow(get(x, $I(1))); /* Blah */\n"}, 
        {"Usage 2",
      "var prices = new(Table, String, Int, \n  $S(\"Apple\"),  $I(12),\n  $S(\"Banana\"), $I( 6),\n  $S(\"Pear\"),   $I(55));\n\nvar pear_price   = get(prices, $S(\"Pear\"));\nvar banana_price = get(prices, $S(\"Banana\"));\nvar apple_price  = get(prices, $S(\"Apple\"));\n\nshow(pear_price);   /* 55 */\nshow(banana_price); /*  6 */\nshow(apple_price);  /* 12 */\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Get_Examples(void) 
{ 


  {
  return (examples___47);
}
}
static struct Method *Get_Methods(void) ;
static struct Method methods___35[7]  = {      {"get", "var get(var self, var key);", "Get the value at a given `key` for object `self`."}, 
        {"set",
      "void set(var self, var key, var val);", "Set the value at a given `key` for object `self`."}, 
        {"mem",
      "bool mem(var self, var key);", "Returns true if `key` is a member of the object `self`."}, 
        {"rem",
      "void rem(var self, var key);", "Removes the `key` from object `self`."}, 
        {"key_type", "var key_type(var self);", "Returns the key type for the object `self`."}, 
        {"val_type",
      "var val_type(var self);", "Returns the value type for the object `self`."}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Get_Methods(void) 
{ 


  {
  return (methods___35);
}
}
static struct Doc __constr_expr_1177  =    {& Get_Name, & Get_Brief, & Get_Description, & Get_Definition, & Get_Examples,
    & Get_Methods};
static var __constr_expr_1176[33]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Get", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Get ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_1177),      (void *)0,      (void *)0, 
        (void *)0};
var Get  =    (var )((char *)(__constr_expr_1176) + sizeof(struct Header ));
var get(var self , var key ) 
{ 
  var tmp ;
  var tmp___0 ;

  {
  tmp = method_at_offset(self, Get, (unsigned long )(& ((struct Get *)0)->get), "get");
  tmp___0 = (*(((struct Get *)tmp)->get))(self, key);
  return (tmp___0);
}
}
void set(var self , var key , var val ) 
{ 
  var tmp ;

  {
  tmp = method_at_offset(self, Get, (unsigned long )(& ((struct Get *)0)->set), "set");
  (*(((struct Get *)tmp)->set))(self, key, val);
  return;
}
}
_Bool mem(var self , var key ) 
{ 
  var tmp ;
  _Bool tmp___0 ;

  {
  tmp = method_at_offset(self, Get, (unsigned long )(& ((struct Get *)0)->mem), "mem");
  tmp___0 = (*(((struct Get *)tmp)->mem))(self, key);
  return (tmp___0);
}
}
void rem(var self , var key ) 
{ 
  var tmp ;

  {
  tmp = method_at_offset(self, Get, (unsigned long )(& ((struct Get *)0)->rem), "rem");
  (*(((struct Get *)tmp)->rem))(self, key);
  return;
}
}
var key_type(var self ) 
{ 
  var tmp ;
  var tmp___0 ;

  {
  tmp = method_at_offset(self, Get, (unsigned long )(& ((struct Get *)0)->key_type),
                         "key_type");
  tmp___0 = (*(((struct Get *)tmp)->key_type))(self);
  return (tmp___0);
}
}
var val_type(var self ) 
{ 
  var tmp ;
  var tmp___0 ;

  {
  tmp = method_at_offset(self, Get, (unsigned long )(& ((struct Get *)0)->val_type),
                         "val_type");
  tmp___0 = (*(((struct Get *)tmp)->val_type))(self);
  return (tmp___0);
}
}
#pragma merger("0","/tmp/cil-XYfdPMEC.i","-std=gnu99,-Wall,-Wno-unused,-g,-ggdb,-fPIC")
extern int fclose(FILE *__stream ) ;
extern int fflush(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
extern int ( /* format attribute */  vfscanf)(FILE * __restrict  __s , char const   * __restrict  __format ,
                                              __gnuc_va_list __arg )  __asm__("__isoc99_vfscanf")  ;
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
extern int fseek(FILE *__stream , long __off , int __whence ) ;
extern long ftell(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
extern FILE *popen(char const   *__command , char const   *__modes ) ;
extern int pclose(FILE *__stream ) ;
var Stream ;
var sopen(var self , var resource , var options ) ;
void sclose(var self ) ;
void sseek(var self , int64_t pos , int origin ) ;
int64_t stell(var self ) ;
void sflush(var self ) ;
_Bool seof(var self ) ;
size_t sread(var self , void *output , size_t size___0 ) ;
size_t swrite(var self , void *input , size_t size___0 ) ;
static char const   *Stream_Name(void) 
{ 


  {
  return ("Stream");
}
}
static char const   *Stream_Brief(void) 
{ 


  {
  return ("File-like");
}
}
static char const   *Stream_Description(void) 
{ 


  {
  return ("The `Stream` class represents an abstract set of operations that can be performed on File-like objects.");
}
}
static char const   *Stream_Definition(void) 
{ 


  {
  return ("struct Stream {\n  var  (*sopen)(var,var,var);\n  void (*sclose)(var);\n  void (*sseek)(var,int64_t,int);\n  int64_t (*stell)(var);\n  void (*sflush)(var);\n  bool (*seof)(var);\n  size_t (*sread)(var,void*,size_t);\n  size_t (*swrite)(var,void*,size_t);\n};\n");
}
}
static struct Example *Stream_Examples(void) ;
static struct Example examples___48[2]  = {      {"Usage", "var f = sopen($(File, NULL), $S(\"test.bin\"), $S(\"r\"));\n\nchar c;\nwhile (!seof(f)) {\n  sread(f, &c, 1);\n  putc(c, stdout);\n}\n\nsclose(f);\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Stream_Examples(void) 
{ 


  {
  return (examples___48);
}
}
static struct Method *Stream_Methods(void) ;
static struct Method methods___36[9]  = 
  {      {"sopen", "var sopen(var self, var resource, var options);", "Open the stream `self` with a given `resource` and `options`."}, 
        {"sclose",
      "void sclose(var self);", "Close the stream `self`."}, 
        {"sseek", "void sseek(var self, int64_t pos, int origin);", "Seek to the position `pos` from some `origin` in the stream `self`."}, 
        {"stell",
      "int64_t stell(var self);", "Return the current position of the stream `stell`."}, 
        {"sflush",
      "void sflush(var self);", "Flush the buffered contents of stream `self`."}, 
        {"seof", "bool seof(var self);", "Returns true if there is no more information in the stream."}, 
        {"sread",
      "size_t sread(var self, void* output, size_t size);", "Read `size` bytes from the stream `self` and write them to `output`."}, 
        {"swrite",
      "size_t swrite(var self, void* input, size_t size);", "Write `size` bytes to the stream `self` and read them from `input`."}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0), (char const   *)((void *)0)}};
static struct Method *Stream_Methods(void) 
{ 


  {
  return (methods___36);
}
}
static struct Doc __constr_expr_1179  =    {& Stream_Name, & Stream_Brief, & Stream_Description, & Stream_Definition, & Stream_Examples,
    & Stream_Methods};
static var __constr_expr_1178[33]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Stream", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Stream ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_1179),      (void *)0,      (void *)0, 
        (void *)0};
var Stream  =    (var )((char *)(__constr_expr_1178) + sizeof(struct Header ));
var sopen(var self , var resource , var options ) 
{ 
  var tmp ;
  var tmp___0 ;

  {
  tmp = method_at_offset(self, Stream, (unsigned long )(& ((struct Stream *)0)->sopen),
                         "sopen");
  tmp___0 = (*(((struct Stream *)tmp)->sopen))(self, resource, options);
  return (tmp___0);
}
}
void sclose(var self ) 
{ 
  var tmp ;

  {
  tmp = method_at_offset(self, Stream, (unsigned long )(& ((struct Stream *)0)->sclose),
                         "sclose");
  (*(((struct Stream *)tmp)->sclose))(self);
  return;
}
}
void sseek(var self , int64_t pos , int origin ) 
{ 
  var tmp ;

  {
  tmp = method_at_offset(self, Stream, (unsigned long )(& ((struct Stream *)0)->sseek),
                         "sseek");
  (*(((struct Stream *)tmp)->sseek))(self, pos, origin);
  return;
}
}
int64_t stell(var self ) 
{ 
  var tmp ;
  int64_t tmp___0 ;

  {
  tmp = method_at_offset(self, Stream, (unsigned long )(& ((struct Stream *)0)->stell),
                         "stell");
  tmp___0 = (*(((struct Stream *)tmp)->stell))(self);
  return (tmp___0);
}
}
void sflush(var self ) 
{ 
  var tmp ;

  {
  tmp = method_at_offset(self, Stream, (unsigned long )(& ((struct Stream *)0)->sflush),
                         "sflush");
  (*(((struct Stream *)tmp)->sflush))(self);
  return;
}
}
_Bool seof(var self ) 
{ 
  var tmp ;
  _Bool tmp___0 ;

  {
  tmp = method_at_offset(self, Stream, (unsigned long )(& ((struct Stream *)0)->seof),
                         "seof");
  tmp___0 = (*(((struct Stream *)tmp)->seof))(self);
  return (tmp___0);
}
}
size_t sread(var self , void *output , size_t size___0 ) 
{ 
  var tmp ;
  size_t tmp___0 ;

  {
  tmp = method_at_offset(self, Stream, (unsigned long )(& ((struct Stream *)0)->sread),
                         "sread");
  tmp___0 = (*(((struct Stream *)tmp)->sread))(self, output, size___0);
  return (tmp___0);
}
}
size_t swrite(var self , void *input , size_t size___0 ) 
{ 
  var tmp ;
  size_t tmp___0 ;

  {
  tmp = method_at_offset(self, Stream, (unsigned long )(& ((struct Stream *)0)->swrite),
                         "swrite");
  tmp___0 = (*(((struct Stream *)tmp)->swrite))(self, input, size___0);
  return (tmp___0);
}
}
static char const   *File_Name(void) 
{ 


  {
  return ("File");
}
}
static char const   *File_Brief(void) 
{ 


  {
  return ("Operating System File");
}
}
static char const   *File_Description(void) 
{ 


  {
  return ("The `File` type is a wrapper of the native C `FILE` type representing a file in the operating system.");
}
}
static char const   *File_Definition(void) 
{ 


  {
  return ("struct File {\n  FILE* file;\n};\n");
}
}
static struct Example *File_Examples(void) ;
static struct Example examples___49[4]  = {      {"Usage", "var x = new(File, $S(\"test.bin\"), $S(\"wb\"));\nchar* data = \"hello\";\nswrite(x, data, strlen(data));\nsclose(x);\n"}, 
        {"Formatted Printing",
      "var x = $(File, NULL);\nsopen(x, $S(\"test.txt\"), $S(\"w\"));\nprint_to(x, 0, \"%$ is %$ \", $S(\"Dan\"), $I(23));\nprint_to(x, 0, \"%$ is %$ \", $S(\"Chess\"), $I(24));\nsclose(x);\n"}, 
        {"Automatic Closing",
      "with(f in new(File, $S(\"test.txt\"), $S(\"r\"))) {\n  var k = new(String); resize(k, 100);\n  var v = new(Int, $I(0));\n  foreach (i in range($I(2))) {\n    scan_from(f, 0, \"%$ is %$ \", k, v);\n    show(k); show(v);\n  }\n}\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *File_Examples(void) 
{ 


  {
  return (examples___49);
}
}
static var File_Open(var self , var filename , var access ) ;
static void File_Close(var self ) ;
static void File_New(var self , var args ) 
{ 
  struct File *f ;
  struct Int __constr_expr_1180 ;
  char __constr_expr_1181[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  var tmp___2 ;
  struct Int __constr_expr_1182 ;
  char __constr_expr_1183[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;
  var tmp___6 ;
  size_t tmp___7 ;

  {
  f = (struct File *)self;
  tmp___7 = len(args);
  if (tmp___7 > 0UL) {
    __constr_expr_1180.val = (int64_t )1;
    __constr_expr_1181[0] = (char)0;
    tmp = 1U;
    while (! (tmp >= 32U)) {
      __constr_expr_1181[tmp] = (char)0;
      tmp ++;
    }
    tmp___0 = header_init((var )(__constr_expr_1181), Int, 2);
    tmp___1 = memcpy((void * __restrict  )((struct Int *)tmp___0), (void const   * __restrict  )(& __constr_expr_1180),
                     sizeof(struct Int ));
    tmp___2 = get(args, (var )((struct Int *)tmp___1));
    __constr_expr_1182.val = (int64_t )0;
    __constr_expr_1183[0] = (char)0;
    tmp___3 = 1U;
    while (! (tmp___3 >= 32U)) {
      __constr_expr_1183[tmp___3] = (char)0;
      tmp___3 ++;
    }
    tmp___4 = header_init((var )(__constr_expr_1183), Int, 2);
    tmp___5 = memcpy((void * __restrict  )((struct Int *)tmp___4), (void const   * __restrict  )(& __constr_expr_1182),
                     sizeof(struct Int ));
    tmp___6 = get(args, (var )((struct Int *)tmp___5));
    File_Open(self, tmp___6, tmp___2);
  }
  return;
}
}
static void File_Del(var self ) 
{ 
  struct File *f ;

  {
  f = (struct File *)self;
  if ((unsigned long )f->file != (unsigned long )((void *)0)) {
    File_Close(self);
  }
  return;
}
}
static var File_Open(var self , var filename , var access ) 
{ 
  struct File *f ;
  char *tmp ;
  char *tmp___0 ;
  struct Tuple __constr_expr_1184 ;
  var __constr_expr_1185[2] ;
  char __constr_expr_1186[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___1 ;
  var tmp___2 ;
  void *tmp___3 ;

  {
  f = (struct File *)self;
  if ((unsigned long )f->file != (unsigned long )((void *)0)) {
    File_Close(self);
  }
  tmp = c_str(access);
  tmp___0 = c_str(filename);
  f->file = fopen((char const   * __restrict  )tmp___0, (char const   * __restrict  )tmp);
  if ((unsigned long )f->file == (unsigned long )((void *)0)) {
    __constr_expr_1185[0] = filename;
    __constr_expr_1185[1] = Terminal;
    __constr_expr_1184.items = __constr_expr_1185;
    __constr_expr_1186[0] = (char)0;
    tmp___1 = 1U;
    while (! (tmp___1 >= 32U)) {
      __constr_expr_1186[tmp___1] = (char)0;
      tmp___1 ++;
    }
    tmp___2 = header_init((var )(__constr_expr_1186), Tuple, 2);
    tmp___3 = memcpy((void * __restrict  )((struct Tuple *)tmp___2), (void const   * __restrict  )(& __constr_expr_1184),
                     sizeof(struct Tuple ));
    exception_throw(IOError, "Could not open file: %s", (var )((struct Tuple *)tmp___3));
  }
  return (self);
}
}
static void File_Close(var self ) 
{ 
  struct File *f ;
  int err ;
  int tmp ;
  struct Tuple __constr_expr_1187 ;
  var __constr_expr_1188[2] ;
  struct Int __constr_expr_1189 ;
  char __constr_expr_1190[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;
  char __constr_expr_1191[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;

  {
  f = (struct File *)self;
  tmp = fclose(f->file);
  err = tmp;
  if (err != 0) {
    __constr_expr_1189.val = (int64_t )err;
    __constr_expr_1190[0] = (char)0;
    tmp___0 = 1U;
    while (! (tmp___0 >= 32U)) {
      __constr_expr_1190[tmp___0] = (char)0;
      tmp___0 ++;
    }
    tmp___1 = header_init((var )(__constr_expr_1190), Int, 2);
    tmp___2 = memcpy((void * __restrict  )((struct Int *)tmp___1), (void const   * __restrict  )(& __constr_expr_1189),
                     sizeof(struct Int ));
    __constr_expr_1188[0] = (var )((struct Int *)tmp___2);
    __constr_expr_1188[1] = Terminal;
    __constr_expr_1187.items = __constr_expr_1188;
    __constr_expr_1191[0] = (char)0;
    tmp___3 = 1U;
    while (! (tmp___3 >= 32U)) {
      __constr_expr_1191[tmp___3] = (char)0;
      tmp___3 ++;
    }
    tmp___4 = header_init((var )(__constr_expr_1191), Tuple, 2);
    tmp___5 = memcpy((void * __restrict  )((struct Tuple *)tmp___4), (void const   * __restrict  )(& __constr_expr_1187),
                     sizeof(struct Tuple ));
    exception_throw(IOError, "Failed to close file: %i", (var )((struct Tuple *)tmp___5));
  }
  f->file = (FILE *)((void *)0);
  return;
}
}
static void File_Seek(var self , int64_t pos , int origin ) 
{ 
  struct File *f ;
  struct Tuple __constr_expr_1192 ;
  var __constr_expr_1193[1] ;
  char __constr_expr_1194[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  int err ;
  int tmp___2 ;
  struct Tuple __constr_expr_1195 ;
  var __constr_expr_1196[2] ;
  struct Int __constr_expr_1197 ;
  char __constr_expr_1198[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;
  char __constr_expr_1199[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___6 ;
  var tmp___7 ;
  void *tmp___8 ;

  {
  f = (struct File *)self;
  if ((unsigned long )f->file == (unsigned long )((void *)0)) {
    __constr_expr_1193[0] = Terminal;
    __constr_expr_1192.items = __constr_expr_1193;
    __constr_expr_1194[0] = (char)0;
    tmp = 1U;
    while (! (tmp >= 32U)) {
      __constr_expr_1194[tmp] = (char)0;
      tmp ++;
    }
    tmp___0 = header_init((var )(__constr_expr_1194), Tuple, 2);
    tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_1192),
                     sizeof(struct Tuple ));
    exception_throw(IOError, "Cannot seek file - no file open.", (var )((struct Tuple *)tmp___1));
  }
  tmp___2 = fseek(f->file, pos, origin);
  err = tmp___2;
  if (err != 0) {
    __constr_expr_1197.val = (int64_t )err;
    __constr_expr_1198[0] = (char)0;
    tmp___3 = 1U;
    while (! (tmp___3 >= 32U)) {
      __constr_expr_1198[tmp___3] = (char)0;
      tmp___3 ++;
    }
    tmp___4 = header_init((var )(__constr_expr_1198), Int, 2);
    tmp___5 = memcpy((void * __restrict  )((struct Int *)tmp___4), (void const   * __restrict  )(& __constr_expr_1197),
                     sizeof(struct Int ));
    __constr_expr_1196[0] = (var )((struct Int *)tmp___5);
    __constr_expr_1196[1] = Terminal;
    __constr_expr_1195.items = __constr_expr_1196;
    __constr_expr_1199[0] = (char)0;
    tmp___6 = 1U;
    while (! (tmp___6 >= 32U)) {
      __constr_expr_1199[tmp___6] = (char)0;
      tmp___6 ++;
    }
    tmp___7 = header_init((var )(__constr_expr_1199), Tuple, 2);
    tmp___8 = memcpy((void * __restrict  )((struct Tuple *)tmp___7), (void const   * __restrict  )(& __constr_expr_1195),
                     sizeof(struct Tuple ));
    exception_throw(IOError, "Failed to seek in file: %i", (var )((struct Tuple *)tmp___8));
  }
  return;
}
}
static int64_t File_Tell(var self ) 
{ 
  struct File *f ;
  struct Tuple __constr_expr_1200 ;
  var __constr_expr_1201[1] ;
  char __constr_expr_1202[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  int64_t i ;
  long tmp___2 ;
  struct Tuple __constr_expr_1203 ;
  var __constr_expr_1204[2] ;
  struct Int __constr_expr_1205 ;
  char __constr_expr_1206[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;
  char __constr_expr_1207[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___6 ;
  var tmp___7 ;
  void *tmp___8 ;

  {
  f = (struct File *)self;
  if ((unsigned long )f->file == (unsigned long )((void *)0)) {
    __constr_expr_1201[0] = Terminal;
    __constr_expr_1200.items = __constr_expr_1201;
    __constr_expr_1202[0] = (char)0;
    tmp = 1U;
    while (! (tmp >= 32U)) {
      __constr_expr_1202[tmp] = (char)0;
      tmp ++;
    }
    tmp___0 = header_init((var )(__constr_expr_1202), Tuple, 2);
    tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_1200),
                     sizeof(struct Tuple ));
    exception_throw(IOError, "Cannot tell file - no file open.", (var )((struct Tuple *)tmp___1));
  }
  tmp___2 = ftell(f->file);
  i = tmp___2;
  if (i == -1L) {
    __constr_expr_1205.val = i;
    __constr_expr_1206[0] = (char)0;
    tmp___3 = 1U;
    while (! (tmp___3 >= 32U)) {
      __constr_expr_1206[tmp___3] = (char)0;
      tmp___3 ++;
    }
    tmp___4 = header_init((var )(__constr_expr_1206), Int, 2);
    tmp___5 = memcpy((void * __restrict  )((struct Int *)tmp___4), (void const   * __restrict  )(& __constr_expr_1205),
                     sizeof(struct Int ));
    __constr_expr_1204[0] = (var )((struct Int *)tmp___5);
    __constr_expr_1204[1] = Terminal;
    __constr_expr_1203.items = __constr_expr_1204;
    __constr_expr_1207[0] = (char)0;
    tmp___6 = 1U;
    while (! (tmp___6 >= 32U)) {
      __constr_expr_1207[tmp___6] = (char)0;
      tmp___6 ++;
    }
    tmp___7 = header_init((var )(__constr_expr_1207), Tuple, 2);
    tmp___8 = memcpy((void * __restrict  )((struct Tuple *)tmp___7), (void const   * __restrict  )(& __constr_expr_1203),
                     sizeof(struct Tuple ));
    exception_throw(IOError, "Failed to tell file: %i", (var )((struct Tuple *)tmp___8));
  }
  return (i);
}
}
static void File_Flush(var self ) 
{ 
  struct File *f ;
  struct Tuple __constr_expr_1208 ;
  var __constr_expr_1209[1] ;
  char __constr_expr_1210[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  int err ;
  int tmp___2 ;
  struct Tuple __constr_expr_1211 ;
  var __constr_expr_1212[2] ;
  struct Int __constr_expr_1213 ;
  char __constr_expr_1214[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;
  char __constr_expr_1215[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___6 ;
  var tmp___7 ;
  void *tmp___8 ;

  {
  f = (struct File *)self;
  if ((unsigned long )f->file == (unsigned long )((void *)0)) {
    __constr_expr_1209[0] = Terminal;
    __constr_expr_1208.items = __constr_expr_1209;
    __constr_expr_1210[0] = (char)0;
    tmp = 1U;
    while (! (tmp >= 32U)) {
      __constr_expr_1210[tmp] = (char)0;
      tmp ++;
    }
    tmp___0 = header_init((var )(__constr_expr_1210), Tuple, 2);
    tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_1208),
                     sizeof(struct Tuple ));
    exception_throw(IOError, "Cannot flush file - no file open.", (var )((struct Tuple *)tmp___1));
  }
  tmp___2 = fflush(f->file);
  err = tmp___2;
  if (err != 0) {
    __constr_expr_1213.val = (int64_t )err;
    __constr_expr_1214[0] = (char)0;
    tmp___3 = 1U;
    while (! (tmp___3 >= 32U)) {
      __constr_expr_1214[tmp___3] = (char)0;
      tmp___3 ++;
    }
    tmp___4 = header_init((var )(__constr_expr_1214), Int, 2);
    tmp___5 = memcpy((void * __restrict  )((struct Int *)tmp___4), (void const   * __restrict  )(& __constr_expr_1213),
                     sizeof(struct Int ));
    __constr_expr_1212[0] = (var )((struct Int *)tmp___5);
    __constr_expr_1212[1] = Terminal;
    __constr_expr_1211.items = __constr_expr_1212;
    __constr_expr_1215[0] = (char)0;
    tmp___6 = 1U;
    while (! (tmp___6 >= 32U)) {
      __constr_expr_1215[tmp___6] = (char)0;
      tmp___6 ++;
    }
    tmp___7 = header_init((var )(__constr_expr_1215), Tuple, 2);
    tmp___8 = memcpy((void * __restrict  )((struct Tuple *)tmp___7), (void const   * __restrict  )(& __constr_expr_1211),
                     sizeof(struct Tuple ));
    exception_throw(IOError, "Failed to flush file: %i", (var )((struct Tuple *)tmp___8));
  }
  return;
}
}
static _Bool File_EOF(var self ) 
{ 
  struct File *f ;
  struct Tuple __constr_expr_1216 ;
  var __constr_expr_1217[1] ;
  char __constr_expr_1218[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  f = (struct File *)self;
  if ((unsigned long )f->file == (unsigned long )((void *)0)) {
    __constr_expr_1217[0] = Terminal;
    __constr_expr_1216.items = __constr_expr_1217;
    __constr_expr_1218[0] = (char)0;
    tmp = 1U;
    while (! (tmp >= 32U)) {
      __constr_expr_1218[tmp] = (char)0;
      tmp ++;
    }
    tmp___0 = header_init((var )(__constr_expr_1218), Tuple, 2);
    tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_1216),
                     sizeof(struct Tuple ));
    exception_throw(IOError, "Cannot eof file - no file open.", (var )((struct Tuple *)tmp___1));
  }
  tmp___2 = feof(f->file);
  return ((_Bool )tmp___2);
}
}
static size_t File_Read(var self , void *output , size_t size___0 ) 
{ 
  struct File *f ;
  struct Tuple __constr_expr_1219 ;
  var __constr_expr_1220[1] ;
  char __constr_expr_1221[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  size_t num ;
  size_t tmp___2 ;
  struct Tuple __constr_expr_1222 ;
  var __constr_expr_1223[2] ;
  struct Int __constr_expr_1224 ;
  char __constr_expr_1225[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;
  char __constr_expr_1226[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___6 ;
  var tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;

  {
  f = (struct File *)self;
  if ((unsigned long )f->file == (unsigned long )((void *)0)) {
    __constr_expr_1220[0] = Terminal;
    __constr_expr_1219.items = __constr_expr_1220;
    __constr_expr_1221[0] = (char)0;
    tmp = 1U;
    while (! (tmp >= 32U)) {
      __constr_expr_1221[tmp] = (char)0;
      tmp ++;
    }
    tmp___0 = header_init((var )(__constr_expr_1221), Tuple, 2);
    tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_1219),
                     sizeof(struct Tuple ));
    exception_throw(IOError, "Cannot read file - no file open.", (var )((struct Tuple *)tmp___1));
  }
  tmp___2 = fread((void * __restrict  )output, size___0, (size_t )1, (FILE * __restrict  )f->file);
  num = tmp___2;
  if (num != 1UL) {
    if (size___0 != 0UL) {
      tmp___9 = feof(f->file);
      if (! tmp___9) {
        __constr_expr_1224.val = (int64_t )num;
        __constr_expr_1225[0] = (char)0;
        tmp___3 = 1U;
        while (! (tmp___3 >= 32U)) {
          __constr_expr_1225[tmp___3] = (char)0;
          tmp___3 ++;
        }
        tmp___4 = header_init((var )(__constr_expr_1225), Int, 2);
        tmp___5 = memcpy((void * __restrict  )((struct Int *)tmp___4), (void const   * __restrict  )(& __constr_expr_1224),
                         sizeof(struct Int ));
        __constr_expr_1223[0] = (var )((struct Int *)tmp___5);
        __constr_expr_1223[1] = Terminal;
        __constr_expr_1222.items = __constr_expr_1223;
        __constr_expr_1226[0] = (char)0;
        tmp___6 = 1U;
        while (! (tmp___6 >= 32U)) {
          __constr_expr_1226[tmp___6] = (char)0;
          tmp___6 ++;
        }
        tmp___7 = header_init((var )(__constr_expr_1226), Tuple, 2);
        tmp___8 = memcpy((void * __restrict  )((struct Tuple *)tmp___7), (void const   * __restrict  )(& __constr_expr_1222),
                         sizeof(struct Tuple ));
        exception_throw(IOError, "Failed to read from file: %i", (var )((struct Tuple *)tmp___8));
        return (num);
      }
    }
  }
  return (num);
}
}
static size_t File_Write(var self , void *input , size_t size___0 ) 
{ 
  struct File *f ;
  struct Tuple __constr_expr_1227 ;
  var __constr_expr_1228[1] ;
  char __constr_expr_1229[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  size_t num ;
  size_t tmp___2 ;
  struct Tuple __constr_expr_1230 ;
  var __constr_expr_1231[2] ;
  struct Int __constr_expr_1232 ;
  char __constr_expr_1233[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;
  char __constr_expr_1234[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___6 ;
  var tmp___7 ;
  void *tmp___8 ;

  {
  f = (struct File *)self;
  if ((unsigned long )f->file == (unsigned long )((void *)0)) {
    __constr_expr_1228[0] = Terminal;
    __constr_expr_1227.items = __constr_expr_1228;
    __constr_expr_1229[0] = (char)0;
    tmp = 1U;
    while (! (tmp >= 32U)) {
      __constr_expr_1229[tmp] = (char)0;
      tmp ++;
    }
    tmp___0 = header_init((var )(__constr_expr_1229), Tuple, 2);
    tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_1227),
                     sizeof(struct Tuple ));
    exception_throw(IOError, "Cannot write file - no file open.", (var )((struct Tuple *)tmp___1));
  }
  tmp___2 = fwrite((void const   * __restrict  )input, size___0, (size_t )1, (FILE * __restrict  )f->file);
  num = tmp___2;
  if (num != 1UL) {
    if (size___0 != 0UL) {
      __constr_expr_1232.val = (int64_t )num;
      __constr_expr_1233[0] = (char)0;
      tmp___3 = 1U;
      while (! (tmp___3 >= 32U)) {
        __constr_expr_1233[tmp___3] = (char)0;
        tmp___3 ++;
      }
      tmp___4 = header_init((var )(__constr_expr_1233), Int, 2);
      tmp___5 = memcpy((void * __restrict  )((struct Int *)tmp___4), (void const   * __restrict  )(& __constr_expr_1232),
                       sizeof(struct Int ));
      __constr_expr_1231[0] = (var )((struct Int *)tmp___5);
      __constr_expr_1231[1] = Terminal;
      __constr_expr_1230.items = __constr_expr_1231;
      __constr_expr_1234[0] = (char)0;
      tmp___6 = 1U;
      while (! (tmp___6 >= 32U)) {
        __constr_expr_1234[tmp___6] = (char)0;
        tmp___6 ++;
      }
      tmp___7 = header_init((var )(__constr_expr_1234), Tuple, 2);
      tmp___8 = memcpy((void * __restrict  )((struct Tuple *)tmp___7), (void const   * __restrict  )(& __constr_expr_1230),
                       sizeof(struct Tuple ));
      exception_throw(IOError, "Failed to write to file: %i", (var )((struct Tuple *)tmp___8));
    }
  }
  return (num);
}
}
static int File_Format_To(var self , int pos , char const   *fmt , va_list___0 va ) 
{ 
  struct File *f ;
  struct Tuple __constr_expr_1235 ;
  var __constr_expr_1236[1] ;
  char __constr_expr_1237[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  f = (struct File *)self;
  if ((unsigned long )f->file == (unsigned long )((void *)0)) {
    __constr_expr_1236[0] = Terminal;
    __constr_expr_1235.items = __constr_expr_1236;
    __constr_expr_1237[0] = (char)0;
    tmp = 1U;
    while (! (tmp >= 32U)) {
      __constr_expr_1237[tmp] = (char)0;
      tmp ++;
    }
    tmp___0 = header_init((var )(__constr_expr_1237), Tuple, 2);
    tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_1235),
                     sizeof(struct Tuple ));
    exception_throw(IOError, "Cannot format to file - no file open.", (var )((struct Tuple *)tmp___1));
  }
  tmp___2 = vfprintf((FILE * __restrict  )f->file, (char const   * __restrict  )fmt,
                     va);
  return (tmp___2);
}
}
static int File_Format_From(var self , int pos , char const   *fmt , va_list___0 va ) 
{ 
  struct File *f ;
  struct Tuple __constr_expr_1238 ;
  var __constr_expr_1239[1] ;
  char __constr_expr_1240[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  f = (struct File *)self;
  if ((unsigned long )f->file == (unsigned long )((void *)0)) {
    __constr_expr_1239[0] = Terminal;
    __constr_expr_1238.items = __constr_expr_1239;
    __constr_expr_1240[0] = (char)0;
    tmp = 1U;
    while (! (tmp >= 32U)) {
      __constr_expr_1240[tmp] = (char)0;
      tmp ++;
    }
    tmp___0 = header_init((var )(__constr_expr_1240), Tuple, 2);
    tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_1238),
                     sizeof(struct Tuple ));
    exception_throw(IOError, "Cannot format from file - no file open.", (var )((struct Tuple *)tmp___1));
  }
  tmp___2 = vfscanf((FILE * __restrict  )f->file, (char const   * __restrict  )fmt,
                    va);
  return (tmp___2);
}
}
static struct Doc __constr_expr_1242  =    {& File_Name, & File_Brief, & File_Description, & File_Definition, & File_Examples,
    (struct Method *(*)(void))((void *)0)};
static struct New __constr_expr_1243  =    {& File_New, & File_Del};
static struct Start __constr_expr_1244  =    {(void (*)(var  ))((void *)0), & File_Close, (void (*)(var  ))((void *)0), (_Bool (*)(var  ))0};
static struct Stream __constr_expr_1245  = 
     {& File_Open, & File_Close, & File_Seek, & File_Tell, & File_Flush, & File_EOF,
    & File_Read, & File_Write};
static struct Format __constr_expr_1246  =    {& File_Format_To, & File_Format_From};
static var __constr_expr_1241[45]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"File", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct File ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_1242),      (void *)0,      (var )"New", 
        (var )(& __constr_expr_1243),      (void *)0,      (var )"Start",      (var )(& __constr_expr_1244), 
        (void *)0,      (var )"Stream",      (var )(& __constr_expr_1245),      (void *)0, 
        (var )"Format",      (var )(& __constr_expr_1246),      (void *)0,      (void *)0, 
        (void *)0};
var File  =    (var )((char *)(__constr_expr_1241) + sizeof(struct Header ));
static char const   *Process_Name(void) 
{ 


  {
  return ("Process");
}
}
static char const   *Process_Brief(void) 
{ 


  {
  return ("Operating System Process");
}
}
static char const   *Process_Description(void) 
{ 


  {
  return ("The `Process` type is a wrapper for an operating system process as constructed by the unix-like call `popen`. In this sense it is much like a standard file in the operating system but that instead of writing data to a location you are writing it as input to a process.");
}
}
static char const   *Process_Definition(void) 
{ 


  {
  return ("struct Process {\n  FILE* proc;\n};\n");
}
}
static struct Example *Process_Examples(void) ;
static struct Example examples___50[2]  = {      {"Usage", "var x = new(Process, $S(\"ls\"), $S(\"r\"));\nchar c;\nwhile (not seof(x)) {\n  sread(x, &c, 1);\n  print(\"%c\", $I(c));\n}\nsclose(x);\n"}, 
        {(char const   *)((void *)0),
      (char const   *)((void *)0)}};
static struct Example *Process_Examples(void) 
{ 


  {
  return (examples___50);
}
}
static var Process_Open(var self , var filename , var access ) ;
static void Process_Close(var self ) ;
static void Process_New(var self , var args ) 
{ 
  struct Process *p ;
  struct Int __constr_expr_1247 ;
  char __constr_expr_1248[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  var tmp___2 ;
  struct Int __constr_expr_1249 ;
  char __constr_expr_1250[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;
  var tmp___6 ;

  {
  p = (struct Process *)self;
  p->proc = (FILE *)((void *)0);
  __constr_expr_1247.val = (int64_t )1;
  __constr_expr_1248[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    __constr_expr_1248[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = header_init((var )(__constr_expr_1248), Int, 2);
  tmp___1 = memcpy((void * __restrict  )((struct Int *)tmp___0), (void const   * __restrict  )(& __constr_expr_1247),
                   sizeof(struct Int ));
  tmp___2 = get(args, (var )((struct Int *)tmp___1));
  __constr_expr_1249.val = (int64_t )0;
  __constr_expr_1250[0] = (char)0;
  tmp___3 = 1U;
  while (! (tmp___3 >= 32U)) {
    __constr_expr_1250[tmp___3] = (char)0;
    tmp___3 ++;
  }
  tmp___4 = header_init((var )(__constr_expr_1250), Int, 2);
  tmp___5 = memcpy((void * __restrict  )((struct Int *)tmp___4), (void const   * __restrict  )(& __constr_expr_1249),
                   sizeof(struct Int ));
  tmp___6 = get(args, (var )((struct Int *)tmp___5));
  Process_Open(self, tmp___6, tmp___2);
  return;
}
}
static void Process_Del(var self ) 
{ 
  struct Process *p ;

  {
  p = (struct Process *)self;
  if ((unsigned long )p->proc != (unsigned long )((void *)0)) {
    Process_Close(self);
  }
  return;
}
}
static var Process_Open(var self , var filename , var access ) 
{ 
  struct Process *p ;
  char *tmp ;
  char *tmp___0 ;
  struct Tuple __constr_expr_1251 ;
  var __constr_expr_1252[2] ;
  char __constr_expr_1253[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___1 ;
  var tmp___2 ;
  void *tmp___3 ;

  {
  p = (struct Process *)self;
  if ((unsigned long )p->proc != (unsigned long )((void *)0)) {
    Process_Close(self);
  }
  tmp = c_str(access);
  tmp___0 = c_str(filename);
  p->proc = popen((char const   *)tmp___0, (char const   *)tmp);
  if ((unsigned long )p->proc == (unsigned long )((void *)0)) {
    __constr_expr_1252[0] = filename;
    __constr_expr_1252[1] = Terminal;
    __constr_expr_1251.items = __constr_expr_1252;
    __constr_expr_1253[0] = (char)0;
    tmp___1 = 1U;
    while (! (tmp___1 >= 32U)) {
      __constr_expr_1253[tmp___1] = (char)0;
      tmp___1 ++;
    }
    tmp___2 = header_init((var )(__constr_expr_1253), Tuple, 2);
    tmp___3 = memcpy((void * __restrict  )((struct Tuple *)tmp___2), (void const   * __restrict  )(& __constr_expr_1251),
                     sizeof(struct Tuple ));
    exception_throw(IOError, "Could not open process: %s", (var )((struct Tuple *)tmp___3));
  }
  return (self);
}
}
static void Process_Close(var self ) 
{ 
  struct Process *p ;
  int err ;
  int tmp ;
  struct Tuple __constr_expr_1254 ;
  var __constr_expr_1255[2] ;
  struct Int __constr_expr_1256 ;
  char __constr_expr_1257[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___0 ;
  var tmp___1 ;
  void *tmp___2 ;
  char __constr_expr_1258[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;

  {
  p = (struct Process *)self;
  tmp = pclose(p->proc);
  err = tmp;
  if (err != 0) {
    __constr_expr_1256.val = (int64_t )err;
    __constr_expr_1257[0] = (char)0;
    tmp___0 = 1U;
    while (! (tmp___0 >= 32U)) {
      __constr_expr_1257[tmp___0] = (char)0;
      tmp___0 ++;
    }
    tmp___1 = header_init((var )(__constr_expr_1257), Int, 2);
    tmp___2 = memcpy((void * __restrict  )((struct Int *)tmp___1), (void const   * __restrict  )(& __constr_expr_1256),
                     sizeof(struct Int ));
    __constr_expr_1255[0] = (var )((struct Int *)tmp___2);
    __constr_expr_1255[1] = Terminal;
    __constr_expr_1254.items = __constr_expr_1255;
    __constr_expr_1258[0] = (char)0;
    tmp___3 = 1U;
    while (! (tmp___3 >= 32U)) {
      __constr_expr_1258[tmp___3] = (char)0;
      tmp___3 ++;
    }
    tmp___4 = header_init((var )(__constr_expr_1258), Tuple, 2);
    tmp___5 = memcpy((void * __restrict  )((struct Tuple *)tmp___4), (void const   * __restrict  )(& __constr_expr_1254),
                     sizeof(struct Tuple ));
    exception_throw(IOError, "Failed to close process: %i", (var )((struct Tuple *)tmp___5));
  }
  p->proc = (FILE *)((void *)0);
  return;
}
}
static void Process_Seek(var self , int64_t pos , int origin ) 
{ 
  struct Process *p ;
  struct Tuple __constr_expr_1259 ;
  var __constr_expr_1260[1] ;
  char __constr_expr_1261[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  int err ;
  int tmp___2 ;
  struct Tuple __constr_expr_1262 ;
  var __constr_expr_1263[2] ;
  struct Int __constr_expr_1264 ;
  char __constr_expr_1265[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;
  char __constr_expr_1266[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___6 ;
  var tmp___7 ;
  void *tmp___8 ;

  {
  p = (struct Process *)self;
  if ((unsigned long )p->proc == (unsigned long )((void *)0)) {
    __constr_expr_1260[0] = Terminal;
    __constr_expr_1259.items = __constr_expr_1260;
    __constr_expr_1261[0] = (char)0;
    tmp = 1U;
    while (! (tmp >= 32U)) {
      __constr_expr_1261[tmp] = (char)0;
      tmp ++;
    }
    tmp___0 = header_init((var )(__constr_expr_1261), Tuple, 2);
    tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_1259),
                     sizeof(struct Tuple ));
    exception_throw(IOError, "Cannot seek process - no process open.", (var )((struct Tuple *)tmp___1));
  }
  tmp___2 = fseek(p->proc, pos, origin);
  err = tmp___2;
  if (err != 0) {
    __constr_expr_1264.val = (int64_t )err;
    __constr_expr_1265[0] = (char)0;
    tmp___3 = 1U;
    while (! (tmp___3 >= 32U)) {
      __constr_expr_1265[tmp___3] = (char)0;
      tmp___3 ++;
    }
    tmp___4 = header_init((var )(__constr_expr_1265), Int, 2);
    tmp___5 = memcpy((void * __restrict  )((struct Int *)tmp___4), (void const   * __restrict  )(& __constr_expr_1264),
                     sizeof(struct Int ));
    __constr_expr_1263[0] = (var )((struct Int *)tmp___5);
    __constr_expr_1263[1] = Terminal;
    __constr_expr_1262.items = __constr_expr_1263;
    __constr_expr_1266[0] = (char)0;
    tmp___6 = 1U;
    while (! (tmp___6 >= 32U)) {
      __constr_expr_1266[tmp___6] = (char)0;
      tmp___6 ++;
    }
    tmp___7 = header_init((var )(__constr_expr_1266), Tuple, 2);
    tmp___8 = memcpy((void * __restrict  )((struct Tuple *)tmp___7), (void const   * __restrict  )(& __constr_expr_1262),
                     sizeof(struct Tuple ));
    exception_throw(IOError, "Failed to seek in process: %i", (var )((struct Tuple *)tmp___8));
  }
  return;
}
}
static int64_t Process_Tell(var self ) 
{ 
  struct Process *p ;
  struct Tuple __constr_expr_1267 ;
  var __constr_expr_1268[1] ;
  char __constr_expr_1269[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  int64_t i ;
  long tmp___2 ;
  struct Tuple __constr_expr_1270 ;
  var __constr_expr_1271[2] ;
  struct Int __constr_expr_1272 ;
  char __constr_expr_1273[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;
  char __constr_expr_1274[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___6 ;
  var tmp___7 ;
  void *tmp___8 ;

  {
  p = (struct Process *)self;
  if ((unsigned long )p->proc == (unsigned long )((void *)0)) {
    __constr_expr_1268[0] = Terminal;
    __constr_expr_1267.items = __constr_expr_1268;
    __constr_expr_1269[0] = (char)0;
    tmp = 1U;
    while (! (tmp >= 32U)) {
      __constr_expr_1269[tmp] = (char)0;
      tmp ++;
    }
    tmp___0 = header_init((var )(__constr_expr_1269), Tuple, 2);
    tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_1267),
                     sizeof(struct Tuple ));
    exception_throw(IOError, "Cannot tell process - no process open.", (var )((struct Tuple *)tmp___1));
  }
  tmp___2 = ftell(p->proc);
  i = tmp___2;
  if (i == -1L) {
    __constr_expr_1272.val = i;
    __constr_expr_1273[0] = (char)0;
    tmp___3 = 1U;
    while (! (tmp___3 >= 32U)) {
      __constr_expr_1273[tmp___3] = (char)0;
      tmp___3 ++;
    }
    tmp___4 = header_init((var )(__constr_expr_1273), Int, 2);
    tmp___5 = memcpy((void * __restrict  )((struct Int *)tmp___4), (void const   * __restrict  )(& __constr_expr_1272),
                     sizeof(struct Int ));
    __constr_expr_1271[0] = (var )((struct Int *)tmp___5);
    __constr_expr_1271[1] = Terminal;
    __constr_expr_1270.items = __constr_expr_1271;
    __constr_expr_1274[0] = (char)0;
    tmp___6 = 1U;
    while (! (tmp___6 >= 32U)) {
      __constr_expr_1274[tmp___6] = (char)0;
      tmp___6 ++;
    }
    tmp___7 = header_init((var )(__constr_expr_1274), Tuple, 2);
    tmp___8 = memcpy((void * __restrict  )((struct Tuple *)tmp___7), (void const   * __restrict  )(& __constr_expr_1270),
                     sizeof(struct Tuple ));
    exception_throw(IOError, "Failed to tell process: %i", (var )((struct Tuple *)tmp___8));
  }
  return (i);
}
}
static void Process_Flush(var self ) 
{ 
  struct Process *p ;
  struct Tuple __constr_expr_1275 ;
  var __constr_expr_1276[1] ;
  char __constr_expr_1277[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  int err ;
  int tmp___2 ;
  struct Tuple __constr_expr_1278 ;
  var __constr_expr_1279[2] ;
  struct Int __constr_expr_1280 ;
  char __constr_expr_1281[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;
  char __constr_expr_1282[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___6 ;
  var tmp___7 ;
  void *tmp___8 ;

  {
  p = (struct Process *)self;
  if ((unsigned long )p->proc == (unsigned long )((void *)0)) {
    __constr_expr_1276[0] = Terminal;
    __constr_expr_1275.items = __constr_expr_1276;
    __constr_expr_1277[0] = (char)0;
    tmp = 1U;
    while (! (tmp >= 32U)) {
      __constr_expr_1277[tmp] = (char)0;
      tmp ++;
    }
    tmp___0 = header_init((var )(__constr_expr_1277), Tuple, 2);
    tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_1275),
                     sizeof(struct Tuple ));
    exception_throw(IOError, "Cannot flush process - no process open.", (var )((struct Tuple *)tmp___1));
  }
  tmp___2 = fflush(p->proc);
  err = tmp___2;
  if (err != 0) {
    __constr_expr_1280.val = (int64_t )err;
    __constr_expr_1281[0] = (char)0;
    tmp___3 = 1U;
    while (! (tmp___3 >= 32U)) {
      __constr_expr_1281[tmp___3] = (char)0;
      tmp___3 ++;
    }
    tmp___4 = header_init((var )(__constr_expr_1281), Int, 2);
    tmp___5 = memcpy((void * __restrict  )((struct Int *)tmp___4), (void const   * __restrict  )(& __constr_expr_1280),
                     sizeof(struct Int ));
    __constr_expr_1279[0] = (var )((struct Int *)tmp___5);
    __constr_expr_1279[1] = Terminal;
    __constr_expr_1278.items = __constr_expr_1279;
    __constr_expr_1282[0] = (char)0;
    tmp___6 = 1U;
    while (! (tmp___6 >= 32U)) {
      __constr_expr_1282[tmp___6] = (char)0;
      tmp___6 ++;
    }
    tmp___7 = header_init((var )(__constr_expr_1282), Tuple, 2);
    tmp___8 = memcpy((void * __restrict  )((struct Tuple *)tmp___7), (void const   * __restrict  )(& __constr_expr_1278),
                     sizeof(struct Tuple ));
    exception_throw(IOError, "Failed to flush process: %i", (var )((struct Tuple *)tmp___8));
  }
  return;
}
}
static _Bool Process_EOF(var self ) 
{ 
  struct Process *p ;
  struct Tuple __constr_expr_1283 ;
  var __constr_expr_1284[1] ;
  char __constr_expr_1285[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  p = (struct Process *)self;
  if ((unsigned long )p->proc == (unsigned long )((void *)0)) {
    __constr_expr_1284[0] = Terminal;
    __constr_expr_1283.items = __constr_expr_1284;
    __constr_expr_1285[0] = (char)0;
    tmp = 1U;
    while (! (tmp >= 32U)) {
      __constr_expr_1285[tmp] = (char)0;
      tmp ++;
    }
    tmp___0 = header_init((var )(__constr_expr_1285), Tuple, 2);
    tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_1283),
                     sizeof(struct Tuple ));
    exception_throw(IOError, "Cannot eof process - no process open.", (var )((struct Tuple *)tmp___1));
  }
  tmp___2 = feof(p->proc);
  return ((_Bool )tmp___2);
}
}
static size_t Process_Read(var self , void *output , size_t size___0 ) 
{ 
  struct Process *p ;
  struct Tuple __constr_expr_1286 ;
  var __constr_expr_1287[1] ;
  char __constr_expr_1288[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  size_t num ;
  size_t tmp___2 ;
  struct Tuple __constr_expr_1289 ;
  var __constr_expr_1290[2] ;
  struct Int __constr_expr_1291 ;
  char __constr_expr_1292[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;
  char __constr_expr_1293[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___6 ;
  var tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;

  {
  p = (struct Process *)self;
  if ((unsigned long )p->proc == (unsigned long )((void *)0)) {
    __constr_expr_1287[0] = Terminal;
    __constr_expr_1286.items = __constr_expr_1287;
    __constr_expr_1288[0] = (char)0;
    tmp = 1U;
    while (! (tmp >= 32U)) {
      __constr_expr_1288[tmp] = (char)0;
      tmp ++;
    }
    tmp___0 = header_init((var )(__constr_expr_1288), Tuple, 2);
    tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_1286),
                     sizeof(struct Tuple ));
    exception_throw(IOError, "Cannot read process - no process open.", (var )((struct Tuple *)tmp___1));
  }
  tmp___2 = fread((void * __restrict  )output, size___0, (size_t )1, (FILE * __restrict  )p->proc);
  num = tmp___2;
  if (num != 1UL) {
    if (size___0 != 0UL) {
      tmp___9 = feof(p->proc);
      if (! tmp___9) {
        __constr_expr_1291.val = (int64_t )num;
        __constr_expr_1292[0] = (char)0;
        tmp___3 = 1U;
        while (! (tmp___3 >= 32U)) {
          __constr_expr_1292[tmp___3] = (char)0;
          tmp___3 ++;
        }
        tmp___4 = header_init((var )(__constr_expr_1292), Int, 2);
        tmp___5 = memcpy((void * __restrict  )((struct Int *)tmp___4), (void const   * __restrict  )(& __constr_expr_1291),
                         sizeof(struct Int ));
        __constr_expr_1290[0] = (var )((struct Int *)tmp___5);
        __constr_expr_1290[1] = Terminal;
        __constr_expr_1289.items = __constr_expr_1290;
        __constr_expr_1293[0] = (char)0;
        tmp___6 = 1U;
        while (! (tmp___6 >= 32U)) {
          __constr_expr_1293[tmp___6] = (char)0;
          tmp___6 ++;
        }
        tmp___7 = header_init((var )(__constr_expr_1293), Tuple, 2);
        tmp___8 = memcpy((void * __restrict  )((struct Tuple *)tmp___7), (void const   * __restrict  )(& __constr_expr_1289),
                         sizeof(struct Tuple ));
        exception_throw(IOError, "Failed to read from process: %i", (var )((struct Tuple *)tmp___8));
        return (num);
      }
    }
  }
  return (num);
}
}
static size_t Process_Write(var self , void *input , size_t size___0 ) 
{ 
  struct Process *p ;
  struct Tuple __constr_expr_1294 ;
  var __constr_expr_1295[1] ;
  char __constr_expr_1296[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  size_t num ;
  size_t tmp___2 ;
  struct Tuple __constr_expr_1297 ;
  var __constr_expr_1298[2] ;
  struct Int __constr_expr_1299 ;
  char __constr_expr_1300[sizeof(struct Header ) + sizeof(struct Int )] ;
  unsigned int tmp___3 ;
  var tmp___4 ;
  void *tmp___5 ;
  char __constr_expr_1301[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp___6 ;
  var tmp___7 ;
  void *tmp___8 ;

  {
  p = (struct Process *)self;
  if ((unsigned long )p->proc == (unsigned long )((void *)0)) {
    __constr_expr_1295[0] = Terminal;
    __constr_expr_1294.items = __constr_expr_1295;
    __constr_expr_1296[0] = (char)0;
    tmp = 1U;
    while (! (tmp >= 32U)) {
      __constr_expr_1296[tmp] = (char)0;
      tmp ++;
    }
    tmp___0 = header_init((var )(__constr_expr_1296), Tuple, 2);
    tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_1294),
                     sizeof(struct Tuple ));
    exception_throw(IOError, "Cannot write process - no process open.", (var )((struct Tuple *)tmp___1));
  }
  tmp___2 = fwrite((void const   * __restrict  )input, size___0, (size_t )1, (FILE * __restrict  )p->proc);
  num = tmp___2;
  if (num != 1UL) {
    if (size___0 != 0UL) {
      __constr_expr_1299.val = (int64_t )num;
      __constr_expr_1300[0] = (char)0;
      tmp___3 = 1U;
      while (! (tmp___3 >= 32U)) {
        __constr_expr_1300[tmp___3] = (char)0;
        tmp___3 ++;
      }
      tmp___4 = header_init((var )(__constr_expr_1300), Int, 2);
      tmp___5 = memcpy((void * __restrict  )((struct Int *)tmp___4), (void const   * __restrict  )(& __constr_expr_1299),
                       sizeof(struct Int ));
      __constr_expr_1298[0] = (var )((struct Int *)tmp___5);
      __constr_expr_1298[1] = Terminal;
      __constr_expr_1297.items = __constr_expr_1298;
      __constr_expr_1301[0] = (char)0;
      tmp___6 = 1U;
      while (! (tmp___6 >= 32U)) {
        __constr_expr_1301[tmp___6] = (char)0;
        tmp___6 ++;
      }
      tmp___7 = header_init((var )(__constr_expr_1301), Tuple, 2);
      tmp___8 = memcpy((void * __restrict  )((struct Tuple *)tmp___7), (void const   * __restrict  )(& __constr_expr_1297),
                       sizeof(struct Tuple ));
      exception_throw(IOError, "Failed to write to process: %i", (var )((struct Tuple *)tmp___8));
    }
  }
  return (num);
}
}
static int Process_Format_To(var self , int pos , char const   *fmt , va_list___0 va ) 
{ 
  struct Process *p ;
  struct Tuple __constr_expr_1302 ;
  var __constr_expr_1303[1] ;
  char __constr_expr_1304[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  p = (struct Process *)self;
  if ((unsigned long )p->proc == (unsigned long )((void *)0)) {
    __constr_expr_1303[0] = Terminal;
    __constr_expr_1302.items = __constr_expr_1303;
    __constr_expr_1304[0] = (char)0;
    tmp = 1U;
    while (! (tmp >= 32U)) {
      __constr_expr_1304[tmp] = (char)0;
      tmp ++;
    }
    tmp___0 = header_init((var )(__constr_expr_1304), Tuple, 2);
    tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_1302),
                     sizeof(struct Tuple ));
    exception_throw(IOError, "Cannot format to process - no process open.", (var )((struct Tuple *)tmp___1));
  }
  tmp___2 = vfprintf((FILE * __restrict  )p->proc, (char const   * __restrict  )fmt,
                     va);
  return (tmp___2);
}
}
static int Process_Format_From(var self , int pos , char const   *fmt , va_list___0 va ) 
{ 
  struct Process *p ;
  struct Tuple __constr_expr_1305 ;
  var __constr_expr_1306[1] ;
  char __constr_expr_1307[sizeof(struct Header ) + sizeof(struct Tuple )] ;
  unsigned int tmp ;
  var tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  p = (struct Process *)self;
  if ((unsigned long )p->proc == (unsigned long )((void *)0)) {
    __constr_expr_1306[0] = Terminal;
    __constr_expr_1305.items = __constr_expr_1306;
    __constr_expr_1307[0] = (char)0;
    tmp = 1U;
    while (! (tmp >= 32U)) {
      __constr_expr_1307[tmp] = (char)0;
      tmp ++;
    }
    tmp___0 = header_init((var )(__constr_expr_1307), Tuple, 2);
    tmp___1 = memcpy((void * __restrict  )((struct Tuple *)tmp___0), (void const   * __restrict  )(& __constr_expr_1305),
                     sizeof(struct Tuple ));
    exception_throw(IOError, "Cannot format from process - no process open.", (var )((struct Tuple *)tmp___1));
  }
  tmp___2 = vfscanf((FILE * __restrict  )p->proc, (char const   * __restrict  )fmt,
                    va);
  return (tmp___2);
}
}
static struct Doc __constr_expr_1309  =    {& Process_Name, & Process_Brief, & Process_Description, & Process_Definition,
    & Process_Examples, (struct Method *(*)(void))((void *)0)};
static struct New __constr_expr_1310  =    {& Process_New, & Process_Del};
static struct Start __constr_expr_1311  =    {(void (*)(var  ))((void *)0), & Process_Close, (void (*)(var  ))((void *)0), (_Bool (*)(var  ))0};
static struct Stream __constr_expr_1312  = 
     {& Process_Open, & Process_Close, & Process_Seek, & Process_Tell, & Process_Flush,
    & Process_EOF, & Process_Read, & Process_Write};
static struct Format __constr_expr_1313  =    {& Process_Format_To, & Process_Format_From};
static var __constr_expr_1308[45]  = 
  {      (void *)0,      (var )1,      (var )844048,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (void *)0,      (void *)0, 
        (void *)0,      (void *)0,      (var )"__Name",      (var )"Process", 
        (void *)0,      (var )"__Size",      (var )sizeof(struct Process ),      (void *)0, 
        (var )"Doc",      (var )(& __constr_expr_1309),      (void *)0,      (var )"New", 
        (var )(& __constr_expr_1310),      (void *)0,      (var )"Start",      (var )(& __constr_expr_1311), 
        (void *)0,      (var )"Stream",      (var )(& __constr_expr_1312),      (void *)0, 
        (var )"Format",      (var )(& __constr_expr_1313),      (void *)0,      (void *)0, 
        (void *)0};
var Process  =    (var )((char *)(__constr_expr_1308) + sizeof(struct Header ));
