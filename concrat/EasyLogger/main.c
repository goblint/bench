/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef unsigned short __uint16_t;
typedef __int8_t int8_t;
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef unsigned long size_t;
struct __anonstruct_ElogTagLvlFilter_993067413 {
   uint8_t level ;
   char tag[17] ;
   _Bool tag_use_flag ;
};
typedef struct __anonstruct_ElogTagLvlFilter_993067413 ElogTagLvlFilter;
struct __anonstruct_ElogFilter_816931338 {
   uint8_t level ;
   char tag[17] ;
   char keyword[17] ;
   ElogTagLvlFilter tag_lvl[5] ;
};
typedef struct __anonstruct_ElogFilter_816931338 ElogFilter;
struct __anonstruct_EasyLogger_153854292 {
   ElogFilter filter ;
   size_t enabled_fmt_set[6] ;
   _Bool init_ok ;
   _Bool output_enabled ;
   _Bool output_lock_enabled ;
   _Bool output_is_locked_before_enable ;
   _Bool output_is_locked_before_disable ;
   _Bool text_color_enabled ;
};
typedef struct __anonstruct_EasyLogger_153854292 EasyLogger;
enum __anonenum_ElogErrCode_773224215 {
    ELOG_NO_ERR = 0
} ;
typedef enum __anonenum_ElogErrCode_773224215 ElogErrCode;
typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list___0;
struct sched_param {
   int sched_priority ;
};
typedef unsigned long pthread_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
union __anonunion_sem_t_998661167 {
   char __size[32] ;
   long __align ;
};
typedef union __anonunion_sem_t_998661167 sem_t;
typedef long __off_t;
typedef long __off64_t;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
struct __anonstruct_ElogFileCfg_211102680 {
   char *name ;
   size_t max_size ;
   int max_rotate ;
};
typedef struct __anonstruct_ElogFileCfg_211102680 ElogFileCfg;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned int __mode_t;
typedef long __time_t;
typedef unsigned int __useconds_t;
typedef int __key_t;
typedef unsigned long __syscall_ulong_t;
typedef __key_t key_t;
struct ipc_perm {
   __key_t __key ;
   __uid_t uid ;
   __gid_t gid ;
   __uid_t cuid ;
   __gid_t cgid ;
   __mode_t mode ;
   unsigned short __seq ;
   unsigned short __pad2 ;
   __syscall_ulong_t __glibc_reserved1 ;
   __syscall_ulong_t __glibc_reserved2 ;
};
struct semid_ds {
   struct ipc_perm sem_perm ;
   __time_t sem_otime ;
   __syscall_ulong_t __glibc_reserved1 ;
   __time_t sem_ctime ;
   __syscall_ulong_t __glibc_reserved2 ;
   __syscall_ulong_t sem_nsems ;
   __syscall_ulong_t __glibc_reserved3 ;
   __syscall_ulong_t __glibc_reserved4 ;
};
struct seminfo {
   int semmap ;
   int semmni ;
   int semmns ;
   int semmnu ;
   int semmsl ;
   int semopm ;
   int semume ;
   int semusz ;
   int semvmx ;
   int semaem ;
};
struct sembuf {
   unsigned short sem_num ;
   short sem_op ;
   short sem_flg ;
};
union semun {
   int val ;
   struct semid_ds *buf ;
   unsigned short *array ;
   struct seminfo *__buf ;
};
typedef int __pid_t;
typedef __time_t time_t;
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#pragma merger("0","/tmp/cil-UT7BAXVt.i","-O0,-g3,-Wall")
ElogErrCode elog_init(void) ;
void elog_deinit(void) ;
void elog_start(void) ;
void elog_stop(void) ;
void elog_set_output_enabled(_Bool enabled ) ;
_Bool elog_get_output_enabled(void) ;
void elog_set_text_color_enabled(_Bool enabled ) ;
_Bool elog_get_text_color_enabled(void) ;
void elog_set_fmt(uint8_t level , size_t set ) ;
void elog_set_filter(uint8_t level , char const   *tag , char const   *keyword ) ;
void elog_set_filter_lvl(uint8_t level ) ;
void elog_set_filter_tag(char const   *tag ) ;
void elog_set_filter_kw(char const   *keyword ) ;
void elog_set_filter_tag_lvl(char const   *tag , uint8_t level ) ;
uint8_t elog_get_filter_tag_lvl(char const   *tag ) ;
void elog_raw(char const   *format  , ...) ;
void elog_output(uint8_t level , char const   *tag , char const   *file , char const   *func ,
                 long const   line , char const   *format  , ...) ;
void elog_output_lock_enabled(_Bool enabled ) ;
void (*elog_assert_hook)(char const   *expr , char const   *func , size_t line )  ;
void elog_assert_set_hook(void (*hook)(char const   *expr , char const   *func , size_t line ) ) ;
int8_t elog_find_lvl(char const   *log ) ;
char const   *elog_find_tag(char const   *log , uint8_t lvl , size_t *tag_len ) ;
void elog_hexdump(char const   *name , uint8_t width , void const   *buf , uint16_t size ) ;
void elog_async_enabled(_Bool enabled ) ;
size_t elog_strcpy(size_t cur_len , char *dst , char const   *src ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memchr)(void const   *__s ,
                                                                                     int __c ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
static EasyLogger elog  ;
static char log_buf[512]  = {      (char)0};
static char const   *level_output_info[6]  = {      "A/",      "E/",      "W/",      "I/", 
        "D/",      "V/"};
static char const   *color_output_info[6]  = {      "35;22m",      "31;22m",      "33;22m",      "36;22m", 
        "32;22m",      "34;22m"};
static _Bool get_fmt_enabled(uint8_t level , size_t set ) ;
static void elog_set_filter_tag_lvl_default(void) ;
void elog_port_output_lock(void) ;
void elog_port_output_unlock(void) ;
ElogErrCode elog_port_init(void) ;
ElogErrCode elog_async_init(void) ;
ElogErrCode elog_init(void) 
{ 
  ElogErrCode result ;

  {
  result = (ElogErrCode )0;
  if ((int )elog.init_ok == 1) {
    return (result);
  }
  result = elog_port_init();
  if ((unsigned int )result != 0U) {
    return (result);
  }
  result = elog_async_init();
  if ((unsigned int )result != 0U) {
    return (result);
  }
  elog_output_lock_enabled((_Bool)1);
  elog.output_is_locked_before_enable = (_Bool)0;
  elog.output_is_locked_before_disable = (_Bool)0;
  elog_set_text_color_enabled((_Bool)0);
  elog_set_filter_lvl((uint8_t )5);
  elog_set_filter_tag_lvl_default();
  elog.init_ok = (_Bool)1;
  return (result);
}
}
void elog_port_deinit(void) ;
void elog_async_deinit(void) ;
void elog_deinit(void) 
{ 


  {
  if (! elog.init_ok) {
    return;
  }
  elog_async_deinit();
  elog_port_deinit();
  elog.init_ok = (_Bool)0;
  return;
}
}
void elog_start(void) 
{ 


  {
  if (! elog.init_ok) {
    return;
  }
  elog_set_output_enabled((_Bool)1);
  elog_async_enabled((_Bool)1);
  elog_output((uint8_t )3, "elog", "../../../easylogger/src/elog.c", "elog_start",
              (long const   )244, "EasyLogger V%s is initialize success.", "2.2.99");
  return;
}
}
void elog_stop(void) 
{ 


  {
  if (! elog.init_ok) {
    return;
  }
  elog_set_output_enabled((_Bool)0);
  elog_async_enabled((_Bool)0);
  elog_output((uint8_t )3, "elog", "../../../easylogger/src/elog.c", "elog_stop",
              (long const   )265, "EasyLogger V%s is deinitialize success.", "2.2.99");
  return;
}
}
void elog_set_output_enabled(_Bool enabled ) 
{ 


  {
  if (! ((int )enabled == 0)) {
    if (! ((int )enabled == 1)) {
      if ((unsigned long )elog_assert_hook == (unsigned long )((void *)0)) {
        elog_output((uint8_t )0, "elog", "../../../easylogger/src/elog.c", "elog_set_output_enabled",
                    (long const   )275, "(%s) has assert failed at %s:%ld.", "(enabled == false) || (enabled == true)",
                    "elog_set_output_enabled", 275);
        while (1) {

        }
      } else {
        (*elog_assert_hook)("(enabled == false) || (enabled == true)", "elog_set_output_enabled",
                            (size_t )275);
      }
    }
  }
  elog.output_enabled = enabled;
  return;
}
}
void elog_set_text_color_enabled(_Bool enabled ) 
{ 


  {
  elog.text_color_enabled = enabled;
  return;
}
}
_Bool elog_get_text_color_enabled(void) 
{ 


  {
  return (elog.text_color_enabled);
}
}
_Bool elog_get_output_enabled(void) 
{ 


  {
  return (elog.output_enabled);
}
}
void elog_set_fmt(uint8_t level , size_t set ) 
{ 


  {
  if (! ((int )level <= 5)) {
    if ((unsigned long )elog_assert_hook == (unsigned long )((void *)0)) {
      elog_output((uint8_t )0, "elog", "../../../easylogger/src/elog.c", "elog_set_fmt",
                  (long const   )316, "(%s) has assert failed at %s:%ld.", "level <= ELOG_LVL_VERBOSE",
                  "elog_set_fmt", 316);
      while (1) {

      }
    } else {
      (*elog_assert_hook)("level <= ELOG_LVL_VERBOSE", "elog_set_fmt", (size_t )316);
    }
  }
  elog.enabled_fmt_set[level] = set;
  return;
}
}
void elog_set_filter(uint8_t level , char const   *tag , char const   *keyword ) 
{ 


  {
  if (! ((int )level <= 5)) {
    if ((unsigned long )elog_assert_hook == (unsigned long )((void *)0)) {
      elog_output((uint8_t )0, "elog", "../../../easylogger/src/elog.c", "elog_set_filter",
                  (long const   )329, "(%s) has assert failed at %s:%ld.", "level <= ELOG_LVL_VERBOSE",
                  "elog_set_filter", 329);
      while (1) {

      }
    } else {
      (*elog_assert_hook)("level <= ELOG_LVL_VERBOSE", "elog_set_filter", (size_t )329);
    }
  }
  elog_set_filter_lvl(level);
  elog_set_filter_tag(tag);
  elog_set_filter_kw(keyword);
  return;
}
}
void elog_set_filter_lvl(uint8_t level ) 
{ 


  {
  if (! ((int )level <= 5)) {
    if ((unsigned long )elog_assert_hook == (unsigned long )((void *)0)) {
      elog_output((uint8_t )0, "elog", "../../../easylogger/src/elog.c", "elog_set_filter_lvl",
                  (long const   )342, "(%s) has assert failed at %s:%ld.", "level <= ELOG_LVL_VERBOSE",
                  "elog_set_filter_lvl", 342);
      while (1) {

      }
    } else {
      (*elog_assert_hook)("level <= ELOG_LVL_VERBOSE", "elog_set_filter_lvl", (size_t )342);
    }
  }
  elog.filter.level = level;
  return;
}
}
void elog_set_filter_tag(char const   *tag ) 
{ 


  {
  strncpy((char * __restrict  )(elog.filter.tag), (char const   * __restrict  )tag,
          (size_t )16);
  return;
}
}
void elog_set_filter_kw(char const   *keyword ) 
{ 


  {
  strncpy((char * __restrict  )(elog.filter.keyword), (char const   * __restrict  )keyword,
          (size_t )16);
  return;
}
}
void elog_output_lock(void) 
{ 


  {
  if (elog.output_lock_enabled) {
    elog_port_output_lock();
    elog.output_is_locked_before_disable = (_Bool)1;
  } else {
    elog.output_is_locked_before_enable = (_Bool)1;
  }
  return;
}
}
void elog_output_unlock(void) 
{ 


  {
  if (elog.output_lock_enabled) {
    elog_port_output_unlock();
    elog.output_is_locked_before_disable = (_Bool)0;
  } else {
    elog.output_is_locked_before_enable = (_Bool)0;
  }
  return;
}
}
static void elog_set_filter_tag_lvl_default(void) 
{ 
  uint8_t i ;

  {
  i = (uint8_t )0;
  i = (uint8_t )0;
  while ((int )i < 5) {
    memset((void *)(elog.filter.tag_lvl[i].tag), '\000', (size_t )17);
    elog.filter.tag_lvl[i].level = (uint8_t )0;
    elog.filter.tag_lvl[i].tag_use_flag = (_Bool)0;
    i = (uint8_t )((int )i + 1);
  }
  return;
}
}
void elog_set_filter_tag_lvl(char const   *tag , uint8_t level ) 
{ 
  uint8_t i ;
  int tmp ;

  {
  if (! ((int )level <= 5)) {
    if ((unsigned long )elog_assert_hook == (unsigned long )((void *)0)) {
      elog_output((uint8_t )0, "elog", "../../../easylogger/src/elog.c", "elog_set_filter_tag_lvl",
                  (long const   )423, "(%s) has assert failed at %s:%ld.", "level <= ELOG_LVL_VERBOSE",
                  "elog_set_filter_tag_lvl", 423);
      while (1) {

      }
    } else {
      (*elog_assert_hook)("level <= ELOG_LVL_VERBOSE", "elog_set_filter_tag_lvl",
                          (size_t )423);
    }
  }
  if (! ((unsigned long )tag != (unsigned long )((void *)0))) {
    if ((unsigned long )elog_assert_hook == (unsigned long )((void *)0)) {
      elog_output((uint8_t )0, "elog", "../../../easylogger/src/elog.c", "elog_set_filter_tag_lvl",
                  (long const   )424, "(%s) has assert failed at %s:%ld.", "tag != ((void *)0)",
                  "elog_set_filter_tag_lvl", 424);
      while (1) {

      }
    } else {
      (*elog_assert_hook)("tag != ((void *)0)", "elog_set_filter_tag_lvl", (size_t )424);
    }
  }
  i = (uint8_t )0;
  if (! elog.init_ok) {
    return;
  }
  elog_output_lock();
  i = (uint8_t )0;
  while ((int )i < 5) {
    if ((int )elog.filter.tag_lvl[i].tag_use_flag == 1) {
      tmp = strncmp(tag, (char const   *)(elog.filter.tag_lvl[i].tag), (size_t )16);
      if (! tmp) {
        break;
      }
    }
    i = (uint8_t )((int )i + 1);
  }
  if ((int )i < 5) {
    if ((int )level == 5) {
      elog.filter.tag_lvl[i].tag_use_flag = (_Bool)0;
      memset((void *)(elog.filter.tag_lvl[i].tag), '\000', (size_t )17);
      elog.filter.tag_lvl[i].level = (uint8_t )0;
    } else {
      elog.filter.tag_lvl[i].level = level;
    }
  } else
  if ((int )level != 5) {
    i = (uint8_t )0;
    while ((int )i < 5) {
      if ((int )elog.filter.tag_lvl[i].tag_use_flag == 0) {
        strncpy((char * __restrict  )(elog.filter.tag_lvl[i].tag), (char const   * __restrict  )tag,
                (size_t )16);
        elog.filter.tag_lvl[i].level = level;
        elog.filter.tag_lvl[i].tag_use_flag = (_Bool)1;
        break;
      }
      i = (uint8_t )((int )i + 1);
    }
  }
  elog_output_unlock();
  return;
}
}
uint8_t elog_get_filter_tag_lvl(char const   *tag ) 
{ 
  uint8_t i ;
  uint8_t level ;
  int tmp ;

  {
  if (! ((unsigned long )tag != (unsigned long )((void *)0))) {
    if ((unsigned long )elog_assert_hook == (unsigned long )((void *)0)) {
      elog_output((uint8_t )0, "elog", "../../../easylogger/src/elog.c", "elog_get_filter_tag_lvl",
                  (long const   )476, "(%s) has assert failed at %s:%ld.", "tag != ((void *)0)",
                  "elog_get_filter_tag_lvl", 476);
      while (1) {

      }
    } else {
      (*elog_assert_hook)("tag != ((void *)0)", "elog_get_filter_tag_lvl", (size_t )476);
    }
  }
  i = (uint8_t )0;
  level = (uint8_t )5;
  if (! elog.init_ok) {
    return (level);
  }
  elog_output_lock();
  i = (uint8_t )0;
  while ((int )i < 5) {
    if ((int )elog.filter.tag_lvl[i].tag_use_flag == 1) {
      tmp = strncmp(tag, (char const   *)(elog.filter.tag_lvl[i].tag), (size_t )16);
      if (! tmp) {
        level = elog.filter.tag_lvl[i].level;
        break;
      }
    }
    i = (uint8_t )((int )i + 1);
  }
  elog_output_unlock();
  return (level);
}
}
void elog_async_output(uint8_t level , char const   *log , size_t size ) ;
void elog_raw(char const   *format  , ...) 
{ 
  va_list___0 args ;
  size_t log_len ;
  int fmt_result ;

  {
  log_len = (size_t )0;
  if (! elog.output_enabled) {
    return;
  }
  __builtin_va_start(args, format);
  elog_output_lock();
  fmt_result = vsnprintf((char * __restrict  )(log_buf), (size_t )512, (char const   * __restrict  )format,
                         args);
  if (fmt_result > -1) {
    if (fmt_result <= 512) {
      log_len = (size_t )fmt_result;
    } else {
      log_len = (size_t )512;
    }
  } else {
    log_len = (size_t )512;
  }
  elog_async_output((uint8_t )0, (char const   *)(log_buf), log_len);
  elog_output_unlock();
  __builtin_va_end(args);
  return;
}
}
char const   *elog_port_get_time(void) ;
char const   *elog_port_get_p_info(void) ;
char const   *elog_port_get_t_info(void) ;
void elog_output(uint8_t level , char const   *tag , char const   *file , char const   *func ,
                 long const   line , char const   *format  , ...) 
{ 
  size_t tag_len ;
  size_t tmp ;
  size_t log_len ;
  size_t newline_len ;
  size_t tmp___0 ;
  char line_num[6] ;
  unsigned int tmp___1 ;
  char tag_sapce[9] ;
  unsigned int tmp___2 ;
  va_list___0 args ;
  int fmt_result ;
  char *tmp___3 ;
  uint8_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  _Bool tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  _Bool tmp___12 ;
  size_t tmp___13 ;
  char const   *tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  _Bool tmp___17 ;
  _Bool tmp___18 ;
  char const   *tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  _Bool tmp___22 ;
  _Bool tmp___23 ;
  char const   *tmp___24 ;
  size_t tmp___25 ;
  _Bool tmp___26 ;
  size_t tmp___27 ;
  _Bool tmp___28 ;
  size_t tmp___29 ;
  size_t tmp___30 ;
  size_t tmp___31 ;
  size_t tmp___32 ;
  _Bool tmp___33 ;
  _Bool tmp___34 ;
  _Bool tmp___35 ;
  size_t tmp___36 ;
  size_t tmp___37 ;
  _Bool tmp___38 ;
  _Bool tmp___39 ;
  size_t tmp___40 ;
  _Bool tmp___41 ;
  size_t tmp___42 ;
  _Bool tmp___43 ;
  char *tmp___44 ;
  size_t tmp___45 ;
  size_t tmp___46 ;

  {
  tmp = strlen(tag);
  tag_len = tmp;
  log_len = (size_t )0;
  tmp___0 = strlen("\n");
  newline_len = tmp___0;
  line_num[0] = (char)0;
  tmp___1 = 1U;
  while (! (tmp___1 >= 6U)) {
    line_num[tmp___1] = (char)0;
    tmp___1 ++;
  }
  tag_sapce[0] = (char)0;
  tmp___2 = 1U;
  while (! (tmp___2 >= 9U)) {
    tag_sapce[tmp___2] = (char)0;
    tmp___2 ++;
  }
  if (! ((int )level <= 5)) {
    if ((unsigned long )elog_assert_hook == (unsigned long )((void *)0)) {
      elog_output((uint8_t )0, "elog", "../../../easylogger/src/elog.c", "elog_output",
                  (long const   )570, "(%s) has assert failed at %s:%ld.", "level <= ELOG_LVL_VERBOSE",
                  "elog_output", 570);
      while (1) {

      }
    } else {
      (*elog_assert_hook)("level <= ELOG_LVL_VERBOSE", "elog_output", (size_t )570);
    }
  }
  if (! elog.output_enabled) {
    return;
  }
  if ((int )level > (int )elog.filter.level) {
    return;
  } else {
    tmp___4 = elog_get_filter_tag_lvl(tag);
    if ((int )level > (int )tmp___4) {
      return;
    } else {
      tmp___3 = strstr(tag, (char const   *)(elog.filter.tag));
      if (! tmp___3) {
        return;
      }
    }
  }
  __builtin_va_start(args, format);
  elog_output_lock();
  if (elog.text_color_enabled) {
    tmp___5 = elog_strcpy(log_len, log_buf + log_len, "\033[");
    log_len += tmp___5;
    tmp___6 = elog_strcpy(log_len, log_buf + log_len, color_output_info[level]);
    log_len += tmp___6;
  }
  tmp___8 = get_fmt_enabled(level, (size_t )1);
  if (tmp___8) {
    tmp___7 = elog_strcpy(log_len, log_buf + log_len, level_output_info[level]);
    log_len += tmp___7;
  }
  tmp___12 = get_fmt_enabled(level, (size_t )2);
  if (tmp___12) {
    tmp___9 = elog_strcpy(log_len, log_buf + log_len, tag);
    log_len += tmp___9;
    if (tag_len <= 8UL) {
      memset((void *)(tag_sapce), ' ', 8UL - tag_len);
      tmp___10 = elog_strcpy(log_len, log_buf + log_len, (char const   *)(tag_sapce));
      log_len += tmp___10;
    }
    tmp___11 = elog_strcpy(log_len, log_buf + log_len, " ");
    log_len += tmp___11;
  }
  tmp___28 = get_fmt_enabled(level, (size_t )28);
  if (tmp___28) {
    tmp___13 = elog_strcpy(log_len, log_buf + log_len, "[");
    log_len += tmp___13;
    tmp___18 = get_fmt_enabled(level, (size_t )4);
    if (tmp___18) {
      tmp___14 = elog_port_get_time();
      tmp___15 = elog_strcpy(log_len, log_buf + log_len, tmp___14);
      log_len += tmp___15;
      tmp___17 = get_fmt_enabled(level, (size_t )24);
      if (tmp___17) {
        tmp___16 = elog_strcpy(log_len, log_buf + log_len, " ");
        log_len += tmp___16;
      }
    }
    tmp___23 = get_fmt_enabled(level, (size_t )8);
    if (tmp___23) {
      tmp___19 = elog_port_get_p_info();
      tmp___20 = elog_strcpy(log_len, log_buf + log_len, tmp___19);
      log_len += tmp___20;
      tmp___22 = get_fmt_enabled(level, (size_t )16);
      if (tmp___22) {
        tmp___21 = elog_strcpy(log_len, log_buf + log_len, " ");
        log_len += tmp___21;
      }
    }
    tmp___26 = get_fmt_enabled(level, (size_t )16);
    if (tmp___26) {
      tmp___24 = elog_port_get_t_info();
      tmp___25 = elog_strcpy(log_len, log_buf + log_len, tmp___24);
      log_len += tmp___25;
    }
    tmp___27 = elog_strcpy(log_len, log_buf + log_len, "] ");
    log_len += tmp___27;
  }
  tmp___43 = get_fmt_enabled(level, (size_t )224);
  if (tmp___43) {
    tmp___29 = elog_strcpy(log_len, log_buf + log_len, "(");
    log_len += tmp___29;
    tmp___35 = get_fmt_enabled(level, (size_t )32);
    if (tmp___35) {
      tmp___30 = elog_strcpy(log_len, log_buf + log_len, file);
      log_len += tmp___30;
      tmp___34 = get_fmt_enabled(level, (size_t )64);
      if (tmp___34) {
        tmp___31 = elog_strcpy(log_len, log_buf + log_len, ":");
        log_len += tmp___31;
      } else {
        tmp___33 = get_fmt_enabled(level, (size_t )128);
        if (tmp___33) {
          tmp___32 = elog_strcpy(log_len, log_buf + log_len, " ");
          log_len += tmp___32;
        }
      }
    }
    tmp___39 = get_fmt_enabled(level, (size_t )128);
    if (tmp___39) {
      snprintf((char * __restrict  )(line_num), (size_t )5, (char const   * __restrict  )"%ld",
               line);
      tmp___36 = elog_strcpy(log_len, log_buf + log_len, (char const   *)(line_num));
      log_len += tmp___36;
      tmp___38 = get_fmt_enabled(level, (size_t )64);
      if (tmp___38) {
        tmp___37 = elog_strcpy(log_len, log_buf + log_len, " ");
        log_len += tmp___37;
      }
    }
    tmp___41 = get_fmt_enabled(level, (size_t )64);
    if (tmp___41) {
      tmp___40 = elog_strcpy(log_len, log_buf + log_len, func);
      log_len += tmp___40;
    }
    tmp___42 = elog_strcpy(log_len, log_buf + log_len, ")");
    log_len += tmp___42;
  }
  fmt_result = vsnprintf((char * __restrict  )(log_buf + log_len), 512UL - log_len,
                         (char const   * __restrict  )format, args);
  __builtin_va_end(args);
  if (log_len + (size_t )fmt_result <= 512UL) {
    if (fmt_result > -1) {
      log_len += (size_t )fmt_result;
    } else {
      log_len = (size_t )512;
    }
  } else {
    log_len = (size_t )512;
  }
  if ((log_len + (sizeof("\033[0m") - 1UL)) + newline_len > 512UL) {
    log_len = (size_t )512;
    log_len -= sizeof("\033[0m") - 1UL;
    log_len -= newline_len;
  }
  if ((int )elog.filter.keyword[0] != 0) {
    log_buf[log_len] = (char )'\000';
    tmp___44 = strstr((char const   *)(log_buf), (char const   *)(elog.filter.keyword));
    if (! tmp___44) {
      elog_output_unlock();
      return;
    }
  }
  if (elog.text_color_enabled) {
    tmp___45 = elog_strcpy(log_len, log_buf + log_len, "\033[0m");
    log_len += tmp___45;
  }
  tmp___46 = elog_strcpy(log_len, log_buf + log_len, "\n");
  log_len += tmp___46;
  elog_async_output(level, (char const   *)(log_buf), log_len);
  elog_output_unlock();
  return;
}
}
static _Bool get_fmt_enabled(uint8_t level , size_t set ) 
{ 


  {
  if (! ((int )level <= 5)) {
    if ((unsigned long )elog_assert_hook == (unsigned long )((void *)0)) {
      elog_output((uint8_t )0, "elog", "../../../easylogger/src/elog.c", "get_fmt_enabled",
                  (long const   )729, "(%s) has assert failed at %s:%ld.", "level <= ELOG_LVL_VERBOSE",
                  "get_fmt_enabled", 729);
      while (1) {

      }
    } else {
      (*elog_assert_hook)("level <= ELOG_LVL_VERBOSE", "get_fmt_enabled", (size_t )729);
    }
  }
  if (elog.enabled_fmt_set[level] & set) {
    return ((_Bool)1);
  } else {
    return ((_Bool)0);
  }
}
}
void elog_output_lock_enabled(_Bool enabled ) 
{ 


  {
  elog.output_lock_enabled = enabled;
  if (elog.output_lock_enabled) {
    if (! elog.output_is_locked_before_disable) {
      if (elog.output_is_locked_before_enable) {
        elog_port_output_lock();
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (elog.output_is_locked_before_disable) {
      if (! elog.output_is_locked_before_enable) {
        elog_port_output_unlock();
      }
    }
  }
  return;
}
}
void elog_assert_set_hook(void (*hook)(char const   *expr , char const   *func , size_t line ) ) 
{ 


  {
  elog_assert_hook = hook;
  return;
}
}
int8_t elog_find_lvl(char const   *log ) 
{ 
  uint8_t i ;
  size_t csi_start_len ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  if (! log) {
    if ((unsigned long )elog_assert_hook == (unsigned long )((void *)0)) {
      elog_output((uint8_t )0, "elog", "../../../easylogger/src/elog.c", "elog_find_lvl",
                  (long const   )776, "(%s) has assert failed at %s:%ld.", "log",
                  "elog_find_lvl", 776);
      while (1) {

      }
    } else {
      (*elog_assert_hook)("log", "elog_find_lvl", (size_t )776);
    }
  }
  if (! (elog.enabled_fmt_set[0] & 1UL)) {
    if ((unsigned long )elog_assert_hook == (unsigned long )((void *)0)) {
      elog_output((uint8_t )0, "elog", "../../../easylogger/src/elog.c", "elog_find_lvl",
                  (long const   )778, "(%s) has assert failed at %s:%ld.", "elog.enabled_fmt_set[ELOG_LVL_ASSERT] & ELOG_FMT_LVL",
                  "elog_find_lvl", 778);
      while (1) {

      }
    } else {
      (*elog_assert_hook)("elog.enabled_fmt_set[ELOG_LVL_ASSERT] & ELOG_FMT_LVL",
                          "elog_find_lvl", (size_t )778);
    }
  }
  if (! (elog.enabled_fmt_set[1] & 1UL)) {
    if ((unsigned long )elog_assert_hook == (unsigned long )((void *)0)) {
      elog_output((uint8_t )0, "elog", "../../../easylogger/src/elog.c", "elog_find_lvl",
                  (long const   )779, "(%s) has assert failed at %s:%ld.", "elog.enabled_fmt_set[ELOG_LVL_ERROR] & ELOG_FMT_LVL",
                  "elog_find_lvl", 779);
      while (1) {

      }
    } else {
      (*elog_assert_hook)("elog.enabled_fmt_set[ELOG_LVL_ERROR] & ELOG_FMT_LVL", "elog_find_lvl",
                          (size_t )779);
    }
  }
  if (! (elog.enabled_fmt_set[2] & 1UL)) {
    if ((unsigned long )elog_assert_hook == (unsigned long )((void *)0)) {
      elog_output((uint8_t )0, "elog", "../../../easylogger/src/elog.c", "elog_find_lvl",
                  (long const   )780, "(%s) has assert failed at %s:%ld.", "elog.enabled_fmt_set[ELOG_LVL_WARN] & ELOG_FMT_LVL",
                  "elog_find_lvl", 780);
      while (1) {

      }
    } else {
      (*elog_assert_hook)("elog.enabled_fmt_set[ELOG_LVL_WARN] & ELOG_FMT_LVL", "elog_find_lvl",
                          (size_t )780);
    }
  }
  if (! (elog.enabled_fmt_set[3] & 1UL)) {
    if ((unsigned long )elog_assert_hook == (unsigned long )((void *)0)) {
      elog_output((uint8_t )0, "elog", "../../../easylogger/src/elog.c", "elog_find_lvl",
                  (long const   )781, "(%s) has assert failed at %s:%ld.", "elog.enabled_fmt_set[ELOG_LVL_INFO] & ELOG_FMT_LVL",
                  "elog_find_lvl", 781);
      while (1) {

      }
    } else {
      (*elog_assert_hook)("elog.enabled_fmt_set[ELOG_LVL_INFO] & ELOG_FMT_LVL", "elog_find_lvl",
                          (size_t )781);
    }
  }
  if (! (elog.enabled_fmt_set[4] & 1UL)) {
    if ((unsigned long )elog_assert_hook == (unsigned long )((void *)0)) {
      elog_output((uint8_t )0, "elog", "../../../easylogger/src/elog.c", "elog_find_lvl",
                  (long const   )782, "(%s) has assert failed at %s:%ld.", "elog.enabled_fmt_set[ELOG_LVL_DEBUG] & ELOG_FMT_LVL",
                  "elog_find_lvl", 782);
      while (1) {

      }
    } else {
      (*elog_assert_hook)("elog.enabled_fmt_set[ELOG_LVL_DEBUG] & ELOG_FMT_LVL", "elog_find_lvl",
                          (size_t )782);
    }
  }
  if (! (elog.enabled_fmt_set[5] & 1UL)) {
    if ((unsigned long )elog_assert_hook == (unsigned long )((void *)0)) {
      elog_output((uint8_t )0, "elog", "../../../easylogger/src/elog.c", "elog_find_lvl",
                  (long const   )783, "(%s) has assert failed at %s:%ld.", "elog.enabled_fmt_set[ELOG_LVL_VERBOSE] & ELOG_FMT_LVL",
                  "elog_find_lvl", 783);
      while (1) {

      }
    } else {
      (*elog_assert_hook)("elog.enabled_fmt_set[ELOG_LVL_VERBOSE] & ELOG_FMT_LVL",
                          "elog_find_lvl", (size_t )783);
    }
  }
  tmp = strlen("\033[");
  csi_start_len = tmp;
  i = (uint8_t )0;
  while ((int )i < 6) {
    tmp___0 = strlen(color_output_info[i]);
    tmp___1 = strncmp(color_output_info[i], log + csi_start_len, tmp___0);
    if (! tmp___1) {
      return ((int8_t )i);
    }
    i = (uint8_t )((int )i + 1);
  }
  return ((int8_t )-1);
}
}
char const   *elog_find_tag(char const   *log , uint8_t lvl , size_t *tag_len ) 
{ 
  char const   *tag ;
  char const   *tag_end ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  tag = (char const   *)((void *)0);
  tag_end = (char const   *)((void *)0);
  if (! log) {
    if ((unsigned long )elog_assert_hook == (unsigned long )((void *)0)) {
      elog_output((uint8_t )0, "elog", "../../../easylogger/src/elog.c", "elog_find_tag",
                  (long const   )822, "(%s) has assert failed at %s:%ld.", "log",
                  "elog_find_tag", 822);
      while (1) {

      }
    } else {
      (*elog_assert_hook)("log", "elog_find_tag", (size_t )822);
    }
  }
  if (! tag_len) {
    if ((unsigned long )elog_assert_hook == (unsigned long )((void *)0)) {
      elog_output((uint8_t )0, "elog", "../../../easylogger/src/elog.c", "elog_find_tag",
                  (long const   )823, "(%s) has assert failed at %s:%ld.", "tag_len",
                  "elog_find_tag", 823);
      while (1) {

      }
    } else {
      (*elog_assert_hook)("tag_len", "elog_find_tag", (size_t )823);
    }
  }
  if (! ((int )lvl < 6)) {
    if ((unsigned long )elog_assert_hook == (unsigned long )((void *)0)) {
      elog_output((uint8_t )0, "elog", "../../../easylogger/src/elog.c", "elog_find_tag",
                  (long const   )824, "(%s) has assert failed at %s:%ld.", "lvl < ELOG_LVL_TOTAL_NUM",
                  "elog_find_tag", 824);
      while (1) {

      }
    } else {
      (*elog_assert_hook)("lvl < ELOG_LVL_TOTAL_NUM", "elog_find_tag", (size_t )824);
    }
  }
  if (! (elog.enabled_fmt_set[lvl] & 2UL)) {
    if ((unsigned long )elog_assert_hook == (unsigned long )((void *)0)) {
      elog_output((uint8_t )0, "elog", "../../../easylogger/src/elog.c", "elog_find_tag",
                  (long const   )826, "(%s) has assert failed at %s:%ld.", "elog.enabled_fmt_set[lvl] & ELOG_FMT_TAG",
                  "elog_find_tag", 826);
      while (1) {

      }
    } else {
      (*elog_assert_hook)("elog.enabled_fmt_set[lvl] & ELOG_FMT_TAG", "elog_find_tag",
                          (size_t )826);
    }
  }
  tmp = strlen("\033[");
  tmp___0 = strlen(color_output_info[lvl]);
  tmp___1 = strlen(level_output_info[lvl]);
  tag = ((log + tmp) + tmp___0) + tmp___1;
  tmp___2 = memchr((void const   *)tag, ' ', (size_t )16);
  tag_end = (char const   *)tmp___2;
  if ((unsigned long )tag_end != (unsigned long )((void *)0)) {
    *tag_len = (size_t )(tag_end - tag);
  } else {
    tag = (char const   *)((void *)0);
  }
  return (tag);
}
}
void elog_hexdump(char const   *name , uint8_t width , void const   *buf , uint16_t size ) 
{ 
  uint16_t i ;
  uint16_t j ;
  uint16_t log_len ;
  uint8_t const   *buf_p ;
  char dump_string[8] ;
  unsigned int tmp ;
  int fmt_result ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
  log_len = (uint16_t )0;
  buf_p = (uint8_t const   *)buf;
  dump_string[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 8U)) {
    dump_string[tmp] = (char)0;
    tmp ++;
  }
  if (! elog.output_enabled) {
    return;
  }
  if (4 > (int )elog.filter.level) {
    return;
  } else {
    tmp___0 = strstr(name, (char const   *)(elog.filter.tag));
    if (! tmp___0) {
      return;
    }
  }
  elog_output_lock();
  i = (uint16_t )0;
  while ((int )i < (int )size) {
    fmt_result = snprintf((char * __restrict  )(log_buf), (size_t )512, (char const   * __restrict  )"D/HEX %s: %04X-%04X: ",
                          name, (int )i, ((int )i + (int )width) - 1);
    if (fmt_result > -1) {
      if (fmt_result <= 512) {
        log_len = (uint16_t )fmt_result;
      } else {
        log_len = (uint16_t )512;
      }
    } else {
      log_len = (uint16_t )512;
    }
    j = (uint16_t )0;
    while ((int )j < (int )width) {
      if ((int )i + (int )j < (int )size) {
        snprintf((char * __restrict  )(dump_string), sizeof(dump_string), (char const   * __restrict  )"%02X ",
                 (int const   )*(buf_p + ((int )i + (int )j)));
      } else {
        strncpy((char * __restrict  )(dump_string), (char const   * __restrict  )"   ",
                sizeof(dump_string));
      }
      tmp___1 = elog_strcpy((size_t )log_len, log_buf + (int )log_len, (char const   *)(dump_string));
      log_len = (uint16_t )((size_t )log_len + tmp___1);
      if (((int )j + 1) % 8 == 0) {
        tmp___2 = elog_strcpy((size_t )log_len, log_buf + (int )log_len, " ");
        log_len = (uint16_t )((size_t )log_len + tmp___2);
      }
      j = (uint16_t )((int )j + 1);
    }
    tmp___3 = elog_strcpy((size_t )log_len, log_buf + (int )log_len, "  ");
    log_len = (uint16_t )((size_t )log_len + tmp___3);
    j = (uint16_t )0;
    while ((int )j < (int )width) {
      if ((int )i + (int )j < (int )size) {
        if ((unsigned int )((int const   )*(buf_p + ((int )i + (int )j)) - 32) < 95U) {
          tmp___4 = (int const   )*(buf_p + ((int )i + (int )j));
        } else {
          tmp___4 = (int const   )'.';
        }
        snprintf((char * __restrict  )(dump_string), sizeof(dump_string), (char const   * __restrict  )"%c",
                 tmp___4);
        tmp___5 = elog_strcpy((size_t )log_len, log_buf + (int )log_len, (char const   *)(dump_string));
        log_len = (uint16_t )((size_t )log_len + tmp___5);
      }
      j = (uint16_t )((int )j + 1);
    }
    tmp___7 = strlen("\n");
    if ((size_t )log_len + tmp___7 > 512UL) {
      tmp___6 = strlen("\n");
      log_len = (uint16_t )(512UL - tmp___6);
    }
    tmp___8 = elog_strcpy((size_t )log_len, log_buf + (int )log_len, "\n");
    log_len = (uint16_t )((size_t )log_len + tmp___8);
    elog_async_output((uint8_t )4, (char const   *)(log_buf), (size_t )log_len);
    i = (uint16_t )((int )i + (int )width);
  }
  elog_output_unlock();
  return;
}
}
#pragma merger("0","/tmp/cil-MoKYU8BK.i","-O0,-g3,-Wall")
size_t elog_async_get_log(char *log , size_t size ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
extern  __attribute__((__nothrow__)) int sched_get_priority_max(int __algorithm ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_attr_init)(pthread_attr_t *__attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_attr_destroy)(pthread_attr_t *__attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) pthread_attr_setschedparam)(pthread_attr_t * __restrict  __attr ,
                                                                                                         struct sched_param  const  * __restrict  __param ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_attr_setschedpolicy)(pthread_attr_t *__attr ,
                                                                                                        int __policy ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_attr_setstacksize)(pthread_attr_t *__attr ,
                                                                                                      size_t __stacksize ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sem_init)(sem_t *__sem ,
                                                                                     int __pshared ,
                                                                                     unsigned int __value ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sem_destroy)(sem_t *__sem ) ;
extern int ( __attribute__((__nonnull__(1))) sem_wait)(sem_t *__sem ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sem_post)(sem_t *__sem ) ;
static sem_t output_notice  ;
static pthread_t async_output_thread  ;
static _Bool init_ok  =    (_Bool)0;
static _Bool thread_running  =    (_Bool)0;
static _Bool is_enabled  =    (_Bool)0;
static char log_buf___0[25600]  = {      (char)0};
static size_t write_index  =    (size_t )0;
static size_t read_index  =    (size_t )0;
static _Bool buf_is_full  =    (_Bool)0;
static _Bool buf_is_empty  =    (_Bool)1;
void elog_port_output(char const   *log , size_t size ) ;
static size_t elog_async_get_buf_used(void) 
{ 


  {
  if (write_index > read_index) {
    return (write_index - read_index);
  } else
  if (! buf_is_full) {
    if (! buf_is_empty) {
      return (25600UL - (read_index - write_index));
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (buf_is_full) {
    return ((size_t )25600);
  } else {
    return ((size_t )0);
  }
}
}
static size_t async_get_buf_space(void) 
{ 
  size_t tmp ;

  {
  tmp = elog_async_get_buf_used();
  return (25600UL - tmp);
}
}
static size_t async_put_log(char const   *log , size_t size ) 
{ 
  size_t space ;

  {
  space = (size_t )0;
  space = async_get_buf_space();
  if (! space) {
    size = (size_t )0;
    goto __exit;
  }
  if (space <= size) {
    size = space;
    buf_is_full = (_Bool)1;
  }
  if (write_index + size < 25600UL) {
    memcpy((void * __restrict  )(log_buf___0 + write_index), (void const   * __restrict  )log,
           size);
    write_index += size;
  } else {
    memcpy((void * __restrict  )(log_buf___0 + write_index), (void const   * __restrict  )log,
           25600UL - write_index);
    memcpy((void * __restrict  )(log_buf___0), (void const   * __restrict  )((log + 25600) - write_index),
           size - (25600UL - write_index));
    write_index += size - 25600UL;
  }
  buf_is_empty = (_Bool)0;
  __exit: 
  return (size);
}
}
size_t elog_async_get_log(char *log , size_t size ) 
{ 
  size_t used ;

  {
  used = (size_t )0;
  elog_output_lock();
  used = elog_async_get_buf_used();
  if (! used) {
    size = (size_t )0;
    goto __exit;
  } else
  if (! size) {
    size = (size_t )0;
    goto __exit;
  }
  if (used <= size) {
    size = used;
    buf_is_empty = (_Bool)1;
  }
  if (read_index + size < 25600UL) {
    memcpy((void * __restrict  )log, (void const   * __restrict  )(log_buf___0 + read_index),
           size);
    read_index += size;
  } else {
    memcpy((void * __restrict  )log, (void const   * __restrict  )(log_buf___0 + read_index),
           25600UL - read_index);
    memcpy((void * __restrict  )((log + 25600) - read_index), (void const   * __restrict  )(log_buf___0),
           size - (25600UL - read_index));
    read_index += size - 25600UL;
  }
  buf_is_full = (_Bool)0;
  __exit: 
  elog_output_unlock();
  return (size);
}
}
void elog_async_output_notice(void) ;
void elog_async_output(uint8_t level , char const   *log , size_t size ) 
{ 
  size_t put_size ;

  {
  if (is_enabled) {
    if ((int )level >= 4) {
      put_size = async_put_log(log, size);
      if (put_size > 0UL) {
        elog_async_output_notice();
      }
    } else {
      elog_port_output(log, size);
    }
  } else {
    elog_port_output(log, size);
  }
  return;
}
}
void elog_async_output_notice(void) 
{ 


  {
  sem_post(& output_notice);
  return;
}
}
static char poll_get_buf[25596]  ;
static void *async_output(void *arg ) 
{ 
  size_t get_log_size ;

  {
  get_log_size = (size_t )0;
  while (thread_running) {
    sem_wait(& output_notice);
    while (1) {
      get_log_size = elog_async_get_log(poll_get_buf, (size_t )25596);
      if (get_log_size) {
        elog_port_output((char const   *)(poll_get_buf), get_log_size);
      } else {
        break;
      }
    }
  }
  return ((void *)0);
}
}
void elog_async_enabled(_Bool enabled ) 
{ 


  {
  is_enabled = enabled;
  return;
}
}
ElogErrCode elog_async_init(void) 
{ 
  ElogErrCode result ;
  pthread_attr_t thread_attr ;
  struct sched_param thread_sched_param ;
  int tmp ;

  {
  result = (ElogErrCode )0;
  if (init_ok) {
    return (result);
  }
  sem_init(& output_notice, 0, 0U);
  thread_running = (_Bool)1;
  pthread_attr_init(& thread_attr);
  pthread_attr_setstacksize(& thread_attr, (size_t )1024);
  pthread_attr_setschedpolicy(& thread_attr, 2);
  tmp = sched_get_priority_max(2);
  thread_sched_param.sched_priority = tmp - 1;
  pthread_attr_setschedparam((pthread_attr_t * __restrict  )(& thread_attr), (struct sched_param  const  * __restrict  )(& thread_sched_param));
  pthread_create((pthread_t * __restrict  )(& async_output_thread), (pthread_attr_t const   * __restrict  )(& thread_attr),
                 & async_output, (void * __restrict  )((void *)0));
  pthread_attr_destroy(& thread_attr);
  init_ok = (_Bool)1;
  return (result);
}
}
void elog_async_deinit(void) 
{ 


  {
  if (! init_ok) {
    return;
  }
  thread_running = (_Bool)0;
  elog_async_output_notice();
  pthread_join(async_output_thread, (void **)((void *)0));
  sem_destroy(& output_notice);
  init_ok = (_Bool)0;
  return;
}
}
#pragma merger("0","/tmp/cil-R_kipRrD.i","-O0,-g3,-Wall")
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#pragma merger("0","/tmp/cil-DNeuD90q.i","-O0,-g3,-Wall")
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
extern int fclose(FILE *__stream ) ;
extern int fflush(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
extern int fseek(FILE *__stream , long __off , int __whence ) ;
extern long ftell(FILE *__stream ) ;
ElogErrCode elog_file_init(void) ;
void elog_file_write(char const   *log , size_t size ) ;
void elog_file_config(ElogFileCfg *cfg ) ;
void elog_file_deinit(void) ;
ElogErrCode elog_file_port_init(void) ;
void elog_file_port_lock(void) ;
void elog_file_port_unlock(void) ;
void elog_file_port_deinit(void) ;
static _Bool init_ok___0  =    (_Bool)0;
static FILE *fp  =    (FILE *)((void *)0);
static ElogFileCfg local_cfg  ;
ElogErrCode elog_file_init(void) 
{ 
  ElogErrCode result ;
  ElogFileCfg cfg ;

  {
  result = (ElogErrCode )0;
  if (init_ok___0) {
    goto __exit;
  }
  elog_file_port_init();
  cfg.name = (char *)"/tmp/elog_file.log";
  cfg.max_size = (size_t )1048576;
  cfg.max_rotate = 5;
  elog_file_config(& cfg);
  init_ok___0 = (_Bool)1;
  __exit: 
  return (result);
}
}
static _Bool elog_file_rotate(void) 
{ 
  int n ;
  int err ;
  char oldpath[256] ;
  char newpath[256] ;
  size_t base ;
  size_t tmp ;
  _Bool result ;
  FILE *tmp_fp ;
  char const   *tmp___0 ;

  {
  err = 0;
  tmp = strlen((char const   *)local_cfg.name);
  base = tmp;
  result = (_Bool)1;
  memcpy((void * __restrict  )(oldpath), (void const   * __restrict  )local_cfg.name,
         base);
  memcpy((void * __restrict  )(newpath), (void const   * __restrict  )local_cfg.name,
         base);
  fclose(fp);
  n = local_cfg.max_rotate - 1;
  while (n >= 0) {
    if (n) {
      tmp___0 = ".%d";
    } else {
      tmp___0 = "";
    }
    snprintf((char * __restrict  )(oldpath + base), (size_t )10, (char const   * __restrict  )tmp___0,
             n - 1);
    snprintf((char * __restrict  )(newpath + base), (size_t )10, (char const   * __restrict  )".%d",
             n);
    tmp_fp = fopen((char const   * __restrict  )(newpath), (char const   * __restrict  )"r");
    if ((unsigned long )tmp_fp != (unsigned long )((void *)0)) {
      fclose(tmp_fp);
      remove((char const   *)(newpath));
    }
    tmp_fp = fopen((char const   * __restrict  )(oldpath), (char const   * __restrict  )"r");
    if ((unsigned long )tmp_fp != (unsigned long )((void *)0)) {
      fclose(tmp_fp);
      err = rename((char const   *)(oldpath), (char const   *)(newpath));
    }
    if (err < 0) {
      result = (_Bool)0;
      goto __exit;
    }
    n --;
  }
  __exit: 
  fp = fopen((char const   * __restrict  )local_cfg.name, (char const   * __restrict  )"a+");
  return (result);
}
}
void elog_file_write(char const   *log , size_t size ) 
{ 
  size_t file_size ;
  long tmp ;
  _Bool tmp___0 ;
  long tmp___1 ;

  {
  file_size = (size_t )0;
  if (! init_ok___0) {
    if ((unsigned long )elog_assert_hook == (unsigned long )((void *)0)) {
      elog_output((uint8_t )0, "elog", "../../../easylogger/plugins/file/elog_file.c",
                  "elog_file_write", (long const   )114, "(%s) has assert failed at %s:%ld.",
                  "init_ok", "elog_file_write", 114);
      while (1) {

      }
    } else {
      (*elog_assert_hook)("init_ok", "elog_file_write", (size_t )114);
    }
  }
  if (! log) {
    if ((unsigned long )elog_assert_hook == (unsigned long )((void *)0)) {
      elog_output((uint8_t )0, "elog", "../../../easylogger/plugins/file/elog_file.c",
                  "elog_file_write", (long const   )115, "(%s) has assert failed at %s:%ld.",
                  "log", "elog_file_write", 115);
      while (1) {

      }
    } else {
      (*elog_assert_hook)("log", "elog_file_write", (size_t )115);
    }
  }
  elog_file_port_lock();
  fseek(fp, 0L, 2);
  tmp = ftell(fp);
  file_size = (size_t )tmp;
  tmp___1 = __builtin_expect((long )(! (! (file_size > local_cfg.max_size))), 0L);
  if (tmp___1) {
    tmp___0 = elog_file_rotate();
    if (! tmp___0) {
      goto __exit;
    }
  }
  fwrite((void const   * __restrict  )log, size, (size_t )1, (FILE * __restrict  )fp);
  fflush(fp);
  __exit: 
  elog_file_port_unlock();
  return;
}
}
void elog_file_deinit(void) 
{ 
  ElogFileCfg cfg ;

  {
  if (! init_ok___0) {
    if ((unsigned long )elog_assert_hook == (unsigned long )((void *)0)) {
      elog_output((uint8_t )0, "elog", "../../../easylogger/plugins/file/elog_file.c",
                  "elog_file_deinit", (long const   )144, "(%s) has assert failed at %s:%ld.",
                  "init_ok", "elog_file_deinit", 144);
      while (1) {

      }
    } else {
      (*elog_assert_hook)("init_ok", "elog_file_deinit", (size_t )144);
    }
  }
  cfg.name = (char *)((void *)0);
  cfg.max_size = (size_t )0;
  cfg.max_rotate = 0;
  elog_file_config(& cfg);
  elog_file_port_deinit();
  init_ok___0 = (_Bool)0;
  return;
}
}
void elog_file_config(ElogFileCfg *cfg ) 
{ 
  size_t tmp ;

  {
  elog_file_port_lock();
  if (fp) {
    fclose(fp);
    fp = (FILE *)((void *)0);
  }
  if ((unsigned long )cfg != (unsigned long )((void *)0)) {
    local_cfg.name = cfg->name;
    local_cfg.max_size = cfg->max_size;
    local_cfg.max_rotate = cfg->max_rotate;
    if ((unsigned long )local_cfg.name != (unsigned long )((void *)0)) {
      tmp = strlen((char const   *)local_cfg.name);
      if (tmp > 0UL) {
        fp = fopen((char const   * __restrict  )local_cfg.name, (char const   * __restrict  )"a+");
      }
    }
  }
  elog_file_port_unlock();
  return;
}
}
#pragma merger("0","/tmp/cil-TP4oT84c.i","-O0,-g3,-Wall")
extern  __attribute__((__nothrow__)) int semctl(int __semid , int __semnum , int __cmd 
                                                , ...) ;
extern  __attribute__((__nothrow__)) int semget(key_t __key , int __nsems , int __semflg ) ;
extern  __attribute__((__nothrow__)) int semop(int __semid , struct sembuf *__sops ,
                                               size_t __nsops ) ;
extern int usleep(__useconds_t __useconds ) ;
static int semid  =    -1;
static struct sembuf  const  up  =    {(unsigned short)0, (short)1, (short)4096};
static struct sembuf  const  down  =    {(unsigned short)0, (short)-1, (short)4096};
static void lock_init(void) ;
static int lock_open(void) ;
static void lock_deinit(void) ;
ElogErrCode elog_file_port_init(void) 
{ 
  ElogErrCode result ;

  {
  result = (ElogErrCode )0;
  lock_init();
  return (result);
}
}
void elog_file_port_lock(void) 
{ 


  {
  if (! (semid == -1)) {
    semop(semid, (struct sembuf *)(& down), (size_t )1);
  }
  return;
}
}
void elog_file_port_unlock(void) 
{ 


  {
  if (! (semid == -1)) {
    semop(semid, (struct sembuf *)(& up), (size_t )1);
  }
  return;
}
}
void elog_file_port_deinit(void) 
{ 


  {
  lock_deinit();
  return;
}
}
static void lock_init(void) 
{ 
  int id ;
  int rc ;
  union semun arg ;
  struct sembuf sembuf ;
  long tmp ;

  {
  id = semget(428934674, 1, 1974);
  tmp = __builtin_expect((long )(! (! (id == -1))), 1L);
  if (tmp) {
    id = lock_open();
    if (id == -1) {
      goto __exit;
    }
  } else {
    arg.val = 0;
    rc = semctl(id, 0, 16, arg);
    if (rc == -1) {
      goto __exit;
    }
    sembuf.sem_num = (unsigned short)0;
    sembuf.sem_op = (short)1;
    sembuf.sem_flg = (short)0;
    rc = semop(id, & sembuf, (size_t )1);
    if (rc == -1) {
      goto __exit;
    }
  }
  semid = id;
  __exit: 
  return;
}
}
static int lock_open(void) 
{ 
  int id ;
  int rc ;
  int i ;
  union semun arg ;
  struct semid_ds ds ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  id = semget(428934674, 1, 438);
  tmp = __builtin_expect((long )(! (! (id == -1))), 0L);
  if (tmp) {
    goto err;
  }
  arg.buf = & ds;
  i = 0;
  while (i < 10) {
    rc = semctl(id, 0, 2, arg);
    tmp___0 = __builtin_expect((long )(! (! (rc == -1))), 0L);
    if (tmp___0) {
      goto err;
    }
    if (ds.sem_otime != 0L) {
      break;
    }
    usleep((__useconds_t )10000);
    i ++;
  }
  tmp___1 = __builtin_expect((long )(! (! (ds.sem_otime == 0L))), 0L);
  if (tmp___1) {
    goto err;
  }
  return (id);
  err: 
  return (-1);
}
}
static void lock_deinit(void) 
{ 


  {
  semid = -1;
  return;
}
}
#pragma merger("0","/tmp/cil-RYjZt6vF.i","-O0,-g3,-Wall")
extern int printf(char const   * __restrict  __format  , ...) ;
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
extern  __attribute__((__nothrow__)) size_t strftime(char * __restrict  __s , size_t __maxsize ,
                                                     char const   * __restrict  __format ,
                                                     struct tm  const  * __restrict  __tp ) ;
extern  __attribute__((__nothrow__)) struct tm *localtime_r(time_t const   * __restrict  __timer ,
                                                            struct tm * __restrict  __tp ) ;
extern  __attribute__((__nothrow__)) pthread_t pthread_self(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
static pthread_mutex_t output_lock  ;
ElogErrCode elog_port_init(void) 
{ 
  ElogErrCode result ;

  {
  result = (ElogErrCode )0;
  pthread_mutex_init(& output_lock, (pthread_mutexattr_t const   *)((void *)0));
  elog_file_init();
  return (result);
}
}
void elog_port_deinit(void) 
{ 


  {
  elog_file_deinit();
  pthread_mutex_destroy(& output_lock);
  return;
}
}
void elog_port_output(char const   *log , size_t size ) 
{ 


  {
  printf((char const   * __restrict  )"%.*s", (int )size, log);
  elog_file_write(log, size);
  return;
}
}
void elog_port_output_lock(void) 
{ 


  {
  pthread_mutex_lock(& output_lock);
  return;
}
}
void elog_port_output_unlock(void) 
{ 


  {
  pthread_mutex_unlock(& output_lock);
  return;
}
}
static char cur_system_time[24]  = {      (char)0};
char const   *elog_port_get_time(void) 
{ 
  time_t cur_t ;
  struct tm cur_tm ;

  {
  time(& cur_t);
  localtime_r((time_t const   * __restrict  )(& cur_t), (struct tm * __restrict  )(& cur_tm));
  strftime((char * __restrict  )(cur_system_time), sizeof(cur_system_time), (char const   * __restrict  )"%Y-%m-%d %T",
           (struct tm  const  * __restrict  )(& cur_tm));
  return ((char const   *)(cur_system_time));
}
}
static char cur_process_info[10]  = {      (char)0};
char const   *elog_port_get_p_info(void) 
{ 
  __pid_t tmp ;

  {
  tmp = getpid();
  snprintf((char * __restrict  )(cur_process_info), (size_t )10, (char const   * __restrict  )"pid:%04d",
           tmp);
  return ((char const   *)(cur_process_info));
}
}
static char cur_thread_info[10]  = {      (char)0};
char const   *elog_port_get_t_info(void) 
{ 
  pthread_t tmp ;

  {
  tmp = pthread_self();
  snprintf((char * __restrict  )(cur_thread_info), (size_t )10, (char const   * __restrict  )"tid:%04ld",
           tmp);
  return ((char const   *)(cur_thread_info));
}
}
#pragma merger("0","/tmp/cil-cVnJ9jOf.i","-O0,-g3,-Wall")
size_t elog_cpyln(char *line , char const   *log , size_t len ) ;
void *elog_memcpy(void *dst , void const   *src , size_t count ) ;
size_t elog_strcpy(size_t cur_len , char *dst , char const   *src ) 
{ 
  char const   *src_old ;
  char *tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;

  {
  src_old = src;
  if (! dst) {
    if ((unsigned long )elog_assert_hook == (unsigned long )((void *)0)) {
      elog_output((uint8_t )0, "elog", "../../../easylogger/src/elog_utils.c", "elog_strcpy",
                  (long const   )44, "(%s) has assert failed at %s:%ld.", "dst", "elog_strcpy",
                  44);
      while (1) {

      }
    } else {
      (*elog_assert_hook)("dst", "elog_strcpy", (size_t )44);
    }
  }
  if (! src) {
    if ((unsigned long )elog_assert_hook == (unsigned long )((void *)0)) {
      elog_output((uint8_t )0, "elog", "../../../easylogger/src/elog_utils.c", "elog_strcpy",
                  (long const   )45, "(%s) has assert failed at %s:%ld.", "src", "elog_strcpy",
                  45);
      while (1) {

      }
    } else {
      (*elog_assert_hook)("src", "elog_strcpy", (size_t )45);
    }
  }
  while ((int const   )*src != 0) {
    tmp___1 = cur_len;
    cur_len ++;
    if (tmp___1 < 512UL) {
      tmp = dst;
      dst ++;
      tmp___0 = src;
      src ++;
      *tmp = (char )*tmp___0;
    } else {
      break;
    }
  }
  return ((size_t )(src - src_old));
}
}
size_t elog_cpyln(char *line , char const   *log , size_t len ) 
{ 
  size_t newline_len ;
  size_t tmp ;
  size_t copy_size ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
  tmp = strlen("\n");
  newline_len = tmp;
  copy_size = (size_t )0;
  if (! line) {
    if ((unsigned long )elog_assert_hook == (unsigned long )((void *)0)) {
      elog_output((uint8_t )0, "elog", "../../../easylogger/src/elog_utils.c", "elog_cpyln",
                  (long const   )70, "(%s) has assert failed at %s:%ld.", "line",
                  "elog_cpyln", 70);
      while (1) {

      }
    } else {
      (*elog_assert_hook)("line", "elog_cpyln", (size_t )70);
    }
  }
  if (! log) {
    if ((unsigned long )elog_assert_hook == (unsigned long )((void *)0)) {
      elog_output((uint8_t )0, "elog", "../../../easylogger/src/elog_utils.c", "elog_cpyln",
                  (long const   )71, "(%s) has assert failed at %s:%ld.", "log", "elog_cpyln",
                  71);
      while (1) {

      }
    } else {
      (*elog_assert_hook)("log", "elog_cpyln", (size_t )71);
    }
  }
  while (1) {
    tmp___3 = len;
    len --;
    if (! tmp___3) {
      break;
    }
    tmp___0 = line;
    line ++;
    tmp___1 = log;
    log ++;
    *tmp___0 = (char )*tmp___1;
    copy_size ++;
    if (copy_size >= newline_len) {
      tmp___2 = strncmp(log - newline_len, "\n", newline_len);
      if (! tmp___2) {
        break;
      }
    }
  }
  return (copy_size);
}
}
void *elog_memcpy(void *dst , void const   *src , size_t count ) 
{ 
  char *tmp ;
  char *s ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;

  {
  tmp = (char *)dst;
  s = (char *)src;
  if (! dst) {
    if ((unsigned long )elog_assert_hook == (unsigned long )((void *)0)) {
      elog_output((uint8_t )0, "elog", "../../../easylogger/src/elog_utils.c", "elog_memcpy",
                  (long const   )96, "(%s) has assert failed at %s:%ld.", "dst", "elog_memcpy",
                  96);
      while (1) {

      }
    } else {
      (*elog_assert_hook)("dst", "elog_memcpy", (size_t )96);
    }
  }
  if (! src) {
    if ((unsigned long )elog_assert_hook == (unsigned long )((void *)0)) {
      elog_output((uint8_t )0, "elog", "../../../easylogger/src/elog_utils.c", "elog_memcpy",
                  (long const   )97, "(%s) has assert failed at %s:%ld.", "src", "elog_memcpy",
                  97);
      while (1) {

      }
    } else {
      (*elog_assert_hook)("src", "elog_memcpy", (size_t )97);
    }
  }
  while (1) {
    tmp___2 = count;
    count --;
    if (! tmp___2) {
      break;
    }
    tmp___0 = tmp;
    tmp ++;
    tmp___1 = s;
    s ++;
    *tmp___0 = *tmp___1;
  }
  return (dst);
}
}
#pragma merger("0","/tmp/cil-JNiOFKj6.i","-O0,-g3,-Wall")
extern FILE *stdout ;
extern  __attribute__((__nothrow__)) void setbuf(FILE * __restrict  __stream , char * __restrict  __buf ) ;
extern unsigned int sleep(unsigned int __seconds ) ;
static void test_elog(void) ;
int main(void) 
{ 


  {
  setbuf((FILE * __restrict  )stdout, (char * __restrict  )((void *)0));
  elog_init();
  elog_set_fmt((uint8_t )0, (size_t )255);
  elog_set_fmt((uint8_t )1, (size_t )7);
  elog_set_fmt((uint8_t )2, (size_t )7);
  elog_set_fmt((uint8_t )3, (size_t )7);
  elog_set_fmt((uint8_t )4, (size_t )191);
  elog_set_fmt((uint8_t )5, (size_t )191);
  elog_set_text_color_enabled((_Bool)1);
  elog_start();
  test_elog();
  return (0);
}
}
static void test_elog(void) 
{ 
  uint8_t buf[256] ;
  unsigned int tmp ;
  int i ;

  {
  buf[0] = (uint8_t )0;
  tmp = 1U;
  while (! (tmp >= 256U)) {
    buf[tmp] = (unsigned char)0;
    tmp ++;
  }
  i = 0;
  i = 0;
  while ((unsigned long )i < sizeof(buf)) {
    buf[i] = (uint8_t )i;
    i ++;
  }
  while (1) {
    elog_output((uint8_t )0, "main", "main.c", "test_elog", (long const   )86, "Hello EasyLogger!");
    elog_output((uint8_t )1, "main", "main.c", "test_elog", (long const   )87, "Hello EasyLogger!");
    elog_output((uint8_t )2, "main", "main.c", "test_elog", (long const   )88, "Hello EasyLogger!");
    elog_output((uint8_t )3, "main", "main.c", "test_elog", (long const   )89, "Hello EasyLogger!");
    elog_output((uint8_t )4, "main", "main.c", "test_elog", (long const   )90, "Hello EasyLogger!");
    elog_output((uint8_t )5, "main", "main.c", "test_elog", (long const   )91, "Hello EasyLogger!");
    elog_hexdump("test", (uint8_t )16, (void const   *)(buf), (uint16_t )sizeof(buf));
    sleep(5U);
  }
}
}
