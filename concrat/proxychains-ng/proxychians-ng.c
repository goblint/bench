/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef __builtin_va_list __gnuc_va_list;
typedef unsigned char __uint8_t;
typedef unsigned short __uint16_t;
typedef unsigned int __uint32_t;
typedef long __off_t;
typedef long __off64_t;
typedef int __pid_t;
typedef long __time_t;
typedef unsigned int __useconds_t;
typedef long __suseconds_t;
typedef long __ssize_t;
typedef unsigned int __socklen_t;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef __gnuc_va_list va_list___0;
typedef __ssize_t ssize_t;
typedef __pid_t pid_t;
typedef __socklen_t socklen_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct sockaddr_storage {
   sa_family_t ss_family ;
   char __ss_padding[(128UL - sizeof(unsigned short )) - sizeof(unsigned long )] ;
   unsigned long __ss_align ;
};
struct sockaddr_in ;
struct sockaddr_in6 ;
typedef uint32_t in_addr_t;
struct in_addr {
   in_addr_t s_addr ;
};
typedef uint16_t in_port_t;
union __anonunion___in6_u_979734923 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
struct in6_addr {
   union __anonunion___in6_u_979734923 __in6_u ;
};
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
typedef unsigned long nfds_t;
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
union __anonunion_ip_type4_826858479 {
   unsigned char octet[4] ;
   uint32_t as_int ;
};
typedef union __anonunion_ip_type4_826858479 ip_type4;
union __anonunion_addr_69655148 {
   ip_type4 v4 ;
   unsigned char v6[16] ;
};
struct __anonstruct_ip_type_888880172 {
   union __anonunion_addr_69655148 addr ;
   char is_v6 ;
};
typedef struct __anonstruct_ip_type_888880172 ip_type;
enum __anonenum_proxy_type_52082966 {
    HTTP_TYPE = 0,
    SOCKS4_TYPE = 1,
    SOCKS5_TYPE = 2,
    RAW_TYPE = 3
} ;
typedef enum __anonenum_proxy_type_52082966 proxy_type;
enum __anonenum_chain_type_723445919 {
    DYNAMIC_TYPE = 0,
    STRICT_TYPE = 1,
    RANDOM_TYPE = 2,
    ROUND_ROBIN_TYPE = 3
} ;
typedef enum __anonenum_chain_type_723445919 chain_type;
enum __anonenum_proxy_state_523521024 {
    PLAY_STATE = 0,
    DOWN_STATE = 1,
    BLOCKED_STATE = 2,
    BUSY_STATE = 3
} ;
typedef enum __anonenum_proxy_state_523521024 proxy_state;
enum __anonenum_select_type_1061206784 {
    RANDOMLY = 0,
    FIFOLY = 1
} ;
typedef enum __anonenum_select_type_1061206784 select_type;
struct __anonstruct_proxy_data_655008577 {
   ip_type ip ;
   unsigned short port ;
   proxy_type pt ;
   proxy_state ps ;
   char user[256] ;
   char pass[256] ;
};
typedef struct __anonstruct_proxy_data_655008577 proxy_data;
struct gethostbyname_data {
   struct hostent hostent_space ;
   in_addr_t resolved_addr ;
   char *resolved_addr_p[2] ;
   char addr_name[256] ;
};
enum dns_lookup_flavor {
    DNSLF_LIBC = 0,
    DNSLF_FORKEXEC = 1,
    DNSLF_RDNS_START = 2,
    DNSLF_RDNS_THREAD = 2,
    DNSLF_RDNS_DAEMON = 3
} ;
struct addrinfo_data {
   struct addrinfo addrinfo_space ;
   struct sockaddr_storage sockaddr_space ;
   char addr_name[256] ;
};
typedef int __clockid_t;
typedef long __syscall_slong_t;
typedef __clockid_t clockid_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
typedef int pthread_once_t;
struct __anonstruct____missing_field_name_625006857 {
   struct in_addr in_addr ;
   struct in_addr in_mask ;
};
struct __anonstruct____missing_field_name_944355870 {
   struct in6_addr in6_addr ;
   unsigned char in6_prefix ;
};
union __anonunion____missing_field_name_165330731 {
   struct __anonstruct____missing_field_name_625006857 __annonCompField4 ;
   struct __anonstruct____missing_field_name_944355870 __annonCompField5 ;
};
struct __anonstruct_localaddr_arg_565560637 {
   sa_family_t family ;
   unsigned short port ;
   union __anonunion____missing_field_name_165330731 __annonCompField6 ;
};
typedef struct __anonstruct_localaddr_arg_565560637 localaddr_arg;
struct __anonstruct_dnat_arg_1073158885 {
   struct in_addr orig_dst ;
   struct in_addr new_dst ;
   unsigned short orig_port ;
   unsigned short new_port ;
};
typedef struct __anonstruct_dnat_arg_1073158885 dnat_arg;
struct __anonstruct_close_range_args_t_888776187 {
   unsigned int first ;
   unsigned int last ;
   unsigned int flags ;
};
typedef struct __anonstruct_close_range_args_t_888776187 close_range_args_t;
enum __anonenum_rs_proxyType_741041632 {
    RS_PT_NONE = 0,
    RS_PT_SOCKS4 = 1,
    RS_PT_SOCKS5 = 2,
    RS_PT_HTTP = 3
} ;
typedef enum __anonenum_rs_proxyType_741041632 rs_proxyType;
typedef short __int16_t;
typedef unsigned long pthread_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
typedef __int16_t int16_t;
typedef long __fd_mask;
struct __anonstruct_fd_set_356711149 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
typedef struct __anonstruct_fd_set_356711149 fd_set;
struct at_msghdr {
   unsigned char msgtype ;
   char reserved ;
   unsigned short datalen ;
};
union __anonunion_m_242812694 {
   char host[260] ;
   ip_type4 ip ;
};
struct at_msg {
   struct at_msghdr h ;
   union __anonunion_m_242812694 m ;
};
struct __anonstruct_string_hash_tuple_67209659 {
   uint32_t hash ;
   char *string ;
};
typedef struct __anonstruct_string_hash_tuple_67209659 string_hash_tuple;
struct __anonstruct_internal_ip_lookup_table_78056353 {
   uint32_t counter ;
   uint32_t capa ;
   string_hash_tuple **list ;
};
typedef struct __anonstruct_internal_ip_lookup_table_78056353 internal_ip_lookup_table;
enum at_direction {
    ATD_SERVER = 0,
    ATD_CLIENT = 1,
    ATD_MAX = 2
} ;
struct hostsreader {
   FILE *f ;
   char *ip ;
   char *name ;
};
typedef unsigned long uint_fast32_t;
#pragma merger("0","/tmp/cil-WKPl5Xbl.i","-Wno-unknown-pragmas,-Wall,-O0,-g,-std=c99,-pipe,-fPIC")
static char const   version[20]  = 
  {      (char const   )'4',      (char const   )'.',      (char const   )'1',      (char const   )'6', 
        (char const   )'-',      (char const   )'g',      (char const   )'i',      (char const   )'t', 
        (char const   )'-',      (char const   )'9',      (char const   )'-',      (char const   )'g', 
        (char const   )'0',      (char const   )'6',      (char const   )'0',      (char const   )'8', 
        (char const   )'0',      (char const   )'1',      (char const   )'d',      (char const   )'\000'};
char const   *proxychains_get_version(void) 
{ 


  {
  return (version);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#pragma merger("0","/tmp/cil-fHjZLme0.i","-Wno-unknown-pragmas,-Wall,-O0,-g,-std=c99,-pipe,-fPIC")
extern FILE *stderr ;
extern int fflush(FILE *__stream ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
extern void perror(char const   *__s ) ;
int close(int fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
extern  __attribute__((__nothrow__)) int pipe2(int *__pipedes , int __flags ) ;
extern int usleep(__useconds_t __useconds ) ;
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) execlp)(char const   *__file ,
                                                                                     char const   *__arg 
                                                                                     , ...) ;
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gethostname)(char *__name ,
                                                                                        size_t __len ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int rand(void) ;
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
extern  __attribute__((__nothrow__)) uint16_t ntohs(uint16_t __netshort )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) uint16_t htons(uint16_t __hostshort )  __attribute__((__const__)) ;
extern struct hostent *gethostent(void) ;
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
extern int getservbyname_r(char const   * __restrict  __name , char const   * __restrict  __proto ,
                           struct servent * __restrict  __result_buf , char * __restrict  __buf ,
                           size_t __buflen , struct servent ** __restrict  __result ) ;
extern  __attribute__((__nothrow__)) in_addr_t inet_addr(char const   *__cp ) ;
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
extern  __attribute__((__nothrow__)) int inet_pton(int __af , char const   * __restrict  __cp ,
                                                   void * __restrict  __buf ) ;
extern  __attribute__((__nothrow__)) char const   *inet_ntop(int __af , void const   * __restrict  __cp ,
                                                             char * __restrict  __buf ,
                                                             socklen_t __len ) ;
extern  __attribute__((__nothrow__)) int inet_aton(char const   *__cp , struct in_addr *__inp ) ;
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
extern int fcntl(int __fd , int __cmd  , ...) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         void * __restrict  __tz ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
int connect_proxy_chain(int sock , ip_type target_ip , unsigned short target_port ,
                        proxy_data *pd , unsigned int proxy_count , chain_type ct ,
                        unsigned int max_chain ) ;
void proxychains_write_log(char *str  , ...) ;
int (*true_connect)(int  , struct sockaddr  const  * , socklen_t  ) ;
struct hostent *proxy_gethostbyname(char const   *name , struct gethostbyname_data *data ) ;
struct hostent *proxy_gethostbyname_old(char const   *name ) ;
int proxy_getaddrinfo(char const   *node , char const   *service , struct addrinfo  const  *hints ,
                      struct addrinfo **res ) ;
void proxy_freeaddrinfo(struct addrinfo *res ) ;
void core_initialize(void) ;
void core_unload(void) ;
int pc_isnumericipv4(char const   *ipstring ) ;
size_t rdns_get_host_for_ip(ip_type4 ip , char *readbuf ) ;
ip_type4 rdns_get_ip_for_host(char *host , size_t len ) ;
enum dns_lookup_flavor proxychains_resolver ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
int tcp_read_time_out ;
int tcp_connect_time_out ;
int proxychains_quiet_mode ;
unsigned int proxychains_proxy_offset ;
unsigned int remote_dns_subnet ;
static int poll_retry(struct pollfd *fds , nfds_t nfsd , int timeout ) 
{ 
  int ret ;
  int time_remain ;
  int time_elapsed ;
  struct timeval start_time ;
  struct timeval tv ;
  int *tmp ;

  {
  time_remain = timeout;
  time_elapsed = 0;
  gettimeofday((struct timeval * __restrict  )(& start_time), (void * __restrict  )((void *)0));
  while (1) {
    ret = poll(fds, nfsd, time_remain);
    gettimeofday((struct timeval * __restrict  )(& tv), (void * __restrict  )((void *)0));
    time_elapsed = (int )((tv.tv_sec - start_time.tv_sec) * 1000L + (tv.tv_usec - start_time.tv_usec) / 1000L);
    time_remain = timeout - time_elapsed;
    if (ret == -1) {
      tmp = __errno_location();
      if (*tmp == 4) {
        if (! (time_remain > 0)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
  }
  return (ret);
}
}
static void encode_base_64(char *src , char *dest , int max_len ) ;
static char const   base64[65]  = 
  {      (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'g',      (char const   )'h',      (char const   )'i',      (char const   )'j', 
        (char const   )'k',      (char const   )'l',      (char const   )'m',      (char const   )'n', 
        (char const   )'o',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'+',      (char const   )'/', 
        (char const   )'\000'};
static void encode_base_64(char *src , char *dest , int max_len ) 
{ 
  int n ;
  int l ;
  int i ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;

  {
  tmp = strlen((char const   *)src);
  l = (int )tmp;
  max_len = (max_len - 1) / 4;
  i = 0;
  while (i < max_len) {
    switch (l) {
    case 0: 
    break;
    case 1: 
    n = (int )*(src + 0) << 16;
    tmp___0 = dest;
    dest ++;
    *tmp___0 = (char )base64[(n >> 18) & 63];
    tmp___1 = dest;
    dest ++;
    *tmp___1 = (char )base64[(n >> 12) & 63];
    tmp___2 = dest;
    dest ++;
    *tmp___2 = (char )'=';
    tmp___3 = dest;
    dest ++;
    *tmp___3 = (char )'=';
    break;
    case 2: 
    n = ((int )*(src + 0) << 16) | ((int )*(src + 1) << 8);
    tmp___4 = dest;
    dest ++;
    *tmp___4 = (char )base64[(n >> 18) & 63];
    tmp___5 = dest;
    dest ++;
    *tmp___5 = (char )base64[(n >> 12) & 63];
    tmp___6 = dest;
    dest ++;
    *tmp___6 = (char )base64[(n >> 6) & 63];
    tmp___7 = dest;
    dest ++;
    *tmp___7 = (char )'=';
    break;
    default: 
    n = (((int )*(src + 0) << 16) | ((int )*(src + 1) << 8)) | (int )*(src + 2);
    tmp___8 = dest;
    dest ++;
    *tmp___8 = (char )base64[(n >> 18) & 63];
    tmp___9 = dest;
    dest ++;
    *tmp___9 = (char )base64[(n >> 12) & 63];
    tmp___10 = dest;
    dest ++;
    *tmp___10 = (char )base64[(n >> 6) & 63];
    tmp___11 = dest;
    dest ++;
    *tmp___11 = (char )base64[n & 63];
    }
    if (l < 3) {
      break;
    }
    i ++;
    src += 3;
    l -= 3;
  }
  tmp___12 = dest;
  dest ++;
  *tmp___12 = (char)0;
  return;
}
}
void proxychains_write_log(char *str  , ...) 
{ 
  char buff[4096] ;
  va_list___0 arglist ;

  {
  if (! proxychains_quiet_mode) {
    __builtin_va_start(arglist, str);
    vsnprintf((char * __restrict  )(buff), sizeof(buff), (char const   * __restrict  )str,
              arglist);
    __builtin_va_end(arglist);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s", buff);
    fflush(stderr);
  }
  return;
}
}
static int write_n_bytes(int fd , char *buff , size_t size ) 
{ 
  int i ;
  size_t wrote ;
  ssize_t tmp ;

  {
  i = 0;
  wrote = (size_t )0;
  while (1) {
    tmp = write(fd, (void const   *)(buff + wrote), size - wrote);
    i = (int )tmp;
    if (i <= 0) {
      return (i);
    }
    wrote += (size_t )i;
    if (wrote == size) {
      return ((int )wrote);
    }
  }
}
}
static int read_n_bytes(int fd , char *buff , size_t size ) 
{ 
  int ready ;
  size_t i ;
  struct pollfd pfd[1] ;
  ssize_t tmp ;

  {
  pfd[0].fd = fd;
  pfd[0].events = (short)1;
  i = (size_t )0;
  while (i < size) {
    pfd[0].revents = (short)0;
    ready = poll_retry(pfd, (nfds_t )1, tcp_read_time_out);
    if (ready != 1) {
      return (-1);
    } else
    if (! ((int )pfd[0].revents & 1)) {
      return (-1);
    } else {
      tmp = read(fd, (void *)(buff + i), (size_t )1);
      if (1L != tmp) {
        return (-1);
      }
    }
    i ++;
  }
  return ((int )size);
}
}
static int timed_connect(int sock , struct sockaddr  const  *addr , socklen_t len ) 
{ 
  int ret ;
  int value ;
  socklen_t value_len ;
  struct pollfd pfd[1] ;
  int *tmp ;

  {
  while (1) {
    while (1) {
      break;
    }
    break;
  }
  pfd[0].fd = sock;
  pfd[0].events = (short)4;
  fcntl(sock, 4, 2048);
  ret = (*true_connect)(sock, addr, len);
  while (1) {
    break;
  }
  if (ret == -1) {
    tmp = __errno_location();
    if (*tmp == 115) {
      ret = poll_retry(pfd, (nfds_t )1, tcp_connect_time_out);
      while (1) {
        break;
      }
      if (ret == 1) {
        value_len = (socklen_t )sizeof(socklen_t );
        getsockopt(sock, 1, 4, (void * __restrict  )(& value), (socklen_t * __restrict  )(& value_len));
        while (1) {
          break;
        }
        if (! value) {
          ret = 0;
        } else {
          ret = -1;
        }
      } else {
        ret = -1;
      }
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (ret != 0) {
    ret = -1;
  }
  fcntl(sock, 4, 0);
  return (ret);
}
}
static int tunnel_to(int sock , ip_type ip , unsigned short port , proxy_type pt ,
                     char *user , char *pass ) 
{ 
  char *dns_name ;
  char hostnamebuf[256] ;
  size_t dns_len ;
  size_t ulen ;
  size_t tmp ;
  size_t passlen ;
  size_t tmp___0 ;
  int len ;
  unsigned char buff[1024] ;
  char ip_buf[46] ;
  int v6 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char src[512] ;
  char dst[2048] ;
  uint16_t hs_port ;
  uint16_t tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  ssize_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int n_methods ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char in[2] ;
  char out[515] ;
  char *cur ;
  size_t c ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int buff_iter ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;

  {
  dns_name = (char *)((void *)0);
  dns_len = (size_t )0;
  while (1) {
    while (1) {
      break;
    }
    break;
  }
  if (! ip.is_v6) {
    if ((unsigned int )proxychains_resolver >= 2U) {
      if ((unsigned int )ip.addr.v4.octet[0] == remote_dns_subnet) {
        dns_len = rdns_get_host_for_ip(ip.addr.v4, hostnamebuf);
        if (! dns_len) {
          goto err;
        } else {
          dns_name = hostnamebuf;
        }
      }
    }
  }
  while (1) {
    break;
  }
  tmp = strlen((char const   *)user);
  ulen = tmp;
  tmp___0 = strlen((char const   *)pass);
  passlen = tmp___0;
  if (ulen > 255UL) {
    proxychains_write_log((char *)"[proxychains] error: maximum size of 255 for user/pass or domain name!\n");
    goto err;
  } else
  if (passlen > 255UL) {
    proxychains_write_log((char *)"[proxychains] error: maximum size of 255 for user/pass or domain name!\n");
    goto err;
  } else
  if (dns_len > 255UL) {
    proxychains_write_log((char *)"[proxychains] error: maximum size of 255 for user/pass or domain name!\n");
    goto err;
  }
  v6 = (int )ip.is_v6;
  switch ((unsigned int )pt) {
  case 3U: 
  return (0);
  break;
  case 0U: 
  if (! dns_len) {
    if (v6) {
      tmp___1 = 10;
    } else {
      tmp___1 = 2;
    }
    tmp___2 = inet_ntop(tmp___1, (void const   * __restrict  )(ip.addr.v6), (char * __restrict  )(ip_buf),
                        (socklen_t )sizeof(ip_buf));
    if (! tmp___2) {
      proxychains_write_log((char *)"[proxychains] error: ip address conversion failed\n");
      goto err;
    }
    dns_name = ip_buf;
  }
  if (ulen) {
    snprintf((char * __restrict  )(src), sizeof(src), (char const   * __restrict  )"%s:%s",
             user, pass);
    encode_base_64(src, dst, (int )sizeof(dst));
  } else {
    dst[0] = (char)0;
  }
  tmp___3 = ntohs(port);
  hs_port = tmp___3;
  if (ulen) {
    tmp___4 = "\r\n";
  } else {
    tmp___4 = (char const   *)(dst);
  }
  if (ulen) {
    tmp___5 = "Proxy-Authorization: Basic ";
  } else {
    tmp___5 = (char const   *)(dst);
  }
  len = snprintf((char * __restrict  )((char *)(buff)), sizeof(buff), (char const   * __restrict  )"CONNECT %s:%d HTTP/1.0\r\nHost: %s:%d\r\n%s%s%s\r\n",
                 dns_name, (int )hs_port, dns_name, (int )hs_port, tmp___5, dst, tmp___4);
  if (len < 0) {
    goto err;
  } else {
    tmp___6 = send(sock, (void const   *)(buff), (size_t )len, 0);
    if ((ssize_t )len != tmp___6) {
      goto err;
    }
  }
  len = 0;
  while (len < 1024) {
    tmp___7 = read_n_bytes(sock, (char *)(buff + len), (size_t )1);
    if (1 == tmp___7) {
      len ++;
    } else {
      goto err;
    }
    if (len > 4) {
      if ((int )buff[len - 1] == 10) {
        if ((int )buff[len - 2] == 13) {
          if ((int )buff[len - 3] == 10) {
            if ((int )buff[len - 4] == 13) {
              break;
            }
          }
        }
      }
    }
  }
  if (len == 1024) {
    goto _L___1;
  } else
  if ((int )buff[9] == 50) {
    if ((int )buff[10] == 48) {
      if (! ((int )buff[11] == 48)) {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    while (1) {
      break;
    }
    return (5);
  }
  return (0);
  break;
  case 1U: 
  if (v6) {
    proxychains_write_log((char *)"[proxychains] error: SOCKS4 doesn\'t support ipv6 addresses\n");
    goto err;
  }
  buff[0] = (unsigned char)4;
  buff[1] = (unsigned char)1;
  memcpy((void * __restrict  )(& buff[2]), (void const   * __restrict  )(& port),
         (size_t )2);
  if (dns_len) {
    ip.addr.v4.octet[0] = (unsigned char)0;
    ip.addr.v4.octet[1] = (unsigned char)0;
    ip.addr.v4.octet[2] = (unsigned char)0;
    ip.addr.v4.octet[3] = (unsigned char)1;
  }
  memcpy((void * __restrict  )(& buff[4]), (void const   * __restrict  )(& ip.addr.v4),
         (size_t )4);
  len = (int )(ulen + 1UL);
  if (len > 1) {
    memcpy((void * __restrict  )(& buff[8]), (void const   * __restrict  )user, (size_t )len);
  } else {
    buff[8] = (unsigned char)0;
  }
  if (dns_len) {
    memcpy((void * __restrict  )(& buff[8 + len]), (void const   * __restrict  )dns_name,
           dns_len + 1UL);
    len = (int )((size_t )len + (dns_len + 1UL));
  }
  tmp___8 = write_n_bytes(sock, (char *)(buff), (size_t )(8 + len));
  if (len + 8 != tmp___8) {
    goto err;
  }
  tmp___9 = read_n_bytes(sock, (char *)(buff), (size_t )8);
  if (8 != tmp___9) {
    goto err;
  }
  if ((int )buff[0] != 0) {
    return (5);
  } else
  if ((int )buff[1] != 90) {
    return (5);
  }
  return (0);
  break;
  case 2U: 
  if (ulen) {
    tmp___10 = 2;
  } else {
    tmp___10 = 1;
  }
  n_methods = tmp___10;
  buff[0] = (unsigned char)5;
  buff[1] = (unsigned char )n_methods;
  buff[2] = (unsigned char)0;
  if (ulen) {
    buff[3] = (unsigned char)2;
  }
  tmp___11 = write_n_bytes(sock, (char *)(buff), (size_t )(2 + n_methods));
  if (2 + n_methods != tmp___11) {
    goto err;
  }
  tmp___12 = read_n_bytes(sock, (char *)(buff), (size_t )2);
  if (2 != tmp___12) {
    goto err;
  }
  if ((int )buff[0] != 5) {
    goto _L___2;
  } else
  if ((int )buff[1] != 0) {
    if ((int )buff[1] != 2) {
      _L___2: /* CIL Label */ 
      if ((int )buff[0] == 5) {
        if ((int )buff[1] == 255) {
          return (5);
        } else {
          goto err;
        }
      } else {
        goto err;
      }
    }
  }
  if ((int )buff[1] == 2) {
    cur = out;
    tmp___13 = cur;
    cur ++;
    *tmp___13 = (char)1;
    c = ulen & 255UL;
    tmp___14 = cur;
    cur ++;
    *tmp___14 = (char )c;
    memcpy((void * __restrict  )cur, (void const   * __restrict  )user, c);
    cur += c;
    c = passlen & 255UL;
    tmp___15 = cur;
    cur ++;
    *tmp___15 = (char )c;
    memcpy((void * __restrict  )cur, (void const   * __restrict  )pass, c);
    cur += c;
    tmp___16 = write_n_bytes(sock, out, (size_t )(cur - out));
    if (cur - out != (long )tmp___16) {
      goto err;
    }
    tmp___17 = read_n_bytes(sock, in, (size_t )2);
    if (2 != tmp___17) {
      goto err;
    }
    if (! ((int )in[0] == 5)) {
      if (! ((int )in[0] == 1)) {
        goto err;
      }
    }
    if ((int )in[1] != 0) {
      return (5);
    }
  }
  buff_iter = 0;
  tmp___18 = buff_iter;
  buff_iter ++;
  buff[tmp___18] = (unsigned char)5;
  tmp___19 = buff_iter;
  buff_iter ++;
  buff[tmp___19] = (unsigned char)1;
  tmp___20 = buff_iter;
  buff_iter ++;
  buff[tmp___20] = (unsigned char)0;
  if (! dns_len) {
    tmp___21 = buff_iter;
    buff_iter ++;
    if (v6) {
      buff[tmp___21] = (unsigned char)4;
    } else {
      buff[tmp___21] = (unsigned char)1;
    }
    if (v6) {
      tmp___22 = 16;
    } else {
      tmp___22 = 4;
    }
    memcpy((void * __restrict  )(buff + buff_iter), (void const   * __restrict  )(ip.addr.v6),
           (size_t )tmp___22);
    if (v6) {
      tmp___23 = 16;
    } else {
      tmp___23 = 4;
    }
    buff_iter += tmp___23;
  } else {
    tmp___24 = buff_iter;
    buff_iter ++;
    buff[tmp___24] = (unsigned char)3;
    tmp___25 = buff_iter;
    buff_iter ++;
    buff[tmp___25] = (unsigned char )(dns_len & 255UL);
    memcpy((void * __restrict  )(buff + buff_iter), (void const   * __restrict  )dns_name,
           dns_len);
    buff_iter = (int )((size_t )buff_iter + dns_len);
  }
  memcpy((void * __restrict  )(buff + buff_iter), (void const   * __restrict  )(& port),
         (size_t )2);
  buff_iter += 2;
  tmp___26 = write_n_bytes(sock, (char *)(buff), (size_t )buff_iter);
  if (buff_iter != tmp___26) {
    goto err;
  }
  tmp___27 = read_n_bytes(sock, (char *)(buff), (size_t )4);
  if (4 != tmp___27) {
    goto err;
  }
  if ((int )buff[0] != 5) {
    goto err;
  } else
  if ((int )buff[1] != 0) {
    goto err;
  }
  switch ((int )buff[3]) {
  case 1: 
  len = 4;
  break;
  case 4: 
  len = 16;
  break;
  case 3: 
  len = 0;
  tmp___28 = read_n_bytes(sock, (char *)(& len), (size_t )1);
  if (1 != tmp___28) {
    goto err;
  }
  break;
  default: 
  goto err;
  }
  tmp___29 = read_n_bytes(sock, (char *)(buff), (size_t )(len + 2));
  if (len + 2 != tmp___29) {
    goto err;
  }
  return (0);
  break;
  }
  err: 
  return (2);
}
}
static int start_chain(int *fd , proxy_data *pd , char *begin_mark ) 
{ 
  int v6 ;
  int tmp ;
  char ip_buf[46] ;
  int tmp___0 ;
  char const   *tmp___1 ;
  uint16_t tmp___2 ;
  struct sockaddr_in addr ;
  struct sockaddr_in6 addr6 ;
  unsigned long tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;

  {
  v6 = (int )pd->ip.is_v6;
  if (v6) {
    tmp = 10;
  } else {
    tmp = 2;
  }
  *fd = socket(tmp, 1, 0);
  if (*fd == -1) {
    goto error;
  }
  if (v6) {
    tmp___0 = 10;
  } else {
    tmp___0 = 2;
  }
  tmp___1 = inet_ntop(tmp___0, (void const   * __restrict  )(pd->ip.addr.v6), (char * __restrict  )(ip_buf),
                      (socklen_t )sizeof(ip_buf));
  if (! tmp___1) {
    goto error;
  }
  tmp___2 = htons(pd->port);
  proxychains_write_log((char *)"[proxychains] %s  ...  %s:%d ", begin_mark, ip_buf,
                        (int )tmp___2);
  pd->ps = (proxy_state )0;
  addr.sin_family = (sa_family_t )2;
  addr.sin_port = pd->port;
  addr.sin_addr.s_addr = pd->ip.addr.v4.as_int;
  addr.sin_zero[0] = (unsigned char)0;
  addr.sin_zero[1] = (unsigned char)0;
  addr.sin_zero[2] = (unsigned char)0;
  addr.sin_zero[3] = (unsigned char)0;
  addr.sin_zero[4] = (unsigned char)0;
  addr.sin_zero[5] = (unsigned char)0;
  addr.sin_zero[6] = (unsigned char)0;
  addr.sin_zero[7] = (unsigned char)0;
  addr6.sin6_family = (sa_family_t )10;
  addr6.sin6_port = pd->port;
  addr6.sin6_flowinfo = 0U;
  addr6.sin6_addr.__in6_u.__u6_addr8[0] = (unsigned char)0;
  addr6.sin6_addr.__in6_u.__u6_addr8[1] = (unsigned char)0;
  addr6.sin6_addr.__in6_u.__u6_addr8[2] = (unsigned char)0;
  addr6.sin6_addr.__in6_u.__u6_addr8[3] = (unsigned char)0;
  addr6.sin6_addr.__in6_u.__u6_addr8[4] = (unsigned char)0;
  addr6.sin6_addr.__in6_u.__u6_addr8[5] = (unsigned char)0;
  addr6.sin6_addr.__in6_u.__u6_addr8[6] = (unsigned char)0;
  addr6.sin6_addr.__in6_u.__u6_addr8[7] = (unsigned char)0;
  addr6.sin6_addr.__in6_u.__u6_addr8[8] = (unsigned char)0;
  addr6.sin6_addr.__in6_u.__u6_addr8[9] = (unsigned char)0;
  addr6.sin6_addr.__in6_u.__u6_addr8[10] = (unsigned char)0;
  addr6.sin6_addr.__in6_u.__u6_addr8[11] = (unsigned char)0;
  addr6.sin6_addr.__in6_u.__u6_addr8[12] = (unsigned char)0;
  addr6.sin6_addr.__in6_u.__u6_addr8[13] = (unsigned char)0;
  addr6.sin6_addr.__in6_u.__u6_addr8[14] = (unsigned char)0;
  addr6.sin6_addr.__in6_u.__u6_addr8[15] = (unsigned char)0;
  addr6.sin6_scope_id = 0U;
  if (v6) {
    memcpy((void * __restrict  )(& addr6.sin6_addr.__in6_u.__u6_addr8), (void const   * __restrict  )(pd->ip.addr.v6),
           (size_t )16);
  }
  if (v6) {
    tmp___3 = sizeof(addr6);
  } else {
    tmp___3 = sizeof(addr);
  }
  if (v6) {
    tmp___4 = (void *)(& addr6);
  } else {
    tmp___4 = (void *)(& addr);
  }
  tmp___5 = timed_connect(*fd, (struct sockaddr  const  *)((struct sockaddr *)tmp___4),
                          (socklen_t )tmp___3);
  if (tmp___5) {
    pd->ps = (proxy_state )1;
    goto error1;
  }
  pd->ps = (proxy_state )3;
  return (0);
  error1: 
  proxychains_write_log((char *)" ...  timeout\n");
  error: 
  if (*fd != -1) {
    close(*fd);
  }
  return (2);
}
}
static proxy_data *select_proxy(select_type how , proxy_data *pd , unsigned int proxy_count ,
                                unsigned int *offset ) 
{ 
  unsigned int i ;
  unsigned int k ;
  int tmp ;
  proxy_data *tmp___0 ;

  {
  i = 0U;
  k = 0U;
  if (*offset >= proxy_count) {
    return ((proxy_data *)((void *)0));
  }
  switch ((unsigned int )how) {
  case 0U: 
  while (1) {
    k ++;
    tmp = rand();
    i = (unsigned int )tmp % proxy_count;
    if ((unsigned int )(pd + i)->ps != 0U) {
      if (! (k < proxy_count * 100U)) {
        break;
      }
    } else {
      break;
    }
  }
  break;
  case 1U: 
  i = *offset;
  while (i < proxy_count) {
    if ((unsigned int )(pd + i)->ps == 0U) {
      *offset = i;
      break;
    }
    i ++;
  }
  default: 
  break;
  }
  if (i >= proxy_count) {
    i = 0U;
  }
  if ((unsigned int )(pd + i)->ps == 0U) {
    tmp___0 = pd + i;
  } else {
    tmp___0 = (proxy_data *)((void *)0);
  }
  return (tmp___0);
}
}
static void release_all(proxy_data *pd , unsigned int proxy_count ) 
{ 
  unsigned int i ;

  {
  i = 0U;
  while (i < proxy_count) {
    (pd + i)->ps = (proxy_state )0;
    i ++;
  }
  return;
}
}
static void release_busy(proxy_data *pd , unsigned int proxy_count ) 
{ 
  unsigned int i ;

  {
  i = 0U;
  while (i < proxy_count) {
    if ((unsigned int )(pd + i)->ps == 3U) {
      (pd + i)->ps = (proxy_state )0;
    }
    i ++;
  }
  return;
}
}
static unsigned int calc_alive(proxy_data *pd , unsigned int proxy_count ) 
{ 
  unsigned int i ;
  int alive_count ;

  {
  alive_count = 0;
  release_busy(pd, proxy_count);
  i = 0U;
  while (i < proxy_count) {
    if ((unsigned int )(pd + i)->ps == 0U) {
      alive_count ++;
    }
    i ++;
  }
  return ((unsigned int )alive_count);
}
}
static int chain_step(int ns , proxy_data *pfrom , proxy_data *pto ) 
{ 
  int retcode ;
  char *hostname ;
  char hostname_buf[256] ;
  char ip_buf[46] ;
  int v6 ;
  size_t tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  uint16_t tmp___2 ;

  {
  retcode = -1;
  v6 = (int )pto->ip.is_v6;
  while (1) {
    while (1) {
      break;
    }
    break;
  }
  if (! v6) {
    if ((unsigned int )proxychains_resolver >= 2U) {
      if ((unsigned int )pto->ip.addr.v4.octet[0] == remote_dns_subnet) {
        tmp = rdns_get_host_for_ip(pto->ip.addr.v4, hostname_buf);
        if (tmp) {
          hostname = hostname_buf;
        } else {
          goto usenumericip;
        }
      } else {
        goto usenumericip;
      }
    } else {
      goto usenumericip;
    }
  } else {
    usenumericip: 
    if (v6) {
      tmp___0 = 10;
    } else {
      tmp___0 = 2;
    }
    tmp___1 = inet_ntop(tmp___0, (void const   * __restrict  )(pto->ip.addr.v6), (char * __restrict  )(ip_buf),
                        (socklen_t )sizeof(ip_buf));
    if (! tmp___1) {
      pto->ps = (proxy_state )1;
      proxychains_write_log((char *)"<--ip conversion error!\n");
      close(ns);
      return (2);
    }
    hostname = ip_buf;
  }
  tmp___2 = htons(pto->port);
  proxychains_write_log((char *)" ...  %s:%d ", hostname, (int )tmp___2);
  retcode = tunnel_to(ns, pto->ip, pto->port, pfrom->pt, pfrom->user, pfrom->pass);
  switch (retcode) {
  case 0: 
  pto->ps = (proxy_state )3;
  break;
  case 5: 
  pto->ps = (proxy_state )2;
  proxychains_write_log((char *)"<--denied\n");
  close(ns);
  break;
  case 2: 
  pto->ps = (proxy_state )1;
  proxychains_write_log((char *)"<--socket error or timeout!\n");
  close(ns);
  break;
  }
  return (retcode);
}
}
int connect_proxy_chain(int sock , ip_type target_ip , unsigned short target_port ,
                        proxy_data *pd , unsigned int proxy_count , chain_type ct ,
                        unsigned int max_chain ) 
{ 
  proxy_data p4 ;
  proxy_data *p1 ;
  proxy_data *p2 ;
  proxy_data *p3 ;
  int ns ;
  int rc ;
  unsigned int offset ;
  unsigned int alive_count ;
  unsigned int curr_len ;
  unsigned int looped ;
  unsigned int rr_loop_max ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;

  {
  ns = -1;
  rc = -1;
  offset = 0U;
  alive_count = 0U;
  curr_len = 0U;
  looped = 0U;
  rr_loop_max = 14U;
  p3 = & p4;
  while (1) {
    while (1) {
      break;
    }
    break;
  }
  again: 
  rc = -1;
  while (1) {
    break;
  }
  switch ((unsigned int )ct) {
  case 0U: 
  alive_count = calc_alive(pd, proxy_count);
  offset = 0U;
  while (1) {
    p1 = select_proxy((select_type )1, pd, proxy_count, & offset);
    if (! p1) {
      goto error_more;
    }
    tmp = start_chain(& ns, p1, (char *)"Dynamic chain");
    if (0 != tmp) {
      if (! (offset < proxy_count)) {
        break;
      }
    } else {
      break;
    }
  }
  while (1) {
    p2 = select_proxy((select_type )1, pd, proxy_count, & offset);
    if (! p2) {
      break;
    }
    tmp___0 = chain_step(ns, p1, p2);
    if (0 != tmp___0) {
      while (1) {
        break;
      }
      goto again;
    }
    p1 = p2;
  }
  p3->ip = target_ip;
  p3->port = target_port;
  tmp___1 = chain_step(ns, p1, p3);
  if (0 != tmp___1) {
    goto error;
  }
  break;
  case 3U: 
  alive_count = calc_alive(pd, proxy_count);
  offset = proxychains_proxy_offset;
  if (alive_count < max_chain) {
    goto error_more;
  }
  while (1) {
    break;
  }
  while (rc != 0) {
    p1 = select_proxy((select_type )1, pd, proxy_count, & offset);
    if (! p1) {
      offset = 0U;
      looped ++;
      if (looped > rr_loop_max) {
        proxychains_proxy_offset = 0U;
        goto error_more;
      } else {
        while (1) {
          break;
        }
        release_all(pd, proxy_count);
        usleep(10000U * looped);
        goto __Cont;
      }
    }
    while (1) {
      break;
    }
    rc = start_chain(& ns, p1, (char *)"Round Robin chain");
    __Cont: /* CIL Label */ ;
  }
  curr_len = 1U;
  while (curr_len < max_chain) {
    while (1) {
      break;
    }
    p2 = select_proxy((select_type )1, pd, proxy_count, & offset);
    if (! p2) {
      offset = 0U;
      goto __Cont___0;
    } else {
      tmp___2 = chain_step(ns, p1, p2);
      if (0 != tmp___2) {
        while (1) {
          break;
        }
        goto again;
      } else {
        p1 = p2;
      }
    }
    curr_len ++;
    __Cont___0: /* CIL Label */ ;
  }
  p3->ip = target_ip;
  p3->port = target_port;
  proxychains_proxy_offset = offset + 1U;
  while (1) {
    break;
  }
  tmp___3 = chain_step(ns, p1, p3);
  if (0 != tmp___3) {
    goto error;
  }
  break;
  case 1U: 
  alive_count = calc_alive(pd, proxy_count);
  offset = 0U;
  p1 = select_proxy((select_type )1, pd, proxy_count, & offset);
  if (! p1) {
    while (1) {
      break;
    }
    goto error_strict;
  }
  tmp___4 = start_chain(& ns, p1, (char *)"Strict chain");
  if (0 != tmp___4) {
    while (1) {
      break;
    }
    goto error_strict;
  }
  while (offset < proxy_count) {
    p2 = select_proxy((select_type )1, pd, proxy_count, & offset);
    if (! p2) {
      break;
    }
    tmp___5 = chain_step(ns, p1, p2);
    if (0 != tmp___5) {
      while (1) {
        break;
      }
      goto error_strict;
    }
    p1 = p2;
  }
  p3->ip = target_ip;
  p3->port = target_port;
  tmp___6 = chain_step(ns, p1, p3);
  if (0 != tmp___6) {
    goto error;
  }
  break;
  case 2U: 
  alive_count = calc_alive(pd, proxy_count);
  if (alive_count < max_chain) {
    goto error_more;
  }
  offset = 0U;
  curr_len = offset;
  while (1) {
    p1 = select_proxy((select_type )0, pd, proxy_count, & offset);
    if (! p1) {
      goto error_more;
    }
    tmp___7 = start_chain(& ns, p1, (char *)"Random chain");
    if (0 != tmp___7) {
      if (! (offset < max_chain)) {
        break;
      }
    } else {
      break;
    }
  }
  while (1) {
    curr_len ++;
    if (! (curr_len < max_chain)) {
      break;
    }
    p2 = select_proxy((select_type )0, pd, proxy_count, & offset);
    if (! p2) {
      goto error_more;
    }
    tmp___8 = chain_step(ns, p1, p2);
    if (0 != tmp___8) {
      while (1) {
        break;
      }
      goto again;
    }
    p1 = p2;
  }
  p3->ip = target_ip;
  p3->port = target_port;
  tmp___9 = chain_step(ns, p1, p3);
  if (0 != tmp___9) {
    goto error;
  }
  }
  proxychains_write_log((char *)" ...  OK\n");
  dup2(ns, sock);
  close(ns);
  return (0);
  error: 
  if (ns != -1) {
    close(ns);
  }
  tmp___10 = __errno_location();
  *tmp___10 = 111;
  return (-1);
  error_more: 
  proxychains_write_log((char *)"\n!!!need more proxies!!!\n");
  error_strict: 
  while (1) {
    break;
  }
  release_all(pd, proxy_count);
  if (ns != -1) {
    close(ns);
  }
  tmp___11 = __errno_location();
  *tmp___11 = 110;
  return (-1);
}
}
static pthread_mutex_t servbyname_lock  ;
void core_initialize(void) 
{ 


  {
  pthread_mutex_init(& servbyname_lock, (pthread_mutexattr_t const   *)((void *)0));
  return;
}
}
void core_unload(void) 
{ 


  {
  pthread_mutex_destroy(& servbyname_lock);
  return;
}
}
static void gethostbyname_data_setstring(struct gethostbyname_data *data , char *name ) 
{ 


  {
  snprintf((char * __restrict  )(data->addr_name), sizeof(data->addr_name), (char const   * __restrict  )"%s",
           name);
  data->hostent_space.h_name = data->addr_name;
  return;
}
}
ip_type4 hostsreader_get_numeric_ip_for_name(char const   *name ) ;
static struct hostent hostent_space  ;
static in_addr_t resolved_addr  ;
static char *resolved_addr_p  ;
static char addr_name[256]  ;
struct hostent *proxy_gethostbyname_old(char const   *name ) 
{ 
  int pipe_fd[2] ;
  char buff[256] ;
  in_addr_t addr ;
  pid_t pid ;
  int status ;
  int ret ;
  size_t l ;
  struct hostent *hp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  hostent_space.h_addr_list = & resolved_addr_p;
  *(hostent_space.h_addr_list) = (char *)(& resolved_addr);
  resolved_addr = (in_addr_t )0;
  tmp = pc_isnumericipv4(name);
  if (tmp) {
    strcpy((char * __restrict  )(buff), (char const   * __restrict  )name);
    goto got_buff;
  }
  gethostname(buff, sizeof(buff));
  tmp___0 = strcmp((char const   *)(buff), name);
  if (! tmp___0) {
    goto got_buff;
  }
  memset((void *)(buff), 0, sizeof(buff));
  while (1) {
    hp = gethostent();
    if (! hp) {
      break;
    }
    tmp___1 = strcmp((char const   *)hp->h_name, name);
    if (! tmp___1) {
      return (hp);
    }
  }
  ret = pipe2((int *)(pipe_fd), 524288);
  if (ret) {
    goto err;
  }
  pid = fork();
  switch (pid) {
  case 0: 
  proxychains_write_log((char *)"|DNS-request| %s \n", name);
  close(pipe_fd[0]);
  dup2(pipe_fd[1], 1);
  close(pipe_fd[1]);
  execlp("proxyresolv", "proxyresolv", name, (void *)0);
  perror("can\'t exec proxyresolv");
  exit(2);
  case -1: 
  close(pipe_fd[0]);
  close(pipe_fd[1]);
  perror("can\'t fork");
  goto err;
  default: 
  close(pipe_fd[1]);
  waitpid(pid, & status, 0);
  buff[0] = (char)0;
  read(pipe_fd[0], (void *)(& buff), sizeof(buff));
  close(pipe_fd[0]);
  got_buff: 
  l = strlen((char const   *)(buff));
  if (l) {
    if ((int )buff[l - 1UL] == 10) {
      buff[l - 1UL] = (char)0;
    }
  }
  addr = inet_addr((char const   *)(buff));
  if (addr == 4294967295U) {
    goto err_dns;
  }
  memcpy((void * __restrict  )*(hostent_space.h_addr_list), (void const   * __restrict  )(& addr),
         sizeof(struct in_addr ));
  hostent_space.h_name = addr_name;
  snprintf((char * __restrict  )(addr_name), sizeof(addr_name), (char const   * __restrict  )"%s",
           buff);
  hostent_space.h_length = (int )sizeof(in_addr_t );
  hostent_space.h_addrtype = 2;
  }
  tmp___2 = inet_ntoa(*((struct in_addr *)(& addr)));
  proxychains_write_log((char *)"|DNS-response| %s is %s\n", name, tmp___2);
  return (& hostent_space);
  err_dns: 
  proxychains_write_log((char *)"|DNS-response|: %s does not exist\n", name);
  perror("err_dns");
  err: 
  return ((struct hostent *)((void *)0));
}
}
struct hostent *proxy_gethostbyname(char const   *name , struct gethostbyname_data *data ) 
{ 
  char buff[256] ;
  int tmp ;
  ip_type4 __constr_expr_0 ;
  int tmp___0 ;
  ip_type4 hdb_res ;
  ip_type4 tmp___1 ;
  ip_type4 __constr_expr_1 ;
  size_t tmp___2 ;
  ip_type4 tmp___3 ;
  ip_type4 __constr_expr_2 ;

  {
  while (1) {
    while (1) {
      break;
    }
    break;
  }
  data->resolved_addr_p[0] = (char *)(& data->resolved_addr);
  data->resolved_addr_p[1] = (char *)((void *)0);
  data->hostent_space.h_addr_list = data->resolved_addr_p;
  data->hostent_space.h_aliases = & data->resolved_addr_p[1];
  data->resolved_addr = (in_addr_t )0;
  data->hostent_space.h_addrtype = 2;
  data->hostent_space.h_length = (int )sizeof(in_addr_t );
  tmp = pc_isnumericipv4(name);
  if (tmp) {
    data->resolved_addr = inet_addr(name);
    goto retname;
  }
  gethostname(buff, sizeof(buff));
  tmp___0 = strcmp((char const   *)(buff), name);
  if (! tmp___0) {
    data->resolved_addr = inet_addr((char const   *)(buff));
    if (data->resolved_addr == 4294967295U) {
      __constr_expr_0.octet[0] = (unsigned char)127;
      __constr_expr_0.octet[1] = (unsigned char)0;
      __constr_expr_0.octet[2] = (unsigned char)0;
      __constr_expr_0.octet[3] = (unsigned char)1;
      data->resolved_addr = __constr_expr_0.as_int;
    }
    goto retname;
  }
  tmp___1 = hostsreader_get_numeric_ip_for_name(name);
  hdb_res = tmp___1;
  __constr_expr_1.as_int = (uint32_t )-1;
  if (hdb_res.as_int != __constr_expr_1.as_int) {
    data->resolved_addr = hdb_res.as_int;
    goto retname;
  }
  tmp___2 = strlen(name);
  tmp___3 = rdns_get_ip_for_host((char *)name, tmp___2);
  data->resolved_addr = tmp___3.as_int;
  __constr_expr_2.as_int = (uint32_t )-1;
  if (data->resolved_addr == __constr_expr_2.as_int) {
    return ((struct hostent *)((void *)0));
  }
  retname: 
  gethostbyname_data_setstring(data, (char *)name);
  while (1) {
    break;
  }
  return (& data->hostent_space);
}
}
void proxy_freeaddrinfo(struct addrinfo *res ) 
{ 


  {
  while (1) {
    while (1) {
      break;
    }
    break;
  }
  free((void *)res);
  return;
}
}
static int mygetservbyname_r(char const   *name , char const   *proto , struct servent *result_buf ,
                             char *buf___0 , size_t buflen , struct servent **result ) 
{ 
  int tmp ;
  struct servent *res ;
  int ret ;

  {
  while (1) {
    while (1) {
      break;
    }
    break;
  }
  while (1) {
    break;
  }
  tmp = getservbyname_r((char const   * __restrict  )name, (char const   * __restrict  )proto,
                        (struct servent * __restrict  )result_buf, (char * __restrict  )buf___0,
                        buflen, (struct servent ** __restrict  )result);
  return (tmp);
  pthread_mutex_lock(& servbyname_lock);
  res = getservbyname(name, proto);
  if (res) {
    *result_buf = *res;
    *result = result_buf;
    ret = 0;
  } else {
    *result = (struct servent *)((void *)0);
    ret = 2;
  }
  pthread_mutex_unlock(& servbyname_lock);
  return (ret);
}
}
static int looks_like_numeric_ipv6(char const   *node ) 
{ 
  char *tmp ;
  char const   *p ;
  char const   *tmp___0 ;

  {
  tmp = strchr(node, ':');
  if (! tmp) {
    return (0);
  }
  p = node;
  while (1) {
    tmp___0 = p;
    p ++;
    switch ((int const   )*tmp___0) {
    case 0: 
    return (1);
    case 102: 
    case 101: 
    case 100: 
    case 99: 
    case 98: 
    case 97: 
    case 70: 
    case 69: 
    case 68: 
    case 67: 
    case 66: 
    case 65: 
    case 57: 
    case 56: 
    case 55: 
    case 54: 
    case 53: 
    case 52: 
    case 51: 
    case 50: 
    case 49: 
    case 48: 
    case 46: 
    case 58: 
    break;
    default: 
    return (0);
    }
  }
}
}
static int my_inet_aton(char const   *node , struct addrinfo_data *space ) 
{ 
  int ret ;
  int tmp ;

  {
  ((struct sockaddr_in *)(& space->sockaddr_space))->sin_family = (sa_family_t )2;
  ret = inet_aton(node, & ((struct sockaddr_in *)(& space->sockaddr_space))->sin_addr);
  if (ret) {
    return (ret);
  } else {
    tmp = looks_like_numeric_ipv6(node);
    if (! tmp) {
      return (ret);
    }
  }
  ret = inet_pton(10, (char const   * __restrict  )node, (void * __restrict  )(& ((struct sockaddr_in6 *)(& space->sockaddr_space))->sin6_addr));
  if (ret) {
    ((struct sockaddr_in6 *)(& space->sockaddr_space))->sin6_family = (sa_family_t )10;
  }
  return (ret);
}
}
int proxy_getaddrinfo(char const   *node , char const   *service , struct addrinfo  const  *hints ,
                      struct addrinfo **res ) 
{ 
  struct gethostbyname_data ghdata ;
  struct addrinfo_data *space ;
  struct servent *se ;
  struct hostent *hp ;
  struct servent se_buf ;
  struct addrinfo *p ;
  char buf___0[1024] ;
  int port ;
  int af ;
  void *tmp ;
  sa_family_t tmp___0 ;
  char __constr_expr_3[4] ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  uint16_t tmp___4 ;
  sa_family_t tmp___5 ;

  {
  se = (struct servent *)((void *)0);
  hp = (struct hostent *)((void *)0);
  af = 2;
  while (1) {
    break;
  }
  tmp = calloc((size_t )1, sizeof(struct addrinfo_data ));
  space = (struct addrinfo_data *)tmp;
  if (! space) {
    goto err1;
  }
  if (node) {
    tmp___1 = my_inet_aton(node, space);
    if (tmp___1) {
      goto _L;
    } else {
      if (hints) {
        if (hints->ai_flags & 4) {
          free((void *)space);
          return (-2);
        }
      }
      if ((unsigned int )proxychains_resolver == 1U) {
        hp = proxy_gethostbyname_old(node);
      } else {
        hp = proxy_gethostbyname(node, & ghdata);
      }
      if (hp) {
        memcpy((void * __restrict  )(& ((struct sockaddr_in *)(& space->sockaddr_space))->sin_addr),
               (void const   * __restrict  )*(hp->h_addr_list), sizeof(in_addr_t ));
      } else {
        goto err2;
      }
    }
  } else
  _L: /* CIL Label */ 
  if (node) {
    af = (int )((struct sockaddr_in *)(& space->sockaddr_space))->sin_family;
  } else
  if (! node) {
    if (! (hints->ai_flags & 1)) {
      tmp___0 = (sa_family_t )2;
      ((struct sockaddr_in *)(& space->sockaddr_space))->sin_family = tmp___0;
      af = (int )tmp___0;
      __constr_expr_3[0] = (char)127;
      __constr_expr_3[1] = (char)0;
      __constr_expr_3[2] = (char)0;
      __constr_expr_3[3] = (char)1;
      memcpy((void * __restrict  )(& ((struct sockaddr_in *)(& space->sockaddr_space))->sin_addr),
             (void const   * __restrict  )(__constr_expr_3), (size_t )4);
    }
  }
  if (service) {
    mygetservbyname_r(service, (char const   *)((void *)0), & se_buf, buf___0, sizeof(buf___0),
                      & se);
  }
  if (se) {
    port = se->s_port;
  } else {
    if (service) {
      tmp___2 = service;
    } else {
      tmp___2 = "0";
    }
    tmp___3 = atoi(tmp___2);
    tmp___4 = htons((uint16_t )tmp___3);
    port = (int )tmp___4;
  }
  if (af == 2) {
    ((struct sockaddr_in *)(& space->sockaddr_space))->sin_port = (in_port_t )port;
  } else {
    ((struct sockaddr_in6 *)(& space->sockaddr_space))->sin6_port = (in_port_t )port;
  }
  p = & space->addrinfo_space;
  *res = p;
  if (! ((size_t )p == (size_t )space)) {
    __assert_fail("(size_t)p == (size_t) space", "src/core.c", 1007U, "proxy_getaddrinfo");
  }
  p->ai_addr = (struct sockaddr *)((void *)(& space->sockaddr_space));
  if (node) {
    snprintf((char * __restrict  )(space->addr_name), sizeof(space->addr_name), (char const   * __restrict  )"%s",
             node);
  }
  p->ai_canonname = space->addr_name;
  p->ai_next = (struct addrinfo *)((void *)0);
  tmp___5 = (sa_family_t )af;
  space->sockaddr_space.ss_family = tmp___5;
  p->ai_family = (int )tmp___5;
  if (af == 2) {
    p->ai_addrlen = (socklen_t )sizeof(struct sockaddr_in );
  } else {
    p->ai_addrlen = (socklen_t )sizeof(struct sockaddr_in6 );
  }
  if (hints) {
    p->ai_socktype = (int )hints->ai_socktype;
    p->ai_flags = (int )hints->ai_flags;
    p->ai_protocol = (int )hints->ai_protocol;
    if (! p->ai_socktype) {
      if (p->ai_protocol == 6) {
        p->ai_socktype = 1;
      }
    }
  } else {
    p->ai_flags = 40;
  }
  goto out;
  err2: 
  free((void *)space);
  err1: 
  return (1);
  out: 
  return (0);
}
}
#pragma merger("0","/tmp/cil-vIio0epA.i","-Wno-unknown-pragmas,-Wall,-O0,-g,-std=c99,-pipe,-fPIC")
char const   *proxy_type_strmap[3] ;
char const   *chain_type_strmap[4] ;
char const   *proxy_state_strmap[4] ;
char *get_config_path(char *default_path , char *pbuf , size_t bufsize ) ;
void pc_stringfromipv4(unsigned char *ip_buf_4_bytes , char *outbuf_16_bytes ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) access)(char const   *__name ,
                                                                                   int __type ) ;
extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size ) ;
char const   *proxy_type_strmap[3]  = {      "http",      "socks4",      "socks5"};
char const   *chain_type_strmap[4]  = {      "dynamic_chain",      "strict_chain",      "random_chain",      "round_robin_chain"};
char const   *proxy_state_strmap[4]  = {      "play",      "down",      "blocked",      "busy"};
int pc_isnumericipv4(char const   *ipstring ) 
{ 
  size_t x ;
  size_t n ;
  size_t d ;
  int wasdot ;

  {
  x = (size_t )0;
  n = (size_t )0;
  d = (size_t )0;
  wasdot = 0;
  while (1) {
    switch ((int const   )*(ipstring + x)) {
    case 0: 
    goto done;
    case 46: 
    if (! n) {
      return (0);
    } else
    if (wasdot) {
      return (0);
    }
    d ++;
    wasdot = 1;
    break;
    case 57: 
    case 56: 
    case 55: 
    case 54: 
    case 53: 
    case 52: 
    case 51: 
    case 50: 
    case 49: 
    case 48: 
    n ++;
    wasdot = 0;
    break;
    default: 
    return (0);
    }
    x ++;
  }
  done: 
  if (d == 3UL) {
    if (n >= 4UL) {
      if (n <= 12UL) {
        return (1);
      }
    }
  }
  return (0);
}
}
void pc_stringfromipv4(unsigned char *ip_buf_4_bytes , char *outbuf_16_bytes ) 
{ 
  unsigned char *p ;
  char *o ;
  unsigned char n ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  o = outbuf_16_bytes;
  p = ip_buf_4_bytes;
  while ((unsigned long )p < (unsigned long )(ip_buf_4_bytes + 4)) {
    n = *p;
    if ((int )*p >= 100) {
      if ((int )*p >= 200) {
        tmp = o;
        o ++;
        *tmp = (char )'2';
      } else {
        tmp___0 = o;
        o ++;
        *tmp___0 = (char )'1';
      }
      n = (unsigned char )((int )n % 100);
    }
    if ((int )*p >= 10) {
      tmp___1 = o;
      o ++;
      *tmp___1 = (char )((int )n / 10 + 48);
      n = (unsigned char )((int )n % 10);
    }
    tmp___2 = o;
    o ++;
    *tmp___2 = (char )((int )n + 48);
    tmp___3 = o;
    o ++;
    *tmp___3 = (char )'.';
    p ++;
  }
  *(o + -1) = (char)0;
  return;
}
}
static int check_path(char *path ) 
{ 
  int tmp ;

  {
  if (! path) {
    return (0);
  }
  tmp = access((char const   *)path, 4);
  return (tmp != -1);
}
}
char *get_config_path(char *default_path , char *pbuf , size_t bufsize ) 
{ 
  char buf___0[512] ;
  char *path ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  path = default_path;
  tmp = check_path(path);
  if (tmp) {
    goto have;
  }
  path = getenv("PROXYCHAINS_CONF_FILE");
  tmp___0 = check_path(path);
  if (tmp___0) {
    goto have;
  }
  path = getcwd(buf___0, sizeof(buf___0));
  snprintf((char * __restrict  )pbuf, bufsize, (char const   * __restrict  )"%s/%s",
           path, "proxychains.conf");
  path = pbuf;
  tmp___1 = check_path(path);
  if (tmp___1) {
    goto have;
  }
  path = getenv("HOME");
  snprintf((char * __restrict  )pbuf, bufsize, (char const   * __restrict  )"%s/.proxychains/%s",
           path, "proxychains.conf");
  path = pbuf;
  tmp___2 = check_path(path);
  if (tmp___2) {
    goto have;
  }
  path = getenv("HOME");
  snprintf((char * __restrict  )pbuf, bufsize, (char const   * __restrict  )"%s/config/settings/%s",
           path, "proxychains.conf");
  path = pbuf;
  tmp___3 = check_path(path);
  if (tmp___3) {
    goto have;
  }
  path = (char *)"/usr/local/etc/proxychains.conf";
  tmp___4 = check_path(path);
  if (tmp___4) {
    goto have;
  }
  path = (char *)"/etc/proxychains.conf";
  tmp___5 = check_path(path);
  if (tmp___5) {
    goto have;
  }
  perror("couldnt find configuration file");
  exit(1);
  return ((char *)((void *)0));
  have: 
  return (path);
}
}
#pragma merger("0","/tmp/cil-XMKZmrn2.i","-Wno-unknown-pragmas,-Wall,-O0,-g,-std=c99,-pipe,-fPIC")
extern int fclose(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...)  __asm__("__isoc99_sscanf")  ;
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
int connect(int sock , struct sockaddr  const  * __restrict  addr , unsigned int len ) ;
ssize_t sendto(int sockfd , void const   *buf___0 , size_t len , int flags , struct sockaddr  const  * __restrict  dest_addr ,
               socklen_t addrlen ) ;
extern  __attribute__((__nothrow__)) uint32_t ntohl(uint32_t __netlong )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) uint32_t htonl(uint32_t __hostlong )  __attribute__((__const__)) ;
struct hostent *gethostbyaddr(void const   *addr , __socklen_t len , int type ) ;
struct hostent *gethostbyname(char const   *name ) ;
int getaddrinfo(char const   * __restrict  node , char const   * __restrict  service ,
                struct addrinfo  const  * __restrict  hints , struct addrinfo ** __restrict  res ) ;
 __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *res ) ;
int getnameinfo(struct sockaddr  const  * __restrict  sa , socklen_t salen , char * __restrict  host ,
                socklen_t hostlen , char * __restrict  serv , socklen_t servlen ,
                int flags ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(2))) dlsym)(void * __restrict  __handle ,
                                                                                    char const   * __restrict  __name ) ;
extern  __attribute__((__nothrow__)) char *dlerror(void) ;
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
extern int ( __attribute__((__nonnull__(1,2))) pthread_once)(pthread_once_t *__once_control ,
                                                             void (*__init_routine)(void) ) ;
int (*true_connect)(int  , struct sockaddr  const  * , socklen_t  )  ;
struct hostent *(*true_gethostbyname)(char const   * )  ;
int (*true_getaddrinfo)(char const   * , char const   * , struct addrinfo  const  * ,
                        struct addrinfo ** )  ;
int (*true_freeaddrinfo)(struct addrinfo * )  ;
int (*true_getnameinfo)(struct sockaddr  const  * , socklen_t  , char * , socklen_t  ,
                        char * , socklen_t  , int  )  ;
struct hostent *(*true_gethostbyaddr)(void const   * , socklen_t  , int  )  ;
void rdns_init(enum dns_lookup_flavor flavor ) ;
void rdns_set_daemon(struct sockaddr_in *addr ) ;
char const   *rdns_resolver_string(enum dns_lookup_flavor flavor ) ;
int (*true_close)(int  )  ;
int (*true_close_range)(unsigned int  , unsigned int  , int  )  ;
ssize_t (*true_sendto)(int sockfd , void const   *buf , size_t len , int flags , struct sockaddr  const  *dest_addr ,
                       socklen_t addrlen )  ;
int tcp_read_time_out  ;
int tcp_connect_time_out  ;
chain_type proxychains_ct  ;
proxy_data proxychains_pd[512]  ;
unsigned int proxychains_proxy_count  =    0U;
unsigned int proxychains_proxy_offset  =    0U;
int proxychains_got_chain_data  =    0;
unsigned int proxychains_max_chain  =    1U;
int proxychains_quiet_mode  =    0;
enum dns_lookup_flavor proxychains_resolver  =    (enum dns_lookup_flavor )0;
localaddr_arg localnet_addr[64]  ;
size_t num_localnet_addr  =    (size_t )0;
dnat_arg dnats[64]  ;
size_t num_dnats  =    (size_t )0;
unsigned int remote_dns_subnet  =    224U;
pthread_once_t init_once  =    0;
static int init_l  =    0;
static void get_chain_data(proxy_data *pd , unsigned int *proxy_count , chain_type *ct ) ;
static void *load_sym(char *symname , void *proxyfunc , int is_mandatory ) 
{ 
  void *funcptr ;
  void *tmp ;
  char *tmp___0 ;

  {
  tmp = dlsym((void * __restrict  )((void *)-1L), (char const   * __restrict  )symname);
  funcptr = tmp;
  if (is_mandatory) {
    if (! funcptr) {
      tmp___0 = dlerror();
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Cannot load symbol \'%s\' %s\n",
              symname, tmp___0);
      exit(1);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (! funcptr) {
    return (funcptr);
  } else {
    while (1) {
      break;
    }
  }
  if ((unsigned long )funcptr == (unsigned long )proxyfunc) {
    while (1) {
      break;
    }
    abort();
  }
  return (funcptr);
}
}
int req_pipefd[2] ;
int resp_pipefd[2] ;
ip_type4 at_get_ip_for_host(char *host , size_t len ) ;
static void setup_hooks(void) ;
static int close_fds[16]  ;
static int close_fds_cnt  =    0;
static close_range_args_t close_range_buffer[16]  ;
static int close_range_buffer_cnt  =    0;
static unsigned int get_rand_seed(void) 
{ 
  struct timespec now ;

  {
  clock_gettime(0, & now);
  return ((unsigned int )(now.tv_sec ^ now.tv_nsec));
}
}
static void do_init(void) 
{ 
  unsigned int tmp ;
  char const   *tmp___0 ;
  int i ;

  {
  tmp = get_rand_seed();
  srand(tmp);
  core_initialize();
  get_chain_data(proxychains_pd, & proxychains_proxy_count, & proxychains_ct);
  while (1) {
    break;
  }
  tmp___0 = proxychains_get_version();
  proxychains_write_log((char *)"[proxychains] DLL init: proxychains-ng %s\n", tmp___0);
  setup_hooks();
  while (close_fds_cnt) {
    close_fds_cnt --;
    (*true_close)(close_fds[close_fds_cnt]);
  }
  while (close_range_buffer_cnt) {
    close_range_buffer_cnt --;
    i = close_range_buffer_cnt;
    (*true_close_range)(close_range_buffer[i].first, close_range_buffer[i].last, (int )close_range_buffer[i].flags);
  }
  init_l = 1;
  rdns_init(proxychains_resolver);
  return;
}
}
static void init_lib_wrapper(char const   *caller ) 
{ 


  {
  if (! init_l) {
    while (1) {
      break;
    }
  }
  pthread_once(& init_once, & do_init);
  return;
}
}
static void gcc_init(void)  __attribute__((__constructor__)) ;
static void gcc_init(void) 
{ 


  {
  init_lib_wrapper("gcc_init");
  return;
}
}
static int proxy_from_string(char const   *proxystring , char *type_buf , char *host_buf ,
                             int *port_n , char *user_buf , char *pass_buf ) 
{ 
  char const   *p ;
  rs_proxyType proxytype ;
  size_t next_token ;
  size_t ul ;
  size_t pl ;
  size_t hl ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char const   *at ;
  char *tmp___2 ;
  char *tmp___3 ;
  char const   *u ;
  char const   *h ;
  char *tmp___4 ;

  {
  next_token = (size_t )6;
  ul = (size_t )0;
  pl = (size_t )0;
  if (! *(proxystring + 0)) {
    goto inv_string;
  } else
  if (! *(proxystring + 1)) {
    goto inv_string;
  } else
  if (! *(proxystring + 2)) {
    goto inv_string;
  } else
  if (! *(proxystring + 3)) {
    goto inv_string;
  } else
  if (! *(proxystring + 4)) {
    goto inv_string;
  } else
  if (! *(proxystring + 5)) {
    goto inv_string;
  }
  if ((int const   )*proxystring == 115) {
    switch ((int const   )*(proxystring + 5)) {
    case 53: 
    proxytype = (rs_proxyType )2;
    break;
    case 52: 
    proxytype = (rs_proxyType )1;
    break;
    default: 
    goto inv_string;
    }
  } else
  if ((int const   )*proxystring == 104) {
    proxytype = (rs_proxyType )3;
    next_token = (size_t )4;
  } else {
    goto inv_string;
  }
  tmp = next_token;
  next_token ++;
  if ((int const   )*(proxystring + tmp) != 58) {
    goto inv_string;
  } else {
    tmp___0 = next_token;
    next_token ++;
    if ((int const   )*(proxystring + tmp___0) != 47) {
      goto inv_string;
    } else {
      tmp___1 = next_token;
      next_token ++;
      if ((int const   )*(proxystring + tmp___1) != 47) {
        goto inv_string;
      }
    }
  }
  tmp___2 = strrchr(proxystring + next_token, '@');
  at = (char const   *)tmp___2;
  if (at) {
    if ((unsigned int )proxytype == 1U) {
      return (0);
    }
    tmp___3 = strchr(proxystring + next_token, ':');
    p = (char const   *)tmp___3;
    if (! p) {
      goto inv_string;
    } else
    if ((unsigned long )p >= (unsigned long )at) {
      goto inv_string;
    }
    u = proxystring + next_token;
    ul = (size_t )(p - u);
    p ++;
    pl = (size_t )(at - p);
    if ((unsigned int )proxytype == 2U) {
      if (ul > 255UL) {
        return (0);
      } else
      if (pl > 255UL) {
        return (0);
      }
    }
    memcpy((void * __restrict  )user_buf, (void const   * __restrict  )u, ul);
    *(user_buf + ul) = (char)0;
    memcpy((void * __restrict  )pass_buf, (void const   * __restrict  )p, pl);
    *(pass_buf + pl) = (char)0;
    next_token += (2UL + ul) + pl;
  } else {
    *(user_buf + 0) = (char)0;
    *(pass_buf + 0) = (char)0;
  }
  h = proxystring + next_token;
  tmp___4 = strchr(h, ':');
  p = (char const   *)tmp___4;
  if (! p) {
    goto inv_string;
  }
  hl = (size_t )(p - h);
  if (hl > 255UL) {
    return (0);
  }
  memcpy((void * __restrict  )host_buf, (void const   * __restrict  )h, hl);
  *(host_buf + hl) = (char)0;
  *port_n = atoi(p + 1);
  switch ((unsigned int )proxytype) {
  case 1U: 
  strcpy((char * __restrict  )type_buf, (char const   * __restrict  )"socks4");
  break;
  case 2U: 
  strcpy((char * __restrict  )type_buf, (char const   * __restrict  )"socks5");
  break;
  case 3U: 
  strcpy((char * __restrict  )type_buf, (char const   * __restrict  )"http");
  break;
  default: 
  return (0);
  }
  return (1);
  inv_string: 
  return (0);
}
}
static char const   *bool_str(int bool_val ) 
{ 


  {
  if (bool_val) {
    return ("true");
  }
  return ("false");
}
}
static void get_chain_data(proxy_data *pd , unsigned int *proxy_count , chain_type *ct ) 
{ 
  int count ;
  int port_n ;
  int list___0 ;
  char buf___0[1024] ;
  char type[1024] ;
  char host[1024] ;
  char user[1024] ;
  char *buff ;
  char *env ;
  char *p ;
  char local_addr_port[64] ;
  char local_addr[64] ;
  char local_netmask[32] ;
  char dnat_orig_addr_port[32] ;
  char dnat_new_addr_port[32] ;
  char dnat_orig_addr[32] ;
  char dnat_orig_port[32] ;
  char dnat_new_addr[32] ;
  char dnat_new_port[32] ;
  char rdnsd_addr[32] ;
  char rdnsd_port[8] ;
  FILE *file ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  int ret ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  ip_type *host_ip ;
  ip_type4 internal_ip ;
  size_t tmp___8 ;
  ip_type4 tmp___9 ;
  ip_type4 __constr_expr_4 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char colon ;
  char extra ;
  char right_bracket[2] ;
  unsigned short local_port ;
  unsigned short local_prefix ;
  int local_family ;
  int n ;
  int valid ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  char *tmp___28 ;
  char *pc ;
  int len ;
  struct sockaddr_in rdns_server_buffer ;
  int tmp___29 ;
  int error ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int error___0 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  char *tmp___50 ;

  {
  count = 0;
  port_n = 0;
  list___0 = 0;
  file = (FILE *)((void *)0);
  if (proxychains_got_chain_data) {
    return;
  }
  while (1) {
    while (1) {
      break;
    }
    break;
  }
  tcp_read_time_out = 4000;
  tcp_connect_time_out = 10000;
  *ct = (chain_type )0;
  tmp = getenv("PROXYCHAINS_CONF_FILE");
  env = get_config_path(tmp, buf___0, sizeof(buf___0));
  file = fopen((char const   * __restrict  )env, (char const   * __restrict  )"r");
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    perror("couldnt read configuration file");
    exit(1);
  }
  env = getenv("PROXYCHAINS_QUIET_MODE");
  if (env) {
    if ((int )*env == 49) {
      proxychains_quiet_mode = 1;
    }
  }
  while (1) {
    tmp___50 = fgets((char * __restrict  )(buf___0), (int )sizeof(buf___0), (FILE * __restrict  )file);
    if (! tmp___50) {
      break;
    }
    buff = buf___0;
    while (1) {
      tmp___0 = __ctype_b_loc();
      if (! ((int const   )*(*tmp___0 + (int )*buff) & 8192)) {
        break;
      }
      buff ++;
    }
    p = strrchr((char const   *)buff, '\n');
    if (p) {
      *p = (char)0;
    }
    tmp___1 = strlen((char const   *)buff);
    p = (buff + tmp___1) - 1;
    while (1) {
      if ((unsigned long )p >= (unsigned long )buff) {
        tmp___3 = __ctype_b_loc();
        if (! ((int const   )*(*tmp___3 + (int )*p) & 8192)) {
          break;
        }
      } else {
        break;
      }
      tmp___2 = p;
      p --;
      *tmp___2 = (char)0;
    }
    if (! *buff) {
      continue;
    } else
    if ((int )*buff == 35) {
      continue;
    }
    if (list___0) {
      if (count >= 512) {
        break;
      }
      memset((void *)(pd + count), 0, sizeof(proxy_data ));
      (pd + count)->ps = (proxy_state )0;
      port_n = 0;
      tmp___4 = sscanf((char const   * __restrict  )buff, (char const   * __restrict  )"%s %s %d %s %s",
                       type, host, & port_n, (pd + count)->user, (pd + count)->pass);
      ret = tmp___4;
      if (ret < 3) {
        goto _L;
      } else
      if (ret == -1) {
        _L: /* CIL Label */ 
        tmp___5 = proxy_from_string((char const   *)buff, type, host, & port_n, (pd + count)->user,
                                    (pd + count)->pass);
        if (! tmp___5) {
          inv: 
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"error: invalid item in proxylist section: %s",
                  buff);
          exit(1);
        }
      }
      memset((void *)(& (pd + count)->ip), 0, sizeof((pd + count)->ip));
      tmp___6 = strchr((char const   *)(host), ':');
      if (tmp___6) {
        tmp___7 = 1;
      } else {
        tmp___7 = 0;
      }
      (pd + count)->ip.is_v6 = (char )tmp___7;
      (pd + count)->port = htons((unsigned short )port_n);
      host_ip = & (pd + count)->ip;
      if (host_ip->is_v6) {
        tmp___13 = 10;
      } else {
        tmp___13 = 2;
      }
      tmp___14 = inet_pton(tmp___13, (char const   * __restrict  )(host), (void * __restrict  )(host_ip->addr.v6));
      if (1 != tmp___14) {
        if ((unsigned int )*ct == 1U) {
          if ((unsigned int )proxychains_resolver >= 2U) {
            if (count > 0) {
              rdns_init(proxychains_resolver);
              tmp___8 = strlen((char const   *)(host));
              tmp___9 = at_get_ip_for_host(host, tmp___8);
              internal_ip = tmp___9;
              (pd + count)->ip.is_v6 = (char)0;
              host_ip->addr.v4 = internal_ip;
              __constr_expr_4.as_int = (uint32_t )-1;
              if (internal_ip.as_int == __constr_expr_4.as_int) {
                goto inv_host;
              }
            } else {
              goto inv_host;
            }
          } else {
            goto inv_host;
          }
        } else {
          inv_host: 
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"proxy %s has invalid value or is not numeric\n",
                  host);
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"non-numeric ips are only allowed under the following circumstances:\n");
          tmp___10 = rdns_resolver_string(proxychains_resolver);
          tmp___11 = bool_str(count > 0);
          tmp___12 = bool_str((unsigned int )*ct == 1U);
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"chaintype == strict (%s), proxy is not first in list (%s), proxy_dns active (%s)\n\n",
                  tmp___12, tmp___11, tmp___10);
          exit(1);
        }
      }
      tmp___18 = strcmp((char const   *)(type), "http");
      if (tmp___18) {
        tmp___17 = strcmp((char const   *)(type), "raw");
        if (tmp___17) {
          tmp___16 = strcmp((char const   *)(type), "socks4");
          if (tmp___16) {
            tmp___15 = strcmp((char const   *)(type), "socks5");
            if (tmp___15) {
              goto inv;
            } else {
              (pd + count)->pt = (proxy_type )2;
            }
          } else {
            (pd + count)->pt = (proxy_type )1;
          }
        } else {
          (pd + count)->pt = (proxy_type )3;
        }
      } else {
        (pd + count)->pt = (proxy_type )0;
      }
      if (port_n) {
        count ++;
      }
    } else {
      tmp___49 = strcmp((char const   *)buff, "[ProxyList]");
      if (tmp___49) {
        tmp___48 = strcmp((char const   *)buff, "random_chain");
        if (tmp___48) {
          tmp___47 = strcmp((char const   *)buff, "strict_chain");
          if (tmp___47) {
            tmp___46 = strcmp((char const   *)buff, "dynamic_chain");
            if (tmp___46) {
              tmp___45 = strcmp((char const   *)buff, "round_robin_chain");
              if (tmp___45) {
                tmp___44 = strncmp((char const   *)buff, "tcp_read_time_out", sizeof("tcp_read_time_out") - 1UL);
                if (tmp___44) {
                  tmp___43 = strncmp((char const   *)buff, "tcp_connect_time_out",
                                     sizeof("tcp_connect_time_out") - 1UL);
                  if (tmp___43) {
                    tmp___42 = strncmp((char const   *)buff, "remote_dns_subnet",
                                       sizeof("remote_dns_subnet") - 1UL);
                    if (tmp___42) {
                      tmp___41 = strncmp((char const   *)buff, "localnet", sizeof("localnet") - 1UL);
                      if (tmp___41) {
                        tmp___40 = strncmp((char const   *)buff, "chain_len", sizeof("chain_len") - 1UL);
                        if (tmp___40) {
                          tmp___39 = strcmp((char const   *)buff, "quiet_mode");
                          if (tmp___39) {
                            tmp___38 = strcmp((char const   *)buff, "proxy_dns_old");
                            if (tmp___38) {
                              tmp___37 = strcmp((char const   *)buff, "proxy_dns");
                              if (tmp___37) {
                                tmp___36 = strncmp((char const   *)buff, "proxy_dns_daemon",
                                                   sizeof("proxy_dns_daemon") - 1UL);
                                if (tmp___36) {
                                  tmp___35 = strncmp((char const   *)buff, "dnat",
                                                     sizeof("dnat") - 1UL);
                                  if (! tmp___35) {
                                    tmp___32 = sscanf((char const   * __restrict  )buff,
                                                      (char const   * __restrict  )"%s %21[^ ] %21s\n",
                                                      user, dnat_orig_addr_port, dnat_new_addr_port);
                                    if (tmp___32 < 3) {
                                      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"dnat format error");
                                      exit(1);
                                    }
                                    memset((void *)(dnat_orig_port), 0, sizeof(dnat_orig_port) / sizeof(dnat_orig_port[0]));
                                    memset((void *)(dnat_new_port), 0, sizeof(dnat_new_port) / sizeof(dnat_new_port[0]));
                                    sscanf((char const   * __restrict  )(dnat_orig_addr_port),
                                           (char const   * __restrict  )"%15[^:]:%5s",
                                           dnat_orig_addr, dnat_orig_port);
                                    sscanf((char const   * __restrict  )(dnat_new_addr_port),
                                           (char const   * __restrict  )"%15[^:]:%5s",
                                           dnat_new_addr, dnat_new_port);
                                    if (num_dnats < 64UL) {
                                      error___0 = inet_pton(2, (char const   * __restrict  )(dnat_orig_addr),
                                                            (void * __restrict  )(& dnats[num_dnats].orig_dst));
                                      if (error___0 <= 0) {
                                        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"dnat original destination address error\n");
                                        exit(1);
                                      }
                                      error___0 = inet_pton(2, (char const   * __restrict  )(dnat_new_addr),
                                                            (void * __restrict  )(& dnats[num_dnats].new_dst));
                                      if (error___0 <= 0) {
                                        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"dnat effective destination address error\n");
                                        exit(1);
                                      }
                                      if (dnat_orig_port[0]) {
                                        tmp___33 = atoi((char const   *)(dnat_orig_port));
                                        dnats[num_dnats].orig_port = (unsigned short )((short )tmp___33);
                                      } else {
                                        dnats[num_dnats].orig_port = (unsigned short)0;
                                      }
                                      if (dnat_new_port[0]) {
                                        tmp___34 = atoi((char const   *)(dnat_new_port));
                                        dnats[num_dnats].new_port = (unsigned short )((short )tmp___34);
                                      } else {
                                        dnats[num_dnats].new_port = (unsigned short)0;
                                      }
                                      while (1) {
                                        break;
                                      }
                                      num_dnats ++;
                                    } else {
                                      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"# of dnat exceed %d.\n",
                                              64);
                                    }
                                  }
                                } else {
                                  tmp___29 = sscanf((char const   * __restrict  )buff,
                                                    (char const   * __restrict  )"%s %15[^:]:%5s",
                                                    user, rdnsd_addr, rdnsd_port);
                                  if (tmp___29 < 3) {
                                    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"proxy_dns_daemon format error\n");
                                    exit(1);
                                  }
                                  rdns_server_buffer.sin_family = (sa_family_t )2;
                                  tmp___30 = inet_pton(2, (char const   * __restrict  )(rdnsd_addr),
                                                       (void * __restrict  )(& rdns_server_buffer.sin_addr));
                                  error = tmp___30;
                                  if (error <= 0) {
                                    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"bogus proxy_dns_daemon address\n");
                                    exit(1);
                                  }
                                  tmp___31 = atoi((char const   *)(rdnsd_port));
                                  rdns_server_buffer.sin_port = htons((uint16_t )tmp___31);
                                  proxychains_resolver = (enum dns_lookup_flavor )3;
                                  rdns_set_daemon(& rdns_server_buffer);
                                }
                              } else {
                                proxychains_resolver = (enum dns_lookup_flavor )2;
                              }
                            } else {
                              proxychains_resolver = (enum dns_lookup_flavor )1;
                            }
                          } else {
                            proxychains_quiet_mode = 1;
                          }
                        } else {
                          pc = strchr((char const   *)buff, '=');
                          if (! pc) {
                            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"error: missing equals sign \'=\' in chain_len directive.\n");
                            exit(1);
                          }
                          pc ++;
                          len = atoi((char const   *)pc);
                          if (len) {
                            proxychains_max_chain = (unsigned int )len;
                          } else {
                            proxychains_max_chain = 1U;
                          }
                        }
                      } else {
                        local_port = (unsigned short)0;
                        tmp___19 = sscanf((char const   * __restrict  )buff, (char const   * __restrict  )"%s %53[^/]/%15s%c",
                                          user, local_addr_port, local_netmask, & extra);
                        if (tmp___19 != 3) {
                          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"localnet format error");
                          exit(1);
                        }
                        p = strchr((char const   *)(local_addr_port), ':');
                        if (! p) {
                          goto _L___2;
                        } else {
                          tmp___23 = strrchr((char const   *)(local_addr_port), ':');
                          if ((unsigned long )p == (unsigned long )tmp___23) {
                            _L___2: /* CIL Label */ 
                            local_family = 2;
                            n = sscanf((char const   * __restrict  )(local_addr_port),
                                       (char const   * __restrict  )"%15[^:]%c%5hu%c",
                                       local_addr, & colon, & local_port, & extra);
                            if (n == 1) {
                              tmp___20 = 1;
                            } else
                            if (n == 3) {
                              if ((int )colon == 58) {
                                tmp___20 = 1;
                              } else {
                                tmp___20 = 0;
                              }
                            } else {
                              tmp___20 = 0;
                            }
                            valid = tmp___20;
                          } else
                          if ((int )local_addr_port[0] == 91) {
                            local_family = 10;
                            n = sscanf((char const   * __restrict  )(local_addr_port),
                                       (char const   * __restrict  )"[%45[^][]%1[]]%c%5hu%c",
                                       local_addr, right_bracket, & colon, & local_port,
                                       & extra);
                            if (n == 2) {
                              tmp___21 = 1;
                            } else
                            if (n == 4) {
                              if ((int )colon == 58) {
                                tmp___21 = 1;
                              } else {
                                tmp___21 = 0;
                              }
                            } else {
                              tmp___21 = 0;
                            }
                            valid = tmp___21;
                          } else {
                            local_family = 10;
                            tmp___22 = sscanf((char const   * __restrict  )(local_addr_port),
                                              (char const   * __restrict  )"%45[^][]%c",
                                              local_addr, & extra);
                            valid = tmp___22 == 1;
                          }
                        }
                        if (! valid) {
                          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"localnet address or port error\n");
                          exit(1);
                        }
                        if (local_port) {
                          while (1) {
                            break;
                          }
                        } else {
                          while (1) {
                            break;
                          }
                        }
                        if (num_localnet_addr < 64UL) {
                          localnet_addr[num_localnet_addr].family = (sa_family_t )local_family;
                          localnet_addr[num_localnet_addr].port = local_port;
                          valid = 0;
                          if (local_family == 2) {
                            tmp___24 = inet_pton(local_family, (char const   * __restrict  )(local_addr),
                                                 (void * __restrict  )(& localnet_addr[num_localnet_addr].__annonCompField6.__annonCompField4.in_addr));
                            valid = tmp___24 > 0;
                          } else
                          if (local_family == 10) {
                            tmp___25 = inet_pton(local_family, (char const   * __restrict  )(local_addr),
                                                 (void * __restrict  )(& localnet_addr[num_localnet_addr].__annonCompField6.__annonCompField5.in6_addr));
                            valid = tmp___25 > 0;
                          }
                          if (! valid) {
                            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"localnet address error\n");
                            exit(1);
                          }
                          if (local_family == 2) {
                            tmp___28 = strchr((char const   *)(local_netmask), '.');
                            if (tmp___28) {
                              tmp___26 = inet_pton(local_family, (char const   * __restrict  )(local_netmask),
                                                   (void * __restrict  )(& localnet_addr[num_localnet_addr].__annonCompField6.__annonCompField4.in_mask));
                              valid = tmp___26 > 0;
                            } else {
                              goto _L___4;
                            }
                          } else {
                            _L___4: /* CIL Label */ 
                            tmp___27 = sscanf((char const   * __restrict  )(local_netmask),
                                              (char const   * __restrict  )"%hu%c",
                                              & local_prefix, & extra);
                            valid = tmp___27 == 1;
                            if (valid) {
                              if (local_family == 2) {
                                if ((int )local_prefix <= 32) {
                                  localnet_addr[num_localnet_addr].__annonCompField6.__annonCompField4.in_mask.s_addr = htonl(4294967295U << (32U - (unsigned int )local_prefix));
                                } else {
                                  goto _L___3;
                                }
                              } else
                              _L___3: /* CIL Label */ 
                              if (local_family == 10) {
                                if ((int )local_prefix <= 128) {
                                  localnet_addr[num_localnet_addr].__annonCompField6.__annonCompField5.in6_prefix = (unsigned char )local_prefix;
                                } else {
                                  valid = 0;
                                }
                              } else {
                                valid = 0;
                              }
                            }
                          }
                          if (! valid) {
                            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"localnet netmask error\n");
                            exit(1);
                          }
                          num_localnet_addr ++;
                        } else {
                          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"# of localnet exceed %d.\n",
                                  64);
                        }
                      }
                    } else {
                      sscanf((char const   * __restrict  )buff, (char const   * __restrict  )"%s %u",
                             user, & remote_dns_subnet);
                      if (remote_dns_subnet >= 256U) {
                        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"remote_dns_subnet: invalid value. requires a number between 0 and 255.\n");
                        exit(1);
                      }
                    }
                  } else {
                    sscanf((char const   * __restrict  )buff, (char const   * __restrict  )"%s %d",
                           user, & tcp_connect_time_out);
                  }
                } else {
                  sscanf((char const   * __restrict  )buff, (char const   * __restrict  )"%s %d",
                         user, & tcp_read_time_out);
                }
              } else {
                *ct = (chain_type )3;
              }
            } else {
              *ct = (chain_type )0;
            }
          } else {
            *ct = (chain_type )1;
          }
        } else {
          *ct = (chain_type )2;
        }
      } else {
        list___0 = 1;
      }
    }
  }
  fclose(file);
  if (! count) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"error: no valid proxy found in config\n");
    exit(1);
  }
  *proxy_count = (unsigned int )count;
  proxychains_got_chain_data = 1;
  while (1) {
    break;
  }
  return;
}
}
int close(int fd ) 
{ 
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  if (! init_l) {
    if ((unsigned long )close_fds_cnt >= sizeof(close_fds) / sizeof(close_fds[0])) {
      goto err;
    }
    tmp = close_fds_cnt;
    close_fds_cnt ++;
    close_fds[tmp] = fd;
    tmp___0 = __errno_location();
    *tmp___0 = 0;
    return (0);
  }
  if ((unsigned int )proxychains_resolver != 2U) {
    tmp___1 = (*true_close)(fd);
    return (tmp___1);
  }
  if (fd != req_pipefd[0]) {
    if (fd != req_pipefd[1]) {
      if (fd != resp_pipefd[0]) {
        if (fd != resp_pipefd[1]) {
          tmp___2 = (*true_close)(fd);
          return (tmp___2);
        }
      }
    }
  }
  err: 
  tmp___3 = __errno_location();
  *tmp___3 = 9;
  return (-1);
}
}
static int is_v4inv6(struct in6_addr  const  *a ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  tmp = memcmp((void const   *)(a->__in6_u.__u6_addr8), (void const   *)"\000\000\000\000\000\000\000\000\000\000\377\377",
               (size_t )12);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  return (tmp___0);
}
}
static void intsort(int *a , int n ) 
{ 
  int i ;
  int j ;
  int s ;

  {
  i = 0;
  while (i < n) {
    j = i + 1;
    while (j < n) {
      if (*(a + j) < *(a + i)) {
        s = *(a + i);
        *(a + i) = *(a + j);
        *(a + j) = s;
      }
      j ++;
    }
    i ++;
  }
  return;
}
}
int close_range(unsigned int first , unsigned int last , int flags ) 
{ 
  int *tmp ;
  int i ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int res ;
  int uerrno ;
  int i___0 ;
  int protected_fds[4] ;
  int next_fd_to_close ;
  int prev ;
  unsigned int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;

  {
  if ((unsigned long )true_close_range == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Calling close_range, but this platform does not provide this system call. ");
    return (-1);
  }
  if (! init_l) {
    if ((unsigned long )close_range_buffer_cnt >= sizeof(close_range_buffer) / sizeof(close_range_buffer[0])) {
      tmp = __errno_location();
      *tmp = 12;
      return (-1);
    }
    tmp___0 = close_range_buffer_cnt;
    close_range_buffer_cnt ++;
    i = tmp___0;
    close_range_buffer[i].first = first;
    close_range_buffer[i].last = last;
    close_range_buffer[i].flags = (unsigned int )flags;
    tmp___1 = __errno_location();
    tmp___2 = 0;
    *tmp___1 = tmp___2;
    return (tmp___2);
  }
  if ((unsigned int )proxychains_resolver != 2U) {
    tmp___3 = (*true_close_range)(first, last, flags);
    return (tmp___3);
  }
  res = 0;
  uerrno = 0;
  protected_fds[0] = req_pipefd[0];
  protected_fds[1] = req_pipefd[1];
  protected_fds[2] = resp_pipefd[0];
  protected_fds[3] = resp_pipefd[1];
  intsort(protected_fds, 4);
  next_fd_to_close = (int )first;
  i___0 = 0;
  while (i___0 < 4) {
    if ((unsigned int )protected_fds[i___0] < first) {
      goto __Cont;
    } else
    if ((unsigned int )protected_fds[i___0] > last) {
      goto __Cont;
    }
    if (i___0 == 0) {
      tmp___4 = first;
    } else
    if ((unsigned int )protected_fds[i___0 - 1] < first) {
      tmp___4 = first;
    } else {
      tmp___4 = (unsigned int )(protected_fds[i___0 - 1] + 1);
    }
    prev = (int )tmp___4;
    if (prev != protected_fds[i___0]) {
      tmp___6 = (*true_close_range)((unsigned int )prev, (unsigned int )(protected_fds[i___0] - 1),
                                    flags);
      if (-1 == tmp___6) {
        res = -1;
        tmp___5 = __errno_location();
        uerrno = *tmp___5;
      }
    }
    next_fd_to_close = protected_fds[i___0] + 1;
    __Cont: /* CIL Label */ 
    i___0 ++;
  }
  if ((unsigned int )next_fd_to_close <= last) {
    tmp___8 = (*true_close_range)((unsigned int )next_fd_to_close, last, flags);
    if (-1 == tmp___8) {
      res = -1;
      tmp___7 = __errno_location();
      uerrno = *tmp___7;
    }
  }
  tmp___9 = __errno_location();
  *tmp___9 = uerrno;
  return (res);
}
}
int connect(int sock , struct sockaddr  const  * __restrict  addr , unsigned int len ) 
{ 
  int socktype ;
  int flags ;
  int ret ;
  socklen_t optlen ;
  ip_type dest_ip ;
  struct in_addr *p_addr_in ;
  struct in6_addr *p_addr_in6 ;
  dnat_arg *dnat ;
  unsigned short port ;
  size_t i ;
  int remote_dns_connect ;
  sa_family_t fam ;
  int tmp ;
  int v6 ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;
  struct in_addr v4inv6 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  uint32_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t prefix_bytes ;
  size_t prefix_bits ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  void *tmp___11 ;
  uint16_t tmp___12 ;
  int *tmp___13 ;

  {
  init_lib_wrapper("connect");
  while (1) {
    while (1) {
      break;
    }
    break;
  }
  socktype = 0;
  flags = 0;
  ret = 0;
  optlen = (socklen_t )0;
  dnat = (dnat_arg *)((void *)0);
  remote_dns_connect = 0;
  optlen = (socklen_t )sizeof(socktype);
  fam = ((struct sockaddr_in *)addr)->sin_family;
  getsockopt(sock, 1, 3, (void * __restrict  )(& socktype), (socklen_t * __restrict  )(& optlen));
  if ((int )fam == 2) {
    goto _L;
  } else
  if ((int )fam == 10) {
    _L: /* CIL Label */ 
    if (! (socktype == 1)) {
      tmp = (*true_connect)(sock, (struct sockaddr  const  *)addr, len);
      return (tmp);
    }
  } else {
    tmp = (*true_connect)(sock, (struct sockaddr  const  *)addr, len);
    return (tmp);
  }
  dest_ip.is_v6 = (char )((int )fam == 10);
  v6 = (int )dest_ip.is_v6;
  p_addr_in = & ((struct sockaddr_in *)addr)->sin_addr;
  p_addr_in6 = & ((struct sockaddr_in6 *)addr)->sin6_addr;
  if (! v6) {
    tmp___0 = ntohs(((struct sockaddr_in *)addr)->sin_port);
    port = tmp___0;
  } else {
    tmp___1 = ntohs(((struct sockaddr_in6 *)addr)->sin6_port);
    port = tmp___1;
  }
  if (v6) {
    tmp___2 = is_v4inv6((struct in6_addr  const  *)p_addr_in6);
    if (tmp___2) {
      memcpy((void * __restrict  )(& v4inv6.s_addr), (void const   * __restrict  )(& p_addr_in6->__in6_u.__u6_addr8[12]),
             (size_t )4);
      dest_ip.is_v6 = (char)0;
      v6 = (int )dest_ip.is_v6;
      p_addr_in = & v4inv6;
    }
  }
  if (! v6) {
    tmp___4 = memcmp((void const   *)p_addr_in, (void const   *)"\000\000\000\000",
                     (size_t )4);
    if (! tmp___4) {
      tmp___3 = __errno_location();
      *tmp___3 = 111;
      return (-1);
    }
  }
  while (1) {
    break;
  }
  while (1) {
    break;
  }
  if (! v6) {
    tmp___5 = ntohl(p_addr_in->s_addr);
    if (tmp___5 >> 24 == remote_dns_subnet) {
      tmp___6 = 1;
    } else {
      tmp___6 = 0;
    }
  } else {
    tmp___6 = 0;
  }
  remote_dns_connect = tmp___6;
  if (! v6) {
    i = (size_t )0;
    while (1) {
      if (i < num_dnats) {
        if (! remote_dns_connect) {
          if (! (! dnat)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      if (dnats[i].orig_dst.s_addr == p_addr_in->s_addr) {
        if (dnats[i].orig_port) {
          if ((int )dnats[i].orig_port == (int )port) {
            dnat = & dnats[i];
          }
        }
      }
      i ++;
    }
  }
  if (! v6) {
    i = (size_t )0;
    while (1) {
      if (i < num_dnats) {
        if (! remote_dns_connect) {
          if (! (! dnat)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      if (dnats[i].orig_dst.s_addr == p_addr_in->s_addr) {
        if (! dnats[i].orig_port) {
          dnat = & dnats[i];
        }
      }
      i ++;
    }
  }
  if (dnat) {
    p_addr_in = & dnat->new_dst;
    if (dnat->new_port) {
      port = dnat->new_port;
    }
  }
  i = (size_t )0;
  while (1) {
    if (i < num_localnet_addr) {
      if (! (! remote_dns_connect)) {
        break;
      }
    } else {
      break;
    }
    if (localnet_addr[i].port) {
      if ((int )localnet_addr[i].port != (int )port) {
        goto __Cont;
      }
    }
    if (v6) {
      tmp___7 = 10;
    } else {
      tmp___7 = 2;
    }
    if ((int )localnet_addr[i].family != tmp___7) {
      goto __Cont;
    }
    if (v6) {
      prefix_bytes = (size_t )((int )localnet_addr[i].__annonCompField6.__annonCompField5.in6_prefix / 8);
      prefix_bits = (size_t )((int )localnet_addr[i].__annonCompField6.__annonCompField5.in6_prefix % 8);
      if (prefix_bytes) {
        tmp___8 = memcmp((void const   *)(p_addr_in6->__in6_u.__u6_addr8), (void const   *)(localnet_addr[i].__annonCompField6.__annonCompField5.in6_addr.__in6_u.__u6_addr8),
                         prefix_bytes);
        if (tmp___8 != 0) {
          goto __Cont;
        }
      }
      if (prefix_bits) {
        if (((int )p_addr_in6->__in6_u.__u6_addr8[prefix_bytes] ^ (int )localnet_addr[i].__annonCompField6.__annonCompField5.in6_addr.__in6_u.__u6_addr8[prefix_bytes]) >> (8UL - prefix_bits)) {
          goto __Cont;
        }
      }
    } else
    if ((p_addr_in->s_addr ^ localnet_addr[i].__annonCompField6.__annonCompField4.in_addr.s_addr) & localnet_addr[i].__annonCompField6.__annonCompField4.in_mask.s_addr) {
      goto __Cont;
    }
    while (1) {
      break;
    }
    tmp___9 = (*true_connect)(sock, (struct sockaddr  const  *)addr, len);
    return (tmp___9);
    __Cont: /* CIL Label */ 
    i ++;
  }
  flags = fcntl(sock, 3, 0);
  if (flags & 2048) {
    fcntl(sock, 4, 0);
  }
  if (v6) {
    tmp___10 = 16;
  } else {
    tmp___10 = 4;
  }
  if (v6) {
    tmp___11 = (void *)p_addr_in6;
  } else {
    tmp___11 = (void *)p_addr_in;
  }
  memcpy((void * __restrict  )(dest_ip.addr.v6), (void const   * __restrict  )tmp___11,
         (size_t )tmp___10);
  tmp___12 = htons(port);
  ret = connect_proxy_chain(sock, dest_ip, tmp___12, proxychains_pd, proxychains_proxy_count,
                            proxychains_ct, proxychains_max_chain);
  fcntl(sock, 4, flags);
  if (ret != 0) {
    tmp___13 = __errno_location();
    *tmp___13 = 111;
  }
  return (ret);
}
}
static struct gethostbyname_data ghbndata  ;
struct hostent *gethostbyname(char const   *name ) 
{ 
  struct hostent *tmp ;
  struct hostent *tmp___0 ;
  struct hostent *tmp___1 ;

  {
  init_lib_wrapper("gethostbyname");
  while (1) {
    break;
  }
  if ((unsigned int )proxychains_resolver == 1U) {
    tmp = proxy_gethostbyname_old(name);
    return (tmp);
  } else
  if ((unsigned int )proxychains_resolver == 0U) {
    tmp___0 = (*true_gethostbyname)(name);
    return (tmp___0);
  } else {
    tmp___1 = proxy_gethostbyname(name, & ghbndata);
    return (tmp___1);
  }
  return ((struct hostent *)((void *)0));
}
}
int getaddrinfo(char const   * __restrict  node , char const   * __restrict  service ,
                struct addrinfo  const  * __restrict  hints , struct addrinfo ** __restrict  res ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  init_lib_wrapper("getaddrinfo");
  while (1) {
    break;
  }
  if ((unsigned int )proxychains_resolver != 0U) {
    tmp = proxy_getaddrinfo((char const   *)node, (char const   *)service, (struct addrinfo  const  *)hints,
                            (struct addrinfo **)res);
    return (tmp);
  } else {
    tmp___0 = (*true_getaddrinfo)((char const   *)node, (char const   *)service, (struct addrinfo  const  *)hints,
                                  (struct addrinfo **)res);
    return (tmp___0);
  }
}
}
 __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *res ) ;
void freeaddrinfo(struct addrinfo *res ) 
{ 


  {
  init_lib_wrapper("freeaddrinfo");
  while (1) {
    break;
  }
  if ((unsigned int )proxychains_resolver == 0U) {
    (*true_freeaddrinfo)(res);
  } else {
    proxy_freeaddrinfo(res);
  }
  return;
}
}
int getnameinfo(struct sockaddr  const  * __restrict  sa , socklen_t salen , char * __restrict  host ,
                socklen_t hostlen , char * __restrict  serv , socklen_t servlen ,
                int flags ) 
{ 
  int tmp ;
  int v6 ;
  unsigned long tmp___0 ;
  unsigned char v4inv6buf[4] ;
  void const   *ip ;
  void *tmp___1 ;
  unsigned int scopeid ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  size_t l ;
  size_t tmp___5 ;
  int tmp___6 ;
  uint16_t tmp___7 ;
  int tmp___8 ;

  {
  init_lib_wrapper("getnameinfo");
  while (1) {
    while (1) {
      break;
    }
    break;
  }
  if ((unsigned int )proxychains_resolver == 0U) {
    tmp = (*true_getnameinfo)((struct sockaddr  const  *)sa, salen, (char *)host,
                              hostlen, (char *)serv, servlen, flags);
    return (tmp);
  } else {
    if (! salen) {
      return (-6);
    } else
    if (! ((int )((struct sockaddr_in *)sa)->sin_family == 2)) {
      if (! ((int )((struct sockaddr_in *)sa)->sin_family == 10)) {
        return (-6);
      }
    }
    v6 = (int )((struct sockaddr_in *)sa)->sin_family == 10;
    if (v6) {
      tmp___0 = sizeof(struct sockaddr_in6 );
    } else {
      tmp___0 = sizeof(struct sockaddr_in );
    }
    if ((unsigned long )salen < tmp___0) {
      return (-6);
    }
    if (hostlen) {
      if (v6) {
        tmp___1 = (void *)(& ((struct sockaddr_in6 *)sa)->sin6_addr);
      } else {
        tmp___1 = (void *)(& ((struct sockaddr_in *)sa)->sin_addr);
      }
      ip = (void const   *)tmp___1;
      scopeid = 0U;
      if (v6) {
        tmp___2 = is_v4inv6((struct in6_addr  const  *)(& ((struct sockaddr_in6 *)sa)->sin6_addr));
        if (tmp___2) {
          memcpy((void * __restrict  )(v4inv6buf), (void const   * __restrict  )(& ((struct sockaddr_in6 *)sa)->sin6_addr.__in6_u.__u6_addr8[12]),
                 (size_t )4);
          ip = (void const   *)(v4inv6buf);
          v6 = 0;
        } else {
          scopeid = ((struct sockaddr_in6 *)sa)->sin6_scope_id;
        }
      }
      if (v6) {
        tmp___3 = 10;
      } else {
        tmp___3 = 2;
      }
      tmp___4 = inet_ntop(tmp___3, (void const   * __restrict  )ip, host, hostlen);
      if (! tmp___4) {
        return (-12);
      }
      if (scopeid) {
        tmp___5 = strlen((char const   *)host);
        l = tmp___5;
        tmp___6 = snprintf(host + l, (size_t )hostlen - l, (char const   * __restrict  )"%%%u",
                           scopeid);
        if ((size_t )tmp___6 >= (size_t )hostlen - l) {
          return (-12);
        }
      }
    }
    if (servlen) {
      tmp___7 = ntohs(((struct sockaddr_in *)sa)->sin_port);
      tmp___8 = snprintf(serv, (size_t )servlen, (char const   * __restrict  )"%d",
                         (int )tmp___7);
      if ((socklen_t )tmp___8 >= servlen) {
        return (-12);
      }
    }
  }
  return (0);
}
}
static char buf[16]  ;
static char ipv4[4]  ;
static char *list[2]  ;
static char *aliases[1]  ;
static struct hostent he  ;
struct hostent *gethostbyaddr(void const   *addr , __socklen_t len , int type ) 
{ 
  struct hostent *tmp ;

  {
  init_lib_wrapper("gethostbyaddr");
  while (1) {
    break;
  }
  if ((unsigned int )proxychains_resolver == 0U) {
    tmp = (*true_gethostbyaddr)(addr, len, type);
    return (tmp);
  } else {
    while (1) {
      break;
    }
    if (len != 4U) {
      return ((struct hostent *)((void *)0));
    }
    he.h_name = buf;
    memcpy((void * __restrict  )(ipv4), (void const   * __restrict  )addr, (size_t )4);
    list[0] = ipv4;
    list[1] = (char *)((void *)0);
    he.h_addr_list = list;
    he.h_addrtype = 2;
    aliases[0] = (char *)((void *)0);
    he.h_aliases = aliases;
    he.h_length = 4;
    pc_stringfromipv4((unsigned char *)addr, buf);
    return (& he);
  }
  return ((struct hostent *)((void *)0));
}
}
ssize_t sendto(int sockfd , void const   *buf___0 , size_t len , int flags , struct sockaddr  const  * __restrict  dest_addr ,
               socklen_t addrlen ) 
{ 
  int tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;

  {
  init_lib_wrapper("sendto");
  while (1) {
    while (1) {
      break;
    }
    break;
  }
  if (flags & 536870912) {
    tmp = connect(sockfd, dest_addr, addrlen);
    if (! tmp) {
      tmp___0 = __errno_location();
      if (*tmp___0 != 115) {
        return ((ssize_t )-1);
      }
    }
    dest_addr = (struct sockaddr  const  * __restrict  )((void *)0);
    addrlen = (socklen_t )0;
    flags &= -536870913;
  }
  tmp___1 = (*true_sendto)(sockfd, buf___0, len, flags, (struct sockaddr  const  *)dest_addr,
                           addrlen);
  return (tmp___1);
}
}
static void setup_hooks(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
  while (1) {
    if (! true_connect) {
      tmp = load_sym((char *)"connect", (void *)(& connect), 1);
      true_connect = (int (*)(int  , struct sockaddr  const  * , socklen_t  ))tmp;
    }
    break;
  }
  while (1) {
    if (! true_sendto) {
      tmp___0 = load_sym((char *)"sendto", (void *)(& sendto), 1);
      true_sendto = (ssize_t (*)(int sockfd , void const   *buf , size_t len , int flags ,
                                 struct sockaddr  const  *dest_addr , socklen_t addrlen ))tmp___0;
    }
    break;
  }
  while (1) {
    if (! true_gethostbyname) {
      tmp___1 = load_sym((char *)"gethostbyname", (void *)(& gethostbyname), 1);
      true_gethostbyname = (struct hostent *(*)(char const   * ))tmp___1;
    }
    break;
  }
  while (1) {
    if (! true_getaddrinfo) {
      tmp___2 = load_sym((char *)"getaddrinfo", (void *)(& getaddrinfo), 1);
      true_getaddrinfo = (int (*)(char const   * , char const   * , struct addrinfo  const  * ,
                                  struct addrinfo ** ))tmp___2;
    }
    break;
  }
  while (1) {
    if (! true_freeaddrinfo) {
      tmp___3 = load_sym((char *)"freeaddrinfo", (void *)(& freeaddrinfo), 1);
      true_freeaddrinfo = (int (*)(struct addrinfo * ))tmp___3;
    }
    break;
  }
  while (1) {
    if (! true_gethostbyaddr) {
      tmp___4 = load_sym((char *)"gethostbyaddr", (void *)(& gethostbyaddr), 1);
      true_gethostbyaddr = (struct hostent *(*)(void const   * , socklen_t  , int  ))tmp___4;
    }
    break;
  }
  while (1) {
    if (! true_getnameinfo) {
      tmp___5 = load_sym((char *)"getnameinfo", (void *)(& getnameinfo), 1);
      true_getnameinfo = (int (*)(struct sockaddr  const  * , socklen_t  , char * ,
                                  socklen_t  , char * , socklen_t  , int  ))tmp___5;
    }
    break;
  }
  while (1) {
    if (! true_close) {
      tmp___6 = load_sym((char *)"close", (void *)(& close), 1);
      true_close = (int (*)(int  ))tmp___6;
    }
    break;
  }
  while (1) {
    if (! true_close_range) {
      tmp___7 = load_sym((char *)"close_range", (void *)(& close_range), 0);
      true_close_range = (int (*)(unsigned int  , unsigned int  , int  ))tmp___7;
    }
    break;
  }
  return;
}
}
#pragma merger("0","/tmp/cil-XRAVriDj.i","-Wno-unknown-pragmas,-Wall,-O0,-g,-std=c99,-pipe,-fPIC")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_attr_init)(pthread_attr_t *__attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_attr_destroy)(pthread_attr_t *__attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_attr_setstacksize)(pthread_attr_t *__attr ,
                                                                                                      size_t __stacksize ) ;
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
extern int ( /* format attribute */  dprintf)(int __fd , char const   * __restrict  __fmt 
                                              , ...) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2))) strerror_r)(int __errnum ,
                                                                                         char *__buf ,
                                                                                         size_t __buflen ) ;
extern  __attribute__((__nothrow__)) void *mmap(void *__addr , size_t __len , int __prot ,
                                                int __flags , int __fd , __off_t __offset ) ;
int req_pipefd[2]  ;
int resp_pipefd[2]  ;
void at_init(void) ;
void at_close(void) ;
size_t at_get_host_for_ip(ip_type4 ip , char *readbuf ) ;
uint32_t dalias_hash(char *s0 ) ;
static void *dumpstring(char *s , size_t len ) 
{ 
  char *p ;
  void *tmp ;

  {
  tmp = malloc(len);
  p = (char *)tmp;
  if (p) {
    memcpy((void * __restrict  )p, (void const   * __restrict  )s, len);
  }
  return ((void *)p);
}
}
static pthread_mutex_t *internal_ips_lock  ;
static internal_ip_lookup_table *internal_ips  ;
uint32_t index_from_internal_ip(ip_type4 internalip ) 
{ 
  ip_type4 tmp ;
  uint32_t ret ;

  {
  while (1) {
    while (1) {
      break;
    }
    break;
  }
  tmp = internalip;
  ret = (uint32_t )(((int )tmp.octet[3] + ((int )tmp.octet[2] << 8)) + ((int )tmp.octet[1] << 16));
  ret --;
  return (ret);
}
}
char *string_from_internal_ip(ip_type4 internalip ) 
{ 
  char *res ;
  uint32_t index___0 ;
  uint32_t tmp ;

  {
  while (1) {
    while (1) {
      break;
    }
    break;
  }
  res = (char *)((void *)0);
  tmp = index_from_internal_ip(internalip);
  index___0 = tmp;
  if (index___0 < internal_ips->counter) {
    res = (*(internal_ips->list + index___0))->string;
  }
  return (res);
}
}
ip_type4 make_internal_ip(uint32_t index___0 ) 
{ 
  ip_type4 ret ;
  ip_type4 __constr_expr_5 ;

  {
  index___0 ++;
  if (index___0 > 16777215U) {
    __constr_expr_5.as_int = (uint32_t )-1;
    return (__constr_expr_5);
  }
  ret.octet[0] = (unsigned char )(remote_dns_subnet & 255U);
  ret.octet[1] = (unsigned char )((index___0 & 16711680U) >> 16);
  ret.octet[2] = (unsigned char )((index___0 & 65280U) >> 8);
  ret.octet[3] = (unsigned char )(index___0 & 255U);
  return (ret);
}
}
static ip_type4 ip_from_internal_list(char *name , size_t len ) 
{ 
  uint32_t hash ;
  uint32_t tmp ;
  size_t i ;
  ip_type4 res ;
  void *new_mem ;
  int tmp___0 ;
  ip_type4 __constr_expr_6 ;
  string_hash_tuple tmp___1 ;
  ip_type4 __constr_expr_7 ;

  {
  tmp = dalias_hash(name);
  hash = tmp;
  if (internal_ips->counter) {
    i = (size_t )0;
    while (i < (size_t )internal_ips->counter) {
      if ((*(internal_ips->list + i))->hash == hash) {
        tmp___0 = strcmp((char const   *)name, (char const   *)(*(internal_ips->list + i))->string);
        if (! tmp___0) {
          res = make_internal_ip((uint32_t )i);
          while (1) {
            break;
          }
          goto have_ip;
        }
      }
      i ++;
    }
  }
  if (internal_ips->capa < internal_ips->counter + 1U) {
    while (1) {
      break;
    }
    new_mem = realloc((void *)internal_ips->list, (unsigned long )(internal_ips->capa + 16U) * sizeof(void *));
    if (new_mem) {
      internal_ips->capa += 16U;
      internal_ips->list = (string_hash_tuple **)new_mem;
    } else {
      oom: 
      while (1) {
        break;
      }
      goto err_plus_unlock;
    }
  }
  res = make_internal_ip(internal_ips->counter);
  __constr_expr_6.as_int = (uint32_t )-1;
  if (res.as_int == __constr_expr_6.as_int) {
    goto err_plus_unlock;
  }
  tmp___1.hash = (uint32_t )0;
  tmp___1.string = (char *)0;
  new_mem = dumpstring((char *)(& tmp___1), sizeof(string_hash_tuple ));
  if (! new_mem) {
    goto oom;
  }
  while (1) {
    break;
  }
  *(internal_ips->list + internal_ips->counter) = (string_hash_tuple *)new_mem;
  (*(internal_ips->list + internal_ips->counter))->hash = hash;
  new_mem = dumpstring(name, len);
  if (! new_mem) {
    *(internal_ips->list + internal_ips->counter) = (string_hash_tuple *)0;
    goto oom;
  }
  (*(internal_ips->list + internal_ips->counter))->string = (char *)new_mem;
  (internal_ips->counter) ++;
  have_ip: 
  return (res);
  err_plus_unlock: 
  while (1) {
    break;
  }
  __constr_expr_7.as_int = (uint32_t )-1;
  return (__constr_expr_7);
}
}
static pthread_t allocator_thread  ;
static int wait_data(int readfd___0 ) 
{ 
  fd_set fds ;
  int __d0 ;
  int __d1 ;
  int ret ;
  int e ;
  int *tmp ;
  char emsg[1024] ;
  char *x ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  while (1) {
    while (1) {
      break;
    }
    break;
  }
  while (1) {
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fds.fds_bits[0]): "memory");
    break;
  }
  fds.fds_bits[readfd___0 / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << readfd___0 % (8 * (int )sizeof(__fd_mask )));
  while (1) {
    ret = select(readfd___0 + 1, (fd_set * __restrict  )(& fds), (fd_set * __restrict  )((void *)0),
                 (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )((void *)0));
    if (! (ret <= 0)) {
      break;
    }
    if (ret < 0) {
      tmp = __errno_location();
      e = *tmp;
      if (e == 4) {
        continue;
      }
      tmp___0 = __errno_location();
      tmp___1 = strerror_r(*tmp___0, emsg, sizeof(emsg));
      x = tmp___1;
      dprintf(2, (char const   * __restrict  )"select2: %s\n", x);
      return (0);
    }
  }
  return (1);
}
}
static int trywrite(int fd , void *buf___0 , size_t bytes ) 
{ 
  ssize_t ret ;
  unsigned char *out ;
  int *tmp ;

  {
  out = (unsigned char *)buf___0;
  again: 
  ret = write(fd, (void const   *)out, bytes);
  switch (ret) {
  case -1L: 
  tmp = __errno_location();
  if (*tmp == 4) {
    goto again;
  }
  case 0L: 
  return (0);
  default: 
  if ((size_t )ret == bytes) {
    return (1);
  } else
  if (! bytes) {
    return (1);
  }
  out += ret;
  bytes -= (size_t )ret;
  goto again;
  }
}
}
static int sendmessage(enum at_direction dir , struct at_msg *msg ) ;
static int *destfd[2]  = {      & req_pipefd[1],      & resp_pipefd[1]};
static int sendmessage(enum at_direction dir , struct at_msg *msg ) 
{ 
  int ret ;
  int tmp ;

  {
  if (! ((int )msg->h.datalen <= 256)) {
    __assert_fail("msg->h.datalen <= MSG_LEN_MAX", "src/allocator_thread.c", 193U,
                  "sendmessage");
  }
  tmp = trywrite(*(destfd[dir]), (void *)msg, sizeof(msg->h) + (unsigned long )msg->h.datalen);
  ret = tmp;
  if (! ((int )msg->h.datalen <= 256)) {
    __assert_fail("msg->h.datalen <= MSG_LEN_MAX", "src/allocator_thread.c", 195U,
                  "sendmessage");
  }
  return (ret);
}
}
static int tryread(int fd , void *buf___0 , size_t bytes ) 
{ 
  ssize_t ret ;
  unsigned char *out ;
  int *tmp ;

  {
  out = (unsigned char *)buf___0;
  again: 
  ret = read(fd, (void *)out, bytes);
  switch (ret) {
  case -1L: 
  tmp = __errno_location();
  if (*tmp == 4) {
    goto again;
  }
  case 0L: 
  return (0);
  default: 
  if ((size_t )ret == bytes) {
    return (1);
  } else
  if (! bytes) {
    return (1);
  }
  out += ret;
  bytes -= (size_t )ret;
  goto again;
  }
}
}
static int readmsg(int fd , struct at_msg *msg ) 
{ 
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = tryread(fd, (void *)msg, sizeof(msg->h));
  ret = tmp;
  if (ret != 1) {
    return (ret);
  }
  tmp___0 = tryread(fd, (void *)(& msg->m), (size_t )msg->h.datalen);
  return (tmp___0);
}
}
static int getmessage(enum at_direction dir , struct at_msg *msg ) ;
static int *readfd[2]  = {      & req_pipefd[0],      & resp_pipefd[0]};
static int getmessage(enum at_direction dir , struct at_msg *msg ) 
{ 
  ssize_t ret ;
  int tmp ;
  int tmp___0 ;

  {
  tmp___0 = wait_data(*(readfd[dir]));
  ret = (ssize_t )tmp___0;
  if (ret) {
    tmp = readmsg(*(readfd[dir]), msg);
    if (! tmp) {
      return (0);
    }
    if (! ((int )msg->h.datalen <= 256)) {
      __assert_fail("msg->h.datalen <= MSG_LEN_MAX", "src/allocator_thread.c", 228U,
                    "getmessage");
    }
  }
  return ((int )ret);
}
}
static void *threadfunc(void *x ) 
{ 
  int ret ;
  struct at_msg msg ;
  char *host ;
  char *tmp ;
  size_t l ;
  size_t tmp___0 ;

  {
  while (1) {
    ret = getmessage((enum at_direction )0, & msg);
    if (! ret) {
      break;
    }
    switch ((int )msg.h.msgtype) {
    case 0: 
    msg.m.ip = ip_from_internal_list(msg.m.host, (size_t )msg.h.datalen);
    msg.h.datalen = (unsigned short )sizeof(ip_type4 );
    break;
    case 1: 
    tmp = string_from_internal_ip(msg.m.ip);
    host = tmp;
    if (host) {
      tmp___0 = strlen((char const   *)host);
      l = tmp___0;
      if (! (l + 1UL < 256UL)) {
        __assert_fail("l+1 < MSG_LEN_MAX", "src/allocator_thread.c", 249U, "threadfunc");
      }
      memcpy((void * __restrict  )(msg.m.host), (void const   * __restrict  )host,
             l + 1UL);
      msg.h.datalen = (unsigned short )(l + 1UL);
    } else {
      msg.h.datalen = (unsigned short)0;
    }
    break;
    case 3: 
    return ((void *)0);
    default: 
    abort();
    }
    ret = sendmessage((enum at_direction )1, & msg);
  }
  return ((void *)0);
}
}
ip_type4 at_get_ip_for_host(char *host , size_t len ) 
{ 
  ip_type4 readbuf ;
  struct at_msg msg ;
  ip_type4 __constr_expr_8 ;
  int tmp ;
  int tmp___0 ;

  {
  pthread_mutex_lock(internal_ips_lock);
  if (len > 256UL) {
    goto inv;
  }
  msg.h.msgtype = (unsigned char)0;
  msg.h.reserved = (char)0;
  msg.h.datalen = (unsigned short )(len + 1UL);
  msg.m.host[0] = (char)0;
  msg.m.host[1] = (char)0;
  msg.m.host[2] = (char)0;
  msg.m.host[3] = (char)0;
  msg.m.host[4] = (char)0;
  msg.m.host[5] = (char)0;
  msg.m.host[6] = (char)0;
  msg.m.host[7] = (char)0;
  msg.m.host[8] = (char)0;
  msg.m.host[9] = (char)0;
  msg.m.host[10] = (char)0;
  msg.m.host[11] = (char)0;
  msg.m.host[12] = (char)0;
  msg.m.host[13] = (char)0;
  msg.m.host[14] = (char)0;
  msg.m.host[15] = (char)0;
  msg.m.host[16] = (char)0;
  msg.m.host[17] = (char)0;
  msg.m.host[18] = (char)0;
  msg.m.host[19] = (char)0;
  msg.m.host[20] = (char)0;
  msg.m.host[21] = (char)0;
  msg.m.host[22] = (char)0;
  msg.m.host[23] = (char)0;
  msg.m.host[24] = (char)0;
  msg.m.host[25] = (char)0;
  msg.m.host[26] = (char)0;
  msg.m.host[27] = (char)0;
  msg.m.host[28] = (char)0;
  msg.m.host[29] = (char)0;
  msg.m.host[30] = (char)0;
  msg.m.host[31] = (char)0;
  msg.m.host[32] = (char)0;
  msg.m.host[33] = (char)0;
  msg.m.host[34] = (char)0;
  msg.m.host[35] = (char)0;
  msg.m.host[36] = (char)0;
  msg.m.host[37] = (char)0;
  msg.m.host[38] = (char)0;
  msg.m.host[39] = (char)0;
  msg.m.host[40] = (char)0;
  msg.m.host[41] = (char)0;
  msg.m.host[42] = (char)0;
  msg.m.host[43] = (char)0;
  msg.m.host[44] = (char)0;
  msg.m.host[45] = (char)0;
  msg.m.host[46] = (char)0;
  msg.m.host[47] = (char)0;
  msg.m.host[48] = (char)0;
  msg.m.host[49] = (char)0;
  msg.m.host[50] = (char)0;
  msg.m.host[51] = (char)0;
  msg.m.host[52] = (char)0;
  msg.m.host[53] = (char)0;
  msg.m.host[54] = (char)0;
  msg.m.host[55] = (char)0;
  msg.m.host[56] = (char)0;
  msg.m.host[57] = (char)0;
  msg.m.host[58] = (char)0;
  msg.m.host[59] = (char)0;
  msg.m.host[60] = (char)0;
  msg.m.host[61] = (char)0;
  msg.m.host[62] = (char)0;
  msg.m.host[63] = (char)0;
  msg.m.host[64] = (char)0;
  msg.m.host[65] = (char)0;
  msg.m.host[66] = (char)0;
  msg.m.host[67] = (char)0;
  msg.m.host[68] = (char)0;
  msg.m.host[69] = (char)0;
  msg.m.host[70] = (char)0;
  msg.m.host[71] = (char)0;
  msg.m.host[72] = (char)0;
  msg.m.host[73] = (char)0;
  msg.m.host[74] = (char)0;
  msg.m.host[75] = (char)0;
  msg.m.host[76] = (char)0;
  msg.m.host[77] = (char)0;
  msg.m.host[78] = (char)0;
  msg.m.host[79] = (char)0;
  msg.m.host[80] = (char)0;
  msg.m.host[81] = (char)0;
  msg.m.host[82] = (char)0;
  msg.m.host[83] = (char)0;
  msg.m.host[84] = (char)0;
  msg.m.host[85] = (char)0;
  msg.m.host[86] = (char)0;
  msg.m.host[87] = (char)0;
  msg.m.host[88] = (char)0;
  msg.m.host[89] = (char)0;
  msg.m.host[90] = (char)0;
  msg.m.host[91] = (char)0;
  msg.m.host[92] = (char)0;
  msg.m.host[93] = (char)0;
  msg.m.host[94] = (char)0;
  msg.m.host[95] = (char)0;
  msg.m.host[96] = (char)0;
  msg.m.host[97] = (char)0;
  msg.m.host[98] = (char)0;
  msg.m.host[99] = (char)0;
  msg.m.host[100] = (char)0;
  msg.m.host[101] = (char)0;
  msg.m.host[102] = (char)0;
  msg.m.host[103] = (char)0;
  msg.m.host[104] = (char)0;
  msg.m.host[105] = (char)0;
  msg.m.host[106] = (char)0;
  msg.m.host[107] = (char)0;
  msg.m.host[108] = (char)0;
  msg.m.host[109] = (char)0;
  msg.m.host[110] = (char)0;
  msg.m.host[111] = (char)0;
  msg.m.host[112] = (char)0;
  msg.m.host[113] = (char)0;
  msg.m.host[114] = (char)0;
  msg.m.host[115] = (char)0;
  msg.m.host[116] = (char)0;
  msg.m.host[117] = (char)0;
  msg.m.host[118] = (char)0;
  msg.m.host[119] = (char)0;
  msg.m.host[120] = (char)0;
  msg.m.host[121] = (char)0;
  msg.m.host[122] = (char)0;
  msg.m.host[123] = (char)0;
  msg.m.host[124] = (char)0;
  msg.m.host[125] = (char)0;
  msg.m.host[126] = (char)0;
  msg.m.host[127] = (char)0;
  msg.m.host[128] = (char)0;
  msg.m.host[129] = (char)0;
  msg.m.host[130] = (char)0;
  msg.m.host[131] = (char)0;
  msg.m.host[132] = (char)0;
  msg.m.host[133] = (char)0;
  msg.m.host[134] = (char)0;
  msg.m.host[135] = (char)0;
  msg.m.host[136] = (char)0;
  msg.m.host[137] = (char)0;
  msg.m.host[138] = (char)0;
  msg.m.host[139] = (char)0;
  msg.m.host[140] = (char)0;
  msg.m.host[141] = (char)0;
  msg.m.host[142] = (char)0;
  msg.m.host[143] = (char)0;
  msg.m.host[144] = (char)0;
  msg.m.host[145] = (char)0;
  msg.m.host[146] = (char)0;
  msg.m.host[147] = (char)0;
  msg.m.host[148] = (char)0;
  msg.m.host[149] = (char)0;
  msg.m.host[150] = (char)0;
  msg.m.host[151] = (char)0;
  msg.m.host[152] = (char)0;
  msg.m.host[153] = (char)0;
  msg.m.host[154] = (char)0;
  msg.m.host[155] = (char)0;
  msg.m.host[156] = (char)0;
  msg.m.host[157] = (char)0;
  msg.m.host[158] = (char)0;
  msg.m.host[159] = (char)0;
  msg.m.host[160] = (char)0;
  msg.m.host[161] = (char)0;
  msg.m.host[162] = (char)0;
  msg.m.host[163] = (char)0;
  msg.m.host[164] = (char)0;
  msg.m.host[165] = (char)0;
  msg.m.host[166] = (char)0;
  msg.m.host[167] = (char)0;
  msg.m.host[168] = (char)0;
  msg.m.host[169] = (char)0;
  msg.m.host[170] = (char)0;
  msg.m.host[171] = (char)0;
  msg.m.host[172] = (char)0;
  msg.m.host[173] = (char)0;
  msg.m.host[174] = (char)0;
  msg.m.host[175] = (char)0;
  msg.m.host[176] = (char)0;
  msg.m.host[177] = (char)0;
  msg.m.host[178] = (char)0;
  msg.m.host[179] = (char)0;
  msg.m.host[180] = (char)0;
  msg.m.host[181] = (char)0;
  msg.m.host[182] = (char)0;
  msg.m.host[183] = (char)0;
  msg.m.host[184] = (char)0;
  msg.m.host[185] = (char)0;
  msg.m.host[186] = (char)0;
  msg.m.host[187] = (char)0;
  msg.m.host[188] = (char)0;
  msg.m.host[189] = (char)0;
  msg.m.host[190] = (char)0;
  msg.m.host[191] = (char)0;
  msg.m.host[192] = (char)0;
  msg.m.host[193] = (char)0;
  msg.m.host[194] = (char)0;
  msg.m.host[195] = (char)0;
  msg.m.host[196] = (char)0;
  msg.m.host[197] = (char)0;
  msg.m.host[198] = (char)0;
  msg.m.host[199] = (char)0;
  msg.m.host[200] = (char)0;
  msg.m.host[201] = (char)0;
  msg.m.host[202] = (char)0;
  msg.m.host[203] = (char)0;
  msg.m.host[204] = (char)0;
  msg.m.host[205] = (char)0;
  msg.m.host[206] = (char)0;
  msg.m.host[207] = (char)0;
  msg.m.host[208] = (char)0;
  msg.m.host[209] = (char)0;
  msg.m.host[210] = (char)0;
  msg.m.host[211] = (char)0;
  msg.m.host[212] = (char)0;
  msg.m.host[213] = (char)0;
  msg.m.host[214] = (char)0;
  msg.m.host[215] = (char)0;
  msg.m.host[216] = (char)0;
  msg.m.host[217] = (char)0;
  msg.m.host[218] = (char)0;
  msg.m.host[219] = (char)0;
  msg.m.host[220] = (char)0;
  msg.m.host[221] = (char)0;
  msg.m.host[222] = (char)0;
  msg.m.host[223] = (char)0;
  msg.m.host[224] = (char)0;
  msg.m.host[225] = (char)0;
  msg.m.host[226] = (char)0;
  msg.m.host[227] = (char)0;
  msg.m.host[228] = (char)0;
  msg.m.host[229] = (char)0;
  msg.m.host[230] = (char)0;
  msg.m.host[231] = (char)0;
  msg.m.host[232] = (char)0;
  msg.m.host[233] = (char)0;
  msg.m.host[234] = (char)0;
  msg.m.host[235] = (char)0;
  msg.m.host[236] = (char)0;
  msg.m.host[237] = (char)0;
  msg.m.host[238] = (char)0;
  msg.m.host[239] = (char)0;
  msg.m.host[240] = (char)0;
  msg.m.host[241] = (char)0;
  msg.m.host[242] = (char)0;
  msg.m.host[243] = (char)0;
  msg.m.host[244] = (char)0;
  msg.m.host[245] = (char)0;
  msg.m.host[246] = (char)0;
  msg.m.host[247] = (char)0;
  msg.m.host[248] = (char)0;
  msg.m.host[249] = (char)0;
  msg.m.host[250] = (char)0;
  msg.m.host[251] = (char)0;
  msg.m.host[252] = (char)0;
  msg.m.host[253] = (char)0;
  msg.m.host[254] = (char)0;
  msg.m.host[255] = (char)0;
  msg.m.host[256] = (char)0;
  msg.m.host[257] = (char)0;
  msg.m.host[258] = (char)0;
  msg.m.host[259] = (char)0;
  memcpy((void * __restrict  )(msg.m.host), (void const   * __restrict  )host, len + 1UL);
  tmp = sendmessage((enum at_direction )0, & msg);
  if (tmp) {
    tmp___0 = getmessage((enum at_direction )1, & msg);
    if (tmp___0) {
      readbuf = msg.m.ip;
    } else {
      goto inv;
    }
  } else {
    inv: 
    __constr_expr_8.as_int = (uint32_t )-1;
    readbuf = __constr_expr_8;
  }
  if (! ((int )msg.h.msgtype == 0)) {
    __assert_fail("msg.h.msgtype == ATM_GETIP", "src/allocator_thread.c", 281U, "at_get_ip_for_host");
  }
  pthread_mutex_unlock(internal_ips_lock);
  return (readbuf);
}
}
size_t at_get_host_for_ip(ip_type4 ip , char *readbuf ) 
{ 
  struct at_msg msg ;
  size_t res ;
  int tmp ;
  int tmp___0 ;

  {
  msg.h.msgtype = (unsigned char)1;
  msg.h.reserved = (char)0;
  msg.h.datalen = (unsigned short )sizeof(ip_type4 );
  msg.m.ip = ip;
  res = (size_t )0;
  pthread_mutex_lock(internal_ips_lock);
  tmp = sendmessage((enum at_direction )0, & msg);
  if (tmp) {
    tmp___0 = getmessage((enum at_direction )1, & msg);
    if (tmp___0) {
      if ((int )((int16_t )msg.h.datalen) <= 0) {
        res = (size_t )0;
      } else {
        memcpy((void * __restrict  )readbuf, (void const   * __restrict  )(msg.m.host),
               (size_t )msg.h.datalen);
        res = (size_t )((int )msg.h.datalen - 1);
      }
    }
  }
  if (! ((int )msg.h.msgtype == 1)) {
    __assert_fail("msg.h.msgtype == ATM_GETNAME", "src/allocator_thread.c", 297U,
                  "at_get_host_for_ip");
  }
  pthread_mutex_unlock(internal_ips_lock);
  return (res);
}
}
static void initpipe(int *fds ) 
{ 
  int retval ;

  {
  retval = pipe2((int *)fds, 524288);
  if (retval == -1) {
    perror("pipe");
    exit(1);
  }
  return;
}
}
void at_init(void) 
{ 
  void *shm ;
  void *tmp ;
  pthread_attr_t allocator_thread_attr ;

  {
  while (1) {
    while (1) {
      break;
    }
    break;
  }
  tmp = mmap((void *)0, (size_t )4096, 3, 33, -1, (__off_t )0);
  shm = tmp;
  if (! shm) {
    __assert_fail("shm", "src/allocator_thread.c", 335U, "at_init");
  }
  internal_ips_lock = (pthread_mutex_t *)shm;
  internal_ips = (internal_ip_lookup_table *)((void *)((char *)shm + 2048));
  pthread_mutex_init(internal_ips_lock, (pthread_mutexattr_t const   *)((void *)0));
  memset((void *)internal_ips, 0, sizeof(*internal_ips));
  initpipe(req_pipefd);
  initpipe(resp_pipefd);
  pthread_attr_init(& allocator_thread_attr);
  pthread_attr_setstacksize(& allocator_thread_attr, (size_t )16384);
  pthread_create((pthread_t * __restrict  )(& allocator_thread), (pthread_attr_t const   * __restrict  )(& allocator_thread_attr),
                 & threadfunc, (void * __restrict  )0);
  pthread_attr_destroy(& allocator_thread_attr);
  return;
}
}
void at_close(void) 
{ 
  int msg ;

  {
  while (1) {
    while (1) {
      break;
    }
    break;
  }
  msg = 3;
  write(req_pipefd[1], (void const   *)(& msg), sizeof(int ));
  pthread_join(allocator_thread, (void **)((void *)0));
  close(req_pipefd[0]);
  close(req_pipefd[1]);
  close(resp_pipefd[0]);
  close(resp_pipefd[1]);
  pthread_mutex_destroy(internal_ips_lock);
  return;
}
}
#pragma merger("0","/tmp/cil-_HJB15kT.i","-Wno-unknown-pragmas,-Wall,-O0,-g,-std=c99,-pipe,-fPIC")
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
static struct sockaddr_in rdns_server  ;
size_t rdns_daemon_get_host_for_ip(ip_type4 ip , char *readbuf ) 
{ 
  struct at_msg msg ;
  uint16_t tmp ;
  int fd ;
  int tmp___0 ;

  {
  tmp = htons((uint16_t )4);
  msg.h.msgtype = (unsigned char)1;
  msg.h.reserved = (char)0;
  msg.h.datalen = tmp;
  msg.m.ip = ip;
  tmp___0 = socket(2, 524290, 0);
  fd = tmp___0;
  sendto(fd, (void const   *)(& msg), sizeof(msg.h) + 4UL, 0, (struct sockaddr  const  * __restrict  )((void *)(& rdns_server)),
         (socklen_t )sizeof(rdns_server));
  recvfrom(fd, (void * __restrict  )(& msg), sizeof(msg), 0, (struct sockaddr * __restrict  )((void *)0),
           (socklen_t * __restrict  )((void *)0));
  close(fd);
  msg.h.datalen = ntohs(msg.h.datalen);
  if (! msg.h.datalen) {
    return ((size_t )0);
  } else
  if ((int )msg.h.datalen > 256) {
    return ((size_t )0);
  }
  memcpy((void * __restrict  )readbuf, (void const   * __restrict  )(msg.m.host),
         (size_t )msg.h.datalen);
  return ((size_t )((int )msg.h.datalen - 1));
}
}
static ip_type4 rdns_daemon_get_ip_for_host(char *host , size_t len ) 
{ 
  struct at_msg msg ;
  ip_type4 __constr_expr_9 ;
  int fd ;
  int tmp ;
  ip_type4 __constr_expr_10 ;
  uint16_t tmp___0 ;

  {
  msg.h.msgtype = (unsigned char)0;
  msg.h.reserved = (char)0;
  msg.h.datalen = (unsigned short)0;
  msg.m.host[0] = (char)0;
  msg.m.host[1] = (char)0;
  msg.m.host[2] = (char)0;
  msg.m.host[3] = (char)0;
  msg.m.host[4] = (char)0;
  msg.m.host[5] = (char)0;
  msg.m.host[6] = (char)0;
  msg.m.host[7] = (char)0;
  msg.m.host[8] = (char)0;
  msg.m.host[9] = (char)0;
  msg.m.host[10] = (char)0;
  msg.m.host[11] = (char)0;
  msg.m.host[12] = (char)0;
  msg.m.host[13] = (char)0;
  msg.m.host[14] = (char)0;
  msg.m.host[15] = (char)0;
  msg.m.host[16] = (char)0;
  msg.m.host[17] = (char)0;
  msg.m.host[18] = (char)0;
  msg.m.host[19] = (char)0;
  msg.m.host[20] = (char)0;
  msg.m.host[21] = (char)0;
  msg.m.host[22] = (char)0;
  msg.m.host[23] = (char)0;
  msg.m.host[24] = (char)0;
  msg.m.host[25] = (char)0;
  msg.m.host[26] = (char)0;
  msg.m.host[27] = (char)0;
  msg.m.host[28] = (char)0;
  msg.m.host[29] = (char)0;
  msg.m.host[30] = (char)0;
  msg.m.host[31] = (char)0;
  msg.m.host[32] = (char)0;
  msg.m.host[33] = (char)0;
  msg.m.host[34] = (char)0;
  msg.m.host[35] = (char)0;
  msg.m.host[36] = (char)0;
  msg.m.host[37] = (char)0;
  msg.m.host[38] = (char)0;
  msg.m.host[39] = (char)0;
  msg.m.host[40] = (char)0;
  msg.m.host[41] = (char)0;
  msg.m.host[42] = (char)0;
  msg.m.host[43] = (char)0;
  msg.m.host[44] = (char)0;
  msg.m.host[45] = (char)0;
  msg.m.host[46] = (char)0;
  msg.m.host[47] = (char)0;
  msg.m.host[48] = (char)0;
  msg.m.host[49] = (char)0;
  msg.m.host[50] = (char)0;
  msg.m.host[51] = (char)0;
  msg.m.host[52] = (char)0;
  msg.m.host[53] = (char)0;
  msg.m.host[54] = (char)0;
  msg.m.host[55] = (char)0;
  msg.m.host[56] = (char)0;
  msg.m.host[57] = (char)0;
  msg.m.host[58] = (char)0;
  msg.m.host[59] = (char)0;
  msg.m.host[60] = (char)0;
  msg.m.host[61] = (char)0;
  msg.m.host[62] = (char)0;
  msg.m.host[63] = (char)0;
  msg.m.host[64] = (char)0;
  msg.m.host[65] = (char)0;
  msg.m.host[66] = (char)0;
  msg.m.host[67] = (char)0;
  msg.m.host[68] = (char)0;
  msg.m.host[69] = (char)0;
  msg.m.host[70] = (char)0;
  msg.m.host[71] = (char)0;
  msg.m.host[72] = (char)0;
  msg.m.host[73] = (char)0;
  msg.m.host[74] = (char)0;
  msg.m.host[75] = (char)0;
  msg.m.host[76] = (char)0;
  msg.m.host[77] = (char)0;
  msg.m.host[78] = (char)0;
  msg.m.host[79] = (char)0;
  msg.m.host[80] = (char)0;
  msg.m.host[81] = (char)0;
  msg.m.host[82] = (char)0;
  msg.m.host[83] = (char)0;
  msg.m.host[84] = (char)0;
  msg.m.host[85] = (char)0;
  msg.m.host[86] = (char)0;
  msg.m.host[87] = (char)0;
  msg.m.host[88] = (char)0;
  msg.m.host[89] = (char)0;
  msg.m.host[90] = (char)0;
  msg.m.host[91] = (char)0;
  msg.m.host[92] = (char)0;
  msg.m.host[93] = (char)0;
  msg.m.host[94] = (char)0;
  msg.m.host[95] = (char)0;
  msg.m.host[96] = (char)0;
  msg.m.host[97] = (char)0;
  msg.m.host[98] = (char)0;
  msg.m.host[99] = (char)0;
  msg.m.host[100] = (char)0;
  msg.m.host[101] = (char)0;
  msg.m.host[102] = (char)0;
  msg.m.host[103] = (char)0;
  msg.m.host[104] = (char)0;
  msg.m.host[105] = (char)0;
  msg.m.host[106] = (char)0;
  msg.m.host[107] = (char)0;
  msg.m.host[108] = (char)0;
  msg.m.host[109] = (char)0;
  msg.m.host[110] = (char)0;
  msg.m.host[111] = (char)0;
  msg.m.host[112] = (char)0;
  msg.m.host[113] = (char)0;
  msg.m.host[114] = (char)0;
  msg.m.host[115] = (char)0;
  msg.m.host[116] = (char)0;
  msg.m.host[117] = (char)0;
  msg.m.host[118] = (char)0;
  msg.m.host[119] = (char)0;
  msg.m.host[120] = (char)0;
  msg.m.host[121] = (char)0;
  msg.m.host[122] = (char)0;
  msg.m.host[123] = (char)0;
  msg.m.host[124] = (char)0;
  msg.m.host[125] = (char)0;
  msg.m.host[126] = (char)0;
  msg.m.host[127] = (char)0;
  msg.m.host[128] = (char)0;
  msg.m.host[129] = (char)0;
  msg.m.host[130] = (char)0;
  msg.m.host[131] = (char)0;
  msg.m.host[132] = (char)0;
  msg.m.host[133] = (char)0;
  msg.m.host[134] = (char)0;
  msg.m.host[135] = (char)0;
  msg.m.host[136] = (char)0;
  msg.m.host[137] = (char)0;
  msg.m.host[138] = (char)0;
  msg.m.host[139] = (char)0;
  msg.m.host[140] = (char)0;
  msg.m.host[141] = (char)0;
  msg.m.host[142] = (char)0;
  msg.m.host[143] = (char)0;
  msg.m.host[144] = (char)0;
  msg.m.host[145] = (char)0;
  msg.m.host[146] = (char)0;
  msg.m.host[147] = (char)0;
  msg.m.host[148] = (char)0;
  msg.m.host[149] = (char)0;
  msg.m.host[150] = (char)0;
  msg.m.host[151] = (char)0;
  msg.m.host[152] = (char)0;
  msg.m.host[153] = (char)0;
  msg.m.host[154] = (char)0;
  msg.m.host[155] = (char)0;
  msg.m.host[156] = (char)0;
  msg.m.host[157] = (char)0;
  msg.m.host[158] = (char)0;
  msg.m.host[159] = (char)0;
  msg.m.host[160] = (char)0;
  msg.m.host[161] = (char)0;
  msg.m.host[162] = (char)0;
  msg.m.host[163] = (char)0;
  msg.m.host[164] = (char)0;
  msg.m.host[165] = (char)0;
  msg.m.host[166] = (char)0;
  msg.m.host[167] = (char)0;
  msg.m.host[168] = (char)0;
  msg.m.host[169] = (char)0;
  msg.m.host[170] = (char)0;
  msg.m.host[171] = (char)0;
  msg.m.host[172] = (char)0;
  msg.m.host[173] = (char)0;
  msg.m.host[174] = (char)0;
  msg.m.host[175] = (char)0;
  msg.m.host[176] = (char)0;
  msg.m.host[177] = (char)0;
  msg.m.host[178] = (char)0;
  msg.m.host[179] = (char)0;
  msg.m.host[180] = (char)0;
  msg.m.host[181] = (char)0;
  msg.m.host[182] = (char)0;
  msg.m.host[183] = (char)0;
  msg.m.host[184] = (char)0;
  msg.m.host[185] = (char)0;
  msg.m.host[186] = (char)0;
  msg.m.host[187] = (char)0;
  msg.m.host[188] = (char)0;
  msg.m.host[189] = (char)0;
  msg.m.host[190] = (char)0;
  msg.m.host[191] = (char)0;
  msg.m.host[192] = (char)0;
  msg.m.host[193] = (char)0;
  msg.m.host[194] = (char)0;
  msg.m.host[195] = (char)0;
  msg.m.host[196] = (char)0;
  msg.m.host[197] = (char)0;
  msg.m.host[198] = (char)0;
  msg.m.host[199] = (char)0;
  msg.m.host[200] = (char)0;
  msg.m.host[201] = (char)0;
  msg.m.host[202] = (char)0;
  msg.m.host[203] = (char)0;
  msg.m.host[204] = (char)0;
  msg.m.host[205] = (char)0;
  msg.m.host[206] = (char)0;
  msg.m.host[207] = (char)0;
  msg.m.host[208] = (char)0;
  msg.m.host[209] = (char)0;
  msg.m.host[210] = (char)0;
  msg.m.host[211] = (char)0;
  msg.m.host[212] = (char)0;
  msg.m.host[213] = (char)0;
  msg.m.host[214] = (char)0;
  msg.m.host[215] = (char)0;
  msg.m.host[216] = (char)0;
  msg.m.host[217] = (char)0;
  msg.m.host[218] = (char)0;
  msg.m.host[219] = (char)0;
  msg.m.host[220] = (char)0;
  msg.m.host[221] = (char)0;
  msg.m.host[222] = (char)0;
  msg.m.host[223] = (char)0;
  msg.m.host[224] = (char)0;
  msg.m.host[225] = (char)0;
  msg.m.host[226] = (char)0;
  msg.m.host[227] = (char)0;
  msg.m.host[228] = (char)0;
  msg.m.host[229] = (char)0;
  msg.m.host[230] = (char)0;
  msg.m.host[231] = (char)0;
  msg.m.host[232] = (char)0;
  msg.m.host[233] = (char)0;
  msg.m.host[234] = (char)0;
  msg.m.host[235] = (char)0;
  msg.m.host[236] = (char)0;
  msg.m.host[237] = (char)0;
  msg.m.host[238] = (char)0;
  msg.m.host[239] = (char)0;
  msg.m.host[240] = (char)0;
  msg.m.host[241] = (char)0;
  msg.m.host[242] = (char)0;
  msg.m.host[243] = (char)0;
  msg.m.host[244] = (char)0;
  msg.m.host[245] = (char)0;
  msg.m.host[246] = (char)0;
  msg.m.host[247] = (char)0;
  msg.m.host[248] = (char)0;
  msg.m.host[249] = (char)0;
  msg.m.host[250] = (char)0;
  msg.m.host[251] = (char)0;
  msg.m.host[252] = (char)0;
  msg.m.host[253] = (char)0;
  msg.m.host[254] = (char)0;
  msg.m.host[255] = (char)0;
  msg.m.host[256] = (char)0;
  msg.m.host[257] = (char)0;
  msg.m.host[258] = (char)0;
  msg.m.host[259] = (char)0;
  if (len >= 256UL) {
    __constr_expr_9.as_int = (uint32_t )-1;
    return (__constr_expr_9);
  }
  memcpy((void * __restrict  )(msg.m.host), (void const   * __restrict  )host, len + 1UL);
  msg.h.datalen = htons((uint16_t )(len + 1UL));
  tmp = socket(2, 524290, 0);
  fd = tmp;
  sendto(fd, (void const   *)(& msg), (sizeof(msg.h) + len) + 1UL, 0, (struct sockaddr  const  * __restrict  )((void *)(& rdns_server)),
         (socklen_t )sizeof(rdns_server));
  recvfrom(fd, (void * __restrict  )(& msg), sizeof(msg), 0, (struct sockaddr * __restrict  )((void *)0),
           (socklen_t * __restrict  )((void *)0));
  close(fd);
  tmp___0 = ntohs(msg.h.datalen);
  if ((int )tmp___0 != 4) {
    __constr_expr_10.as_int = (uint32_t )-1;
    return (__constr_expr_10);
  }
  return (msg.m.ip);
}
}
static char const   tab[4][7]  = { {        (char const   )'o',        (char const   )'f',        (char const   )'f',        (char const   )'\000'}, 
   {        (char const   )'o',        (char const   )'l',        (char const   )'d',        (char const   )'\000'}, 
   {        (char const   )'t',        (char const   )'h',        (char const   )'r',        (char const   )'e', 
            (char const   )'a',        (char const   )'d',        (char const   )'\000'}, 
   {        (char const   )'d',        (char const   )'a',        (char const   )'e',        (char const   )'m', 
            (char const   )'o',        (char const   )'n',        (char const   )'\000'}};
char const   *rdns_resolver_string(enum dns_lookup_flavor flavor ) 
{ 


  {
  return (tab[flavor]);
}
}
static int init_done  =    0;
void rdns_init(enum dns_lookup_flavor flavor ) 
{ 


  {
  if (! init_done) {
    switch ((unsigned int )flavor) {
    case 2U: 
    at_init();
    break;
    default: 
    break;
    }
  }
  init_done = 1;
  return;
}
}
void rdns_set_daemon(struct sockaddr_in *addr ) 
{ 


  {
  rdns_server = *addr;
  return;
}
}
size_t rdns_get_host_for_ip(ip_type4 ip , char *readbuf ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
  switch ((unsigned int )proxychains_resolver) {
  case 2U: 
  tmp = at_get_host_for_ip(ip, readbuf);
  return (tmp);
  case 3U: 
  tmp___0 = rdns_daemon_get_host_for_ip(ip, readbuf);
  return (tmp___0);
  default: 
  abort();
  }
}
}
ip_type4 rdns_get_ip_for_host(char *host , size_t len ) 
{ 
  ip_type4 tmp ;
  ip_type4 tmp___0 ;

  {
  switch ((unsigned int )proxychains_resolver) {
  case 2U: 
  tmp = at_get_ip_for_host(host, len);
  return (tmp);
  case 3U: 
  tmp___0 = rdns_daemon_get_ip_for_host(host, len);
  return (tmp___0);
  default: 
  abort();
  }
}
}
#pragma merger("0","/tmp/cil-wowbJszf.i","-Wno-unknown-pragmas,-Wall,-O0,-g,-std=c99,-pipe,-fPIC")
int hostsreader_open(struct hostsreader *ctx ) 
{ 
  FILE *tmp ;

  {
  tmp = fopen((char const   * __restrict  )"/etc/hosts", (char const   * __restrict  )"r");
  ctx->f = tmp;
  if (! tmp) {
    return (0);
  }
  return (1);
}
}
void hostsreader_close(struct hostsreader *ctx ) 
{ 


  {
  fclose(ctx->f);
  return;
}
}
int hostsreader_get(struct hostsreader *ctx , char *buf___0 , size_t bufsize ) 
{ 
  char *tmp ;
  char *p ;
  size_t l ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;

  {
  while (1) {
    tmp = fgets((char * __restrict  )buf___0, (int )bufsize, (FILE * __restrict  )ctx->f);
    if (! tmp) {
      return (0);
    }
    if ((int )*buf___0 == 35) {
      continue;
    }
    p = buf___0;
    l = bufsize;
    ctx->ip = p;
    while (1) {
      if (*p) {
        tmp___0 = __ctype_b_loc();
        if ((int const   )*(*tmp___0 + (int )*p) & 8192) {
          break;
        } else
        if (! l) {
          break;
        }
      } else {
        break;
      }
      p ++;
      l --;
    }
    if (! l) {
      continue;
    } else
    if (! *p) {
      continue;
    } else
    if ((unsigned long )p == (unsigned long )ctx->ip) {
      continue;
    }
    *p = (char)0;
    p ++;
    while (1) {
      if (*p) {
        tmp___1 = __ctype_b_loc();
        if ((int const   )*(*tmp___1 + (int )*p) & 8192) {
          if (! l) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      p ++;
      l --;
    }
    if (! l) {
      continue;
    } else
    if (! *p) {
      continue;
    }
    ctx->name = p;
    while (1) {
      if (*p) {
        tmp___2 = __ctype_b_loc();
        if ((int const   )*(*tmp___2 + (int )*p) & 8192) {
          break;
        } else
        if (! l) {
          break;
        }
      } else {
        break;
      }
      p ++;
      l --;
    }
    if (! l) {
      continue;
    } else
    if (! *p) {
      continue;
    }
    *p = (char)0;
    tmp___3 = pc_isnumericipv4((char const   *)ctx->ip);
    if (tmp___3) {
      return (1);
    }
  }
}
}
char *hostsreader_get_ip_for_name(char const   *name , char *buf___0 , size_t bufsize ) 
{ 
  struct hostsreader ctx ;
  char *res ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  res = (char *)0;
  tmp = hostsreader_open(& ctx);
  if (! tmp) {
    return ((char *)0);
  }
  while (1) {
    tmp___1 = hostsreader_get(& ctx, buf___0, bufsize);
    if (! tmp___1) {
      break;
    }
    tmp___0 = strcmp((char const   *)ctx.name, name);
    if (! tmp___0) {
      res = ctx.ip;
      break;
    }
  }
  hostsreader_close(& ctx);
  return (res);
}
}
ip_type4 hostsreader_get_numeric_ip_for_name(char const   *name ) 
{ 
  char *hres ;
  char buf___0[320] ;
  struct in_addr c ;
  ip_type4 res ;
  ip_type4 __constr_expr_11 ;

  {
  hres = hostsreader_get_ip_for_name(name, buf___0, sizeof(buf___0));
  if (hres) {
    inet_aton((char const   *)hres, & c);
    memcpy((void * __restrict  )(res.octet), (void const   * __restrict  )(& c.s_addr),
           (size_t )4);
    return (res);
  } else {
    __constr_expr_11.as_int = (uint32_t )-1;
    return (__constr_expr_11);
  }
}
}
#pragma merger("0","/tmp/cil-2KY2itqe.i","-Wno-unknown-pragmas,-Wall,-O0,-g,-std=c99,-pipe,-fPIC")
uint32_t dalias_hash(char *s0 ) 
{ 
  unsigned char *s ;
  uint_fast32_t h ;
  unsigned char *tmp ;

  {
  s = (unsigned char *)((void *)s0);
  h = (uint_fast32_t )0;
  while (*s) {
    tmp = s;
    s ++;
    h = 16UL * h + (uint_fast32_t )*tmp;
    h ^= (h >> 24) & 240UL;
  }
  return ((uint32_t )(h & 268435455UL));
}
}
#pragma merger("0","/tmp/cil-m07yqmyd.i","-Wno-unknown-pragmas,-Wall,-O0,-g,-std=c99,-pipe,-fPIC")
