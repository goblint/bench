/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned short __uint16_t;
typedef unsigned int __uint32_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef int __pid_t;
struct __anonstruct___fsid_t_109580352 {
   int __val[2] ;
};
typedef struct __anonstruct___fsid_t_109580352 __fsid_t;
typedef long __time_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef unsigned long __fsblkcnt_t;
typedef unsigned long __fsfilcnt_t;
typedef long __fsword_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
typedef __mode_t mode_t;
typedef __off_t off_t;
typedef __pid_t pid_t;
typedef __ssize_t ssize_t;
typedef unsigned long size_t;
struct __anonstruct___sigset_t_991265788 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___sigset_t_991265788 __sigset_t;
typedef __sigset_t sigset_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
struct __anonstruct___wseq32_112954846 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_578844408 {
   unsigned long long __wseq ;
   struct __anonstruct___wseq32_112954846 __wseq32 ;
};
struct __anonstruct___g1_start32_175635502 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_175635501 {
   unsigned long long __g1_start ;
   struct __anonstruct___g1_start32_175635502 __g1_start32 ;
};
struct __pthread_cond_s {
   union __anonunion____missing_field_name_578844408 __annonCompField1 ;
   union __anonunion____missing_field_name_175635501 __annonCompField2 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
typedef unsigned long pthread_t;
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
union __anonunion_pthread_condattr_t_488594145 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_condattr_t_488594145 pthread_condattr_t;
typedef unsigned int pthread_key_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
union __anonunion_pthread_cond_t_951761805 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
typedef union __anonunion_pthread_cond_t_951761805 pthread_cond_t;
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef mode_t mdb_mode_t;
typedef size_t mdb_size_t;
typedef int mdb_filehandle_t;
struct MDB_env ;
typedef struct MDB_env MDB_env;
struct MDB_txn ;
typedef struct MDB_txn MDB_txn;
typedef unsigned int MDB_dbi;
struct MDB_cursor ;
typedef struct MDB_cursor MDB_cursor;
struct MDB_val {
   size_t mv_size ;
   void *mv_data ;
};
typedef struct MDB_val MDB_val;
typedef int MDB_cmp_func(MDB_val const   *a , MDB_val const   *b );
typedef void MDB_rel_func(MDB_val *item , void *oldptr , void *newptr , void *relctx );
enum MDB_cursor_op {
    MDB_FIRST = 0,
    MDB_FIRST_DUP = 1,
    MDB_GET_BOTH = 2,
    MDB_GET_BOTH_RANGE = 3,
    MDB_GET_CURRENT = 4,
    MDB_GET_MULTIPLE = 5,
    MDB_LAST = 6,
    MDB_LAST_DUP = 7,
    MDB_NEXT = 8,
    MDB_NEXT_DUP = 9,
    MDB_NEXT_MULTIPLE = 10,
    MDB_NEXT_NODUP = 11,
    MDB_PREV = 12,
    MDB_PREV_DUP = 13,
    MDB_PREV_NODUP = 14,
    MDB_SET = 15,
    MDB_SET_KEY = 16,
    MDB_SET_RANGE = 17,
    MDB_PREV_MULTIPLE = 18
} ;
typedef enum MDB_cursor_op MDB_cursor_op;
struct MDB_stat {
   unsigned int ms_psize ;
   unsigned int ms_depth ;
   mdb_size_t ms_branch_pages ;
   mdb_size_t ms_leaf_pages ;
   mdb_size_t ms_overflow_pages ;
   mdb_size_t ms_entries ;
};
typedef struct MDB_stat MDB_stat;
struct MDB_envinfo {
   void *me_mapaddr ;
   mdb_size_t me_mapsize ;
   mdb_size_t me_last_pgno ;
   mdb_size_t me_last_txnid ;
   unsigned int me_maxreaders ;
   unsigned int me_numreaders ;
};
typedef struct MDB_envinfo MDB_envinfo;
typedef void MDB_assert_func(MDB_env *env , char const   *msg );
typedef int MDB_msg_func(char const   *msg , void *ctx );
typedef mdb_size_t MDB_ID;
typedef MDB_ID *MDB_IDL;
struct MDB_ID2 {
   MDB_ID mid ;
   void *mptr ;
};
typedef struct MDB_ID2 MDB_ID2;
typedef MDB_ID2 *MDB_ID2L;
typedef pthread_mutex_t mdb_mutex_t[1];
typedef pthread_mutex_t *mdb_mutexref_t;
typedef MDB_ID pgno_t;
typedef MDB_ID txnid_t;
typedef uint16_t indx_t;
struct MDB_rxbody {
   txnid_t volatile   mrb_txnid ;
   pid_t volatile   mrb_pid ;
   pthread_t volatile   mrb_tid ;
};
typedef struct MDB_rxbody MDB_rxbody;
union __anonunion_mru_29383123 {
   MDB_rxbody mrx ;
   char pad[((sizeof(MDB_rxbody ) + 64UL) - 1UL) & 0xffffffffffffffc0UL] ;
};
struct MDB_reader {
   union __anonunion_mru_29383123 mru ;
};
typedef struct MDB_reader MDB_reader;
struct MDB_txbody {
   uint32_t mtb_magic ;
   uint32_t mtb_format ;
   txnid_t volatile   mtb_txnid ;
   unsigned int volatile   mtb_numreaders ;
   mdb_mutex_t mtb_rmutex ;
};
typedef struct MDB_txbody MDB_txbody;
union __anonunion_mt1_1001079246 {
   MDB_txbody mtb ;
   char pad[((sizeof(MDB_txbody ) + 64UL) - 1UL) & 0xffffffffffffffc0UL] ;
};
union __anonunion_mt2_574372486 {
   mdb_mutex_t mt2_wmutex ;
   char pad[((sizeof(pthread_mutex_t ) + 64UL) - 1UL) & 0xffffffffffffffc0UL] ;
};
struct MDB_txninfo {
   union __anonunion_mt1_1001079246 mt1 ;
   union __anonunion_mt2_574372486 mt2 ;
   MDB_reader mti_readers[1] ;
};
typedef struct MDB_txninfo MDB_txninfo;
union __anonunion_mp_p_409824043 {
   pgno_t p_pgno ;
   struct MDB_page *p_next ;
};
struct __anonstruct_pb_438838223 {
   indx_t pb_lower ;
   indx_t pb_upper ;
};
union __anonunion_mp_pb_280193743 {
   struct __anonstruct_pb_438838223 pb ;
   uint32_t pb_pages ;
};
struct MDB_page {
   union __anonunion_mp_p_409824043 mp_p ;
   uint16_t mp_pad ;
   uint16_t mp_flags ;
   union __anonunion_mp_pb_280193743 mp_pb ;
   indx_t mp_ptrs[1] ;
};
typedef struct MDB_page MDB_page;
struct MDB_node {
   unsigned short mn_lo ;
   unsigned short mn_hi ;
   unsigned short mn_flags ;
   unsigned short mn_ksize ;
   char mn_data[1] ;
};
typedef struct MDB_node MDB_node;
struct MDB_db {
   uint32_t md_pad ;
   uint16_t md_flags ;
   uint16_t md_depth ;
   pgno_t md_branch_pages ;
   pgno_t md_leaf_pages ;
   pgno_t md_overflow_pages ;
   mdb_size_t md_entries ;
   pgno_t md_root ;
};
typedef struct MDB_db MDB_db;
struct MDB_meta {
   uint32_t mm_magic ;
   uint32_t mm_version ;
   void *mm_address ;
   mdb_size_t mm_mapsize ;
   MDB_db mm_dbs[2] ;
   pgno_t mm_last_pg ;
   txnid_t volatile   mm_txnid ;
};
typedef struct MDB_meta MDB_meta;
struct __anonstruct_mb_metabuf_1013834518 {
   char mm_pad[(unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))] ;
   MDB_meta mm_meta ;
};
union MDB_metabuf {
   MDB_page mb_page ;
   struct __anonstruct_mb_metabuf_1013834518 mb_metabuf ;
};
typedef union MDB_metabuf MDB_metabuf;
struct MDB_dbx {
   MDB_val md_name ;
   MDB_cmp_func *md_cmp ;
   MDB_cmp_func *md_dcmp ;
   MDB_rel_func *md_rel ;
   void *md_relctx ;
};
typedef struct MDB_dbx MDB_dbx;
union __anonunion_mt_u_704457406 {
   MDB_ID2L dirty_list ;
   MDB_reader *reader ;
};
struct MDB_txn {
   MDB_txn *mt_parent ;
   MDB_txn *mt_child ;
   pgno_t mt_next_pgno ;
   txnid_t mt_txnid ;
   MDB_env *mt_env ;
   MDB_IDL mt_free_pgs ;
   MDB_page *mt_loose_pgs ;
   int mt_loose_count ;
   MDB_IDL mt_spill_pgs ;
   union __anonunion_mt_u_704457406 mt_u ;
   MDB_dbx *mt_dbxs ;
   MDB_db *mt_dbs ;
   unsigned int *mt_dbiseqs ;
   MDB_cursor **mt_cursors ;
   unsigned char *mt_dbflags ;
   MDB_dbi mt_numdbs ;
   unsigned int mt_flags ;
   unsigned int mt_dirty_room ;
};
struct MDB_xcursor ;
struct MDB_cursor {
   MDB_cursor *mc_next ;
   MDB_cursor *mc_backup ;
   struct MDB_xcursor *mc_xcursor ;
   MDB_txn *mc_txn ;
   MDB_dbi mc_dbi ;
   MDB_db *mc_db ;
   MDB_dbx *mc_dbx ;
   unsigned char *mc_dbflag ;
   unsigned short mc_snum ;
   unsigned short mc_top ;
   unsigned int mc_flags ;
   MDB_page *mc_pg[32] ;
   indx_t mc_ki[32] ;
};
struct MDB_xcursor {
   MDB_cursor mx_cursor ;
   MDB_db mx_db ;
   MDB_dbx mx_dbx ;
   unsigned char mx_dbflag ;
};
typedef struct MDB_xcursor MDB_xcursor;
struct MDB_pgstate {
   pgno_t *mf_pghead ;
   txnid_t mf_pglast ;
};
typedef struct MDB_pgstate MDB_pgstate;
struct MDB_env {
   int me_fd ;
   int me_lfd ;
   int me_mfd ;
   uint32_t me_flags ;
   unsigned int me_psize ;
   unsigned int me_os_psize ;
   unsigned int me_maxreaders ;
   int volatile   me_close_readers ;
   MDB_dbi me_numdbs ;
   MDB_dbi me_maxdbs ;
   pid_t me_pid ;
   char *me_path ;
   char *me_map ;
   MDB_txninfo *me_txns ;
   MDB_meta *me_metas[2] ;
   void *me_pbuf ;
   MDB_txn *me_txn ;
   MDB_txn *me_txn0 ;
   mdb_size_t me_mapsize ;
   off_t me_size ;
   pgno_t me_maxpg ;
   MDB_dbx *me_dbxs ;
   uint16_t *me_dbflags ;
   unsigned int *me_dbiseqs ;
   pthread_key_t me_txkey ;
   txnid_t me_pgoldest ;
   MDB_pgstate me_pgstate ;
   MDB_page *me_dpages ;
   MDB_IDL me_free_pgs ;
   MDB_ID2L me_dirty_list ;
   int me_maxfree_1pg ;
   unsigned int me_nodemax ;
   int me_live_reader ;
   void *me_userctx ;
   MDB_assert_func *me_assert_func ;
};
struct MDB_ntxn {
   MDB_txn mnt_txn ;
   MDB_pgstate mnt_pgstate ;
};
typedef struct MDB_ntxn MDB_ntxn;
enum Pidlock_op {
    Pidset = 6,
    Pidcheck = 5
} ;
typedef char mdb_nchar_t;
struct MDB_name {
   int mn_len ;
   int mn_alloced ;
   mdb_nchar_t *mn_val ;
};
typedef struct MDB_name MDB_name;
enum mdb_fopen_type {
    MDB_O_RDONLY = 0,
    MDB_O_RDWR = 66,
    MDB_O_META = 528385,
    MDB_O_COPY = 524481,
    MDB_O_MASK = 528579,
    MDB_O_LOCKS = 524358
} ;
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char domainname[65] ;
};
struct statfs {
   __fsword_t f_type ;
   __fsword_t f_bsize ;
   __fsblkcnt_t f_blocks ;
   __fsblkcnt_t f_bfree ;
   __fsblkcnt_t f_bavail ;
   __fsfilcnt_t f_files ;
   __fsfilcnt_t f_ffree ;
   __fsid_t f_fsid ;
   __fsword_t f_namelen ;
   __fsword_t f_frsize ;
   __fsword_t f_flags ;
   __fsword_t f_spare[4] ;
};
struct mdb_copy {
   MDB_env *mc_env ;
   MDB_txn *mc_txn ;
   pthread_mutex_t mc_mutex ;
   pthread_cond_t mc_cond ;
   char *mc_wbuf[2] ;
   char *mc_over[2] ;
   int mc_wlen[2] ;
   int mc_olen[2] ;
   pgno_t mc_next_pgno ;
   int mc_fd ;
   int mc_toggle ;
   int mc_new ;
   int volatile   mc_error ;
};
typedef struct mdb_copy mdb_copy;
typedef __time_t time_t;
#pragma merger("0","/tmp/cil-yqc6CwFj.i","-pthread")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat)(int __fd ,
                                                                                  struct stat *__buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigemptyset)(sigset_t *__set ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigaddset)(sigset_t *__set ,
                                                                                      int __signo ) ;
extern int ( __attribute__((__nonnull__(1,2))) sigwait)(sigset_t const   * __restrict  __set ,
                                                        int * __restrict  __sig ) ;
extern  __attribute__((__nothrow__)) int pthread_sigmask(int __how , __sigset_t const   * __restrict  __newmask ,
                                                         __sigset_t * __restrict  __oldmask ) ;
extern ssize_t writev(int __fd , struct iovec  const  *__iovec , int __count ) ;
extern  __attribute__((__nothrow__)) void *mmap(void *__addr , size_t __len , int __prot ,
                                                int __flags , int __fd , __off_t __offset ) ;
extern  __attribute__((__nothrow__)) int munmap(void *__addr , size_t __len ) ;
extern int msync(void *__addr , size_t __len , int __flags ) ;
extern  __attribute__((__nothrow__)) int madvise(void *__addr , size_t __len , int __advice ) ;
extern int fcntl(int __fd , int __cmd  , ...) ;
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
extern FILE *stderr ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) posix_memalign)(void **__memptr ,
                                                                                           size_t __alignment ,
                                                                                           size_t __size ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
extern int close(int __fd ) ;
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) ;
extern ssize_t pwrite(int __fd , void const   *__buf , size_t __n , __off_t __offset ) ;
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
extern int fsync(int __fd ) ;
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off_t __length ) ;
extern int fdatasync(int __fildes ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
extern  __attribute__((__nothrow__)) pthread_t pthread_self(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_consistent)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutexattr_init)(pthread_mutexattr_t *__attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutexattr_destroy)(pthread_mutexattr_t *__attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutexattr_setpshared)(pthread_mutexattr_t *__attr ,
                                                                                                         int __pshared ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutexattr_setrobust)(pthread_mutexattr_t *__attr ,
                                                                                                        int __robustness ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                                              pthread_condattr_t const   * __restrict  __cond_attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_destroy)(pthread_cond_t *__cond ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_signal)(pthread_cond_t *__cond ) ;
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_key_create)(pthread_key_t *__key ,
                                                                                               void (*__destr_function)(void * ) ) ;
extern  __attribute__((__nothrow__)) int pthread_key_delete(pthread_key_t __key ) ;
extern  __attribute__((__nothrow__)) void *pthread_getspecific(pthread_key_t __key ) ;
extern  __attribute__((__nothrow__)) int pthread_setspecific(pthread_key_t __key ,
                                                             void const   *__pointer ) ;
char *mdb_version(int *major , int *minor , int *patch )  __attribute__((__section__("text_env"))) ;
char *mdb_strerror(int err ) ;
int mdb_env_create(MDB_env **env )  __attribute__((__section__("text_env"))) ;
int mdb_env_open(MDB_env *env , char const   *path , unsigned int flags , mdb_mode_t mode )  __attribute__((__section__("text_env"))) ;
int mdb_env_copy(MDB_env *env , char const   *path )  __attribute__((__section__("text_env"))) ;
int mdb_env_copyfd(MDB_env *env , int fd )  __attribute__((__section__("text_env"))) ;
int mdb_env_copy2(MDB_env *env , char const   *path , unsigned int flags )  __attribute__((__section__("text_env"))) ;
int mdb_env_copyfd2(MDB_env *env , int fd , unsigned int flags )  __attribute__((__section__("text_env"))) ;
int mdb_env_stat(MDB_env *env , MDB_stat *arg )  __attribute__((__section__("text_env"))) ;
int mdb_env_info(MDB_env *env , MDB_envinfo *arg )  __attribute__((__section__("text_env"))) ;
int mdb_env_sync(MDB_env *env , int force ) ;
void mdb_env_close(MDB_env *env )  __attribute__((__section__("text_env"))) ;
int mdb_env_set_flags(MDB_env *env , unsigned int flag , int onoff )  __attribute__((__section__("text_env"))) ;
int mdb_env_get_flags(MDB_env *env , unsigned int *arg )  __attribute__((__section__("text_env"))) ;
int mdb_env_get_path(MDB_env *env , char const   **arg )  __attribute__((__section__("text_env"))) ;
int mdb_env_get_fd(MDB_env *env , mdb_filehandle_t *arg )  __attribute__((__section__("text_env"))) ;
int mdb_env_set_mapsize(MDB_env *env , mdb_size_t size )  __attribute__((__section__("text_env"))) ;
int mdb_env_set_maxreaders(MDB_env *env , unsigned int readers )  __attribute__((__section__("text_env"))) ;
int mdb_env_get_maxreaders(MDB_env *env , unsigned int *readers )  __attribute__((__section__("text_env"))) ;
int mdb_env_set_maxdbs(MDB_env *env , MDB_dbi dbs )  __attribute__((__section__("text_env"))) ;
int mdb_env_get_maxkeysize(MDB_env *env )  __attribute__((__section__("text_env"))) ;
int mdb_env_set_userctx(MDB_env *env , void *ctx )  __attribute__((__section__("text_env"))) ;
void *mdb_env_get_userctx(MDB_env *env )  __attribute__((__section__("text_env"))) ;
int mdb_env_set_assert(MDB_env *env , MDB_assert_func *func )  __attribute__((__section__("text_env"))) ;
int mdb_txn_begin(MDB_env *env , MDB_txn *parent , unsigned int flags , MDB_txn **ret ) ;
MDB_env *mdb_txn_env(MDB_txn *txn ) ;
mdb_size_t mdb_txn_id(MDB_txn *txn ) ;
int mdb_txn_commit(MDB_txn *txn ) ;
void mdb_txn_abort(MDB_txn *txn ) ;
void mdb_txn_reset(MDB_txn *txn ) ;
int mdb_txn_renew(MDB_txn *txn ) ;
int mdb_dbi_open(MDB_txn *txn , char const   *name , unsigned int flags , MDB_dbi *dbi ) ;
int mdb_stat(MDB_txn *txn , MDB_dbi dbi , MDB_stat *arg )  __attribute__((__section__("text_env"))) ;
int mdb_dbi_flags(MDB_txn *txn , MDB_dbi dbi , unsigned int *flags ) ;
void mdb_dbi_close(MDB_env *env , MDB_dbi dbi ) ;
int mdb_drop(MDB_txn *txn , MDB_dbi dbi , int del ) ;
int mdb_set_compare(MDB_txn *txn , MDB_dbi dbi , MDB_cmp_func *cmp ) ;
int mdb_set_dupsort(MDB_txn *txn , MDB_dbi dbi , MDB_cmp_func *cmp ) ;
int mdb_set_relfunc(MDB_txn *txn , MDB_dbi dbi , MDB_rel_func *rel ) ;
int mdb_set_relctx(MDB_txn *txn , MDB_dbi dbi , void *ctx ) ;
int mdb_get(MDB_txn *txn , MDB_dbi dbi , MDB_val *key , MDB_val *data ) ;
int mdb_put(MDB_txn *txn , MDB_dbi dbi , MDB_val *key , MDB_val *data , unsigned int flags ) ;
int mdb_del(MDB_txn *txn , MDB_dbi dbi , MDB_val *key , MDB_val *data ) ;
int mdb_cursor_open(MDB_txn *txn , MDB_dbi dbi , MDB_cursor **ret ) ;
void mdb_cursor_close(MDB_cursor *mc ) ;
int mdb_cursor_renew(MDB_txn *txn , MDB_cursor *mc ) ;
MDB_txn *mdb_cursor_txn(MDB_cursor *mc ) ;
MDB_dbi mdb_cursor_dbi(MDB_cursor *mc ) ;
int mdb_cursor_get(MDB_cursor *mc , MDB_val *key , MDB_val *data , MDB_cursor_op op ) ;
int mdb_cursor_put(MDB_cursor *mc , MDB_val *key , MDB_val *data , unsigned int flags ) ;
int mdb_cursor_del(MDB_cursor *mc , unsigned int flags ) ;
int mdb_cursor_count(MDB_cursor *mc , mdb_size_t *countp ) ;
int mdb_cmp(MDB_txn *txn , MDB_dbi dbi , MDB_val const   *a , MDB_val const   *b ) ;
int mdb_dcmp(MDB_txn *txn , MDB_dbi dbi , MDB_val const   *a , MDB_val const   *b ) ;
int mdb_reader_list(MDB_env *env , MDB_msg_func *func , void *ctx )  __attribute__((__section__("text_env"))) ;
int mdb_reader_check(MDB_env *env , int *dead )  __attribute__((__section__("text_env"))) ;
unsigned int mdb_midl_search(MDB_IDL ids , MDB_ID id ) ;
MDB_IDL mdb_midl_alloc(int num ) ;
void mdb_midl_free(MDB_IDL ids ) ;
void mdb_midl_shrink(MDB_IDL *idp ) ;
int mdb_midl_need(MDB_IDL *idp , unsigned int num ) ;
int mdb_midl_append(MDB_IDL *idp , MDB_ID id ) ;
int mdb_midl_append_list(MDB_IDL *idp , MDB_IDL app ) ;
int mdb_midl_append_range(MDB_IDL *idp , MDB_ID id , unsigned int n ) ;
void mdb_midl_xmerge(MDB_IDL idl , MDB_IDL merge ) ;
void mdb_midl_sort(MDB_IDL ids ) ;
unsigned int mdb_mid2l_search(MDB_ID2L ids , MDB_ID id ) ;
int mdb_mid2l_insert(MDB_ID2L ids , MDB_ID2 *id ) ;
int mdb_mid2l_append(MDB_ID2L ids , MDB_ID2 *id ) ;
static int mdb_mutex_failed(MDB_env *env , mdb_mutexref_t mutex , int rc )  __attribute__((__section__("text_env"))) ;
static int mdb_page_alloc(MDB_cursor *mc , int num , MDB_page **mp ) ;
static int mdb_page_new(MDB_cursor *mc , uint32_t flags , int num , MDB_page **mp ) ;
static int mdb_page_touch(MDB_cursor *mc ) ;
static void mdb_txn_end(MDB_txn *txn , unsigned int mode ) ;
static int mdb_page_get(MDB_cursor *mc , pgno_t pgno , MDB_page **ret , int *lvl ) ;
static int mdb_page_search_root(MDB_cursor *mc , MDB_val *key , int flags ) ;
static int mdb_page_search(MDB_cursor *mc , MDB_val *key , int flags ) ;
static int mdb_page_merge(MDB_cursor *csrc , MDB_cursor *cdst ) ;
static int mdb_page_split(MDB_cursor *mc , MDB_val *newkey , MDB_val *newdata , pgno_t newpgno ,
                          unsigned int nflags ) ;
static int mdb_env_read_header(MDB_env *env , int prev , MDB_meta *meta )  __attribute__((__section__("text_env"))) ;
static MDB_meta *mdb_env_pick_meta(MDB_env const   *env ) ;
static int mdb_env_write_meta(MDB_txn *txn ) ;
static void mdb_env_close0(MDB_env *env , int excl )  __attribute__((__section__("text_env"))) ;
static MDB_node *mdb_node_search(MDB_cursor *mc , MDB_val *key , int *exactp ) ;
static int mdb_node_add(MDB_cursor *mc , indx_t indx , MDB_val *key , MDB_val *data ,
                        pgno_t pgno , unsigned int flags ) ;
static void mdb_node_del(MDB_cursor *mc , int ksize ) ;
static void mdb_node_shrink(MDB_page *mp , indx_t indx ) ;
static int mdb_node_move(MDB_cursor *csrc , MDB_cursor *cdst , int fromleft ) ;
static int mdb_node_read(MDB_cursor *mc , MDB_node *leaf , MDB_val *data ) ;
static size_t mdb_leaf_size(MDB_env *env , MDB_val *key , MDB_val *data ) ;
static size_t mdb_branch_size(MDB_env *env , MDB_val *key ) ;
static int mdb_rebalance(MDB_cursor *mc ) ;
static int mdb_update_key(MDB_cursor *mc , MDB_val *key ) ;
static void mdb_cursor_pop(MDB_cursor *mc ) ;
static int mdb_cursor_push(MDB_cursor *mc , MDB_page *mp ) ;
static int mdb_cursor_del0(MDB_cursor *mc ) ;
static int mdb_del0(MDB_txn *txn , MDB_dbi dbi , MDB_val *key , MDB_val *data , unsigned int flags ) ;
static int mdb_cursor_sibling(MDB_cursor *mc , int move_right ) ;
static int mdb_cursor_next(MDB_cursor *mc , MDB_val *key , MDB_val *data , MDB_cursor_op op ) ;
static int mdb_cursor_prev(MDB_cursor *mc , MDB_val *key , MDB_val *data , MDB_cursor_op op ) ;
static int mdb_cursor_set(MDB_cursor *mc , MDB_val *key , MDB_val *data , MDB_cursor_op op ,
                          int *exactp ) ;
static int mdb_cursor_first(MDB_cursor *mc , MDB_val *key , MDB_val *data ) ;
static int mdb_cursor_last(MDB_cursor *mc , MDB_val *key , MDB_val *data ) ;
static void mdb_cursor_init(MDB_cursor *mc , MDB_txn *txn , MDB_dbi dbi , MDB_xcursor *mx ) ;
static void mdb_xcursor_init0(MDB_cursor *mc ) ;
static void mdb_xcursor_init1(MDB_cursor *mc , MDB_node *node ) ;
static void mdb_xcursor_init2(MDB_cursor *mc , MDB_xcursor *src_mx , int new_dupdata ) ;
static int mdb_drop0(MDB_cursor *mc , int subs ) ;
static void mdb_default_cmp(MDB_txn *txn , MDB_dbi dbi ) ;
static int mdb_reader_check0(MDB_env *env , int rlocked , int *dead )  __attribute__((__section__("text_env"))) ;
static int mdb_cmp_memn(MDB_val const   *a , MDB_val const   *b ) ;
static int mdb_cmp_memnr(MDB_val const   *a , MDB_val const   *b ) ;
static int mdb_cmp_int(MDB_val const   *a , MDB_val const   *b ) ;
static int mdb_cmp_cint(MDB_val const   *a , MDB_val const   *b ) ;
static int mdb_cmp_long(MDB_val const   *a , MDB_val const   *b ) ;
char *mdb_version(int *major , int *minor , int *patch )  __attribute__((__section__("text_env"))) ;
char *mdb_version(int *major , int *minor , int *patch ) 
{ 


  {
  if (major) {
    *major = 0;
  }
  if (minor) {
    *minor = 9;
  }
  if (patch) {
    *patch = 70;
  }
  return ((char *)"LMDB 0.9.70: (December 19, 2015)");
}
}
static char * const  mdb_errstr[21]  = 
  {      (char * const  )"MDB_KEYEXIST: Key/data pair already exists",      (char * const  )"MDB_NOTFOUND: No matching key/data pair found",      (char * const  )"MDB_PAGE_NOTFOUND: Requested page not found",      (char * const  )"MDB_CORRUPTED: Located page was wrong type", 
        (char * const  )"MDB_PANIC: Update of meta page failed or environment had fatal error",      (char * const  )"MDB_VERSION_MISMATCH: Database environment version mismatch",      (char * const  )"MDB_INVALID: File is not an LMDB file",      (char * const  )"MDB_MAP_FULL: Environment mapsize limit reached", 
        (char * const  )"MDB_DBS_FULL: Environment maxdbs limit reached",      (char * const  )"MDB_READERS_FULL: Environment maxreaders limit reached",      (char * const  )"MDB_TLS_FULL: Thread-local storage keys full - too many environments open",      (char * const  )"MDB_TXN_FULL: Transaction has too many dirty pages - transaction too big", 
        (char * const  )"MDB_CURSOR_FULL: Internal error - cursor stack limit reached",      (char * const  )"MDB_PAGE_FULL: Internal error - page has no more space",      (char * const  )"MDB_MAP_RESIZED: Database contents grew beyond environment mapsize",      (char * const  )"MDB_INCOMPATIBLE: Operation and DB incompatible, or DB flags changed", 
        (char * const  )"MDB_BAD_RSLOT: Invalid reuse of reader locktable slot",      (char * const  )"MDB_BAD_TXN: Transaction must abort, has a child, or is invalid",      (char * const  )"MDB_BAD_VALSIZE: Unsupported size of key/DB name/data, or wrong DUPFIXED size",      (char * const  )"MDB_BAD_DBI: The specified DBI handle was closed/changed unexpectedly", 
        (char * const  )"MDB_PROBLEM: Unexpected problem - txn should abort"};
char *mdb_strerror(int err ) 
{ 
  int i ;
  char *tmp ;

  {
  if (! err) {
    return ((char *)"Successful return: 0");
  }
  if (err >= -30799) {
    if (err <= -30779) {
      i = err - -30799;
      return ((char *)mdb_errstr[i]);
    }
  }
  tmp = strerror(err);
  return (tmp);
}
}
static void mdb_assert_fail(MDB_env *env , char const   *expr_txt , char const   *func ,
                            char const   *file , int line )  __attribute__((__section__("text_env"))) ;
static void mdb_assert_fail(MDB_env *env , char const   *expr_txt , char const   *func ,
                            char const   *file , int line ) 
{ 
  char buf[400] ;

  {
  sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%.100s:%d: Assertion \'%.200s\' failed in %.40s()",
          file, line, expr_txt, func);
  if (env->me_assert_func) {
    (*(env->me_assert_func))(env, (char const   *)(buf));
  }
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n", buf);
  abort();
}
}
int mdb_cmp(MDB_txn *txn , MDB_dbi dbi , MDB_val const   *a , MDB_val const   *b ) 
{ 
  int tmp ;

  {
  tmp = (*((txn->mt_dbxs + dbi)->md_cmp))(a, b);
  return (tmp);
}
}
int mdb_dcmp(MDB_txn *txn , MDB_dbi dbi , MDB_val const   *a , MDB_val const   *b ) 
{ 
  MDB_cmp_func *dcmp ;
  int tmp ;

  {
  dcmp = (txn->mt_dbxs + dbi)->md_dcmp;
  if ((unsigned long )dcmp == (unsigned long )(& mdb_cmp_int)) {
    if (a->mv_size == (size_t const   )sizeof(mdb_size_t )) {
      dcmp = & mdb_cmp_long;
    }
  }
  tmp = (*dcmp)(a, b);
  return (tmp);
}
}
static MDB_page *mdb_page_malloc(MDB_txn *txn , unsigned int num ) 
{ 
  MDB_env *env ;
  MDB_page *ret ;
  size_t psize ;
  size_t sz ;
  size_t off ;
  void *tmp ;

  {
  env = txn->mt_env;
  ret = env->me_dpages;
  psize = (size_t )env->me_psize;
  sz = psize;
  if (num == 1U) {
    if (ret) {
      env->me_dpages = ret->mp_p.p_next;
      return (ret);
    }
    off = (size_t )((unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs)));
    psize -= off;
  } else {
    sz *= (size_t )num;
    off = sz - psize;
  }
  tmp = malloc(sz);
  ret = (MDB_page *)tmp;
  if ((unsigned long )ret != (unsigned long )((void *)0)) {
    if (! (env->me_flags & 16777216U)) {
      memset((void *)((char *)ret + off), 0, psize);
      ret->mp_pad = (uint16_t )0;
    }
  } else {
    txn->mt_flags |= 2U;
  }
  return (ret);
}
}
static void mdb_page_free(MDB_env *env , MDB_page *mp ) 
{ 


  {
  mp->mp_p.p_next = env->me_dpages;
  env->me_dpages = mp;
  return;
}
}
static void mdb_dpage_free(MDB_env *env , MDB_page *dp ) 
{ 


  {
  if (! (((int )dp->mp_flags & 4) == 4)) {
    mdb_page_free(env, dp);
  } else
  if (dp->mp_pb.pb_pages == 1U) {
    mdb_page_free(env, dp);
  } else {
    free((void *)dp);
  }
  return;
}
}
static void mdb_dlist_free(MDB_txn *txn ) 
{ 
  MDB_env *env ;
  MDB_ID2L dl ;
  unsigned int i ;
  unsigned int n ;

  {
  env = txn->mt_env;
  dl = txn->mt_u.dirty_list;
  n = (unsigned int )(dl + 0)->mid;
  i = 1U;
  while (i <= n) {
    mdb_dpage_free(env, (MDB_page *)(dl + i)->mptr);
    i ++;
  }
  (dl + 0)->mid = (MDB_ID )0;
  return;
}
}
static int mdb_page_loose(MDB_cursor *mc , MDB_page *mp ) 
{ 
  int loose ;
  pgno_t pgno ;
  MDB_txn *txn ;
  MDB_ID2 *dl ;
  unsigned int x ;
  unsigned int tmp ;
  int rc ;
  int tmp___0 ;

  {
  loose = 0;
  pgno = mp->mp_p.p_pgno;
  txn = mc->mc_txn;
  if ((int )mp->mp_flags & 16) {
    if (mc->mc_dbi != 0U) {
      if (txn->mt_parent) {
        dl = txn->mt_u.dirty_list;
        if ((dl + 0)->mid) {
          tmp = mdb_mid2l_search(dl, pgno);
          x = tmp;
          if ((MDB_ID )x <= (dl + 0)->mid) {
            if ((dl + x)->mid == pgno) {
              if ((unsigned long )mp != (unsigned long )(dl + x)->mptr) {
                mc->mc_flags &= 4294967292U;
                txn->mt_flags |= 2U;
                return (-30779);
              }
              loose = 1;
            }
          }
        }
      } else {
        loose = 1;
      }
    }
  }
  if (loose) {
    *((MDB_page **)(mp + 2)) = txn->mt_loose_pgs;
    txn->mt_loose_pgs = mp;
    (txn->mt_loose_count) ++;
    mp->mp_flags = (uint16_t )((int )mp->mp_flags | 16384);
  } else {
    tmp___0 = mdb_midl_append(& txn->mt_free_pgs, pgno);
    rc = tmp___0;
    if (rc) {
      return (rc);
    }
  }
  return (0);
}
}
static int mdb_pages_xkeep(MDB_cursor *mc , unsigned int pflags , int all ) 
{ 
  MDB_txn *txn ;
  MDB_cursor *m3 ;
  MDB_cursor *m0 ;
  MDB_xcursor *mx ;
  MDB_page *dp ;
  MDB_page *mp ;
  MDB_node *leaf ;
  unsigned int i ;
  unsigned int j ;
  int rc ;
  int level ;
  pgno_t pgno ;

  {
  txn = mc->mc_txn;
  m0 = mc;
  rc = 0;
  i = txn->mt_numdbs;
  while (1) {
    if (mc->mc_flags & 1U) {
      m3 = mc;
      while (1) {
        mp = (MDB_page *)((void *)0);
        j = 0U;
        while (j < (unsigned int )m3->mc_snum) {
          mp = m3->mc_pg[j];
          if ((unsigned int )((int )mp->mp_flags & 49232) == pflags) {
            mp->mp_flags = (uint16_t )((int )mp->mp_flags ^ 32768);
          }
          j ++;
        }
        mx = m3->mc_xcursor;
        if (mx) {
          if (! (mx->mx_cursor.mc_flags & 1U)) {
            break;
          }
        } else {
          break;
        }
        if (mp) {
          if (! ((int )mp->mp_flags & 2)) {
            break;
          }
        } else {
          break;
        }
        leaf = (MDB_node *)(((char *)mp + (int )mp->mp_ptrs[m3->mc_ki[j - 1U]]) + 0U);
        if (! ((int )leaf->mn_flags & 2)) {
          break;
        }
        m3 = & mx->mx_cursor;
      }
    }
    mc = mc->mc_next;
    while (1) {
      if (! (! mc)) {
        if (! ((unsigned long )mc == (unsigned long )m0)) {
          break;
        }
      }
      if (i == 0U) {
        goto mark_done;
      }
      i --;
      mc = *(txn->mt_cursors + i);
    }
  }
  mark_done: 
  if (all) {
    i = 0U;
    while (i < txn->mt_numdbs) {
      if ((int )*(txn->mt_dbflags + i) & 1) {
        pgno = (txn->mt_dbs + i)->md_root;
        if (pgno == 18446744073709551615) {
          goto __Cont;
        }
        rc = mdb_page_get(m0, pgno, & dp, & level);
        if (rc != 0) {
          break;
        }
        if ((unsigned int )((int )dp->mp_flags & 49232) == pflags) {
          if (level <= 1) {
            dp->mp_flags = (uint16_t )((int )dp->mp_flags ^ 32768);
          }
        }
      }
      __Cont: /* CIL Label */ 
      i ++;
    }
  }
  return (rc);
}
}
static int mdb_page_flush(MDB_txn *txn , int keep ) ;
static int mdb_page_spill(MDB_cursor *m0 , MDB_val *key , MDB_val *data ) 
{ 
  MDB_txn *txn ;
  MDB_page *dp ;
  MDB_ID2L dl ;
  unsigned int i ;
  unsigned int j ;
  unsigned int need ;
  int rc ;
  MDB_IDL sl ;
  unsigned int num ;
  MDB_ID pn ;
  MDB_txn *tx2 ;
  int tmp ;

  {
  txn = m0->mc_txn;
  dl = txn->mt_u.dirty_list;
  if (m0->mc_flags & 4U) {
    return (0);
  }
  i = (unsigned int )(m0->mc_db)->md_depth;
  if (m0->mc_dbi >= 2U) {
    i += (unsigned int )(txn->mt_dbs + 1)->md_depth;
  }
  if (key) {
    i = (unsigned int )((unsigned long )i + ((((unsigned long )(& ((MDB_node *)0)->mn_data) + key->mv_size) + data->mv_size) + (unsigned long )(txn->mt_env)->me_psize) / (unsigned long )(txn->mt_env)->me_psize);
  }
  i += i;
  need = i;
  if (txn->mt_dirty_room > i) {
    return (0);
  }
  if (! txn->mt_spill_pgs) {
    txn->mt_spill_pgs = mdb_midl_alloc((1 << 17) - 1);
    if (! txn->mt_spill_pgs) {
      return (12);
    }
  } else {
    sl = txn->mt_spill_pgs;
    num = (unsigned int )*(sl + 0);
    j = 0U;
    i = 1U;
    while (i <= num) {
      if (! (*(sl + i) & 1UL)) {
        j ++;
        *(sl + j) = *(sl + i);
      }
      i ++;
    }
    *(sl + 0) = (MDB_ID )j;
  }
  rc = mdb_pages_xkeep(m0, 16U, 1);
  if (rc != 0) {
    goto done;
  }
  if (need < (unsigned int )(((1 << 17) - 1) / 8)) {
    need = (unsigned int )(((1 << 17) - 1) / 8);
  }
  i = (unsigned int )(dl + 0)->mid;
  while (1) {
    if (i) {
      if (! need) {
        break;
      }
    } else {
      break;
    }
    pn = (dl + i)->mid << 1;
    dp = (MDB_page *)(dl + i)->mptr;
    if ((int )dp->mp_flags & 49152) {
      goto __Cont;
    }
    if (txn->mt_parent) {
      tx2 = txn->mt_parent;
      while (tx2) {
        if (tx2->mt_spill_pgs) {
          j = mdb_midl_search(tx2->mt_spill_pgs, pn);
          if ((MDB_ID )j <= *(tx2->mt_spill_pgs + 0)) {
            if (*(tx2->mt_spill_pgs + j) == pn) {
              dp->mp_flags = (uint16_t )((int )dp->mp_flags | 32768);
              break;
            }
          }
        }
        tx2 = tx2->mt_parent;
      }
      if (tx2) {
        goto __Cont;
      }
    }
    rc = mdb_midl_append(& txn->mt_spill_pgs, pn);
    if (rc) {
      goto done;
    }
    need --;
    __Cont: /* CIL Label */ 
    i --;
  }
  mdb_midl_sort(txn->mt_spill_pgs);
  rc = mdb_page_flush(txn, (int )i);
  if (rc != 0) {
    goto done;
  }
  rc = mdb_pages_xkeep(m0, 32784U, (int )i);
  done: 
  if (rc) {
    tmp = 2;
  } else {
    tmp = 8;
  }
  txn->mt_flags |= (unsigned int )tmp;
  return (rc);
}
}
static txnid_t mdb_find_oldest(MDB_txn *txn ) 
{ 
  int i ;
  txnid_t mr ;
  txnid_t oldest ;
  MDB_reader *r ;

  {
  oldest = txn->mt_txnid - 1UL;
  if ((txn->mt_env)->me_txns) {
    r = ((txn->mt_env)->me_txns)->mti_readers;
    i = (int )((txn->mt_env)->me_txns)->mt1.mtb.mtb_numreaders;
    while (1) {
      i --;
      if (! (i >= 0)) {
        break;
      }
      if ((r + i)->mru.mrx.mrb_pid) {
        mr = (txnid_t )(r + i)->mru.mrx.mrb_txnid;
        if (oldest > mr) {
          oldest = mr;
        }
      }
    }
  }
  return (oldest);
}
}
static void mdb_page_dirty(MDB_txn *txn , MDB_page *mp ) 
{ 
  MDB_ID2 mid ;
  int rc ;
  int (*insert)(MDB_ID2L  , MDB_ID2 * ) ;

  {
  if (txn->mt_flags & 524288U) {
    insert = & mdb_mid2l_append;
  } else {
    insert = & mdb_mid2l_insert;
  }
  mid.mid = mp->mp_p.p_pgno;
  mid.mptr = (void *)mp;
  rc = (*insert)(txn->mt_u.dirty_list, & mid);
  if (! (rc == 0)) {
    mdb_assert_fail(txn->mt_env, "rc == 0", "mdb_page_dirty", "mdb.c", 2412);
  }
  (txn->mt_dirty_room) --;
  return;
}
}
static int mdb_page_alloc(MDB_cursor *mc , int num , MDB_page **mp ) 
{ 
  int rc ;
  int retry ;
  MDB_txn *txn ;
  MDB_env *env ;
  pgno_t pgno ;
  pgno_t *mop ;
  unsigned int i ;
  unsigned int j ;
  unsigned int mop_len ;
  pgno_t tmp ;
  unsigned int n2 ;
  MDB_page *np ;
  txnid_t oldest ;
  txnid_t last ;
  MDB_cursor_op op ;
  MDB_cursor m2 ;
  int found_old ;
  MDB_val key ;
  MDB_val data ;
  MDB_node *leaf ;
  pgno_t *idl ;
  pgno_t *tmp___0 ;

  {
  retry = num * 60;
  txn = mc->mc_txn;
  env = txn->mt_env;
  mop = env->me_pgstate.mf_pghead;
  if (mop) {
    tmp = *(mop + 0);
  } else {
    tmp = (pgno_t )0;
  }
  mop_len = (unsigned int )tmp;
  n2 = (unsigned int )(num - 1);
  oldest = (txnid_t )0;
  found_old = 0;
  if (num == 1) {
    if (txn->mt_loose_pgs) {
      np = txn->mt_loose_pgs;
      txn->mt_loose_pgs = *((MDB_page **)(np + 2));
      (txn->mt_loose_count) --;
      *mp = np;
      return (0);
    }
  }
  *mp = (MDB_page *)((void *)0);
  if (txn->mt_dirty_room == 0U) {
    rc = -30788;
    goto fail;
  }
  op = (MDB_cursor_op )0;
  while (1) {
    if (mop_len > n2) {
      i = mop_len;
      while (1) {
        pgno = *(mop + i);
        if (*(mop + (i - n2)) == pgno + (pgno_t )n2) {
          goto search_done;
        }
        i --;
        if (! (i > n2)) {
          break;
        }
      }
      retry --;
      if (retry < 0) {
        break;
      }
    }
    if ((unsigned int )op == 0U) {
      last = env->me_pgstate.mf_pglast;
      oldest = env->me_pgoldest;
      mdb_cursor_init(& m2, txn, (MDB_dbi )0, (MDB_xcursor *)((void *)0));
      if (last) {
        op = (MDB_cursor_op )17;
        key.mv_data = (void *)(& last);
        key.mv_size = sizeof(last);
      }
    }
    last ++;
    if (oldest <= last) {
      if (! found_old) {
        oldest = mdb_find_oldest(txn);
        env->me_pgoldest = oldest;
        found_old = 1;
      }
      if (oldest <= last) {
        break;
      }
    }
    rc = mdb_cursor_get(& m2, & key, (MDB_val *)((void *)0), op);
    if (rc) {
      if (rc == -30798) {
        break;
      }
      goto fail;
    }
    last = *((txnid_t *)key.mv_data);
    if (oldest <= last) {
      if (! found_old) {
        oldest = mdb_find_oldest(txn);
        env->me_pgoldest = oldest;
        found_old = 1;
      }
      if (oldest <= last) {
        break;
      }
    }
    np = m2.mc_pg[m2.mc_top];
    leaf = (MDB_node *)(((char *)np + (int )np->mp_ptrs[m2.mc_ki[m2.mc_top]]) + 0U);
    rc = mdb_node_read(& m2, leaf, & data);
    if (rc != 0) {
      goto fail;
    }
    idl = (MDB_ID *)data.mv_data;
    i = (unsigned int )*(idl + 0);
    if (! mop) {
      mop = mdb_midl_alloc((int )i);
      tmp___0 = mop;
      env->me_pgstate.mf_pghead = tmp___0;
      if (! tmp___0) {
        rc = 12;
        goto fail;
      }
    } else {
      rc = mdb_midl_need(& env->me_pgstate.mf_pghead, i);
      if (rc != 0) {
        goto fail;
      }
      mop = env->me_pgstate.mf_pghead;
    }
    env->me_pgstate.mf_pglast = last;
    mdb_midl_xmerge(mop, idl);
    mop_len = (unsigned int )*(mop + 0);
    op = (MDB_cursor_op )8;
  }
  i = 0U;
  pgno = txn->mt_next_pgno;
  if (pgno + (pgno_t )num >= env->me_maxpg) {
    rc = -30792;
    goto fail;
  }
  search_done: 
  if (env->me_flags & 524288U) {
    np = (MDB_page *)(env->me_map + (pgno_t )env->me_psize * pgno);
  } else {
    np = mdb_page_malloc(txn, (unsigned int )num);
    if (! np) {
      rc = 12;
      goto fail;
    }
  }
  if (i) {
    mop_len -= (unsigned int )num;
    *(mop + 0) = (pgno_t )mop_len;
    j = i - (unsigned int )num;
    while (j < mop_len) {
      j ++;
      i ++;
      *(mop + j) = *(mop + i);
    }
  } else {
    txn->mt_next_pgno = pgno + (pgno_t )num;
  }
  np->mp_p.p_pgno = pgno;
  mdb_page_dirty(txn, np);
  *mp = np;
  return (0);
  fail: 
  txn->mt_flags |= 2U;
  return (rc);
}
}
static void mdb_page_copy(MDB_page *dst , MDB_page *src , unsigned int psize ) 
{ 
  indx_t upper ;
  indx_t lower ;
  indx_t unused ;

  {
  upper = src->mp_pb.pb.pb_upper;
  lower = src->mp_pb.pb.pb_lower;
  unused = (indx_t )((int )upper - (int )lower);
  unused = (indx_t )((int )unused & -8);
  if (unused) {
    if (! (((int )src->mp_flags & 32) == 32)) {
      upper = (indx_t )((unsigned int )upper & 4294967288U);
      memcpy((void * __restrict  )dst, (void const   * __restrict  )src, (size_t )(((unsigned int )lower + 7U) & 4294967288U));
      memcpy((void * __restrict  )((pgno_t *)((char *)dst + (int )upper)), (void const   * __restrict  )((pgno_t *)((char *)src + (int )upper)),
             (size_t )(psize - (unsigned int )upper));
    } else {
      memcpy((void * __restrict  )dst, (void const   * __restrict  )src, (size_t )(psize - (unsigned int )unused));
    }
  } else {
    memcpy((void * __restrict  )dst, (void const   * __restrict  )src, (size_t )(psize - (unsigned int )unused));
  }
  return;
}
}
static int mdb_page_unspill(MDB_txn *txn , MDB_page *mp , MDB_page **ret ) 
{ 
  MDB_env *env ;
  MDB_txn const   *tx2 ;
  unsigned int x ;
  pgno_t pgno ;
  pgno_t pn ;
  MDB_page *np ;
  int num ;

  {
  env = txn->mt_env;
  pgno = mp->mp_p.p_pgno;
  pn = pgno << 1;
  tx2 = (MDB_txn const   *)txn;
  while (tx2) {
    if (! tx2->mt_spill_pgs) {
      goto __Cont;
    }
    x = mdb_midl_search((MDB_IDL )tx2->mt_spill_pgs, pn);
    if ((MDB_ID )x <= *(tx2->mt_spill_pgs + 0)) {
      if (*(tx2->mt_spill_pgs + x) == pn) {
        if (txn->mt_dirty_room == 0U) {
          return (-30788);
        }
        if (((int )mp->mp_flags & 4) == 4) {
          num = (int )mp->mp_pb.pb_pages;
        } else {
          num = 1;
        }
        if (env->me_flags & 524288U) {
          np = mp;
        } else {
          np = mdb_page_malloc(txn, (unsigned int )num);
          if (! np) {
            return (12);
          }
          if (num > 1) {
            memcpy((void * __restrict  )np, (void const   * __restrict  )mp, (size_t )((unsigned int )num * env->me_psize));
          } else {
            mdb_page_copy(np, mp, env->me_psize);
          }
        }
        if ((unsigned long )tx2 == (unsigned long )txn) {
          if ((MDB_ID )x == *(txn->mt_spill_pgs + 0)) {
            (*(txn->mt_spill_pgs + 0)) --;
          } else {
            *(txn->mt_spill_pgs + x) |= 1UL;
          }
        }
        mdb_page_dirty(txn, np);
        np->mp_flags = (uint16_t )((int )np->mp_flags | 16);
        *ret = np;
        break;
      }
    }
    __Cont: /* CIL Label */ 
    tx2 = (MDB_txn const   *)tx2->mt_parent;
  }
  return (0);
}
}
static int mdb_page_touch(MDB_cursor *mc ) 
{ 
  MDB_page *mp ;
  MDB_page *np ;
  MDB_txn *txn ;
  MDB_cursor *m2 ;
  MDB_cursor *m3 ;
  pgno_t pgno ;
  int rc ;
  MDB_ID *xidl ;
  MDB_ID xlen ;
  MDB_page *parent ;
  MDB_node *node ;
  MDB_ID2 mid ;
  MDB_ID2 *dl ;
  unsigned int x ;
  unsigned int tmp ;
  MDB_page *xr_pg ;
  MDB_node *xr_node ;

  {
  mp = mc->mc_pg[mc->mc_top];
  txn = mc->mc_txn;
  if (! (((int )mp->mp_flags & 16) == 16)) {
    if (txn->mt_flags & 8U) {
      np = (MDB_page *)((void *)0);
      rc = mdb_page_unspill(txn, mp, & np);
      if (rc) {
        goto fail;
      }
      if (np) {
        goto done;
      }
    }
    rc = mdb_midl_need(& txn->mt_free_pgs, 1U);
    if (rc) {
      goto fail;
    } else {
      rc = mdb_page_alloc(mc, 1, & np);
      if (rc) {
        goto fail;
      }
    }
    pgno = np->mp_p.p_pgno;
    if (! (mp->mp_p.p_pgno != pgno)) {
      mdb_assert_fail((mc->mc_txn)->mt_env, "mp->mp_pgno != pgno", "mdb_page_touch",
                      "mdb.c", 2741);
    }
    while (1) {
      xidl = txn->mt_free_pgs;
      (*(xidl + 0)) ++;
      xlen = *(xidl + 0);
      *(xidl + xlen) = mp->mp_p.p_pgno;
      break;
    }
    if (mc->mc_top) {
      parent = mc->mc_pg[(int )mc->mc_top - 1];
      node = (MDB_node *)(((char *)parent + (int )parent->mp_ptrs[mc->mc_ki[(int )mc->mc_top - 1]]) + 0U);
      while (1) {
        node->mn_lo = (unsigned short )(pgno & 65535UL);
        node->mn_hi = (unsigned short )(pgno >> 16);
        node->mn_flags = (unsigned short )(pgno >> 32);
        break;
      }
    } else {
      (mc->mc_db)->md_root = pgno;
    }
  } else
  if (txn->mt_parent) {
    if (! (((int )mp->mp_flags & 64) == 64)) {
      dl = txn->mt_u.dirty_list;
      pgno = mp->mp_p.p_pgno;
      if ((dl + 0)->mid) {
        tmp = mdb_mid2l_search(dl, pgno);
        x = tmp;
        if ((MDB_ID )x <= (dl + 0)->mid) {
          if ((dl + x)->mid == pgno) {
            if ((unsigned long )mp != (unsigned long )(dl + x)->mptr) {
              mc->mc_flags &= 4294967292U;
              txn->mt_flags |= 2U;
              return (-30779);
            }
            return (0);
          }
        }
      }
      if (! ((dl + 0)->mid < (MDB_ID )((1 << 17) - 1))) {
        mdb_assert_fail((mc->mc_txn)->mt_env, "dl[0].mid < MDB_IDL_UM_MAX", "mdb_page_touch",
                        "mdb.c", 2768);
      }
      np = mdb_page_malloc(txn, 1U);
      if (! np) {
        return (12);
      }
      mid.mid = pgno;
      mid.mptr = (void *)np;
      rc = mdb_mid2l_insert(dl, & mid);
      if (! (rc == 0)) {
        mdb_assert_fail((mc->mc_txn)->mt_env, "rc == 0", "mdb_page_touch", "mdb.c",
                        2776);
      }
    } else {
      return (0);
    }
  } else {
    return (0);
  }
  mdb_page_copy(np, mp, (txn->mt_env)->me_psize);
  np->mp_p.p_pgno = pgno;
  np->mp_flags = (uint16_t )((int )np->mp_flags | 16);
  done: 
  mc->mc_pg[mc->mc_top] = np;
  m2 = *(txn->mt_cursors + mc->mc_dbi);
  if (mc->mc_flags & 4U) {
    while (m2) {
      m3 = & (m2->mc_xcursor)->mx_cursor;
      if ((int )m3->mc_snum < (int )mc->mc_snum) {
        goto __Cont;
      }
      if ((unsigned long )m3->mc_pg[mc->mc_top] == (unsigned long )mp) {
        m3->mc_pg[mc->mc_top] = np;
      }
      __Cont: /* CIL Label */ 
      m2 = m2->mc_next;
    }
  } else {
    while (m2) {
      if ((int )m2->mc_snum < (int )mc->mc_snum) {
        goto __Cont___0;
      }
      if ((unsigned long )m2 == (unsigned long )mc) {
        goto __Cont___0;
      }
      if ((unsigned long )m2->mc_pg[mc->mc_top] == (unsigned long )mp) {
        m2->mc_pg[mc->mc_top] = np;
        if (((int )np->mp_flags & 2) == 2) {
          while (1) {
            xr_pg = np;
            if (m2->mc_xcursor) {
              if ((m2->mc_xcursor)->mx_cursor.mc_flags & 1U) {
                if ((unsigned int )m2->mc_ki[mc->mc_top] >= ((unsigned int )xr_pg->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) {
                  break;
                }
              } else {
                break;
              }
            } else {
              break;
            }
            xr_node = (MDB_node *)(((char *)xr_pg + (int )xr_pg->mp_ptrs[m2->mc_ki[mc->mc_top]]) + 0U);
            if (((int )xr_node->mn_flags & 6) == 4) {
              (m2->mc_xcursor)->mx_cursor.mc_pg[0] = (MDB_page *)((void *)(xr_node->mn_data + (int )xr_node->mn_ksize));
            }
            break;
          }
        }
      }
      __Cont___0: /* CIL Label */ 
      m2 = m2->mc_next;
    }
  }
  return (0);
  fail: 
  txn->mt_flags |= 2U;
  return (rc);
}
}
int mdb_env_sync0(MDB_env *env , int force , pgno_t numpgs ) 
{ 
  int rc ;
  int flags ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
  rc = 0;
  if (env->me_flags & 131072U) {
    return (13);
  }
  if (force) {
    goto _L;
  } else
  if (! (env->me_flags & 65536U)) {
    _L: /* CIL Label */ 
    if (env->me_flags & 524288U) {
      if (env->me_flags & 1048576U) {
        if (! force) {
          tmp = 1;
        } else {
          tmp = 4;
        }
      } else {
        tmp = 4;
      }
      flags = tmp;
      tmp___1 = msync((void *)env->me_map, (pgno_t )env->me_psize * numpgs, flags);
      if (tmp___1) {
        tmp___0 = __errno_location();
        rc = *tmp___0;
      }
    } else
    if (env->me_flags & 134217728U) {
      tmp___3 = fsync(env->me_fd);
      if (tmp___3) {
        tmp___2 = __errno_location();
        rc = *tmp___2;
      }
    } else {
      tmp___5 = fdatasync(env->me_fd);
      if (tmp___5) {
        tmp___4 = __errno_location();
        rc = *tmp___4;
      }
    }
  }
  return (rc);
}
}
int mdb_env_sync(MDB_env *env , int force ) 
{ 
  MDB_meta *m ;
  MDB_meta *tmp ;
  int tmp___0 ;

  {
  tmp = mdb_env_pick_meta((MDB_env const   *)env);
  m = tmp;
  tmp___0 = mdb_env_sync0(env, force, m->mm_last_pg + 1UL);
  return (tmp___0);
}
}
static int mdb_cursor_shadow(MDB_txn *src , MDB_txn *dst ) 
{ 
  MDB_cursor *mc ;
  MDB_cursor *bk ;
  MDB_xcursor *mx ;
  size_t size ;
  int i ;
  void *tmp ;

  {
  i = (int )src->mt_numdbs;
  while (1) {
    i --;
    if (! (i >= 0)) {
      break;
    }
    mc = *(src->mt_cursors + i);
    if ((unsigned long )mc != (unsigned long )((void *)0)) {
      size = sizeof(MDB_cursor );
      if (mc->mc_xcursor) {
        size += sizeof(MDB_xcursor );
      }
      while (mc) {
        tmp = malloc(size);
        bk = (MDB_cursor *)tmp;
        if (! bk) {
          return (12);
        }
        *bk = *mc;
        mc->mc_backup = bk;
        mc->mc_db = dst->mt_dbs + i;
        mc->mc_txn = dst;
        mc->mc_dbflag = dst->mt_dbflags + i;
        mx = mc->mc_xcursor;
        if ((unsigned long )mx != (unsigned long )((void *)0)) {
          *((MDB_xcursor *)(bk + 1)) = *mx;
          mx->mx_cursor.mc_txn = dst;
        }
        mc->mc_next = *(dst->mt_cursors + i);
        *(dst->mt_cursors + i) = mc;
        mc = bk->mc_next;
      }
    }
  }
  return (0);
}
}
static void mdb_cursors_close(MDB_txn *txn , unsigned int merge ) 
{ 
  MDB_cursor **cursors ;
  MDB_cursor *mc ;
  MDB_cursor *next ;
  MDB_cursor *bk ;
  MDB_xcursor *mx ;
  int i ;

  {
  cursors = txn->mt_cursors;
  i = (int )txn->mt_numdbs;
  while (1) {
    i --;
    if (! (i >= 0)) {
      break;
    }
    mc = *(cursors + i);
    while (mc) {
      next = mc->mc_next;
      bk = mc->mc_backup;
      if ((unsigned long )bk != (unsigned long )((void *)0)) {
        if (merge) {
          mc->mc_next = bk->mc_next;
          mc->mc_backup = bk->mc_backup;
          mc->mc_txn = bk->mc_txn;
          mc->mc_db = bk->mc_db;
          mc->mc_dbflag = bk->mc_dbflag;
          mx = mc->mc_xcursor;
          if ((unsigned long )mx != (unsigned long )((void *)0)) {
            mx->mx_cursor.mc_txn = bk->mc_txn;
          }
        } else {
          *mc = *bk;
          mx = mc->mc_xcursor;
          if ((unsigned long )mx != (unsigned long )((void *)0)) {
            *mx = *((MDB_xcursor *)(bk + 1));
          }
        }
        mc = bk;
      }
      free((void *)mc);
      mc = next;
    }
    *(cursors + i) = (MDB_cursor *)((void *)0);
  }
  return;
}
}
static int mdb_reader_pid(MDB_env *env , enum Pidlock_op op , pid_t pid ) 
{ 
  int rc ;
  struct flock lock_info ;
  int *tmp ;

  {
  while (1) {
    memset((void *)(& lock_info), 0, sizeof(lock_info));
    lock_info.l_type = (short)1;
    lock_info.l_whence = (short)0;
    lock_info.l_start = (__off_t )pid;
    lock_info.l_len = (__off_t )1;
    rc = fcntl(env->me_lfd, (int )op, & lock_info);
    if (rc == 0) {
      if ((unsigned int )op == 5U) {
        if ((int )lock_info.l_type != 2) {
          rc = -1;
        }
      }
    } else {
      tmp = __errno_location();
      rc = *tmp;
      if (rc == 4) {
        goto __Cont;
      }
    }
    return (rc);
    __Cont: /* CIL Label */ ;
  }
}
}
static int mdb_txn_renew0(MDB_txn *txn ) 
{ 
  MDB_env *env ;
  MDB_txninfo *ti ;
  MDB_meta *meta ;
  unsigned int i ;
  unsigned int nr ;
  unsigned int flags ;
  uint16_t x ;
  int rc ;
  int new_notls ;
  MDB_reader *r ;
  void *tmp ;
  void *tmp___0 ;
  pid_t pid ;
  pthread_t tid ;
  pthread_t tmp___1 ;
  mdb_mutexref_t rmutex ;

  {
  env = txn->mt_env;
  ti = env->me_txns;
  flags = txn->mt_flags;
  new_notls = 0;
  flags &= 131072U;
  if (flags != 0U) {
    if (! ti) {
      meta = mdb_env_pick_meta((MDB_env const   *)env);
      txn->mt_txnid = (txnid_t )meta->mm_txnid;
      txn->mt_u.reader = (MDB_reader *)((void *)0);
    } else {
      if (env->me_flags & 2097152U) {
        tmp___0 = (void *)txn->mt_u.reader;
      } else {
        tmp = pthread_getspecific(env->me_txkey);
        tmp___0 = tmp;
      }
      r = (MDB_reader *)tmp___0;
      if (r) {
        if (r->mru.mrx.mrb_pid != (pid_t volatile   )env->me_pid) {
          return (-30783);
        } else
        if (r->mru.mrx.mrb_txnid != (txnid_t volatile   )0xffffffffffffffffUL) {
          return (-30783);
        }
      } else {
        pid = env->me_pid;
        tmp___1 = pthread_self();
        tid = tmp___1;
        rmutex = (env->me_txns)->mt1.mtb.mtb_rmutex;
        if (! env->me_live_reader) {
          rc = mdb_reader_pid(env, (enum Pidlock_op )6, pid);
          if (rc) {
            return (rc);
          }
          env->me_live_reader = 1;
        }
        rc = pthread_mutex_lock(rmutex);
        if (rc) {
          rc = mdb_mutex_failed(env, rmutex, rc);
          if (rc) {
            return (rc);
          }
        }
        nr = (unsigned int )ti->mt1.mtb.mtb_numreaders;
        i = 0U;
        while (i < nr) {
          if (ti->mti_readers[i].mru.mrx.mrb_pid == (pid_t volatile   )0) {
            break;
          }
          i ++;
        }
        if (i == env->me_maxreaders) {
          pthread_mutex_unlock(rmutex);
          return (-30790);
        }
        r = & ti->mti_readers[i];
        r->mru.mrx.mrb_pid = (pid_t volatile   )0;
        r->mru.mrx.mrb_txnid = (txnid_t volatile   )((txnid_t )-1);
        r->mru.mrx.mrb_tid = (pthread_t volatile   )tid;
        if (i == nr) {
          nr ++;
          ti->mt1.mtb.mtb_numreaders = (unsigned int volatile   )nr;
        }
        env->me_close_readers = (int volatile   )nr;
        r->mru.mrx.mrb_pid = (pid_t volatile   )pid;
        pthread_mutex_unlock(rmutex);
        new_notls = (int )(env->me_flags & 2097152U);
        if (! new_notls) {
          rc = pthread_setspecific(env->me_txkey, (void const   *)r);
          if (rc) {
            r->mru.mrx.mrb_pid = (pid_t volatile   )0;
            return (rc);
          }
        }
      }
      while (1) {
        r->mru.mrx.mrb_txnid = ti->mt1.mtb.mtb_txnid;
        if (! (r->mru.mrx.mrb_txnid != ti->mt1.mtb.mtb_txnid)) {
          break;
        }
      }
      txn->mt_txnid = (txnid_t )r->mru.mrx.mrb_txnid;
      txn->mt_u.reader = r;
      meta = env->me_metas[txn->mt_txnid & 1UL];
    }
  } else {
    if (ti) {
      rc = pthread_mutex_lock((env->me_txns)->mt2.mt2_wmutex);
      if (rc) {
        rc = mdb_mutex_failed(env, (env->me_txns)->mt2.mt2_wmutex, rc);
        if (rc) {
          return (rc);
        }
      }
      txn->mt_txnid = (txnid_t )ti->mt1.mtb.mtb_txnid;
      meta = env->me_metas[txn->mt_txnid & 1UL];
    } else {
      meta = mdb_env_pick_meta((MDB_env const   *)env);
      txn->mt_txnid = (txnid_t )meta->mm_txnid;
    }
    (txn->mt_txnid) ++;
    txn->mt_child = (MDB_txn *)((void *)0);
    txn->mt_loose_pgs = (MDB_page *)((void *)0);
    txn->mt_loose_count = 0;
    txn->mt_dirty_room = (unsigned int )((1 << 17) - 1);
    txn->mt_u.dirty_list = env->me_dirty_list;
    (txn->mt_u.dirty_list + 0)->mid = (MDB_ID )0;
    txn->mt_free_pgs = env->me_free_pgs;
    *(txn->mt_free_pgs + 0) = (MDB_ID )0;
    txn->mt_spill_pgs = (MDB_IDL )((void *)0);
    env->me_txn = txn;
    memcpy((void * __restrict  )txn->mt_dbiseqs, (void const   * __restrict  )env->me_dbiseqs,
           (unsigned long )env->me_maxdbs * sizeof(unsigned int ));
  }
  memcpy((void * __restrict  )txn->mt_dbs, (void const   * __restrict  )(meta->mm_dbs),
         2UL * sizeof(MDB_db ));
  txn->mt_next_pgno = meta->mm_last_pg + 1UL;
  txn->mt_flags = flags;
  txn->mt_numdbs = env->me_numdbs;
  i = 2U;
  while (i < txn->mt_numdbs) {
    x = *(env->me_dbflags + i);
    (txn->mt_dbs + i)->md_flags = (uint16_t )((int )x & 32767);
    if ((int )x & 32768) {
      *(txn->mt_dbflags + i) = (unsigned char)26;
    } else {
      *(txn->mt_dbflags + i) = (unsigned char)0;
    }
    i ++;
  }
  *(txn->mt_dbflags + 1) = (unsigned char)24;
  *(txn->mt_dbflags + 0) = (unsigned char)8;
  if (env->me_flags & 2147483648U) {
    rc = -30795;
  } else
  if (env->me_maxpg < txn->mt_next_pgno) {
    rc = -30785;
  } else {
    return (0);
  }
  mdb_txn_end(txn, (unsigned int )(new_notls | 5));
  return (rc);
}
}
int mdb_txn_renew(MDB_txn *txn ) 
{ 
  int rc ;

  {
  if (! txn) {
    return (22);
  } else
  if (! ((txn->mt_flags & 131073U) == 131073U)) {
    return (22);
  }
  rc = mdb_txn_renew0(txn);
  return (rc);
}
}
int mdb_txn_begin(MDB_env *env , MDB_txn *parent , unsigned int flags , MDB_txn **ret ) 
{ 
  MDB_txn *txn ;
  MDB_ntxn *ntxn ;
  int rc ;
  int size ;
  int tsize ;
  int tmp ;
  void *tmp___0 ;
  unsigned int i ;
  void *tmp___1 ;
  MDB_IDL tmp___2 ;

  {
  flags &= 458752U;
  flags |= env->me_flags & 524288U;
  if ((env->me_flags & 131072U) & ~ flags) {
    return (13);
  }
  if (parent) {
    flags |= parent->mt_flags;
    if (flags & 655379U) {
      if (parent->mt_flags & 131072U) {
        tmp = 22;
      } else {
        tmp = -30782;
      }
      return (tmp);
    }
    size = (int )((unsigned long )env->me_maxdbs * ((sizeof(MDB_db ) + sizeof(MDB_cursor *)) + 1UL));
    tsize = (int )sizeof(MDB_ntxn );
    size += tsize;
  } else
  if (flags & 131072U) {
    size = (int )((unsigned long )env->me_maxdbs * (sizeof(MDB_db ) + 1UL));
    tsize = (int )sizeof(MDB_txn );
    size += tsize;
  } else {
    txn = env->me_txn0;
    goto renew;
  }
  tmp___0 = calloc((size_t )1, (size_t )size);
  txn = (MDB_txn *)tmp___0;
  if ((unsigned long )txn == (unsigned long )((void *)0)) {
    return (12);
  }
  txn->mt_dbxs = env->me_dbxs;
  txn->mt_dbs = (MDB_db *)((char *)txn + tsize);
  txn->mt_dbflags = ((unsigned char *)txn + size) - env->me_maxdbs;
  txn->mt_flags = flags;
  txn->mt_env = env;
  if (parent) {
    txn->mt_cursors = (MDB_cursor **)(txn->mt_dbs + env->me_maxdbs);
    txn->mt_dbiseqs = parent->mt_dbiseqs;
    tmp___1 = malloc(sizeof(MDB_ID2 ) * (unsigned long )(1 << 17));
    txn->mt_u.dirty_list = (MDB_ID2L )tmp___1;
    if (! txn->mt_u.dirty_list) {
      free((void *)txn->mt_u.dirty_list);
      free((void *)txn);
      return (12);
    } else {
      tmp___2 = mdb_midl_alloc((1 << 17) - 1);
      txn->mt_free_pgs = tmp___2;
      if (! tmp___2) {
        free((void *)txn->mt_u.dirty_list);
        free((void *)txn);
        return (12);
      }
    }
    txn->mt_txnid = parent->mt_txnid;
    txn->mt_dirty_room = parent->mt_dirty_room;
    (txn->mt_u.dirty_list + 0)->mid = (MDB_ID )0;
    txn->mt_spill_pgs = (MDB_IDL )((void *)0);
    txn->mt_next_pgno = parent->mt_next_pgno;
    parent->mt_flags |= 16U;
    parent->mt_child = txn;
    txn->mt_parent = parent;
    txn->mt_numdbs = parent->mt_numdbs;
    memcpy((void * __restrict  )txn->mt_dbs, (void const   * __restrict  )parent->mt_dbs,
           (unsigned long )txn->mt_numdbs * sizeof(MDB_db ));
    i = 0U;
    while (i < txn->mt_numdbs) {
      *(txn->mt_dbflags + i) = (unsigned char )((int )*(parent->mt_dbflags + i) & -5);
      i ++;
    }
    rc = 0;
    ntxn = (MDB_ntxn *)txn;
    ntxn->mnt_pgstate = env->me_pgstate;
    if (env->me_pgstate.mf_pghead) {
      size = (int )((*(env->me_pgstate.mf_pghead + 0) + 1UL) * sizeof(MDB_ID ));
      env->me_pgstate.mf_pghead = mdb_midl_alloc((int )*(env->me_pgstate.mf_pghead + 0));
      if (env->me_pgstate.mf_pghead) {
        memcpy((void * __restrict  )env->me_pgstate.mf_pghead, (void const   * __restrict  )ntxn->mnt_pgstate.mf_pghead,
               (size_t )size);
      } else {
        rc = 12;
      }
    }
    if (! rc) {
      rc = mdb_cursor_shadow(parent, txn);
    }
    if (rc) {
      mdb_txn_end(txn, 6U);
    }
  } else {
    txn->mt_dbiseqs = env->me_dbiseqs;
    renew: 
    rc = mdb_txn_renew0(txn);
  }
  if (rc) {
    if ((unsigned long )txn != (unsigned long )env->me_txn0) {
      free((void *)txn);
    }
  } else {
    txn->mt_flags |= flags;
    *ret = txn;
  }
  return (rc);
}
}
MDB_env *mdb_txn_env(MDB_txn *txn ) 
{ 


  {
  if (! txn) {
    return ((MDB_env *)((void *)0));
  }
  return (txn->mt_env);
}
}
mdb_size_t mdb_txn_id(MDB_txn *txn ) 
{ 


  {
  if (! txn) {
    return ((mdb_size_t )0);
  }
  return (txn->mt_txnid);
}
}
static void mdb_dbis_update(MDB_txn *txn , int keep ) 
{ 
  int i ;
  MDB_dbi n ;
  MDB_env *env ;
  unsigned char *tdbflags ;
  char *ptr ;

  {
  n = txn->mt_numdbs;
  env = txn->mt_env;
  tdbflags = txn->mt_dbflags;
  i = (int )n;
  while (1) {
    i --;
    if (! (i >= 2)) {
      break;
    }
    if ((int )*(tdbflags + i) & 4) {
      if (keep) {
        *(env->me_dbflags + i) = (uint16_t )((int )(txn->mt_dbs + i)->md_flags | 32768);
      } else {
        ptr = (char *)(env->me_dbxs + i)->md_name.mv_data;
        if (ptr) {
          (env->me_dbxs + i)->md_name.mv_data = (void *)0;
          (env->me_dbxs + i)->md_name.mv_size = (size_t )0;
          *(env->me_dbflags + i) = (uint16_t )0;
          (*(env->me_dbiseqs + i)) ++;
          free((void *)ptr);
        }
      }
    }
  }
  if (keep) {
    if (env->me_numdbs < n) {
      env->me_numdbs = n;
    }
  }
  return;
}
}
static void mdb_txn_end(MDB_txn *txn , unsigned int mode ) 
{ 
  MDB_env *env ;
  pgno_t *pghead ;

  {
  env = txn->mt_env;
  mdb_dbis_update(txn, (int )(mode & 16U));
  if ((txn->mt_flags & 131072U) == 131072U) {
    if (txn->mt_u.reader) {
      (txn->mt_u.reader)->mru.mrx.mrb_txnid = (txnid_t volatile   )((txnid_t )-1);
      if (! (env->me_flags & 2097152U)) {
        txn->mt_u.reader = (MDB_reader *)((void *)0);
      } else
      if (mode & 2097152U) {
        (txn->mt_u.reader)->mru.mrx.mrb_pid = (pid_t volatile   )0;
        txn->mt_u.reader = (MDB_reader *)((void *)0);
      }
    }
    txn->mt_numdbs = (MDB_dbi )0;
    txn->mt_flags |= 1U;
  } else
  if (! ((txn->mt_flags & 1U) == 1U)) {
    pghead = env->me_pgstate.mf_pghead;
    if (! (mode & 16U)) {
      mdb_cursors_close(txn, 0U);
    }
    if (! (env->me_flags & 524288U)) {
      mdb_dlist_free(txn);
    }
    txn->mt_numdbs = (MDB_dbi )0;
    txn->mt_flags = 1U;
    if (! txn->mt_parent) {
      mdb_midl_shrink(& txn->mt_free_pgs);
      env->me_free_pgs = txn->mt_free_pgs;
      env->me_pgstate.mf_pghead = (pgno_t *)((void *)0);
      env->me_pgstate.mf_pglast = (txnid_t )0;
      env->me_txn = (MDB_txn *)((void *)0);
      mode = 0U;
      if (env->me_txns) {
        pthread_mutex_unlock((env->me_txns)->mt2.mt2_wmutex);
      }
    } else {
      (txn->mt_parent)->mt_child = (MDB_txn *)((void *)0);
      (txn->mt_parent)->mt_flags &= 4294967279U;
      env->me_pgstate = ((MDB_ntxn *)txn)->mnt_pgstate;
      mdb_midl_free(txn->mt_free_pgs);
      free((void *)txn->mt_u.dirty_list);
    }
    mdb_midl_free(txn->mt_spill_pgs);
    mdb_midl_free(pghead);
  }
  if (mode & 32U) {
    free((void *)txn);
  }
  return;
}
}
void mdb_txn_reset(MDB_txn *txn ) 
{ 


  {
  if ((unsigned long )txn == (unsigned long )((void *)0)) {
    return;
  }
  if (! (txn->mt_flags & 131072U)) {
    return;
  }
  mdb_txn_end(txn, 3U);
  return;
}
}
void mdb_txn_abort(MDB_txn *txn ) 
{ 


  {
  if ((unsigned long )txn == (unsigned long )((void *)0)) {
    return;
  }
  if (txn->mt_child) {
    mdb_txn_abort(txn->mt_child);
  }
  mdb_txn_end(txn, 2097186U);
  return;
}
}
static int mdb_freelist_save(MDB_txn *txn ) 
{ 
  MDB_cursor mc ;
  MDB_env *env ;
  int rc ;
  int maxfree_1pg ;
  int more ;
  txnid_t pglast ;
  txnid_t head_id ;
  pgno_t freecnt ;
  pgno_t *free_pgs ;
  pgno_t *mop ;
  ssize_t head_room ;
  ssize_t total_room ;
  ssize_t mop_len ;
  ssize_t clean_limit ;
  MDB_page *mp ;
  MDB_ID2 *dl ;
  unsigned int x ;
  MDB_ID *xidl ;
  MDB_ID xlen ;
  unsigned int y ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  MDB_val key ;
  MDB_val data ;
  pgno_t *pgs ;
  ssize_t j ;
  pgno_t tmp___1 ;
  MDB_page *mp___0 ;
  unsigned int count ;
  MDB_IDL loose ;
  MDB_val key___0 ;
  MDB_val data___0 ;
  txnid_t id ;
  ssize_t len ;
  MDB_ID save ;

  {
  env = txn->mt_env;
  maxfree_1pg = env->me_maxfree_1pg;
  more = 1;
  pglast = (txnid_t )0;
  head_id = (txnid_t )0;
  freecnt = (pgno_t )0;
  head_room = (ssize_t )0;
  total_room = (ssize_t )0;
  mdb_cursor_init(& mc, txn, (MDB_dbi )0, (MDB_xcursor *)((void *)0));
  if (env->me_pgstate.mf_pghead) {
    rc = mdb_page_search(& mc, (MDB_val *)((void *)0), 5);
    if (rc) {
      if (rc != -30798) {
        return (rc);
      }
    }
  }
  if (! env->me_pgstate.mf_pghead) {
    if (txn->mt_loose_pgs) {
      mp = txn->mt_loose_pgs;
      dl = txn->mt_u.dirty_list;
      rc = mdb_midl_need(& txn->mt_free_pgs, (unsigned int )txn->mt_loose_count);
      if (rc != 0) {
        return (rc);
      }
      while (mp) {
        while (1) {
          xidl = txn->mt_free_pgs;
          (*(xidl + 0)) ++;
          xlen = *(xidl + 0);
          *(xidl + xlen) = mp->mp_p.p_pgno;
          break;
        }
        if (txn->mt_flags & 524288U) {
          x = 1U;
          while ((MDB_ID )x <= (dl + 0)->mid) {
            if ((dl + x)->mid == mp->mp_p.p_pgno) {
              break;
            }
            x ++;
          }
          if (! ((MDB_ID )x <= (dl + 0)->mid)) {
            mdb_assert_fail(txn->mt_env, "x <= dl[0].mid", "mdb_freelist_save", "mdb.c",
                            3476);
          }
        } else {
          x = mdb_mid2l_search(dl, mp->mp_p.p_pgno);
          if (! ((dl + x)->mid == mp->mp_p.p_pgno)) {
            mdb_assert_fail(txn->mt_env, "dl[x].mid == mp->mp_pgno", "mdb_freelist_save",
                            "mdb.c", 3479);
          }
          mdb_dpage_free(env, mp);
        }
        (dl + x)->mptr = (void *)0;
        mp = *((MDB_page **)(mp + 2));
      }
      y = 1U;
      while (1) {
        if ((dl + y)->mptr) {
          if (! ((MDB_ID )y <= (dl + 0)->mid)) {
            break;
          }
        } else {
          break;
        }
        y ++;
      }
      if ((MDB_ID )y <= (dl + 0)->mid) {
        x = y;
        y ++;
        while (1) {
          while (1) {
            if (! (dl + y)->mptr) {
              if (! ((MDB_ID )y <= (dl + 0)->mid)) {
                break;
              }
            } else {
              break;
            }
            y ++;
          }
          if ((MDB_ID )y > (dl + 0)->mid) {
            break;
          }
          tmp = x;
          x ++;
          tmp___0 = y;
          y ++;
          *(dl + tmp) = *(dl + tmp___0);
        }
        (dl + 0)->mid = (MDB_ID )(x - 1U);
      } else {
        (dl + 0)->mid = (MDB_ID )0;
      }
      txn->mt_loose_pgs = (MDB_page *)((void *)0);
      txn->mt_loose_count = 0;
    }
  }
  if (env->me_flags & 17301504U) {
    clean_limit = 9223372036854775807L;
  } else {
    clean_limit = (ssize_t )maxfree_1pg;
  }
  while (1) {
    while (pglast < env->me_pgstate.mf_pglast) {
      rc = mdb_cursor_first(& mc, & key, (MDB_val *)((void *)0));
      if (rc) {
        return (rc);
      }
      head_id = *((txnid_t *)key.mv_data);
      pglast = head_id;
      head_room = (ssize_t )0;
      total_room = head_room;
      if (! (pglast <= env->me_pgstate.mf_pglast)) {
        mdb_assert_fail(txn->mt_env, "pglast <= env->me_pglast", "mdb_freelist_save",
                        "mdb.c", 3523);
      }
      rc = mdb_cursor_del(& mc, 0U);
      if (rc) {
        return (rc);
      }
    }
    if (freecnt < *(txn->mt_free_pgs + 0)) {
      if (! freecnt) {
        rc = mdb_page_search(& mc, (MDB_val *)((void *)0), 9);
        if (rc) {
          if (rc != -30798) {
            return (rc);
          }
        }
      }
      free_pgs = txn->mt_free_pgs;
      key.mv_size = sizeof(txn->mt_txnid);
      key.mv_data = (void *)(& txn->mt_txnid);
      while (1) {
        freecnt = *(free_pgs + 0);
        data.mv_size = (*(free_pgs + 0) + 1UL) * sizeof(MDB_ID );
        rc = mdb_cursor_put(& mc, & key, & data, 65536U);
        if (rc) {
          return (rc);
        }
        free_pgs = txn->mt_free_pgs;
        if (! (freecnt < *(free_pgs + 0))) {
          break;
        }
      }
      mdb_midl_sort(free_pgs);
      memcpy((void * __restrict  )data.mv_data, (void const   * __restrict  )free_pgs,
             data.mv_size);
      goto __Cont;
    }
    mop = env->me_pgstate.mf_pghead;
    if (mop) {
      tmp___1 = *(mop + 0);
    } else {
      tmp___1 = (pgno_t )0;
    }
    mop_len = (ssize_t )(tmp___1 + (pgno_t )txn->mt_loose_count);
    if (total_room >= mop_len) {
      if (total_room == mop_len) {
        break;
      } else {
        more --;
        if (more < 0) {
          break;
        }
      }
    } else
    if (head_room >= (ssize_t )maxfree_1pg) {
      if (head_id > 1UL) {
        head_id --;
        head_room = (ssize_t )0;
      }
    }
    total_room -= head_room;
    head_room = mop_len - total_room;
    if (head_room > (ssize_t )maxfree_1pg) {
      if (head_id > 1UL) {
        head_room = (ssize_t )((txnid_t )head_room / head_id);
        head_room += (long )maxfree_1pg - head_room % (long )(maxfree_1pg + 1);
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (head_room < 0L) {
      head_room = (ssize_t )0;
    }
    key.mv_size = sizeof(head_id);
    key.mv_data = (void *)(& head_id);
    data.mv_size = (unsigned long )(head_room + 1L) * sizeof(pgno_t );
    rc = mdb_cursor_put(& mc, & key, & data, 65536U);
    if (rc) {
      return (rc);
    }
    pgs = (pgno_t *)data.mv_data;
    if (head_room > clean_limit) {
      j = head_room;
    } else {
      j = (ssize_t )0;
    }
    while (1) {
      *(pgs + j) = (pgno_t )0;
      j --;
      if (! (j >= 0L)) {
        break;
      }
    }
    total_room += head_room;
    __Cont: /* CIL Label */ ;
  }
  if (txn->mt_loose_pgs) {
    mp___0 = txn->mt_loose_pgs;
    count = (unsigned int )txn->mt_loose_count;
    rc = mdb_midl_need(& env->me_pgstate.mf_pghead, 2U * count + 1U);
    if (rc != 0) {
      return (rc);
    }
    mop = env->me_pgstate.mf_pghead;
    loose = (mop + *(mop + -1)) - count;
    count = 0U;
    while (mp___0) {
      count ++;
      *(loose + count) = mp___0->mp_p.p_pgno;
      mp___0 = *((MDB_page **)(mp___0 + 2));
    }
    *(loose + 0) = (MDB_ID )count;
    mdb_midl_sort(loose);
    mdb_midl_xmerge(mop, loose);
    txn->mt_loose_pgs = (MDB_page *)((void *)0);
    txn->mt_loose_count = 0;
    mop_len = (ssize_t )*(mop + 0);
  }
  rc = 0;
  if (mop_len) {
    mop += mop_len;
    rc = mdb_cursor_first(& mc, & key___0, & data___0);
    while (! rc) {
      id = *((txnid_t *)key___0.mv_data);
      len = (ssize_t )(data___0.mv_size / sizeof(MDB_ID )) - 1L;
      if (len >= 0L) {
        if (! (id <= env->me_pgstate.mf_pglast)) {
          mdb_assert_fail(txn->mt_env, "len >= 0 && id <= env->me_pglast", "mdb_freelist_save",
                          "mdb.c", 3639);
        }
      } else {
        mdb_assert_fail(txn->mt_env, "len >= 0 && id <= env->me_pglast", "mdb_freelist_save",
                        "mdb.c", 3639);
      }
      key___0.mv_data = (void *)(& id);
      if (len > mop_len) {
        len = mop_len;
        data___0.mv_size = (unsigned long )(len + 1L) * sizeof(MDB_ID );
      }
      mop -= len;
      data___0.mv_data = (void *)mop;
      save = *(mop + 0);
      *(mop + 0) = (pgno_t )len;
      rc = mdb_cursor_put(& mc, & key___0, & data___0, 64U);
      *(mop + 0) = save;
      if (rc) {
        break;
      } else {
        mop_len -= len;
        if (! mop_len) {
          break;
        }
      }
      rc = mdb_cursor_next(& mc, & key___0, & data___0, (MDB_cursor_op )8);
    }
  }
  return (rc);
}
}
static int mdb_page_flush(MDB_txn *txn , int keep ) 
{ 
  MDB_env *env ;
  MDB_ID2L dl ;
  unsigned int psize ;
  unsigned int j ;
  int i ;
  int pagecount ;
  int rc ;
  size_t size ;
  off_t pos ;
  pgno_t pgno ;
  MDB_page *dp ;
  struct iovec iov[64] ;
  int fd ;
  ssize_t wsize ;
  ssize_t wres ;
  off_t wpos ;
  off_t next_pos ;
  int n ;
  int *tmp ;
  __off_t tmp___0 ;
  int *tmp___1 ;

  {
  env = txn->mt_env;
  dl = txn->mt_u.dirty_list;
  psize = env->me_psize;
  pagecount = (int )(dl + 0)->mid;
  size = (size_t )0;
  pos = (off_t )0;
  pgno = (pgno_t )0;
  dp = (MDB_page *)((void *)0);
  fd = env->me_fd;
  wsize = (ssize_t )0;
  wpos = (off_t )0;
  next_pos = (off_t )1;
  n = 0;
  i = keep;
  j = (unsigned int )i;
  if (env->me_flags & 524288U) {
    while (1) {
      i ++;
      if (! (i <= pagecount)) {
        break;
      }
      dp = (MDB_page *)(dl + i)->mptr;
      if ((int )dp->mp_flags & 49152) {
        dp->mp_flags = (uint16_t )((int )dp->mp_flags & -32769);
        j ++;
        *(dl + j) = *(dl + i);
        continue;
      }
      dp->mp_flags = (uint16_t )((int )dp->mp_flags & -17);
    }
    goto done;
  }
  while (1) {
    i ++;
    if (i <= pagecount) {
      dp = (MDB_page *)(dl + i)->mptr;
      if ((int )dp->mp_flags & 49152) {
        dp->mp_flags = (uint16_t )((int )dp->mp_flags & -32769);
        (dl + i)->mid = (MDB_ID )0;
        goto __Cont;
      }
      pgno = (dl + i)->mid;
      dp->mp_flags = (uint16_t )((int )dp->mp_flags & -17);
      pos = (off_t )(pgno * (pgno_t )psize);
      size = (size_t )psize;
      if (((int )dp->mp_flags & 4) == 4) {
        size *= (size_t )dp->mp_pb.pb_pages;
      }
    }
    if (pos != next_pos) {
      goto _L;
    } else
    if (n == 64) {
      goto _L;
    } else
    if ((size_t )wsize + size > (size_t )(1073741824U >> (sizeof(ssize_t ) == 4UL))) {
      _L: /* CIL Label */ 
      if (n) {
        retry_write: ;
        if (n == 1) {
          wres = pwrite(fd, (void const   *)iov[0].iov_base, (size_t )wsize, wpos);
        } else {
          retry_seek: 
          tmp___0 = lseek(fd, wpos, 0);
          if (tmp___0 == -1L) {
            tmp = __errno_location();
            rc = *tmp;
            if (rc == 4) {
              goto retry_seek;
            }
            return (rc);
          }
          wres = writev(fd, (struct iovec  const  *)(iov), n);
        }
        if (wres != wsize) {
          if (wres < 0L) {
            tmp___1 = __errno_location();
            rc = *tmp___1;
            if (rc == 4) {
              goto retry_write;
            }
          } else {
            rc = 5;
          }
          return (rc);
        }
        n = 0;
      }
      if (i > pagecount) {
        break;
      }
      wpos = pos;
      wsize = (ssize_t )0;
    }
    iov[n].iov_len = size;
    iov[n].iov_base = (void *)((char *)dp);
    next_pos = (off_t )((size_t )pos + size);
    wsize = (ssize_t )((size_t )wsize + size);
    n ++;
    __Cont: /* CIL Label */ ;
  }
  if (! (env->me_flags & 524288U)) {
    i = keep;
    while (1) {
      i ++;
      if (! (i <= pagecount)) {
        break;
      }
      dp = (MDB_page *)(dl + i)->mptr;
      if (! (dl + i)->mid) {
        j ++;
        *(dl + j) = *(dl + i);
        (dl + j)->mid = dp->mp_p.p_pgno;
        goto __Cont___0;
      }
      mdb_dpage_free(env, dp);
      __Cont___0: /* CIL Label */ ;
    }
  }
  done: 
  i --;
  txn->mt_dirty_room += (unsigned int )i - j;
  (dl + 0)->mid = (MDB_ID )j;
  return (0);
}
}
static int mdb_env_share_locks(MDB_env *env , int *excl )  __attribute__((__section__("text_env"))) ;
int mdb_txn_commit(MDB_txn *txn ) 
{ 
  int rc ;
  unsigned int i ;
  unsigned int end_mode ;
  MDB_env *env ;
  MDB_txn *parent ;
  MDB_page **lp ;
  MDB_ID2L dst ;
  MDB_ID2L src ;
  MDB_IDL pspill ;
  unsigned int x ;
  unsigned int y ;
  unsigned int len ;
  unsigned int ps_len ;
  MDB_ID pn ;
  MDB_ID pn___0 ;
  unsigned int tmp ;
  pgno_t yp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  pgno_t yp___0 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  MDB_cursor mc ;
  MDB_dbi i___0 ;
  MDB_val data ;
  int excl ;

  {
  if ((unsigned long )txn == (unsigned long )((void *)0)) {
    return (22);
  }
  end_mode = 2097201U;
  if (txn->mt_child) {
    rc = mdb_txn_commit(txn->mt_child);
    if (rc) {
      goto fail;
    }
  }
  env = txn->mt_env;
  if ((txn->mt_flags & 131072U) == 131072U) {
    goto done;
  }
  if (txn->mt_flags & 3U) {
    if (txn->mt_parent) {
      (txn->mt_parent)->mt_flags |= 2U;
    }
    rc = -30782;
    goto fail;
  }
  if (txn->mt_parent) {
    parent = txn->mt_parent;
    rc = mdb_midl_append_list(& parent->mt_free_pgs, txn->mt_free_pgs);
    if (rc) {
      goto fail;
    }
    mdb_midl_free(txn->mt_free_pgs);
    parent->mt_next_pgno = txn->mt_next_pgno;
    parent->mt_flags = txn->mt_flags;
    mdb_cursors_close(txn, 1U);
    memcpy((void * __restrict  )parent->mt_dbs, (void const   * __restrict  )txn->mt_dbs,
           (unsigned long )txn->mt_numdbs * sizeof(MDB_db ));
    parent->mt_numdbs = txn->mt_numdbs;
    *(parent->mt_dbflags + 0) = *(txn->mt_dbflags + 0);
    *(parent->mt_dbflags + 1) = *(txn->mt_dbflags + 1);
    i = 2U;
    while (i < txn->mt_numdbs) {
      x = (unsigned int )((int )*(parent->mt_dbflags + i) & 4);
      *(parent->mt_dbflags + i) = (unsigned char )((unsigned int )*(txn->mt_dbflags + i) | x);
      i ++;
    }
    dst = parent->mt_u.dirty_list;
    src = txn->mt_u.dirty_list;
    pspill = parent->mt_spill_pgs;
    if (pspill) {
      ps_len = (unsigned int )*(pspill + 0);
      if (ps_len) {
        y = ps_len;
        x = y;
        *(pspill + 0) = (pgno_t )-1;
        i = 0U;
        len = (unsigned int )(src + 0)->mid;
        while (1) {
          i ++;
          if (! (i <= len)) {
            break;
          }
          pn = (src + i)->mid << 1;
          while (pn > *(pspill + x)) {
            x --;
          }
          if (pn == *(pspill + x)) {
            *(pspill + x) = (MDB_ID )1;
            x --;
            y = x;
          }
        }
        x = y;
        while (1) {
          x ++;
          if (! (x <= ps_len)) {
            break;
          }
          if (! (*(pspill + x) & 1UL)) {
            y ++;
            *(pspill + y) = *(pspill + x);
          }
        }
        *(pspill + 0) = (MDB_ID )y;
      }
    }
    if (txn->mt_spill_pgs) {
      if (*(txn->mt_spill_pgs + 0)) {
        i = 1U;
        while ((MDB_ID )i <= *(txn->mt_spill_pgs + 0)) {
          pn___0 = *(txn->mt_spill_pgs + i);
          if (pn___0 & 1UL) {
            goto __Cont;
          }
          pn___0 >>= 1;
          y = mdb_mid2l_search(dst, pn___0);
          if ((MDB_ID )y <= (dst + 0)->mid) {
            if ((dst + y)->mid == pn___0) {
              free((dst + y)->mptr);
              while ((MDB_ID )y < (dst + 0)->mid) {
                *(dst + y) = *(dst + (y + 1U));
                y ++;
              }
              ((dst + 0)->mid) --;
            }
          }
          __Cont: /* CIL Label */ 
          i ++;
        }
      }
    }
    x = (unsigned int )(dst + 0)->mid;
    (dst + 0)->mid = (MDB_ID )0;
    if (parent->mt_parent) {
      len = (unsigned int )((MDB_ID )x + (src + 0)->mid);
      tmp = mdb_mid2l_search(src, (dst + x)->mid + 1UL);
      y = tmp - 1U;
      i = x;
      while (1) {
        if (y) {
          if (! i) {
            break;
          }
        } else {
          break;
        }
        yp = (src + y)->mid;
        while (yp < (dst + i)->mid) {
          i --;
        }
        if (yp == (dst + i)->mid) {
          i --;
          len --;
        }
        y --;
      }
    } else {
      len = (unsigned int )((1 << 17) - 1) - txn->mt_dirty_room;
    }
    y = (unsigned int )(src + 0)->mid;
    i = len;
    while (y) {
      yp___0 = (src + y)->mid;
      while (yp___0 < (dst + x)->mid) {
        tmp___2 = i;
        i --;
        tmp___3 = x;
        x --;
        *(dst + tmp___2) = *(dst + tmp___3);
      }
      if (yp___0 == (dst + x)->mid) {
        tmp___4 = x;
        x --;
        free((dst + tmp___4)->mptr);
      }
      tmp___0 = i;
      i --;
      tmp___1 = y;
      y --;
      *(dst + tmp___0) = *(src + tmp___1);
    }
    if (! (i == x)) {
      mdb_assert_fail(txn->mt_env, "i == x", "mdb_txn_commit", "mdb.c", 4028);
    }
    (dst + 0)->mid = (MDB_ID )len;
    free((void *)txn->mt_u.dirty_list);
    parent->mt_dirty_room = txn->mt_dirty_room;
    if (txn->mt_spill_pgs) {
      if (parent->mt_spill_pgs) {
        rc = mdb_midl_append_list(& parent->mt_spill_pgs, txn->mt_spill_pgs);
        if (rc) {
          parent->mt_flags |= 2U;
        }
        mdb_midl_free(txn->mt_spill_pgs);
        mdb_midl_sort(parent->mt_spill_pgs);
      } else {
        parent->mt_spill_pgs = txn->mt_spill_pgs;
      }
    }
    lp = & parent->mt_loose_pgs;
    while (*lp) {
      lp = (MDB_page **)(*lp + 2);
    }
    *lp = txn->mt_loose_pgs;
    parent->mt_loose_count += txn->mt_loose_count;
    parent->mt_child = (MDB_txn *)((void *)0);
    mdb_midl_free(((MDB_ntxn *)txn)->mnt_pgstate.mf_pghead);
    free((void *)txn);
    return (rc);
  }
  if ((unsigned long )txn != (unsigned long )env->me_txn) {
    rc = 22;
    goto fail;
  }
  mdb_cursors_close(txn, 0U);
  if (! (txn->mt_u.dirty_list + 0)->mid) {
    if (! (txn->mt_flags & 12U)) {
      goto done;
    }
  }
  if (txn->mt_numdbs > 2U) {
    data.mv_size = sizeof(MDB_db );
    mdb_cursor_init(& mc, txn, (MDB_dbi )1, (MDB_xcursor *)((void *)0));
    i___0 = (MDB_dbi )2;
    while (i___0 < txn->mt_numdbs) {
      if ((int )*(txn->mt_dbflags + i___0) & 1) {
        if (*(txn->mt_dbiseqs + i___0) != *((txn->mt_env)->me_dbiseqs + i___0)) {
          rc = -30780;
          goto fail;
        }
        data.mv_data = (void *)(txn->mt_dbs + i___0);
        rc = mdb_cursor_put(& mc, & (txn->mt_dbxs + i___0)->md_name, & data, 2U);
        if (rc) {
          goto fail;
        }
      }
      i___0 ++;
    }
  }
  rc = mdb_freelist_save(txn);
  if (rc) {
    goto fail;
  }
  mdb_midl_free(env->me_pgstate.mf_pghead);
  env->me_pgstate.mf_pghead = (pgno_t *)((void *)0);
  mdb_midl_shrink(& txn->mt_free_pgs);
  rc = mdb_page_flush(txn, 0);
  if (rc) {
    goto fail;
  }
  if (! ((txn->mt_flags & 65536U) == 65536U)) {
    rc = mdb_env_sync0(env, 0, txn->mt_next_pgno);
    if (rc) {
      goto fail;
    }
  }
  rc = mdb_env_write_meta(txn);
  if (rc) {
    goto fail;
  }
  end_mode = 16U;
  if (env->me_flags & 33554432U) {
    if (! (env->me_flags & 4194304U)) {
      rc = mdb_env_share_locks(env, & excl);
      if (rc) {
        goto fail;
      }
    }
    env->me_flags ^= 33554432U;
  }
  done: 
  mdb_txn_end(txn, end_mode);
  return (0);
  fail: 
  mdb_txn_abort(txn);
  return (rc);
}
}
static int mdb_env_read_header(MDB_env *env , int prev , MDB_meta *meta )  __attribute__((__section__("text_env"))) ;
static int mdb_env_read_header(MDB_env *env , int prev , MDB_meta *meta ) 
{ 
  MDB_metabuf pbuf ;
  MDB_page *p ;
  MDB_meta *m ;
  int i ;
  int rc ;
  int off ;
  ssize_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  off = 0;
  i = off;
  while (i < 2) {
    tmp = pread(env->me_fd, (void *)(& pbuf), (size_t )152, (__off_t )off);
    rc = (int )tmp;
    if (rc != 152) {
      if (rc == 0) {
        if (off == 0) {
          return (2);
        }
      }
      if (rc < 0) {
        tmp___0 = __errno_location();
        rc = *tmp___0;
      } else {
        rc = -30793;
      }
      return (rc);
    }
    p = (MDB_page *)(& pbuf);
    if (! (((int )p->mp_flags & 8) == 8)) {
      return (-30793);
    }
    m = (MDB_meta *)((void *)((char *)p + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))));
    if (m->mm_magic != 3203383518U) {
      return (-30793);
    }
    if (m->mm_version != 1U) {
      return (-30794);
    }
    if (off == 0) {
      *meta = *m;
    } else {
      if (prev) {
        tmp___1 = m->mm_txnid < meta->mm_txnid;
      } else {
        tmp___1 = m->mm_txnid > meta->mm_txnid;
      }
      if (tmp___1) {
        *meta = *m;
      }
    }
    i ++;
    off = (int )((uint32_t )off + meta->mm_dbs[0].md_pad);
  }
  return (0);
}
}
static void mdb_env_init_meta0(MDB_env *env , MDB_meta *meta )  __attribute__((__section__("text_env"))) ;
static void mdb_env_init_meta0(MDB_env *env , MDB_meta *meta ) 
{ 


  {
  meta->mm_magic = 3203383518U;
  meta->mm_version = (uint32_t )1;
  meta->mm_mapsize = env->me_mapsize;
  meta->mm_dbs[0].md_pad = env->me_psize;
  meta->mm_last_pg = (pgno_t )1;
  meta->mm_dbs[0].md_flags = (uint16_t )(env->me_flags & 65535U);
  meta->mm_dbs[0].md_flags = (uint16_t )((int )meta->mm_dbs[0].md_flags | 8);
  meta->mm_dbs[0].md_root = ~ ((pgno_t )0);
  meta->mm_dbs[1].md_root = ~ ((pgno_t )0);
  return;
}
}
static int mdb_env_init_meta(MDB_env *env , MDB_meta *meta )  __attribute__((__section__("text_env"))) ;
static int mdb_env_init_meta(MDB_env *env , MDB_meta *meta ) 
{ 
  MDB_page *p ;
  MDB_page *q ;
  int rc ;
  unsigned int psize ;
  int len ;
  void *tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  psize = env->me_psize;
  tmp = calloc((size_t )2, (size_t )psize);
  p = (MDB_page *)tmp;
  if (! p) {
    return (12);
  }
  p->mp_p.p_pgno = (pgno_t )0;
  p->mp_flags = (uint16_t )8;
  *((MDB_meta *)((void *)((char *)p + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))))) = *meta;
  q = (MDB_page *)((char *)p + psize);
  q->mp_p.p_pgno = (pgno_t )1;
  q->mp_flags = (uint16_t )8;
  *((MDB_meta *)((void *)((char *)q + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))))) = *meta;
  while (1) {
    tmp___0 = pwrite(env->me_fd, (void const   *)p, (size_t )(psize * 2U), (__off_t )0);
    len = (int )tmp___0;
    if (len == -1) {
      tmp___1 = __errno_location();
      if (*tmp___1 == 4) {
        goto __Cont;
      }
    }
    rc = len >= 0;
    break;
    __Cont: /* CIL Label */ ;
  }
  if (! rc) {
    tmp___2 = __errno_location();
    rc = *tmp___2;
  } else
  if ((unsigned int )len == psize * 2U) {
    rc = 0;
  } else {
    rc = 28;
  }
  free((void *)p);
  return (rc);
}
}
static int mdb_env_write_meta(MDB_txn *txn ) 
{ 
  MDB_env *env ;
  MDB_meta meta ;
  MDB_meta metab ;
  MDB_meta *mp ;
  unsigned int flags ;
  mdb_size_t mapsize ;
  off_t off ;
  int rc ;
  int len ;
  int toggle ;
  char *ptr ;
  int mfd ;
  int r2 ;
  unsigned int meta_size ;
  int *tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  ssize_t tmp___3 ;

  {
  toggle = (int )(txn->mt_txnid & 1UL);
  env = txn->mt_env;
  flags = txn->mt_flags | env->me_flags;
  mp = env->me_metas[toggle];
  mapsize = (env->me_metas[toggle ^ 1])->mm_mapsize;
  if (mapsize < env->me_mapsize) {
    mapsize = env->me_mapsize;
  }
  if (flags & 524288U) {
    mp->mm_mapsize = mapsize;
    mp->mm_dbs[0] = *(txn->mt_dbs + 0);
    mp->mm_dbs[1] = *(txn->mt_dbs + 1);
    mp->mm_last_pg = txn->mt_next_pgno - 1UL;
    mp->mm_txnid = (txnid_t volatile   )txn->mt_txnid;
    if (! (flags & 327680U)) {
      meta_size = env->me_psize;
      if (env->me_flags & 1048576U) {
        rc = 1;
      } else {
        rc = 4;
      }
      ptr = (char *)mp - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs));
      r2 = (int )((ptr - env->me_map) & (long )(env->me_os_psize - 1U));
      ptr -= r2;
      meta_size += (unsigned int )r2;
      tmp___0 = msync((void *)ptr, (size_t )meta_size, rc);
      if (tmp___0) {
        tmp = __errno_location();
        rc = *tmp;
        goto fail;
      }
    }
    goto done;
  }
  metab.mm_txnid = mp->mm_txnid;
  metab.mm_last_pg = mp->mm_last_pg;
  meta.mm_mapsize = mapsize;
  meta.mm_dbs[0] = *(txn->mt_dbs + 0);
  meta.mm_dbs[1] = *(txn->mt_dbs + 1);
  meta.mm_last_pg = txn->mt_next_pgno - 1UL;
  meta.mm_txnid = (txnid_t volatile   )txn->mt_txnid;
  off = (off_t )((unsigned long )(& ((MDB_meta *)0)->mm_mapsize));
  ptr = (char *)(& meta) + off;
  len = (int )(sizeof(MDB_meta ) - (unsigned long )off);
  off += (char *)mp - env->me_map;
  if (flags & 327680U) {
    mfd = env->me_fd;
  } else {
    mfd = env->me_mfd;
  }
  retry_write: 
  tmp___1 = pwrite(mfd, (void const   *)ptr, (size_t )len, off);
  rc = (int )tmp___1;
  if (rc != len) {
    if (rc < 0) {
      tmp___2 = __errno_location();
      rc = *tmp___2;
    } else {
      rc = 5;
    }
    if (rc == 4) {
      goto retry_write;
    }
    meta.mm_last_pg = metab.mm_last_pg;
    meta.mm_txnid = metab.mm_txnid;
    tmp___3 = pwrite(env->me_fd, (void const   *)ptr, (size_t )len, off);
    r2 = (int )tmp___3;
    fail: 
    env->me_flags |= 2147483648U;
    return (rc);
  }
  done: 
  if (env->me_txns) {
    (env->me_txns)->mt1.mtb.mtb_txnid = (txnid_t volatile   )txn->mt_txnid;
  }
  return (0);
}
}
static MDB_meta *mdb_env_pick_meta(MDB_env const   *env ) 
{ 
  MDB_meta * const  *metas ;

  {
  metas = (MDB_meta * const  *)(env->me_metas);
  return ((MDB_meta *)*(metas + (((*(metas + 0))->mm_txnid < (*(metas + 1))->mm_txnid) ^ ((env->me_flags & 33554432U) != 0U))));
}
}
int mdb_env_create(MDB_env **env )  __attribute__((__section__("text_env"))) ;
int mdb_env_create(MDB_env **env ) 
{ 
  MDB_env *e ;
  void *tmp ;
  MDB_dbi tmp___0 ;
  long tmp___1 ;

  {
  tmp = calloc((size_t )1, sizeof(MDB_env ));
  e = (MDB_env *)tmp;
  if (! e) {
    return (12);
  }
  e->me_maxreaders = 126U;
  tmp___0 = (MDB_dbi )2;
  e->me_numdbs = tmp___0;
  e->me_maxdbs = tmp___0;
  e->me_fd = -1;
  e->me_lfd = -1;
  e->me_mfd = -1;
  e->me_pid = getpid();
  tmp___1 = sysconf(30);
  e->me_os_psize = (unsigned int )tmp___1;
  *env = e;
  return (0);
}
}
static int mdb_env_map(MDB_env *env , void *addr )  __attribute__((__section__("text_env"))) ;
static int mdb_env_map(MDB_env *env , void *addr ) 
{ 
  MDB_page *p ;
  unsigned int flags ;
  int mmap_flags ;
  int prot ;
  int *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
  flags = env->me_flags;
  mmap_flags = 1;
  prot = 1;
  if (flags & 524288U) {
    prot |= 2;
    tmp___0 = ftruncate(env->me_fd, (__off_t )env->me_mapsize);
    if (tmp___0 < 0) {
      tmp = __errno_location();
      return (*tmp);
    }
  }
  tmp___1 = mmap(addr, env->me_mapsize, prot, mmap_flags, env->me_fd, (__off_t )0);
  env->me_map = (char *)tmp___1;
  if ((unsigned long )env->me_map == (unsigned long )((void *)-1)) {
    env->me_map = (char *)((void *)0);
    tmp___2 = __errno_location();
    return (*tmp___2);
  }
  if (flags & 8388608U) {
    madvise((void *)env->me_map, env->me_mapsize, 1);
  }
  if (addr) {
    if ((unsigned long )env->me_map != (unsigned long )addr) {
      return (16);
    }
  }
  p = (MDB_page *)env->me_map;
  env->me_metas[0] = (MDB_meta *)((void *)((char *)p + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))));
  env->me_metas[1] = (MDB_meta *)((char *)env->me_metas[0] + env->me_psize);
  return (0);
}
}
int mdb_env_set_mapsize(MDB_env *env , mdb_size_t size )  __attribute__((__section__("text_env"))) ;
int mdb_env_set_mapsize(MDB_env *env , mdb_size_t size ) 
{ 
  MDB_meta *meta ;
  void *old ;
  int rc ;
  mdb_size_t minsize ;

  {
  if (env->me_map) {
    if (env->me_txn) {
      return (22);
    }
    meta = mdb_env_pick_meta((MDB_env const   *)env);
    if (! size) {
      size = meta->mm_mapsize;
    }
    minsize = (meta->mm_last_pg + 1UL) * (pgno_t )env->me_psize;
    if (size < minsize) {
      size = minsize;
    }
    munmap((void *)env->me_map, env->me_mapsize);
    env->me_mapsize = size;
    if (env->me_flags & 1U) {
      old = (void *)env->me_map;
    } else {
      old = (void *)0;
    }
    rc = mdb_env_map(env, old);
    if (rc) {
      return (rc);
    }
  }
  env->me_mapsize = size;
  if (env->me_psize) {
    env->me_maxpg = env->me_mapsize / (mdb_size_t )env->me_psize;
  }
  return (0);
}
}
int mdb_env_set_maxdbs(MDB_env *env , MDB_dbi dbs )  __attribute__((__section__("text_env"))) ;
int mdb_env_set_maxdbs(MDB_env *env , MDB_dbi dbs ) 
{ 


  {
  if (env->me_map) {
    return (22);
  }
  env->me_maxdbs = dbs + 2U;
  return (0);
}
}
int mdb_env_set_maxreaders(MDB_env *env , unsigned int readers )  __attribute__((__section__("text_env"))) ;
int mdb_env_set_maxreaders(MDB_env *env , unsigned int readers ) 
{ 


  {
  if (env->me_map) {
    return (22);
  } else
  if (readers < 1U) {
    return (22);
  }
  env->me_maxreaders = readers;
  return (0);
}
}
int mdb_env_get_maxreaders(MDB_env *env , unsigned int *readers )  __attribute__((__section__("text_env"))) ;
int mdb_env_get_maxreaders(MDB_env *env , unsigned int *readers ) 
{ 


  {
  if (! env) {
    return (22);
  } else
  if (! readers) {
    return (22);
  }
  *readers = env->me_maxreaders;
  return (0);
}
}
static int mdb_fsize(int fd , mdb_size_t *size )  __attribute__((__section__("text_env"))) ;
static int mdb_fsize(int fd , mdb_size_t *size ) 
{ 
  struct stat st ;
  int *tmp ;
  int tmp___0 ;

  {
  tmp___0 = fstat(fd, & st);
  if (tmp___0) {
    tmp = __errno_location();
    return (*tmp);
  }
  *size = (mdb_size_t )st.st_size;
  return (0);
}
}
static mdb_nchar_t const   * const  mdb_suffixes[2][2]  = { {        (mdb_nchar_t const   * const  )"/data.mdb",        (mdb_nchar_t const   * const  )""}, 
   {        (mdb_nchar_t const   * const  )"/lock.mdb",        (mdb_nchar_t const   * const  )"-lock"}};
static int mdb_fname_init(char const   *path , unsigned int envflags , MDB_name *fname )  __attribute__((__section__("text_env"))) ;
static int mdb_fname_init(char const   *path , unsigned int envflags , MDB_name *fname ) 
{ 
  int no_suffix ;
  size_t tmp ;
  mdb_nchar_t *tmp___0 ;
  void *tmp___1 ;

  {
  no_suffix = (envflags & 4210688U) == 4210688U;
  fname->mn_alloced = 0;
  tmp = strlen(path);
  fname->mn_len = (int )tmp;
  if (no_suffix) {
    fname->mn_val = (char *)path;
  } else {
    tmp___1 = malloc((size_t )((fname->mn_len + 9) + 1));
    tmp___0 = (mdb_nchar_t *)tmp___1;
    fname->mn_val = tmp___0;
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
      fname->mn_alloced = 1;
      strcpy((char * __restrict  )fname->mn_val, (char const   * __restrict  )path);
    } else {
      return (12);
    }
  }
  return (0);
}
}
static int mdb_fopen(MDB_env const   *env , MDB_name *fname , enum mdb_fopen_type which ,
                     mdb_mode_t mode , int *res )  __attribute__((__section__("text_env"))) ;
static int mdb_fopen(MDB_env const   *env , MDB_name *fname , enum mdb_fopen_type which ,
                     mdb_mode_t mode , int *res ) 
{ 
  int rc ;
  int fd ;
  int flags ;
  int *tmp ;
  int tmp___0 ;

  {
  rc = 0;
  if (fname->mn_alloced) {
    strcpy((char * __restrict  )(fname->mn_val + fname->mn_len), (char const   * __restrict  )mdb_suffixes[(unsigned int )which == 524358U][(env->me_flags & 16384U) == 16384U]);
  }
  fd = open((char const   *)fname->mn_val, (int )((unsigned int )which & 528579U),
            mode);
  if (fd == -1) {
    tmp = __errno_location();
    rc = *tmp;
  } else {
    if ((unsigned int )which != 0U) {
      if ((unsigned int )which != 66U) {
        tmp___0 = 1;
      } else {
        tmp___0 = 0;
      }
    } else {
      tmp___0 = 0;
    }
    if ((unsigned int )which == 524481U) {
      if (env->me_psize >= env->me_os_psize) {
        flags = fcntl(fd, 3);
        if (flags != -1) {
          fcntl(fd, 4, flags | 16384);
        }
      }
    }
  }
  *res = fd;
  return (rc);
}
}
extern  __attribute__((__nothrow__)) int uname(struct utsname *__name ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstatfs)(int __fildes ,
                                                                                    struct statfs *__buf ) ;
static int mdb_env_open2(MDB_env *env , int prev )  __attribute__((__section__("text_env"))) ;
static int mdb_env_open2(MDB_env *env , int prev ) 
{ 
  unsigned int flags ;
  int i ;
  int newenv ;
  int rc ;
  MDB_meta meta ;
  struct statfs st ;
  struct utsname uts ;
  int i___0 ;
  int tmp ;
  int tmp___0 ;
  mdb_size_t minsize ;
  void *tmp___1 ;

  {
  flags = env->me_flags;
  newenv = 0;
  fstatfs(env->me_fd, & st);
  while (st.f_type == 61267L) {
    uname(& uts);
    if ((int )uts.release[0] < 51) {
      tmp___0 = strncmp((char const   *)(uts.release), "2.6.32.", (size_t )7);
      if (tmp___0) {
        tmp = strncmp((char const   *)(uts.release), "2.6.34.", (size_t )7);
        if (! tmp) {
          i___0 = atoi((char const   *)(uts.release + 7));
          if (i___0 >= 15) {
            break;
          }
        }
      } else {
        i___0 = atoi((char const   *)(uts.release + 7));
        if (i___0 >= 60) {
          break;
        }
      }
    } else
    if ((int )uts.release[0] == 51) {
      i___0 = atoi((char const   *)(uts.release + 2));
      if (i___0 > 5) {
        break;
      }
      if (i___0 == 5) {
        i___0 = atoi((char const   *)(uts.release + 4));
        if (i___0 >= 4) {
          break;
        }
      } else
      if (i___0 == 2) {
        i___0 = atoi((char const   *)(uts.release + 4));
        if (i___0 >= 30) {
          break;
        }
      }
    } else {
      break;
    }
    env->me_flags |= 134217728U;
    break;
  }
  i = mdb_env_read_header(env, prev, & meta);
  if (i != 0) {
    if (i != 2) {
      return (i);
    }
    newenv = 1;
    env->me_psize = env->me_os_psize;
    if (env->me_psize > 32768U) {
      env->me_psize = 32768U;
    }
    memset((void *)(& meta), 0, sizeof(meta));
    mdb_env_init_meta0(env, & meta);
    meta.mm_mapsize = (mdb_size_t )1048576;
  } else {
    env->me_psize = meta.mm_dbs[0].md_pad;
  }
  if (! env->me_mapsize) {
    env->me_mapsize = meta.mm_mapsize;
  }
  minsize = (meta.mm_last_pg + 1UL) * (pgno_t )meta.mm_dbs[0].md_pad;
  if (env->me_mapsize < minsize) {
    env->me_mapsize = minsize;
  }
  meta.mm_mapsize = env->me_mapsize;
  if (newenv) {
    if (! (flags & 1U)) {
      rc = mdb_env_init_meta(env, & meta);
      if (rc) {
        return (rc);
      }
      newenv = 0;
    }
  }
  if (flags & 1U) {
    tmp___1 = meta.mm_address;
  } else {
    tmp___1 = (void *)0;
  }
  rc = mdb_env_map(env, tmp___1);
  if (rc) {
    return (rc);
  }
  if (newenv) {
    if (flags & 1U) {
      meta.mm_address = (void *)env->me_map;
    }
    i = mdb_env_init_meta(env, & meta);
    if (i != 0) {
      return (i);
    }
  }
  env->me_maxfree_1pg = (int )((unsigned long )(env->me_psize - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) / sizeof(pgno_t ) - 1UL);
  env->me_nodemax = (unsigned int )((unsigned long )((env->me_psize - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) / 2U & 4294967294U) - sizeof(indx_t ));
  env->me_maxpg = env->me_mapsize / (mdb_size_t )env->me_psize;
  return (0);
}
}
static void mdb_env_reader_dest(void *ptr ) 
{ 
  MDB_reader *reader ;
  __pid_t tmp ;

  {
  reader = (MDB_reader *)ptr;
  tmp = getpid();
  if (reader->mru.mrx.mrb_pid == (pid_t volatile   )tmp) {
    reader->mru.mrx.mrb_pid = (pid_t volatile   )0;
  }
  return;
}
}
static int mdb_env_share_locks(MDB_env *env , int *excl )  __attribute__((__section__("text_env"))) ;
static int mdb_env_share_locks(MDB_env *env , int *excl ) 
{ 
  int rc ;
  MDB_meta *meta ;
  MDB_meta *tmp ;
  struct flock lock_info ;
  int *tmp___0 ;

  {
  rc = 0;
  tmp = mdb_env_pick_meta((MDB_env const   *)env);
  meta = tmp;
  (env->me_txns)->mt1.mtb.mtb_txnid = meta->mm_txnid;
  memset((void *)(& lock_info), 0, sizeof(lock_info));
  lock_info.l_type = (short)0;
  lock_info.l_whence = (short)0;
  lock_info.l_start = (__off_t )0;
  lock_info.l_len = (__off_t )1;
  while (1) {
    rc = fcntl(env->me_lfd, 6, & lock_info);
    if (rc) {
      tmp___0 = __errno_location();
      rc = *tmp___0;
      if (! (rc == 4)) {
        break;
      }
    } else {
      break;
    }
  }
  if (rc) {
    *excl = -1;
  } else {
    *excl = 0;
  }
  return (rc);
}
}
static int mdb_env_excl_lock(MDB_env *env , int *excl )  __attribute__((__section__("text_env"))) ;
static int mdb_env_excl_lock(MDB_env *env , int *excl ) 
{ 
  int rc ;
  struct flock lock_info ;
  int *tmp ;
  int *tmp___0 ;

  {
  rc = 0;
  memset((void *)(& lock_info), 0, sizeof(lock_info));
  lock_info.l_type = (short)1;
  lock_info.l_whence = (short)0;
  lock_info.l_start = (__off_t )0;
  lock_info.l_len = (__off_t )1;
  while (1) {
    rc = fcntl(env->me_lfd, 6, & lock_info);
    if (rc) {
      tmp = __errno_location();
      rc = *tmp;
      if (! (rc == 4)) {
        break;
      }
    } else {
      break;
    }
  }
  if (! rc) {
    *excl = 1;
  } else {
    lock_info.l_type = (short)0;
    while (1) {
      rc = fcntl(env->me_lfd, 7, & lock_info);
      if (rc) {
        tmp___0 = __errno_location();
        rc = *tmp___0;
        if (! (rc == 4)) {
          break;
        }
      } else {
        break;
      }
    }
    if (rc == 0) {
      *excl = 0;
    }
  }
  return (rc);
}
}
static int mdb_env_setup_locks(MDB_env *env , MDB_name *fname , int mode , int *excl )  __attribute__((__section__("text_env"))) ;
static int mdb_env_setup_locks(MDB_env *env , MDB_name *fname , int mode , int *excl ) 
{ 
  int rc ;
  off_t size ;
  off_t rsize ;
  int tmp ;
  void *m ;
  void *tmp___0 ;
  pthread_mutexattr_t mattr ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  rc = mdb_fopen((MDB_env const   *)env, fname, (enum mdb_fopen_type )524358, (mdb_mode_t )mode,
                 & env->me_lfd);
  if (rc) {
    if (rc == 30) {
      if (env->me_flags & 131072U) {
        return (0);
      }
    }
    goto fail;
  }
  if (! (env->me_flags & 2097152U)) {
    rc = pthread_key_create(& env->me_txkey, & mdb_env_reader_dest);
    if (rc) {
      goto fail;
    }
    env->me_flags |= 268435456U;
  }
  rc = mdb_env_excl_lock(env, excl);
  if (rc) {
    goto fail;
  }
  size = lseek(env->me_lfd, (__off_t )0, 2);
  if (size == -1L) {
    goto fail_errno;
  }
  rsize = (off_t )((unsigned long )(env->me_maxreaders - 1U) * sizeof(MDB_reader ) + sizeof(MDB_txninfo ));
  if (size < rsize) {
    if (*excl > 0) {
      tmp = ftruncate(env->me_lfd, rsize);
      if (tmp != 0) {
        goto fail_errno;
      }
    } else {
      rsize = size;
      size = (off_t )((unsigned long )rsize - sizeof(MDB_txninfo ));
      env->me_maxreaders = (unsigned int )((unsigned long )size / sizeof(MDB_reader ) + 1UL);
    }
  } else {
    rsize = size;
    size = (off_t )((unsigned long )rsize - sizeof(MDB_txninfo ));
    env->me_maxreaders = (unsigned int )((unsigned long )size / sizeof(MDB_reader ) + 1UL);
  }
  tmp___0 = mmap((void *)0, (size_t )rsize, 3, 1, env->me_lfd, (__off_t )0);
  m = tmp___0;
  if ((unsigned long )m == (unsigned long )((void *)-1)) {
    goto fail_errno;
  }
  env->me_txns = (MDB_txninfo *)m;
  if (*excl > 0) {
    memset((void *)((env->me_txns)->mt1.mtb.mtb_rmutex), 0, sizeof((env->me_txns)->mt1.mtb.mtb_rmutex[0]));
    memset((void *)((env->me_txns)->mt2.mt2_wmutex), 0, sizeof((env->me_txns)->mt2.mt2_wmutex[0]));
    rc = pthread_mutexattr_init(& mattr);
    if (rc != 0) {
      goto fail;
    }
    rc = pthread_mutexattr_setpshared(& mattr, 1);
    if (! rc) {
      rc = pthread_mutexattr_setrobust(& mattr, 1);
    }
    if (! rc) {
      rc = pthread_mutex_init((env->me_txns)->mt1.mtb.mtb_rmutex, (pthread_mutexattr_t const   *)(& mattr));
    }
    if (! rc) {
      rc = pthread_mutex_init((env->me_txns)->mt2.mt2_wmutex, (pthread_mutexattr_t const   *)(& mattr));
    }
    pthread_mutexattr_destroy(& mattr);
    if (rc) {
      goto fail;
    }
    (env->me_txns)->mt1.mtb.mtb_magic = 3203383518U;
    (env->me_txns)->mt1.mtb.mtb_format = 2U % (1U << 12) + 180982U * (1U << 12);
    (env->me_txns)->mt1.mtb.mtb_txnid = (txnid_t volatile   )0;
    (env->me_txns)->mt1.mtb.mtb_numreaders = (unsigned int volatile   )0;
  } else {
    if ((env->me_txns)->mt1.mtb.mtb_magic != 3203383518U) {
      rc = -30793;
      goto fail;
    }
    if ((env->me_txns)->mt1.mtb.mtb_format != 2U % (1U << 12) + 180982U * (1U << 12)) {
      rc = -30794;
      goto fail;
    }
    tmp___1 = __errno_location();
    rc = *tmp___1;
    if (rc) {
      if (rc != 13) {
        if (rc != 11) {
          goto fail;
        }
      }
    }
  }
  return (0);
  fail_errno: 
  tmp___2 = __errno_location();
  rc = *tmp___2;
  fail: 
  return (rc);
}
}
int mdb_env_open(MDB_env *env , char const   *path , unsigned int flags , mdb_mode_t mode )  __attribute__((__section__("text_env"))) ;
int mdb_env_open(MDB_env *env , char const   *path , unsigned int flags , mdb_mode_t mode ) 
{ 
  int rc ;
  int excl ;
  MDB_name fname ;
  MDB_IDL tmp ;
  MDB_ID2L tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  MDB_txn *txn ;
  int tsize ;
  int size ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
  excl = -1;
  if (env->me_fd != -1) {
    return (22);
  } else
  if (flags & 4227907582U) {
    return (22);
  }
  flags |= env->me_flags;
  rc = mdb_fname_init(path, flags, & fname);
  if (rc) {
    return (rc);
  }
  flags |= 536870912U;
  if (flags & 131072U) {
    flags &= 4294443007U;
  } else {
    tmp = mdb_midl_alloc((1 << 17) - 1);
    env->me_free_pgs = tmp;
    if (tmp) {
      tmp___1 = calloc((size_t )(1 << 17), sizeof(MDB_ID2 ));
      tmp___0 = (MDB_ID2L )tmp___1;
      env->me_dirty_list = tmp___0;
      if (! tmp___0) {
        rc = 12;
      }
    } else {
      rc = 12;
    }
  }
  env->me_flags = flags;
  if (rc) {
    goto leave;
  }
  env->me_path = strdup(path);
  tmp___2 = calloc((size_t )env->me_maxdbs, sizeof(MDB_dbx ));
  env->me_dbxs = (MDB_dbx *)tmp___2;
  tmp___3 = calloc((size_t )env->me_maxdbs, sizeof(uint16_t ));
  env->me_dbflags = (uint16_t *)tmp___3;
  tmp___4 = calloc((size_t )env->me_maxdbs, sizeof(unsigned int ));
  env->me_dbiseqs = (unsigned int *)tmp___4;
  if (env->me_dbxs) {
    if (env->me_path) {
      if (env->me_dbflags) {
        if (! env->me_dbiseqs) {
          rc = 12;
          goto leave;
        }
      } else {
        rc = 12;
        goto leave;
      }
    } else {
      rc = 12;
      goto leave;
    }
  } else {
    rc = 12;
    goto leave;
  }
  (env->me_dbxs + 0)->md_cmp = & mdb_cmp_long;
  if (! (flags & 4325376U)) {
    rc = mdb_env_setup_locks(env, & fname, (int )mode, & excl);
    if (rc) {
      goto leave;
    }
    if (flags & 33554432U) {
      if (! excl) {
        rc = 11;
        goto leave;
      }
    }
  }
  if (flags & 131072U) {
    tmp___5 = 0;
  } else {
    tmp___5 = 66;
  }
  rc = mdb_fopen((MDB_env const   *)env, & fname, (enum mdb_fopen_type )tmp___5, mode,
                 & env->me_fd);
  if (rc) {
    goto leave;
  }
  if ((flags & 4325376U) == 131072U) {
    rc = mdb_env_setup_locks(env, & fname, (int )mode, & excl);
    if (rc) {
      goto leave;
    }
  }
  rc = mdb_env_open2(env, (int )(flags & 33554432U));
  if (rc == 0) {
    if (! (flags & 655360U)) {
      rc = mdb_fopen((MDB_env const   *)env, & fname, (enum mdb_fopen_type )528385,
                     mode, & env->me_mfd);
      if (rc) {
        goto leave;
      }
    }
    if (excl > 0) {
      if (! (flags & 33554432U)) {
        rc = mdb_env_share_locks(env, & excl);
        if (rc) {
          goto leave;
        }
      }
    }
    if (! (flags & 131072U)) {
      tsize = (int )sizeof(MDB_txn );
      size = (int )((unsigned long )tsize + (unsigned long )env->me_maxdbs * (((sizeof(MDB_db ) + sizeof(MDB_cursor *)) + sizeof(unsigned int )) + 1UL));
      tmp___6 = calloc((size_t )1, (size_t )env->me_psize);
      env->me_pbuf = tmp___6;
      if (tmp___6) {
        tmp___7 = calloc((size_t )1, (size_t )size);
        txn = (MDB_txn *)tmp___7;
        if (txn) {
          txn->mt_dbs = (MDB_db *)((char *)txn + tsize);
          txn->mt_cursors = (MDB_cursor **)(txn->mt_dbs + env->me_maxdbs);
          txn->mt_dbiseqs = (unsigned int *)(txn->mt_cursors + env->me_maxdbs);
          txn->mt_dbflags = (unsigned char *)(txn->mt_dbiseqs + env->me_maxdbs);
          txn->mt_env = env;
          txn->mt_dbxs = env->me_dbxs;
          txn->mt_flags = 1U;
          env->me_txn0 = txn;
        } else {
          rc = 12;
        }
      } else {
        rc = 12;
      }
    }
  }
  leave: 
  if (rc) {
    mdb_env_close0(env, excl);
  }
  while (1) {
    if (fname.mn_alloced) {
      free((void *)fname.mn_val);
    }
    break;
  }
  return (rc);
}
}
static void mdb_env_close0(MDB_env *env , int excl )  __attribute__((__section__("text_env"))) ;
static void mdb_env_close0(MDB_env *env , int excl ) 
{ 
  int i ;
  pid_t pid ;
  __pid_t tmp ;

  {
  if (! (env->me_flags & 536870912U)) {
    return;
  }
  if (env->me_dbxs) {
    i = (int )env->me_maxdbs;
    while (1) {
      i --;
      if (! (i >= 2)) {
        break;
      }
      free((env->me_dbxs + i)->md_name.mv_data);
    }
    free((void *)env->me_dbxs);
  }
  free(env->me_pbuf);
  free((void *)env->me_dbiseqs);
  free((void *)env->me_dbflags);
  free((void *)env->me_path);
  free((void *)env->me_dirty_list);
  free((void *)env->me_txn0);
  mdb_midl_free(env->me_free_pgs);
  if (env->me_flags & 268435456U) {
    pthread_key_delete(env->me_txkey);
  }
  if (env->me_map) {
    munmap((void *)env->me_map, env->me_mapsize);
  }
  if (env->me_mfd != -1) {
    close(env->me_mfd);
  }
  if (env->me_fd != -1) {
    close(env->me_fd);
  }
  if (env->me_txns) {
    tmp = getpid();
    pid = tmp;
    i = (int )env->me_close_readers;
    while (1) {
      i --;
      if (! (i >= 0)) {
        break;
      }
      if ((env->me_txns)->mti_readers[i].mru.mrx.mrb_pid == (pid_t volatile   )pid) {
        (env->me_txns)->mti_readers[i].mru.mrx.mrb_pid = (pid_t volatile   )0;
      }
    }
    if (excl == 0) {
      mdb_env_excl_lock(env, & excl);
    }
    if (excl > 0) {
      pthread_mutex_destroy((env->me_txns)->mt1.mtb.mtb_rmutex);
      pthread_mutex_destroy((env->me_txns)->mt2.mt2_wmutex);
    }
    munmap((void *)env->me_txns, (unsigned long )(env->me_maxreaders - 1U) * sizeof(MDB_reader ) + sizeof(MDB_txninfo ));
  }
  if (env->me_lfd != -1) {
    close(env->me_lfd);
  }
  env->me_flags &= 3489660927U;
  return;
}
}
void mdb_env_close(MDB_env *env )  __attribute__((__section__("text_env"))) ;
void mdb_env_close(MDB_env *env ) 
{ 
  MDB_page *dp ;

  {
  if ((unsigned long )env == (unsigned long )((void *)0)) {
    return;
  }
  while (1) {
    dp = env->me_dpages;
    if (! ((unsigned long )dp != (unsigned long )((void *)0))) {
      break;
    }
    env->me_dpages = dp->mp_p.p_next;
    free((void *)dp);
  }
  mdb_env_close0(env, 0);
  free((void *)env);
  return;
}
}
static int mdb_cmp_long(MDB_val const   *a , MDB_val const   *b ) 
{ 
  int tmp ;

  {
  if (*((mdb_size_t *)a->mv_data) < *((mdb_size_t *)b->mv_data)) {
    tmp = -1;
  } else {
    tmp = *((mdb_size_t *)a->mv_data) > *((mdb_size_t *)b->mv_data);
  }
  return (tmp);
}
}
static int mdb_cmp_int(MDB_val const   *a , MDB_val const   *b ) 
{ 
  int tmp ;

  {
  if (*((unsigned int *)a->mv_data) < *((unsigned int *)b->mv_data)) {
    tmp = -1;
  } else {
    tmp = *((unsigned int *)a->mv_data) > *((unsigned int *)b->mv_data);
  }
  return (tmp);
}
}
static int mdb_cmp_cint(MDB_val const   *a , MDB_val const   *b ) 
{ 
  unsigned short *u ;
  unsigned short *c ;
  int x ;

  {
  u = (unsigned short *)((char *)a->mv_data + a->mv_size);
  c = (unsigned short *)((char *)b->mv_data + a->mv_size);
  while (1) {
    u --;
    c --;
    x = (int )*u - (int )*c;
    if (! x) {
      if (! ((unsigned long )u > (unsigned long )((unsigned short *)a->mv_data))) {
        break;
      }
    } else {
      break;
    }
  }
  return (x);
}
}
static int mdb_cmp_memn(MDB_val const   *a , MDB_val const   *b ) 
{ 
  int diff ;
  ssize_t len_diff ;
  unsigned int len ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
  len = (unsigned int )a->mv_size;
  len_diff = (ssize_t )a->mv_size - (ssize_t )b->mv_size;
  if (len_diff > 0L) {
    len = (unsigned int )b->mv_size;
    len_diff = (ssize_t )1;
  }
  diff = memcmp((void const   *)a->mv_data, (void const   *)b->mv_data, (size_t )len);
  if (diff) {
    tmp___0 = (ssize_t )diff;
  } else {
    if (len_diff < 0L) {
      tmp = (ssize_t )-1;
    } else {
      tmp = len_diff;
    }
    tmp___0 = tmp;
  }
  return ((int )tmp___0);
}
}
static int mdb_cmp_memnr(MDB_val const   *a , MDB_val const   *b ) 
{ 
  unsigned char const   *p1 ;
  unsigned char const   *p2 ;
  unsigned char const   *p1_lim ;
  ssize_t len_diff ;
  int diff ;
  ssize_t tmp ;

  {
  p1_lim = (unsigned char const   *)a->mv_data;
  p1 = (unsigned char const   *)a->mv_data + a->mv_size;
  p2 = (unsigned char const   *)b->mv_data + b->mv_size;
  len_diff = (ssize_t )a->mv_size - (ssize_t )b->mv_size;
  if (len_diff > 0L) {
    p1_lim += len_diff;
    len_diff = (ssize_t )1;
  }
  while ((unsigned long )p1 > (unsigned long )p1_lim) {
    p1 --;
    p2 --;
    diff = (int )((int const   )*p1 - (int const   )*p2);
    if (diff) {
      return (diff);
    }
  }
  if (len_diff < 0L) {
    tmp = (ssize_t )-1;
  } else {
    tmp = len_diff;
  }
  return ((int )tmp);
}
}
static MDB_node *mdb_node_search(MDB_cursor *mc , MDB_val *key , int *exactp ) 
{ 
  unsigned int i ;
  unsigned int nkeys ;
  int low ;
  int high ;
  int rc ;
  MDB_page *mp ;
  MDB_node *node ;
  MDB_val nodekey ;
  MDB_cmp_func *cmp ;
  int tmp ;

  {
  i = 0U;
  rc = 0;
  mp = mc->mc_pg[mc->mc_top];
  node = (MDB_node *)((void *)0);
  nkeys = ((unsigned int )mp->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1;
  if (((int )mp->mp_flags & 2) == 2) {
    low = 0;
  } else {
    low = 1;
  }
  high = (int )(nkeys - 1U);
  cmp = (mc->mc_dbx)->md_cmp;
  if ((unsigned long )cmp == (unsigned long )(& mdb_cmp_cint)) {
    if (((int )mp->mp_flags & 1) == 1) {
      if ((unsigned long )((MDB_node *)(((char *)mp + (int )mp->mp_ptrs[1]) + 0U))->mn_ksize == sizeof(mdb_size_t )) {
        cmp = & mdb_cmp_long;
      } else {
        cmp = & mdb_cmp_int;
      }
    }
  }
  if (((int )mp->mp_flags & 32) == 32) {
    nodekey.mv_size = (size_t )(mc->mc_db)->md_pad;
    node = (MDB_node *)(((char *)mp + (int )mp->mp_ptrs[0]) + 0U);
    while (low <= high) {
      i = (unsigned int )((low + high) >> 1);
      nodekey.mv_data = (void *)(((char *)mp + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) + (size_t )i * nodekey.mv_size);
      rc = (*cmp)((MDB_val const   *)key, (MDB_val const   *)(& nodekey));
      if (rc == 0) {
        break;
      }
      if (rc > 0) {
        low = (int )(i + 1U);
      } else {
        high = (int )(i - 1U);
      }
    }
  } else {
    while (low <= high) {
      i = (unsigned int )((low + high) >> 1);
      node = (MDB_node *)(((char *)mp + (int )mp->mp_ptrs[i]) + 0U);
      nodekey.mv_size = (size_t )node->mn_ksize;
      nodekey.mv_data = (void *)(node->mn_data);
      rc = (*cmp)((MDB_val const   *)key, (MDB_val const   *)(& nodekey));
      if (rc == 0) {
        break;
      }
      if (rc > 0) {
        low = (int )(i + 1U);
      } else {
        high = (int )(i - 1U);
      }
    }
  }
  if (rc > 0) {
    i ++;
    if (! (((int )mp->mp_flags & 32) == 32)) {
      node = (MDB_node *)(((char *)mp + (int )mp->mp_ptrs[i]) + 0U);
    }
  }
  if (exactp) {
    if (rc == 0) {
      if (nkeys > 0U) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
    *exactp = tmp;
  }
  mc->mc_ki[mc->mc_top] = (indx_t )i;
  if (i >= nkeys) {
    return ((MDB_node *)((void *)0));
  }
  return (node);
}
}
static void mdb_cursor_pop(MDB_cursor *mc ) 
{ 


  {
  if (mc->mc_snum) {
    mc->mc_snum = (unsigned short )((int )mc->mc_snum - 1);
    if (mc->mc_snum) {
      mc->mc_top = (unsigned short )((int )mc->mc_top - 1);
    } else {
      mc->mc_flags &= 4294967294U;
    }
  }
  return;
}
}
static int mdb_cursor_push(MDB_cursor *mc , MDB_page *mp ) 
{ 
  unsigned short tmp ;

  {
  if ((int )mc->mc_snum >= 32) {
    (mc->mc_txn)->mt_flags |= 2U;
    return (-30787);
  }
  tmp = mc->mc_snum;
  mc->mc_snum = (unsigned short )((int )mc->mc_snum + 1);
  mc->mc_top = tmp;
  mc->mc_pg[mc->mc_top] = mp;
  mc->mc_ki[mc->mc_top] = (indx_t )0;
  return (0);
}
}
static int mdb_page_get(MDB_cursor *mc , pgno_t pgno , MDB_page **ret , int *lvl ) 
{ 
  MDB_txn *txn ;
  MDB_page *p ;
  int level ;
  MDB_txn *tx2 ;
  MDB_ID2L dl ;
  unsigned int x ;
  MDB_ID pn ;
  unsigned int x___0 ;
  unsigned int tmp ;
  MDB_env *env ;

  {
  txn = mc->mc_txn;
  p = (MDB_page *)((void *)0);
  if (! (mc->mc_flags & 655360U)) {
    tx2 = txn;
    level = 1;
    while (1) {
      dl = tx2->mt_u.dirty_list;
      if (tx2->mt_spill_pgs) {
        pn = pgno << 1;
        x = mdb_midl_search(tx2->mt_spill_pgs, pn);
        if ((MDB_ID )x <= *(tx2->mt_spill_pgs + 0)) {
          if (*(tx2->mt_spill_pgs + x) == pn) {
            goto mapped;
          }
        }
      }
      if ((dl + 0)->mid) {
        tmp = mdb_mid2l_search(dl, pgno);
        x___0 = tmp;
        if ((MDB_ID )x___0 <= (dl + 0)->mid) {
          if ((dl + x___0)->mid == pgno) {
            p = (MDB_page *)(dl + x___0)->mptr;
            goto done;
          }
        }
      }
      level ++;
      tx2 = tx2->mt_parent;
      if (! ((unsigned long )tx2 != (unsigned long )((void *)0))) {
        break;
      }
    }
  }
  if (pgno >= txn->mt_next_pgno) {
    txn->mt_flags |= 2U;
    return (-30797);
  }
  level = 0;
  mapped: 
  env = txn->mt_env;
  p = (MDB_page *)(env->me_map + (pgno_t )env->me_psize * pgno);
  done: 
  *ret = p;
  if (lvl) {
    *lvl = level;
  }
  return (0);
}
}
static int mdb_page_search_root(MDB_cursor *mc , MDB_val *key , int flags ) 
{ 
  MDB_page *mp ;
  int rc ;
  MDB_node *node ;
  indx_t i ;
  unsigned short tmp ;
  int exact ;

  {
  mp = mc->mc_pg[mc->mc_top];
  while (((int )mp->mp_flags & 1) == 1) {
    if (! (! mc->mc_dbi)) {
      if (! (((unsigned int )mp->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1 > 1U)) {
        mdb_assert_fail((mc->mc_txn)->mt_env, "!mc->mc_dbi || NUMKEYS(mp) > 1", "mdb_page_search_root",
                        "mdb.c", 6482);
      }
    }
    if (flags & 12) {
      i = (indx_t )0;
      if (flags & 8) {
        i = (indx_t )((((unsigned int )mp->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) - 1U);
        if (mc->mc_flags & 1U) {
          if ((int )mc->mc_ki[mc->mc_top] == (int )i) {
            tmp = mc->mc_snum;
            mc->mc_snum = (unsigned short )((int )mc->mc_snum + 1);
            mc->mc_top = tmp;
            mp = mc->mc_pg[mc->mc_top];
            goto ready;
          }
        }
      }
    } else {
      node = mdb_node_search(mc, key, & exact);
      if ((unsigned long )node == (unsigned long )((void *)0)) {
        i = (indx_t )((((unsigned int )mp->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) - 1U);
      } else {
        i = mc->mc_ki[mc->mc_top];
        if (! exact) {
          if (! ((int )i > 0)) {
            mdb_assert_fail((mc->mc_txn)->mt_env, "i > 0", "mdb_page_search_root",
                            "mdb.c", 6506);
          }
          i = (indx_t )((int )i - 1);
        }
      }
    }
    if (! ((unsigned int )i < ((unsigned int )mp->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1)) {
      mdb_assert_fail((mc->mc_txn)->mt_env, "i < NUMKEYS(mp)", "mdb_page_search_root",
                      "mdb.c", 6513);
    }
    node = (MDB_node *)(((char *)mp + (int )mp->mp_ptrs[i]) + 0U);
    rc = mdb_page_get(mc, ((unsigned long )node->mn_lo | ((pgno_t )node->mn_hi << 16)) | ((pgno_t )node->mn_flags << 32),
                      & mp, (int *)((void *)0));
    if (rc != 0) {
      return (rc);
    }
    mc->mc_ki[mc->mc_top] = i;
    rc = mdb_cursor_push(mc, mp);
    if (rc) {
      return (rc);
    }
    ready: 
    if (flags & 1) {
      rc = mdb_page_touch(mc);
      if (rc != 0) {
        return (rc);
      }
      mp = mc->mc_pg[mc->mc_top];
    }
  }
  if (! (((int )mp->mp_flags & 2) == 2)) {
    (mc->mc_txn)->mt_flags |= 2U;
    return (-30796);
  }
  mc->mc_flags |= 1U;
  mc->mc_flags &= 4294967293U;
  return (0);
}
}
static int mdb_page_search_lowest(MDB_cursor *mc ) 
{ 
  MDB_page *mp ;
  MDB_node *node ;
  int rc ;
  int tmp ;

  {
  mp = mc->mc_pg[mc->mc_top];
  node = (MDB_node *)(((char *)mp + (int )mp->mp_ptrs[0]) + 0U);
  rc = mdb_page_get(mc, ((unsigned long )node->mn_lo | ((pgno_t )node->mn_hi << 16)) | ((pgno_t )node->mn_flags << 32),
                    & mp, (int *)((void *)0));
  if (rc != 0) {
    return (rc);
  }
  mc->mc_ki[mc->mc_top] = (indx_t )0;
  rc = mdb_cursor_push(mc, mp);
  if (rc) {
    return (rc);
  }
  tmp = mdb_page_search_root(mc, (MDB_val *)((void *)0), 4);
  return (tmp);
}
}
static int mdb_page_search(MDB_cursor *mc , MDB_val *key , int flags ) 
{ 
  int rc ;
  pgno_t root ;
  MDB_cursor mc2 ;
  MDB_val data ;
  int exact ;
  uint16_t flags___0 ;
  MDB_node *leaf ;
  MDB_node *tmp ;
  int tmp___0 ;

  {
  if ((mc->mc_txn)->mt_flags & 19U) {
    return (-30782);
  } else {
    if ((int )*(mc->mc_dbflag) & 2) {
      if (*((mc->mc_txn)->mt_dbiseqs + mc->mc_dbi) != *(((mc->mc_txn)->mt_env)->me_dbiseqs + mc->mc_dbi)) {
        return (-30780);
      }
      mdb_cursor_init(& mc2, mc->mc_txn, (MDB_dbi )1, (MDB_xcursor *)((void *)0));
      rc = mdb_page_search(& mc2, & (mc->mc_dbx)->md_name, 0);
      if (rc) {
        return (rc);
      }
      exact = 0;
      tmp = mdb_node_search(& mc2, & (mc->mc_dbx)->md_name, & exact);
      leaf = tmp;
      if (! exact) {
        return (-30798);
      }
      if (((int )leaf->mn_flags & 6) != 2) {
        return (-30784);
      }
      rc = mdb_node_read(& mc2, leaf, & data);
      if (rc) {
        return (rc);
      }
      memcpy((void * __restrict  )(& flags___0), (void const   * __restrict  )((char *)data.mv_data + (unsigned long )(& ((MDB_db *)0)->md_flags)),
             sizeof(uint16_t ));
      if (((int )(mc->mc_db)->md_flags & 32767) != (int )flags___0) {
        return (-30784);
      }
      memcpy((void * __restrict  )mc->mc_db, (void const   * __restrict  )data.mv_data,
             sizeof(MDB_db ));
      *(mc->mc_dbflag) = (unsigned char )((int )*(mc->mc_dbflag) & -3);
    }
    root = (mc->mc_db)->md_root;
    if (root == 18446744073709551615) {
      return (-30798);
    }
  }
  if (! (root > 1UL)) {
    mdb_assert_fail((mc->mc_txn)->mt_env, "root > 1", "mdb_page_search", "mdb.c",
                    6633);
  }
  if (! mc->mc_pg[0]) {
    goto _L;
  } else
  if ((mc->mc_pg[0])->mp_p.p_pgno != root) {
    _L: /* CIL Label */ 
    rc = mdb_page_get(mc, root, & mc->mc_pg[0], (int *)((void *)0));
    if (rc != 0) {
      return (rc);
    }
  }
  mc->mc_snum = (unsigned short)1;
  mc->mc_top = (unsigned short)0;
  if (flags & 1) {
    rc = mdb_page_touch(mc);
    if (rc) {
      return (rc);
    }
  }
  if (flags & 2) {
    return (0);
  }
  tmp___0 = mdb_page_search_root(mc, key, flags);
  return (tmp___0);
}
}
static int mdb_ovpage_free(MDB_cursor *mc , MDB_page *mp ) 
{ 
  MDB_txn *txn ;
  pgno_t pg ;
  unsigned int x ;
  unsigned int ovpages ;
  MDB_env *env ;
  MDB_IDL sl ;
  MDB_ID pn ;
  int rc ;
  unsigned int i ;
  unsigned int j ;
  pgno_t *mop ;
  MDB_ID2 *dl ;
  MDB_ID2 ix ;
  MDB_ID2 iy ;
  MDB_ID tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  pgno_t tmp___2 ;

  {
  txn = mc->mc_txn;
  pg = mp->mp_p.p_pgno;
  x = 0U;
  ovpages = mp->mp_pb.pb_pages;
  env = txn->mt_env;
  sl = txn->mt_spill_pgs;
  pn = pg << 1;
  if (env->me_pgstate.mf_pghead) {
    if (! txn->mt_parent) {
      if ((int )mp->mp_flags & 16) {
        goto _L___0;
      } else
      if (sl) {
        x = mdb_midl_search(sl, pn);
        if ((MDB_ID )x <= *(sl + 0)) {
          if (*(sl + x) == pn) {
            _L___0: /* CIL Label */ 
            rc = mdb_midl_need(& env->me_pgstate.mf_pghead, ovpages);
            if (rc) {
              return (rc);
            }
            if (! ((int )mp->mp_flags & 16)) {
              if ((MDB_ID )x == *(sl + 0)) {
                (*(sl + 0)) --;
              } else {
                *(sl + x) |= 1UL;
              }
              goto release;
            }
            dl = txn->mt_u.dirty_list;
            tmp = (dl + 0)->mid;
            ((dl + 0)->mid) --;
            x = (unsigned int )tmp;
            ix = *(dl + x);
            while ((unsigned long )ix.mptr != (unsigned long )mp) {
              if (x > 1U) {
                x --;
                iy = *(dl + x);
                *(dl + x) = ix;
              } else {
                if (! (x > 1U)) {
                  mdb_assert_fail((mc->mc_txn)->mt_env, "x > 1", "mdb_ovpage_free",
                                  "mdb.c", 6715);
                }
                ((dl + 0)->mid) ++;
                j = (unsigned int )(dl + 0)->mid;
                *(dl + j) = ix;
                txn->mt_flags |= 2U;
                return (-30779);
              }
              ix = iy;
            }
            (txn->mt_dirty_room) ++;
            if (! (env->me_flags & 524288U)) {
              mdb_dpage_free(env, mp);
            }
            release: 
            mop = env->me_pgstate.mf_pghead;
            j = (unsigned int )(*(mop + 0) + (pgno_t )ovpages);
            i = (unsigned int )*(mop + 0);
            while (1) {
              if (i) {
                if (! (*(mop + i) < pg)) {
                  break;
                }
              } else {
                break;
              }
              tmp___0 = j;
              j --;
              *(mop + tmp___0) = *(mop + i);
              i --;
            }
            while (j > i) {
              tmp___1 = j;
              j --;
              tmp___2 = pg;
              pg ++;
              *(mop + tmp___1) = tmp___2;
            }
            *(mop + 0) += (pgno_t )ovpages;
          } else {
            goto _L___1;
          }
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    rc = mdb_midl_append_range(& txn->mt_free_pgs, pg, ovpages);
    if (rc) {
      return (rc);
    }
  }
  (mc->mc_db)->md_overflow_pages -= (pgno_t )ovpages;
  return (0);
}
}
static int mdb_node_read(MDB_cursor *mc , MDB_node *leaf , MDB_val *data ) 
{ 
  MDB_page *omp ;
  pgno_t pgno ;
  int rc ;

  {
  if (! (((int )leaf->mn_flags & 1) == 1)) {
    data->mv_size = (size_t )((unsigned int )leaf->mn_lo | ((unsigned int )leaf->mn_hi << 16));
    data->mv_data = (void *)(leaf->mn_data + (int )leaf->mn_ksize);
    return (0);
  }
  data->mv_size = (size_t )((unsigned int )leaf->mn_lo | ((unsigned int )leaf->mn_hi << 16));
  memcpy((void * __restrict  )(& pgno), (void const   * __restrict  )((void *)(leaf->mn_data + (int )leaf->mn_ksize)),
         sizeof(pgno));
  rc = mdb_page_get(mc, pgno, & omp, (int *)((void *)0));
  if (rc != 0) {
    return (rc);
  }
  data->mv_data = (void *)((char *)omp + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs)));
  return (0);
}
}
int mdb_get(MDB_txn *txn , MDB_dbi dbi , MDB_val *key , MDB_val *data ) 
{ 
  MDB_cursor mc ;
  MDB_xcursor mx ;
  int exact ;
  int rc ;

  {
  exact = 0;
  if (! key) {
    return (22);
  } else
  if (! data) {
    return (22);
  } else
  if (txn) {
    if (dbi < txn->mt_numdbs) {
      if (! ((int )*(txn->mt_dbflags + dbi) & 16)) {
        return (22);
      }
    } else {
      return (22);
    }
  } else {
    return (22);
  }
  if (txn->mt_flags & 19U) {
    return (-30782);
  }
  mdb_cursor_init(& mc, txn, dbi, & mx);
  rc = mdb_cursor_set(& mc, key, data, (MDB_cursor_op )15, & exact);
  return (rc);
}
}
static int mdb_cursor_sibling(MDB_cursor *mc , int move_right ) 
{ 
  int rc ;
  MDB_node *indx ;
  MDB_page *mp ;
  int tmp ;

  {
  if ((int )mc->mc_snum < 2) {
    return (-30798);
  }
  mdb_cursor_pop(mc);
  if (move_right) {
    tmp = (unsigned int )mc->mc_ki[mc->mc_top] + 1U >= ((unsigned int )(mc->mc_pg[mc->mc_top])->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1;
  } else {
    tmp = (int )mc->mc_ki[mc->mc_top] == 0;
  }
  if (tmp) {
    rc = mdb_cursor_sibling(mc, move_right);
    if (rc != 0) {
      mc->mc_top = (unsigned short )((int )mc->mc_top + 1);
      mc->mc_snum = (unsigned short )((int )mc->mc_snum + 1);
      return (rc);
    }
  } else
  if (move_right) {
    mc->mc_ki[mc->mc_top] = (indx_t )((int )mc->mc_ki[mc->mc_top] + 1);
  } else {
    mc->mc_ki[mc->mc_top] = (indx_t )((int )mc->mc_ki[mc->mc_top] - 1);
  }
  if (! (((int )(mc->mc_pg[mc->mc_top])->mp_flags & 1) == 1)) {
    mdb_assert_fail((mc->mc_txn)->mt_env, "IS_BRANCH(mc->mc_pg[mc->mc_top])", "mdb_cursor_sibling",
                    "mdb.c", 6857);
  }
  indx = (MDB_node *)(((char *)mc->mc_pg[mc->mc_top] + (int )(mc->mc_pg[mc->mc_top])->mp_ptrs[mc->mc_ki[mc->mc_top]]) + 0U);
  rc = mdb_page_get(mc, ((unsigned long )indx->mn_lo | ((pgno_t )indx->mn_hi << 16)) | ((pgno_t )indx->mn_flags << 32),
                    & mp, (int *)((void *)0));
  if (rc != 0) {
    mc->mc_flags &= 4294967292U;
    return (rc);
  }
  mdb_cursor_push(mc, mp);
  if (! move_right) {
    mc->mc_ki[mc->mc_top] = (indx_t )((((unsigned int )mp->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) - 1U);
  }
  return (0);
}
}
static int mdb_cursor_next(MDB_cursor *mc , MDB_val *key , MDB_val *data , MDB_cursor_op op ) 
{ 
  MDB_page *mp ;
  MDB_node *leaf ;
  int rc ;
  int tmp ;

  {
  if (mc->mc_flags & 8U) {
    if ((unsigned int )op == 9U) {
      return (-30798);
    }
  }
  if (! (mc->mc_flags & 1U)) {
    tmp = mdb_cursor_first(mc, key, data);
    return (tmp);
  }
  mp = mc->mc_pg[mc->mc_top];
  if (mc->mc_flags & 2U) {
    if ((unsigned int )mc->mc_ki[mc->mc_top] >= (((unsigned int )mp->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) - 1U) {
      return (-30798);
    }
    mc->mc_flags ^= 2U;
  }
  if ((int )(mc->mc_db)->md_flags & 4) {
    leaf = (MDB_node *)(((char *)mp + (int )mp->mp_ptrs[mc->mc_ki[mc->mc_top]]) + 0U);
    if (((int )leaf->mn_flags & 4) == 4) {
      if ((unsigned int )op == 8U) {
        goto _L___0;
      } else
      if ((unsigned int )op == 9U) {
        _L___0: /* CIL Label */ 
        rc = mdb_cursor_next(& (mc->mc_xcursor)->mx_cursor, data, (MDB_val *)((void *)0),
                             (MDB_cursor_op )8);
        if ((unsigned int )op != 8U) {
          goto _L;
        } else
        if (rc != -30798) {
          _L: /* CIL Label */ 
          if (rc == 0) {
            if ((unsigned long )key != (unsigned long )((void *)0)) {
              key->mv_size = (size_t )leaf->mn_ksize;
              key->mv_data = (void *)(leaf->mn_data);
            }
          }
          return (rc);
        }
      }
    } else {
      (mc->mc_xcursor)->mx_cursor.mc_flags &= 4294967292U;
      if ((unsigned int )op == 9U) {
        return (-30798);
      }
    }
  }
  if (mc->mc_flags & 8U) {
    mc->mc_flags ^= 8U;
    goto skip;
  }
  if ((unsigned int )mc->mc_ki[mc->mc_top] + 1U >= ((unsigned int )mp->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) {
    rc = mdb_cursor_sibling(mc, 1);
    if (rc != 0) {
      mc->mc_flags |= 2U;
      return (rc);
    }
    mp = mc->mc_pg[mc->mc_top];
  } else {
    mc->mc_ki[mc->mc_top] = (indx_t )((int )mc->mc_ki[mc->mc_top] + 1);
  }
  skip: ;
  if (((int )mp->mp_flags & 32) == 32) {
    key->mv_size = (size_t )(mc->mc_db)->md_pad;
    key->mv_data = (void *)(((char *)mp + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) + (size_t )mc->mc_ki[mc->mc_top] * key->mv_size);
    return (0);
  }
  if (! (((int )mp->mp_flags & 2) == 2)) {
    mdb_assert_fail((mc->mc_txn)->mt_env, "IS_LEAF(mp)", "mdb_cursor_next", "mdb.c",
                    6946);
  }
  leaf = (MDB_node *)(((char *)mp + (int )mp->mp_ptrs[mc->mc_ki[mc->mc_top]]) + 0U);
  if (((int )leaf->mn_flags & 4) == 4) {
    mdb_xcursor_init1(mc, leaf);
    rc = mdb_cursor_first(& (mc->mc_xcursor)->mx_cursor, data, (MDB_val *)((void *)0));
    if (rc != 0) {
      return (rc);
    }
  } else
  if (data) {
    rc = mdb_node_read(mc, leaf, data);
    if (rc != 0) {
      return (rc);
    }
  }
  if ((unsigned long )key != (unsigned long )((void *)0)) {
    key->mv_size = (size_t )leaf->mn_ksize;
    key->mv_data = (void *)(leaf->mn_data);
  }
  return (0);
}
}
static int mdb_cursor_prev(MDB_cursor *mc , MDB_val *key , MDB_val *data , MDB_cursor_op op ) 
{ 
  MDB_page *mp ;
  MDB_node *leaf ;
  int rc ;

  {
  if (! (mc->mc_flags & 1U)) {
    rc = mdb_cursor_last(mc, key, data);
    if (rc) {
      return (rc);
    }
    mc->mc_ki[mc->mc_top] = (indx_t )((int )mc->mc_ki[mc->mc_top] + 1);
  }
  mp = mc->mc_pg[mc->mc_top];
  if ((int )(mc->mc_db)->md_flags & 4) {
    if ((unsigned int )mc->mc_ki[mc->mc_top] < ((unsigned int )mp->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) {
      leaf = (MDB_node *)(((char *)mp + (int )mp->mp_ptrs[mc->mc_ki[mc->mc_top]]) + 0U);
      if (((int )leaf->mn_flags & 4) == 4) {
        if ((unsigned int )op == 12U) {
          goto _L___0;
        } else
        if ((unsigned int )op == 13U) {
          _L___0: /* CIL Label */ 
          rc = mdb_cursor_prev(& (mc->mc_xcursor)->mx_cursor, data, (MDB_val *)((void *)0),
                               (MDB_cursor_op )12);
          if ((unsigned int )op != 12U) {
            goto _L;
          } else
          if (rc != -30798) {
            _L: /* CIL Label */ 
            if (rc == 0) {
              if ((unsigned long )key != (unsigned long )((void *)0)) {
                key->mv_size = (size_t )leaf->mn_ksize;
                key->mv_data = (void *)(leaf->mn_data);
              }
              mc->mc_flags &= 4294967293U;
            }
            return (rc);
          }
        }
      } else {
        (mc->mc_xcursor)->mx_cursor.mc_flags &= 4294967292U;
        if ((unsigned int )op == 13U) {
          return (-30798);
        }
      }
    }
  }
  mc->mc_flags &= 4294967285U;
  if ((int )mc->mc_ki[mc->mc_top] == 0) {
    rc = mdb_cursor_sibling(mc, 0);
    if (rc != 0) {
      return (rc);
    }
    mp = mc->mc_pg[mc->mc_top];
    mc->mc_ki[mc->mc_top] = (indx_t )((((unsigned int )mp->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) - 1U);
  } else {
    mc->mc_ki[mc->mc_top] = (indx_t )((int )mc->mc_ki[mc->mc_top] - 1);
  }
  if (! (((int )mp->mp_flags & 2) == 2)) {
    return (-30796);
  }
  if (((int )mp->mp_flags & 32) == 32) {
    key->mv_size = (size_t )(mc->mc_db)->md_pad;
    key->mv_data = (void *)(((char *)mp + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) + (size_t )mc->mc_ki[mc->mc_top] * key->mv_size);
    return (0);
  }
  leaf = (MDB_node *)(((char *)mp + (int )mp->mp_ptrs[mc->mc_ki[mc->mc_top]]) + 0U);
  if (((int )leaf->mn_flags & 4) == 4) {
    mdb_xcursor_init1(mc, leaf);
    rc = mdb_cursor_last(& (mc->mc_xcursor)->mx_cursor, data, (MDB_val *)((void *)0));
    if (rc != 0) {
      return (rc);
    }
  } else
  if (data) {
    rc = mdb_node_read(mc, leaf, data);
    if (rc != 0) {
      return (rc);
    }
  }
  if ((unsigned long )key != (unsigned long )((void *)0)) {
    key->mv_size = (size_t )leaf->mn_ksize;
    key->mv_data = (void *)(leaf->mn_data);
  }
  return (0);
}
}
static int mdb_cursor_set(MDB_cursor *mc , MDB_val *key , MDB_val *data , MDB_cursor_op op ,
                          int *exactp ) 
{ 
  int rc ;
  MDB_page *mp ;
  MDB_node *leaf ;
  MDB_val nodekey ;
  unsigned int i ;
  unsigned int nkeys ;
  int ex2 ;
  int *ex2p ;
  MDB_val olddata ;
  MDB_cmp_func *dcmp ;

  {
  leaf = (MDB_node *)((void *)0);
  if (key->mv_size == 0UL) {
    return (-30781);
  }
  if (mc->mc_xcursor) {
    (mc->mc_xcursor)->mx_cursor.mc_flags &= 4294967292U;
  }
  if (mc->mc_flags & 1U) {
    mp = mc->mc_pg[mc->mc_top];
    if (! (((unsigned int )mp->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1)) {
      mc->mc_ki[mc->mc_top] = (indx_t )0;
      return (-30798);
    }
    if ((int )mp->mp_flags & 32) {
      nodekey.mv_size = (size_t )(mc->mc_db)->md_pad;
      nodekey.mv_data = (void *)(((char *)mp + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) + 0UL);
    } else {
      leaf = (MDB_node *)(((char *)mp + (int )mp->mp_ptrs[0]) + 0U);
      nodekey.mv_size = (size_t )leaf->mn_ksize;
      nodekey.mv_data = (void *)(leaf->mn_data);
    }
    rc = (*((mc->mc_dbx)->md_cmp))((MDB_val const   *)key, (MDB_val const   *)(& nodekey));
    if (rc == 0) {
      mc->mc_ki[mc->mc_top] = (indx_t )0;
      if (exactp) {
        *exactp = 1;
      }
      goto set1;
    }
    if (rc > 0) {
      nkeys = ((unsigned int )mp->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1;
      if (nkeys > 1U) {
        if ((int )mp->mp_flags & 32) {
          nodekey.mv_data = (void *)(((char *)mp + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) + (size_t )(nkeys - 1U) * nodekey.mv_size);
        } else {
          leaf = (MDB_node *)(((char *)mp + (int )mp->mp_ptrs[nkeys - 1U]) + 0U);
          nodekey.mv_size = (size_t )leaf->mn_ksize;
          nodekey.mv_data = (void *)(leaf->mn_data);
        }
        rc = (*((mc->mc_dbx)->md_cmp))((MDB_val const   *)key, (MDB_val const   *)(& nodekey));
        if (rc == 0) {
          mc->mc_ki[mc->mc_top] = (indx_t )(nkeys - 1U);
          if (exactp) {
            *exactp = 1;
          }
          goto set1;
        }
        if (rc < 0) {
          if ((unsigned int )mc->mc_ki[mc->mc_top] < ((unsigned int )mp->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) {
            if ((int )mp->mp_flags & 32) {
              nodekey.mv_data = (void *)(((char *)mp + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) + (size_t )mc->mc_ki[mc->mc_top] * nodekey.mv_size);
            } else {
              leaf = (MDB_node *)(((char *)mp + (int )mp->mp_ptrs[mc->mc_ki[mc->mc_top]]) + 0U);
              nodekey.mv_size = (size_t )leaf->mn_ksize;
              nodekey.mv_data = (void *)(leaf->mn_data);
            }
            rc = (*((mc->mc_dbx)->md_cmp))((MDB_val const   *)key, (MDB_val const   *)(& nodekey));
            if (rc == 0) {
              if (exactp) {
                *exactp = 1;
              }
              goto set1;
            }
          }
          rc = 0;
          mc->mc_flags &= 4294967293U;
          goto set2;
        }
      }
      i = 0U;
      while (i < (unsigned int )mc->mc_top) {
        if ((unsigned int )mc->mc_ki[i] < (((unsigned int )(mc->mc_pg[i])->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) - 1U) {
          break;
        }
        i ++;
      }
      if (i == (unsigned int )mc->mc_top) {
        mc->mc_ki[mc->mc_top] = (indx_t )nkeys;
        return (-30798);
      }
    }
    if (! mc->mc_top) {
      mc->mc_ki[mc->mc_top] = (indx_t )0;
      if ((unsigned int )op == 17U) {
        if (! exactp) {
          rc = 0;
          goto set1;
        } else {
          return (-30798);
        }
      } else {
        return (-30798);
      }
    }
  } else {
    mc->mc_pg[0] = (MDB_page *)0;
  }
  rc = mdb_page_search(mc, key, 0);
  if (rc != 0) {
    return (rc);
  }
  mp = mc->mc_pg[mc->mc_top];
  if (! (((int )mp->mp_flags & 2) == 2)) {
    mdb_assert_fail((mc->mc_txn)->mt_env, "IS_LEAF(mp)", "mdb_cursor_set", "mdb.c",
                    7165);
  }
  set2: 
  leaf = mdb_node_search(mc, key, exactp);
  if ((unsigned long )exactp != (unsigned long )((void *)0)) {
    if (! *exactp) {
      return (-30798);
    }
  }
  if ((unsigned long )leaf == (unsigned long )((void *)0)) {
    rc = mdb_cursor_sibling(mc, 1);
    if (rc != 0) {
      mc->mc_flags |= 2U;
      return (rc);
    }
    mp = mc->mc_pg[mc->mc_top];
    if (! (((int )mp->mp_flags & 2) == 2)) {
      mdb_assert_fail((mc->mc_txn)->mt_env, "IS_LEAF(mp)", "mdb_cursor_set", "mdb.c",
                      7181);
    }
    leaf = (MDB_node *)(((char *)mp + (int )mp->mp_ptrs[0]) + 0U);
  }
  set1: 
  mc->mc_flags |= 1U;
  mc->mc_flags &= 4294967293U;
  if (((int )mp->mp_flags & 32) == 32) {
    if ((unsigned int )op == 17U) {
      key->mv_size = (size_t )(mc->mc_db)->md_pad;
      key->mv_data = (void *)(((char *)mp + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) + (size_t )mc->mc_ki[mc->mc_top] * key->mv_size);
    } else
    if ((unsigned int )op == 16U) {
      key->mv_size = (size_t )(mc->mc_db)->md_pad;
      key->mv_data = (void *)(((char *)mp + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) + (size_t )mc->mc_ki[mc->mc_top] * key->mv_size);
    }
    return (0);
  }
  if (((int )leaf->mn_flags & 4) == 4) {
    mdb_xcursor_init1(mc, leaf);
    if ((unsigned int )op == 15U) {
      rc = mdb_cursor_first(& (mc->mc_xcursor)->mx_cursor, data, (MDB_val *)((void *)0));
    } else
    if ((unsigned int )op == 16U) {
      rc = mdb_cursor_first(& (mc->mc_xcursor)->mx_cursor, data, (MDB_val *)((void *)0));
    } else
    if ((unsigned int )op == 17U) {
      rc = mdb_cursor_first(& (mc->mc_xcursor)->mx_cursor, data, (MDB_val *)((void *)0));
    } else {
      if ((unsigned int )op == 2U) {
        ex2p = & ex2;
        ex2 = 0;
      } else {
        ex2p = (int *)((void *)0);
      }
      rc = mdb_cursor_set(& (mc->mc_xcursor)->mx_cursor, data, (MDB_val *)((void *)0),
                          (MDB_cursor_op )17, ex2p);
      if (rc != 0) {
        return (rc);
      }
    }
  } else
  if (data) {
    if ((unsigned int )op == 2U) {
      goto _L;
    } else
    if ((unsigned int )op == 3U) {
      _L: /* CIL Label */ 
      rc = mdb_node_read(mc, leaf, & olddata);
      if (rc != 0) {
        return (rc);
      }
      dcmp = (mc->mc_dbx)->md_dcmp;
      if ((unsigned long )dcmp == (unsigned long )(& mdb_cmp_int)) {
        if (olddata.mv_size == sizeof(mdb_size_t )) {
          dcmp = & mdb_cmp_long;
        }
      }
      rc = (*dcmp)((MDB_val const   *)data, (MDB_val const   *)(& olddata));
      if (rc) {
        if ((unsigned int )op == 2U) {
          return (-30798);
        } else
        if (rc > 0) {
          return (-30798);
        }
        rc = 0;
      }
      *data = olddata;
    } else {
      if (mc->mc_xcursor) {
        (mc->mc_xcursor)->mx_cursor.mc_flags &= 4294967292U;
      }
      rc = mdb_node_read(mc, leaf, data);
      if (rc != 0) {
        return (rc);
      }
    }
  }
  if ((unsigned int )op == 17U) {
    goto _L___0;
  } else
  if ((unsigned int )op == 16U) {
    _L___0: /* CIL Label */ 
    if ((unsigned long )key != (unsigned long )((void *)0)) {
      key->mv_size = (size_t )leaf->mn_ksize;
      key->mv_data = (void *)(leaf->mn_data);
    }
  }
  return (rc);
}
}
static int mdb_cursor_first(MDB_cursor *mc , MDB_val *key , MDB_val *data ) 
{ 
  int rc ;
  MDB_node *leaf ;

  {
  if (mc->mc_xcursor) {
    (mc->mc_xcursor)->mx_cursor.mc_flags &= 4294967292U;
  }
  if (! (mc->mc_flags & 1U)) {
    goto _L;
  } else
  if (mc->mc_top) {
    _L: /* CIL Label */ 
    rc = mdb_page_search(mc, (MDB_val *)((void *)0), 4);
    if (rc != 0) {
      return (rc);
    }
  }
  if (! (((int )(mc->mc_pg[mc->mc_top])->mp_flags & 2) == 2)) {
    mdb_assert_fail((mc->mc_txn)->mt_env, "IS_LEAF(mc->mc_pg[mc->mc_top])", "mdb_cursor_first",
                    "mdb.c", 7263);
  }
  leaf = (MDB_node *)(((char *)mc->mc_pg[mc->mc_top] + (int )(mc->mc_pg[mc->mc_top])->mp_ptrs[0]) + 0U);
  mc->mc_flags |= 1U;
  mc->mc_flags &= 4294967293U;
  mc->mc_ki[mc->mc_top] = (indx_t )0;
  if (((int )(mc->mc_pg[mc->mc_top])->mp_flags & 32) == 32) {
    if (key) {
      key->mv_size = (size_t )(mc->mc_db)->md_pad;
      key->mv_data = (void *)(((char *)mc->mc_pg[mc->mc_top] + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) + 0UL);
    }
    return (0);
  }
  if (((int )leaf->mn_flags & 4) == 4) {
    mdb_xcursor_init1(mc, leaf);
    rc = mdb_cursor_first(& (mc->mc_xcursor)->mx_cursor, data, (MDB_val *)((void *)0));
    if (rc) {
      return (rc);
    }
  } else
  if (data) {
    rc = mdb_node_read(mc, leaf, data);
    if (rc != 0) {
      return (rc);
    }
  }
  if ((unsigned long )key != (unsigned long )((void *)0)) {
    key->mv_size = (size_t )leaf->mn_ksize;
    key->mv_data = (void *)(leaf->mn_data);
  }
  return (0);
}
}
static int mdb_cursor_last(MDB_cursor *mc , MDB_val *key , MDB_val *data ) 
{ 
  int rc ;
  MDB_node *leaf ;

  {
  if (mc->mc_xcursor) {
    (mc->mc_xcursor)->mx_cursor.mc_flags &= 4294967292U;
  }
  if (! (mc->mc_flags & 1U)) {
    goto _L;
  } else
  if (mc->mc_top) {
    _L: /* CIL Label */ 
    rc = mdb_page_search(mc, (MDB_val *)((void *)0), 8);
    if (rc != 0) {
      return (rc);
    }
  }
  if (! (((int )(mc->mc_pg[mc->mc_top])->mp_flags & 2) == 2)) {
    mdb_assert_fail((mc->mc_txn)->mt_env, "IS_LEAF(mc->mc_pg[mc->mc_top])", "mdb_cursor_last",
                    "mdb.c", 7310);
  }
  mc->mc_ki[mc->mc_top] = (indx_t )((((unsigned int )(mc->mc_pg[mc->mc_top])->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) - 1U);
  mc->mc_flags |= 3U;
  leaf = (MDB_node *)(((char *)mc->mc_pg[mc->mc_top] + (int )(mc->mc_pg[mc->mc_top])->mp_ptrs[mc->mc_ki[mc->mc_top]]) + 0U);
  if (((int )(mc->mc_pg[mc->mc_top])->mp_flags & 32) == 32) {
    if (key) {
      key->mv_size = (size_t )(mc->mc_db)->md_pad;
      key->mv_data = (void *)(((char *)mc->mc_pg[mc->mc_top] + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) + (size_t )mc->mc_ki[mc->mc_top] * key->mv_size);
    }
    return (0);
  }
  if (((int )leaf->mn_flags & 4) == 4) {
    mdb_xcursor_init1(mc, leaf);
    rc = mdb_cursor_last(& (mc->mc_xcursor)->mx_cursor, data, (MDB_val *)((void *)0));
    if (rc) {
      return (rc);
    }
  } else
  if (data) {
    rc = mdb_node_read(mc, leaf, data);
    if (rc != 0) {
      return (rc);
    }
  }
  if ((unsigned long )key != (unsigned long )((void *)0)) {
    key->mv_size = (size_t )leaf->mn_ksize;
    key->mv_data = (void *)(leaf->mn_data);
  }
  return (0);
}
}
int mdb_cursor_get(MDB_cursor *mc , MDB_val *key , MDB_val *data , MDB_cursor_op op ) 
{ 
  int rc ;
  int exact ;
  int (*mfunc)(MDB_cursor *mc , MDB_val *key , MDB_val *data ) ;
  MDB_page *mp ;
  int nkeys ;
  MDB_node *leaf ;
  int *tmp ;
  MDB_cursor *mx ;
  MDB_cursor *mx___0 ;
  MDB_node *leaf___0 ;

  {
  exact = 0;
  if ((unsigned long )mc == (unsigned long )((void *)0)) {
    return (22);
  }
  if ((mc->mc_txn)->mt_flags & 19U) {
    return (-30782);
  }
  switch ((unsigned int )op) {
  case 4U: 
  if (! (mc->mc_flags & 1U)) {
    rc = 22;
  } else {
    mp = mc->mc_pg[mc->mc_top];
    nkeys = (int )(((unsigned int )mp->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1);
    if (! nkeys) {
      mc->mc_ki[mc->mc_top] = (indx_t )nkeys;
      rc = -30798;
      break;
    } else
    if ((int )mc->mc_ki[mc->mc_top] >= nkeys) {
      mc->mc_ki[mc->mc_top] = (indx_t )nkeys;
      rc = -30798;
      break;
    }
    rc = 0;
    if (((int )mp->mp_flags & 32) == 32) {
      key->mv_size = (size_t )(mc->mc_db)->md_pad;
      key->mv_data = (void *)(((char *)mp + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) + (size_t )mc->mc_ki[mc->mc_top] * key->mv_size);
    } else {
      leaf = (MDB_node *)(((char *)mp + (int )mp->mp_ptrs[mc->mc_ki[mc->mc_top]]) + 0U);
      if ((unsigned long )key != (unsigned long )((void *)0)) {
        key->mv_size = (size_t )leaf->mn_ksize;
        key->mv_data = (void *)(leaf->mn_data);
      }
      if (data) {
        if (((int )leaf->mn_flags & 4) == 4) {
          rc = mdb_cursor_get(& (mc->mc_xcursor)->mx_cursor, data, (MDB_val *)((void *)0),
                              (MDB_cursor_op )4);
        } else {
          rc = mdb_node_read(mc, leaf, data);
        }
      }
    }
  }
  break;
  case 3U: 
  case 2U: 
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    rc = 22;
    break;
  }
  if ((unsigned long )mc->mc_xcursor == (unsigned long )((void *)0)) {
    rc = -30784;
    break;
  }
  case 17U: 
  case 16U: 
  case 15U: 
  if ((unsigned long )key == (unsigned long )((void *)0)) {
    rc = 22;
  } else {
    if ((unsigned int )op == 17U) {
      tmp = (int *)((void *)0);
    } else {
      tmp = & exact;
    }
    rc = mdb_cursor_set(mc, key, data, op, tmp);
  }
  break;
  case 5U: 
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    rc = 22;
    break;
  } else
  if (! (mc->mc_flags & 1U)) {
    rc = 22;
    break;
  }
  if (! ((int )(mc->mc_db)->md_flags & 16)) {
    rc = -30784;
    break;
  }
  rc = 0;
  if (! ((mc->mc_xcursor)->mx_cursor.mc_flags & 1U)) {
    break;
  } else
  if ((mc->mc_xcursor)->mx_cursor.mc_flags & 2U) {
    break;
  }
  goto fetchm;
  case 10U: 
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    rc = 22;
    break;
  }
  if (! ((int )(mc->mc_db)->md_flags & 16)) {
    rc = -30784;
    break;
  }
  rc = mdb_cursor_next(mc, key, data, (MDB_cursor_op )9);
  if (rc == 0) {
    if ((mc->mc_xcursor)->mx_cursor.mc_flags & 1U) {
      fetchm: 
      mx = & (mc->mc_xcursor)->mx_cursor;
      data->mv_size = (size_t )((((unsigned int )(mx->mc_pg[mx->mc_top])->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) * (mx->mc_db)->md_pad);
      data->mv_data = (void *)((char *)mx->mc_pg[mx->mc_top] + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs)));
      mx->mc_ki[mx->mc_top] = (indx_t )((((unsigned int )(mx->mc_pg[mx->mc_top])->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) - 1U);
    } else {
      rc = -30798;
    }
  }
  break;
  case 18U: 
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    rc = 22;
    break;
  }
  if (! ((int )(mc->mc_db)->md_flags & 16)) {
    rc = -30784;
    break;
  }
  if (! (mc->mc_flags & 1U)) {
    rc = mdb_cursor_last(mc, key, data);
  } else {
    rc = 0;
  }
  if (rc == 0) {
    mx___0 = & (mc->mc_xcursor)->mx_cursor;
    if (mx___0->mc_flags & 1U) {
      rc = mdb_cursor_sibling(mx___0, 0);
      if (rc == 0) {
        goto fetchm;
      }
    } else {
      rc = -30798;
    }
  }
  break;
  case 11U: 
  case 9U: 
  case 8U: 
  rc = mdb_cursor_next(mc, key, data, op);
  break;
  case 14U: 
  case 13U: 
  case 12U: 
  rc = mdb_cursor_prev(mc, key, data, op);
  break;
  case 0U: 
  rc = mdb_cursor_first(mc, key, data);
  break;
  case 1U: 
  mfunc = & mdb_cursor_first;
  mmove: 
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    rc = 22;
    break;
  } else
  if (! (mc->mc_flags & 1U)) {
    rc = 22;
    break;
  }
  if ((unsigned long )mc->mc_xcursor == (unsigned long )((void *)0)) {
    rc = -30784;
    break;
  }
  if ((unsigned int )mc->mc_ki[mc->mc_top] >= ((unsigned int )(mc->mc_pg[mc->mc_top])->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) {
    mc->mc_ki[mc->mc_top] = (indx_t )(((unsigned int )(mc->mc_pg[mc->mc_top])->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1);
    rc = -30798;
    break;
  }
  mc->mc_flags &= 4294967293U;
  leaf___0 = (MDB_node *)(((char *)mc->mc_pg[mc->mc_top] + (int )(mc->mc_pg[mc->mc_top])->mp_ptrs[mc->mc_ki[mc->mc_top]]) + 0U);
  if (! (((int )leaf___0->mn_flags & 4) == 4)) {
    if ((unsigned long )key != (unsigned long )((void *)0)) {
      key->mv_size = (size_t )leaf___0->mn_ksize;
      key->mv_data = (void *)(leaf___0->mn_data);
    }
    rc = mdb_node_read(mc, leaf___0, data);
    break;
  }
  if (! ((mc->mc_xcursor)->mx_cursor.mc_flags & 1U)) {
    rc = 22;
    break;
  }
  rc = (*mfunc)(& (mc->mc_xcursor)->mx_cursor, data, (MDB_val *)((void *)0));
  break;
  case 6U: 
  rc = mdb_cursor_last(mc, key, data);
  break;
  case 7U: 
  mfunc = & mdb_cursor_last;
  goto mmove;
  default: 
  rc = 22;
  break;
  }
  if (mc->mc_flags & 8U) {
    mc->mc_flags ^= 8U;
  }
  return (rc);
}
}
static int mdb_cursor_touch(MDB_cursor *mc ) 
{ 
  int rc ;
  MDB_cursor mc2 ;
  MDB_xcursor mcx ;

  {
  rc = 0;
  if (mc->mc_dbi >= 2U) {
    if (! ((int )*(mc->mc_dbflag) & 33)) {
      if (*((mc->mc_txn)->mt_dbiseqs + mc->mc_dbi) != *(((mc->mc_txn)->mt_env)->me_dbiseqs + mc->mc_dbi)) {
        return (-30780);
      }
      mdb_cursor_init(& mc2, mc->mc_txn, (MDB_dbi )1, & mcx);
      rc = mdb_page_search(& mc2, & (mc->mc_dbx)->md_name, 1);
      if (rc) {
        return (rc);
      }
      *(mc->mc_dbflag) = (unsigned char )((int )*(mc->mc_dbflag) | 1);
    }
  }
  mc->mc_top = (unsigned short)0;
  if (mc->mc_snum) {
    while (1) {
      rc = mdb_page_touch(mc);
      if (! rc) {
        mc->mc_top = (unsigned short )((int )mc->mc_top + 1);
        if (! ((int )mc->mc_top < (int )mc->mc_snum)) {
          break;
        }
      } else {
        break;
      }
    }
    mc->mc_top = (unsigned short )((int )mc->mc_snum - 1);
  }
  return (rc);
}
}
int mdb_cursor_put(MDB_cursor *mc , MDB_val *key , MDB_val *data , unsigned int flags ) 
{ 
  MDB_env *env ;
  MDB_node *leaf ;
  MDB_page *fp ;
  MDB_page *mp ;
  MDB_page *sub_root ;
  uint16_t fp_flags ;
  MDB_val xdata ;
  MDB_val *rdata ;
  MDB_val dkey ;
  MDB_val olddata ;
  MDB_db dummy ;
  int do_sub ;
  int insert_key ;
  int insert_data ;
  unsigned int mcount ;
  unsigned int dcount ;
  unsigned int nospill ;
  size_t nsize ;
  int rc ;
  int rc2 ;
  unsigned int nflags ;
  int tmp ;
  unsigned long tmp___0 ;
  int exact ;
  MDB_val d2 ;
  MDB_val k2 ;
  MDB_page *np ;
  indx_t tmp___1 ;
  char *ptr ;
  unsigned int ksize ;
  unsigned short dtop ;
  unsigned int i ;
  unsigned int offset ;
  MDB_cmp_func *dcmp ;
  int tmp___2 ;
  MDB_page *omp ;
  pgno_t pg ;
  int level ;
  int ovpages ;
  int dpages ;
  size_t sz ;
  size_t off ;
  MDB_page *np___0 ;
  MDB_page *tmp___3 ;
  MDB_ID2 id2 ;
  size_t tmp___4 ;
  MDB_cursor *m2 ;
  MDB_cursor *m3 ;
  MDB_dbi dbi ;
  unsigned int i___0 ;
  MDB_page *mp___0 ;
  MDB_page *xr_pg ;
  MDB_node *xr_node ;
  int xflags ;
  int new_dupdata ;
  mdb_size_t ecount ;
  MDB_cursor *m2___0 ;
  MDB_xcursor *mx ;
  unsigned int i___1 ;
  MDB_page *mp___1 ;
  MDB_page *xr_pg___0 ;
  MDB_node *xr_node___0 ;
  void *db ;

  {
  leaf = (MDB_node *)((void *)0);
  sub_root = (MDB_page *)((void *)0);
  do_sub = 0;
  mcount = 0U;
  dcount = 0U;
  if ((unsigned long )mc == (unsigned long )((void *)0)) {
    return (22);
  } else
  if ((unsigned long )key == (unsigned long )((void *)0)) {
    return (22);
  }
  env = (mc->mc_txn)->mt_env;
  if (flags & 524288U) {
    dcount = (unsigned int )(data + 1)->mv_size;
    (data + 1)->mv_size = (size_t )0;
    if (! (((int )(mc->mc_db)->md_flags & 16) == 16)) {
      return (-30784);
    }
  }
  nospill = flags & 32768U;
  flags &= 4294934527U;
  if ((mc->mc_txn)->mt_flags & 131091U) {
    if ((mc->mc_txn)->mt_flags & 131072U) {
      tmp = 13;
    } else {
      tmp = -30782;
    }
    return (tmp);
  }
  if (key->mv_size - 1UL >= 511UL) {
    return (-30781);
  }
  if ((int )(mc->mc_db)->md_flags & 4) {
    tmp___0 = 511UL;
  } else {
    tmp___0 = 4294967295UL;
  }
  if (data->mv_size > tmp___0) {
    return (-30781);
  }
  dkey.mv_size = (size_t )0;
  if (flags & 64U) {
    if (! (mc->mc_flags & 1U)) {
      return (22);
    }
    rc = 0;
  } else
  if ((mc->mc_db)->md_root == 18446744073709551615) {
    mc->mc_snum = (unsigned short)0;
    mc->mc_top = (unsigned short)0;
    mc->mc_flags &= 4294967294U;
    rc = -30769;
  } else {
    exact = 0;
    if (flags & 131072U) {
      rc = mdb_cursor_last(mc, & k2, & d2);
      if (rc == 0) {
        rc = (*((mc->mc_dbx)->md_cmp))((MDB_val const   *)key, (MDB_val const   *)(& k2));
        if (rc > 0) {
          rc = -30798;
          mc->mc_ki[mc->mc_top] = (indx_t )((int )mc->mc_ki[mc->mc_top] + 1);
        } else {
          rc = -30799;
        }
      }
    } else {
      rc = mdb_cursor_set(mc, key, & d2, (MDB_cursor_op )15, & exact);
    }
    if (flags & 16U) {
      if (rc == 0) {
        *data = d2;
        return (-30799);
      }
    }
    if (rc) {
      if (rc != -30798) {
        return (rc);
      }
    }
  }
  if (mc->mc_flags & 8U) {
    mc->mc_flags ^= 8U;
  }
  if (! nospill) {
    if (flags & 524288U) {
      rdata = & xdata;
      xdata.mv_size = data->mv_size * (size_t )dcount;
    } else {
      rdata = data;
    }
    rc2 = mdb_page_spill(mc, key, rdata);
    if (rc2) {
      return (rc2);
    }
  }
  if (rc == -30769) {
    rc2 = mdb_page_new(mc, (uint32_t )2, 1, & np);
    if (rc2) {
      return (rc2);
    }
    mdb_cursor_push(mc, np);
    (mc->mc_db)->md_root = np->mp_p.p_pgno;
    (mc->mc_db)->md_depth = (uint16_t )((int )(mc->mc_db)->md_depth + 1);
    *(mc->mc_dbflag) = (unsigned char )((int )*(mc->mc_dbflag) | 1);
    if (((int )(mc->mc_db)->md_flags & 20) == 16) {
      np->mp_flags = (uint16_t )((int )np->mp_flags | 32);
    }
    mc->mc_flags |= 1U;
  } else {
    rc2 = mdb_cursor_touch(mc);
    if (rc2) {
      return (rc2);
    }
  }
  insert_data = rc;
  insert_key = insert_data;
  if (insert_key) {
    if ((int )(mc->mc_db)->md_flags & 4) {
      if (((unsigned long )(& ((MDB_node *)0)->mn_data) + key->mv_size) + data->mv_size > (unsigned long )env->me_nodemax) {
        fp_flags = (uint16_t )18;
        fp = (MDB_page *)env->me_pbuf;
        fp->mp_pad = (uint16_t )data->mv_size;
        tmp___1 = (indx_t )((unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs)));
        fp->mp_pb.pb.pb_upper = tmp___1;
        fp->mp_pb.pb.pb_lower = tmp___1;
        olddata.mv_size = (size_t )((unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs)));
        goto prep_subDB;
      }
    }
  } else {
    if (((int )(mc->mc_pg[mc->mc_top])->mp_flags & 32) == 32) {
      ksize = (mc->mc_db)->md_pad;
      if (key->mv_size != (size_t )ksize) {
        return (-30781);
      }
      ptr = ((char *)mc->mc_pg[mc->mc_top] + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) + (unsigned int )mc->mc_ki[mc->mc_top] * ksize;
      memcpy((void * __restrict  )ptr, (void const   * __restrict  )key->mv_data,
             (size_t )ksize);
      fix_parent: 
      if (mc->mc_top) {
        if (! mc->mc_ki[mc->mc_top]) {
          dtop = (unsigned short)1;
          mc->mc_top = (unsigned short )((int )mc->mc_top - 1);
          while (1) {
            if (mc->mc_top) {
              if (! (! mc->mc_ki[mc->mc_top])) {
                break;
              }
            } else {
              break;
            }
            mc->mc_top = (unsigned short )((int )mc->mc_top - 1);
            dtop = (unsigned short )((int )dtop + 1);
          }
          if (mc->mc_ki[mc->mc_top]) {
            rc2 = mdb_update_key(mc, key);
          } else {
            rc2 = 0;
          }
          mc->mc_top = (unsigned short )((int )mc->mc_top + (int )dtop);
          if (rc2) {
            return (rc2);
          }
        }
      }
      return (0);
    }
    more: 
    leaf = (MDB_node *)(((char *)mc->mc_pg[mc->mc_top] + (int )(mc->mc_pg[mc->mc_top])->mp_ptrs[mc->mc_ki[mc->mc_top]]) + 0U);
    olddata.mv_size = (size_t )((unsigned int )leaf->mn_lo | ((unsigned int )leaf->mn_hi << 16));
    olddata.mv_data = (void *)(leaf->mn_data + (int )leaf->mn_ksize);
    if (((int )(mc->mc_db)->md_flags & 4) == 4) {
      offset = 0U;
      xdata.mv_data = env->me_pbuf;
      fp = (MDB_page *)xdata.mv_data;
      mp = fp;
      mp->mp_p.p_pgno = (mc->mc_pg[mc->mc_top])->mp_p.p_pgno;
      if (! (((int )leaf->mn_flags & 4) == 4)) {
        if (flags == 64U) {
          goto current;
        }
        dcmp = (mc->mc_dbx)->md_dcmp;
        if ((unsigned long )dcmp == (unsigned long )(& mdb_cmp_int)) {
          if (olddata.mv_size == sizeof(mdb_size_t )) {
            dcmp = & mdb_cmp_long;
          }
        }
        tmp___2 = (*dcmp)((MDB_val const   *)data, (MDB_val const   *)(& olddata));
        if (! tmp___2) {
          if (flags & 262176U) {
            return (-30799);
          }
          goto current;
        }
        dkey.mv_size = olddata.mv_size;
        dkey.mv_data = memcpy((void * __restrict  )(fp + 1), (void const   * __restrict  )olddata.mv_data,
                              olddata.mv_size);
        fp->mp_flags = (uint16_t )82;
        fp->mp_pb.pb.pb_lower = (indx_t )((unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs)));
        xdata.mv_size = ((size_t )((unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) + dkey.mv_size) + data->mv_size;
        if ((int )(mc->mc_db)->md_flags & 16) {
          fp->mp_flags = (uint16_t )((int )fp->mp_flags | 32);
          fp->mp_pad = (uint16_t )data->mv_size;
          xdata.mv_size += 2UL * data->mv_size;
        } else {
          xdata.mv_size += (2UL * (sizeof(indx_t ) + (unsigned long )(& ((MDB_node *)0)->mn_data)) + (dkey.mv_size & 1UL)) + (data->mv_size & 1UL);
        }
        fp->mp_pb.pb.pb_upper = (indx_t )xdata.mv_size;
        olddata.mv_size = xdata.mv_size;
      } else
      if ((int )leaf->mn_flags & 2) {
        flags |= 6U;
        goto put_sub;
      } else {
        fp = (MDB_page *)olddata.mv_data;
        switch (flags) {
        default: 
        if (! ((int )(mc->mc_db)->md_flags & 16)) {
          offset = (unsigned int )(((((unsigned long )(& ((MDB_node *)0)->mn_data) + sizeof(indx_t )) + data->mv_size) + 1UL) & 18446744073709551614);
          break;
        }
        offset = (unsigned int )fp->mp_pad;
        if ((unsigned int )((indx_t )((int )fp->mp_pb.pb.pb_upper - (int )fp->mp_pb.pb.pb_lower)) < offset) {
          offset *= 4U;
          break;
        }
        case 64U: 
        fp->mp_flags = (uint16_t )((int )fp->mp_flags | 16);
        fp->mp_p.p_pgno = mp->mp_p.p_pgno;
        (mc->mc_xcursor)->mx_cursor.mc_pg[0] = fp;
        flags |= 4U;
        goto put_sub;
        }
        xdata.mv_size = olddata.mv_size + (size_t )offset;
      }
      fp_flags = fp->mp_flags;
      if (((unsigned long )(& ((MDB_node *)0)->mn_data) + (unsigned long )leaf->mn_ksize) + xdata.mv_size > (unsigned long )env->me_nodemax) {
        fp_flags = (uint16_t )((int )fp_flags & -65);
        prep_subDB: 
        if ((int )(mc->mc_db)->md_flags & 16) {
          fp_flags = (uint16_t )((int )fp_flags | 32);
          dummy.md_pad = (uint32_t )fp->mp_pad;
          dummy.md_flags = (uint16_t )16;
          if ((int )(mc->mc_db)->md_flags & 32) {
            dummy.md_flags = (uint16_t )((int )dummy.md_flags | 8);
          }
        } else {
          dummy.md_pad = (uint32_t )0;
          dummy.md_flags = (uint16_t )0;
        }
        dummy.md_depth = (uint16_t )1;
        dummy.md_branch_pages = (pgno_t )0;
        dummy.md_leaf_pages = (pgno_t )1;
        dummy.md_overflow_pages = (pgno_t )0;
        dummy.md_entries = (mdb_size_t )(((unsigned int )fp->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1);
        xdata.mv_size = sizeof(MDB_db );
        xdata.mv_data = (void *)(& dummy);
        rc = mdb_page_alloc(mc, 1, & mp);
        if (rc) {
          return (rc);
        }
        offset = (unsigned int )((size_t )env->me_psize - olddata.mv_size);
        flags |= 6U;
        dummy.md_root = mp->mp_p.p_pgno;
        sub_root = mp;
      }
      if ((unsigned long )mp != (unsigned long )fp) {
        mp->mp_flags = (uint16_t )((int )fp_flags | 16);
        mp->mp_pad = fp->mp_pad;
        mp->mp_pb.pb.pb_lower = fp->mp_pb.pb.pb_lower;
        mp->mp_pb.pb.pb_upper = (indx_t )((unsigned int )fp->mp_pb.pb.pb_upper + offset);
        if ((int )fp_flags & 32) {
          memcpy((void * __restrict  )((void *)((char *)mp + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs)))),
                 (void const   * __restrict  )((void *)((char *)fp + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs)))),
                 (size_t )((((unsigned int )fp->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) * (unsigned int )fp->mp_pad));
        } else {
          memcpy((void * __restrict  )(((char *)mp + (int )mp->mp_pb.pb.pb_upper) + 0U),
                 (void const   * __restrict  )(((char *)fp + (int )fp->mp_pb.pb.pb_upper) + 0U),
                 olddata.mv_size - (size_t )fp->mp_pb.pb.pb_upper);
          memcpy((void * __restrict  )((char *)(& mp->mp_ptrs)), (void const   * __restrict  )((char *)(& fp->mp_ptrs)),
                 (unsigned long )(((unsigned int )fp->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) * sizeof(mp->mp_ptrs[0]));
          i = 0U;
          while (i < ((unsigned int )fp->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) {
            mp->mp_ptrs[i] = (indx_t )((unsigned int )mp->mp_ptrs[i] + offset);
            i ++;
          }
        }
      }
      rdata = & xdata;
      flags |= 4U;
      do_sub = 1;
      if (! insert_key) {
        mdb_node_del(mc, 0);
      }
      goto new_sub;
    }
    current: 
    if (((unsigned int )leaf->mn_flags ^ flags) & 2U) {
      return (-30784);
    }
    if (((int )leaf->mn_flags & 1) == 1) {
      dpages = (int )(((size_t )((unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs)) - 1U) + data->mv_size) / (size_t )env->me_psize + 1UL);
      memcpy((void * __restrict  )(& pg), (void const   * __restrict  )olddata.mv_data,
             sizeof(pg));
      rc2 = mdb_page_get(mc, pg, & omp, & level);
      if (rc2 != 0) {
        return (rc2);
      }
      ovpages = (int )omp->mp_pb.pb_pages;
      if (ovpages >= dpages) {
        if (! ((int )omp->mp_flags & 16)) {
          if (level) {
            goto _L;
          } else
          if (env->me_flags & 524288U) {
            _L: /* CIL Label */ 
            rc = mdb_page_unspill(mc->mc_txn, omp, & omp);
            if (rc) {
              return (rc);
            }
            level = 0;
          }
        }
        if ((int )omp->mp_flags & 16) {
          if (level > 1) {
            sz = (size_t )env->me_psize * (size_t )ovpages;
            tmp___3 = mdb_page_malloc(mc->mc_txn, (unsigned int )ovpages);
            np___0 = tmp___3;
            if (! np___0) {
              return (12);
            }
            id2.mid = pg;
            id2.mptr = (void *)np___0;
            rc2 = mdb_mid2l_insert((mc->mc_txn)->mt_u.dirty_list, & id2);
            if (! (rc2 == 0)) {
              mdb_assert_fail((mc->mc_txn)->mt_env, "rc2 == 0", "mdb_cursor_put",
                              "mdb.c", 7913);
            }
            if (! (flags & 65536U)) {
              off = ((size_t )((unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) + data->mv_size) & - sizeof(size_t );
              memcpy((void * __restrict  )((size_t *)((char *)np___0 + off)), (void const   * __restrict  )((size_t *)((char *)omp + off)),
                     sz - off);
              sz = (size_t )((unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs)));
            }
            memcpy((void * __restrict  )np___0, (void const   * __restrict  )omp,
                   sz);
            omp = np___0;
          }
          while (1) {
            leaf->mn_lo = (unsigned short )(data->mv_size & 65535UL);
            leaf->mn_hi = (unsigned short )(data->mv_size >> 16);
            break;
          }
          if ((flags & 65536U) == 65536U) {
            data->mv_data = (void *)((char *)omp + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs)));
          } else {
            memcpy((void * __restrict  )((void *)((char *)omp + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs)))),
                   (void const   * __restrict  )data->mv_data, data->mv_size);
          }
          return (0);
        }
      }
      rc2 = mdb_ovpage_free(mc, omp);
      if (rc2 != 0) {
        return (rc2);
      }
    } else
    if (data->mv_size == olddata.mv_size) {
      if ((flags & 65536U) == 65536U) {
        data->mv_data = olddata.mv_data;
      } else
      if (! (mc->mc_flags & 4U)) {
        memcpy((void * __restrict  )olddata.mv_data, (void const   * __restrict  )data->mv_data,
               data->mv_size);
      } else {
        memcpy((void * __restrict  )((void *)(leaf->mn_data)), (void const   * __restrict  )key->mv_data,
               key->mv_size);
        goto fix_parent;
      }
      return (0);
    }
    mdb_node_del(mc, 0);
  }
  rdata = data;
  new_sub: 
  nflags = flags & 196614U;
  if (((int )(mc->mc_pg[mc->mc_top])->mp_flags & 32) == 32) {
    nsize = key->mv_size;
  } else {
    tmp___4 = mdb_leaf_size(env, key, rdata);
    nsize = tmp___4;
  }
  if ((size_t )((indx_t )((int )(mc->mc_pg[mc->mc_top])->mp_pb.pb.pb_upper - (int )(mc->mc_pg[mc->mc_top])->mp_pb.pb.pb_lower)) < nsize) {
    if ((flags & 6U) == 4U) {
      nflags &= 4294836223U;
    }
    if (! insert_key) {
      nflags |= 262144U;
    }
    rc = mdb_page_split(mc, key, rdata, ~ ((pgno_t )0), nflags);
  } else {
    rc = mdb_node_add(mc, mc->mc_ki[mc->mc_top], key, rdata, (pgno_t )0, nflags);
    if (rc == 0) {
      dbi = mc->mc_dbi;
      i___0 = (unsigned int )mc->mc_top;
      mp___0 = mc->mc_pg[i___0];
      m2 = *((mc->mc_txn)->mt_cursors + dbi);
      while (m2) {
        if (mc->mc_flags & 4U) {
          m3 = & (m2->mc_xcursor)->mx_cursor;
        } else {
          m3 = m2;
        }
        if ((unsigned long )m3 == (unsigned long )mc) {
          goto __Cont;
        } else
        if ((int )m3->mc_snum < (int )mc->mc_snum) {
          goto __Cont;
        } else
        if ((unsigned long )m3->mc_pg[i___0] != (unsigned long )mp___0) {
          goto __Cont;
        }
        if ((int )m3->mc_ki[i___0] >= (int )mc->mc_ki[i___0]) {
          if (insert_key) {
            m3->mc_ki[i___0] = (indx_t )((int )m3->mc_ki[i___0] + 1);
          }
        }
        while (1) {
          xr_pg = mp___0;
          if (m3->mc_xcursor) {
            if ((m3->mc_xcursor)->mx_cursor.mc_flags & 1U) {
              if ((unsigned int )m3->mc_ki[i___0] >= ((unsigned int )xr_pg->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) {
                break;
              }
            } else {
              break;
            }
          } else {
            break;
          }
          xr_node = (MDB_node *)(((char *)xr_pg + (int )xr_pg->mp_ptrs[m3->mc_ki[i___0]]) + 0U);
          if (((int )xr_node->mn_flags & 6) == 4) {
            (m3->mc_xcursor)->mx_cursor.mc_pg[0] = (MDB_page *)((void *)(xr_node->mn_data + (int )xr_node->mn_ksize));
          }
          break;
        }
        __Cont: /* CIL Label */ 
        m2 = m2->mc_next;
      }
    }
  }
  if (rc == 0) {
    if (do_sub) {
      put_sub: 
      xdata.mv_size = (size_t )0;
      xdata.mv_data = (void *)"";
      leaf = (MDB_node *)(((char *)mc->mc_pg[mc->mc_top] + (int )(mc->mc_pg[mc->mc_top])->mp_ptrs[mc->mc_ki[mc->mc_top]]) + 0U);
      if ((flags & 262208U) == 64U) {
        xflags = 32832;
      } else {
        mdb_xcursor_init1(mc, leaf);
        if (flags & 32U) {
          xflags = 32784;
        } else {
          xflags = 32768;
        }
      }
      if (sub_root) {
        (mc->mc_xcursor)->mx_cursor.mc_pg[0] = sub_root;
      }
      new_dupdata = (int )dkey.mv_size;
      if (dkey.mv_size) {
        rc = mdb_cursor_put(& (mc->mc_xcursor)->mx_cursor, & dkey, & xdata, (unsigned int )xflags);
        if (rc) {
          goto bad_sub;
        }
        dkey.mv_size = (size_t )0;
      }
      if (! ((int )leaf->mn_flags & 2)) {
        goto _L___0;
      } else
      if (sub_root) {
        _L___0: /* CIL Label */ 
        mx = mc->mc_xcursor;
        i___1 = (unsigned int )mc->mc_top;
        mp___1 = mc->mc_pg[i___1];
        m2___0 = *((mc->mc_txn)->mt_cursors + mc->mc_dbi);
        while (m2___0) {
          if ((unsigned long )m2___0 == (unsigned long )mc) {
            goto __Cont___0;
          } else
          if ((int )m2___0->mc_snum < (int )mc->mc_snum) {
            goto __Cont___0;
          }
          if (! (m2___0->mc_flags & 1U)) {
            goto __Cont___0;
          }
          if ((unsigned long )m2___0->mc_pg[i___1] == (unsigned long )mp___1) {
            if ((int )m2___0->mc_ki[i___1] == (int )mc->mc_ki[i___1]) {
              mdb_xcursor_init2(m2___0, mx, new_dupdata);
            } else
            if (! insert_key) {
              while (1) {
                xr_pg___0 = mp___1;
                if (m2___0->mc_xcursor) {
                  if ((m2___0->mc_xcursor)->mx_cursor.mc_flags & 1U) {
                    if ((unsigned int )m2___0->mc_ki[i___1] >= ((unsigned int )xr_pg___0->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) {
                      break;
                    }
                  } else {
                    break;
                  }
                } else {
                  break;
                }
                xr_node___0 = (MDB_node *)(((char *)xr_pg___0 + (int )xr_pg___0->mp_ptrs[m2___0->mc_ki[i___1]]) + 0U);
                if (((int )xr_node___0->mn_flags & 6) == 4) {
                  (m2___0->mc_xcursor)->mx_cursor.mc_pg[0] = (MDB_page *)((void *)(xr_node___0->mn_data + (int )xr_node___0->mn_ksize));
                }
                break;
              }
            }
          }
          __Cont___0: /* CIL Label */ 
          m2___0 = m2___0->mc_next;
        }
      }
      ecount = (mc->mc_xcursor)->mx_db.md_entries;
      if (flags & 262144U) {
        xflags |= 131072;
      }
      rc = mdb_cursor_put(& (mc->mc_xcursor)->mx_cursor, data, & xdata, (unsigned int )xflags);
      if (flags & 2U) {
        db = (void *)(leaf->mn_data + (int )leaf->mn_ksize);
        memcpy((void * __restrict  )db, (void const   * __restrict  )(& (mc->mc_xcursor)->mx_db),
               sizeof(MDB_db ));
      }
      insert_data = (int )((mc->mc_xcursor)->mx_db.md_entries - ecount);
    }
    if (insert_data) {
      ((mc->mc_db)->md_entries) ++;
    }
    if (insert_key) {
      if (rc) {
        goto bad_sub;
      }
      mc->mc_flags |= 1U;
    }
    if (flags & 524288U) {
      if (! rc) {
        mcount ++;
        (data + 1)->mv_size = (size_t )mcount;
        if (mcount < dcount) {
          (data + 0)->mv_data = (void *)((char *)(data + 0)->mv_data + (data + 0)->mv_size);
          insert_data = 0;
          insert_key = insert_data;
          goto more;
        }
      }
    }
    return (rc);
    bad_sub: 
    if (rc == -30799) {
      rc = -30779;
    }
  }
  (mc->mc_txn)->mt_flags |= 2U;
  return (rc);
}
}
int mdb_cursor_del(MDB_cursor *mc , unsigned int flags ) 
{ 
  MDB_node *leaf ;
  MDB_page *mp ;
  int rc ;
  int tmp ;
  void *db ;
  MDB_cursor *m2 ;
  MDB_page *xr_pg ;
  MDB_node *xr_node ;
  MDB_page *omp ;
  pgno_t pg ;
  int tmp___0 ;

  {
  if ((mc->mc_txn)->mt_flags & 131091U) {
    if ((mc->mc_txn)->mt_flags & 131072U) {
      tmp = 13;
    } else {
      tmp = -30782;
    }
    return (tmp);
  }
  if (! (mc->mc_flags & 1U)) {
    return (22);
  }
  if ((unsigned int )mc->mc_ki[mc->mc_top] >= ((unsigned int )(mc->mc_pg[mc->mc_top])->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) {
    return (-30798);
  }
  if (! (flags & 32768U)) {
    rc = mdb_page_spill(mc, (MDB_val *)((void *)0), (MDB_val *)((void *)0));
    if (rc) {
      return (rc);
    }
  }
  rc = mdb_cursor_touch(mc);
  if (rc) {
    return (rc);
  }
  mp = mc->mc_pg[mc->mc_top];
  if (! (((int )mp->mp_flags & 2) == 2)) {
    return (-30796);
  }
  if (((int )mp->mp_flags & 32) == 32) {
    goto del_key;
  }
  leaf = (MDB_node *)(((char *)mp + (int )mp->mp_ptrs[mc->mc_ki[mc->mc_top]]) + 0U);
  if (((int )leaf->mn_flags & 4) == 4) {
    if (flags & 32U) {
      (mc->mc_db)->md_entries -= (mc->mc_xcursor)->mx_db.md_entries - 1UL;
      (mc->mc_xcursor)->mx_cursor.mc_flags &= 4294967294U;
    } else {
      if (! (((int )leaf->mn_flags & 2) == 2)) {
        (mc->mc_xcursor)->mx_cursor.mc_pg[0] = (MDB_page *)((void *)(leaf->mn_data + (int )leaf->mn_ksize));
      }
      rc = mdb_cursor_del(& (mc->mc_xcursor)->mx_cursor, 32768U);
      if (rc) {
        return (rc);
      }
      if ((mc->mc_xcursor)->mx_db.md_entries) {
        if ((int )leaf->mn_flags & 2) {
          db = (void *)(leaf->mn_data + (int )leaf->mn_ksize);
          memcpy((void * __restrict  )db, (void const   * __restrict  )(& (mc->mc_xcursor)->mx_db),
                 sizeof(MDB_db ));
        } else {
          mdb_node_shrink(mp, mc->mc_ki[mc->mc_top]);
          leaf = (MDB_node *)(((char *)mp + (int )mp->mp_ptrs[mc->mc_ki[mc->mc_top]]) + 0U);
          (mc->mc_xcursor)->mx_cursor.mc_pg[0] = (MDB_page *)((void *)(leaf->mn_data + (int )leaf->mn_ksize));
          m2 = *((mc->mc_txn)->mt_cursors + mc->mc_dbi);
          while (m2) {
            if ((unsigned long )m2 == (unsigned long )mc) {
              goto __Cont;
            } else
            if ((int )m2->mc_snum < (int )mc->mc_snum) {
              goto __Cont;
            }
            if (! (m2->mc_flags & 1U)) {
              goto __Cont;
            }
            if ((unsigned long )m2->mc_pg[mc->mc_top] == (unsigned long )mp) {
              while (1) {
                xr_pg = mp;
                if (m2->mc_xcursor) {
                  if ((m2->mc_xcursor)->mx_cursor.mc_flags & 1U) {
                    if ((unsigned int )m2->mc_ki[mc->mc_top] >= ((unsigned int )xr_pg->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) {
                      break;
                    }
                  } else {
                    break;
                  }
                } else {
                  break;
                }
                xr_node = (MDB_node *)(((char *)xr_pg + (int )xr_pg->mp_ptrs[m2->mc_ki[mc->mc_top]]) + 0U);
                if (((int )xr_node->mn_flags & 6) == 4) {
                  (m2->mc_xcursor)->mx_cursor.mc_pg[0] = (MDB_page *)((void *)(xr_node->mn_data + (int )xr_node->mn_ksize));
                }
                break;
              }
            }
            __Cont: /* CIL Label */ 
            m2 = m2->mc_next;
          }
        }
        ((mc->mc_db)->md_entries) --;
        return (rc);
      } else {
        (mc->mc_xcursor)->mx_cursor.mc_flags &= 4294967294U;
      }
    }
    if ((int )leaf->mn_flags & 2) {
      rc = mdb_drop0(& (mc->mc_xcursor)->mx_cursor, 0);
      if (rc) {
        goto fail;
      }
    }
  } else
  if (((unsigned int )leaf->mn_flags ^ flags) & 2U) {
    rc = -30784;
    goto fail;
  }
  if (((int )leaf->mn_flags & 1) == 1) {
    memcpy((void * __restrict  )(& pg), (void const   * __restrict  )((void *)(leaf->mn_data + (int )leaf->mn_ksize)),
           sizeof(pg));
    rc = mdb_page_get(mc, pg, & omp, (int *)((void *)0));
    if (rc) {
      goto fail;
    } else {
      rc = mdb_ovpage_free(mc, omp);
      if (rc) {
        goto fail;
      }
    }
  }
  del_key: 
  tmp___0 = mdb_cursor_del0(mc);
  return (tmp___0);
  fail: 
  (mc->mc_txn)->mt_flags |= 2U;
  return (rc);
}
}
static int mdb_page_new(MDB_cursor *mc , uint32_t flags , int num , MDB_page **mp ) 
{ 
  MDB_page *np ;
  int rc ;

  {
  rc = mdb_page_alloc(mc, num, & np);
  if (rc) {
    return (rc);
  }
  np->mp_flags = (uint16_t )(flags | 16U);
  np->mp_pb.pb.pb_lower = (indx_t )((unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs)));
  np->mp_pb.pb.pb_upper = (indx_t )((mc->mc_txn)->mt_env)->me_psize;
  if (((int )np->mp_flags & 1) == 1) {
    ((mc->mc_db)->md_branch_pages) ++;
  } else
  if (((int )np->mp_flags & 2) == 2) {
    ((mc->mc_db)->md_leaf_pages) ++;
  } else
  if (((int )np->mp_flags & 4) == 4) {
    (mc->mc_db)->md_overflow_pages += (pgno_t )num;
    np->mp_pb.pb_pages = (uint32_t )num;
  }
  *mp = np;
  return (0);
}
}
static size_t mdb_leaf_size(MDB_env *env , MDB_val *key , MDB_val *data ) 
{ 
  size_t sz ;

  {
  sz = ((unsigned long )(& ((MDB_node *)0)->mn_data) + key->mv_size) + data->mv_size;
  if (sz > (size_t )env->me_nodemax) {
    sz -= data->mv_size - sizeof(pgno_t );
  }
  return (((sz + sizeof(indx_t )) + 1UL) & 18446744073709551614);
}
}
static size_t mdb_branch_size(MDB_env *env , MDB_val *key ) 
{ 
  size_t sz ;
  size_t tmp ;

  {
  if ((unsigned long )key == (unsigned long )((void *)0)) {
    tmp = (size_t )0;
  } else {
    tmp = key->mv_size;
  }
  sz = (unsigned long )(& ((MDB_node *)0)->mn_data) + tmp;
  return (sz + sizeof(indx_t ));
}
}
static int mdb_node_add(MDB_cursor *mc , indx_t indx , MDB_val *key , MDB_val *data ,
                        pgno_t pgno , unsigned int flags ) 
{ 
  unsigned int i ;
  size_t node_size ;
  ssize_t room ;
  indx_t ofs ;
  MDB_node *node ;
  MDB_page *mp ;
  MDB_page *ofp ;
  void *ndata ;
  int ksize ;
  int dif ;
  char *ptr ;
  int ovpages ;
  int rc ;

  {
  node_size = (unsigned long )(& ((MDB_node *)0)->mn_data);
  mp = mc->mc_pg[mc->mc_top];
  ofp = (MDB_page *)((void *)0);
  if (! ((int )mp->mp_pb.pb.pb_upper >= (int )mp->mp_pb.pb.pb_lower)) {
    mdb_assert_fail((mc->mc_txn)->mt_env, "mp->mp_upper >= mp->mp_lower", "mdb_node_add",
                    "mdb.c", 8306);
  }
  if (((int )mp->mp_flags & 32) == 32) {
    ksize = (int )(mc->mc_db)->md_pad;
    ptr = ((char *)mp + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) + (int )indx * ksize;
    dif = (int )((((unsigned int )mp->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) - (unsigned int )indx);
    if (dif > 0) {
      memmove((void *)(ptr + ksize), (void const   *)ptr, (size_t )(dif * ksize));
    }
    memcpy((void * __restrict  )ptr, (void const   * __restrict  )key->mv_data, (size_t )ksize);
    mp->mp_pb.pb.pb_lower = (indx_t )((unsigned long )mp->mp_pb.pb.pb_lower + sizeof(indx_t ));
    mp->mp_pb.pb.pb_upper = (indx_t )((unsigned long )mp->mp_pb.pb.pb_upper - ((unsigned long )ksize - sizeof(indx_t )));
    return (0);
  }
  room = (ssize_t )((indx_t )((int )mp->mp_pb.pb.pb_upper - (int )mp->mp_pb.pb.pb_lower)) - (ssize_t )sizeof(indx_t );
  if ((unsigned long )key != (unsigned long )((void *)0)) {
    node_size += key->mv_size;
  }
  if (((int )mp->mp_flags & 2) == 2) {
    if (key) {
      if (! data) {
        mdb_assert_fail((mc->mc_txn)->mt_env, "key && data", "mdb_node_add", "mdb.c",
                        8334);
      }
    } else {
      mdb_assert_fail((mc->mc_txn)->mt_env, "key && data", "mdb_node_add", "mdb.c",
                      8334);
    }
    if ((flags & 1U) == 1U) {
      node_size += sizeof(pgno_t );
    } else
    if (node_size + data->mv_size > (size_t )((mc->mc_txn)->mt_env)->me_nodemax) {
      ovpages = (int )(((size_t )((unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs)) - 1U) + data->mv_size) / (size_t )((mc->mc_txn)->mt_env)->me_psize + 1UL);
      node_size = ((node_size + sizeof(pgno_t )) + 1UL) & 18446744073709551614;
      if ((ssize_t )node_size > room) {
        goto full;
      }
      rc = mdb_page_new(mc, (uint32_t )4, ovpages, & ofp);
      if (rc) {
        return (rc);
      }
      flags |= 1U;
      goto update;
    } else {
      node_size += data->mv_size;
    }
  }
  node_size = (node_size + 1UL) & 18446744073709551614;
  if ((ssize_t )node_size > room) {
    goto full;
  }
  update: 
  i = ((unsigned int )mp->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1;
  while (i > (unsigned int )indx) {
    mp->mp_ptrs[i] = mp->mp_ptrs[i - 1U];
    i --;
  }
  ofs = (indx_t )((size_t )mp->mp_pb.pb.pb_upper - node_size);
  if (! ((unsigned long )ofs >= (unsigned long )mp->mp_pb.pb.pb_lower + sizeof(indx_t ))) {
    mdb_assert_fail((mc->mc_txn)->mt_env, "ofs >= mp->mp_lower + sizeof(indx_t)",
                    "mdb_node_add", "mdb.c", 8367);
  }
  mp->mp_ptrs[indx] = ofs;
  mp->mp_pb.pb.pb_upper = ofs;
  mp->mp_pb.pb.pb_lower = (indx_t )((unsigned long )mp->mp_pb.pb.pb_lower + sizeof(indx_t ));
  node = (MDB_node *)(((char *)mp + (int )mp->mp_ptrs[indx]) + 0U);
  if ((unsigned long )key == (unsigned long )((void *)0)) {
    node->mn_ksize = (unsigned short)0;
  } else {
    node->mn_ksize = (unsigned short )key->mv_size;
  }
  node->mn_flags = (unsigned short )flags;
  if (((int )mp->mp_flags & 2) == 2) {
    while (1) {
      node->mn_lo = (unsigned short )(data->mv_size & 65535UL);
      node->mn_hi = (unsigned short )(data->mv_size >> 16);
      break;
    }
  } else {
    while (1) {
      node->mn_lo = (unsigned short )(pgno & 65535UL);
      node->mn_hi = (unsigned short )(pgno >> 16);
      node->mn_flags = (unsigned short )(pgno >> 32);
      break;
    }
  }
  if (key) {
    memcpy((void * __restrict  )((void *)(node->mn_data)), (void const   * __restrict  )key->mv_data,
           key->mv_size);
  }
  if (((int )mp->mp_flags & 2) == 2) {
    ndata = (void *)(node->mn_data + (int )node->mn_ksize);
    if ((unsigned long )ofp == (unsigned long )((void *)0)) {
      if ((flags & 1U) == 1U) {
        memcpy((void * __restrict  )ndata, (void const   * __restrict  )data->mv_data,
               sizeof(pgno_t ));
      } else
      if ((flags & 65536U) == 65536U) {
        data->mv_data = ndata;
      } else {
        memcpy((void * __restrict  )ndata, (void const   * __restrict  )data->mv_data,
               data->mv_size);
      }
    } else {
      memcpy((void * __restrict  )ndata, (void const   * __restrict  )(& ofp->mp_p.p_pgno),
             sizeof(pgno_t ));
      ndata = (void *)((char *)ofp + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs)));
      if ((flags & 65536U) == 65536U) {
        data->mv_data = ndata;
      } else {
        memcpy((void * __restrict  )ndata, (void const   * __restrict  )data->mv_data,
               data->mv_size);
      }
    }
  }
  return (0);
  full: 
  (mc->mc_txn)->mt_flags |= 2U;
  return (-30786);
}
}
static void mdb_node_del(MDB_cursor *mc , int ksize ) 
{ 
  MDB_page *mp ;
  indx_t indx ;
  unsigned int sz ;
  indx_t i ;
  indx_t j ;
  indx_t numkeys ;
  indx_t ptr ;
  MDB_node *node ;
  char *base ;
  int x ;

  {
  mp = mc->mc_pg[mc->mc_top];
  indx = mc->mc_ki[mc->mc_top];
  numkeys = (indx_t )(((unsigned int )mp->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1);
  if (! ((int )indx < (int )numkeys)) {
    mdb_assert_fail((mc->mc_txn)->mt_env, "indx < numkeys", "mdb_node_del", "mdb.c",
                    8432);
  }
  if (((int )mp->mp_flags & 32) == 32) {
    x = ((int )numkeys - 1) - (int )indx;
    base = ((char *)mp + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) + (int )indx * ksize;
    if (x) {
      memmove((void *)base, (void const   *)(base + ksize), (size_t )(x * ksize));
    }
    mp->mp_pb.pb.pb_lower = (indx_t )((unsigned long )mp->mp_pb.pb.pb_lower - sizeof(indx_t ));
    mp->mp_pb.pb.pb_upper = (indx_t )((unsigned long )mp->mp_pb.pb.pb_upper + ((unsigned long )ksize - sizeof(indx_t )));
    return;
  }
  node = (MDB_node *)(((char *)mp + (int )mp->mp_ptrs[indx]) + 0U);
  sz = (unsigned int )((unsigned long )(& ((MDB_node *)0)->mn_data) + (unsigned long )node->mn_ksize);
  if (((int )mp->mp_flags & 2) == 2) {
    if (((int )node->mn_flags & 1) == 1) {
      sz = (unsigned int )((unsigned long )sz + sizeof(pgno_t ));
    } else {
      sz += (unsigned int )node->mn_lo | ((unsigned int )node->mn_hi << 16);
    }
  }
  sz = (sz + 1U) & 4294967294U;
  ptr = mp->mp_ptrs[indx];
  j = (indx_t )0;
  i = j;
  while ((int )i < (int )numkeys) {
    if ((int )i != (int )indx) {
      mp->mp_ptrs[j] = mp->mp_ptrs[i];
      if ((int )mp->mp_ptrs[i] < (int )ptr) {
        mp->mp_ptrs[j] = (indx_t )((unsigned int )mp->mp_ptrs[j] + sz);
      }
      j = (indx_t )((int )j + 1);
    }
    i = (indx_t )((int )i + 1);
  }
  base = ((char *)mp + (int )mp->mp_pb.pb.pb_upper) + 0U;
  memmove((void *)(base + sz), (void const   *)base, (size_t )((int )ptr - (int )mp->mp_pb.pb.pb_upper));
  mp->mp_pb.pb.pb_lower = (indx_t )((unsigned long )mp->mp_pb.pb.pb_lower - sizeof(indx_t ));
  mp->mp_pb.pb.pb_upper = (indx_t )((unsigned int )mp->mp_pb.pb.pb_upper + sz);
  return;
}
}
static void mdb_node_shrink(MDB_page *mp , indx_t indx ) 
{ 
  MDB_node *node ;
  MDB_page *sp ;
  MDB_page *xp ;
  char *base ;
  indx_t delta ;
  indx_t nsize ;
  indx_t len ;
  indx_t ptr ;
  int i ;

  {
  node = (MDB_node *)(((char *)mp + (int )mp->mp_ptrs[indx]) + 0U);
  sp = (MDB_page *)((void *)(node->mn_data + (int )node->mn_ksize));
  delta = (indx_t )((int )sp->mp_pb.pb.pb_upper - (int )sp->mp_pb.pb.pb_lower);
  nsize = (indx_t )(((unsigned int )node->mn_lo | ((unsigned int )node->mn_hi << 16)) - (unsigned int )delta);
  if (((int )sp->mp_flags & 32) == 32) {
    len = nsize;
    if ((int )nsize & 1) {
      return;
    }
  } else {
    xp = (MDB_page *)((char *)sp + (int )delta);
    i = (int )(((unsigned int )sp->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1);
    while (1) {
      i --;
      if (! (i >= 0)) {
        break;
      }
      xp->mp_ptrs[i] = (indx_t )((int )sp->mp_ptrs[i] - (int )delta);
    }
    len = (indx_t )((unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs)));
  }
  sp->mp_pb.pb.pb_upper = sp->mp_pb.pb.pb_lower;
  sp->mp_p.p_pgno = mp->mp_p.p_pgno;
  while (1) {
    node->mn_lo = (unsigned short )((int )nsize & 65535);
    node->mn_hi = (unsigned short )((int )nsize >> 16);
    break;
  }
  base = ((char *)mp + (int )mp->mp_pb.pb.pb_upper) + 0U;
  memmove((void *)(base + (int )delta), (void const   *)base, (size_t )(((char *)sp + (int )len) - base));
  ptr = mp->mp_ptrs[indx];
  i = (int )(((unsigned int )mp->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1);
  while (1) {
    i --;
    if (! (i >= 0)) {
      break;
    }
    if ((int )mp->mp_ptrs[i] <= (int )ptr) {
      mp->mp_ptrs[i] = (indx_t )((int )mp->mp_ptrs[i] + (int )delta);
    }
  }
  mp->mp_pb.pb.pb_upper = (indx_t )((int )mp->mp_pb.pb.pb_upper + (int )delta);
  return;
}
}
static void mdb_xcursor_init0(MDB_cursor *mc ) 
{ 
  MDB_xcursor *mx ;

  {
  mx = mc->mc_xcursor;
  mx->mx_cursor.mc_xcursor = (struct MDB_xcursor *)((void *)0);
  mx->mx_cursor.mc_txn = mc->mc_txn;
  mx->mx_cursor.mc_db = & mx->mx_db;
  mx->mx_cursor.mc_dbx = & mx->mx_dbx;
  mx->mx_cursor.mc_dbi = mc->mc_dbi;
  mx->mx_cursor.mc_dbflag = & mx->mx_dbflag;
  mx->mx_cursor.mc_snum = (unsigned short)0;
  mx->mx_cursor.mc_top = (unsigned short)0;
  mx->mx_cursor.mc_flags = 4U | (mc->mc_flags & 655360U);
  mx->mx_dbx.md_name.mv_size = (size_t )0;
  mx->mx_dbx.md_name.mv_data = (void *)0;
  mx->mx_dbx.md_cmp = (mc->mc_dbx)->md_dcmp;
  mx->mx_dbx.md_dcmp = (MDB_cmp_func *)((void *)0);
  mx->mx_dbx.md_rel = (mc->mc_dbx)->md_rel;
  return;
}
}
static void mdb_xcursor_init1(MDB_cursor *mc , MDB_node *node ) 
{ 
  MDB_xcursor *mx ;
  MDB_page *fp ;

  {
  mx = mc->mc_xcursor;
  mx->mx_cursor.mc_flags &= 655364U;
  if ((int )node->mn_flags & 2) {
    memcpy((void * __restrict  )(& mx->mx_db), (void const   * __restrict  )((void *)(node->mn_data + (int )node->mn_ksize)),
           sizeof(MDB_db ));
    mx->mx_cursor.mc_pg[0] = (MDB_page *)0;
    mx->mx_cursor.mc_snum = (unsigned short)0;
    mx->mx_cursor.mc_top = (unsigned short)0;
  } else {
    fp = (MDB_page *)((void *)(node->mn_data + (int )node->mn_ksize));
    mx->mx_db.md_pad = (uint32_t )0;
    mx->mx_db.md_flags = (uint16_t )0;
    mx->mx_db.md_depth = (uint16_t )1;
    mx->mx_db.md_branch_pages = (pgno_t )0;
    mx->mx_db.md_leaf_pages = (pgno_t )1;
    mx->mx_db.md_overflow_pages = (pgno_t )0;
    mx->mx_db.md_entries = (mdb_size_t )(((unsigned int )fp->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1);
    mx->mx_db.md_root = fp->mp_p.p_pgno;
    mx->mx_cursor.mc_snum = (unsigned short)1;
    mx->mx_cursor.mc_top = (unsigned short)0;
    mx->mx_cursor.mc_flags |= 1U;
    mx->mx_cursor.mc_pg[0] = fp;
    mx->mx_cursor.mc_ki[0] = (indx_t )0;
    if ((int )(mc->mc_db)->md_flags & 16) {
      mx->mx_db.md_flags = (uint16_t )16;
      mx->mx_db.md_pad = (uint32_t )fp->mp_pad;
      if ((int )(mc->mc_db)->md_flags & 32) {
        mx->mx_db.md_flags = (uint16_t )((int )mx->mx_db.md_flags | 8);
      }
    }
  }
  mx->mx_dbflag = (unsigned char)56;
  if ((unsigned long )mx->mx_dbx.md_cmp == (unsigned long )(& mdb_cmp_int)) {
    if ((unsigned long )mx->mx_db.md_pad == sizeof(mdb_size_t )) {
      mx->mx_dbx.md_cmp = & mdb_cmp_long;
    }
  }
  return;
}
}
static void mdb_xcursor_init2(MDB_cursor *mc , MDB_xcursor *src_mx , int new_dupdata ) 
{ 
  MDB_xcursor *mx ;

  {
  mx = mc->mc_xcursor;
  if (new_dupdata) {
    mx->mx_cursor.mc_snum = (unsigned short)1;
    mx->mx_cursor.mc_top = (unsigned short)0;
    mx->mx_cursor.mc_flags |= 1U;
    mx->mx_cursor.mc_ki[0] = (indx_t )0;
    mx->mx_dbflag = (unsigned char)56;
    mx->mx_dbx.md_cmp = src_mx->mx_dbx.md_cmp;
  } else
  if (! (mx->mx_cursor.mc_flags & 1U)) {
    return;
  }
  mx->mx_db = src_mx->mx_db;
  mx->mx_cursor.mc_pg[0] = src_mx->mx_cursor.mc_pg[0];
  return;
}
}
static void mdb_cursor_init(MDB_cursor *mc , MDB_txn *txn , MDB_dbi dbi , MDB_xcursor *mx ) 
{ 


  {
  mc->mc_next = (MDB_cursor *)((void *)0);
  mc->mc_backup = (MDB_cursor *)((void *)0);
  mc->mc_dbi = dbi;
  mc->mc_txn = txn;
  mc->mc_db = txn->mt_dbs + dbi;
  mc->mc_dbx = txn->mt_dbxs + dbi;
  mc->mc_dbflag = txn->mt_dbflags + dbi;
  mc->mc_snum = (unsigned short)0;
  mc->mc_top = (unsigned short)0;
  mc->mc_pg[0] = (MDB_page *)0;
  mc->mc_ki[0] = (indx_t )0;
  mc->mc_flags = txn->mt_flags & 655360U;
  if ((int )(txn->mt_dbs + dbi)->md_flags & 4) {
    if (! ((unsigned long )mx != (unsigned long )((void *)0))) {
      mdb_assert_fail(txn->mt_env, "mx != NULL", "mdb_cursor_init", "mdb.c", 8643);
    }
    mc->mc_xcursor = mx;
    mdb_xcursor_init0(mc);
  } else {
    mc->mc_xcursor = (struct MDB_xcursor *)((void *)0);
  }
  if ((int )*(mc->mc_dbflag) & 2) {
    mdb_page_search(mc, (MDB_val *)((void *)0), 2);
  }
  return;
}
}
int mdb_cursor_open(MDB_txn *txn , MDB_dbi dbi , MDB_cursor **ret ) 
{ 
  MDB_cursor *mc ;
  size_t size ;
  void *tmp ;

  {
  size = sizeof(MDB_cursor );
  if (! ret) {
    return (22);
  } else
  if (txn) {
    if (dbi < txn->mt_numdbs) {
      if (! ((int )*(txn->mt_dbflags + dbi) & 8)) {
        return (22);
      }
    } else {
      return (22);
    }
  } else {
    return (22);
  }
  if (txn->mt_flags & 19U) {
    return (-30782);
  }
  if (dbi == 0U) {
    if (! ((txn->mt_flags & 131072U) == 131072U)) {
      return (22);
    }
  }
  if ((int )(txn->mt_dbs + dbi)->md_flags & 4) {
    size += sizeof(MDB_xcursor );
  }
  tmp = malloc(size);
  mc = (MDB_cursor *)tmp;
  if ((unsigned long )mc != (unsigned long )((void *)0)) {
    mdb_cursor_init(mc, txn, dbi, (MDB_xcursor *)(mc + 1));
    if (txn->mt_cursors) {
      mc->mc_next = *(txn->mt_cursors + dbi);
      *(txn->mt_cursors + dbi) = mc;
      mc->mc_flags |= 64U;
    }
  } else {
    return (12);
  }
  *ret = mc;
  return (0);
}
}
int mdb_cursor_renew(MDB_txn *txn , MDB_cursor *mc ) 
{ 


  {
  if (! mc) {
    return (22);
  } else
  if (txn) {
    if (mc->mc_dbi < txn->mt_numdbs) {
      if (! ((int )*(txn->mt_dbflags + mc->mc_dbi) & 8)) {
        return (22);
      }
    } else {
      return (22);
    }
  } else {
    return (22);
  }
  if (mc->mc_flags & 64U) {
    return (22);
  } else
  if (txn->mt_cursors) {
    return (22);
  }
  if (txn->mt_flags & 19U) {
    return (-30782);
  }
  mdb_cursor_init(mc, txn, mc->mc_dbi, mc->mc_xcursor);
  return (0);
}
}
int mdb_cursor_count(MDB_cursor *mc , mdb_size_t *countp ) 
{ 
  MDB_node *leaf ;

  {
  if ((unsigned long )mc == (unsigned long )((void *)0)) {
    return (22);
  } else
  if ((unsigned long )countp == (unsigned long )((void *)0)) {
    return (22);
  }
  if ((unsigned long )mc->mc_xcursor == (unsigned long )((void *)0)) {
    return (-30784);
  }
  if ((mc->mc_txn)->mt_flags & 19U) {
    return (-30782);
  }
  if (! (mc->mc_flags & 1U)) {
    return (22);
  }
  if (! mc->mc_snum) {
    return (-30798);
  }
  if (mc->mc_flags & 2U) {
    if ((unsigned int )mc->mc_ki[mc->mc_top] >= ((unsigned int )(mc->mc_pg[mc->mc_top])->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) {
      return (-30798);
    }
    mc->mc_flags ^= 2U;
  }
  leaf = (MDB_node *)(((char *)mc->mc_pg[mc->mc_top] + (int )(mc->mc_pg[mc->mc_top])->mp_ptrs[mc->mc_ki[mc->mc_top]]) + 0U);
  if (! (((int )leaf->mn_flags & 4) == 4)) {
    *countp = (mdb_size_t )1;
  } else {
    if (! ((mc->mc_xcursor)->mx_cursor.mc_flags & 1U)) {
      return (22);
    }
    *countp = (mc->mc_xcursor)->mx_db.md_entries;
  }
  return (0);
}
}
void mdb_cursor_close(MDB_cursor *mc ) 
{ 
  MDB_cursor **prev ;

  {
  if (mc) {
    if (! mc->mc_backup) {
      if (mc->mc_flags & 64U) {
        if ((mc->mc_txn)->mt_cursors) {
          prev = (mc->mc_txn)->mt_cursors + mc->mc_dbi;
          while (1) {
            if (*prev) {
              if (! ((unsigned long )*prev != (unsigned long )mc)) {
                break;
              }
            } else {
              break;
            }
            prev = & (*prev)->mc_next;
          }
          if ((unsigned long )*prev == (unsigned long )mc) {
            *prev = mc->mc_next;
          }
        }
      }
      free((void *)mc);
    }
  }
  return;
}
}
MDB_txn *mdb_cursor_txn(MDB_cursor *mc ) 
{ 


  {
  if (! mc) {
    return ((MDB_txn *)((void *)0));
  }
  return (mc->mc_txn);
}
}
MDB_dbi mdb_cursor_dbi(MDB_cursor *mc ) 
{ 


  {
  return (mc->mc_dbi);
}
}
static int mdb_update_key(MDB_cursor *mc , MDB_val *key ) 
{ 
  MDB_page *mp ;
  MDB_node *node ;
  char *base ;
  size_t len ;
  int delta ;
  int ksize ;
  int oksize ;
  indx_t ptr ;
  indx_t i ;
  indx_t numkeys ;
  indx_t indx ;
  pgno_t pgno ;
  int tmp ;

  {
  indx = mc->mc_ki[mc->mc_top];
  mp = mc->mc_pg[mc->mc_top];
  node = (MDB_node *)(((char *)mp + (int )mp->mp_ptrs[indx]) + 0U);
  ptr = mp->mp_ptrs[indx];
  ksize = (int )((key->mv_size + 1UL) & 18446744073709551614);
  oksize = (int )(((unsigned int )node->mn_ksize + 1U) & 4294967294U);
  delta = ksize - oksize;
  if (delta) {
    if (delta > 0) {
      if ((int )((indx_t )((int )mp->mp_pb.pb.pb_upper - (int )mp->mp_pb.pb.pb_lower)) < delta) {
        pgno = ((unsigned long )node->mn_lo | ((pgno_t )node->mn_hi << 16)) | ((pgno_t )node->mn_flags << 32);
        mdb_node_del(mc, 0);
        tmp = mdb_page_split(mc, key, (MDB_val *)((void *)0), pgno, 262144U);
        return (tmp);
      }
    }
    numkeys = (indx_t )(((unsigned int )mp->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1);
    i = (indx_t )0;
    while ((int )i < (int )numkeys) {
      if ((int )mp->mp_ptrs[i] <= (int )ptr) {
        mp->mp_ptrs[i] = (indx_t )((int )mp->mp_ptrs[i] - delta);
      }
      i = (indx_t )((int )i + 1);
    }
    base = ((char *)mp + (int )mp->mp_pb.pb.pb_upper) + 0U;
    len = (unsigned long )((int )ptr - (int )mp->mp_pb.pb.pb_upper) + (unsigned long )(& ((MDB_node *)0)->mn_data);
    memmove((void *)(base - delta), (void const   *)base, len);
    mp->mp_pb.pb.pb_upper = (indx_t )((int )mp->mp_pb.pb.pb_upper - delta);
    node = (MDB_node *)(((char *)mp + (int )mp->mp_ptrs[indx]) + 0U);
  }
  if ((size_t )node->mn_ksize != key->mv_size) {
    node->mn_ksize = (unsigned short )key->mv_size;
  }
  if (key->mv_size) {
    memcpy((void * __restrict  )((void *)(node->mn_data)), (void const   * __restrict  )key->mv_data,
           key->mv_size);
  }
  return (0);
}
}
static void mdb_cursor_copy(MDB_cursor const   *csrc , MDB_cursor *cdst ) ;
static int mdb_node_move(MDB_cursor *csrc , MDB_cursor *cdst , int fromleft ) 
{ 
  MDB_node *srcnode ;
  MDB_val key ;
  MDB_val data ;
  pgno_t srcpg ;
  MDB_cursor mn ;
  int rc ;
  unsigned short flags ;
  unsigned int snum ;
  MDB_node *s2 ;
  unsigned int tmp ;
  unsigned int snum___0 ;
  MDB_node *s2___0 ;
  MDB_val bkey ;
  unsigned int tmp___0 ;
  MDB_cursor *m2 ;
  MDB_cursor *m3 ;
  MDB_dbi dbi ;
  MDB_page *mpd ;
  MDB_page *mps ;
  MDB_page *xr_pg ;
  MDB_node *xr_node ;
  MDB_page *xr_pg___0 ;
  MDB_node *xr_node___0 ;
  MDB_cursor dummy ;
  MDB_cursor *tracked ;
  MDB_cursor **tp ;
  MDB_val nullkey ;
  indx_t ix ;
  MDB_cursor dummy___0 ;
  MDB_cursor *tracked___0 ;
  MDB_cursor **tp___0 ;
  MDB_val nullkey___0 ;
  indx_t ix___0 ;

  {
  rc = mdb_page_touch(csrc);
  if (rc) {
    return (rc);
  } else {
    rc = mdb_page_touch(cdst);
    if (rc) {
      return (rc);
    }
  }
  if (((int )(csrc->mc_pg[csrc->mc_top])->mp_flags & 32) == 32) {
    key.mv_size = (size_t )(csrc->mc_db)->md_pad;
    key.mv_data = (void *)(((char *)csrc->mc_pg[csrc->mc_top] + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) + (size_t )csrc->mc_ki[csrc->mc_top] * key.mv_size);
    data.mv_size = (size_t )0;
    data.mv_data = (void *)0;
    srcpg = (pgno_t )0;
    flags = (unsigned short)0;
  } else {
    srcnode = (MDB_node *)(((char *)csrc->mc_pg[csrc->mc_top] + (int )(csrc->mc_pg[csrc->mc_top])->mp_ptrs[csrc->mc_ki[csrc->mc_top]]) + 0U);
    if (! (! ((size_t )srcnode & 1UL))) {
      mdb_assert_fail((csrc->mc_txn)->mt_env, "!((size_t)srcnode & 1)", "mdb_node_move",
                      "mdb.c", 8899);
    }
    srcpg = ((unsigned long )srcnode->mn_lo | ((pgno_t )srcnode->mn_hi << 16)) | ((pgno_t )srcnode->mn_flags << 32);
    flags = srcnode->mn_flags;
    if ((int )csrc->mc_ki[csrc->mc_top] == 0) {
      if (((int )(csrc->mc_pg[csrc->mc_top])->mp_flags & 1) == 1) {
        snum = (unsigned int )csrc->mc_snum;
        rc = mdb_page_search_lowest(csrc);
        if (rc) {
          return (rc);
        }
        if (((int )(csrc->mc_pg[csrc->mc_top])->mp_flags & 32) == 32) {
          key.mv_size = (size_t )(csrc->mc_db)->md_pad;
          key.mv_data = (void *)(((char *)csrc->mc_pg[csrc->mc_top] + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) + 0UL);
        } else {
          s2 = (MDB_node *)(((char *)csrc->mc_pg[csrc->mc_top] + (int )(csrc->mc_pg[csrc->mc_top])->mp_ptrs[0]) + 0U);
          key.mv_size = (size_t )s2->mn_ksize;
          key.mv_data = (void *)(s2->mn_data);
        }
        tmp = snum;
        snum --;
        csrc->mc_snum = (unsigned short )tmp;
        csrc->mc_top = (unsigned short )snum;
      } else {
        key.mv_size = (size_t )srcnode->mn_ksize;
        key.mv_data = (void *)(srcnode->mn_data);
      }
    } else {
      key.mv_size = (size_t )srcnode->mn_ksize;
      key.mv_data = (void *)(srcnode->mn_data);
    }
    data.mv_size = (size_t )((unsigned int )srcnode->mn_lo | ((unsigned int )srcnode->mn_hi << 16));
    data.mv_data = (void *)(srcnode->mn_data + (int )srcnode->mn_ksize);
  }
  mn.mc_xcursor = (struct MDB_xcursor *)((void *)0);
  if (((int )(cdst->mc_pg[cdst->mc_top])->mp_flags & 1) == 1) {
    if ((int )cdst->mc_ki[cdst->mc_top] == 0) {
      snum___0 = (unsigned int )cdst->mc_snum;
      mdb_cursor_copy((MDB_cursor const   *)cdst, & mn);
      rc = mdb_page_search_lowest(& mn);
      if (rc) {
        return (rc);
      }
      if (((int )(mn.mc_pg[mn.mc_top])->mp_flags & 32) == 32) {
        bkey.mv_size = (size_t )(mn.mc_db)->md_pad;
        bkey.mv_data = (void *)(((char *)mn.mc_pg[mn.mc_top] + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) + 0UL);
      } else {
        s2___0 = (MDB_node *)(((char *)mn.mc_pg[mn.mc_top] + (int )(mn.mc_pg[mn.mc_top])->mp_ptrs[0]) + 0U);
        bkey.mv_size = (size_t )s2___0->mn_ksize;
        bkey.mv_data = (void *)(s2___0->mn_data);
      }
      tmp___0 = snum___0;
      snum___0 --;
      mn.mc_snum = (unsigned short )tmp___0;
      mn.mc_top = (unsigned short )snum___0;
      mn.mc_ki[snum___0] = (indx_t )0;
      rc = mdb_update_key(& mn, & bkey);
      if (rc) {
        return (rc);
      }
    }
  }
  rc = mdb_node_add(cdst, cdst->mc_ki[cdst->mc_top], & key, & data, srcpg, (unsigned int )flags);
  if (rc != 0) {
    return (rc);
  }
  mdb_node_del(csrc, (int )key.mv_size);
  dbi = csrc->mc_dbi;
  mps = csrc->mc_pg[csrc->mc_top];
  if (fromleft) {
    mpd = cdst->mc_pg[csrc->mc_top];
    m2 = *((csrc->mc_txn)->mt_cursors + dbi);
    while (m2) {
      if (csrc->mc_flags & 4U) {
        m3 = & (m2->mc_xcursor)->mx_cursor;
      } else {
        m3 = m2;
      }
      if (! (m3->mc_flags & 1U)) {
        goto __Cont;
      } else
      if ((int )m3->mc_top < (int )csrc->mc_top) {
        goto __Cont;
      }
      if ((unsigned long )m3 != (unsigned long )cdst) {
        if ((unsigned long )m3->mc_pg[csrc->mc_top] == (unsigned long )mpd) {
          if ((int )m3->mc_ki[csrc->mc_top] >= (int )cdst->mc_ki[csrc->mc_top]) {
            m3->mc_ki[csrc->mc_top] = (indx_t )((int )m3->mc_ki[csrc->mc_top] + 1);
          }
        }
      }
      if ((unsigned long )m3 != (unsigned long )csrc) {
        if ((unsigned long )m3->mc_pg[csrc->mc_top] == (unsigned long )mps) {
          if ((int )m3->mc_ki[csrc->mc_top] == (int )csrc->mc_ki[csrc->mc_top]) {
            m3->mc_pg[csrc->mc_top] = cdst->mc_pg[cdst->mc_top];
            m3->mc_ki[csrc->mc_top] = cdst->mc_ki[cdst->mc_top];
            m3->mc_ki[(int )csrc->mc_top - 1] = (indx_t )((int )m3->mc_ki[(int )csrc->mc_top - 1] + 1);
          }
        }
      }
      if (((int )mps->mp_flags & 2) == 2) {
        while (1) {
          xr_pg = m3->mc_pg[csrc->mc_top];
          if (m3->mc_xcursor) {
            if ((m3->mc_xcursor)->mx_cursor.mc_flags & 1U) {
              if ((unsigned int )m3->mc_ki[csrc->mc_top] >= ((unsigned int )xr_pg->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) {
                break;
              }
            } else {
              break;
            }
          } else {
            break;
          }
          xr_node = (MDB_node *)(((char *)xr_pg + (int )xr_pg->mp_ptrs[m3->mc_ki[csrc->mc_top]]) + 0U);
          if (((int )xr_node->mn_flags & 6) == 4) {
            (m3->mc_xcursor)->mx_cursor.mc_pg[0] = (MDB_page *)((void *)(xr_node->mn_data + (int )xr_node->mn_ksize));
          }
          break;
        }
      }
      __Cont: /* CIL Label */ 
      m2 = m2->mc_next;
    }
  } else {
    m2 = *((csrc->mc_txn)->mt_cursors + dbi);
    while (m2) {
      if (csrc->mc_flags & 4U) {
        m3 = & (m2->mc_xcursor)->mx_cursor;
      } else {
        m3 = m2;
      }
      if ((unsigned long )m3 == (unsigned long )csrc) {
        goto __Cont___0;
      }
      if (! (m3->mc_flags & 1U)) {
        goto __Cont___0;
      } else
      if ((int )m3->mc_top < (int )csrc->mc_top) {
        goto __Cont___0;
      }
      if ((unsigned long )m3->mc_pg[csrc->mc_top] == (unsigned long )mps) {
        if (! m3->mc_ki[csrc->mc_top]) {
          m3->mc_pg[csrc->mc_top] = cdst->mc_pg[cdst->mc_top];
          m3->mc_ki[csrc->mc_top] = cdst->mc_ki[cdst->mc_top];
          m3->mc_ki[(int )csrc->mc_top - 1] = (indx_t )((int )m3->mc_ki[(int )csrc->mc_top - 1] - 1);
        } else {
          m3->mc_ki[csrc->mc_top] = (indx_t )((int )m3->mc_ki[csrc->mc_top] - 1);
        }
        if (((int )mps->mp_flags & 2) == 2) {
          while (1) {
            xr_pg___0 = m3->mc_pg[csrc->mc_top];
            if (m3->mc_xcursor) {
              if ((m3->mc_xcursor)->mx_cursor.mc_flags & 1U) {
                if ((unsigned int )m3->mc_ki[csrc->mc_top] >= ((unsigned int )xr_pg___0->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) {
                  break;
                }
              } else {
                break;
              }
            } else {
              break;
            }
            xr_node___0 = (MDB_node *)(((char *)xr_pg___0 + (int )xr_pg___0->mp_ptrs[m3->mc_ki[csrc->mc_top]]) + 0U);
            if (((int )xr_node___0->mn_flags & 6) == 4) {
              (m3->mc_xcursor)->mx_cursor.mc_pg[0] = (MDB_page *)((void *)(xr_node___0->mn_data + (int )xr_node___0->mn_ksize));
            }
            break;
          }
        }
      }
      __Cont___0: /* CIL Label */ 
      m2 = m2->mc_next;
    }
  }
  if ((int )csrc->mc_ki[csrc->mc_top] == 0) {
    if ((int )csrc->mc_ki[(int )csrc->mc_top - 1] != 0) {
      if (((int )(csrc->mc_pg[csrc->mc_top])->mp_flags & 32) == 32) {
        key.mv_data = (void *)(((char *)csrc->mc_pg[csrc->mc_top] + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) + 0UL);
      } else {
        srcnode = (MDB_node *)(((char *)csrc->mc_pg[csrc->mc_top] + (int )(csrc->mc_pg[csrc->mc_top])->mp_ptrs[0]) + 0U);
        key.mv_size = (size_t )srcnode->mn_ksize;
        key.mv_data = (void *)(srcnode->mn_data);
      }
      mdb_cursor_copy((MDB_cursor const   *)csrc, & mn);
      mn.mc_snum = (unsigned short )((int )mn.mc_snum - 1);
      mn.mc_top = (unsigned short )((int )mn.mc_top - 1);
      while (1) {
        tp = (mn.mc_txn)->mt_cursors + mn.mc_dbi;
        if (mn.mc_flags & 4U) {
          dummy.mc_flags = 1U;
          dummy.mc_xcursor = (MDB_xcursor *)(& mn);
          tracked = & dummy;
        } else {
          tracked = & mn;
        }
        tracked->mc_next = *tp;
        *tp = tracked;
        rc = mdb_update_key(& mn, & key);
        *tp = tracked->mc_next;
        break;
      }
      if (rc) {
        return (rc);
      }
    }
    if (((int )(csrc->mc_pg[csrc->mc_top])->mp_flags & 1) == 1) {
      ix = csrc->mc_ki[csrc->mc_top];
      nullkey.mv_size = (size_t )0;
      csrc->mc_ki[csrc->mc_top] = (indx_t )0;
      rc = mdb_update_key(csrc, & nullkey);
      csrc->mc_ki[csrc->mc_top] = ix;
      if (! (rc == 0)) {
        mdb_assert_fail((csrc->mc_txn)->mt_env, "rc == MDB_SUCCESS", "mdb_node_move",
                        "mdb.c", 9056);
      }
    }
  }
  if ((int )cdst->mc_ki[cdst->mc_top] == 0) {
    if ((int )cdst->mc_ki[(int )cdst->mc_top - 1] != 0) {
      if (((int )(csrc->mc_pg[csrc->mc_top])->mp_flags & 32) == 32) {
        key.mv_data = (void *)(((char *)cdst->mc_pg[cdst->mc_top] + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) + 0UL);
      } else {
        srcnode = (MDB_node *)(((char *)cdst->mc_pg[cdst->mc_top] + (int )(cdst->mc_pg[cdst->mc_top])->mp_ptrs[0]) + 0U);
        key.mv_size = (size_t )srcnode->mn_ksize;
        key.mv_data = (void *)(srcnode->mn_data);
      }
      mdb_cursor_copy((MDB_cursor const   *)cdst, & mn);
      mn.mc_snum = (unsigned short )((int )mn.mc_snum - 1);
      mn.mc_top = (unsigned short )((int )mn.mc_top - 1);
      while (1) {
        tp___0 = (mn.mc_txn)->mt_cursors + mn.mc_dbi;
        if (mn.mc_flags & 4U) {
          dummy___0.mc_flags = 1U;
          dummy___0.mc_xcursor = (MDB_xcursor *)(& mn);
          tracked___0 = & dummy___0;
        } else {
          tracked___0 = & mn;
        }
        tracked___0->mc_next = *tp___0;
        *tp___0 = tracked___0;
        rc = mdb_update_key(& mn, & key);
        *tp___0 = tracked___0->mc_next;
        break;
      }
      if (rc) {
        return (rc);
      }
    }
    if (((int )(cdst->mc_pg[cdst->mc_top])->mp_flags & 1) == 1) {
      ix___0 = cdst->mc_ki[cdst->mc_top];
      nullkey___0.mv_size = (size_t )0;
      cdst->mc_ki[cdst->mc_top] = (indx_t )0;
      rc = mdb_update_key(cdst, & nullkey___0);
      cdst->mc_ki[cdst->mc_top] = ix___0;
      if (! (rc == 0)) {
        mdb_assert_fail((cdst->mc_txn)->mt_env, "rc == MDB_SUCCESS", "mdb_node_move",
                        "mdb.c", 9087);
      }
    }
  }
  return (0);
}
}
static int mdb_page_merge(MDB_cursor *csrc , MDB_cursor *cdst ) 
{ 
  MDB_page *psrc ;
  MDB_page *pdst ;
  MDB_node *srcnode ;
  MDB_val key ;
  MDB_val data ;
  unsigned int nkeys ;
  int rc ;
  indx_t i ;
  indx_t j ;
  MDB_cursor mn ;
  MDB_node *s2 ;
  MDB_cursor *m2 ;
  MDB_cursor *m3 ;
  MDB_dbi dbi ;
  unsigned int top ;
  MDB_page *xr_pg ;
  MDB_node *xr_node ;
  unsigned int snum ;
  uint16_t depth ;

  {
  psrc = csrc->mc_pg[csrc->mc_top];
  pdst = cdst->mc_pg[cdst->mc_top];
  if (! ((int )csrc->mc_snum > 1)) {
    mdb_assert_fail((csrc->mc_txn)->mt_env, "csrc->mc_snum > 1", "mdb_page_merge",
                    "mdb.c", 9117);
  }
  if (! ((int )cdst->mc_snum > 1)) {
    mdb_assert_fail((csrc->mc_txn)->mt_env, "cdst->mc_snum > 1", "mdb_page_merge",
                    "mdb.c", 9118);
  }
  rc = mdb_page_touch(cdst);
  if (rc) {
    return (rc);
  }
  pdst = cdst->mc_pg[cdst->mc_top];
  nkeys = ((unsigned int )pdst->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1;
  j = (indx_t )nkeys;
  if (((int )psrc->mp_flags & 32) == 32) {
    key.mv_size = (size_t )(csrc->mc_db)->md_pad;
    key.mv_data = (void *)((char *)psrc + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs)));
    i = (indx_t )0;
    while ((unsigned int )i < ((unsigned int )psrc->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) {
      rc = mdb_node_add(cdst, j, & key, (MDB_val *)((void *)0), (pgno_t )0, 0U);
      if (rc != 0) {
        return (rc);
      }
      key.mv_data = (void *)((char *)key.mv_data + key.mv_size);
      i = (indx_t )((int )i + 1);
      j = (indx_t )((int )j + 1);
    }
  } else {
    i = (indx_t )0;
    while ((unsigned int )i < ((unsigned int )psrc->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) {
      srcnode = (MDB_node *)(((char *)psrc + (int )psrc->mp_ptrs[i]) + 0U);
      if ((int )i == 0) {
        if (((int )psrc->mp_flags & 1) == 1) {
          mdb_cursor_copy((MDB_cursor const   *)csrc, & mn);
          mn.mc_xcursor = (struct MDB_xcursor *)((void *)0);
          rc = mdb_page_search_lowest(& mn);
          if (rc) {
            return (rc);
          }
          if (((int )(mn.mc_pg[mn.mc_top])->mp_flags & 32) == 32) {
            key.mv_size = (size_t )(mn.mc_db)->md_pad;
            key.mv_data = (void *)(((char *)mn.mc_pg[mn.mc_top] + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) + 0UL);
          } else {
            s2 = (MDB_node *)(((char *)mn.mc_pg[mn.mc_top] + (int )(mn.mc_pg[mn.mc_top])->mp_ptrs[0]) + 0U);
            key.mv_size = (size_t )s2->mn_ksize;
            key.mv_data = (void *)(s2->mn_data);
          }
        } else {
          key.mv_size = (size_t )srcnode->mn_ksize;
          key.mv_data = (void *)(srcnode->mn_data);
        }
      } else {
        key.mv_size = (size_t )srcnode->mn_ksize;
        key.mv_data = (void *)(srcnode->mn_data);
      }
      data.mv_size = (size_t )((unsigned int )srcnode->mn_lo | ((unsigned int )srcnode->mn_hi << 16));
      data.mv_data = (void *)(srcnode->mn_data + (int )srcnode->mn_ksize);
      rc = mdb_node_add(cdst, j, & key, & data, ((unsigned long )srcnode->mn_lo | ((pgno_t )srcnode->mn_hi << 16)) | ((pgno_t )srcnode->mn_flags << 32),
                        (unsigned int )srcnode->mn_flags);
      if (rc != 0) {
        return (rc);
      }
      i = (indx_t )((int )i + 1);
      j = (indx_t )((int )j + 1);
    }
  }
  csrc->mc_top = (unsigned short )((int )csrc->mc_top - 1);
  mdb_node_del(csrc, 0);
  if ((int )csrc->mc_ki[csrc->mc_top] == 0) {
    key.mv_size = (size_t )0;
    rc = mdb_update_key(csrc, & key);
    if (rc) {
      csrc->mc_top = (unsigned short )((int )csrc->mc_top + 1);
      return (rc);
    }
  }
  csrc->mc_top = (unsigned short )((int )csrc->mc_top + 1);
  psrc = csrc->mc_pg[csrc->mc_top];
  rc = mdb_page_loose(csrc, psrc);
  if (rc) {
    return (rc);
  }
  if (((int )psrc->mp_flags & 2) == 2) {
    ((csrc->mc_db)->md_leaf_pages) --;
  } else {
    ((csrc->mc_db)->md_branch_pages) --;
  }
  dbi = csrc->mc_dbi;
  top = (unsigned int )csrc->mc_top;
  m2 = *((csrc->mc_txn)->mt_cursors + dbi);
  while (m2) {
    if (csrc->mc_flags & 4U) {
      m3 = & (m2->mc_xcursor)->mx_cursor;
    } else {
      m3 = m2;
    }
    if ((unsigned long )m3 == (unsigned long )csrc) {
      goto __Cont;
    }
    if ((int )m3->mc_snum < (int )csrc->mc_snum) {
      goto __Cont;
    }
    if ((unsigned long )m3->mc_pg[top] == (unsigned long )psrc) {
      m3->mc_pg[top] = pdst;
      m3->mc_ki[top] = (indx_t )((unsigned int )m3->mc_ki[top] + nkeys);
      m3->mc_ki[top - 1U] = cdst->mc_ki[top - 1U];
    } else
    if ((unsigned long )m3->mc_pg[top - 1U] == (unsigned long )csrc->mc_pg[top - 1U]) {
      if ((int )m3->mc_ki[top - 1U] > (int )csrc->mc_ki[top - 1U]) {
        m3->mc_ki[top - 1U] = (indx_t )((int )m3->mc_ki[top - 1U] - 1);
      }
    }
    if (((int )psrc->mp_flags & 2) == 2) {
      while (1) {
        xr_pg = m3->mc_pg[top];
        if (m3->mc_xcursor) {
          if ((m3->mc_xcursor)->mx_cursor.mc_flags & 1U) {
            if ((unsigned int )m3->mc_ki[top] >= ((unsigned int )xr_pg->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) {
              break;
            }
          } else {
            break;
          }
        } else {
          break;
        }
        xr_node = (MDB_node *)(((char *)xr_pg + (int )xr_pg->mp_ptrs[m3->mc_ki[top]]) + 0U);
        if (((int )xr_node->mn_flags & 6) == 4) {
          (m3->mc_xcursor)->mx_cursor.mc_pg[0] = (MDB_page *)((void *)(xr_node->mn_data + (int )xr_node->mn_ksize));
        }
        break;
      }
    }
    __Cont: /* CIL Label */ 
    m2 = m2->mc_next;
  }
  snum = (unsigned int )cdst->mc_snum;
  depth = (cdst->mc_db)->md_depth;
  mdb_cursor_pop(cdst);
  rc = mdb_rebalance(cdst);
  if ((int )depth != (int )(cdst->mc_db)->md_depth) {
    snum += (unsigned int )((int )(cdst->mc_db)->md_depth - (int )depth);
  }
  cdst->mc_snum = (unsigned short )snum;
  cdst->mc_top = (unsigned short )(snum - 1U);
  return (rc);
}
}
static void mdb_cursor_copy(MDB_cursor const   *csrc , MDB_cursor *cdst ) 
{ 
  unsigned int i ;

  {
  cdst->mc_txn = (MDB_txn *)csrc->mc_txn;
  cdst->mc_dbi = (MDB_dbi )csrc->mc_dbi;
  cdst->mc_db = (MDB_db *)csrc->mc_db;
  cdst->mc_dbx = (MDB_dbx *)csrc->mc_dbx;
  cdst->mc_snum = (unsigned short )csrc->mc_snum;
  cdst->mc_top = (unsigned short )csrc->mc_top;
  cdst->mc_flags = (unsigned int )csrc->mc_flags;
  i = 0U;
  while (i < (unsigned int )csrc->mc_snum) {
    cdst->mc_pg[i] = csrc->mc_pg[i];
    cdst->mc_ki[i] = csrc->mc_ki[i];
    i ++;
  }
  return;
}
}
static int mdb_rebalance(MDB_cursor *mc ) 
{ 
  MDB_node *node ;
  int rc ;
  int fromleft ;
  unsigned int ptop ;
  unsigned int minkeys ;
  unsigned int thresh ;
  MDB_cursor mn ;
  indx_t oldki ;
  MDB_page *mp ;
  MDB_cursor *m2 ;
  MDB_cursor *m3 ;
  MDB_dbi dbi ;
  int i ;
  MDB_cursor *m2___0 ;
  MDB_cursor *m3___0 ;
  MDB_dbi dbi___0 ;
  MDB_cursor dummy ;
  MDB_cursor *tracked ;
  MDB_cursor **tp ;

  {
  if (((int )(mc->mc_pg[mc->mc_top])->mp_flags & 1) == 1) {
    minkeys = 2U;
    thresh = 1U;
  } else {
    minkeys = 1U;
    thresh = 250U;
  }
  if ((1000L * (long )((((mc->mc_txn)->mt_env)->me_psize - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) - (unsigned int )((indx_t )((int )(mc->mc_pg[mc->mc_top])->mp_pb.pb.pb_upper - (int )(mc->mc_pg[mc->mc_top])->mp_pb.pb.pb_lower)))) / (long )(((mc->mc_txn)->mt_env)->me_psize - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >= (long )thresh) {
    if (((unsigned int )(mc->mc_pg[mc->mc_top])->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1 >= minkeys) {
      return (0);
    }
  }
  if ((int )mc->mc_snum < 2) {
    mp = mc->mc_pg[0];
    if (((int )mp->mp_flags & 64) == 64) {
      return (0);
    }
    if (((unsigned int )mp->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1 == 0U) {
      (mc->mc_db)->md_root = ~ ((pgno_t )0);
      (mc->mc_db)->md_depth = (uint16_t )0;
      (mc->mc_db)->md_leaf_pages = (pgno_t )0;
      rc = mdb_midl_append(& (mc->mc_txn)->mt_free_pgs, mp->mp_p.p_pgno);
      if (rc) {
        return (rc);
      }
      mc->mc_snum = (unsigned short)0;
      mc->mc_top = (unsigned short)0;
      mc->mc_flags &= 4294967294U;
      dbi = mc->mc_dbi;
      m2 = *((mc->mc_txn)->mt_cursors + dbi);
      while (m2) {
        if (mc->mc_flags & 4U) {
          m3 = & (m2->mc_xcursor)->mx_cursor;
        } else {
          m3 = m2;
        }
        if (! (m3->mc_flags & 1U)) {
          goto __Cont;
        } else
        if ((int )m3->mc_snum < (int )mc->mc_snum) {
          goto __Cont;
        }
        if ((unsigned long )m3->mc_pg[0] == (unsigned long )mp) {
          m3->mc_snum = (unsigned short)0;
          m3->mc_top = (unsigned short)0;
          m3->mc_flags &= 4294967294U;
        }
        __Cont: /* CIL Label */ 
        m2 = m2->mc_next;
      }
    } else
    if (((int )mp->mp_flags & 1) == 1) {
      if (((unsigned int )mp->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1 == 1U) {
        rc = mdb_midl_append(& (mc->mc_txn)->mt_free_pgs, mp->mp_p.p_pgno);
        if (rc) {
          return (rc);
        }
        (mc->mc_db)->md_root = ((unsigned long )((MDB_node *)(((char *)mp + (int )mp->mp_ptrs[0]) + 0U))->mn_lo | ((pgno_t )((MDB_node *)(((char *)mp + (int )mp->mp_ptrs[0]) + 0U))->mn_hi << 16)) | ((pgno_t )((MDB_node *)(((char *)mp + (int )mp->mp_ptrs[0]) + 0U))->mn_flags << 32);
        rc = mdb_page_get(mc, (mc->mc_db)->md_root, & mc->mc_pg[0], (int *)((void *)0));
        if (rc) {
          return (rc);
        }
        (mc->mc_db)->md_depth = (uint16_t )((int )(mc->mc_db)->md_depth - 1);
        ((mc->mc_db)->md_branch_pages) --;
        mc->mc_ki[0] = mc->mc_ki[1];
        i = 1;
        while (i < (int )(mc->mc_db)->md_depth) {
          mc->mc_pg[i] = mc->mc_pg[i + 1];
          mc->mc_ki[i] = mc->mc_ki[i + 1];
          i ++;
        }
        dbi___0 = mc->mc_dbi;
        m2___0 = *((mc->mc_txn)->mt_cursors + dbi___0);
        while (m2___0) {
          if (mc->mc_flags & 4U) {
            m3___0 = & (m2___0->mc_xcursor)->mx_cursor;
          } else {
            m3___0 = m2___0;
          }
          if ((unsigned long )m3___0 == (unsigned long )mc) {
            goto __Cont___0;
          }
          if (! (m3___0->mc_flags & 1U)) {
            goto __Cont___0;
          }
          if ((unsigned long )m3___0->mc_pg[0] == (unsigned long )mp) {
            i = 0;
            while (i < (int )(mc->mc_db)->md_depth) {
              m3___0->mc_pg[i] = m3___0->mc_pg[i + 1];
              m3___0->mc_ki[i] = m3___0->mc_ki[i + 1];
              i ++;
            }
            m3___0->mc_snum = (unsigned short )((int )m3___0->mc_snum - 1);
            m3___0->mc_top = (unsigned short )((int )m3___0->mc_top - 1);
          }
          __Cont___0: /* CIL Label */ 
          m2___0 = m2___0->mc_next;
        }
      }
    }
    return (0);
  }
  ptop = (unsigned int )((int )mc->mc_top - 1);
  if (! (((unsigned int )(mc->mc_pg[ptop])->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1 > 1U)) {
    mdb_assert_fail((mc->mc_txn)->mt_env, "NUMKEYS(mc->mc_pg[ptop]) > 1", "mdb_rebalance",
                    "mdb.c", 9382);
  }
  mdb_cursor_copy((MDB_cursor const   *)mc, & mn);
  mn.mc_xcursor = (struct MDB_xcursor *)((void *)0);
  oldki = mc->mc_ki[mc->mc_top];
  if ((int )mc->mc_ki[ptop] == 0) {
    mn.mc_ki[ptop] = (indx_t )((int )mn.mc_ki[ptop] + 1);
    node = (MDB_node *)(((char *)mc->mc_pg[ptop] + (int )(mc->mc_pg[ptop])->mp_ptrs[mn.mc_ki[ptop]]) + 0U);
    rc = mdb_page_get(mc, ((unsigned long )node->mn_lo | ((pgno_t )node->mn_hi << 16)) | ((pgno_t )node->mn_flags << 32),
                      & mn.mc_pg[mn.mc_top], (int *)((void *)0));
    if (rc) {
      return (rc);
    }
    mn.mc_ki[mn.mc_top] = (indx_t )0;
    mc->mc_ki[mc->mc_top] = (indx_t )(((unsigned int )(mc->mc_pg[mc->mc_top])->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1);
    fromleft = 0;
  } else {
    mn.mc_ki[ptop] = (indx_t )((int )mn.mc_ki[ptop] - 1);
    node = (MDB_node *)(((char *)mc->mc_pg[ptop] + (int )(mc->mc_pg[ptop])->mp_ptrs[mn.mc_ki[ptop]]) + 0U);
    rc = mdb_page_get(mc, ((unsigned long )node->mn_lo | ((pgno_t )node->mn_hi << 16)) | ((pgno_t )node->mn_flags << 32),
                      & mn.mc_pg[mn.mc_top], (int *)((void *)0));
    if (rc) {
      return (rc);
    }
    mn.mc_ki[mn.mc_top] = (indx_t )((((unsigned int )(mn.mc_pg[mn.mc_top])->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) - 1U);
    mc->mc_ki[mc->mc_top] = (indx_t )0;
    fromleft = 1;
  }
  if ((1000L * (long )((((mc->mc_txn)->mt_env)->me_psize - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) - (unsigned int )((indx_t )((int )(mn.mc_pg[mn.mc_top])->mp_pb.pb.pb_upper - (int )(mn.mc_pg[mn.mc_top])->mp_pb.pb.pb_lower)))) / (long )(((mc->mc_txn)->mt_env)->me_psize - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >= (long )thresh) {
    if (((unsigned int )(mn.mc_pg[mn.mc_top])->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1 > minkeys) {
      rc = mdb_node_move(& mn, mc, fromleft);
      if (fromleft) {
        oldki = (indx_t )((int )oldki + 1);
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (! fromleft) {
      rc = mdb_page_merge(& mn, mc);
    } else {
      oldki = (indx_t )((unsigned int )oldki + (((unsigned int )(mn.mc_pg[mn.mc_top])->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1));
      mn.mc_ki[mn.mc_top] = (indx_t )((int )mn.mc_ki[mn.mc_top] + ((int )mc->mc_ki[mn.mc_top] + 1));
      while (1) {
        tp = (mn.mc_txn)->mt_cursors + mn.mc_dbi;
        if (mn.mc_flags & 4U) {
          dummy.mc_flags = 1U;
          dummy.mc_xcursor = (MDB_xcursor *)(& mn);
          tracked = & dummy;
        } else {
          tracked = & mn;
        }
        tracked->mc_next = *tp;
        *tp = tracked;
        rc = mdb_page_merge(mc, & mn);
        *tp = tracked->mc_next;
        break;
      }
      mdb_cursor_copy((MDB_cursor const   *)(& mn), mc);
    }
    mc->mc_flags &= 4294967293U;
  }
  mc->mc_ki[mc->mc_top] = oldki;
  return (rc);
}
}
static int mdb_cursor_del0(MDB_cursor *mc ) 
{ 
  int rc ;
  MDB_page *mp ;
  indx_t ki ;
  unsigned int nkeys ;
  MDB_cursor *m2 ;
  MDB_cursor *m3 ;
  MDB_dbi dbi ;
  MDB_page *xr_pg ;
  MDB_node *xr_node ;
  MDB_node *node ;

  {
  dbi = mc->mc_dbi;
  ki = mc->mc_ki[mc->mc_top];
  mp = mc->mc_pg[mc->mc_top];
  mdb_node_del(mc, (int )(mc->mc_db)->md_pad);
  ((mc->mc_db)->md_entries) --;
  m2 = *((mc->mc_txn)->mt_cursors + dbi);
  while (m2) {
    if (mc->mc_flags & 4U) {
      m3 = & (m2->mc_xcursor)->mx_cursor;
    } else {
      m3 = m2;
    }
    if (! ((m2->mc_flags & m3->mc_flags) & 1U)) {
      goto __Cont;
    }
    if ((unsigned long )m3 == (unsigned long )mc) {
      goto __Cont;
    } else
    if ((int )m3->mc_snum < (int )mc->mc_snum) {
      goto __Cont;
    }
    if ((unsigned long )m3->mc_pg[mc->mc_top] == (unsigned long )mp) {
      if ((int )m3->mc_ki[mc->mc_top] == (int )ki) {
        m3->mc_flags |= 8U;
        if ((int )(mc->mc_db)->md_flags & 4) {
          (m3->mc_xcursor)->mx_cursor.mc_flags &= 4294967292U;
        }
        goto __Cont;
      } else
      if ((int )m3->mc_ki[mc->mc_top] > (int )ki) {
        m3->mc_ki[mc->mc_top] = (indx_t )((int )m3->mc_ki[mc->mc_top] - 1);
      }
      while (1) {
        xr_pg = mp;
        if (m3->mc_xcursor) {
          if ((m3->mc_xcursor)->mx_cursor.mc_flags & 1U) {
            if ((unsigned int )m3->mc_ki[mc->mc_top] >= ((unsigned int )xr_pg->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) {
              break;
            }
          } else {
            break;
          }
        } else {
          break;
        }
        xr_node = (MDB_node *)(((char *)xr_pg + (int )xr_pg->mp_ptrs[m3->mc_ki[mc->mc_top]]) + 0U);
        if (((int )xr_node->mn_flags & 6) == 4) {
          (m3->mc_xcursor)->mx_cursor.mc_pg[0] = (MDB_page *)((void *)(xr_node->mn_data + (int )xr_node->mn_ksize));
        }
        break;
      }
    }
    __Cont: /* CIL Label */ 
    m2 = m2->mc_next;
  }
  rc = mdb_rebalance(mc);
  if (rc) {
    goto fail;
  }
  if (! mc->mc_snum) {
    mc->mc_flags |= 2U;
    return (rc);
  }
  mp = mc->mc_pg[mc->mc_top];
  nkeys = ((unsigned int )mp->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1;
  m2 = *((mc->mc_txn)->mt_cursors + dbi);
  while (1) {
    if (! rc) {
      if (! m2) {
        break;
      }
    } else {
      break;
    }
    if (mc->mc_flags & 4U) {
      m3 = & (m2->mc_xcursor)->mx_cursor;
    } else {
      m3 = m2;
    }
    if (! ((m2->mc_flags & m3->mc_flags) & 1U)) {
      goto __Cont___0;
    }
    if ((int )m3->mc_snum < (int )mc->mc_snum) {
      goto __Cont___0;
    }
    if ((unsigned long )m3->mc_pg[mc->mc_top] == (unsigned long )mp) {
      if ((int )m3->mc_ki[mc->mc_top] >= (int )mc->mc_ki[mc->mc_top]) {
        if ((unsigned int )m3->mc_ki[mc->mc_top] >= nkeys) {
          rc = mdb_cursor_sibling(m3, 1);
          if (rc == -30798) {
            m3->mc_flags |= 2U;
            rc = 0;
            goto __Cont___0;
          }
          if (rc) {
            goto fail;
          }
        }
        if (m3->mc_xcursor) {
          if (! (m3->mc_flags & 2U)) {
            node = (MDB_node *)(((char *)m3->mc_pg[m3->mc_top] + (int )(m3->mc_pg[m3->mc_top])->mp_ptrs[m3->mc_ki[m3->mc_top]]) + 0U);
            if ((int )node->mn_flags & 4) {
              if ((m3->mc_xcursor)->mx_cursor.mc_flags & 1U) {
                if (! ((int )node->mn_flags & 2)) {
                  (m3->mc_xcursor)->mx_cursor.mc_pg[0] = (MDB_page *)((void *)(node->mn_data + (int )node->mn_ksize));
                }
              } else {
                mdb_xcursor_init1(m3, node);
                rc = mdb_cursor_first(& (m3->mc_xcursor)->mx_cursor, (MDB_val *)((void *)0),
                                      (MDB_val *)((void *)0));
                if (rc) {
                  goto fail;
                }
              }
            }
            (m3->mc_xcursor)->mx_cursor.mc_flags |= 8U;
          }
        }
      }
    }
    __Cont___0: /* CIL Label */ 
    m2 = m2->mc_next;
  }
  mc->mc_flags |= 8U;
  fail: 
  if (rc) {
    (mc->mc_txn)->mt_flags |= 2U;
  }
  return (rc);
}
}
int mdb_del(MDB_txn *txn , MDB_dbi dbi , MDB_val *key , MDB_val *data ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (! key) {
    return (22);
  } else
  if (txn) {
    if (dbi < txn->mt_numdbs) {
      if (! ((int )*(txn->mt_dbflags + dbi) & 16)) {
        return (22);
      }
    } else {
      return (22);
    }
  } else {
    return (22);
  }
  if (txn->mt_flags & 131091U) {
    if (txn->mt_flags & 131072U) {
      tmp = 13;
    } else {
      tmp = -30782;
    }
    return (tmp);
  }
  if (! (((int )(txn->mt_dbs + dbi)->md_flags & 4) == 4)) {
    data = (MDB_val *)((void *)0);
  }
  tmp___0 = mdb_del0(txn, dbi, key, data, 0U);
  return (tmp___0);
}
}
static int mdb_del0(MDB_txn *txn , MDB_dbi dbi , MDB_val *key , MDB_val *data , unsigned int flags ) 
{ 
  MDB_cursor mc ;
  MDB_xcursor mx ;
  MDB_cursor_op op ;
  MDB_val rdata ;
  MDB_val *xdata ;
  int rc ;
  int exact ;

  {
  exact = 0;
  mdb_cursor_init(& mc, txn, dbi, & mx);
  if (data) {
    op = (MDB_cursor_op )2;
    rdata = *data;
    xdata = & rdata;
  } else {
    op = (MDB_cursor_op )15;
    xdata = (MDB_val *)((void *)0);
    flags |= 32U;
  }
  rc = mdb_cursor_set(& mc, key, xdata, op, & exact);
  if (rc == 0) {
    mc.mc_next = *(txn->mt_cursors + dbi);
    *(txn->mt_cursors + dbi) = & mc;
    rc = mdb_cursor_del(& mc, flags);
    *(txn->mt_cursors + dbi) = mc.mc_next;
  }
  return (rc);
}
}
static int mdb_page_split(MDB_cursor *mc , MDB_val *newkey , MDB_val *newdata , pgno_t newpgno ,
                          unsigned int nflags ) 
{ 
  unsigned int flags ;
  int rc ;
  int new_root ;
  int did_split ;
  indx_t newindx ;
  pgno_t pgno ;
  int i ;
  int j ;
  int split_indx ;
  int nkeys ;
  int pmax ;
  MDB_env *env ;
  MDB_node *node ;
  MDB_val sepkey ;
  MDB_val rkey ;
  MDB_val xdata ;
  MDB_val *rdata ;
  MDB_page *copy ;
  MDB_page *mp ;
  MDB_page *rp ;
  MDB_page *pp ;
  int ptop ;
  MDB_cursor mn ;
  uint16_t tmp ;
  char *split ;
  char *ins ;
  int x ;
  unsigned int lsize ;
  unsigned int rsize ;
  unsigned int ksize ;
  int psize ;
  int nsize ;
  int k ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int snum ;
  MDB_cursor dummy ;
  MDB_cursor *tracked ;
  MDB_cursor **tp ;
  size_t tmp___4 ;
  MDB_cursor *m2 ;
  MDB_cursor *m3 ;
  MDB_dbi dbi ;
  int k___0 ;
  MDB_page *xr_pg ;
  MDB_node *xr_node ;

  {
  rc = 0;
  new_root = 0;
  did_split = 0;
  pgno = (pgno_t )0;
  env = (mc->mc_txn)->mt_env;
  rdata = & xdata;
  copy = (MDB_page *)((void *)0);
  mp = mc->mc_pg[mc->mc_top];
  newindx = mc->mc_ki[mc->mc_top];
  nkeys = (int )(((unsigned int )mp->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1);
  rc = mdb_page_new(mc, (uint32_t )mp->mp_flags, 1, & rp);
  if (rc) {
    return (rc);
  }
  rp->mp_pad = mp->mp_pad;
  if ((int )mc->mc_top < 1) {
    rc = mdb_page_new(mc, (uint32_t )1, 1, & pp);
    if (rc) {
      goto done;
    }
    i = (int )mc->mc_snum;
    while (i > 0) {
      mc->mc_pg[i] = mc->mc_pg[i - 1];
      mc->mc_ki[i] = mc->mc_ki[i - 1];
      i --;
    }
    mc->mc_pg[0] = pp;
    mc->mc_ki[0] = (indx_t )0;
    (mc->mc_db)->md_root = pp->mp_p.p_pgno;
    tmp = (mc->mc_db)->md_depth;
    (mc->mc_db)->md_depth = (uint16_t )((int )(mc->mc_db)->md_depth + 1);
    new_root = (int )tmp;
    rc = mdb_node_add(mc, (indx_t )0, (MDB_val *)((void *)0), (MDB_val *)((void *)0),
                      mp->mp_p.p_pgno, 0U);
    if (rc != 0) {
      mc->mc_pg[0] = mc->mc_pg[1];
      mc->mc_ki[0] = mc->mc_ki[1];
      (mc->mc_db)->md_root = mp->mp_p.p_pgno;
      (mc->mc_db)->md_depth = (uint16_t )((int )(mc->mc_db)->md_depth - 1);
      goto done;
    }
    mc->mc_snum = (unsigned short )((int )mc->mc_snum + 1);
    mc->mc_top = (unsigned short )((int )mc->mc_top + 1);
    ptop = 0;
  } else {
    ptop = (int )mc->mc_top - 1;
  }
  mdb_cursor_copy((MDB_cursor const   *)mc, & mn);
  mn.mc_xcursor = (struct MDB_xcursor *)((void *)0);
  mn.mc_pg[mn.mc_top] = rp;
  mn.mc_ki[ptop] = (indx_t )((int )mc->mc_ki[ptop] + 1);
  if (nflags & 131072U) {
    mn.mc_ki[mn.mc_top] = (indx_t )0;
    sepkey = *newkey;
    split_indx = (int )newindx;
    nkeys = 0;
  } else {
    split_indx = (nkeys + 1) / 2;
    if (((int )rp->mp_flags & 32) == 32) {
      x = (int )mc->mc_ki[mc->mc_top] - split_indx;
      ksize = (mc->mc_db)->md_pad;
      split = ((char *)mp + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) + (unsigned int )split_indx * ksize;
      rsize = (unsigned int )(nkeys - split_indx) * ksize;
      lsize = (unsigned int )((unsigned long )(nkeys - split_indx) * sizeof(indx_t ));
      mp->mp_pb.pb.pb_lower = (indx_t )((unsigned int )mp->mp_pb.pb.pb_lower - lsize);
      rp->mp_pb.pb.pb_lower = (indx_t )((unsigned int )rp->mp_pb.pb.pb_lower + lsize);
      mp->mp_pb.pb.pb_upper = (indx_t )((unsigned int )mp->mp_pb.pb.pb_upper + (rsize - lsize));
      rp->mp_pb.pb.pb_upper = (indx_t )((unsigned int )rp->mp_pb.pb.pb_upper - (rsize - lsize));
      sepkey.mv_size = (size_t )ksize;
      if ((int )newindx == split_indx) {
        sepkey.mv_data = newkey->mv_data;
      } else {
        sepkey.mv_data = (void *)split;
      }
      if (x < 0) {
        ins = ((char *)mp + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) + (unsigned int )mc->mc_ki[mc->mc_top] * ksize;
        memcpy((void * __restrict  )(rp->mp_ptrs), (void const   * __restrict  )split,
               (size_t )rsize);
        sepkey.mv_data = (void *)(rp->mp_ptrs);
        memmove((void *)(ins + ksize), (void const   *)ins, (size_t )((unsigned int )(split_indx - (int )mc->mc_ki[mc->mc_top]) * ksize));
        memcpy((void * __restrict  )ins, (void const   * __restrict  )newkey->mv_data,
               (size_t )ksize);
        mp->mp_pb.pb.pb_lower = (indx_t )((unsigned long )mp->mp_pb.pb.pb_lower + sizeof(indx_t ));
        mp->mp_pb.pb.pb_upper = (indx_t )((unsigned long )mp->mp_pb.pb.pb_upper - ((unsigned long )ksize - sizeof(indx_t )));
      } else {
        if (x) {
          memcpy((void * __restrict  )(rp->mp_ptrs), (void const   * __restrict  )split,
                 (size_t )((unsigned int )x * ksize));
        }
        ins = ((char *)rp + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) + (unsigned int )x * ksize;
        memcpy((void * __restrict  )ins, (void const   * __restrict  )newkey->mv_data,
               (size_t )ksize);
        memcpy((void * __restrict  )(ins + ksize), (void const   * __restrict  )(split + (unsigned int )x * ksize),
               (size_t )(rsize - (unsigned int )x * ksize));
        rp->mp_pb.pb.pb_lower = (indx_t )((unsigned long )rp->mp_pb.pb.pb_lower + sizeof(indx_t ));
        rp->mp_pb.pb.pb_upper = (indx_t )((unsigned long )rp->mp_pb.pb.pb_upper - ((unsigned long )ksize - sizeof(indx_t )));
        mc->mc_ki[mc->mc_top] = (indx_t )x;
      }
    } else {
      pmax = (int )(env->me_psize - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs)));
      if (((int )mp->mp_flags & 2) == 2) {
        tmp___0 = mdb_leaf_size(env, newkey, newdata);
        nsize = (int )tmp___0;
      } else {
        tmp___1 = mdb_branch_size(env, newkey);
        nsize = (int )tmp___1;
      }
      nsize = (int )(((unsigned int )nsize + 1U) & 4294967294U);
      copy = mdb_page_malloc(mc->mc_txn, 1U);
      if ((unsigned long )copy == (unsigned long )((void *)0)) {
        rc = 12;
        goto done;
      }
      copy->mp_p.p_pgno = mp->mp_p.p_pgno;
      copy->mp_flags = mp->mp_flags;
      copy->mp_pb.pb.pb_lower = (indx_t )((unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs)));
      copy->mp_pb.pb.pb_upper = (indx_t )env->me_psize;
      i = 0;
      j = 0;
      while (i < nkeys) {
        if (i == (int )newindx) {
          tmp___2 = j;
          j ++;
          copy->mp_ptrs[tmp___2] = (indx_t )0;
        }
        tmp___3 = j;
        j ++;
        copy->mp_ptrs[tmp___3] = mp->mp_ptrs[i];
        i ++;
      }
      if (nkeys < 32) {
        goto _L___0;
      } else
      if (nsize > pmax / 16) {
        goto _L___0;
      } else
      if ((int )newindx >= nkeys) {
        _L___0: /* CIL Label */ 
        psize = 0;
        if ((int )newindx <= split_indx) {
          goto _L;
        } else
        if ((int )newindx >= nkeys) {
          _L: /* CIL Label */ 
          i = 0;
          j = 1;
          if ((int )newindx >= nkeys) {
            k = nkeys;
          } else {
            k = (split_indx + 1) + (((int )mp->mp_flags & 2) == 2);
          }
        } else {
          i = nkeys;
          j = -1;
          k = split_indx - 1;
        }
        while (i != k) {
          if (i == (int )newindx) {
            psize += nsize;
            node = (MDB_node *)((void *)0);
          } else {
            node = (MDB_node *)(((char *)mp + (int )copy->mp_ptrs[i]) + 0U);
            psize = (int )((unsigned long )psize + (((unsigned long )(& ((MDB_node *)0)->mn_data) + (unsigned long )node->mn_ksize) + sizeof(indx_t )));
            if (((int )mp->mp_flags & 2) == 2) {
              if (((int )node->mn_flags & 1) == 1) {
                psize = (int )((unsigned long )psize + sizeof(pgno_t ));
              } else {
                psize = (int )((unsigned int )psize + ((unsigned int )node->mn_lo | ((unsigned int )node->mn_hi << 16)));
              }
            }
            psize = (int )(((unsigned int )psize + 1U) & 4294967294U);
          }
          if (psize > pmax) {
            split_indx = i + (j < 0);
            break;
          } else
          if (i == k - j) {
            split_indx = i + (j < 0);
            break;
          }
          i += j;
        }
      }
      if (split_indx == (int )newindx) {
        sepkey.mv_size = newkey->mv_size;
        sepkey.mv_data = newkey->mv_data;
      } else {
        node = (MDB_node *)(((char *)mp + (int )copy->mp_ptrs[split_indx]) + 0U);
        sepkey.mv_size = (size_t )node->mn_ksize;
        sepkey.mv_data = (void *)(node->mn_data);
      }
    }
  }
  tmp___4 = mdb_branch_size(env, & sepkey);
  if ((size_t )((indx_t )((int )(mn.mc_pg[ptop])->mp_pb.pb.pb_upper - (int )(mn.mc_pg[ptop])->mp_pb.pb.pb_lower)) < tmp___4) {
    snum = (int )mc->mc_snum;
    mn.mc_snum = (unsigned short )((int )mn.mc_snum - 1);
    mn.mc_top = (unsigned short )((int )mn.mc_top - 1);
    did_split = 1;
    while (1) {
      tp = (mn.mc_txn)->mt_cursors + mn.mc_dbi;
      if (mn.mc_flags & 4U) {
        dummy.mc_flags = 1U;
        dummy.mc_xcursor = (MDB_xcursor *)(& mn);
        tracked = & dummy;
      } else {
        tracked = & mn;
      }
      tracked->mc_next = *tp;
      *tp = tracked;
      rc = mdb_page_split(& mn, & sepkey, (MDB_val *)((void *)0), rp->mp_p.p_pgno,
                          0U);
      *tp = tracked->mc_next;
      break;
    }
    if (rc) {
      goto done;
    }
    if ((int )mc->mc_snum > snum) {
      ptop ++;
    }
    if ((unsigned long )mn.mc_pg[ptop] != (unsigned long )mc->mc_pg[ptop]) {
      if ((unsigned int )mc->mc_ki[ptop] >= ((unsigned int )(mc->mc_pg[ptop])->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) {
        i = 0;
        while (i < ptop) {
          mc->mc_pg[i] = mn.mc_pg[i];
          mc->mc_ki[i] = mn.mc_ki[i];
          i ++;
        }
        mc->mc_pg[ptop] = mn.mc_pg[ptop];
        if (mn.mc_ki[ptop]) {
          mc->mc_ki[ptop] = (indx_t )((int )mn.mc_ki[ptop] - 1);
        } else {
          mc->mc_ki[ptop] = mn.mc_ki[ptop];
          rc = mdb_cursor_sibling(mc, 0);
        }
      }
    }
  } else {
    mn.mc_top = (unsigned short )((int )mn.mc_top - 1);
    rc = mdb_node_add(& mn, mn.mc_ki[ptop], & sepkey, (MDB_val *)((void *)0), rp->mp_p.p_pgno,
                      0U);
    mn.mc_top = (unsigned short )((int )mn.mc_top + 1);
  }
  if (rc != 0) {
    if (rc == -30798) {
      rc = -30779;
    }
    goto done;
  }
  if (nflags & 131072U) {
    mc->mc_pg[mc->mc_top] = rp;
    mc->mc_ki[mc->mc_top] = (indx_t )0;
    rc = mdb_node_add(mc, (indx_t )0, newkey, newdata, newpgno, nflags);
    if (rc) {
      goto done;
    }
    i = 0;
    while (i < (int )mc->mc_top) {
      mc->mc_ki[i] = mn.mc_ki[i];
      i ++;
    }
  } else
  if (! (((int )mp->mp_flags & 32) == 32)) {
    mc->mc_pg[mc->mc_top] = rp;
    i = split_indx;
    j = 0;
    while (1) {
      if (i == (int )newindx) {
        rkey.mv_data = newkey->mv_data;
        rkey.mv_size = newkey->mv_size;
        if (((int )mp->mp_flags & 2) == 2) {
          rdata = newdata;
        } else {
          pgno = newpgno;
        }
        flags = nflags;
        mc->mc_ki[mc->mc_top] = (indx_t )j;
      } else {
        node = (MDB_node *)(((char *)mp + (int )copy->mp_ptrs[i]) + 0U);
        rkey.mv_data = (void *)(node->mn_data);
        rkey.mv_size = (size_t )node->mn_ksize;
        if (((int )mp->mp_flags & 2) == 2) {
          xdata.mv_data = (void *)(node->mn_data + (int )node->mn_ksize);
          xdata.mv_size = (size_t )((unsigned int )node->mn_lo | ((unsigned int )node->mn_hi << 16));
          rdata = & xdata;
        } else {
          pgno = ((unsigned long )node->mn_lo | ((pgno_t )node->mn_hi << 16)) | ((pgno_t )node->mn_flags << 32);
        }
        flags = (unsigned int )node->mn_flags;
      }
      if (! (((int )mp->mp_flags & 2) == 2)) {
        if (j == 0) {
          rkey.mv_size = (size_t )0;
        }
      }
      rc = mdb_node_add(mc, (indx_t )j, & rkey, rdata, pgno, flags);
      if (rc) {
        goto done;
      }
      if (i == nkeys) {
        i = 0;
        j = 0;
        mc->mc_pg[mc->mc_top] = copy;
      } else {
        i ++;
        j ++;
      }
      if (! (i != split_indx)) {
        break;
      }
    }
    nkeys = (int )(((unsigned int )copy->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1);
    i = 0;
    while (i < nkeys) {
      mp->mp_ptrs[i] = copy->mp_ptrs[i];
      i ++;
    }
    mp->mp_pb.pb.pb_lower = copy->mp_pb.pb.pb_lower;
    mp->mp_pb.pb.pb_upper = copy->mp_pb.pb.pb_upper;
    memcpy((void * __restrict  )((MDB_node *)(((char *)mp + (int )mp->mp_ptrs[nkeys - 1]) + 0U)),
           (void const   * __restrict  )((MDB_node *)(((char *)copy + (int )copy->mp_ptrs[nkeys - 1]) + 0U)),
           (size_t )(env->me_psize - (unsigned int )copy->mp_pb.pb.pb_upper));
    if ((int )newindx < split_indx) {
      mc->mc_pg[mc->mc_top] = mp;
    } else {
      mc->mc_pg[mc->mc_top] = rp;
      mc->mc_ki[ptop] = (indx_t )((int )mc->mc_ki[ptop] + 1);
      if ((unsigned long )mn.mc_pg[ptop] != (unsigned long )mc->mc_pg[ptop]) {
        if ((unsigned int )mc->mc_ki[ptop] >= ((unsigned int )(mc->mc_pg[ptop])->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) {
          i = 0;
          while (i <= ptop) {
            mc->mc_pg[i] = mn.mc_pg[i];
            mc->mc_ki[i] = mn.mc_ki[i];
            i ++;
          }
        }
      }
    }
    if (nflags & 65536U) {
      node = (MDB_node *)(((char *)mc->mc_pg[mc->mc_top] + (int )(mc->mc_pg[mc->mc_top])->mp_ptrs[mc->mc_ki[mc->mc_top]]) + 0U);
      if (! ((int )node->mn_flags & 1)) {
        newdata->mv_data = (void *)(node->mn_data + (int )node->mn_ksize);
      }
    }
  } else
  if ((int )newindx >= split_indx) {
    mc->mc_pg[mc->mc_top] = rp;
    mc->mc_ki[ptop] = (indx_t )((int )mc->mc_ki[ptop] + 1);
    if ((unsigned long )mn.mc_pg[ptop] != (unsigned long )mc->mc_pg[ptop]) {
      if ((unsigned int )mc->mc_ki[ptop] >= ((unsigned int )(mc->mc_pg[ptop])->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) {
        i = 0;
        while (i <= ptop) {
          mc->mc_pg[i] = mn.mc_pg[i];
          mc->mc_ki[i] = mn.mc_ki[i];
          i ++;
        }
      }
    }
  }
  dbi = mc->mc_dbi;
  nkeys = (int )(((unsigned int )mp->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1);
  m2 = *((mc->mc_txn)->mt_cursors + dbi);
  while (m2) {
    if (mc->mc_flags & 4U) {
      m3 = & (m2->mc_xcursor)->mx_cursor;
    } else {
      m3 = m2;
    }
    if ((unsigned long )m3 == (unsigned long )mc) {
      goto __Cont;
    }
    if (! ((m2->mc_flags & m3->mc_flags) & 1U)) {
      goto __Cont;
    }
    if (new_root) {
      if ((unsigned long )m3->mc_pg[0] != (unsigned long )mp) {
        goto __Cont;
      }
      k___0 = new_root;
      while (k___0 >= 0) {
        m3->mc_ki[k___0 + 1] = m3->mc_ki[k___0];
        m3->mc_pg[k___0 + 1] = m3->mc_pg[k___0];
        k___0 --;
      }
      if ((int )m3->mc_ki[0] >= nkeys) {
        m3->mc_ki[0] = (indx_t )1;
      } else {
        m3->mc_ki[0] = (indx_t )0;
      }
      m3->mc_pg[0] = mc->mc_pg[0];
      m3->mc_snum = (unsigned short )((int )m3->mc_snum + 1);
      m3->mc_top = (unsigned short )((int )m3->mc_top + 1);
    }
    if ((int )m3->mc_top >= (int )mc->mc_top) {
      if ((unsigned long )m3->mc_pg[mc->mc_top] == (unsigned long )mp) {
        if ((int )m3->mc_ki[mc->mc_top] >= (int )newindx) {
          if (! (nflags & 262144U)) {
            m3->mc_ki[mc->mc_top] = (indx_t )((int )m3->mc_ki[mc->mc_top] + 1);
          }
        }
        if ((int )m3->mc_ki[mc->mc_top] >= nkeys) {
          m3->mc_pg[mc->mc_top] = rp;
          m3->mc_ki[mc->mc_top] = (indx_t )((int )m3->mc_ki[mc->mc_top] - nkeys);
          i = 0;
          while (i < (int )mc->mc_top) {
            m3->mc_ki[i] = mn.mc_ki[i];
            m3->mc_pg[i] = mn.mc_pg[i];
            i ++;
          }
        }
      } else {
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
    if (! did_split) {
      if ((int )m3->mc_top >= ptop) {
        if ((unsigned long )m3->mc_pg[ptop] == (unsigned long )mc->mc_pg[ptop]) {
          if ((int )m3->mc_ki[ptop] >= (int )mc->mc_ki[ptop]) {
            m3->mc_ki[ptop] = (indx_t )((int )m3->mc_ki[ptop] + 1);
          }
        }
      }
    }
    if (((int )mp->mp_flags & 2) == 2) {
      while (1) {
        xr_pg = m3->mc_pg[mc->mc_top];
        if (m3->mc_xcursor) {
          if ((m3->mc_xcursor)->mx_cursor.mc_flags & 1U) {
            if ((unsigned int )m3->mc_ki[mc->mc_top] >= ((unsigned int )xr_pg->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1) {
              break;
            }
          } else {
            break;
          }
        } else {
          break;
        }
        xr_node = (MDB_node *)(((char *)xr_pg + (int )xr_pg->mp_ptrs[m3->mc_ki[mc->mc_top]]) + 0U);
        if (((int )xr_node->mn_flags & 6) == 4) {
          (m3->mc_xcursor)->mx_cursor.mc_pg[0] = (MDB_page *)((void *)(xr_node->mn_data + (int )xr_node->mn_ksize));
        }
        break;
      }
    }
    __Cont: /* CIL Label */ 
    m2 = m2->mc_next;
  }
  done: 
  if (copy) {
    mdb_page_free(env, copy);
  }
  if (rc) {
    (mc->mc_txn)->mt_flags |= 2U;
  }
  return (rc);
}
}
int mdb_put(MDB_txn *txn , MDB_dbi dbi , MDB_val *key , MDB_val *data , unsigned int flags ) 
{ 
  MDB_cursor mc ;
  MDB_xcursor mx ;
  int rc ;
  int tmp ;

  {
  if (! key) {
    return (22);
  } else
  if (! data) {
    return (22);
  } else
  if (txn) {
    if (dbi < txn->mt_numdbs) {
      if (! ((int )*(txn->mt_dbflags + dbi) & 16)) {
        return (22);
      }
    } else {
      return (22);
    }
  } else {
    return (22);
  }
  if (flags & 4294508495U) {
    return (22);
  }
  if (txn->mt_flags & 131091U) {
    if (txn->mt_flags & 131072U) {
      tmp = 13;
    } else {
      tmp = -30782;
    }
    return (tmp);
  }
  mdb_cursor_init(& mc, txn, dbi, & mx);
  mc.mc_next = *(txn->mt_cursors + dbi);
  *(txn->mt_cursors + dbi) = & mc;
  rc = mdb_cursor_put(& mc, key, data, flags);
  *(txn->mt_cursors + dbi) = mc.mc_next;
  return (rc);
}
}
static void *mdb_env_copythr(void *arg )  __attribute__((__section__("text_env"))) ;
static void *mdb_env_copythr(void *arg ) 
{ 
  mdb_copy *my ;
  char *ptr ;
  int toggle ;
  int wsize ;
  int rc ;
  int len ;
  sigset_t set ;
  ssize_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  my = (mdb_copy *)arg;
  toggle = 0;
  sigemptyset(& set);
  sigaddset(& set, 13);
  rc = pthread_sigmask(0, (__sigset_t const   * __restrict  )(& set), (__sigset_t * __restrict  )((void *)0));
  if (rc != 0) {
    my->mc_error = (int volatile   )rc;
  }
  pthread_mutex_lock(& my->mc_mutex);
  while (1) {
    while (! my->mc_new) {
      pthread_cond_wait((pthread_cond_t * __restrict  )(& my->mc_cond), (pthread_mutex_t * __restrict  )(& my->mc_mutex));
    }
    if (my->mc_new == 16) {
      break;
    }
    wsize = my->mc_wlen[toggle];
    ptr = my->mc_wbuf[toggle];
    again: 
    rc = 0;
    while (1) {
      if (wsize > 0) {
        if (! (! my->mc_error)) {
          break;
        }
      } else {
        break;
      }
      tmp = write(my->mc_fd, (void const   *)ptr, (size_t )wsize);
      len = (int )tmp;
      rc = len >= 0;
      if (! rc) {
        tmp___0 = __errno_location();
        rc = *tmp___0;
        if (rc == 32) {
          sigwait((sigset_t const   * __restrict  )(& set), (int * __restrict  )(& tmp___1));
        }
        break;
      } else
      if (len > 0) {
        rc = 0;
        ptr += len;
        wsize -= len;
        continue;
      } else {
        rc = 5;
        break;
      }
    }
    if (rc) {
      my->mc_error = (int volatile   )rc;
    }
    if (my->mc_olen[toggle]) {
      wsize = my->mc_olen[toggle];
      ptr = my->mc_over[toggle];
      my->mc_olen[toggle] = 0;
      goto again;
    }
    my->mc_wlen[toggle] = 0;
    toggle ^= 1;
    (my->mc_new) --;
    pthread_cond_signal(& my->mc_cond);
  }
  pthread_mutex_unlock(& my->mc_mutex);
  return ((void *)0);
}
}
static int mdb_env_cthr_toggle(mdb_copy *my , int adjust )  __attribute__((__section__("text_env"))) ;
static int mdb_env_cthr_toggle(mdb_copy *my , int adjust ) 
{ 


  {
  pthread_mutex_lock(& my->mc_mutex);
  my->mc_new += adjust;
  pthread_cond_signal(& my->mc_cond);
  while (my->mc_new & 2) {
    pthread_cond_wait((pthread_cond_t * __restrict  )(& my->mc_cond), (pthread_mutex_t * __restrict  )(& my->mc_mutex));
  }
  pthread_mutex_unlock(& my->mc_mutex);
  my->mc_toggle ^= adjust & 1;
  my->mc_wlen[my->mc_toggle] = 0;
  return ((int )my->mc_error);
}
}
static int mdb_env_cwalk(mdb_copy *my , pgno_t *pg , int flags )  __attribute__((__section__("text_env"))) ;
static int mdb_env_cwalk(mdb_copy *my , pgno_t *pg , int flags ) 
{ 
  MDB_cursor mc ;
  MDB_node *ni ;
  MDB_page *mo ;
  MDB_page *mp ;
  MDB_page *leaf ;
  char *buf ;
  char *ptr ;
  int rc ;
  int toggle ;
  unsigned int i ;
  void *tmp ;
  unsigned int n ;
  MDB_page *omp ;
  pgno_t pg___0 ;
  MDB_db db ;
  pgno_t pg___1 ;
  pgno_t tmp___0 ;

  {
  mc.mc_next = (MDB_cursor *)0;
  mc.mc_backup = (MDB_cursor *)0;
  mc.mc_xcursor = (struct MDB_xcursor *)0;
  mc.mc_txn = (MDB_txn *)0;
  mc.mc_dbi = 0U;
  mc.mc_db = (MDB_db *)0;
  mc.mc_dbx = (MDB_dbx *)0;
  mc.mc_dbflag = (unsigned char *)0;
  mc.mc_snum = (unsigned short)0;
  mc.mc_top = (unsigned short)0;
  mc.mc_flags = 0U;
  mc.mc_pg[0] = (MDB_page *)0;
  mc.mc_pg[1] = (MDB_page *)0;
  mc.mc_pg[2] = (MDB_page *)0;
  mc.mc_pg[3] = (MDB_page *)0;
  mc.mc_pg[4] = (MDB_page *)0;
  mc.mc_pg[5] = (MDB_page *)0;
  mc.mc_pg[6] = (MDB_page *)0;
  mc.mc_pg[7] = (MDB_page *)0;
  mc.mc_pg[8] = (MDB_page *)0;
  mc.mc_pg[9] = (MDB_page *)0;
  mc.mc_pg[10] = (MDB_page *)0;
  mc.mc_pg[11] = (MDB_page *)0;
  mc.mc_pg[12] = (MDB_page *)0;
  mc.mc_pg[13] = (MDB_page *)0;
  mc.mc_pg[14] = (MDB_page *)0;
  mc.mc_pg[15] = (MDB_page *)0;
  mc.mc_pg[16] = (MDB_page *)0;
  mc.mc_pg[17] = (MDB_page *)0;
  mc.mc_pg[18] = (MDB_page *)0;
  mc.mc_pg[19] = (MDB_page *)0;
  mc.mc_pg[20] = (MDB_page *)0;
  mc.mc_pg[21] = (MDB_page *)0;
  mc.mc_pg[22] = (MDB_page *)0;
  mc.mc_pg[23] = (MDB_page *)0;
  mc.mc_pg[24] = (MDB_page *)0;
  mc.mc_pg[25] = (MDB_page *)0;
  mc.mc_pg[26] = (MDB_page *)0;
  mc.mc_pg[27] = (MDB_page *)0;
  mc.mc_pg[28] = (MDB_page *)0;
  mc.mc_pg[29] = (MDB_page *)0;
  mc.mc_pg[30] = (MDB_page *)0;
  mc.mc_pg[31] = (MDB_page *)0;
  mc.mc_ki[0] = (unsigned short)0;
  mc.mc_ki[1] = (unsigned short)0;
  mc.mc_ki[2] = (unsigned short)0;
  mc.mc_ki[3] = (unsigned short)0;
  mc.mc_ki[4] = (unsigned short)0;
  mc.mc_ki[5] = (unsigned short)0;
  mc.mc_ki[6] = (unsigned short)0;
  mc.mc_ki[7] = (unsigned short)0;
  mc.mc_ki[8] = (unsigned short)0;
  mc.mc_ki[9] = (unsigned short)0;
  mc.mc_ki[10] = (unsigned short)0;
  mc.mc_ki[11] = (unsigned short)0;
  mc.mc_ki[12] = (unsigned short)0;
  mc.mc_ki[13] = (unsigned short)0;
  mc.mc_ki[14] = (unsigned short)0;
  mc.mc_ki[15] = (unsigned short)0;
  mc.mc_ki[16] = (unsigned short)0;
  mc.mc_ki[17] = (unsigned short)0;
  mc.mc_ki[18] = (unsigned short)0;
  mc.mc_ki[19] = (unsigned short)0;
  mc.mc_ki[20] = (unsigned short)0;
  mc.mc_ki[21] = (unsigned short)0;
  mc.mc_ki[22] = (unsigned short)0;
  mc.mc_ki[23] = (unsigned short)0;
  mc.mc_ki[24] = (unsigned short)0;
  mc.mc_ki[25] = (unsigned short)0;
  mc.mc_ki[26] = (unsigned short)0;
  mc.mc_ki[27] = (unsigned short)0;
  mc.mc_ki[28] = (unsigned short)0;
  mc.mc_ki[29] = (unsigned short)0;
  mc.mc_ki[30] = (unsigned short)0;
  mc.mc_ki[31] = (unsigned short)0;
  if (*pg == 18446744073709551615) {
    return (0);
  }
  mc.mc_snum = (unsigned short)1;
  mc.mc_txn = my->mc_txn;
  mc.mc_flags = (my->mc_txn)->mt_flags & 655360U;
  rc = mdb_page_get(& mc, *pg, & mc.mc_pg[0], (int *)((void *)0));
  if (rc) {
    return (rc);
  }
  rc = mdb_page_search_root(& mc, (MDB_val *)((void *)0), 4);
  if (rc) {
    return (rc);
  }
  tmp = malloc((size_t )((my->mc_env)->me_psize * (unsigned int )mc.mc_snum));
  ptr = (char *)tmp;
  buf = ptr;
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    return (12);
  }
  i = 0U;
  while (i < (unsigned int )mc.mc_top) {
    mdb_page_copy((MDB_page *)ptr, mc.mc_pg[i], (my->mc_env)->me_psize);
    mc.mc_pg[i] = (MDB_page *)ptr;
    ptr += (my->mc_env)->me_psize;
    i ++;
  }
  leaf = (MDB_page *)ptr;
  toggle = my->mc_toggle;
  while ((int )mc.mc_snum > 0) {
    mp = mc.mc_pg[mc.mc_top];
    n = ((unsigned int )mp->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1;
    if (((int )mp->mp_flags & 2) == 2) {
      if (! (((int )mp->mp_flags & 32) == 32)) {
        if (! (flags & 4)) {
          i = 0U;
          while (i < n) {
            ni = (MDB_node *)(((char *)mp + (int )mp->mp_ptrs[i]) + 0U);
            if ((int )ni->mn_flags & 1) {
              if ((unsigned long )mp != (unsigned long )leaf) {
                mc.mc_pg[mc.mc_top] = leaf;
                mdb_page_copy(leaf, mp, (my->mc_env)->me_psize);
                mp = leaf;
                ni = (MDB_node *)(((char *)mp + (int )mp->mp_ptrs[i]) + 0U);
              }
              memcpy((void * __restrict  )(& pg___0), (void const   * __restrict  )((void *)(ni->mn_data + (int )ni->mn_ksize)),
                     sizeof(pg___0));
              memcpy((void * __restrict  )((void *)(ni->mn_data + (int )ni->mn_ksize)),
                     (void const   * __restrict  )(& my->mc_next_pgno), sizeof(pgno_t ));
              rc = mdb_page_get(& mc, pg___0, & omp, (int *)((void *)0));
              if (rc) {
                goto done;
              }
              if (my->mc_wlen[toggle] >= 1048576) {
                rc = mdb_env_cthr_toggle(my, 1);
                if (rc) {
                  goto done;
                }
                toggle = my->mc_toggle;
              }
              mo = (MDB_page *)(my->mc_wbuf[toggle] + my->mc_wlen[toggle]);
              memcpy((void * __restrict  )mo, (void const   * __restrict  )omp, (size_t )(my->mc_env)->me_psize);
              mo->mp_p.p_pgno = my->mc_next_pgno;
              my->mc_next_pgno += (pgno_t )omp->mp_pb.pb_pages;
              my->mc_wlen[toggle] = (int )((unsigned int )my->mc_wlen[toggle] + (my->mc_env)->me_psize);
              if (omp->mp_pb.pb_pages > 1U) {
                my->mc_olen[toggle] = (int )((my->mc_env)->me_psize * (omp->mp_pb.pb_pages - 1U));
                my->mc_over[toggle] = (char *)omp + (my->mc_env)->me_psize;
                rc = mdb_env_cthr_toggle(my, 1);
                if (rc) {
                  goto done;
                }
                toggle = my->mc_toggle;
              }
            } else
            if ((int )ni->mn_flags & 2) {
              if ((unsigned long )mp != (unsigned long )leaf) {
                mc.mc_pg[mc.mc_top] = leaf;
                mdb_page_copy(leaf, mp, (my->mc_env)->me_psize);
                mp = leaf;
                ni = (MDB_node *)(((char *)mp + (int )mp->mp_ptrs[i]) + 0U);
              }
              memcpy((void * __restrict  )(& db), (void const   * __restrict  )((void *)(ni->mn_data + (int )ni->mn_ksize)),
                     sizeof(db));
              my->mc_toggle = toggle;
              rc = mdb_env_cwalk(my, & db.md_root, (int )ni->mn_flags & 4);
              if (rc) {
                goto done;
              }
              toggle = my->mc_toggle;
              memcpy((void * __restrict  )((void *)(ni->mn_data + (int )ni->mn_ksize)),
                     (void const   * __restrict  )(& db), sizeof(db));
            }
            i ++;
          }
        }
      }
    } else {
      mc.mc_ki[mc.mc_top] = (indx_t )((int )mc.mc_ki[mc.mc_top] + 1);
      if ((unsigned int )mc.mc_ki[mc.mc_top] < n) {
        again: 
        ni = (MDB_node *)(((char *)mp + (int )mp->mp_ptrs[mc.mc_ki[mc.mc_top]]) + 0U);
        pg___1 = ((unsigned long )ni->mn_lo | ((pgno_t )ni->mn_hi << 16)) | ((pgno_t )ni->mn_flags << 32);
        rc = mdb_page_get(& mc, pg___1, & mp, (int *)((void *)0));
        if (rc) {
          goto done;
        }
        mc.mc_top = (unsigned short )((int )mc.mc_top + 1);
        mc.mc_snum = (unsigned short )((int )mc.mc_snum + 1);
        mc.mc_ki[mc.mc_top] = (indx_t )0;
        if (((int )mp->mp_flags & 1) == 1) {
          mdb_page_copy(mc.mc_pg[mc.mc_top], mp, (my->mc_env)->me_psize);
          goto again;
        } else {
          mc.mc_pg[mc.mc_top] = mp;
        }
        continue;
      }
    }
    if (my->mc_wlen[toggle] >= 1048576) {
      rc = mdb_env_cthr_toggle(my, 1);
      if (rc) {
        goto done;
      }
      toggle = my->mc_toggle;
    }
    mo = (MDB_page *)(my->mc_wbuf[toggle] + my->mc_wlen[toggle]);
    mdb_page_copy(mo, mp, (my->mc_env)->me_psize);
    tmp___0 = my->mc_next_pgno;
    (my->mc_next_pgno) ++;
    mo->mp_p.p_pgno = tmp___0;
    my->mc_wlen[toggle] = (int )((unsigned int )my->mc_wlen[toggle] + (my->mc_env)->me_psize);
    if (mc.mc_top) {
      ni = (MDB_node *)(((char *)mc.mc_pg[(int )mc.mc_top - 1] + (int )(mc.mc_pg[(int )mc.mc_top - 1])->mp_ptrs[mc.mc_ki[(int )mc.mc_top - 1]]) + 0U);
      while (1) {
        ni->mn_lo = (unsigned short )(mo->mp_p.p_pgno & 65535UL);
        ni->mn_hi = (unsigned short )(mo->mp_p.p_pgno >> 16);
        ni->mn_flags = (unsigned short )(mo->mp_p.p_pgno >> 32);
        break;
      }
      mdb_cursor_pop(& mc);
    } else {
      *pg = mo->mp_p.p_pgno;
      break;
    }
  }
  done: 
  free((void *)buf);
  return (rc);
}
}
static int mdb_env_copyfd1(MDB_env *env , int fd )  __attribute__((__section__("text_env"))) ;
static int mdb_env_copyfd1(MDB_env *env , int fd ) 
{ 
  MDB_meta *mm ;
  MDB_page *mp ;
  mdb_copy my ;
  MDB_txn *txn ;
  pthread_t thr ;
  pgno_t root ;
  pgno_t new_root ;
  int rc ;
  void *p ;
  MDB_ID freecount ;
  MDB_cursor mc ;
  MDB_val key ;
  MDB_val data ;
  int tmp ;

  {
  my.mc_env = (MDB_env *)0;
  my.mc_txn = (MDB_txn *)0;
  my.mc_mutex.__data.__lock = 0;
  my.mc_mutex.__data.__count = 0U;
  my.mc_mutex.__data.__owner = 0;
  my.mc_mutex.__data.__nusers = 0U;
  my.mc_mutex.__data.__kind = 0;
  my.mc_mutex.__data.__spins = (short)0;
  my.mc_mutex.__data.__elision = (short)0;
  my.mc_mutex.__data.__list.__prev = (struct __pthread_internal_list *)0;
  my.mc_mutex.__data.__list.__next = (struct __pthread_internal_list *)0;
  my.mc_cond.__data.__annonCompField1.__wseq = 0ULL;
  my.mc_cond.__data.__annonCompField2.__g1_start = 0ULL;
  my.mc_cond.__data.__g_refs[0] = 0U;
  my.mc_cond.__data.__g_refs[1] = 0U;
  my.mc_cond.__data.__g_size[0] = 0U;
  my.mc_cond.__data.__g_size[1] = 0U;
  my.mc_cond.__data.__g1_orig_size = 0U;
  my.mc_cond.__data.__wrefs = 0U;
  my.mc_cond.__data.__g_signals[0] = 0U;
  my.mc_cond.__data.__g_signals[1] = 0U;
  my.mc_wbuf[0] = (char *)0;
  my.mc_wbuf[1] = (char *)0;
  my.mc_over[0] = (char *)0;
  my.mc_over[1] = (char *)0;
  my.mc_wlen[0] = 0;
  my.mc_wlen[1] = 0;
  my.mc_olen[0] = 0;
  my.mc_olen[1] = 0;
  my.mc_next_pgno = 0UL;
  my.mc_fd = 0;
  my.mc_toggle = 0;
  my.mc_new = 0;
  my.mc_error = 0;
  txn = (MDB_txn *)((void *)0);
  rc = 0;
  rc = pthread_mutex_init(& my.mc_mutex, (pthread_mutexattr_t const   *)((void *)0));
  if (rc != 0) {
    return (rc);
  }
  rc = pthread_cond_init((pthread_cond_t * __restrict  )(& my.mc_cond), (pthread_condattr_t const   * __restrict  )((void *)0));
  if (rc != 0) {
    goto done2;
  }
  rc = posix_memalign(& p, (size_t )env->me_os_psize, (size_t )2097152);
  if (rc != 0) {
    goto done;
  }
  my.mc_wbuf[0] = (char *)p;
  memset((void *)my.mc_wbuf[0], 0, (size_t )2097152);
  my.mc_wbuf[1] = my.mc_wbuf[0] + 1048576;
  my.mc_next_pgno = (pgno_t )2;
  my.mc_env = env;
  my.mc_fd = fd;
  rc = pthread_create((pthread_t * __restrict  )(& thr), (pthread_attr_t const   * __restrict  )((void *)0),
                      & mdb_env_copythr, (void * __restrict  )(& my));
  if (rc) {
    goto done;
  }
  rc = mdb_txn_begin(env, (MDB_txn *)((void *)0), 131072U, & txn);
  if (rc) {
    goto finish;
  }
  mp = (MDB_page *)my.mc_wbuf[0];
  memset((void *)mp, 0, (size_t )(2U * env->me_psize));
  mp->mp_p.p_pgno = (pgno_t )0;
  mp->mp_flags = (uint16_t )8;
  mm = (MDB_meta *)((void *)((char *)mp + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))));
  mdb_env_init_meta0(env, mm);
  mm->mm_address = (env->me_metas[0])->mm_address;
  mp = (MDB_page *)(my.mc_wbuf[0] + env->me_psize);
  mp->mp_p.p_pgno = (pgno_t )1;
  mp->mp_flags = (uint16_t )8;
  *((MDB_meta *)((void *)((char *)mp + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))))) = *mm;
  mm = (MDB_meta *)((void *)((char *)mp + (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))));
  new_root = (txn->mt_dbs + 1)->md_root;
  root = new_root;
  if (root != 18446744073709551615) {
    freecount = (MDB_ID )0;
    mdb_cursor_init(& mc, txn, (MDB_dbi )0, (MDB_xcursor *)((void *)0));
    while (1) {
      rc = mdb_cursor_get(& mc, & key, & data, (MDB_cursor_op )8);
      if (! (rc == 0)) {
        break;
      }
      freecount += *((MDB_ID *)data.mv_data);
    }
    if (rc != -30798) {
      goto finish;
    }
    freecount += ((txn->mt_dbs + 0)->md_branch_pages + (txn->mt_dbs + 0)->md_leaf_pages) + (txn->mt_dbs + 0)->md_overflow_pages;
    new_root = (txn->mt_next_pgno - 1UL) - freecount;
    mm->mm_last_pg = new_root;
    mm->mm_dbs[1] = *(txn->mt_dbs + 1);
    mm->mm_dbs[1].md_root = new_root;
  } else {
    mm->mm_dbs[1].md_flags = (txn->mt_dbs + 1)->md_flags;
  }
  if (root != 18446744073709551615) {
    mm->mm_txnid = (txnid_t volatile   )1;
  } else
  if (mm->mm_dbs[1].md_flags) {
    mm->mm_txnid = (txnid_t volatile   )1;
  }
  my.mc_wlen[0] = (int )(env->me_psize * 2U);
  my.mc_txn = txn;
  rc = mdb_env_cwalk(& my, & root, 0);
  if (rc == 0) {
    if (root != new_root) {
      rc = -30784;
    }
  }
  finish: 
  if (rc) {
    my.mc_error = (int volatile   )rc;
  }
  mdb_env_cthr_toggle(& my, 17);
  rc = pthread_join(thr, (void **)((void *)0));
  mdb_txn_abort(txn);
  done: 
  free((void *)my.mc_wbuf[0]);
  pthread_cond_destroy(& my.mc_cond);
  done2: 
  pthread_mutex_destroy(& my.mc_mutex);
  if (rc) {
    tmp = rc;
  } else {
    tmp = (int )my.mc_error;
  }
  return (tmp);
}
}
static int mdb_env_copyfd0(MDB_env *env , int fd )  __attribute__((__section__("text_env"))) ;
static int mdb_env_copyfd0(MDB_env *env , int fd ) 
{ 
  MDB_txn *txn ;
  mdb_mutexref_t wmutex ;
  int rc ;
  mdb_size_t wsize ;
  mdb_size_t w3 ;
  char *ptr ;
  ssize_t len ;
  size_t w2 ;
  int *tmp ;
  mdb_size_t fsize ;
  int *tmp___0 ;

  {
  txn = (MDB_txn *)((void *)0);
  wmutex = (mdb_mutexref_t )((void *)0);
  rc = mdb_txn_begin(env, (MDB_txn *)((void *)0), 131072U, & txn);
  if (rc) {
    return (rc);
  }
  if (env->me_txns) {
    mdb_txn_end(txn, 4U);
    wmutex = (env->me_txns)->mt2.mt2_wmutex;
    rc = pthread_mutex_lock(wmutex);
    if (rc) {
      rc = mdb_mutex_failed(env, wmutex, rc);
      if (rc) {
        goto leave;
      }
    }
    rc = mdb_txn_renew0(txn);
    if (rc) {
      pthread_mutex_unlock(wmutex);
      goto leave;
    }
  }
  wsize = (mdb_size_t )(env->me_psize * 2U);
  ptr = env->me_map;
  w2 = wsize;
  while (w2 > 0UL) {
    len = write(fd, (void const   *)ptr, w2);
    rc = len >= 0L;
    if (! rc) {
      tmp = __errno_location();
      rc = *tmp;
      break;
    } else
    if (len > 0L) {
      rc = 0;
      ptr += len;
      w2 -= (size_t )len;
      continue;
    } else {
      rc = 5;
      break;
    }
  }
  if (wmutex) {
    pthread_mutex_unlock(wmutex);
  }
  if (rc) {
    goto leave;
  }
  w3 = txn->mt_next_pgno * (pgno_t )env->me_psize;
  fsize = (mdb_size_t )0;
  rc = mdb_fsize(env->me_fd, & fsize);
  if (rc) {
    goto leave;
  }
  if (w3 > fsize) {
    w3 = fsize;
  }
  wsize = w3 - wsize;
  while (wsize > 0UL) {
    if (wsize > (mdb_size_t )(1073741824U >> (sizeof(ssize_t ) == 4UL))) {
      w2 = (size_t )(1073741824U >> (sizeof(ssize_t ) == 4UL));
    } else {
      w2 = wsize;
    }
    len = write(fd, (void const   *)ptr, w2);
    rc = len >= 0L;
    if (! rc) {
      tmp___0 = __errno_location();
      rc = *tmp___0;
      break;
    } else
    if (len > 0L) {
      rc = 0;
      ptr += len;
      wsize -= (mdb_size_t )len;
      continue;
    } else {
      rc = 5;
      break;
    }
  }
  leave: 
  mdb_txn_abort(txn);
  return (rc);
}
}
int mdb_env_copyfd2(MDB_env *env , int fd , unsigned int flags )  __attribute__((__section__("text_env"))) ;
int mdb_env_copyfd2(MDB_env *env , int fd , unsigned int flags ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (flags & 1U) {
    tmp = mdb_env_copyfd1(env, fd);
    return (tmp);
  } else {
    tmp___0 = mdb_env_copyfd0(env, fd);
    return (tmp___0);
  }
}
}
int mdb_env_copyfd(MDB_env *env , int fd )  __attribute__((__section__("text_env"))) ;
int mdb_env_copyfd(MDB_env *env , int fd ) 
{ 
  int tmp ;

  {
  tmp = mdb_env_copyfd2(env, fd, 0U);
  return (tmp);
}
}
int mdb_env_copy2(MDB_env *env , char const   *path , unsigned int flags )  __attribute__((__section__("text_env"))) ;
int mdb_env_copy2(MDB_env *env , char const   *path , unsigned int flags ) 
{ 
  int rc ;
  MDB_name fname ;
  int newfd ;
  int *tmp ;
  int tmp___0 ;

  {
  newfd = -1;
  rc = mdb_fname_init(path, env->me_flags | 4194304U, & fname);
  if (rc == 0) {
    rc = mdb_fopen((MDB_env const   *)env, & fname, (enum mdb_fopen_type )524481,
                   (mdb_mode_t )438, & newfd);
    while (1) {
      if (fname.mn_alloced) {
        free((void *)fname.mn_val);
      }
      break;
    }
  }
  if (rc == 0) {
    rc = mdb_env_copyfd2(env, newfd, flags);
    tmp___0 = close(newfd);
    if (tmp___0 < 0) {
      if (rc == 0) {
        tmp = __errno_location();
        rc = *tmp;
      }
    }
  }
  return (rc);
}
}
int mdb_env_copy(MDB_env *env , char const   *path )  __attribute__((__section__("text_env"))) ;
int mdb_env_copy(MDB_env *env , char const   *path ) 
{ 
  int tmp ;

  {
  tmp = mdb_env_copy2(env, path, 0U);
  return (tmp);
}
}
int mdb_env_set_flags(MDB_env *env , unsigned int flag , int onoff )  __attribute__((__section__("text_env"))) ;
int mdb_env_set_flags(MDB_env *env , unsigned int flag , int onoff ) 
{ 


  {
  if (flag & 4276813823U) {
    return (22);
  }
  if (onoff) {
    env->me_flags |= flag;
  } else {
    env->me_flags &= ~ flag;
  }
  return (0);
}
}
int mdb_env_get_flags(MDB_env *env , unsigned int *arg )  __attribute__((__section__("text_env"))) ;
int mdb_env_get_flags(MDB_env *env , unsigned int *arg ) 
{ 


  {
  if (! env) {
    return (22);
  } else
  if (! arg) {
    return (22);
  }
  *arg = env->me_flags & 67059713U;
  return (0);
}
}
int mdb_env_set_userctx(MDB_env *env , void *ctx )  __attribute__((__section__("text_env"))) ;
int mdb_env_set_userctx(MDB_env *env , void *ctx ) 
{ 


  {
  if (! env) {
    return (22);
  }
  env->me_userctx = ctx;
  return (0);
}
}
void *mdb_env_get_userctx(MDB_env *env )  __attribute__((__section__("text_env"))) ;
void *mdb_env_get_userctx(MDB_env *env ) 
{ 
  void *tmp ;

  {
  if (env) {
    tmp = env->me_userctx;
  } else {
    tmp = (void *)0;
  }
  return (tmp);
}
}
int mdb_env_set_assert(MDB_env *env , MDB_assert_func *func )  __attribute__((__section__("text_env"))) ;
int mdb_env_set_assert(MDB_env *env , MDB_assert_func *func ) 
{ 


  {
  if (! env) {
    return (22);
  }
  env->me_assert_func = func;
  return (0);
}
}
int mdb_env_get_path(MDB_env *env , char const   **arg )  __attribute__((__section__("text_env"))) ;
int mdb_env_get_path(MDB_env *env , char const   **arg ) 
{ 


  {
  if (! env) {
    return (22);
  } else
  if (! arg) {
    return (22);
  }
  *arg = (char const   *)env->me_path;
  return (0);
}
}
int mdb_env_get_fd(MDB_env *env , mdb_filehandle_t *arg )  __attribute__((__section__("text_env"))) ;
int mdb_env_get_fd(MDB_env *env , mdb_filehandle_t *arg ) 
{ 


  {
  if (! env) {
    return (22);
  } else
  if (! arg) {
    return (22);
  }
  *arg = env->me_fd;
  return (0);
}
}
static int mdb_stat0(MDB_env *env , MDB_db *db , MDB_stat *arg )  __attribute__((__section__("text_env"))) ;
static int mdb_stat0(MDB_env *env , MDB_db *db , MDB_stat *arg ) 
{ 


  {
  arg->ms_psize = env->me_psize;
  arg->ms_depth = (unsigned int )db->md_depth;
  arg->ms_branch_pages = db->md_branch_pages;
  arg->ms_leaf_pages = db->md_leaf_pages;
  arg->ms_overflow_pages = db->md_overflow_pages;
  arg->ms_entries = db->md_entries;
  return (0);
}
}
int mdb_env_stat(MDB_env *env , MDB_stat *arg )  __attribute__((__section__("text_env"))) ;
int mdb_env_stat(MDB_env *env , MDB_stat *arg ) 
{ 
  MDB_meta *meta ;
  int tmp ;

  {
  if ((unsigned long )env == (unsigned long )((void *)0)) {
    return (22);
  } else
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
    return (22);
  }
  meta = mdb_env_pick_meta((MDB_env const   *)env);
  tmp = mdb_stat0(env, & meta->mm_dbs[1], arg);
  return (tmp);
}
}
int mdb_env_info(MDB_env *env , MDB_envinfo *arg )  __attribute__((__section__("text_env"))) ;
int mdb_env_info(MDB_env *env , MDB_envinfo *arg ) 
{ 
  MDB_meta *meta ;

  {
  if ((unsigned long )env == (unsigned long )((void *)0)) {
    return (22);
  } else
  if ((unsigned long )arg == (unsigned long )((void *)0)) {
    return (22);
  }
  meta = mdb_env_pick_meta((MDB_env const   *)env);
  arg->me_mapaddr = meta->mm_address;
  arg->me_last_pgno = meta->mm_last_pg;
  arg->me_last_txnid = (mdb_size_t )meta->mm_txnid;
  arg->me_mapsize = env->me_mapsize;
  arg->me_maxreaders = env->me_maxreaders;
  if (env->me_txns) {
    arg->me_numreaders = (unsigned int )(env->me_txns)->mt1.mtb.mtb_numreaders;
  } else {
    arg->me_numreaders = 0U;
  }
  return (0);
}
}
static void mdb_default_cmp(MDB_txn *txn , MDB_dbi dbi ) 
{ 
  uint16_t f ;
  int (*tmp)(MDB_val const   *a , MDB_val const   *b ) ;
  int (*tmp___0)(MDB_val const   *a , MDB_val const   *b ) ;
  int (*tmp___1)(MDB_val const   *a , MDB_val const   *b ) ;
  int (*tmp___2)(MDB_val const   *a , MDB_val const   *b ) ;

  {
  f = (txn->mt_dbs + dbi)->md_flags;
  if ((int )f & 2) {
    (txn->mt_dbxs + dbi)->md_cmp = & mdb_cmp_memnr;
  } else {
    if ((int )f & 8) {
      tmp = & mdb_cmp_cint;
    } else {
      tmp = & mdb_cmp_memn;
    }
    (txn->mt_dbxs + dbi)->md_cmp = tmp;
  }
  if (! ((int )f & 4)) {
    (txn->mt_dbxs + dbi)->md_dcmp = (MDB_cmp_func *)0;
  } else {
    if ((int )f & 32) {
      if ((int )f & 16) {
        tmp___0 = & mdb_cmp_int;
      } else {
        tmp___0 = & mdb_cmp_cint;
      }
      tmp___2 = tmp___0;
    } else {
      if ((int )f & 64) {
        tmp___1 = & mdb_cmp_memnr;
      } else {
        tmp___1 = & mdb_cmp_memn;
      }
      tmp___2 = tmp___1;
    }
    (txn->mt_dbxs + dbi)->md_dcmp = tmp___2;
  }
  return;
}
}
int mdb_dbi_open(MDB_txn *txn , char const   *name , unsigned int flags , MDB_dbi *dbi ) 
{ 
  MDB_val key ;
  MDB_val data ;
  MDB_dbi i ;
  MDB_cursor mc ;
  MDB_db dummy ;
  int rc ;
  int dbflag ;
  int exact ;
  unsigned int unused ;
  unsigned int seq ;
  char *namedup ;
  size_t len ;
  uint16_t f2 ;
  int tmp ;
  int tmp___0 ;
  MDB_node *node ;
  MDB_cursor dummy___0 ;
  MDB_cursor *tracked ;
  MDB_cursor **tp ;
  unsigned int slot ;
  unsigned int tmp___1 ;

  {
  unused = 0U;
  if (flags & 4294705025U) {
    return (22);
  }
  if (txn->mt_flags & 19U) {
    return (-30782);
  }
  if (! name) {
    *dbi = (MDB_dbi )1;
    if (flags & 32767U) {
      f2 = (uint16_t )(flags & 32767U);
      if (((int )(txn->mt_dbs + 1)->md_flags | (int )f2) != (int )(txn->mt_dbs + 1)->md_flags) {
        (txn->mt_dbs + 1)->md_flags = (uint16_t )((int )(txn->mt_dbs + 1)->md_flags | (int )f2);
        txn->mt_flags |= 4U;
      }
    }
    mdb_default_cmp(txn, (MDB_dbi )1);
    return (0);
  }
  if ((unsigned long )(txn->mt_dbxs + 1)->md_cmp == (unsigned long )((void *)0)) {
    mdb_default_cmp(txn, (MDB_dbi )1);
  }
  len = strlen(name);
  i = (MDB_dbi )2;
  while (i < txn->mt_numdbs) {
    if (! (txn->mt_dbxs + i)->md_name.mv_size) {
      if (! unused) {
        unused = i;
      }
      goto __Cont;
    }
    if (len == (txn->mt_dbxs + i)->md_name.mv_size) {
      tmp = strncmp(name, (char const   *)(txn->mt_dbxs + i)->md_name.mv_data, len);
      if (! tmp) {
        *dbi = i;
        return (0);
      }
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  if (! unused) {
    if (txn->mt_numdbs >= (txn->mt_env)->me_maxdbs) {
      return (-30791);
    }
  }
  if ((int )(txn->mt_dbs + 1)->md_flags & 12) {
    if (flags & 262144U) {
      tmp___0 = -30784;
    } else {
      tmp___0 = -30798;
    }
    return (tmp___0);
  }
  dbflag = 28;
  exact = 0;
  key.mv_size = len;
  key.mv_data = (void *)name;
  mdb_cursor_init(& mc, txn, (MDB_dbi )1, (MDB_xcursor *)((void *)0));
  rc = mdb_cursor_set(& mc, & key, & data, (MDB_cursor_op )15, & exact);
  if (rc == 0) {
    node = (MDB_node *)(((char *)mc.mc_pg[mc.mc_top] + (int )(mc.mc_pg[mc.mc_top])->mp_ptrs[mc.mc_ki[mc.mc_top]]) + 0U);
    if (((int )node->mn_flags & 6) != 2) {
      return (-30784);
    }
  } else {
    if (rc != -30798) {
      return (rc);
    } else
    if (! (flags & 262144U)) {
      return (rc);
    }
    if ((txn->mt_flags & 131072U) == 131072U) {
      return (13);
    }
  }
  namedup = strdup(name);
  if ((unsigned long )namedup == (unsigned long )((void *)0)) {
    return (12);
  }
  if (rc) {
    data.mv_size = sizeof(MDB_db );
    data.mv_data = (void *)(& dummy);
    memset((void *)(& dummy), 0, sizeof(dummy));
    dummy.md_root = ~ ((pgno_t )0);
    dummy.md_flags = (uint16_t )(flags & 32767U);
    while (1) {
      tp = (mc.mc_txn)->mt_cursors + mc.mc_dbi;
      if (mc.mc_flags & 4U) {
        dummy___0.mc_flags = 1U;
        dummy___0.mc_xcursor = (MDB_xcursor *)(& mc);
        tracked = & dummy___0;
      } else {
        tracked = & mc;
      }
      tracked->mc_next = *tp;
      *tp = tracked;
      rc = mdb_cursor_put(& mc, & key, & data, 2U);
      *tp = tracked->mc_next;
      break;
    }
    dbflag |= 1;
  }
  if (rc) {
    free((void *)namedup);
  } else {
    if (unused) {
      tmp___1 = unused;
    } else {
      tmp___1 = txn->mt_numdbs;
    }
    slot = tmp___1;
    (txn->mt_dbxs + slot)->md_name.mv_data = (void *)namedup;
    (txn->mt_dbxs + slot)->md_name.mv_size = len;
    (txn->mt_dbxs + slot)->md_rel = (MDB_rel_func *)((void *)0);
    *(txn->mt_dbflags + slot) = (unsigned char )dbflag;
    (*((txn->mt_env)->me_dbiseqs + slot)) ++;
    seq = *((txn->mt_env)->me_dbiseqs + slot);
    *(txn->mt_dbiseqs + slot) = seq;
    memcpy((void * __restrict  )(txn->mt_dbs + slot), (void const   * __restrict  )data.mv_data,
           sizeof(MDB_db ));
    *dbi = slot;
    mdb_default_cmp(txn, slot);
    if (! unused) {
      (txn->mt_numdbs) ++;
    }
  }
  return (rc);
}
}
int mdb_stat(MDB_txn *txn , MDB_dbi dbi , MDB_stat *arg )  __attribute__((__section__("text_env"))) ;
int mdb_stat(MDB_txn *txn , MDB_dbi dbi , MDB_stat *arg ) 
{ 
  MDB_cursor mc ;
  MDB_xcursor mx ;
  int tmp ;

  {
  if (! arg) {
    return (22);
  } else
  if (txn) {
    if (dbi < txn->mt_numdbs) {
      if (! ((int )*(txn->mt_dbflags + dbi) & 8)) {
        return (22);
      }
    } else {
      return (22);
    }
  } else {
    return (22);
  }
  if (txn->mt_flags & 19U) {
    return (-30782);
  }
  if ((int )*(txn->mt_dbflags + dbi) & 2) {
    mdb_cursor_init(& mc, txn, dbi, & mx);
  }
  tmp = mdb_stat0(txn->mt_env, txn->mt_dbs + dbi, arg);
  return (tmp);
}
}
void mdb_dbi_close(MDB_env *env , MDB_dbi dbi ) 
{ 
  char *ptr ;

  {
  if (dbi < 2U) {
    return;
  } else
  if (dbi >= env->me_maxdbs) {
    return;
  }
  ptr = (char *)(env->me_dbxs + dbi)->md_name.mv_data;
  if (ptr) {
    (env->me_dbxs + dbi)->md_name.mv_data = (void *)0;
    (env->me_dbxs + dbi)->md_name.mv_size = (size_t )0;
    *(env->me_dbflags + dbi) = (uint16_t )0;
    (*(env->me_dbiseqs + dbi)) ++;
    free((void *)ptr);
  }
  return;
}
}
int mdb_dbi_flags(MDB_txn *txn , MDB_dbi dbi , unsigned int *flags ) 
{ 


  {
  if (txn) {
    if (dbi < txn->mt_numdbs) {
      if (! ((int )*(txn->mt_dbflags + dbi) & 16)) {
        return (22);
      }
    } else {
      return (22);
    }
  } else {
    return (22);
  }
  *flags = (unsigned int )((int )(txn->mt_dbs + dbi)->md_flags & 32767);
  return (0);
}
}
static int mdb_drop0(MDB_cursor *mc , int subs ) 
{ 
  int rc ;
  MDB_txn *txn ;
  MDB_node *ni ;
  MDB_cursor mx ;
  unsigned int i ;
  MDB_page *mp ;
  unsigned int n ;
  MDB_page *omp ;
  pgno_t pg ;
  pgno_t pg___0 ;
  MDB_ID *xidl ;
  MDB_ID xlen ;

  {
  rc = mdb_page_search(mc, (MDB_val *)((void *)0), 4);
  if (rc == 0) {
    txn = mc->mc_txn;
    if (mc->mc_flags & 4U) {
      mdb_cursor_pop(mc);
    } else
    if (! subs) {
      if (! (mc->mc_db)->md_overflow_pages) {
        mdb_cursor_pop(mc);
      }
    }
    mdb_cursor_copy((MDB_cursor const   *)mc, & mx);
    while ((int )mc->mc_snum > 0) {
      mp = mc->mc_pg[mc->mc_top];
      n = ((unsigned int )mp->mp_pb.pb.pb_lower - (unsigned int )((unsigned long )(& ((MDB_page *)0)->mp_ptrs))) >> 1;
      if (((int )mp->mp_flags & 2) == 2) {
        i = 0U;
        while (i < n) {
          ni = (MDB_node *)(((char *)mp + (int )mp->mp_ptrs[i]) + 0U);
          if ((int )ni->mn_flags & 1) {
            memcpy((void * __restrict  )(& pg), (void const   * __restrict  )((void *)(ni->mn_data + (int )ni->mn_ksize)),
                   sizeof(pg));
            rc = mdb_page_get(mc, pg, & omp, (int *)((void *)0));
            if (rc != 0) {
              goto done;
            }
            if (! (((int )omp->mp_flags & 4) == 4)) {
              mdb_assert_fail((mc->mc_txn)->mt_env, "IS_OVERFLOW(omp)", "mdb_drop0",
                              "mdb.c", 10975);
            }
            rc = mdb_midl_append_range(& txn->mt_free_pgs, pg, omp->mp_pb.pb_pages);
            if (rc) {
              goto done;
            }
            (mc->mc_db)->md_overflow_pages -= (pgno_t )omp->mp_pb.pb_pages;
            if (! (mc->mc_db)->md_overflow_pages) {
              if (! subs) {
                break;
              }
            }
          } else
          if (subs) {
            if ((int )ni->mn_flags & 2) {
              mdb_xcursor_init1(mc, ni);
              rc = mdb_drop0(& (mc->mc_xcursor)->mx_cursor, 0);
              if (rc) {
                goto done;
              }
            }
          }
          i ++;
        }
        if (! subs) {
          if (! (mc->mc_db)->md_overflow_pages) {
            goto pop;
          }
        }
      } else {
        rc = mdb_midl_need(& txn->mt_free_pgs, n);
        if (rc != 0) {
          goto done;
        }
        i = 0U;
        while (i < n) {
          ni = (MDB_node *)(((char *)mp + (int )mp->mp_ptrs[i]) + 0U);
          pg___0 = ((unsigned long )ni->mn_lo | ((pgno_t )ni->mn_hi << 16)) | ((pgno_t )ni->mn_flags << 32);
          while (1) {
            xidl = txn->mt_free_pgs;
            (*(xidl + 0)) ++;
            xlen = *(xidl + 0);
            *(xidl + xlen) = pg___0;
            break;
          }
          i ++;
        }
      }
      if (! mc->mc_top) {
        break;
      }
      mc->mc_ki[mc->mc_top] = (indx_t )i;
      rc = mdb_cursor_sibling(mc, 1);
      if (rc) {
        if (rc != -30798) {
          goto done;
        }
        pop: 
        mdb_cursor_pop(mc);
        mc->mc_ki[0] = (indx_t )0;
        i = 1U;
        while (i < (unsigned int )mc->mc_snum) {
          mc->mc_ki[i] = (indx_t )0;
          mc->mc_pg[i] = mx.mc_pg[i];
          i ++;
        }
      }
    }
    rc = mdb_midl_append(& txn->mt_free_pgs, (mc->mc_db)->md_root);
    done: 
    if (rc) {
      txn->mt_flags |= 2U;
    }
  } else
  if (rc == -30798) {
    rc = 0;
  }
  mc->mc_flags &= 4294967294U;
  return (rc);
}
}
int mdb_drop(MDB_txn *txn , MDB_dbi dbi , int del ) 
{ 
  MDB_cursor *mc ;
  MDB_cursor *m2 ;
  int rc ;

  {
  if ((unsigned int )del > 1U) {
    return (22);
  } else
  if (txn) {
    if (dbi < txn->mt_numdbs) {
      if (! ((int )*(txn->mt_dbflags + dbi) & 16)) {
        return (22);
      }
    } else {
      return (22);
    }
  } else {
    return (22);
  }
  if ((txn->mt_flags & 131072U) == 131072U) {
    return (13);
  }
  if (*(txn->mt_dbiseqs + dbi) != *((txn->mt_env)->me_dbiseqs + dbi)) {
    return (-30780);
  }
  rc = mdb_cursor_open(txn, dbi, & mc);
  if (rc) {
    return (rc);
  }
  rc = mdb_drop0(mc, (int )(mc->mc_db)->md_flags & 4);
  m2 = *(txn->mt_cursors + dbi);
  while (m2) {
    m2->mc_flags &= 4294967292U;
    m2 = m2->mc_next;
  }
  if (rc) {
    goto leave;
  }
  if (del) {
    if (dbi >= 2U) {
      rc = mdb_del0(txn, (MDB_dbi )1, & (mc->mc_dbx)->md_name, (MDB_val *)((void *)0),
                    2U);
      if (! rc) {
        *(txn->mt_dbflags + dbi) = (unsigned char)2;
        mdb_dbi_close(txn->mt_env, dbi);
      } else {
        txn->mt_flags |= 2U;
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    *(txn->mt_dbflags + dbi) = (unsigned char )((int )*(txn->mt_dbflags + dbi) | 1);
    (txn->mt_dbs + dbi)->md_depth = (uint16_t )0;
    (txn->mt_dbs + dbi)->md_branch_pages = (pgno_t )0;
    (txn->mt_dbs + dbi)->md_leaf_pages = (pgno_t )0;
    (txn->mt_dbs + dbi)->md_overflow_pages = (pgno_t )0;
    (txn->mt_dbs + dbi)->md_entries = (mdb_size_t )0;
    (txn->mt_dbs + dbi)->md_root = ~ ((pgno_t )0);
    txn->mt_flags |= 4U;
  }
  leave: 
  mdb_cursor_close(mc);
  return (rc);
}
}
int mdb_set_compare(MDB_txn *txn , MDB_dbi dbi , MDB_cmp_func *cmp ) 
{ 


  {
  if (txn) {
    if (dbi < txn->mt_numdbs) {
      if (! ((int )*(txn->mt_dbflags + dbi) & 16)) {
        return (22);
      }
    } else {
      return (22);
    }
  } else {
    return (22);
  }
  (txn->mt_dbxs + dbi)->md_cmp = cmp;
  return (0);
}
}
int mdb_set_dupsort(MDB_txn *txn , MDB_dbi dbi , MDB_cmp_func *cmp ) 
{ 


  {
  if (txn) {
    if (dbi < txn->mt_numdbs) {
      if (! ((int )*(txn->mt_dbflags + dbi) & 16)) {
        return (22);
      }
    } else {
      return (22);
    }
  } else {
    return (22);
  }
  (txn->mt_dbxs + dbi)->md_dcmp = cmp;
  return (0);
}
}
int mdb_set_relfunc(MDB_txn *txn , MDB_dbi dbi , MDB_rel_func *rel ) 
{ 


  {
  if (txn) {
    if (dbi < txn->mt_numdbs) {
      if (! ((int )*(txn->mt_dbflags + dbi) & 16)) {
        return (22);
      }
    } else {
      return (22);
    }
  } else {
    return (22);
  }
  (txn->mt_dbxs + dbi)->md_rel = rel;
  return (0);
}
}
int mdb_set_relctx(MDB_txn *txn , MDB_dbi dbi , void *ctx ) 
{ 


  {
  if (txn) {
    if (dbi < txn->mt_numdbs) {
      if (! ((int )*(txn->mt_dbflags + dbi) & 16)) {
        return (22);
      }
    } else {
      return (22);
    }
  } else {
    return (22);
  }
  (txn->mt_dbxs + dbi)->md_relctx = ctx;
  return (0);
}
}
int mdb_env_get_maxkeysize(MDB_env *env )  __attribute__((__section__("text_env"))) ;
int mdb_env_get_maxkeysize(MDB_env *env ) 
{ 


  {
  return (511);
}
}
int mdb_reader_list(MDB_env *env , MDB_msg_func *func , void *ctx )  __attribute__((__section__("text_env"))) ;
int mdb_reader_list(MDB_env *env , MDB_msg_func *func , void *ctx ) 
{ 
  unsigned int i ;
  unsigned int rdrs ;
  MDB_reader *mr ;
  char buf[64] ;
  int rc ;
  int first ;
  int tmp ;
  txnid_t txnid ;
  char const   *tmp___0 ;

  {
  rc = 0;
  first = 1;
  if (! env) {
    return (-1);
  } else
  if (! func) {
    return (-1);
  }
  if (! env->me_txns) {
    tmp = (*func)("(no reader locks)\n", ctx);
    return (tmp);
  }
  rdrs = (unsigned int )(env->me_txns)->mt1.mtb.mtb_numreaders;
  mr = (env->me_txns)->mti_readers;
  i = 0U;
  while (i < rdrs) {
    if ((mr + i)->mru.mrx.mrb_pid) {
      txnid = (txnid_t )(mr + i)->mru.mrx.mrb_txnid;
      if (txnid == 0xffffffffffffffffUL) {
        tmp___0 = "%10d %zx -\n";
      } else {
        tmp___0 = "%10d %zx %zu\n";
      }
      sprintf((char * __restrict  )(buf), (char const   * __restrict  )tmp___0, (int )(mr + i)->mru.mrx.mrb_pid,
              (size_t )(mr + i)->mru.mrx.mrb_tid, txnid);
      if (first) {
        first = 0;
        rc = (*func)("    pid     thread     txnid\n", ctx);
        if (rc < 0) {
          break;
        }
      }
      rc = (*func)((char const   *)(buf), ctx);
      if (rc < 0) {
        break;
      }
    }
    i ++;
  }
  if (first) {
    rc = (*func)("(no active readers)\n", ctx);
  }
  return (rc);
}
}
static int mdb_pid_insert(pid_t *ids , pid_t pid )  __attribute__((__section__("text_env"))) ;
static int mdb_pid_insert(pid_t *ids , pid_t pid ) 
{ 
  unsigned int base ;
  unsigned int cursor ;
  int val ;
  unsigned int n ;
  unsigned int pivot ;

  {
  base = 0U;
  cursor = 1U;
  val = 0;
  n = (unsigned int )*(ids + 0);
  while (0U < n) {
    pivot = n >> 1;
    cursor = (base + pivot) + 1U;
    val = pid - *(ids + cursor);
    if (val < 0) {
      n = pivot;
    } else
    if (val > 0) {
      base = cursor;
      n -= pivot + 1U;
    } else {
      return (-1);
    }
  }
  if (val > 0) {
    cursor ++;
  }
  (*(ids + 0)) ++;
  n = (unsigned int )*(ids + 0);
  while (n > cursor) {
    *(ids + n) = *(ids + (n - 1U));
    n --;
  }
  *(ids + n) = pid;
  return (0);
}
}
int mdb_reader_check(MDB_env *env , int *dead )  __attribute__((__section__("text_env"))) ;
int mdb_reader_check(MDB_env *env , int *dead ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (! env) {
    return (22);
  }
  if (dead) {
    *dead = 0;
  }
  if (env->me_txns) {
    tmp = mdb_reader_check0(env, 0, dead);
    tmp___0 = tmp;
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
static int mdb_reader_check0(MDB_env *env , int rlocked , int *dead )  __attribute__((__section__("text_env"))) ;
static int mdb_reader_check0(MDB_env *env , int rlocked , int *dead ) 
{ 
  mdb_mutexref_t rmutex ;
  pthread_mutex_t *tmp ;
  unsigned int i ;
  unsigned int j ;
  unsigned int rdrs ;
  MDB_reader *mr ;
  pid_t *pids ;
  pid_t pid ;
  int rc ;
  int count ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if (rlocked) {
    tmp = (pthread_mutex_t *)((void *)0);
  } else {
    tmp = (env->me_txns)->mt1.mtb.mtb_rmutex;
  }
  rmutex = tmp;
  rc = 0;
  count = 0;
  rdrs = (unsigned int )(env->me_txns)->mt1.mtb.mtb_numreaders;
  tmp___0 = malloc((unsigned long )(rdrs + 1U) * sizeof(pid_t ));
  pids = (pid_t *)tmp___0;
  if (! pids) {
    return (12);
  }
  *(pids + 0) = 0;
  mr = (env->me_txns)->mti_readers;
  i = 0U;
  while (i < rdrs) {
    pid = (pid_t )(mr + i)->mru.mrx.mrb_pid;
    if (pid) {
      if (pid != env->me_pid) {
        tmp___3 = mdb_pid_insert(pids, pid);
        if (tmp___3 == 0) {
          tmp___2 = mdb_reader_pid(env, (enum Pidlock_op )5, pid);
          if (! tmp___2) {
            j = i;
            if (rmutex) {
              rc = pthread_mutex_lock(rmutex);
              if (rc != 0) {
                rc = mdb_mutex_failed(env, rmutex, rc);
                if (rc) {
                  break;
                }
                rdrs = 0U;
              } else {
                tmp___1 = mdb_reader_pid(env, (enum Pidlock_op )5, pid);
                if (tmp___1) {
                  j = rdrs;
                }
              }
            }
            while (j < rdrs) {
              if ((mr + j)->mru.mrx.mrb_pid == (pid_t volatile   )pid) {
                (mr + j)->mru.mrx.mrb_pid = (pid_t volatile   )0;
                count ++;
              }
              j ++;
            }
            if (rmutex) {
              pthread_mutex_unlock(rmutex);
            }
          }
        }
      }
    }
    i ++;
  }
  free((void *)pids);
  if (dead) {
    *dead = count;
  }
  return (rc);
}
}
static int mdb_mutex_failed(MDB_env *env , mdb_mutexref_t mutex , int rc )  __attribute__((__section__("text_env"))) ;
static int mdb_mutex_failed(MDB_env *env , mdb_mutexref_t mutex , int rc ) 
{ 
  int rlocked ;
  int rc2 ;
  MDB_meta *meta ;

  {
  if (rc == 130) {
    rc = 0;
    rlocked = (unsigned long )mutex == (unsigned long )((env->me_txns)->mt1.mtb.mtb_rmutex);
    if (! rlocked) {
      meta = mdb_env_pick_meta((MDB_env const   *)env);
      (env->me_txns)->mt1.mtb.mtb_txnid = meta->mm_txnid;
      if (env->me_txn) {
        env->me_flags |= 2147483648U;
        env->me_txn = (MDB_txn *)((void *)0);
        rc = -30795;
      }
    }
    rc2 = mdb_reader_check0(env, rlocked, (int *)((void *)0));
    if (rc2 == 0) {
      rc2 = pthread_mutex_consistent(mutex);
    }
    if (rc) {
      pthread_mutex_unlock(mutex);
    } else {
      rc = rc2;
      if (rc) {
        pthread_mutex_unlock(mutex);
      }
    }
  }
  return (rc);
}
}
#pragma merger("0","/tmp/cil-tnjOjgwE.i","-pthread")
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
unsigned int mdb_midl_search(MDB_IDL ids , MDB_ID id ) 
{ 
  unsigned int base ;
  unsigned int cursor ;
  int val ;
  unsigned int n ;
  unsigned int pivot ;

  {
  base = 0U;
  cursor = 1U;
  val = 0;
  n = (unsigned int )*(ids + 0);
  while (0U < n) {
    pivot = n >> 1;
    cursor = (base + pivot) + 1U;
    if (*(ids + cursor) < id) {
      val = -1;
    } else {
      val = *(ids + cursor) > id;
    }
    if (val < 0) {
      n = pivot;
    } else
    if (val > 0) {
      base = cursor;
      n -= pivot + 1U;
    } else {
      return (cursor);
    }
  }
  if (val > 0) {
    cursor ++;
  }
  return (cursor);
}
}
MDB_IDL mdb_midl_alloc(int num ) 
{ 
  MDB_IDL ids ;
  void *tmp ;
  MDB_IDL tmp___0 ;

  {
  tmp = malloc((unsigned long )(num + 2) * sizeof(MDB_ID ));
  ids = (MDB_IDL )tmp;
  if (ids) {
    tmp___0 = ids;
    ids ++;
    *tmp___0 = (MDB_ID )num;
    *ids = (MDB_ID )0;
  }
  return (ids);
}
}
void mdb_midl_free(MDB_IDL ids ) 
{ 


  {
  if (ids) {
    free((void *)(ids - 1));
  }
  return;
}
}
void mdb_midl_shrink(MDB_IDL *idp ) 
{ 
  MDB_IDL ids ;
  MDB_IDL tmp ;
  void *tmp___0 ;

  {
  ids = *idp;
  ids --;
  if (*ids > (MDB_ID )((1 << 17) - 1)) {
    tmp___0 = realloc((void *)ids, (unsigned long )(((1 << 17) - 1) + 2) * sizeof(MDB_ID ));
    ids = (MDB_IDL )tmp___0;
    if (ids) {
      tmp = ids;
      ids ++;
      *tmp = (MDB_ID )((1 << 17) - 1);
      *idp = ids;
    }
  }
  return;
}
}
static int mdb_midl_grow(MDB_IDL *idp , int num ) 
{ 
  MDB_IDL idn ;
  void *tmp ;
  MDB_IDL tmp___0 ;

  {
  idn = *idp - 1;
  tmp = realloc((void *)idn, ((*idn + (MDB_ID )num) + 2UL) * sizeof(MDB_ID ));
  idn = (MDB_IDL )tmp;
  if (! idn) {
    return (12);
  }
  tmp___0 = idn;
  idn ++;
  *tmp___0 += (MDB_ID )num;
  *idp = idn;
  return (0);
}
}
int mdb_midl_need(MDB_IDL *idp , unsigned int num ) 
{ 
  MDB_IDL ids ;
  void *tmp ;
  MDB_IDL tmp___0 ;

  {
  ids = *idp;
  num = (unsigned int )((MDB_ID )num + *(ids + 0));
  if ((MDB_ID )num > *(ids + -1)) {
    num = ((num + num / 4U) + 258U) & 4294967040U;
    tmp = realloc((void *)(ids - 1), (unsigned long )num * sizeof(MDB_ID ));
    ids = (MDB_IDL )tmp;
    if (! ids) {
      return (12);
    }
    tmp___0 = ids;
    ids ++;
    *tmp___0 = (MDB_ID )(num - 2U);
    *idp = ids;
  }
  return (0);
}
}
int mdb_midl_append(MDB_IDL *idp , MDB_ID id ) 
{ 
  MDB_IDL ids ;
  int tmp ;

  {
  ids = *idp;
  if (*(ids + 0) >= *(ids + -1)) {
    tmp = mdb_midl_grow(idp, (1 << 17) - 1);
    if (tmp) {
      return (12);
    }
    ids = *idp;
  }
  (*(ids + 0)) ++;
  *(ids + *(ids + 0)) = id;
  return (0);
}
}
int mdb_midl_append_list(MDB_IDL *idp , MDB_IDL app ) 
{ 
  MDB_IDL ids ;
  int tmp ;

  {
  ids = *idp;
  if (*(ids + 0) + *(app + 0) >= *(ids + -1)) {
    tmp = mdb_midl_grow(idp, (int )*(app + 0));
    if (tmp) {
      return (12);
    }
    ids = *idp;
  }
  memcpy((void * __restrict  )(ids + (*(ids + 0) + 1UL)), (void const   * __restrict  )(app + 1),
         *(app + 0) * sizeof(MDB_ID ));
  *(ids + 0) += *(app + 0);
  return (0);
}
}
int mdb_midl_append_range(MDB_IDL *idp , MDB_ID id , unsigned int n ) 
{ 
  MDB_ID *ids ;
  MDB_ID len ;
  int tmp ;
  unsigned int tmp___0 ;
  MDB_ID tmp___1 ;

  {
  ids = *idp;
  len = *(ids + 0);
  if (len + (MDB_ID )n > *(ids + -1)) {
    tmp = mdb_midl_grow(idp, (int )(n | (unsigned int )((1 << 17) - 1)));
    if (tmp) {
      return (12);
    }
    ids = *idp;
  }
  *(ids + 0) = len + (MDB_ID )n;
  ids += len;
  while (n) {
    tmp___0 = n;
    n --;
    tmp___1 = id;
    id ++;
    *(ids + tmp___0) = tmp___1;
  }
  return (0);
}
}
void mdb_midl_xmerge(MDB_IDL idl , MDB_IDL merge ) 
{ 
  MDB_ID old_id ;
  MDB_ID merge_id ;
  MDB_ID i ;
  MDB_ID j ;
  MDB_ID k ;
  MDB_ID total ;
  MDB_ID tmp ;
  MDB_ID tmp___0 ;
  MDB_ID tmp___1 ;

  {
  i = *(merge + 0);
  j = *(idl + 0);
  k = i + j;
  total = k;
  *(idl + 0) = (MDB_ID )-1;
  old_id = *(idl + j);
  while (i) {
    tmp = i;
    i --;
    merge_id = *(merge + tmp);
    while (old_id < merge_id) {
      tmp___0 = k;
      k --;
      *(idl + tmp___0) = old_id;
      j --;
      old_id = *(idl + j);
    }
    tmp___1 = k;
    k --;
    *(idl + tmp___1) = merge_id;
  }
  *(idl + 0) = total;
  return;
}
}
void mdb_midl_sort(MDB_IDL ids ) 
{ 
  int istack[(sizeof(int ) * 8UL) * 2UL] ;
  int i ;
  int j ;
  int k ;
  int l ;
  int ir ;
  int jstack ;
  MDB_ID a ;
  MDB_ID itmp ;
  int tmp ;
  int tmp___0 ;

  {
  ir = (int )*(ids + 0);
  l = 1;
  jstack = 0;
  while (1) {
    if (ir - l < 8) {
      j = l + 1;
      while (j <= ir) {
        a = *(ids + j);
        i = j - 1;
        while (i >= 1) {
          if (*(ids + i) >= a) {
            break;
          }
          *(ids + (i + 1)) = *(ids + i);
          i --;
        }
        *(ids + (i + 1)) = a;
        j ++;
      }
      if (jstack == 0) {
        break;
      }
      tmp = jstack;
      jstack --;
      ir = istack[tmp];
      tmp___0 = jstack;
      jstack --;
      l = istack[tmp___0];
    } else {
      k = (l + ir) >> 1;
      itmp = *(ids + k);
      *(ids + k) = *(ids + (l + 1));
      *(ids + (l + 1)) = itmp;
      if (*(ids + l) < *(ids + ir)) {
        itmp = *(ids + l);
        *(ids + l) = *(ids + ir);
        *(ids + ir) = itmp;
      }
      if (*(ids + (l + 1)) < *(ids + ir)) {
        itmp = *(ids + (l + 1));
        *(ids + (l + 1)) = *(ids + ir);
        *(ids + ir) = itmp;
      }
      if (*(ids + l) < *(ids + (l + 1))) {
        itmp = *(ids + l);
        *(ids + l) = *(ids + (l + 1));
        *(ids + (l + 1)) = itmp;
      }
      i = l + 1;
      j = ir;
      a = *(ids + (l + 1));
      while (1) {
        while (1) {
          i ++;
          if (! (*(ids + i) > a)) {
            break;
          }
        }
        while (1) {
          j --;
          if (! (*(ids + j) < a)) {
            break;
          }
        }
        if (j < i) {
          break;
        }
        itmp = *(ids + i);
        *(ids + i) = *(ids + j);
        *(ids + j) = itmp;
      }
      *(ids + (l + 1)) = *(ids + j);
      *(ids + j) = a;
      jstack += 2;
      if ((ir - i) + 1 >= j - l) {
        istack[jstack] = ir;
        istack[jstack - 1] = i;
        ir = j - 1;
      } else {
        istack[jstack] = j - 1;
        istack[jstack - 1] = l;
        l = i;
      }
    }
  }
  return;
}
}
unsigned int mdb_mid2l_search(MDB_ID2L ids , MDB_ID id ) 
{ 
  unsigned int base ;
  unsigned int cursor ;
  int val ;
  unsigned int n ;
  unsigned int pivot ;

  {
  base = 0U;
  cursor = 1U;
  val = 0;
  n = (unsigned int )(ids + 0)->mid;
  while (0U < n) {
    pivot = n >> 1;
    cursor = (base + pivot) + 1U;
    if (id < (ids + cursor)->mid) {
      val = -1;
    } else {
      val = id > (ids + cursor)->mid;
    }
    if (val < 0) {
      n = pivot;
    } else
    if (val > 0) {
      base = cursor;
      n -= pivot + 1U;
    } else {
      return (cursor);
    }
  }
  if (val > 0) {
    cursor ++;
  }
  return (cursor);
}
}
int mdb_mid2l_insert(MDB_ID2L ids , MDB_ID2 *id ) 
{ 
  unsigned int x ;
  unsigned int i ;

  {
  x = mdb_mid2l_search(ids, id->mid);
  if (x < 1U) {
    return (-2);
  }
  if ((MDB_ID )x <= (ids + 0)->mid) {
    if ((ids + x)->mid == id->mid) {
      return (-1);
    }
  }
  if ((ids + 0)->mid >= (MDB_ID )((1 << 17) - 1)) {
    return (-2);
  } else {
    ((ids + 0)->mid) ++;
    i = (unsigned int )(ids + 0)->mid;
    while (i > x) {
      *(ids + i) = *(ids + (i - 1U));
      i --;
    }
    *(ids + x) = *id;
  }
  return (0);
}
}
int mdb_mid2l_append(MDB_ID2L ids , MDB_ID2 *id ) 
{ 


  {
  if ((ids + 0)->mid >= (MDB_ID )((1 << 17) - 1)) {
    return (-2);
  }
  ((ids + 0)->mid) ++;
  *(ids + (ids + 0)->mid) = *id;
  return (0);
}
}
#pragma merger("0","/tmp/cil-iM5r3ytY.i","-pthread")
extern int printf(char const   * __restrict  __format  , ...) ;
extern  __attribute__((__nothrow__)) int rand(void) ;
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
int main(int argc , char **argv ) 
{ 
  int i ;
  int j ;
  int rc ;
  MDB_env *env ;
  MDB_dbi dbi ;
  MDB_val key ;
  MDB_val data ;
  MDB_txn *txn ;
  MDB_stat mst ;
  MDB_cursor *cursor ;
  MDB_cursor *cur2 ;
  MDB_cursor_op op ;
  int count ;
  int *values ;
  char sval[32] ;
  unsigned int tmp ;
  time_t tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;

  {
  i = 0;
  j = 0;
  sval[0] = (char )'\000';
  tmp = 1U;
  while (! (tmp >= 32U)) {
    sval[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = time((time_t *)((void *)0));
  srand((unsigned int )tmp___0);
  tmp___1 = rand();
  count = tmp___1 % 384 + 64;
  tmp___2 = malloc((unsigned long )count * sizeof(int ));
  values = (int *)tmp___2;
  i = 0;
  while (i < count) {
    tmp___3 = rand();
    *(values + i) = tmp___3 % 1024;
    i ++;
  }
  rc = mdb_env_create(& env);
  if (! (rc == 0)) {
    tmp___4 = mdb_strerror(rc);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: %s: %s\n",
            "mtest.c", 47, "mdb_env_create(&env)", tmp___4);
    abort();
  }
  rc = mdb_env_set_maxreaders(env, 1U);
  if (! (rc == 0)) {
    tmp___5 = mdb_strerror(rc);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: %s: %s\n",
            "mtest.c", 48, "mdb_env_set_maxreaders(env, 1)", tmp___5);
    abort();
  }
  rc = mdb_env_set_mapsize(env, (mdb_size_t )10485760);
  if (! (rc == 0)) {
    tmp___6 = mdb_strerror(rc);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: %s: %s\n",
            "mtest.c", 49, "mdb_env_set_mapsize(env, 10485760)", tmp___6);
    abort();
  }
  rc = mdb_env_open(env, "./testdb", 1U, (mdb_mode_t )436);
  if (! (rc == 0)) {
    tmp___7 = mdb_strerror(rc);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: %s: %s\n",
            "mtest.c", 50, "mdb_env_open(env, \"./testdb\", MDB_FIXEDMAP , 0664)",
            tmp___7);
    abort();
  }
  rc = mdb_txn_begin(env, (MDB_txn *)((void *)0), 0U, & txn);
  if (! (rc == 0)) {
    tmp___8 = mdb_strerror(rc);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: %s: %s\n",
            "mtest.c", 52, "mdb_txn_begin(env, NULL, 0, &txn)", tmp___8);
    abort();
  }
  rc = mdb_dbi_open(txn, (char const   *)((void *)0), 0U, & dbi);
  if (! (rc == 0)) {
    tmp___9 = mdb_strerror(rc);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: %s: %s\n",
            "mtest.c", 53, "mdb_dbi_open(txn, NULL, 0, &dbi)", tmp___9);
    abort();
  }
  key.mv_size = sizeof(int );
  key.mv_data = (void *)(sval);
  printf((char const   * __restrict  )"Adding %d values\n", count);
  i = 0;
  while (i < count) {
    sprintf((char * __restrict  )(sval), (char const   * __restrict  )"%03x %d foo bar",
            *(values + i), *(values + i));
    data.mv_size = sizeof(sval);
    data.mv_data = (void *)(sval);
    rc = mdb_put(txn, dbi, & key, & data, 16U);
    if (rc == -30799) {
      j ++;
      data.mv_size = sizeof(sval);
      data.mv_data = (void *)(sval);
    } else
    if (! (! rc)) {
      tmp___10 = mdb_strerror(rc);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: %s: %s\n",
              "mtest.c", 64, "mdb_put(txn, dbi, &key, &data, MDB_NOOVERWRITE)", tmp___10);
      abort();
    }
    i ++;
  }
  if (j) {
    printf((char const   * __restrict  )"%d duplicates skipped\n", j);
  }
  rc = mdb_txn_commit(txn);
  if (! (rc == 0)) {
    tmp___11 = mdb_strerror(rc);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: %s: %s\n",
            "mtest.c", 71, "mdb_txn_commit(txn)", tmp___11);
    abort();
  }
  rc = mdb_env_stat(env, & mst);
  if (! (rc == 0)) {
    tmp___12 = mdb_strerror(rc);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: %s: %s\n",
            "mtest.c", 72, "mdb_env_stat(env, &mst)", tmp___12);
    abort();
  }
  rc = mdb_txn_begin(env, (MDB_txn *)((void *)0), 131072U, & txn);
  if (! (rc == 0)) {
    tmp___13 = mdb_strerror(rc);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: %s: %s\n",
            "mtest.c", 74, "mdb_txn_begin(env, NULL, MDB_RDONLY, &txn)", tmp___13);
    abort();
  }
  rc = mdb_cursor_open(txn, dbi, & cursor);
  if (! (rc == 0)) {
    tmp___14 = mdb_strerror(rc);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: %s: %s\n",
            "mtest.c", 75, "mdb_cursor_open(txn, dbi, &cursor)", tmp___14);
    abort();
  }
  while (1) {
    rc = mdb_cursor_get(cursor, & key, & data, (MDB_cursor_op )8);
    if (! (rc == 0)) {
      break;
    }
    printf((char const   * __restrict  )"key: %p %.*s, data: %p %.*s\n", key.mv_data,
           (int )key.mv_size, (char *)key.mv_data, data.mv_data, (int )data.mv_size,
           (char *)data.mv_data);
  }
  if (! (rc == -30798)) {
    tmp___15 = mdb_strerror(rc);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: %s: %s\n",
            "mtest.c", 81, "mdb_cursor_get", tmp___15);
    abort();
  }
  mdb_cursor_close(cursor);
  mdb_txn_abort(txn);
  j = 0;
  key.mv_data = (void *)(sval);
  i = count - 1;
  while (i > -1) {
    j ++;
    txn = (MDB_txn *)((void *)0);
    rc = mdb_txn_begin(env, (MDB_txn *)((void *)0), 0U, & txn);
    if (! (rc == 0)) {
      tmp___17 = mdb_strerror(rc);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: %s: %s\n",
              "mtest.c", 90, "mdb_txn_begin(env, NULL, 0, &txn)", tmp___17);
      abort();
    }
    sprintf((char * __restrict  )(sval), (char const   * __restrict  )"%03x ", *(values + i));
    rc = mdb_del(txn, dbi, & key, (MDB_val *)((void *)0));
    if (rc == -30798) {
      j --;
      mdb_txn_abort(txn);
    } else {
      if (! (! rc)) {
        tmp___19 = mdb_strerror(rc);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: %s: %s\n",
                "mtest.c", 92, "mdb_del(txn, dbi, &key, NULL)", tmp___19);
        abort();
      }
      rc = mdb_txn_commit(txn);
      if (! (rc == 0)) {
        tmp___18 = mdb_strerror(rc);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: %s: %s\n",
                "mtest.c", 96, "mdb_txn_commit(txn)", tmp___18);
        abort();
      }
    }
    tmp___16 = rand();
    i -= tmp___16 % 5;
  }
  free((void *)values);
  printf((char const   * __restrict  )"Deleted %d values\n", j);
  rc = mdb_env_stat(env, & mst);
  if (! (rc == 0)) {
    tmp___20 = mdb_strerror(rc);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: %s: %s\n",
            "mtest.c", 102, "mdb_env_stat(env, &mst)", tmp___20);
    abort();
  }
  rc = mdb_txn_begin(env, (MDB_txn *)((void *)0), 131072U, & txn);
  if (! (rc == 0)) {
    tmp___21 = mdb_strerror(rc);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: %s: %s\n",
            "mtest.c", 103, "mdb_txn_begin(env, NULL, MDB_RDONLY, &txn)", tmp___21);
    abort();
  }
  rc = mdb_cursor_open(txn, dbi, & cursor);
  if (! (rc == 0)) {
    tmp___22 = mdb_strerror(rc);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: %s: %s\n",
            "mtest.c", 104, "mdb_cursor_open(txn, dbi, &cursor)", tmp___22);
    abort();
  }
  printf((char const   * __restrict  )"Cursor next\n");
  while (1) {
    rc = mdb_cursor_get(cursor, & key, & data, (MDB_cursor_op )8);
    if (! (rc == 0)) {
      break;
    }
    printf((char const   * __restrict  )"key: %.*s, data: %.*s\n", (int )key.mv_size,
           (char *)key.mv_data, (int )data.mv_size, (char *)data.mv_data);
  }
  if (! (rc == -30798)) {
    tmp___23 = mdb_strerror(rc);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: %s: %s\n",
            "mtest.c", 111, "mdb_cursor_get", tmp___23);
    abort();
  }
  printf((char const   * __restrict  )"Cursor last\n");
  rc = mdb_cursor_get(cursor, & key, & data, (MDB_cursor_op )6);
  if (! (rc == 0)) {
    tmp___24 = mdb_strerror(rc);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: %s: %s\n",
            "mtest.c", 113, "mdb_cursor_get(cursor, &key, &data, MDB_LAST)", tmp___24);
    abort();
  }
  printf((char const   * __restrict  )"key: %.*s, data: %.*s\n", (int )key.mv_size,
         (char *)key.mv_data, (int )data.mv_size, (char *)data.mv_data);
  printf((char const   * __restrict  )"Cursor prev\n");
  while (1) {
    rc = mdb_cursor_get(cursor, & key, & data, (MDB_cursor_op )12);
    if (! (rc == 0)) {
      break;
    }
    printf((char const   * __restrict  )"key: %.*s, data: %.*s\n", (int )key.mv_size,
           (char *)key.mv_data, (int )data.mv_size, (char *)data.mv_data);
  }
  if (! (rc == -30798)) {
    tmp___25 = mdb_strerror(rc);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: %s: %s\n",
            "mtest.c", 123, "mdb_cursor_get", tmp___25);
    abort();
  }
  printf((char const   * __restrict  )"Cursor last/prev\n");
  rc = mdb_cursor_get(cursor, & key, & data, (MDB_cursor_op )6);
  if (! (rc == 0)) {
    tmp___26 = mdb_strerror(rc);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: %s: %s\n",
            "mtest.c", 125, "mdb_cursor_get(cursor, &key, &data, MDB_LAST)", tmp___26);
    abort();
  }
  printf((char const   * __restrict  )"key: %.*s, data: %.*s\n", (int )key.mv_size,
         (char *)key.mv_data, (int )data.mv_size, (char *)data.mv_data);
  rc = mdb_cursor_get(cursor, & key, & data, (MDB_cursor_op )12);
  if (! (rc == 0)) {
    tmp___27 = mdb_strerror(rc);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: %s: %s\n",
            "mtest.c", 129, "mdb_cursor_get(cursor, &key, &data, MDB_PREV)", tmp___27);
    abort();
  }
  printf((char const   * __restrict  )"key: %.*s, data: %.*s\n", (int )key.mv_size,
         (char *)key.mv_data, (int )data.mv_size, (char *)data.mv_data);
  mdb_cursor_close(cursor);
  mdb_txn_abort(txn);
  printf((char const   * __restrict  )"Deleting with cursor\n");
  rc = mdb_txn_begin(env, (MDB_txn *)((void *)0), 0U, & txn);
  if (! (rc == 0)) {
    tmp___28 = mdb_strerror(rc);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: %s: %s\n",
            "mtest.c", 138, "mdb_txn_begin(env, NULL, 0, &txn)", tmp___28);
    abort();
  }
  rc = mdb_cursor_open(txn, dbi, & cur2);
  if (! (rc == 0)) {
    tmp___29 = mdb_strerror(rc);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: %s: %s\n",
            "mtest.c", 139, "mdb_cursor_open(txn, dbi, &cur2)", tmp___29);
    abort();
  }
  i = 0;
  while (i < 50) {
    rc = mdb_cursor_get(cur2, & key, & data, (MDB_cursor_op )8);
    if (rc == -30798) {
      break;
    } else
    if (! (! rc)) {
      tmp___30 = mdb_strerror(rc);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: %s: %s\n",
              "mtest.c", 141, "mdb_cursor_get(cur2, &key, &data, MDB_NEXT)", tmp___30);
      abort();
    }
    printf((char const   * __restrict  )"key: %p %.*s, data: %p %.*s\n", key.mv_data,
           (int )key.mv_size, (char *)key.mv_data, data.mv_data, (int )data.mv_size,
           (char *)data.mv_data);
    rc = mdb_del(txn, dbi, & key, (MDB_val *)((void *)0));
    if (! (rc == 0)) {
      tmp___31 = mdb_strerror(rc);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: %s: %s\n",
              "mtest.c", 146, "mdb_del(txn, dbi, &key, NULL)", tmp___31);
      abort();
    }
    i ++;
  }
  printf((char const   * __restrict  )"Restarting cursor in txn\n");
  op = (MDB_cursor_op )0;
  i = 0;
  while (i <= 32) {
    rc = mdb_cursor_get(cur2, & key, & data, op);
    if (rc == -30798) {
      break;
    } else
    if (! (! rc)) {
      tmp___32 = mdb_strerror(rc);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: %s: %s\n",
              "mtest.c", 151, "mdb_cursor_get(cur2, &key, &data, op)", tmp___32);
      abort();
    }
    printf((char const   * __restrict  )"key: %p %.*s, data: %p %.*s\n", key.mv_data,
           (int )key.mv_size, (char *)key.mv_data, data.mv_data, (int )data.mv_size,
           (char *)data.mv_data);
    op = (MDB_cursor_op )8;
    i ++;
  }
  mdb_cursor_close(cur2);
  rc = mdb_txn_commit(txn);
  if (! (rc == 0)) {
    tmp___33 = mdb_strerror(rc);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: %s: %s\n",
            "mtest.c", 158, "mdb_txn_commit(txn)", tmp___33);
    abort();
  }
  printf((char const   * __restrict  )"Restarting cursor outside txn\n");
  rc = mdb_txn_begin(env, (MDB_txn *)((void *)0), 0U, & txn);
  if (! (rc == 0)) {
    tmp___34 = mdb_strerror(rc);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: %s: %s\n",
            "mtest.c", 161, "mdb_txn_begin(env, NULL, 0, &txn)", tmp___34);
    abort();
  }
  rc = mdb_cursor_open(txn, dbi, & cursor);
  if (! (rc == 0)) {
    tmp___35 = mdb_strerror(rc);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: %s: %s\n",
            "mtest.c", 162, "mdb_cursor_open(txn, dbi, &cursor)", tmp___35);
    abort();
  }
  op = (MDB_cursor_op )0;
  i = 0;
  while (i <= 32) {
    rc = mdb_cursor_get(cursor, & key, & data, op);
    if (rc == -30798) {
      break;
    } else
    if (! (! rc)) {
      tmp___36 = mdb_strerror(rc);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%d: %s: %s\n",
              "mtest.c", 164, "mdb_cursor_get(cursor, &key, &data, op)", tmp___36);
      abort();
    }
    printf((char const   * __restrict  )"key: %p %.*s, data: %p %.*s\n", key.mv_data,
           (int )key.mv_size, (char *)key.mv_data, data.mv_data, (int )data.mv_size,
           (char *)data.mv_data);
    op = (MDB_cursor_op )8;
    i ++;
  }
  mdb_cursor_close(cursor);
  mdb_txn_abort(txn);
  mdb_dbi_close(env, dbi);
  mdb_env_close(env);
  return (0);
}
}
