/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef __builtin_va_list __gnuc_va_list;
typedef int __pid_t;
typedef long __time_t;
typedef unsigned long size_t;
typedef __time_t time_t;
typedef __pid_t pid_t;
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
struct __anonstruct___wseq32_112954846 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_920131302 {
   unsigned long long __wseq ;
   struct __anonstruct___wseq32_112954846 __wseq32 ;
};
struct __anonstruct___g1_start32_1003085126 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_1003085125 {
   unsigned long long __g1_start ;
   struct __anonstruct___g1_start32_1003085126 __g1_start32 ;
};
struct __pthread_cond_s {
   union __anonunion____missing_field_name_920131302 __annonCompField1 ;
   union __anonunion____missing_field_name_1003085125 __annonCompField2 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
typedef unsigned long pthread_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
union __anonunion_pthread_cond_t_951761805 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
typedef union __anonunion_pthread_cond_t_951761805 pthread_cond_t;
typedef __gnuc_va_list va_list___0;
enum LogLevel {
    debug = 0,
    info = 1,
    warn = 2,
    crit = 3,
    error = 4
} ;
typedef unsigned short __u16;
typedef unsigned int __u32;
typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;
struct sysinfo {
   __kernel_long_t uptime ;
   __kernel_ulong_t loads[3] ;
   __kernel_ulong_t totalram ;
   __kernel_ulong_t freeram ;
   __kernel_ulong_t sharedram ;
   __kernel_ulong_t bufferram ;
   __kernel_ulong_t totalswap ;
   __kernel_ulong_t freeswap ;
   __u16 procs ;
   __u16 pad ;
   __kernel_ulong_t totalhigh ;
   __kernel_ulong_t freehigh ;
   __u32 mem_unit ;
   char _f[(20UL - 2UL * sizeof(__kernel_ulong_t )) - sizeof(__u32 )] ;
};
union __anonunion_sem_t_1036286215 {
   char __size[32] ;
   long __align ;
};
typedef union __anonunion_sem_t_1036286215 sem_t;
struct Event {
   pthread_mutex_t mutex ;
   pthread_cond_t cond ;
   _Bool bTriggered ;
   _Bool bManualReset ;
   char Name[64] ;
   int nWaiters ;
};
enum EHandleType {
    EVENT = 0,
    SEMAPHORE = 1
} ;
union __anonunion____missing_field_name_654135139 {
   struct Event event ;
   sem_t semaphore ;
};
struct Handle {
   union __anonunion____missing_field_name_654135139 __annonCompField4 ;
   enum EHandleType type ;
};
struct ProcDumpConfiguration ;
struct ProcDumpConfiguration {
   pid_t ProcessId ;
   char *ProcessName ;
   struct sysinfo SystemInfo ;
   int NumberOfDumpsCollecting ;
   int NumberOfDumpsCollected ;
   _Bool bTerminated ;
   int nQuit ;
   struct Handle evtQuit ;
   _Bool bTriggerThenSnoozeCPU ;
   _Bool bTriggerThenSnoozeMemory ;
   _Bool bTriggerThenSnoozeTimer ;
   int CpuThreshold ;
   _Bool bCpuTriggerBelowValue ;
   int MemoryThreshold ;
   _Bool bMemoryTriggerBelowValue ;
   int ThresholdSeconds ;
   _Bool bTimerThreshold ;
   int NumberOfDumpsToCollect ;
   _Bool WaitingForProcessName ;
   _Bool DiagnosticsLoggingEnabled ;
   int ThreadThreshold ;
   int FileDescriptorThreshold ;
   int SignalNumber ;
   int PollingInterval ;
   char *CoreDumpPath ;
   char *CoreDumpName ;
   int nThreads ;
   pthread_t Threads[3] ;
   struct Handle semAvailableDumpSlots ;
   struct Handle evtCtrlHandlerCleanupComplete ;
   struct Handle evtBannerPrinted ;
   struct Handle evtConfigurationPrinted ;
   struct Handle evtDebugThreadInitialized ;
   struct Handle evtStartMonitoring ;
   pid_t gcorePid ;
};
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
union __anonunion_pthread_condattr_t_488594145 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_condattr_t_488594145 pthread_condattr_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __syscall_slong_t;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
struct __anonstruct___sigset_t_991265788 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___sigset_t_991265788 __sigset_t;
typedef __sigset_t sigset_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char __domainname[65] ;
};
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
enum __ptrace_request {
    PTRACE_TRACEME = 0,
    PTRACE_PEEKTEXT = 1,
    PTRACE_PEEKDATA = 2,
    PTRACE_PEEKUSER = 3,
    PTRACE_POKETEXT = 4,
    PTRACE_POKEDATA = 5,
    PTRACE_POKEUSER = 6,
    PTRACE_CONT = 7,
    PTRACE_KILL = 8,
    PTRACE_SINGLESTEP = 9,
    PTRACE_GETREGS = 12,
    PTRACE_SETREGS = 13,
    PTRACE_GETFPREGS = 14,
    PTRACE_SETFPREGS = 15,
    PTRACE_ATTACH = 16,
    PTRACE_DETACH = 17,
    PTRACE_GETFPXREGS = 18,
    PTRACE_SETFPXREGS = 19,
    PTRACE_SYSCALL = 24,
    PTRACE_GET_THREAD_AREA = 25,
    PTRACE_SET_THREAD_AREA = 26,
    PTRACE_ARCH_PRCTL = 30,
    PTRACE_SYSEMU = 31,
    PTRACE_SYSEMU_SINGLESTEP = 32,
    PTRACE_SINGLEBLOCK = 33,
    PTRACE_SETOPTIONS = 16896,
    PTRACE_GETEVENTMSG = 16897,
    PTRACE_GETSIGINFO = 16898,
    PTRACE_SETSIGINFO = 16899,
    PTRACE_GETREGSET = 16900,
    PTRACE_SETREGSET = 16901,
    PTRACE_SEIZE = 16902,
    PTRACE_INTERRUPT = 16903,
    PTRACE_LISTEN = 16904,
    PTRACE_PEEKSIGINFO = 16905,
    PTRACE_GETSIGMASK = 16906,
    PTRACE_SETSIGMASK = 16907,
    PTRACE_SECCOMP_GET_FILTER = 16908,
    PTRACE_SECCOMP_GET_METADATA = 16909,
    PTRACE_GET_SYSCALL_INFO = 16910
} ;
typedef int __clockid_t;
typedef __clockid_t clockid_t;
struct thread_result {
   int retVal ;
   int threadIndex ;
};
struct coordinator {
   pthread_cond_t condEventTriggered ;
   pthread_mutex_t mutexEventTriggered ;
   struct thread_result *results ;
   int numberTriggered ;
   int nWaiters ;
   int stopIssued ;
   struct Handle evtCanCleanUp ;
   struct Handle evtStartWaiting ;
};
struct thread_args {
   struct Handle *handle ;
   struct coordinator *coordinator ;
   int milliseconds ;
   int retVal ;
   int threadIndex ;
};
struct __dirstream ;
typedef struct __dirstream DIR;
typedef __gid_t gid_t;
struct ProcessStat {
   pid_t pid ;
   char *comm ;
   char state ;
   pid_t ppid ;
   gid_t pgrp ;
   int session ;
   int tty_nr ;
   gid_t tpgid ;
   unsigned int flags ;
   unsigned long minflt ;
   unsigned long cminflt ;
   unsigned long majflt ;
   unsigned long cmajflt ;
   unsigned long utime ;
   unsigned long stime ;
   unsigned long cutime ;
   unsigned long cstime ;
   long priority ;
   long nice ;
   long num_threads ;
   long itrealvalue ;
   unsigned long long starttime ;
   unsigned long vsize ;
   long rss ;
   unsigned long rsslim ;
   unsigned long startcode ;
   unsigned long endcode ;
   unsigned long startstack ;
   unsigned long kstkesp ;
   unsigned long kstkeip ;
   unsigned long signal ;
   unsigned long blocked ;
   unsigned long sigignore ;
   unsigned long sigcatch ;
   unsigned long wchan ;
   unsigned long nswap ;
   unsigned long cnswap ;
   int exit_signal ;
   int processor ;
   unsigned int rt_priority ;
   unsigned int policy ;
   unsigned long long delayacct_blkio_ticks ;
   unsigned long guest_time ;
   long cguest_time ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   int exit_code ;
   int num_filedescriptors ;
};
enum ECoreDumpType {
    COMMIT = 0,
    CPU = 1,
    THREAD = 2,
    FILEDESC = 3,
    SIGNAL = 4,
    TIME = 5,
    MANUAL = 6
} ;
struct CoreDumpWriter {
   struct ProcDumpConfiguration *Config ;
   enum ECoreDumpType Type ;
};
typedef unsigned char __uint8_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef long __ssize_t;
typedef unsigned int __socklen_t;
typedef __ssize_t ssize_t;
typedef __int32_t int32_t;
typedef __socklen_t socklen_t;
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef int wchar_t;
struct MagicVersion {
   uint8_t Magic[14] ;
};
union __anonunion____missing_field_name_584942040 {
   struct MagicVersion _magic ;
   uint8_t Magic[14] ;
};
struct IpcHeader {
   union __anonunion____missing_field_name_584942040 __annonCompField6 ;
   uint16_t Size ;
   uint8_t CommandSet ;
   uint8_t CommandId ;
   uint16_t Reserved ;
};
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#pragma merger("0","/tmp/cil-WBdWn4w_.i","-g,-Wall,-pthread,-std=gnu99")
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
extern  __attribute__((__nothrow__)) size_t strftime(char * __restrict  __s , size_t __maxsize ,
                                                     char const   * __restrict  __format ,
                                                     struct tm  const  * __restrict  __tp ) ;
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
extern int puts(char const   *__s ) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
void Log(enum LogLevel logLevel , char const   *message  , ...) ;
void DiagTrace(char const   *message  , ...) ;
static char const   *LogLevelStrings[5]  = {      "DEBUG",      "INFO",      "WARN",      "CRITICAL", 
        "ERROR"};
struct ProcDumpConfiguration g_config ;
pthread_mutex_t LoggerLock  ;
void LogFormatter(enum LogLevel logLevel , char const   *message , va_list___0 args ) 
{ 
  char timeBuff[64] ;
  time_t rawTime ;
  struct tm *timeInfo ;
  char *trace ;
  va_list___0 copy ;
  int traceLen ;
  int tmp ;
  int argsLen ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  timeInfo = (struct tm *)((void *)0);
  trace = (char *)((void *)0);
  __builtin_va_copy(copy, args);
  pthread_mutex_lock(& LoggerLock);
  rawTime = time((time_t *)((void *)0));
  timeInfo = localtime((time_t const   *)(& rawTime));
  strftime((char * __restrict  )(timeBuff), (size_t )64, (char const   * __restrict  )"%T",
           (struct tm  const  * __restrict  )timeInfo);
  tmp = snprintf((char * __restrict  )((void *)0), (size_t )0, (char const   * __restrict  )"[%s - %s]: ",
                 timeBuff, LogLevelStrings[logLevel]);
  traceLen = tmp;
  tmp___0 = vsnprintf((char * __restrict  )((void *)0), (size_t )0, (char const   * __restrict  )message,
                      copy);
  argsLen = tmp___0;
  tmp___1 = malloc((size_t )((traceLen + argsLen) + 1));
  trace = (char *)tmp___1;
  if (! trace) {
    pthread_mutex_unlock(& LoggerLock);
    __builtin_va_end(copy);
    return;
  }
  sprintf((char * __restrict  )trace, (char const   * __restrict  )"[%s - %s]: ",
          timeBuff, LogLevelStrings[logLevel]);
  vsprintf((char * __restrict  )(trace + traceLen), (char const   * __restrict  )message,
           args);
  if ((unsigned int )logLevel != 0U) {
    puts((char const   *)trace);
  }
  syslog(7, "%s", trace);
  __builtin_va_end(copy);
  free((void *)trace);
  pthread_mutex_unlock(& LoggerLock);
  return;
}
}
void Log(enum LogLevel logLevel , char const   *message  , ...) 
{ 
  va_list___0 args ;

  {
  __builtin_va_start(args, message);
  LogFormatter(logLevel, message, args);
  __builtin_va_end(args);
  return;
}
}
void DiagTrace(char const   *message  , ...) 
{ 
  va_list___0 args ;

  {
  __builtin_va_start(args, message);
  if (g_config.DiagnosticsLoggingEnabled) {
    LogFormatter((enum LogLevel )0, message, args);
  }
  __builtin_va_end(args);
  return;
}
}
#pragma merger("0","/tmp/cil-BQxXUuqk.i","-g,-Wall,-pthread,-std=gnu99")
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                                              pthread_condattr_t const   * __restrict  __cond_attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_destroy)(pthread_cond_t *__cond ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_signal)(pthread_cond_t *__cond ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_broadcast)(pthread_cond_t *__cond ) ;
struct Event *CreateEvent(_Bool IsManualReset , _Bool InitialState ) ;
struct Event *CreateNamedEvent(_Bool IsManualReset , _Bool InitialState , char *Name ) ;
void InitEvent(struct Event *Event , _Bool IsManualReset , _Bool InitialState ) ;
void InitNamedEvent(struct Event *Event , _Bool IsManualReset , _Bool InitialState ,
                    char *Name ) ;
void DestroyEvent(struct Event *Event ) ;
_Bool SetEvent(struct Event *Event ) ;
_Bool ResetEvent(struct Event *Event ) ;
struct Event *CreateEvent(_Bool IsManualReset , _Bool InitialState ) 
{ 
  struct Event *event ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct Event ));
  event = (struct Event *)tmp;
  if ((unsigned long )event == (unsigned long )((void *)0)) {
    Log((enum LogLevel )4, "INTERNAL_ERROR");
    DiagTrace("CreateEvent: failed memory allocation. %s", "in src/Events.c, at line 24");
    exit(-1);
  }
  InitEvent(event, IsManualReset, InitialState);
  return (event);
}
}
struct Event *CreateNamedEvent(_Bool IsManualReset , _Bool InitialState , char *Name ) 
{ 
  struct Event *event ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct Event ));
  event = (struct Event *)tmp;
  if ((unsigned long )event == (unsigned long )((void *)0)) {
    Log((enum LogLevel )4, "Internal Error has occurred. If problem continues to occur run procdump with -d flag to trace issue");
    DiagTrace("CreateNamedEvent: failed memory allocation. %s", "in src/Events.c, at line 43");
    exit(-1);
  }
  InitNamedEvent(event, IsManualReset, InitialState, Name);
  return (event);
}
}
void InitEvent(struct Event *Event , _Bool IsManualReset , _Bool InitialState ) 
{ 


  {
  InitNamedEvent(Event, IsManualReset, InitialState, (char *)((void *)0));
  return;
}
}
static int unamedEventId  =    0;
void InitNamedEvent(struct Event *Event , _Bool IsManualReset , _Bool InitialState ,
                    char *Name ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  pthread_mutex_init(& Event->mutex, (pthread_mutexattr_t const   *)((void *)0));
  tmp = pthread_cond_init((pthread_cond_t * __restrict  )(& Event->cond), (pthread_condattr_t const   * __restrict  )((void *)0));
  if (tmp != 0) {
    Log((enum LogLevel )4, "Internal Error has occurred. If problem continues to occur run procdump with -d flag to trace issue");
    DiagTrace("InitNamedEvent: failed pthread_cond_init. %s", "in src/Events.c, at line 76");
    exit(-1);
  }
  Event->bManualReset = IsManualReset;
  Event->bTriggered = InitialState;
  Event->nWaiters = 0;
  if ((unsigned long )Name == (unsigned long )((void *)0)) {
    unamedEventId ++;
    sprintf((char * __restrict  )(Event->Name), (char const   * __restrict  )"Unnamed Event %d",
            unamedEventId);
  } else {
    tmp___0 = strlen((char const   *)Name);
    if (tmp___0 >= 64UL) {
      strncpy((char * __restrict  )(Event->Name), (char const   * __restrict  )Name,
              (size_t )64);
      Event->Name[63] = (char )'\000';
    } else {
      strcpy((char * __restrict  )(Event->Name), (char const   * __restrict  )Name);
    }
  }
  return;
}
}
void DestroyEvent(struct Event *Event ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  tmp = pthread_cond_destroy(& Event->cond);
  if (tmp != 0) {
    Log((enum LogLevel )4, "Internal Error has occurred. If problem continues to occur run procdump with -d flag to trace issue");
    DiagTrace("DestroyEvent: failed pthread_cond_destroy. %s", "in src/Events.c, at line 104");
    exit(-1);
  }
  tmp___0 = pthread_mutex_destroy(& Event->mutex);
  if (tmp___0 != 0) {
    Log((enum LogLevel )4, "Internal Error has occurred. If problem continues to occur run procdump with -d flag to trace issue");
    DiagTrace("DestroyEvent: failed pthread_mutex_destroy. %s", "in src/Events.c, at line 109");
    exit(-1);
  }
  return;
}
}
_Bool SetEvent(struct Event *Event ) 
{ 
  int success ;

  {
  success = 0;
  success = pthread_mutex_lock(& Event->mutex);
  if (success == 0) {
    Event->bTriggered = (_Bool)1;
    if (Event->bManualReset) {
      pthread_cond_broadcast(& Event->cond);
    } else {
      pthread_cond_signal(& Event->cond);
    }
    pthread_mutex_unlock(& Event->mutex);
  } else {
    Log((enum LogLevel )4, "Internal Error has occurred. If problem continues to occur run procdump with -d flag to trace issue");
    DiagTrace("SetEvent: failed pthread_mutex_lock. %s", "in src/Events.c, at line 135");
    exit(-1);
  }
  return ((_Bool )(success == 0));
}
}
_Bool ResetEvent(struct Event *Event ) 
{ 
  int success ;
  int tmp ;

  {
  success = 0;
  success = pthread_mutex_lock(& Event->mutex);
  if (success == 0) {
    Event->bTriggered = (_Bool)0;
    tmp = pthread_mutex_unlock(& Event->mutex);
    if (tmp != 0) {
      Log((enum LogLevel )4, "Internal Error has occurred. If problem continues to occur run procdump with -d flag to trace issue");
      DiagTrace("ResetEvent: failed pthread_mutex_unlock. %s", "in src/Events.c, at line 157");
      exit(-1);
    }
  } else {
    Log((enum LogLevel )4, "Internal Error has occurred. If problem continues to occur run procdump with -d flag to trace issue");
    DiagTrace("ResetEvent: failed pthread_mutex_lock. %s", "in src/Events.c, at line 163");
    exit(-1);
  }
  return ((_Bool )(success == 0));
}
}
#pragma merger("0","/tmp/cil-hxpzm858.i","-g,-Wall,-pthread,-std=gnu99")
extern FILE *stderr ;
extern int fclose(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...)  __asm__("__isoc99_sscanf")  ;
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
extern char *optarg ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) getopt_long)(int ___argc ,
                                                                                          char * const  *___argv ,
                                                                                          char const   *__shortopts ,
                                                                                          struct option  const  *__longopts ,
                                                                                          int *__longind ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigemptyset)(sigset_t *__set ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigaddset)(sigset_t *__set ,
                                                                                      int __signo ) ;
extern int ( __attribute__((__nonnull__(1,2))) sigwait)(sigset_t const   * __restrict  __set ,
                                                        int * __restrict  __sig ) ;
extern  __attribute__((__nothrow__)) int pthread_sigmask(int __how , __sigset_t const   * __restrict  __newmask ,
                                                         __sigset_t * __restrict  __oldmask ) ;
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
extern  __attribute__((__nothrow__)) int sysinfo(struct sysinfo *__info ) ;
extern  __attribute__((__nothrow__)) int uname(struct utsname *__name ) ;
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
extern void closelog(void) ;
extern void openlog(char const   *__ident , int __option , int __facility ) ;
extern int ( __attribute__((__nonnull__(1,2))) scandir)(char const   * __restrict  __dir ,
                                                        struct dirent *** __restrict  __namelist ,
                                                        int (*__selector)(struct dirent  const  * ) ,
                                                        int (*__cmp)(struct dirent  const  ** ,
                                                                     struct dirent  const  ** ) ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) alphasort)(struct dirent  const  **__e1 ,
                                                                                        struct dirent  const  **__e2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) char *dirname(char *__path ) ;
extern  __attribute__((__nothrow__)) char *__xpg_basename(char *__path ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __file ,
                                                                                   struct stat * __restrict  __buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern  __attribute__((__noreturn__)) void pthread_exit(void *__retval ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
extern int pthread_cancel(pthread_t __th ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sem_init)(sem_t *__sem ,
                                                                                     int __pshared ,
                                                                                     unsigned int __value ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sem_destroy)(sem_t *__sem ) ;
int WaitForSingleObject(struct Handle *Handle , int Milliseconds ) ;
int WaitForMultipleObjects(int Count , struct Handle **Handles , _Bool WaitAll , int Milliseconds ) ;
extern  __attribute__((__nothrow__)) long ptrace(enum __ptrace_request __request 
                                                 , ...) ;
void *CommitMonitoringThread(void *thread_args ) ;
void *CpuMonitoringThread(void *thread_args ) ;
void *ThreadCountMonitoringThread(void *thread_args ) ;
void *FileDescriptorCountMonitoringThread(void *thread_args ) ;
void *SignalMonitoringThread(void *thread_args ) ;
void *TimerThread(void *thread_args ) ;
int GetOptions(struct ProcDumpConfiguration *self , int argc , char **argv ) ;
char *GetProcessName(pid_t pid ) ;
_Bool LookupProcessByPid(struct ProcDumpConfiguration *self ) ;
_Bool WaitForProcessName(struct ProcDumpConfiguration *self ) ;
int CreateTriggerThreads(struct ProcDumpConfiguration *self ) ;
int WaitForQuit(struct ProcDumpConfiguration *self , int milliseconds ) ;
int WaitForQuitOrEvent(struct ProcDumpConfiguration *self , struct Handle *handle ,
                       int milliseconds ) ;
int WaitForAllThreadsToTerminate(struct ProcDumpConfiguration *self ) ;
_Bool IsQuit(struct ProcDumpConfiguration *self ) ;
int SetQuit(struct ProcDumpConfiguration *self , int quit ) ;
_Bool PrintConfiguration(struct ProcDumpConfiguration *self ) ;
_Bool ContinueMonitoring(struct ProcDumpConfiguration *self ) ;
_Bool BeginMonitoring(struct ProcDumpConfiguration *self ) ;
void FreeProcDumpConfiguration(struct ProcDumpConfiguration *self ) ;
void InitProcDumpConfiguration(struct ProcDumpConfiguration *self ) ;
void InitProcDump(void) ;
void ExitProcDump(void) ;
void PrintBanner(void) ;
int PrintUsage(struct ProcDumpConfiguration *self ) ;
_Bool IsValidNumberArg(char const   *arg ) ;
_Bool CheckKernelVersion(void) ;
struct Handle g_evtConfigurationInitialized  =    {{{{{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0,
                                              (struct __pthread_internal_list *)0}}},
      {{{0ULL}, {0ULL}, {0U, 0U}, {0U, 0U}, 0U, 0U, {0U, 0U}}}, (_Bool)0, (_Bool)1,
      {(char )'C', (char )'o', (char )'n', (char )'f', (char )'i', (char )'g', (char )'u',
       (char )'r', (char )'a', (char )'t', (char )'i', (char )'o', (char )'n', (char )'I',
       (char )'n', (char )'i', (char )'t', (char )'i', (char )'a', (char )'l', (char )'i',
       (char )'z', (char )'e', (char )'d', (char )'\000'}, 0}}, (enum EHandleType )0};
static sigset_t sig_set  ;
static pthread_t sig_thread_id  ;
static pthread_t sig_monitor_thread_id  ;
long HZ  ;
int MAXIMUM_CPU  ;
struct ProcDumpConfiguration g_config  ;
pthread_mutex_t ptrace_mutex  ;
void *SignalThread(void *input ) 
{ 
  struct ProcDumpConfiguration *config ;
  int sig_caught ;
  int rc ;

  {
  config = (struct ProcDumpConfiguration *)input;
  rc = sigwait((sigset_t const   * __restrict  )(& sig_set), (int * __restrict  )(& sig_caught));
  if (rc != 0) {
    Log((enum LogLevel )4, "Failed to wait on signal");
    exit(-1);
  }
  switch (sig_caught) {
  case 2: 
  SetQuit(config, 1);
  if (config->gcorePid != 2147483647) {
    Log((enum LogLevel )1, "Shutting down gcore");
    rc = kill(- config->gcorePid, 9);
    if (rc != 0) {
      Log((enum LogLevel )4, "Failed to shutdown gcore.");
    }
  }
  if (config->SignalNumber != -1) {
    pthread_mutex_lock(& ptrace_mutex);
    ptrace((enum __ptrace_request )17, config->ProcessId, 0, 0);
    pthread_mutex_unlock(& ptrace_mutex);
    rc = pthread_cancel(sig_monitor_thread_id);
    if (rc != 0) {
      Log((enum LogLevel )4, "An error occurred while canceling SignalMonitorThread.\n");
      exit(-1);
    }
  }
  Log((enum LogLevel )1, "Quit");
  break;
  default: 
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\nUnexpected signal %d\n",
          sig_caught);
  break;
  }
  pthread_exit((void *)0);
}
}
void InitProcDump(void) 
{ 
  _Bool tmp ;

  {
  openlog("ProcDump", 1, 1 << 3);
  tmp = CheckKernelVersion();
  if ((int )tmp == 0) {
    Log((enum LogLevel )4, "Kernel version lower than 3.5+.");
    exit(-1);
  }
  InitProcDumpConfiguration(& g_config);
  pthread_mutex_init(& LoggerLock, (pthread_mutexattr_t const   *)((void *)0));
  pthread_mutex_init(& ptrace_mutex, (pthread_mutexattr_t const   *)((void *)0));
  return;
}
}
void ExitProcDump(void) 
{ 


  {
  pthread_mutex_destroy(& LoggerLock);
  closelog();
  FreeProcDumpConfiguration(& g_config);
  return;
}
}
void InitProcDumpConfiguration(struct ProcDumpConfiguration *self ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
  tmp = WaitForSingleObject(& g_evtConfigurationInitialized, 0);
  if (tmp == 0) {
    return;
  }
  tmp___0 = sysconf(84);
  MAXIMUM_CPU = 100 * (int )tmp___0;
  HZ = sysconf(2);
  sysinfo(& self->SystemInfo);
  InitNamedEvent(& self->evtCtrlHandlerCleanupComplete.__annonCompField4.event, (_Bool)1,
                 (_Bool)0, (char *)"CtrlHandlerCleanupComplete");
  self->evtCtrlHandlerCleanupComplete.type = (enum EHandleType )0;
  InitNamedEvent(& self->evtBannerPrinted.__annonCompField4.event, (_Bool)1, (_Bool)0,
                 (char *)"BannerPrinted");
  self->evtBannerPrinted.type = (enum EHandleType )0;
  InitNamedEvent(& self->evtConfigurationPrinted.__annonCompField4.event, (_Bool)1,
                 (_Bool)0, (char *)"ConfigurationPrinted");
  self->evtConfigurationPrinted.type = (enum EHandleType )0;
  InitNamedEvent(& self->evtDebugThreadInitialized.__annonCompField4.event, (_Bool)1,
                 (_Bool)0, (char *)"DebugThreadInitialized");
  self->evtDebugThreadInitialized.type = (enum EHandleType )0;
  InitNamedEvent(& self->evtQuit.__annonCompField4.event, (_Bool)1, (_Bool)0, (char *)"Quit");
  self->evtQuit.type = (enum EHandleType )0;
  InitNamedEvent(& self->evtStartMonitoring.__annonCompField4.event, (_Bool)1, (_Bool)0,
                 (char *)"StartMonitoring");
  self->evtStartMonitoring.type = (enum EHandleType )0;
  sem_init(& self->semAvailableDumpSlots.__annonCompField4.semaphore, 0, 1U);
  self->semAvailableDumpSlots.type = (enum EHandleType )1;
  self->ProcessId = 2147483647;
  self->NumberOfDumpsCollected = 0;
  self->NumberOfDumpsToCollect = 1;
  self->CpuThreshold = -1;
  self->MemoryThreshold = -1;
  self->ThreadThreshold = -1;
  self->FileDescriptorThreshold = -1;
  self->SignalNumber = -1;
  self->ThresholdSeconds = 10;
  self->bCpuTriggerBelowValue = (_Bool)0;
  self->bMemoryTriggerBelowValue = (_Bool)0;
  self->bTimerThreshold = (_Bool)0;
  self->WaitingForProcessName = (_Bool)0;
  self->DiagnosticsLoggingEnabled = (_Bool)0;
  self->gcorePid = 2147483647;
  self->PollingInterval = 1000;
  self->CoreDumpPath = (char *)((void *)0);
  self->CoreDumpName = (char *)((void *)0);
  SetEvent(& g_evtConfigurationInitialized.__annonCompField4.event);
  return;
}
}
void FreeProcDumpConfiguration(struct ProcDumpConfiguration *self ) 
{ 
  int tmp ;

  {
  DestroyEvent(& self->evtCtrlHandlerCleanupComplete.__annonCompField4.event);
  DestroyEvent(& self->evtBannerPrinted.__annonCompField4.event);
  DestroyEvent(& self->evtConfigurationPrinted.__annonCompField4.event);
  DestroyEvent(& self->evtDebugThreadInitialized.__annonCompField4.event);
  DestroyEvent(& self->evtQuit.__annonCompField4.event);
  DestroyEvent(& self->evtStartMonitoring.__annonCompField4.event);
  sem_destroy(& self->semAvailableDumpSlots.__annonCompField4.semaphore);
  tmp = strcmp((char const   *)self->ProcessName, "null");
  if (tmp != 0) {
    free((void *)self->ProcessName);
  }
  free((void *)self->CoreDumpPath);
  free((void *)self->CoreDumpName);
  return;
}
}
int GetOptions(struct ProcDumpConfiguration *self , int argc , char **argv ) 
{ 
  int tmp ;
  int tmp___0 ;
  int next_option ;
  int option_index ;
  char const   *short_options ;
  struct option long_options[16] ;
  char *tempOutputPath ;
  struct stat statbuf ;
  int tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  _Bool tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  _Bool tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  _Bool tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  _Bool tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  _Bool tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  _Bool tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  _Bool tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  _Bool tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  _Bool tmp___32 ;
  int tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  size_t tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;

  {
  tmp = WaitForSingleObject(& g_evtConfigurationInitialized, 0);
  if (tmp != 0) {
    DiagTrace("GetOptions: Configuration not initialized. %s", "in src/ProcDumpConfiguration.c, at line 202");
    return (-1);
  }
  if (argc < 2) {
    DiagTrace("GetOptions: Invalid number of command line arguments. %s", "in src/ProcDumpConfiguration.c, at line 207");
    tmp___0 = PrintUsage(self);
    return (tmp___0);
  }
  option_index = 0;
  short_options = "+p:C:c:M:m:n:s:w:T:F:G:I:o:dh";
  long_options[0].name = "pid";
  long_options[0].has_arg = 1;
  long_options[0].flag = (int *)((void *)0);
  long_options[0].val = 'p';
  long_options[1].name = "cpu";
  long_options[1].has_arg = 1;
  long_options[1].flag = (int *)((void *)0);
  long_options[1].val = 'C';
  long_options[2].name = "lower-cpu";
  long_options[2].has_arg = 1;
  long_options[2].flag = (int *)((void *)0);
  long_options[2].val = 'c';
  long_options[3].name = "memory";
  long_options[3].has_arg = 1;
  long_options[3].flag = (int *)((void *)0);
  long_options[3].val = 'M';
  long_options[4].name = "lower-mem";
  long_options[4].has_arg = 1;
  long_options[4].flag = (int *)((void *)0);
  long_options[4].val = 'm';
  long_options[5].name = "number-of-dumps";
  long_options[5].has_arg = 1;
  long_options[5].flag = (int *)((void *)0);
  long_options[5].val = 'n';
  long_options[6].name = "time-between-dumps";
  long_options[6].has_arg = 1;
  long_options[6].flag = (int *)((void *)0);
  long_options[6].val = 's';
  long_options[7].name = "wait";
  long_options[7].has_arg = 1;
  long_options[7].flag = (int *)((void *)0);
  long_options[7].val = 'w';
  long_options[8].name = "threads";
  long_options[8].has_arg = 1;
  long_options[8].flag = (int *)((void *)0);
  long_options[8].val = 'T';
  long_options[9].name = "filedescriptors";
  long_options[9].has_arg = 1;
  long_options[9].flag = (int *)((void *)0);
  long_options[9].val = 'F';
  long_options[10].name = "signal";
  long_options[10].has_arg = 1;
  long_options[10].flag = (int *)((void *)0);
  long_options[10].val = 'G';
  long_options[11].name = "pollinginterval";
  long_options[11].has_arg = 1;
  long_options[11].flag = (int *)((void *)0);
  long_options[11].val = 'I';
  long_options[12].name = "output-path";
  long_options[12].has_arg = 1;
  long_options[12].flag = (int *)((void *)0);
  long_options[12].val = 'o';
  long_options[13].name = "diag";
  long_options[13].has_arg = 0;
  long_options[13].flag = (int *)((void *)0);
  long_options[13].val = 'd';
  long_options[14].name = "help";
  long_options[14].has_arg = 0;
  long_options[14].flag = (int *)((void *)0);
  long_options[14].val = 'h';
  long_options[15].name = (char const   *)((void *)0);
  long_options[15].has_arg = 0;
  long_options[15].flag = (int *)((void *)0);
  long_options[15].val = 0;
  tempOutputPath = (char *)((void *)0);
  while (1) {
    next_option = getopt_long(argc, (char * const  *)argv, short_options, (struct option  const  *)(long_options),
                              & option_index);
    if (! (next_option != -1)) {
      break;
    }
    switch (next_option) {
    case 112: 
    tmp___1 = atoi((char const   *)optarg);
    self->ProcessId = tmp___1;
    tmp___3 = LookupProcessByPid(self);
    if (! tmp___3) {
      Log((enum LogLevel )4, "Invalid PID - failed looking up process name by PID.");
      tmp___2 = PrintUsage(self);
      return (tmp___2);
    }
    break;
    case 67: 
    if (self->CpuThreshold != -1) {
      Log((enum LogLevel )4, "Invalid CPU threshold specified.");
      tmp___4 = PrintUsage(self);
      return (tmp___4);
    } else {
      tmp___5 = IsValidNumberArg((char const   *)optarg);
      if (tmp___5) {
        tmp___6 = atoi((char const   *)optarg);
        self->CpuThreshold = tmp___6;
        if (tmp___6 < 0) {
          Log((enum LogLevel )4, "Invalid CPU threshold specified.");
          tmp___4 = PrintUsage(self);
          return (tmp___4);
        } else
        if (self->CpuThreshold > MAXIMUM_CPU) {
          Log((enum LogLevel )4, "Invalid CPU threshold specified.");
          tmp___4 = PrintUsage(self);
          return (tmp___4);
        }
      } else {
        Log((enum LogLevel )4, "Invalid CPU threshold specified.");
        tmp___4 = PrintUsage(self);
        return (tmp___4);
      }
    }
    break;
    case 73: 
    tmp___8 = IsValidNumberArg((char const   *)optarg);
    if (tmp___8) {
      tmp___9 = atoi((char const   *)optarg);
      self->PollingInterval = tmp___9;
      if (tmp___9 < 0) {
        Log((enum LogLevel )4, "Invalid polling interval specified (minimum %d).",
            1000);
        tmp___7 = PrintUsage(self);
        return (tmp___7);
      } else
      if (self->PollingInterval < 1000) {
        Log((enum LogLevel )4, "Invalid polling interval specified (minimum %d).",
            1000);
        tmp___7 = PrintUsage(self);
        return (tmp___7);
      }
    } else {
      Log((enum LogLevel )4, "Invalid polling interval specified (minimum %d).", 1000);
      tmp___7 = PrintUsage(self);
      return (tmp___7);
    }
    break;
    case 84: 
    if (self->ThreadThreshold != -1) {
      Log((enum LogLevel )4, "Invalid threads threshold specified.");
      tmp___10 = PrintUsage(self);
      return (tmp___10);
    } else {
      tmp___11 = IsValidNumberArg((char const   *)optarg);
      if (tmp___11) {
        tmp___12 = atoi((char const   *)optarg);
        self->ThreadThreshold = tmp___12;
        if (tmp___12 < 0) {
          Log((enum LogLevel )4, "Invalid threads threshold specified.");
          tmp___10 = PrintUsage(self);
          return (tmp___10);
        }
      } else {
        Log((enum LogLevel )4, "Invalid threads threshold specified.");
        tmp___10 = PrintUsage(self);
        return (tmp___10);
      }
    }
    break;
    case 70: 
    if (self->FileDescriptorThreshold != -1) {
      Log((enum LogLevel )4, "Invalid file descriptor threshold specified.");
      tmp___13 = PrintUsage(self);
      return (tmp___13);
    } else {
      tmp___14 = IsValidNumberArg((char const   *)optarg);
      if (tmp___14) {
        tmp___15 = atoi((char const   *)optarg);
        self->FileDescriptorThreshold = tmp___15;
        if (tmp___15 < 0) {
          Log((enum LogLevel )4, "Invalid file descriptor threshold specified.");
          tmp___13 = PrintUsage(self);
          return (tmp___13);
        }
      } else {
        Log((enum LogLevel )4, "Invalid file descriptor threshold specified.");
        tmp___13 = PrintUsage(self);
        return (tmp___13);
      }
    }
    break;
    case 71: 
    if (self->SignalNumber != -1) {
      Log((enum LogLevel )4, "Invalid signal specified.");
      tmp___16 = PrintUsage(self);
      return (tmp___16);
    } else {
      tmp___17 = IsValidNumberArg((char const   *)optarg);
      if (tmp___17) {
        tmp___18 = atoi((char const   *)optarg);
        self->SignalNumber = tmp___18;
        if (tmp___18 < 0) {
          Log((enum LogLevel )4, "Invalid signal specified.");
          tmp___16 = PrintUsage(self);
          return (tmp___16);
        }
      } else {
        Log((enum LogLevel )4, "Invalid signal specified.");
        tmp___16 = PrintUsage(self);
        return (tmp___16);
      }
    }
    break;
    case 99: 
    if (self->CpuThreshold != -1) {
      Log((enum LogLevel )4, "Invalid CPU threshold specified.");
      tmp___19 = PrintUsage(self);
      return (tmp___19);
    } else {
      tmp___20 = IsValidNumberArg((char const   *)optarg);
      if (tmp___20) {
        tmp___21 = atoi((char const   *)optarg);
        self->CpuThreshold = tmp___21;
        if (tmp___21 < 0) {
          Log((enum LogLevel )4, "Invalid CPU threshold specified.");
          tmp___19 = PrintUsage(self);
          return (tmp___19);
        } else
        if (self->CpuThreshold > MAXIMUM_CPU) {
          Log((enum LogLevel )4, "Invalid CPU threshold specified.");
          tmp___19 = PrintUsage(self);
          return (tmp___19);
        }
      } else {
        Log((enum LogLevel )4, "Invalid CPU threshold specified.");
        tmp___19 = PrintUsage(self);
        return (tmp___19);
      }
    }
    self->bCpuTriggerBelowValue = (_Bool)1;
    break;
    case 77: 
    if (self->MemoryThreshold != -1) {
      Log((enum LogLevel )4, "Invalid memory threshold specified.");
      tmp___22 = PrintUsage(self);
      return (tmp___22);
    } else {
      tmp___23 = IsValidNumberArg((char const   *)optarg);
      if (tmp___23) {
        tmp___24 = atoi((char const   *)optarg);
        self->MemoryThreshold = tmp___24;
        if (tmp___24 < 0) {
          Log((enum LogLevel )4, "Invalid memory threshold specified.");
          tmp___22 = PrintUsage(self);
          return (tmp___22);
        }
      } else {
        Log((enum LogLevel )4, "Invalid memory threshold specified.");
        tmp___22 = PrintUsage(self);
        return (tmp___22);
      }
    }
    break;
    case 109: 
    if (self->MemoryThreshold != -1) {
      Log((enum LogLevel )4, "Invalid memory threshold specified.");
      tmp___25 = PrintUsage(self);
      return (tmp___25);
    } else {
      tmp___26 = IsValidNumberArg((char const   *)optarg);
      if (tmp___26) {
        tmp___27 = atoi((char const   *)optarg);
        self->MemoryThreshold = tmp___27;
        if (tmp___27 < 0) {
          Log((enum LogLevel )4, "Invalid memory threshold specified.");
          tmp___25 = PrintUsage(self);
          return (tmp___25);
        }
      } else {
        Log((enum LogLevel )4, "Invalid memory threshold specified.");
        tmp___25 = PrintUsage(self);
        return (tmp___25);
      }
    }
    self->bMemoryTriggerBelowValue = (_Bool)1;
    break;
    case 110: 
    tmp___29 = IsValidNumberArg((char const   *)optarg);
    if (tmp___29) {
      tmp___30 = atoi((char const   *)optarg);
      self->NumberOfDumpsToCollect = tmp___30;
      if (tmp___30 < 0) {
        Log((enum LogLevel )4, "Invalid dumps threshold specified.");
        tmp___28 = PrintUsage(self);
        return (tmp___28);
      }
    } else {
      Log((enum LogLevel )4, "Invalid dumps threshold specified.");
      tmp___28 = PrintUsage(self);
      return (tmp___28);
    }
    break;
    case 115: 
    tmp___32 = IsValidNumberArg((char const   *)optarg);
    if (tmp___32) {
      tmp___33 = atoi((char const   *)optarg);
      self->ThresholdSeconds = tmp___33;
      if (tmp___33 == 0) {
        Log((enum LogLevel )4, "Invalid time threshold specified.");
        tmp___31 = PrintUsage(self);
        return (tmp___31);
      }
    } else {
      Log((enum LogLevel )4, "Invalid time threshold specified.");
      tmp___31 = PrintUsage(self);
      return (tmp___31);
    }
    break;
    case 119: 
    self->WaitingForProcessName = (_Bool)1;
    self->ProcessName = strdup((char const   *)optarg);
    break;
    case 111: 
    tempOutputPath = strdup((char const   *)optarg);
    tmp___36 = stat((char const   * __restrict  )tempOutputPath, (struct stat * __restrict  )(& statbuf));
    if (tmp___36 == 0) {
      if ((statbuf.st_mode & 61440U) == 16384U) {
        self->CoreDumpPath = tempOutputPath;
        self->CoreDumpName = (char *)((void *)0);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      tmp___37 = strlen((char const   *)tempOutputPath);
      if ((int )*(tempOutputPath + (tmp___37 - 1UL)) == 47) {
        self->CoreDumpPath = tempOutputPath;
        self->CoreDumpName = (char *)((void *)0);
      } else {
        tmp___34 = dirname(tempOutputPath);
        self->CoreDumpPath = strdup((char const   *)tmp___34);
        free((void *)tempOutputPath);
        tempOutputPath = strdup((char const   *)optarg);
        tmp___35 = __xpg_basename(tempOutputPath);
        self->CoreDumpName = strdup((char const   *)tmp___35);
        free((void *)tempOutputPath);
      }
    }
    tmp___39 = stat((char const   * __restrict  )self->CoreDumpPath, (struct stat * __restrict  )(& statbuf));
    if (tmp___39 < 0) {
      Log((enum LogLevel )4, "Invalid directory (\"%s\") provided for core dump output.",
          self->CoreDumpPath);
      tmp___38 = PrintUsage(self);
      return (tmp___38);
    } else
    if (! ((statbuf.st_mode & 61440U) == 16384U)) {
      Log((enum LogLevel )4, "Invalid directory (\"%s\") provided for core dump output.",
          self->CoreDumpPath);
      tmp___38 = PrintUsage(self);
      return (tmp___38);
    }
    break;
    case 100: 
    self->DiagnosticsLoggingEnabled = (_Bool)1;
    break;
    case 104: 
    tmp___40 = PrintUsage(self);
    return (tmp___40);
    default: 
    Log((enum LogLevel )4, "Invalid switch specified");
    tmp___41 = PrintUsage(self);
    return (tmp___41);
    }
  }
  if ((unsigned long )self->CoreDumpPath == (unsigned long )((void *)0)) {
    self->CoreDumpPath = strdup(".");
  }
  if (self->NumberOfDumpsToCollect != -1) {
    if (self->MemoryThreshold == -1) {
      if (self->CpuThreshold == -1) {
        if (self->ThreadThreshold == -1) {
          if (self->FileDescriptorThreshold == -1) {
            self->bTimerThreshold = (_Bool)1;
          }
        }
      }
    }
  }
  if (self->SignalNumber != -1) {
    if (self->CpuThreshold != -1) {
      Log((enum LogLevel )4, "Signal trigger must be the only trigger specified.");
      tmp___42 = PrintUsage(self);
      return (tmp___42);
    } else
    if (self->ThreadThreshold != -1) {
      Log((enum LogLevel )4, "Signal trigger must be the only trigger specified.");
      tmp___42 = PrintUsage(self);
      return (tmp___42);
    } else
    if (self->FileDescriptorThreshold != -1) {
      Log((enum LogLevel )4, "Signal trigger must be the only trigger specified.");
      tmp___42 = PrintUsage(self);
      return (tmp___42);
    } else
    if (self->MemoryThreshold != -1) {
      Log((enum LogLevel )4, "Signal trigger must be the only trigger specified.");
      tmp___42 = PrintUsage(self);
      return (tmp___42);
    }
    if (self->PollingInterval != 1000) {
      Log((enum LogLevel )4, "Polling interval has no meaning during signal monitoring.");
      tmp___43 = PrintUsage(self);
      return (tmp___43);
    }
    self->bTimerThreshold = (_Bool)0;
  }
  if (self->ProcessId == 2147483647) {
    if (! self->WaitingForProcessName) {
      Log((enum LogLevel )4, "A valid PID or process name must be specified");
      tmp___44 = PrintUsage(self);
      return (tmp___44);
    }
  }
  if (self->ProcessId != 2147483647) {
    if (self->WaitingForProcessName) {
      Log((enum LogLevel )4, "Please only specify one of -p or -w");
      tmp___45 = PrintUsage(self);
      return (tmp___45);
    }
  }
  if (! self->WaitingForProcessName) {
    self->ProcessName = GetProcessName(self->ProcessId);
  }
  DiagTrace("GetOpts and initial Configuration finished %s", "in src/ProcDumpConfiguration.c, at line 429");
  return (0);
}
}
_Bool LookupProcessByPid(struct ProcDumpConfiguration *self ) 
{ 
  char statFilePath[32] ;
  FILE *fd ;
  FILE *tmp ;

  {
  sprintf((char * __restrict  )(statFilePath), (char const   * __restrict  )"/proc/%d/stat",
          self->ProcessId);
  tmp = fopen((char const   * __restrict  )(statFilePath), (char const   * __restrict  )"r");
  fd = tmp;
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    Log((enum LogLevel )4, "No process matching the specified PID can be found.");
    Log((enum LogLevel )4, "Try elevating the command prompt (i.e., `sudo procdump ...`)");
    return ((_Bool)0);
  }
  fclose(fd);
  return ((_Bool)1);
}
}
static int FilterForPid(struct dirent  const  *entry ) 
{ 
  _Bool tmp ;

  {
  tmp = IsValidNumberArg((char const   *)(entry->d_name));
  return ((int )tmp);
}
}
_Bool WaitForProcessName(struct ProcDumpConfiguration *self ) 
{ 
  struct dirent **nameList ;
  _Bool moreThanOne ;
  pid_t matchingPid ;
  int numEntries ;
  int tmp ;
  int i ;
  pid_t procPid ;
  int tmp___0 ;
  char *nameForPid ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int i___0 ;

  {
  Log((enum LogLevel )1, "Waiting for process \'%s\' to launch...", self->ProcessName);
  while (1) {
    moreThanOne = (_Bool)0;
    matchingPid = 2147483647;
    tmp = scandir((char const   * __restrict  )"/proc/", (struct dirent *** __restrict  )(& nameList),
                  & FilterForPid, (int (*)(struct dirent  const  ** , struct dirent  const  ** ))(& alphasort));
    numEntries = tmp;
    i = 0;
    while (i < numEntries) {
      tmp___0 = atoi((char const   *)((*(nameList + i))->d_name));
      procPid = tmp___0;
      tmp___1 = GetProcessName(procPid);
      nameForPid = tmp___1;
      tmp___2 = strcmp((char const   *)nameForPid, "null");
      if (tmp___2 == 0) {
        goto __Cont;
      }
      tmp___3 = strcmp((char const   *)nameForPid, (char const   *)self->ProcessName);
      if (tmp___3 == 0) {
        if (matchingPid == 2147483647) {
          matchingPid = procPid;
        } else {
          Log((enum LogLevel )4, "More than one matching process found, exiting...");
          moreThanOne = (_Bool)1;
          free((void *)nameForPid);
          break;
        }
      }
      free((void *)nameForPid);
      __Cont: /* CIL Label */ 
      i ++;
    }
    i___0 = 0;
    while (i___0 < numEntries) {
      free((void *)*(nameList + i___0));
      i___0 ++;
    }
    free((void *)nameList);
    if (moreThanOne) {
      self->bTerminated = (_Bool)1;
      return ((_Bool)0);
    } else
    if (matchingPid != 2147483647) {
      self->ProcessId = matchingPid;
      Log((enum LogLevel )1, "Found process with PID %d", matchingPid);
      return ((_Bool)1);
    }
  }
}
}
char *GetProcessName(pid_t pid ) 
{ 
  char procFilePath[32] ;
  char fileBuffer[4097] ;
  int charactersRead ;
  int itr ;
  char *stringItr ;
  char *processName ;
  FILE *procFile ;
  int tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int i ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  charactersRead = 0;
  itr = 0;
  tmp = sprintf((char * __restrict  )(procFilePath), (char const   * __restrict  )"/proc/%d/cmdline",
                pid);
  if (tmp < 0) {
    return ((char *)"null");
  }
  procFile = fopen((char const   * __restrict  )(procFilePath), (char const   * __restrict  )"r");
  if ((unsigned long )procFile != (unsigned long )((void *)0)) {
    tmp___1 = fgets((char * __restrict  )(fileBuffer), 4097, (FILE * __restrict  )procFile);
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      fclose(procFile);
      tmp___0 = strlen((char const   *)(fileBuffer));
      if (tmp___0 == 0UL) {
        Log((enum LogLevel )0, "Empty cmdline.\n");
      } else {
        Log((enum LogLevel )0, "Failed to read from %s.\n", procFilePath);
      }
      return ((char *)"null");
    }
    fclose(procFile);
  } else {
    Log((enum LogLevel )0, "Failed to open %s.\n", procFilePath);
    return ((char *)"null");
  }
  stringItr = fileBuffer;
  tmp___2 = strlen((char const   *)(fileBuffer));
  charactersRead = (int )tmp___2;
  i = 0;
  while (i <= charactersRead) {
    if ((int )fileBuffer[i] == 0) {
      itr = i - itr;
      tmp___5 = strcmp((char const   *)stringItr, "sudo");
      if (tmp___5 != 0) {
        processName = strrchr((char const   *)stringItr, '/');
        if ((unsigned long )processName != (unsigned long )((void *)0)) {
          tmp___3 = strdup((char const   *)(processName + 1));
          return (tmp___3);
        } else {
          tmp___4 = strdup((char const   *)stringItr);
          return (tmp___4);
        }
      } else {
        stringItr += itr + 1;
      }
    }
    i ++;
  }
  Log((enum LogLevel )0, "Failed to extract process name from /proc/PID/cmdline");
  return ((char *)"null");
}
}
int CreateTriggerThreads(struct ProcDumpConfiguration *self ) 
{ 
  int rc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  rc = 0;
  self->nThreads = 0;
  rc = sigemptyset(& sig_set);
  if (rc < 0) {
    DiagTrace("CreateTriggerThreads: sigemptyset failed. %s", "in src/ProcDumpConfiguration.c, at line 598");
    return (rc);
  }
  rc = sigaddset(& sig_set, 2);
  if (rc < 0) {
    DiagTrace("CreateTriggerThreads: sigaddset failed. %s", "in src/ProcDumpConfiguration.c, at line 603");
    return (rc);
  }
  rc = sigaddset(& sig_set, 15);
  if (rc < 0) {
    DiagTrace("CreateTriggerThreads: sigaddset failed. %s", "in src/ProcDumpConfiguration.c, at line 608");
    return (rc);
  }
  rc = pthread_sigmask(0, (__sigset_t const   * __restrict  )(& sig_set), (__sigset_t * __restrict  )((void *)0));
  if (rc != 0) {
    DiagTrace("CreateTriggerThreads: pthread_sigmask failed. %s", "in src/ProcDumpConfiguration.c, at line 614");
    return (rc);
  }
  if (self->CpuThreshold != -1) {
    tmp = self->nThreads;
    (self->nThreads) ++;
    rc = pthread_create((pthread_t * __restrict  )(& self->Threads[tmp]), (pthread_attr_t const   * __restrict  )((void *)0),
                        & CpuMonitoringThread, (void * __restrict  )((void *)self));
    if (rc != 0) {
      DiagTrace("CreateTriggerThreads: failed to create CpuThread. %s", "in src/ProcDumpConfiguration.c, at line 621");
      return (rc);
    }
  }
  if (self->MemoryThreshold != -1) {
    tmp___0 = self->nThreads;
    (self->nThreads) ++;
    rc = pthread_create((pthread_t * __restrict  )(& self->Threads[tmp___0]), (pthread_attr_t const   * __restrict  )((void *)0),
                        & CommitMonitoringThread, (void * __restrict  )((void *)self));
    if (rc != 0) {
      DiagTrace("CreateTriggerThreads: failed to create CommitThread. %s", "in src/ProcDumpConfiguration.c, at line 628");
      return (rc);
    }
  }
  if (self->ThreadThreshold != -1) {
    tmp___1 = self->nThreads;
    (self->nThreads) ++;
    rc = pthread_create((pthread_t * __restrict  )(& self->Threads[tmp___1]), (pthread_attr_t const   * __restrict  )((void *)0),
                        & ThreadCountMonitoringThread, (void * __restrict  )((void *)self));
    if (rc != 0) {
      DiagTrace("CreateTriggerThreads: failed to create ThreadThread. %s", "in src/ProcDumpConfiguration.c, at line 635");
      return (rc);
    }
  }
  if (self->FileDescriptorThreshold != -1) {
    tmp___2 = self->nThreads;
    (self->nThreads) ++;
    rc = pthread_create((pthread_t * __restrict  )(& self->Threads[tmp___2]), (pthread_attr_t const   * __restrict  )((void *)0),
                        & FileDescriptorCountMonitoringThread, (void * __restrict  )((void *)self));
    if (rc != 0) {
      DiagTrace("CreateTriggerThreads: failed to create FileDescriptorThread. %s",
                "in src/ProcDumpConfiguration.c, at line 642");
      return (rc);
    }
  }
  if (self->SignalNumber != -1) {
    rc = pthread_create((pthread_t * __restrict  )(& sig_monitor_thread_id), (pthread_attr_t const   * __restrict  )((void *)0),
                        & SignalMonitoringThread, (void * __restrict  )((void *)self));
    if (rc != 0) {
      DiagTrace("CreateTriggerThreads: failed to create SignalMonitoringThread. %s",
                "in src/ProcDumpConfiguration.c, at line 649");
      return (rc);
    }
  }
  if (self->bTimerThreshold) {
    tmp___3 = self->nThreads;
    (self->nThreads) ++;
    rc = pthread_create((pthread_t * __restrict  )(& self->Threads[tmp___3]), (pthread_attr_t const   * __restrict  )((void *)0),
                        & TimerThread, (void * __restrict  )((void *)self));
    if (rc != 0) {
      DiagTrace("CreateTriggerThreads: failed to create TimerThread. %s", "in src/ProcDumpConfiguration.c, at line 656");
      return (rc);
    }
  }
  rc = pthread_create((pthread_t * __restrict  )(& sig_thread_id), (pthread_attr_t const   * __restrict  )((void *)0),
                      & SignalThread, (void * __restrict  )((void *)self));
  if (rc != 0) {
    DiagTrace("CreateTriggerThreads: failed to create SignalThread. %s", "in src/ProcDumpConfiguration.c, at line 663");
    return (rc);
  }
  return (0);
}
}
int WaitForQuit(struct ProcDumpConfiguration *self , int milliseconds ) 
{ 
  _Bool tmp ;
  int wait___0 ;
  int tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = ContinueMonitoring(self);
  if (! tmp) {
    return (128);
  }
  tmp___0 = WaitForSingleObject(& self->evtQuit, milliseconds);
  wait___0 = tmp___0;
  if (wait___0 == 110) {
    tmp___1 = ContinueMonitoring(self);
    if (! tmp___1) {
      return (128);
    }
  }
  return (wait___0);
}
}
int WaitForQuitOrEvent(struct ProcDumpConfiguration *self , struct Handle *handle ,
                       int milliseconds ) 
{ 
  struct Handle *waits[2] ;
  _Bool tmp ;
  int wait___0 ;
  int tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;

  {
  waits[0] = & self->evtQuit;
  waits[1] = handle;
  tmp = ContinueMonitoring(self);
  if (! tmp) {
    return (128);
  }
  tmp___0 = WaitForMultipleObjects(2, waits, (_Bool)0, milliseconds);
  wait___0 = tmp___0;
  if (wait___0 == 110) {
    tmp___1 = ContinueMonitoring(self);
    if (! tmp___1) {
      return (128);
    }
  }
  if (wait___0 == 0) {
    tmp___2 = ContinueMonitoring(self);
    if (! tmp___2) {
      return (128);
    }
  }
  return (wait___0);
}
}
int WaitForAllThreadsToTerminate(struct ProcDumpConfiguration *self ) 
{ 
  int rc ;
  int i ;

  {
  rc = 0;
  if (self->SignalNumber != -1) {
    rc = pthread_join(sig_monitor_thread_id, (void **)((void *)0));
    if (rc != 0) {
      Log((enum LogLevel )4, "An error occurred while joining SignalMonitorThread.\n");
      exit(-1);
    }
  } else {
    i = 0;
    while (i < self->nThreads) {
      rc = pthread_join(self->Threads[i], (void **)((void *)0));
      if (rc != 0) {
        Log((enum LogLevel )4, "An error occurred while joining threads\n");
        exit(-1);
      }
      i ++;
    }
  }
  pthread_cancel(sig_thread_id);
  rc = pthread_join(sig_thread_id, (void **)((void *)0));
  if (rc != 0) {
    Log((enum LogLevel )4, "An error occurred while joining SignalThread.\n");
    exit(-1);
  }
  return (rc);
}
}
_Bool IsQuit(struct ProcDumpConfiguration *self ) 
{ 


  {
  return ((_Bool )(self->nQuit != 0));
}
}
int SetQuit(struct ProcDumpConfiguration *self , int quit ) 
{ 


  {
  self->nQuit = quit;
  SetEvent(& self->evtQuit.__annonCompField4.event);
  return (self->nQuit);
}
}
_Bool PrintConfiguration(struct ProcDumpConfiguration *self ) 
{ 
  int tmp ;

  {
  tmp = WaitForSingleObject(& self->evtConfigurationPrinted, 0);
  if (tmp == 110) {
    if (self->SignalNumber != -1) {
      printf((char const   * __restrict  )"** NOTE ** Signal triggers use PTRACE which will impact the performance of the target process\n\n");
    }
    printf((char const   * __restrict  )"Process:\t\t%s", self->ProcessName);
    if (! self->WaitingForProcessName) {
      printf((char const   * __restrict  )" (%d)", self->ProcessId);
    } else {
      printf((char const   * __restrict  )" (pending)");
    }
    printf((char const   * __restrict  )"\n");
    if (self->CpuThreshold != -1) {
      if (self->bCpuTriggerBelowValue) {
        printf((char const   * __restrict  )"CPU Threshold:\t\t<%d\n", self->CpuThreshold);
      } else {
        printf((char const   * __restrict  )"CPU Threshold:\t\t>=%d\n", self->CpuThreshold);
      }
    } else {
      printf((char const   * __restrict  )"CPU Threshold:\t\tn/a\n");
    }
    if (self->MemoryThreshold != -1) {
      if (self->bMemoryTriggerBelowValue) {
        printf((char const   * __restrict  )"Commit Threshold:\t<%d\n", self->MemoryThreshold);
      } else {
        printf((char const   * __restrict  )"Commit Threshold:\t>=%d\n", self->MemoryThreshold);
      }
    } else {
      printf((char const   * __restrict  )"Commit Threshold:\tn/a\n");
    }
    if (self->ThreadThreshold != -1) {
      printf((char const   * __restrict  )"Thread Threshold:\t>=%d\n", self->ThreadThreshold);
    } else {
      printf((char const   * __restrict  )"Thread Threshold:\t\tn/a\n");
    }
    if (self->FileDescriptorThreshold != -1) {
      printf((char const   * __restrict  )"File descriptor Threshold:\t>=%d\n", self->FileDescriptorThreshold);
    } else {
      printf((char const   * __restrict  )"File descriptor Threshold:\t\tn/a\n");
    }
    if (self->SignalNumber != -1) {
      printf((char const   * __restrict  )"Signal number:\t%d\n", self->SignalNumber);
    } else {
      printf((char const   * __restrict  )"Signal:\t\tn/a\n");
    }
    printf((char const   * __restrict  )"Polling interval (ms):\t%d\n", self->PollingInterval);
    printf((char const   * __restrict  )"Threshold (s):\t%d\n", self->ThresholdSeconds);
    printf((char const   * __restrict  )"Number of Dumps:\t%d\n", self->NumberOfDumpsToCollect);
    printf((char const   * __restrict  )"Output directory for core dumps:\t%s\n",
           self->CoreDumpPath);
    if ((unsigned long )self->CoreDumpName != (unsigned long )((void *)0)) {
      printf((char const   * __restrict  )"Custom name for core dumps:\t%s_<counter>.<pid>\n",
             self->CoreDumpName);
    }
    SetEvent(& self->evtConfigurationPrinted.__annonCompField4.event);
    return ((_Bool)1);
  }
  return ((_Bool)0);
}
}
_Bool ContinueMonitoring(struct ProcDumpConfiguration *self ) 
{ 
  int tmp ;

  {
  if (self->NumberOfDumpsCollected >= self->NumberOfDumpsToCollect) {
    return ((_Bool)0);
  }
  if (self->bTerminated) {
    return ((_Bool)0);
  }
  tmp = kill(self->ProcessId, 0);
  if (tmp) {
    self->bTerminated = (_Bool)1;
    Log((enum LogLevel )4, "Target process is no longer alive");
    return ((_Bool)0);
  }
  return ((_Bool)1);
}
}
_Bool BeginMonitoring(struct ProcDumpConfiguration *self ) 
{ 
  _Bool tmp ;

  {
  tmp = SetEvent(& self->evtStartMonitoring.__annonCompField4.event);
  return (tmp);
}
}
_Bool IsValidNumberArg(char const   *arg ) 
{ 
  int strLen ;
  size_t tmp ;
  int i ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  tmp = strlen(arg);
  strLen = (int )tmp;
  i = 0;
  while (i < strLen) {
    tmp___0 = __ctype_b_loc();
    if (! ((int const   )*(*tmp___0 + (int )*(arg + i)) & 2048)) {
      tmp___1 = __ctype_b_loc();
      if (! ((int const   )*(*tmp___1 + (int )*(arg + i)) & 8192)) {
        return ((_Bool)0);
      }
    }
    i ++;
  }
  return ((_Bool)1);
}
}
_Bool CheckKernelVersion(void) 
{ 
  struct utsname kernelInfo ;
  int version ;
  int patch ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  tmp___4 = uname(& kernelInfo);
  if (tmp___4 == 0) {
    patch = 0;
    tmp___1 = sscanf((char const   * __restrict  )(kernelInfo.release), (char const   * __restrict  )"%d.%d",
                     & version, & patch);
    if (tmp___1 != 2) {
      Log((enum LogLevel )4, "Cannot validate kernel version");
      tmp = __errno_location();
      tmp___0 = strerror(*tmp);
      DiagTrace("%s %s", tmp___0, "in src/ProcDumpConfiguration.c, at line 963");
      return ((_Bool)0);
    }
    if (version > 3) {
      return ((_Bool)1);
    }
    if (version == 3) {
      if (patch >= 5) {
        return ((_Bool)1);
      }
    }
  } else {
    tmp___2 = __errno_location();
    tmp___3 = strerror(*tmp___2);
    Log((enum LogLevel )4, (char const   *)tmp___3);
  }
  return ((_Bool)0);
}
}
void PrintBanner(void) 
{ 


  {
  printf((char const   * __restrict  )"\nProcDump v1.2 - Sysinternals process dump utility\n");
  printf((char const   * __restrict  )"Copyright (C) 2020 Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n");
  printf((char const   * __restrict  )"Mark Russinovich, Mario Hewardt, John Salem, Javid Habibi\n");
  printf((char const   * __restrict  )"Monitors a process and writes a dump file when the process meets the\n");
  printf((char const   * __restrict  )"specified criteria.\n\n");
  return;
}
}
int PrintUsage(struct ProcDumpConfiguration *self ) 
{ 


  {
  printf((char const   * __restrict  )"\nUsage: procdump [OPTIONS...] TARGET\n");
  printf((char const   * __restrict  )"   OPTIONS\n");
  printf((char const   * __restrict  )"      -h          Prints this help screen\n");
  printf((char const   * __restrict  )"      -C          Trigger core dump generation when CPU exceeds or equals specified value (0 to 100 * nCPU)\n");
  printf((char const   * __restrict  )"      -c          Trigger core dump generation when CPU is less than specified value (0 to 100 * nCPU)\n");
  printf((char const   * __restrict  )"      -M          Trigger core dump generation when memory commit exceeds or equals specified value (MB)\n");
  printf((char const   * __restrict  )"      -m          Trigger core dump generation when when memory commit is less than specified value (MB)\n");
  printf((char const   * __restrict  )"      -T          Trigger when thread count exceeds or equals specified value.\n");
  printf((char const   * __restrict  )"      -F          Trigger when file descriptor count exceeds or equals specified value.\n");
  printf((char const   * __restrict  )"      -G          Trigger when signal with the specified value (num) is sent (uses PTRACE and will affect performance of target process).\n");
  printf((char const   * __restrict  )"      -I          Polling frequency in milliseconds (default is %d)\n",
         1000);
  printf((char const   * __restrict  )"      -n          Number of core dumps to write before exiting (default is %d)\n",
         1);
  printf((char const   * __restrict  )"      -s          Consecutive seconds before dump is written (default is %d)\n",
         10);
  printf((char const   * __restrict  )"      -o          Path and/or filename prefix where the core dump is written to\n");
  printf((char const   * __restrict  )"      -d          Writes diagnostic logs to syslog\n");
  printf((char const   * __restrict  )"   TARGET must be exactly one of these:\n");
  printf((char const   * __restrict  )"      -p          pid of the process\n");
  printf((char const   * __restrict  )"      -w          Name of the process executable\n\n");
  return (-1);
}
}
#pragma merger("0","/tmp/cil-8JoZWLlg.i","-g,-Wall,-pthread,-std=gnu99")
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
extern  __attribute__((__nothrow__)) int pthread_detach(pthread_t __th ) ;
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
extern int ( __attribute__((__nonnull__(1,2,3))) pthread_cond_timedwait)(pthread_cond_t * __restrict  __cond ,
                                                                         pthread_mutex_t * __restrict  __mutex ,
                                                                         struct timespec  const  * __restrict  __abstime ) ;
extern int ( __attribute__((__nonnull__(1))) sem_wait)(sem_t *__sem ) ;
extern int ( __attribute__((__nonnull__(1,2))) sem_timedwait)(sem_t * __restrict  __sem ,
                                                              struct timespec  const  * __restrict  __abstime ) ;
int WaitForSingleObject(struct Handle *Handle , int Milliseconds ) 
{ 
  struct timespec ts ;
  int rc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  rc = 0;
  if (Milliseconds != -1) {
    clock_gettime(0, & ts);
    ts.tv_sec += (__time_t )(Milliseconds / 1000);
    ts.tv_nsec += (__syscall_slong_t )((Milliseconds % 1000) * 1000000);
  }
  switch ((unsigned int )Handle->type) {
  case 0U: 
  rc = pthread_mutex_lock(& Handle->__annonCompField4.event.mutex);
  if (rc == 0) {
    (Handle->__annonCompField4.event.nWaiters) ++;
    while (1) {
      if (! Handle->__annonCompField4.event.bTriggered) {
        if (! (rc == 0)) {
          break;
        }
      } else {
        break;
      }
      if (Milliseconds == -1) {
        tmp = pthread_cond_wait((pthread_cond_t * __restrict  )(& Handle->__annonCompField4.event.cond),
                                (pthread_mutex_t * __restrict  )(& Handle->__annonCompField4.event.mutex));
        rc = tmp;
      } else {
        tmp___0 = pthread_cond_timedwait((pthread_cond_t * __restrict  )(& Handle->__annonCompField4.event.cond),
                                         (pthread_mutex_t * __restrict  )(& Handle->__annonCompField4.event.mutex),
                                         (struct timespec  const  * __restrict  )(& ts));
        rc = tmp___0;
      }
    }
    (Handle->__annonCompField4.event.nWaiters) --;
    if (Handle->__annonCompField4.event.nWaiters == 0) {
      if (! Handle->__annonCompField4.event.bManualReset) {
        Handle->__annonCompField4.event.bTriggered = (_Bool)0;
      }
    }
    pthread_mutex_unlock(& Handle->__annonCompField4.event.mutex);
  }
  break;
  case 1U: 
  if (Milliseconds == -1) {
    tmp___1 = sem_wait(& Handle->__annonCompField4.semaphore);
    rc = tmp___1;
  } else {
    tmp___2 = sem_timedwait((sem_t * __restrict  )(& Handle->__annonCompField4.semaphore),
                            (struct timespec  const  * __restrict  )(& ts));
    rc = tmp___2;
  }
  break;
  default: 
  rc = -1;
  break;
  }
  return (rc);
}
}
void *WaiterThread(void *thread_args ) 
{ 
  int rc ;
  struct thread_args *input ;
  struct thread_result result ;
  int tmp ;

  {
  input = (struct thread_args *)thread_args;
  rc = WaitForSingleObject(& (input->coordinator)->evtStartWaiting, 2000);
  if (input->milliseconds == -1) {
    while (1) {
      rc = WaitForSingleObject(input->handle, 5000);
      if (! (input->coordinator)->stopIssued) {
        if (! (rc == 110)) {
          break;
        }
      } else {
        break;
      }
    }
  } else {
    rc = WaitForSingleObject(input->handle, input->milliseconds);
  }
  pthread_mutex_lock(& (input->coordinator)->mutexEventTriggered);
  result.retVal = rc;
  result.threadIndex = input->threadIndex;
  tmp = (input->coordinator)->numberTriggered;
  ((input->coordinator)->numberTriggered) ++;
  *((input->coordinator)->results + tmp) = result;
  pthread_mutex_unlock(& (input->coordinator)->mutexEventTriggered);
  pthread_cond_signal(& (input->coordinator)->condEventTriggered);
  WaitForSingleObject(& (input->coordinator)->evtCanCleanUp, -1);
  pthread_mutex_lock(& (input->coordinator)->mutexEventTriggered);
  ((input->coordinator)->nWaiters) --;
  if ((input->coordinator)->nWaiters == 0) {
    pthread_mutex_unlock(& (input->coordinator)->mutexEventTriggered);
    pthread_mutex_destroy(& (input->coordinator)->mutexEventTriggered);
    pthread_cond_destroy(& (input->coordinator)->condEventTriggered);
    free((void *)(input->coordinator)->results);
    free((void *)input->coordinator);
    free((void *)input);
  } else {
    pthread_mutex_unlock(& (input->coordinator)->mutexEventTriggered);
    free((void *)input);
  }
  pthread_exit((void *)0);
}
}
int WaitForMultipleObjects(int Count , struct Handle **Handles , _Bool WaitAll , int Milliseconds ) 
{ 
  struct coordinator *coordinator ;
  struct thread_result *results ;
  pthread_t *threads ;
  struct thread_args **thread_args ;
  struct timespec ts ;
  int t ;
  int rc ;
  int retVal ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  struct thread_result *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  tmp = malloc(sizeof(pthread_t ) * (unsigned long )Count);
  threads = (pthread_t *)tmp;
  tmp___0 = malloc(sizeof(struct thread_args *) * (unsigned long )Count);
  thread_args = (struct thread_args **)tmp___0;
  tmp___1 = malloc(sizeof(struct coordinator ));
  coordinator = (struct coordinator *)tmp___1;
  if ((unsigned long )coordinator == (unsigned long )((void *)0)) {
    printf((char const   * __restrict  )"ERROR: Failed to malloc in %s\n", "src/Handle.c");
    exit(-1);
  }
  coordinator->numberTriggered = 0;
  coordinator->stopIssued = 0;
  coordinator->evtCanCleanUp.type = (enum EHandleType )0;
  coordinator->evtStartWaiting.type = (enum EHandleType )0;
  InitNamedEvent(& coordinator->evtCanCleanUp.__annonCompField4.event, (_Bool)1, (_Bool)0,
                 (char *)"CanCleanUp");
  InitNamedEvent(& coordinator->evtStartWaiting.__annonCompField4.event, (_Bool)1,
                 (_Bool)0, (char *)"StartWaiting");
  pthread_cond_init((pthread_cond_t * __restrict  )(& coordinator->condEventTriggered),
                    (pthread_condattr_t const   * __restrict  )((void *)0));
  pthread_mutex_init(& coordinator->mutexEventTriggered, (pthread_mutexattr_t const   *)((void *)0));
  tmp___3 = malloc(sizeof(struct thread_result ) * (unsigned long )Count);
  tmp___2 = (struct thread_result *)tmp___3;
  coordinator->results = tmp___2;
  results = tmp___2;
  if (Milliseconds != -1) {
    clock_gettime(0, & ts);
    ts.tv_sec += (__time_t )(Milliseconds / 1000);
    ts.tv_nsec += (__syscall_slong_t )((Milliseconds % 1000) * 1000000);
  }
  pthread_mutex_lock(& coordinator->mutexEventTriggered);
  t = 0;
  while (t < Count) {
    tmp___4 = malloc(sizeof(struct thread_args ));
    *(thread_args + t) = (struct thread_args *)tmp___4;
    if ((unsigned long )*(thread_args + t) == (unsigned long )((void *)0)) {
      printf((char const   * __restrict  )"ERROR: Failed to alloc in %s\n", "src/Handle.c");
      exit(-1);
    }
    (*(thread_args + t))->handle = *(Handles + t);
    if (Milliseconds == -1) {
      (*(thread_args + t))->milliseconds = Milliseconds;
    } else {
      (*(thread_args + t))->milliseconds = Milliseconds + 100;
    }
    (*(thread_args + t))->threadIndex = t;
    (*(thread_args + t))->coordinator = coordinator;
    rc = pthread_create((pthread_t * __restrict  )(threads + t), (pthread_attr_t const   * __restrict  )((void *)0),
                        & WaiterThread, (void * __restrict  )((void *)*(thread_args + t)));
    if (rc) {
      printf((char const   * __restrict  )"ERROR: pthread_create failed in %s with error %d\n",
             "src/Handle.c", rc);
      exit(-1);
    }
    t ++;
  }
  coordinator->nWaiters = Count;
  SetEvent(& coordinator->evtStartWaiting.__annonCompField4.event);
  while (1) {
    if (WaitAll) {
      if (coordinator->numberTriggered < Count) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (! WaitAll) {
      if (coordinator->numberTriggered == 0) {
        _L: /* CIL Label */ 
        if (! (rc == 0)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    if (Milliseconds == -1) {
      rc = pthread_cond_wait((pthread_cond_t * __restrict  )(& coordinator->condEventTriggered),
                             (pthread_mutex_t * __restrict  )(& coordinator->mutexEventTriggered));
      if (rc != 0) {
        break;
      }
    } else {
      rc = pthread_cond_timedwait((pthread_cond_t * __restrict  )(& coordinator->condEventTriggered),
                                  (pthread_mutex_t * __restrict  )(& coordinator->mutexEventTriggered),
                                  (struct timespec  const  * __restrict  )(& ts));
      if (rc != 0) {
        break;
      }
    }
  }
  coordinator->stopIssued = 1;
  pthread_mutex_unlock(& coordinator->mutexEventTriggered);
  t = 0;
  while (t < Count) {
    pthread_detach(*(threads + t));
    t ++;
  }
  SetEvent(& coordinator->evtCanCleanUp.__annonCompField4.event);
  free((void *)threads);
  free((void *)thread_args);
  if (rc) {
    retVal = rc;
  } else
  if (WaitAll) {
    retVal = rc;
  } else {
    retVal = (results + 0)->retVal + (results + 0)->threadIndex;
  }
  return (retVal);
}
}
#pragma merger("0","/tmp/cil-mihUaB96.i","-g,-Wall,-pthread,-std=gnu99")
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2,3))) strtok_r)(char * __restrict  __s ,
                                                                                         char const   * __restrict  __delim ,
                                                                                         char ** __restrict  __save_ptr ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) strtoul)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__nonnull__(1))) strtoull)(char const   * __restrict  __nptr ,
                                                                                                    char ** __restrict  __endptr ,
                                                                                                    int __base ) ;
_Bool GetProcessStat(pid_t pid , struct ProcessStat *proc ) ;
_Bool GetProcessStat(pid_t pid , struct ProcessStat *proc ) 
{ 
  char procFilePath[32] ;
  char fileBuffer[1024] ;
  char *token ;
  char *savePtr ;
  FILE *procFile ;
  DIR *fddir ;
  struct dirent *entry ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  unsigned long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  unsigned long tmp___12 ;
  unsigned long tmp___13 ;
  long tmp___14 ;

  {
  savePtr = (char *)((void *)0);
  procFile = (FILE *)((void *)0);
  fddir = (DIR *)((void *)0);
  entry = (struct dirent *)((void *)0);
  tmp = sprintf((char * __restrict  )(procFilePath), (char const   * __restrict  )"/proc/%d/fdinfo",
                pid);
  if (tmp < 0) {
    return ((_Bool)0);
  }
  fddir = opendir((char const   *)(procFilePath));
  if (fddir) {
    proc->num_filedescriptors = 0;
    while (1) {
      entry = readdir(fddir);
      if (! ((unsigned long )entry != (unsigned long )((void *)0))) {
        break;
      }
      (proc->num_filedescriptors) ++;
    }
    closedir(fddir);
  } else {
    Log((enum LogLevel )4, "Failed to open %s. Exiting...\n", procFilePath);
    return ((_Bool)0);
  }
  proc->num_filedescriptors -= 2;
  tmp___0 = sprintf((char * __restrict  )(procFilePath), (char const   * __restrict  )"/proc/%d/stat",
                    pid);
  if (tmp___0 < 0) {
    return ((_Bool)0);
  }
  procFile = fopen((char const   * __restrict  )(procFilePath), (char const   * __restrict  )"r");
  if ((unsigned long )procFile != (unsigned long )((void *)0)) {
    tmp___1 = fgets((char * __restrict  )(fileBuffer), (int )sizeof(fileBuffer), (FILE * __restrict  )procFile);
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      Log((enum LogLevel )4, "Failed to read from %s. Exiting...\n", procFilePath);
      fclose(procFile);
      return ((_Bool)0);
    }
    fclose(procFile);
  } else {
    Log((enum LogLevel )4, "Failed to open %s.\n", procFilePath);
    return ((_Bool)0);
  }
  tmp___2 = atoi((char const   *)(fileBuffer));
  proc->pid = tmp___2;
  savePtr = strrchr((char const   *)(fileBuffer), ')');
  if ((unsigned long )savePtr != (unsigned long )((void *)0)) {
    savePtr += 2;
    tmp___3 = strtok_r((char * __restrict  )savePtr, (char const   * __restrict  )" ",
                       (char ** __restrict  )(& savePtr));
    proc->state = *(tmp___3 + 0);
  }
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - Parent PID. %s",
              "in src/Process.c, at line 84");
    return ((_Bool)0);
  }
  tmp___4 = strtol((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                   10);
  proc->ppid = (pid_t )tmp___4;
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - Process group ID. %s",
              "in src/Process.c, at line 93");
    return ((_Bool)0);
  }
  tmp___5 = strtol((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                   10);
  proc->pgrp = (gid_t )tmp___5;
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - Session ID. %s",
              "in src/Process.c, at line 102");
    return ((_Bool)0);
  }
  tmp___6 = strtol((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                   10);
  proc->session = (int )tmp___6;
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - Controlling terminal. %s",
              "in src/Process.c, at line 111");
    return ((_Bool)0);
  }
  tmp___7 = strtol((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                   10);
  proc->tty_nr = (int )tmp___7;
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - Foreground group ID. %s",
              "in src/Process.c, at line 120");
    return ((_Bool)0);
  }
  tmp___8 = strtol((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                   10);
  proc->tpgid = (gid_t )tmp___8;
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - Kernel flags. %s",
              "in src/Process.c, at line 129");
    return ((_Bool)0);
  }
  tmp___9 = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                    10);
  proc->flags = (unsigned int )tmp___9;
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - Minflt. %s",
              "in src/Process.c, at line 138");
    return ((_Bool)0);
  }
  proc->minflt = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                         10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - cminflt. %s",
              "in src/Process.c, at line 147");
    return ((_Bool)0);
  }
  proc->cminflt = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                          10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - majflt. %s",
              "in src/Process.c, at line 156");
    return ((_Bool)0);
  }
  proc->majflt = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                         10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - cmajflt. %s",
              "in src/Process.c, at line 165");
    return ((_Bool)0);
  }
  proc->cmajflt = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                          10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - utime. %s",
              "in src/Process.c, at line 174");
    return ((_Bool)0);
  }
  proc->utime = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                        10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - stime. %s",
              "in src/Process.c, at line 183");
    return ((_Bool)0);
  }
  proc->stime = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                        10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - cutime. %s",
              "in src/Process.c, at line 192");
    return ((_Bool)0);
  }
  proc->cutime = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                         10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - cstime. %s",
              "in src/Process.c, at line 201");
    return ((_Bool)0);
  }
  proc->cstime = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                         10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - priority. %s",
              "in src/Process.c, at line 210");
    return ((_Bool)0);
  }
  proc->priority = strtol((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                          10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - nice. %s",
              "in src/Process.c, at line 219");
    return ((_Bool)0);
  }
  proc->nice = strtol((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                      10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - num_threads. %s",
              "in src/Process.c, at line 228");
    return ((_Bool)0);
  }
  proc->num_threads = strtol((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                             10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - itrealvalue. %s",
              "in src/Process.c, at line 237");
    return ((_Bool)0);
  }
  proc->itrealvalue = strtol((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                             10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - starttime. %s",
              "in src/Process.c, at line 246");
    return ((_Bool)0);
  }
  proc->starttime = strtoull((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                             10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - vsize. %s",
              "in src/Process.c, at line 255");
    return ((_Bool)0);
  }
  proc->vsize = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                        10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - rss. %s",
              "in src/Process.c, at line 264");
    return ((_Bool)0);
  }
  proc->rss = strtol((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                     10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - rsslim. %s",
              "in src/Process.c, at line 273");
    return ((_Bool)0);
  }
  proc->rsslim = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                         10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - startcode. %s",
              "in src/Process.c, at line 282");
    return ((_Bool)0);
  }
  proc->startcode = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                            10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - endcode. %s",
              "in src/Process.c, at line 291");
    return ((_Bool)0);
  }
  proc->endcode = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                          10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - startstack. %s",
              "in src/Process.c, at line 300");
    return ((_Bool)0);
  }
  proc->startstack = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                             10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - kstkesp. %s",
              "in src/Process.c, at line 309");
    return ((_Bool)0);
  }
  proc->kstkesp = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                          10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - kstkeip. %s",
              "in src/Process.c, at line 318");
    return ((_Bool)0);
  }
  proc->kstkeip = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                          10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - signal. %s",
              "in src/Process.c, at line 327");
    return ((_Bool)0);
  }
  proc->signal = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                         10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - blocked. %s",
              "in src/Process.c, at line 336");
    return ((_Bool)0);
  }
  proc->blocked = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                          10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - sigignore. %s",
              "in src/Process.c, at line 345");
    return ((_Bool)0);
  }
  proc->sigignore = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                            10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - sigcatch. %s",
              "in src/Process.c, at line 354");
    return ((_Bool)0);
  }
  proc->sigcatch = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                           10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - wchan. %s",
              "in src/Process.c, at line 363");
    return ((_Bool)0);
  }
  proc->wchan = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                        10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - nswap. %s",
              "in src/Process.c, at line 372");
    return ((_Bool)0);
  }
  proc->nswap = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                        10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - cnswap. %s",
              "in src/Process.c, at line 381");
    return ((_Bool)0);
  }
  proc->cnswap = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                         10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - exit_signal. %s",
              "in src/Process.c, at line 390");
    return ((_Bool)0);
  }
  tmp___10 = strtol((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                    10);
  proc->exit_signal = (int )tmp___10;
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - processor. %s",
              "in src/Process.c, at line 399");
    return ((_Bool)0);
  }
  tmp___11 = strtol((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                    10);
  proc->processor = (int )tmp___11;
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - rt_priority. %s",
              "in src/Process.c, at line 408");
    return ((_Bool)0);
  }
  tmp___12 = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                     10);
  proc->rt_priority = (unsigned int )tmp___12;
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - policy. %s",
              "in src/Process.c, at line 417");
    return ((_Bool)0);
  }
  tmp___13 = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                     10);
  proc->policy = (unsigned int )tmp___13;
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - delayacct_blkio_ticks. %s",
              "in src/Process.c, at line 426");
    return ((_Bool)0);
  }
  proc->delayacct_blkio_ticks = strtoull((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                                         10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - guest_time. %s",
              "in src/Process.c, at line 435");
    return ((_Bool)0);
  }
  proc->guest_time = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                             10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - cguest_time. %s",
              "in src/Process.c, at line 444");
    return ((_Bool)0);
  }
  proc->cguest_time = strtol((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                             10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - start_data. %s",
              "in src/Process.c, at line 453");
    return ((_Bool)0);
  }
  proc->start_data = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                             10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - end_data. %s",
              "in src/Process.c, at line 462");
    return ((_Bool)0);
  }
  proc->end_data = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                           10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - start_brk. %s",
              "in src/Process.c, at line 471");
    return ((_Bool)0);
  }
  proc->end_data = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                           10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - arg_start. %s",
              "in src/Process.c, at line 480");
    return ((_Bool)0);
  }
  proc->arg_start = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                            10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - arg_end. %s",
              "in src/Process.c, at line 489");
    return ((_Bool)0);
  }
  proc->arg_end = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                          10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - env_start. %s",
              "in src/Process.c, at line 498");
    return ((_Bool)0);
  }
  proc->env_start = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                            10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - env_end. %s",
              "in src/Process.c, at line 507");
    return ((_Bool)0);
  }
  proc->env_end = strtoul((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                          10);
  token = strtok_r((char * __restrict  )((void *)0), (char const   * __restrict  )" ",
                   (char ** __restrict  )(& savePtr));
  if ((unsigned long )token == (unsigned long )((void *)0)) {
    DiagTrace("GetProcessStat: failed to get token from proc/[pid]/stat - exit_code. %s",
              "in src/Process.c, at line 516");
    return ((_Bool)0);
  }
  tmp___14 = strtol((char const   * __restrict  )token, (char ** __restrict  )((void *)0),
                    10);
  proc->exit_code = (int )tmp___14;
  return ((_Bool)1);
}
}
#pragma merger("0","/tmp/cil-GAzlKcgP.i","-g,-Wall,-pthread,-std=gnu99")
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
int main(int argc , char **argv ) 
{ 
  int tmp ;
  __uid_t tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;

  {
  PrintBanner();
  InitProcDump();
  tmp = GetOptions(& g_config, argc, argv);
  if (tmp != 0) {
    DiagTrace("main: failed to parse command line arguments %s", "in src/Procdump.c, at line 21");
    exit(-1);
  }
  PrintConfiguration(& g_config);
  printf((char const   * __restrict  )"\nPress Ctrl-C to end monitoring without terminating the process.\n\n");
  tmp___0 = geteuid();
  if (tmp___0 != 0U) {
    Log((enum LogLevel )2, "Procdump not running with elevated credentials. If your uid does not match the uid of the target process procdump will not be able to capture memory dumps");
  }
  if (g_config.WaitingForProcessName) {
    tmp___1 = WaitForProcessName(& g_config);
    if ((int )tmp___1 == 0) {
      ExitProcDump();
    }
  }
  tmp___2 = CreateTriggerThreads(& g_config);
  if (tmp___2 != 0) {
    Log((enum LogLevel )4, "Internal Error has occurred. If problem continues to occur run procdump with -d flag to trace issue");
    DiagTrace("main: failed to create trigger threads. %s", "in src/Procdump.c, at line 45");
    ExitProcDump();
  }
  tmp___3 = BeginMonitoring(& g_config);
  if ((int )tmp___3 == 0) {
    Log((enum LogLevel )4, "Internal Error has occurred. If problem continues to occur run procdump with -d flag to trace issue");
    DiagTrace("main: failed to start monitoring. %s", "in src/Procdump.c, at line 51");
    ExitProcDump();
  }
  WaitForAllThreadsToTerminate(& g_config);
  ExitProcDump();
  return (0);
}
}
#pragma merger("0","/tmp/cil-uKVdWh5m.i","-g,-Wall,-pthread,-std=gnu99")
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
struct CoreDumpWriter *NewCoreDumpWriter(enum ECoreDumpType type , struct ProcDumpConfiguration *config ) ;
int WriteCoreDump(struct CoreDumpWriter *self ) ;
void *CommitMonitoringThread(void *thread_args ) 
{ 
  struct ProcDumpConfiguration *config ;
  long pageSize_kb ;
  unsigned long memUsage ;
  struct ProcessStat proc ;
  int rc ;
  struct CoreDumpWriter *writer ;
  struct CoreDumpWriter *tmp ;
  long tmp___0 ;
  _Bool tmp___1 ;

  {
  DiagTrace("CommitMonitoringThread: Starting Trigger Thread %s", "in src/TriggerThreadProcs.c, at line 16");
  config = (struct ProcDumpConfiguration *)thread_args;
  memUsage = 0UL;
  proc.pid = 0;
  proc.comm = (char *)0;
  proc.state = (char)0;
  proc.ppid = 0;
  proc.pgrp = 0U;
  proc.session = 0;
  proc.tty_nr = 0;
  proc.tpgid = 0U;
  proc.flags = 0U;
  proc.minflt = 0UL;
  proc.cminflt = 0UL;
  proc.majflt = 0UL;
  proc.cmajflt = 0UL;
  proc.utime = 0UL;
  proc.stime = 0UL;
  proc.cutime = 0UL;
  proc.cstime = 0UL;
  proc.priority = 0L;
  proc.nice = 0L;
  proc.num_threads = 0L;
  proc.itrealvalue = 0L;
  proc.starttime = 0ULL;
  proc.vsize = 0UL;
  proc.rss = 0L;
  proc.rsslim = 0UL;
  proc.startcode = 0UL;
  proc.endcode = 0UL;
  proc.startstack = 0UL;
  proc.kstkesp = 0UL;
  proc.kstkeip = 0UL;
  proc.signal = 0UL;
  proc.blocked = 0UL;
  proc.sigignore = 0UL;
  proc.sigcatch = 0UL;
  proc.wchan = 0UL;
  proc.nswap = 0UL;
  proc.cnswap = 0UL;
  proc.exit_signal = 0;
  proc.processor = 0;
  proc.rt_priority = 0U;
  proc.policy = 0U;
  proc.delayacct_blkio_ticks = 0ULL;
  proc.guest_time = 0UL;
  proc.cguest_time = 0L;
  proc.start_data = 0UL;
  proc.end_data = 0UL;
  proc.start_brk = 0UL;
  proc.arg_start = 0UL;
  proc.arg_end = 0UL;
  proc.env_start = 0UL;
  proc.env_end = 0UL;
  proc.exit_code = 0;
  proc.num_filedescriptors = 0;
  rc = 0;
  tmp = NewCoreDumpWriter((enum ECoreDumpType )0, config);
  writer = tmp;
  tmp___0 = sysconf(30);
  pageSize_kb = tmp___0 >> 10;
  rc = WaitForQuitOrEvent(config, & config->evtStartMonitoring, -1);
  if (rc == 1) {
    while (1) {
      rc = WaitForQuit(config, config->PollingInterval);
      if (! (rc == 110)) {
        break;
      }
      tmp___1 = GetProcessStat(config->ProcessId, & proc);
      if (tmp___1) {
        memUsage = (unsigned long )(proc.rss * pageSize_kb >> 10);
        memUsage += proc.nswap * (unsigned long )pageSize_kb >> 10;
        if (config->bMemoryTriggerBelowValue) {
          if (memUsage < (unsigned long )config->MemoryThreshold) {
            goto _L;
          } else {
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
        if (! config->bMemoryTriggerBelowValue) {
          if (memUsage >= (unsigned long )config->MemoryThreshold) {
            _L: /* CIL Label */ 
            Log((enum LogLevel )1, "Commit: %ld MB", memUsage);
            rc = WriteCoreDump(writer);
            rc = WaitForQuit(config, config->ThresholdSeconds * 1000);
            if (rc != 110) {
              break;
            }
          }
        }
      } else {
        Log((enum LogLevel )4, "An error occurred while parsing procfs\n");
        exit(-1);
      }
    }
  }
  free((void *)writer);
  DiagTrace("CommitMonitoringThread: Exiting Trigger Thread %s", "in src/TriggerThreadProcs.c, at line 59");
  pthread_exit((void *)0);
}
}
void *ThreadCountMonitoringThread(void *thread_args ) 
{ 
  struct ProcDumpConfiguration *config ;
  struct ProcessStat proc ;
  int rc ;
  struct CoreDumpWriter *writer ;
  struct CoreDumpWriter *tmp ;
  _Bool tmp___0 ;

  {
  DiagTrace("ThreadCountMonitoringThread: Starting Thread Thread %s", "in src/TriggerThreadProcs.c, at line 65");
  config = (struct ProcDumpConfiguration *)thread_args;
  proc.pid = 0;
  proc.comm = (char *)0;
  proc.state = (char)0;
  proc.ppid = 0;
  proc.pgrp = 0U;
  proc.session = 0;
  proc.tty_nr = 0;
  proc.tpgid = 0U;
  proc.flags = 0U;
  proc.minflt = 0UL;
  proc.cminflt = 0UL;
  proc.majflt = 0UL;
  proc.cmajflt = 0UL;
  proc.utime = 0UL;
  proc.stime = 0UL;
  proc.cutime = 0UL;
  proc.cstime = 0UL;
  proc.priority = 0L;
  proc.nice = 0L;
  proc.num_threads = 0L;
  proc.itrealvalue = 0L;
  proc.starttime = 0ULL;
  proc.vsize = 0UL;
  proc.rss = 0L;
  proc.rsslim = 0UL;
  proc.startcode = 0UL;
  proc.endcode = 0UL;
  proc.startstack = 0UL;
  proc.kstkesp = 0UL;
  proc.kstkeip = 0UL;
  proc.signal = 0UL;
  proc.blocked = 0UL;
  proc.sigignore = 0UL;
  proc.sigcatch = 0UL;
  proc.wchan = 0UL;
  proc.nswap = 0UL;
  proc.cnswap = 0UL;
  proc.exit_signal = 0;
  proc.processor = 0;
  proc.rt_priority = 0U;
  proc.policy = 0U;
  proc.delayacct_blkio_ticks = 0ULL;
  proc.guest_time = 0UL;
  proc.cguest_time = 0L;
  proc.start_data = 0UL;
  proc.end_data = 0UL;
  proc.start_brk = 0UL;
  proc.arg_start = 0UL;
  proc.arg_end = 0UL;
  proc.env_start = 0UL;
  proc.env_end = 0UL;
  proc.exit_code = 0;
  proc.num_filedescriptors = 0;
  rc = 0;
  tmp = NewCoreDumpWriter((enum ECoreDumpType )2, config);
  writer = tmp;
  rc = WaitForQuitOrEvent(config, & config->evtStartMonitoring, -1);
  if (rc == 1) {
    while (1) {
      rc = WaitForQuit(config, config->PollingInterval);
      if (! (rc == 110)) {
        break;
      }
      tmp___0 = GetProcessStat(config->ProcessId, & proc);
      if (tmp___0) {
        if (proc.num_threads >= (long )config->ThreadThreshold) {
          Log((enum LogLevel )1, "Threads: %ld", proc.num_threads);
          rc = WriteCoreDump(writer);
          rc = WaitForQuit(config, config->ThresholdSeconds * 1000);
          if (rc != 110) {
            break;
          }
        }
      } else {
        Log((enum LogLevel )4, "An error occurred while parsing procfs\n");
        exit(-1);
      }
    }
  }
  free((void *)writer);
  DiagTrace("ThreadCountMonitoringThread: Exiting Thread trigger Thread %s", "in src/TriggerThreadProcs.c, at line 98");
  pthread_exit((void *)0);
}
}
void *FileDescriptorCountMonitoringThread(void *thread_args ) 
{ 
  struct ProcDumpConfiguration *config ;
  struct ProcessStat proc ;
  int rc ;
  struct CoreDumpWriter *writer ;
  struct CoreDumpWriter *tmp ;
  _Bool tmp___0 ;

  {
  DiagTrace("FileDescriptorCountMonitoringThread: Starting Filedescriptor Thread %s",
            "in src/TriggerThreadProcs.c, at line 105");
  config = (struct ProcDumpConfiguration *)thread_args;
  proc.pid = 0;
  proc.comm = (char *)0;
  proc.state = (char)0;
  proc.ppid = 0;
  proc.pgrp = 0U;
  proc.session = 0;
  proc.tty_nr = 0;
  proc.tpgid = 0U;
  proc.flags = 0U;
  proc.minflt = 0UL;
  proc.cminflt = 0UL;
  proc.majflt = 0UL;
  proc.cmajflt = 0UL;
  proc.utime = 0UL;
  proc.stime = 0UL;
  proc.cutime = 0UL;
  proc.cstime = 0UL;
  proc.priority = 0L;
  proc.nice = 0L;
  proc.num_threads = 0L;
  proc.itrealvalue = 0L;
  proc.starttime = 0ULL;
  proc.vsize = 0UL;
  proc.rss = 0L;
  proc.rsslim = 0UL;
  proc.startcode = 0UL;
  proc.endcode = 0UL;
  proc.startstack = 0UL;
  proc.kstkesp = 0UL;
  proc.kstkeip = 0UL;
  proc.signal = 0UL;
  proc.blocked = 0UL;
  proc.sigignore = 0UL;
  proc.sigcatch = 0UL;
  proc.wchan = 0UL;
  proc.nswap = 0UL;
  proc.cnswap = 0UL;
  proc.exit_signal = 0;
  proc.processor = 0;
  proc.rt_priority = 0U;
  proc.policy = 0U;
  proc.delayacct_blkio_ticks = 0ULL;
  proc.guest_time = 0UL;
  proc.cguest_time = 0L;
  proc.start_data = 0UL;
  proc.end_data = 0UL;
  proc.start_brk = 0UL;
  proc.arg_start = 0UL;
  proc.arg_end = 0UL;
  proc.env_start = 0UL;
  proc.env_end = 0UL;
  proc.exit_code = 0;
  proc.num_filedescriptors = 0;
  rc = 0;
  tmp = NewCoreDumpWriter((enum ECoreDumpType )3, config);
  writer = tmp;
  rc = WaitForQuitOrEvent(config, & config->evtStartMonitoring, -1);
  if (rc == 1) {
    while (1) {
      rc = WaitForQuit(config, config->PollingInterval);
      if (! (rc == 110)) {
        break;
      }
      tmp___0 = GetProcessStat(config->ProcessId, & proc);
      if (tmp___0) {
        if (proc.num_filedescriptors >= config->FileDescriptorThreshold) {
          Log((enum LogLevel )1, "File descriptors: %ld", proc.num_filedescriptors);
          rc = WriteCoreDump(writer);
          rc = WaitForQuit(config, config->ThresholdSeconds * 1000);
          if (rc != 110) {
            break;
          }
        }
      } else {
        Log((enum LogLevel )4, "An error occurred while parsing procfs\n");
        exit(-1);
      }
    }
  }
  free((void *)writer);
  DiagTrace("FileDescriptorCountMonitoringThread: Exiting Filedescriptor trigger Thread %s",
            "in src/TriggerThreadProcs.c, at line 138");
  pthread_exit((void *)0);
}
}
void *SignalMonitoringThread(void *thread_args ) 
{ 
  struct ProcDumpConfiguration *config ;
  int wstatus ;
  int signum ;
  int rc ;
  struct CoreDumpWriter *writer ;
  struct CoreDumpWriter *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
  DiagTrace("SignalMonitoringThread: Starting SignalMonitoring Thread %s", "in src/TriggerThreadProcs.c, at line 154");
  config = (struct ProcDumpConfiguration *)thread_args;
  signum = -1;
  rc = 0;
  tmp = NewCoreDumpWriter((enum ECoreDumpType )4, config);
  writer = tmp;
  rc = WaitForQuitOrEvent(config, & config->evtStartMonitoring, -1);
  if (rc == 1) {
    tmp___2 = ptrace((enum __ptrace_request )16902, config->ProcessId, (void *)0,
                     (void *)0);
    if (tmp___2 == -1L) {
      Log((enum LogLevel )4, "Unable to PTRACE the target process");
    } else {
      while (1) {
        waitpid(config->ProcessId, & wstatus, 0);
        if ((wstatus & 127) == 0) {
          ptrace((enum __ptrace_request )17, config->ProcessId, 0, 0);
          break;
        } else
        if ((int )((signed char )((wstatus & 127) + 1)) >> 1 > 0) {
          ptrace((enum __ptrace_request )17, config->ProcessId, 0, 0);
          break;
        }
        pthread_mutex_lock(& ptrace_mutex);
        signum = (wstatus & 65280) >> 8;
        if (signum == config->SignalNumber) {
          tmp___0 = ptrace((enum __ptrace_request )17, config->ProcessId, 0, 19);
          if (tmp___0 == -1L) {
            Log((enum LogLevel )4, "Unable to PTRACE (DETACH) the target process");
            pthread_mutex_unlock(& ptrace_mutex);
            break;
          }
          Log((enum LogLevel )1, "Signal intercepted: %d", signum);
          rc = WriteCoreDump(writer);
          kill(config->ProcessId, 18);
          if (config->NumberOfDumpsCollected >= config->NumberOfDumpsToCollect) {
            kill(config->ProcessId, signum);
            pthread_mutex_unlock(& ptrace_mutex);
            break;
          }
          ptrace((enum __ptrace_request )7, config->ProcessId, (void *)0, signum);
          tmp___1 = ptrace((enum __ptrace_request )16902, config->ProcessId, (void *)0,
                           (void *)0);
          if (tmp___1 == -1L) {
            Log((enum LogLevel )4, "Unable to PTRACE the target process");
            pthread_mutex_unlock(& ptrace_mutex);
            break;
          }
          pthread_mutex_unlock(& ptrace_mutex);
          continue;
        }
        ptrace((enum __ptrace_request )7, config->ProcessId, (void *)0, signum);
        pthread_mutex_unlock(& ptrace_mutex);
      }
    }
  }
  free((void *)writer);
  DiagTrace("SignalMonitoringThread: Exiting SignalMonitoring Thread %s", "in src/TriggerThreadProcs.c, at line 232");
  pthread_exit((void *)0);
}
}
void *CpuMonitoringThread(void *thread_args ) 
{ 
  struct ProcDumpConfiguration *config ;
  unsigned long totalTime ;
  unsigned long elapsedTime ;
  struct sysinfo sysInfo ;
  int cpuUsage ;
  struct CoreDumpWriter *writer ;
  struct CoreDumpWriter *tmp ;
  int rc ;
  struct ProcessStat proc ;
  _Bool tmp___0 ;

  {
  DiagTrace("CpuMonitoringThread: Starting Trigger Thread %s", "in src/TriggerThreadProcs.c, at line 238");
  config = (struct ProcDumpConfiguration *)thread_args;
  totalTime = 0UL;
  elapsedTime = 0UL;
  tmp = NewCoreDumpWriter((enum ECoreDumpType )1, config);
  writer = tmp;
  rc = 0;
  proc.pid = 0;
  proc.comm = (char *)0;
  proc.state = (char)0;
  proc.ppid = 0;
  proc.pgrp = 0U;
  proc.session = 0;
  proc.tty_nr = 0;
  proc.tpgid = 0U;
  proc.flags = 0U;
  proc.minflt = 0UL;
  proc.cminflt = 0UL;
  proc.majflt = 0UL;
  proc.cmajflt = 0UL;
  proc.utime = 0UL;
  proc.stime = 0UL;
  proc.cutime = 0UL;
  proc.cstime = 0UL;
  proc.priority = 0L;
  proc.nice = 0L;
  proc.num_threads = 0L;
  proc.itrealvalue = 0L;
  proc.starttime = 0ULL;
  proc.vsize = 0UL;
  proc.rss = 0L;
  proc.rsslim = 0UL;
  proc.startcode = 0UL;
  proc.endcode = 0UL;
  proc.startstack = 0UL;
  proc.kstkesp = 0UL;
  proc.kstkeip = 0UL;
  proc.signal = 0UL;
  proc.blocked = 0UL;
  proc.sigignore = 0UL;
  proc.sigcatch = 0UL;
  proc.wchan = 0UL;
  proc.nswap = 0UL;
  proc.cnswap = 0UL;
  proc.exit_signal = 0;
  proc.processor = 0;
  proc.rt_priority = 0U;
  proc.policy = 0U;
  proc.delayacct_blkio_ticks = 0ULL;
  proc.guest_time = 0UL;
  proc.cguest_time = 0L;
  proc.start_data = 0UL;
  proc.end_data = 0UL;
  proc.start_brk = 0UL;
  proc.arg_start = 0UL;
  proc.arg_end = 0UL;
  proc.env_start = 0UL;
  proc.env_end = 0UL;
  proc.exit_code = 0;
  proc.num_filedescriptors = 0;
  rc = WaitForQuitOrEvent(config, & config->evtStartMonitoring, -1);
  if (rc == 1) {
    while (1) {
      rc = WaitForQuit(config, config->PollingInterval);
      if (! (rc == 110)) {
        break;
      }
      sysinfo(& sysInfo);
      tmp___0 = GetProcessStat(config->ProcessId, & proc);
      if (tmp___0) {
        totalTime = (proc.utime + proc.stime) / (unsigned long )HZ;
        elapsedTime = (unsigned long )(sysInfo.uptime - (long )(proc.starttime / (unsigned long long )HZ));
        cpuUsage = (int )((double )100 * ((double )totalTime / (double )elapsedTime));
        if (config->bCpuTriggerBelowValue) {
          if (cpuUsage < config->CpuThreshold) {
            goto _L;
          } else {
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
        if (! config->bCpuTriggerBelowValue) {
          if (cpuUsage >= config->CpuThreshold) {
            _L: /* CIL Label */ 
            Log((enum LogLevel )1, "CPU:\t%d%%", cpuUsage);
            rc = WriteCoreDump(writer);
            rc = WaitForQuit(config, config->ThresholdSeconds * 1000);
            if (rc != 110) {
              break;
            }
          }
        }
      } else {
        Log((enum LogLevel )4, "An error occurred while parsing procfs\n");
        exit(-1);
      }
    }
  }
  free((void *)writer);
  DiagTrace("CpuTCpuMonitoringThread: Exiting Trigger Thread %s", "in src/TriggerThreadProcs.c, at line 285");
  pthread_exit((void *)0);
}
}
void *TimerThread(void *thread_args ) 
{ 
  struct ProcDumpConfiguration *config ;
  struct CoreDumpWriter *writer ;
  struct CoreDumpWriter *tmp ;
  int rc ;

  {
  DiagTrace("TimerThread: Starting Trigger Thread %s", "in src/TriggerThreadProcs.c, at line 291");
  config = (struct ProcDumpConfiguration *)thread_args;
  tmp = NewCoreDumpWriter((enum ECoreDumpType )5, config);
  writer = tmp;
  rc = 0;
  rc = WaitForQuitOrEvent(config, & config->evtStartMonitoring, -1);
  if (rc == 1) {
    while (1) {
      rc = WaitForQuit(config, 0);
      if (! (rc == 110)) {
        break;
      }
      Log((enum LogLevel )1, "Timed:");
      rc = WriteCoreDump(writer);
      rc = WaitForQuit(config, config->ThresholdSeconds * 1000);
      if (rc != 110) {
        break;
      }
    }
  }
  free((void *)writer);
  DiagTrace("TimerThread: Exiting Trigger Thread %s", "in src/TriggerThreadProcs.c, at line 312");
  pthread_exit((void *)0);
}
}
#pragma merger("0","/tmp/cil-22GQKc4s.i","-g,-Wall,-pthread,-std=gnu99")
extern int pthread_setcanceltype(int __type , int *__oldtype ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sem_post)(sem_t *__sem ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) access)(char const   *__name ,
                                                                                   int __type ) ;
extern int close(int __fd ) ;
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
extern unsigned int sleep(unsigned int __seconds ) ;
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) execl)(char const   *__path ,
                                                                                    char const   *__arg 
                                                                                    , ...) ;
extern  __attribute__((__nothrow__)) int setpgid(__pid_t __pid , __pid_t __pgid ) ;
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2))) strtok)(char * __restrict  __s ,
                                                                                     char const   * __restrict  __delim ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
extern int pclose(FILE *__stream ) ;
char *sanitize(char *processName ) ;
static char const   *CoreDumpTypeStrings[7]  = {      "commit",      "cpu",      "thread",      "filedesc", 
        "signal",      "time",      "manual"};
_Bool GenerateCoreClrDump(char *socketName , char *dumpFileName ) ;
_Bool IsCoreClrProcess(struct CoreDumpWriter *self , char **socketName ) ;
char *GetPath(char *lineBuf ) ;
uint16_t *GetUint16(char *buffer ) ;
int WriteCoreDumpInternal(struct CoreDumpWriter *self , char *socketName ) ;
FILE *popen2(char const   *command , char const   *type , pid_t *pid ) ;
struct CoreDumpWriter *NewCoreDumpWriter(enum ECoreDumpType type , struct ProcDumpConfiguration *config ) 
{ 
  struct CoreDumpWriter *writer ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct CoreDumpWriter ));
  writer = (struct CoreDumpWriter *)tmp;
  if ((unsigned long )writer == (unsigned long )((void *)0)) {
    Log((enum LogLevel )4, "Internal Error has occurred. If problem continues to occur run procdump with -d flag to trace issue");
    DiagTrace("NewCoreDumpWriter: failed to allocate memory. %s", "in src/CoreDumpWriter.c, at line 39");
    exit(-1);
  }
  writer->Config = config;
  writer->Type = type;
  return (writer);
}
}
char *GetPath(char *lineBuf ) 
{ 
  char delim[2] ;
  char *ptr ;
  char *tmp ;
  int i ;
  size_t tmp___0 ;

  {
  delim[0] = (char )' ';
  delim[1] = (char )'\000';
  tmp = strtok((char * __restrict  )lineBuf, (char const   * __restrict  )(delim));
  ptr = tmp;
  i = 0;
  while (i < 7) {
    ptr = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )(delim));
    i ++;
  }
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
    tmp___0 = strlen((char const   *)ptr);
    *(ptr + (tmp___0 - 1UL)) = (char )'\000';
  }
  return (ptr);
}
}
_Bool IsCoreClrProcess(struct CoreDumpWriter *self , char **socketName ) 
{ 
  _Bool bRet ;
  FILE *procFile ;
  char lineBuf[4096] ;
  char tmpFolder[4096] ;
  char *prefixTmpFolder ;
  char *ptr ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;

  {
  bRet = (_Bool)0;
  *socketName = (char *)((void *)0);
  procFile = (FILE *)((void *)0);
  prefixTmpFolder = (char *)((void *)0);
  prefixTmpFolder = getenv("TMPDIR");
  if ((unsigned long )prefixTmpFolder == (unsigned long )((void *)0)) {
    snprintf((char * __restrict  )(tmpFolder), (size_t )4096, (char const   * __restrict  )"/tmp/dotnet-diagnostic-%d",
             (self->Config)->ProcessId);
  } else {
    strncpy((char * __restrict  )(tmpFolder), (char const   * __restrict  )prefixTmpFolder,
            (size_t )4096);
  }
  procFile = fopen((char const   * __restrict  )"/proc/net/unix", (char const   * __restrict  )"r");
  if ((unsigned long )procFile != (unsigned long )((void *)0)) {
    fgets((char * __restrict  )(lineBuf), (int )sizeof(lineBuf), (FILE * __restrict  )procFile);
    while (1) {
      tmp___7 = fgets((char * __restrict  )(lineBuf), 4096, (FILE * __restrict  )procFile);
      if (! ((unsigned long )tmp___7 != (unsigned long )((void *)0))) {
        break;
      }
      tmp = GetPath(lineBuf);
      ptr = tmp;
      if ((unsigned long )ptr != (unsigned long )((void *)0)) {
        tmp___5 = strlen((char const   *)(tmpFolder));
        tmp___6 = strncmp((char const   *)ptr, (char const   *)(tmpFolder), tmp___5);
        if (tmp___6 == 0) {
          tmp___0 = strlen((char const   *)ptr);
          tmp___1 = malloc(sizeof(char ) * tmp___0 + 1UL);
          *socketName = (char *)tmp___1;
          if ((unsigned long )*socketName != (unsigned long )((void *)0)) {
            tmp___2 = strlen((char const   *)ptr);
            memset((void *)*socketName, 0, sizeof(char ) * tmp___2 + 1UL);
            tmp___3 = strlen((char const   *)ptr);
            tmp___4 = strncpy((char * __restrict  )*socketName, (char const   * __restrict  )ptr,
                              sizeof(char ) * tmp___3 + 1UL);
            if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
              DiagTrace("CoreCLR diagnostics socket: %s %s", socketName, "in src/CoreDumpWriter.c, at line 140");
              bRet = (_Bool)1;
            }
            break;
          }
        }
      }
    }
  } else {
    tmp___8 = __errno_location();
    DiagTrace("Failed to open /proc/net/unix [%d]. %s", *tmp___8, "in src/CoreDumpWriter.c, at line 151");
  }
  if ((unsigned long )procFile != (unsigned long )((void *)0)) {
    fclose(procFile);
    procFile = (FILE *)((void *)0);
  }
  if ((unsigned long )*socketName != (unsigned long )((void *)0)) {
    if ((int )bRet == 0) {
      free((void *)*socketName);
      *socketName = (char *)((void *)0);
    }
  }
  return (bRet);
}
}
int WriteCoreDump(struct CoreDumpWriter *self ) 
{ 
  int rc ;
  int tmp ;
  char *socketName ;
  int tmp___0 ;
  int tmp___1 ;

  {
  rc = 0;
  rc = WaitForQuitOrEvent(self->Config, & (self->Config)->semAvailableDumpSlots, -1);
  if (rc == 0) {
    Log((enum LogLevel )4, "Internal Error has occurred. If problem continues to occur run procdump with -d flag to trace issue");
    DiagTrace("WriteCoreDump: failed WaitForQuitOrEvent. %s", "in src/CoreDumpWriter.c, at line 189");
    exit(-1);
  }
  tmp = pthread_setcanceltype(0, (int *)((void *)0));
  if (tmp != 0) {
    Log((enum LogLevel )4, "Internal Error has occurred. If problem continues to occur run procdump with -d flag to trace issue");
    DiagTrace("WriteCoreDump: failed pthread_setcanceltype. %s", "in src/CoreDumpWriter.c, at line 194");
    exit(-1);
  }
  switch (rc) {
  case 0: 
  break;
  case 1: 
  socketName = (char *)((void *)0);
  IsCoreClrProcess(self, & socketName);
  rc = WriteCoreDumpInternal(self, socketName);
  if (rc == 0) {
    tmp___0 = sem_post(& (self->Config)->semAvailableDumpSlots.__annonCompField4.semaphore);
    if (tmp___0 == -1) {
      Log((enum LogLevel )4, "Internal Error has occurred. If problem continues to occur run procdump with -d flag to trace issue");
      DiagTrace("WriteCoreDump: failed sem_post. %s", "in src/CoreDumpWriter.c, at line 208");
      if (socketName) {
        free((void *)socketName);
      }
      exit(-1);
    }
  }
  if (socketName) {
    free((void *)socketName);
  }
  break;
  case 128: 
  break;
  default: 
  DiagTrace("WriteCoreDump: Error in default case %s", "in src/CoreDumpWriter.c, at line 219");
  break;
  }
  tmp___1 = pthread_setcanceltype(1, (int *)((void *)0));
  if (tmp___1 != 0) {
    Log((enum LogLevel )4, "Internal Error has occurred. If problem continues to occur run procdump with -d flag to trace issue");
    DiagTrace("WriteCoreDump: failed pthread_setcanceltype. %s", "in src/CoreDumpWriter.c, at line 224");
    exit(-1);
  }
  return (rc);
}
}
uint16_t *GetUint16(char *buffer ) 
{ 
  uint16_t *dumpFileNameW ;
  size_t tmp ;
  void *tmp___0 ;
  int i ;
  size_t tmp___1 ;

  {
  dumpFileNameW = (uint16_t *)((void *)0);
  if ((unsigned long )buffer != (unsigned long )((void *)0)) {
    tmp = strlen((char const   *)buffer);
    tmp___0 = malloc((tmp + 1UL) * sizeof(uint16_t ));
    dumpFileNameW = (uint16_t *)tmp___0;
    i = 0;
    while (1) {
      tmp___1 = strlen((char const   *)buffer);
      if (! ((size_t )i < tmp___1 + 1UL)) {
        break;
      }
      *(dumpFileNameW + i) = (uint16_t )*(buffer + i);
      i ++;
    }
  }
  return (dumpFileNameW);
}
}
_Bool GenerateCoreClrDump(char *socketName , char *dumpFileName ) 
{ 
  _Bool bRet ;
  struct sockaddr_un addr ;
  int fd ;
  uint16_t *dumpFileNameW ;
  void *temp_buffer ;
  unsigned int dumpFileNameLen ;
  size_t tmp ;
  int payloadSize ;
  unsigned int dumpType ;
  unsigned int diagnostics ;
  uint16_t totalPacketSize ;
  struct IpcHeader dumpHeader ;
  void *temp_buffer_cur ;
  int *tmp___0 ;
  struct IpcHeader retHeader ;
  int *tmp___1 ;
  int32_t res ;
  int *tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;
  int tmp___6 ;

  {
  bRet = (_Bool)0;
  addr.sun_family = (sa_family_t )0;
  addr.sun_path[0] = (char)0;
  addr.sun_path[1] = (char)0;
  addr.sun_path[2] = (char)0;
  addr.sun_path[3] = (char)0;
  addr.sun_path[4] = (char)0;
  addr.sun_path[5] = (char)0;
  addr.sun_path[6] = (char)0;
  addr.sun_path[7] = (char)0;
  addr.sun_path[8] = (char)0;
  addr.sun_path[9] = (char)0;
  addr.sun_path[10] = (char)0;
  addr.sun_path[11] = (char)0;
  addr.sun_path[12] = (char)0;
  addr.sun_path[13] = (char)0;
  addr.sun_path[14] = (char)0;
  addr.sun_path[15] = (char)0;
  addr.sun_path[16] = (char)0;
  addr.sun_path[17] = (char)0;
  addr.sun_path[18] = (char)0;
  addr.sun_path[19] = (char)0;
  addr.sun_path[20] = (char)0;
  addr.sun_path[21] = (char)0;
  addr.sun_path[22] = (char)0;
  addr.sun_path[23] = (char)0;
  addr.sun_path[24] = (char)0;
  addr.sun_path[25] = (char)0;
  addr.sun_path[26] = (char)0;
  addr.sun_path[27] = (char)0;
  addr.sun_path[28] = (char)0;
  addr.sun_path[29] = (char)0;
  addr.sun_path[30] = (char)0;
  addr.sun_path[31] = (char)0;
  addr.sun_path[32] = (char)0;
  addr.sun_path[33] = (char)0;
  addr.sun_path[34] = (char)0;
  addr.sun_path[35] = (char)0;
  addr.sun_path[36] = (char)0;
  addr.sun_path[37] = (char)0;
  addr.sun_path[38] = (char)0;
  addr.sun_path[39] = (char)0;
  addr.sun_path[40] = (char)0;
  addr.sun_path[41] = (char)0;
  addr.sun_path[42] = (char)0;
  addr.sun_path[43] = (char)0;
  addr.sun_path[44] = (char)0;
  addr.sun_path[45] = (char)0;
  addr.sun_path[46] = (char)0;
  addr.sun_path[47] = (char)0;
  addr.sun_path[48] = (char)0;
  addr.sun_path[49] = (char)0;
  addr.sun_path[50] = (char)0;
  addr.sun_path[51] = (char)0;
  addr.sun_path[52] = (char)0;
  addr.sun_path[53] = (char)0;
  addr.sun_path[54] = (char)0;
  addr.sun_path[55] = (char)0;
  addr.sun_path[56] = (char)0;
  addr.sun_path[57] = (char)0;
  addr.sun_path[58] = (char)0;
  addr.sun_path[59] = (char)0;
  addr.sun_path[60] = (char)0;
  addr.sun_path[61] = (char)0;
  addr.sun_path[62] = (char)0;
  addr.sun_path[63] = (char)0;
  addr.sun_path[64] = (char)0;
  addr.sun_path[65] = (char)0;
  addr.sun_path[66] = (char)0;
  addr.sun_path[67] = (char)0;
  addr.sun_path[68] = (char)0;
  addr.sun_path[69] = (char)0;
  addr.sun_path[70] = (char)0;
  addr.sun_path[71] = (char)0;
  addr.sun_path[72] = (char)0;
  addr.sun_path[73] = (char)0;
  addr.sun_path[74] = (char)0;
  addr.sun_path[75] = (char)0;
  addr.sun_path[76] = (char)0;
  addr.sun_path[77] = (char)0;
  addr.sun_path[78] = (char)0;
  addr.sun_path[79] = (char)0;
  addr.sun_path[80] = (char)0;
  addr.sun_path[81] = (char)0;
  addr.sun_path[82] = (char)0;
  addr.sun_path[83] = (char)0;
  addr.sun_path[84] = (char)0;
  addr.sun_path[85] = (char)0;
  addr.sun_path[86] = (char)0;
  addr.sun_path[87] = (char)0;
  addr.sun_path[88] = (char)0;
  addr.sun_path[89] = (char)0;
  addr.sun_path[90] = (char)0;
  addr.sun_path[91] = (char)0;
  addr.sun_path[92] = (char)0;
  addr.sun_path[93] = (char)0;
  addr.sun_path[94] = (char)0;
  addr.sun_path[95] = (char)0;
  addr.sun_path[96] = (char)0;
  addr.sun_path[97] = (char)0;
  addr.sun_path[98] = (char)0;
  addr.sun_path[99] = (char)0;
  addr.sun_path[100] = (char)0;
  addr.sun_path[101] = (char)0;
  addr.sun_path[102] = (char)0;
  addr.sun_path[103] = (char)0;
  addr.sun_path[104] = (char)0;
  addr.sun_path[105] = (char)0;
  addr.sun_path[106] = (char)0;
  addr.sun_path[107] = (char)0;
  fd = 0;
  dumpFileNameW = (uint16_t *)((void *)0);
  temp_buffer = (void *)0;
  dumpFileNameW = GetUint16(dumpFileName);
  if ((unsigned long )dumpFileNameW != (unsigned long )((void *)0)) {
    fd = socket(1, 1, 0);
    if (fd == -1) {
      DiagTrace("Failed to create socket for .NET Core dump generation. %s", "in src/CoreDumpWriter.c, at line 276");
    } else {
      memset((void *)(& addr), 0, sizeof(struct sockaddr_un ));
      addr.sun_family = (sa_family_t )1;
      strncpy((char * __restrict  )(addr.sun_path), (char const   * __restrict  )socketName,
              sizeof(addr.sun_path) - 1UL);
      tmp___6 = connect(fd, (struct sockaddr  const  *)((struct sockaddr *)(& addr)),
                        (socklen_t )sizeof(struct sockaddr_un ));
      if (tmp___6 == -1) {
        DiagTrace("Failed to connect to socket for .NET Core dump generation. %s",
                  "in src/CoreDumpWriter.c, at line 287");
      } else {
        tmp = strlen((char const   *)dumpFileName);
        dumpFileNameLen = (unsigned int )(tmp + 1UL);
        payloadSize = (int )sizeof(dumpFileNameLen);
        payloadSize = (int )((unsigned long )payloadSize + (unsigned long )dumpFileNameLen * sizeof(wchar_t ));
        dumpType = 4U;
        payloadSize = (int )((unsigned long )payloadSize + sizeof(dumpType));
        diagnostics = 0U;
        payloadSize = (int )((unsigned long )payloadSize + sizeof(diagnostics));
        totalPacketSize = (uint16_t )(sizeof(struct IpcHeader ) + (unsigned long )payloadSize);
        temp_buffer = malloc((size_t )totalPacketSize);
        if ((unsigned long )temp_buffer != (unsigned long )((void *)0)) {
          memset(temp_buffer, 0, (size_t )totalPacketSize);
          dumpHeader.__annonCompField6._magic.Magic[0] = (uint8_t )'D';
          dumpHeader.__annonCompField6._magic.Magic[1] = (uint8_t )'O';
          dumpHeader.__annonCompField6._magic.Magic[2] = (uint8_t )'T';
          dumpHeader.__annonCompField6._magic.Magic[3] = (uint8_t )'N';
          dumpHeader.__annonCompField6._magic.Magic[4] = (uint8_t )'E';
          dumpHeader.__annonCompField6._magic.Magic[5] = (uint8_t )'T';
          dumpHeader.__annonCompField6._magic.Magic[6] = (uint8_t )'_';
          dumpHeader.__annonCompField6._magic.Magic[7] = (uint8_t )'I';
          dumpHeader.__annonCompField6._magic.Magic[8] = (uint8_t )'P';
          dumpHeader.__annonCompField6._magic.Magic[9] = (uint8_t )'C';
          dumpHeader.__annonCompField6._magic.Magic[10] = (uint8_t )'_';
          dumpHeader.__annonCompField6._magic.Magic[11] = (uint8_t )'V';
          dumpHeader.__annonCompField6._magic.Magic[12] = (uint8_t )'1';
          dumpHeader.__annonCompField6._magic.Magic[13] = (uint8_t )'\000';
          dumpHeader.Size = totalPacketSize;
          dumpHeader.CommandSet = (uint8_t )1;
          dumpHeader.CommandId = (uint8_t )1;
          dumpHeader.Reserved = (uint16_t )0;
          temp_buffer_cur = temp_buffer;
          memcpy((void * __restrict  )temp_buffer_cur, (void const   * __restrict  )(& dumpHeader),
                 sizeof(struct IpcHeader ));
          temp_buffer_cur += sizeof(struct IpcHeader );
          memcpy((void * __restrict  )temp_buffer_cur, (void const   * __restrict  )(& dumpFileNameLen),
                 sizeof(dumpFileNameLen));
          temp_buffer_cur += sizeof(dumpFileNameLen);
          memcpy((void * __restrict  )temp_buffer_cur, (void const   * __restrict  )dumpFileNameW,
                 (unsigned long )dumpFileNameLen * sizeof(uint16_t ));
          temp_buffer_cur += (unsigned long )dumpFileNameLen * sizeof(uint16_t );
          memcpy((void * __restrict  )temp_buffer_cur, (void const   * __restrict  )(& dumpType),
                 sizeof(unsigned int ));
          temp_buffer_cur += sizeof(unsigned int );
          memcpy((void * __restrict  )temp_buffer_cur, (void const   * __restrict  )(& diagnostics),
                 sizeof(unsigned int ));
          tmp___5 = send(fd, (void const   *)temp_buffer, (size_t )totalPacketSize,
                         0);
          if (tmp___5 == -1L) {
            tmp___0 = __errno_location();
            DiagTrace("Failed sending packet to diagnostics server [%d] %s", *tmp___0,
                      "in src/CoreDumpWriter.c, at line 336");
          } else {
            tmp___4 = recv(fd, (void *)(& retHeader), sizeof(struct IpcHeader ), 0);
            if (tmp___4 == -1L) {
              tmp___1 = __errno_location();
              DiagTrace("Failed receiving response header from diagnostics server [%d] %s",
                        *tmp___1, "in src/CoreDumpWriter.c, at line 344");
            } else
            if ((int )retHeader.Size != 24) {
              DiagTrace("Failed validating header size in response header from diagnostics server [%d != 24] %s",
                        (int )retHeader.Size, "in src/CoreDumpWriter.c, at line 351");
            } else {
              res = -1;
              tmp___3 = recv(fd, (void *)(& res), sizeof(int32_t ), 0);
              if (tmp___3 == -1L) {
                tmp___2 = __errno_location();
                DiagTrace("Failed receiving result code from response payload from diagnostics server [%d] %s",
                          *tmp___2, "in src/CoreDumpWriter.c, at line 359");
              } else
              if (res == 0) {
                bRet = (_Bool)1;
              }
            }
          }
        }
      }
    }
  }
  if ((unsigned long )temp_buffer != (unsigned long )((void *)0)) {
    free(temp_buffer);
    temp_buffer = (void *)0;
  }
  if (fd != 0) {
    close(fd);
    fd = 0;
  }
  if ((unsigned long )dumpFileNameW != (unsigned long )((void *)0)) {
    free((void *)dumpFileNameW);
    dumpFileNameW = (uint16_t *)((void *)0);
  }
  return (bRet);
}
}
int WriteCoreDumpInternal(struct CoreDumpWriter *self , char *socketName ) 
{ 
  char date[26] ;
  char command[1024] ;
  char **outputBuffer ;
  char lineBuffer[1024] ;
  char gcorePrefixName[1024] ;
  char coreDumpFileName[1024] ;
  int lineLength ;
  int i ;
  int rc ;
  time_t rawTime ;
  pid_t gcorePid ;
  struct tm *timerInfo ;
  FILE *commandPipe ;
  char const   *desc ;
  char *name ;
  char *tmp ;
  pid_t pid ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  _Bool tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  int j ;
  char *tmp___10 ;
  int j___0 ;
  int ret ;
  int tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;

  {
  rc = 0;
  timerInfo = (struct tm *)((void *)0);
  commandPipe = (FILE *)((void *)0);
  desc = CoreDumpTypeStrings[self->Type];
  tmp = sanitize((self->Config)->ProcessName);
  name = tmp;
  pid = (self->Config)->ProcessId;
  tmp___0 = malloc(sizeof(char *) * 15UL);
  outputBuffer = (char **)tmp___0;
  if ((unsigned long )outputBuffer == (unsigned long )((void *)0)) {
    Log((enum LogLevel )4, "Internal Error has occurred. If problem continues to occur run procdump with -d flag to trace issue");
    DiagTrace("WriteCoreDumpInternal: failed gcore output buffer allocation %s", "in src/CoreDumpWriter.c, at line 428");
    exit(-1);
  }
  rawTime = time((time_t *)((void *)0));
  timerInfo = localtime((time_t const   *)(& rawTime));
  if ((unsigned long )timerInfo == (unsigned long )((void *)0)) {
    Log((enum LogLevel )4, "Internal Error has occurred. If problem continues to occur run procdump with -d flag to trace issue");
    DiagTrace("WriteCoreDumpInternal: failed localtime %s", "in src/CoreDumpWriter.c, at line 436");
    exit(-1);
  }
  strftime((char * __restrict  )(date), (size_t )26, (char const   * __restrict  )"%Y-%m-%d_%H:%M:%S",
           (struct tm  const  * __restrict  )timerInfo);
  if ((unsigned long )(self->Config)->CoreDumpName != (unsigned long )((void *)0)) {
    tmp___1 = snprintf((char * __restrict  )(gcorePrefixName), (size_t )1024, (char const   * __restrict  )"%s/%s_%d",
                       (self->Config)->CoreDumpPath, (self->Config)->CoreDumpName,
                       (self->Config)->NumberOfDumpsCollected);
    if (tmp___1 < 0) {
      Log((enum LogLevel )4, "Internal Error has occurred. If problem continues to occur run procdump with -d flag to trace issue");
      DiagTrace("WriteCoreDumpInternal: failed sprintf custom output file name %s",
                "in src/CoreDumpWriter.c, at line 448");
      exit(-1);
    }
  } else {
    tmp___2 = snprintf((char * __restrict  )(gcorePrefixName), (size_t )1024, (char const   * __restrict  )"%s/%s_%s_%s",
                       (self->Config)->CoreDumpPath, name, desc, date);
    if (tmp___2 < 0) {
      Log((enum LogLevel )4, "Internal Error has occurred. If problem continues to occur run procdump with -d flag to trace issue");
      DiagTrace("WriteCoreDumpInternal: failed sprintf default output file name %s",
                "in src/CoreDumpWriter.c, at line 455");
      exit(-1);
    }
  }
  tmp___3 = snprintf((char * __restrict  )(command), (size_t )1024, (char const   * __restrict  )"gcore -o %s %d 2>&1",
                     gcorePrefixName, pid);
  if (tmp___3 < 0) {
    Log((enum LogLevel )4, "Internal Error has occurred. If problem continues to occur run procdump with -d flag to trace issue");
    DiagTrace("WriteCoreDumpInternal: failed sprintf gcore command %s", "in src/CoreDumpWriter.c, at line 463");
    exit(-1);
  }
  tmp___4 = snprintf((char * __restrict  )(coreDumpFileName), (size_t )1024, (char const   * __restrict  )"%s.%d",
                     gcorePrefixName, pid);
  if (tmp___4 < 0) {
    Log((enum LogLevel )4, "Internal Error has occurred. If problem continues to occur run procdump with -d flag to trace issue");
    DiagTrace("WriteCoreDumpInternal: failed sprintf core file name %s", "in src/CoreDumpWriter.c, at line 470");
    exit(-1);
  }
  tmp___5 = access((char const   *)(self->Config)->CoreDumpPath, 2);
  if (tmp___5 < 0) {
    Log((enum LogLevel )4, "Internal Error has occurred. If problem continues to occur run procdump with -d flag to trace issue");
    DiagTrace("WriteCoreDumpInternal: no write permission to core dump target file %s %s",
              coreDumpFileName, "in src/CoreDumpWriter.c, at line 478");
    exit(-1);
  }
  if ((unsigned long )socketName != (unsigned long )((void *)0)) {
    tmp___6 = GenerateCoreClrDump(socketName, coreDumpFileName);
    if ((int )tmp___6 == 0) {
      Log((enum LogLevel )4, "An error occurred while generating the core dump for .NET 3.x+ process");
    } else {
      Log((enum LogLevel )1, "Core dump %d generated: %s", (self->Config)->NumberOfDumpsCollected,
          coreDumpFileName);
      ((self->Config)->NumberOfDumpsCollected) ++;
      if ((self->Config)->NumberOfDumpsCollected >= (self->Config)->NumberOfDumpsToCollect) {
        SetEvent(& (self->Config)->evtQuit.__annonCompField4.event);
        rc = 1;
      }
    }
    free((void *)outputBuffer);
  } else {
    commandPipe = popen2((char const   *)(command), "r", & gcorePid);
    (self->Config)->gcorePid = gcorePid;
    if ((unsigned long )commandPipe == (unsigned long )((void *)0)) {
      Log((enum LogLevel )4, "An error occurred while generating the core dump");
      DiagTrace("WriteCoreDumpInternal: Failed to open pipe to gcore %s", "in src/CoreDumpWriter.c, at line 512");
      exit(1);
    }
    i = 0;
    while (1) {
      if (i < 15) {
        tmp___9 = fgets((char * __restrict  )(lineBuffer), (int )sizeof(lineBuffer),
                        (FILE * __restrict  )commandPipe);
        if (! ((unsigned long )tmp___9 != (unsigned long )((void *)0))) {
          break;
        }
      } else {
        break;
      }
      tmp___7 = strlen((char const   *)(lineBuffer));
      lineLength = (int )tmp___7;
      tmp___8 = malloc(sizeof(char ) * (unsigned long )lineLength);
      *(outputBuffer + i) = (char *)tmp___8;
      if ((unsigned long )*(outputBuffer + i) != (unsigned long )((void *)0)) {
        strncpy((char * __restrict  )*(outputBuffer + i), (char const   * __restrict  )(lineBuffer),
                (size_t )(lineLength - 1));
        *(*(outputBuffer + i) + (lineLength - 1)) = (char )'\000';
      } else {
        Log((enum LogLevel )4, "Internal Error has occurred. If problem continues to occur run procdump with -d flag to trace issue");
        DiagTrace("WriteCoreDumpInternal: failed to allocate gcore error message buffer %s",
                  "in src/CoreDumpWriter.c, at line 527");
        exit(-1);
      }
      i ++;
    }
    (self->Config)->gcorePid = 2147483647;
    pclose(commandPipe);
    tmp___10 = strstr((char const   *)*(outputBuffer + (i - 1)), "gcore: failed");
    if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
      Log((enum LogLevel )4, "An error occurred while generating the core dump");
      j = 0;
      while (j < i) {
        if ((unsigned long )*(outputBuffer + j) != (unsigned long )((void *)0)) {
          Log((enum LogLevel )4, "GCORE - %s", *(outputBuffer + j));
        }
        j ++;
      }
      exit(1);
    }
    j___0 = 0;
    while (j___0 < i) {
      free((void *)*(outputBuffer + j___0));
      j___0 ++;
    }
    free((void *)outputBuffer);
    sleep(1U);
    tmp___13 = access((char const   *)(coreDumpFileName), 0);
    if (tmp___13 != -1) {
      if ((self->Config)->nQuit) {
        tmp___11 = unlink((char const   *)(coreDumpFileName));
        ret = tmp___11;
        if (ret < 0) {
          tmp___12 = __errno_location();
          if (*tmp___12 != 2) {
            DiagTrace("WriteCoreDumpInternal: Failed to remove partial core dump %s",
                      "in src/CoreDumpWriter.c, at line 564");
            exit(-1);
          }
        }
      } else {
        Log((enum LogLevel )1, "Core dump %d generated: %s", (self->Config)->NumberOfDumpsCollected,
            coreDumpFileName);
        ((self->Config)->NumberOfDumpsCollected) ++;
        if ((self->Config)->NumberOfDumpsCollected >= (self->Config)->NumberOfDumpsToCollect) {
          SetEvent(& (self->Config)->evtQuit.__annonCompField4.event);
          rc = 1;
        }
      }
    }
  }
  free((void *)name);
  return (rc);
}
}
FILE *popen2(char const   *command , char const   *type , pid_t *pid ) 
{ 
  int pipefd[2] ;
  pid_t childPid ;
  int tmp ;
  FILE *tmp___0 ;
  FILE *tmp___1 ;

  {
  tmp = pipe((int *)(pipefd));
  if (tmp == -1) {
    Log((enum LogLevel )4, "Internal Error has occurred. If problem continues to occur run procdump with -d flag to trace issue");
    DiagTrace("popen2: unable to open pipe %s", "in src/CoreDumpWriter.c, at line 605");
    exit(-1);
  }
  childPid = fork();
  if (childPid == -1) {
    Log((enum LogLevel )4, "Internal Error has occurred. If problem continues to occur run procdump with -d flag to trace issue");
    DiagTrace("popen2: unable to fork process %s", "in src/CoreDumpWriter.c, at line 612");
    exit(-1);
  }
  if (childPid == 0) {
    setpgid(0, 0);
    if ((int const   )*(type + 0) == 114) {
      close(pipefd[0]);
      dup2(pipefd[1], 1);
    } else {
      close(pipefd[1]);
      dup2(pipefd[0], 0);
    }
    execl("/bin/bash", "bash", "-c", command, (char *)((void *)0));
    return ((FILE *)((void *)0));
  } else {
    setpgid(childPid, childPid);
    *pid = childPid;
    if ((int const   )*(type + 0) == 114) {
      close(pipefd[1]);
      tmp___0 = fdopen(pipefd[0], "r");
      return (tmp___0);
    } else {
      close(pipefd[0]);
      tmp___1 = fdopen(pipefd[1], "w");
      return (tmp___1);
    }
  }
}
}
char *sanitize(char *processName ) 
{ 
  char *sanitizedProcessName ;
  char *tmp ;
  int i ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;

  {
  if ((unsigned long )processName == (unsigned long )((void *)0)) {
    Log((enum LogLevel )4, "NULL process name.\n");
    exit(-1);
  }
  tmp = strdup((char const   *)processName);
  sanitizedProcessName = tmp;
  i = 0;
  while (1) {
    tmp___1 = strlen((char const   *)sanitizedProcessName);
    if (! ((size_t )i < tmp___1)) {
      break;
    }
    tmp___0 = __ctype_b_loc();
    if (! ((int const   )*(*tmp___0 + (int )*(sanitizedProcessName + i)) & 8)) {
      *(sanitizedProcessName + i) = (char )'_';
    }
    i ++;
  }
  return (sanitizedProcessName);
}
}
