/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */
#include <pthread.h>
#include <signal.h>
#include <sys/sysinfo.h>
#include <unistd.h>
#include <semaphore.h>
#include <stdarg.h>
#include <stdio.h>
#include <pthread.h>
#include <time.h>
#include <stdlib.h>
#include <syslog.h>
#include <string.h>
#include <sys/stat.h>








typedef unsigned short __u16;
typedef unsigned int __u32;
typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;
struct sysinfo {
   __kernel_long_t uptime ;
   __kernel_ulong_t loads[3] ;
   __kernel_ulong_t totalram ;
   __kernel_ulong_t freeram ;
   __kernel_ulong_t sharedram ;
   __kernel_ulong_t bufferram ;
   __kernel_ulong_t totalswap ;
   __kernel_ulong_t freeswap ;
   __u16 procs ;
   __u16 pad ;
   __kernel_ulong_t totalhigh ;
   __kernel_ulong_t freehigh ;
   __u32 mem_unit ;
   char _f[(20UL - 2UL * sizeof(__kernel_ulong_t )) - sizeof(__u32 )] ;
};

struct Event {
   pthread_mutex_t mutex ;
   pthread_cond_t cond ;
   _Bool bTriggered ;
   _Bool bManualReset ;
   char Name[64] ;
   int nWaiters ;
};
enum EHandleType {
    EVENT = 0,
    SEMAPHORE = 1
} ;
union __anonunion____missing_field_name_654135139 {
   struct Event event ;
   sem_t semaphore ;
};
struct Handle {
   union __anonunion____missing_field_name_654135139 __annonCompField4 ;
   enum EHandleType type ;
};
struct ProcDumpConfiguration ;
struct ProcDumpConfiguration {
   pid_t ProcessId ;
   char *ProcessName ;
   struct sysinfo SystemInfo ;
   int NumberOfDumpsCollecting ;
   int NumberOfDumpsCollected ;
   _Bool bTerminated ;
   int nQuit ;
   struct Handle evtQuit ;
   _Bool bTriggerThenSnoozeCPU ;
   _Bool bTriggerThenSnoozeMemory ;
   _Bool bTriggerThenSnoozeTimer ;
   int CpuThreshold ;
   _Bool bCpuTriggerBelowValue ;
   int MemoryThreshold ;
   _Bool bMemoryTriggerBelowValue ;
   int ThresholdSeconds ;
   _Bool bTimerThreshold ;
   int NumberOfDumpsToCollect ;
   _Bool WaitingForProcessName ;
   _Bool DiagnosticsLoggingEnabled ;
   int ThreadThreshold ;
   int FileDescriptorThreshold ;
   int SignalNumber ;
   int PollingInterval ;
   char *CoreDumpPath ;
   char *CoreDumpName ;
   int nThreads ;
   pthread_t Threads[3] ;
   struct Handle semAvailableDumpSlots ;
   struct Handle evtCtrlHandlerCleanupComplete ;

   struct Handle evtConfigurationPrinted ;
   struct Handle evtDebugThreadInitialized ;
   struct Handle evtStartMonitoring ;
   pid_t gcorePid ;
};

typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __syscall_slong_t;

struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};

struct thread_result {
   int retVal ;
   int threadIndex ;
};
struct coordinator {
   pthread_cond_t condEventTriggered ;
   pthread_mutex_t mutexEventTriggered ;
   struct thread_result *results ;
   int numberTriggered ;
   int nWaiters ;
   int stopIssued ;
   struct Handle evtCanCleanUp ;
   struct Handle evtStartWaiting ;
};
struct thread_args {
   struct Handle *handle ;
   struct coordinator *coordinator ;
   int milliseconds ;
   int retVal ;
   int threadIndex ;
};

typedef __gid_t gid_t;
struct ProcessStat {
   pid_t pid ;
   char *comm ;
   char state ;
   pid_t ppid ;
   gid_t pgrp ;
   int session ;
   int tty_nr ;
   gid_t tpgid ;
   unsigned int flags ;
   unsigned long minflt ;
   unsigned long cminflt ;
   unsigned long majflt ;
   unsigned long cmajflt ;
   unsigned long utime ;
   unsigned long stime ;
   unsigned long cutime ;
   unsigned long cstime ;
   long priority ;
   long nice ;
   long num_threads ;
   long itrealvalue ;
   unsigned long long starttime ;
   unsigned long vsize ;
   long rss ;
   unsigned long rsslim ;
   unsigned long startcode ;
   unsigned long endcode ;
   unsigned long startstack ;
   unsigned long kstkesp ;
   unsigned long kstkeip ;
   unsigned long signal ;
   unsigned long blocked ;
   unsigned long sigignore ;
   unsigned long sigcatch ;
   unsigned long wchan ;
   unsigned long nswap ;
   unsigned long cnswap ;
   int exit_signal ;
   int processor ;
   unsigned int rt_priority ;
   unsigned int policy ;
   unsigned long long delayacct_blkio_ticks ;
   unsigned long guest_time ;
   long cguest_time ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   int exit_code ;
   int num_filedescriptors ;
};

struct ProcDumpConfiguration g_config ;
pthread_mutex_t LoggerLock  ;
void DestroyEvent(struct Event *Event ) ;
_Bool SetEvent(struct Event *Event ) ;


void DestroyEvent(struct Event *Event ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  tmp = pthread_cond_destroy(& Event->cond);
  tmp___0 = pthread_mutex_destroy(& Event->mutex);
  return;
}
}
_Bool SetEvent(struct Event *Event ) 
{ 
  int success ;

  {
  success = 0;
  success = pthread_mutex_lock(& Event->mutex);
  if (success == 0) {
    Event->bTriggered = (_Bool)1;
    if (Event->bManualReset) {
      pthread_cond_broadcast(& Event->cond);
    } else {
      pthread_cond_signal(& Event->cond);
    }
    pthread_mutex_unlock(& Event->mutex);
  } else {
    exit(-1);
  }
  return ((_Bool )(success == 0));
}
}

#pragma merger("0","/tmp/cil-hxpzm858.i","-g,-Wall,-pthread,-std=gnu99")

extern char *optarg ;

int WaitForSingleObject(struct Handle *Handle , int Milliseconds ) ;
int WaitForMultipleObjects(int Count , struct Handle **Handles , _Bool WaitAll , int Milliseconds ) ;
void *CpuMonitoringThread(void *thread_args ) ;
void *TimerThread(void *thread_args ) ;
int GetOptions(struct ProcDumpConfiguration *self , int argc , char **argv ) ;
int CreateTriggerThreads(struct ProcDumpConfiguration *self ) ;
int WaitForQuit(struct ProcDumpConfiguration *self , int milliseconds ) ;
int WaitForQuitOrEvent(struct ProcDumpConfiguration *self , struct Handle *handle ,
                       int milliseconds ) ;
int WaitForAllThreadsToTerminate(struct ProcDumpConfiguration *self ) ;
_Bool ContinueMonitoring(struct ProcDumpConfiguration *self ) ;
void FreeProcDumpConfiguration(struct ProcDumpConfiguration *self ) ;
void InitProcDumpConfiguration(struct ProcDumpConfiguration *self ) ;
void InitProcDump(void) ;
void ExitProcDump(void) ;
struct Handle g_evtConfigurationInitialized  =    {{{{{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0,
                                              (struct __pthread_internal_list *)0}}},
      {{{0ULL}, {0ULL}, {0U, 0U}, {0U, 0U}, 0U, 0U, {0U, 0U}}}, (_Bool)0, (_Bool)1,
      {(char )'C', (char )'o', (char )'n', (char )'f', (char )'i', (char )'g', (char )'u',
       (char )'r', (char )'a', (char )'t', (char )'i', (char )'o', (char )'n', (char )'I',
       (char )'n', (char )'i', (char )'t', (char )'i', (char )'a', (char )'l', (char )'i',
       (char )'z', (char )'e', (char )'d', (char )'\000'}, 0}}, (enum EHandleType )0};
static sigset_t sig_set  ;
static pthread_t sig_thread_id  ;
static pthread_t sig_monitor_thread_id  ;
long HZ  ;
int MAXIMUM_CPU  ;
struct ProcDumpConfiguration g_config  ;
pthread_mutex_t ptrace_mutex  ;

void InitProcDump(void) 
{ 
  _Bool tmp ;

  {
  openlog("ProcDump", 1, 1 << 3);
  tmp = 1;
  if ((int )tmp == 0) {
    exit(-1);
  }
  InitProcDumpConfiguration(& g_config);
  pthread_mutex_init(& LoggerLock, (pthread_mutexattr_t const   *)((void *)0));
  pthread_mutex_init(& ptrace_mutex, (pthread_mutexattr_t const   *)((void *)0));
  return;
}
}
void ExitProcDump(void) 
{ 


  {
  pthread_mutex_destroy(& LoggerLock);
  closelog();
  FreeProcDumpConfiguration(& g_config);
  return;
}
}
void InitProcDumpConfiguration(struct ProcDumpConfiguration *self ) 
{ 
  int tmp ;
  long tmp___0 ;

  {
  tmp = WaitForSingleObject(& g_evtConfigurationInitialized, 0);
  if (tmp == 0) {
    return;
  }
  tmp___0 = sysconf(84);
  MAXIMUM_CPU = 100 * (int )tmp___0;
  HZ = sysconf(2);
  sysinfo(& self->SystemInfo);
  
  self->evtStartMonitoring.type = (enum EHandleType )0;
  sem_init(& self->semAvailableDumpSlots.__annonCompField4.semaphore, 0, 1U);
  self->semAvailableDumpSlots.type = (enum EHandleType )1;
  self->ProcessId = 2147483647;
  self->NumberOfDumpsCollected = 0;
  self->NumberOfDumpsToCollect = 1;
  self->CpuThreshold = -1;
  self->MemoryThreshold = -1;
  self->ThreadThreshold = -1;
  self->bCpuTriggerBelowValue = (_Bool)0;
  self->bMemoryTriggerBelowValue = (_Bool)0;
  self->bTimerThreshold = (_Bool)0;
  self->WaitingForProcessName = (_Bool)0;
  self->DiagnosticsLoggingEnabled = (_Bool)0;
  self->gcorePid = 2147483647;
  self->PollingInterval = 1000;
  self->CoreDumpPath = (char *)((void *)0);
  self->CoreDumpName = (char *)((void *)0);
  SetEvent(& g_evtConfigurationInitialized.__annonCompField4.event);
  return;
}
}
void FreeProcDumpConfiguration(struct ProcDumpConfiguration *self ) 
{ 
  int tmp ;

  {
  DestroyEvent(& self->evtCtrlHandlerCleanupComplete.__annonCompField4.event);
  DestroyEvent(& self->evtConfigurationPrinted.__annonCompField4.event);
  DestroyEvent(& self->evtDebugThreadInitialized.__annonCompField4.event);
  DestroyEvent(& self->evtQuit.__annonCompField4.event);
  DestroyEvent(& self->evtStartMonitoring.__annonCompField4.event);
  sem_destroy(& self->semAvailableDumpSlots.__annonCompField4.semaphore);
  tmp = strcmp((char const   *)self->ProcessName, "null");
  if (tmp != 0) {
    free((void *)self->ProcessName);
  }
  free((void *)self->CoreDumpPath);
  free((void *)self->CoreDumpName);
  return;
}
}
int GetOptions(struct ProcDumpConfiguration *self , int argc , char **argv ) 
{ 
  int tmp ;
  int tmp___0 ;
  int next_option ;
  int option_index ;
  char const   *short_options ;
  struct option long_options[16] ;
  char *tempOutputPath ;
  struct stat statbuf ;
  int tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  _Bool tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  _Bool tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  _Bool tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  _Bool tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  _Bool tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  _Bool tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  _Bool tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  _Bool tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  _Bool tmp___32 ;
  int tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  size_t tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;

  {
  tmp = WaitForSingleObject(& g_evtConfigurationInitialized, 0);
  
  tempOutputPath = (char *)((void *)0);
  while (1) {
    next_option = getopt_long(argc, (char * const  *)argv, short_options, (struct option  const  *)(long_options),
                              & option_index);
    if (! (next_option != -1)) {
      break;
    }
    switch (next_option) {
    

    case 84: 
    if (self->ThreadThreshold != -1) {
      tmp___10 = -1;
      return (tmp___10);
    } else {
      tmp___11 = 1;
      if (tmp___11) {
        tmp___12 = atoi((char const   *)optarg);
        self->ThreadThreshold = tmp___12;
        if (tmp___12 < 0) {
          tmp___10 = -1;
          return (tmp___10);
        }
      } else {
        tmp___10 = -1;
        return (tmp___10);
      }
    }
    break;
    
    case 99: 
    if (self->CpuThreshold != -1) {
      tmp___19 = -1;
      return (tmp___19);
    } else {
      tmp___20 = 1;
      if (tmp___20) {
        tmp___21 = atoi((char const   *)optarg);
        self->CpuThreshold = tmp___21;
        if (tmp___21 < 0) {
          tmp___19 = -1;
          return (tmp___19);
        } else
        if (self->CpuThreshold > MAXIMUM_CPU) {
          tmp___19 = -1;
          return (tmp___19);
        }
      } else {
        tmp___19 = -1;
        return (tmp___19);
      }
    }
    self->bCpuTriggerBelowValue = (_Bool)1;
    break;
    
    }
  }
  if (self->NumberOfDumpsToCollect != -1) {
    if (self->MemoryThreshold == -1) {
      if (self->CpuThreshold == -1) {
        if (self->ThreadThreshold == -1) {
          if (self->FileDescriptorThreshold == -1) {
            self->bTimerThreshold = (_Bool)1;
          }
        }
      }
    }
  }
  
  return (0);
}
}


int CreateTriggerThreads(struct ProcDumpConfiguration *self ) 
{ 
  int rc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  rc = 0;
  self->nThreads = 0;
  rc = sigemptyset(& sig_set);
  
  if (self->CpuThreshold != -1) {
    tmp = self->nThreads;
    (self->nThreads) ++;
    rc = pthread_create((pthread_t * __restrict  )(& self->Threads[tmp]), (pthread_attr_t const   * __restrict  )((void *)0),
                        & CpuMonitoringThread, (void * __restrict  )((void *)self));
  }
  return (0);
}
}
int WaitForQuit(struct ProcDumpConfiguration *self , int milliseconds ) 
{ 
  _Bool tmp ;
  int wait___0 ;
  int tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = 1;
  if (! tmp) {
    return (128);
  }
  tmp___0 = WaitForSingleObject(& self->evtQuit, milliseconds);
  wait___0 = tmp___0;
  if (wait___0 == 110) {
    tmp___1 = ContinueMonitoring(self);
    if (! tmp___1) {
      return (128);
    }
  }
  return (wait___0);
}
}
int WaitForQuitOrEvent(struct ProcDumpConfiguration *self , struct Handle *handle ,
                       int milliseconds ) 
{ 
  struct Handle *waits[2] ;
  _Bool tmp ;
  int wait___0 ;
  int tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;

  {
  waits[0] = & self->evtQuit;
  waits[1] = handle;
  tmp = ContinueMonitoring(self);
  if (! tmp) {
    return (128);
  }
  tmp___0 = WaitForMultipleObjects(2, waits, (_Bool)0, milliseconds);
  wait___0 = tmp___0;
  
  return (wait___0);
}
}
int WaitForAllThreadsToTerminate(struct ProcDumpConfiguration *self ) 
{ 
  int rc ;
  int i ;

  {
  rc = 0;
  if (self->SignalNumber != -1) {
    rc = pthread_join(sig_monitor_thread_id, (void **)((void *)0));
    if (rc != 0) {
      exit(-1);
    }
  } else {
    i = 0;
    while (i < self->nThreads) {
      rc = pthread_join(self->Threads[i], (void **)((void *)0));
      if (rc != 0) {
        exit(-1);
      }
      i ++;
    }
  }
  pthread_cancel(sig_thread_id);
  rc = pthread_join(sig_thread_id, (void **)((void *)0));
  if (rc != 0) {
    exit(-1);
  }
  return (rc);
}
}

_Bool ContinueMonitoring(struct ProcDumpConfiguration *self ) 
{ 
  int tmp ;

  {
  if (self->NumberOfDumpsCollected >= self->NumberOfDumpsToCollect) {
    return ((_Bool)0);
  }
  if (self->bTerminated) {
    return ((_Bool)0);
  }
  tmp = kill(self->ProcessId, 0);
  if (tmp) {
    self->bTerminated = (_Bool)1;
    return ((_Bool)0);
  }
  return ((_Bool)1);
}
}
#pragma merger("0","/tmp/cil-8JoZWLlg.i","-g,-Wall,-pthread,-std=gnu99")

int WaitForSingleObject(struct Handle *Handle , int Milliseconds ) 
{ 
  struct timespec ts ;
  int rc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  rc = 0;
  if (Milliseconds != -1) {
    clock_gettime(0, & ts);
    ts.tv_sec += (__time_t )(Milliseconds / 1000);
    ts.tv_nsec += (__syscall_slong_t )((Milliseconds % 1000) * 1000000);
  }
  switch ((unsigned int )Handle->type) {
  case 0U: 
  rc = pthread_mutex_lock(& Handle->__annonCompField4.event.mutex);
  if (rc == 0) {
    (Handle->__annonCompField4.event.nWaiters) ++;
    while (1) {
      if (! Handle->__annonCompField4.event.bTriggered) {
        if (! (rc == 0)) {
          break;
        }
      } else {
        break;
      }
      if (Milliseconds == -1) {
        tmp = pthread_cond_wait((pthread_cond_t * __restrict  )(& Handle->__annonCompField4.event.cond),
                                (pthread_mutex_t * __restrict  )(& Handle->__annonCompField4.event.mutex));
        rc = tmp;
      } else {
        tmp___0 = pthread_cond_timedwait((pthread_cond_t * __restrict  )(& Handle->__annonCompField4.event.cond),
                                         (pthread_mutex_t * __restrict  )(& Handle->__annonCompField4.event.mutex),
                                         (struct timespec  const  * __restrict  )(& ts));
        rc = tmp___0;
      }
    }
    (Handle->__annonCompField4.event.nWaiters) --;
    if (Handle->__annonCompField4.event.nWaiters == 0) {
      if (! Handle->__annonCompField4.event.bManualReset) {
        Handle->__annonCompField4.event.bTriggered = (_Bool)0;
      }
    }
    pthread_mutex_unlock(& Handle->__annonCompField4.event.mutex);
  }
  break;
  case 1U: 
  if (Milliseconds == -1) {
    tmp___1 = sem_wait(& Handle->__annonCompField4.semaphore);
    rc = tmp___1;
  } else {
    tmp___2 = sem_timedwait((sem_t * __restrict  )(& Handle->__annonCompField4.semaphore),
                            (struct timespec  const  * __restrict  )(& ts));
    rc = tmp___2;
  }
  break;
  default: 
  rc = -1;
  break;
  }
  return (rc);
}
}
void *WaiterThread(void *thread_args ) 
{ 
  int rc ;
  struct thread_args *input ;
  struct thread_result result ;
  int tmp ;

  {
  input = (struct thread_args *)thread_args;
  rc = WaitForSingleObject(& (input->coordinator)->evtStartWaiting, 2000);
  if (input->milliseconds == -1) {
    while (1) {
      rc = WaitForSingleObject(input->handle, 5000);
      if (! (input->coordinator)->stopIssued) {
        if (! (rc == 110)) {
          break;
        }
      } else {
        break;
      }
    }
  } else {
    rc = WaitForSingleObject(input->handle, input->milliseconds);
  }
  pthread_mutex_lock(& (input->coordinator)->mutexEventTriggered);
  result.retVal = rc;
  result.threadIndex = input->threadIndex;
  tmp = (input->coordinator)->numberTriggered;
  ((input->coordinator)->numberTriggered) ++;
  *((input->coordinator)->results + tmp) = result;
  pthread_mutex_unlock(& (input->coordinator)->mutexEventTriggered);
  pthread_cond_signal(& (input->coordinator)->condEventTriggered);
  WaitForSingleObject(& (input->coordinator)->evtCanCleanUp, -1);
  pthread_mutex_lock(& (input->coordinator)->mutexEventTriggered);
  ((input->coordinator)->nWaiters) --;
  if ((input->coordinator)->nWaiters == 0) {
    pthread_mutex_unlock(& (input->coordinator)->mutexEventTriggered);
    pthread_mutex_destroy(& (input->coordinator)->mutexEventTriggered);
    pthread_cond_destroy(& (input->coordinator)->condEventTriggered);
    free((void *)(input->coordinator)->results);
    free((void *)input->coordinator);
    free((void *)input);
  } else {
    pthread_mutex_unlock(& (input->coordinator)->mutexEventTriggered);
    free((void *)input);
  }
  pthread_exit((void *)0);
}
}
int WaitForMultipleObjects(int Count , struct Handle **Handles , _Bool WaitAll , int Milliseconds ) 
{ 
  struct coordinator *coordinator ;
  struct thread_result *results ;
  pthread_t *threads ;
  struct thread_args **thread_args ;
  struct timespec ts ;
  int t ;
  int rc ;
  int retVal ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  struct thread_result *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  tmp = malloc(sizeof(pthread_t ) * (unsigned long )Count);
  threads = (pthread_t *)tmp;
  tmp___0 = malloc(sizeof(struct thread_args *) * (unsigned long )Count);
  thread_args = (struct thread_args **)tmp___0;
  tmp___1 = malloc(sizeof(struct coordinator ));
  coordinator = (struct coordinator *)tmp___1;
  if ((unsigned long )coordinator == (unsigned long )((void *)0)) {
    exit(-1);
  }
  coordinator->numberTriggered = 0;
  coordinator->stopIssued = 0;
  coordinator->evtCanCleanUp.type = (enum EHandleType )0;
  coordinator->evtStartWaiting.type = (enum EHandleType )0;
  
  pthread_cond_init((pthread_cond_t * __restrict  )(& coordinator->condEventTriggered),
                    (pthread_condattr_t const   * __restrict  )((void *)0));
  pthread_mutex_init(& coordinator->mutexEventTriggered, (pthread_mutexattr_t const   *)((void *)0));
  tmp___3 = malloc(sizeof(struct thread_result ) * (unsigned long )Count);
  tmp___2 = (struct thread_result *)tmp___3;
  coordinator->results = tmp___2;
  results = tmp___2;
  if (Milliseconds != -1) {
    clock_gettime(0, & ts);
    ts.tv_sec += (__time_t )(Milliseconds / 1000);
    ts.tv_nsec += (__syscall_slong_t )((Milliseconds % 1000) * 1000000);
  }
  pthread_mutex_lock(& coordinator->mutexEventTriggered);
  t = 0;
  while (t < Count) {
    tmp___4 = malloc(sizeof(struct thread_args ));
    *(thread_args + t) = (struct thread_args *)tmp___4;
    if ((unsigned long )*(thread_args + t) == (unsigned long )((void *)0)) {
      exit(-1);
    }
    (*(thread_args + t))->handle = *(Handles + t);
    if (Milliseconds == -1) {
      (*(thread_args + t))->milliseconds = Milliseconds;
    } else {
      (*(thread_args + t))->milliseconds = Milliseconds + 100;
    }
    (*(thread_args + t))->threadIndex = t;
    (*(thread_args + t))->coordinator = coordinator;
    rc = pthread_create((pthread_t * __restrict  )(threads + t), (pthread_attr_t const   * __restrict  )((void *)0),
                        & WaiterThread, (void * __restrict  )((void *)*(thread_args + t)));
    if (rc) {
      exit(-1);
    }
    t ++;
  }
  coordinator->nWaiters = Count;
  SetEvent(& coordinator->evtStartWaiting.__annonCompField4.event);
  while (1) {
    if (WaitAll) {
      if (coordinator->numberTriggered < Count) {
        goto _L;
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (! WaitAll) {
      if (coordinator->numberTriggered == 0) {
        _L: /* CIL Label */ 
        if (! (rc == 0)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    if (Milliseconds == -1) {
      rc = pthread_cond_wait((pthread_cond_t * __restrict  )(& coordinator->condEventTriggered),
                             (pthread_mutex_t * __restrict  )(& coordinator->mutexEventTriggered));
      if (rc != 0) {
        break;
      }
    } else {
      rc = pthread_cond_timedwait((pthread_cond_t * __restrict  )(& coordinator->condEventTriggered),
                                  (pthread_mutex_t * __restrict  )(& coordinator->mutexEventTriggered),
                                  (struct timespec  const  * __restrict  )(& ts));
      if (rc != 0) {
        break;
      }
    }
  }
  coordinator->stopIssued = 1;
  pthread_mutex_unlock(& coordinator->mutexEventTriggered);
  t = 0;
  while (t < Count) {
    pthread_detach(*(threads + t));
    t ++;
  }
  SetEvent(& coordinator->evtCanCleanUp.__annonCompField4.event);
  free((void *)threads);
  free((void *)thread_args);
  if (rc) {
    retVal = rc;
  } else
  if (WaitAll) {
    retVal = rc;
  } else {
    retVal = (results + 0)->retVal + (results + 0)->threadIndex;
  }
  return (retVal);
}
}
#pragma merger("0","/tmp/cil-GAzlKcgP.i","-g,-Wall,-pthread,-std=gnu99")

int main(int argc , char **argv ) 
{ 
  int tmp ;
  __uid_t tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;

  {
  InitProcDump();
  tmp = GetOptions(& g_config, argc, argv);
  
  
  tmp___2 = CreateTriggerThreads(& g_config);
  
  WaitForAllThreadsToTerminate(& g_config);
  ExitProcDump();
  return (0);
}
}
#pragma merger("0","/tmp/cil-uKVdWh5m.i","-g,-Wall,-pthread,-std=gnu99")

void *CpuMonitoringThread(void *thread_args ) 
{ 
  struct ProcDumpConfiguration *config ;
  unsigned long totalTime ;
  unsigned long elapsedTime ;
  struct sysinfo sysInfo ;
  int cpuUsage ;
  int rc ;
  struct ProcessStat proc ;
  _Bool tmp___0 ;

  {
  config = (struct ProcDumpConfiguration *)thread_args;
  totalTime = 0UL;
  elapsedTime = 0UL;
  rc = 0;
  
  rc = WaitForQuitOrEvent(config, & config->evtStartMonitoring, -1);
  if (rc == 1) {
    while (1) {
      rc = WaitForQuit(config, config->PollingInterval);
      if (! (rc == 110)) {
        break;
      }
      sysinfo(& sysInfo);
      tmp___0 = 1;
      if (tmp___0) {
        totalTime = (proc.utime + proc.stime) / (unsigned long )HZ;
        elapsedTime = (unsigned long )(sysInfo.uptime - (long )(proc.starttime / (unsigned long long )HZ));
        cpuUsage = (int )((double )100 * ((double )totalTime / (double )elapsedTime));
        if (config->bCpuTriggerBelowValue) {
          if (cpuUsage < config->CpuThreshold) {
            goto _L;
          } else {
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
        if (! config->bCpuTriggerBelowValue) {
          if (cpuUsage >= config->CpuThreshold) {
            _L: /* CIL Label */ 
            rc = 110;
            rc = WaitForQuit(config, config->ThresholdSeconds * 1000);
            if (rc != 110) {
              break;
            }
          }
        }
      } else {
        exit(-1);
      }
    }
  }
  pthread_exit((void *)0);
}
}

#pragma merger("0","/tmp/cil-22GQKc4s.i","-g,-Wall,-pthread,-std=gnu99")