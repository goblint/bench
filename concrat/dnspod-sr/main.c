/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef unsigned char __uint8_t;
typedef unsigned short __uint16_t;
typedef unsigned int __uint32_t;
typedef unsigned long __uint64_t;
typedef unsigned int __uid_t;
typedef long __off_t;
typedef long __off64_t;
typedef int __pid_t;
typedef long __clock_t;
typedef long __time_t;
typedef long __suseconds_t;
typedef long __ssize_t;
typedef __ssize_t ssize_t;
typedef __time_t time_t;
struct __anonstruct___sigset_t_991265788 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___sigset_t_991265788 __sigset_t;
typedef __sigset_t sigset_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
typedef int volatile   pthread_spinlock_t;
typedef __builtin_va_list __gnuc_va_list;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef __gnuc_va_list va_list___0;
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
typedef union sigval __sigval_t;
struct __anonstruct__kill_244518854 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
struct __anonstruct__timer_490064738 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
struct __anonstruct__rt_619254530 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
struct __anonstruct__sigchld_284671705 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
struct __anonstruct__addr_bnd_5259977 {
   void *_lower ;
   void *_upper ;
};
union __anonunion__bounds_1031523602 {
   struct __anonstruct__addr_bnd_5259977 _addr_bnd ;
   __uint32_t _pkey ;
};
struct __anonstruct__sigfault_192557564 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion__bounds_1031523602 _bounds ;
};
struct __anonstruct__sigpoll_386613454 {
   long si_band ;
   int si_fd ;
};
struct __anonstruct__sigsys_44812255 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
union __anonunion__sifields_998240460 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_244518854 _kill ;
   struct __anonstruct__timer_490064738 _timer ;
   struct __anonstruct__rt_619254530 _rt ;
   struct __anonstruct__sigchld_284671705 _sigchld ;
   struct __anonstruct__sigfault_192557564 _sigfault ;
   struct __anonstruct__sigpoll_386613454 _sigpoll ;
   struct __anonstruct__sigsys_44812255 _sigsys ;
};
struct __anonstruct_siginfo_t_267242570 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion__sifields_998240460 _sifields ;
};
typedef struct __anonstruct_siginfo_t_267242570 siginfo_t;
union __anonunion___sigaction_handler_363639592 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
struct sigaction {
   union __anonunion___sigaction_handler_363639592 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
typedef unsigned int uint___0;
typedef unsigned char uchar;
typedef unsigned short ushort___0;
typedef unsigned long ulong___0;
typedef uint32_t hashval_t;
struct _packet_type {
   uint8_t label_count ;
   uchar domain[256] ;
   uint8_t *label[64] ;
   uint8_t label_offsets[64] ;
   uint8_t label_len[64] ;
   hashval_t hash[64] ;
};
typedef struct _packet_type packet_type;
struct list_node {
   void *data ;
   struct list_node *next ;
};
struct list {
   pthread_spinlock_t lock ;
   struct list_node *head ;
};
struct ttlnode {
   uint___0 exp ;
   ushort___0 dlen ;
   ushort___0 type ;
   hashval_t *hash ;
   packet_type *lowerdomain ;
   uchar *data ;
};
enum rrtype {
    BEGIN_TYPE = 0,
    A = 1,
    NS = 2,
    MD = 3,
    MF = 4,
    CNAME = 5,
    SOA = 6,
    MB = 7,
    MG = 8,
    MR = 9,
    NUL = 10,
    WKS = 11,
    PTR = 12,
    HINFO = 13,
    MINFO = 14,
    MX = 15,
    TXT = 16,
    RP = 17,
    AFSDB = 18,
    SIG = 24,
    KEY = 25,
    AAAA = 28,
    NXT = 30,
    SRV = 33,
    CERT = 37,
    A6 = 38,
    DNAME = 39,
    OPT = 41,
    APL = 42,
    DS = 43,
    RRSIG = 46,
    NSEC = 47,
    DNSKEY = 48,
    DHCID = 49,
    TKEY = 249,
    AXFR = 252,
    MAILB = 253,
    MAILA = 254,
    ANY = 255
} ;
struct _type_value {
   uchar *A ;
   uchar *NS ;
   uchar *CNAME ;
   uchar *SOA ;
   uchar *MX ;
   uchar *TXT ;
   uchar *AAAA ;
   uchar *SRV ;
   uchar *PTR ;
};
typedef struct _type_value type_value;
typedef int comprbt(void * , void * , void * );
struct rbnode {
   struct rbnode *parent ;
   struct rbnode *left ;
   struct rbnode *right ;
   int color ;
   void *key ;
};
struct rbtree {
   struct rbnode *root ;
   struct rbnode nil ;
   pthread_spinlock_t lock ;
   uint___0 size ;
   comprbt *c ;
   void *argv ;
};
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
typedef uint32_t in_addr_t;
struct in_addr {
   in_addr_t s_addr ;
};
typedef uint16_t in_port_t;
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
struct prod {
   uint32_t watermark ;
   uint32_t sp_enqueue ;
   uint32_t size ;
   uint32_t mask ;
   uint32_t volatile   head ;
   uint32_t volatile   tail ;
};
struct cons {
   uint32_t sc_dequeue ;
   uint32_t size ;
   uint32_t mask ;
   uint32_t volatile   head ;
   uint32_t volatile   tail ;
};
struct mbuf_ring {
   struct prod prod  __attribute__((__aligned__(64))) ;
   struct cons cons  __attribute__((__aligned__(64))) ;
   void *ring[0]  __attribute__((__aligned__(64))) ;
};
struct _mem_buf {
   struct mbuf_ring *mbuf ;
   uint___0 fetch_len ;
   uint___0 socktype ;
   int fd ;
   struct sockaddr_in *addr ;
   struct sockaddr_in caddr ;
   struct sockaddr_in aaddr ;
   uchar data[4096] ;
   enum rrtype qtype ;
   int err ;
   int dlen ;
   ushort___0 id ;
   packet_type lowerdomain ;
   uchar *origindomain ;
   int buflen ;
   uchar *buf ;
   uchar *td ;
   ushort___0 cid ;
   ushort___0 qlen ;
   ushort___0 lables ;
   uchar *qing ;
   hashval_t *qhash ;
   ushort___0 backid ;
   ushort___0 aid ;
   ushort___0 mask ;
   ushort___0 qname ;
   ushort___0 sq ;
   ushort___0 qtimes ;
   ushort___0 auth_socktype ;
   ushort___0 stat ;
   uchar qbuffer[256] ;
   hashval_t qbuffer_hash ;
   uchar *tdbuffer ;
   uchar *tempbuffer ;
   uchar *dmbuffer ;
   uchar *ipbuffer ;
   ushort___0 hascname ;
   int tcpfd ;
   int tcpnums ;
   int mxtry ;
   int qns ;
   uint64_t stime ;
};
typedef struct _mem_buf mbuf_type;
struct msgcache {
   uint64_t head ;
   uint64_t tail ;
   uint32_t size ;
   uint32_t pkt ;
   pthread_spinlock_t lock ;
   uchar data[0] ;
};
typedef hashval_t hashfunc(void *data , int  );
typedef int comparefunc(void * , void * );
union __anonunion____missing_field_name_355715386 {
   uchar *vals[9] ;
   type_value val ;
};
struct hentry {
   union __anonunion____missing_field_name_355715386 __annonCompField4 ;
   struct hentry *next ;
   int count ;
   uchar key[0] ;
};
struct hdata {
   struct hentry *list ;
   uint64_t now ;
   pthread_spinlock_t lock ;
};
struct htable {
   pthread_spinlock_t lock ;
   struct hdata *table ;
   uchar *edata ;
   hashfunc *h ;
   uint___0 size ;
   uint___0 mask ;
   uint___0 now ;
   comparefunc *c ;
};
union epoll_data {
   void *ptr ;
   int fd ;
   uint32_t u32 ;
   uint64_t u64 ;
};
typedef union epoll_data epoll_data_t;
struct epoll_event {
   uint32_t events ;
   epoll_data_t data ;
} __attribute__((__packed__)) ;
struct sockinfo {
   struct sockaddr_in addr ;
   int fd ;
   int buflen ;
   int socktype ;
   uchar *buf ;
   packet_type *lowerdomain ;
   mbuf_type *mbuf ;
};
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
struct qoutinfo {
   uchar *td ;
   uchar type ;
   packet_type *lowerdomain ;
   struct sockinfo *cli ;
   ushort___0 cid ;
   ushort___0 dlen ;
   ushort___0 qlen ;
   ushort___0 lables ;
   uchar *qing ;
   hashval_t *qhash ;
   ushort___0 backid ;
   ushort___0 aid ;
   ushort___0 mask ;
   ushort___0 qname ;
   ushort___0 sq ;
   ushort___0 qtimes ;
   ushort___0 socktype ;
   ushort___0 stat ;
   uchar qbuffer[256] ;
   hashval_t qbuffer_hash ;
   uchar *tdbuffer ;
   uchar *tempbuffer ;
   uchar *dmbuffer ;
   uchar *ipbuffer ;
   ushort___0 hascname ;
   int tcpfd ;
   int tcpnums ;
   int mxtry ;
   int qns ;
   uint64_t stime ;
};
struct log_info {
   int logfd ;
   time_t lastlog ;
   int log_type ;
   uchar log_cache[1048576] ;
   int log_cache_cursor ;
};
struct eptcpfds {
   int ret ;
   uchar domain[256] ;
};
struct server ;
struct author {
   int audp ;
   int cudp ;
   int idx ;
   struct server *s ;
   pthread_spinlock_t lock ;
   struct qoutinfo *list[10000] ;
   int qnum ;
   int response ;
   int qidx ;
   int timex ;
   struct list *el ;
   int bdepfd ;
   struct log_info *loginfo ;
   pthread_spinlock_t dblock[101] ;
   uchar databuffer[65528] ;
   uchar randombuffer[3000] ;
   uchar tmpbuffer[2000] ;
   uchar tdbuffer[256] ;
   uchar tempbuffer[2000] ;
   uchar dmbuffer[512] ;
   uchar ipbuffer[512] ;
   struct epoll_event e[1000] ;
   int rndidx ;
   int dataidx ;
   uchar ip[2000] ;
   struct eptcpfds eptcpfds[65530] ;
   uint___0 rdb ;
   int ddbefore ;
   int underattack ;
   int tcpinuse ;
   struct htable *fwd ;
   struct htable *ds ;
   int dupbefore ;
   int limits ;
   int hsidx ;
   uint___0 quizz ;
   uint___0 drop ;
   uint___0 timeout ;
   int start ;
   int end ;
};
struct fetcher {
   int idx ;
   struct server *s ;
   struct msgcache *mc ;
   struct list *el ;
   struct log_info *loginfo ;
   uchar originbuffer[65528] ;
   uchar tdbuffer[256] ;
   uchar databuffer[65528] ;
   uchar cbbuffer[512] ;
   int dataidx ;
   int qidx ;
   uint64_t pkg ;
   uint64_t send ;
   uint64_t miss ;
};
struct server {
   ushort___0 nquizzer ;
   ushort___0 nfetcher ;
   int ludp ;
   int ltcp ;
   struct fetcher *fetchers ;
   struct author *authors ;
   struct list eventlist ;
   struct htable *datasets ;
   struct htable *forward ;
   struct htable *qlist ;
   ulong___0 pkg ;
   uchar logpath[255] ;
   ulong___0 recordsindb ;
   struct rbtree *ttlexp ;
   uint16_t refreshflag ;
   time_t lastrefresh ;
   int is_forward ;
};
struct thread_query_info {
   unsigned long query_num[9] ;
};
struct global_query_info {
   int thread_num ;
   int log_flag ;
   struct thread_query_info query_info[65] ;
};
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
typedef unsigned int __socklen_t;
typedef __socklen_t socklen_t;
typedef struct sockaddr SA;
typedef unsigned long pthread_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
struct mvalue {
   uint16_t len ;
   uint16_t num ;
   uint32_t ttl ;
   uint32_t hits ;
   uint16_t seg ;
};
struct st_hlp {
   struct htable *ht ;
   int idx ;
};
struct setheader {
   ushort___0 an ;
   ushort___0 ns ;
   ushort___0 id ;
   ushort___0 dlen ;
   uchar *od ;
   uchar *itor ;
   ushort___0 type ;
};
struct hlpp {
   int *stype ;
   struct htable *ds ;
   struct rbtree *rbt ;
   uchar *buf ;
   int datalen ;
   uchar *dms ;
   int dmsidx ;
   int section ;
   uchar *tmpbuf ;
   uchar *domainbuf ;
   uchar *dmbuf ;
};
struct hlpc {
   uchar *name ;
   short off ;
   short level ;
   short ref ;
   short mt ;
   short len ;
};
struct hlpf {
   ushort___0 type ;
   ushort___0 len ;
   uint___0 ttl ;
   uchar *hdr ;
   uchar *from ;
   uchar *to ;
};
#pragma pack(1)
struct fillmsg {
   uint16_t type ;
   uint16_t dclass ;
   uint32_t ttl ;
   uint16_t len ;
};
#pragma pack()
#pragma pack(1)
struct tag_dnsheader {
   uint16_t id ;
   uint16_t flags ;
   uint16_t qdcount ;
   uint16_t ancount ;
   uint16_t nscount ;
   uint16_t arcount ;
};
typedef struct tag_dnsheader dnsheader;
#pragma pack()
#pragma pack(1)
struct tag_dq {
   uint16_t type ;
   uint16_t dclass ;
};
typedef struct tag_dq qdns;
#pragma pack()
#pragma pack(1)
#pragma pack()
#pragma pack(1)
struct srv {
   uint16_t pri ;
   uint16_t wei ;
   uint16_t port ;
};
#pragma pack()
typedef unsigned int __mode_t;
typedef __mode_t mode_t;
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
typedef unsigned long __cpu_mask;
struct __anonstruct_cpu_set_t_826868708 {
   __cpu_mask __bits[1024UL / (8UL * sizeof(__cpu_mask ))] ;
};
typedef struct __anonstruct_cpu_set_t_826868708 cpu_set_t;
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
struct event_data ;
struct event_data {
   int fd ;
   int (*cb)(struct event_data * , void * , int  ) ;
   void *ext ;
};
struct iner_event ;
struct event {
   int size ;
   int onexit ;
   struct iner_event *ie ;
   struct event_data data[0] ;
};
enum event_type {
    ET_READ = 1,
    ET_WRITE = 2,
    ET_ALL = 3
} ;
struct event_help {
   int fd ;
   int spfd ;
   int num ;
   enum event_type type ;
   struct timeval *to ;
   int (*cb)(struct event_data * , void * , int  ) ;
   void *ext ;
};
struct iner_event {
   int epfd ;
   char *buf ;
   struct epoll_event e[0] ;
};
typedef int __int32_t;
typedef unsigned int __useconds_t;
typedef __int32_t int32_t;
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
union grifa {
   int val ;
   uchar randombuffer[sizeof(int )] ;
};
typedef int __key_t;
typedef long __syscall_slong_t;
typedef int __sig_atomic_t;
typedef __key_t key_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
typedef __sig_atomic_t sig_atomic_t;
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
typedef unsigned long __dev_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned long __nlink_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
#pragma pack(1)
#pragma pack()
/* compiler builtin:
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin:
   void __builtin_va_end(__builtin_va_list  ) ;  */
#pragma merger("0","/tmp/cil-7JmtMyBq.i","-g,-Wall")
extern  __attribute__((__nothrow__)) long random(void) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern FILE *stdout ;
extern int fflush(FILE *__stream ) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern int vprintf(char const   * __restrict  __format , __gnuc_va_list __arg ) ;
extern void perror(char const   *__s ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern int close(int __fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag
                                                   , ...) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         void * __restrict  __tz ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_spin_trylock)(pthread_spinlock_t *__lock ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_spin_unlock)(pthread_spinlock_t *__lock ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigemptyset)(sigset_t *__set ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigaddset)(sigset_t *__set ,
                                                                                      int __signo ) ;
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
extern  __attribute__((__nothrow__)) int pthread_sigmask(int __how , __sigset_t const   * __restrict  __newmask ,
                                                         __sigset_t * __restrict  __oldmask ) ;
int trig_signals(int sig ) ;
void drop_privilege(char *root ) ;
uchar *get_str(uchar *str , int len ) ;
void put_str(uchar *str ) ;
int dict_comp_uint_equ(void *a , void *b ) ;
int dict_comp_str_equ(void *a , void *b ) ;
int rbt_comp_uint_gt(void *v1 , void *v2 , void *argv ) ;
int rbt_comp_ttl_gt(void *v1 , void *v2 , void *argv ) ;
void dns_error(int level , char *msg ) ;
int dbg(char const   *format  , ...) ;
void print_hex(uchar *val , int n ) ;
int str_to_uchar4(char const   *addr , uchar *val ) ;
int str_to_uchar6(uchar *addr , uchar *val ) ;
int to_uppercase(uchar *buf , int n ) ;
int to_lowercase(uchar *msg , int len ) ;
int fix_tail(char *domain ) ;
int empty_function(int i ) ;
void insert_mem_bar(void) ;
int test_lock(pthread_spinlock_t *l ) ;
int set_bit(unsigned short *bit , int off ) ;
int clr_bit(unsigned short *bit , int off ) ;
int tst_bit(unsigned short const   bit , int off ) ;
int get_random_data(uchar *buffer , int len ) ;
int get_time_usage(struct timeval *tv , int start ) ;
int is_uppercase(int c ) ;
int is_lowercase(int c ) ;
hashval_t uint_hash_function(void *ptr ) ;
hashval_t nocase_char_hash_function(void *argv , int klen ) ;
int slog(uchar *msg , int fd , pthread_spinlock_t *lock ) ;
unsigned char LowerTable[256] ;
unsigned char UpperTable[256] ;
struct server *global_serv  ;
char *g_nameservers[2]  ;
struct global_query_info *global_out_info  ;
int query_type_map[256]  ;
int slog(uchar *msg , int fd , pthread_spinlock_t *lock )
{


  {
  return (0);
}
}
int get_random_data(uchar *buffer , int len )
{
  int fd ;
  int ret ;
  ssize_t tmp ;

  {
  fd = -1;
  ret = 0;
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    return (-1);
  } else
  if (len < 0) {
    return (-1);
  }
  fd = open("/dev/urandom", 0);
  if (fd <= 0) {
    return (fd);
  }
  tmp = read(fd, (void *)buffer, (size_t )len);
  ret = (int )tmp;
  if (ret == -1) {
    perror("read");
  }
  close(fd);
  return (0);
}
}
uchar *get_str(uchar *str , int len )
{
  uchar *ret ;
  void *tmp ;

  {
  tmp = malloc((size_t )(len + 1));
  ret = (uchar *)tmp;
  strncpy((char * __restrict  )((char *)ret), (char const   * __restrict  )((char *)str),
          (size_t )(len + 1));
  *(ret + len) = (uchar )0;
  return (ret);
}
}
void put_str(uchar *str )
{


  {
  free((void *)str);
  return;
}
}
int flush_all_to_disk(struct server *s )
{
  int i ;
  int ret ;
  struct log_info *log ;
  ssize_t tmp ;
  ssize_t tmp___0 ;

  {
  log = (struct log_info *)((void *)0);
  i = 0;
  while (i < (int )s->nfetcher) {
    log = (s->fetchers + i)->loginfo;
    tmp = write(log->logfd, (void const   *)(log->log_cache), (size_t )log->log_cache_cursor);
    ret = (int )tmp;
    if (ret == -1) {
      perror("write");
    }
    log->log_cache_cursor = 0;
    close(log->logfd);
    i ++;
  }
  i = 0;
  while (i < (int )s->nquizzer) {
    log = (s->authors + i)->loginfo;
    tmp___0 = write(log->logfd, (void const   *)(log->log_cache), (size_t )log->log_cache_cursor);
    ret = (int )tmp___0;
    if (ret == -1) {
      perror("write");
    }
    log->log_cache_cursor = 0;
    close(log->logfd);
    i ++;
  }
  return (0);
}
}
static void sig_segment_fault(int signo )
{


  {
  printf((char const   * __restrict  )"sig number is %d\n", signo);
  flush_all_to_disk(global_serv);
  exit(0);
}
}
int trig_signals(int sig )
{
  sigset_t bset ;
  sigset_t oset ;
  int sigs[4] ;
  int i ;
  int sig_num ;
  struct sigaction sa ;
  struct sigaction oa ;
  int tmp ;

  {
  sigs[0] = 2;
  sigs[1] = 7;
  sigs[2] = 11;
  sigs[3] = 13;
  memset((void *)(& sa), 0, sizeof(sa));
  sa.__sigaction_handler.sa_handler = & sig_segment_fault;
  sa.sa_flags = 268435456;
  i = 0;
  while ((unsigned long )i < sizeof(sigs) / sizeof(sigs[0])) {
    sig_num = sigs[i];
    sigaction(sig_num, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )(& oa));
    i ++;
  }
  sigemptyset(& bset);
  sigaddset(& bset, 10);
  tmp = pthread_sigmask(0, (__sigset_t const   * __restrict  )(& bset), (__sigset_t * __restrict  )(& oset));
  if (tmp != 0) {
    dns_error(0, (char *)"sig error");
  }
  return (0);
}
}
void drop_privilege(char *root )
{


  {
  if ((unsigned long )root == (unsigned long )((void *)0)) {
    return;
  }
  return;
}
}
int dict_comp_uint_equ(void *a , void *b )
{
  uint___0 *u1 ;
  uint___0 *u2 ;
  int tmp ;

  {
  u1 = (uint___0 *)a;
  u2 = (uint___0 *)b;
  if ((unsigned long )u1 == (unsigned long )((void *)0)) {
    return (-1);
  }
  if ((unsigned long )u2 == (unsigned long )((void *)0)) {
    return (1);
  }
  if (*u1 == *u2) {
    return (0);
  }
  if ((unsigned long )u1 > (unsigned long )u2) {
    tmp = 1;
  } else {
    tmp = -1;
  }
  return (tmp);
}
}
int dict_comp_str_equ(void *a , void *b )
{
  uchar *d1 ;
  uchar *d2 ;
  int to ;
  int tmp ;

  {
  d1 = (uchar *)a;
  d2 = (uchar *)b;
  to = 256;
  if ((unsigned long )d1 == (unsigned long )((void *)0)) {
    return (-1);
  }
  if ((unsigned long )d2 == (unsigned long )((void *)0)) {
    return (1);
  }
  while (1) {
    if ((int )*d1 != 0) {
      if (! ((int )*d2 != 0)) {
        break;
      }
    } else {
      break;
    }
    if ((int )*d1 > (int )*d2) {
      return (1);
    }
    if ((int )*d1 < (int )*d2) {
      return (-1);
    }
    d1 ++;
    d2 ++;
    tmp = to;
    to --;
    if (tmp == 0) {
      printf((char const   * __restrict  )"str compare error\n");
      exit(0);
    }
  }
  if ((int )*d1 == 0) {
    if ((int )*d2 == 0) {
      return (0);
    }
  }
  if ((int )*d1 == 0) {
    return (-1);
  }
  return (1);
}
}
int rbt_comp_ttl_gt(void *v1 , void *v2 , void *argv )
{
  int ret ;
  struct ttlnode *n1 ;
  struct ttlnode *n2 ;

  {
  if ((unsigned long )v2 == (unsigned long )((void *)0)) {
    return (1);
  }
  if ((unsigned long )v1 == (unsigned long )((void *)0)) {
    return (-1);
  }
  n1 = (struct ttlnode *)v1;
  n2 = (struct ttlnode *)v2;
  if (n1->exp > n2->exp) {
    return (1);
  }
  if (n1->exp < n2->exp) {
    return (-1);
  }
  if ((int )n1->type > (int )n2->type) {
    return (1);
  }
  if ((int )n1->type < (int )n2->type) {
    return (-1);
  }
  ret = dict_comp_str_equ((void *)n1->data, (void *)n2->data);
  if (ret > 0) {
    return (1);
  }
  if (ret < 0) {
    return (-1);
  }
  return (0);
}
}
int rbt_comp_uint_gt(void *v1 , void *v2 , void *argv )
{
  uint___0 n1 ;
  uint___0 n2 ;
  int tmp ;

  {
  if ((unsigned long )v2 == (unsigned long )((void *)0)) {
    return (1);
  }
  if ((unsigned long )v1 == (unsigned long )((void *)0)) {
    return (-1);
  }
  n1 = *((uint___0 *)v1);
  n2 = *((uint___0 *)v2);
  if (n1 == n2) {
    return (0);
  }
  if (n1 > n2) {
    tmp = 1;
  } else {
    tmp = -1;
  }
  return (tmp);
}
}
unsigned char LowerTable[256]  =
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)2,      (unsigned char)3,
        (unsigned char)4,      (unsigned char)5,      (unsigned char)6,      (unsigned char)7,
        (unsigned char)8,      (unsigned char)9,      (unsigned char)10,      (unsigned char)11,
        (unsigned char)12,      (unsigned char)13,      (unsigned char)14,      (unsigned char)15,
        (unsigned char)16,      (unsigned char)17,      (unsigned char)18,      (unsigned char)19,
        (unsigned char)20,      (unsigned char)21,      (unsigned char)22,      (unsigned char)23,
        (unsigned char)24,      (unsigned char)25,      (unsigned char)26,      (unsigned char)27,
        (unsigned char)28,      (unsigned char)29,      (unsigned char)30,      (unsigned char)31,
        (unsigned char)32,      (unsigned char)33,      (unsigned char)34,      (unsigned char)35,
        (unsigned char)36,      (unsigned char)37,      (unsigned char)38,      (unsigned char)39,
        (unsigned char)40,      (unsigned char)41,      (unsigned char)42,      (unsigned char)43,
        (unsigned char)44,      (unsigned char)45,      (unsigned char)46,      (unsigned char)47,
        (unsigned char)48,      (unsigned char)49,      (unsigned char)50,      (unsigned char)51,
        (unsigned char)52,      (unsigned char)53,      (unsigned char)54,      (unsigned char)55,
        (unsigned char)56,      (unsigned char)57,      (unsigned char)58,      (unsigned char)59,
        (unsigned char)60,      (unsigned char)61,      (unsigned char)62,      (unsigned char)63,
        (unsigned char)64,      (unsigned char)97,      (unsigned char)98,      (unsigned char)99,
        (unsigned char)100,      (unsigned char)101,      (unsigned char)102,      (unsigned char)103,
        (unsigned char)104,      (unsigned char)105,      (unsigned char)106,      (unsigned char)107,
        (unsigned char)108,      (unsigned char)109,      (unsigned char)110,      (unsigned char)111,
        (unsigned char)112,      (unsigned char)113,      (unsigned char)114,      (unsigned char)115,
        (unsigned char)116,      (unsigned char)117,      (unsigned char)118,      (unsigned char)119,
        (unsigned char)120,      (unsigned char)121,      (unsigned char)122,      (unsigned char)91,
        (unsigned char)92,      (unsigned char)93,      (unsigned char)94,      (unsigned char)95,
        (unsigned char)96,      (unsigned char)97,      (unsigned char)98,      (unsigned char)99,
        (unsigned char)100,      (unsigned char)101,      (unsigned char)102,      (unsigned char)103,
        (unsigned char)104,      (unsigned char)105,      (unsigned char)106,      (unsigned char)107,
        (unsigned char)108,      (unsigned char)109,      (unsigned char)110,      (unsigned char)111,
        (unsigned char)112,      (unsigned char)113,      (unsigned char)114,      (unsigned char)115,
        (unsigned char)116,      (unsigned char)117,      (unsigned char)118,      (unsigned char)119,
        (unsigned char)120,      (unsigned char)121,      (unsigned char)122,      (unsigned char)123,
        (unsigned char)124,      (unsigned char)125,      (unsigned char)126,      (unsigned char)127,
        (unsigned char)128,      (unsigned char)129,      (unsigned char)130,      (unsigned char)131,
        (unsigned char)132,      (unsigned char)133,      (unsigned char)134,      (unsigned char)135,
        (unsigned char)136,      (unsigned char)137,      (unsigned char)138,      (unsigned char)139,
        (unsigned char)140,      (unsigned char)141,      (unsigned char)142,      (unsigned char)143,
        (unsigned char)144,      (unsigned char)145,      (unsigned char)146,      (unsigned char)147,
        (unsigned char)148,      (unsigned char)149,      (unsigned char)150,      (unsigned char)151,
        (unsigned char)152,      (unsigned char)153,      (unsigned char)154,      (unsigned char)155,
        (unsigned char)156,      (unsigned char)157,      (unsigned char)158,      (unsigned char)159,
        (unsigned char)160,      (unsigned char)161,      (unsigned char)162,      (unsigned char)163,
        (unsigned char)164,      (unsigned char)165,      (unsigned char)166,      (unsigned char)167,
        (unsigned char)168,      (unsigned char)169,      (unsigned char)170,      (unsigned char)171,
        (unsigned char)172,      (unsigned char)173,      (unsigned char)174,      (unsigned char)175,
        (unsigned char)176,      (unsigned char)177,      (unsigned char)178,      (unsigned char)179,
        (unsigned char)180,      (unsigned char)181,      (unsigned char)182,      (unsigned char)183,
        (unsigned char)184,      (unsigned char)185,      (unsigned char)186,      (unsigned char)187,
        (unsigned char)188,      (unsigned char)189,      (unsigned char)190,      (unsigned char)191,
        (unsigned char)192,      (unsigned char)193,      (unsigned char)194,      (unsigned char)195,
        (unsigned char)196,      (unsigned char)197,      (unsigned char)198,      (unsigned char)199,
        (unsigned char)200,      (unsigned char)201,      (unsigned char)202,      (unsigned char)203,
        (unsigned char)204,      (unsigned char)205,      (unsigned char)206,      (unsigned char)207,
        (unsigned char)208,      (unsigned char)209,      (unsigned char)210,      (unsigned char)211,
        (unsigned char)212,      (unsigned char)213,      (unsigned char)214,      (unsigned char)215,
        (unsigned char)216,      (unsigned char)217,      (unsigned char)218,      (unsigned char)219,
        (unsigned char)220,      (unsigned char)221,      (unsigned char)222,      (unsigned char)223,
        (unsigned char)224,      (unsigned char)225,      (unsigned char)226,      (unsigned char)227,
        (unsigned char)228,      (unsigned char)229,      (unsigned char)230,      (unsigned char)231,
        (unsigned char)232,      (unsigned char)233,      (unsigned char)234,      (unsigned char)235,
        (unsigned char)236,      (unsigned char)237,      (unsigned char)238,      (unsigned char)239,
        (unsigned char)240,      (unsigned char)241,      (unsigned char)242,      (unsigned char)243,
        (unsigned char)244,      (unsigned char)245,      (unsigned char)246,      (unsigned char)247,
        (unsigned char)248,      (unsigned char)249,      (unsigned char)250,      (unsigned char)251,
        (unsigned char)252,      (unsigned char)253,      (unsigned char)254,      (unsigned char)255};
unsigned char UpperTable[256]  =
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)2,      (unsigned char)3,
        (unsigned char)4,      (unsigned char)5,      (unsigned char)6,      (unsigned char)7,
        (unsigned char)8,      (unsigned char)9,      (unsigned char)10,      (unsigned char)11,
        (unsigned char)12,      (unsigned char)13,      (unsigned char)14,      (unsigned char)15,
        (unsigned char)16,      (unsigned char)17,      (unsigned char)18,      (unsigned char)19,
        (unsigned char)20,      (unsigned char)21,      (unsigned char)22,      (unsigned char)23,
        (unsigned char)24,      (unsigned char)25,      (unsigned char)26,      (unsigned char)27,
        (unsigned char)28,      (unsigned char)29,      (unsigned char)30,      (unsigned char)31,
        (unsigned char)32,      (unsigned char)33,      (unsigned char)34,      (unsigned char)35,
        (unsigned char)36,      (unsigned char)37,      (unsigned char)38,      (unsigned char)39,
        (unsigned char)40,      (unsigned char)41,      (unsigned char)42,      (unsigned char)43,
        (unsigned char)44,      (unsigned char)45,      (unsigned char)46,      (unsigned char)47,
        (unsigned char)48,      (unsigned char)49,      (unsigned char)50,      (unsigned char)51,
        (unsigned char)52,      (unsigned char)53,      (unsigned char)54,      (unsigned char)55,
        (unsigned char)56,      (unsigned char)57,      (unsigned char)58,      (unsigned char)59,
        (unsigned char)60,      (unsigned char)61,      (unsigned char)62,      (unsigned char)63,
        (unsigned char)64,      (unsigned char)65,      (unsigned char)66,      (unsigned char)67,
        (unsigned char)68,      (unsigned char)69,      (unsigned char)70,      (unsigned char)71,
        (unsigned char)72,      (unsigned char)73,      (unsigned char)74,      (unsigned char)75,
        (unsigned char)76,      (unsigned char)77,      (unsigned char)78,      (unsigned char)79,
        (unsigned char)80,      (unsigned char)81,      (unsigned char)82,      (unsigned char)83,
        (unsigned char)84,      (unsigned char)85,      (unsigned char)86,      (unsigned char)87,
        (unsigned char)88,      (unsigned char)89,      (unsigned char)90,      (unsigned char)91,
        (unsigned char)92,      (unsigned char)93,      (unsigned char)94,      (unsigned char)95,
        (unsigned char)96,      (unsigned char)65,      (unsigned char)66,      (unsigned char)67,
        (unsigned char)68,      (unsigned char)69,      (unsigned char)70,      (unsigned char)71,
        (unsigned char)72,      (unsigned char)73,      (unsigned char)74,      (unsigned char)75,
        (unsigned char)76,      (unsigned char)77,      (unsigned char)78,      (unsigned char)79,
        (unsigned char)80,      (unsigned char)81,      (unsigned char)82,      (unsigned char)83,
        (unsigned char)84,      (unsigned char)85,      (unsigned char)86,      (unsigned char)87,
        (unsigned char)88,      (unsigned char)89,      (unsigned char)90,      (unsigned char)123,
        (unsigned char)124,      (unsigned char)125,      (unsigned char)126,      (unsigned char)127,
        (unsigned char)128,      (unsigned char)129,      (unsigned char)130,      (unsigned char)131,
        (unsigned char)132,      (unsigned char)133,      (unsigned char)134,      (unsigned char)135,
        (unsigned char)136,      (unsigned char)137,      (unsigned char)138,      (unsigned char)139,
        (unsigned char)140,      (unsigned char)141,      (unsigned char)142,      (unsigned char)143,
        (unsigned char)144,      (unsigned char)145,      (unsigned char)146,      (unsigned char)147,
        (unsigned char)148,      (unsigned char)149,      (unsigned char)150,      (unsigned char)151,
        (unsigned char)152,      (unsigned char)153,      (unsigned char)154,      (unsigned char)155,
        (unsigned char)156,      (unsigned char)157,      (unsigned char)158,      (unsigned char)159,
        (unsigned char)160,      (unsigned char)161,      (unsigned char)162,      (unsigned char)163,
        (unsigned char)164,      (unsigned char)165,      (unsigned char)166,      (unsigned char)167,
        (unsigned char)168,      (unsigned char)169,      (unsigned char)170,      (unsigned char)171,
        (unsigned char)172,      (unsigned char)173,      (unsigned char)174,      (unsigned char)175,
        (unsigned char)176,      (unsigned char)177,      (unsigned char)178,      (unsigned char)179,
        (unsigned char)180,      (unsigned char)181,      (unsigned char)182,      (unsigned char)183,
        (unsigned char)184,      (unsigned char)185,      (unsigned char)186,      (unsigned char)187,
        (unsigned char)188,      (unsigned char)189,      (unsigned char)190,      (unsigned char)191,
        (unsigned char)192,      (unsigned char)193,      (unsigned char)194,      (unsigned char)195,
        (unsigned char)196,      (unsigned char)197,      (unsigned char)198,      (unsigned char)199,
        (unsigned char)200,      (unsigned char)201,      (unsigned char)202,      (unsigned char)203,
        (unsigned char)204,      (unsigned char)205,      (unsigned char)206,      (unsigned char)207,
        (unsigned char)208,      (unsigned char)209,      (unsigned char)210,      (unsigned char)211,
        (unsigned char)212,      (unsigned char)213,      (unsigned char)214,      (unsigned char)215,
        (unsigned char)216,      (unsigned char)217,      (unsigned char)218,      (unsigned char)219,
        (unsigned char)220,      (unsigned char)221,      (unsigned char)222,      (unsigned char)223,
        (unsigned char)224,      (unsigned char)225,      (unsigned char)226,      (unsigned char)227,
        (unsigned char)228,      (unsigned char)229,      (unsigned char)230,      (unsigned char)231,
        (unsigned char)232,      (unsigned char)233,      (unsigned char)234,      (unsigned char)235,
        (unsigned char)236,      (unsigned char)237,      (unsigned char)238,      (unsigned char)239,
        (unsigned char)240,      (unsigned char)241,      (unsigned char)242,      (unsigned char)243,
        (unsigned char)244,      (unsigned char)245,      (unsigned char)246,      (unsigned char)247,
        (unsigned char)248,      (unsigned char)249,      (unsigned char)250,      (unsigned char)251,
        (unsigned char)252,      (unsigned char)253,      (unsigned char)254,      (unsigned char)255};
int to_lowercase(uchar *msg , int len )
{
  int i ;

  {
  i = 0;
  while (i < len) {
    *(msg + i) = LowerTable[*(msg + i)];
    i ++;
  }
  return (0);
}
}
int to_uppercase(uchar *buf , int n )
{
  int i ;

  {
  i = 0;
  while (i < n) {
    *(buf + i) = UpperTable[*(buf + i)];
    i ++;
  }
  return (0);
}
}
int str_to_uchar4(char const   *addr , uchar *val )
{
  uint___0 tv[4] ;
  unsigned int tmp ;
  uint___0 idx ;
  int i ;
  int n ;
  size_t tmp___0 ;

  {
  tv[0] = (uint___0 )0;
  tmp = 1U;
  while (! (tmp >= 4U)) {
    tv[tmp] = 0U;
    tmp ++;
  }
  idx = (uint___0 )0;
  tmp___0 = strlen(addr);
  n = (int )tmp___0;
  i = 0;
  while (i < n) {
    if ((int const   )*(addr + i) >= 48) {
      if ((int const   )*(addr + i) <= 57) {
        tv[idx] = (tv[idx] * 10U + (uint___0 )*(addr + i)) - 48U;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */
      idx ++;
      if ((int const   )*(addr + i) != 46) {
        *val = (uchar )0;
        return (-1);
      } else
      if (idx == 4U) {
        *val = (uchar )0;
        return (-1);
      }
    }
    i ++;
  }
  i = 0;
  while (i < 4) {
    *(val + i) = (uchar )tv[i];
    i ++;
  }
  return (0);
}
}
int str_to_uchar6(uchar *addr , uchar *val )
{
  ushort___0 tv[8] ;
  unsigned int tmp ;
  int idx ;
  int gap ;
  int gapidx ;
  int hasgap ;
  int i ;
  int n ;
  size_t tmp___0 ;
  char tmp___1 ;
  uchar tmp___2 ;
  uchar tmp___3 ;
  uchar tmp___4 ;

  {
  tv[0] = (ushort___0 )0;
  tmp = 1U;
  while (! (tmp >= 8U)) {
    tv[tmp] = (unsigned short)0;
    tmp ++;
  }
  idx = 0;
  gap = 0;
  gapidx = -1;
  hasgap = 0;
  tmp___0 = strlen((char const   *)addr);
  n = (int )tmp___0;
  to_lowercase(addr, n);
  memset((void *)val, 0, (size_t )16);
  i = 0;
  while (i < n) {
    tmp___1 = (char )*(addr + i);
    if ((int )tmp___1 >= 48) {
      if ((int )tmp___1 <= 57) {
        gap = 0;
        tv[idx] = (ushort___0 )(((int )tv[idx] * 16 + (int )tmp___1) - 48);
      } else {
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */
    if ((int )tmp___1 >= 97) {
      if ((int )tmp___1 <= 122) {
        gap = 0;
        tv[idx] = (ushort___0 )((((int )tv[idx] * 16 + (int )tmp___1) - 97) + 10);
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */
      idx ++;
      if (gap == 1) {
        if (hasgap == 1) {
          return (-1);
        }
        hasgap = 1;
        gapidx = idx - 1;
      }
      if (gap == 0) {
        gap = 1;
      }
      if ((int )tmp___1 != 58) {
        goto _L;
      } else
      if (idx == 8) {
        _L: /* CIL Label */
        tmp___4 = (uchar )0;
        *(val + 3) = tmp___4;
        tmp___3 = tmp___4;
        *(val + 2) = tmp___3;
        tmp___2 = tmp___3;
        *(val + 1) = tmp___2;
        *(val + 0) = tmp___2;
        return (0);
      }
    }
    i ++;
  }
  if (hasgap == 1) {
    i = 0;
    while (i < gapidx) {
      *(val + i * 2) = (uchar )((int )tv[i] / 256);
      *(val + (i * 2 + 1)) = (uchar )((int )tv[i] % 256);
      i ++;
    }
    i = idx - 1;
    while (i >= gapidx) {
      *(val + (((i + 7) - idx) + 1) * 2) = (uchar )((int )tv[i + 1] / 256);
      *(val + ((((i + 7) - idx) + 1) * 2 + 1)) = (uchar )((int )tv[i + 1] % 256);
      i --;
    }
  } else {
    i = 0;
    while (i < 8) {
      *(val + i * 2) = (uchar )((int )tv[i] / 256);
      *(val + (i * 2 + 1)) = (uchar )((int )tv[i] % 256);
      i ++;
    }
  }
  return (0);
}
}
int fix_tail(char *domain )
{
  int len ;
  size_t tmp ;
  uchar c ;

  {
  tmp = strlen((char const   *)domain);
  len = (int )tmp;
  len --;
  c = (uchar )*(domain + len);
  if ((int )c == 13) {
    *(domain + len) = (char)0;
    len --;
  } else
  if ((int )c == 10) {
    *(domain + len) = (char)0;
    len --;
  }
  c = (uchar )*(domain + len);
  if ((int )c == 13) {
    *(domain + len) = (char)0;
    len --;
  } else
  if ((int )c == 10) {
    *(domain + len) = (char)0;
    len --;
  }
  return (0);
}
}
int opr_bit(unsigned short *bit , int off , int set )
{
  unsigned short mask ;

  {
  mask = (unsigned short)1;
  if (off > 15) {
    return (-1);
  } else
  if (off < 0) {
    return (-1);
  }
  mask = (unsigned short )((int )mask << off);
  if (set == 0) {
    mask = (unsigned short )(~ ((int )mask));
  }
  if (set == 0) {
    *bit = (unsigned short )((int )*bit & (int )mask);
  } else {
    *bit = (unsigned short )((int )*bit | (int )mask);
  }
  return (0);
}
}
int set_bit(unsigned short *bit , int off )
{


  {
  opr_bit(bit, off, 1);
  return (0);
}
}
int clr_bit(unsigned short *bit , int off )
{


  {
  opr_bit(bit, off, 0);
  return (0);
}
}
int tst_bit(unsigned short const   bit , int off )
{
  unsigned short mask ;

  {
  mask = (unsigned short)1;
  if (off > 15) {
    return (-1);
  } else
  if (off < 0) {
    return (-1);
  }
  mask = (unsigned short )((int )mask << off);
  if (((int const   )bit & (int const   )mask) == 0) {
    return (0);
  }
  return (1);
}
}
int get_time_usage(struct timeval *tv , int start )
{
  ulong___0 msec ;
  struct timeval tmp ;

  {
  msec = (ulong___0 )0;
  if ((unsigned long )tv == (unsigned long )((void *)0)) {
    return (-1);
  }
  if (start == 1) {
    gettimeofday((struct timeval * __restrict  )tv, (void * __restrict  )((void *)0));
  } else {
    tmp = *tv;
    gettimeofday((struct timeval * __restrict  )tv, (void * __restrict  )((void *)0));
    if (tv->tv_usec < tmp.tv_usec) {
      msec = (ulong___0 )(((tv->tv_usec - tmp.tv_usec) + 1000000L) / 1000L);
      (tv->tv_sec) --;
    }
    printf((char const   * __restrict  )"%lu s,%lu ms\n", tv->tv_sec - tmp.tv_sec,
           msec);
  }
  return (0);
}
}
int is_uppercase(int c )
{


  {
  if (c >= 65) {
    if (c <= 90) {
      return (1);
    }
  }
  return (0);
}
}
int is_lowercase(int c )
{


  {
  if (c >= 97) {
    if (c <= 122) {
      return (1);
    }
  }
  return (0);
}
}
int empty_function(int i )
{


  {
  return (0);
}
}
void insert_mem_bar(void)
{
  int i ;
  int size ;
  long tmp ;
  uchar *ptr ;
  void *tmp___0 ;

  {
  tmp = random();
  size = (int )(tmp % 99L + 10000L);
  tmp___0 = malloc((size_t )size);
  ptr = (uchar *)tmp___0;
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    return;
  }
  i = 0;
  while (i < size) {
    *(ptr + i) = (uchar )i;
    i ++;
  }
  free((void *)ptr);
  return;
}
}
int test_lock(pthread_spinlock_t *l )
{
  int tmp ;

  {
  tmp = pthread_spin_trylock(l);
  if (tmp < 0) {
    return (-1);
  }
  pthread_spin_unlock(l);
  return (0);
}
}
void dbg_print_bit(unsigned short bit )
{
  int i ;
  unsigned short val ;

  {
  val = (unsigned short )(1 << 15);
  i = 0;
  while (i < 16) {
    if (((int )bit & (int )val) == 0) {
      printf((char const   * __restrict  )"0");
    } else {
      printf((char const   * __restrict  )"1");
    }
    if ((i + 1) % 4 == 0) {
      if (i != 15) {
        printf((char const   * __restrict  )",");
      }
    }
    val = (unsigned short )((int )val >> 1);
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  return;
}
}
void print_hex(uchar *val , int n )
{
  int i ;

  {
  i = 0;
  while (i < n) {
    printf((char const   * __restrict  )"%x,", (int )*(val + i));
    i ++;
  }
  printf((char const   * __restrict  )"\n");
  return;
}
}
void dns_error(int level , char *msg )
{


  {
  dbg("Error:%s\n", msg);
  fflush(stdout);
  if (level == 0) {
    exit(-1);
  }
  return;
}
}
int dbg(char const   *format  , ...)
{
  int ret ;
  va_list___0 ap ;

  {
  __builtin_va_start(ap, format);
  printf((char const   * __restrict  )"dbg:");
  ret = vprintf((char const   * __restrict  )format, ap);
  __builtin_va_end(ap);
  return (ret);
}
}
hashval_t uint_hash_function(void *ptr )
{
  uint___0 key ;

  {
  key = *((uint___0 *)ptr);
  key += ~ (key << 15);
  key ^= key >> 10;
  key += key << 3;
  key ^= key >> 6;
  key += ~ (key << 11);
  key ^= key >> 16;
  return (key);
}
}
hashval_t nocase_char_hash_function(void *argv , int klen )
{
  int len ;
  int tmp ;
  uchar *buf ;
  hashval_t hash ;
  uchar *tmp___0 ;
  int tmp___1 ;

  {
  if (klen == 2) {
    tmp = 1;
  } else {
    tmp = klen;
  }
  len = tmp;
  buf = (uchar *)argv;
  hash = (hashval_t )5381;
  while (1) {
    tmp___1 = len;
    len --;
    if (! tmp___1) {
      break;
    }
    tmp___0 = buf;
    buf ++;
    hash = ((hash << 5) + hash) + (hashval_t )*tmp___0;
  }
  return (hash);
}
}
#pragma merger("0","/tmp/cil-ErEAriE4.i","-g,-Wall")
extern unsigned int sleep(unsigned int __seconds ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_spin_init)(pthread_spinlock_t *__lock ,
                                                                                              int __pshared ) ;
struct rbtree *create_rbtree(comprbt *c , void *argv ) ;
void *delete_node(struct rbtree *rbt , struct rbnode *nd ) ;
int insert_node(struct rbtree *rbt , struct rbnode *pnd ) ;
struct rbnode *find_node(struct rbtree *rbt , void *key ) ;
struct rbnode *min_node(struct rbtree *rbt ) ;
uint___0 get_rbt_size(struct rbtree *rbt ) ;
int rbtree_test(void) ;
static void left_rotate(struct rbtree *rbt , struct rbnode *node )
{
  struct rbnode *tmp ;

  {
  tmp = node->right;
  node->right = tmp->left;
  if ((unsigned long )tmp->left != (unsigned long )(& rbt->nil)) {
    (tmp->left)->parent = node;
  }
  tmp->parent = node->parent;
  if ((unsigned long )node->parent == (unsigned long )(& rbt->nil)) {
    rbt->root = tmp;
  } else
  if ((unsigned long )node == (unsigned long )(node->parent)->left) {
    (node->parent)->left = tmp;
  } else {
    (node->parent)->right = tmp;
  }
  tmp->left = node;
  node->parent = tmp;
  return;
}
}
static void right_rotate(struct rbtree *rbt , struct rbnode *node )
{
  struct rbnode *tmp ;

  {
  tmp = node->left;
  node->left = tmp->right;
  if ((unsigned long )tmp->right != (unsigned long )(& rbt->nil)) {
    (tmp->right)->parent = node;
  }
  tmp->parent = node->parent;
  if ((unsigned long )node->parent == (unsigned long )(& rbt->nil)) {
    rbt->root = tmp;
  } else
  if ((unsigned long )node == (unsigned long )(node->parent)->left) {
    (node->parent)->left = tmp;
  } else {
    (node->parent)->right = tmp;
  }
  tmp->right = node;
  node->parent = tmp;
  return;
}
}
static void insert_fixup(struct rbtree *rbt , struct rbnode *nd )
{
  struct rbnode *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  while ((nd->parent)->color == 1) {
    if ((unsigned long )nd->parent == (unsigned long )((nd->parent)->parent)->left) {
      tmp = ((nd->parent)->parent)->right;
      if (tmp->color == 1) {
        tmp___0 = 0;
        tmp->color = tmp___0;
        (nd->parent)->color = tmp___0;
        ((nd->parent)->parent)->color = 1;
        nd = (nd->parent)->parent;
      } else {
        if ((unsigned long )nd == (unsigned long )(nd->parent)->right) {
          nd = nd->parent;
          left_rotate(rbt, nd);
        }
        (nd->parent)->color = 0;
        ((nd->parent)->parent)->color = 1;
        right_rotate(rbt, (nd->parent)->parent);
      }
    } else {
      tmp = ((nd->parent)->parent)->left;
      if (tmp->color == 1) {
        tmp___1 = 0;
        tmp->color = tmp___1;
        (nd->parent)->color = tmp___1;
        ((nd->parent)->parent)->color = 1;
        nd = (nd->parent)->parent;
      } else {
        if ((unsigned long )nd == (unsigned long )(nd->parent)->left) {
          nd = nd->parent;
          right_rotate(rbt, nd);
        }
        (nd->parent)->color = 0;
        ((nd->parent)->parent)->color = 1;
        left_rotate(rbt, (nd->parent)->parent);
      }
    }
  }
  (rbt->root)->color = 0;
  return;
}
}
struct rbnode *find_node(struct rbtree *rbt , void *key )
{
  struct rbnode *nd ;
  int i ;

  {
  nd = & rbt->nil;
  nd = rbt->root;
  while ((unsigned long )nd != (unsigned long )(& rbt->nil)) {
    i = (*(rbt->c))(nd->key, key, rbt->argv);
    if (i > 0) {
      nd = nd->left;
    }
    if (i < 0) {
      nd = nd->right;
    }
    if ((unsigned long )nd == (unsigned long )(& rbt->nil)) {
      break;
    }
    if (i == 0) {
      return (nd);
    }
  }
  return ((struct rbnode *)((void *)0));
}
}
int insert_node(struct rbtree *rbt , struct rbnode *pnd )
{
  struct rbnode *tmp ;
  struct rbnode *itor ;
  struct rbnode *nd ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct rbnode *tmp___3 ;

  {
  tmp = & rbt->nil;
  itor = rbt->root;
  tmp___0 = malloc(sizeof(struct rbnode ));
  nd = (struct rbnode *)tmp___0;
  if ((unsigned long )nd == (unsigned long )((void *)0)) {
    return (-1);
  }
  *nd = *pnd;
  while ((unsigned long )itor != (unsigned long )(& rbt->nil)) {
    tmp = itor;
    tmp___1 = (*(rbt->c))(itor->key, nd->key, rbt->argv);
    if (tmp___1 > 0) {
      itor = itor->left;
    } else {
      itor = itor->right;
    }
  }
  nd->parent = tmp;
  if ((unsigned long )tmp == (unsigned long )(& rbt->nil)) {
    rbt->root = nd;
  } else {
    tmp___2 = (*(rbt->c))(tmp->key, nd->key, rbt->argv);
    if (tmp___2 > 0) {
      tmp->left = nd;
    } else {
      tmp->right = nd;
    }
  }
  tmp___3 = & rbt->nil;
  nd->right = tmp___3;
  nd->left = tmp___3;
  nd->color = 1;
  insert_fixup(rbt, nd);
  (rbt->size) ++;
  return (0);
}
}
static struct rbnode *rbt_successor(struct rbtree *rbt , struct rbnode *nd )
{
  struct rbnode *min ;

  {
  min = & rbt->nil;
  if ((unsigned long )nd->right != (unsigned long )(& rbt->nil)) {
    min = nd->right;
    while ((unsigned long )min->left != (unsigned long )(& rbt->nil)) {
      min = min->left;
    }
    return (min);
  }
  min = nd->parent;
  while (1) {
    if ((unsigned long )min != (unsigned long )(& rbt->nil)) {
      if (! ((unsigned long )nd == (unsigned long )min->right)) {
        break;
      }
    } else {
      break;
    }
    nd = min;
    min = min->parent;
  }
  return (min);
}
}
static void delete_fixup(struct rbtree *rbt , struct rbnode *nd )
{
  struct rbnode *tmp ;

  {
  tmp = & rbt->nil;
  while (1) {
    if ((unsigned long )nd != (unsigned long )rbt->root) {
      if (! (nd->color == 0)) {
        break;
      }
    } else {
      break;
    }
    if ((unsigned long )nd == (unsigned long )(nd->parent)->left) {
      tmp = (nd->parent)->right;
      if (tmp->color == 1) {
        tmp->color = 0;
        (nd->parent)->color = 1;
        left_rotate(rbt, nd->parent);
        tmp = (nd->parent)->right;
      }
      if ((tmp->left)->color == 0) {
        if ((tmp->right)->color == 0) {
          tmp->color = 1;
          nd = nd->parent;
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */
        if ((tmp->right)->color == 0) {
          (tmp->left)->color = 0;
          tmp->color = 1;
          right_rotate(rbt, tmp);
          tmp = (nd->parent)->right;
        }
        tmp->color = (nd->parent)->color;
        (nd->parent)->color = 0;
        (tmp->right)->color = 0;
        left_rotate(rbt, nd->parent);
        nd = rbt->root;
      }
    } else {
      tmp = (nd->parent)->left;
      if (tmp->color == 1) {
        tmp->color = 0;
        (nd->parent)->color = 1;
        right_rotate(rbt, nd->parent);
        tmp = (nd->parent)->left;
      }
      if ((tmp->right)->color == 0) {
        if ((tmp->left)->color == 0) {
          tmp->color = 1;
          nd = nd->parent;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */
        if ((tmp->left)->color == 0) {
          (tmp->right)->color = 0;
          tmp->color = 1;
          left_rotate(rbt, tmp);
          tmp = (nd->parent)->left;
        }
        tmp->color = (nd->parent)->color;
        (nd->parent)->color = 0;
        (tmp->left)->color = 0;
        right_rotate(rbt, nd->parent);
        nd = rbt->root;
      }
    }
  }
  nd->color = 0;
  return;
}
}
struct rbnode *min_node(struct rbtree *rbt )
{
  struct rbnode *tmp ;
  struct rbnode *ret ;

  {
  tmp = rbt->root;
  ret = & rbt->nil;
  if ((unsigned long )tmp == (unsigned long )(& rbt->nil)) {
    return ((struct rbnode *)((void *)0));
  }
  while ((unsigned long )tmp != (unsigned long )(& rbt->nil)) {
    ret = tmp;
    tmp = tmp->left;
  }
  if ((unsigned long )ret == (unsigned long )(& rbt->nil)) {
    return ((struct rbnode *)((void *)0));
  }
  return (ret);
}
}
void *delete_node(struct rbtree *rbt , struct rbnode *nd )
{
  struct ttlnode *val ;
  struct rbnode *ret ;
  struct rbnode *tmp ;
  struct rbnode *itor ;

  {
  val = (struct ttlnode *)((void *)0);
  ret = nd;
  if ((unsigned long )nd == (unsigned long )((void *)0)) {
    return ((void *)0);
  } else
  if ((unsigned long )rbt == (unsigned long )((void *)0)) {
    return ((void *)0);
  }
  val = (struct ttlnode *)nd->key;
  if ((unsigned long )nd->left == (unsigned long )(& rbt->nil)) {
    tmp = nd;
  } else
  if ((unsigned long )nd->right == (unsigned long )(& rbt->nil)) {
    tmp = nd;
  } else {
    tmp = rbt_successor(rbt, nd);
  }
  if ((unsigned long )tmp->left != (unsigned long )(& rbt->nil)) {
    itor = tmp->left;
  } else {
    itor = tmp->right;
  }
  itor->parent = tmp->parent;
  if ((unsigned long )tmp->parent == (unsigned long )(& rbt->nil)) {
    rbt->root = itor;
  } else
  if ((unsigned long )tmp == (unsigned long )(tmp->parent)->left) {
    (tmp->parent)->left = itor;
  } else {
    (tmp->parent)->right = itor;
  }
  if ((unsigned long )tmp != (unsigned long )itor) {
    nd->key = tmp->key;
  }
  if (tmp->color == 0) {
    delete_fixup(rbt, itor);
  }
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    printf((char const   * __restrict  )"ret is null\n");
  }
  free((void *)tmp);
  (rbt->size) --;
  return ((void *)val);
}
}
struct rbtree *create_rbtree(comprbt *c , void *argv )
{
  struct rbtree *rbt ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct rbtree ));
  rbt = (struct rbtree *)tmp;
  if ((unsigned long )rbt == (unsigned long )((void *)0)) {
    return ((struct rbtree *)((void *)0));
  }
  rbt->argv = argv;
  rbt->c = c;
  rbt->size = (uint___0 )0;
  pthread_spin_init(& rbt->lock, 0);
  rbt->nil.parent = & rbt->nil;
  rbt->nil.left = & rbt->nil;
  rbt->nil.right = & rbt->nil;
  rbt->nil.color = 0;
  rbt->nil.key = (void *)0;
  rbt->root = & rbt->nil;
  return (rbt);
}
}
uint___0 get_rbt_size(struct rbtree *rbt )
{


  {
  return (rbt->size);
}
}
int free_rbtree(struct rbtree *rbt )
{
  uint___0 tmp ;

  {
  tmp = get_rbt_size(rbt);
  if (tmp > 0U) {
    return (-1);
  }
  free((void *)rbt);
  return (0);
}
}
int rbtree_test(void)
{
  int i ;
  int j ;
  int len ;
  int slice ;
  int ret ;
  struct rbnode node ;
  struct rbnode *pn ;
  struct ttlnode *tn ;
  struct rbtree *rbt ;
  long tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  pn = (struct rbnode *)((void *)0);
  tn = (struct ttlnode *)((void *)0);
  rbt = (struct rbtree *)((void *)0);
  rbt = create_rbtree(& rbt_comp_ttl_gt, (void *)0);
  if ((unsigned long )rbt == (unsigned long )((void *)0)) {
    dns_error(0, (char *)"create rbtree");
  }
  node = rbt->nil;
  slice = 8000000;
  j = 0;
  while (j < slice) {
    tmp = random();
    len = (int )(tmp % 30L);
    tmp___0 = malloc(sizeof(struct ttlnode ) + (unsigned long )len);
    tn = (struct ttlnode *)tmp___0;
    if ((unsigned long )tn == (unsigned long )((void *)0)) {
      printf((char const   * __restrict  )"oom\n");
    }
    tn->exp = (uint___0 )j;
    i = 0;
    while (i < len) {
      *(tn->data + i) = (uchar )(97 + i);
      i ++;
    }
    node.key = (void *)tn;
    ret = insert_node(rbt, & node);
    if (ret != 0) {
      printf((char const   * __restrict  )"insert error\n");
    }
    j ++;
  }
  printf((char const   * __restrict  )"insert all\n");
  sleep(2U);
  j = 0;
  while (j < slice) {
    pn = min_node(rbt);
    if ((unsigned long )pn != (unsigned long )((void *)0)) {
      tmp___1 = delete_node(rbt, pn);
      tn = (struct ttlnode *)tmp___1;
      free((void *)tn);
    } else {
      printf((char const   * __restrict  )"error\n");
    }
    j ++;
  }
  printf((char const   * __restrict  )"delete all\n");
  sleep(5U);
  tmp___2 = free_rbtree(rbt);
  if (tmp___2 != 0) {
    dns_error(0, (char *)"free");
  }
  return (0);
}
}
#pragma merger("0","/tmp/cil-detrVtJE.i","-g,-Wall")
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  *__addr ,
                                              socklen_t __len ) ;
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
extern  __attribute__((__nothrow__)) uint16_t ntohs(uint16_t __netshort )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) uint32_t htonl(uint32_t __hostlong )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) uint16_t htons(uint16_t __hostshort )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int epoll_create(int __size ) ;
extern  __attribute__((__nothrow__)) int epoll_ctl(int __epfd , int __op , int __fd ,
                                                   struct epoll_event *__event ) ;
extern  __attribute__((__nothrow__)) int inet_pton(int __af , char const   * __restrict  __cp ,
                                                   void * __restrict  __buf ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
extern int fcntl(int __fd , int __cmd  , ...) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
int create_socket(int port , int proto , uchar *addr ) ;
int add_backdoor(int fd ) ;
int udp_write_info(mbuf_type *mbuf , int vi ) ;
int udp_read_msg(mbuf_type *mbuf , int visible ) ;
int tcp_write_info(mbuf_type *mbuf , int vi ) ;
int tcp_read_dns_msg(mbuf_type *mbuf , uint___0 max , int vi ) ;
int connect_to(struct sockinfo *si ) ;
int set_recv_timeout(int fd , int sec , int usec ) ;
int set_non_block(int fd ) ;
int set_sock_buff(int fd , int m ) ;
int check_client_addr(struct sockaddr_in *addr ) ;
int dbg_print_addr(struct sockaddr_in *addr ) ;
int make_bin_from_str(uchar *bin , char const   *str ) ;
int make_addr_from_bin(struct sockaddr_in *addr , uchar *data ) ;
int check_client_addr(struct sockaddr_in *addr )
{


  {
  return (0);
}
}
int add_backdoor(int fd )
{
  int epfd ;
  int ret ;
  struct epoll_event ev ;

  {
  ev.events = (uint32_t )0;
  ev.data.ptr = (void *)0;
  epfd = epoll_create(1000);
  if (epfd < 0) {
    dns_error(0, (char *)"epoll bd");
  }
  ev.data.fd = fd;
  ev.events = (uint32_t )1;
  ret = epoll_ctl(epfd, 1, ev.data.fd, & ev);
  if (ret < 0) {
    dns_error(0, (char *)"epoll add udp backdoor");
  }
  return (epfd);
}
}
int set_recv_timeout(int fd , int sec , int usec )
{
  int ret ;
  struct timeval tv ;

  {
  tv.tv_sec = (__time_t )sec;
  tv.tv_usec = (__suseconds_t )usec;
  ret = setsockopt(fd, 1, 20, (void const   *)((char *)(& tv)), (socklen_t )sizeof(struct timeval ));
  return (ret);
}
}
int create_socket(int port , int proto , uchar *addr )
{
  int fd ;
  int pt ;
  struct sockaddr_in srv ;
  int tmp ;

  {
  fd = -1;
  pt = -1;
  if (proto == 2) {
    pt = 2;
  } else
  if (proto == 1) {
    pt = 1;
  }
  fd = socket(2, pt, 0);
  if (fd <= 0) {
    return (-1);
  }
  srv.sin_family = (sa_family_t )2;
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
    srv.sin_addr.s_addr = htonl((in_addr_t )0);
  } else {
    inet_pton(2, (char const   * __restrict  )((char const   *)addr), (void * __restrict  )(& srv.sin_addr));
  }
  srv.sin_port = htons((uint16_t )port);
  tmp = bind(fd, (struct sockaddr  const  *)((SA *)(& srv)), (socklen_t )sizeof(srv));
  if (tmp < 0) {
    perror("bind:");
    return (-1);
  }
  if (proto == 1) {
    listen(fd, 512);
  }
  return (fd);
}
}
int connect_to(struct sockinfo *si )
{
  int ret ;
  socklen_t len ;
  int *tmp ;
  int *tmp___0 ;

  {
  ret = 0;
  len = (socklen_t )sizeof(struct sockaddr_in );
  ret = connect(si->fd, (struct sockaddr  const  *)((SA *)(& si->addr)), len);
  if (ret < 0) {
    tmp = __errno_location();
    if (*tmp == 115) {
      return (0);
    }
    tmp___0 = __errno_location();
    printf((char const   * __restrict  )"%d,%d,", si->fd, *tmp___0);
    perror("conn");
    return (-1);
  }
  return (0);
}
}
int tcp_write_info(mbuf_type *mbuf , int vi )
{
  int i ;
  int ret ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
  tmp = send(mbuf->fd, (void const   *)mbuf->buf, (size_t )mbuf->buflen, 16384);
  ret = (int )tmp;
  if (ret < 0) {
    tmp___0 = __errno_location();
    printf((char const   * __restrict  )"%d,", *tmp___0);
    perror("tcp send");
  }
  if (vi == 1) {
    printf((char const   * __restrict  )"fd is %d\n", mbuf->fd);
    i = 0;
    while (i < mbuf->buflen) {
      printf((char const   * __restrict  )"%x,", (int )*(mbuf->buf + i));
      i ++;
    }
    printf((char const   * __restrict  )"\n");
  }
  return (ret);
}
}
int udp_write_info(mbuf_type *mbuf , int vi )
{
  int i ;
  int ret ;
  socklen_t len ;
  ssize_t tmp ;

  {
  if (vi) {
    dbg_print_addr(mbuf->addr);
    i = 0;
    while (i < mbuf->buflen) {
      if (i % 16 == 0) {
        printf((char const   * __restrict  )"\n");
      }
      printf((char const   * __restrict  )"%02x,", (int )*(mbuf->buf + i));
      i ++;
    }
    printf((char const   * __restrict  )"\n");
  }
  len = (socklen_t )sizeof(struct sockaddr_in );
  (mbuf->addr)->sin_family = (sa_family_t )2;
  tmp = sendto(mbuf->fd, (void const   *)mbuf->buf, (size_t )mbuf->buflen, 0, (struct sockaddr  const  *)((SA *)mbuf->addr),
               len);
  ret = (int )tmp;
  return (ret);
}
}
int tcp_read_dns_msg(mbuf_type *mbuf , uint___0 max , int vi )
{
  int ret ;
  int tp ;
  int rcvnum ;
  uchar buf[4] ;
  unsigned int tmp ;
  ushort___0 le ;
  ssize_t tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  ret = 0;
  buf[0] = (uchar )0;
  tmp = 1U;
  while (! (tmp >= 4U)) {
    buf[tmp] = (unsigned char)0;
    tmp ++;
  }
  le = (ushort___0 )0;
  tmp___0 = recv(mbuf->fd, (void *)(buf), (size_t )2, 0);
  tp = (int )tmp___0;
  if (tp < 0) {
    printf((char const   * __restrict  )"%d,", mbuf->fd);
    perror("tp");
    return (-1);
  }
  if (tp == 0) {
    return (0);
  }
  memcpy((void * __restrict  )(& le), (void const   * __restrict  )(buf), sizeof(ushort___0 ));
  le = ntohs(le);
  if ((uint___0 )le > max) {
    printf((char const   * __restrict  )"too large %d,%u,%d\n", mbuf->fd, (int )le,
           max);
    return (-1);
  }
  while (ret < (int )le) {
    tmp___1 = recv(mbuf->fd, (void *)(mbuf->buf + ret), (size_t )(mbuf->buflen - ret),
                   0);
    rcvnum = (int )tmp___1;
    if (rcvnum < 0) {
      tmp___2 = __errno_location();
      if (*tmp___2 == 11) {
        continue;
      } else {
        tmp___3 = __errno_location();
        if (*tmp___3 == 11) {
          continue;
        }
      }
      printf((char const   * __restrict  )"tcp data %d,%d,%d", mbuf->fd, (int )le,
             ret);
      perror("tcp read");
      return (-1);
    }
    if (rcvnum == 0) {
      ret = -1;
      break;
    }
    ret += rcvnum;
  }
  return (ret);
}
}
int udp_read_msg(mbuf_type *mbuf , int visible )
{
  int ret ;
  int i ;
  socklen_t len ;
  ssize_t tmp ;

  {
  len = (socklen_t )sizeof(struct sockaddr_in );
  tmp = recvfrom(mbuf->fd, (void * __restrict  )mbuf->buf, (size_t )mbuf->buflen,
                 0, (struct sockaddr * __restrict  )((SA *)mbuf->addr), (socklen_t * __restrict  )(& len));
  ret = (int )tmp;
  if (ret < 0) {
    return (ret);
  }
  if (visible) {
    i = 0;
    while (i < ret) {
      printf((char const   * __restrict  )"%x,", (int )*(mbuf->buf + i));
      i ++;
    }
    printf((char const   * __restrict  )"\n");
  }
  return (ret);
}
}
int set_sock_buff(int fd , int m )
{
  int ret ;
  int bufsize ;

  {
  bufsize = (m * 1024) * 1024;
  if (fd <= 0) {
    return (-1);
  }
  ret = setsockopt(fd, 1, 8, (void const   *)((uchar const   *)(& bufsize)), (socklen_t )sizeof(int ));
  return (ret);
}
}
int set_non_block(int fd )
{
  int opt ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = fcntl(fd, 3, 0);
  opt = tmp;
  if (opt < 0) {
    return (-1);
  }
  opt |= 2048;
  tmp___0 = fcntl(fd, 4, opt);
  return (tmp___0);
}
}
int make_bin_from_str(uchar *bin , char const   *str )
{
  int i ;
  uchar val ;

  {
  val = (uchar )0;
  i = 0;
  while (i < 4) {
    while (1) {
      if ((int const   )*(str + 0) != 46) {
        if (! ((int const   )*(str + 0) != 0)) {
          break;
        }
      } else {
        break;
      }
      val = (uchar )(((int )val * 10 + (int )*(str + 0)) - 48);
      str ++;
    }
    str ++;
    *(bin + 0) = val;
    val = (uchar )0;
    bin ++;
    i ++;
  }
  return (0);
}
}
int make_addr_from_bin(struct sockaddr_in *addr , uchar *data )
{
  uchar ipv4[16] ;
  unsigned int tmp ;
  int idx ;
  int i ;
  ushort___0 val ;

  {
  ipv4[0] = (uchar )0;
  tmp = 1U;
  while (! (tmp >= 16U)) {
    ipv4[tmp] = (unsigned char)0;
    tmp ++;
  }
  idx = 0;
  val = (ushort___0 )0;
  if ((int )*(data + 0) == 0) {
    if ((int )*(data + 1) == 0) {
      if ((int )*(data + 2) == 0) {
        if ((int )*(data + 3) == 0) {
          return (-1);
        }
      }
    }
  }
  i = 0;
  while (i < 4) {
    val = (ushort___0 )*(data + i);
    if ((int )val > 99) {
      ipv4[idx] = (uchar )((int )val / 100 + 48);
      idx ++;
    }
    if ((int )val > 9) {
      ipv4[idx] = (uchar )(((int )val % 100) / 10 + 48);
      idx ++;
    }
    ipv4[idx] = (uchar )((int )val % 10 + 48);
    idx ++;
    ipv4[idx] = (uchar )'.';
    idx ++;
    i ++;
  }
  ipv4[idx - 1] = (uchar )0;
  i = inet_pton(2, (char const   * __restrict  )((char const   *)(ipv4)), (void * __restrict  )(& addr->sin_addr));
  return (0);
}
}
int dbg_print_addr(struct sockaddr_in *addr )
{
  uint___0 i ;

  {
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
    printf((char const   * __restrict  )"null addr\n");
    return (0);
  }
  i = addr->sin_addr.s_addr;
  printf((char const   * __restrict  )"%u.%u.%u.%u\n", i % 256U, (i / 256U) % 256U,
         ((i / 256U) / 256U) % 256U, ((i / 256U) / 256U) / 256U);
  return (0);
}
}
#pragma merger("0","/tmp/cil-T50FJM8Y.i","-g,-Wall")
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format
                                                 , ...) ;
extern  __attribute__((__nothrow__)) int getpagesize(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_spin_lock)(pthread_spinlock_t *__lock ) ;
time_t global_now ;
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
struct msgcache *init_msgcache(int n ) ;
void free_msgcache(struct msgcache *mc ) ;
unsigned int const   MAX_ELE_NUM ;
enum rrtype  const  support_type[9] ;
struct htable *htable_create(hashfunc *h , comparefunc *c , int size , int num ) ;
int htable_insert(struct htable *ht , uchar *key , int klen , int type , uchar *val ,
                  int replace , struct mvalue *mv , hashval_t *hashd ) ;
uchar *htable_delete(struct htable *ht , uchar *key , int klen , int type , hashval_t hashd ) ;
int htable_find(struct htable *ht , uchar *key , int klen , int type , uchar *buffer ,
                int vlen , struct mvalue *md , hashval_t *hashd ) ;
int htable_find_io(struct htable *ht , int idx , uint32_t limit , struct rbtree *rbt ,
                   int ttl_update ) ;
uint___0 get_pre_mem_hash(void *argv , int klen , hashval_t *hash ) ;
int find_record_with_ttl(struct htable *ht , uchar *key , int klen , int type , uchar *val ,
                         int vlen , struct mvalue *md , hashval_t *hash ) ;
int htable_find_list_io(struct htable *ht , int idx , int off , int *typeoff , uchar **buffer ) ;
int htable_find_list(struct htable *ht , uchar *key , int typeoff , int idx , uchar **buffer ) ;
uchar *htable_delete_list_io(struct htable *ht , int typeoff , int idx , int off ) ;
uchar *htable_delete_list(struct htable *ht , uchar *key , int typeoff , int idx ) ;
int htable_insert_list(struct htable *ht , uchar *key , int klen , int type , uchar *val ,
                       int replace , struct mvalue *mv , hashval_t *hashd ) ;
int check_support_type(ushort___0 type ) ;
unsigned int const   MAX_ELE_NUM  =    (uint___0 const   )1000000;
struct msgcache *init_msgcache(int n )
{
  struct msgcache *mc ;
  int pgsz ;
  void *tmp ;
  uint64_t tmp___0 ;

  {
  mc = (struct msgcache *)((void *)0);
  if (n < 1) {
    return ((struct msgcache *)((void *)0));
  } else
  if (n > 5000) {
    return ((struct msgcache *)((void *)0));
  }
  pgsz = getpagesize();
  tmp = malloc(sizeof(struct msgcache ) + (unsigned long )(pgsz * n));
  mc = (struct msgcache *)tmp;
  if ((unsigned long )mc == (unsigned long )((void *)0)) {
    return ((struct msgcache *)((void *)0));
  }
  mc->size = (uint32_t )(pgsz * n);
  pthread_spin_init(& mc->lock, 0);
  tmp___0 = (uint64_t )0;
  mc->tail = tmp___0;
  mc->head = tmp___0;
  mc->pkt = (uint32_t )0;
  return (mc);
}
}
void free_msgcache(struct msgcache *mc )
{


  {
  if ((unsigned long )mc != (unsigned long )((void *)0)) {
    free((void *)mc);
  }
  return;
}
}
int get_mvalue_len(uchar *val )
{
  struct mvalue *mv ;

  {
  mv = (struct mvalue *)val;
  return ((int )mv->len);
}
}
int ttl_expired(uchar *val )
{
  struct mvalue *mv ;
  uint___0 tx ;

  {
  mv = (struct mvalue *)val;
  tx = (uint___0 )global_now;
  if (mv->ttl == 604801U) {
    return (0);
  }
  if (mv->ttl < tx) {
    return (1);
  }
  return (0);
}
}
static int deep_copy(uchar *from , uchar *to , int tlen )
{
  struct mvalue *mv ;
  int sz ;

  {
  mv = (struct mvalue *)from;
  sz = (int )(((unsigned long )mv->len + sizeof(struct mvalue )) + (unsigned long )mv->seg * sizeof(uint16_t ));
  if (sz >= tlen) {
    return (-1);
  }
  (mv->hits) ++;
  memcpy((void * __restrict  )to, (void const   * __restrict  )from, (size_t )sz);
  return (sz);
}
}
uint___0 get_pre_mem_hash(void *argv , int klen , hashval_t *hash )
{
  uint___0 ret ;

  {
  ret = (uint___0 )0;
  if (*hash == 0U) {
    *hash = nocase_char_hash_function(argv, klen);
  }
  ret = (*hash / 10U) % 10U;
  return (ret);
}
}
struct htable *htable_create(hashfunc *h , comparefunc *c , int size , int num )
{
  int i ;
  int j ;
  struct htable *ht ;
  void *tmp ;
  struct hdata *tmp___0 ;
  void *tmp___1 ;

  {
  ht = (struct htable *)((void *)0);
  if ((unsigned long )c == (unsigned long )((void *)0)) {
    return ((struct htable *)((void *)0));
  }
  tmp = malloc(sizeof(struct htable ) * (unsigned long )num);
  ht = (struct htable *)tmp;
  if ((unsigned long )ht == (unsigned long )((void *)0)) {
    return ((struct htable *)((void *)0));
  }
  i = 0;
  while (i < num) {
    (ht + i)->h = h;
    if ((unsigned long )h == (unsigned long )((void *)0)) {
      (ht + i)->h = & nocase_char_hash_function;
    }
    (ht + i)->c = c;
    (ht + i)->size = (uint___0 )size;
    (ht + i)->edata = (uchar *)((void *)0);
    (ht + i)->now = (uint___0 )0;
    (ht + i)->mask = (uint___0 )(size - 1);
    pthread_spin_init(& (ht + i)->lock, 0);
    tmp___1 = malloc(sizeof(struct hdata ) * (unsigned long )(ht + i)->size);
    tmp___0 = (struct hdata *)tmp___1;
    (ht + i)->table = tmp___0;
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      j = 0;
      while (j < i) {
        free((void *)(ht + j)->table);
        j ++;
      }
      free((void *)ht);
      return ((struct htable *)((void *)0));
    }
    j = 0;
    while (j < size) {
      ((ht + i)->table + j)->list = (struct hentry *)((void *)0);
      pthread_spin_init(& ((ht + i)->table + j)->lock, 0);
      j ++;
    }
    i ++;
  }
  return (ht);
}
}
void find_io_from_he(struct hentry *he , uint32_t limit , struct rbtree *rbt , int ttl_update )
{
  struct mvalue *mv ;
  int i ;
  int val_num ;
  uchar *val ;
  time_t now ;
  struct ttlnode tn ;
  struct ttlnode *ptn ;
  struct rbnode *pn ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  val_num = 9;
  now = global_now;
  if (! (he->count > 0)) {
    __assert_fail("he->count > 0", "storage.c", 162U, "find_io_from_he");
  }
  i = 0;
  while (i < val_num) {
    val = he->__annonCompField4.vals[i];
    if ((unsigned long )val == (unsigned long )((void *)0)) {
      goto __Cont;
    }
    mv = (struct mvalue *)val;
    if ((time_t )mv->ttl > (now + (time_t )ttl_update) + 1L) {
      if (mv->hits < limit) {
        tn.data = he->key;
        tn.type = (ushort___0 )support_type[i];
        tn.exp = mv->ttl;
        tmp___0 = strlen((char const   *)(he->key));
        tn.dlen = (ushort___0 )(tmp___0 + 1UL);
        tn.lowerdomain = (packet_type *)((void *)0);
        pthread_spin_lock(& rbt->lock);
        pn = find_node(rbt, (void *)(& tn));
        if ((unsigned long )pn != (unsigned long )((void *)0)) {
          tmp___1 = delete_node(rbt, pn);
          ptn = (struct ttlnode *)tmp___1;
          if ((unsigned long )ptn != (unsigned long )((void *)0)) {
            free((void *)ptn->lowerdomain);
            free((void *)ptn);
          } else {
            printf((char const   * __restrict  )"delete error\n");
          }
        }
        pthread_spin_unlock(& rbt->lock);
        free((void *)val);
        he->__annonCompField4.vals[i] = (uchar *)((void *)0);
        (he->count) --;
      }
    }
    if (0 == he->count) {
      break;
    }
    __Cont: /* CIL Label */
    i ++;
  }
  return;
}
}
int htable_find_io(struct htable *ht , int idx , uint32_t limit , struct rbtree *rbt ,
                   int ttl_update )
{
  int debug ;
  struct hdata *hd ;
  struct hentry *he ;
  struct hentry *prev ;
  struct hentry *tmp ;

  {
  debug = 500;
  prev = (struct hentry *)((void *)0);
  if (idx > 65536) {
    return (-1);
  }
  hd = ht->table + idx;
  pthread_spin_lock(& hd->lock);
  if ((unsigned long )hd->list == (unsigned long )((void *)0)) {
    pthread_spin_unlock(& hd->lock);
    return (-1);
  }
  he = hd->list;
  while ((unsigned long )he != (unsigned long )((void *)0)) {
    find_io_from_he(he, limit, rbt, ttl_update);
    if (0 == he->count) {
      tmp = he;
      if ((unsigned long )((void *)0) == (unsigned long )prev) {
        hd->list = he->next;
      } else {
        prev->next = he->next;
      }
      he = he->next;
      free((void *)tmp);
      (hd->now) --;
      pthread_spin_lock(& ht->lock);
      (ht->now) --;
      pthread_spin_unlock(& ht->lock);
    } else {
      prev = he;
      he = he->next;
    }
    debug --;
    if (debug == 0) {
      printf((char const   * __restrict  )"error in storage...\n");
      exit(0);
    }
  }
  pthread_spin_unlock(& hd->lock);
  return (-1);
}
}
uchar *get_val_from_he(struct hentry *he , int type )
{
  uchar *val ;

  {
  if (! (he->count > 0)) {
    __assert_fail("he->count > 0", "storage.c", 263U, "get_val_from_he");
  }
  switch (type) {
  case 1:
  val = he->__annonCompField4.val.A;
  break;
  case 2:
  val = he->__annonCompField4.val.NS;
  break;
  case 5:
  val = he->__annonCompField4.val.CNAME;
  break;
  case 6:
  val = he->__annonCompField4.val.SOA;
  break;
  case 15:
  val = he->__annonCompField4.val.MX;
  break;
  case 16:
  val = he->__annonCompField4.val.TXT;
  break;
  case 28:
  val = he->__annonCompField4.val.AAAA;
  break;
  case 33:
  val = he->__annonCompField4.val.SRV;
  break;
  case 12:
  val = he->__annonCompField4.val.PTR;
  break;
  default:
  val = (uchar *)((void *)0);
  break;
  }
  return (val);
}
}
int htable_find(struct htable *ht , uchar *key , int klen , int type , uchar *buffer ,
                int vlen , struct mvalue *md , hashval_t *hashd )
{
  int idx ;
  int debug ;
  int ret ;
  struct hdata *hd ;
  struct hentry *he ;
  struct mvalue *mx ;
  uchar *val ;
  int tmp ;
  int tmp___0 ;

  {
  debug = 500;
  hd = (struct hdata *)((void *)0);
  he = (struct hentry *)((void *)0);
  mx = (struct mvalue *)((void *)0);
  if (*hashd == 0U) {
    *hashd = (*(ht->h))((void *)key, klen);
  }
  idx = (int )(*hashd & ht->mask);
  hd = ht->table + idx;
  pthread_spin_lock(& hd->lock);
  if ((unsigned long )hd->list == (unsigned long )((void *)0)) {
    pthread_spin_unlock(& hd->lock);
    return (-1);
  }
  he = hd->list;
  while ((unsigned long )he != (unsigned long )((void *)0)) {
    tmp = (*(ht->c))((void *)key, (void *)(he->key));
    if (tmp == 0) {
      val = get_val_from_he(he, type);
      if ((unsigned long )((void *)0) == (unsigned long )val) {
        ret = -1;
      } else
      if ((unsigned long )buffer != (unsigned long )((void *)0)) {
        ret = deep_copy(val, buffer, vlen);
      } else {
        if ((unsigned long )md != (unsigned long )((void *)0)) {
          mx = (struct mvalue *)val;
          *md = *mx;
        }
        ret = 1;
      }
      pthread_spin_unlock(& hd->lock);
      return (ret);
    }
    he = he->next;
    tmp___0 = debug;
    debug --;
    if (tmp___0 == 0) {
      printf((char const   * __restrict  )"error in htable find\n");
      exit(0);
    }
  }
  pthread_spin_unlock(& hd->lock);
  return (-1);
}
}
int find_list_io_from_he(struct hentry *he , int *typeoff , uchar **buffer )
{
  int i ;
  int val_num ;
  uchar *val ;

  {
  val_num = 9;
  if (! (he->count > 0)) {
    __assert_fail("he->count > 0", "storage.c", 356U, "find_list_io_from_he");
  }
  i = *typeoff;
  while (i < val_num) {
    val = he->__annonCompField4.vals[i];
    if ((unsigned long )val == (unsigned long )((void *)0)) {
      goto __Cont;
    }
    *buffer = val;
    *typeoff = i;
    return (1);
    __Cont: /* CIL Label */
    i ++;
  }
  return (0);
}
}
int htable_find_list_io(struct htable *ht , int idx , int off , int *typeoff , uchar **buffer )
{
  int debug ;
  int ret ;
  struct hdata *hd ;
  struct hentry *he ;
  int tmp ;

  {
  debug = 500;
  hd = (struct hdata *)((void *)0);
  he = (struct hentry *)((void *)0);
  hd = ht->table + idx;
  pthread_spin_lock(& hd->lock);
  if ((unsigned long )hd->list == (unsigned long )((void *)0)) {
    pthread_spin_unlock(& hd->lock);
    return (-1);
  }
  he = hd->list;
  while ((unsigned long )he != (unsigned long )((void *)0)) {
    if (off == 0) {
      ret = find_list_io_from_he(he, typeoff, buffer);
      pthread_spin_unlock(& hd->lock);
      return (ret);
    }
    off --;
    he = he->next;
    tmp = debug;
    debug --;
    if (tmp == 0) {
      printf((char const   * __restrict  )"error in htable find list io\n");
      exit(0);
    }
  }
  pthread_spin_unlock(& hd->lock);
  return (-1);
}
}
int get_list_val_from_he(struct hentry *he , int typeoff , uchar **buffer )
{
  uchar *val ;

  {
  if (! (he->count > 0)) {
    __assert_fail("he->count > 0", "storage.c", 408U, "get_list_val_from_he");
  }
  val = he->__annonCompField4.vals[typeoff];
  *buffer = val;
  if ((unsigned long )((void *)0) == (unsigned long )val) {
    return (-1);
  }
  return (1);
}
}
int htable_find_list(struct htable *ht , uchar *key , int typeoff , int idx , uchar **buffer )
{
  int debug ;
  struct hdata *hd ;
  struct hentry *he ;
  mbuf_type *mbuf ;
  int tmp ;
  int tmp___0 ;

  {
  debug = 500;
  hd = (struct hdata *)((void *)0);
  he = (struct hentry *)((void *)0);
  hd = ht->table + idx;
  pthread_spin_lock(& hd->lock);
  if ((unsigned long )hd->list == (unsigned long )((void *)0)) {
    pthread_spin_unlock(& hd->lock);
    return (-1);
  }
  he = hd->list;
  while ((unsigned long )he != (unsigned long )((void *)0)) {
    mbuf = (mbuf_type *)he->__annonCompField4.vals[typeoff];
    if ((unsigned long )mbuf != (unsigned long )((void *)0)) {
      tmp = (*(ht->c))((void *)key, (void *)mbuf->qing);
      if (tmp == 0) {
        *buffer = (uchar *)mbuf;
        pthread_spin_unlock(& hd->lock);
        return (1);
      }
    }
    he = he->next;
    tmp___0 = debug;
    debug --;
    if (tmp___0 == 0) {
      printf((char const   * __restrict  )"error in htable find\n");
      exit(0);
    }
  }
  pthread_spin_unlock(& hd->lock);
  return (-1);
}
}
uchar *delete_val_from_he(struct hentry *he , int type )
{
  uchar **oval ;
  uchar *val ;

  {
  val = (uchar *)((void *)0);
  if (! (he->count > 0)) {
    __assert_fail("he->count > 0", "storage.c", 453U, "delete_val_from_he");
  }
  switch (type) {
  case 1:
  oval = & he->__annonCompField4.val.A;
  break;
  case 2:
  oval = & he->__annonCompField4.val.NS;
  break;
  case 5:
  oval = & he->__annonCompField4.val.CNAME;
  break;
  case 6:
  oval = & he->__annonCompField4.val.SOA;
  break;
  case 15:
  oval = & he->__annonCompField4.val.MX;
  break;
  case 16:
  oval = & he->__annonCompField4.val.TXT;
  break;
  case 28:
  oval = & he->__annonCompField4.val.AAAA;
  break;
  case 33:
  oval = & he->__annonCompField4.val.SRV;
  break;
  case 12:
  oval = & he->__annonCompField4.val.PTR;
  break;
  default:
  return ((uchar *)((void *)0));
  break;
  }
  if ((unsigned long )*oval != (unsigned long )((void *)0)) {
    val = *oval;
    *oval = (uchar *)((void *)0);
    (he->count) --;
  }
  return (val);
}
}
uchar *htable_delete(struct htable *ht , uchar *key , int klen , int type , hashval_t hashd )
{
  hashval_t h ;
  hashval_t tmp ;
  hashval_t tmp___0 ;
  int idx ;
  int debug ;
  struct hdata *hd ;
  struct hentry *he ;
  struct hentry *prev ;
  uchar *val ;
  int tmp___1 ;

  {
  if (hashd) {
    tmp___0 = hashd;
  } else {
    tmp = (*(ht->h))((void *)key, klen);
    tmp___0 = tmp;
  }
  h = tmp___0;
  idx = (int )(h & ht->mask);
  debug = 500;
  hd = (struct hdata *)((void *)0);
  he = (struct hentry *)((void *)0);
  prev = (struct hentry *)((void *)0);
  hd = ht->table + idx;
  pthread_spin_lock(& hd->lock);
  if ((unsigned long )hd->list == (unsigned long )((void *)0)) {
    pthread_spin_unlock(& hd->lock);
    return ((uchar *)((void *)0));
  }
  he = hd->list;
  while ((unsigned long )he != (unsigned long )((void *)0)) {
    tmp___1 = (*(ht->c))((void *)key, (void *)(he->key));
    if (tmp___1 == 0) {
      val = delete_val_from_he(he, type);
      if (0 == he->count) {
        if ((unsigned long )((void *)0) == (unsigned long )prev) {
          hd->list = he->next;
        } else {
          prev->next = he->next;
        }
        free((void *)he);
        (hd->now) --;
        pthread_spin_lock(& ht->lock);
        (ht->now) --;
        pthread_spin_unlock(& ht->lock);
      }
      pthread_spin_unlock(& hd->lock);
      return (val);
    }
    prev = he;
    he = he->next;
    debug --;
    if (debug == 0) {
      printf((char const   * __restrict  )"error in storage\n");
      exit(0);
    }
  }
  pthread_spin_unlock(& hd->lock);
  return ((uchar *)((void *)0));
}
}
uchar *delete_list_val_from_he(struct hentry *he , int typeoff )
{
  uchar **oval ;
  uchar *val ;

  {
  val = (uchar *)((void *)0);
  if (! (he->count > 0)) {
    __assert_fail("he->count > 0", "storage.c", 549U, "delete_list_val_from_he");
  }
  oval = & he->__annonCompField4.vals[typeoff];
  if ((unsigned long )*oval != (unsigned long )((void *)0)) {
    val = *oval;
    *oval = (uchar *)((void *)0);
    (he->count) --;
  }
  return (val);
}
}
uchar *htable_delete_list_io(struct htable *ht , int typeoff , int idx , int off )
{
  int debug ;
  struct hdata *hd ;
  struct hentry *he ;
  struct hentry *prev ;
  uchar *val ;
  int tmp ;

  {
  debug = 500;
  hd = (struct hdata *)((void *)0);
  he = (struct hentry *)((void *)0);
  prev = (struct hentry *)((void *)0);
  hd = ht->table + idx;
  pthread_spin_lock(& hd->lock);
  if ((unsigned long )hd->list == (unsigned long )((void *)0)) {
    pthread_spin_unlock(& hd->lock);
    return ((uchar *)((void *)0));
  }
  he = hd->list;
  while ((unsigned long )he != (unsigned long )((void *)0)) {
    if (off == 0) {
      val = delete_list_val_from_he(he, typeoff);
      if (0 == he->count) {
        if ((unsigned long )((void *)0) == (unsigned long )prev) {
          hd->list = he->next;
        } else {
          prev->next = he->next;
        }
        free((void *)he);
        (hd->now) --;
        pthread_spin_lock(& ht->lock);
        (ht->now) --;
        pthread_spin_unlock(& ht->lock);
      }
      pthread_spin_unlock(& hd->lock);
      return (val);
    }
    off --;
    prev = he;
    he = he->next;
    tmp = debug;
    debug --;
    if (tmp == 0) {
      printf((char const   * __restrict  )"error in htable find list io\n");
      exit(0);
    }
  }
  pthread_spin_unlock(& hd->lock);
  return ((uchar *)((void *)0));
}
}
uchar *htable_delete_list(struct htable *ht , uchar *key , int typeoff , int idx )
{
  int debug ;
  struct hdata *hd ;
  struct hentry *he ;
  struct hentry *prev ;
  uchar *val ;
  int tmp ;
  int tmp___0 ;

  {
  debug = 500;
  hd = (struct hdata *)((void *)0);
  he = (struct hentry *)((void *)0);
  prev = (struct hentry *)((void *)0);
  hd = ht->table + idx;
  pthread_spin_lock(& hd->lock);
  if ((unsigned long )hd->list == (unsigned long )((void *)0)) {
    pthread_spin_unlock(& hd->lock);
    return ((uchar *)((void *)0));
  }
  he = hd->list;
  while ((unsigned long )he != (unsigned long )((void *)0)) {
    tmp = (*(ht->c))((void *)key, (void *)(he->key));
    if (tmp == 0) {
      val = delete_list_val_from_he(he, typeoff);
      if (0 == he->count) {
        if ((unsigned long )((void *)0) == (unsigned long )prev) {
          hd->list = he->next;
        } else {
          prev->next = he->next;
        }
        free((void *)he);
        (hd->now) --;
        pthread_spin_lock(& ht->lock);
        (ht->now) --;
        pthread_spin_unlock(& ht->lock);
      }
      pthread_spin_unlock(& hd->lock);
      return (val);
    }
    prev = he;
    he = he->next;
    tmp___0 = debug;
    debug --;
    if (tmp___0 == 0) {
      printf((char const   * __restrict  )"error in htable find list io\n");
      exit(0);
    }
  }
  pthread_spin_unlock(& hd->lock);
  return ((uchar *)((void *)0));
}
}
int append_value_to_he(struct hentry *he , uchar *val , int type , int replace , struct mvalue *mv )
{
  int ret ;
  uchar **oval ;

  {
  switch (type) {
  case 1:
  oval = & he->__annonCompField4.val.A;
  break;
  case 2:
  oval = & he->__annonCompField4.val.NS;
  break;
  case 5:
  oval = & he->__annonCompField4.val.CNAME;
  break;
  case 6:
  oval = & he->__annonCompField4.val.SOA;
  break;
  case 15:
  oval = & he->__annonCompField4.val.MX;
  break;
  case 16:
  oval = & he->__annonCompField4.val.TXT;
  break;
  case 28:
  oval = & he->__annonCompField4.val.AAAA;
  break;
  case 33:
  oval = & he->__annonCompField4.val.SRV;
  break;
  case 12:
  oval = & he->__annonCompField4.val.PTR;
  break;
  default:
  return (-1);
  break;
  }
  if ((unsigned long )*oval != (unsigned long )((void *)0)) {
    if (replace) {
      if ((unsigned long )mv != (unsigned long )((void *)0)) {
        *mv = *((struct mvalue *)*oval);
      }
      if ((unsigned long )mv != (unsigned long )((void *)0)) {
        if (mv->ttl != 604801U) {
          if (2 == type) {
            ((struct mvalue *)val)->ttl = mv->ttl;
          }
          free((void *)*oval);
          *oval = val;
          ret = 1;
        } else {
          ret = 2;
        }
      } else {
        ret = 2;
      }
    } else {
      ret = 3;
    }
  } else {
    (he->count) ++;
    *oval = val;
    ret = 0;
  }
  return (ret);
}
}
int htable_insert(struct htable *ht , uchar *key , int klen , int type , uchar *val ,
                  int replace , struct mvalue *mv , hashval_t *hashd )
{
  int idx ;
  int ret ;
  int debug ;
  struct hentry *he ;
  struct hentry *cl ;
  struct hdata *hd ;
  uchar dlen ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  debug = 500;
  he = (struct hentry *)((void *)0);
  cl = (struct hentry *)((void *)0);
  hd = (struct hdata *)((void *)0);
  dlen = (uchar )klen;
  tmp = check_support_type((ushort___0 )type);
  if (tmp == -1) {
    printf((char const   * __restrict  )"invalud type:%d, key:[%s]\n", type, key);
    return (-1);
  }
  tmp___0 = malloc(sizeof(struct hentry ) + (unsigned long )dlen);
  he = (struct hentry *)tmp___0;
  if ((unsigned long )he == (unsigned long )((void *)0)) {
    printf((char const   * __restrict  )"oom\n");
    return (-1);
  }
  memset((void *)he, 0, sizeof(struct hentry ));
  memcpy((void * __restrict  )(he->key), (void const   * __restrict  )key, (size_t )dlen);
  if (*hashd == 0U) {
    *hashd = (*(ht->h))((void *)key, klen);
  }
  idx = (int )(*hashd & ht->mask);
  hd = ht->table + idx;
  pthread_spin_lock(& hd->lock);
  if ((unsigned long )hd->list == (unsigned long )((void *)0)) {
    ret = append_value_to_he(he, val, type, replace, (struct mvalue *)((void *)0));
    hd->now = (uint64_t )1;
    hd->list = he;
  } else {
    cl = hd->list;
    while ((unsigned long )cl != (unsigned long )((void *)0)) {
      tmp___1 = (*(ht->c))((void *)(cl->key), (void *)(he->key));
      if (tmp___1 == 0) {
        ret = append_value_to_he(cl, val, type, replace, mv);
        pthread_spin_unlock(& hd->lock);
        free((void *)he);
        return (ret);
      }
      cl = cl->next;
      debug --;
      if (debug == 0) {
        printf((char const   * __restrict  )"error in storage2\n");
        exit(0);
      }
    }
    ret = append_value_to_he(he, val, type, replace, (struct mvalue *)((void *)0));
    he->next = hd->list;
    hd->list = he;
    (hd->now) ++;
  }
  pthread_spin_unlock(& hd->lock);
  pthread_spin_lock(& ht->lock);
  (ht->now) ++;
  pthread_spin_unlock(& ht->lock);
  return (0);
}
}
int htable_insert_list(struct htable *ht , uchar *key , int klen , int type , uchar *val ,
                       int replace , struct mvalue *mv , hashval_t *hashd )
{
  int idx ;
  int ret ;
  int debug ;
  struct hentry *he ;
  struct hentry *cl ;
  struct hentry *prev ;
  struct hdata *hd ;
  uchar dlen ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  debug = 500;
  he = (struct hentry *)((void *)0);
  cl = (struct hentry *)((void *)0);
  prev = (struct hentry *)((void *)0);
  hd = (struct hdata *)((void *)0);
  dlen = (uchar )klen;
  tmp = check_support_type((ushort___0 )type);
  if (tmp == -1) {
    printf((char const   * __restrict  )"invalud type:%d, key:[%s]\n", type, key);
    return (-1);
  }
  tmp___0 = malloc(sizeof(struct hentry ) + (unsigned long )dlen);
  he = (struct hentry *)tmp___0;
  if ((unsigned long )he == (unsigned long )((void *)0)) {
    printf((char const   * __restrict  )"oom\n");
    return (-1);
  }
  memset((void *)he, 0, sizeof(struct hentry ));
  memcpy((void * __restrict  )(he->key), (void const   * __restrict  )key, (size_t )dlen);
  if (*hashd == 0U) {
    *hashd = (*(ht->h))((void *)key, klen);
  }
  idx = (int )(*hashd & ht->mask);
  hd = ht->table + idx;
  pthread_spin_lock(& hd->lock);
  if ((unsigned long )hd->list == (unsigned long )((void *)0)) {
    ret = append_value_to_he(he, val, type, replace, (struct mvalue *)((void *)0));
    hd->now = (uint64_t )1;
    hd->list = he;
  } else {
    cl = hd->list;
    while ((unsigned long )cl != (unsigned long )((void *)0)) {
      tmp___1 = (*(ht->c))((void *)(cl->key), (void *)(he->key));
      if (tmp___1 == 0) {
        ret = append_value_to_he(cl, val, type, replace, mv);
        pthread_spin_unlock(& hd->lock);
        free((void *)he);
        return (ret);
      }
      prev = cl;
      cl = cl->next;
      debug --;
      if (debug == 0) {
        printf((char const   * __restrict  )"error in storage3\n");
        exit(0);
      }
    }
    ret = append_value_to_he(he, val, type, replace, (struct mvalue *)((void *)0));
    prev->next = he;
    (hd->now) ++;
  }
  pthread_spin_unlock(& hd->lock);
  pthread_spin_lock(& ht->lock);
  (ht->now) ++;
  pthread_spin_unlock(& ht->lock);
  return (0);
}
}
int find_record_with_ttl(struct htable *ht , uchar *key , int klen , int type , uchar *val ,
                         int vlen , struct mvalue *md , hashval_t *hash )
{
  int idx ;
  int ret ;
  uchar *oval ;
  uint___0 tmp ;
  int tmp___0 ;

  {
  tmp = get_pre_mem_hash((void *)key, klen, hash);
  idx = (int )tmp;
  ret = htable_find(ht + idx, key, klen, type, val, vlen, md, hash);
  if (ret > 0) {
    tmp___0 = ttl_expired(val);
    if (tmp___0 == 1) {
      oval = htable_delete(ht + idx, key, klen, type, *hash);
      if ((unsigned long )oval != (unsigned long )((void *)0)) {
        free((void *)oval);
      }
    } else {
      return (ret);
    }
  }
  return (-1);
}
}
void *st_th(void *arg )
{
  int i ;
  int idx ;
  uchar key[50] ;
  unsigned int tmp ;
  int klen ;
  uchar *val ;
  int pre ;
  uchar *oval ;
  struct htable *ht ;
  struct st_hlp *sh ;
  hashval_t hash ;
  void *tmp___0 ;
  size_t tmp___1 ;
  uint___0 tmp___2 ;
  size_t tmp___3 ;
  uint___0 tmp___4 ;

  {
  key[0] = (uchar )0;
  tmp = 1U;
  while (! (tmp >= 50U)) {
    key[tmp] = (unsigned char)0;
    tmp ++;
  }
  val = (uchar *)((void *)0);
  pre = 0;
  sh = (struct st_hlp *)arg;
  idx = sh->idx;
  ht = sh->ht;
  i = idx * 10000;
  while (i < (idx + 1) * 10000) {
    hash = (hashval_t )0;
    sprintf((char * __restrict  )((char *)(key)), (char const   * __restrict  )"%dkey",
            i);
    tmp___0 = malloc((size_t )50);
    val = (uchar *)tmp___0;
    sprintf((char * __restrict  )((char *)val), (char const   * __restrict  )"%dval",
            i);
    tmp___1 = strlen((char const   *)(key));
    klen = (int )(tmp___1 + 1UL);
    tmp___2 = get_pre_mem_hash((void *)(key), klen, & hash);
    pre = (int )tmp___2;
    htable_insert(ht + pre, key, klen, 1, val, 0, (struct mvalue *)((void *)0), & hash);
    i ++;
  }
  if (idx == 4) {
    idx = -1;
  }
  sleep(2U);
  i = (idx + 1) * 10000;
  while (i < (idx + 2) * 10000) {
    hash = (hashval_t )0;
    sprintf((char * __restrict  )((char *)(key)), (char const   * __restrict  )"%dkey",
            i);
    tmp___3 = strlen((char const   *)(key));
    klen = (int )(tmp___3 + 1UL);
    tmp___4 = get_pre_mem_hash((void *)(key), klen, & hash);
    pre = (int )tmp___4;
    oval = htable_delete(ht + pre, key, klen, 1, hash);
    if ((unsigned long )oval == (unsigned long )((void *)0)) {
      printf((char const   * __restrict  )"error in test %s,%d,%d\n", key, idx, i);
    } else {
      free((void *)oval);
    }
    i ++;
  }
  sleep(5U);
  return ((void *)0);
}
}
int storage_test(void)
{
  struct htable *ht ;
  pthread_t pt[5] ;
  int i ;
  struct st_hlp sh[5] ;
  int tmp ;

  {
  ht = (struct htable *)((void *)0);
  if ((unsigned long )ht == (unsigned long )((void *)0)) {
    dns_error(0, (char *)"create htable error");
  }
  i = 0;
  while (i < 5) {
    sh[i].ht = ht;
    sh[i].idx = i;
    tmp = pthread_create((pthread_t * __restrict  )(pt + i), (pthread_attr_t const   * __restrict  )((void *)0),
                         & st_th, (void * __restrict  )(sh + i));
    if (tmp) {
      dns_error(0, (char *)"create pthread");
    }
    i ++;
  }
  i = 0;
  while (i < 5) {
    pthread_join(pt[i], (void **)((void *)0));
    i ++;
  }
  sleep(2U);
  return (0);
}
}
#pragma merger("0","/tmp/cil-7mSYdpLE.i","-g,-Wall")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) uint32_t ntohl(uint32_t __netlong )  __attribute__((__const__)) ;
int find_addr(struct htable *fwd , struct htable *ht , mbuf_type *mbuf , uchar *ip ,
              int forward ) ;
uchar *fill_header_in_msg(struct setheader *sh ) ;
uchar *fill_rrset_in_msg(struct hlpc *h , uchar *from , uchar *to , int *pn , uchar *hdr ) ;
int check_out_msg(ushort___0 cid , uchar *buf , int len ) ;
int check_an_msg(ushort___0 flag , uchar *domain , int *bk ) ;
int check_dns_name(uchar *domain , packet_type *lowerdomain ) ;
int check_domain_mask(uchar *domain , uchar *origin , int len ) ;
int make_dns_msg_for_new(uchar *itor , ushort___0 msgid , uchar *d , int len , ushort___0 type ) ;
int send_tc_to_client(mbuf_type *mbuf ) ;
uchar *str_to_len_label(uchar *domain , int len ) ;
int get_domain_from_msg(uchar *itor , uchar *hdr , uchar *to , int *tmplen ) ;
int get_dns_info(uchar *label , ushort___0 *tp , ushort___0 *cls , uint___0 *ttl ,
                 ushort___0 *lth ) ;
int get_level(uchar *itor ) ;
int make_type_domain(uchar *domain , int dlen , int type , uchar *buffer ) ;
int insert_kv_mem(struct rbtree *rbt , struct htable *ds , uchar *k , int klen , int type ,
                  uchar *v , int vlen , int hijack___0 , packet_type *lowerdomain ) ;
uchar *fill_name_in_msg(struct hlpc *h , uchar *to , int idx ) ;
int fill_rrset_in_buffer(uchar *buffer , uchar *label , uchar *hdr , int lth , int type ,
                         struct hlpp *hlp ) ;
int transfer_record_to_msg(uchar *buff , uchar *key , uchar *msg , int msglen , uint16_t *ttloff ) ;
void passer_dns_data(mbuf_type *mbuf ) ;
uchar *process_rdata(struct hlpp *hlp , uchar *label , int n ) ;
int check_qo(struct qoutinfo *qo ) ;
uchar *dbg_print_label(uchar *label , int visible ) ;
uchar *dbg_print_domain(uchar *hdr , uchar *itor ) ;
void dbg_print_ip(uchar *ip , enum rrtype type ) ;
int dbg_print_td(uchar *td ) ;
int insert_into_ttltree(struct rbtree *rbt , uchar *td , int len , int type , uint___0 ttl ,
                        packet_type *lowerdomain ) ;
enum rrtype  const  support_type[9]  =
  {      (enum rrtype  const  )1,      (enum rrtype  const  )2,      (enum rrtype  const  )5,      (enum rrtype  const  )6,
        (enum rrtype  const  )15,      (enum rrtype  const  )16,      (enum rrtype  const  )28,      (enum rrtype  const  )33,
        (enum rrtype  const  )12};
uchar *str_to_len_label(uchar *domain , int len )
{
  uchar l ;
  int i ;

  {
  l = (uchar )0;
  if ((int )*(domain + (len - 1)) != 0) {
    return ((uchar *)((void *)0));
  } else
  if ((int )*(domain + (len - 2)) != 46) {
    return ((uchar *)((void *)0));
  }
  i = len - 2;
  while (i > 0) {
    *(domain + i) = *(domain + (i - 1));
    l = (uchar )((int )l + 1);
    if ((int )*(domain + i) == 46) {
      *(domain + i) = (uchar )((int )l - 1);
      l = (uchar )0;
    }
    i --;
  }
  *(domain + 0) = l;
  return (domain);
}
}
unsigned char SupportTypeTable[256]  =
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)2,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)5,      (unsigned char)6,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)12,      (unsigned char)0,      (unsigned char)0,      (unsigned char)15,
        (unsigned char)16,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)28,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)33,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0};
int check_support_type(ushort___0 type )
{


  {
  if ((int )type > 255) {
    return (-1);
  }
  if ((int )SupportTypeTable[(unsigned char )type] != 0) {
    return (0);
  }
  return (-1);
}
}
void passer_dns_data(mbuf_type *mbuf )
{
  uchar *buf ;
  int num ;
  int dlen ;
  uchar *tail ;
  dnsheader *hdr ;
  uint16_t tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;
  uint16_t tmp___2 ;
  uchar *tmp___3 ;
  uint16_t tmp___4 ;
  int tmp___5 ;

  {
  buf = mbuf->buf;
  dlen = 0;
  tail = (uchar *)((void *)0);
  hdr = (dnsheader *)buf;
  mbuf->err = 1;
  tmp = ntohs(hdr->qdcount);
  num = (int )tmp;
  if (num != 1) {
    return;
  }
  tmp___0 = ntohs(hdr->ancount);
  num = (int )tmp___0;
  if (num != 0) {
    return;
  }
  tmp___1 = ntohs(hdr->nscount);
  num = (int )tmp___1;
  if (num != 0) {
    return;
  }
  tmp___2 = ntohs(hdr->arcount);
  num = (int )tmp___2;
  if (num > 1) {
    return;
  }
  mbuf->id = hdr->id;
  dlen = check_dns_name(buf + sizeof(dnsheader ), & mbuf->lowerdomain);
  if (dlen < 0) {
    return;
  }
  mbuf->dlen = dlen;
  tmp___3 = buf + sizeof(dnsheader );
  mbuf->origindomain = tmp___3;
  tail = tmp___3;
  if (dlen == 2) {
    tail ++;
  } else {
    tail += dlen;
  }
  tmp___4 = ntohs(*((ushort___0 *)tail));
  mbuf->qtype = (enum rrtype )tmp___4;
  tmp___5 = check_support_type((ushort___0 )mbuf->qtype);
  if (tmp___5 == 0) {
    mbuf->err = 0;
  }
  return;
}
}
int send_tc_to_client(mbuf_type *mbuf )
{
  uchar *itor ;
  dnsheader *hdr ;
  qdns *qd ;
  uint16_t tmp ;
  uint16_t tmp___0 ;

  {
  itor = mbuf->buf;
  hdr = (dnsheader *)itor;
  qd = (qdns *)((void *)0);
  if ((unsigned long )mbuf->td == (unsigned long )((void *)0)) {
    return (-1);
  }
  hdr->id = mbuf->id;
  hdr->flags = (uint16_t )0;
  hdr->flags = (uint16_t )((int )hdr->flags | 32768);
  hdr->flags = (uint16_t )((int )hdr->flags | 128);
  hdr->flags = (uint16_t )((int )hdr->flags | 512);
  hdr->flags = htons(hdr->flags);
  hdr->qdcount = htons((uint16_t )1);
  tmp___0 = htons((uint16_t )0);
  hdr->arcount = tmp___0;
  tmp = tmp___0;
  hdr->nscount = tmp;
  hdr->ancount = tmp;
  itor += sizeof(dnsheader );
  memcpy((void * __restrict  )itor, (void const   * __restrict  )mbuf->td, (size_t )mbuf->dlen);
  itor += mbuf->dlen;
  qd = (qdns *)itor;
  qd->type = htons((uint16_t )mbuf->qtype);
  qd->dclass = htons((uint16_t )1);
  itor += sizeof(qdns );
  mbuf->buflen = (int )(itor - mbuf->buf);
  udp_write_info(mbuf, 0);
  return (0);
}
}
int get_domain_from_msg(uchar *itor , uchar *hdr , uchar *to , int *tmplen )
{
  uchar len ;
  ushort___0 offset ;
  int dlen ;
  int hasptr ;
  int infinite ;
  int tmp ;

  {
  offset = (ushort___0 )0;
  len = *(itor + 0);
  dlen = 0;
  hasptr = 0;
  infinite = 20;
  offset = ntohs(*((ushort___0 *)itor));
  *tmplen = 0;
  while (1) {
    if ((int )len != 0) {
      tmp = infinite;
      infinite --;
      if (! tmp) {
        break;
      }
    } else {
      break;
    }
    if ((int )offset >= 49152) {
      if ((int )offset <= 53247) {
        itor = hdr + ((int )offset & 16383);
        if (hasptr == 0) {
          dlen = 2;
          if (*tmplen != 0) {
            dlen += *tmplen;
          }
        }
        hasptr = 1;
        offset = ntohs(*((ushort___0 *)itor));
        continue;
      }
    }
    *(to + 0) = *(itor + 0);
    (*tmplen) ++;
    *tmplen += (int )*(to + 0);
    if ((int )*(to + 0) > 64) {
      return (-1);
    }
    to ++;
    memcpy((void * __restrict  )to, (void const   * __restrict  )(itor + 1), (size_t )*(itor + 0));
    to += (int )*(itor + 0);
    itor = (itor + (int )*(itor + 0)) + 1;
    len = *(itor + 0);
    offset = ntohs(*((ushort___0 *)itor));
  }
  if (infinite <= 0) {
    return (-1);
  }
  *(to + 0) = (uchar )0;
  to ++;
  (*tmplen) ++;
  if (dlen == 0) {
    dlen = *tmplen;
  }
  if (dlen > 255) {
    return (-1);
  }
  return (dlen);
}
}
int insert_into_ttltree(struct rbtree *rbt , uchar *td , int len , int type , uint___0 ttl ,
                        packet_type *lowerdomain )
{
  struct rbnode node ;
  struct ttlnode *tn ;
  void *tmp ;
  packet_type *tmp___0 ;
  void *tmp___1 ;
  int i ;

  {
  node.parent = (struct rbnode *)0;
  node.left = (struct rbnode *)0;
  node.right = (struct rbnode *)0;
  node.color = 0;
  node.key = (void *)0;
  tn = (struct ttlnode *)((void *)0);
  tmp = malloc(sizeof(struct ttlnode ));
  tn = (struct ttlnode *)tmp;
  if ((unsigned long )tn == (unsigned long )((void *)0)) {
    return (-1);
  }
  tmp___1 = malloc(sizeof(packet_type ));
  tmp___0 = (packet_type *)tmp___1;
  tn->lowerdomain = tmp___0;
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    free((void *)tn);
    return (-1);
  }
  tn->dlen = (ushort___0 )len;
  tn->exp = ttl;
  tn->type = (ushort___0 )type;
  tn->hash = & (tn->lowerdomain)->hash[0];
  memcpy((void * __restrict  )tn->lowerdomain, (void const   * __restrict  )lowerdomain,
         sizeof(packet_type ));
  i = 0;
  while (i < (int )(tn->lowerdomain)->label_count) {
    (tn->lowerdomain)->label[i] = (tn->lowerdomain)->domain + (int )(tn->lowerdomain)->label_offsets[i];
    i ++;
  }
  tn->data = (tn->lowerdomain)->domain;
  node.key = (void *)tn;
  insert_node(rbt, & node);
  return (0);
}
}
uint___0 random_ttl(uint___0 ttl )
{
  uint___0 ret ;

  {
  ret = ttl % 7U;
  ttl += ret * 3U;
  if (ttl > 604800U) {
    ttl = 604800U - ttl % 604800U;
  }
  return (ttl);
}
}
int is_parent(uchar *parent , uchar *son )
{
  int sp ;
  int ss ;
  int x ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  tmp = strlen((char const   *)parent);
  sp = (int )tmp;
  tmp___0 = strlen((char const   *)son);
  ss = (int )tmp___0;
  if (ss < sp) {
    return (-1);
  }
  x = ss - sp;
  son += x;
  tmp___1 = strcmp((char const   *)parent, (char const   *)son);
  if (tmp___1 == 0) {
    return (0);
  }
  return (-1);
}
}
int check_dms(uchar *ck , uchar *dms , int num )
{


  {
  return (0);
}
}
uchar *process_rdata(struct hlpp *hlp , uchar *label , int n )
{
  uchar *buffer ;
  ushort___0 type ;
  ushort___0 classin ;
  ushort___0 lth ;
  ushort___0 tmptype ;
  uint___0 ttl ;
  uint___0 tmpttl ;
  uint___0 tx ;
  int i ;
  int dlen ;
  int ret ;
  int tmplen ;
  int *stype ;
  struct htable *ds ;
  struct rbtree *rbt ;
  uchar *hdr ;
  int mlen ;
  struct mvalue *mv ;
  uchar *tmpdomain ;
  uchar *dm ;
  uchar *itor ;
  packet_type lowerdomain ;
  uchar tmp ;
  int tmp___0 ;
  uint___0 tmp___1 ;
  int tmp___2 ;
  uint___0 tmp___3 ;

  {
  buffer = hlp->tmpbuf;
  type = (ushort___0 )0;
  tmptype = (ushort___0 )0;
  ttl = (uint___0 )0;
  tmpttl = (uint___0 )0;
  tmplen = 0;
  stype = hlp->stype;
  ds = hlp->ds;
  rbt = hlp->rbt;
  hdr = hlp->buf;
  mlen = hlp->datalen;
  mv = (struct mvalue *)buffer;
  tmpdomain = hlp->domainbuf;
  itor = (uchar *)((void *)0);
  dm = lowerdomain.domain;
  memset((void *)mv, 0, sizeof(struct mvalue ));
  itor = buffer + sizeof(struct mvalue );
  tx = (uint___0 )global_now;
  tmp = (uchar )0;
  *(dm + 1) = tmp;
  *(dm + 0) = tmp;
  i = 0;
  while (i < n) {
    dlen = get_domain_from_msg(label, hdr, tmpdomain, & tmplen);
    if ((int )*(dm + 0) == 0) {
      if ((int )*(dm + 1) == 0) {
        check_dns_name(tmpdomain, & lowerdomain);
      }
    }
    if (dlen < 0) {
      return ((uchar *)((void *)0));
    }
    label += dlen;
    tmp___0 = get_dns_info(label, & tmptype, & classin, & ttl, & lth);
    if (tmp___0 < 0) {
      return ((uchar *)((void *)0));
    }
    if (ttl < 10U) {
      ttl = (uint___0 )10;
    }
    ttl = random_ttl(ttl + (uint___0 )n);
    label += 10;
    if ((int )tmptype == 6) {
      goto _L;
    } else
    if ((int )tmptype == 5) {
      _L: /* CIL Label */
      if (i == n - 1) {
        *stype = (int )tmptype;
      }
    }
    if ((int )type == 0) {
      type = tmptype;
    }
    if (ttl > 604800U) {
      ttl = (uint___0 )604800;
    }
    if (tmpttl == 0U) {
      tmpttl = ttl;
    }
    tmp___2 = dict_comp_str_equ((void *)tmpdomain, (void *)dm);
    if (tmp___2 != 0) {
      goto _L___0;
    } else
    if ((int )type != (int )tmptype) {
      _L___0: /* CIL Label */
      tmp___1 = random_ttl((tmpttl + (uint___0 )i) + tx % 5U);
      mv->ttl = tmp___1 + tx;
      if ((int )*(dm + ((int )*(dm + 0) + 2)) != 0) {
        insert_kv_mem(rbt, ds, dm, (int )lowerdomain.label_len[0], (int )type, buffer,
                      (int )((unsigned long )mv->len + sizeof(struct mvalue )), 0,
                      & lowerdomain);
      }
      type = tmptype;
      check_dns_name(tmpdomain, & lowerdomain);
      memset((void *)mv, 0, sizeof(struct mvalue ));
      itor = buffer + sizeof(struct mvalue );
    }
    ret = fill_rrset_in_buffer(itor, label, hdr, (int )lth, (int )type, hlp);
    if (ret > 0) {
      itor += ret;
      mv->len = (uint16_t )((int )mv->len + ret);
      mv->num = (uint16_t )((int )mv->num + 1);
    }
    tmpttl = ttl;
    label += (int )lth;
    if ((unsigned long )label < (unsigned long )hdr) {
      return ((uchar *)((void *)0));
    } else
    if ((unsigned long )label > (unsigned long )(hdr + mlen)) {
      return ((uchar *)((void *)0));
    }
    i ++;
  }
  if ((int )mv->num > 0) {
    tmp___3 = random_ttl((tmpttl + (uint___0 )i) + tx % 5U);
    mv->ttl = tmp___3 + tx;
    mv->hits = (uint32_t )0;
    mv->seg = (uint16_t )0;
    if ((int )*(dm + ((int )*(dm + 0) + 2)) != 0) {
      insert_kv_mem(rbt, ds, dm, (int )lowerdomain.label_len[0], (int )type, buffer,
                    (int )((unsigned long )mv->len + sizeof(struct mvalue )), 0, & lowerdomain);
    }
  }
  return (label);
}
}
int check_domain_mask(uchar *domain , uchar *origin , int len )
{
  int tmp ;

  {
  tmp = strncmp((char const   *)origin, (char const   *)domain, (size_t )len);
  return (tmp);
}
}
int get_dns_info(uchar *label , ushort___0 *tp , ushort___0 *cls , uint___0 *ttl ,
                 ushort___0 *lth )
{
  ushort___0 *us ;
  uint___0 *ui ;

  {
  us = (ushort___0 *)((void *)0);
  ui = (uint___0 *)((void *)0);
  us = (ushort___0 *)label;
  *tp = ntohs(*us);
  if ((int )*tp > 254) {
    printf((char const   * __restrict  )"type is %u\n", (int )*tp);
    return (-1);
  }
  label += sizeof(ushort___0 );
  us = (ushort___0 *)label;
  *cls = ntohs(*us);
  if ((int )*cls != 1) {
    return (-1);
  }
  label += sizeof(ushort___0 );
  ui = (uint___0 *)label;
  *ttl = ntohl(*ui);
  label += sizeof(uint___0 );
  us = (ushort___0 *)label;
  *lth = ntohs(*us);
  return (0);
}
}
unsigned char DnsNameTable[256]  =
  {      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)42,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)45,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)48,      (unsigned char)49,      (unsigned char)50,      (unsigned char)51,
        (unsigned char)52,      (unsigned char)53,      (unsigned char)54,      (unsigned char)55,
        (unsigned char)56,      (unsigned char)57,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)97,      (unsigned char)98,      (unsigned char)99,
        (unsigned char)100,      (unsigned char)101,      (unsigned char)102,      (unsigned char)103,
        (unsigned char)104,      (unsigned char)105,      (unsigned char)106,      (unsigned char)107,
        (unsigned char)108,      (unsigned char)109,      (unsigned char)110,      (unsigned char)111,
        (unsigned char)112,      (unsigned char)113,      (unsigned char)114,      (unsigned char)115,
        (unsigned char)116,      (unsigned char)117,      (unsigned char)118,      (unsigned char)119,
        (unsigned char)120,      (unsigned char)121,      (unsigned char)122,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)95,
        (unsigned char)0,      (unsigned char)97,      (unsigned char)98,      (unsigned char)99,
        (unsigned char)100,      (unsigned char)101,      (unsigned char)102,      (unsigned char)103,
        (unsigned char)104,      (unsigned char)105,      (unsigned char)106,      (unsigned char)107,
        (unsigned char)108,      (unsigned char)109,      (unsigned char)110,      (unsigned char)111,
        (unsigned char)112,      (unsigned char)113,      (unsigned char)114,      (unsigned char)115,
        (unsigned char)116,      (unsigned char)117,      (unsigned char)118,      (unsigned char)119,
        (unsigned char)120,      (unsigned char)121,      (unsigned char)122,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0};
unsigned char InvalidDnsNameTable[256]  =
  {      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)0,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)0,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)0,
        (unsigned char)1,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1,
        (unsigned char)1,      (unsigned char)1,      (unsigned char)1,      (unsigned char)1};
int check_dns_name(uchar *domain , packet_type *lowerdomain )
{
  uchar len ;
  uchar i ;
  int tlen ;
  uchar *dst ;
  hashval_t *hash ;
  uchar *tmp ;
  uchar *tmp___0 ;

  {
  len = *(domain + 0);
  tlen = 0;
  dst = lowerdomain->domain;
  hash = & lowerdomain->hash[0];
  lowerdomain->label_count = (uint8_t )0;
  lowerdomain->label[lowerdomain->label_count] = dst;
  lowerdomain->label_offsets[lowerdomain->label_count] = (uint8_t )0;
  lowerdomain->hash[0] = (hashval_t )5381;
  *dst = len;
  tmp = dst;
  dst ++;
  *hash = ((*hash << 5) + *hash) + (hashval_t )*tmp;
  domain ++;
  if ((int )len == 0) {
    *dst = (uchar )'\000';
    tlen = 2;
    return (tlen);
  }
  while ((int )len != 0) {
    if ((int )len > 63) {
      return (-1);
    }
    i = (uchar )0;
    while ((int )i < (int )len) {
      *dst = DnsNameTable[*(domain + i)];
      if (! *dst) {
        return (-1);
      }
      *hash = ((*hash << 5) + *hash) + (hashval_t )*dst;
      dst ++;
      i = (uchar )((int )i + 1);
    }
    domain += (int )len;
    len = *(domain + 0);
    lowerdomain->label_count = (uint8_t )((int )lowerdomain->label_count + 1);
    lowerdomain->label[lowerdomain->label_count] = dst;
    lowerdomain->label_offsets[lowerdomain->label_count] = (uint8_t )(dst - lowerdomain->domain);
    lowerdomain->hash[lowerdomain->label_count] = (hashval_t )0;
    *dst = len;
    tmp___0 = dst;
    dst ++;
    *hash = ((*hash << 5) + *hash) + (hashval_t )*tmp___0;
    domain ++;
  }
  i = (uchar )0;
  while ((int )i < (int )lowerdomain->label_count) {
    lowerdomain->label_len[i] = (uint8_t )(dst - lowerdomain->label[i]);
    i = (uchar )((int )i + 1);
  }
  tlen = (int )lowerdomain->label_len[0];
  if (tlen > 255) {
    return (-1);
  }
  return (tlen);
}
}
int make_type_domain(uchar *domain , int dlen , int type , uchar *buffer )
{


  {
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    return (-1);
  } else
  if ((unsigned long )domain == (unsigned long )((void *)0)) {
    return (-1);
  }
  *(buffer + 0) = (uchar )type;
  memcpy((void * __restrict  )(buffer + 1), (void const   * __restrict  )domain, (size_t )dlen);
  return (0);
}
}
int check_memcpy(uchar *to , uchar *from , int vlen )
{
  int i ;

  {
  i = 0;
  while (i < vlen) {
    if ((int )*(to + i) != (int )*(from + i)) {
      return (-1);
    }
    i ++;
  }
  return (0);
}
}
int insert_kv_mem(struct rbtree *rbt , struct htable *ds , uchar *k , int klen , int type ,
                  uchar *v , int vlen , int hijack___0 , packet_type *lowerdomain )
{
  uchar *val ;
  struct mvalue *mv ;
  struct mvalue tmp ;
  int ret ;
  struct rbnode *pn ;
  struct ttlnode tn ;
  struct ttlnode *tmp_tn ;
  int idx ;
  hashval_t *hash ;
  uint___0 tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  val = (uchar *)((void *)0);
  mv = (struct mvalue *)((void *)0);
  tmp.len = (uint16_t )0;
  tmp.num = (unsigned short)0;
  tmp.ttl = 0U;
  tmp.hits = 0U;
  tmp.seg = (unsigned short)0;
  ret = -1;
  pn = (struct rbnode *)((void *)0);
  tn.exp = (uint___0 )0;
  tn.dlen = (unsigned short)0;
  tn.type = (unsigned short)0;
  tn.hash = (hashval_t *)0;
  tn.lowerdomain = (packet_type *)0;
  tn.data = (uchar *)0;
  tmp_tn = (struct ttlnode *)((void *)0);
  if (vlen < 0) {
    return (-1);
  } else
  if (vlen > 4096) {
    return (-1);
  }
  hash = & lowerdomain->hash[0];
  tmp___0 = get_pre_mem_hash((void *)k, klen, hash);
  idx = (int )tmp___0;
  tmp___1 = malloc((size_t )vlen);
  val = (uchar *)tmp___1;
  if ((unsigned long )val == (unsigned long )((void *)0)) {
    return (-1);
  }
  memcpy((void * __restrict  )val, (void const   * __restrict  )v, (size_t )vlen);
  mv = (struct mvalue *)v;
  ret = htable_insert(ds + idx, k, klen, type, val, 1, & tmp, hash);
  if (ret >= 2) {
    free((void *)val);
  }
  if (rbt) {
    if (ret == 1) {
      pthread_spin_lock(& rbt->lock);
      tn.dlen = (ushort___0 )klen;
      tn.exp = tmp.ttl;
      tn.type = (ushort___0 )type;
      tn.lowerdomain = (packet_type *)((void *)0);
      tn.data = k;
      pn = find_node(rbt, (void *)(& tn));
      if ((unsigned long )pn != (unsigned long )((void *)0)) {
        tmp___2 = delete_node(rbt, pn);
        tmp_tn = (struct ttlnode *)tmp___2;
        if (tmp_tn) {
          free((void *)tmp_tn->lowerdomain);
          free((void *)tmp_tn);
        }
      }
      pthread_spin_unlock(& rbt->lock);
    }
  }
  if (mv->ttl == 604801U) {
    return (0);
  }
  if ((unsigned long )rbt == (unsigned long )((void *)0)) {
    return (0);
  }
  pthread_spin_lock(& rbt->lock);
  if (type != 2) {
    if (ret == 1) {
      ret = insert_into_ttltree(rbt, k, klen, type, mv->ttl, lowerdomain);
    } else {
      ret = insert_into_ttltree(rbt, k, klen, type, tmp.ttl, lowerdomain);
    }
  } else {
    ret = insert_into_ttltree(rbt, k, klen, type, tmp.ttl, lowerdomain);
  }
  pthread_spin_unlock(& rbt->lock);
  return (0);
}
}
int get_level(uchar *itor )
{
  int lvl ;
  uchar len ;

  {
  lvl = 0;
  len = *(itor + 0);
  while ((int )len != 0) {
    lvl ++;
    itor += (int )*(itor + 0) + 1;
    len = *(itor + 0);
    if ((int )len > 63) {
      return (-1);
    }
  }
  return (lvl);
}
}
uchar *fill_all_records_in_msg(struct hlpc *h , struct hlpf *hf , int *pidx )
{
  int step ;
  uint16_t txtlen ;
  uchar *tmp ;
  uchar *to ;
  uchar *from ;
  struct fillmsg *fm ;
  int idx ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  step = 0;
  tmp = (uchar *)((void *)0);
  to = hf->to;
  from = hf->from;
  fm = (struct fillmsg *)hf->to;
  idx = *pidx;
  fm->type = htons(hf->type);
  fm->dclass = htons((uint16_t )1);
  fm->ttl = htonl((uint32_t )((time_t )hf->ttl - global_now));
  if (hf->ttl == 604801U) {
    fm->ttl = htonl(hf->ttl - 1U);
  }
  to += sizeof(struct fillmsg );
  if ((int )hf->type == 1) {
    step = 4;
  }
  if ((int )hf->type == 28) {
    step = 16;
  }
  switch ((int )hf->type) {
  case 28:
  case 1:
  fm->len = htons((uint16_t )step);
  memcpy((void * __restrict  )to, (void const   * __restrict  )from, (size_t )step);
  to += step;
  break;
  case 2:
  case 5:
  idx ++;
  *pidx = idx;
  (h + idx)->name = from;
  (h + idx)->off = (short )(to - hf->hdr);
  (h + idx)->ref = (short)-1;
  tmp___0 = get_level((h + idx)->name);
  (h + idx)->level = (short )tmp___0;
  (h + idx)->mt = (short)0;
  (h + idx)->len = (short )hf->len;
  tmp = fill_name_in_msg(h, to, idx);
  fm->len = htons((uint16_t )(tmp - to));
  to = tmp;
  break;
  case 15:
  memcpy((void * __restrict  )to, (void const   * __restrict  )from, sizeof(uint16_t ));
  from += sizeof(uint16_t );
  to += sizeof(uint16_t );
  idx ++;
  *pidx = idx;
  (h + idx)->name = from;
  (h + idx)->off = (short )(to - hf->hdr);
  (h + idx)->ref = (short)-1;
  tmp___1 = get_level((h + idx)->name);
  (h + idx)->level = (short )tmp___1;
  (h + idx)->mt = (short)0;
  (h + idx)->len = (short )hf->len;
  tmp = fill_name_in_msg(h, to, idx);
  fm->len = htons((uint16_t )((unsigned long )(tmp - to) + sizeof(uint16_t )));
  to = tmp;
  break;
  case 16:
  txtlen = *((uint16_t *)from);
  from += sizeof(uint16_t );
  memcpy((void * __restrict  )to, (void const   * __restrict  )from, (size_t )txtlen);
  fm->len = htons(txtlen);
  to += (int )txtlen;
  break;
  case 33:
  memcpy((void * __restrict  )to, (void const   * __restrict  )from, sizeof(uint16_t ) * 3UL);
  from += sizeof(uint16_t ) * 3UL;
  to += sizeof(uint16_t ) * 3UL;
  idx ++;
  *pidx = idx;
  (h + idx)->name = from;
  (h + idx)->off = (short )(to - hf->hdr);
  (h + idx)->ref = (short)-1;
  tmp___2 = get_level((h + idx)->name);
  (h + idx)->level = (short )tmp___2;
  (h + idx)->mt = (short)0;
  (h + idx)->len = (short )hf->len;
  tmp = fill_name_in_msg(h, to, idx);
  fm->len = htons((uint16_t )((unsigned long )(tmp - to) + sizeof(uint16_t ) * 3UL));
  to = tmp;
  break;
  default:
  break;
  }
  return (to);
}
}
int reverse_compare(uchar *from , int flen , uchar *to , int tolen )
{
  uchar fi ;
  uchar ti ;
  uchar rec ;
  int match ;

  {
  rec = (uchar )0;
  match = 0;
  flen --;
  tolen --;
  while (1) {
    flen --;
    fi = *(from + flen);
    tolen --;
    ti = *(to + tolen);
    if ((int )fi != (int )ti) {
      break;
    }
    rec = (uchar )((int )rec + 1);
    if ((int )fi == (int )rec - 1) {
      match ++;
      rec = (uchar )0;
    }
    if (flen) {
      if (! tolen) {
        break;
      }
    } else {
      break;
    }
  }
  return (match);
}
}
uchar *fill_name_in_msg(struct hlpc *h , uchar *to , int idx )
{
  int i ;
  int m ;
  int len ;
  int fill ;
  int jump ;
  int off ;
  ushort___0 base ;
  uchar *itor ;
  uchar *dn ;

  {
  m = 0;
  fill = 0;
  jump = 0;
  off = 0;
  base = (ushort___0 )49152;
  itor = (h + idx)->name;
  dn = (uchar *)((void *)0);
  if (idx == 0) {
    *((ushort___0 *)to) = htons((uint16_t )((int )(h + 0)->off + (int )base));
    to += sizeof(ushort___0 );
    return (to);
  }
  len = (int )(h + idx)->len;
  i = idx - 1;
  while (i >= 0) {
    m = reverse_compare((h + i)->name, (int )(h + i)->len, (h + idx)->name, len);
    if (m > (int )(h + idx)->mt) {
      (h + idx)->mt = (short )m;
      (h + idx)->ref = (short )i;
    }
    i --;
  }
  if ((int )(h + idx)->mt >= 0) {
    fill = (int )(h + idx)->level - (int )(h + idx)->mt;
  } else {
    fill = (int )(h + idx)->level;
  }
  i = 0;
  while (i < fill) {
    memcpy((void * __restrict  )to, (void const   * __restrict  )itor, (size_t )((int )*(itor + 0) + 1));
    to = (to + (int )*(itor + 0)) + 1;
    itor = (itor + (int )*(itor + 0)) + 1;
    i ++;
  }
  len = 0;
  if ((int )(h + idx)->ref >= 0) {
    dn = (h + (h + idx)->ref)->name;
    jump = (int )(h + (h + idx)->ref)->level - (int )(h + idx)->mt;
    i = 0;
    while (i < jump) {
      len += (int )*(dn + 0) + 1;
      dn += (int )*(dn + 0) + 1;
      i ++;
    }
    off = (int )(h + (h + idx)->ref)->off + len;
    *((ushort___0 *)to) = htons((uint16_t )(off + (int )base));
    to += 2;
  } else {
    *(to + 0) = (uchar )0;
    to ++;
  }
  return (to);
}
}
uchar *fill_rrset_in_msg(struct hlpc *h , uchar *from , uchar *to , int *pn , uchar *hdr )
{
  uchar type ;
  int i ;
  int step ;
  uint16_t txtlen ;
  struct hlpf hf ;
  int num ;
  struct mvalue *mv ;
  int n ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  step = 0;
  txtlen = (uint16_t )0;
  num = 0;
  mv = (struct mvalue *)((void *)0);
  n = *pn;
  type = *(from + 0);
  from ++;
  mv = (struct mvalue *)from;
  from += sizeof(struct mvalue );
  num = (int )mv->num;
  if (num > 32) {
    num = 32;
  }
  hf.hdr = hdr;
  hf.ttl = mv->ttl;
  hf.type = (ushort___0 )type;
  if ((int )type == 1) {
    step = 4;
  }
  if ((int )type == 28) {
    step = 16;
  }
  switch ((int )type) {
  case 28:
  case 1:
  i = 0;
  while (i < num) {
    to = fill_name_in_msg(h, to, n);
    hf.from = from;
    hf.to = to;
    to = fill_all_records_in_msg(h, & hf, pn);
    from += step;
    i ++;
  }
  return (to);
  break;
  case 5:
  to = fill_name_in_msg(h, to, n);
  hf.from = from;
  hf.to = to;
  tmp = strlen((char const   *)from);
  hf.len = (ushort___0 )(tmp + 1UL);
  to = fill_all_records_in_msg(h, & hf, pn);
  return (to);
  break;
  case 2:
  i = 0;
  while (i < num) {
    to = fill_name_in_msg(h, to, n);
    hf.from = from;
    hf.to = to;
    tmp___0 = strlen((char const   *)from);
    hf.len = (ushort___0 )(tmp___0 + 1UL);
    to = fill_all_records_in_msg(h, & hf, pn);
    from += (int )hf.len;
    i ++;
  }
  return (to);
  break;
  case 15:
  i = 0;
  while (i < num) {
    to = fill_name_in_msg(h, to, n);
    hf.from = from;
    hf.to = to;
    tmp___1 = strlen((char const   *)(from + sizeof(uint16_t )));
    hf.len = (ushort___0 )(tmp___1 + 1UL);
    to = fill_all_records_in_msg(h, & hf, pn);
    from += sizeof(uint16_t );
    from += (int )hf.len;
    i ++;
  }
  return (to);
  break;
  case 16:
  i = 0;
  while (i < num) {
    txtlen = *((uint16_t *)from);
    (h + n)->len = (short )txtlen;
    to = fill_name_in_msg(h, to, n);
    hf.from = from;
    hf.to = to;
    to = fill_all_records_in_msg(h, & hf, pn);
    from = (from + (int )txtlen) + sizeof(uint16_t );
    i ++;
  }
  return (to);
  break;
  case 33:
  i = 0;
  while (i < num) {
    to = fill_name_in_msg(h, to, n);
    hf.from = from;
    hf.to = to;
    tmp___2 = strlen((char const   *)(from + sizeof(uint16_t ) * 3UL));
    hf.len = (ushort___0 )(tmp___2 + 1UL);
    to = fill_all_records_in_msg(h, & hf, pn);
    from += sizeof(uint16_t ) * 3UL;
    from += (int )hf.len;
    i ++;
  }
  return (to);
  break;
  default:
  printf((char const   * __restrict  )"not support or error in fill msg\n");
  break;
  }
  return ((uchar *)((void *)0));
}
}
uchar *fill_header_in_msg(struct setheader *sh )
{
  uchar *itor ;
  dnsheader *hdr ;
  qdns *qd ;

  {
  itor = sh->itor;
  hdr = (dnsheader *)sh->itor;
  hdr->flags = (uint16_t )0;
  hdr->flags = (uint16_t )((int )hdr->flags | 32768);
  hdr->flags = (uint16_t )((int )hdr->flags | 128);
  hdr->flags = (uint16_t )(((int )hdr->flags >> 8) | (int )((uint16_t )((int )hdr->flags << 8)));
  hdr->ancount = (uint16_t )(((int )sh->an >> 8) | (int )((uint16_t )((int )sh->an << 8)));
  hdr->nscount = (uint16_t )(((int )sh->ns >> 8) | (int )((uint16_t )((int )sh->ns << 8)));
  hdr->arcount = (uint16_t )0;
  itor += sizeof(dnsheader );
  itor += (int )sh->dlen;
  qd = (qdns *)itor;
  qd->type = (uint16_t )(((int )sh->type >> 8) | (int )((uint16_t )((int )sh->type << 8)));
  qd->dclass = (uint16_t )((1 >> 8) | (int )((uint16_t )(1 << 8)));
  itor += sizeof(qdns );
  return (itor);
}
}
int make_dns_msg_for_new(uchar *itor , ushort___0 msgid , uchar *d , int len , ushort___0 type )
{
  uchar *buf ;
  dnsheader *hdr ;
  qdns *qd ;
  uint16_t tmp ;
  uint16_t tmp___0 ;

  {
  buf = itor;
  hdr = (dnsheader *)((void *)0);
  qd = (qdns *)((void *)0);
  hdr = (dnsheader *)buf;
  hdr->id = msgid;
  hdr->flags = htons((uint16_t )256);
  hdr->qdcount = htons((uint16_t )1);
  tmp___0 = htons((uint16_t )0);
  hdr->arcount = tmp___0;
  tmp = tmp___0;
  hdr->nscount = tmp;
  hdr->ancount = tmp;
  buf += sizeof(dnsheader );
  memcpy((void * __restrict  )buf, (void const   * __restrict  )d, (size_t )len);
  *(buf + (len - 1)) = (uchar )0;
  buf += len;
  qd = (qdns *)buf;
  qd->type = htons(type);
  qd->dclass = htons((uint16_t )1);
  buf += 4;
  return ((int )(buf - itor));
}
}
int fill_rrset_in_buffer(uchar *buffer , uchar *label , uchar *hdr , int lth , int type ,
                         struct hlpp *hlp )
{
  int mlen ;
  uint16_t len ;
  struct srv *from ;
  struct srv *to ;

  {
  mlen = 0;
  len = (uint16_t )lth;
  switch (type) {
  case 1:
  mlen = 4;
  memcpy((void * __restrict  )buffer, (void const   * __restrict  )label, (size_t )4);
  break;
  case 5:
  case 2:
  get_domain_from_msg(label, hdr, buffer, & mlen);
  to_lowercase(buffer, mlen);
  break;
  case 6:
  mlen = 0;
  break;
  case 28:
  mlen = 16;
  memcpy((void * __restrict  )buffer, (void const   * __restrict  )label, (size_t )16);
  break;
  case 15:
  memcpy((void * __restrict  )buffer, (void const   * __restrict  )label, (size_t )2);
  label += 2;
  buffer += 2;
  get_domain_from_msg(label, hdr, buffer, & mlen);
  mlen += 2;
  break;
  case 33:
  from = (struct srv *)label;
  to = (struct srv *)buffer;
  to->pri = from->pri;
  to->wei = from->wei;
  to->port = from->port;
  buffer += sizeof(uint16_t ) * 3UL;
  label += sizeof(uint16_t ) * 3UL;
  get_domain_from_msg(label, hdr, buffer, & mlen);
  mlen = (int )((unsigned long )mlen + sizeof(uint16_t ) * 3UL);
  break;
  case 16:
  memcpy((void * __restrict  )buffer, (void const   * __restrict  )(& len), sizeof(uint16_t ));
  buffer += sizeof(uint16_t );
  memcpy((void * __restrict  )buffer, (void const   * __restrict  )label, (size_t )lth);
  mlen = (int )((unsigned long )lth + sizeof(uint16_t ));
  break;
  default:
  return (-1);
  }
  return (mlen);
}
}
int check_an_msg(ushort___0 flag , uchar *domain , int *bk )
{
  uint___0 get ;

  {
  get = (uint___0 )0;
  flag = ntohs(flag);
  get = (uint___0 )(((int )flag & 32768) / 32768);
  if (get == 0U) {
    printf((char const   * __restrict  )"answer set Q sign\n");
    return (-1);
  }
  get = (uint___0 )(((int )flag & 30720) >> 11);
  get = (uint___0 )(((int )flag & 1024) / 1024);
  get = (uint___0 )(((int )flag & 512) / 512);
  if (get == 1U) {
    return (1);
  }
  get = (uint___0 )(((int )flag & 256) / 256);
  get = (uint___0 )((int )flag & 7);
  if (get != 0U) {
    if (get != 3U) {
      switch (get) {
      case 2U:
      break;
      case 1U:
      break;
      case 4U:
      break;
      case 5U:
      break;
      }
      return (2);
    }
  }
  return (0);
}
}
int check_out_msg(ushort___0 cid , uchar *buf , int len )
{
  dnsheader *hdr ;

  {
  hdr = (dnsheader *)buf;
  hdr->id = cid;
  hdr->flags = (uint16_t )0;
  hdr->flags = htons((uint16_t )((int )hdr->flags | 32768));
  return (0);
}
}
int check_td(uchar *td )
{
  uchar type ;
  uchar *itor ;
  uchar len ;

  {
  type = *(td + 0);
  itor = td + 1;
  len = *(itor + 0);
  if ((int )type != 1) {
    if ((int )type != 2) {
      if ((int )type != 5) {
        return (-1);
      }
    }
  }
  while ((int )len != 0) {
    if ((int )len > 50) {
      return (-1);
    }
    itor = (itor + (int )len) + 1;
    len = *(itor + 0);
  }
  return (0);
}
}
int is_glue(uchar *domain , uchar *ns )
{
  uchar d ;
  uchar n ;
  int dlen ;
  int nlen ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  tmp = strlen((char const   *)domain);
  dlen = (int )tmp;
  tmp___0 = strlen((char const   *)ns);
  nlen = (int )tmp___0;
  dlen --;
  nlen --;
  if (dlen >= nlen) {
    return (0);
  }
  d = *(domain + dlen);
  n = *(ns + nlen);
  while ((int )d == (int )n) {
    dlen --;
    nlen --;
    if (dlen == 0) {
      return (1);
    }
    d = *(domain + dlen);
    n = *(ns + nlen);
  }
  return (0);
}
}
int pre_find(mbuf_type *mbuf , struct htable *fwd , struct htable *ht , uchar *ip )
{
  uchar *td ;
  uchar *itor ;
  int xlen ;
  int dbg___0 ;
  struct mvalue *mv ;
  int td_len ;
  int new_td_len ;
  hashval_t *hash ;
  hashval_t thash ;
  uchar *new_td ;
  int rlen ;
  int tmp ;
  int tmp___0 ;

  {
  itor = (uchar *)((void *)0);
  xlen = 0;
  dbg___0 = 100;
  mv = (struct mvalue *)((void *)0);
  thash = (hashval_t )0;
  mbuf->qname = (ushort___0 )4;
  if ((int )mbuf->hascname == 1) {
    mbuf->qing = mbuf->qbuffer;
    td_len = (int )mbuf->qlen;
    td = mbuf->qbuffer;
    mbuf->qhash = & mbuf->qbuffer_hash;
  } else {
    td_len = mbuf->dlen;
    mbuf->qing = mbuf->td;
    mbuf->qlen = (ushort___0 )mbuf->dlen;
    td = mbuf->td;
    mbuf->qhash = & mbuf->lowerdomain.hash[0];
  }
  hash = mbuf->qhash;
  xlen = htable_find(fwd, td, td_len, 1, ip, 1900, (struct mvalue *)((void *)0), hash);
  if (xlen > 0) {
    ip += xlen;
    mv = (struct mvalue *)ip;
    mv->num = (uint16_t )0;
    mv->ttl = (uint32_t )0;
    mv->hits = (uint32_t )0;
    mv->len = (uint16_t )0;
    return (xlen);
  } else {
    new_td = mbuf->tdbuffer;
    if ((int )mbuf->lowerdomain.label_count > 1) {
      *(new_td + 0) = (uchar )1;
      *(new_td + 1) = (uchar )'*';
      new_td_len = (int )mbuf->lowerdomain.label_len[(int )mbuf->lowerdomain.label_count - 2];
      memcpy((void * __restrict  )(new_td + 2), (void const   * __restrict  )mbuf->lowerdomain.label[(int )mbuf->lowerdomain.label_count - 2],
             (size_t )new_td_len);
      thash = (hashval_t )0;
      tmp = htable_find(fwd, new_td, new_td_len + 2, 1, ip, 1900, (struct mvalue *)((void *)0),
                        & thash);
      rlen = tmp;
      if (rlen > 0) {
        ip += rlen;
        mv = (struct mvalue *)ip;
        mv->num = (uint16_t )0;
        mv->ttl = (uint32_t )0;
        mv->hits = (uint32_t )0;
        mv->len = (uint16_t )0;
        return (rlen);
      }
    }
  }
  if ((unsigned int )mbuf->qtype == 5U) {
    return (0);
  }
  itor = mbuf->tempbuffer;
  while (1) {
    xlen = find_record_with_ttl(ht, td, td_len, 5, itor, 2000, (struct mvalue *)((void *)0),
                                hash);
    if (xlen > 0) {
      mbuf->qname = (ushort___0 )3;
      mbuf->hascname = (ushort___0 )1;
      mv = (struct mvalue *)itor;
      itor += sizeof(struct mvalue );
      if ((int )mv->len > 255) {
        return (-1);
      }
      memcpy((void * __restrict  )(mbuf->qbuffer), (void const   * __restrict  )itor,
             (size_t )mv->len);
      mbuf->qing = mbuf->qbuffer;
      td_len = (int )mv->len;
      mbuf->qlen = (ushort___0 )td_len;
      mbuf->qbuffer_hash = (hashval_t )0;
      hash = & mbuf->qbuffer_hash;
      td = mbuf->qbuffer;
    } else {
      break;
    }
    tmp___0 = dbg___0;
    dbg___0 --;
    if (tmp___0 == 0) {
      return (-1);
    }
  }
  return (0);
}
}
int transfer_record_to_msg(uchar *buff , uchar *key , uchar *msg , int msglen , uint16_t *ttloff )
{
  uint16_t segs ;
  uint16_t totallen ;
  uchar *itor ;
  struct mvalue *mv ;

  {
  segs = *(ttloff + 0);
  totallen = (uint16_t )0;
  itor = (uchar *)((void *)0);
  mv = (struct mvalue *)((void *)0);
  if ((int )segs == 0) {
    return (-1);
  } else
  if ((int )segs > 100) {
    return (-1);
  }
  totallen = (uint16_t )msglen;
  totallen = (uint16_t )(((unsigned long )totallen + (unsigned long )segs * sizeof(uint16_t )) + sizeof(struct mvalue ));
  if ((int )totallen > 2048) {
    return (-1);
  }
  itor = buff;
  mv = (struct mvalue *)itor;
  mv->seg = segs;
  mv->len = (uint16_t )msglen;
  itor += sizeof(struct mvalue );
  memcpy((void * __restrict  )itor, (void const   * __restrict  )(ttloff + 1), sizeof(uint16_t ) * (unsigned long )segs);
  itor += sizeof(uint16_t ) * (unsigned long )segs;
  memcpy((void * __restrict  )itor, (void const   * __restrict  )msg, (size_t )msglen);
  return (0);
}
}
int make_A_record_from_segment(uchar *ipmsg , uchar *iitor )
{
  int reallen ;
  uchar *ipto ;
  uchar *ipfrom ;
  struct mvalue *mv ;
  uint16_t off ;
  int segs ;
  int i ;

  {
  reallen = 0;
  ipto = (uchar *)((void *)0);
  ipfrom = (uchar *)((void *)0);
  mv = (struct mvalue *)((void *)0);
  segs = 0;
  mv = (struct mvalue *)ipmsg;
  segs = (int )mv->seg;
  ipto = iitor + sizeof(struct mvalue );
  i = 0;
  while (i < segs) {
    off = *((uint16_t *)((ipmsg + sizeof(struct mvalue )) + (unsigned long )i * sizeof(uint16_t )));
    ipfrom = ipmsg + (int )off;
    memcpy((void * __restrict  )ipto, (void const   * __restrict  )ipfrom, (size_t )4);
    reallen += 4;
    ipto += 4;
    i ++;
  }
  mv->len = (uint16_t )reallen;
  memcpy((void * __restrict  )iitor, (void const   * __restrict  )ipmsg, sizeof(struct mvalue ));
  return (0);
}
}
int retrive_ip(mbuf_type *mbuf , uchar *itor , int num , uchar *ip , struct htable *ht ,
               int *fq )
{
  struct mvalue *mi ;
  int i ;
  int xlen ;
  int iplen ;
  int got ;
  uchar *ipbuffer ;
  uchar *nstd ;
  uchar *iitor ;
  hashval_t hash ;
  size_t tmp ;

  {
  mi = (struct mvalue *)((void *)0);
  iplen = 2000;
  got = 0;
  ipbuffer = mbuf->ipbuffer;
  *fq = 0;
  iitor = ip;
  i = 0;
  while (i < num) {
    tmp = strlen((char const   *)itor);
    xlen = (int )(tmp + 1UL);
    nstd = itor;
    itor += xlen;
    hash = (hashval_t )0;
    xlen = find_record_with_ttl(ht, nstd, xlen, 1, ipbuffer, (int )((unsigned long )iplen - sizeof(struct mvalue )),
                                (struct mvalue *)((void *)0), & hash);
    if (xlen > 0) {
      mi = (struct mvalue *)ipbuffer;
      if ((int )mi->seg > 0) {
        make_A_record_from_segment(ipbuffer, iitor);
      } else {
        memcpy((void * __restrict  )iitor, (void const   * __restrict  )ipbuffer,
               (unsigned long )mi->len + sizeof(struct mvalue ));
      }
      iitor = (iitor + (int )mi->len) + sizeof(struct mvalue );
      iplen = (int )((unsigned long )(iplen - (int )mi->len) - sizeof(struct mvalue ));
      got ++;
    }
    if (xlen < 0) {
      *fq = i;
      break;
    }
    i ++;
  }
  if ((unsigned long )iitor != (unsigned long )ip) {
    mi = (struct mvalue *)iitor;
    mi->num = (uint16_t )0;
    mi->ttl = (uint32_t )0;
    mi->hits = (uint32_t )0;
    mi->len = (uint16_t )0;
    return (got);
  }
  return (-1);
}
}
int fill_extra_addr(uchar *ip )
{
  char const   *extra[2] ;
  int i ;
  int n ;
  struct mvalue *mv ;
  int tmp ;

  {
  extra[0] = (char const   *)g_nameservers[0];
  extra[1] = (char const   *)g_nameservers[1];
  mv = (struct mvalue *)((void *)0);
  n = (int )(sizeof(extra) / sizeof(extra[0]));
  mv = (struct mvalue *)ip;
  ip += sizeof(struct mvalue );
  mv->num = (uint16_t )0;
  mv->ttl = (uint32_t )0;
  mv->hits = (uint32_t )0;
  mv->len = (uint16_t )0;
  mv->seg = (uint16_t )0;
  i = 0;
  while (i < n) {
    tmp = make_bin_from_str(ip, extra[i]);
    if (tmp == 0) {
      mv->num = (uint16_t )((int )mv->num + 1);
      mv->len = (uint16_t )((int )mv->len + 4);
      ip += 4;
    }
    i ++;
  }
  mv = (struct mvalue *)ip;
  mv->num = (uint16_t )0;
  mv->ttl = (uint32_t )0;
  mv->hits = (uint32_t )0;
  mv->len = (uint16_t )0;
  mv->seg = (uint16_t )0;
  return (0);
}
}
int find_addr(struct htable *fwd , struct htable *ht , mbuf_type *mbuf , uchar *ip ,
              int forward )
{
  int ret ;
  int xlen ;
  int dbg___0 ;
  int first_query ;
  int i ;
  struct mvalue *mv ;
  uchar *td ;
  uchar *buffer ;
  uchar *itor ;
  uchar *glue ;
  int td_len ;
  int diff_len ;
  int ori_flag ;
  int root_flag ;
  hashval_t thash ;
  hashval_t *hash ;
  int label_count ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  xlen = 0;
  dbg___0 = 100;
  mv = (struct mvalue *)((void *)0);
  buffer = mbuf->tempbuffer;
  itor = (uchar *)((void *)0);
  glue = (uchar *)((void *)0);
  ori_flag = 0;
  root_flag = 0;
  label_count = 0;
  if ((int )mbuf->qtimes > 12) {
    fill_extra_addr(ip);
    return (0);
  }
  ret = pre_find(mbuf, fwd, ht, ip);
  if (ret > 0) {
    return (0);
  } else
  if (ret < 0) {
    return (ret);
  } else
  if (forward) {
    fill_extra_addr(ip);
    return (0);
  }
  td = mbuf->qing;
  itor = td;
  hash = mbuf->qhash;
  td_len = (int )mbuf->qlen;
  if (mbuf->hascname) {
    ori_flag = 1;
  }
  while (1) {
    while (1) {
      ret = find_record_with_ttl(ht, itor, td_len, 2, buffer, 2000, (struct mvalue *)((void *)0),
                                 hash);
      if (ret > 0) {
        break;
      }
      tmp = dbg___0;
      dbg___0 --;
      if (tmp == 0) {
        return (-1);
      }
      if (ori_flag) {
        diff_len = (int )*(itor + 0) + 1;
        itor += diff_len;
        if ((int )*(itor + 0) == 0) {
          if (root_flag == 0) {
            *(itor + 1) = (uchar )'\000';
            root_flag = 1;
            td_len = 2;
          } else {
            return (-1);
          }
        } else {
          td_len -= diff_len;
        }
        thash = (hashval_t )0;
        hash = & thash;
      } else {
        label_count ++;
        if (label_count > (int )mbuf->lowerdomain.label_count) {
          return (-1);
        }
        if (label_count == (int )mbuf->lowerdomain.label_count) {
          itor = mbuf->lowerdomain.label[label_count - 1] + (int )mbuf->lowerdomain.label_len[label_count - 1];
          *(itor + 1) = (uchar )'\000';
          td_len = 2;
          thash = (hashval_t )0;
          hash = & thash;
        } else {
          itor = mbuf->lowerdomain.label[label_count];
          td_len = (int )mbuf->lowerdomain.label_len[label_count];
          hash = & mbuf->lowerdomain.hash[label_count];
        }
      }
    }
    mv = (struct mvalue *)buffer;
    glue = itor;
    itor = buffer + sizeof(struct mvalue );
    ret = retrive_ip(mbuf, itor, (int )mv->num, ip, ht, & first_query);
    if (ret > 0) {
      if (ret < (int )mv->num) {
        if (mbuf->qns == 1) {
          mbuf->qns = 0;
          i = 0;
          while (i < first_query) {
            tmp___0 = strlen((char const   *)itor);
            xlen = (int )(tmp___0 + 1UL);
            itor += xlen;
            i ++;
          }
        } else {
          return (0);
        }
      } else {
        return (0);
      }
    }
    tmp___2 = is_glue(glue, itor);
    if (tmp___2 != 1) {
      if (! ori_flag) {
        ori_flag = 1;
      }
      tmp___1 = strlen((char const   *)itor);
      xlen = (int )(tmp___1 + 1UL);
      if (xlen > 255) {
        return (-1);
      } else
      if ((int )*(itor + 0) == 0) {
        return (-1);
      } else
      if ((int )*(itor + 0) > xlen) {
        return (-1);
      }
      memcpy((void * __restrict  )(mbuf->qbuffer), (void const   * __restrict  )itor,
             (size_t )xlen);
      mbuf->qbuffer_hash = (hashval_t )0;
      mbuf->qing = mbuf->qbuffer;
      mbuf->qhash = & mbuf->qbuffer_hash;
      mbuf->qlen = (ushort___0 )xlen;
      hash = mbuf->qhash;
      td_len = (int )mbuf->qlen;
      td = mbuf->qing;
      itor = td;
    } else
    if (ori_flag) {
      diff_len = (int )*(glue + 0) + 1;
      itor = glue + diff_len;
      if ((int )*(itor + 0) == 0) {
        return (-1);
      }
      td_len -= diff_len;
      thash = (hashval_t )0;
      hash = & thash;
    } else {
      label_count ++;
      if (label_count >= (int )mbuf->lowerdomain.label_count) {
        return (-1);
      }
      itor = mbuf->lowerdomain.label[label_count];
      td_len = (int )mbuf->lowerdomain.label_len[label_count];
      hash = & mbuf->lowerdomain.hash[label_count];
    }
    mbuf->qname = (ushort___0 )6;
    tmp___3 = dbg___0;
    dbg___0 --;
    if (tmp___3 == 0) {
      return (-1);
    }
  }
  return (0);
}
}
int check_qo(struct qoutinfo *qo )
{


  {
  if ((unsigned long )qo == (unsigned long )((void *)0)) {
    return (0);
  }
  if ((int )qo->hascname > 1) {
    printf((char const   * __restrict  )"qo error\n");
  }
  if ((unsigned long )qo->td == (unsigned long )((void *)0)) {
    printf((char const   * __restrict  )"qo error2\n");
  }
  return (0);
}
}
uchar *dbg_print_label(uchar *label , int visible )
{
  uchar i ;
  uchar len ;

  {
  len = *label;
  if (visible == 1) {
    i = (uchar )1;
    while ((int )i < (int )len + 1) {
      printf((char const   * __restrict  )"%c", (int )*(label + i));
      i = (uchar )((int )i + 1);
    }
  }
  return ((label + (int )*(label + 0)) + 1);
}
}
uchar *dbg_print_domain(uchar *hdr , uchar *itor )
{
  uchar len ;
  uchar *tmp ;
  ushort___0 offset ;
  int debug ;
  int tmp___0 ;

  {
  tmp = (uchar *)((void *)0);
  debug = 100;
  len = *(itor + 0);
  if ((int )len == 0) {
    printf((char const   * __restrict  )"root\n");
    return ((uchar *)0);
  }
  offset = ntohs(*((ushort___0 *)itor));
  if ((int )offset >= 49152) {
    if ((int )offset <= 53247) {
      itor = hdr + ((int )offset & 16383);
    }
  }
  while (1) {
    if ((int )len != 0) {
      tmp___0 = debug;
      debug --;
      if (! tmp___0) {
        break;
      }
    } else {
      break;
    }
    if ((int )offset >= 49152) {
      if ((int )offset <= 53247) {
        tmp = itor + 2;
        itor = dbg_print_label(hdr + ((int )offset & 16383), 1);
      } else {
        itor = dbg_print_label(itor, 1);
      }
    } else {
      itor = dbg_print_label(itor, 1);
    }
    printf((char const   * __restrict  )".");
    len = *(itor + 0);
    offset = ntohs(*((ushort___0 *)itor));
  }
  printf((char const   * __restrict  )"\n");
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    tmp = itor + 1;
  }
  return (tmp);
}
}
void dbg_print_ip(uchar *ip , enum rrtype type )
{
  int i ;
  uint___0 ipv4[4] ;
  unsigned int tmp ;

  {
  ipv4[0] = (uint___0 )0;
  tmp = 1U;
  while (! (tmp >= 4U)) {
    ipv4[tmp] = 0U;
    tmp ++;
  }
  i = 0;
  while (i < 4) {
    ipv4[i] = (uint___0 )*(ip + i);
    i ++;
  }
  if ((unsigned int )type == 1U) {
    printf((char const   * __restrict  )"%u.%u.%u.%u\n", (int )((unsigned short )ipv4[0]),
           ipv4[1], ipv4[2], ipv4[3]);
  } else
  if ((unsigned int )type == 28U) {
    i = 0;
    while (i < 8) {
      if ((int )*(ip + i * 2) != 0) {
        if ((int )*(ip + i * 2) < 16) {
          printf((char const   * __restrict  )"0");
        }
        printf((char const   * __restrict  )"%x", (uint___0 )*(ip + i * 2));
      }
      if ((int )*(ip + (i * 2 + 1)) < 16) {
        printf((char const   * __restrict  )"0");
      }
      printf((char const   * __restrict  )"%x", (uint___0 )*(ip + (i * 2 + 1)));
      if (i != 7) {
        printf((char const   * __restrict  )":");
      }
      i ++;
    }
    printf((char const   * __restrict  )"\n");
  } else {
    printf((char const   * __restrict  )"unknow type %d\n", (unsigned int )type);
  }
  return;
}
}
int dbg_print_td(uchar *td )
{
  uchar c ;

  {
  c = *(td + 0);
  printf((char const   * __restrict  )"%d,", (int )c);
  dbg_print_domain((uchar *)((void *)0), td + 1);
  return (0);
}
}
#pragma merger("0","/tmp/cil-hOm_mMta.i","-g,-Wall")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
extern FILE *stderr ;
extern int fclose(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format
                   , ...) ;
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format
                                                , ...)  __asm__("__isoc99_sscanf")  ;
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mkdir)(char const   *__path ,
                                                                                  __mode_t __mode ) ;
int read_config(char const   *fn , char *logpath , struct htable *forward , char **nameservers ) ;
int create_new_log(uchar *prefix , int idx , int type ) ;
int write_log(struct log_info *log , int idx , uchar const   *domain , int dlen ,
              int type , struct sockaddr_in *addr ) ;
int read_root(struct htable *ds , struct rbtree *rbt ) ;
int refresh_records(struct htable *ds , struct rbtree *rbt ) ;
uchar *jump_space(uchar *itor ) ;
int add_query_info(int log_type , int idx , uint16_t type ) ;
uchar *jump_space(uchar *itor )
{
  int t ;
  int tmp ;
  int tmp___0 ;

  {
  t = 100;
  while (1) {
    if ((int )*(itor + 0) != 32) {
      if ((int )*(itor + 0) != 9) {
        tmp = t;
        t --;
        if (! tmp) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    itor ++;
  }
  *(itor + 0) = (uchar )0;
  itor ++;
  while (1) {
    if (! ((int )*(itor + 0) == 32)) {
      if (! ((int )*(itor + 0) == 9)) {
        break;
      }
    }
    itor ++;
    tmp___0 = t;
    t --;
    if (tmp___0 == 0) {
      printf((char const   * __restrict  )"error line in file\n");
      return ((uchar *)((void *)0));
    }
  }
  return (itor);
}
}
int read_records_from_file(char const   *fn , struct htable *ds , struct rbtree *rbt ,
                           int hijack___0 )
{
  FILE *fd ;
  uchar vbuffer[5000] ;
  unsigned int tmp ;
  uchar ipv4[4] ;
  uchar ipv6[16] ;
  uchar rbuffer[1024] ;
  unsigned int tmp___0 ;
  uchar tmpdomain[256] ;
  unsigned int tmp___1 ;
  uchar tmptype[10] ;
  unsigned int tmp___2 ;
  uchar *ps[5] ;
  unsigned int tmp___3 ;
  uchar *ritor ;
  uchar *vitor ;
  int tmplen ;
  int type ;
  int i ;
  uchar *kbuffer ;
  uint___0 ttl ;
  uint___0 tmpttl ;
  int dlen ;
  struct mvalue *mv ;
  packet_type lowerdomain ;
  packet_type lowerns ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  size_t tmp___24 ;

  {
  fd = (FILE *)((void *)0);
  vbuffer[0] = (uchar )0;
  tmp = 1U;
  while (! (tmp >= 5000U)) {
    vbuffer[tmp] = (unsigned char)0;
    tmp ++;
  }
  rbuffer[0] = (uchar )0;
  tmp___0 = 1U;
  while (! (tmp___0 >= 1024U)) {
    rbuffer[tmp___0] = (unsigned char)0;
    tmp___0 ++;
  }
  tmpdomain[0] = (uchar )'.';
  tmpdomain[1] = (uchar )'\000';
  tmp___1 = 2U;
  while (! (tmp___1 >= 256U)) {
    tmpdomain[tmp___1] = (unsigned char)0;
    tmp___1 ++;
  }
  tmptype[0] = (uchar )'N';
  tmptype[1] = (uchar )'S';
  tmptype[2] = (uchar )'\000';
  tmp___2 = 3U;
  while (! (tmp___2 >= 10U)) {
    tmptype[tmp___2] = (unsigned char)0;
    tmp___2 ++;
  }
  ps[0] = (uchar *)0;
  tmp___3 = 1U;
  while (! (tmp___3 >= 5U)) {
    ps[tmp___3] = (uchar *)0;
    tmp___3 ++;
  }
  ritor = (uchar *)((void *)0);
  vitor = vbuffer;
  tmplen = 0;
  type = 0;
  ttl = (uint___0 )0;
  tmpttl = (uint___0 )0;
  mv = (struct mvalue *)(vbuffer);
  if ((unsigned long )ds == (unsigned long )((void *)0)) {
    dns_error(0, (char *)"datasets null");
  }
  fd = fopen((char const   * __restrict  )fn, (char const   * __restrict  )"r");
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"open file %s error\n",
            fn);
    perror("fopen");
    dns_error(0, (char *)"open file root.z");
  }
  kbuffer = lowerdomain.domain;
  mv->num = (uint16_t )0;
  mv->ttl = (uint32_t )0;
  mv->len = (uint16_t )0;
  mv->seg = (uint16_t )0;
  vitor = vbuffer + sizeof(struct mvalue );
  while (1) {
    tmp___20 = fgets((char * __restrict  )((char *)(rbuffer)), 1024, (FILE * __restrict  )fd);
    if (! ((unsigned long )tmp___20 != (unsigned long )((void *)0))) {
      break;
    }
    ritor = rbuffer;
    ps[0] = ritor;
    i = 1;
    while (i < 5) {
      ritor = jump_space(ritor);
      ps[i] = ritor;
      i ++;
    }
    tmp___4 = strlen((char const   *)ps[0]);
    to_lowercase(ps[0], (int )(tmp___4 + 1UL));
    fix_tail((char *)ps[4]);
    tmp___5 = atoi((char const   *)ps[1]);
    tmpttl = (uint___0 )tmp___5;
    ttl = (uint___0 )((time_t )tmpttl + global_now);
    if (tmpttl >= 604801U) {
      ttl = tmpttl;
    }
    if (tmpttl == 172800U) {
      ttl = (uint___0 )604801;
    }
    if (tmpttl == 518400U) {
      ttl = (uint___0 )604801;
    }
    tmp___13 = strcmp((char const   *)ps[0], (char const   *)(tmpdomain));
    if (tmp___13 != 0) {
      goto _L;
    } else {
      tmp___14 = strcmp((char const   *)ps[3], (char const   *)(tmptype));
      if (tmp___14 != 0) {
        _L: /* CIL Label */
        tmp___8 = strcmp((char const   *)(tmptype), "NS");
        if (tmp___8 == 0) {
          type = 2;
        } else {
          tmp___7 = strcmp((char const   *)(tmptype), "A");
          if (tmp___7 == 0) {
            type = 1;
          } else {
            tmp___6 = strcmp((char const   *)(tmptype), "AAAA");
            if (tmp___6 == 0) {
              type = 28;
            }
          }
        }
        tmp___9 = strcmp((char const   *)(tmptype), "CNAME");
        if (tmp___9 == 0) {
          type = 5;
        }
        tmp___10 = strlen((char const   *)(tmpdomain));
        dlen = (int )(tmp___10 + 1UL);
        if (dlen > 1) {
          str_to_len_label(tmpdomain, dlen);
          check_dns_name(tmpdomain, & lowerdomain);
          insert_kv_mem(rbt, ds, kbuffer, dlen, type, vbuffer, (int )((unsigned long )mv->len + sizeof(struct mvalue )),
                        hijack___0, & lowerdomain);
        }
        tmp___11 = strlen((char const   *)ps[3]);
        memcpy((void * __restrict  )(tmptype), (void const   * __restrict  )ps[3],
               tmp___11 + 1UL);
        tmp___12 = strlen((char const   *)ps[0]);
        memcpy((void * __restrict  )(tmpdomain), (void const   * __restrict  )ps[0],
               tmp___12 + 1UL);
        vitor = vbuffer + sizeof(struct mvalue );
        mv->num = (uint16_t )0;
        mv->ttl = (uint32_t )0;
        mv->len = (uint16_t )0;
        mv->seg = (uint16_t )0;
      }
    }
    if (ttl > mv->ttl) {
      mv->ttl = ttl;
    }
    tmp___18 = strcmp((char const   *)ps[3], "NS");
    if (tmp___18 == 0) {
      goto _L___0;
    } else {
      tmp___19 = strcmp((char const   *)ps[3], "CNAME");
      if (tmp___19 == 0) {
        _L___0: /* CIL Label */
        tmp___15 = strlen((char const   *)ps[4]);
        str_to_len_label(ps[4], (int )(tmp___15 + 1UL));
        tmplen = check_dns_name(ps[4], & lowerns);
        if (tmplen > 0) {
          memcpy((void * __restrict  )vitor, (void const   * __restrict  )(lowerns.domain),
                 (size_t )tmplen);
          vitor += tmplen;
          mv->len = (uint16_t )((int )mv->len + tmplen);
          mv->num = (uint16_t )((int )mv->num + 1);
        }
      } else {
        tmp___17 = strcmp((char const   *)ps[3], "A");
        if (tmp___17 == 0) {
          str_to_uchar4((char const   *)ps[4], ipv4);
          memcpy((void * __restrict  )vitor, (void const   * __restrict  )(ipv4),
                 (size_t )4);
          vitor += 4;
          mv->len = (uint16_t )((int )mv->len + 4);
          mv->num = (uint16_t )((int )mv->num + 1);
        } else {
          tmp___16 = strcmp((char const   *)ps[3], "AAAA");
          if (tmp___16 == 0) {
            str_to_uchar6(ps[4], ipv6);
            memcpy((void * __restrict  )vitor, (void const   * __restrict  )(ipv6),
                   (size_t )16);
            vitor += 16;
            mv->len = (uint16_t )((int )mv->len + 16);
            mv->num = (uint16_t )((int )mv->num + 1);
          }
        }
      }
    }
  }
  tmp___21 = strcmp((char const   *)(tmptype), "NS");
  if (tmp___21 == 0) {
    type = 2;
  }
  tmp___22 = strcmp((char const   *)(tmptype), "A");
  if (tmp___22 == 0) {
    type = 1;
  }
  tmp___23 = strcmp((char const   *)(tmptype), "AAAA");
  if (tmp___23 == 0) {
    type = 28;
  }
  tmp___24 = strlen((char const   *)(tmpdomain));
  dlen = (int )(tmp___24 + 1UL);
  if (dlen > 1) {
    str_to_len_label(tmpdomain, dlen);
    check_dns_name(tmpdomain, & lowerdomain);
    insert_kv_mem(rbt, ds, kbuffer, dlen, type, vbuffer, (int )((unsigned long )mv->len + sizeof(struct mvalue )),
                  hijack___0, & lowerdomain);
  }
  fclose(fd);
  return (0);
}
}
int read_root(struct htable *ds , struct rbtree *rbt )
{
  int tmp ;

  {
  tmp = read_records_from_file("../root.z", ds, rbt, 0);
  return (tmp);
}
}
int refresh_records(struct htable *ds , struct rbtree *rbt )
{
  int tmp ;

  {
  printf((char const   * __restrict  )"read from records.z\n");
  tmp = read_records_from_file("../records.z", ds, rbt, 1);
  return (tmp);
}
}
int create_transfer_point(uchar *name , struct htable *fwd , int n )
{
  int i ;
  int dlen ;
  int ret ;
  uchar ipv4[4] ;
  unsigned int tmp ;
  uchar *addr ;
  uchar *itor ;
  uchar vbuffer[1000] ;
  unsigned int tmp___0 ;
  uchar *v ;
  hashval_t hash ;
  size_t tmp___1 ;
  struct mvalue *mv ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
  i = -1;
  ipv4[0] = (uchar )0;
  tmp = 1U;
  while (! (tmp >= 4U)) {
    ipv4[tmp] = (unsigned char)0;
    tmp ++;
  }
  addr = (uchar *)((void *)0);
  vbuffer[0] = (uchar )0;
  tmp___0 = 1U;
  while (! (tmp___0 >= 1000U)) {
    vbuffer[tmp___0] = (unsigned char)0;
    tmp___0 ++;
  }
  v = (uchar *)((void *)0);
  hash = (hashval_t )0;
  tmp___1 = strlen((char const   *)name);
  dlen = (int )(tmp___1 + 1UL);
  str_to_len_label(name, dlen);
  addr = name + dlen;
  mv = (struct mvalue *)(vbuffer);
  mv->num = (uint16_t )0;
  mv->ttl = (uint32_t )604801;
  mv->len = (uint16_t )0;
  itor = vbuffer + sizeof(struct mvalue );
  i = 0;
  while (i < n) {
    str_to_uchar4((char const   *)addr, ipv4);
    memcpy((void * __restrict  )itor, (void const   * __restrict  )(ipv4), (size_t )4);
    tmp___2 = strlen((char const   *)addr);
    addr = (addr + tmp___2) + 1;
    itor += 4;
    mv->len = (uint16_t )((int )mv->len + 4);
    mv->num = (uint16_t )((int )mv->num + 1);
    if ((int )*(addr + 0) == 0) {
      break;
    }
    i ++;
  }
  tmp___3 = malloc((unsigned long )mv->len + sizeof(struct mvalue ));
  v = (uchar *)tmp___3;
  memcpy((void * __restrict  )v, (void const   * __restrict  )(vbuffer), (unsigned long )mv->len + sizeof(struct mvalue ));
  ret = htable_insert(fwd, name, dlen, 1, v, 0, (struct mvalue *)((void *)0), & hash);
  if (! (ret == 0)) {
    __assert_fail("ret == HTABLE_INSERT_RET_NORMAL", "io.c", 241U, "create_transfer_point");
  }
  return (0);
}
}
int read_resolve(FILE *fd , char **nameservers , int n )
{
  char buf[1024] ;
  unsigned int tmp ;
  char *tmp___0 ;
  int i ;
  char placeholder[128] ;
  unsigned int tmp___1 ;
  char temp[32] ;
  unsigned int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
  buf[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 1024U)) {
    buf[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = (char *)((void *)0);
  i = 0;
  placeholder[0] = (char)0;
  tmp___1 = 1U;
  while (! (tmp___1 >= 128U)) {
    placeholder[tmp___1] = (char)0;
    tmp___1 ++;
  }
  temp[0] = (char)0;
  tmp___2 = 1U;
  while (! (tmp___2 >= 32U)) {
    temp[tmp___2] = (char)0;
    tmp___2 ++;
  }
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    return (-1);
  } else
  if (n <= 0) {
    return (-1);
  }
  i = 0;
  while (1) {
    tmp___6 = fgets((char * __restrict  )(buf), 1024, (FILE * __restrict  )fd);
    if (! ((unsigned long )tmp___6 != (unsigned long )((void *)0))) {
      break;
    }
    fix_tail(buf);
    if ((int )buf[0] == 58) {
      break;
    }
    tmp___0 = strstr((char const   *)(buf), "nameserver");
    if (! tmp___0) {
      continue;
    }
    if (i + 1 > n) {
      continue;
    }
    memset((void *)(placeholder), 0, (size_t )128);
    memset((void *)(temp), 0, (size_t )32);
    sscanf((char const   * __restrict  )(buf), (char const   * __restrict  )"%s %s",
           placeholder, temp);
    tmp___3 = strlen((char const   *)(temp));
    if (tmp___3 > 15UL) {
      continue;
    } else {
      tmp___4 = strlen((char const   *)(temp));
      if (tmp___4 < 7UL) {
        continue;
      }
    }
    tmp___5 = i;
    i ++;
    *(nameservers + tmp___5) = strdup((char const   *)(temp));
  }
  return (i);
}
}
int read_logpath(FILE *fd , char *path )
{
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  tmp = fgets((char * __restrict  )path, 512, (FILE * __restrict  )fd);
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    memcpy((void * __restrict  )path, (void const   * __restrict  )"/var/dnspod-sr/log/",
           (size_t )20);
  }
  fix_tail(path);
  tmp___1 = mkdir((char const   *)path, (__mode_t )493);
  if (tmp___1 != 0) {
    tmp___0 = __errno_location();
    if (*tmp___0 == 17) {
      return (0);
    } else {
      dns_error(0, (char *)"create log parent dir failed");
    }
  }
  return (0);
}
}
int read_transfer(FILE *fd , struct htable *fwd )
{
  char buf[1024] ;
  unsigned int tmp ;
  char *tmp___0 ;
  int i ;
  int n ;
  char *tmp___1 ;

  {
  buf[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 1024U)) {
    buf[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = (char *)((void *)0);
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    return (-1);
  } else
  if ((unsigned long )fwd == (unsigned long )((void *)0)) {
    return (-1);
  }
  while (1) {
    tmp___1 = fgets((char * __restrict  )(buf), 1024, (FILE * __restrict  )fd);
    if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
      break;
    }
    fix_tail(buf);
    if ((int )buf[0] == 58) {
      break;
    }
    tmp___0 = strstr((char const   *)(buf), ":");
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
      *(tmp___0 + 0) = (char)0;
      tmp___0 ++;
      n = 1;
      i = 0;
      while (i < 8) {
        tmp___0 = strstr((char const   *)tmp___0, ",");
        if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
          break;
        } else {
          n ++;
          *(tmp___0 + 0) = (char)0;
          tmp___0 ++;
        }
        i ++;
      }
      if (i != 8) {
        create_transfer_point((uchar *)(buf), fwd, n);
      }
    }
  }
  return (0);
}
}
int read_config(char const   *fn , char *logpath , struct htable *forward , char **nameservers )
{
  FILE *fd ;
  char buf[1024] ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  fd = (FILE *)((void *)0);
  buf[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 1024U)) {
    buf[tmp] = (char)0;
    tmp ++;
  }
  if ((unsigned long )fn == (unsigned long )((void *)0)) {
    return (-1);
  }
  fd = fopen((char const   * __restrict  )fn, (char const   * __restrict  )"r");
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    return (-1);
  }
  while (1) {
    tmp___3 = fgets((char * __restrict  )(buf), 1024, (FILE * __restrict  )fd);
    if (! ((unsigned long )tmp___3 != (unsigned long )((void *)0))) {
      break;
    }
    fix_tail(buf);
    tmp___0 = strcmp((char const   *)(buf), "xfer:");
    if (tmp___0 == 0) {
      read_transfer(fd, forward);
      continue;
    }
    tmp___1 = strcmp((char const   *)(buf), "log_path:");
    if (tmp___1 == 0) {
      read_logpath(fd, logpath);
      continue;
    }
    tmp___2 = strcmp((char const   *)(buf), "resolve:");
    if (tmp___2 == 0) {
      read_resolve(fd, nameservers, 2);
      continue;
    }
  }
  fclose(fd);
  return (0);
}
}
int fill_domain_to_len_label(char const   *from , char *to )
{
  int len ;
  char const   *itor ;

  {
  len = 0;
  itor = from;
  if ((int const   )*(itor + 0) == 0) {
    *(to + 0) = (char )'.';
    return (1);
  }
  while ((int const   )*(itor + 0) != 0) {
    memcpy((void * __restrict  )to, (void const   * __restrict  )(itor + 1), (size_t )*(itor + 0));
    to += (int const   )*(itor + 0);
    len += (int )*(itor + 0);
    itor = (itor + (int const   )*(itor + 0)) + 1;
    *(to + 0) = (char )'.';
    to ++;
    len ++;
  }
  return (len);
}
}
int write_loginfo_into_file(struct log_info *log , uchar const   *domain , int dlen ,
                            int type , struct sockaddr_in *addr )
{
  uchar tp ;
  int fd ;
  int tmplen ;
  int ret ;
  ssize_t tmp ;

  {
  tp = (uchar )(type % 256);
  fd = log->logfd;
  tmplen = 0;
  ret = 0;
  if (fd <= 0) {
    return (-1);
  }
  if ((unsigned long )domain != (unsigned long )((void *)0)) {
    tmplen = 8 + dlen;
    if (log->log_cache_cursor + tmplen >= 1048576) {
      tmp = write(log->logfd, (void const   *)(log->log_cache), (size_t )log->log_cache_cursor);
      ret = (int )tmp;
      if (ret == -1) {
        perror("write");
      }
      log->log_cache_cursor = 0;
    }
    if (tmplen >= 1048576) {
      return (0);
    } else {
      log->log_cache[log->log_cache_cursor] = (uchar )255;
      log->log_cache[log->log_cache_cursor + 1] = tp;
      log->log_cache[log->log_cache_cursor + 2] = (uchar )2;
      memcpy((void * __restrict  )((log->log_cache + log->log_cache_cursor) + 3),
             (void const   * __restrict  )(& addr->sin_addr.s_addr), sizeof(addr->sin_addr.s_addr));
      memcpy((void * __restrict  )(((log->log_cache + log->log_cache_cursor) + 3) + sizeof(addr->sin_addr.s_addr)),
             (void const   * __restrict  )domain, (size_t )dlen);
      log->log_cache_cursor += tmplen;
      log->log_cache[log->log_cache_cursor - 1] = (uchar )'#';
    }
  }
  return (0);
}
}
static char pf[50]  = {      (char)0};
int create_new_log(uchar *prefix , int idx , int type )
{
  char filename[80] ;
  unsigned int tmp ;
  char final[130] ;
  unsigned int tmp___0 ;
  int fd ;
  int bit ;
  int len ;
  mode_t mode ;
  time_t prev ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
  filename[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 80U)) {
    filename[tmp] = (char)0;
    tmp ++;
  }
  final[0] = (char)0;
  tmp___0 = 1U;
  while (! (tmp___0 >= 130U)) {
    final[tmp___0] = (char)0;
    tmp___0 ++;
  }
  fd = -1;
  mode = (mode_t )((384 | (256 >> 3)) | ((256 >> 3) >> 3));
  if ((int )pf[0] == 0) {
    tmp___1 = strlen((char const   *)prefix);
    memcpy((void * __restrict  )(pf), (void const   * __restrict  )prefix, tmp___1 + 1UL);
  }
  filename[0] = (char )'f';
  if (type != 233) {
    if (type != 112) {
      return (-1);
    }
  }
  if (type == 233) {
    filename[0] = (char )'q';
  }
  bit = idx / 100;
  filename[1] = (char )(bit + 48);
  bit = (idx % 100) / 10;
  filename[2] = (char )(bit + 48);
  bit = idx % 10;
  filename[3] = (char )(bit + 48);
  prev = global_now - global_now % 900L;
  sprintf((char * __restrict  )(filename + 4), (char const   * __restrict  )"%lu",
          prev);
  tmp___2 = strlen((char const   *)(filename));
  memcpy((void * __restrict  )(filename + tmp___2), (void const   * __restrict  )".log",
         (size_t )5);
  tmp___3 = strlen((char const   *)(pf));
  len = (int )tmp___3;
  memcpy((void * __restrict  )(final), (void const   * __restrict  )(pf), (size_t )len);
  tmp___4 = strlen((char const   *)(filename));
  memcpy((void * __restrict  )(final + len), (void const   * __restrict  )(filename),
         tmp___4 + 1UL);
  fd = open((char const   *)(final), 65, mode);
  return (fd);
}
}
int write_log(struct log_info *log , int idx , uchar const   *domain , int dlen ,
              int type , struct sockaddr_in *addr )
{
  int lfd ;

  {
  add_query_info(log->log_type, idx, (uint16_t )type);
  lfd = log->logfd;
  if (global_now % 900L == 0L) {
    if (global_now > log->lastlog) {
      close(lfd);
      lfd = create_new_log((uchar *)((void *)0), idx, log->log_type);
      log->logfd = lfd;
    }
  }
  write_loginfo_into_file(log, domain, dlen, type, addr);
  log->lastlog = global_now;
  return (0);
}
}
/* compiler builtin:
   void *__builtin_memset(void * , int  , int  ) ;  */
#pragma merger("0","/tmp/cil-Ekft9TMn.i","-g,-Wall")
extern  __attribute__((__nothrow__)) pthread_t pthread_self(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) pthread_setaffinity_np)(pthread_t __th ,
                                                                                                   size_t __cpusetsize ,
                                                                                                   cpu_set_t const   *__cpuset ) ;
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
mbuf_type *mbuf_alloc(void) ;
int mbuf_free(mbuf_type *mbuf ) ;
extern int epoll_wait(int __epfd , struct epoll_event *__events , int __maxevents ,
                      int __timeout ) ;
int global_cron(struct server *s ) ;
int run_sentinel(struct server *s ) ;
struct event *create_event(int size ) ;
int add_event(struct event *ev , struct event_help *help___0 ) ;
int del_event(struct event *ev , struct event_help *help___0 ) ;
struct event *create_event(int size )
{
  struct event *ev ;
  void *tmp ;
  int epfd ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  tmp = malloc(sizeof(struct event ) + sizeof(struct event_data ) * (unsigned long )size);
  ev = (struct event *)tmp;
  tmp___0 = epoll_create(size);
  epfd = tmp___0;
  if (epfd == 0) {
    dns_error(0, (char *)"epoll create");
  }
  ev->size = size;
  tmp___1 = malloc(sizeof(struct iner_event ) + sizeof(struct epoll_event ) * (unsigned long )ev->size);
  ev->ie = (struct iner_event *)tmp___1;
  if ((unsigned long )ev->ie == (unsigned long )((void *)0)) {
    dns_error(0, (char *)"alloc iner event");
  }
  memset((void *)ev->ie, 0, sizeof(struct iner_event ) + sizeof(struct epoll_event ) * (unsigned long )ev->size);
  (ev->ie)->epfd = epfd;
  return (ev);
}
}
int add_event(struct event *ev , struct event_help *help___0 )
{
  struct epoll_event e ;
  int ret ;
  int epfd ;

  {
  e.events = (uint32_t )0;
  e.data.ptr = (void *)0;
  ret = 0;
  epfd = (ev->ie)->epfd;
  e.data.fd = help___0->fd;
  if (e.data.fd < 0) {
    return (-1);
  }
  if ((unsigned int )help___0->type == 1U) {
    e.events = (uint32_t )1;
  }
  if ((unsigned int )help___0->type == 2U) {
    e.events = (uint32_t )4;
  }
  ev->data[help___0->fd].cb = help___0->cb;
  if ((unsigned long )help___0->ext != (unsigned long )((void *)0)) {
    ev->data[help___0->fd].ext = help___0->ext;
  }
  ret = epoll_ctl(epfd, 1, help___0->fd, & e);
  if (ret < 0) {
    printf((char const   * __restrict  )"fd is %d\n", help___0->fd);
    perror("epoll_ctl");
  }
  return (ret);
}
}
int del_event(struct event *ev , struct event_help *help___0 )
{
  struct epoll_event e ;
  struct iner_event *ie ;
  int ret ;

  {
  ie = ev->ie;
  ret = 0;
  e.data.fd = help___0->fd;
  ret = epoll_ctl(ie->epfd, 2, help___0->fd, & e);
  return (ret);
}
}
int handle_event(struct event *ev , int to )
{
  int num ;
  struct iner_event *ie ;
  int *tmp ;

  {
  num = 0;
  ie = ev->ie;
  if (to == 0) {
    to = -1;
  } else {
    to *= 100;
  }
  ev->size = 100;
  while (1) {
    num = epoll_wait(ie->epfd, ie->e, ev->size, to);
    if (num >= 0) {
      break;
    }
    if (num < 0) {
      tmp = __errno_location();
      if (*tmp == 4) {
        continue;
      }
    }
  }
  return (num);
}
}
int cb_get_tcp_msg(struct event_data *data , void *v , int idx )
{
  int ret ;
  int szhdr ;
  struct msgcache *mc ;
  struct fetcher *f ;
  mbuf_type *mbuf ;

  {
  szhdr = (int )sizeof(dnsheader );
  f = (struct fetcher *)v;
  mbuf = mbuf_alloc();
  if ((unsigned long )((void *)0) == (unsigned long )mbuf) {
    return (0);
  }
  memset((void *)mbuf, 0, sizeof(mbuf_type ));
  mc = (f + idx)->mc;
  pthread_spin_lock(& mc->lock);
  if (mc->tail + 8UL > (uint64_t )mc->size) {
    mc->tail = (uint64_t )0;
  }
  if (mc->tail + 8UL > mc->head) {
    if (mc->tail < mc->head) {
      close(data->fd);
      ((f + idx)->miss) ++;
      pthread_spin_unlock(& mc->lock);
      mbuf_free(mbuf);
      return (0);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */
  if (mc->tail == mc->head) {
    if (mc->pkt != 0U) {
      close(data->fd);
      ((f + idx)->miss) ++;
      pthread_spin_unlock(& mc->lock);
      mbuf_free(mbuf);
      return (0);
    }
  }
  ((f + idx)->pkg) ++;
  mbuf->socktype = (uint___0 )1;
  mbuf->fd = data->fd;
  mbuf->buf = mbuf->data;
  mbuf->buflen = 4096;
  ret = tcp_read_dns_msg(mbuf, (uint___0 )4096, 0);
  if (ret < szhdr) {
    pthread_spin_unlock(& mc->lock);
    mbuf_free(mbuf);
    return (-1);
  }
  mbuf->fetch_len = (uint___0 )ret;
  memcpy((void * __restrict  )(mc->data + mc->tail), (void const   * __restrict  )(& mbuf),
         sizeof(void *));
  mc->tail += sizeof(void *);
  if (mc->tail + 8UL > (uint64_t )mc->size) {
    mc->tail = (uint64_t )0;
  }
  (mc->pkt) ++;
  pthread_spin_unlock(& mc->lock);
  return (0);
}
}
int fake_recv(struct event_data *data , void *v , int idx )
{
  struct fetcher *f ;
  struct sockaddr_in addr ;
  uchar buffer[512] ;
  unsigned int tmp ;
  int ret ;
  socklen_t len ;
  ssize_t tmp___0 ;

  {
  f = (struct fetcher *)v;
  buffer[0] = (uchar )0;
  tmp = 1U;
  while (! (tmp >= 512U)) {
    buffer[tmp] = (unsigned char)0;
    tmp ++;
  }
  idx = 0;
  len = (socklen_t )sizeof(struct sockaddr_in );
  while (1) {
    tmp___0 = recvfrom(data->fd, (void * __restrict  )(buffer), (size_t )512, 0, (struct sockaddr * __restrict  )((SA *)(& addr)),
                       (socklen_t * __restrict  )(& len));
    ret = (int )tmp___0;
    if (ret > 0) {
      ((f + idx)->pkg) ++;
    } else {
      return (0);
    }
  }
  return (0);
}
}
int cb_get_udp_msg(struct event_data *data , void *v , int idx )
{
  int ret ;
  int szhdr ;
  struct msgcache *mc ;
  struct fetcher *f ;
  mbuf_type *mbuf ;

  {
  szhdr = (int )sizeof(dnsheader );
  mc = (struct msgcache *)((void *)0);
  f = (struct fetcher *)v;
  while (1) {
    mbuf = mbuf_alloc();
    if ((unsigned long )((void *)0) == (unsigned long )mbuf) {
      return (0);
    }
    memset((void *)mbuf, 0, sizeof(mbuf_type ));
    mc = (f + idx)->mc;
    pthread_spin_lock(& mc->lock);
    if (mc->tail + 8UL > mc->head) {
      if (mc->tail < mc->head) {
        ((f + idx)->miss) ++;
        pthread_spin_unlock(& mc->lock);
        mbuf_free(mbuf);
        return (0);
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */
    if (mc->tail == mc->head) {
      if (mc->pkt != 0U) {
        ((f + idx)->miss) ++;
        pthread_spin_unlock(& mc->lock);
        mbuf_free(mbuf);
        return (0);
      }
    }
    ((f + idx)->pkg) ++;
    mbuf->socktype = (uint___0 )2;
    mbuf->fd = data->fd;
    mbuf->buf = mbuf->data + 2;
    mbuf->buflen = 4094;
    mbuf->addr = & mbuf->caddr;
    ret = udp_read_msg(mbuf, 0);
    if (ret < szhdr) {
      pthread_spin_unlock(& mc->lock);
      mbuf_free(mbuf);
      return (-1);
    }
    mbuf->fetch_len = (uint___0 )ret;
    memcpy((void * __restrict  )(mc->data + mc->tail), (void const   * __restrict  )(& mbuf),
           sizeof(void *));
    mc->tail += sizeof(void *);
    if (mc->tail + 8UL > (uint64_t )mc->size) {
      mc->tail = (uint64_t )0;
    }
    (mc->pkt) ++;
    pthread_spin_unlock(& mc->lock);
  }
  return (0);
}
}
int insert_events(struct event *ev , int fd , int type )
{
  struct event_help h ;
  int tmp ;

  {
  if (fd > 0) {
    memset((void *)(& h), 0, sizeof(struct event_help ));
    h.type = (enum event_type )1;
    h.fd = fd;
    if (type == 2) {
      h.cb = & cb_get_udp_msg;
    } else {
      h.cb = & cb_get_tcp_msg;
    }
    tmp = add_event(ev, & h);
    if (tmp < 0) {
      dns_error(1, (char *)"add event notify");
    }
  }
  return (0);
}
}
int run_sentinel(struct server *s )
{
  int num ;
  int i ;
  int ls ;
  int connfd ;
  int ret ;
  int fidx ;
  struct sockaddr_in addr ;
  struct event_help h ;
  socklen_t len ;
  struct fetcher *f ;
  struct event *ev ;
  struct event *tmp ;
  cpu_set_t cpuinfo ;
  pthread_t pt ;
  pthread_t tmp___0 ;
  size_t __cpu ;
  int tmp___1 ;
  int fd ;
  int (*cb)(struct event_data * , void * , int  ) ;

  {
  fidx = 0;
  len = (socklen_t )sizeof(addr);
  f = s->fetchers;
  tmp = create_event(1000);
  ev = tmp;
  tmp___0 = pthread_self();
  pt = tmp___0;
  while (1) {
    __builtin_memset((void *)(& cpuinfo), '\000', (int )sizeof(cpu_set_t ));
    break;
  }
  __cpu = (size_t )0;
  if (__cpu / 8UL < sizeof(cpuinfo)) {
    cpuinfo.__bits[__cpu / (8UL * sizeof(__cpu_mask ))] |= 1UL << __cpu % (8UL * sizeof(__cpu_mask ));
  }
  tmp___1 = pthread_setaffinity_np(pt, sizeof(cpu_set_t ), (cpu_set_t const   *)(& cpuinfo));
  if (0 != tmp___1) {
    printf((char const   * __restrict  )"set affinity fetcher\n");
    exit(0);
  }
  if ((unsigned long )ev == (unsigned long )((void *)0)) {
    dns_error(0, (char *)"create event st");
  }
  insert_events(ev, s->ludp, 2);
  insert_events(ev, s->ltcp, 1);
  ls = s->ltcp;
  while (1) {
    num = handle_event(ev, 1);
    global_cron(s);
    i = 0;
    while (i < num) {
      fd = (ev->ie)->e[i].data.fd;
      cb = ev->data[fd].cb;
      ev->data[fd].fd = fd;
      if (fd == ls) {
        connfd = accept(fd, (struct sockaddr * __restrict  )((SA *)(& addr)), (socklen_t * __restrict  )(& len));
        set_non_block(connfd);
        insert_events(ev, connfd, 1);
        goto __Cont;
      } else
      if ((unsigned long )cb != (unsigned long )((void *)0)) {
        fidx ++;
        fidx %= 2;
        if (fidx >= 2) {
          fidx = 1;
        }
        ret = (*cb)(ev->data + fd, (void *)f, fidx);
        if ((unsigned long )cb == (unsigned long )(& cb_get_tcp_msg)) {
          if (ret == -1) {
            close(fd);
          }
          h.fd = fd;
          del_event(ev, & h);
        }
      } else {
        dns_error(1, (char *)"call back func is null");
      }
      __Cont: /* CIL Label */
      i ++;
    }
  }
  return (0);
}
}
#pragma merger("0","/tmp/cil-NmyyAHrN.i","-g,-Wall")
extern int usleep(__useconds_t __useconds ) ;
extern  __attribute__((__nothrow__)) int pthread_detach(pthread_t __th ) ;
void *run_quizzer(void *arg ) ;
int run_fetcher(struct fetcher *f ) ;
int write_back_to_client(mbuf_type *mbuf , uchar *fr , int vlen ) ;
uchar qlist_val[10]  =
  {      (uchar )'q',      (uchar )'l',      (uchar )'i',      (uchar )'s',
        (uchar )'t',      (uchar )' ',      (uchar )'v',      (uchar )'a',
        (uchar )'l',      (uchar )'\000'};
int find_record_from_mem(uchar *otd , int dlen , int type , struct htable *datasets ,
                         uchar *tdbuffer , uchar *databuffer , hashval_t *hash ) ;
int add_to_quizzer(struct qoutinfo *qo , struct server *s , int qidx ) ;
int add_query_info(int log_type , int idx , uint16_t type )
{
  int thread_num ;
  int query_type_num ;

  {
  thread_num = 0;
  if (log_type == 112) {
    thread_num = idx;
  } else
  if (log_type == 233) {
    thread_num = idx + 2;
  } else {
    return (-1);
  }
  query_type_num = query_type_map[type];
  if (query_type_num < 0) {
    return (-1);
  }
  (global_out_info->query_info[thread_num].query_num[query_type_num]) ++;
  return (0);
}
}
int get_random_int_from_author(struct author *author )
{
  int val ;
  union grifa tmp ;

  {
  val = 0;
  if ((unsigned long )author->rndidx + sizeof(int ) >= 3000UL) {
    get_random_data(author->randombuffer, 3000);
    author->rndidx = 0;
  }
  memcpy((void * __restrict  )(tmp.randombuffer), (void const   * __restrict  )(author->randombuffer + author->rndidx),
         sizeof(int ));
  val = tmp.val;
  author->rndidx = (int )((unsigned long )author->rndidx + sizeof(int ));
  return (val);
}
}
int delete_close_event(int fd , struct fetcher *f )
{
  struct list *el ;
  struct list_node *nd ;
  void *tmp ;

  {
  el = (struct list *)((void *)0);
  nd = (struct list_node *)((void *)0);
  el = f->el;
  if ((unsigned long )el == (unsigned long )((void *)0)) {
    return (-1);
  }
  tmp = malloc(sizeof(struct list_node ));
  nd = (struct list_node *)tmp;
  if ((unsigned long )nd == (unsigned long )((void *)0)) {
    return (-1);
  }
  nd->data = malloc(sizeof(int ));
  if ((unsigned long )nd->data == (unsigned long )((void *)0)) {
    free((void *)nd);
    return (-1);
  }
  memcpy((void * __restrict  )nd->data, (void const   * __restrict  )(& fd), sizeof(int ));
  pthread_spin_lock(& el->lock);
  nd->next = el->head;
  el->head = nd;
  pthread_spin_unlock(& el->lock);
  return (0);
}
}
int write_back_to_client(mbuf_type *mbuf , uchar *fr , int vlen )
{
  struct setheader sh ;
  int main_val ;
  int dnslen ;
  uchar *msg ;
  uchar type ;
  uchar *from ;
  uchar *to ;
  struct mvalue *mv ;
  int jump ;
  uint16_t temp ;
  struct hlpc hlp[100] ;

  {
  sh.an = (ushort___0 )0;
  sh.ns = (unsigned short)0;
  sh.id = (unsigned short)0;
  sh.dlen = (unsigned short)0;
  sh.od = (uchar *)0;
  sh.itor = (uchar *)0;
  sh.type = (unsigned short)0;
  main_val = 0;
  dnslen = 0;
  msg = mbuf->buf;
  from = fr;
  to = msg;
  mv = (struct mvalue *)((void *)0);
  jump = 0;
  temp = (uint16_t )0;
  hlp[0].name = mbuf->td;
  hlp[0].off = (short )sizeof(dnsheader );
  hlp[0].level = (short )mbuf->lowerdomain.label_count;
  hlp[0].ref = (short)-1;
  hlp[0].mt = (short)0;
  hlp[0].len = (short )mbuf->dlen;
  if (mbuf->dlen == 2) {
    jump = (int )((sizeof(dnsheader ) + 1UL) + sizeof(qdns ));
  } else {
    jump = (int )((sizeof(dnsheader ) + (unsigned long )mbuf->dlen) + sizeof(qdns ));
  }
  to += jump;
  while (vlen > 1) {
    type = *(from + 0);
    mv = (struct mvalue *)(from + 1);
    to = fill_rrset_in_msg(hlp, from, to, & main_val, msg);
    if ((unsigned long )to == (unsigned long )((void *)0)) {
      return (-1);
    }
    vlen = (int )((unsigned long )((vlen - 1) - (int )mv->len) - sizeof(struct mvalue ));
    sh.an = (ushort___0 )((int )sh.an + (int )mv->num);
    from = ((from + (int )mv->len) + 1) + sizeof(struct mvalue );
    if ((int )type == 5) {
      if (vlen > 1) {
        if ((int )*(from + 0) == 1) {
          goto _L;
        } else
        if ((int )*(from + 0) == 28) {
          goto _L;
        } else
        if ((int )*(from + 0) == 5) {
          _L: /* CIL Label */
          main_val ++;
          hlp[main_val].name = hlp[main_val - 1].name;
          hlp[main_val].off = hlp[main_val - 1].off;
          hlp[main_val].level = hlp[main_val - 1].level;
          hlp[main_val].len = hlp[main_val - 1].len;
          hlp[main_val].ref = (short)-1;
          hlp[main_val].mt = (short)0;
        }
      }
    }
  }
  sh.itor = msg;
  if (mbuf->dlen == 2) {
    sh.dlen = (ushort___0 )1;
  } else {
    sh.dlen = (ushort___0 )mbuf->dlen;
  }
  sh.od = mbuf->td;
  sh.id = mbuf->id;
  sh.type = (ushort___0 )mbuf->qtype;
  fill_header_in_msg(& sh);
  dnslen = (int )(to - msg);
  mbuf->buflen = dnslen;
  mbuf->addr = & mbuf->caddr;
  if (mbuf->socktype == 2U) {
    if (dnslen > 512) {
      send_tc_to_client(mbuf);
    } else {
      udp_write_info(mbuf, 0);
    }
  } else {
    temp = (uint16_t )(((int )((uint16_t )dnslen) >> 8) | (int )((uint16_t )(dnslen << 8)));
    memcpy((void * __restrict  )(msg - 2), (void const   * __restrict  )(& temp),
           sizeof(uint16_t ));
    mbuf->buflen = dnslen + 2;
    mbuf->buf = msg - 2;
    tcp_write_info(mbuf, 0);
  }
  return (0);
}
}
int passer_related_data(struct sockinfo *si , mbuf_type *mbuf , struct author *author )
{
  uchar *buf ;
  uchar *tail ;
  int stype ;
  struct rbtree *rbt ;
  int datalen ;
  ushort___0 n ;
  struct hlpp hlp ;
  dnsheader *hdr ;
  uint8_t opt_owner ;
  uint16_t opt_type ;

  {
  buf = si->buf;
  tail = (uchar *)((void *)0);
  stype = 0;
  datalen = 0;
  hdr = (dnsheader *)buf;
  tail = (buf + sizeof(dnsheader )) + (int )(si->lowerdomain)->label_len[0];
  tail += 4;
  datalen = si->buflen;
  rbt = (author->s)->ttlexp;
  n = ntohs(hdr->ancount);
  hlp.stype = & stype;
  hlp.ds = (author->s)->datasets;
  hlp.rbt = rbt;
  hlp.buf = buf;
  hlp.datalen = datalen;
  hlp.tmpbuf = mbuf->tempbuffer;
  hlp.domainbuf = mbuf->tdbuffer;
  hlp.dmbuf = mbuf->dmbuffer;
  if ((int )n > 0) {
    hlp.section = 2;
    tail = process_rdata(& hlp, tail, (int )n);
    if ((unsigned long )tail == (unsigned long )((void *)0)) {
      return (-1);
    }
  }
  n = ntohs(hdr->nscount);
  if ((int )n > 0) {
    hlp.section = 5;
    tail = process_rdata(& hlp, tail, (int )n);
    if ((unsigned long )tail == (unsigned long )((void *)0)) {
      return (-1);
    }
  }
  n = ntohs(hdr->arcount);
  if ((int )n > 0) {
    if ((unsigned long )((tail + 9U) + 2) <= (unsigned long )(buf + datalen)) {
      opt_owner = *tail;
      opt_type = *((uint16_t *)(tail + 1));
      if ((int )opt_owner == 0) {
        if ((((int )opt_type >> 8) | (int )((uint16_t )((int )opt_type << 8))) == 41) {
          return (stype);
        }
      }
    }
    hlp.section = 7;
    tail = process_rdata(& hlp, tail, (int )n);
    if ((unsigned long )tail == (unsigned long )((void *)0)) {
      return (-1);
    }
  }
  return (stype);
}
}
int send_msg_tcp(struct author *author , int fd )
{
  ushort___0 id ;
  ushort___0 typeoff ;
  ushort___0 temp ;
  ushort___0 type ;
  uchar *buffer ;
  int len ;
  int ret ;
  mbuf_type *mbuf ;
  uchar *domain ;

  {
  buffer = author->tmpbuffer;
  ret = author->eptcpfds[fd].ret;
  if (ret <= 0) {
    return (-1);
  }
  domain = author->eptcpfds[fd].domain;
  id = (ushort___0 )(ret & 4095);
  typeoff = (ushort___0 )(ret >> 12);
  ret = htable_find_list((author->s)->qlist, domain, (int )typeoff, (int )id, (uchar **)(& mbuf));
  if (ret < 0) {
    return (ret);
  }
  type = (ushort___0 )mbuf->qtype;
  if ((int )mbuf->qname == 6) {
    type = (ushort___0 )1;
  }
  len = make_dns_msg_for_new(buffer + 2, mbuf->aid, mbuf->qing, (int )mbuf->qlen,
                             type);
  temp = htons((uint16_t )len);
  memcpy((void * __restrict  )buffer, (void const   * __restrict  )(& temp), sizeof(ushort___0 ));
  mbuf->fd = fd;
  mbuf->buf = buffer;
  mbuf->buflen = len + 2;
  tcp_write_info(mbuf, 0);
  return (0);
}
}
int query_from_auth_tcp(struct author *author , mbuf_type *mbuf )
{
  struct sockinfo si ;
  int i ;
  int st ;
  uchar *ip ;
  struct mvalue *mv ;

  {
  st = 0;
  ip = author->ip;
  mv = (struct mvalue *)((void *)0);
  mv = (struct mvalue *)ip;
  while ((int )mv->num > 0) {
    ip += sizeof(struct mvalue );
    i = 0;
    while (i < (int )mv->num) {
      if (st == mbuf->tcpnums - 1) {
        si.fd = mbuf->tcpfd;
        make_addr_from_bin(& si.addr, ip);
        si.addr.sin_port = htons((uint16_t )53);
        si.addr.sin_family = (sa_family_t )2;
        connect_to(& si);
        st = 4;
      }
      st ++;
      i ++;
    }
    ip += (int )mv->len;
    mv = (struct mvalue *)ip;
    if (st > 3) {
      break;
    }
  }
  return (0);
}
}
int query_from_auth_server(mbuf_type *mbuf , struct author *author )
{
  ushort___0 id ;
  ushort___0 type ;
  uchar *buffer ;
  uchar *ip ;
  int len ;
  int i ;
  int st ;
  int ret ;
  struct mvalue *mv ;

  {
  id = mbuf->aid;
  buffer = mbuf->tempbuffer;
  ip = author->ip;
  st = 1;
  mv = (struct mvalue *)((void *)0);
  if ((int )mbuf->qname == 6) {
    type = (ushort___0 )1;
  } else {
    type = (ushort___0 )mbuf->qtype;
  }
  (mbuf->mxtry) ++;
  if (mbuf->socktype == 2U) {
    len = make_dns_msg_for_new(buffer, id, mbuf->qing, (int )mbuf->qlen, type);
    mbuf->buf = buffer;
    mbuf->buflen = len;
    mbuf->fd = author->audp;
    mv = (struct mvalue *)ip;
    while ((int )mv->num > 0) {
      ip += sizeof(struct mvalue );
      i = 0;
      while (i < (int )mv->num) {
        make_addr_from_bin(& mbuf->aaddr, ip + i * 4);
        mbuf->aaddr.sin_port = htons((uint16_t )53);
        mbuf->addr = & mbuf->aaddr;
        ret = udp_write_info(mbuf, 0);
        if (ret > 0) {
          st ++;
        }
        if (st > mbuf->mxtry) {
          return (0);
        }
        i ++;
      }
      ip += (int )mv->len;
      mv = (struct mvalue *)ip;
      if (st > 3) {
        break;
      }
    }
  }
  return (0);
}
}
int release_qoutinfo(struct author *author , mbuf_type *mbuf , uint32_t idx )
{
  int fd ;
  int epfd ;
  int id ;
  int typeoff ;
  uchar *val ;
  struct epoll_event ev ;

  {
  fd = mbuf->tcpfd;
  if (fd > 0) {
    ev.events = (uint32_t )0;
    ev.data.ptr = (void *)0;
    epfd = author->bdepfd;
    (author->tcpinuse) --;
    epoll_ctl(epfd, 2, fd, & ev);
    author->eptcpfds[fd].ret = 0;
    close(fd);
  }
  id = (int )(idx & 4095U);
  typeoff = (int )(idx >> 12);
  val = htable_delete_list((author->s)->qlist, mbuf->lowerdomain.domain, typeoff,
                           id);
  if ((unsigned long )val == (unsigned long )((void *)0)) {
    printf((char const   * __restrict  )"del list val =0, mbuf:0x%0x\n", mbuf);
    return (0);
  }
  if (! ((unsigned long )val == (unsigned long )((void *)mbuf))) {
    __assert_fail("val == (void *)mbuf", "author.c", 446U, "release_qoutinfo");
  }
  mbuf_free(mbuf);
  return (0);
}
}
int init_qoutinfo(mbuf_type *mbuf )
{
  struct timeval tv ;

  {
  gettimeofday((struct timeval * __restrict  )(& tv), (void * __restrict  )((void *)0));
  mbuf->socktype = (uint___0 )2;
  mbuf->mxtry = 0;
  mbuf->qns = 1;
  mbuf->sq = (ushort___0 )1;
  mbuf->stime = (uint64_t )(tv.tv_sec * 1000L + tv.tv_usec / 1000L);
  mbuf->tcpfd = 0;
  mbuf->qtimes = (ushort___0 )0;
  mbuf->tdbuffer = (uchar *)((void *)0);
  mbuf->tempbuffer = (uchar *)((void *)0);
  mbuf->dmbuffer = (uchar *)((void *)0);
  mbuf->ipbuffer = (uchar *)((void *)0);
  mbuf->hascname = (ushort___0 )0;
  mbuf->tcpnums = 0;
  mbuf->stat = (ushort___0 )0;
  return (0);
}
}
int check_enter(struct author *author , uchar *buf , int *idx , mbuf_type **mbuf ,
                packet_type *lowerdomain )
{
  int32_t id ;
  int32_t typeoff ;
  int ret ;
  int tx ;
  dnsheader *hdr ;

  {
  tx = 0;
  hdr = (dnsheader *)buf;
  *idx = (int )hdr->id;
  id = (int )hdr->id & 4095;
  typeoff = (int )hdr->id >> 12;
  if (id >= 4095) {
    return (-1);
  } else
  if (typeoff >= 9) {
    return (-1);
  }
  ret = check_dns_name(buf + sizeof(dnsheader ), lowerdomain);
  if (ret < 0) {
    return (-1);
  }
  ret = htable_find_list((author->s)->qlist, lowerdomain->domain, typeoff, id, (uchar **)mbuf);
  if (ret < 0) {
    return (-1);
  }
  if ((int )(*mbuf)->stat == 0) {
    *mbuf = (mbuf_type *)((void *)0);
    return (-1);
  }
  ret = check_an_msg(hdr->flags, (uchar *)((void *)0), & tx);
  if (ret < 0) {
    return (-1);
  }
  if (ret == 1) {
    return (-2);
  }
  if (ret == 2) {
    if (tx == 1) {
      return (-3);
    }
  }
  (*mbuf)->socktype = (uint___0 )2;
  return (1);
}
}
int passer_auth_data(struct author *author , uchar *buf , struct sockinfo *si )
{
  int idx ;
  int ret ;
  int pret ;
  mbuf_type *mbuf ;
  ushort___0 xtype ;
  dnsheader *hdr ;
  packet_type lowerdomain ;
  uint16_t tmp ;

  {
  mbuf = (mbuf_type *)((void *)0);
  xtype = (ushort___0 )0;
  hdr = (dnsheader *)buf;
  ret = check_enter(author, buf, & idx, & mbuf, & lowerdomain);
  mbuf_free(si->mbuf);
  si->mbuf = mbuf;
  if (ret == -2) {
    return (- idx - 1);
  }
  if (ret == 0) {
    return (0);
  }
  if (ret == -1) {
    return (idx + 1);
  }
  (mbuf->mxtry) --;
  if (ret == -3) {
    mbuf->qtimes = (ushort___0 )((int )mbuf->qtimes + 1);
    return (0);
  }
  si->lowerdomain = & lowerdomain;
  pret = passer_related_data(si, mbuf, author);
  if (pret < 0) {
    return (0);
  }
  mbuf->fd = (author->s)->ludp;
  mbuf->addr = & mbuf->caddr;
  if (pret == 5) {
    if ((unsigned int )mbuf->qtype == 5U) {
      if (mbuf->fd != -1) {
        *((ushort___0 *)buf) = mbuf->cid;
        mbuf->buf = buf;
        mbuf->buflen = si->buflen;
        if (si->buflen > 512) {
          send_tc_to_client(mbuf);
        } else {
          udp_write_info(mbuf, 0);
          write_log(author->loginfo, author->idx, (uchar const   *)mbuf->td, mbuf->dlen,
                    (int )mbuf->qtype, mbuf->addr);
        }
      }
      return (idx + 1);
    }
  }
  if (pret == 5) {
    mbuf->stat = (ushort___0 )1;
    mbuf->socktype = (uint___0 )2;
    return (0);
  } else
  if ((int )mbuf->qname != 4) {
    mbuf->stat = (ushort___0 )1;
    mbuf->socktype = (uint___0 )2;
    return (0);
  }
  if (pret == 6) {
    goto _L;
  } else {
    tmp = ntohs(hdr->ancount);
    if ((int )tmp > 0) {
      _L: /* CIL Label */
      if (mbuf->fd != -1) {
        if ((int )mbuf->hascname == 0) {
          *((ushort___0 *)buf) = mbuf->cid;
          mbuf->buf = buf;
          mbuf->buflen = si->buflen;
          if (si->buflen > 512) {
            send_tc_to_client(mbuf);
          } else {
            udp_write_info(mbuf, 0);
            write_log(author->loginfo, author->idx, (uchar const   *)mbuf->td, mbuf->dlen,
                      (int )mbuf->qtype, mbuf->addr);
          }
        } else {
          if (pret == 6) {
            xtype = (ushort___0 )5;
          } else {
            xtype = (ushort___0 )mbuf->qtype;
          }
          ret = find_record_from_mem(mbuf->td, mbuf->dlen, (int )xtype, (author->s)->datasets,
                                     author->tmpbuffer, author->databuffer, & mbuf->lowerdomain.hash[0]);
          if (ret > 0) {
            (author->response) ++;
            if (mbuf->fd != -1) {
              mbuf->buf = mbuf->data + 2;
              write_back_to_client(mbuf, author->databuffer, ret);
            }
            write_log(author->loginfo, author->idx, (uchar const   *)mbuf->td, mbuf->dlen,
                      (int )mbuf->qtype, mbuf->addr);
          }
        }
      }
      return (idx + 1);
    }
  }
  mbuf->stat = (ushort___0 )1;
  mbuf->socktype = (uint___0 )2;
  return (0);
}
}
int cb_read_auth(struct epoll_event *ev , struct sockinfo *si )
{
  int ret ;
  int szhdr ;
  mbuf_type *mbuf ;
  mbuf_type *tmp ;
  int tmp___0 ;

  {
  szhdr = (int )sizeof(dnsheader );
  tmp = mbuf_alloc();
  mbuf = tmp;
  if ((unsigned long )((void *)0) == (unsigned long )mbuf) {
    return (-1);
  }
  memset((void *)mbuf, 0, sizeof(mbuf_type ));
  mbuf->fd = ev->data.fd;
  mbuf->buf = si->buf;
  mbuf->buflen = 2000;
  mbuf->addr = & mbuf->aaddr;
  if (si->socktype == 1) {
    ret = tcp_read_dns_msg(mbuf, (uint___0 )4094, 0);
  } else {
    ret = udp_read_msg(mbuf, 0);
  }
  if (ret < szhdr) {
    mbuf_free(mbuf);
    return (-1);
  }
  tmp___0 = ret;
  mbuf->buflen = tmp___0;
  si->buflen = tmp___0;
  si->mbuf = mbuf;
  return (ret);
}
}
int launch_new_query(struct author *author )
{
  int new_query ;
  int i ;
  int start ;
  int end ;
  int ret ;
  mbuf_type *mbuf ;
  struct timeval tv ;
  uint64_t msnow ;
  int slotoff ;
  int typeoff ;

  {
  new_query = 0;
  msnow = (uint64_t )0;
  start = author->start;
  end = author->end;
  gettimeofday((struct timeval * __restrict  )(& tv), (void * __restrict  )((void *)0));
  msnow = (uint64_t )(tv.tv_sec * 1000L + tv.tv_usec / 1000L);
  i = start;
  while (i < end) {
    slotoff = 0;
    typeoff = 0;
    mbuf = (mbuf_type *)((void *)0);
    ret = htable_find_list_io((author->s)->qlist, i, slotoff, & typeoff, (uchar **)(& mbuf));
    while (ret >= 0) {
      if (ret > 0) {
        if ((int )mbuf->qtimes > 15) {
          release_qoutinfo(author, mbuf, (uint32_t )(i | (typeoff << 12)));
        } else
        if (msnow - mbuf->stime > 5000UL) {
          release_qoutinfo(author, mbuf, (uint32_t )(i | (typeoff << 12)));
        } else {
          if ((int )mbuf->stat == 0) {
            if (i < 4095) {
              if (! (typeoff < 9)) {
                __assert_fail("i < QLIST_TABLE_SIZE && typeoff < SUPPORT_TYPE_NUM",
                              "author.c", 684U, "launch_new_query");
              }
            } else {
              __assert_fail("i < QLIST_TABLE_SIZE && typeoff < SUPPORT_TYPE_NUM",
                            "author.c", 684U, "launch_new_query");
            }
            mbuf->aid = (ushort___0 )(i | (typeoff << 12));
            mbuf->backid = mbuf->aid;
            mbuf->mxtry = 0;
            if (mbuf->fd != -1) {
              mbuf->fd = author->cudp;
            }
            mbuf->tdbuffer = author->tdbuffer;
            mbuf->tempbuffer = author->tempbuffer;
            mbuf->dmbuffer = author->dmbuffer;
            mbuf->ipbuffer = author->ipbuffer;
            new_query ++;
            mbuf->stat = (ushort___0 )1;
          }
          if (msnow - mbuf->stime > 1000UL) {
            if ((int )mbuf->sq == 0) {
              mbuf->sq = (ushort___0 )1;
            }
          }
          if (mbuf->socktype == 2U) {
            if ((int )mbuf->sq == 1) {
              ret = find_addr((author->s)->forward, (author->s)->datasets, mbuf, author->ip,
                              (author->s)->is_forward);
              if ((int )mbuf->stat == 1) {
                if (ret == 0) {
                  query_from_auth_server(mbuf, author);
                }
              }
              mbuf->qtimes = (ushort___0 )((int )mbuf->qtimes + 1);
            }
          }
        }
      }
      if (ret == 0) {
        slotoff ++;
        typeoff = 0;
      } else
      if (typeoff == 8) {
        slotoff ++;
        typeoff = 0;
      } else {
        typeoff ++;
      }
      mbuf = (mbuf_type *)((void *)0);
      ret = htable_find_list_io((author->s)->qlist, i, slotoff, & typeoff, (uchar **)(& mbuf));
    }
    i ++;
  }
  return (new_query);
}
}
int after_pass_data(int ret , struct author *author , mbuf_type *mbuf )
{
  struct epoll_event ev ;
  int fd ;

  {
  ev.events = (uint32_t )0;
  ev.data.ptr = (void *)0;
  if (ret == 0) {
    return (0);
  }
  if ((unsigned long )mbuf == (unsigned long )((void *)0)) {
    return (-1);
  }
  if (ret < 0) {
    ret ++;
    ret = - ret;
    if (mbuf->tcpfd > 0) {
      if ((int )mbuf->qtimes % 5 == 0) {
        ev.data.fd = mbuf->tcpfd;
        mbuf->tcpfd = 0;
        (author->tcpinuse) --;
        epoll_ctl(author->bdepfd, 2, ev.data.fd, & ev);
        close(ev.data.fd);
      }
    }
    if (mbuf->tcpfd > 0) {
      return (0);
    }
    if (author->tcpinuse > 1000) {
      fd = -1;
    } else {
      (mbuf->tcpnums) ++;
      fd = socket(2, 1, 0);
    }
    if (fd > 0) {
      (author->tcpinuse) ++;
      mbuf->tcpfd = fd;
      mbuf->socktype = (uint___0 )1;
      ev.data.fd = fd;
      ev.events = (uint32_t )4;
      author->eptcpfds[fd].ret = ret;
      memcpy((void * __restrict  )(author->eptcpfds[fd].domain), (void const   * __restrict  )mbuf->td,
             (size_t )mbuf->dlen);
      set_non_block(fd);
      set_recv_timeout(fd, 0, 500);
      epoll_ctl(author->bdepfd, 1, fd, & ev);
      query_from_auth_tcp(author, mbuf);
      return (0);
    } else {
      ret ++;
    }
  }
  if (ret > 0) {
    ret --;
    release_qoutinfo(author, mbuf, (uint32_t )ret);
  }
  return (0);
}
}
int handle_back_event(struct author *author )
{
  int infinite ;
  int ret ;
  int i ;
  int epfd ;
  struct sockinfo si ;
  int bf ;
  int rx ;
  struct epoll_event ev ;
  struct epoll_event *e ;
  uchar *buf ;
  int tmp ;

  {
  infinite = 1;
  epfd = author->bdepfd;
  si.addr.sin_family = (sa_family_t )0;
  si.addr.sin_port = (unsigned short)0;
  si.addr.sin_addr.s_addr = 0U;
  si.addr.sin_zero[0] = (unsigned char)0;
  si.addr.sin_zero[1] = (unsigned char)0;
  si.addr.sin_zero[2] = (unsigned char)0;
  si.addr.sin_zero[3] = (unsigned char)0;
  si.addr.sin_zero[4] = (unsigned char)0;
  si.addr.sin_zero[5] = (unsigned char)0;
  si.addr.sin_zero[6] = (unsigned char)0;
  si.addr.sin_zero[7] = (unsigned char)0;
  si.fd = 0;
  si.buflen = 0;
  si.socktype = 0;
  si.buf = (uchar *)0;
  si.lowerdomain = (packet_type *)0;
  si.mbuf = (mbuf_type *)0;
  bf = 0;
  ev.events = (uint32_t )0;
  ev.data.ptr = (void *)0;
  e = author->e;
  buf = author->tmpbuffer;
  while (infinite) {
    bf = author->audp;
    ret = epoll_wait(epfd, e, 1000, 500);
    if (ret <= 0) {
      break;
    }
    i = 0;
    while (i < ret) {
      memset((void *)(& si), 0, sizeof(struct sockinfo ));
      si.buf = buf;
      if ((e + i)->data.fd == bf) {
        si.socktype = 2;
        while (1) {
          tmp = cb_read_auth(e + i, & si);
          if (! (tmp > 0)) {
            break;
          }
          rx = passer_auth_data(author, buf, & si);
          after_pass_data(rx, author, si.mbuf);
        }
      } else
      if ((e + i)->data.fd > 0) {
        if ((e + i)->events == 4U) {
          rx = send_msg_tcp(author, (e + i)->data.fd);
          if (rx < 0) {
            printf((char const   * __restrict  )"send msg tcp error\n");
          }
          ev.data.fd = (e + i)->data.fd;
          ev.events = (uint32_t )1;
          epoll_ctl(epfd, 3, (e + i)->data.fd, & ev);
        } else
        if ((e + i)->events == 1U) {
          si.socktype = 1;
          rx = cb_read_auth(e + i, & si);
          if (rx < 0) {
            author->eptcpfds[(e + i)->data.fd].ret = 0;
            close((e + i)->data.fd);
            ev.data.fd = (e + i)->data.fd;
            epoll_ctl(epfd, 2, ev.data.fd, & ev);
          } else {
            rx = passer_auth_data(author, buf, & si);
            after_pass_data(rx, author, si.mbuf);
          }
        } else {
          ev.data.fd = (e + i)->data.fd;
          rx = epoll_ctl(epfd, 2, (e + i)->data.fd, & ev);
          author->eptcpfds[(e + i)->data.fd].ret = 0;
          close((e + i)->data.fd);
        }
      }
      i ++;
    }
  }
  return (0);
}
}
int dup_data_into_db(struct author *a )
{
  uint___0 i ;
  uint___0 limit ;
  struct rbtree *rbt ;
  uint___0 dboff ;
  uint___0 dbidx ;

  {
  rbt = (a->s)->ttlexp;
  if (a->dupbefore == 1) {
    a->limits += 5;
    if (a->limits > 1000) {
      a->limits = 1000;
    }
  }
  limit = (uint___0 )a->limits;
  (a->hsidx) ++;
  if (a->hsidx == 10) {
    a->hsidx = 0;
  }
  i = (uint___0 )0;
  while (i < 65536U) {
    dbidx = i;
    dboff = (uint___0 )a->hsidx;
    htable_find_io((a->s)->datasets + dboff, (int )dbidx, limit, rbt, 3);
    i ++;
  }
  a->dupbefore = 1;
  return (0);
}
}
int check_mm_cache(struct author *author ) ;
static int tmx  =    0;
int check_mm_cache(struct author *author )
{
  uint___0 total ;
  int i ;

  {
  total = (uint___0 )0;
  i = 0;
  while (i < 10) {
    pthread_spin_lock(& ((author->s)->datasets + i)->lock);
    total += ((author->s)->datasets + i)->now;
    pthread_spin_unlock(& ((author->s)->datasets + i)->lock);
    i ++;
  }
  tmx ++;
  if (total > (uint___0 )MAX_ELE_NUM) {
    return (1);
  }
  return (0);
}
}
int check_ttl_expire(struct author *author )
{
  time_t now ;
  struct ttlnode *tn ;
  struct rbnode *pn ;
  mbuf_type *mbuf ;
  int ret ;
  struct rbtree *rbt ;
  void *tmp ;
  int i ;

  {
  tn = (struct ttlnode *)((void *)0);
  pn = (struct rbnode *)((void *)0);
  ret = -1;
  rbt = (struct rbtree *)((void *)0);
  mbuf = mbuf_alloc();
  if ((unsigned long )((void *)0) == (unsigned long )mbuf) {
    return (-1);
  }
  now = global_now;
  rbt = (author->s)->ttlexp;
  pthread_spin_lock(& rbt->lock);
  pn = min_node(rbt);
  while ((unsigned long )pn != (unsigned long )((void *)0)) {
    tn = (struct ttlnode *)pn->key;
    if ((time_t )tn->exp > now + 3L) {
      break;
    }
    tmp = delete_node(rbt, pn);
    tn = (struct ttlnode *)tmp;
    pthread_spin_unlock(& rbt->lock);
    if ((unsigned long )tn != (unsigned long )((void *)0)) {
      memset((void *)mbuf, 0, sizeof(mbuf_type ));
      mbuf->qname = tn->type;
      mbuf->qtype = (enum rrtype )tn->type;
      mbuf->dlen = (int )tn->dlen;
      memcpy((void * __restrict  )(& mbuf->lowerdomain), (void const   * __restrict  )tn->lowerdomain,
             sizeof(packet_type ));
      i = 0;
      while (i < (int )(tn->lowerdomain)->label_count) {
        mbuf->lowerdomain.label[i] = mbuf->lowerdomain.domain + (int )mbuf->lowerdomain.label_offsets[i];
        i ++;
      }
      mbuf->qhash = & mbuf->lowerdomain.hash[0];
      mbuf->td = mbuf->lowerdomain.domain;
      mbuf->qing = mbuf->td;
      mbuf->qlen = (ushort___0 )mbuf->dlen;
      mbuf->cid = (ushort___0 )0;
      mbuf->fd = -1;
      init_qoutinfo(mbuf);
      ret = htable_insert_list((author->s)->qlist, tn->data, (int )tn->dlen, (int )tn->type,
                               (uchar *)mbuf, 0, (struct mvalue *)((void *)0), tn->hash);
      if (0 == ret) {
        mbuf = mbuf_alloc();
        if ((unsigned long )((void *)0) == (unsigned long )mbuf) {
          free((void *)tn->lowerdomain);
          free((void *)tn);
          return (-1);
        }
      }
      free((void *)tn->lowerdomain);
      free((void *)tn);
    }
    pthread_spin_lock(& rbt->lock);
    pn = min_node(rbt);
  }
  mbuf_free(mbuf);
  pthread_spin_unlock(& rbt->lock);
  return (0);
}
}
int check_refresh_flag(struct author *author )
{
  struct server *s ;

  {
  s = author->s;
  if (s->lastrefresh + 10L > global_now) {
    return (0);
  }
  if ((int )s->refreshflag == 1) {
    s->refreshflag = (uint16_t )0;
    s->lastrefresh = global_now;
    refresh_records(s->datasets, s->ttlexp);
  }
  return (0);
}
}
void *run_quizzer(void *arg )
{
  struct author *author ;
  int epfd ;
  pthread_t tmp ;
  int tmp___0 ;

  {
  author = (struct author *)arg;
  tmp = pthread_self();
  pthread_detach(tmp);
  epfd = add_backdoor(author->audp);
  author->bdepfd = epfd;
  while (1) {
    launch_new_query(author);
    handle_back_event(author);
    if (author->idx == 0) {
      check_ttl_expire(author);
      tmp___0 = check_mm_cache(author);
      if (tmp___0 == 1) {
        dup_data_into_db(author);
      } else {
        author->dupbefore = 0;
      }
      check_refresh_flag(author);
    }
  }
}
}
int add_to_quizzer(struct qoutinfo *qo , struct server *s , int qidx )
{
  int i ;
  int j ;
  int randomoff ;
  struct qoutinfo *qi ;
  long tmp ;

  {
  randomoff = 0;
  qi = qo;
  qi->stat = (ushort___0 )0;
  tmp = random();
  randomoff = (int )(tmp % 10000L);
  j = qidx;
  while (j < 2) {
    i = randomoff;
    while (i < 10000) {
      if ((unsigned long )(s->authors + j)->list[i] == (unsigned long )((void *)0)) {
        pthread_spin_lock(& (s->authors + j)->lock);
        if ((unsigned long )(s->authors + j)->list[i] != (unsigned long )((void *)0)) {
          pthread_spin_unlock(& (s->authors + j)->lock);
          goto __Cont;
        }
        (s->authors + j)->list[i] = qi;
        ((s->authors + j)->qnum) ++;
        pthread_spin_unlock(& (s->authors + j)->lock);
        return (0);
      }
      __Cont: /* CIL Label */
      i ++;
    }
    i = 0;
    while (i < randomoff) {
      if ((unsigned long )(s->authors + j)->list[i] == (unsigned long )((void *)0)) {
        pthread_spin_lock(& (s->authors + j)->lock);
        if ((unsigned long )(s->authors + j)->list[i] != (unsigned long )((void *)0)) {
          pthread_spin_unlock(& (s->authors + j)->lock);
          goto __Cont___0;
        }
        (s->authors + j)->list[i] = qi;
        ((s->authors + j)->qnum) ++;
        pthread_spin_unlock(& (s->authors + j)->lock);
        return (0);
      }
      __Cont___0: /* CIL Label */
      i ++;
    }
    j ++;
  }
  j = 0;
  while (j < qidx) {
    i = randomoff;
    while (i < 10000) {
      if ((unsigned long )(s->authors + j)->list[i] == (unsigned long )((void *)0)) {
        pthread_spin_lock(& (s->authors + j)->lock);
        if ((unsigned long )(s->authors + j)->list[i] != (unsigned long )((void *)0)) {
          pthread_spin_unlock(& (s->authors + j)->lock);
          goto __Cont___1;
        }
        (s->authors + j)->list[i] = qi;
        ((s->authors + j)->qnum) ++;
        pthread_spin_unlock(& (s->authors + j)->lock);
        return (0);
      }
      __Cont___1: /* CIL Label */
      i ++;
    }
    i = 0;
    while (i < randomoff) {
      if ((unsigned long )(s->authors + j)->list[i] == (unsigned long )((void *)0)) {
        pthread_spin_lock(& (s->authors + j)->lock);
        if ((unsigned long )(s->authors + j)->list[i] != (unsigned long )((void *)0)) {
          pthread_spin_unlock(& (s->authors + j)->lock);
          goto __Cont___2;
        }
        (s->authors + j)->list[i] = qi;
        ((s->authors + j)->qnum) ++;
        pthread_spin_unlock(& (s->authors + j)->lock);
        return (0);
      }
      __Cont___2: /* CIL Label */
      i ++;
    }
    j ++;
  }
  return (-1);
}
}
int lock_and_add_to_quizz(mbuf_type *mbuf , struct fetcher *f )
{
  int ret ;

  {
  if (mbuf->dlen < 1) {
    return (-1);
  }
  mbuf->qname = (ushort___0 )mbuf->qtype;
  mbuf->td = mbuf->lowerdomain.domain;
  mbuf->qing = mbuf->td;
  mbuf->qhash = & mbuf->lowerdomain.hash[0];
  mbuf->qlen = (ushort___0 )mbuf->dlen;
  mbuf->cid = mbuf->id;
  init_qoutinfo(mbuf);
  ret = htable_insert_list((f->s)->qlist, mbuf->lowerdomain.domain, mbuf->dlen, (int )mbuf->qtype,
                           (uchar *)mbuf, 0, (struct mvalue *)((void *)0), & mbuf->lowerdomain.hash[0]);
  if (ret != 0) {
    return (-1);
  }
  return (0);
}
}
int find_record_from_mem(uchar *otd , int dlen , int type , struct htable *datasets ,
                         uchar *tdbuffer , uchar *databuffer , hashval_t *hash )
{
  uchar *td ;
  int ret ;
  int dataidx ;
  int clen ;
  int debug ;
  hashval_t thash ;
  hashval_t *h ;
  int tmp ;

  {
  td = otd;
  dataidx = 0;
  debug = 100;
  h = hash;
  dataidx ++;
  if (type != 5) {
    while (1) {
      ret = find_record_with_ttl(datasets, td, dlen, 5, databuffer + dataidx, 65528 - dataidx,
                                 (struct mvalue *)((void *)0), h);
      if (! (ret > 0)) {
        break;
      }
      *(databuffer + (dataidx - 1)) = (uchar )5;
      clen = (int )((unsigned long )ret - sizeof(struct mvalue ));
      td = tdbuffer;
      memcpy((void * __restrict  )td, (void const   * __restrict  )((databuffer + dataidx) + sizeof(struct mvalue )),
             (size_t )clen);
      dataidx += ret;
      dataidx ++;
      tmp = debug;
      debug --;
      if (tmp == 0) {
        return (-1);
      }
      thash = (hashval_t )0;
      h = & thash;
      dlen = clen;
    }
    thash = (hashval_t )0;
  }
  ret = find_record_with_ttl(datasets, td, dlen, type, databuffer + dataidx, 65528 - dataidx,
                             (struct mvalue *)((void *)0), h);
  if (ret > 0) {
    *(databuffer + (dataidx - 1)) = (uchar )type;
    dataidx += ret;
    return (dataidx);
  }
  return (-1);
}
}
int global_cron(struct server *s )
{
  int fd ;
  struct list_node *nds ;
  struct list_node *tmp ;
  struct list *el ;

  {
  fd = -1;
  el = & s->eventlist;
  pthread_spin_lock(& el->lock);
  nds = el->head;
  el->head = (struct list_node *)((void *)0);
  pthread_spin_unlock(& el->lock);
  while ((unsigned long )nds != (unsigned long )((void *)0)) {
    fd = *((int *)nds->data);
    if (fd > 0) {
      close(fd);
    }
    tmp = nds->next;
    free(nds->data);
    free((void *)nds);
    nds = tmp;
  }
  return (0);
}
}
int run_fetcher(struct fetcher *f )
{
  struct msgcache *mc ;
  int ret ;
  mbuf_type *mbuf ;
  int fd ;
  int tmp ;

  {
  mc = f->mc;
  ret = 0;
  while (1) {
    fd = -1;
    pthread_spin_lock(& mc->lock);
    if (mc->pkt == 0U) {
      pthread_spin_unlock(& mc->lock);
      usleep((__useconds_t )1000);
      continue;
    }
    memcpy((void * __restrict  )(& mbuf), (void const   * __restrict  )(mc->data + mc->head),
           sizeof(void *));
    mc->head += sizeof(void *);
    if (mc->head + 8UL > (uint64_t )mc->size) {
      mc->head = (uint64_t )0;
    }
    (mc->pkt) --;
    pthread_spin_unlock(& mc->lock);
    if (mbuf->socktype == 2U) {
      mbuf->fd = (f->s)->ludp;
    }
    passer_dns_data(mbuf);
    if (mbuf->err == 1) {
      mbuf_free(mbuf);
      continue;
    }
    f->dataidx = 0;
    mbuf->td = mbuf->lowerdomain.domain;
    ret = find_record_from_mem(mbuf->td, mbuf->dlen, (int )mbuf->qtype, (f->s)->datasets,
                               f->tdbuffer, f->databuffer, & mbuf->lowerdomain.hash[0]);
    if (ret > 0) {
      write_back_to_client(mbuf, f->databuffer, ret);
      write_log(f->loginfo, f->idx, (uchar const   *)mbuf->td, mbuf->dlen - 1, (int )mbuf->qtype,
                mbuf->addr);
      mbuf_free(mbuf);
    } else {
      if (mbuf->socktype == 1U) {
        fd = mbuf->fd;
        mbuf->fd = -1;
      }
      tmp = lock_and_add_to_quizz(mbuf, f);
      if (tmp < 0) {
        (f->miss) ++;
        mbuf_free(mbuf);
      }
    }
    if (fd != -1) {
      delete_close_event(fd, f);
    }
  }
  return (0);
}
}
#pragma merger("0","/tmp/cil-uFyqP0HO.i","-g,-Wall")
extern char *optarg ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) getopt)(int ___argc ,
                                                                                     char * const  *___argv ,
                                                                                     char const   *__shortopts ) ;
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
extern int ( __attribute__((__nonnull__(1))) sigtimedwait)(sigset_t const   * __restrict  __set ,
                                                           siginfo_t * __restrict  __info ,
                                                           struct timespec  const  * __restrict  __timeout ) ;
int mempool_create(uint32_t num ) ;
extern  __attribute__((__nothrow__)) int shmget(key_t __key , size_t __size , int __shmflg ) ;
extern  __attribute__((__nothrow__)) void *shmat(int __shmid , void const   *__shmaddr ,
                                                 int __shmflg ) ;
int start_local_server(struct server *s ) ;
time_t global_now  =    (time_t )0;
pthread_mutex_t gnlock  ;
int volatile   refresh_record  =    (sig_atomic_t volatile   )0;
static int daemonrize(int dm )
{
  int tmp ;

  {
  if (dm == 1) {
    tmp = daemon(1, 0);
    if (tmp == -1) {
      dns_error(0, (char *)"daemonrize");
    } else {
      printf((char const   * __restrict  )"daemon!!!\n");
    }
  }
  return (0);
}
}
static int create_listen_ports(int port , int proto , uchar *addr )
{
  int fd ;
  int tmp ;

  {
  fd = -1;
  fd = create_socket(port, proto, addr);
  if (fd < 0) {
    printf((char const   * __restrict  )"port:%d,proto:%d\n", port, proto);
    dns_error(0, (char *)"fd < 0");
  } else {
    tmp = set_non_block(fd);
    if (tmp < 0) {
      printf((char const   * __restrict  )"port:%d,proto:%d\n", port, proto);
      dns_error(0, (char *)"fd < 0");
    }
  }
  return (fd);
}
}
int create_author(struct server *s , int n )
{
  int i ;
  int j ;
  struct author *authors ;
  cpu_set_t cpuinfo ;
  pthread_t apt[2] ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  size_t __cpu ;
  int tmp___2 ;

  {
  authors = (struct author *)((void *)0);
  if (n < 1) {
    dns_error(0, (char *)"quizzer bad range");
  } else
  if (n > 50) {
    dns_error(0, (char *)"quizzer bad range");
  }
  tmp = malloc(sizeof(struct author ) * (unsigned long )n);
  authors = (struct author *)tmp;
  if ((unsigned long )authors == (unsigned long )((void *)0)) {
    dns_error(0, (char *)"out of memory in quizzer");
  }
  memset((void *)authors, 0, sizeof(struct author ) * (unsigned long )n);
  s->authors = authors;
  i = 0;
  while (i < n) {
    (authors + i)->idx = i;
    (authors + i)->cudp = s->ludp;
    (authors + i)->audp = create_listen_ports(i * 1000 + 998, 2, (uchar *)((void *)0));
    if ((authors + i)->audp < 0) {
      dns_error(0, (char *)"auth fd error");
    }
    set_sock_buff((authors + i)->audp, 1);
    (authors + i)->el = & s->eventlist;
    (authors + i)->s = s;
    get_random_data((authors + i)->randombuffer, 3000);
    (authors + i)->rndidx = 0;
    (authors + i)->dupbefore = 0;
    (authors + i)->limits = 10;
    (authors + i)->bdepfd = 0;
    (authors + i)->fwd = s->forward;
    (authors + i)->ds = s->datasets;
    (authors + i)->qnum = 0;
    (authors + i)->underattack = 0;
    (authors + i)->timex = 0;
    (authors + i)->response = 0;
    (authors + i)->tcpinuse = 0;
    (authors + i)->rdb = (uint___0 )0;
    (authors + i)->quizz = (uint___0 )0;
    (authors + i)->drop = (uint___0 )0;
    (authors + i)->timeout = (uint___0 )0;
    (authors + i)->qidx = 0;
    (authors + i)->start = 2047 * i;
    if (i == 1) {
      (authors + i)->end = 4095;
    } else {
      (authors + i)->end = 2047 * (i + 1);
    }
    memset((void *)((authors + i)->ip), 0, (size_t )2000);
    tmp___0 = malloc(sizeof(struct log_info ));
    (authors + i)->loginfo = (struct log_info *)tmp___0;
    memset((void *)(authors + i)->loginfo, 0, sizeof(struct log_info ));
    ((authors + i)->loginfo)->log_type = 233;
    ((authors + i)->loginfo)->logfd = create_new_log(s->logpath, i, 233);
    j = 0;
    while (j < 101) {
      pthread_spin_init(& (authors + i)->dblock[j], 0);
      j ++;
    }
    j = 0;
    while (j < 10000) {
      (authors + i)->list[j] = (struct qoutinfo *)((void *)0);
      j ++;
    }
    j = 0;
    while (j < 65530) {
      (authors + i)->eptcpfds[j].ret = -1;
      j ++;
    }
    pthread_spin_init(& (authors + i)->lock, 0);
    ((authors + i)->loginfo)->lastlog = global_now;
    if ((authors + i)->cudp < 0) {
      dns_error(0, (char *)"create quizzer2");
    } else
    if ((authors + i)->audp < 0) {
      dns_error(0, (char *)"create quizzer2");
    }
    tmp___1 = pthread_create((pthread_t * __restrict  )(apt + i), (pthread_attr_t const   * __restrict  )((void *)0),
                             & run_quizzer, (void * __restrict  )((void *)(authors + i)));
    if (tmp___1 != 0) {
      dns_error(0, (char *)"create quizzer");
    }
    i ++;
  }
  global_out_info->thread_num += i;
  i = 0;
  while (i < 2) {
    while (1) {
      __builtin_memset((void *)(& cpuinfo), '\000', (int )sizeof(cpu_set_t ));
      break;
    }
    __cpu = (size_t )((i + 2) + 1);
    if (__cpu / 8UL < sizeof(cpuinfo)) {
      cpuinfo.__bits[__cpu / (8UL * sizeof(__cpu_mask ))] |= 1UL << __cpu % (8UL * sizeof(__cpu_mask ));
    }
    tmp___2 = pthread_setaffinity_np(apt[i], sizeof(cpu_set_t ), (cpu_set_t const   *)(& cpuinfo));
    if (0 != tmp___2) {
      printf((char const   * __restrict  )"set affinity quizzer failed, may be the cpu cores num less than (FETCHER_NUM + QUIZZER_NUM + 1)\n");
    }
    i ++;
  }
  return (0);
}
}
static int create_fetcher(struct server *s , int n )
{
  int i ;
  struct fetcher *ws ;
  struct fetcher *tmp ;
  cpu_set_t cpuinfo ;
  pthread_t fpt[2] ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  size_t __cpu ;
  int tmp___3 ;

  {
  if (n < 1) {
    return (-1);
  }
  tmp___0 = malloc(sizeof(struct fetcher ) * (unsigned long )n);
  ws = (struct fetcher *)tmp___0;
  if ((unsigned long )ws == (unsigned long )((void *)0)) {
    return (-1);
  }
  memset((void *)ws, 0, sizeof(struct fetcher ) * (unsigned long )n);
  s->fetchers = ws;
  i = 0;
  while (i < n) {
    tmp = ws + i;
    tmp->s = s;
    tmp->idx = i;
    tmp->pkg = (uint64_t )0;
    tmp->send = (uint64_t )0;
    tmp->miss = (uint64_t )0;
    tmp->el = & s->eventlist;
    tmp->qidx = i % 2;
    tmp->mc = init_msgcache(100);
    if ((unsigned long )tmp->mc == (unsigned long )((void *)0)) {
      dns_error(0, (char *)"get msgcache");
    }
    tmp___1 = malloc(sizeof(struct log_info ));
    tmp->loginfo = (struct log_info *)tmp___1;
    memset((void *)tmp->loginfo, 0, sizeof(struct log_info ));
    (tmp->loginfo)->lastlog = global_now;
    (tmp->loginfo)->log_type = 112;
    (tmp->loginfo)->logfd = create_new_log(s->logpath, i, 112);
    if ((tmp->loginfo)->logfd < 0) {
      dns_error(0, (char *)"log file error");
    }
    tmp___2 = pthread_create((pthread_t * __restrict  )(fpt + i), (pthread_attr_t const   * __restrict  )((void *)0),
                             (void *(*)(void * ))((void *)(& run_fetcher)), (void * __restrict  )tmp);
    if (tmp___2 != 0) {
      dns_error(0, (char *)"init worker");
    }
    i ++;
  }
  global_out_info->thread_num += i;
  i = 0;
  while (i < 2) {
    while (1) {
      __builtin_memset((void *)(& cpuinfo), '\000', (int )sizeof(cpu_set_t ));
      break;
    }
    __cpu = (size_t )(i + 1);
    if (__cpu / 8UL < sizeof(cpuinfo)) {
      cpuinfo.__bits[__cpu / (8UL * sizeof(__cpu_mask ))] |= 1UL << __cpu % (8UL * sizeof(__cpu_mask ));
    }
    tmp___3 = pthread_setaffinity_np(fpt[i], sizeof(cpu_set_t ), (cpu_set_t const   *)(& cpuinfo));
    if (0 != tmp___3) {
      printf((char const   * __restrict  )"set affinity fetcher failed,  may be the cpu cores num less than (FETCHER_NUM + QUIZZER_NUM + 1)\n");
    }
    i ++;
  }
  return (0);
}
}
static struct server *server_init(void)
{
  struct server *s ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = malloc(sizeof(struct server ));
  s = (struct server *)tmp;
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    dns_error(0, (char *)"out of memory in server_init");
  }
  s->nfetcher = (ushort___0 )2;
  s->nquizzer = (ushort___0 )2;
  s->authors = (struct author *)((void *)0);
  s->fetchers = (struct fetcher *)((void *)0);
  s->pkg = (ulong___0 )0;
  pthread_spin_init(& s->eventlist.lock, 0);
  s->eventlist.head = (struct list_node *)((void *)0);
  tmp___0 = create_listen_ports(53, 2, (uchar *)"0.0.0.0");
  s->ludp = tmp___0;
  if (tmp___0 < 0) {
    dns_error(0, (char *)"can not open udp");
  }
  set_sock_buff(s->ludp, 10);
  tmp___1 = create_listen_ports(53, 1, (uchar *)"0.0.0.0");
  s->ltcp = tmp___1;
  if (tmp___1 < 0) {
    dns_error(0, (char *)"can not open tcp");
  }
  s->datasets = htable_create((hashfunc *)((void *)0), & dict_comp_str_equ, 65536,
                              10);
  if ((unsigned long )s->datasets == (unsigned long )((void *)0)) {
    dns_error(0, (char *)"htable create");
  }
  s->forward = htable_create((hashfunc *)((void *)0), & dict_comp_str_equ, 1024, 1);
  if ((unsigned long )s->forward == (unsigned long )((void *)0)) {
    dns_error(0, (char *)"create forward");
  }
  s->qlist = htable_create((hashfunc *)((void *)0), & dict_comp_str_equ, 4095, 1);
  if ((unsigned long )s->qlist == (unsigned long )((void *)0)) {
    dns_error(0, (char *)"create qlist");
  }
  s->ttlexp = create_rbtree(& rbt_comp_ttl_gt, (void *)0);
  if ((unsigned long )s->ttlexp == (unsigned long )((void *)0)) {
    dns_error(0, (char *)"create ttl tree");
  }
  s->recordsindb = (ulong___0 )0;
  s->refreshflag = (uint16_t )0;
  s->lastrefresh = global_now;
  s->is_forward = 0;
  return (s);
}
}
void *time_cron(void *arg )
{
  struct server *s ;
  struct timespec tv ;
  sigset_t waitset ;
  siginfo_t info ;
  int ret ;

  {
  s = (struct server *)arg;
  tv.tv_sec = (__time_t )0;
  tv.tv_nsec = 0L;
  sigemptyset(& waitset);
  sigaddset(& waitset, 10);
  global_now = time((time_t *)((void *)0));
  while (1) {
    tv.tv_sec = (__time_t )1;
    tv.tv_nsec = (__syscall_slong_t )0;
    ret = sigtimedwait((sigset_t const   * __restrict  )(& waitset), (siginfo_t * __restrict  )(& info),
                       (struct timespec  const  * __restrict  )(& tv));
    if (ret > 0) {
      s->refreshflag = (uint16_t )1;
    }
    global_now = time((time_t *)((void *)0));
  }
  return ((void *)0);
}
}
void *recv_update(void *arg )
{
  struct server *s ;

  {
  s = (struct server *)arg;
  start_local_server(s);
  return ((void *)0);
}
}
int sanity_test(int exi )
{


  {
  if (exi) {
    exit(0);
  }
  return (0);
}
}
int print_basic_debug(void)
{


  {
  printf((char const   * __restrict  )"[DBG:] dnspod-sr is successfully running now!!\n");
  printf((char const   * __restrict  )"[DBG:] max_ele_size is %u - 1808\n", MAX_ELE_NUM);
  printf((char const   * __restrict  )"[DBG:] server may contain %u useful records\n",
         (MAX_ELE_NUM - 1808U) / 3U);
  printf((char const   * __restrict  )"[DBG:] hash_table_size is %u\n", 65536);
  printf((char const   * __restrict  )"[DBG:] we have %u hash tables\n", 10);
  printf((char const   * __restrict  )"[DBG:] we have %u fetchers,%u quizzers\n",
         2, 2);
  return (0);
}
}
void help(char const   *progname )
{


  {
  printf((char const   * __restrict  )"DNSPod recursive dns server\n");
  printf((char const   * __restrict  )"version 0.01\n");
  printf((char const   * __restrict  )"Usage: %s [-c config]\n", progname);
  return;
}
}
int init_globe(void)
{
  int shmid ;
  void *tmp ;
  int i ;

  {
  shmid = shmget(38899, sizeof(struct global_query_info ), 896);
  if (shmid < 0) {
    printf((char const   * __restrict  )"%lu\n", 38899UL + sizeof(struct global_query_info ));
    perror("shmget");
    dns_error(0, (char *)"shmget error");
  }
  tmp = shmat(shmid, (void const   *)((void *)0), 0);
  global_out_info = (struct global_query_info *)tmp;
  memset((void *)global_out_info, 0, sizeof(struct global_query_info ));
  global_out_info->thread_num = 0;
  i = 0;
  while ((unsigned long )i < sizeof(query_type_map) / sizeof(int )) {
    query_type_map[i] = -1;
    i ++;
  }
  query_type_map[1] = 0;
  query_type_map[2] = 1;
  query_type_map[5] = 2;
  query_type_map[6] = 3;
  query_type_map[15] = 4;
  query_type_map[16] = 5;
  query_type_map[28] = 6;
  query_type_map[33] = 7;
  query_type_map[255] = 8;
  return (0);
}
}
void init_mempool(void)
{
  int ret ;

  {
  ret = mempool_create((uint32_t )65536);
  if (ret < 0) {
    dns_error(0, (char *)"create mempool failed");
  }
  return;
}
}
int main(int argc , char **argv )
{
  struct server *s ;
  pthread_t pt ;
  pthread_t ctl ;
  int c ;
  int is_forward ;
  char const   *config ;
  int daemon___0 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  s = (struct server *)((void *)0);
  is_forward = 0;
  config = "../sr.conf";
  daemon___0 = 0;
  while (1) {
    c = getopt(argc, (char * const  *)argv, "c:vhfd");
    if (! (c != -1)) {
      break;
    }
    switch (c) {
    case 99:
    config = (char const   *)optarg;
    break;
    case 104:
    help((char const   *)*(argv + 0));
    exit(0);
    break;
    case 102:
    is_forward = 1;
    break;
    case 100:
    daemon___0 = 1;
    break;
    case 63:
    printf((char const   * __restrict  )"Try -h please\n");
    exit(0);
    break;
    case 118:
    printf((char const   * __restrict  )"dnspod-sr 0.01\n");
    exit(0);
    break;
    default:
    exit(0);
    break;
    }
  }
  sanity_test(0);
  drop_privilege((char *)"./");
  daemonrize(daemon___0);
  trig_signals(1);
  global_now = time((time_t *)((void *)0));
  g_nameservers[1] = (char *)((void *)0);
  g_nameservers[0] = g_nameservers[1];
  init_globe();
  init_mempool();
  s = server_init();
  s->is_forward = is_forward;
  read_config(config, (char *)(s->logpath), s->forward, g_nameservers);
  if ((unsigned long )g_nameservers[0] == (unsigned long )((void *)0)) {
    if (! ((unsigned long )g_nameservers[1] == (unsigned long )((void *)0))) {
      __assert_fail("g_nameservers[1] == NULL", "init.c", 412U, "main");
    }
    g_nameservers[0] = strdup("119.29.29.29");
    g_nameservers[1] = strdup("8.8.4.4");
  }
  if ((unsigned long )g_nameservers[1] == (unsigned long )((void *)0)) {
    tmp___0 = strcmp((char const   *)g_nameservers[0], "119.29.29.29");
    if (tmp___0 == 0) {
      g_nameservers[1] = strdup("8.8.4.4");
    } else {
      g_nameservers[1] = strdup("119.29.29.29");
    }
  }
  tmp___1 = create_fetcher(s, (int )s->nfetcher);
  if (tmp___1 < 0) {
    dns_error(0, (char *)"create worker");
  }
  tmp___2 = create_author(s, (int )s->nquizzer);
  if (tmp___2 < 0) {
    dns_error(0, (char *)"create author");
  }
  tmp___3 = pthread_create((pthread_t * __restrict  )(& pt), (pthread_attr_t const   * __restrict  )((void *)0),
                           (void *(*)(void * ))((void *)(& time_cron)), (void * __restrict  )s);
  if (tmp___3 != 0) {
    dns_error(0, (char *)"time cron error");
  }
  tmp___4 = pthread_create((pthread_t * __restrict  )(& ctl), (pthread_attr_t const   * __restrict  )((void *)0),
                           (void *(*)(void * ))((void *)(& recv_update)), (void * __restrict  )s);
  if (tmp___4 != 0) {
    dns_error(0, (char *)"recv update thread error");
  }
  read_root(s->datasets, s->ttlexp);
  print_basic_debug();
  global_serv = s;
  run_sentinel(s);
  return (0);
}
}
#pragma merger("0","/tmp/cil-YswTHoTf.i","-g,-Wall")
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __file ,
                                                                                   struct stat * __restrict  __buf ) ;
int cache_flush(uchar *domain , uint16_t type , struct htable *ht , struct rbtree *ttlexp ) ;
int hijack(uchar *domain , uint16_t type , struct htable *ht , struct rbtree *ttlexp ) ;
char const   *local_socket_name  =    "/tmp/foo.socket";
int create_local_server(char const   *path )
{
  int sock ;
  int size ;
  int ret ;
  struct sockaddr_un addr ;
  size_t tmp ;

  {
  sock = socket(1, 1, 0);
  if (sock < 0) {
    perror("socket error");
    return (-1);
  }
  memset((void *)(& addr), 0, sizeof(struct sockaddr_un ));
  addr.sun_family = (sa_family_t )1;
  strcpy((char * __restrict  )(addr.sun_path), (char const   * __restrict  )path);
  tmp = strlen(path);
  size = (int )((unsigned long )(& ((struct sockaddr_un *)0)->sun_path) + tmp);
  unlink((char const   *)(addr.sun_path));
  ret = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& addr)), (socklen_t )size);
  if (ret < 0) {
    perror("bind error");
    close(sock);
    return (-2);
  }
  ret = listen(sock, 10);
  if (ret < 0) {
    perror("listen error");
    close(sock);
    return (-3);
  }
  return (sock);
}
}
int ctl_fd(int epfd , int fd , int ctl , uint32_t events )
{
  int ret ;
  struct epoll_event ev ;

  {
  memset((void *)(& ev), 0, sizeof(struct epoll_event ));
  ev.data.fd = fd;
  if (ctl == 1) {
    ev.events = events;
  }
  ret = epoll_ctl(epfd, ctl, fd, & ev);
  if (ret < 0) {
    perror("epoll_ctl");
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ctl fd %d error\n",
            fd);
    return (-1);
  }
  return (0);
}
}
int accept_client(int epfd , int sock )
{
  int clifd ;
  socklen_t len ;
  struct sockaddr_un cli_addr ;
  struct stat statbuf ;
  struct timeval tv ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = (char *)((void *)0);
  len = (socklen_t )sizeof(cli_addr);
  clifd = accept(sock, (struct sockaddr * __restrict  )((struct sockaddr *)(& cli_addr)),
                 (socklen_t * __restrict  )(& len));
  if (clifd < 0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"accept error\n");
    close(clifd);
    return (-1);
  }
  len = (socklen_t )((unsigned long )len - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path));
  if (len > 0U) {
    cli_addr.sun_path[len] = (char )'\000';
    tmp___0 = stat((char const   * __restrict  )(cli_addr.sun_path), (struct stat * __restrict  )(& statbuf));
    if (tmp___0 < 0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"no this socket\n");
      close(clifd);
      return (-2);
    }
    if (((statbuf.st_mode & 61440U) == 49152U) == 0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"not a socket\n");
      close(clifd);
      return (-3);
    }
    unlink((char const   *)(cli_addr.sun_path));
    tmp = strrchr((char const   *)(cli_addr.sun_path), '/');
    if (tmp) {
      printf((char const   * __restrict  )"client pid: %s connected: %d\n", tmp + 1,
             clifd);
    }
  } else {
    printf((char const   * __restrict  )"new client (unknown pid) connected: %d\n",
           clifd);
  }
  tmp___1 = ctl_fd(epfd, clifd, 1, (uint32_t )1);
  if (tmp___1) {
    close(clifd);
    return (-1);
  }
  tv.tv_sec = (__time_t )3;
  tv.tv_usec = (__suseconds_t )0;
  setsockopt(clifd, 1, 20, (void const   *)(& tv), (socklen_t )sizeof(tv));
  return (clifd);
}
}
void disconnect_client(int epfd , int client )
{


  {
  ctl_fd(epfd, client, 2, (uint32_t )0);
  close(client);
  printf((char const   * __restrict  )"disconnect with client %d\n", client);
  return;
}
}
uint16_t get_type_from_str(char const   *str_type )
{
  uint16_t type ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  type = (uint16_t )0;
  if (! str_type) {
    type = (uint16_t )1;
  } else
  if ((int const   )*(str_type + 0) == 0) {
    type = (uint16_t )1;
  } else {
    tmp___7 = strcmp(str_type, "A");
    if (tmp___7 == 0) {
      type = (uint16_t )1;
    } else {
      tmp___6 = strcmp(str_type, "CNAME");
      if (tmp___6 == 0) {
        type = (uint16_t )5;
      } else {
        tmp___5 = strcmp(str_type, "AAAA");
        if (tmp___5 == 0) {
          type = (uint16_t )28;
        } else {
          tmp___4 = strcmp(str_type, "MX");
          if (tmp___4 == 0) {
            type = (uint16_t )15;
          } else {
            tmp___3 = strcmp(str_type, "TXT");
            if (tmp___3 == 0) {
              type = (uint16_t )16;
            } else {
              tmp___2 = strcmp(str_type, "SRV");
              if (tmp___2 == 0) {
                type = (uint16_t )33;
              } else {
                tmp___1 = strcmp(str_type, "NS");
                if (tmp___1 == 0) {
                  type = (uint16_t )2;
                } else {
                  tmp___0 = strcmp(str_type, "SOA");
                  if (tmp___0 == 0) {
                    type = (uint16_t )6;
                  } else {
                    tmp = strcmp(str_type, "PTR");
                    if (tmp == 0) {
                      type = (uint16_t )12;
                    } else {
                      dns_error(1, (char *)"invalid cache flush type");
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return (type);
}
}
int cmd_analyze(char *str , uchar *domain , uint16_t *type )
{
  uchar *p ;
  char *tmp ;
  uchar *temp ;
  uchar str_type[32] ;
  unsigned int tmp___0 ;
  size_t len ;
  int cmd_type ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp = strchr((char const   *)str, ':');
  p = (uchar *)tmp;
  temp = (uchar *)((void *)0);
  str_type[0] = (uchar )0;
  tmp___0 = 1U;
  while (! (tmp___0 >= 32U)) {
    str_type[tmp___0] = (unsigned char)0;
    tmp___0 ++;
  }
  cmd_type = -1;
  if (! p) {
    tmp___1 = strcmp((char const   *)str, "hijack");
    if (tmp___1 == 0) {
      cmd_type = 2;
    }
  } else {
    tmp___3 = strncmp((char const   *)str, "cache flush", (size_t )11);
    if (tmp___3 == 0) {
      cmd_type = 1;
    } else {
      tmp___2 = strncmp((char const   *)str, "hijack", (size_t )6);
      if (tmp___2 == 0) {
        cmd_type = 2;
      }
    }
    p ++;
    temp = jump_space(p);
    fix_tail((char *)temp);
    sscanf((char const   * __restrict  )((char const   *)temp), (char const   * __restrict  )"%s %s",
           domain, str_type);
    *type = get_type_from_str((char const   *)(str_type));
    len = strlen((char const   *)domain);
    if ((int )*(domain + (len - 1UL)) != 46) {
      *(domain + len) = (uchar )'.';
      *(domain + (len + 1UL)) = (uchar )'\000';
    }
  }
  return (cmd_type);
}
}
int talk_with_client(int epfd , int client , struct server *s )
{
  char buffer[8192] ;
  unsigned int tmp ;
  int ret ;
  ssize_t tmp___0 ;
  uchar domain[512] ;
  unsigned int tmp___1 ;
  uint16_t type ;
  int ret___0 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
  buffer[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 8192U)) {
    buffer[tmp] = (char)0;
    tmp ++;
  }
  tmp___0 = recv(client, (void *)(buffer), (size_t )8191, 0);
  ret = (int )tmp___0;
  if (ret == 0) {
    disconnect_client(epfd, client);
  }
  if (ret > 0) {
    printf((char const   * __restrict  )"recv from client [%d] %d bytes: %s\n", client,
           ret, buffer);
    domain[0] = (uchar )0;
    tmp___1 = 1U;
    while (! (tmp___1 >= 512U)) {
      domain[tmp___1] = (unsigned char)0;
      tmp___1 ++;
    }
    type = (uint16_t )0;
    tmp___2 = cmd_analyze(buffer, domain, & type);
    ret___0 = tmp___2;
    if (ret___0 == 2) {
      hijack(domain, type, s->datasets, s->ttlexp);
    } else
    if (ret___0 == 1) {
      if ((int )type != 0) {
        tmp___3 = strlen((char const   *)((char *)(domain)));
        if (tmp___3 > 3UL) {
          cache_flush(domain, type, s->datasets, s->ttlexp);
        }
      }
    }
    tmp___4 = strlen((char const   *)(buffer));
    send(client, (void const   *)(buffer), tmp___4, 0);
  }
  return (0);
}
}
int start_local_server(struct server *s )
{
  int server ;
  int ret ;
  int epfd ;
  int i ;
  int fd ;
  struct epoll_event e[1024] ;
  int tmp ;

  {
  server = create_local_server(local_socket_name);
  if (server < 0) {
    return (-1);
  }
  epfd = epoll_create(1);
  if (epfd < 0) {
    perror("epoll_create error");
    close(server);
    return (-1);
  }
  tmp = ctl_fd(epfd, server, 1, (uint32_t )1);
  if (tmp != 0) {
    close(server);
    return (-1);
  }
  while (1) {
    ret = epoll_wait(epfd, e, 1024, 1000);
    if (! (ret < 0)) {
      i = 0;
      while (i < ret) {
        fd = e[i].data.fd;
        if (fd == server) {
          accept_client(epfd, server);
        } else
        if (e[i].events & 16U) {
          disconnect_client(epfd, fd);
        } else
        if (e[i].events & 8U) {
          disconnect_client(epfd, fd);
        } else
        if (e[i].events & 1U) {
          talk_with_client(epfd, fd, s);
        }
        i ++;
      }
    }
  }
}
}
#pragma merger("0","/tmp/cil-wYxPbCP2.i","-g,-Wall")
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
int refresh_ttl_with_td(uchar *key , int len , int type , struct htable *ht , struct rbtree *ttlexp ,
                        packet_type *lowerdomain )
{
  uint___0 tmp ;
  uint___0 tmp___0 ;

  {
  pthread_spin_lock(& ttlexp->lock);
  tmp = get_rbt_size(ttlexp);
  printf((char const   * __restrict  )"after delete, before insert, rbt size: %d\n",
         tmp);
  insert_into_ttltree(ttlexp, key, len, type, (uint___0 )0, lowerdomain);
  tmp___0 = get_rbt_size(ttlexp);
  printf((char const   * __restrict  )"after insert, rbt size: %d\n", tmp___0);
  pthread_spin_unlock(& ttlexp->lock);
  return (0);
}
}
int hijack(uchar *domain , uint16_t type , struct htable *ht , struct rbtree *ttlexp )
{
  __pid_t tmp ;

  {
  if (! domain) {
    tmp = getpid();
    kill(tmp, 10);
  } else
  if ((int )*(domain + 0) == 0) {
    tmp = getpid();
    kill(tmp, 10);
  } else
  if ((int )type <= 0) {
    tmp = getpid();
    kill(tmp, 10);
  } else
  if ((int )type > 255) {
    tmp = getpid();
    kill(tmp, 10);
  } else {
    cache_flush(domain, type, ht, ttlexp);
  }
  return (0);
}
}
int cache_flush(uchar *domain , uint16_t type , struct htable *ht , struct rbtree *ttlexp )
{
  int dlen ;
  size_t tmp ;
  hashval_t hash ;
  packet_type lowerdomain ;
  int idx ;
  uint___0 tmp___0 ;
  uchar *val ;
  uchar *tmp___1 ;
  struct mvalue *tmp___2 ;
  struct ttlnode tn ;
  struct ttlnode *tmp_tn ;
  struct rbnode *pn ;
  struct rbnode *tmp___3 ;
  void *tmp___4 ;

  {
  printf((char const   * __restrict  )"cache flush domain %s\n", domain);
  tmp = strlen((char const   *)domain);
  dlen = (int )(tmp + 1UL);
  hash = (hashval_t )0;
  str_to_len_label(domain, dlen);
  check_dns_name(domain, & lowerdomain);
  domain = lowerdomain.domain;
  tmp___0 = get_pre_mem_hash((void *)domain, dlen, & hash);
  idx = (int )tmp___0;
  tmp___1 = htable_delete(ht + idx, domain, dlen, (int )type, hash);
  val = tmp___1;
  if (val) {
    tmp___2 = (struct mvalue *)val;
    tn.exp = (uint___0 )0;
    tn.dlen = (unsigned short)0;
    tn.type = (unsigned short)0;
    tn.hash = (hashval_t *)0;
    tn.lowerdomain = (packet_type *)0;
    tn.data = (uchar *)0;
    tmp_tn = (struct ttlnode *)((void *)0);
    pthread_spin_lock(& ttlexp->lock);
    tn.dlen = (ushort___0 )dlen;
    tn.exp = tmp___2->ttl;
    tn.type = type;
    tn.data = domain;
    tn.lowerdomain = (packet_type *)((void *)0);
    tmp___3 = find_node(ttlexp, (void *)(& tn));
    pn = tmp___3;
    if ((unsigned long )pn != (unsigned long )((void *)0)) {
      tmp___4 = delete_node(ttlexp, pn);
      tmp_tn = (struct ttlnode *)tmp___4;
      if (tmp_tn) {
        free((void *)tmp_tn->lowerdomain);
        free((void *)tmp_tn);
      } else {
        __assert_fail("0", "control.c", 70U, "cache_flush");
      }
    }
    pthread_spin_unlock(& ttlexp->lock);
    free((void *)val);
    refresh_ttl_with_td(domain, dlen, (int )type, ht, ttlexp, & lowerdomain);
  }
  return (0);
}
}
#pragma merger("0","/tmp/cil-FXNdOcB_.i","-g,-Wall")
struct mbuf_ring *mbuf_ring  =    (struct mbuf_ring *)((void *)0);
struct mbuf_ring *mbuf_ring_create(uint32_t count )
{
  struct mbuf_ring *r ;
  uint64_t ring_size ;
  void *tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t volatile   tmp___2 ;
  uint32_t volatile   tmp___3 ;

  {
  ring_size = (unsigned long )count * sizeof(void *) + sizeof(struct mbuf_ring );
  tmp = malloc(ring_size);
  r = (struct mbuf_ring *)tmp;
  if ((unsigned long )r != (unsigned long )((void *)0)) {
    memset((void *)r, 0, sizeof(struct mbuf_ring ));
    r->prod.watermark = count;
    tmp___0 = count;
    r->cons.size = tmp___0;
    r->prod.size = tmp___0;
    tmp___1 = count - 1U;
    r->cons.mask = tmp___1;
    r->prod.mask = tmp___1;
    tmp___2 = (uint32_t volatile   )0;
    r->cons.head = tmp___2;
    r->prod.head = tmp___2;
    tmp___3 = (uint32_t volatile   )0;
    r->cons.tail = tmp___3;
    r->prod.tail = tmp___3;
  }
  return (r);
}
}
int mempool_create(uint32_t num )
{
  mbuf_type *tmp ;
  int i ;
  void *tmp___0 ;
  uint32_t volatile   tmp___1 ;

  {
  mbuf_ring = mbuf_ring_create(num);
  if ((unsigned long )((void *)0) == (unsigned long )mbuf_ring) {
    return (-1);
  }
  i = 0;
  while ((uint32_t )i < num) {
    tmp___0 = malloc(sizeof(mbuf_type ));
    tmp = (mbuf_type *)tmp___0;
    if ((unsigned long )((void *)0) == (unsigned long )tmp) {
      return (-1);
    }
    tmp->mbuf = mbuf_ring;
    mbuf_ring->ring[i] = (void *)tmp;
    i ++;
  }
  tmp___1 = (uint32_t volatile   )(num - 1U);
  mbuf_ring->prod.tail = tmp___1;
  mbuf_ring->prod.head = tmp___1;
  return (0);
}
}
__inline static int rte_atomic32_cmpset(uint32_t volatile   *dst , uint32_t exp ,
                                        uint32_t src )
{
  uint8_t res ;

  {
  __asm__  volatile   ("lock ; "
                       "cmpxchgl %[src], %[dst];"
                       "sete %[res];": [res] "=a" (res), [dst] "=m" (*dst): [src] "r" (src),
                       "a" (exp), "m" (*dst): "memory");
  return ((int )res);
}
}
mbuf_type *mbuf_alloc(void)
{
  uint32_t cons_head ;
  uint32_t prod_tail ;
  uint32_t cons_next ;
  uint32_t entries ;
  int success ;
  uint32_t mask ;
  mbuf_type *mbuf ;

  {
  mask = mbuf_ring->prod.mask;
  cons_head = (uint32_t )mbuf_ring->cons.head;
  prod_tail = (uint32_t )mbuf_ring->prod.tail;
  entries = prod_tail - cons_head;
  if (0U == entries) {
    dns_error(1, (char *)"out of mbuf ring(memory pool)");
    return ((mbuf_type *)((void *)0));
  }
  cons_next = cons_head + 1U;
  success = rte_atomic32_cmpset(& mbuf_ring->cons.head, cons_head, cons_next);
  if (success != 1) {
    return ((mbuf_type *)((void *)0));
  }
  mbuf = (mbuf_type *)mbuf_ring->ring[cons_head & mask];
  if (! ((unsigned long )mbuf != (unsigned long )((void *)0))) {
    __assert_fail("mbuf != NULL", "memory.c", 129U, "mbuf_alloc");
  }
  while (1) {
    __asm__  volatile   ("": : : "memory");
    break;
  }
  while (mbuf_ring->cons.tail != (uint32_t volatile   )cons_head) {

  }
  mbuf_ring->cons.tail = (uint32_t volatile   )cons_next;
  return (mbuf);
}
}
int mbuf_free(mbuf_type *mbuf )
{
  uint32_t prod_head ;
  uint32_t prod_next ;
  uint32_t cons_tail ;
  uint32_t free_entries ;
  int success ;
  uint32_t mask ;

  {
  mask = mbuf_ring->prod.mask;
  if ((unsigned long )((void *)0) == (unsigned long )mbuf) {
    return (0);
  }
  while (1) {
    prod_head = (uint32_t )mbuf_ring->prod.head;
    cons_tail = (uint32_t )mbuf_ring->cons.tail;
    free_entries = ((mask + 1U) + cons_tail) - prod_head;
    if (! (free_entries > 0U)) {
      __assert_fail("free_entries > 0", "memory.c", 155U, "mbuf_free");
    }
    prod_next = prod_head + 1U;
    success = rte_atomic32_cmpset(& mbuf_ring->prod.head, prod_head, prod_next);
    if (! (0 == success)) {
      break;
    }
  }
  mbuf_ring->ring[prod_head & mask] = (void *)mbuf;
  while (1) {
    __asm__  volatile   ("": : : "memory");
    break;
  }
  while (mbuf_ring->prod.tail != (uint32_t volatile   )prod_head) {

  }
  mbuf_ring->prod.tail = (uint32_t volatile   )prod_next;
  return (0);
}
}
