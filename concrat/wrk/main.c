/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long __int64_t;
typedef unsigned long __uint64_t;
typedef long __intmax_t;
typedef unsigned long __uintmax_t;
typedef unsigned int __uid_t;
typedef long __off_t;
typedef long __off64_t;
typedef int __pid_t;
typedef long __clock_t;
typedef long __time_t;
typedef long __suseconds_t;
typedef unsigned int __socklen_t;
typedef int __sig_atomic_t;
typedef unsigned long size_t;
typedef __time_t time_t;
typedef unsigned long pthread_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
typedef __int64_t int64_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
typedef int __gwchar_t;
struct __anonstruct___sigset_t_991265788 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___sigset_t_991265788 __sigset_t;
typedef __sigset_t sigset_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
typedef __socklen_t socklen_t;
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
typedef __builtin_va_list __gnuc_va_list;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
struct ssl_st ;
typedef struct ssl_st SSL;
struct ssl_ctx_st ;
typedef struct ssl_ctx_st SSL_CTX;
struct lua_State ;
typedef struct lua_State lua_State;
struct __anonstruct_errors_1007178897 {
   uint32_t connect ;
   uint32_t read ;
   uint32_t write ;
   uint32_t status ;
   uint32_t timeout ;
};
typedef struct __anonstruct_errors_1007178897 errors;
struct __anonstruct_stats_804253929 {
   uint64_t count ;
   uint64_t limit ;
   uint64_t min ;
   uint64_t max ;
   uint64_t data[] ;
};
typedef struct __anonstruct_stats_804253929 stats;
struct aeEventLoop ;
typedef void aeFileProc(struct aeEventLoop *eventLoop , int fd , void *clientData ,
                        int mask );
typedef int aeTimeProc(struct aeEventLoop *eventLoop , long long id , void *clientData );
typedef void aeEventFinalizerProc(struct aeEventLoop *eventLoop , void *clientData );
typedef void aeBeforeSleepProc(struct aeEventLoop *eventLoop );
struct aeFileEvent {
   int mask ;
   aeFileProc *rfileProc ;
   aeFileProc *wfileProc ;
   void *clientData ;
};
typedef struct aeFileEvent aeFileEvent;
struct aeTimeEvent {
   long long id ;
   long when_sec ;
   long when_ms ;
   aeTimeProc *timeProc ;
   aeEventFinalizerProc *finalizerProc ;
   void *clientData ;
   struct aeTimeEvent *next ;
};
typedef struct aeTimeEvent aeTimeEvent;
struct aeFiredEvent {
   int fd ;
   int mask ;
};
typedef struct aeFiredEvent aeFiredEvent;
struct aeEventLoop {
   int maxfd ;
   int setsize ;
   long long timeEventNextId ;
   time_t lastTime ;
   aeFileEvent *events ;
   aeFiredEvent *fired ;
   aeTimeEvent *timeEventHead ;
   int stop ;
   void *apidata ;
   aeBeforeSleepProc *beforesleep ;
};
typedef struct aeEventLoop aeEventLoop;
struct http_parser ;
typedef struct http_parser http_parser;
struct http_parser_settings ;
typedef struct http_parser_settings http_parser_settings;
enum http_parser_type {
    HTTP_REQUEST = 0,
    HTTP_RESPONSE = 1,
    HTTP_BOTH = 2
} ;
struct http_parser {
   unsigned int type : 2 ;
   unsigned int flags : 8 ;
   unsigned int state : 7 ;
   unsigned int header_state : 7 ;
   unsigned int index : 7 ;
   unsigned int lenient_http_headers : 1 ;
   uint32_t nread ;
   uint64_t content_length ;
   unsigned short http_major ;
   unsigned short http_minor ;
   unsigned int status_code : 16 ;
   unsigned int method : 8 ;
   unsigned int http_errno : 7 ;
   unsigned int upgrade : 1 ;
   void *data ;
};
struct http_parser_settings {
   int (*on_message_begin)(http_parser * ) ;
   int (*on_url)(http_parser * , char const   *at , size_t length ) ;
   int (*on_status)(http_parser * , char const   *at , size_t length ) ;
   int (*on_header_field)(http_parser * , char const   *at , size_t length ) ;
   int (*on_header_value)(http_parser * , char const   *at , size_t length ) ;
   int (*on_headers_complete)(http_parser * ) ;
   int (*on_body)(http_parser * , char const   *at , size_t length ) ;
   int (*on_message_complete)(http_parser * ) ;
   int (*on_chunk_header)(http_parser * ) ;
   int (*on_chunk_complete)(http_parser * ) ;
};
enum http_parser_url_fields {
    UF_SCHEMA = 0,
    UF_HOST = 1,
    UF_PORT = 2,
    UF_PATH = 3,
    UF_QUERY = 4,
    UF_FRAGMENT = 5,
    UF_USERINFO = 6,
    UF_MAX = 7
} ;
struct __anonstruct_field_data_753912357 {
   uint16_t off ;
   uint16_t len ;
};
struct http_parser_url {
   uint16_t field_set ;
   uint16_t port ;
   struct __anonstruct_field_data_753912357 field_data[7] ;
};
struct connection ;
struct __anonstruct_thread_238483422 {
   pthread_t thread ;
   aeEventLoop *loop ;
   struct addrinfo *addr ;
   uint64_t connections ;
   uint64_t complete ;
   uint64_t requests ;
   uint64_t bytes ;
   uint64_t start ;
   lua_State *L ;
   errors errors ;
   struct connection *cs ;
};
typedef struct __anonstruct_thread_238483422 thread;
struct __anonstruct_buffer_827665108 {
   char *buffer ;
   size_t length ;
   char *cursor ;
};
typedef struct __anonstruct_buffer_827665108 buffer;
enum __anonenum_state_47808738 {
    FIELD = 0,
    VALUE = 1
} ;
struct connection {
   thread *thread ;
   http_parser parser ;
   enum __anonenum_state_47808738 state ;
   int fd ;
   SSL *ssl ;
   _Bool delayed ;
   uint64_t start ;
   char *request ;
   size_t length ;
   size_t written ;
   uint64_t pending ;
   buffer headers ;
   buffer body ;
   char buf[8192] ;
};
typedef struct connection connection;
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
typedef __sig_atomic_t sig_atomic_t;
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
typedef union sigval __sigval_t;
struct __anonstruct__kill_244518854 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
struct __anonstruct__timer_490064738 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
struct __anonstruct__rt_619254530 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
struct __anonstruct__sigchld_284671705 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
struct __anonstruct__addr_bnd_5259977 {
   void *_lower ;
   void *_upper ;
};
union __anonunion__bounds_341140457 {
   struct __anonstruct__addr_bnd_5259977 _addr_bnd ;
   __uint32_t _pkey ;
};
struct __anonstruct__sigfault_496270274 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion__bounds_341140457 _bounds ;
};
struct __anonstruct__sigpoll_386613454 {
   long si_band ;
   int si_fd ;
};
struct __anonstruct__sigsys_44812255 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
union __anonunion__sifields_534194718 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_244518854 _kill ;
   struct __anonstruct__timer_490064738 _timer ;
   struct __anonstruct__rt_619254530 _rt ;
   struct __anonstruct__sigchld_284671705 _sigchld ;
   struct __anonstruct__sigfault_496270274 _sigfault ;
   struct __anonstruct__sigpoll_386613454 _sigpoll ;
   struct __anonstruct__sigsys_44812255 _sigsys ;
};
struct __anonstruct_siginfo_t_981507777 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion__sifields_534194718 _sifields ;
};
typedef struct __anonstruct_siginfo_t_981507777 siginfo_t;
typedef void (*__sighandler_t)(int  );
union __anonunion___sigaction_handler_363639592 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
struct sigaction {
   union __anonunion___sigaction_handler_363639592 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
enum __anonenum_status_995329011 {
    OK = 0,
    ERROR = 1,
    RETRY = 2
} ;
typedef enum __anonenum_status_995329011 status;
struct sock {
   status (*connect)(connection * , char * ) ;
   status (*close)(connection * ) ;
   status (*read)(connection * , size_t * ) ;
   status (*write)(connection * , char * , size_t  , size_t * ) ;
   size_t (*readable)(connection * ) ;
};
struct config ;
struct config {
   uint64_t connections ;
   uint64_t duration ;
   uint64_t threads ;
   uint64_t timeout ;
   uint64_t pipeline ;
   _Bool delay ;
   _Bool dynamic ;
   _Bool latency ;
   char *host ;
   char *script ;
   SSL_CTX *ctx ;
};
struct __anonstruct_statistics_580573181 {
   stats *latency ;
   stats *requests ;
};
typedef long __ssize_t;
typedef __ssize_t ssize_t;
struct x509_store_ctx_st ;
typedef struct x509_store_ctx_st X509_STORE_CTX;
struct ossl_init_settings_st ;
typedef struct ossl_init_settings_st OPENSSL_INIT_SETTINGS;
struct ssl_method_st ;
typedef struct ssl_method_st SSL_METHOD;
typedef __gnuc_va_list va_list___0;
typedef long ptrdiff_t;
typedef double lua_Number;
typedef ptrdiff_t lua_Integer;
struct luaL_Reg {
   char const   *name ;
   int (*func)(lua_State *L ) ;
};
typedef struct luaL_Reg luaL_Reg;
struct luaL_Buffer {
   char *p ;
   int lvl ;
   lua_State *L ;
   char buffer[8192] ;
};
typedef struct luaL_Buffer luaL_Buffer;
enum http_errno {
    HPE_OK = 0,
    HPE_CB_message_begin = 1,
    HPE_CB_url = 2,
    HPE_CB_header_field = 3,
    HPE_CB_header_value = 4,
    HPE_CB_headers_complete = 5,
    HPE_CB_body = 6,
    HPE_CB_message_complete = 7,
    HPE_CB_status = 8,
    HPE_CB_chunk_header = 9,
    HPE_CB_chunk_complete = 10,
    HPE_INVALID_EOF_STATE = 11,
    HPE_HEADER_OVERFLOW = 12,
    HPE_CLOSED_CONNECTION = 13,
    HPE_INVALID_VERSION = 14,
    HPE_INVALID_STATUS = 15,
    HPE_INVALID_METHOD = 16,
    HPE_INVALID_URL = 17,
    HPE_INVALID_HOST = 18,
    HPE_INVALID_PORT = 19,
    HPE_INVALID_PATH = 20,
    HPE_INVALID_QUERY_STRING = 21,
    HPE_INVALID_FRAGMENT = 22,
    HPE_LF_EXPECTED = 23,
    HPE_INVALID_HEADER_TOKEN = 24,
    HPE_INVALID_CONTENT_LENGTH = 25,
    HPE_UNEXPECTED_CONTENT_LENGTH = 26,
    HPE_INVALID_CHUNK_SIZE = 27,
    HPE_INVALID_CONSTANT = 28,
    HPE_INVALID_INTERNAL_STATE = 29,
    HPE_STRICT = 30,
    HPE_PAUSED = 31,
    HPE_UNKNOWN = 32
} ;
struct __anonstruct_table_field_66454024 {
   char *name ;
   int type ;
   void *value ;
};
typedef struct __anonstruct_table_field_66454024 table_field;
struct __anonstruct_units_255056401 {
   int scale ;
   char *base ;
   char *units[] ;
};
typedef struct __anonstruct_units_255056401 units;
typedef unsigned long nfds_t;
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
union epoll_data {
   void *ptr ;
   int fd ;
   uint32_t u32 ;
   uint64_t u64 ;
};
typedef union epoll_data epoll_data_t;
struct epoll_event {
   uint32_t events ;
   epoll_data_t data ;
} __attribute__((__packed__)) ;
struct aeApiState {
   int epfd ;
   struct epoll_event *events ;
};
typedef struct aeApiState aeApiState;
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef __int8_t int8_t;
typedef __uint8_t uint8_t;
enum http_method {
    HTTP_DELETE = 0,
    HTTP_GET = 1,
    HTTP_HEAD = 2,
    HTTP_POST = 3,
    HTTP_PUT = 4,
    HTTP_CONNECT = 5,
    HTTP_OPTIONS = 6,
    HTTP_TRACE = 7,
    HTTP_COPY = 8,
    HTTP_LOCK = 9,
    HTTP_MKCOL = 10,
    HTTP_MOVE = 11,
    HTTP_PROPFIND = 12,
    HTTP_PROPPATCH = 13,
    HTTP_SEARCH = 14,
    HTTP_UNLOCK = 15,
    HTTP_BIND = 16,
    HTTP_REBIND = 17,
    HTTP_UNBIND = 18,
    HTTP_ACL = 19,
    HTTP_REPORT = 20,
    HTTP_MKACTIVITY = 21,
    HTTP_CHECKOUT = 22,
    HTTP_MERGE = 23,
    HTTP_MSEARCH = 24,
    HTTP_NOTIFY = 25,
    HTTP_SUBSCRIBE = 26,
    HTTP_UNSUBSCRIBE = 27,
    HTTP_PATCH = 28,
    HTTP_PURGE = 29,
    HTTP_MKCALENDAR = 30,
    HTTP_LINK = 31,
    HTTP_UNLINK = 32
} ;
enum state {
    s_dead = 1,
    s_start_req_or_res = 2,
    s_res_or_resp_H = 3,
    s_start_res = 4,
    s_res_H = 5,
    s_res_HT = 6,
    s_res_HTT = 7,
    s_res_HTTP = 8,
    s_res_http_major = 9,
    s_res_http_dot = 10,
    s_res_http_minor = 11,
    s_res_http_end = 12,
    s_res_first_status_code = 13,
    s_res_status_code = 14,
    s_res_status_start = 15,
    s_res_status = 16,
    s_res_line_almost_done = 17,
    s_start_req = 18,
    s_req_method = 19,
    s_req_spaces_before_url = 20,
    s_req_schema = 21,
    s_req_schema_slash = 22,
    s_req_schema_slash_slash = 23,
    s_req_server_start = 24,
    s_req_server = 25,
    s_req_server_with_at = 26,
    s_req_path = 27,
    s_req_query_string_start = 28,
    s_req_query_string = 29,
    s_req_fragment_start = 30,
    s_req_fragment = 31,
    s_req_http_start = 32,
    s_req_http_H = 33,
    s_req_http_HT = 34,
    s_req_http_HTT = 35,
    s_req_http_HTTP = 36,
    s_req_http_major = 37,
    s_req_http_dot = 38,
    s_req_http_minor = 39,
    s_req_http_end = 40,
    s_req_line_almost_done = 41,
    s_header_field_start = 42,
    s_header_field = 43,
    s_header_value_discard_ws = 44,
    s_header_value_discard_ws_almost_done = 45,
    s_header_value_discard_lws = 46,
    s_header_value_start = 47,
    s_header_value = 48,
    s_header_value_lws = 49,
    s_header_almost_done = 50,
    s_chunk_size_start = 51,
    s_chunk_size = 52,
    s_chunk_parameters = 53,
    s_chunk_size_almost_done = 54,
    s_headers_almost_done = 55,
    s_headers_done = 56,
    s_chunk_data = 57,
    s_chunk_data_almost_done = 58,
    s_chunk_data_done = 59,
    s_body_identity = 60,
    s_body_identity_eof = 61,
    s_message_done = 62
} ;
enum header_states {
    h_general = 0,
    h_C = 1,
    h_CO = 2,
    h_CON = 3,
    h_matching_connection = 4,
    h_matching_proxy_connection = 5,
    h_matching_content_length = 6,
    h_matching_transfer_encoding = 7,
    h_matching_upgrade = 8,
    h_connection = 9,
    h_content_length = 10,
    h_transfer_encoding = 11,
    h_upgrade = 12,
    h_matching_transfer_encoding_chunked = 13,
    h_matching_connection_token_start = 14,
    h_matching_connection_keep_alive = 15,
    h_matching_connection_close = 16,
    h_matching_connection_upgrade = 17,
    h_matching_connection_token = 18,
    h_transfer_encoding_chunked = 19,
    h_connection_keep_alive = 20,
    h_connection_close = 21,
    h_connection_upgrade = 22
} ;
enum http_host_state {
    s_http_host_dead = 1,
    s_http_userinfo_start = 2,
    s_http_userinfo = 3,
    s_http_host_start = 4,
    s_http_host_v6_start = 5,
    s_http_host = 6,
    s_http_host_v6 = 7,
    s_http_host_v6_end = 8,
    s_http_host_v6_zone_start = 9,
    s_http_host_v6_zone = 10,
    s_http_host_port_start = 11,
    s_http_host_port = 12
} ;
struct __anonstruct_http_strerror_tab_527861670 {
   char const   *name ;
   char const   *description ;
};
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#pragma merger("0","/tmp/cil-KBBcajIN.i","-std=c99,-Wall,-O2")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                     pthread_t __thread2 ) 
{ 


  {
  return (__thread1 == __thread2);
}
}
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   * __restrict  nptr ,
                                                                                                    char ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   * __restrict  nptr ,
                                                                                                     char ** __restrict  endptr ,
                                                                                                     int base ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                    __gwchar_t ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                     __gwchar_t ** __restrict  endptr ,
                                                                                                     int base ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) __strtol_internal)(char const   * __restrict  __nptr ,
                                                                                               char ** __restrict  __endptr ,
                                                                                               int __base ,
                                                                                               int __group ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   * __restrict  nptr ,
                                                                                                    char ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   * __restrict  nptr ,
                                                                      char ** __restrict  endptr ,
                                                                      int base ) 
{ 
  long tmp ;

  {
  tmp = __strtol_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) __strtoul_internal)(char const   * __restrict  __nptr ,
                                                                                                         char ** __restrict  __endptr ,
                                                                                                         int __base ,
                                                                                                         int __group ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   * __restrict  nptr ,
                                                                                                     char ** __restrict  endptr ,
                                                                                                     int base ) ;
__inline extern uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   * __restrict  nptr ,
                                                                       char ** __restrict  endptr ,
                                                                       int base ) 
{ 
  unsigned long tmp ;

  {
  tmp = __strtoul_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) __wcstol_internal)(__gwchar_t const   * __restrict  __nptr ,
                                                                                               __gwchar_t ** __restrict  __endptr ,
                                                                                               int __base ,
                                                                                               int __group ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                    __gwchar_t ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t const   * __restrict  nptr ,
                                                                      __gwchar_t ** __restrict  endptr ,
                                                                      int base ) 
{ 
  long tmp ;

  {
  tmp = __wcstol_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) __wcstoul_internal)(__gwchar_t const   * __restrict  __nptr ,
                                                                                                         __gwchar_t ** __restrict  __endptr ,
                                                                                                         int __base ,
                                                                                                         int __group ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                     __gwchar_t ** __restrict  endptr ,
                                                                                                     int base ) ;
__inline extern uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t const   * __restrict  nptr ,
                                                                       __gwchar_t ** __restrict  endptr ,
                                                                       int base ) 
{ 
  unsigned long tmp ;

  {
  tmp = __wcstoul_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                               struct cmsghdr *__cmsg ) ;
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                               struct cmsghdr *__cmsg ) ;
__inline extern struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                 struct cmsghdr *__cmsg ) 
{ 


  {
  if (__cmsg->cmsg_len < sizeof(struct cmsghdr )) {
    return ((struct cmsghdr *)0);
  }
  __cmsg = (struct cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)));
  if ((unsigned long )((unsigned char *)(__cmsg + 1)) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  } else
  if ((unsigned long )((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  }
  return (__cmsg);
}
}
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1))) strtoll)(char const   * __restrict  __nptr ,
                                                                                          char ** __restrict  __endptr ,
                                                                                          int __base ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) atoi)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return ((int )tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long ( __attribute__((__nonnull__(1), __gnu_inline__)) atol)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long long ( __attribute__((__nonnull__(1), __gnu_inline__)) atoll)(char const   *__nptr ) 
{ 
  long long tmp ;

  {
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
  __l = (size_t )0;
  __u = __nmemb;
  while (__l < __u) {
    __idx = (__l + __u) / 2UL;
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
    __comparison = (*__compar)(__key, __p);
    if (__comparison < 0) {
      __u = __idx;
    } else
    if (__comparison > 0) {
      __l = __idx + 1UL;
    } else {
      return ((void *)__p);
    }
  }
  return ((void *)0);
}
}
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern double ( __attribute__((__nonnull__(1), __gnu_inline__)) atof)(char const   *__nptr ) 
{ 
  double tmp ;

  {
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
  return (tmp);
}
}
extern FILE *stdin ;
extern FILE *stdout ;
extern FILE *stderr ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) ;
extern int getc(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
extern int putc(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
extern int __uflow(FILE * ) ;
extern int __overflow(FILE * , int  ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) 
{ 
  int tmp ;

  {
  tmp = vfprintf((FILE * __restrict  )stdout, __fmt, __arg);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) 
{ 
  int tmp ;

  {
  tmp = getc(stdin);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(__fp);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = __fp->_IO_read_ptr;
    (__fp->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(stdin);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = stdin->_IO_read_ptr;
    (stdin->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) 
{ 
  int tmp ;

  {
  tmp = putc(__c, stdout);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = __stream->_IO_write_ptr;
    (__stream->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = stdout->_IO_write_ptr;
    (stdout->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 16) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 32) != 0);
}
}
extern SSL *SSL_new(SSL_CTX *ctx ) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
extern void ERR_print_errors_fp(FILE *fp ) ;
stats *stats_alloc(uint64_t max ) ;
int stats_record(stats *stats___0 , uint64_t n ) ;
void stats_correct(stats *stats___0 , int64_t expected ) ;
long double stats_mean(stats *stats___0 ) ;
long double stats_stdev(stats *stats___0 , long double mean ) ;
long double stats_within_stdev(stats *stats___0 , long double mean , long double stdev ,
                               uint64_t n ) ;
uint64_t stats_percentile(stats *stats___0 , long double p ) ;
aeEventLoop *aeCreateEventLoop(int setsize ) ;
void aeDeleteEventLoop(aeEventLoop *eventLoop ) ;
void aeStop(aeEventLoop *eventLoop ) ;
int aeCreateFileEvent(aeEventLoop *eventLoop , int fd , int mask , aeFileProc *proc ,
                      void *clientData ) ;
void aeDeleteFileEvent(aeEventLoop *eventLoop , int fd , int mask ) ;
long long aeCreateTimeEvent(aeEventLoop *eventLoop , long long milliseconds , aeTimeProc *proc ,
                            void *clientData , aeEventFinalizerProc *finalizerProc ) ;
void aeMain(aeEventLoop *eventLoop ) ;
char *aeGetApiName(void) ;
void http_parser_init(http_parser *parser , enum http_parser_type t ) ;
size_t http_parser_execute(http_parser *parser , http_parser_settings const   *settings ,
                           char const   *data , size_t len ) ;
int http_should_keep_alive(http_parser const   *parser ) ;
int http_body_is_final(struct http_parser  const  *parser ) ;
char const   *VERSION ;
extern int close(int __fd ) ;
extern unsigned int sleep(unsigned int __seconds ) ;
extern char *optarg ;
extern int optind ;
lua_State *script_create(char *file , char *url , char **headers ) ;
_Bool script_resolve(lua_State *L , char *host , char *service ) ;
void script_done(lua_State *L , stats *latency , stats *requests ) ;
void script_init(lua_State *L , thread *t , int argc , char **argv ) ;
uint64_t script_delay(lua_State *L ) ;
void script_request(lua_State *L , char **buf , size_t *len ) ;
void script_response(lua_State *L , int status , buffer *headers , buffer *body ) ;
size_t script_verify_request(lua_State *L ) ;
_Bool script_is_static(lua_State *L ) ;
_Bool script_want_response(lua_State *L ) ;
_Bool script_has_delay(lua_State *L ) ;
_Bool script_has_done(lua_State *L ) ;
void script_summary(lua_State *L , uint64_t duration , uint64_t requests , uint64_t bytes ) ;
void script_errors(lua_State *L , errors *errors___0 ) ;
int script_parse_url(char *url , struct http_parser_url *parts ) ;
void buffer_append(buffer *b , char const   *data , size_t len ) ;
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) tolower)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_tolower_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
    tmp___0 = (__int32_t const   )__c;
  }
  return ((int )tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) toupper)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_toupper_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
    tmp___0 = (__int32_t const   )__c;
  }
  return ((int )tmp___0);
}
}
extern int fcntl(int __fd , int __cmd  , ...) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) getopt_long)(int ___argc ,
                                                                                          char * const  *___argv ,
                                                                                          char const   *__shortopts ,
                                                                                          struct option  const  *__longopts ,
                                                                                          int *__longind ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigfillset)(sigset_t *__set ) ;
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         void * __restrict  __tz ) ;
status sock_connect(connection *c , char *host ) ;
status sock_close(connection *c ) ;
status sock_read(connection *c , size_t *n ) ;
status sock_write(connection *c , char *buf , size_t len , size_t *n ) ;
size_t sock_readable(connection *c ) ;
SSL_CTX *ssl_init(void) ;
status ssl_connect(connection *c , char *host ) ;
status ssl_close(connection *c ) ;
status ssl_read(connection *c , size_t *n ) ;
status ssl_write(connection *c , char *buf , size_t len , size_t *n ) ;
size_t ssl_readable(connection *c ) ;
char *format_binary(long double n ) ;
char *format_metric(long double n ) ;
char *format_time_us(long double n ) ;
char *format_time_s(long double n ) ;
int scan_metric(char *s , uint64_t *n ) ;
int scan_time(char *s , uint64_t *n ) ;
void *zmalloc(size_t size ) ;
void *zcalloc(size_t size ) ;
void zfree(void *ptr ) ;
static void *thread_main(void *arg ) ;
static int connect_socket(thread *thread___0 , connection *c ) ;
static int reconnect_socket(thread *thread___0 , connection *c ) ;
static int record_rate(aeEventLoop *loop , long long id , void *data ) ;
static void socket_connected(aeEventLoop *loop , int fd , void *data , int mask ) ;
static void socket_writeable(aeEventLoop *loop , int fd , void *data , int mask ) ;
static void socket_readable(aeEventLoop *loop , int fd , void *data , int mask ) ;
static int response_complete(http_parser *parser ) ;
static int header_field(http_parser *parser , char const   *at , size_t len ) ;
static int header_value(http_parser *parser , char const   *at , size_t len ) ;
static int response_body(http_parser *parser , char const   *at , size_t len ) ;
static uint64_t time_us(void) ;
static int parse_args(struct config *cfg___0 , char **url , struct http_parser_url *parts ,
                      char **headers , int argc , char **argv ) ;
static char *copy_url_part(char *url , struct http_parser_url *parts , enum http_parser_url_fields field ) ;
static void print_stats_header(void) ;
static void print_stats(char *name , stats *stats___0 , char *(*fmt)(long double  ) ) ;
static void print_stats_latency(stats *stats___0 ) ;
static struct config cfg  ;
static struct __anonstruct_statistics_580573181 statistics  ;
static struct sock sock  =    {& sock_connect, & sock_close, & sock_read, & sock_write, & sock_readable};
static struct http_parser_settings parser_settings  = 
     {(int (*)(http_parser * ))0, (int (*)(http_parser * , char const   *at , size_t length ))0,
    (int (*)(http_parser * , char const   *at , size_t length ))0, (int (*)(http_parser * ,
                                                                            char const   *at ,
                                                                            size_t length ))0,
    (int (*)(http_parser * , char const   *at , size_t length ))0, (int (*)(http_parser * ))0,
    (int (*)(http_parser * , char const   *at , size_t length ))0, & response_complete,
    (int (*)(http_parser * ))0, (int (*)(http_parser * ))0};
static int volatile   stop  =    (sig_atomic_t volatile   )0;
static void handler(int sig ) 
{ 


  {
  stop = (int volatile   )1;
  return;
}
}
static void usage(void) 
{ 


  {
  printf((char const   * __restrict  )"Usage: wrk <options> <url>                            \n  Options:                                            \n    -c, --connections <N>  Connections to keep open   \n    -d, --duration    <T>  Duration of test           \n    -t, --threads     <N>  Number of threads to use   \n                                                      \n    -s, --script      <S>  Load Lua script file       \n    -H, --header      <H>  Add header to request      \n        --latency          Print latency statistics   \n        --timeout     <T>  Socket/request timeout     \n    -v, --version          Print version details      \n                                                      \n  Numeric arguments may include a SI unit (1k, 1M, 1G)\n  Time arguments may include a time unit (2s, 2m, 2h)\n");
  return;
}
}
int main(int argc , char **argv ) 
{ 
  char *url ;
  char **headers ;
  void *tmp ;
  struct http_parser_url parts ;
  int tmp___0 ;
  char *schema ;
  char *tmp___1 ;
  char *host ;
  char *tmp___2 ;
  char *port ;
  char *tmp___3 ;
  char *service ;
  char *tmp___4 ;
  int tmp___5 ;
  thread *threads ;
  void *tmp___6 ;
  lua_State *L ;
  lua_State *tmp___7 ;
  char *msg ;
  int *tmp___8 ;
  char *tmp___9 ;
  _Bool tmp___10 ;
  uint64_t i ;
  thread *t ;
  _Bool tmp___11 ;
  int tmp___12 ;
  _Bool tmp___13 ;
  char *msg___0 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  struct sigaction sa ;
  char *time___0 ;
  char *tmp___17 ;
  uint64_t start ;
  uint64_t tmp___18 ;
  uint64_t complete ;
  uint64_t bytes ;
  errors errors___0 ;
  uint64_t i___0 ;
  thread *t___0 ;
  uint64_t runtime_us ;
  uint64_t tmp___19 ;
  long double runtime_s ;
  long double req_per_s ;
  long double bytes_per_s ;
  int64_t interval ;
  char *runtime_msg ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  _Bool tmp___23 ;

  {
  tmp = zmalloc((unsigned long )argc * sizeof(char *));
  headers = (char **)tmp;
  parts.field_set = (uint16_t )0;
  parts.port = (unsigned short)0;
  parts.field_data[0].off = (unsigned short)0;
  parts.field_data[0].len = (unsigned short)0;
  parts.field_data[1].off = (unsigned short)0;
  parts.field_data[1].len = (unsigned short)0;
  parts.field_data[2].off = (unsigned short)0;
  parts.field_data[2].len = (unsigned short)0;
  parts.field_data[3].off = (unsigned short)0;
  parts.field_data[3].len = (unsigned short)0;
  parts.field_data[4].off = (unsigned short)0;
  parts.field_data[4].len = (unsigned short)0;
  parts.field_data[5].off = (unsigned short)0;
  parts.field_data[5].len = (unsigned short)0;
  parts.field_data[6].off = (unsigned short)0;
  parts.field_data[6].len = (unsigned short)0;
  tmp___0 = parse_args(& cfg, & url, & parts, headers, argc, argv);
  if (tmp___0) {
    usage();
    exit(1);
  }
  tmp___1 = copy_url_part(url, & parts, (enum http_parser_url_fields )0);
  schema = tmp___1;
  tmp___2 = copy_url_part(url, & parts, (enum http_parser_url_fields )1);
  host = tmp___2;
  tmp___3 = copy_url_part(url, & parts, (enum http_parser_url_fields )2);
  port = tmp___3;
  if (port) {
    tmp___4 = port;
  } else {
    tmp___4 = schema;
  }
  service = tmp___4;
  tmp___5 = strncmp("https", (char const   *)schema, (size_t )5);
  if (! tmp___5) {
    cfg.ctx = ssl_init();
    if ((unsigned long )cfg.ctx == (unsigned long )((void *)0)) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"unable to initialize SSL\n");
      ERR_print_errors_fp(stderr);
      exit(1);
    }
    sock.connect = & ssl_connect;
    sock.close = & ssl_close;
    sock.read = & ssl_read;
    sock.write = & ssl_write;
    sock.readable = & ssl_readable;
  }
  signal(13, (void (*)(int  ))1);
  signal(2, (void (*)(int  ))1);
  statistics.latency = stats_alloc(cfg.timeout * 1000UL);
  statistics.requests = stats_alloc((uint64_t )10000000);
  tmp___6 = zcalloc(cfg.threads * sizeof(thread ));
  threads = (thread *)tmp___6;
  tmp___7 = script_create(cfg.script, url, headers);
  L = tmp___7;
  tmp___10 = script_resolve(L, host, service);
  if (! tmp___10) {
    tmp___8 = __errno_location();
    tmp___9 = strerror(*tmp___8);
    msg = tmp___9;
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"unable to connect to %s:%s %s\n",
            host, service, msg);
    exit(1);
  }
  cfg.host = host;
  i = (uint64_t )0;
  while (i < cfg.threads) {
    t = threads + i;
    t->loop = aeCreateEventLoop((int )(10UL + cfg.connections * 3UL));
    t->connections = cfg.connections / cfg.threads;
    t->L = script_create(cfg.script, url, headers);
    script_init(L, t, argc - optind, argv + optind);
    if (i == 0UL) {
      cfg.pipeline = script_verify_request(t->L);
      tmp___11 = script_is_static(t->L);
      if (tmp___11) {
        tmp___12 = 0;
      } else {
        tmp___12 = 1;
      }
      cfg.dynamic = (_Bool )tmp___12;
      cfg.delay = script_has_delay(t->L);
      tmp___13 = script_want_response(t->L);
      if (tmp___13) {
        parser_settings.on_header_field = & header_field;
        parser_settings.on_header_value = & header_value;
        parser_settings.on_body = & response_body;
      }
    }
    if (! t->loop) {
      tmp___14 = __errno_location();
      tmp___15 = strerror(*tmp___14);
      msg___0 = tmp___15;
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"unable to create thread %lu: %s\n",
              i, msg___0);
      exit(2);
    } else {
      tmp___16 = pthread_create((pthread_t * __restrict  )(& t->thread), (pthread_attr_t const   * __restrict  )((void *)0),
                                & thread_main, (void * __restrict  )t);
      if (tmp___16) {
        tmp___14 = __errno_location();
        tmp___15 = strerror(*tmp___14);
        msg___0 = tmp___15;
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"unable to create thread %lu: %s\n",
                i, msg___0);
        exit(2);
      }
    }
    i ++;
  }
  sa.__sigaction_handler.sa_handler = & handler;
  sa.sa_mask.__val[0] = 0UL;
  sa.sa_mask.__val[1] = 0UL;
  sa.sa_mask.__val[2] = 0UL;
  sa.sa_mask.__val[3] = 0UL;
  sa.sa_mask.__val[4] = 0UL;
  sa.sa_mask.__val[5] = 0UL;
  sa.sa_mask.__val[6] = 0UL;
  sa.sa_mask.__val[7] = 0UL;
  sa.sa_mask.__val[8] = 0UL;
  sa.sa_mask.__val[9] = 0UL;
  sa.sa_mask.__val[10] = 0UL;
  sa.sa_mask.__val[11] = 0UL;
  sa.sa_mask.__val[12] = 0UL;
  sa.sa_mask.__val[13] = 0UL;
  sa.sa_mask.__val[14] = 0UL;
  sa.sa_mask.__val[15] = 0UL;
  sa.sa_flags = 0;
  sa.sa_restorer = (void (*)(void))0;
  sigfillset(& sa.sa_mask);
  sigaction(2, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
  tmp___17 = format_time_s((long double )cfg.duration);
  time___0 = tmp___17;
  printf((char const   * __restrict  )"Running %s test @ %s\n", time___0, url);
  printf((char const   * __restrict  )"  %lu threads and %lu connections\n", cfg.threads,
         cfg.connections);
  tmp___18 = time_us();
  start = tmp___18;
  complete = (uint64_t )0;
  bytes = (uint64_t )0;
  errors___0.connect = (uint32_t )0;
  errors___0.read = 0U;
  errors___0.write = 0U;
  errors___0.status = 0U;
  errors___0.timeout = 0U;
  sleep((unsigned int )cfg.duration);
  stop = (int volatile   )1;
  i___0 = (uint64_t )0;
  while (i___0 < cfg.threads) {
    t___0 = threads + i___0;
    pthread_join(t___0->thread, (void **)((void *)0));
    complete += t___0->complete;
    bytes += t___0->bytes;
    errors___0.connect += t___0->errors.connect;
    errors___0.read += t___0->errors.read;
    errors___0.write += t___0->errors.write;
    errors___0.timeout += t___0->errors.timeout;
    errors___0.status += t___0->errors.status;
    i___0 ++;
  }
  tmp___19 = time_us();
  runtime_us = tmp___19 - start;
  runtime_s = (long double )((double )runtime_us / 1000000.0);
  req_per_s = (long double )complete / runtime_s;
  bytes_per_s = (long double )bytes / runtime_s;
  if (complete / cfg.connections > 0UL) {
    interval = (int64_t )(runtime_us / (complete / cfg.connections));
    stats_correct(statistics.latency, interval);
  }
  print_stats_header();
  print_stats((char *)"Latency", statistics.latency, & format_time_us);
  print_stats((char *)"Req/Sec", statistics.requests, & format_metric);
  if (cfg.latency) {
    print_stats_latency(statistics.latency);
  }
  tmp___20 = format_time_us((long double )runtime_us);
  runtime_msg = tmp___20;
  tmp___21 = format_binary((long double )bytes);
  printf((char const   * __restrict  )"  %lu requests in %s, %sB read\n", complete,
         runtime_msg, tmp___21);
  if (errors___0.connect) {
    printf((char const   * __restrict  )"  Socket errors: connect %d, read %d, write %d, timeout %d\n",
           errors___0.connect, errors___0.read, errors___0.write, errors___0.timeout);
  } else
  if (errors___0.read) {
    printf((char const   * __restrict  )"  Socket errors: connect %d, read %d, write %d, timeout %d\n",
           errors___0.connect, errors___0.read, errors___0.write, errors___0.timeout);
  } else
  if (errors___0.write) {
    printf((char const   * __restrict  )"  Socket errors: connect %d, read %d, write %d, timeout %d\n",
           errors___0.connect, errors___0.read, errors___0.write, errors___0.timeout);
  } else
  if (errors___0.timeout) {
    printf((char const   * __restrict  )"  Socket errors: connect %d, read %d, write %d, timeout %d\n",
           errors___0.connect, errors___0.read, errors___0.write, errors___0.timeout);
  }
  if (errors___0.status) {
    printf((char const   * __restrict  )"  Non-2xx or 3xx responses: %d\n", errors___0.status);
  }
  printf((char const   * __restrict  )"Requests/sec: %9.2Lf\n", req_per_s);
  tmp___22 = format_binary(bytes_per_s);
  printf((char const   * __restrict  )"Transfer/sec: %10sB\n", tmp___22);
  tmp___23 = script_has_done(L);
  if (tmp___23) {
    script_summary(L, runtime_us, complete, bytes);
    script_errors(L, & errors___0);
    script_done(L, statistics.latency, statistics.requests);
  }
  return (0);
}
}
static void *thread_main(void *arg ) 
{ 
  thread *thread___0 ;
  char *request ;
  size_t length ;
  void *tmp ;
  connection *c ;
  uint64_t i ;
  SSL *tmp___0 ;
  aeEventLoop *loop ;

  {
  thread___0 = (thread *)arg;
  request = (char *)((void *)0);
  length = (size_t )0;
  if (! cfg.dynamic) {
    script_request(thread___0->L, & request, & length);
  }
  tmp = zcalloc(thread___0->connections * sizeof(connection ));
  thread___0->cs = (struct connection *)tmp;
  c = thread___0->cs;
  i = (uint64_t )0;
  while (i < thread___0->connections) {
    c->thread = thread___0;
    if (cfg.ctx) {
      tmp___0 = SSL_new(cfg.ctx);
      c->ssl = tmp___0;
    } else {
      c->ssl = (SSL *)((void *)0);
    }
    c->request = request;
    c->length = length;
    c->delayed = cfg.delay;
    connect_socket(thread___0, c);
    i ++;
    c ++;
  }
  loop = thread___0->loop;
  aeCreateTimeEvent(loop, 100LL, & record_rate, (void *)thread___0, (aeEventFinalizerProc *)((void *)0));
  thread___0->start = time_us();
  aeMain(loop);
  aeDeleteEventLoop(loop);
  zfree((void *)thread___0->cs);
  return ((void *)0);
}
}
static int connect_socket(thread *thread___0 , connection *c ) 
{ 
  struct addrinfo *addr ;
  struct aeEventLoop *loop ;
  int fd ;
  int flags ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  addr = thread___0->addr;
  loop = thread___0->loop;
  fd = socket(addr->ai_family, addr->ai_socktype, addr->ai_protocol);
  flags = fcntl(fd, 3, 0);
  fcntl(fd, 4, flags | 2048);
  tmp___0 = connect(fd, (struct sockaddr  const  *)addr->ai_addr, addr->ai_addrlen);
  if (tmp___0 == -1) {
    tmp = __errno_location();
    if (*tmp != 115) {
      goto error;
    }
  }
  flags = 1;
  setsockopt(fd, 6, 1, (void const   *)(& flags), (socklen_t )sizeof(flags));
  flags = 3;
  tmp___1 = aeCreateFileEvent(loop, fd, flags, & socket_connected, (void *)c);
  if (tmp___1 == 0) {
    c->parser.data = (void *)c;
    c->fd = fd;
    return (fd);
  }
  error: 
  (thread___0->errors.connect) ++;
  close(fd);
  return (-1);
}
}
static int reconnect_socket(thread *thread___0 , connection *c ) 
{ 
  int tmp ;

  {
  aeDeleteFileEvent(thread___0->loop, c->fd, 3);
  (*(sock.close))(c);
  close(c->fd);
  tmp = connect_socket(thread___0, c);
  return (tmp);
}
}
static int record_rate(aeEventLoop *loop , long long id , void *data ) 
{ 
  thread *thread___0 ;
  uint64_t elapsed_ms ;
  uint64_t tmp ;
  uint64_t requests ;

  {
  thread___0 = (thread *)data;
  if (thread___0->requests > 0UL) {
    tmp = time_us();
    elapsed_ms = (tmp - thread___0->start) / 1000UL;
    requests = (uint64_t )(((double )thread___0->requests / (double )elapsed_ms) * (double )1000);
    stats_record(statistics.requests, requests);
    thread___0->requests = (uint64_t )0;
    thread___0->start = time_us();
  }
  if (stop) {
    aeStop(loop);
  }
  return (100);
}
}
static int delay_request(aeEventLoop *loop , long long id , void *data ) 
{ 
  connection *c ;

  {
  c = (connection *)data;
  c->delayed = (_Bool)0;
  aeCreateFileEvent(loop, c->fd, 2, & socket_writeable, (void *)c);
  return (-1);
}
}
static int header_field(http_parser *parser , char const   *at , size_t len ) 
{ 
  connection *c ;
  char *tmp ;

  {
  c = (connection *)parser->data;
  if ((unsigned int )c->state == 1U) {
    tmp = c->headers.cursor;
    (c->headers.cursor) ++;
    *tmp = (char )'\000';
    c->state = (enum __anonenum_state_47808738 )0;
  }
  buffer_append(& c->headers, at, len);
  return (0);
}
}
static int header_value(http_parser *parser , char const   *at , size_t len ) 
{ 
  connection *c ;
  char *tmp ;

  {
  c = (connection *)parser->data;
  if ((unsigned int )c->state == 0U) {
    tmp = c->headers.cursor;
    (c->headers.cursor) ++;
    *tmp = (char )'\000';
    c->state = (enum __anonenum_state_47808738 )1;
  }
  buffer_append(& c->headers, at, len);
  return (0);
}
}
static int response_body(http_parser *parser , char const   *at , size_t len ) 
{ 
  connection *c ;

  {
  c = (connection *)parser->data;
  buffer_append(& c->body, at, len);
  return (0);
}
}
static int response_complete(http_parser *parser ) 
{ 
  connection *c ;
  thread *thread___0 ;
  uint64_t now ;
  uint64_t tmp ;
  int status___0 ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  c = (connection *)parser->data;
  thread___0 = c->thread;
  tmp = time_us();
  now = tmp;
  status___0 = (int )parser->status_code;
  (thread___0->complete) ++;
  (thread___0->requests) ++;
  if (status___0 > 399) {
    (thread___0->errors.status) ++;
  }
  if (c->headers.buffer) {
    tmp___0 = c->headers.cursor;
    (c->headers.cursor) ++;
    *tmp___0 = (char )'\000';
    script_response(thread___0->L, status___0, & c->headers, & c->body);
    c->state = (enum __anonenum_state_47808738 )0;
  }
  (c->pending) --;
  if (c->pending == 0UL) {
    tmp___1 = stats_record(statistics.latency, now - c->start);
    if (! tmp___1) {
      (thread___0->errors.timeout) ++;
    }
    c->delayed = cfg.delay;
    aeCreateFileEvent(thread___0->loop, c->fd, 2, & socket_writeable, (void *)c);
  }
  tmp___2 = http_should_keep_alive((http_parser const   *)parser);
  if (! tmp___2) {
    reconnect_socket(thread___0, c);
    goto done;
  }
  http_parser_init(parser, (enum http_parser_type )1);
  done: 
  return (0);
}
}
static void socket_connected(aeEventLoop *loop , int fd , void *data , int mask ) 
{ 
  connection *c ;
  status tmp ;

  {
  c = (connection *)data;
  tmp = (*(sock.connect))(c, cfg.host);
  switch ((unsigned int )tmp) {
  case 0U: 
  break;
  case 1U: 
  goto error;
  case 2U: 
  return;
  }
  http_parser_init(& c->parser, (enum http_parser_type )1);
  c->written = (size_t )0;
  aeCreateFileEvent((c->thread)->loop, fd, 1, & socket_readable, (void *)c);
  aeCreateFileEvent((c->thread)->loop, fd, 2, & socket_writeable, (void *)c);
  return;
  error: 
  ((c->thread)->errors.connect) ++;
  reconnect_socket(c->thread, c);
  return;
}
}
static void socket_writeable(aeEventLoop *loop , int fd , void *data , int mask ) 
{ 
  connection *c ;
  thread *thread___0 ;
  uint64_t delay ;
  uint64_t tmp ;
  char *buf ;
  size_t len ;
  size_t n ;
  status tmp___0 ;

  {
  c = (connection *)data;
  thread___0 = c->thread;
  if (c->delayed) {
    tmp = script_delay(thread___0->L);
    delay = tmp;
    aeDeleteFileEvent(loop, fd, 2);
    aeCreateTimeEvent(loop, (long long )delay, & delay_request, (void *)c, (aeEventFinalizerProc *)((void *)0));
    return;
  }
  if (! c->written) {
    if (cfg.dynamic) {
      script_request(thread___0->L, & c->request, & c->length);
    }
    c->start = time_us();
    c->pending = cfg.pipeline;
  }
  buf = c->request + c->written;
  len = c->length - c->written;
  tmp___0 = (*(sock.write))(c, buf, len, & n);
  switch ((unsigned int )tmp___0) {
  case 0U: 
  break;
  case 1U: 
  goto error;
  case 2U: 
  return;
  }
  c->written += n;
  if (c->written == c->length) {
    c->written = (size_t )0;
    aeDeleteFileEvent(loop, fd, 2);
  }
  return;
  error: 
  (thread___0->errors.write) ++;
  reconnect_socket(thread___0, c);
  return;
}
}
static void socket_readable(aeEventLoop *loop , int fd , void *data , int mask ) 
{ 
  connection *c ;
  size_t n ;
  status tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
  c = (connection *)data;
  while (1) {
    tmp = (*(sock.read))(c, & n);
    switch ((unsigned int )tmp) {
    case 0U: 
    break;
    case 1U: 
    goto error;
    case 2U: 
    return;
    }
    tmp___0 = http_parser_execute(& c->parser, (http_parser_settings const   *)(& parser_settings),
                                  (char const   *)(c->buf), n);
    if (tmp___0 != n) {
      goto error;
    }
    if (n == 0UL) {
      tmp___1 = http_body_is_final((http_parser const   *)(& c->parser));
      if (! tmp___1) {
        goto error;
      }
    }
    (c->thread)->bytes += n;
    if (n == 8192UL) {
      tmp___2 = (*(sock.readable))(c);
      if (! (tmp___2 > 0UL)) {
        break;
      }
    } else {
      break;
    }
  }
  return;
  error: 
  ((c->thread)->errors.read) ++;
  reconnect_socket(c->thread, c);
  return;
}
}
static uint64_t time_us(void) 
{ 
  struct timeval t ;

  {
  gettimeofday((struct timeval * __restrict  )(& t), (void * __restrict  )((void *)0));
  return ((uint64_t )(t.tv_sec * 1000000L + t.tv_usec));
}
}
static char *copy_url_part(char *url , struct http_parser_url *parts , enum http_parser_url_fields field ) 
{ 
  char *part ;
  uint16_t off ;
  uint16_t len ;
  void *tmp ;

  {
  part = (char *)((void *)0);
  if ((int )parts->field_set & (1 << (unsigned int )field)) {
    off = parts->field_data[field].off;
    len = parts->field_data[field].len;
    tmp = zcalloc((unsigned long )len + sizeof(char ));
    part = (char *)tmp;
    memcpy((void * __restrict  )part, (void const   * __restrict  )(url + off), (size_t )len);
  }
  return (part);
}
}
static struct option longopts[10]  = 
  {      {"connections", 1, (int *)((void *)0), 'c'}, 
        {"duration", 1, (int *)((void *)0), 'd'}, 
        {"threads", 1, (int *)((void *)0), 't'}, 
        {"script", 1, (int *)((void *)0), 's'}, 
        {"header", 1, (int *)((void *)0), 'H'}, 
        {"latency", 0, (int *)((void *)0), 'L'}, 
        {"timeout", 1, (int *)((void *)0), 'T'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"version", 0, (int *)((void *)0), 'v'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
static int parse_args(struct config *cfg___0 , char **url , struct http_parser_url *parts ,
                      char **headers , int argc , char **argv ) 
{ 
  char **header ;
  int c ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char **tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  header = headers;
  memset((void *)cfg___0, 0, sizeof(struct config ));
  cfg___0->threads = (uint64_t )2;
  cfg___0->connections = (uint64_t )10;
  cfg___0->duration = (uint64_t )10;
  cfg___0->timeout = (uint64_t )2000;
  while (1) {
    c = getopt_long(argc, (char * const  *)argv, "t:c:d:s:H:T:Lrv?", (struct option  const  *)(longopts),
                    (int *)((void *)0));
    if (! (c != -1)) {
      break;
    }
    switch (c) {
    case 116: 
    tmp = scan_metric(optarg, & cfg___0->threads);
    if (tmp) {
      return (-1);
    }
    break;
    case 99: 
    tmp___0 = scan_metric(optarg, & cfg___0->connections);
    if (tmp___0) {
      return (-1);
    }
    break;
    case 100: 
    tmp___1 = scan_time(optarg, & cfg___0->duration);
    if (tmp___1) {
      return (-1);
    }
    break;
    case 115: 
    cfg___0->script = optarg;
    break;
    case 72: 
    tmp___2 = header;
    header ++;
    *tmp___2 = optarg;
    break;
    case 76: 
    cfg___0->latency = (_Bool)1;
    break;
    case 84: 
    tmp___3 = scan_time(optarg, & cfg___0->timeout);
    if (tmp___3) {
      return (-1);
    }
    cfg___0->timeout *= 1000UL;
    break;
    case 118: 
    tmp___4 = aeGetApiName();
    printf((char const   * __restrict  )"wrk %s [%s] ", VERSION, tmp___4);
    printf((char const   * __restrict  )"Copyright (C) 2012 Will Glozer\n");
    break;
    default: 
    return (-1);
    }
  }
  if (optind == argc) {
    return (-1);
  } else
  if (! cfg___0->threads) {
    return (-1);
  } else
  if (! cfg___0->duration) {
    return (-1);
  }
  tmp___5 = script_parse_url(*(argv + optind), parts);
  if (! tmp___5) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"invalid URL: %s\n",
            *(argv + optind));
    return (-1);
  }
  if (! cfg___0->connections) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"number of connections must be >= threads\n");
    return (-1);
  } else
  if (cfg___0->connections < cfg___0->threads) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"number of connections must be >= threads\n");
    return (-1);
  }
  *url = *(argv + optind);
  *header = (char *)((void *)0);
  return (0);
}
}
static void print_stats_header(void) 
{ 


  {
  printf((char const   * __restrict  )"  Thread Stats%6s%11s%8s%12s\n", "Avg", "Stdev",
         "Max", "+/- Stdev");
  return;
}
}
static void print_units(long double n , char *(*fmt)(long double  ) , int width ) 
{ 
  char *msg ;
  char *tmp ;
  int len ;
  size_t tmp___0 ;
  int pad ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  tmp = (*fmt)(n);
  msg = tmp;
  tmp___0 = strlen((char const   *)msg);
  len = (int )tmp___0;
  pad = 2;
  tmp___1 = __ctype_b_loc();
  if ((int const   )*(*tmp___1 + (int )*(msg + (len - 1))) & 1024) {
    pad --;
  }
  tmp___2 = __ctype_b_loc();
  if ((int const   )*(*tmp___2 + (int )*(msg + (len - 2))) & 1024) {
    pad --;
  }
  width -= pad;
  printf((char const   * __restrict  )"%*.*s%.*s", width, width, msg, pad, "  ");
  free((void *)msg);
  return;
}
}
static void print_stats(char *name , stats *stats___0 , char *(*fmt)(long double  ) ) 
{ 
  uint64_t max ;
  long double mean ;
  long double tmp ;
  long double stdev ;
  long double tmp___0 ;
  long double tmp___1 ;

  {
  max = stats___0->max;
  tmp = stats_mean(stats___0);
  mean = tmp;
  tmp___0 = stats_stdev(stats___0, mean);
  stdev = tmp___0;
  printf((char const   * __restrict  )"    %-10s", name);
  print_units(mean, fmt, 8);
  print_units(stdev, fmt, 10);
  print_units((long double )max, fmt, 9);
  tmp___1 = stats_within_stdev(stats___0, mean, stdev, (uint64_t )1);
  printf((char const   * __restrict  )"%8.2Lf%%\n", tmp___1);
  return;
}
}
static void print_stats_latency(stats *stats___0 ) 
{ 
  long double percentiles[4] ;
  size_t i ;
  long double p ;
  uint64_t n ;
  uint64_t tmp ;

  {
  percentiles[0] = (long double )50.0;
  percentiles[1] = (long double )75.0;
  percentiles[2] = (long double )90.0;
  percentiles[3] = (long double )99.0;
  printf((char const   * __restrict  )"  Latency Distribution\n");
  i = (size_t )0;
  while (i < sizeof(percentiles) / sizeof(long double )) {
    p = percentiles[i];
    tmp = stats_percentile(stats___0, p);
    n = tmp;
    printf((char const   * __restrict  )"%7.0Lf%%", p);
    print_units((long double )n, & format_time_us, 10);
    printf((char const   * __restrict  )"\n");
    i ++;
  }
  return;
}
}
#pragma merger("0","/tmp/cil-kXOVwQtH.i","-std=c99,-Wall,-O2")
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
status sock_connect(connection *c , char *host ) 
{ 


  {
  return ((status )0);
}
}
status sock_close(connection *c ) 
{ 


  {
  return ((status )0);
}
}
status sock_read(connection *c , size_t *n ) 
{ 
  ssize_t r ;
  ssize_t tmp ;
  int tmp___0 ;

  {
  tmp = read(c->fd, (void *)(c->buf), sizeof(c->buf));
  r = tmp;
  *n = (size_t )r;
  if (r >= 0L) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  return ((status )tmp___0);
}
}
status sock_write(connection *c , char *buf , size_t len , size_t *n ) 
{ 
  ssize_t r ;
  int *tmp ;

  {
  r = write(c->fd, (void const   *)buf, len);
  if (r == -1L) {
    tmp = __errno_location();
    switch (*tmp) {
    case 11: 
    return ((status )2);
    default: 
    return ((status )1);
    }
  }
  *n = (size_t )r;
  return ((status )0);
}
}
size_t sock_readable(connection *c ) 
{ 
  int n ;
  int rc ;
  int tmp ;

  {
  rc = ioctl(c->fd, 21531UL, & n);
  if (rc == -1) {
    tmp = 0;
  } else {
    tmp = n;
  }
  return ((size_t )tmp);
}
}
#pragma merger("0","/tmp/cil-tPFi4ojc.i","-std=c99,-Wall,-O2")
extern int OPENSSL_init_crypto(uint64_t opts , OPENSSL_INIT_SETTINGS const   *settings ) ;
extern SSL_CTX *SSL_CTX_new(SSL_METHOD const   *meth ) ;
extern int SSL_clear(SSL *s ) ;
extern int SSL_pending(SSL const   *s ) ;
extern int SSL_set_fd(SSL *s , int fd ) ;
extern void SSL_CTX_set_verify(SSL_CTX *ctx , int mode , int (*callback)(int preverify_ok ,
                                                                         X509_STORE_CTX *x509_ctx ) ) ;
extern void SSL_CTX_set_verify_depth(SSL_CTX *ctx , int depth ) ;
extern int SSL_connect(SSL *ssl ) ;
extern int SSL_read(SSL *ssl , void *buf , int num ) ;
extern int SSL_write(SSL *ssl , void const   *buf , int num ) ;
extern long SSL_ctrl(SSL *ssl , int cmd , long larg , void *parg ) ;
extern long SSL_CTX_ctrl(SSL_CTX *ctx , int cmd , long larg , void *parg ) ;
extern int SSL_get_error(SSL const   *s , int ret_code ) ;
extern SSL_METHOD const   *TLS_client_method(void) ;
extern int SSL_shutdown(SSL *s ) ;
extern int OPENSSL_init_ssl(uint64_t opts , OPENSSL_INIT_SETTINGS const   *settings ) ;
SSL_CTX *ssl_init(void) 
{ 
  SSL_CTX *ctx ;
  SSL_METHOD const   *tmp ;

  {
  ctx = (SSL_CTX *)((void *)0);
  OPENSSL_init_ssl((uint64_t )2097154L, (OPENSSL_INIT_SETTINGS const   *)((void *)0));
  OPENSSL_init_ssl((uint64_t )0, (OPENSSL_INIT_SETTINGS const   *)((void *)0));
  OPENSSL_init_crypto((uint64_t )12L, (OPENSSL_INIT_SETTINGS const   *)((void *)0));
  tmp = TLS_client_method();
  ctx = SSL_CTX_new(tmp);
  if (ctx) {
    SSL_CTX_set_verify(ctx, 0, (int (*)(int preverify_ok , X509_STORE_CTX *x509_ctx ))((void *)0));
    SSL_CTX_set_verify_depth(ctx, 0);
    SSL_CTX_ctrl(ctx, 33, 4L, (void *)0);
    SSL_CTX_ctrl(ctx, 44, 1L, (void *)0);
  }
  return (ctx);
}
}
status ssl_connect(connection *c , char *host ) 
{ 
  int r ;
  int tmp ;

  {
  SSL_set_fd(c->ssl, c->fd);
  SSL_ctrl(c->ssl, 55, 0L, (void *)host);
  r = SSL_connect(c->ssl);
  if (r != 1) {
    tmp = SSL_get_error((SSL const   *)c->ssl, r);
    switch (tmp) {
    case 2: 
    return ((status )2);
    case 3: 
    return ((status )2);
    default: 
    return ((status )1);
    }
  }
  return ((status )0);
}
}
status ssl_close(connection *c ) 
{ 


  {
  SSL_shutdown(c->ssl);
  SSL_clear(c->ssl);
  return ((status )0);
}
}
status ssl_read(connection *c , size_t *n ) 
{ 
  int r ;
  int tmp ;

  {
  r = SSL_read(c->ssl, (void *)(c->buf), (int )sizeof(c->buf));
  if (r <= 0) {
    tmp = SSL_get_error((SSL const   *)c->ssl, r);
    switch (tmp) {
    case 2: 
    return ((status )2);
    case 3: 
    return ((status )2);
    default: 
    return ((status )1);
    }
  }
  *n = (size_t )r;
  return ((status )0);
}
}
status ssl_write(connection *c , char *buf , size_t len , size_t *n ) 
{ 
  int r ;
  int tmp ;

  {
  r = SSL_write(c->ssl, (void const   *)buf, (int )len);
  if (r <= 0) {
    tmp = SSL_get_error((SSL const   *)c->ssl, r);
    switch (tmp) {
    case 2: 
    return ((status )2);
    case 3: 
    return ((status )2);
    default: 
    return ((status )1);
    }
  }
  *n = (size_t )r;
  return ((status )0);
}
}
size_t ssl_readable(connection *c ) 
{ 
  int tmp ;

  {
  tmp = SSL_pending((SSL const   *)c->ssl);
  return ((size_t )tmp);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#pragma merger("0","/tmp/cil-Wvn64wZR.i","-std=c99,-Wall,-O2")
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
char *aprintf(char **s , char const   *fmt  , ...) 
{ 
  char *c ;
  int n ;
  int len ;
  va_list___0 ap ;
  int tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;

  {
  c = (char *)((void *)0);
  __builtin_va_start(ap, fmt);
  tmp = vsnprintf((char * __restrict  )((void *)0), (size_t )0, (char const   * __restrict  )fmt,
                  ap);
  n = tmp + 1;
  __builtin_va_end(ap);
  if (*s) {
    tmp___0 = strlen((char const   *)*s);
    len = (int )tmp___0;
  } else {
    len = 0;
  }
  tmp___2 = realloc((void *)*s, (unsigned long )(len + n) * sizeof(char ));
  tmp___1 = (char *)tmp___2;
  *s = tmp___1;
  if (tmp___1) {
    c = *s + len;
    __builtin_va_start(ap, fmt);
    vsnprintf((char * __restrict  )c, (size_t )n, (char const   * __restrict  )fmt,
              ap);
    __builtin_va_end(ap);
  }
  return (c);
}
}
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_val_compare_and_swap(...) ;  */
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_add(...) ;  */
#pragma merger("0","/tmp/cil-w9tj1ijD.i","-std=c99,-Wall,-O2")
extern  __attribute__((__nothrow__)) double round(double __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) long double powl(long double __x , long double __y ) ;
extern  __attribute__((__nothrow__)) long double sqrtl(long double __x ) ;
void stats_free(stats *stats___0 ) ;
uint64_t stats_popcount(stats *stats___0 ) ;
uint64_t stats_value_at(stats *stats___0 , uint64_t index , uint64_t *count ) ;
stats *stats_alloc(uint64_t max ) 
{ 
  uint64_t limit ;
  stats *s ;
  void *tmp ;

  {
  limit = max + 1UL;
  tmp = zcalloc(sizeof(stats ) + sizeof(uint64_t ) * limit);
  s = (stats *)tmp;
  s->limit = limit;
  s->min = 18446744073709551615;
  return (s);
}
}
void stats_free(stats *stats___0 ) 
{ 


  {
  zfree((void *)stats___0);
  return;
}
}
int stats_record(stats *stats___0 , uint64_t n ) 
{ 
  uint64_t min ;
  uint64_t max ;

  {
  if (n >= stats___0->limit) {
    return (0);
  }
  __sync_fetch_and_add(& stats___0->data[n], 1);
  __sync_fetch_and_add(& stats___0->count, 1);
  min = stats___0->min;
  max = stats___0->max;
  while (n < min) {
    min = (uint64_t )__sync_val_compare_and_swap(& stats___0->min, min, n);
  }
  while (n > max) {
    max = (uint64_t )__sync_val_compare_and_swap(& stats___0->max, max, n);
  }
  return (1);
}
}
void stats_correct(stats *stats___0 , int64_t expected ) 
{ 
  uint64_t n ;
  uint64_t count ;
  int64_t m ;

  {
  n = (uint64_t )(expected * 2L);
  while (n <= stats___0->max) {
    count = stats___0->data[n];
    m = (int64_t )n - expected;
    while (1) {
      if (count) {
        if (! (m > expected)) {
          break;
        }
      } else {
        break;
      }
      stats___0->data[m] += count;
      stats___0->count += count;
      m -= expected;
    }
    n ++;
  }
  return;
}
}
long double stats_mean(stats *stats___0 ) 
{ 
  uint64_t sum ;
  uint64_t i ;

  {
  if (stats___0->count == 0UL) {
    return ((long double )0.0);
  }
  sum = (uint64_t )0;
  i = stats___0->min;
  while (i <= stats___0->max) {
    sum += stats___0->data[i] * i;
    i ++;
  }
  return ((long double )sum / (long double )stats___0->count);
}
}
long double stats_stdev(stats *stats___0 , long double mean ) 
{ 
  long double sum ;
  uint64_t i ;
  long double tmp ;
  long double tmp___0 ;

  {
  sum = (long double )0.0;
  if (stats___0->count < 2UL) {
    return ((long double )0.0);
  }
  i = stats___0->min;
  while (i <= stats___0->max) {
    if (stats___0->data[i]) {
      tmp = powl((long double )i - mean, (long double )2);
      sum += tmp * (long double )stats___0->data[i];
    }
    i ++;
  }
  tmp___0 = sqrtl(sum / (long double )(stats___0->count - 1UL));
  return (tmp___0);
}
}
long double stats_within_stdev(stats *stats___0 , long double mean , long double stdev ,
                               uint64_t n ) 
{ 
  long double upper ;
  long double lower ;
  uint64_t sum ;
  uint64_t i ;

  {
  upper = mean + stdev * (long double )n;
  lower = mean - stdev * (long double )n;
  sum = (uint64_t )0;
  i = stats___0->min;
  while (i <= stats___0->max) {
    if ((long double )i >= lower) {
      if ((long double )i <= upper) {
        sum += stats___0->data[i];
      }
    }
    i ++;
  }
  return (((long double )sum / (long double )stats___0->count) * (long double )100);
}
}
uint64_t stats_percentile(stats *stats___0 , long double p ) 
{ 
  uint64_t rank ;
  double tmp ;
  uint64_t total ;
  uint64_t i ;

  {
  tmp = round((double )((p / (long double )100.0) * (long double )stats___0->count + (long double )0.5));
  rank = (uint64_t )tmp;
  total = (uint64_t )0;
  i = stats___0->min;
  while (i <= stats___0->max) {
    total += stats___0->data[i];
    if (total >= rank) {
      return (i);
    }
    i ++;
  }
  return ((uint64_t )0);
}
}
uint64_t stats_popcount(stats *stats___0 ) 
{ 
  uint64_t count ;
  uint64_t i ;

  {
  count = (uint64_t )0;
  i = stats___0->min;
  while (i <= stats___0->max) {
    if (stats___0->data[i]) {
      count ++;
    }
    i ++;
  }
  return (count);
}
}
uint64_t stats_value_at(stats *stats___0 , uint64_t index , uint64_t *count ) 
{ 
  uint64_t i ;
  uint64_t tmp ;

  {
  *count = (uint64_t )0;
  i = stats___0->min;
  while (i <= stats___0->max) {
    if (stats___0->data[i]) {
      tmp = *count;
      (*count) ++;
      if (tmp == index) {
        *count = stats___0->data[i];
        return (i);
      }
    }
    i ++;
  }
  return ((uint64_t )0);
}
}
#pragma merger("0","/tmp/cil-bGK6AheC.i","-std=c99,-Wall,-O2")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
extern void lua_settop(lua_State *L , int idx ) ;
extern void lua_pushvalue(lua_State *L , int idx ) ;
extern int lua_type(lua_State *L , int idx ) ;
extern char const   *lua_typename(lua_State *L , int tp ) ;
extern lua_Number lua_tonumber(lua_State *L , int idx ) ;
extern int lua_toboolean(lua_State *L , int idx ) ;
extern char const   *lua_tolstring(lua_State *L , int idx , size_t *len ) ;
extern size_t lua_objlen(lua_State *L , int idx ) ;
extern void lua_pushnil(lua_State *L ) ;
extern void lua_pushnumber(lua_State *L , lua_Number n ) ;
extern void lua_pushinteger(lua_State *L , lua_Integer n ) ;
extern void lua_pushlstring(lua_State *L , char const   *s , size_t l ) ;
extern void lua_pushstring(lua_State *L , char const   *s ) ;
extern char const   *lua_pushfstring(lua_State *L , char const   *fmt  , ...) ;
extern void lua_pushcclosure(lua_State *L , int (*fn)(lua_State *L ) , int n ) ;
extern void lua_pushboolean(lua_State *L , int b ) ;
extern void lua_getfield(lua_State *L , int idx , char const   *k ) ;
extern void lua_createtable(lua_State *L , int narr , int nrec ) ;
extern void *lua_newuserdata(lua_State *L , size_t sz ) ;
extern void lua_settable(lua_State *L , int idx ) ;
extern void lua_setfield(lua_State *L , int idx , char const   *k ) ;
extern void lua_rawset(lua_State *L , int idx ) ;
extern void lua_rawseti(lua_State *L , int idx , int n ) ;
extern int lua_setmetatable(lua_State *L , int objindex ) ;
extern void lua_call(lua_State *L , int nargs , int nresults ) ;
extern int lua_pcall(lua_State *L , int nargs , int nresults , int errfunc ) ;
extern int lua_next(lua_State *L , int idx ) ;
extern void luaL_openlibs(lua_State *L ) ;
extern void luaL_register(lua_State *L , char const   *libname , luaL_Reg const   *l ) ;
extern int luaL_argerror(lua_State *L , int numarg , char const   *extramsg ) ;
extern lua_Number luaL_checknumber(lua_State *L , int numArg ) ;
extern int luaL_newmetatable(lua_State *L , char const   *tname ) ;
extern void *luaL_checkudata(lua_State *L , int ud , char const   *tname ) ;
extern int luaL_error(lua_State *L , char const   *fmt  , ...) ;
extern int luaL_loadfile(lua_State *L , char const   *filename ) ;
extern int luaL_loadstring(lua_State *L , char const   *s ) ;
extern lua_State *luaL_newstate(void) ;
extern void luaL_pushresult(luaL_Buffer *B ) ;
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , int __flags ) ;
char const   *http_errno_description(enum http_errno err ) ;
int http_parser_parse_url(char const   *buf , size_t buflen , int is_connect , struct http_parser_url *u ) ;
void script_copy_value(lua_State *src , lua_State *dst , int index___0 ) ;
void buffer_reset(buffer *b ) ;
char *buffer_pushlstring(lua_State *L , char *start ) ;
void *zrealloc(void *ptr , size_t size ) ;
static int script_addr_tostring(lua_State *L ) ;
static int script_addr_gc(lua_State *L ) ;
static int script_stats_call(lua_State *L ) ;
static int script_stats_len(lua_State *L ) ;
static int script_stats_index(lua_State *L ) ;
static int script_thread_index(lua_State *L ) ;
static int script_thread_newindex(lua_State *L ) ;
static int script_wrk_lookup(lua_State *L ) ;
static int script_wrk_connect(lua_State *L ) ;
static void set_fields(lua_State *L , int index___0 , table_field const   *fields ) ;
static void set_field(lua_State *L , int index___0 , char *field , int type ) ;
static int push_url_part(lua_State *L , char *url , struct http_parser_url *parts ,
                         enum http_parser_url_fields field ) ;
static struct luaL_Reg  const  addrlib[3]  = {      {"__tostring", & script_addr_tostring}, 
        {"__gc", & script_addr_gc}, 
        {(char const   *)((void *)0), (int (*)(lua_State *L ))((void *)0)}};
static struct luaL_Reg  const  statslib[4]  = {      {"__call", & script_stats_call}, 
        {"__index", & script_stats_index}, 
        {"__len", & script_stats_len}, 
        {(char const   *)((void *)0), (int (*)(lua_State *L ))((void *)0)}};
static struct luaL_Reg  const  threadlib[3]  = {      {"__index", & script_thread_index}, 
        {"__newindex", & script_thread_newindex}, 
        {(char const   *)((void *)0), (int (*)(lua_State *L ))((void *)0)}};
lua_State *script_create(char *file , char *url , char **headers ) 
{ 
  lua_State *L ;
  lua_State *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct http_parser_url parts ;
  char *path ;
  table_field fields[4] ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char **h ;
  char *p ;
  char *tmp___6 ;
  char const   *cause ;
  char const   *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  tmp = luaL_newstate();
  L = tmp;
  luaL_openlibs(L);
  tmp___0 = luaL_loadstring(L, "wrk = require \"wrk\"");
  if (tmp___0) {
    tmp___2 = 1;
  } else {
    tmp___1 = lua_pcall(L, 0, -1, 0);
    if (tmp___1) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
  }
  luaL_newmetatable(L, "wrk.addr");
  luaL_register(L, (char const   *)((void *)0), addrlib);
  luaL_newmetatable(L, "wrk.stats");
  luaL_register(L, (char const   *)((void *)0), statslib);
  luaL_newmetatable(L, "wrk.thread");
  luaL_register(L, (char const   *)((void *)0), threadlib);
  parts.field_set = (uint16_t )0;
  parts.port = (unsigned short)0;
  parts.field_data[0].off = (unsigned short)0;
  parts.field_data[0].len = (unsigned short)0;
  parts.field_data[1].off = (unsigned short)0;
  parts.field_data[1].len = (unsigned short)0;
  parts.field_data[2].off = (unsigned short)0;
  parts.field_data[2].len = (unsigned short)0;
  parts.field_data[3].off = (unsigned short)0;
  parts.field_data[3].len = (unsigned short)0;
  parts.field_data[4].off = (unsigned short)0;
  parts.field_data[4].len = (unsigned short)0;
  parts.field_data[5].off = (unsigned short)0;
  parts.field_data[5].len = (unsigned short)0;
  parts.field_data[6].off = (unsigned short)0;
  parts.field_data[6].len = (unsigned short)0;
  script_parse_url(url, & parts);
  path = (char *)"/";
  if ((int )parts.field_set & (1 << 3)) {
    path = url + parts.field_data[3].off;
  }
  fields[0].name = (char *)"lookup";
  fields[0].type = 6;
  fields[0].value = (void *)(& script_wrk_lookup);
  fields[1].name = (char *)"connect";
  fields[1].type = 6;
  fields[1].value = (void *)(& script_wrk_connect);
  fields[2].name = (char *)"path";
  fields[2].type = 4;
  fields[2].value = (void *)path;
  fields[3].name = (char *)((void *)0);
  fields[3].type = 0;
  fields[3].value = (void *)0;
  lua_getfield(L, -10002, "wrk");
  tmp___3 = push_url_part(L, url, & parts, (enum http_parser_url_fields )0);
  set_field(L, 4, (char *)"scheme", tmp___3);
  tmp___4 = push_url_part(L, url, & parts, (enum http_parser_url_fields )1);
  set_field(L, 4, (char *)"host", tmp___4);
  tmp___5 = push_url_part(L, url, & parts, (enum http_parser_url_fields )2);
  set_field(L, 4, (char *)"port", tmp___5);
  set_fields(L, 4, (table_field const   *)(fields));
  lua_getfield(L, 4, "headers");
  h = headers;
  while (*h) {
    tmp___6 = strchr((char const   *)*h, ':');
    p = tmp___6;
    if (p) {
      if ((int )*(p + 1) == 32) {
        lua_pushlstring(L, (char const   *)*h, (size_t )(p - *h));
        lua_pushstring(L, (char const   *)(p + 2));
        lua_settable(L, 5);
      }
    }
    h ++;
  }
  lua_settop(L, -6);
  if (file) {
    tmp___8 = luaL_loadfile(L, (char const   *)file);
    if (tmp___8) {
      tmp___7 = lua_tolstring(L, -1, (size_t *)((void *)0));
      cause = tmp___7;
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s\n",
              file, cause);
    } else {
      tmp___9 = lua_pcall(L, 0, -1, 0);
      if (tmp___9) {
        tmp___7 = lua_tolstring(L, -1, (size_t *)((void *)0));
        cause = tmp___7;
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s\n",
                file, cause);
      }
    }
  }
  return (L);
}
}
_Bool script_resolve(lua_State *L , char *host , char *service ) 
{ 
  size_t count ;
  size_t tmp ;

  {
  lua_getfield(L, -10002, "wrk");
  lua_getfield(L, -1, "resolve");
  lua_pushstring(L, (char const   *)host);
  lua_pushstring(L, (char const   *)service);
  lua_call(L, 2, 0);
  lua_getfield(L, -1, "addrs");
  tmp = lua_objlen(L, -1);
  count = tmp;
  lua_settop(L, -3);
  return ((_Bool )(count > 0UL));
}
}
void script_push_thread(lua_State *L , thread *t ) 
{ 
  thread **ptr ;
  void *tmp ;

  {
  tmp = lua_newuserdata(L, sizeof(thread **));
  ptr = (thread **)tmp;
  *ptr = t;
  lua_getfield(L, -10000, "wrk.thread");
  lua_setmetatable(L, -2);
  return;
}
}
void script_init(lua_State *L , thread *t , int argc , char **argv ) 
{ 
  int i ;

  {
  lua_getfield(t->L, -10002, "wrk");
  script_push_thread(t->L, t);
  lua_setfield(t->L, -2, "thread");
  lua_getfield(L, -10002, "wrk");
  lua_getfield(L, -1, "setup");
  script_push_thread(L, t);
  lua_call(L, 1, 0);
  lua_settop(L, -2);
  lua_getfield(t->L, -1, "init");
  lua_createtable(t->L, 0, 0);
  i = 0;
  while (i < argc) {
    lua_pushstring(t->L, (char const   *)*(argv + i));
    lua_rawseti(t->L, -2, i);
    i ++;
  }
  lua_call(t->L, 1, 0);
  lua_settop(t->L, -2);
  return;
}
}
uint64_t script_delay(lua_State *L ) 
{ 
  uint64_t delay ;
  lua_Number tmp ;

  {
  lua_getfield(L, -10002, "delay");
  lua_call(L, 0, 1);
  tmp = lua_tonumber(L, -1);
  delay = (uint64_t )tmp;
  lua_settop(L, -2);
  return (delay);
}
}
void script_request(lua_State *L , char **buf , size_t *len ) 
{ 
  int pop ;
  int tmp ;
  char const   *str ;
  char const   *tmp___0 ;
  void *tmp___1 ;

  {
  pop = 1;
  lua_getfield(L, -10002, "request");
  tmp = lua_type(L, -1);
  if (! (tmp == 6)) {
    lua_getfield(L, -10002, "wrk");
    lua_getfield(L, -1, "request");
    pop += 2;
  }
  lua_call(L, 0, 1);
  tmp___0 = lua_tolstring(L, -1, len);
  str = tmp___0;
  tmp___1 = realloc((void *)*buf, *len);
  *buf = (char *)tmp___1;
  memcpy((void * __restrict  )*buf, (void const   * __restrict  )str, *len);
  lua_settop(L, - pop - 1);
  return;
}
}
void script_response(lua_State *L , int status , buffer *headers , buffer *body ) 
{ 
  char *c ;

  {
  lua_getfield(L, -10002, "response");
  lua_pushinteger(L, (lua_Integer )status);
  lua_createtable(L, 0, 0);
  c = headers->buffer;
  while ((unsigned long )c < (unsigned long )headers->cursor) {
    c = buffer_pushlstring(L, c);
    c = buffer_pushlstring(L, c);
    lua_rawset(L, -3);
  }
  lua_pushlstring(L, (char const   *)body->buffer, (size_t )(body->cursor - body->buffer));
  lua_call(L, 3, 0);
  buffer_reset(headers);
  buffer_reset(body);
  return;
}
}
_Bool script_is_function(lua_State *L , char *name ) 
{ 
  _Bool is_function ;
  int tmp ;

  {
  lua_getfield(L, -10002, (char const   *)name);
  tmp = lua_type(L, -1);
  is_function = (_Bool )(tmp == 6);
  lua_settop(L, -2);
  return (is_function);
}
}
_Bool script_is_static(lua_State *L ) 
{ 
  _Bool tmp ;
  int tmp___0 ;

  {
  tmp = script_is_function(L, (char *)"request");
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  return ((_Bool )tmp___0);
}
}
_Bool script_want_response(lua_State *L ) 
{ 
  _Bool tmp ;

  {
  tmp = script_is_function(L, (char *)"response");
  return (tmp);
}
}
_Bool script_has_delay(lua_State *L ) 
{ 
  _Bool tmp ;

  {
  tmp = script_is_function(L, (char *)"delay");
  return (tmp);
}
}
_Bool script_has_done(lua_State *L ) 
{ 
  _Bool tmp ;

  {
  tmp = script_is_function(L, (char *)"done");
  return (tmp);
}
}
void script_header_done(lua_State *L , luaL_Buffer *buffer___0 ) 
{ 


  {
  luaL_pushresult(buffer___0);
  return;
}
}
void script_summary(lua_State *L , uint64_t duration , uint64_t requests , uint64_t bytes ) 
{ 
  table_field fields[4] ;

  {
  fields[0].name = (char *)"duration";
  fields[0].type = 3;
  fields[0].value = (void *)(& duration);
  fields[1].name = (char *)"requests";
  fields[1].type = 3;
  fields[1].value = (void *)(& requests);
  fields[2].name = (char *)"bytes";
  fields[2].type = 3;
  fields[2].value = (void *)(& bytes);
  fields[3].name = (char *)((void *)0);
  fields[3].type = 0;
  fields[3].value = (void *)0;
  lua_createtable(L, 0, 0);
  set_fields(L, 1, (table_field const   *)(fields));
  return;
}
}
void script_errors(lua_State *L , errors *errors___0 ) 
{ 
  uint64_t e[5] ;
  table_field fields[6] ;

  {
  e[0] = (uint64_t )errors___0->connect;
  e[1] = (uint64_t )errors___0->read;
  e[2] = (uint64_t )errors___0->write;
  e[3] = (uint64_t )errors___0->status;
  e[4] = (uint64_t )errors___0->timeout;
  fields[0].name = (char *)"connect";
  fields[0].type = 3;
  fields[0].value = (void *)(& e[0]);
  fields[1].name = (char *)"read";
  fields[1].type = 3;
  fields[1].value = (void *)(& e[1]);
  fields[2].name = (char *)"write";
  fields[2].type = 3;
  fields[2].value = (void *)(& e[2]);
  fields[3].name = (char *)"status";
  fields[3].type = 3;
  fields[3].value = (void *)(& e[3]);
  fields[4].name = (char *)"timeout";
  fields[4].type = 3;
  fields[4].value = (void *)(& e[4]);
  fields[5].name = (char *)((void *)0);
  fields[5].type = 0;
  fields[5].value = (void *)0;
  lua_createtable(L, 0, 0);
  set_fields(L, 2, (table_field const   *)(fields));
  lua_setfield(L, 1, "errors");
  return;
}
}
void script_push_stats(lua_State *L , stats *s ) 
{ 
  stats **ptr ;
  void *tmp ;

  {
  tmp = lua_newuserdata(L, sizeof(stats **));
  ptr = (stats **)tmp;
  *ptr = s;
  lua_getfield(L, -10000, "wrk.stats");
  lua_setmetatable(L, -2);
  return;
}
}
void script_done(lua_State *L , stats *latency , stats *requests ) 
{ 


  {
  lua_getfield(L, -10002, "done");
  lua_pushvalue(L, 1);
  script_push_stats(L, latency);
  script_push_stats(L, requests);
  lua_call(L, 3, 0);
  lua_settop(L, -2);
  return;
}
}
static int verify_request(http_parser *parser ) 
{ 
  size_t *count ;

  {
  count = (size_t *)parser->data;
  (*count) ++;
  return (0);
}
}
size_t script_verify_request(lua_State *L ) 
{ 
  http_parser_settings settings ;
  http_parser parser ;
  char *request ;
  size_t len ;
  size_t count ;
  size_t parsed ;
  size_t tmp ;
  enum http_errno err ;
  char const   *desc ;
  char const   *tmp___0 ;
  char const   *msg ;
  char const   *tmp___1 ;
  int line ;
  int column ;
  char *c ;

  {
  settings.on_message_begin = (int (*)(http_parser * ))0;
  settings.on_url = (int (*)(http_parser * , char const   *at , size_t length ))0;
  settings.on_status = (int (*)(http_parser * , char const   *at , size_t length ))0;
  settings.on_header_field = (int (*)(http_parser * , char const   *at , size_t length ))0;
  settings.on_header_value = (int (*)(http_parser * , char const   *at , size_t length ))0;
  settings.on_headers_complete = (int (*)(http_parser * ))0;
  settings.on_body = (int (*)(http_parser * , char const   *at , size_t length ))0;
  settings.on_message_complete = & verify_request;
  settings.on_chunk_header = (int (*)(http_parser * ))0;
  settings.on_chunk_complete = (int (*)(http_parser * ))0;
  request = (char *)((void *)0);
  count = (size_t )0;
  script_request(L, & request, & len);
  http_parser_init(& parser, (enum http_parser_type )0);
  parser.data = (void *)(& count);
  tmp = http_parser_execute(& parser, (http_parser_settings const   *)(& settings),
                            (char const   *)request, len);
  parsed = tmp;
  if (parsed != len) {
    goto _L;
  } else
  if (count == 0UL) {
    _L: /* CIL Label */ 
    err = (enum http_errno )parser.http_errno;
    tmp___0 = http_errno_description(err);
    desc = tmp___0;
    if ((unsigned int )err != 0U) {
      tmp___1 = desc;
    } else {
      tmp___1 = "incomplete request";
    }
    msg = tmp___1;
    line = 1;
    column = 1;
    c = request;
    while ((unsigned long )c < (unsigned long )(request + parsed)) {
      column ++;
      if ((int )*c == 10) {
        column = 1;
        line ++;
      }
      c ++;
    }
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s at %d:%d\n",
            msg, line, column);
    exit(1);
  }
  return (count);
}
}
static struct addrinfo *checkaddr(lua_State *L ) 
{ 
  struct addrinfo *addr ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = luaL_checkudata(L, -1, "wrk.addr");
  addr = (struct addrinfo *)tmp;
  if ((unsigned long )addr != (unsigned long )((void *)0)) {
    tmp___1 = 1;
  } else {
    tmp___0 = luaL_argerror(L, 1, "`addr\' expected");
    if (tmp___0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  }
  return (addr);
}
}
void script_addr_copy(struct addrinfo *src , struct addrinfo *dst ) 
{ 
  void *tmp ;

  {
  *dst = *src;
  tmp = zmalloc((size_t )src->ai_addrlen);
  dst->ai_addr = (struct sockaddr *)tmp;
  memcpy((void * __restrict  )dst->ai_addr, (void const   * __restrict  )src->ai_addr,
         (size_t )src->ai_addrlen);
  return;
}
}
struct addrinfo *script_addr_clone(lua_State *L , struct addrinfo *addr ) 
{ 
  struct addrinfo *udata ;
  void *tmp ;

  {
  tmp = lua_newuserdata(L, sizeof(*udata));
  udata = (struct addrinfo *)tmp;
  lua_getfield(L, -10000, "wrk.addr");
  lua_setmetatable(L, -2);
  script_addr_copy(addr, udata);
  return (udata);
}
}
static int script_addr_tostring(lua_State *L ) 
{ 
  struct addrinfo *addr ;
  struct addrinfo *tmp ;
  char host[1025] ;
  char service[32] ;
  int flags ;
  int rc ;
  int tmp___0 ;
  char const   *msg ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  tmp = checkaddr(L);
  addr = tmp;
  flags = 3;
  tmp___0 = getnameinfo((struct sockaddr  const  * __restrict  )addr->ai_addr, addr->ai_addrlen,
                        (char * __restrict  )(host), (socklen_t )1025, (char * __restrict  )(service),
                        (socklen_t )32, flags);
  rc = tmp___0;
  if (rc != 0) {
    tmp___1 = gai_strerror(rc);
    msg = tmp___1;
    tmp___2 = luaL_error(L, "addr tostring failed %s", msg);
    return (tmp___2);
  }
  lua_pushfstring(L, "%s:%s", host, service);
  return (1);
}
}
static int script_addr_gc(lua_State *L ) 
{ 
  struct addrinfo *addr ;
  struct addrinfo *tmp ;

  {
  tmp = checkaddr(L);
  addr = tmp;
  zfree((void *)addr->ai_addr);
  return (0);
}
}
static stats *checkstats(lua_State *L ) 
{ 
  stats **s ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = luaL_checkudata(L, 1, "wrk.stats");
  s = (stats **)tmp;
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    tmp___1 = 1;
  } else {
    tmp___0 = luaL_argerror(L, 1, "`stats\' expected");
    if (tmp___0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  }
  return (*s);
}
}
static int script_stats_percentile(lua_State *L ) 
{ 
  stats *s ;
  stats *tmp ;
  lua_Number p ;
  lua_Number tmp___0 ;
  uint64_t tmp___1 ;

  {
  tmp = checkstats(L);
  s = tmp;
  tmp___0 = luaL_checknumber(L, 2);
  p = tmp___0;
  tmp___1 = stats_percentile(s, (long double )p);
  lua_pushnumber(L, (lua_Number )tmp___1);
  return (1);
}
}
static int script_stats_call(lua_State *L ) 
{ 
  stats *s ;
  stats *tmp ;
  uint64_t index___0 ;
  lua_Number tmp___0 ;
  uint64_t count ;
  uint64_t tmp___1 ;

  {
  tmp = checkstats(L);
  s = tmp;
  tmp___0 = lua_tonumber(L, 2);
  index___0 = (uint64_t )tmp___0;
  tmp___1 = stats_value_at(s, index___0 - 1UL, & count);
  lua_pushnumber(L, (lua_Number )tmp___1);
  lua_pushnumber(L, (lua_Number )count);
  return (2);
}
}
static int script_stats_index(lua_State *L ) 
{ 
  stats *s ;
  stats *tmp ;
  char const   *method ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long double tmp___3 ;
  int tmp___4 ;
  long double tmp___5 ;
  long double tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  tmp = checkstats(L);
  s = tmp;
  tmp___0 = lua_tolstring(L, 2, (size_t *)((void *)0));
  method = tmp___0;
  tmp___1 = strcmp("min", method);
  if (! tmp___1) {
    lua_pushnumber(L, (lua_Number )s->min);
  }
  tmp___2 = strcmp("max", method);
  if (! tmp___2) {
    lua_pushnumber(L, (lua_Number )s->max);
  }
  tmp___4 = strcmp("mean", method);
  if (! tmp___4) {
    tmp___3 = stats_mean(s);
    lua_pushnumber(L, (lua_Number )tmp___3);
  }
  tmp___7 = strcmp("stdev", method);
  if (! tmp___7) {
    tmp___5 = stats_mean(s);
    tmp___6 = stats_stdev(s, tmp___5);
    lua_pushnumber(L, (lua_Number )tmp___6);
  }
  tmp___8 = strcmp("percentile", method);
  if (! tmp___8) {
    lua_pushcclosure(L, & script_stats_percentile, 0);
  }
  return (1);
}
}
static int script_stats_len(lua_State *L ) 
{ 
  stats *s ;
  stats *tmp ;
  uint64_t tmp___0 ;

  {
  tmp = checkstats(L);
  s = tmp;
  tmp___0 = stats_popcount(s);
  lua_pushinteger(L, (lua_Integer )tmp___0);
  return (1);
}
}
static thread *checkthread(lua_State *L ) 
{ 
  thread **t ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = luaL_checkudata(L, 1, "wrk.thread");
  t = (thread **)tmp;
  if ((unsigned long )t != (unsigned long )((void *)0)) {
    tmp___1 = 1;
  } else {
    tmp___0 = luaL_argerror(L, 1, "`thread\' expected");
    if (tmp___0) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  }
  return (*t);
}
}
static int script_thread_get(lua_State *L ) 
{ 
  thread *t ;
  thread *tmp ;
  char const   *key ;
  char const   *tmp___0 ;

  {
  tmp = checkthread(L);
  t = tmp;
  tmp___0 = lua_tolstring(L, -1, (size_t *)((void *)0));
  key = tmp___0;
  lua_getfield(t->L, -10002, key);
  script_copy_value(t->L, L, -1);
  lua_settop(t->L, -2);
  return (1);
}
}
static int script_thread_set(lua_State *L ) 
{ 
  thread *t ;
  thread *tmp ;
  char const   *name ;
  char const   *tmp___0 ;

  {
  tmp = checkthread(L);
  t = tmp;
  tmp___0 = lua_tolstring(L, -2, (size_t *)((void *)0));
  name = tmp___0;
  script_copy_value(L, t->L, -1);
  lua_setfield(t->L, -10002, name);
  return (0);
}
}
static int script_thread_stop(lua_State *L ) 
{ 
  thread *t ;
  thread *tmp ;

  {
  tmp = checkthread(L);
  t = tmp;
  aeStop(t->loop);
  return (0);
}
}
static int script_thread_index(lua_State *L ) 
{ 
  thread *t ;
  thread *tmp ;
  char const   *key ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  tmp = checkthread(L);
  t = tmp;
  tmp___0 = lua_tolstring(L, 2, (size_t *)((void *)0));
  key = tmp___0;
  tmp___1 = strcmp("get", key);
  if (! tmp___1) {
    lua_pushcclosure(L, & script_thread_get, 0);
  }
  tmp___2 = strcmp("set", key);
  if (! tmp___2) {
    lua_pushcclosure(L, & script_thread_set, 0);
  }
  tmp___3 = strcmp("stop", key);
  if (! tmp___3) {
    lua_pushcclosure(L, & script_thread_stop, 0);
  }
  tmp___4 = strcmp("addr", key);
  if (! tmp___4) {
    script_addr_clone(L, t->addr);
  }
  return (1);
}
}
static int script_thread_newindex(lua_State *L ) 
{ 
  thread *t ;
  thread *tmp ;
  char const   *key ;
  char const   *tmp___0 ;
  struct addrinfo *addr ;
  struct addrinfo *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;

  {
  tmp = checkthread(L);
  t = tmp;
  tmp___0 = lua_tolstring(L, -2, (size_t *)((void *)0));
  key = tmp___0;
  tmp___5 = strcmp("addr", key);
  if (tmp___5) {
    tmp___3 = lua_type(L, -1);
    tmp___4 = lua_typename(L, tmp___3);
    luaL_error(L, "cannot set \'%s\' on thread", tmp___4);
  } else {
    tmp___1 = checkaddr(L);
    addr = tmp___1;
    if (t->addr) {
      zfree((void *)(t->addr)->ai_addr);
    }
    tmp___2 = zrealloc((void *)t->addr, sizeof(*addr));
    t->addr = (struct addrinfo *)tmp___2;
    script_addr_copy(addr, t->addr);
  }
  return (0);
}
}
static int script_wrk_lookup(lua_State *L ) 
{ 
  struct addrinfo *addrs ;
  struct addrinfo hints ;
  int rc ;
  int index___0 ;
  char const   *host ;
  char const   *tmp ;
  char const   *service ;
  char const   *tmp___0 ;
  char const   *msg ;
  char const   *tmp___1 ;
  struct addrinfo *addr ;
  int tmp___2 ;

  {
  hints.ai_flags = 0;
  hints.ai_family = 0;
  hints.ai_socktype = 1;
  hints.ai_protocol = 0;
  hints.ai_addrlen = 0U;
  hints.ai_addr = (struct sockaddr *)0;
  hints.ai_canonname = (char *)0;
  hints.ai_next = (struct addrinfo *)0;
  index___0 = 1;
  tmp = lua_tolstring(L, -2, (size_t *)((void *)0));
  host = tmp;
  tmp___0 = lua_tolstring(L, -1, (size_t *)((void *)0));
  service = tmp___0;
  rc = getaddrinfo((char const   * __restrict  )host, (char const   * __restrict  )service,
                   (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& addrs));
  if (rc != 0) {
    tmp___1 = gai_strerror(rc);
    msg = tmp___1;
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"unable to resolve %s:%s %s\n",
            host, service, msg);
    exit(1);
  }
  lua_createtable(L, 0, 0);
  addr = addrs;
  while ((unsigned long )addr != (unsigned long )((void *)0)) {
    script_addr_clone(L, addr);
    tmp___2 = index___0;
    index___0 ++;
    lua_rawseti(L, -2, tmp___2);
    addr = addr->ai_next;
  }
  freeaddrinfo(addrs);
  return (1);
}
}
static int script_wrk_connect(lua_State *L ) 
{ 
  struct addrinfo *addr ;
  struct addrinfo *tmp ;
  int fd ;
  int connected ;
  int tmp___0 ;

  {
  tmp = checkaddr(L);
  addr = tmp;
  connected = 0;
  fd = socket(addr->ai_family, addr->ai_socktype, addr->ai_protocol);
  if (fd != -1) {
    tmp___0 = connect(fd, (struct sockaddr  const  *)addr->ai_addr, addr->ai_addrlen);
    connected = tmp___0 == 0;
    close(fd);
  }
  lua_pushboolean(L, connected);
  return (1);
}
}
void script_copy_value(lua_State *src , lua_State *dst , int index___0 ) 
{ 
  int tmp ;
  int tmp___0 ;
  lua_Number tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;

  {
  tmp = lua_type(src, index___0);
  switch (tmp) {
  case 1: 
  tmp___0 = lua_toboolean(src, index___0);
  lua_pushboolean(dst, tmp___0);
  break;
  case 0: 
  lua_pushnil(dst);
  break;
  case 3: 
  tmp___1 = lua_tonumber(src, index___0);
  lua_pushnumber(dst, tmp___1);
  break;
  case 4: 
  tmp___2 = lua_tolstring(src, index___0, (size_t *)((void *)0));
  lua_pushstring(dst, tmp___2);
  break;
  case 5: 
  lua_createtable(dst, 0, 0);
  lua_pushnil(src);
  while (1) {
    tmp___3 = lua_next(src, index___0 - 1);
    if (! tmp___3) {
      break;
    }
    script_copy_value(src, dst, -2);
    script_copy_value(src, dst, -1);
    lua_settable(dst, -3);
    lua_settop(src, -2);
  }
  lua_settop(src, -2);
  break;
  default: 
  tmp___4 = lua_type(src, index___0);
  tmp___5 = lua_typename(src, tmp___4);
  luaL_error(src, "cannot transfer \'%s\' to thread", tmp___5);
  }
  return;
}
}
int script_parse_url(char *url , struct http_parser_url *parts ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  tmp = strlen((char const   *)url);
  tmp___0 = http_parser_parse_url((char const   *)url, tmp, 0, parts);
  if (! tmp___0) {
    if (! ((int )parts->field_set & 1)) {
      return (0);
    }
    if (! ((int )parts->field_set & (1 << 1))) {
      return (0);
    }
    return (1);
  }
  return (0);
}
}
static int push_url_part(lua_State *L , char *url , struct http_parser_url *parts ,
                         enum http_parser_url_fields field ) 
{ 
  int type ;
  int tmp ;
  uint16_t off ;
  uint16_t len ;

  {
  if ((int )parts->field_set & (1 << (unsigned int )field)) {
    tmp = 4;
  } else {
    tmp = 0;
  }
  type = tmp;
  switch (type) {
  case 4: 
  off = parts->field_data[field].off;
  len = parts->field_data[field].len;
  lua_pushlstring(L, (char const   *)(url + off), (size_t )len);
  break;
  case 0: 
  lua_pushnil(L);
  }
  return (type);
}
}
static void set_field(lua_State *L , int index___0 , char *field , int type ) 
{ 


  {
  lua_setfield(L, index___0, (char const   *)field);
  return;
}
}
static void set_fields(lua_State *L , int index___0 , table_field const   *fields ) 
{ 
  int i ;
  table_field f ;
  int tmp ;

  {
  i = 0;
  while ((fields + i)->name) {
    f = *(fields + i);
    if ((unsigned long )f.value == (unsigned long )((void *)0)) {
      tmp = 0;
    } else {
      tmp = f.type;
    }
    switch (tmp) {
    case 6: 
    lua_pushcclosure(L, (int (*)(lua_State *L ))f.value, 0);
    break;
    case 3: 
    lua_pushinteger(L, *((lua_Integer *)f.value));
    break;
    case 4: 
    lua_pushstring(L, (char const   *)f.value);
    break;
    case 0: 
    lua_pushnil(L);
    break;
    }
    lua_setfield(L, index___0, (char const   *)f.name);
    i ++;
  }
  return;
}
}
void buffer_append(buffer *b , char const   *data , size_t len ) 
{ 
  size_t used ;
  void *tmp ;

  {
  used = (size_t )(b->cursor - b->buffer);
  while ((used + len) + 1UL >= b->length) {
    b->length += 1024UL;
    tmp = realloc((void *)b->buffer, b->length);
    b->buffer = (char *)tmp;
    b->cursor = b->buffer + used;
  }
  memcpy((void * __restrict  )b->cursor, (void const   * __restrict  )data, len);
  b->cursor += len;
  return;
}
}
void buffer_reset(buffer *b ) 
{ 


  {
  b->cursor = b->buffer;
  return;
}
}
char *buffer_pushlstring(lua_State *L , char *start ) 
{ 
  char *end ;
  char *tmp ;

  {
  tmp = strchr((char const   *)start, 0);
  end = tmp;
  lua_pushlstring(L, (char const   *)start, (size_t )(end - start));
  return (end + 1);
}
}
#pragma merger("0","/tmp/cil-iZXEWh0e.i","-std=c99,-Wall,-O2")
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...)  __asm__("__isoc99_sscanf")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncasecmp)(char const   *__s1 ,
                                                                                          char const   *__s2 ,
                                                                                          size_t __n )  __attribute__((__pure__)) ;
units time_units_us  =    {1000, (char *)"us", {(char *)"ms", (char *)"s", (char *)((void *)0)}};
units time_units_s  =    {60, (char *)"s", {(char *)"m", (char *)"h", (char *)((void *)0)}};
units binary_units  =    {1024, (char *)"", {(char *)"K", (char *)"M", (char *)"G", (char *)"T", (char *)"P",
                       (char *)((void *)0)}};
units metric_units  =    {1000, (char *)"", {(char *)"k", (char *)"M", (char *)"G", (char *)"T", (char *)"P",
                       (char *)((void *)0)}};
static char *format_units(long double n , units *m , int p ) 
{ 
  long double amt ;
  long double scale ;
  char *unit ;
  char *msg ;
  int i ;

  {
  amt = n;
  unit = m->base;
  msg = (char *)((void *)0);
  scale = (long double )((double )m->scale * 0.85);
  i = 0;
  while (1) {
    if (m->units[i + 1]) {
      if (! (amt >= scale)) {
        break;
      }
    } else {
      break;
    }
    amt /= (long double )m->scale;
    unit = m->units[i];
    i ++;
  }
  aprintf(& msg, "%.*Lf%s", p, amt, unit);
  return (msg);
}
}
static int scan_units(char *s , uint64_t *n , units *m ) 
{ 
  uint64_t base ;
  uint64_t scale ;
  char unit[3] ;
  int i ;
  int c ;
  int tmp ;
  int tmp___0 ;

  {
  scale = (uint64_t )1;
  unit[0] = (char)0;
  unit[1] = (char)0;
  unit[2] = (char)0;
  c = sscanf((char const   * __restrict  )s, (char const   * __restrict  )"%lu%2s",
             & base, unit);
  if (c < 1) {
    return (-1);
  }
  if (c == 2) {
    tmp___0 = strncasecmp((char const   *)(unit), (char const   *)m->base, (size_t )3);
    if (tmp___0) {
      i = 0;
      while ((unsigned long )m->units[i] != (unsigned long )((void *)0)) {
        scale *= (uint64_t )m->scale;
        tmp = strncasecmp((char const   *)(unit), (char const   *)m->units[i], (size_t )3);
        if (! tmp) {
          break;
        }
        i ++;
      }
      if ((unsigned long )m->units[i] == (unsigned long )((void *)0)) {
        return (-1);
      }
    }
  }
  *n = base * scale;
  return (0);
}
}
char *format_binary(long double n ) 
{ 
  char *tmp ;

  {
  tmp = format_units(n, & binary_units, 2);
  return (tmp);
}
}
char *format_metric(long double n ) 
{ 
  char *tmp ;

  {
  tmp = format_units(n, & metric_units, 2);
  return (tmp);
}
}
char *format_time_us(long double n ) 
{ 
  units *units___0 ;
  char *tmp ;

  {
  units___0 = & time_units_us;
  if (n >= (long double )1000000.0) {
    n /= (long double )1000000.0;
    units___0 = & time_units_s;
  }
  tmp = format_units(n, units___0, 2);
  return (tmp);
}
}
char *format_time_s(long double n ) 
{ 
  char *tmp ;

  {
  tmp = format_units(n, & time_units_s, 0);
  return (tmp);
}
}
int scan_metric(char *s , uint64_t *n ) 
{ 
  int tmp ;

  {
  tmp = scan_units(s, n, & metric_units);
  return (tmp);
}
}
int scan_time(char *s , uint64_t *n ) 
{ 
  int tmp ;

  {
  tmp = scan_units(s, n, & time_units_s);
  return (tmp);
}
}
#pragma merger("0","/tmp/cil-oD_SP1o_.i","-std=c99,-Wall,-O2")
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
int aeGetFileEvents(aeEventLoop *eventLoop , int fd ) ;
int aeDeleteTimeEvent(aeEventLoop *eventLoop , long long id ) ;
int aeProcessEvents(aeEventLoop *eventLoop , int flags ) ;
int aeWait(int fd , int mask , long long milliseconds ) ;
void aeSetBeforeSleepProc(aeEventLoop *eventLoop , aeBeforeSleepProc *beforesleep ) ;
int aeGetSetSize(aeEventLoop *eventLoop ) ;
int aeResizeSetSize(aeEventLoop *eventLoop , int setsize ) ;
extern  __attribute__((__nothrow__)) int epoll_create(int __size ) ;
extern  __attribute__((__nothrow__)) int epoll_ctl(int __epfd , int __op , int __fd ,
                                                   struct epoll_event *__event ) ;
extern int epoll_wait(int __epfd , struct epoll_event *__events , int __maxevents ,
                      int __timeout ) ;
static int aeApiCreate(aeEventLoop *eventLoop ) 
{ 
  aeApiState *state ;
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = zmalloc(sizeof(aeApiState ));
  state = (aeApiState *)tmp;
  if (! state) {
    return (-1);
  }
  tmp___0 = zmalloc(sizeof(struct epoll_event ) * (unsigned long )eventLoop->setsize);
  state->events = (struct epoll_event *)tmp___0;
  if (! state->events) {
    zfree((void *)state);
    return (-1);
  }
  state->epfd = epoll_create(1024);
  if (state->epfd == -1) {
    zfree((void *)state->events);
    zfree((void *)state);
    return (-1);
  }
  eventLoop->apidata = (void *)state;
  return (0);
}
}
static int aeApiResize(aeEventLoop *eventLoop , int setsize ) 
{ 
  aeApiState *state ;
  void *tmp ;

  {
  state = (aeApiState *)eventLoop->apidata;
  tmp = zrealloc((void *)state->events, sizeof(struct epoll_event ) * (unsigned long )setsize);
  state->events = (struct epoll_event *)tmp;
  return (0);
}
}
static void aeApiFree(aeEventLoop *eventLoop ) 
{ 
  aeApiState *state ;

  {
  state = (aeApiState *)eventLoop->apidata;
  close(state->epfd);
  zfree((void *)state->events);
  zfree((void *)state);
  return;
}
}
static int aeApiAddEvent(aeEventLoop *eventLoop , int fd , int mask ) 
{ 
  aeApiState *state ;
  struct epoll_event ee ;
  int op ;
  int tmp ;
  int tmp___0 ;

  {
  state = (aeApiState *)eventLoop->apidata;
  ee.events = (uint32_t )0;
  ee.data.ptr = (void *)0;
  if ((eventLoop->events + fd)->mask == 0) {
    tmp = 1;
  } else {
    tmp = 3;
  }
  op = tmp;
  ee.events = (uint32_t )0;
  mask |= (eventLoop->events + fd)->mask;
  if (mask & 1) {
    ee.events |= 1U;
  }
  if (mask & 2) {
    ee.events |= 4U;
  }
  ee.data.fd = fd;
  tmp___0 = epoll_ctl(state->epfd, op, fd, & ee);
  if (tmp___0 == -1) {
    return (-1);
  }
  return (0);
}
}
static void aeApiDelEvent(aeEventLoop *eventLoop , int fd , int delmask ) 
{ 
  aeApiState *state ;
  struct epoll_event ee ;
  int mask ;

  {
  state = (aeApiState *)eventLoop->apidata;
  ee.events = (uint32_t )0;
  ee.data.ptr = (void *)0;
  mask = (eventLoop->events + fd)->mask & ~ delmask;
  ee.events = (uint32_t )0;
  if (mask & 1) {
    ee.events |= 1U;
  }
  if (mask & 2) {
    ee.events |= 4U;
  }
  ee.data.fd = fd;
  if (mask != 0) {
    epoll_ctl(state->epfd, 3, fd, & ee);
  } else {
    epoll_ctl(state->epfd, 2, fd, & ee);
  }
  return;
}
}
static int aeApiPoll(aeEventLoop *eventLoop , struct timeval *tvp ) 
{ 
  aeApiState *state ;
  int retval ;
  int numevents ;
  __time_t tmp ;
  int j ;
  int mask ;
  struct epoll_event *e ;

  {
  state = (aeApiState *)eventLoop->apidata;
  numevents = 0;
  if (tvp) {
    tmp = tvp->tv_sec * 1000L + tvp->tv_usec / 1000L;
  } else {
    tmp = (__time_t )-1;
  }
  retval = epoll_wait(state->epfd, state->events, eventLoop->setsize, (int )tmp);
  if (retval > 0) {
    numevents = retval;
    j = 0;
    while (j < numevents) {
      mask = 0;
      e = state->events + j;
      if (e->events & 1U) {
        mask |= 1;
      }
      if (e->events & 4U) {
        mask |= 2;
      }
      if (e->events & 8U) {
        mask |= 2;
      }
      if (e->events & 16U) {
        mask |= 2;
      }
      (eventLoop->fired + j)->fd = e->data.fd;
      (eventLoop->fired + j)->mask = mask;
      j ++;
    }
  }
  return (numevents);
}
}
static char *aeApiName(void) 
{ 


  {
  return ((char *)"epoll");
}
}
aeEventLoop *aeCreateEventLoop(int setsize ) 
{ 
  aeEventLoop *eventLoop ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  tmp = zmalloc(sizeof(*eventLoop));
  eventLoop = (aeEventLoop *)tmp;
  if ((unsigned long )eventLoop == (unsigned long )((void *)0)) {
    goto err;
  }
  tmp___0 = zmalloc(sizeof(aeFileEvent ) * (unsigned long )setsize);
  eventLoop->events = (aeFileEvent *)tmp___0;
  tmp___1 = zmalloc(sizeof(aeFiredEvent ) * (unsigned long )setsize);
  eventLoop->fired = (aeFiredEvent *)tmp___1;
  if ((unsigned long )eventLoop->events == (unsigned long )((void *)0)) {
    goto err;
  } else
  if ((unsigned long )eventLoop->fired == (unsigned long )((void *)0)) {
    goto err;
  }
  eventLoop->setsize = setsize;
  eventLoop->lastTime = time((time_t *)((void *)0));
  eventLoop->timeEventHead = (aeTimeEvent *)((void *)0);
  eventLoop->timeEventNextId = 0LL;
  eventLoop->stop = 0;
  eventLoop->maxfd = -1;
  eventLoop->beforesleep = (aeBeforeSleepProc *)((void *)0);
  tmp___2 = aeApiCreate(eventLoop);
  if (tmp___2 == -1) {
    goto err;
  }
  i = 0;
  while (i < setsize) {
    (eventLoop->events + i)->mask = 0;
    i ++;
  }
  return (eventLoop);
  err: 
  if (eventLoop) {
    zfree((void *)eventLoop->events);
    zfree((void *)eventLoop->fired);
    zfree((void *)eventLoop);
  }
  return ((aeEventLoop *)((void *)0));
}
}
int aeGetSetSize(aeEventLoop *eventLoop ) 
{ 


  {
  return (eventLoop->setsize);
}
}
int aeResizeSetSize(aeEventLoop *eventLoop , int setsize ) 
{ 
  int i ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  if (setsize == eventLoop->setsize) {
    return (0);
  }
  if (eventLoop->maxfd >= setsize) {
    return (-1);
  }
  tmp = aeApiResize(eventLoop, setsize);
  if (tmp == -1) {
    return (-1);
  }
  tmp___0 = zrealloc((void *)eventLoop->events, sizeof(aeFileEvent ) * (unsigned long )setsize);
  eventLoop->events = (aeFileEvent *)tmp___0;
  tmp___1 = zrealloc((void *)eventLoop->fired, sizeof(aeFiredEvent ) * (unsigned long )setsize);
  eventLoop->fired = (aeFiredEvent *)tmp___1;
  eventLoop->setsize = setsize;
  i = eventLoop->maxfd + 1;
  while (i < setsize) {
    (eventLoop->events + i)->mask = 0;
    i ++;
  }
  return (0);
}
}
void aeDeleteEventLoop(aeEventLoop *eventLoop ) 
{ 


  {
  aeApiFree(eventLoop);
  zfree((void *)eventLoop->events);
  zfree((void *)eventLoop->fired);
  zfree((void *)eventLoop);
  return;
}
}
void aeStop(aeEventLoop *eventLoop ) 
{ 


  {
  eventLoop->stop = 1;
  return;
}
}
int aeCreateFileEvent(aeEventLoop *eventLoop , int fd , int mask , aeFileProc *proc ,
                      void *clientData ) 
{ 
  int *tmp ;
  aeFileEvent *fe ;
  int tmp___0 ;

  {
  if (fd >= eventLoop->setsize) {
    tmp = __errno_location();
    *tmp = 34;
    return (-1);
  }
  fe = eventLoop->events + fd;
  tmp___0 = aeApiAddEvent(eventLoop, fd, mask);
  if (tmp___0 == -1) {
    return (-1);
  }
  fe->mask |= mask;
  if (mask & 1) {
    fe->rfileProc = proc;
  }
  if (mask & 2) {
    fe->wfileProc = proc;
  }
  fe->clientData = clientData;
  if (fd > eventLoop->maxfd) {
    eventLoop->maxfd = fd;
  }
  return (0);
}
}
void aeDeleteFileEvent(aeEventLoop *eventLoop , int fd , int mask ) 
{ 
  aeFileEvent *fe ;
  int j ;

  {
  if (fd >= eventLoop->setsize) {
    return;
  }
  fe = eventLoop->events + fd;
  if (fe->mask == 0) {
    return;
  }
  aeApiDelEvent(eventLoop, fd, mask);
  fe->mask &= ~ mask;
  if (fd == eventLoop->maxfd) {
    if (fe->mask == 0) {
      j = eventLoop->maxfd - 1;
      while (j >= 0) {
        if ((eventLoop->events + j)->mask != 0) {
          break;
        }
        j --;
      }
      eventLoop->maxfd = j;
    }
  }
  return;
}
}
int aeGetFileEvents(aeEventLoop *eventLoop , int fd ) 
{ 
  aeFileEvent *fe ;

  {
  if (fd >= eventLoop->setsize) {
    return (0);
  }
  fe = eventLoop->events + fd;
  return (fe->mask);
}
}
static void aeGetTime(long *seconds , long *milliseconds ) 
{ 
  struct timeval tv ;

  {
  gettimeofday((struct timeval * __restrict  )(& tv), (void * __restrict  )((void *)0));
  *seconds = tv.tv_sec;
  *milliseconds = tv.tv_usec / 1000L;
  return;
}
}
static void aeAddMillisecondsToNow(long long milliseconds , long *sec , long *ms ) 
{ 
  long cur_sec ;
  long cur_ms ;
  long when_sec ;
  long when_ms ;

  {
  aeGetTime(& cur_sec, & cur_ms);
  when_sec = (long )((long long )cur_sec + milliseconds / 1000LL);
  when_ms = (long )((long long )cur_ms + milliseconds % 1000LL);
  if (when_ms >= 1000L) {
    when_sec ++;
    when_ms -= 1000L;
  }
  *sec = when_sec;
  *ms = when_ms;
  return;
}
}
long long aeCreateTimeEvent(aeEventLoop *eventLoop , long long milliseconds , aeTimeProc *proc ,
                            void *clientData , aeEventFinalizerProc *finalizerProc ) 
{ 
  long long id ;
  long long tmp ;
  aeTimeEvent *te ;
  void *tmp___0 ;

  {
  tmp = eventLoop->timeEventNextId;
  (eventLoop->timeEventNextId) ++;
  id = tmp;
  tmp___0 = zmalloc(sizeof(*te));
  te = (aeTimeEvent *)tmp___0;
  if ((unsigned long )te == (unsigned long )((void *)0)) {
    return (-1LL);
  }
  te->id = id;
  aeAddMillisecondsToNow(milliseconds, & te->when_sec, & te->when_ms);
  te->timeProc = proc;
  te->finalizerProc = finalizerProc;
  te->clientData = clientData;
  te->next = eventLoop->timeEventHead;
  eventLoop->timeEventHead = te;
  return (id);
}
}
int aeDeleteTimeEvent(aeEventLoop *eventLoop , long long id ) 
{ 
  aeTimeEvent *te ;

  {
  te = eventLoop->timeEventHead;
  while (te) {
    if (te->id == id) {
      te->id = -1LL;
      return (0);
    }
    te = te->next;
  }
  return (-1);
}
}
static aeTimeEvent *aeSearchNearestTimer(aeEventLoop *eventLoop ) 
{ 
  aeTimeEvent *te ;
  aeTimeEvent *nearest ;

  {
  te = eventLoop->timeEventHead;
  nearest = (aeTimeEvent *)((void *)0);
  while (te) {
    if (! nearest) {
      nearest = te;
    } else
    if (te->when_sec < nearest->when_sec) {
      nearest = te;
    } else
    if (te->when_sec == nearest->when_sec) {
      if (te->when_ms < nearest->when_ms) {
        nearest = te;
      }
    }
    te = te->next;
  }
  return (nearest);
}
}
static int processTimeEvents(aeEventLoop *eventLoop ) 
{ 
  int processed ;
  aeTimeEvent *te ;
  aeTimeEvent *prev ;
  long long maxId ;
  time_t now ;
  time_t tmp ;
  long now_sec ;
  long now_ms ;
  long long id ;
  aeTimeEvent *next ;
  int retval ;

  {
  processed = 0;
  tmp = time((time_t *)((void *)0));
  now = tmp;
  if (now < eventLoop->lastTime) {
    te = eventLoop->timeEventHead;
    while (te) {
      te->when_sec = 0L;
      te = te->next;
    }
  }
  eventLoop->lastTime = now;
  prev = (aeTimeEvent *)((void *)0);
  te = eventLoop->timeEventHead;
  maxId = eventLoop->timeEventNextId - 1LL;
  while (te) {
    if (te->id == -1LL) {
      next = te->next;
      if ((unsigned long )prev == (unsigned long )((void *)0)) {
        eventLoop->timeEventHead = te->next;
      } else {
        prev->next = te->next;
      }
      if (te->finalizerProc) {
        (*(te->finalizerProc))(eventLoop, te->clientData);
      }
      zfree((void *)te);
      te = next;
      continue;
    }
    if (te->id > maxId) {
      te = te->next;
      continue;
    }
    aeGetTime(& now_sec, & now_ms);
    if (now_sec > te->when_sec) {
      goto _L;
    } else
    if (now_sec == te->when_sec) {
      if (now_ms >= te->when_ms) {
        _L: /* CIL Label */ 
        id = te->id;
        retval = (*(te->timeProc))(eventLoop, id, te->clientData);
        processed ++;
        if (retval != -1) {
          aeAddMillisecondsToNow((long long )retval, & te->when_sec, & te->when_ms);
        } else {
          te->id = -1LL;
        }
      }
    }
    prev = te;
    te = te->next;
  }
  return (processed);
}
}
int aeProcessEvents(aeEventLoop *eventLoop , int flags ) 
{ 
  int processed ;
  int numevents ;
  int j ;
  aeTimeEvent *shortest ;
  struct timeval tv ;
  struct timeval *tvp ;
  long now_sec ;
  long now_ms ;
  long long ms ;
  aeFileEvent *fe ;
  int mask ;
  int fd ;
  int rfired ;
  int tmp ;

  {
  processed = 0;
  if (! (flags & 2)) {
    if (! (flags & 1)) {
      return (0);
    }
  }
  if (eventLoop->maxfd != -1) {
    goto _L;
  } else
  if (flags & 2) {
    if (! (flags & 4)) {
      _L: /* CIL Label */ 
      shortest = (aeTimeEvent *)((void *)0);
      if (flags & 2) {
        if (! (flags & 4)) {
          shortest = aeSearchNearestTimer(eventLoop);
        }
      }
      if (shortest) {
        aeGetTime(& now_sec, & now_ms);
        tvp = & tv;
        ms = (long long )(((shortest->when_sec - now_sec) * 1000L + shortest->when_ms) - now_ms);
        if (ms > 0LL) {
          tvp->tv_sec = (__time_t )(ms / 1000LL);
          tvp->tv_usec = (__suseconds_t )((ms % 1000LL) * 1000LL);
        } else {
          tvp->tv_sec = (__time_t )0;
          tvp->tv_usec = (__suseconds_t )0;
        }
      } else
      if (flags & 4) {
        tv.tv_usec = (__suseconds_t )0;
        tv.tv_sec = tv.tv_usec;
        tvp = & tv;
      } else {
        tvp = (struct timeval *)((void *)0);
      }
      numevents = aeApiPoll(eventLoop, tvp);
      j = 0;
      while (j < numevents) {
        fe = eventLoop->events + (eventLoop->fired + j)->fd;
        mask = (eventLoop->fired + j)->mask;
        fd = (eventLoop->fired + j)->fd;
        rfired = 0;
        if ((fe->mask & mask) & 1) {
          rfired = 1;
          (*(fe->rfileProc))(eventLoop, fd, fe->clientData, mask);
        }
        if ((fe->mask & mask) & 2) {
          if (! rfired) {
            (*(fe->wfileProc))(eventLoop, fd, fe->clientData, mask);
          } else
          if ((unsigned long )fe->wfileProc != (unsigned long )fe->rfileProc) {
            (*(fe->wfileProc))(eventLoop, fd, fe->clientData, mask);
          }
        }
        processed ++;
        j ++;
      }
    }
  }
  if (flags & 2) {
    tmp = processTimeEvents(eventLoop);
    processed += tmp;
  }
  return (processed);
}
}
int aeWait(int fd , int mask , long long milliseconds ) 
{ 
  struct pollfd pfd ;
  int retmask ;
  int retval ;

  {
  retmask = 0;
  memset((void *)(& pfd), 0, sizeof(pfd));
  pfd.fd = fd;
  if (mask & 1) {
    pfd.events = (short )((int )pfd.events | 1);
  }
  if (mask & 2) {
    pfd.events = (short )((int )pfd.events | 4);
  }
  retval = poll(& pfd, (nfds_t )1, (int )milliseconds);
  if (retval == 1) {
    if ((int )pfd.revents & 1) {
      retmask |= 1;
    }
    if ((int )pfd.revents & 4) {
      retmask |= 2;
    }
    if ((int )pfd.revents & 8) {
      retmask |= 2;
    }
    if ((int )pfd.revents & 16) {
      retmask |= 2;
    }
    return (retmask);
  } else {
    return (retval);
  }
}
}
void aeMain(aeEventLoop *eventLoop ) 
{ 


  {
  eventLoop->stop = 0;
  while (! eventLoop->stop) {
    if ((unsigned long )eventLoop->beforesleep != (unsigned long )((void *)0)) {
      (*(eventLoop->beforesleep))(eventLoop);
    }
    aeProcessEvents(eventLoop, 3);
  }
  return;
}
}
char *aeGetApiName(void) 
{ 
  char *tmp ;

  {
  tmp = aeApiName();
  return (tmp);
}
}
void aeSetBeforeSleepProc(aeEventLoop *eventLoop , aeBeforeSleepProc *beforesleep ) 
{ 


  {
  eventLoop->beforesleep = beforesleep;
  return;
}
}
#pragma merger("0","/tmp/cil-W4pl4Mz0.i","-std=c99,-Wall,-O2")
extern int fflush(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
void zlibc_free(void *ptr ) 
{ 


  {
  free(ptr);
  return;
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
char *zstrdup(char const   *s ) ;
size_t zmalloc_used_memory(void) ;
void zmalloc_set_oom_handler(void (*oom_handler)(size_t  ) ) ;
float zmalloc_get_fragmentation_ratio(size_t rss ) ;
size_t zmalloc_get_rss(void) ;
size_t zmalloc_get_private_dirty(long pid ) ;
size_t zmalloc_get_smap_bytes_by_field(char *field , long pid ) ;
size_t zmalloc_get_memory_size(void) ;
size_t zmalloc_size(void *ptr ) ;
static size_t used_memory  =    (size_t )0;
pthread_mutex_t used_memory_mutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
static void zmalloc_default_oom(size_t size ) 
{ 


  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"zmalloc: Out of memory trying to allocate %zu bytes\n",
          size);
  fflush(stderr);
  abort();
}
}
static void (*zmalloc_oom_handler)(size_t  )  =    & zmalloc_default_oom;
void *zmalloc(size_t size ) 
{ 
  void *ptr ;
  void *tmp ;
  size_t _n ;

  {
  tmp = malloc(size + sizeof(size_t ));
  ptr = tmp;
  if (! ptr) {
    (*zmalloc_oom_handler)(size);
  }
  *((size_t *)ptr) = size;
  while (1) {
    _n = size + sizeof(size_t );
    if (_n & (sizeof(long ) - 1UL)) {
      _n += sizeof(long ) - (_n & (sizeof(long ) - 1UL));
    }
    while (1) {
      pthread_mutex_lock(& used_memory_mutex);
      used_memory += size + sizeof(size_t );
      pthread_mutex_unlock(& used_memory_mutex);
      break;
    }
    break;
  }
  return ((void *)((char *)ptr + sizeof(size_t )));
}
}
void *zcalloc(size_t size ) 
{ 
  void *ptr ;
  void *tmp ;
  size_t _n ;

  {
  tmp = calloc((size_t )1, size + sizeof(size_t ));
  ptr = tmp;
  if (! ptr) {
    (*zmalloc_oom_handler)(size);
  }
  *((size_t *)ptr) = size;
  while (1) {
    _n = size + sizeof(size_t );
    if (_n & (sizeof(long ) - 1UL)) {
      _n += sizeof(long ) - (_n & (sizeof(long ) - 1UL));
    }
    while (1) {
      pthread_mutex_lock(& used_memory_mutex);
      used_memory += size + sizeof(size_t );
      pthread_mutex_unlock(& used_memory_mutex);
      break;
    }
    break;
  }
  return ((void *)((char *)ptr + sizeof(size_t )));
}
}
void *zrealloc(void *ptr , size_t size ) 
{ 
  void *realptr ;
  size_t oldsize ;
  void *newptr ;
  void *tmp ;
  size_t _n ;
  size_t _n___0 ;

  {
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    tmp = zmalloc(size);
    return (tmp);
  }
  realptr = (void *)((char *)ptr - sizeof(size_t ));
  oldsize = *((size_t *)realptr);
  newptr = realloc(realptr, size + sizeof(size_t ));
  if (! newptr) {
    (*zmalloc_oom_handler)(size);
  }
  *((size_t *)newptr) = size;
  while (1) {
    _n = oldsize;
    if (_n & (sizeof(long ) - 1UL)) {
      _n += sizeof(long ) - (_n & (sizeof(long ) - 1UL));
    }
    while (1) {
      pthread_mutex_lock(& used_memory_mutex);
      used_memory -= oldsize;
      pthread_mutex_unlock(& used_memory_mutex);
      break;
    }
    break;
  }
  while (1) {
    _n___0 = size;
    if (_n___0 & (sizeof(long ) - 1UL)) {
      _n___0 += sizeof(long ) - (_n___0 & (sizeof(long ) - 1UL));
    }
    while (1) {
      pthread_mutex_lock(& used_memory_mutex);
      used_memory += size;
      pthread_mutex_unlock(& used_memory_mutex);
      break;
    }
    break;
  }
  return ((void *)((char *)newptr + sizeof(size_t )));
}
}
size_t zmalloc_size(void *ptr ) 
{ 
  void *realptr ;
  size_t size ;

  {
  realptr = (void *)((char *)ptr - sizeof(size_t ));
  size = *((size_t *)realptr);
  if (size & (sizeof(long ) - 1UL)) {
    size += sizeof(long ) - (size & (sizeof(long ) - 1UL));
  }
  return (size + sizeof(size_t ));
}
}
void zfree(void *ptr ) 
{ 
  void *realptr ;
  size_t oldsize ;
  size_t _n ;

  {
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    return;
  }
  realptr = (void *)((char *)ptr - sizeof(size_t ));
  oldsize = *((size_t *)realptr);
  while (1) {
    _n = oldsize + sizeof(size_t );
    if (_n & (sizeof(long ) - 1UL)) {
      _n += sizeof(long ) - (_n & (sizeof(long ) - 1UL));
    }
    while (1) {
      pthread_mutex_lock(& used_memory_mutex);
      used_memory -= oldsize + sizeof(size_t );
      pthread_mutex_unlock(& used_memory_mutex);
      break;
    }
    break;
  }
  free(realptr);
  return;
}
}
char *zstrdup(char const   *s ) 
{ 
  size_t l ;
  size_t tmp ;
  char *p ;
  void *tmp___0 ;

  {
  tmp = strlen(s);
  l = tmp + 1UL;
  tmp___0 = zmalloc(l);
  p = (char *)tmp___0;
  memcpy((void * __restrict  )p, (void const   * __restrict  )s, l);
  return (p);
}
}
size_t zmalloc_used_memory(void) 
{ 
  size_t um ;

  {
  while (1) {
    pthread_mutex_lock(& used_memory_mutex);
    um = used_memory;
    pthread_mutex_unlock(& used_memory_mutex);
    break;
  }
  return (um);
}
}
void zmalloc_set_oom_handler(void (*oom_handler)(size_t  ) ) 
{ 


  {
  zmalloc_oom_handler = oom_handler;
  return;
}
}
size_t zmalloc_get_rss(void) 
{ 
  size_t tmp ;

  {
  tmp = zmalloc_used_memory();
  return (tmp);
}
}
float zmalloc_get_fragmentation_ratio(size_t rss ) 
{ 
  size_t tmp ;

  {
  tmp = zmalloc_used_memory();
  return ((float )rss / (float )tmp);
}
}
size_t zmalloc_get_smap_bytes_by_field(char *field , long pid ) 
{ 


  {
  return ((size_t )0);
}
}
size_t zmalloc_get_private_dirty(long pid ) 
{ 
  size_t tmp ;

  {
  tmp = zmalloc_get_smap_bytes_by_field((char *)"Private_Dirty:", pid);
  return (tmp);
}
}
size_t zmalloc_get_memory_size(void) 
{ 


  {
  return ((size_t )0L);
}
}
#pragma merger("0","/tmp/cil-gHfSC3BF.i","-std=c99,-Wall,-O2")
unsigned long http_parser_version(void) ;
void http_parser_settings_init(http_parser_settings *settings ) ;
char const   *http_method_str(enum http_method m ) ;
char const   *http_errno_name(enum http_errno err ) ;
void http_parser_url_init(struct http_parser_url *u ) ;
void http_parser_pause(http_parser *parser , int paused ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) strtoul)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memchr)(void const   *__s ,
                                                                                     int __c ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
static char const   *method_strings[33]  = 
  {      "DELETE",      "GET",      "HEAD",      "POST", 
        "PUT",      "CONNECT",      "OPTIONS",      "TRACE", 
        "COPY",      "LOCK",      "MKCOL",      "MOVE", 
        "PROPFIND",      "PROPPATCH",      "SEARCH",      "UNLOCK", 
        "BIND",      "REBIND",      "UNBIND",      "ACL", 
        "REPORT",      "MKACTIVITY",      "CHECKOUT",      "MERGE", 
        "M-SEARCH",      "NOTIFY",      "SUBSCRIBE",      "UNSUBSCRIBE", 
        "PATCH",      "PURGE",      "MKCALENDAR",      "LINK", 
        "UNLINK"};
static char const   tokens[256]  = 
  {      (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )'!',      (char const   )0,      (char const   )'#', 
        (char const   )'$',      (char const   )'%',      (char const   )'&',      (char const   )'\'', 
        (char const   )0,      (char const   )0,      (char const   )'*',      (char const   )'+', 
        (char const   )0,      (char const   )'-',      (char const   )'.',      (char const   )0, 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )'a',      (char const   )'b',      (char const   )'c', 
        (char const   )'d',      (char const   )'e',      (char const   )'f',      (char const   )'g', 
        (char const   )'h',      (char const   )'i',      (char const   )'j',      (char const   )'k', 
        (char const   )'l',      (char const   )'m',      (char const   )'n',      (char const   )'o', 
        (char const   )'p',      (char const   )'q',      (char const   )'r',      (char const   )'s', 
        (char const   )'t',      (char const   )'u',      (char const   )'v',      (char const   )'w', 
        (char const   )'x',      (char const   )'y',      (char const   )'z',      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )'^',      (char const   )'_', 
        (char const   )'`',      (char const   )'a',      (char const   )'b',      (char const   )'c', 
        (char const   )'d',      (char const   )'e',      (char const   )'f',      (char const   )'g', 
        (char const   )'h',      (char const   )'i',      (char const   )'j',      (char const   )'k', 
        (char const   )'l',      (char const   )'m',      (char const   )'n',      (char const   )'o', 
        (char const   )'p',      (char const   )'q',      (char const   )'r',      (char const   )'s', 
        (char const   )'t',      (char const   )'u',      (char const   )'v',      (char const   )'w', 
        (char const   )'x',      (char const   )'y',      (char const   )'z',      (char const   )0, 
        (char const   )'|',      (char const   )0,      (char const   )'~',      (char const   )0};
static int8_t const   unhex[256]  = 
  {      (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1, 
        (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1, 
        (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1, 
        (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1, 
        (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1, 
        (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1, 
        (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1, 
        (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1, 
        (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1, 
        (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1, 
        (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1, 
        (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1, 
        (int8_t const   )0,      (int8_t const   )1,      (int8_t const   )2,      (int8_t const   )3, 
        (int8_t const   )4,      (int8_t const   )5,      (int8_t const   )6,      (int8_t const   )7, 
        (int8_t const   )8,      (int8_t const   )9,      (int8_t const   )-1,      (int8_t const   )-1, 
        (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1, 
        (int8_t const   )-1,      (int8_t const   )10,      (int8_t const   )11,      (int8_t const   )12, 
        (int8_t const   )13,      (int8_t const   )14,      (int8_t const   )15,      (int8_t const   )-1, 
        (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1, 
        (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1, 
        (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1, 
        (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1, 
        (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1, 
        (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1, 
        (int8_t const   )-1,      (int8_t const   )10,      (int8_t const   )11,      (int8_t const   )12, 
        (int8_t const   )13,      (int8_t const   )14,      (int8_t const   )15,      (int8_t const   )-1, 
        (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1, 
        (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1, 
        (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1, 
        (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1, 
        (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1, 
        (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1,      (int8_t const   )-1};
static uint8_t const   normal_url_char[32]  = 
  {      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )0, 
        (uint8_t const   )246,      (uint8_t const   )255,      (uint8_t const   )255,      (uint8_t const   )127, 
        (uint8_t const   )255,      (uint8_t const   )255,      (uint8_t const   )255,      (uint8_t const   )255, 
        (uint8_t const   )255,      (uint8_t const   )255,      (uint8_t const   )255,      (uint8_t const   )127};
static struct __anonstruct_http_strerror_tab_527861670 http_strerror_tab[33]  = 
  {      {"HPE_OK", "success"}, 
        {"HPE_CB_message_begin", "the on_message_begin callback failed"}, 
        {"HPE_CB_url", "the on_url callback failed"}, 
        {"HPE_CB_header_field", "the on_header_field callback failed"}, 
        {"HPE_CB_header_value", "the on_header_value callback failed"}, 
        {"HPE_CB_headers_complete", "the on_headers_complete callback failed"}, 
        {"HPE_CB_body", "the on_body callback failed"}, 
        {"HPE_CB_message_complete", "the on_message_complete callback failed"}, 
        {"HPE_CB_status", "the on_status callback failed"}, 
        {"HPE_CB_chunk_header", "the on_chunk_header callback failed"}, 
        {"HPE_CB_chunk_complete", "the on_chunk_complete callback failed"}, 
        {"HPE_INVALID_EOF_STATE", "stream ended at an unexpected time"}, 
        {"HPE_HEADER_OVERFLOW", "too many header bytes seen; overflow detected"}, 
        {"HPE_CLOSED_CONNECTION", "data received after completed connection: close message"}, 
        {"HPE_INVALID_VERSION",
      "invalid HTTP version"}, 
        {"HPE_INVALID_STATUS", "invalid HTTP status code"}, 
        {"HPE_INVALID_METHOD", "invalid HTTP method"}, 
        {"HPE_INVALID_URL", "invalid URL"}, 
        {"HPE_INVALID_HOST", "invalid host"}, 
        {"HPE_INVALID_PORT", "invalid port"}, 
        {"HPE_INVALID_PATH", "invalid path"}, 
        {"HPE_INVALID_QUERY_STRING", "invalid query string"}, 
        {"HPE_INVALID_FRAGMENT", "invalid fragment"}, 
        {"HPE_LF_EXPECTED", "LF character expected"}, 
        {"HPE_INVALID_HEADER_TOKEN", "invalid character in header"}, 
        {"HPE_INVALID_CONTENT_LENGTH", "invalid character in content-length header"}, 
        {"HPE_UNEXPECTED_CONTENT_LENGTH",
      "unexpected content-length header"}, 
        {"HPE_INVALID_CHUNK_SIZE", "invalid character in chunk size header"}, 
        {"HPE_INVALID_CONSTANT", "invalid constant string"}, 
        {"HPE_INVALID_INTERNAL_STATE", "encountered unexpected internal state"}, 
        {"HPE_STRICT", "strict mode assertion failed"}, 
        {"HPE_PAUSED", "parser is paused"}, 
        {"HPE_UNKNOWN", "an unknown error occurred"}};
int http_message_needs_eof(http_parser const   *parser ) ;
static enum state parse_url_char(enum state s , char const   ch ) 
{ 


  {
  if ((int const   )ch == 32) {
    return ((enum state )1);
  } else
  if ((int const   )ch == 13) {
    return ((enum state )1);
  } else
  if ((int const   )ch == 10) {
    return ((enum state )1);
  }
  if ((int const   )ch == 9) {
    return ((enum state )1);
  } else
  if ((int const   )ch == 12) {
    return ((enum state )1);
  }
  switch ((unsigned int )s) {
  case 20U: 
  if ((int const   )ch == 47) {
    return ((enum state )27);
  } else
  if ((int const   )ch == 42) {
    return ((enum state )27);
  }
  if ((int )((unsigned char )((int const   )ch | 32)) >= 97) {
    if ((int )((unsigned char )((int const   )ch | 32)) <= 122) {
      return ((enum state )21);
    }
  }
  break;
  case 21U: 
  if ((int )((unsigned char )((int const   )ch | 32)) >= 97) {
    if ((int )((unsigned char )((int const   )ch | 32)) <= 122) {
      return (s);
    }
  }
  if ((int const   )ch == 58) {
    return ((enum state )22);
  }
  break;
  case 22U: 
  if ((int const   )ch == 47) {
    return ((enum state )23);
  }
  break;
  case 23U: 
  if ((int const   )ch == 47) {
    return ((enum state )24);
  }
  break;
  case 26U: 
  if ((int const   )ch == 64) {
    return ((enum state )1);
  }
  case 25U: 
  case 24U: 
  if ((int const   )ch == 47) {
    return ((enum state )27);
  }
  if ((int const   )ch == 63) {
    return ((enum state )28);
  }
  if ((int const   )ch == 64) {
    return ((enum state )26);
  }
  if ((int )((unsigned char )((int const   )ch | 32)) >= 97) {
    if ((int )((unsigned char )((int const   )ch | 32)) <= 122) {
      return ((enum state )25);
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if ((int const   )ch >= 48) {
    if ((int const   )ch <= 57) {
      return ((enum state )25);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if ((int const   )ch == 45) {
    return ((enum state )25);
  } else
  if ((int const   )ch == 95) {
    return ((enum state )25);
  } else
  if ((int const   )ch == 46) {
    return ((enum state )25);
  } else
  if ((int const   )ch == 33) {
    return ((enum state )25);
  } else
  if ((int const   )ch == 126) {
    return ((enum state )25);
  } else
  if ((int const   )ch == 42) {
    return ((enum state )25);
  } else
  if ((int const   )ch == 39) {
    return ((enum state )25);
  } else
  if ((int const   )ch == 40) {
    return ((enum state )25);
  } else
  if ((int const   )ch == 41) {
    return ((enum state )25);
  } else
  if ((int const   )ch == 37) {
    return ((enum state )25);
  } else
  if ((int const   )ch == 59) {
    return ((enum state )25);
  } else
  if ((int const   )ch == 58) {
    return ((enum state )25);
  } else
  if ((int const   )ch == 38) {
    return ((enum state )25);
  } else
  if ((int const   )ch == 61) {
    return ((enum state )25);
  } else
  if ((int const   )ch == 43) {
    return ((enum state )25);
  } else
  if ((int const   )ch == 36) {
    return ((enum state )25);
  } else
  if ((int const   )ch == 44) {
    return ((enum state )25);
  } else
  if ((int const   )ch == 91) {
    return ((enum state )25);
  } else
  if ((int const   )ch == 93) {
    return ((enum state )25);
  }
  break;
  case 27U: 
  if (! (! ((unsigned int )normal_url_char[(unsigned int )((unsigned char )ch) >> 3] & (unsigned int )(1 << ((unsigned int )((unsigned char )ch) & 7U))))) {
    return (s);
  }
  switch ((int const   )ch) {
  case 63: 
  return ((enum state )28);
  case 35: 
  return ((enum state )30);
  }
  break;
  case 29U: 
  case 28U: 
  if (! (! ((unsigned int )normal_url_char[(unsigned int )((unsigned char )ch) >> 3] & (unsigned int )(1 << ((unsigned int )((unsigned char )ch) & 7U))))) {
    return ((enum state )29);
  }
  switch ((int const   )ch) {
  case 63: 
  return ((enum state )29);
  case 35: 
  return ((enum state )30);
  }
  break;
  case 30U: 
  if (! (! ((unsigned int )normal_url_char[(unsigned int )((unsigned char )ch) >> 3] & (unsigned int )(1 << ((unsigned int )((unsigned char )ch) & 7U))))) {
    return ((enum state )31);
  }
  switch ((int const   )ch) {
  case 63: 
  return ((enum state )31);
  case 35: 
  return (s);
  }
  break;
  case 31U: 
  if (! (! ((unsigned int )normal_url_char[(unsigned int )((unsigned char )ch) >> 3] & (unsigned int )(1 << ((unsigned int )((unsigned char )ch) & 7U))))) {
    return (s);
  }
  switch ((int const   )ch) {
  case 35: 
  case 63: 
  return (s);
  }
  break;
  default: 
  break;
  }
  return ((enum state )1);
}
}
size_t http_parser_execute(http_parser *parser , http_parser_settings const   *settings ,
                           char const   *data , size_t len ) 
{ 
  char c ;
  char ch ;
  int8_t unhex_val ;
  char const   *p ;
  char const   *header_field_mark ;
  char const   *header_value_mark ;
  char const   *url_mark ;
  char const   *body_mark ;
  char const   *status_mark ;
  enum state p_state ;
  unsigned int lenient ;
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  long tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;
  int tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  int tmp___21 ;
  long tmp___22 ;
  long tmp___23 ;
  long tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  long tmp___27 ;
  long tmp___28 ;
  long tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  long tmp___32 ;
  long tmp___33 ;
  long tmp___34 ;
  int tmp___35 ;
  long tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  long tmp___39 ;
  long tmp___40 ;
  long tmp___41 ;
  char const   *matcher ;
  long tmp___42 ;
  enum state tmp___43 ;
  long tmp___44 ;
  enum state tmp___45 ;
  long tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  long tmp___49 ;
  long tmp___50 ;
  long tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  long tmp___55 ;
  long tmp___56 ;
  long tmp___57 ;
  enum state tmp___58 ;
  long tmp___59 ;
  int tmp___60 ;
  long tmp___61 ;
  long tmp___62 ;
  int tmp___63 ;
  long tmp___64 ;
  long tmp___65 ;
  long tmp___66 ;
  char const   *start ;
  long tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  long tmp___70 ;
  long tmp___71 ;
  long tmp___72 ;
  int tmp___73 ;
  long tmp___74 ;
  char const   *start___0 ;
  enum header_states h_state ;
  int tmp___75 ;
  int tmp___76 ;
  long tmp___77 ;
  long tmp___78 ;
  long tmp___79 ;
  long tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  long tmp___83 ;
  long tmp___84 ;
  long tmp___85 ;
  char const   *p_cr ;
  char const   *p_lf ;
  size_t limit ;
  void *tmp___86 ;
  void *tmp___87 ;
  long tmp___88 ;
  uint64_t t ;
  int tmp___89 ;
  long tmp___90 ;
  long tmp___91 ;
  long tmp___92 ;
  long tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  long tmp___96 ;
  long tmp___97 ;
  long tmp___98 ;
  int tmp___99 ;
  int tmp___100 ;
  long tmp___101 ;
  long tmp___102 ;
  long tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;
  int hasBody ;
  int tmp___106 ;
  int tmp___108 ;
  int tmp___109 ;
  int tmp___110 ;
  int tmp___111 ;
  int tmp___112 ;
  long tmp___113 ;
  long tmp___114 ;
  long tmp___115 ;
  int tmp___117 ;
  int tmp___118 ;
  int tmp___119 ;
  int tmp___120 ;
  int tmp___121 ;
  long tmp___122 ;
  long tmp___123 ;
  long tmp___124 ;
  int tmp___126 ;
  int tmp___127 ;
  int tmp___128 ;
  int tmp___129 ;
  int tmp___130 ;
  long tmp___131 ;
  long tmp___132 ;
  long tmp___133 ;
  int tmp___135 ;
  int tmp___136 ;
  int tmp___137 ;
  int tmp___138 ;
  int tmp___139 ;
  long tmp___140 ;
  long tmp___141 ;
  long tmp___142 ;
  int tmp___143 ;
  uint64_t to_read ;
  uint64_t tmp___144 ;
  int tmp___145 ;
  int tmp___146 ;
  long tmp___147 ;
  long tmp___148 ;
  long tmp___149 ;
  int tmp___151 ;
  int tmp___152 ;
  int tmp___153 ;
  int tmp___154 ;
  int tmp___155 ;
  long tmp___156 ;
  long tmp___157 ;
  long tmp___158 ;
  long tmp___159 ;
  uint64_t t___0 ;
  long tmp___160 ;
  int tmp___161 ;
  int tmp___162 ;
  long tmp___163 ;
  long tmp___164 ;
  long tmp___165 ;
  uint64_t to_read___0 ;
  uint64_t tmp___166 ;
  int tmp___167 ;
  int tmp___168 ;
  long tmp___169 ;
  long tmp___170 ;
  long tmp___171 ;
  int tmp___172 ;
  int tmp___173 ;
  long tmp___174 ;
  long tmp___175 ;
  long tmp___176 ;
  int tmp___177 ;
  int tmp___178 ;
  int tmp___179 ;
  int tmp___180 ;
  int tmp___181 ;
  int tmp___182 ;
  int tmp___183 ;
  long tmp___184 ;
  long tmp___185 ;
  long tmp___186 ;
  int tmp___187 ;
  int tmp___188 ;
  long tmp___189 ;
  long tmp___190 ;
  long tmp___191 ;
  int tmp___192 ;
  int tmp___193 ;
  long tmp___194 ;
  long tmp___195 ;
  long tmp___196 ;
  int tmp___197 ;
  int tmp___198 ;
  long tmp___199 ;
  long tmp___200 ;
  long tmp___201 ;
  int tmp___202 ;
  int tmp___203 ;
  long tmp___204 ;
  long tmp___205 ;
  long tmp___206 ;

  {
  p = data;
  header_field_mark = (char const   *)0;
  header_value_mark = (char const   *)0;
  url_mark = (char const   *)0;
  body_mark = (char const   *)0;
  status_mark = (char const   *)0;
  p_state = (enum state )parser->state;
  lenient = parser->lenient_http_headers;
  if ((unsigned int )((enum http_errno )parser->http_errno) != 0U) {
    return ((size_t )0);
  }
  if (len == 0UL) {
    switch ((unsigned int )p_state) {
    case 61U: 
    while (1) {
      if (! ((unsigned int )((enum http_errno )parser->http_errno) == 0U)) {
        __assert_fail("HTTP_PARSER_ERRNO(parser) == HPE_OK", "src/http_parser.c",
                      658U, "http_parser_execute");
      }
      tmp___3 = __builtin_expect((long )(! (! settings->on_message_complete)), 1L);
      if (tmp___3) {
        parser->state = (unsigned int )p_state;
        tmp = (*(settings->on_message_complete))(parser);
        if (0 != tmp) {
          tmp___0 = 1;
        } else {
          tmp___0 = 0;
        }
        tmp___1 = __builtin_expect((long )tmp___0, 0L);
        if (tmp___1) {
          while (1) {
            parser->http_errno = 7U;
            break;
          }
        }
        p_state = (enum state )parser->state;
        tmp___2 = __builtin_expect((long )(! (! ((unsigned int )((enum http_errno )parser->http_errno) != 0U))),
                                   0L);
        if (tmp___2) {
          return ((size_t )(p - data));
        }
      }
      break;
    }
    return ((size_t )0);
    case 18U: 
    case 4U: 
    case 2U: 
    case 1U: 
    return ((size_t )0);
    default: 
    while (1) {
      parser->http_errno = 11U;
      break;
    }
    return ((size_t )1);
    }
  }
  if ((unsigned int )p_state == 43U) {
    header_field_mark = data;
  }
  if ((unsigned int )p_state == 48U) {
    header_value_mark = data;
  }
  switch ((unsigned int )p_state) {
  case 31U: 
  case 30U: 
  case 29U: 
  case 28U: 
  case 26U: 
  case 25U: 
  case 24U: 
  case 23U: 
  case 22U: 
  case 21U: 
  case 27U: 
  url_mark = data;
  break;
  case 16U: 
  status_mark = data;
  break;
  default: 
  break;
  }
  p = data;
  while ((unsigned long )p != (unsigned long )(data + len)) {
    ch = (char )*p;
    if ((unsigned int )p_state <= 56U) {
      while (1) {
        (parser->nread) ++;
        tmp___4 = __builtin_expect((long )(! (! (parser->nread > 81920U))), 0L);
        if (tmp___4) {
          while (1) {
            parser->http_errno = 12U;
            break;
          }
          goto error;
        }
        break;
      }
    }
    reexecute: 
    switch ((unsigned int )p_state) {
    case 1U: 
    if ((int )ch == 13) {
      tmp___5 = 1;
    } else
    if ((int )ch == 10) {
      tmp___5 = 1;
    } else {
      tmp___5 = 0;
    }
    tmp___6 = __builtin_expect((long )tmp___5, 1L);
    if (tmp___6) {
      break;
    }
    while (1) {
      parser->http_errno = 13U;
      break;
    }
    goto error;
    case 2U: 
    if ((int )ch == 13) {
      break;
    } else
    if ((int )ch == 10) {
      break;
    }
    parser->flags = 0U;
    parser->content_length = (uint64_t )18446744073709551615;
    if ((int )ch == 72) {
      p_state = (enum state )3;
      while (1) {
        if (! ((unsigned int )((enum http_errno )parser->http_errno) == 0U)) {
          __assert_fail("HTTP_PARSER_ERRNO(parser) == HPE_OK", "src/http_parser.c",
                        728U, "http_parser_execute");
        }
        tmp___11 = __builtin_expect((long )(! (! settings->on_message_begin)), 1L);
        if (tmp___11) {
          parser->state = (unsigned int )p_state;
          tmp___7 = (*(settings->on_message_begin))(parser);
          if (0 != tmp___7) {
            tmp___8 = 1;
          } else {
            tmp___8 = 0;
          }
          tmp___9 = __builtin_expect((long )tmp___8, 0L);
          if (tmp___9) {
            while (1) {
              parser->http_errno = 1U;
              break;
            }
          }
          p_state = (enum state )parser->state;
          tmp___10 = __builtin_expect((long )(! (! ((unsigned int )((enum http_errno )parser->http_errno) != 0U))),
                                      0L);
          if (tmp___10) {
            return ((size_t )((p - data) + 1L));
          }
        }
        break;
      }
    } else {
      parser->type = 0U;
      p_state = (enum state )18;
      goto reexecute;
    }
    break;
    case 3U: 
    if ((int )ch == 84) {
      parser->type = 1U;
      p_state = (enum state )6;
    } else {
      tmp___12 = __builtin_expect((long )(! (! ((int )ch != 69))), 0L);
      if (tmp___12) {
        while (1) {
          parser->http_errno = 28U;
          break;
        }
        goto error;
      }
      parser->type = 0U;
      parser->method = 2U;
      parser->index = 2U;
      p_state = (enum state )19;
    }
    break;
    case 4U: 
    parser->flags = 0U;
    parser->content_length = (uint64_t )18446744073709551615;
    switch ((int )ch) {
    case 72: 
    p_state = (enum state )5;
    break;
    case 10: 
    case 13: 
    break;
    default: 
    while (1) {
      parser->http_errno = 28U;
      break;
    }
    goto error;
    }
    while (1) {
      if (! ((unsigned int )((enum http_errno )parser->http_errno) == 0U)) {
        __assert_fail("HTTP_PARSER_ERRNO(parser) == HPE_OK", "src/http_parser.c",
                      774U, "http_parser_execute");
      }
      tmp___17 = __builtin_expect((long )(! (! settings->on_message_begin)), 1L);
      if (tmp___17) {
        parser->state = (unsigned int )p_state;
        tmp___13 = (*(settings->on_message_begin))(parser);
        if (0 != tmp___13) {
          tmp___14 = 1;
        } else {
          tmp___14 = 0;
        }
        tmp___15 = __builtin_expect((long )tmp___14, 0L);
        if (tmp___15) {
          while (1) {
            parser->http_errno = 1U;
            break;
          }
        }
        p_state = (enum state )parser->state;
        tmp___16 = __builtin_expect((long )(! (! ((unsigned int )((enum http_errno )parser->http_errno) != 0U))),
                                    0L);
        if (tmp___16) {
          return ((size_t )((p - data) + 1L));
        }
      }
      break;
    }
    break;
    case 5U: 
    while (1) {
      if ((int )ch != 84) {
        while (1) {
          parser->http_errno = 30U;
          break;
        }
        goto error;
      }
      break;
    }
    p_state = (enum state )6;
    break;
    case 6U: 
    while (1) {
      if ((int )ch != 84) {
        while (1) {
          parser->http_errno = 30U;
          break;
        }
        goto error;
      }
      break;
    }
    p_state = (enum state )7;
    break;
    case 7U: 
    while (1) {
      if ((int )ch != 80) {
        while (1) {
          parser->http_errno = 30U;
          break;
        }
        goto error;
      }
      break;
    }
    p_state = (enum state )8;
    break;
    case 8U: 
    while (1) {
      if ((int )ch != 47) {
        while (1) {
          parser->http_errno = 30U;
          break;
        }
        goto error;
      }
      break;
    }
    p_state = (enum state )9;
    break;
    case 9U: 
    if ((int )ch >= 48) {
      if ((int )ch <= 57) {
        tmp___18 = 0;
      } else {
        tmp___18 = 1;
      }
    } else {
      tmp___18 = 1;
    }
    tmp___19 = __builtin_expect((long )tmp___18, 0L);
    if (tmp___19) {
      while (1) {
        parser->http_errno = 14U;
        break;
      }
      goto error;
    }
    parser->http_major = (unsigned short )((int )ch - 48);
    p_state = (enum state )10;
    break;
    case 10U: 
    tmp___20 = __builtin_expect((long )(! (! ((int )ch != 46))), 0L);
    if (tmp___20) {
      while (1) {
        parser->http_errno = 14U;
        break;
      }
      goto error;
    }
    p_state = (enum state )11;
    break;
    case 11U: 
    if ((int )ch >= 48) {
      if ((int )ch <= 57) {
        tmp___21 = 0;
      } else {
        tmp___21 = 1;
      }
    } else {
      tmp___21 = 1;
    }
    tmp___22 = __builtin_expect((long )tmp___21, 0L);
    if (tmp___22) {
      while (1) {
        parser->http_errno = 14U;
        break;
      }
      goto error;
    }
    parser->http_minor = (unsigned short )((int )ch - 48);
    p_state = (enum state )12;
    break;
    case 12U: 
    tmp___23 = __builtin_expect((long )(! (! ((int )ch != 32))), 0L);
    if (tmp___23) {
      while (1) {
        parser->http_errno = 14U;
        break;
      }
      goto error;
    }
    p_state = (enum state )13;
    break;
    case 13U: 
    if ((int )ch >= 48) {
      if (! ((int )ch <= 57)) {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      if ((int )ch == 32) {
        break;
      }
      while (1) {
        parser->http_errno = 15U;
        break;
      }
      goto error;
    }
    parser->status_code = (unsigned int )((int )ch - 48);
    p_state = (enum state )14;
    break;
    case 14U: 
    if ((int )ch >= 48) {
      if (! ((int )ch <= 57)) {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      switch ((int )ch) {
      case 32: 
      p_state = (enum state )15;
      break;
      case 10: 
      case 13: 
      p_state = (enum state )15;
      goto reexecute;
      break;
      default: 
      while (1) {
        parser->http_errno = 15U;
        break;
      }
      goto error;
      }
      break;
    }
    parser->status_code *= 10U;
    parser->status_code += (unsigned int )((int )ch - 48);
    tmp___24 = __builtin_expect((long )(! (! (parser->status_code > 999U))), 0L);
    if (tmp___24) {
      while (1) {
        parser->http_errno = 15U;
        break;
      }
      goto error;
    }
    break;
    case 15U: 
    while (1) {
      if (! status_mark) {
        status_mark = p;
      }
      break;
    }
    p_state = (enum state )16;
    parser->index = 0U;
    if ((int )ch == 13) {
      goto reexecute;
    } else
    if ((int )ch == 10) {
      goto reexecute;
    }
    break;
    case 16U: 
    if ((int )ch == 13) {
      p_state = (enum state )17;
      while (1) {
        if (! ((unsigned int )((enum http_errno )parser->http_errno) == 0U)) {
          __assert_fail("HTTP_PARSER_ERRNO(parser) == HPE_OK", "src/http_parser.c",
                        900U, "http_parser_execute");
        }
        if (status_mark) {
          tmp___29 = __builtin_expect((long )(! (! settings->on_status)), 1L);
          if (tmp___29) {
            parser->state = (unsigned int )p_state;
            tmp___25 = (*(settings->on_status))(parser, status_mark, (size_t )(p - status_mark));
            if (0 != tmp___25) {
              tmp___26 = 1;
            } else {
              tmp___26 = 0;
            }
            tmp___27 = __builtin_expect((long )tmp___26, 0L);
            if (tmp___27) {
              while (1) {
                parser->http_errno = 8U;
                break;
              }
            }
            p_state = (enum state )parser->state;
            tmp___28 = __builtin_expect((long )(! (! ((unsigned int )((enum http_errno )parser->http_errno) != 0U))),
                                        0L);
            if (tmp___28) {
              return ((size_t )((p - data) + 1L));
            }
          }
          status_mark = (char const   *)((void *)0);
        }
        break;
      }
      break;
    }
    if ((int )ch == 10) {
      p_state = (enum state )42;
      while (1) {
        if (! ((unsigned int )((enum http_errno )parser->http_errno) == 0U)) {
          __assert_fail("HTTP_PARSER_ERRNO(parser) == HPE_OK", "src/http_parser.c",
                        906U, "http_parser_execute");
        }
        if (status_mark) {
          tmp___34 = __builtin_expect((long )(! (! settings->on_status)), 1L);
          if (tmp___34) {
            parser->state = (unsigned int )p_state;
            tmp___30 = (*(settings->on_status))(parser, status_mark, (size_t )(p - status_mark));
            if (0 != tmp___30) {
              tmp___31 = 1;
            } else {
              tmp___31 = 0;
            }
            tmp___32 = __builtin_expect((long )tmp___31, 0L);
            if (tmp___32) {
              while (1) {
                parser->http_errno = 8U;
                break;
              }
            }
            p_state = (enum state )parser->state;
            tmp___33 = __builtin_expect((long )(! (! ((unsigned int )((enum http_errno )parser->http_errno) != 0U))),
                                        0L);
            if (tmp___33) {
              return ((size_t )((p - data) + 1L));
            }
          }
          status_mark = (char const   *)((void *)0);
        }
        break;
      }
      break;
    }
    break;
    case 17U: 
    while (1) {
      if ((int )ch != 10) {
        while (1) {
          parser->http_errno = 30U;
          break;
        }
        goto error;
      }
      break;
    }
    p_state = (enum state )42;
    break;
    case 18U: 
    if ((int )ch == 13) {
      break;
    } else
    if ((int )ch == 10) {
      break;
    }
    parser->flags = 0U;
    parser->content_length = (uint64_t )18446744073709551615;
    if ((int )((unsigned char )((int )ch | 32)) >= 97) {
      if ((int )((unsigned char )((int )ch | 32)) <= 122) {
        tmp___35 = 0;
      } else {
        tmp___35 = 1;
      }
    } else {
      tmp___35 = 1;
    }
    tmp___36 = __builtin_expect((long )tmp___35, 0L);
    if (tmp___36) {
      while (1) {
        parser->http_errno = 16U;
        break;
      }
      goto error;
    }
    parser->method = (unsigned int )((enum http_method )0);
    parser->index = 1U;
    switch ((int )ch) {
    case 65: 
    parser->method = 19U;
    break;
    case 66: 
    parser->method = 16U;
    break;
    case 67: 
    parser->method = 5U;
    break;
    case 68: 
    parser->method = 0U;
    break;
    case 71: 
    parser->method = 1U;
    break;
    case 72: 
    parser->method = 2U;
    break;
    case 76: 
    parser->method = 9U;
    break;
    case 77: 
    parser->method = 10U;
    break;
    case 78: 
    parser->method = 25U;
    break;
    case 79: 
    parser->method = 6U;
    break;
    case 80: 
    parser->method = 3U;
    break;
    case 82: 
    parser->method = 20U;
    break;
    case 83: 
    parser->method = 26U;
    break;
    case 84: 
    parser->method = 7U;
    break;
    case 85: 
    parser->method = 15U;
    break;
    default: 
    while (1) {
      parser->http_errno = 16U;
      break;
    }
    goto error;
    }
    p_state = (enum state )19;
    while (1) {
      if (! ((unsigned int )((enum http_errno )parser->http_errno) == 0U)) {
        __assert_fail("HTTP_PARSER_ERRNO(parser) == HPE_OK", "src/http_parser.c",
                      955U, "http_parser_execute");
      }
      tmp___41 = __builtin_expect((long )(! (! settings->on_message_begin)), 1L);
      if (tmp___41) {
        parser->state = (unsigned int )p_state;
        tmp___37 = (*(settings->on_message_begin))(parser);
        if (0 != tmp___37) {
          tmp___38 = 1;
        } else {
          tmp___38 = 0;
        }
        tmp___39 = __builtin_expect((long )tmp___38, 0L);
        if (tmp___39) {
          while (1) {
            parser->http_errno = 1U;
            break;
          }
        }
        p_state = (enum state )parser->state;
        tmp___40 = __builtin_expect((long )(! (! ((unsigned int )((enum http_errno )parser->http_errno) != 0U))),
                                    0L);
        if (tmp___40) {
          return ((size_t )((p - data) + 1L));
        }
      }
      break;
    }
    break;
    case 19U: 
    tmp___42 = __builtin_expect((long )(! (! ((int )ch == 0))), 0L);
    if (tmp___42) {
      while (1) {
        parser->http_errno = 16U;
        break;
      }
      goto error;
    }
    matcher = method_strings[parser->method];
    if ((int )ch == 32) {
      if ((int const   )*(matcher + parser->index) == 0) {
        p_state = (enum state )20;
      } else {
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
    if (! ((int )ch == (int )*(matcher + parser->index))) {
      if ((int )ch >= 65) {
        if ((int )ch <= 90) {
          goto _L___1;
        } else {
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
      if ((int )ch == 45) {
        _L___1: /* CIL Label */ 
        switch (((parser->method << 16) | (parser->index << 8)) | (unsigned int )ch) {
        case (unsigned int )(((3 << 16) | (1 << 8)) | 85): 
        parser->method = 4U;
        break;
        case (unsigned int )(((3 << 16) | (1 << 8)) | 65): 
        parser->method = 28U;
        break;
        case (unsigned int )(((3 << 16) | (1 << 8)) | 82): 
        parser->method = 12U;
        break;
        case (unsigned int )(((4 << 16) | (2 << 8)) | 82): 
        parser->method = 29U;
        break;
        case (unsigned int )(((5 << 16) | (1 << 8)) | 72): 
        parser->method = 22U;
        break;
        case (unsigned int )(((5 << 16) | (2 << 8)) | 80): 
        parser->method = 8U;
        break;
        case (unsigned int )(((10 << 16) | (1 << 8)) | 79): 
        parser->method = 11U;
        break;
        case (unsigned int )(((10 << 16) | (1 << 8)) | 69): 
        parser->method = 23U;
        break;
        case (unsigned int )(((10 << 16) | (1 << 8)) | 45): 
        parser->method = 24U;
        break;
        case (unsigned int )(((10 << 16) | (2 << 8)) | 65): 
        parser->method = 21U;
        break;
        case (unsigned int )(((10 << 16) | (3 << 8)) | 65): 
        parser->method = 30U;
        break;
        case (unsigned int )(((26 << 16) | (1 << 8)) | 69): 
        parser->method = 14U;
        break;
        case (unsigned int )(((20 << 16) | (2 << 8)) | 66): 
        parser->method = 17U;
        break;
        case (unsigned int )(((12 << 16) | (4 << 8)) | 80): 
        parser->method = 13U;
        break;
        case (unsigned int )(((9 << 16) | (1 << 8)) | 73): 
        parser->method = 31U;
        break;
        case (unsigned int )(((15 << 16) | (2 << 8)) | 83): 
        parser->method = 27U;
        break;
        case (unsigned int )(((15 << 16) | (2 << 8)) | 66): 
        parser->method = 18U;
        break;
        case (unsigned int )(((15 << 16) | (3 << 8)) | 73): 
        parser->method = 32U;
        break;
        default: 
        while (1) {
          parser->http_errno = 16U;
          break;
        }
        goto error;
        }
      } else {
        while (1) {
          parser->http_errno = 16U;
          break;
        }
        goto error;
      }
    }
    (parser->index) ++;
    break;
    case 20U: 
    if ((int )ch == 32) {
      break;
    }
    while (1) {
      if (! url_mark) {
        url_mark = p;
      }
      break;
    }
    if (parser->method == 5U) {
      p_state = (enum state )24;
    }
    tmp___43 = parse_url_char(p_state, (char const   )ch);
    p_state = tmp___43;
    tmp___44 = __builtin_expect((long )(! (! ((unsigned int )p_state == 1U))), 0L);
    if (tmp___44) {
      while (1) {
        parser->http_errno = 17U;
        break;
      }
      goto error;
    }
    break;
    case 24U: 
    case 23U: 
    case 22U: 
    case 21U: 
    switch ((int )ch) {
    case 10: 
    case 13: 
    case 32: 
    while (1) {
      parser->http_errno = 17U;
      break;
    }
    goto error;
    default: 
    tmp___45 = parse_url_char(p_state, (char const   )ch);
    p_state = tmp___45;
    tmp___46 = __builtin_expect((long )(! (! ((unsigned int )p_state == 1U))), 0L);
    if (tmp___46) {
      while (1) {
        parser->http_errno = 17U;
        break;
      }
      goto error;
    }
    }
    break;
    case 31U: 
    case 30U: 
    case 29U: 
    case 28U: 
    case 27U: 
    case 26U: 
    case 25U: 
    switch ((int )ch) {
    case 32: 
    p_state = (enum state )32;
    while (1) {
      if (! ((unsigned int )((enum http_errno )parser->http_errno) == 0U)) {
        __assert_fail("HTTP_PARSER_ERRNO(parser) == HPE_OK", "src/http_parser.c",
                      1064U, "http_parser_execute");
      }
      if (url_mark) {
        tmp___51 = __builtin_expect((long )(! (! settings->on_url)), 1L);
        if (tmp___51) {
          parser->state = (unsigned int )p_state;
          tmp___47 = (*(settings->on_url))(parser, url_mark, (size_t )(p - url_mark));
          if (0 != tmp___47) {
            tmp___48 = 1;
          } else {
            tmp___48 = 0;
          }
          tmp___49 = __builtin_expect((long )tmp___48, 0L);
          if (tmp___49) {
            while (1) {
              parser->http_errno = 2U;
              break;
            }
          }
          p_state = (enum state )parser->state;
          tmp___50 = __builtin_expect((long )(! (! ((unsigned int )((enum http_errno )parser->http_errno) != 0U))),
                                      0L);
          if (tmp___50) {
            return ((size_t )((p - data) + 1L));
          }
        }
        url_mark = (char const   *)((void *)0);
      }
      break;
    }
    break;
    case 10: 
    case 13: 
    parser->http_major = (unsigned short)0;
    parser->http_minor = (unsigned short)9;
    if ((int )ch == 13) {
      tmp___52 = 41;
    } else {
      tmp___52 = 42;
    }
    p_state = (enum state )tmp___52;
    while (1) {
      if (! ((unsigned int )((enum http_errno )parser->http_errno) == 0U)) {
        __assert_fail("HTTP_PARSER_ERRNO(parser) == HPE_OK", "src/http_parser.c",
                      1073U, "http_parser_execute");
      }
      if (url_mark) {
        tmp___57 = __builtin_expect((long )(! (! settings->on_url)), 1L);
        if (tmp___57) {
          parser->state = (unsigned int )p_state;
          tmp___53 = (*(settings->on_url))(parser, url_mark, (size_t )(p - url_mark));
          if (0 != tmp___53) {
            tmp___54 = 1;
          } else {
            tmp___54 = 0;
          }
          tmp___55 = __builtin_expect((long )tmp___54, 0L);
          if (tmp___55) {
            while (1) {
              parser->http_errno = 2U;
              break;
            }
          }
          p_state = (enum state )parser->state;
          tmp___56 = __builtin_expect((long )(! (! ((unsigned int )((enum http_errno )parser->http_errno) != 0U))),
                                      0L);
          if (tmp___56) {
            return ((size_t )((p - data) + 1L));
          }
        }
        url_mark = (char const   *)((void *)0);
      }
      break;
    }
    break;
    default: 
    tmp___58 = parse_url_char(p_state, (char const   )ch);
    p_state = tmp___58;
    tmp___59 = __builtin_expect((long )(! (! ((unsigned int )p_state == 1U))), 0L);
    if (tmp___59) {
      while (1) {
        parser->http_errno = 17U;
        break;
      }
      goto error;
    }
    }
    break;
    case 32U: 
    switch ((int )ch) {
    case 72: 
    p_state = (enum state )33;
    break;
    case 32: 
    break;
    default: 
    while (1) {
      parser->http_errno = 28U;
      break;
    }
    goto error;
    }
    break;
    case 33U: 
    while (1) {
      if ((int )ch != 84) {
        while (1) {
          parser->http_errno = 30U;
          break;
        }
        goto error;
      }
      break;
    }
    p_state = (enum state )34;
    break;
    case 34U: 
    while (1) {
      if ((int )ch != 84) {
        while (1) {
          parser->http_errno = 30U;
          break;
        }
        goto error;
      }
      break;
    }
    p_state = (enum state )35;
    break;
    case 35U: 
    while (1) {
      if ((int )ch != 80) {
        while (1) {
          parser->http_errno = 30U;
          break;
        }
        goto error;
      }
      break;
    }
    p_state = (enum state )36;
    break;
    case 36U: 
    while (1) {
      if ((int )ch != 47) {
        while (1) {
          parser->http_errno = 30U;
          break;
        }
        goto error;
      }
      break;
    }
    p_state = (enum state )37;
    break;
    case 37U: 
    if ((int )ch >= 48) {
      if ((int )ch <= 57) {
        tmp___60 = 0;
      } else {
        tmp___60 = 1;
      }
    } else {
      tmp___60 = 1;
    }
    tmp___61 = __builtin_expect((long )tmp___60, 0L);
    if (tmp___61) {
      while (1) {
        parser->http_errno = 14U;
        break;
      }
      goto error;
    }
    parser->http_major = (unsigned short )((int )ch - 48);
    p_state = (enum state )38;
    break;
    case 38U: 
    tmp___62 = __builtin_expect((long )(! (! ((int )ch != 46))), 0L);
    if (tmp___62) {
      while (1) {
        parser->http_errno = 14U;
        break;
      }
      goto error;
    }
    p_state = (enum state )39;
    break;
    case 39U: 
    if ((int )ch >= 48) {
      if ((int )ch <= 57) {
        tmp___63 = 0;
      } else {
        tmp___63 = 1;
      }
    } else {
      tmp___63 = 1;
    }
    tmp___64 = __builtin_expect((long )tmp___63, 0L);
    if (tmp___64) {
      while (1) {
        parser->http_errno = 14U;
        break;
      }
      goto error;
    }
    parser->http_minor = (unsigned short )((int )ch - 48);
    p_state = (enum state )40;
    break;
    case 40U: 
    if ((int )ch == 13) {
      p_state = (enum state )41;
      break;
    }
    if ((int )ch == 10) {
      p_state = (enum state )42;
      break;
    }
    while (1) {
      parser->http_errno = 14U;
      break;
    }
    goto error;
    break;
    case 41U: 
    tmp___65 = __builtin_expect((long )(! (! ((int )ch != 10))), 0L);
    if (tmp___65) {
      while (1) {
        parser->http_errno = 23U;
        break;
      }
      goto error;
    }
    p_state = (enum state )42;
    break;
    case 42U: 
    if ((int )ch == 13) {
      p_state = (enum state )55;
      break;
    }
    if ((int )ch == 10) {
      p_state = (enum state )55;
      goto reexecute;
    }
    c = (char )tokens[(unsigned char )ch];
    tmp___66 = __builtin_expect((long )(! (! (! c))), 0L);
    if (tmp___66) {
      while (1) {
        parser->http_errno = 24U;
        break;
      }
      goto error;
    }
    while (1) {
      if (! header_field_mark) {
        header_field_mark = p;
      }
      break;
    }
    parser->index = 0U;
    p_state = (enum state )43;
    switch ((int )c) {
    case 99: 
    parser->header_state = 1U;
    break;
    case 112: 
    parser->header_state = 5U;
    break;
    case 116: 
    parser->header_state = 7U;
    break;
    case 117: 
    parser->header_state = 8U;
    break;
    default: 
    parser->header_state = 0U;
    break;
    }
    break;
    case 43U: 
    start = p;
    while ((unsigned long )p != (unsigned long )(data + len)) {
      ch = (char )*p;
      c = (char )tokens[(unsigned char )ch];
      if (! c) {
        break;
      }
      switch (parser->header_state) {
      case 0U: 
      break;
      case 1U: 
      (parser->index) ++;
      if ((int )c == 111) {
        parser->header_state = 2U;
      } else {
        parser->header_state = 0U;
      }
      break;
      case 2U: 
      (parser->index) ++;
      if ((int )c == 110) {
        parser->header_state = 3U;
      } else {
        parser->header_state = 0U;
      }
      break;
      case 3U: 
      (parser->index) ++;
      switch ((int )c) {
      case 110: 
      parser->header_state = 4U;
      break;
      case 116: 
      parser->header_state = 6U;
      break;
      default: 
      parser->header_state = 0U;
      break;
      }
      break;
      case 4U: 
      (parser->index) ++;
      if ((unsigned long )parser->index > sizeof("connection") - 1UL) {
        parser->header_state = 0U;
      } else
      if ((int )c != (int )*("connection" + parser->index)) {
        parser->header_state = 0U;
      } else
      if ((unsigned long )parser->index == sizeof("connection") - 2UL) {
        parser->header_state = 9U;
      }
      break;
      case 5U: 
      (parser->index) ++;
      if ((unsigned long )parser->index > sizeof("proxy-connection") - 1UL) {
        parser->header_state = 0U;
      } else
      if ((int )c != (int )*("proxy-connection" + parser->index)) {
        parser->header_state = 0U;
      } else
      if ((unsigned long )parser->index == sizeof("proxy-connection") - 2UL) {
        parser->header_state = 9U;
      }
      break;
      case 6U: 
      (parser->index) ++;
      if ((unsigned long )parser->index > sizeof("content-length") - 1UL) {
        parser->header_state = 0U;
      } else
      if ((int )c != (int )*("content-length" + parser->index)) {
        parser->header_state = 0U;
      } else
      if ((unsigned long )parser->index == sizeof("content-length") - 2UL) {
        parser->header_state = 10U;
      }
      break;
      case 7U: 
      (parser->index) ++;
      if ((unsigned long )parser->index > sizeof("transfer-encoding") - 1UL) {
        parser->header_state = 0U;
      } else
      if ((int )c != (int )*("transfer-encoding" + parser->index)) {
        parser->header_state = 0U;
      } else
      if ((unsigned long )parser->index == sizeof("transfer-encoding") - 2UL) {
        parser->header_state = 11U;
      }
      break;
      case 8U: 
      (parser->index) ++;
      if ((unsigned long )parser->index > sizeof("upgrade") - 1UL) {
        parser->header_state = 0U;
      } else
      if ((int )c != (int )*("upgrade" + parser->index)) {
        parser->header_state = 0U;
      } else
      if ((unsigned long )parser->index == sizeof("upgrade") - 2UL) {
        parser->header_state = 12U;
      }
      break;
      case 12U: 
      case 11U: 
      case 10U: 
      case 9U: 
      if ((int )ch != 32) {
        parser->header_state = 0U;
      }
      break;
      default: 
      __assert_fail("0 && \"Unknown header_state\"", "src/http_parser.c", 1335U, "http_parser_execute");
      break;
      }
      p ++;
    }
    while (1) {
      parser->nread = (uint32_t )((long )parser->nread + (p - start));
      tmp___67 = __builtin_expect((long )(! (! (parser->nread > 81920U))), 0L);
      if (tmp___67) {
        while (1) {
          parser->http_errno = 12U;
          break;
        }
        goto error;
      }
      break;
    }
    if ((unsigned long )p == (unsigned long )(data + len)) {
      p --;
      break;
    }
    if ((int )ch == 58) {
      p_state = (enum state )44;
      while (1) {
        if (! ((unsigned int )((enum http_errno )parser->http_errno) == 0U)) {
          __assert_fail("HTTP_PARSER_ERRNO(parser) == HPE_OK", "src/http_parser.c",
                        1349U, "http_parser_execute");
        }
        if (header_field_mark) {
          tmp___72 = __builtin_expect((long )(! (! settings->on_header_field)), 1L);
          if (tmp___72) {
            parser->state = (unsigned int )p_state;
            tmp___68 = (*(settings->on_header_field))(parser, header_field_mark, (size_t )(p - header_field_mark));
            if (0 != tmp___68) {
              tmp___69 = 1;
            } else {
              tmp___69 = 0;
            }
            tmp___70 = __builtin_expect((long )tmp___69, 0L);
            if (tmp___70) {
              while (1) {
                parser->http_errno = 3U;
                break;
              }
            }
            p_state = (enum state )parser->state;
            tmp___71 = __builtin_expect((long )(! (! ((unsigned int )((enum http_errno )parser->http_errno) != 0U))),
                                        0L);
            if (tmp___71) {
              return ((size_t )((p - data) + 1L));
            }
          }
          header_field_mark = (char const   *)((void *)0);
        }
        break;
      }
      break;
    }
    while (1) {
      parser->http_errno = 24U;
      break;
    }
    goto error;
    case 44U: 
    if ((int )ch == 32) {
      break;
    } else
    if ((int )ch == 9) {
      break;
    }
    if ((int )ch == 13) {
      p_state = (enum state )45;
      break;
    }
    if ((int )ch == 10) {
      p_state = (enum state )46;
      break;
    }
    case 47U: 
    while (1) {
      if (! header_value_mark) {
        header_value_mark = p;
      }
      break;
    }
    p_state = (enum state )48;
    parser->index = 0U;
    c = (char )((unsigned char )((int )ch | 32));
    switch (parser->header_state) {
    case 12U: 
    parser->flags |= 32U;
    parser->header_state = 0U;
    break;
    case 11U: 
    if (99 == (int )c) {
      parser->header_state = 13U;
    } else {
      parser->header_state = 0U;
    }
    break;
    case 10U: 
    if ((int )ch >= 48) {
      if ((int )ch <= 57) {
        tmp___73 = 0;
      } else {
        tmp___73 = 1;
      }
    } else {
      tmp___73 = 1;
    }
    tmp___74 = __builtin_expect((long )tmp___73, 0L);
    if (tmp___74) {
      while (1) {
        parser->http_errno = 25U;
        break;
      }
      goto error;
    }
    if (parser->flags & 128U) {
      while (1) {
        parser->http_errno = 26U;
        break;
      }
      goto error;
    }
    parser->flags |= 128U;
    parser->content_length = (uint64_t )((int )ch - 48);
    break;
    case 9U: 
    if ((int )c == 107) {
      parser->header_state = 15U;
    } else
    if ((int )c == 99) {
      parser->header_state = 16U;
    } else
    if ((int )c == 117) {
      parser->header_state = 17U;
    } else {
      parser->header_state = 18U;
    }
    break;
    case 14U: 
    break;
    default: 
    parser->header_state = 0U;
    break;
    }
    break;
    case 48U: 
    start___0 = p;
    h_state = (enum header_states )parser->header_state;
    while ((unsigned long )p != (unsigned long )(data + len)) {
      ch = (char )*p;
      if ((int )ch == 13) {
        p_state = (enum state )50;
        parser->header_state = (unsigned int )h_state;
        while (1) {
          if (! ((unsigned int )((enum http_errno )parser->http_errno) == 0U)) {
            __assert_fail("HTTP_PARSER_ERRNO(parser) == HPE_OK", "src/http_parser.c",
                          1445U, "http_parser_execute");
          }
          if (header_value_mark) {
            tmp___79 = __builtin_expect((long )(! (! settings->on_header_value)),
                                        1L);
            if (tmp___79) {
              parser->state = (unsigned int )p_state;
              tmp___75 = (*(settings->on_header_value))(parser, header_value_mark,
                                                        (size_t )(p - header_value_mark));
              if (0 != tmp___75) {
                tmp___76 = 1;
              } else {
                tmp___76 = 0;
              }
              tmp___77 = __builtin_expect((long )tmp___76, 0L);
              if (tmp___77) {
                while (1) {
                  parser->http_errno = 4U;
                  break;
                }
              }
              p_state = (enum state )parser->state;
              tmp___78 = __builtin_expect((long )(! (! ((unsigned int )((enum http_errno )parser->http_errno) != 0U))),
                                          0L);
              if (tmp___78) {
                return ((size_t )((p - data) + 1L));
              }
            }
            header_value_mark = (char const   *)((void *)0);
          }
          break;
        }
        break;
      }
      if ((int )ch == 10) {
        p_state = (enum state )50;
        while (1) {
          parser->nread = (uint32_t )((long )parser->nread + (p - start___0));
          tmp___80 = __builtin_expect((long )(! (! (parser->nread > 81920U))), 0L);
          if (tmp___80) {
            while (1) {
              parser->http_errno = 12U;
              break;
            }
            goto error;
          }
          break;
        }
        parser->header_state = (unsigned int )h_state;
        while (1) {
          if (! ((unsigned int )((enum http_errno )parser->http_errno) == 0U)) {
            __assert_fail("HTTP_PARSER_ERRNO(parser) == HPE_OK", "src/http_parser.c",
                          1453U, "http_parser_execute");
          }
          if (header_value_mark) {
            tmp___85 = __builtin_expect((long )(! (! settings->on_header_value)),
                                        1L);
            if (tmp___85) {
              parser->state = (unsigned int )p_state;
              tmp___81 = (*(settings->on_header_value))(parser, header_value_mark,
                                                        (size_t )(p - header_value_mark));
              if (0 != tmp___81) {
                tmp___82 = 1;
              } else {
                tmp___82 = 0;
              }
              tmp___83 = __builtin_expect((long )tmp___82, 0L);
              if (tmp___83) {
                while (1) {
                  parser->http_errno = 4U;
                  break;
                }
              }
              p_state = (enum state )parser->state;
              tmp___84 = __builtin_expect((long )(! (! ((unsigned int )((enum http_errno )parser->http_errno) != 0U))),
                                          0L);
              if (tmp___84) {
                return ((size_t )(p - data));
              }
            }
            header_value_mark = (char const   *)((void *)0);
          }
          break;
        }
        goto reexecute;
      }
      if (! lenient) {
        if (! ((int )ch == 13)) {
          if (! ((int )ch == 10)) {
            if (! ((int )ch == 9)) {
              if ((int )((unsigned char )ch) > 31) {
                if (! ((int )ch != 127)) {
                  goto _L___4;
                }
              } else {
                _L___4: /* CIL Label */ 
                while (1) {
                  parser->http_errno = 24U;
                  break;
                }
                goto error;
              }
            }
          }
        }
      }
      c = (char )((unsigned char )((int )ch | 32));
      switch ((unsigned int )h_state) {
      case 0U: 
      limit = (size_t )((data + len) - p);
      if (limit < 81920UL) {
        limit = limit;
      } else {
        limit = (size_t )81920;
      }
      tmp___86 = memchr((void const   *)p, '\r', limit);
      p_cr = (char const   *)tmp___86;
      tmp___87 = memchr((void const   *)p, '\n', limit);
      p_lf = (char const   *)tmp___87;
      if ((unsigned long )p_cr != (unsigned long )((void *)0)) {
        if ((unsigned long )p_lf != (unsigned long )((void *)0)) {
          if ((unsigned long )p_cr >= (unsigned long )p_lf) {
            p = p_lf;
          } else {
            p = p_cr;
          }
        } else {
          p = p_cr;
        }
      } else {
        tmp___88 = __builtin_expect((long )(! (! ((unsigned long )p_lf != (unsigned long )((void *)0)))),
                                    0L);
        if (tmp___88) {
          p = p_lf;
        } else {
          p = data + len;
        }
      }
      p --;
      break;
      case 11U: 
      case 9U: 
      __assert_fail("0 && \"Shouldn\'t get here.\"", "src/http_parser.c", 1492U, "http_parser_execute");
      break;
      case 10U: 
      if ((int )ch == 32) {
        break;
      }
      if ((int )ch >= 48) {
        if ((int )ch <= 57) {
          tmp___89 = 0;
        } else {
          tmp___89 = 1;
        }
      } else {
        tmp___89 = 1;
      }
      tmp___90 = __builtin_expect((long )tmp___89, 0L);
      if (tmp___90) {
        while (1) {
          parser->http_errno = 25U;
          break;
        }
        parser->header_state = (unsigned int )h_state;
        goto error;
      }
      t = parser->content_length;
      t *= 10UL;
      t += (uint64_t )((int )ch - 48);
      tmp___91 = __builtin_expect((long )(! (! (1844674407370955160ULL < (unsigned long long )parser->content_length))),
                                  0L);
      if (tmp___91) {
        while (1) {
          parser->http_errno = 25U;
          break;
        }
        parser->header_state = (unsigned int )h_state;
        goto error;
      }
      parser->content_length = t;
      break;
      case 13U: 
      (parser->index) ++;
      if ((unsigned long )parser->index > sizeof("chunked") - 1UL) {
        h_state = (enum header_states )0;
      } else
      if ((int )c != (int )*("chunked" + parser->index)) {
        h_state = (enum header_states )0;
      } else
      if ((unsigned long )parser->index == sizeof("chunked") - 2UL) {
        h_state = (enum header_states )19;
      }
      break;
      case 14U: 
      if ((int )c == 107) {
        h_state = (enum header_states )15;
      } else
      if ((int )c == 99) {
        h_state = (enum header_states )16;
      } else
      if ((int )c == 117) {
        h_state = (enum header_states )17;
      } else
      if (tokens[(unsigned char )c]) {
        h_state = (enum header_states )18;
      } else
      if (! ((int )c == 32)) {
        if (! ((int )c == 9)) {
          h_state = (enum header_states )0;
        }
      }
      break;
      case 15U: 
      (parser->index) ++;
      if ((unsigned long )parser->index > sizeof("keep-alive") - 1UL) {
        h_state = (enum header_states )18;
      } else
      if ((int )c != (int )*("keep-alive" + parser->index)) {
        h_state = (enum header_states )18;
      } else
      if ((unsigned long )parser->index == sizeof("keep-alive") - 2UL) {
        h_state = (enum header_states )20;
      }
      break;
      case 16U: 
      (parser->index) ++;
      if ((unsigned long )parser->index > sizeof("close") - 1UL) {
        h_state = (enum header_states )18;
      } else
      if ((int )c != (int )*("close" + parser->index)) {
        h_state = (enum header_states )18;
      } else
      if ((unsigned long )parser->index == sizeof("close") - 2UL) {
        h_state = (enum header_states )21;
      }
      break;
      case 17U: 
      (parser->index) ++;
      if ((unsigned long )parser->index > sizeof("upgrade") - 1UL) {
        h_state = (enum header_states )18;
      } else
      if ((int )c != (int )*("upgrade" + parser->index)) {
        h_state = (enum header_states )18;
      } else
      if ((unsigned long )parser->index == sizeof("upgrade") - 2UL) {
        h_state = (enum header_states )22;
      }
      break;
      case 18U: 
      if ((int )ch == 44) {
        h_state = (enum header_states )14;
        parser->index = 0U;
      }
      break;
      case 19U: 
      if ((int )ch != 32) {
        h_state = (enum header_states )0;
      }
      break;
      case 22U: 
      case 21U: 
      case 20U: 
      if ((int )ch == 44) {
        if ((unsigned int )h_state == 20U) {
          parser->flags |= 2U;
        } else
        if ((unsigned int )h_state == 21U) {
          parser->flags |= 4U;
        } else
        if ((unsigned int )h_state == 22U) {
          parser->flags |= 8U;
        }
        h_state = (enum header_states )14;
        parser->index = 0U;
      } else
      if ((int )ch != 32) {
        h_state = (enum header_states )18;
      }
      break;
      default: 
      p_state = (enum state )48;
      h_state = (enum header_states )0;
      break;
      }
      p ++;
    }
    parser->header_state = (unsigned int )h_state;
    while (1) {
      parser->nread = (uint32_t )((long )parser->nread + (p - start___0));
      tmp___92 = __builtin_expect((long )(! (! (parser->nread > 81920U))), 0L);
      if (tmp___92) {
        while (1) {
          parser->http_errno = 12U;
          break;
        }
        goto error;
      }
      break;
    }
    if ((unsigned long )p == (unsigned long )(data + len)) {
      p --;
    }
    break;
    case 50U: 
    tmp___93 = __builtin_expect((long )(! (! ((int )ch != 10))), 0L);
    if (tmp___93) {
      while (1) {
        parser->http_errno = 23U;
        break;
      }
      goto error;
    }
    p_state = (enum state )49;
    break;
    case 49U: 
    if ((int )ch == 32) {
      p_state = (enum state )47;
      goto reexecute;
    } else
    if ((int )ch == 9) {
      p_state = (enum state )47;
      goto reexecute;
    }
    switch (parser->header_state) {
    case 20U: 
    parser->flags |= 2U;
    break;
    case 21U: 
    parser->flags |= 4U;
    break;
    case 19U: 
    parser->flags |= 1U;
    break;
    case 22U: 
    parser->flags |= 8U;
    break;
    default: 
    break;
    }
    p_state = (enum state )42;
    goto reexecute;
    case 45U: 
    while (1) {
      if ((int )ch != 10) {
        while (1) {
          parser->http_errno = 30U;
          break;
        }
        goto error;
      }
      break;
    }
    p_state = (enum state )46;
    break;
    case 46U: 
    if ((int )ch == 32) {
      p_state = (enum state )44;
      break;
    } else
    if ((int )ch == 9) {
      p_state = (enum state )44;
      break;
    } else {
      switch (parser->header_state) {
      case 20U: 
      parser->flags |= 2U;
      break;
      case 21U: 
      parser->flags |= 4U;
      break;
      case 22U: 
      parser->flags |= 8U;
      break;
      case 19U: 
      parser->flags |= 1U;
      break;
      default: 
      break;
      }
      while (1) {
        if (! header_value_mark) {
          header_value_mark = p;
        }
        break;
      }
      p_state = (enum state )42;
      while (1) {
        if (! ((unsigned int )((enum http_errno )parser->http_errno) == 0U)) {
          __assert_fail("HTTP_PARSER_ERRNO(parser) == HPE_OK", "src/http_parser.c",
                        1700U, "http_parser_execute");
        }
        if (header_value_mark) {
          tmp___98 = __builtin_expect((long )(! (! settings->on_header_value)), 1L);
          if (tmp___98) {
            parser->state = (unsigned int )p_state;
            tmp___94 = (*(settings->on_header_value))(parser, header_value_mark, (size_t )(p - header_value_mark));
            if (0 != tmp___94) {
              tmp___95 = 1;
            } else {
              tmp___95 = 0;
            }
            tmp___96 = __builtin_expect((long )tmp___95, 0L);
            if (tmp___96) {
              while (1) {
                parser->http_errno = 4U;
                break;
              }
            }
            p_state = (enum state )parser->state;
            tmp___97 = __builtin_expect((long )(! (! ((unsigned int )((enum http_errno )parser->http_errno) != 0U))),
                                        0L);
            if (tmp___97) {
              return ((size_t )(p - data));
            }
          }
          header_value_mark = (char const   *)((void *)0);
        }
        break;
      }
      goto reexecute;
    }
    case 55U: 
    while (1) {
      if ((int )ch != 10) {
        while (1) {
          parser->http_errno = 30U;
          break;
        }
        goto error;
      }
      break;
    }
    if (parser->flags & 16U) {
      p_state = (enum state )62;
      while (1) {
        if (! ((unsigned int )((enum http_errno )parser->http_errno) == 0U)) {
          __assert_fail("HTTP_PARSER_ERRNO(parser) == HPE_OK", "src/http_parser.c",
                        1712U, "http_parser_execute");
        }
        tmp___103 = __builtin_expect((long )(! (! settings->on_chunk_complete)), 1L);
        if (tmp___103) {
          parser->state = (unsigned int )p_state;
          tmp___99 = (*(settings->on_chunk_complete))(parser);
          if (0 != tmp___99) {
            tmp___100 = 1;
          } else {
            tmp___100 = 0;
          }
          tmp___101 = __builtin_expect((long )tmp___100, 0L);
          if (tmp___101) {
            while (1) {
              parser->http_errno = 10U;
              break;
            }
          }
          p_state = (enum state )parser->state;
          tmp___102 = __builtin_expect((long )(! (! ((unsigned int )((enum http_errno )parser->http_errno) != 0U))),
                                       0L);
          if (tmp___102) {
            return ((size_t )(p - data));
          }
        }
        break;
      }
      goto reexecute;
    }
    if (parser->flags & 1U) {
      if (parser->flags & 128U) {
        while (1) {
          parser->http_errno = 26U;
          break;
        }
        goto error;
      }
    }
    p_state = (enum state )56;
    if (parser->flags & 32U) {
      if (parser->flags & 8U) {
        if (parser->type == 0U) {
          tmp___104 = 1;
        } else
        if (parser->status_code == 101U) {
          tmp___104 = 1;
        } else {
          tmp___104 = 0;
        }
        parser->upgrade = (unsigned int )tmp___104;
      } else {
        parser->upgrade = (unsigned int )(parser->method == 5U);
      }
    } else {
      parser->upgrade = (unsigned int )(parser->method == 5U);
    }
    if (settings->on_headers_complete) {
      tmp___105 = (*(settings->on_headers_complete))(parser);
      switch (tmp___105) {
      case 0: 
      break;
      case 2: 
      parser->upgrade = 1U;
      case 1: 
      parser->flags |= 64U;
      break;
      default: 
      while (1) {
        parser->http_errno = 5U;
        break;
      }
      while (1) {
        parser->state = (unsigned int )p_state;
        return ((size_t )(p - data));
        break;
      }
      }
    }
    if ((unsigned int )((enum http_errno )parser->http_errno) != 0U) {
      while (1) {
        parser->state = (unsigned int )p_state;
        return ((size_t )(p - data));
        break;
      }
    }
    goto reexecute;
    case 56U: 
    while (1) {
      if ((int )ch != 10) {
        while (1) {
          parser->http_errno = 30U;
          break;
        }
        goto error;
      }
      break;
    }
    parser->nread = (uint32_t )0;
    if (parser->flags & 1U) {
      tmp___106 = 1;
    } else
    if (parser->content_length > 0UL) {
      if ((unsigned long long )parser->content_length != 18446744073709551615) {
        tmp___106 = 1;
      } else {
        tmp___106 = 0;
      }
    } else {
      tmp___106 = 0;
    }
    hasBody = tmp___106;
    if (parser->upgrade) {
      if (parser->method == 5U) {
        goto _L___5;
      } else
      if (parser->flags & 64U) {
        goto _L___5;
      } else
      if (! hasBody) {
        _L___5: /* CIL Label */ 
        tmp___110 = http_should_keep_alive((http_parser const   *)parser);
        if (tmp___110) {
          if (parser->type == 0U) {
            tmp___108 = 18;
          } else {
            tmp___108 = 4;
          }
          tmp___109 = tmp___108;
        } else {
          tmp___109 = 1;
        }
        p_state = (enum state )tmp___109;
        while (1) {
          if (! ((unsigned int )((enum http_errno )parser->http_errno) == 0U)) {
            __assert_fail("HTTP_PARSER_ERRNO(parser) == HPE_OK", "src/http_parser.c",
                          1787U, "http_parser_execute");
          }
          tmp___115 = __builtin_expect((long )(! (! settings->on_message_complete)),
                                       1L);
          if (tmp___115) {
            parser->state = (unsigned int )p_state;
            tmp___111 = (*(settings->on_message_complete))(parser);
            if (0 != tmp___111) {
              tmp___112 = 1;
            } else {
              tmp___112 = 0;
            }
            tmp___113 = __builtin_expect((long )tmp___112, 0L);
            if (tmp___113) {
              while (1) {
                parser->http_errno = 7U;
                break;
              }
            }
            p_state = (enum state )parser->state;
            tmp___114 = __builtin_expect((long )(! (! ((unsigned int )((enum http_errno )parser->http_errno) != 0U))),
                                         0L);
            if (tmp___114) {
              return ((size_t )((p - data) + 1L));
            }
          }
          break;
        }
        while (1) {
          parser->state = (unsigned int )p_state;
          return ((size_t )((p - data) + 1L));
          break;
        }
      }
    }
    if (parser->flags & 64U) {
      tmp___119 = http_should_keep_alive((http_parser const   *)parser);
      if (tmp___119) {
        if (parser->type == 0U) {
          tmp___117 = 18;
        } else {
          tmp___117 = 4;
        }
        tmp___118 = tmp___117;
      } else {
        tmp___118 = 1;
      }
      p_state = (enum state )tmp___118;
      while (1) {
        if (! ((unsigned int )((enum http_errno )parser->http_errno) == 0U)) {
          __assert_fail("HTTP_PARSER_ERRNO(parser) == HPE_OK", "src/http_parser.c",
                        1793U, "http_parser_execute");
        }
        tmp___124 = __builtin_expect((long )(! (! settings->on_message_complete)),
                                     1L);
        if (tmp___124) {
          parser->state = (unsigned int )p_state;
          tmp___120 = (*(settings->on_message_complete))(parser);
          if (0 != tmp___120) {
            tmp___121 = 1;
          } else {
            tmp___121 = 0;
          }
          tmp___122 = __builtin_expect((long )tmp___121, 0L);
          if (tmp___122) {
            while (1) {
              parser->http_errno = 7U;
              break;
            }
          }
          p_state = (enum state )parser->state;
          tmp___123 = __builtin_expect((long )(! (! ((unsigned int )((enum http_errno )parser->http_errno) != 0U))),
                                       0L);
          if (tmp___123) {
            return ((size_t )((p - data) + 1L));
          }
        }
        break;
      }
    } else
    if (parser->flags & 1U) {
      p_state = (enum state )51;
    } else
    if (parser->content_length == 0UL) {
      tmp___128 = http_should_keep_alive((http_parser const   *)parser);
      if (tmp___128) {
        if (parser->type == 0U) {
          tmp___126 = 18;
        } else {
          tmp___126 = 4;
        }
        tmp___127 = tmp___126;
      } else {
        tmp___127 = 1;
      }
      p_state = (enum state )tmp___127;
      while (1) {
        if (! ((unsigned int )((enum http_errno )parser->http_errno) == 0U)) {
          __assert_fail("HTTP_PARSER_ERRNO(parser) == HPE_OK", "src/http_parser.c",
                        1801U, "http_parser_execute");
        }
        tmp___133 = __builtin_expect((long )(! (! settings->on_message_complete)),
                                     1L);
        if (tmp___133) {
          parser->state = (unsigned int )p_state;
          tmp___129 = (*(settings->on_message_complete))(parser);
          if (0 != tmp___129) {
            tmp___130 = 1;
          } else {
            tmp___130 = 0;
          }
          tmp___131 = __builtin_expect((long )tmp___130, 0L);
          if (tmp___131) {
            while (1) {
              parser->http_errno = 7U;
              break;
            }
          }
          p_state = (enum state )parser->state;
          tmp___132 = __builtin_expect((long )(! (! ((unsigned int )((enum http_errno )parser->http_errno) != 0U))),
                                       0L);
          if (tmp___132) {
            return ((size_t )((p - data) + 1L));
          }
        }
        break;
      }
    } else
    if ((unsigned long long )parser->content_length != 18446744073709551615) {
      p_state = (enum state )60;
    } else {
      tmp___143 = http_message_needs_eof((http_parser const   *)parser);
      if (tmp___143) {
        p_state = (enum state )61;
      } else {
        tmp___137 = http_should_keep_alive((http_parser const   *)parser);
        if (tmp___137) {
          if (parser->type == 0U) {
            tmp___135 = 18;
          } else {
            tmp___135 = 4;
          }
          tmp___136 = tmp___135;
        } else {
          tmp___136 = 1;
        }
        p_state = (enum state )tmp___136;
        while (1) {
          if (! ((unsigned int )((enum http_errno )parser->http_errno) == 0U)) {
            __assert_fail("HTTP_PARSER_ERRNO(parser) == HPE_OK", "src/http_parser.c",
                          1809U, "http_parser_execute");
          }
          tmp___142 = __builtin_expect((long )(! (! settings->on_message_complete)),
                                       1L);
          if (tmp___142) {
            parser->state = (unsigned int )p_state;
            tmp___138 = (*(settings->on_message_complete))(parser);
            if (0 != tmp___138) {
              tmp___139 = 1;
            } else {
              tmp___139 = 0;
            }
            tmp___140 = __builtin_expect((long )tmp___139, 0L);
            if (tmp___140) {
              while (1) {
                parser->http_errno = 7U;
                break;
              }
            }
            p_state = (enum state )parser->state;
            tmp___141 = __builtin_expect((long )(! (! ((unsigned int )((enum http_errno )parser->http_errno) != 0U))),
                                         0L);
            if (tmp___141) {
              return ((size_t )((p - data) + 1L));
            }
          }
          break;
        }
      }
    }
    break;
    case 60U: 
    if (parser->content_length < (uint64_t )((data + len) - p)) {
      tmp___144 = parser->content_length;
    } else {
      tmp___144 = (uint64_t )((data + len) - p);
    }
    to_read = tmp___144;
    if (parser->content_length != 0UL) {
      if (! ((unsigned long long )parser->content_length != 18446744073709551615)) {
        __assert_fail("parser->content_length != 0 && parser->content_length != ULLONG_MAX",
                      "src/http_parser.c", 1826U, "http_parser_execute");
      }
    } else {
      __assert_fail("parser->content_length != 0 && parser->content_length != ULLONG_MAX",
                    "src/http_parser.c", 1826U, "http_parser_execute");
    }
    while (1) {
      if (! body_mark) {
        body_mark = p;
      }
      break;
    }
    parser->content_length -= to_read;
    p += to_read - 1UL;
    if (parser->content_length == 0UL) {
      p_state = (enum state )62;
      while (1) {
        if (! ((unsigned int )((enum http_errno )parser->http_errno) == 0U)) {
          __assert_fail("HTTP_PARSER_ERRNO(parser) == HPE_OK", "src/http_parser.c",
                        1849U, "http_parser_execute");
        }
        if (body_mark) {
          tmp___149 = __builtin_expect((long )(! (! settings->on_body)), 1L);
          if (tmp___149) {
            parser->state = (unsigned int )p_state;
            tmp___145 = (*(settings->on_body))(parser, body_mark, (size_t )((p - body_mark) + 1L));
            if (0 != tmp___145) {
              tmp___146 = 1;
            } else {
              tmp___146 = 0;
            }
            tmp___147 = __builtin_expect((long )tmp___146, 0L);
            if (tmp___147) {
              while (1) {
                parser->http_errno = 6U;
                break;
              }
            }
            p_state = (enum state )parser->state;
            tmp___148 = __builtin_expect((long )(! (! ((unsigned int )((enum http_errno )parser->http_errno) != 0U))),
                                         0L);
            if (tmp___148) {
              return ((size_t )(p - data));
            }
          }
          body_mark = (char const   *)((void *)0);
        }
        break;
      }
      goto reexecute;
    }
    break;
    case 61U: 
    while (1) {
      if (! body_mark) {
        body_mark = p;
      }
      break;
    }
    p = (data + len) - 1;
    break;
    case 62U: 
    tmp___153 = http_should_keep_alive((http_parser const   *)parser);
    if (tmp___153) {
      if (parser->type == 0U) {
        tmp___151 = 18;
      } else {
        tmp___151 = 4;
      }
      tmp___152 = tmp___151;
    } else {
      tmp___152 = 1;
    }
    p_state = (enum state )tmp___152;
    while (1) {
      if (! ((unsigned int )((enum http_errno )parser->http_errno) == 0U)) {
        __assert_fail("HTTP_PARSER_ERRNO(parser) == HPE_OK", "src/http_parser.c",
                      1865U, "http_parser_execute");
      }
      tmp___158 = __builtin_expect((long )(! (! settings->on_message_complete)), 1L);
      if (tmp___158) {
        parser->state = (unsigned int )p_state;
        tmp___154 = (*(settings->on_message_complete))(parser);
        if (0 != tmp___154) {
          tmp___155 = 1;
        } else {
          tmp___155 = 0;
        }
        tmp___156 = __builtin_expect((long )tmp___155, 0L);
        if (tmp___156) {
          while (1) {
            parser->http_errno = 7U;
            break;
          }
        }
        p_state = (enum state )parser->state;
        tmp___157 = __builtin_expect((long )(! (! ((unsigned int )((enum http_errno )parser->http_errno) != 0U))),
                                     0L);
        if (tmp___157) {
          return ((size_t )((p - data) + 1L));
        }
      }
      break;
    }
    if (parser->upgrade) {
      while (1) {
        parser->state = (unsigned int )p_state;
        return ((size_t )((p - data) + 1L));
        break;
      }
    }
    break;
    case 51U: 
    if (! (parser->nread == 1U)) {
      __assert_fail("parser->nread == 1", "src/http_parser.c", 1874U, "http_parser_execute");
    }
    if (! (parser->flags & 1U)) {
      __assert_fail("parser->flags & F_CHUNKED", "src/http_parser.c", 1875U, "http_parser_execute");
    }
    unhex_val = (int8_t )unhex[(unsigned char )ch];
    tmp___159 = __builtin_expect((long )(! (! ((int )unhex_val == -1))), 0L);
    if (tmp___159) {
      while (1) {
        parser->http_errno = 27U;
        break;
      }
      goto error;
    }
    parser->content_length = (uint64_t )unhex_val;
    p_state = (enum state )52;
    break;
    case 52U: 
    if (! (parser->flags & 1U)) {
      __assert_fail("parser->flags & F_CHUNKED", "src/http_parser.c", 1892U, "http_parser_execute");
    }
    if ((int )ch == 13) {
      p_state = (enum state )54;
      break;
    }
    unhex_val = (int8_t )unhex[(unsigned char )ch];
    if ((int )unhex_val == -1) {
      if ((int )ch == 59) {
        p_state = (enum state )53;
        break;
      } else
      if ((int )ch == 32) {
        p_state = (enum state )53;
        break;
      }
      while (1) {
        parser->http_errno = 27U;
        break;
      }
      goto error;
    }
    t___0 = parser->content_length;
    t___0 *= 16UL;
    t___0 += (uint64_t )unhex_val;
    tmp___160 = __builtin_expect((long )(! (! (1152921504606846974ULL < (unsigned long long )parser->content_length))),
                                 0L);
    if (tmp___160) {
      while (1) {
        parser->http_errno = 25U;
        break;
      }
      goto error;
    }
    parser->content_length = t___0;
    break;
    case 53U: 
    if (! (parser->flags & 1U)) {
      __assert_fail("parser->flags & F_CHUNKED", "src/http_parser.c", 1927U, "http_parser_execute");
    }
    if ((int )ch == 13) {
      p_state = (enum state )54;
      break;
    }
    break;
    case 54U: 
    if (! (parser->flags & 1U)) {
      __assert_fail("parser->flags & F_CHUNKED", "src/http_parser.c", 1938U, "http_parser_execute");
    }
    while (1) {
      if ((int )ch != 10) {
        while (1) {
          parser->http_errno = 30U;
          break;
        }
        goto error;
      }
      break;
    }
    parser->nread = (uint32_t )0;
    if (parser->content_length == 0UL) {
      parser->flags |= 16U;
      p_state = (enum state )42;
    } else {
      p_state = (enum state )57;
    }
    while (1) {
      if (! ((unsigned int )((enum http_errno )parser->http_errno) == 0U)) {
        __assert_fail("HTTP_PARSER_ERRNO(parser) == HPE_OK", "src/http_parser.c",
                      1949U, "http_parser_execute");
      }
      tmp___165 = __builtin_expect((long )(! (! settings->on_chunk_header)), 1L);
      if (tmp___165) {
        parser->state = (unsigned int )p_state;
        tmp___161 = (*(settings->on_chunk_header))(parser);
        if (0 != tmp___161) {
          tmp___162 = 1;
        } else {
          tmp___162 = 0;
        }
        tmp___163 = __builtin_expect((long )tmp___162, 0L);
        if (tmp___163) {
          while (1) {
            parser->http_errno = 9U;
            break;
          }
        }
        p_state = (enum state )parser->state;
        tmp___164 = __builtin_expect((long )(! (! ((unsigned int )((enum http_errno )parser->http_errno) != 0U))),
                                     0L);
        if (tmp___164) {
          return ((size_t )((p - data) + 1L));
        }
      }
      break;
    }
    break;
    case 57U: 
    if (parser->content_length < (uint64_t )((data + len) - p)) {
      tmp___166 = parser->content_length;
    } else {
      tmp___166 = (uint64_t )((data + len) - p);
    }
    to_read___0 = tmp___166;
    if (! (parser->flags & 1U)) {
      __assert_fail("parser->flags & F_CHUNKED", "src/http_parser.c", 1958U, "http_parser_execute");
    }
    if (parser->content_length != 0UL) {
      if (! ((unsigned long long )parser->content_length != 18446744073709551615)) {
        __assert_fail("parser->content_length != 0 && parser->content_length != ULLONG_MAX",
                      "src/http_parser.c", 1960U, "http_parser_execute");
      }
    } else {
      __assert_fail("parser->content_length != 0 && parser->content_length != ULLONG_MAX",
                    "src/http_parser.c", 1960U, "http_parser_execute");
    }
    while (1) {
      if (! body_mark) {
        body_mark = p;
      }
      break;
    }
    parser->content_length -= to_read___0;
    p += to_read___0 - 1UL;
    if (parser->content_length == 0UL) {
      p_state = (enum state )58;
    }
    break;
    case 58U: 
    if (! (parser->flags & 1U)) {
      __assert_fail("parser->flags & F_CHUNKED", "src/http_parser.c", 1977U, "http_parser_execute");
    }
    if (! (parser->content_length == 0UL)) {
      __assert_fail("parser->content_length == 0", "src/http_parser.c", 1978U, "http_parser_execute");
    }
    while (1) {
      if ((int )ch != 13) {
        while (1) {
          parser->http_errno = 30U;
          break;
        }
        goto error;
      }
      break;
    }
    p_state = (enum state )59;
    while (1) {
      if (! ((unsigned int )((enum http_errno )parser->http_errno) == 0U)) {
        __assert_fail("HTTP_PARSER_ERRNO(parser) == HPE_OK", "src/http_parser.c",
                      1981U, "http_parser_execute");
      }
      if (body_mark) {
        tmp___171 = __builtin_expect((long )(! (! settings->on_body)), 1L);
        if (tmp___171) {
          parser->state = (unsigned int )p_state;
          tmp___167 = (*(settings->on_body))(parser, body_mark, (size_t )(p - body_mark));
          if (0 != tmp___167) {
            tmp___168 = 1;
          } else {
            tmp___168 = 0;
          }
          tmp___169 = __builtin_expect((long )tmp___168, 0L);
          if (tmp___169) {
            while (1) {
              parser->http_errno = 6U;
              break;
            }
          }
          p_state = (enum state )parser->state;
          tmp___170 = __builtin_expect((long )(! (! ((unsigned int )((enum http_errno )parser->http_errno) != 0U))),
                                       0L);
          if (tmp___170) {
            return ((size_t )((p - data) + 1L));
          }
        }
        body_mark = (char const   *)((void *)0);
      }
      break;
    }
    break;
    case 59U: 
    if (! (parser->flags & 1U)) {
      __assert_fail("parser->flags & F_CHUNKED", "src/http_parser.c", 1985U, "http_parser_execute");
    }
    while (1) {
      if ((int )ch != 10) {
        while (1) {
          parser->http_errno = 30U;
          break;
        }
        goto error;
      }
      break;
    }
    parser->nread = (uint32_t )0;
    p_state = (enum state )51;
    while (1) {
      if (! ((unsigned int )((enum http_errno )parser->http_errno) == 0U)) {
        __assert_fail("HTTP_PARSER_ERRNO(parser) == HPE_OK", "src/http_parser.c",
                      1989U, "http_parser_execute");
      }
      tmp___176 = __builtin_expect((long )(! (! settings->on_chunk_complete)), 1L);
      if (tmp___176) {
        parser->state = (unsigned int )p_state;
        tmp___172 = (*(settings->on_chunk_complete))(parser);
        if (0 != tmp___172) {
          tmp___173 = 1;
        } else {
          tmp___173 = 0;
        }
        tmp___174 = __builtin_expect((long )tmp___173, 0L);
        if (tmp___174) {
          while (1) {
            parser->http_errno = 10U;
            break;
          }
        }
        p_state = (enum state )parser->state;
        tmp___175 = __builtin_expect((long )(! (! ((unsigned int )((enum http_errno )parser->http_errno) != 0U))),
                                     0L);
        if (tmp___175) {
          return ((size_t )((p - data) + 1L));
        }
      }
      break;
    }
    break;
    default: 
    __assert_fail("0 && \"unhandled state\"", "src/http_parser.c", 1993U, "http_parser_execute");
    while (1) {
      parser->http_errno = 29U;
      break;
    }
    goto error;
    }
    p ++;
  }
  if (header_field_mark) {
    tmp___177 = 1;
  } else {
    tmp___177 = 0;
  }
  if (header_value_mark) {
    tmp___178 = 1;
  } else {
    tmp___178 = 0;
  }
  if (url_mark) {
    tmp___179 = 1;
  } else {
    tmp___179 = 0;
  }
  if (body_mark) {
    tmp___180 = 1;
  } else {
    tmp___180 = 0;
  }
  if (status_mark) {
    tmp___181 = 1;
  } else {
    tmp___181 = 0;
  }
  if (! ((((tmp___177 + tmp___178) + tmp___179) + tmp___180) + tmp___181 <= 1)) {
    __assert_fail("((header_field_mark ? 1 : 0) + (header_value_mark ? 1 : 0) + (url_mark ? 1 : 0) + (body_mark ? 1 : 0) + (status_mark ? 1 : 0)) <= 1",
                  "src/http_parser.c", 2013U, "http_parser_execute");
  }
  while (1) {
    if (! ((unsigned int )((enum http_errno )parser->http_errno) == 0U)) {
      __assert_fail("HTTP_PARSER_ERRNO(parser) == HPE_OK", "src/http_parser.c", 2015U,
                    "http_parser_execute");
    }
    if (header_field_mark) {
      tmp___186 = __builtin_expect((long )(! (! settings->on_header_field)), 1L);
      if (tmp___186) {
        parser->state = (unsigned int )p_state;
        tmp___182 = (*(settings->on_header_field))(parser, header_field_mark, (size_t )(p - header_field_mark));
        if (0 != tmp___182) {
          tmp___183 = 1;
        } else {
          tmp___183 = 0;
        }
        tmp___184 = __builtin_expect((long )tmp___183, 0L);
        if (tmp___184) {
          while (1) {
            parser->http_errno = 3U;
            break;
          }
        }
        p_state = (enum state )parser->state;
        tmp___185 = __builtin_expect((long )(! (! ((unsigned int )((enum http_errno )parser->http_errno) != 0U))),
                                     0L);
        if (tmp___185) {
          return ((size_t )(p - data));
        }
      }
      header_field_mark = (char const   *)((void *)0);
    }
    break;
  }
  while (1) {
    if (! ((unsigned int )((enum http_errno )parser->http_errno) == 0U)) {
      __assert_fail("HTTP_PARSER_ERRNO(parser) == HPE_OK", "src/http_parser.c", 2016U,
                    "http_parser_execute");
    }
    if (header_value_mark) {
      tmp___191 = __builtin_expect((long )(! (! settings->on_header_value)), 1L);
      if (tmp___191) {
        parser->state = (unsigned int )p_state;
        tmp___187 = (*(settings->on_header_value))(parser, header_value_mark, (size_t )(p - header_value_mark));
        if (0 != tmp___187) {
          tmp___188 = 1;
        } else {
          tmp___188 = 0;
        }
        tmp___189 = __builtin_expect((long )tmp___188, 0L);
        if (tmp___189) {
          while (1) {
            parser->http_errno = 4U;
            break;
          }
        }
        p_state = (enum state )parser->state;
        tmp___190 = __builtin_expect((long )(! (! ((unsigned int )((enum http_errno )parser->http_errno) != 0U))),
                                     0L);
        if (tmp___190) {
          return ((size_t )(p - data));
        }
      }
      header_value_mark = (char const   *)((void *)0);
    }
    break;
  }
  while (1) {
    if (! ((unsigned int )((enum http_errno )parser->http_errno) == 0U)) {
      __assert_fail("HTTP_PARSER_ERRNO(parser) == HPE_OK", "src/http_parser.c", 2017U,
                    "http_parser_execute");
    }
    if (url_mark) {
      tmp___196 = __builtin_expect((long )(! (! settings->on_url)), 1L);
      if (tmp___196) {
        parser->state = (unsigned int )p_state;
        tmp___192 = (*(settings->on_url))(parser, url_mark, (size_t )(p - url_mark));
        if (0 != tmp___192) {
          tmp___193 = 1;
        } else {
          tmp___193 = 0;
        }
        tmp___194 = __builtin_expect((long )tmp___193, 0L);
        if (tmp___194) {
          while (1) {
            parser->http_errno = 2U;
            break;
          }
        }
        p_state = (enum state )parser->state;
        tmp___195 = __builtin_expect((long )(! (! ((unsigned int )((enum http_errno )parser->http_errno) != 0U))),
                                     0L);
        if (tmp___195) {
          return ((size_t )(p - data));
        }
      }
      url_mark = (char const   *)((void *)0);
    }
    break;
  }
  while (1) {
    if (! ((unsigned int )((enum http_errno )parser->http_errno) == 0U)) {
      __assert_fail("HTTP_PARSER_ERRNO(parser) == HPE_OK", "src/http_parser.c", 2018U,
                    "http_parser_execute");
    }
    if (body_mark) {
      tmp___201 = __builtin_expect((long )(! (! settings->on_body)), 1L);
      if (tmp___201) {
        parser->state = (unsigned int )p_state;
        tmp___197 = (*(settings->on_body))(parser, body_mark, (size_t )(p - body_mark));
        if (0 != tmp___197) {
          tmp___198 = 1;
        } else {
          tmp___198 = 0;
        }
        tmp___199 = __builtin_expect((long )tmp___198, 0L);
        if (tmp___199) {
          while (1) {
            parser->http_errno = 6U;
            break;
          }
        }
        p_state = (enum state )parser->state;
        tmp___200 = __builtin_expect((long )(! (! ((unsigned int )((enum http_errno )parser->http_errno) != 0U))),
                                     0L);
        if (tmp___200) {
          return ((size_t )(p - data));
        }
      }
      body_mark = (char const   *)((void *)0);
    }
    break;
  }
  while (1) {
    if (! ((unsigned int )((enum http_errno )parser->http_errno) == 0U)) {
      __assert_fail("HTTP_PARSER_ERRNO(parser) == HPE_OK", "src/http_parser.c", 2019U,
                    "http_parser_execute");
    }
    if (status_mark) {
      tmp___206 = __builtin_expect((long )(! (! settings->on_status)), 1L);
      if (tmp___206) {
        parser->state = (unsigned int )p_state;
        tmp___202 = (*(settings->on_status))(parser, status_mark, (size_t )(p - status_mark));
        if (0 != tmp___202) {
          tmp___203 = 1;
        } else {
          tmp___203 = 0;
        }
        tmp___204 = __builtin_expect((long )tmp___203, 0L);
        if (tmp___204) {
          while (1) {
            parser->http_errno = 8U;
            break;
          }
        }
        p_state = (enum state )parser->state;
        tmp___205 = __builtin_expect((long )(! (! ((unsigned int )((enum http_errno )parser->http_errno) != 0U))),
                                     0L);
        if (tmp___205) {
          return ((size_t )(p - data));
        }
      }
      status_mark = (char const   *)((void *)0);
    }
    break;
  }
  while (1) {
    parser->state = (unsigned int )p_state;
    return (len);
    break;
  }
  error: 
  if ((unsigned int )((enum http_errno )parser->http_errno) == 0U) {
    while (1) {
      parser->http_errno = 32U;
      break;
    }
  }
  while (1) {
    parser->state = (unsigned int )p_state;
    return ((size_t )(p - data));
    break;
  }
  return (0UL);
}
}
int http_message_needs_eof(http_parser const   *parser ) 
{ 


  {
  if (parser->type == 0U) {
    return (0);
  }
  if (parser->status_code / 100U == 1U) {
    return (0);
  } else
  if (parser->status_code == 204U) {
    return (0);
  } else
  if (parser->status_code == 304U) {
    return (0);
  } else
  if (parser->flags & 64U) {
    return (0);
  }
  if (parser->flags & 1U) {
    return (0);
  } else
  if ((unsigned long long )parser->content_length != 18446744073709551615) {
    return (0);
  }
  return (1);
}
}
int http_should_keep_alive(http_parser const   *parser ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if ((int const   )parser->http_major > 0) {
    if ((int const   )parser->http_minor > 0) {
      if (parser->flags & 4U) {
        return (0);
      }
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (! (parser->flags & 2U)) {
    return (0);
  }
  tmp = http_message_needs_eof(parser);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  return (tmp___0);
}
}
char const   *http_method_str(enum http_method m ) 
{ 
  char const   *tmp ;

  {
  if ((unsigned long )((unsigned int )m) < sizeof(method_strings) / sizeof(method_strings[0])) {
    tmp = method_strings[m];
  } else {
    tmp = "<unknown>";
  }
  return (tmp);
}
}
void http_parser_init(http_parser *parser , enum http_parser_type t ) 
{ 
  void *data ;
  int tmp ;

  {
  data = parser->data;
  memset((void *)parser, 0, sizeof(*parser));
  parser->data = data;
  parser->type = (unsigned int )t;
  if ((unsigned int )t == 0U) {
    parser->state = 18U;
  } else {
    if ((unsigned int )t == 1U) {
      tmp = 4;
    } else {
      tmp = 2;
    }
    parser->state = (unsigned int )tmp;
  }
  parser->http_errno = 0U;
  return;
}
}
void http_parser_settings_init(http_parser_settings *settings ) 
{ 


  {
  memset((void *)settings, 0, sizeof(*settings));
  return;
}
}
char const   *http_errno_name(enum http_errno err ) 
{ 


  {
  if (! ((size_t )err < sizeof(http_strerror_tab) / sizeof(http_strerror_tab[0]))) {
    __assert_fail("((size_t) err) < ARRAY_SIZE(http_strerror_tab)", "src/http_parser.c",
                  2101U, "http_errno_name");
  }
  return (http_strerror_tab[err].name);
}
}
char const   *http_errno_description(enum http_errno err ) 
{ 


  {
  if (! ((size_t )err < sizeof(http_strerror_tab) / sizeof(http_strerror_tab[0]))) {
    __assert_fail("((size_t) err) < ARRAY_SIZE(http_strerror_tab)", "src/http_parser.c",
                  2107U, "http_errno_description");
  }
  return (http_strerror_tab[err].description);
}
}
static enum http_host_state http_parse_host_char(enum http_host_state s , char const   ch ) 
{ 


  {
  switch ((unsigned int )s) {
  case 2U: 
  case 3U: 
  if ((int const   )ch == 64) {
    return ((enum http_host_state )4);
  }
  if ((int )((unsigned char )((int const   )ch | 32)) >= 97) {
    if ((int )((unsigned char )((int const   )ch | 32)) <= 122) {
      return ((enum http_host_state )3);
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if ((int const   )ch >= 48) {
    if ((int const   )ch <= 57) {
      return ((enum http_host_state )3);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if ((int const   )ch == 45) {
    return ((enum http_host_state )3);
  } else
  if ((int const   )ch == 95) {
    return ((enum http_host_state )3);
  } else
  if ((int const   )ch == 46) {
    return ((enum http_host_state )3);
  } else
  if ((int const   )ch == 33) {
    return ((enum http_host_state )3);
  } else
  if ((int const   )ch == 126) {
    return ((enum http_host_state )3);
  } else
  if ((int const   )ch == 42) {
    return ((enum http_host_state )3);
  } else
  if ((int const   )ch == 39) {
    return ((enum http_host_state )3);
  } else
  if ((int const   )ch == 40) {
    return ((enum http_host_state )3);
  } else
  if ((int const   )ch == 41) {
    return ((enum http_host_state )3);
  } else
  if ((int const   )ch == 37) {
    return ((enum http_host_state )3);
  } else
  if ((int const   )ch == 59) {
    return ((enum http_host_state )3);
  } else
  if ((int const   )ch == 58) {
    return ((enum http_host_state )3);
  } else
  if ((int const   )ch == 38) {
    return ((enum http_host_state )3);
  } else
  if ((int const   )ch == 61) {
    return ((enum http_host_state )3);
  } else
  if ((int const   )ch == 43) {
    return ((enum http_host_state )3);
  } else
  if ((int const   )ch == 36) {
    return ((enum http_host_state )3);
  } else
  if ((int const   )ch == 44) {
    return ((enum http_host_state )3);
  }
  break;
  case 4U: 
  if ((int const   )ch == 91) {
    return ((enum http_host_state )5);
  }
  if ((int )((unsigned char )((int const   )ch | 32)) >= 97) {
    if ((int )((unsigned char )((int const   )ch | 32)) <= 122) {
      return ((enum http_host_state )6);
    } else {
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
  if ((int const   )ch >= 48) {
    if ((int const   )ch <= 57) {
      return ((enum http_host_state )6);
    } else {
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
  if ((int const   )ch == 46) {
    return ((enum http_host_state )6);
  } else
  if ((int const   )ch == 45) {
    return ((enum http_host_state )6);
  }
  break;
  case 6U: 
  if ((int )((unsigned char )((int const   )ch | 32)) >= 97) {
    if ((int )((unsigned char )((int const   )ch | 32)) <= 122) {
      return ((enum http_host_state )6);
    } else {
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
  if ((int const   )ch >= 48) {
    if ((int const   )ch <= 57) {
      return ((enum http_host_state )6);
    } else {
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
  if ((int const   )ch == 46) {
    return ((enum http_host_state )6);
  } else
  if ((int const   )ch == 45) {
    return ((enum http_host_state )6);
  }
  case 8U: 
  if ((int const   )ch == 58) {
    return ((enum http_host_state )11);
  }
  break;
  case 7U: 
  if ((int const   )ch == 93) {
    return ((enum http_host_state )8);
  }
  case 5U: 
  if ((int const   )ch >= 48) {
    if ((int const   )ch <= 57) {
      return ((enum http_host_state )7);
    } else {
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
  if ((int )((unsigned char )((int const   )ch | 32)) >= 97) {
    if ((int )((unsigned char )((int const   )ch | 32)) <= 102) {
      return ((enum http_host_state )7);
    } else {
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
  if ((int const   )ch == 58) {
    return ((enum http_host_state )7);
  } else
  if ((int const   )ch == 46) {
    return ((enum http_host_state )7);
  }
  if ((unsigned int )s == 7U) {
    if ((int const   )ch == 37) {
      return ((enum http_host_state )9);
    }
  }
  break;
  case 10U: 
  if ((int const   )ch == 93) {
    return ((enum http_host_state )8);
  }
  case 9U: 
  if ((int )((unsigned char )((int const   )ch | 32)) >= 97) {
    if ((int )((unsigned char )((int const   )ch | 32)) <= 122) {
      return ((enum http_host_state )10);
    } else {
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
  if ((int const   )ch >= 48) {
    if ((int const   )ch <= 57) {
      return ((enum http_host_state )10);
    } else {
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
  if ((int const   )ch == 37) {
    return ((enum http_host_state )10);
  } else
  if ((int const   )ch == 46) {
    return ((enum http_host_state )10);
  } else
  if ((int const   )ch == 45) {
    return ((enum http_host_state )10);
  } else
  if ((int const   )ch == 95) {
    return ((enum http_host_state )10);
  } else
  if ((int const   )ch == 126) {
    return ((enum http_host_state )10);
  }
  break;
  case 11U: 
  case 12U: 
  if ((int const   )ch >= 48) {
    if ((int const   )ch <= 57) {
      return ((enum http_host_state )12);
    }
  }
  break;
  default: 
  break;
  }
  return ((enum http_host_state )1);
}
}
static int http_parse_host(char const   *buf , struct http_parser_url *u , int found_at ) 
{ 
  enum http_host_state s ;
  char const   *p ;
  size_t buflen ;
  enum http_host_state new_s ;
  enum http_host_state tmp ;

  {
  buflen = (size_t )((int )u->field_data[1].off + (int )u->field_data[1].len);
  if (! ((int )u->field_set & (1 << 1))) {
    __assert_fail("u->field_set & (1 << UF_HOST)", "src/http_parser.c", 2200U, "http_parse_host");
  }
  u->field_data[1].len = (uint16_t )0;
  if (found_at) {
    s = (enum http_host_state )2;
  } else {
    s = (enum http_host_state )4;
  }
  p = buf + (int )u->field_data[1].off;
  while ((unsigned long )p < (unsigned long )(buf + buflen)) {
    tmp = http_parse_host_char(s, *p);
    new_s = tmp;
    if ((unsigned int )new_s == 1U) {
      return (1);
    }
    switch ((unsigned int )new_s) {
    case 6U: 
    if ((unsigned int )s != 6U) {
      u->field_data[1].off = (uint16_t )(p - buf);
    }
    u->field_data[1].len = (uint16_t )((int )u->field_data[1].len + 1);
    break;
    case 7U: 
    if ((unsigned int )s != 7U) {
      u->field_data[1].off = (uint16_t )(p - buf);
    }
    u->field_data[1].len = (uint16_t )((int )u->field_data[1].len + 1);
    break;
    case 10U: 
    case 9U: 
    u->field_data[1].len = (uint16_t )((int )u->field_data[1].len + 1);
    break;
    case 12U: 
    if ((unsigned int )s != 12U) {
      u->field_data[2].off = (uint16_t )(p - buf);
      u->field_data[2].len = (uint16_t )0;
      u->field_set = (uint16_t )((int )u->field_set | (1 << 2));
    }
    u->field_data[2].len = (uint16_t )((int )u->field_data[2].len + 1);
    break;
    case 3U: 
    if ((unsigned int )s != 3U) {
      u->field_data[6].off = (uint16_t )(p - buf);
      u->field_data[6].len = (uint16_t )0;
      u->field_set = (uint16_t )((int )u->field_set | (1 << 6));
    }
    u->field_data[6].len = (uint16_t )((int )u->field_data[6].len + 1);
    break;
    default: 
    break;
    }
    s = new_s;
    p ++;
  }
  switch ((unsigned int )s) {
  case 2U: 
  case 3U: 
  case 11U: 
  case 10U: 
  case 9U: 
  case 7U: 
  case 5U: 
  case 4U: 
  return (1);
  default: 
  break;
  }
  return (0);
}
}
void http_parser_url_init(struct http_parser_url *u ) 
{ 


  {
  memset((void *)u, 0, sizeof(*u));
  return;
}
}
int http_parser_parse_url(char const   *buf , size_t buflen , int is_connect , struct http_parser_url *u ) 
{ 
  enum state s ;
  char const   *p ;
  enum http_parser_url_fields uf ;
  enum http_parser_url_fields old_uf ;
  int found_at ;
  uint16_t tmp ;
  int tmp___0 ;
  unsigned long v ;
  unsigned long tmp___1 ;

  {
  found_at = 0;
  tmp = (uint16_t )0;
  u->field_set = tmp;
  u->port = tmp;
  if (is_connect) {
    s = (enum state )24;
  } else {
    s = (enum state )20;
  }
  old_uf = (enum http_parser_url_fields )7;
  p = buf;
  while ((unsigned long )p < (unsigned long )(buf + buflen)) {
    s = parse_url_char(s, *p);
    switch ((unsigned int )s) {
    case 1U: 
    return (1);
    case 30U: 
    case 28U: 
    case 24U: 
    case 23U: 
    case 22U: 
    goto __Cont;
    case 21U: 
    uf = (enum http_parser_url_fields )0;
    break;
    case 26U: 
    found_at = 1;
    case 25U: 
    uf = (enum http_parser_url_fields )1;
    break;
    case 27U: 
    uf = (enum http_parser_url_fields )3;
    break;
    case 29U: 
    uf = (enum http_parser_url_fields )4;
    break;
    case 31U: 
    uf = (enum http_parser_url_fields )5;
    break;
    default: 
    __assert_fail("!\"Unexpected state\"", "src/http_parser.c", 2334U, "http_parser_parse_url");
    return (1);
    }
    if ((unsigned int )uf == (unsigned int )old_uf) {
      u->field_data[uf].len = (uint16_t )((int )u->field_data[uf].len + 1);
      goto __Cont;
    }
    u->field_data[uf].off = (uint16_t )(p - buf);
    u->field_data[uf].len = (uint16_t )1;
    u->field_set = (uint16_t )((int )u->field_set | (1 << (unsigned int )uf));
    old_uf = uf;
    __Cont: /* CIL Label */ 
    p ++;
  }
  if ((int )u->field_set & 1) {
    if (((int )u->field_set & (1 << 1)) == 0) {
      return (1);
    }
  }
  if ((int )u->field_set & (1 << 1)) {
    tmp___0 = http_parse_host(buf, u, found_at);
    if (tmp___0 != 0) {
      return (1);
    }
  }
  if (is_connect) {
    if ((int )u->field_set != ((1 << 1) | (1 << 2))) {
      return (1);
    }
  }
  if ((int )u->field_set & (1 << 2)) {
    tmp___1 = strtoul((char const   * __restrict  )(buf + (int )u->field_data[2].off),
                      (char ** __restrict  )((void *)0), 10);
    v = tmp___1;
    if (v > 65535UL) {
      return (1);
    }
    u->port = (uint16_t )v;
  }
  return (0);
}
}
void http_parser_pause(http_parser *parser , int paused ) 
{ 


  {
  if ((unsigned int )((enum http_errno )parser->http_errno) == 0U) {
    goto _L;
  } else
  if ((unsigned int )((enum http_errno )parser->http_errno) == 31U) {
    _L: /* CIL Label */ 
    while (1) {
      if (paused) {
        parser->http_errno = 31U;
      } else {
        parser->http_errno = 0U;
      }
      break;
    }
  } else {
    __assert_fail("0 && \"Attempting to pause parser in error state\"", "src/http_parser.c",
                  2394U, "http_parser_pause");
  }
  return;
}
}
int http_body_is_final(struct http_parser  const  *parser ) 
{ 


  {
  return (parser->state == 62U);
}
}
unsigned long http_parser_version(void) 
{ 


  {
  return (132865UL);
}
}
#pragma merger("0","/tmp/cil-tQQBxmVw.i","-std=c99,-Wall,-O2")
unsigned char const   luaJIT_BC_wrk[1069]  = 
  {      (unsigned char const   )27,      (unsigned char const   )76,      (unsigned char const   )74,      (unsigned char const   )2, 
        (unsigned char const   )10,      (unsigned char const   )139,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )11,      (unsigned char const   )1,      (unsigned char const   )5, 
        (unsigned char const   )0,      (unsigned char const   )24,      (unsigned char const   )45,      (unsigned char const   )2, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )57,      (unsigned char const   )2, 
        (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )18,      (unsigned char const   )4, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )18,      (unsigned char const   )5, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )66,      (unsigned char const   )2, 
        (unsigned char const   )3,      (unsigned char const   )2,      (unsigned char const   )21,      (unsigned char const   )3, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )41,      (unsigned char const   )4, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )41,      (unsigned char const   )5, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )77,      (unsigned char const   )3, 
        (unsigned char const   )12,      (unsigned char const   )128,      (unsigned char const   )45,      (unsigned char const   )7, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )57,      (unsigned char const   )7, 
        (unsigned char const   )1,      (unsigned char const   )7,      (unsigned char const   )56,      (unsigned char const   )9, 
        (unsigned char const   )6,      (unsigned char const   )2,      (unsigned char const   )66,      (unsigned char const   )7, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )14,      (unsigned char const   )0, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )88,      (unsigned char const   )7, 
        (unsigned char const   )5,      (unsigned char const   )128,      (unsigned char const   )54,      (unsigned char const   )7, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )57,      (unsigned char const   )7, 
        (unsigned char const   )3,      (unsigned char const   )7,      (unsigned char const   )18,      (unsigned char const   )9, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )18,      (unsigned char const   )10, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )66,      (unsigned char const   )7, 
        (unsigned char const   )3,      (unsigned char const   )1,      (unsigned char const   )79,      (unsigned char const   )3, 
        (unsigned char const   )244,      (unsigned char const   )127,      (unsigned char const   )45,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )61,      (unsigned char const   )2, 
        (unsigned char const   )4,      (unsigned char const   )3,      (unsigned char const   )75,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192, 
        (unsigned char const   )10,      (unsigned char const   )97,      (unsigned char const   )100,      (unsigned char const   )100, 
        (unsigned char const   )114,      (unsigned char const   )115,      (unsigned char const   )11,      (unsigned char const   )114, 
        (unsigned char const   )101,      (unsigned char const   )109,      (unsigned char const   )111,      (unsigned char const   )118, 
        (unsigned char const   )101,      (unsigned char const   )10,      (unsigned char const   )116,      (unsigned char const   )97, 
        (unsigned char const   )98,      (unsigned char const   )108,      (unsigned char const   )101,      (unsigned char const   )12, 
        (unsigned char const   )99,      (unsigned char const   )111,      (unsigned char const   )110,      (unsigned char const   )110, 
        (unsigned char const   )101,      (unsigned char const   )99,      (unsigned char const   )116,      (unsigned char const   )11, 
        (unsigned char const   )108,      (unsigned char const   )111,      (unsigned char const   )111,      (unsigned char const   )107, 
        (unsigned char const   )117,      (unsigned char const   )112,      (unsigned char const   )92,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )4,      (unsigned char const   )1,      (unsigned char const   )5, 
        (unsigned char const   )0,      (unsigned char const   )13,      (unsigned char const   )45,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )57,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )58,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )61,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )54,      (unsigned char const   )1, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )54,      (unsigned char const   )3, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )66,      (unsigned char const   )1, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )7,      (unsigned char const   )1, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )88,      (unsigned char const   )1, 
        (unsigned char const   )3,      (unsigned char const   )128,      (unsigned char const   )54,      (unsigned char const   )1, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )18,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )66,      (unsigned char const   )1, 
        (unsigned char const   )2,      (unsigned char const   )1,      (unsigned char const   )75,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192, 
        (unsigned char const   )13,      (unsigned char const   )102,      (unsigned char const   )117,      (unsigned char const   )110, 
        (unsigned char const   )99,      (unsigned char const   )116,      (unsigned char const   )105,      (unsigned char const   )111, 
        (unsigned char const   )110,      (unsigned char const   )10,      (unsigned char const   )115,      (unsigned char const   )101, 
        (unsigned char const   )116,      (unsigned char const   )117,      (unsigned char const   )112,      (unsigned char const   )9, 
        (unsigned char const   )116,      (unsigned char const   )121,      (unsigned char const   )112,      (unsigned char const   )101, 
        (unsigned char const   )10,      (unsigned char const   )97,      (unsigned char const   )100,      (unsigned char const   )100, 
        (unsigned char const   )114,      (unsigned char const   )115,      (unsigned char const   )9,      (unsigned char const   )97, 
        (unsigned char const   )100,      (unsigned char const   )100,      (unsigned char const   )114,      (unsigned char const   )17, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )45, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )76, 
        (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )1, 
        (unsigned char const   )192,      (unsigned char const   )142,      (unsigned char const   )2,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )7,      (unsigned char const   )1,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )48,      (unsigned char const   )45,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )57,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )57,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )1,      (unsigned char const   )14,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )88,      (unsigned char const   )1, 
        (unsigned char const   )27,      (unsigned char const   )128,      (unsigned char const   )45,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )57,      (unsigned char const   )1, 
        (unsigned char const   )2,      (unsigned char const   )1,      (unsigned char const   )45,      (unsigned char const   )2, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )57,      (unsigned char const   )2, 
        (unsigned char const   )3,      (unsigned char const   )2,      (unsigned char const   )18,      (unsigned char const   )5, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )57,      (unsigned char const   )3, 
        (unsigned char const   )4,      (unsigned char const   )1,      (unsigned char const   )39,      (unsigned char const   )6, 
        (unsigned char const   )5,      (unsigned char const   )0,      (unsigned char const   )66,      (unsigned char const   )3, 
        (unsigned char const   )3,      (unsigned char const   )2,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )88,      (unsigned char const   )4, 
        (unsigned char const   )6,      (unsigned char const   )128,      (unsigned char const   )39,      (unsigned char const   )3, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )18,      (unsigned char const   )4, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )39,      (unsigned char const   )5, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )38,      (unsigned char const   )3, 
        (unsigned char const   )5,      (unsigned char const   )3,      (unsigned char const   )12,      (unsigned char const   )1, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )88,      (unsigned char const   )4, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )88,      (unsigned char const   )3, 
        (unsigned char const   )6,      (unsigned char const   )128,      (unsigned char const   )18,      (unsigned char const   )3, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )39,      (unsigned char const   )4, 
        (unsigned char const   )5,      (unsigned char const   )0,      (unsigned char const   )18,      (unsigned char const   )5, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )38,      (unsigned char const   )3, 
        (unsigned char const   )5,      (unsigned char const   )3,      (unsigned char const   )12,      (unsigned char const   )1, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )88,      (unsigned char const   )4, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )45,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )57,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )61,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )3,      (unsigned char const   )54,      (unsigned char const   )1, 
        (unsigned char const   )8,      (unsigned char const   )0,      (unsigned char const   )54,      (unsigned char const   )3, 
        (unsigned char const   )9,      (unsigned char const   )0,      (unsigned char const   )66,      (unsigned char const   )1, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )7,      (unsigned char const   )1, 
        (unsigned char const   )10,      (unsigned char const   )0,      (unsigned char const   )88,      (unsigned char const   )1, 
        (unsigned char const   )3,      (unsigned char const   )128,      (unsigned char const   )54,      (unsigned char const   )1, 
        (unsigned char const   )9,      (unsigned char const   )0,      (unsigned char const   )18,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )66,      (unsigned char const   )1, 
        (unsigned char const   )2,      (unsigned char const   )1,      (unsigned char const   )45,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )57,      (unsigned char const   )1, 
        (unsigned char const   )11,      (unsigned char const   )1,      (unsigned char const   )66,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )45,      (unsigned char const   )2, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )51,      (unsigned char const   )3, 
        (unsigned char const   )13,      (unsigned char const   )0,      (unsigned char const   )61,      (unsigned char const   )3, 
        (unsigned char const   )12,      (unsigned char const   )2,      (unsigned char const   )50,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )75,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192, 
        (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )114,      (unsigned char const   )101, 
        (unsigned char const   )113,      (unsigned char const   )117,      (unsigned char const   )101,      (unsigned char const   )115, 
        (unsigned char const   )116,      (unsigned char const   )11,      (unsigned char const   )102,      (unsigned char const   )111, 
        (unsigned char const   )114,      (unsigned char const   )109,      (unsigned char const   )97,      (unsigned char const   )116, 
        (unsigned char const   )13,      (unsigned char const   )102,      (unsigned char const   )117,      (unsigned char const   )110, 
        (unsigned char const   )99,      (unsigned char const   )116,      (unsigned char const   )105,      (unsigned char const   )111, 
        (unsigned char const   )110,      (unsigned char const   )9,      (unsigned char const   )105,      (unsigned char const   )110, 
        (unsigned char const   )105,      (unsigned char const   )116,      (unsigned char const   )9,      (unsigned char const   )116, 
        (unsigned char const   )121,      (unsigned char const   )112,      (unsigned char const   )101,      (unsigned char const   )6, 
        (unsigned char const   )93,      (unsigned char const   )6,      (unsigned char const   )91,      (unsigned char const   )6, 
        (unsigned char const   )58,      (unsigned char const   )9,      (unsigned char const   )102,      (unsigned char const   )105, 
        (unsigned char const   )110,      (unsigned char const   )100,      (unsigned char const   )9,      (unsigned char const   )112, 
        (unsigned char const   )111,      (unsigned char const   )114,      (unsigned char const   )116,      (unsigned char const   )9, 
        (unsigned char const   )104,      (unsigned char const   )111,      (unsigned char const   )115,      (unsigned char const   )116, 
        (unsigned char const   )9,      (unsigned char const   )72,      (unsigned char const   )111,      (unsigned char const   )115, 
        (unsigned char const   )116,      (unsigned char const   )12,      (unsigned char const   )104,      (unsigned char const   )101, 
        (unsigned char const   )97,      (unsigned char const   )100,      (unsigned char const   )101,      (unsigned char const   )114, 
        (unsigned char const   )115,      (unsigned char const   )134,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )4,      (unsigned char const   )20,      (unsigned char const   )1,      (unsigned char const   )16, 
        (unsigned char const   )1,      (unsigned char const   )68,      (unsigned char const   )12,      (unsigned char const   )4, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )88,      (unsigned char const   )4, 
        (unsigned char const   )2,      (unsigned char const   )128,      (unsigned char const   )45,      (unsigned char const   )4, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )57,      (unsigned char const   )4, 
        (unsigned char const   )0,      (unsigned char const   )4,      (unsigned char const   )12,      (unsigned char const   )5, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )88,      (unsigned char const   )5, 
        (unsigned char const   )2,      (unsigned char const   )128,      (unsigned char const   )45,      (unsigned char const   )5, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )57,      (unsigned char const   )5, 
        (unsigned char const   )1,      (unsigned char const   )5,      (unsigned char const   )12,      (unsigned char const   )6, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )88,      (unsigned char const   )6, 
        (unsigned char const   )2,      (unsigned char const   )128,      (unsigned char const   )45,      (unsigned char const   )6, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )57,      (unsigned char const   )6, 
        (unsigned char const   )2,      (unsigned char const   )6,      (unsigned char const   )12,      (unsigned char const   )7, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )88,      (unsigned char const   )7, 
        (unsigned char const   )2,      (unsigned char const   )128,      (unsigned char const   )45,      (unsigned char const   )7, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )57,      (unsigned char const   )7, 
        (unsigned char const   )3,      (unsigned char const   )7,      (unsigned char const   )52,      (unsigned char const   )8, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )57,      (unsigned char const   )9, 
        (unsigned char const   )4,      (unsigned char const   )6,      (unsigned char const   )14,      (unsigned char const   )0, 
        (unsigned char const   )9,      (unsigned char const   )0,      (unsigned char const   )88,      (unsigned char const   )9, 
        (unsigned char const   )4,      (unsigned char const   )128,      (unsigned char const   )45,      (unsigned char const   )9, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )57,      (unsigned char const   )9, 
        (unsigned char const   )2,      (unsigned char const   )9,      (unsigned char const   )57,      (unsigned char const   )9, 
        (unsigned char const   )4,      (unsigned char const   )9,      (unsigned char const   )61,      (unsigned char const   )9, 
        (unsigned char const   )4,      (unsigned char const   )6,      (unsigned char const   )13,      (unsigned char const   )9, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )88,      (unsigned char const   )9, 
        (unsigned char const   )4,      (unsigned char const   )128,      (unsigned char const   )54,      (unsigned char const   )9, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )57,      (unsigned char const   )9, 
        (unsigned char const   )7,      (unsigned char const   )9,      (unsigned char const   )18,      (unsigned char const   )11, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )66,      (unsigned char const   )9, 
        (unsigned char const   )2,      (unsigned char const   )2,      (unsigned char const   )61,      (unsigned char const   )9, 
        (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )54,      (unsigned char const   )9, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )57,      (unsigned char const   )9, 
        (unsigned char const   )8,      (unsigned char const   )9,      (unsigned char const   )39,      (unsigned char const   )11, 
        (unsigned char const   )9,      (unsigned char const   )0,      (unsigned char const   )18,      (unsigned char const   )12, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )18,      (unsigned char const   )13, 
        (unsigned char const   )5,      (unsigned char const   )0,      (unsigned char const   )66,      (unsigned char const   )9, 
        (unsigned char const   )4,      (unsigned char const   )2,      (unsigned char const   )62,      (unsigned char const   )9, 
        (unsigned char const   )1,      (unsigned char const   )8,      (unsigned char const   )54,      (unsigned char const   )9, 
        (unsigned char const   )10,      (unsigned char const   )0,      (unsigned char const   )18,      (unsigned char const   )11, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )66,      (unsigned char const   )9, 
        (unsigned char const   )2,      (unsigned char const   )4,      (unsigned char const   )72,      (unsigned char const   )12, 
        (unsigned char const   )9,      (unsigned char const   )128,      (unsigned char const   )21,      (unsigned char const   )14, 
        (unsigned char const   )8,      (unsigned char const   )0,      (unsigned char const   )22,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )14,      (unsigned char const   )54,      (unsigned char const   )15, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )57,      (unsigned char const   )15, 
        (unsigned char const   )8,      (unsigned char const   )15,      (unsigned char const   )39,      (unsigned char const   )17, 
        (unsigned char const   )11,      (unsigned char const   )0,      (unsigned char const   )18,      (unsigned char const   )18, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )18,      (unsigned char const   )19, 
        (unsigned char const   )13,      (unsigned char const   )0,      (unsigned char const   )66,      (unsigned char const   )15, 
        (unsigned char const   )4,      (unsigned char const   )2,      (unsigned char const   )60,      (unsigned char const   )15, 
        (unsigned char const   )14,      (unsigned char const   )8,      (unsigned char const   )70,      (unsigned char const   )12, 
        (unsigned char const   )3,      (unsigned char const   )3,      (unsigned char const   )82,      (unsigned char const   )12, 
        (unsigned char const   )245,      (unsigned char const   )127,      (unsigned char const   )21,      (unsigned char const   )9, 
        (unsigned char const   )8,      (unsigned char const   )0,      (unsigned char const   )22,      (unsigned char const   )9, 
        (unsigned char const   )0,      (unsigned char const   )9,      (unsigned char const   )39,      (unsigned char const   )10, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )60,      (unsigned char const   )10, 
        (unsigned char const   )9,      (unsigned char const   )8,      (unsigned char const   )21,      (unsigned char const   )9, 
        (unsigned char const   )8,      (unsigned char const   )0,      (unsigned char const   )22,      (unsigned char const   )9, 
        (unsigned char const   )0,      (unsigned char const   )9,      (unsigned char const   )12,      (unsigned char const   )10, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )88,      (unsigned char const   )10, 
        (unsigned char const   )1,      (unsigned char const   )128,      (unsigned char const   )39,      (unsigned char const   )10, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )60,      (unsigned char const   )10, 
        (unsigned char const   )9,      (unsigned char const   )8,      (unsigned char const   )54,      (unsigned char const   )9, 
        (unsigned char const   )13,      (unsigned char const   )0,      (unsigned char const   )57,      (unsigned char const   )9, 
        (unsigned char const   )14,      (unsigned char const   )9,      (unsigned char const   )18,      (unsigned char const   )11, 
        (unsigned char const   )8,      (unsigned char const   )0,      (unsigned char const   )39,      (unsigned char const   )12, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )68,      (unsigned char const   )9, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192, 
        (unsigned char const   )7,      (unsigned char const   )13,      (unsigned char const   )10,      (unsigned char const   )11, 
        (unsigned char const   )99,      (unsigned char const   )111,      (unsigned char const   )110,      (unsigned char const   )99, 
        (unsigned char const   )97,      (unsigned char const   )116,      (unsigned char const   )10,      (unsigned char const   )116, 
        (unsigned char const   )97,      (unsigned char const   )98,      (unsigned char const   )108,      (unsigned char const   )101, 
        (unsigned char const   )5,      (unsigned char const   )11,      (unsigned char const   )37,      (unsigned char const   )115, 
        (unsigned char const   )58,      (unsigned char const   )32,      (unsigned char const   )37,      (unsigned char const   )115, 
        (unsigned char const   )10,      (unsigned char const   )112,      (unsigned char const   )97,      (unsigned char const   )105, 
        (unsigned char const   )114,      (unsigned char const   )115,      (unsigned char const   )19,      (unsigned char const   )37, 
        (unsigned char const   )115,      (unsigned char const   )32,      (unsigned char const   )37,      (unsigned char const   )115, 
        (unsigned char const   )32,      (unsigned char const   )72,      (unsigned char const   )84,      (unsigned char const   )84, 
        (unsigned char const   )80,      (unsigned char const   )47,      (unsigned char const   )49,      (unsigned char const   )46, 
        (unsigned char const   )49,      (unsigned char const   )11,      (unsigned char const   )102,      (unsigned char const   )111, 
        (unsigned char const   )114,      (unsigned char const   )109,      (unsigned char const   )97,      (unsigned char const   )116, 
        (unsigned char const   )8,      (unsigned char const   )108,      (unsigned char const   )101,      (unsigned char const   )110, 
        (unsigned char const   )11,      (unsigned char const   )115,      (unsigned char const   )116,      (unsigned char const   )114, 
        (unsigned char const   )105,      (unsigned char const   )110,      (unsigned char const   )103,      (unsigned char const   )19, 
        (unsigned char const   )67,      (unsigned char const   )111,      (unsigned char const   )110,      (unsigned char const   )116, 
        (unsigned char const   )101,      (unsigned char const   )110,      (unsigned char const   )116,      (unsigned char const   )45, 
        (unsigned char const   )76,      (unsigned char const   )101,      (unsigned char const   )110,      (unsigned char const   )103, 
        (unsigned char const   )116,      (unsigned char const   )104,      (unsigned char const   )9,      (unsigned char const   )72, 
        (unsigned char const   )111,      (unsigned char const   )115,      (unsigned char const   )116,      (unsigned char const   )9, 
        (unsigned char const   )98,      (unsigned char const   )111,      (unsigned char const   )100,      (unsigned char const   )121, 
        (unsigned char const   )12,      (unsigned char const   )104,      (unsigned char const   )101,      (unsigned char const   )97, 
        (unsigned char const   )100,      (unsigned char const   )101,      (unsigned char const   )114,      (unsigned char const   )115, 
        (unsigned char const   )9,      (unsigned char const   )112,      (unsigned char const   )97,      (unsigned char const   )116, 
        (unsigned char const   )104,      (unsigned char const   )11,      (unsigned char const   )109,      (unsigned char const   )101, 
        (unsigned char const   )116,      (unsigned char const   )104,      (unsigned char const   )111,      (unsigned char const   )100, 
        (unsigned char const   )2,      (unsigned char const   )145,      (unsigned char const   )1,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )10, 
        (unsigned char const   )0,      (unsigned char const   )13,      (unsigned char const   )53,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )52,      (unsigned char const   )1, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )61,      (unsigned char const   )1, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )51,      (unsigned char const   )1, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )61,      (unsigned char const   )1, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )51,      (unsigned char const   )1, 
        (unsigned char const   )5,      (unsigned char const   )0,      (unsigned char const   )61,      (unsigned char const   )1, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )51,      (unsigned char const   )1, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )61,      (unsigned char const   )1, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )51,      (unsigned char const   )1, 
        (unsigned char const   )9,      (unsigned char const   )0,      (unsigned char const   )61,      (unsigned char const   )1, 
        (unsigned char const   )8,      (unsigned char const   )0,      (unsigned char const   )50,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )76,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )11, 
        (unsigned char const   )102,      (unsigned char const   )111,      (unsigned char const   )114,      (unsigned char const   )109, 
        (unsigned char const   )97,      (unsigned char const   )116,      (unsigned char const   )0,      (unsigned char const   )9, 
        (unsigned char const   )105,      (unsigned char const   )110,      (unsigned char const   )105,      (unsigned char const   )116, 
        (unsigned char const   )0,      (unsigned char const   )10,      (unsigned char const   )115,      (unsigned char const   )101, 
        (unsigned char const   )116,      (unsigned char const   )117,      (unsigned char const   )112,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )114,      (unsigned char const   )101,      (unsigned char const   )115, 
        (unsigned char const   )111,      (unsigned char const   )108,      (unsigned char const   )118,      (unsigned char const   )101, 
        (unsigned char const   )12,      (unsigned char const   )104,      (unsigned char const   )101,      (unsigned char const   )97, 
        (unsigned char const   )100,      (unsigned char const   )101,      (unsigned char const   )114,      (unsigned char const   )115, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )4,      (unsigned char const   )9, 
        (unsigned char const   )104,      (unsigned char const   )111,      (unsigned char const   )115,      (unsigned char const   )116, 
        (unsigned char const   )14,      (unsigned char const   )108,      (unsigned char const   )111,      (unsigned char const   )99, 
        (unsigned char const   )97,      (unsigned char const   )108,      (unsigned char const   )104,      (unsigned char const   )111, 
        (unsigned char const   )115,      (unsigned char const   )116,      (unsigned char const   )11,      (unsigned char const   )109, 
        (unsigned char const   )101,      (unsigned char const   )116,      (unsigned char const   )104,      (unsigned char const   )111, 
        (unsigned char const   )100,      (unsigned char const   )8,      (unsigned char const   )71,      (unsigned char const   )69, 
        (unsigned char const   )84,      (unsigned char const   )11,      (unsigned char const   )115,      (unsigned char const   )99, 
        (unsigned char const   )104,      (unsigned char const   )101,      (unsigned char const   )109,      (unsigned char const   )101, 
        (unsigned char const   )9,      (unsigned char const   )104,      (unsigned char const   )116,      (unsigned char const   )116, 
        (unsigned char const   )112,      (unsigned char const   )9,      (unsigned char const   )112,      (unsigned char const   )97, 
        (unsigned char const   )116,      (unsigned char const   )104,      (unsigned char const   )6,      (unsigned char const   )47, 
        (unsigned char const   )0};
#pragma merger("0","/tmp/cil-bs6pi5yT.i","")
char const   *VERSION  =    "";
