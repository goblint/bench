/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef unsigned int __uint32_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef int __pid_t;
typedef long __clock_t;
typedef unsigned long __rlim_t;
typedef long __time_t;
typedef unsigned int __useconds_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef unsigned long __fsblkcnt_t;
typedef unsigned long __fsfilcnt_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
typedef __int8_t int8_t;
typedef __uint8_t uint8_t;
typedef __uint32_t uint32_t;
struct inotify_event {
   int wd ;
   uint32_t mask ;
   uint32_t cookie ;
   uint32_t len ;
   char name[] ;
};
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    __RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    __RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    __RLIMIT_NPROC = 6,
    __RLIMIT_MEMLOCK = 8,
    __RLIMIT_LOCKS = 10,
    __RLIMIT_SIGPENDING = 11,
    __RLIMIT_MSGQUEUE = 12,
    __RLIMIT_NICE = 13,
    __RLIMIT_RTPRIO = 14,
    __RLIMIT_RTTIME = 15,
    __RLIMIT_NLIMITS = 16,
    __RLIM_NLIMITS = 16
} ;
typedef __rlim_t rlim_t;
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
typedef enum __rlimit_resource __rlimit_resource_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
typedef __time_t time_t;
typedef __dev_t dev_t;
typedef __ino_t ino_t;
typedef __mode_t mode_t;
typedef __nlink_t nlink_t;
typedef __off_t off_t;
typedef __blkcnt_t blkcnt_t;
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
struct statvfs {
   unsigned long f_bsize ;
   unsigned long f_frsize ;
   __fsblkcnt_t f_blocks ;
   __fsblkcnt_t f_bfree ;
   __fsblkcnt_t f_bavail ;
   __fsfilcnt_t f_files ;
   __fsfilcnt_t f_ffree ;
   __fsfilcnt_t f_favail ;
   unsigned long f_fsid ;
   unsigned long f_flag ;
   unsigned long f_namemax ;
   int __f_spare[6] ;
};
typedef __pid_t pid_t;
struct __anonstruct___sigset_t_991265788 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___sigset_t_991265788 __sigset_t;
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
typedef union sigval __sigval_t;
struct __anonstruct__kill_244518854 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
struct __anonstruct__timer_490064738 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
struct __anonstruct__rt_619254530 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
struct __anonstruct__sigchld_284671705 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
struct __anonstruct__addr_bnd_5259977 {
   void *_lower ;
   void *_upper ;
};
union __anonunion__bounds_432680557 {
   struct __anonstruct__addr_bnd_5259977 _addr_bnd ;
   __uint32_t _pkey ;
};
struct __anonstruct__sigfault_40845203 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion__bounds_432680557 _bounds ;
};
struct __anonstruct__sigpoll_386613454 {
   long si_band ;
   int si_fd ;
};
struct __anonstruct__sigsys_44812255 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
union __anonunion__sifields_85651287 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_244518854 _kill ;
   struct __anonstruct__timer_490064738 _timer ;
   struct __anonstruct__rt_619254530 _rt ;
   struct __anonstruct__sigchld_284671705 _sigchld ;
   struct __anonstruct__sigfault_40845203 _sigfault ;
   struct __anonstruct__sigpoll_386613454 _sigpoll ;
   struct __anonstruct__sigsys_44812255 _sigsys ;
};
struct __anonstruct_siginfo_t_27519928 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion__sifields_85651287 _sifields ;
};
typedef struct __anonstruct_siginfo_t_27519928 siginfo_t;
union pthread_attr_t ;
typedef union pthread_attr_t pthread_attr_t;
union __anonunion___sigaction_handler_363639592 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
struct sigaction {
   union __anonunion___sigaction_handler_363639592 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
typedef unsigned long size_t;
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
typedef unsigned long pthread_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
struct __dirstream ;
typedef struct __dirstream DIR;
typedef __ssize_t ssize_t;
typedef __useconds_t useconds_t;
struct _ftsent ;
struct __anonstruct_FTS_272296835 {
   struct _ftsent *fts_cur ;
   struct _ftsent *fts_child ;
   struct _ftsent **fts_array ;
   dev_t fts_dev ;
   char *fts_path ;
   int fts_rfd ;
   int fts_pathlen ;
   int fts_nitems ;
   int (*fts_compar)(void const   * , void const   * ) ;
   int fts_options ;
};
typedef struct __anonstruct_FTS_272296835 FTS;
struct _ftsent {
   struct _ftsent *fts_cycle ;
   struct _ftsent *fts_parent ;
   struct _ftsent *fts_link ;
   long fts_number ;
   void *fts_pointer ;
   char *fts_accpath ;
   char *fts_path ;
   int fts_errno ;
   int fts_symfd ;
   unsigned short fts_pathlen ;
   unsigned short fts_namelen ;
   ino_t fts_ino ;
   dev_t fts_dev ;
   nlink_t fts_nlink ;
   short fts_level ;
   unsigned short fts_info ;
   unsigned short fts_flags ;
   unsigned short fts_instr ;
   struct stat *fts_statp ;
   char fts_name[1] ;
};
typedef struct _ftsent FTSENT;
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef unsigned long __re_long_size_t;
typedef unsigned long reg_syntax_t;
struct re_dfa_t ;
struct re_pattern_buffer {
   struct re_dfa_t *buffer ;
   __re_long_size_t allocated ;
   __re_long_size_t used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
typedef struct re_pattern_buffer regex_t;
typedef int regoff_t;
struct __anonstruct_regmatch_t_1035675074 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
typedef struct __anonstruct_regmatch_t_1035675074 regmatch_t;
typedef int wchar_t;
typedef unsigned int chtype;
struct screen ;
typedef struct screen SCREEN;
struct _win_st ;
typedef struct _win_st WINDOW;
typedef chtype attr_t;
typedef unsigned int wint_t;
struct __anonstruct_cchar_t_667532103 {
   attr_t attr ;
   wchar_t chars[5] ;
   int ext_color ;
};
typedef struct __anonstruct_cchar_t_667532103 cchar_t;
struct ldat ;
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
   cchar_t _bkgrnd ;
   int _color ;
};
enum action {
    SEL_BACK = 1,
    SEL_OPEN = 2,
    SEL_NAV_IN = 3,
    SEL_NEXT = 4,
    SEL_PREV = 5,
    SEL_PGDN = 6,
    SEL_PGUP = 7,
    SEL_CTRL_D = 8,
    SEL_CTRL_U = 9,
    SEL_HOME = 10,
    SEL_END = 11,
    SEL_FIRST = 12,
    SEL_JUMP = 13,
    SEL_CDHOME = 14,
    SEL_CDBEGIN = 15,
    SEL_CDLAST = 16,
    SEL_CDROOT = 17,
    SEL_BMOPEN = 18,
    SEL_REMOTE = 19,
    SEL_CYCLE = 20,
    SEL_CYCLER = 21,
    SEL_CTX1 = 22,
    SEL_CTX2 = 23,
    SEL_CTX3 = 24,
    SEL_CTX4 = 25,
    SEL_MARK = 26,
    SEL_BMARK = 27,
    SEL_FLTR = 28,
    SEL_MFLTR = 29,
    SEL_HIDDEN = 30,
    SEL_DETAIL = 31,
    SEL_STATS = 32,
    SEL_CHMODX = 33,
    SEL_ARCHIVE = 34,
    SEL_SORT = 35,
    SEL_REDRAW = 36,
    SEL_SEL = 37,
    SEL_SELMUL = 38,
    SEL_SELALL = 39,
    SEL_SELINV = 40,
    SEL_SELEDIT = 41,
    SEL_CP = 42,
    SEL_MV = 43,
    SEL_CPMVAS = 44,
    SEL_RM = 45,
    SEL_OPENWITH = 46,
    SEL_NEW = 47,
    SEL_RENAME = 48,
    SEL_RENAMEMUL = 49,
    SEL_UMOUNT = 50,
    SEL_HELP = 51,
    SEL_AUTONEXT = 52,
    SEL_EDIT = 53,
    SEL_PLUGIN = 54,
    SEL_SHELL = 55,
    SEL_LAUNCH = 56,
    SEL_PROMPT = 57,
    SEL_LOCK = 58,
    SEL_SESSIONS = 59,
    SEL_EXPORT = 60,
    SEL_TIMETYPE = 61,
    SEL_QUITCTX = 62,
    SEL_QUITCD = 63,
    SEL_QUIT = 64,
    SEL_QUITERR = 65
} ;
struct key {
   wint_t sym ;
   enum action act ;
};
typedef unsigned int uint_t;
typedef unsigned char uchar_t;
typedef unsigned short ushort_t;
typedef unsigned long long ullong_t;
struct __anonstruct____missing_field_name_824606445 {
   ullong_t blocks : 40 ;
   ullong_t nlen : 16 ;
   ullong_t flags : 8 ;
};
struct entry {
   char *name ;
   time_t sec ;
   uint_t nsec ;
   mode_t mode ;
   off_t size ;
   struct __anonstruct____missing_field_name_824606445 __annonCompField18 ;
};
typedef struct entry *pEntry;
struct __anonstruct_selmark_653462436 {
   char *startpos ;
   size_t len ;
};
typedef struct __anonstruct_selmark_653462436 selmark;
struct __anonstruct_kv_1012109243 {
   int key ;
   int off ;
};
typedef struct __anonstruct_kv_1012109243 kv;
struct __anonstruct_fltrexp_t_723168813 {
   regex_t const   *regex ;
   char const   *str ;
};
typedef struct __anonstruct_fltrexp_t_723168813 fltrexp_t;
struct __anonstruct_settings_893539002 {
   uint_t filtermode : 1 ;
   uint_t timeorder : 1 ;
   uint_t sizeorder : 1 ;
   uint_t apparentsz : 1 ;
   uint_t blkorder : 1 ;
   uint_t extnorder : 1 ;
   uint_t showhidden : 1 ;
   uint_t reserved0 : 1 ;
   uint_t showdetail : 1 ;
   uint_t ctxactive : 1 ;
   uint_t reverse : 1 ;
   uint_t version : 1 ;
   uint_t reserved1 : 1 ;
   uint_t curctx : 3 ;
   uint_t prefersel : 1 ;
   uint_t fileinfo : 1 ;
   uint_t nonavopen : 1 ;
   uint_t autoenter : 1 ;
   uint_t reserved2 : 1 ;
   uint_t useeditor : 1 ;
   uint_t reserved3 : 3 ;
   uint_t regex : 1 ;
   uint_t x11 : 1 ;
   uint_t timetype : 2 ;
   uint_t cliopener : 1 ;
   uint_t waitedit : 1 ;
   uint_t rollover : 1 ;
};
typedef struct __anonstruct_settings_893539002 settings;
struct __anonstruct_runstate_1070726198 {
   uint_t autofifo : 1 ;
   uint_t autonext : 1 ;
   uint_t dircolor : 1 ;
   uint_t dirctx : 1 ;
   uint_t duinit : 1 ;
   uint_t fifomode : 1 ;
   uint_t forcequit : 1 ;
   uint_t initfile : 1 ;
   uint_t interrupt : 1 ;
   uint_t move : 1 ;
   uint_t oldcolor : 1 ;
   uint_t picked : 1 ;
   uint_t picker : 1 ;
   uint_t pluginit : 1 ;
   uint_t prstssn : 1 ;
   uint_t rangesel : 1 ;
   uint_t runctx : 3 ;
   uint_t runplugin : 1 ;
   uint_t selbm : 1 ;
   uint_t selmode : 1 ;
   uint_t stayonsel : 1 ;
   uint_t trash : 2 ;
   uint_t uidgid : 1 ;
   uint_t usebsdtar : 1 ;
   uint_t reserved : 5 ;
};
typedef struct __anonstruct_runstate_1070726198 runstate;
struct __anonstruct_context_430508109 {
   char c_path[4096] ;
   char c_last[4096] ;
   char c_name[256] ;
   char c_fltr[48] ;
   settings c_cfg ;
   uint_t color ;
};
typedef struct __anonstruct_context_430508109 context;
struct __anonstruct_thread_data_232432842 {
   char path[4096] ;
   int entnum ;
   ushort_t core ;
   _Bool mntpoint ;
};
typedef struct __anonstruct_thread_data_232432842 thread_data;
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#pragma merger("0","/tmp/cil-iYrqH5m8.i","-std=c11,-pthread")
extern  __attribute__((__nothrow__)) int inotify_init1(int __flags ) ;
extern  __attribute__((__nothrow__)) int inotify_add_watch(int __fd , char const   *__name ,
                                                           uint32_t __mask ) ;
extern  __attribute__((__nothrow__)) int inotify_rm_watch(int __fd , int __wd ) ;
extern  __attribute__((__nothrow__)) int getrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit *__rlimits ) ;
extern  __attribute__((__nothrow__)) int setrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit  const  *__rlimits ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __file ,
                                                                                   struct stat * __restrict  __buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat)(int __fd ,
                                                                                  struct stat *__buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) fstatat)(int __fd ,
                                                                                      char const   * __restrict  __file ,
                                                                                      struct stat * __restrict  __buf ,
                                                                                      int __flag ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) lstat)(char const   * __restrict  __file ,
                                                                                    struct stat * __restrict  __buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chmod)(char const   *__file ,
                                                                                  __mode_t __mode ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mkdir)(char const   *__path ,
                                                                                  __mode_t __mode ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mkfifo)(char const   *__path ,
                                                                                   __mode_t __mode ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) statvfs)(char const   * __restrict  __file ,
                                                                                      struct statvfs * __restrict  __buf ) ;
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) dirfd)(DIR *__dirp ) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
extern int fcntl(int __fd , int __cmd  , ...) ;
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
extern  __attribute__((__nothrow__)) int posix_fadvise(int __fd , off_t __offset ,
                                                       off_t __len , int __advise ) ;
extern int fts_close(FTS * ) ;
extern FTS *fts_open(char * const  * , int  , int (*)(FTSENT const   ** , FTSENT const   ** ) ) ;
extern FTSENT *fts_read(FTS * ) ;
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
extern  __attribute__((__nothrow__)) struct tm *localtime_r(time_t const   * __restrict  __timer ,
                                                            struct tm * __restrict  __tp ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
extern FILE *stdin ;
extern FILE *stderr ;
extern  __attribute__((__nothrow__)) int renameat(int __oldfd , char const   *__old ,
                                                  int __newfd , char const   *__new ) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
extern int ( /* format attribute */  dprintf)(int __fd , char const   * __restrict  __fmt 
                                              , ...) ;
extern void perror(char const   *__s ) ;
extern  __attribute__((__nothrow__)) char *ctermid(char *__s ) ;
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __String ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
extern void regfree(regex_t *__preg ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1))) strtoll)(char const   * __restrict  __nptr ,
                                                                                          char ** __restrict  __endptr ,
                                                                                          int __base ) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atexit)(void (*__func)(void) ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) setenv)(char const   *__name ,
                                                                                   char const   *__value ,
                                                                                   int __replace ) ;
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) mkdtemp)(char *__template ) ;
extern  __attribute__((__nothrow__)) char *realpath(char const   * __restrict  __name ,
                                                    char * __restrict  __resolved ) ;
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t * __restrict  __pwcs ,
                                                     char const   * __restrict  __s ,
                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) size_t wcstombs(char * __restrict  __s , wchar_t const   * __restrict  __pwcs ,
                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memccpy)(void * __restrict  __dest ,
                                                                                        void const   * __restrict  __src ,
                                                                                        int __c ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memchr)(void const   *__s ,
                                                                                     int __c ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) rawmemchr)(void const   *__s ,
                                                                                        int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memrchr)(void const   *__s ,
                                                                                      int __c ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcasestr)(char const   *__haystack ,
                                                                                           char const   *__needle )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,3))) memmem)(void const   *__haystack ,
                                                                                       size_t __haystacklen ,
                                                                                       void const   *__needle ,
                                                                                       size_t __needlelen )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
extern  __attribute__((__nothrow__)) int ffs(int __i )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) access)(char const   *__name ,
                                                                                   int __type ) ;
extern int close(int __fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
extern int usleep(__useconds_t __useconds ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chdir)(char const   *__path ) ;
extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size ) ;
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) execvp)(char const   *__file ,
                                                                                     char * const  *__argv ) ;
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
extern  __attribute__((__nothrow__)) __pid_t getppid(void) ;
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) link)(char const   *__from ,
                                                                                   char const   *__to ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) symlink)(char const   *__from ,
                                                                                      char const   *__to ) ;
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2))) readlink)(char const   * __restrict  __path ,
                                                                                           char * __restrict  __buf ,
                                                                                           size_t __len ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) rmdir)(char const   *__path ) ;
extern char *optarg ;
extern int optind ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) getopt)(int ___argc ,
                                                                                     char * const  *___argv ,
                                                                                     char const   *__shortopts ) ;
extern  __attribute__((__nothrow__)) int wcswidth(wchar_t const   *__s , size_t __n ) ;
extern int cbreak(void) ;
extern int curs_set(int  ) ;
extern int endwin(void) ;
extern WINDOW *initscr(void) ;
extern int init_pair(short  , short  , short  ) ;
extern char const   *keyname(int  ) ;
extern int keypad(WINDOW * , _Bool  ) ;
extern SCREEN *newterm(char const   * , FILE * , FILE * ) ;
extern int noecho(void) ;
extern int nonl(void) ;
extern int printw(char const   *  , ...) ;
extern int start_color(void) ;
extern int waddch(WINDOW * , chtype const    ) ;
extern int waddnstr(WINDOW * , char const   * , int  ) ;
extern int wattr_on(WINDOW * , attr_t  , void * ) ;
extern int wattr_off(WINDOW * , attr_t  , void * ) ;
extern int wclrtoeol(WINDOW * ) ;
extern int werase(WINDOW * ) ;
extern int wmove(WINDOW * , int  , int  ) ;
extern int wrefresh(WINDOW * ) ;
extern void wtimeout(WINDOW * , int  ) ;
extern int set_escdelay(int  ) ;
extern int use_default_colors(void) ;
extern WINDOW *stdscr ;
extern int COLORS ;
extern int COLS ;
extern int LINES ;
extern int unget_wch(wchar_t const    ) ;
extern int waddnwstr(WINDOW * , wchar_t const   * , int  ) ;
extern int wget_wch(WINDOW * , wint_t * ) ;
static struct key bindings[84]  = 
  {      {(wint_t )260, (enum action )1}, 
        {(wint_t )'h', (enum action )1}, 
        {(wint_t )343, (enum action )2}, 
        {(wint_t )'\r', (enum action )2}, 
        {(wint_t )261, (enum action )3}, 
        {(wint_t )'l', (enum action )3}, 
        {(wint_t )'j', (enum action )4}, 
        {(wint_t )258, (enum action )4}, 
        {(wint_t )'k', (enum action )5}, 
        {(wint_t )259, (enum action )5}, 
        {(wint_t )338, (enum action )6}, 
        {(wint_t )339, (enum action )7}, 
        {(wint_t )4, (enum action )8}, 
        {(wint_t )21, (enum action )9}, 
        {(wint_t )262, (enum action )10}, 
        {(wint_t )'g', (enum action )10}, 
        {(wint_t )1, (enum action )10}, 
        {(wint_t )360, (enum action )11}, 
        {(wint_t )'G', (enum action )11}, 
        {(wint_t )5, (enum action )11}, 
        {(wint_t )'\'', (enum action )12}, 
        {(wint_t )'J', (enum action )13}, 
        {(wint_t )'~', (enum action )14}, 
        {(wint_t )'@', (enum action )15}, 
        {(wint_t )'-', (enum action )16}, 
        {(wint_t )'`', (enum action )17}, 
        {(wint_t )'b', (enum action )18}, 
        {(wint_t )31, (enum action )18}, 
        {(wint_t )'c', (enum action )19}, 
        {(wint_t )'\t', (enum action )20}, 
        {(wint_t )353, (enum action )21}, 
        {(wint_t )'1', (enum action )22}, 
        {(wint_t )'2', (enum action )23}, 
        {(wint_t )'3', (enum action )24}, 
        {(wint_t )'4', (enum action )25}, 
        {(wint_t )',', (enum action )26}, 
        {(wint_t )'B', (enum action )27}, 
        {(wint_t )'/', (enum action )28}, 
        {(wint_t )14, (enum action )29}, 
        {(wint_t )'.', (enum action )30}, 
        {(wint_t )'d', (enum action )31}, 
        {(wint_t )'f', (enum action )32}, 
        {(wint_t )6, (enum action )32}, 
        {(wint_t )'*', (enum action )33}, 
        {(wint_t )'z', (enum action )34}, 
        {(wint_t )'t', (enum action )35}, 
        {(wint_t )20, (enum action )35}, 
        {(wint_t )12, (enum action )36}, 
        {(wint_t )' ', (enum action )37}, 
        {(wint_t )'+', (enum action )37}, 
        {(wint_t )'m', (enum action )38}, 
        {(wint_t )'a', (enum action )39}, 
        {(wint_t )'A', (enum action )40}, 
        {(wint_t )'E', (enum action )41}, 
        {(wint_t )'p', (enum action )42}, 
        {(wint_t )16, (enum action )42}, 
        {(wint_t )'v', (enum action )43}, 
        {(wint_t )22, (enum action )43}, 
        {(wint_t )'w', (enum action )44}, 
        {(wint_t )23, (enum action )44}, 
        {(wint_t )'x', (enum action )45}, 
        {(wint_t )24, (enum action )45}, 
        {(wint_t )'o', (enum action )46}, 
        {(wint_t )15, (enum action )46}, 
        {(wint_t )'n', (enum action )47}, 
        {(wint_t )18, (enum action )48}, 
        {(wint_t )'r', (enum action )49}, 
        {(wint_t )'u', (enum action )50}, 
        {(wint_t )'?', (enum action )51}, 
        {(wint_t )10, (enum action )52}, 
        {(wint_t )'e', (enum action )53}, 
        {(wint_t )';', (enum action )54}, 
        {(wint_t )'!', (enum action )55}, 
        {(wint_t )29, (enum action )55}, 
        {(wint_t )'=', (enum action )56}, 
        {(wint_t )']', (enum action )57}, 
        {(wint_t )'0', (enum action )58}, 
        {(wint_t )'s', (enum action )59}, 
        {(wint_t )'>', (enum action )60}, 
        {(wint_t )'T', (enum action )61}, 
        {(wint_t )'q', (enum action )62}, 
        {(wint_t )7, (enum action )63}, 
        {(wint_t )17, (enum action )64}, 
        {(wint_t )'Q', (enum action )65}};
static settings cfg  = 
     {0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, (uint_t )1, 0U, 0U, 0U, 0U, 0U, 0U, 0U, (uint_t )1,
    0U, 0U, 0U, 0U, 0U, (uint_t )2, 0U, 0U, (uint_t )1};
static context g_ctx[4]  __attribute__((__aligned__))  ;
static int ndents  ;
static int cur  ;
static int last  ;
static int curscroll  ;
static int last_curscroll  ;
static int total_dents  =    64;
static int scroll_lines  =    1;
static int nselected  ;
static time_t gtimesecs  ;
static uint_t idletimeout  ;
static uint_t selbufpos  ;
static uint_t selbuflen  ;
static ushort_t xlines  ;
static ushort_t xcols  ;
static ushort_t idle  ;
static uchar_t maxbm  ;
static uchar_t maxplug  ;
static uchar_t maxorder  ;
static uchar_t cfgsort[5]  ;
static char *bmstr  ;
static char *pluginstr  ;
static char *orderstr  ;
static char *opener  ;
static char *editor  ;
static char *enveditor  ;
static char *pager  ;
static char *shell  ;
static char *home  ;
static char *initpath  ;
static char *cfgpath  ;
static char *selpath  ;
static char *listpath  ;
static char *listroot  ;
static char *plgpath  ;
static char *pnamebuf  ;
static char *pselbuf  ;
static char *findselpos  ;
static char *mark  ;
static char *lastcmd  ;
static ullong_t *ihashbmp  ;
static struct entry *pdents  ;
static blkcnt_t dir_blocks  ;
static kv *bookmark  ;
static kv *plug  ;
static kv *order  ;
static uchar_t tmpfplen  ;
static uchar_t homelen  ;
static uchar_t blk_shift  =    (uchar_t )9;
static regex_t archive_re  ;
static int threadbmp  =    -1;
static int volatile   active_threads  ;
static pthread_mutex_t running_mutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
static pthread_mutex_t hardlink_mutex  =    {{0,
     0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
static ullong_t *core_files  ;
static blkcnt_t *core_blocks  ;
static ullong_t num_files  ;
static thread_data *core_data  ;
static struct sigaction oldsighup  ;
static struct sigaction oldsigtstp  ;
static struct sigaction oldsigwinch  ;
static char g_buf[4096 + (256 << 1)]  __attribute__((__aligned__))  ;
static char g_sel[4096]  __attribute__((__aligned__))  ;
static char g_tmpfpath[64]  __attribute__((__aligned__))  ;
static char g_pipepath[64]  __attribute__((__aligned__))  ;
static runstate g_state  ;
static char * const  utils[21]  = 
  {      (char * const  )"xdg-open",      (char * const  )"atool",      (char * const  )"bsdtar",      (char * const  )"unzip", 
        (char * const  )"tar",      (char * const  )"vlock",      (char * const  )"launch",      (char * const  )"sh -c", 
        (char * const  )"bash",      (char * const  )"sshfs",      (char * const  )"rclone",      (char * const  )"vi", 
        (char * const  )"less",      (char * const  )"sh",      (char * const  )"fzf",      (char * const  )".ntfy", 
        (char * const  )".cbcp",      (char * const  )".nmv",      (char * const  )"trash-put",      (char * const  )"gio trash", 
        (char * const  )"rm -rf"};
static char const   * const  messages[45]  = 
  {      (char const   * const  )"",      (char const   * const  )"0 entries",      (char const   * const  )"/.nnnXXXXXX",      (char const   * const  )"0 selected", 
        (char const   * const  )"cancelled",      (char const   * const  )"failed!",      (char const   * const  )"session name: ",      (char const   * const  )"\'c\'p/\'m\'v as?", 
        (char const   * const  )"\'c\'urrent/\'s\'el?",      (char const   * const  )"%s %s? [Esc cancels]",      (char const   * const  )"size limit exceeded",      (char const   * const  )"\'f\'ile/\'d\'ir/\'s\'ym/\'h\'ard?", 
        (char const   * const  )"\'c\'li/\'g\'ui?",      (char const   * const  )"overwrite?",      (char const   * const  )"\'s\'ave/\'l\'oad/\'r\'estore?",      (char const   * const  )"Quit all contexts?", 
        (char const   * const  )"remote name (- for hovered): ",      (char const   * const  )"archive [path/]name: ",      (char const   * const  )"open with: ",      (char const   * const  )"[path/]name: ", 
        (char const   * const  )"link prefix [@ for none]: ",      (char const   * const  )"copy [path/]name: ",      (char const   * const  )"\n\'Enter\' to continue",      (char const   * const  )"open failed", 
        (char const   * const  )"dir inaccessible",      (char const   * const  )"empty! edit/open with",      (char const   * const  )"?",      (char const   * const  )"not set", 
        (char const   * const  )"entry exists",      (char const   * const  )"too few cols!",      (char const   * const  )"\'s\'shfs/\'r\'clone?",      (char const   * const  )"refresh if slow", 
        (char const   * const  )"app: ",      (char const   * const  )"\'o\'pen/e\'x\'tract/\'l\'s/\'m\'nt?",      (char const   * const  )"keys:",      (char const   * const  )"invalid regex", 
        (char const   * const  )"\'a\'u/\'d\'u/\'e\'xt/\'r\'ev/\'s\'z/\'t\'m/\'v\'er/\'c\'lr/\'^T\'?",      (char const   * const  )"unmount failed! try lazy?",      (char const   * const  )"first file (\')/char?",      (char const   * const  )"remove tmp file?", 
        (char const   * const  )"invalid key",      (char const   * const  )"unchanged",      (char const   * const  )"dir changed, range sel off",      (char const   * const  )"name: ", 
        (char const   * const  )"file limit exceeded"};
static char const   * const  env_cfg[14]  = 
  {      (char const   * const  )"NNN_OPTS",      (char const   * const  )"NNN_BMS",      (char const   * const  )"NNN_PLUG",      (char const   * const  )"NNN_OPENER", 
        (char const   * const  )"NNN_COLORS",      (char const   * const  )"NNN_FCOLORS",      (char const   * const  )"NNNLVL",      (char const   * const  )"NNN_PIPE", 
        (char const   * const  )"NNN_MCLICK",      (char const   * const  )"NNN_SEL",      (char const   * const  )"NNN_ARCHIVE",      (char const   * const  )"NNN_ORDER", 
        (char const   * const  )"NNN_HELP",      (char const   * const  )"NNN_TRASH"};
static char const   * const  envs[5]  = {      (char const   * const  )"SHELL",      (char const   * const  )"VISUAL",      (char const   * const  )"EDITOR",      (char const   * const  )"PAGER", 
        (char const   * const  )"nnn"};
static char cp[10]  = 
  {      (char )'c',      (char )'p',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'i',      (char )'R', 
        (char )'p',      (char )'\000'};
static char mv[8]  = 
  {      (char )'m',      (char )'v',      (char )' ',      (char )' ', 
        (char )' ',      (char )'-',      (char )'i',      (char )'\000'};
static char const   * const  archive_cmd[4]  = {      (char const   * const  )"atool -a",      (char const   * const  )"bsdtar -acvf",      (char const   * const  )"zip -r",      (char const   * const  )"tar -acvf"};
static char const   * const  toks[4]  = {      (char const   * const  )"bookmarks",      (char const   * const  )"sessions",      (char const   * const  )"mounts",      (char const   * const  )"plugins"};
static char const   * const  patterns[5]  = {      (char const   * const  )"sed -i \'s|^\\(\\(.*/\\)\\(.*\\)$\\)|#\\1\\n\\3|\' %s",      (char const   * const  )"sed \'s|^\\([^#/][^/]\\?.*\\)$|%s/\\1|;s|^#\\(/.*\\)$|\\1|\' %s | tr \'\\n\' \'\\0\' | xargs -0 -n2 sh -c \'%s \"$0\" \"$@\" < /dev/tty\'",      (char const   * const  )"\\.(bz|bz2|gz|tar|taz|tbz|tbz2|tgz|z|zip)$",      (char const   * const  )"sed -i \'s|^%s\\(.*\\)$|%s\\1|\' %s", 
        (char const   * const  )"sed -ze \'s|^%s/||\' \'%s\' | xargs -0 %s %s"};
static char gcolors[25]  = 
  {      (char )'c',      (char )'1',      (char )'e',      (char )'2', 
        (char )'2',      (char )'7',      (char )'2',      (char )'e', 
        (char )'0',      (char )'0',      (char )'6',      (char )'0', 
        (char )'3',      (char )'3',      (char )'f',      (char )'7', 
        (char )'c',      (char )'6',      (char )'d',      (char )'6', 
        (char )'a',      (char )'b',      (char )'c',      (char )'4', 
        (char )'\000'};
static uint_t fcolors[17]  = {      (uint_t )0};
static int inotify_fd  ;
static int inotify_wd  =    -1;
static uint_t INOTIFY_MASK  =    (uint_t )4034;
static void redraw(char *path ) ;
static int spawn(char *file , char *arg1 , char *arg2 , char *arg3 , ushort_t flag ) ;
static void move_cursor(int target , int ignore_scrolloff ) ;
static char *load_input(int fd , char const   *path ) ;
static int set_sort_flags(int r ) ;
static void statusbar(char *path ) ;
static _Bool get_output(char *file , char *arg1 , char *arg2 , int fdout , _Bool multi ,
                        _Bool page ) ;
static void sigint_handler(int sig ) 
{ 


  {
  g_state.interrupt = (uint_t )1;
  return;
}
}
static void clean_exit_sighandler(int sig ) 
{ 


  {
  endwin();
  exit(0);
}
}
static char *xitoa(uint_t val ) ;
static char dst[32]  = {      (char )'\000'};
static char const   digits[201]  = 
  {      (char const   )'0',      (char const   )'0',      (char const   )'0',      (char const   )'1', 
        (char const   )'0',      (char const   )'2',      (char const   )'0',      (char const   )'3', 
        (char const   )'0',      (char const   )'4',      (char const   )'0',      (char const   )'5', 
        (char const   )'0',      (char const   )'6',      (char const   )'0',      (char const   )'7', 
        (char const   )'0',      (char const   )'8',      (char const   )'0',      (char const   )'9', 
        (char const   )'1',      (char const   )'0',      (char const   )'1',      (char const   )'1', 
        (char const   )'1',      (char const   )'2',      (char const   )'1',      (char const   )'3', 
        (char const   )'1',      (char const   )'4',      (char const   )'1',      (char const   )'5', 
        (char const   )'1',      (char const   )'6',      (char const   )'1',      (char const   )'7', 
        (char const   )'1',      (char const   )'8',      (char const   )'1',      (char const   )'9', 
        (char const   )'2',      (char const   )'0',      (char const   )'2',      (char const   )'1', 
        (char const   )'2',      (char const   )'2',      (char const   )'2',      (char const   )'3', 
        (char const   )'2',      (char const   )'4',      (char const   )'2',      (char const   )'5', 
        (char const   )'2',      (char const   )'6',      (char const   )'2',      (char const   )'7', 
        (char const   )'2',      (char const   )'8',      (char const   )'2',      (char const   )'9', 
        (char const   )'3',      (char const   )'0',      (char const   )'3',      (char const   )'1', 
        (char const   )'3',      (char const   )'2',      (char const   )'3',      (char const   )'3', 
        (char const   )'3',      (char const   )'4',      (char const   )'3',      (char const   )'5', 
        (char const   )'3',      (char const   )'6',      (char const   )'3',      (char const   )'7', 
        (char const   )'3',      (char const   )'8',      (char const   )'3',      (char const   )'9', 
        (char const   )'4',      (char const   )'0',      (char const   )'4',      (char const   )'1', 
        (char const   )'4',      (char const   )'2',      (char const   )'4',      (char const   )'3', 
        (char const   )'4',      (char const   )'4',      (char const   )'4',      (char const   )'5', 
        (char const   )'4',      (char const   )'6',      (char const   )'4',      (char const   )'7', 
        (char const   )'4',      (char const   )'8',      (char const   )'4',      (char const   )'9', 
        (char const   )'5',      (char const   )'0',      (char const   )'5',      (char const   )'1', 
        (char const   )'5',      (char const   )'2',      (char const   )'5',      (char const   )'3', 
        (char const   )'5',      (char const   )'4',      (char const   )'5',      (char const   )'5', 
        (char const   )'5',      (char const   )'6',      (char const   )'5',      (char const   )'7', 
        (char const   )'5',      (char const   )'8',      (char const   )'5',      (char const   )'9', 
        (char const   )'6',      (char const   )'0',      (char const   )'6',      (char const   )'1', 
        (char const   )'6',      (char const   )'2',      (char const   )'6',      (char const   )'3', 
        (char const   )'6',      (char const   )'4',      (char const   )'6',      (char const   )'5', 
        (char const   )'6',      (char const   )'6',      (char const   )'6',      (char const   )'7', 
        (char const   )'6',      (char const   )'8',      (char const   )'6',      (char const   )'9', 
        (char const   )'7',      (char const   )'0',      (char const   )'7',      (char const   )'1', 
        (char const   )'7',      (char const   )'2',      (char const   )'7',      (char const   )'3', 
        (char const   )'7',      (char const   )'4',      (char const   )'7',      (char const   )'5', 
        (char const   )'7',      (char const   )'6',      (char const   )'7',      (char const   )'7', 
        (char const   )'7',      (char const   )'8',      (char const   )'7',      (char const   )'9', 
        (char const   )'8',      (char const   )'0',      (char const   )'8',      (char const   )'1', 
        (char const   )'8',      (char const   )'2',      (char const   )'8',      (char const   )'3', 
        (char const   )'8',      (char const   )'4',      (char const   )'8',      (char const   )'5', 
        (char const   )'8',      (char const   )'6',      (char const   )'8',      (char const   )'7', 
        (char const   )'8',      (char const   )'8',      (char const   )'8',      (char const   )'9', 
        (char const   )'9',      (char const   )'0',      (char const   )'9',      (char const   )'1', 
        (char const   )'9',      (char const   )'2',      (char const   )'9',      (char const   )'3', 
        (char const   )'9',      (char const   )'4',      (char const   )'9',      (char const   )'5', 
        (char const   )'9',      (char const   )'6',      (char const   )'9',      (char const   )'7', 
        (char const   )'9',      (char const   )'8',      (char const   )'9',      (char const   )'9', 
        (char const   )'\000'};
static char *xitoa(uint_t val ) 
{ 
  uint_t next ;
  uint_t quo ;
  uint_t i ;

  {
  next = (uint_t )30;
  while (val >= 100U) {
    quo = val / 100U;
    i = (val - quo * 100U) * 2U;
    val = quo;
    dst[next] = (char )digits[i + 1U];
    next --;
    dst[next] = (char )digits[i];
    next --;
  }
  if (val < 10U) {
    dst[next] = (char )(48U + val);
  } else {
    i = val * 2U;
    dst[next] = (char )digits[i + 1U];
    next --;
    dst[next] = (char )digits[i];
  }
  return (& dst[next]);
}
}
static uchar_t xchartohex(uchar_t c ) 
{ 


  {
  if ((unsigned int )c - 48U <= 9U) {
    return ((uchar_t )((int )c - 48));
  }
  if ((int )c >= 97) {
    if ((int )c <= 102) {
      return ((uchar_t )(((int )c - 97) + 10));
    }
  }
  if ((int )c >= 65) {
    if ((int )c <= 70) {
      return ((uchar_t )(((int )c - 65) + 10));
    }
  }
  return (c);
}
}
static _Bool test_set_bit(uint_t nr ) 
{ 
  ullong_t *m ;

  {
  nr &= 16777215U;
  pthread_mutex_lock(& hardlink_mutex);
  m = ihashbmp + (nr >> 6);
  if (*m & (unsigned long long )(1 << (nr & 63U))) {
    pthread_mutex_unlock(& hardlink_mutex);
    return ((_Bool)0);
  }
  *m |= (unsigned long long )(1 << (nr & 63U));
  pthread_mutex_unlock(& hardlink_mutex);
  return ((_Bool)1);
}
}
static void max_openfds(void) 
{ 
  struct rlimit rl ;
  int tmp ;

  {
  tmp = getrlimit((__rlimit_resource_t )7, & rl);
  if (! tmp) {
    if (rl.rlim_cur < rl.rlim_max) {
      rl.rlim_cur = rl.rlim_max;
      setrlimit((__rlimit_resource_t )7, (struct rlimit  const  *)(& rl));
    }
  }
  return;
}
}
static void *xrealloc(void *pcur , size_t len ) 
{ 
  void *pmem ;
  void *tmp ;

  {
  tmp = realloc(pcur, len);
  pmem = tmp;
  if (! pmem) {
    free(pcur);
  }
  return (pmem);
}
}
static size_t xstrsncpy(char * __restrict  dst___0 , char const   * __restrict  src ,
                        size_t n ) 
{ 
  char *end ;
  void *tmp ;

  {
  tmp = memccpy((void * __restrict  )dst___0, (void const   * __restrict  )src, '\000',
                n);
  end = (char *)tmp;
  if (! end) {
    *(dst___0 + (n - 1UL)) = (char )'\000';
    end = (char *)(dst___0 + n);
  }
  return ((size_t )(end - (char *)dst___0));
}
}
__inline static size_t xstrlen(char const   * __restrict  s ) 
{ 
  void *tmp ;

  {
  tmp = rawmemchr((void const   *)s, '\000');
  return ((size_t )((char *)tmp - (char *)s));
}
}
static char *xstrdup(char const   * __restrict  s ) 
{ 
  size_t len ;
  size_t tmp ;
  char *ptr ;
  void *tmp___0 ;

  {
  tmp = xstrlen(s);
  len = tmp + 1UL;
  tmp___0 = malloc(len);
  ptr = (char *)tmp___0;
  if (ptr) {
    xstrsncpy((char * __restrict  )ptr, s, len);
  }
  return (ptr);
}
}
static _Bool is_suffix(char const   * __restrict  str , char const   * __restrict  suffix ) 
{ 
  size_t lenstr ;
  size_t tmp ;
  size_t lensuffix ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (! str) {
    return ((_Bool)0);
  } else
  if (! suffix) {
    return ((_Bool)0);
  }
  tmp = xstrlen(str);
  lenstr = tmp;
  tmp___0 = xstrlen(suffix);
  lensuffix = tmp___0;
  if (lensuffix > lenstr) {
    return ((_Bool)0);
  }
  if ((int const   )*(str + (lenstr - lensuffix)) != (int const   )*suffix) {
    tmp___2 = -1;
  } else {
    tmp___1 = strcmp((char const   *)(str + (lenstr - lensuffix)), (char const   *)suffix);
    tmp___2 = tmp___1;
  }
  return ((_Bool )(tmp___2 == 0));
}
}
__inline static _Bool is_prefix(char const   * __restrict  str , char const   * __restrict  prefix ,
                                size_t len ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  tmp = strncmp((char const   *)str, (char const   *)prefix, len);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  return ((_Bool )tmp___0);
}
}
static void *xmemrchr(uchar_t * __restrict  s , uchar_t ch , size_t n ) 
{ 
  void *tmp ;

  {
  tmp = memrchr((void const   *)s, (int )ch, n);
  return (tmp);
}
}
static char *xdirname(char *path ) 
{ 
  char *base ;
  size_t tmp ;
  void *tmp___0 ;

  {
  tmp = xstrlen((char const   * __restrict  )path);
  tmp___0 = xmemrchr((uchar_t * __restrict  )((uchar_t *)path), (uchar_t )'/', tmp);
  base = (char *)tmp___0;
  if ((unsigned long )base == (unsigned long )path) {
    *(path + 1) = (char )'\000';
  } else {
    *base = (char )'\000';
  }
  return (path);
}
}
static char *xbasename(char *path ) 
{ 
  char *base ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  tmp = xstrlen((char const   * __restrict  )path);
  tmp___0 = xmemrchr((uchar_t * __restrict  )((uchar_t *)path), (uchar_t )'/', tmp);
  base = (char *)tmp___0;
  if (base) {
    tmp___1 = base + 1;
  } else {
    tmp___1 = path;
  }
  return (tmp___1);
}
}
__inline static char *xextension(char const   *fname , size_t len ) 
{ 
  void *tmp ;

  {
  tmp = xmemrchr((uchar_t * __restrict  )((uchar_t *)fname), (uchar_t )'.', len);
  return ((char *)tmp);
}
}
__inline static _Bool getutil(char *util ) 
{ 
  int tmp ;

  {
  tmp = spawn((char *)"which", util, (char *)((void *)0), (char *)((void *)0), (ushort_t )12);
  return ((_Bool )(tmp == 0));
}
}
static size_t mkpath(char const   *dir , char const   *name , char *out ) 
{ 
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  len = (size_t )0;
  if ((int const   )*(name + 0) != 47) {
    if ((int const   )*(dir + 1) == 0) {
      if ((int const   )*(dir + 0) == 47) {
        len = (size_t )1;
      } else {
        tmp = xstrsncpy((char * __restrict  )out, (char const   * __restrict  )dir,
                        (size_t )4096);
        len = tmp;
      }
    } else {
      tmp = xstrsncpy((char * __restrict  )out, (char const   * __restrict  )dir,
                      (size_t )4096);
      len = tmp;
    }
    *(out + (len - 1UL)) = (char )'/';
  }
  tmp___0 = xstrsncpy((char * __restrict  )(out + len), (char const   * __restrict  )name,
                      4096UL - len);
  return (tmp___0 + len);
}
}
static char *common_prefix(char const   *path , char *prefix ) 
{ 
  char const   *x ;
  char const   *y ;
  char *sep ;
  void *tmp ;

  {
  x = path;
  y = (char const   *)prefix;
  if (! path) {
    return ((char *)((void *)0));
  } else
  if (! *path) {
    return ((char *)((void *)0));
  } else
  if (! prefix) {
    return ((char *)((void *)0));
  }
  if (! *prefix) {
    xstrsncpy((char * __restrict  )prefix, (char const   * __restrict  )path, (size_t )4096);
    return (prefix);
  }
  while (1) {
    if (*x) {
      if (*y) {
        if (! ((int const   )*x == (int const   )*y)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    x ++;
    y ++;
  }
  if (! *x) {
    if (! *y) {
      return (prefix);
    }
  }
  if (! *x) {
    if ((int const   )*y == 47) {
      xstrsncpy((char * __restrict  )prefix, (char const   * __restrict  )path, (size_t )(y - path));
      return (prefix);
    }
  }
  if (! *y) {
    if ((int const   )*x == 47) {
      return (prefix);
    }
  }
  *(prefix + (y - (char const   *)prefix)) = (char )'\000';
  tmp = xmemrchr((uchar_t * __restrict  )((uchar_t *)prefix), (uchar_t )'/', (size_t )(y - (char const   *)prefix));
  sep = (char *)tmp;
  if ((unsigned long )sep != (unsigned long )prefix) {
    *sep = (char )'\000';
  } else {
    *(prefix + 1) = (char )'\000';
  }
  return (prefix);
}
}
static char *abspath(char const   *path , char const   *cwd , char *buf ) 
{ 
  char *tmp ;
  size_t dst_size ;
  size_t src_size ;
  size_t tmp___0 ;
  size_t cwd_size ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t len ;
  char const   *src ;
  char *dst___0 ;
  char *resolved_path ;
  void *tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  char const   *next ;
  void *tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;

  {
  if (! path) {
    return ((char *)((void *)0));
  }
  if ((int const   )*(path + 0) == 126) {
    cwd = (char const   *)home;
  } else
  if ((int const   )*(path + 0) != 47) {
    if (! cwd) {
      tmp = getcwd((char *)((void *)0), (size_t )0);
      cwd = (char const   *)tmp;
    }
  }
  dst_size = (size_t )0;
  tmp___0 = xstrlen((char const   * __restrict  )path);
  src_size = tmp___0;
  if (cwd) {
    tmp___1 = xstrlen((char const   * __restrict  )cwd);
    tmp___2 = tmp___1;
  } else {
    tmp___2 = (size_t )0;
  }
  cwd_size = tmp___2;
  len = src_size;
  if (buf) {
    tmp___4 = (void *)buf;
  } else {
    tmp___3 = malloc((src_size + cwd_size) + 2UL);
    tmp___4 = tmp___3;
  }
  resolved_path = (char *)tmp___4;
  if (! resolved_path) {
    return ((char *)((void *)0));
  }
  if ((int const   )*(path + 0) != 47) {
    if (! cwd) {
      if (! buf) {
        free((void *)resolved_path);
      }
      return ((char *)((void *)0));
    }
    tmp___5 = xstrsncpy((char * __restrict  )resolved_path, (char const   * __restrict  )cwd,
                        cwd_size + 1UL);
    dst_size = tmp___5 - 1UL;
  } else {
    *(resolved_path + 0) = (char )'\000';
  }
  src = path;
  dst___0 = resolved_path + dst_size;
  next = (char const   *)((void *)0);
  while ((unsigned long )next != (unsigned long )(path + src_size)) {
    tmp___6 = memchr((void const   *)src, '/', len);
    next = (char const   *)tmp___6;
    if (! next) {
      next = path + src_size;
    }
    if (next - src == 2L) {
      if ((int const   )*(src + 0) == 46) {
        if ((int const   )*(src + 1) == 46) {
          if (dst___0 - resolved_path) {
            tmp___7 = xmemrchr((uchar_t * __restrict  )((uchar_t *)resolved_path),
                               (uchar_t )'/', (size_t )(dst___0 - resolved_path));
            dst___0 = (char *)tmp___7;
            *dst___0 = (char )'\000';
          }
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
    if (next - src == 1L) {
      if (! ((int const   )*(src + 0) == 46)) {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (next - src) {
      tmp___8 = dst___0;
      dst___0 ++;
      *tmp___8 = (char )'/';
      xstrsncpy((char * __restrict  )dst___0, (char const   * __restrict  )src, (size_t )((next - src) + 1L));
      dst___0 += next - src;
    }
    src = next + 1;
    len = src_size - (size_t )(src - path);
  }
  if ((int )*resolved_path == 0) {
    *(resolved_path + 0) = (char )'/';
    *(resolved_path + 1) = (char )'\000';
  }
  return (resolved_path);
}
}
static _Bool set_tilde_in_path(char *path ) 
{ 
  _Bool tmp ;

  {
  tmp = is_prefix((char const   * __restrict  )path, (char const   * __restrict  )home,
                  (size_t )homelen);
  if (tmp) {
    *(home + homelen) = *(path + ((int )homelen - 1));
    *(path + ((int )homelen - 1)) = (char )'~';
    return ((_Bool)1);
  }
  return ((_Bool)0);
}
}
static void reset_tilde_in_path(char *path ) 
{ 


  {
  *(path + ((int )homelen - 1)) = *(home + homelen);
  *(home + homelen) = (char )'\000';
  return;
}
}
static void convert_tilde(char const   *path , char *buf ) 
{ 
  ssize_t len ;
  size_t tmp ;
  ssize_t loclen ;
  size_t tmp___0 ;

  {
  if ((int const   )*(path + 0) == 126) {
    tmp = xstrlen((char const   * __restrict  )home);
    len = (ssize_t )tmp;
    tmp___0 = xstrlen((char const   * __restrict  )path);
    loclen = (ssize_t )tmp___0;
    xstrsncpy((char * __restrict  )buf, (char const   * __restrict  )home, (size_t )(len + 1L));
    xstrsncpy((char * __restrict  )(buf + len), (char const   * __restrict  )(path + 1),
              (size_t )loclen);
  }
  return;
}
}
static int create_tmp_file(void) 
{ 
  int fd ;
  int tmp ;

  {
  xstrsncpy((char * __restrict  )((g_tmpfpath + (int )tmpfplen) - 1), (char const   * __restrict  )messages[2],
            (size_t )(64 - (int )tmpfplen));
  tmp = mkstemp(g_tmpfpath);
  fd = tmp;
  return (fd);
}
}
static void msg(char const   *message ) 
{ 


  {
  dprintf(2, (char const   * __restrict  )"%s\n", message);
  return;
}
}
static void handle_key_resize(void) 
{ 


  {
  endwin();
  wrefresh(stdscr);
  return;
}
}
static void clearoldprompt(void) 
{ 


  {
  wmove(stdscr, (int )xlines - 2, 0);
  wclrtoeol(stdscr);
  wmove(stdscr, (int )xlines - 1, 0);
  wclrtoeol(stdscr);
  handle_key_resize();
  return;
}
}
__inline static void printmsg_nc(char const   *msg___0 ) 
{ 


  {
  wmove(stdscr, (int )xlines - 1, 0);
  waddnstr(stdscr, msg___0, -1);
  wclrtoeol(stdscr);
  return;
}
}
static void printmsg(char const   *msg___0 ) 
{ 


  {
  wattr_on(stdscr, ((cfg.curctx + 1U) << 8) & (((1U << 8) - 1U) << 8), (void *)0);
  printmsg_nc(msg___0);
  wattr_off(stdscr, ((cfg.curctx + 1U) << 8) & (((1U << 8) - 1U) << 8), (void *)0);
  return;
}
}
static void printwait(char const   *msg___0 , int *presel ) 
{ 


  {
  printmsg(msg___0);
  if (presel) {
    *presel = '$';
    if (ndents) {
      xstrsncpy((char * __restrict  )(g_ctx[cfg.curctx].c_name), (char const   * __restrict  )(pdents + cur)->name,
                (size_t )256);
    }
  }
  return;
}
}
static void printerr(int linenum ) 
{ 
  char *tmp ;

  {
  endwin();
  tmp = xitoa((uint_t )linenum);
  perror((char const   *)tmp);
  if (! g_state.picker) {
    if (selpath) {
      unlink((char const   *)selpath);
    }
  }
  free((void *)pselbuf);
  exit(1);
}
}
__inline static _Bool xconfirm(int c ) 
{ 
  int tmp ;

  {
  if (c == 121) {
    tmp = 1;
  } else
  if (c == 89) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  return ((_Bool )tmp);
}
}
static int get_input(char const   *prompt ) 
{ 
  wint_t ch[1] ;

  {
  if (prompt) {
    printmsg(prompt);
  }
  wtimeout(stdscr, -1);
  wget_wch(stdscr, ch);
  while (ch[0] == 410U) {
    if (prompt) {
      clearoldprompt();
      xlines = (ushort_t )LINES;
      printmsg(prompt);
    }
    wget_wch(stdscr, ch);
  }
  wtimeout(stdscr, 1000);
  return ((int )ch[0]);
}
}
static _Bool isselfileempty(void) 
{ 
  struct stat sb ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = stat((char const   * __restrict  )selpath, (struct stat * __restrict  )(& sb));
  if (tmp == -1) {
    tmp___0 = 1;
  } else
  if (! sb.st_size) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  return ((_Bool )tmp___0);
}
}
static int get_cur_or_sel(void) 
{ 
  _Bool sel ;
  _Bool tmp ;
  int tmp___0 ;
  int choice ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (selbufpos) {
    tmp___0 = 1;
  } else {
    tmp = isselfileempty();
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  }
  sel = (_Bool )tmp___0;
  if (sel) {
    if (ndents) {
      if (cfg.prefersel) {
        if (selbufpos) {
          return ('s');
        }
      }
      tmp___1 = get_input((char const   *)messages[8]);
      choice = tmp___1;
      if (choice == 99) {
        tmp___2 = choice;
      } else
      if (choice == 115) {
        tmp___2 = choice;
      } else {
        tmp___2 = 0;
      }
      return (tmp___2);
    }
  }
  if (sel) {
    return ('s');
  }
  if (ndents) {
    return ('c');
  }
  return (0);
}
}
static void xdelay(useconds_t delay ) 
{ 


  {
  wrefresh(stdscr);
  usleep(delay);
  return;
}
}
static char confirm_force(_Bool selection ) 
{ 
  char str[64] ;
  char const   *tmp ;
  char *tmp___0 ;
  int r ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (selection) {
    tmp = "selection";
  } else {
    tmp = "hovered";
  }
  if (g_state.trash) {
    tmp___0 = utils[19] + 4;
  } else {
    tmp___0 = utils[20];
  }
  snprintf((char * __restrict  )(str), (size_t )64, (char const   * __restrict  )messages[9],
           tmp___0, tmp);
  tmp___1 = get_input((char const   *)(str));
  r = tmp___1;
  if (r == 27) {
    return ((char )'\000');
  }
  if (r == 121) {
    return ((char )'f');
  } else
  if (r == 89) {
    return ((char )'f');
  }
  if (g_state.trash) {
    tmp___2 = '\000';
  } else {
    tmp___2 = 'i';
  }
  return ((char )tmp___2);
}
}
static void writesel(char const   *buf , size_t const   buflen ) 
{ 
  int fd ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  ssize_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;

  {
  if (! selpath) {
    return;
  }
  tmp = open((char const   *)selpath, 577, 438);
  fd = tmp;
  if (fd != -1) {
    tmp___2 = write(fd, (void const   *)buf, (size_t )buflen);
    if (tmp___2 != (ssize_t )buflen) {
      tmp___0 = __errno_location();
      tmp___1 = strerror(*tmp___0);
      printwait((char const   *)tmp___1, (int *)((void *)0));
    }
    close(fd);
  } else {
    tmp___3 = __errno_location();
    tmp___4 = strerror(*tmp___3);
    printwait((char const   *)tmp___4, (int *)((void *)0));
  }
  return;
}
}
static void appendfpath(char const   *path , size_t const   len ) 
{ 
  void *tmp ;
  size_t tmp___0 ;

  {
  if (selbufpos >= selbuflen) {
    goto _L;
  } else
  if (len + 3UL > (size_t const   )(selbuflen - selbufpos)) {
    _L: /* CIL Label */ 
    selbuflen += 4096U;
    tmp = xrealloc((void *)pselbuf, (size_t )selbuflen);
    pselbuf = (char *)tmp;
    if (! pselbuf) {
      printerr(1465);
    }
  }
  tmp___0 = xstrsncpy((char * __restrict  )(pselbuf + selbufpos), (char const   * __restrict  )path,
                      (size_t )len);
  selbufpos = (uint_t )((size_t )selbufpos + tmp___0);
  return;
}
}
static void selbufrealloc(size_t const   alloclen ) 
{ 
  void *tmp ;

  {
  if ((size_t const   )selbufpos + alloclen > (size_t const   )selbuflen) {
    selbuflen = (uint_t )((((((size_t const   )selbufpos + alloclen) + 4096UL) - 1UL) / 4096UL) * 4096UL);
    tmp = xrealloc((void *)pselbuf, (size_t )selbuflen);
    pselbuf = (char *)tmp;
    if (! pselbuf) {
      printerr(1477);
    }
  }
  return;
}
}
static size_t seltofile(int fd , uint_t *pcount ) 
{ 
  uint_t lastpos ;
  uint_t count ;
  char *pbuf ;
  size_t pos ;
  ssize_t len ;
  ssize_t prefixlen ;
  ssize_t initlen ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  ssize_t tmp___2 ;
  ssize_t tmp___3 ;
  ssize_t tmp___4 ;
  _Bool tmp___5 ;
  ssize_t tmp___6 ;

  {
  count = (uint_t )0;
  pbuf = pselbuf;
  pos = (size_t )0;
  prefixlen = (ssize_t )0;
  initlen = (ssize_t )0;
  if (pcount) {
    *pcount = (uint_t )0;
  }
  if (! selbufpos) {
    return ((size_t )0);
  }
  lastpos = selbufpos - 1U;
  if (listpath) {
    tmp = xstrlen((char const   * __restrict  )listroot);
    prefixlen = (ssize_t )tmp;
    tmp___0 = xstrlen((char const   * __restrict  )listpath);
    initlen = (ssize_t )tmp___0;
  }
  while (pos <= (size_t )lastpos) {
    tmp___1 = xstrlen((char const   * __restrict  )pbuf);
    len = (ssize_t )tmp___1;
    if (! listpath) {
      goto _L;
    } else {
      tmp___5 = is_prefix((char const   * __restrict  )pbuf, (char const   * __restrict  )listpath,
                          (size_t )initlen);
      if (tmp___5) {
        tmp___3 = write(fd, (void const   *)listroot, (size_t )prefixlen);
        if (tmp___3 != prefixlen) {
          return (pos);
        }
        tmp___4 = write(fd, (void const   *)(pbuf + initlen), (size_t )(len - initlen));
        if (tmp___4 != len - initlen) {
          return (pos);
        }
      } else {
        _L: /* CIL Label */ 
        tmp___2 = write(fd, (void const   *)pbuf, (size_t )len);
        if (tmp___2 != len) {
          return (pos);
        }
      }
    }
    pos += (size_t )len;
    if (pos <= (size_t )lastpos) {
      tmp___6 = write(fd, (void const   *)"\n", (size_t )1);
      if (tmp___6 != 1L) {
        return (pos);
      }
      pbuf += len + 1L;
    }
    pos ++;
    count ++;
  }
  if (pcount) {
    *pcount = count;
  }
  return (pos);
}
}
static _Bool listselfile(void) 
{ 
  _Bool tmp ;

  {
  tmp = isselfileempty();
  if (tmp) {
    return ((_Bool)0);
  }
  snprintf((char * __restrict  )(g_buf), (size_t )(4096 + (256 << 1)), (char const   * __restrict  )"tr \'\\0\' \'\\n\' < %s",
           selpath);
  spawn((char *)utils[7], g_buf, (char *)((void *)0), (char *)((void *)0), (ushort_t )25);
  return ((_Bool)1);
}
}
static void resetselind(void) 
{ 
  int r ;

  {
  r = 0;
  while (r < ndents) {
    if ((pdents + r)->__annonCompField18.flags & 16ULL) {
      (pdents + r)->__annonCompField18.flags &= 0xffffffffffffffefULL;
    }
    r ++;
  }
  return;
}
}
static void startselection(void) 
{ 


  {
  if (! g_state.selmode) {
    g_state.selmode = (uint_t )1;
    nselected = 0;
    if (selbufpos) {
      resetselind();
      writesel((char const   *)((void *)0), (size_t const   )0);
      selbufpos = (uint_t )0;
    }
  }
  return;
}
}
static void clearselection(void) 
{ 


  {
  nselected = 0;
  selbufpos = (uint_t )0;
  g_state.selmode = (uint_t )0;
  writesel((char const   *)((void *)0), (size_t const   )0);
  return;
}
}
static char *findinsel(char *startpos , int len ) 
{ 
  char *found___0 ;
  size_t buflen ;
  void *tmp ;

  {
  if (! selbufpos) {
    return ((char *)0);
  }
  if (! startpos) {
    startpos = pselbuf;
  }
  found___0 = startpos;
  buflen = (size_t )((long )selbufpos - (startpos - pselbuf));
  while (1) {
    tmp = memmem((void const   *)found___0, buflen - (size_t )(found___0 - startpos),
                 (void const   *)(g_sel), (size_t )len);
    found___0 = (char *)tmp;
    if (! found___0) {
      return ((char *)((void *)0));
    }
    if ((unsigned long )found___0 == (unsigned long )startpos) {
      return (found___0);
    } else
    if ((int )*(found___0 - 1) == 0) {
      return (found___0);
    }
    found___0 += len;
    if ((unsigned long )found___0 >= (unsigned long )(startpos + buflen)) {
      return ((char *)((void *)0));
    }
  }
}
}
static int markcmp(void const   *va , void const   *vb ) 
{ 
  selmark const   *ma ;
  selmark const   *mb ;

  {
  ma = (selmark const   *)((selmark *)va);
  mb = (selmark const   *)((selmark *)vb);
  return ((int )(ma->startpos - mb->startpos));
}
}
__inline static void findmarkentry(size_t len , struct entry *dentp ) 
{ 
  size_t tmp ;
  char *tmp___0 ;

  {
  if (! (dentp->__annonCompField18.flags & 32ULL)) {
    tmp = xstrsncpy((char * __restrict  )(g_sel + len), (char const   * __restrict  )dentp->name,
                    (size_t )dentp->__annonCompField18.nlen);
    tmp___0 = findinsel(findselpos, (int )(len + tmp));
    if (tmp___0) {
      dentp->__annonCompField18.flags |= 16ULL;
    }
    dentp->__annonCompField18.flags |= 32ULL;
  }
  return;
}
}
static void invertselbuf(int const   pathlen ) 
{ 
  size_t len ;
  size_t endpos ;
  size_t shrinklen ;
  size_t alloclen ;
  char *pbuf ;
  char *found___0 ;
  int i ;
  int nmarked ;
  int prev ;
  struct entry *dentp ;
  _Bool scan ;
  selmark *marked ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
  shrinklen = (size_t )0;
  alloclen = (size_t )0;
  pbuf = g_sel + pathlen;
  nmarked = 0;
  prev = 0;
  scan = (_Bool)0;
  tmp = malloc((unsigned long )nselected * sizeof(selmark ));
  marked = (selmark *)tmp;
  if (! marked) {
    tmp___0 = __errno_location();
    tmp___1 = strerror(*tmp___0);
    printwait((char const   *)tmp___1, (int *)((void *)0));
    return;
  }
  i = 0;
  while (i < ndents) {
    dentp = pdents + i;
    if (dentp->__annonCompField18.flags & 32ULL) {
      if (dentp->__annonCompField18.flags & 16ULL) {
        dentp->__annonCompField18.flags ^= 16ULL;
        scan = (_Bool)1;
      } else {
        dentp->__annonCompField18.flags |= 16ULL;
        alloclen = (size_t )((ullong_t )alloclen + ((ullong_t )pathlen + dentp->__annonCompField18.nlen));
      }
    } else {
      dentp->__annonCompField18.flags |= 32ULL;
      scan = (_Bool)1;
    }
    if (scan) {
      tmp___2 = xstrsncpy((char * __restrict  )pbuf, (char const   * __restrict  )dentp->name,
                          (size_t )255);
      len = (size_t )pathlen + tmp___2;
      found___0 = findinsel(findselpos, (int )len);
      if (found___0) {
        if ((unsigned long )findselpos == (unsigned long )found___0) {
          findselpos += len;
        }
        if (nmarked) {
          if ((unsigned long )found___0 == (unsigned long )((marked + (nmarked - 1))->startpos + (marked + (nmarked - 1))->len)) {
            (marked + (nmarked - 1))->len += len;
          } else {
            (marked + nmarked)->startpos = found___0;
            (marked + nmarked)->len = len;
            nmarked ++;
          }
        } else {
          (marked + nmarked)->startpos = found___0;
          (marked + nmarked)->len = len;
          nmarked ++;
        }
        nselected --;
        shrinklen += len;
      } else {
        dentp->__annonCompField18.flags |= 16ULL;
        alloclen = (size_t )((ullong_t )alloclen + ((ullong_t )pathlen + dentp->__annonCompField18.nlen));
      }
      scan = (_Bool)0;
    }
    i ++;
  }
  qsort((void *)marked, (size_t )nmarked, sizeof(selmark ), & markcmp);
  i = 1;
  while (i < nmarked) {
    if ((unsigned long )(marked + i)->startpos == (unsigned long )((marked + prev)->startpos + (marked + prev)->len)) {
      (marked + prev)->len += (marked + i)->len;
    } else {
      prev ++;
      (marked + prev)->startpos = (marked + i)->startpos;
      (marked + prev)->len = (marked + i)->len;
    }
    i ++;
  }
  if (nmarked) {
    nmarked = prev + 1;
  }
  i = 0;
  while (i < nmarked) {
    found___0 = (marked + i)->startpos;
    if (i + 1 == nmarked) {
      endpos = (size_t )selbufpos;
    } else {
      endpos = (size_t )((marked + (i + 1))->startpos - pselbuf);
    }
    len = (marked + i)->len;
    memmove((void *)found___0, (void const   *)(found___0 + len), endpos - (size_t )((found___0 + len) - pselbuf));
    i ++;
  }
  free((void *)marked);
  selbufpos = (uint_t )((size_t )selbufpos - shrinklen);
  selbufrealloc((size_t const   )alloclen);
  i = 0;
  while (i < ndents) {
    if ((pdents + i)->__annonCompField18.flags & 16ULL) {
      tmp___3 = xstrsncpy((char * __restrict  )pbuf, (char const   * __restrict  )(pdents + i)->name,
                          (size_t )255);
      len = (size_t )pathlen + tmp___3;
      appendfpath((char const   *)(g_sel), (size_t const   )len);
      nselected ++;
    }
    i ++;
  }
  if (nselected) {
    writesel((char const   *)pselbuf, (size_t const   )(selbufpos - 1U));
  } else {
    clearselection();
  }
  return;
}
}
static void addtoselbuf(int const   pathlen , int startid , int endid ) 
{ 
  int i ;
  size_t len ;
  size_t alloclen ;
  struct entry *dentp ;
  char *found___0 ;
  char *pbuf ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  alloclen = (size_t )0;
  pbuf = g_sel + pathlen;
  i = startid;
  while (i <= endid) {
    dentp = pdents + i;
    if (findselpos) {
      tmp = xstrsncpy((char * __restrict  )pbuf, (char const   * __restrict  )dentp->name,
                      (size_t )255);
      len = (size_t )pathlen + tmp;
      found___0 = findinsel(findselpos, (int )len);
      if (found___0) {
        dentp->__annonCompField18.flags |= 48ULL;
        if ((unsigned long )found___0 == (unsigned long )findselpos) {
          findselpos += len;
          if ((unsigned long )findselpos == (unsigned long )(pselbuf + selbufpos)) {
            findselpos = (char *)((void *)0);
          }
        }
      } else {
        alloclen = (size_t )((ullong_t )alloclen + ((ullong_t )pathlen + dentp->__annonCompField18.nlen));
      }
    } else {
      alloclen = (size_t )((ullong_t )alloclen + ((ullong_t )pathlen + dentp->__annonCompField18.nlen));
    }
    i ++;
  }
  selbufrealloc((size_t const   )alloclen);
  i = startid;
  while (i <= endid) {
    if (! ((pdents + i)->__annonCompField18.flags & 16ULL)) {
      tmp___0 = xstrsncpy((char * __restrict  )pbuf, (char const   * __restrict  )(pdents + i)->name,
                          (size_t )255);
      len = (size_t )pathlen + tmp___0;
      appendfpath((char const   *)(g_sel), (size_t const   )len);
      nselected ++;
      (pdents + i)->__annonCompField18.flags |= 48ULL;
    }
    i ++;
  }
  writesel((char const   *)pselbuf, (size_t const   )(selbufpos - 1U));
  return;
}
}
static void rmfromselbuf(size_t len ) 
{ 
  char *found___0 ;
  char *tmp ;

  {
  tmp = findinsel(findselpos, (int )len);
  found___0 = tmp;
  if (! found___0) {
    return;
  }
  memmove((void *)found___0, (void const   *)(found___0 + len), (size_t )((long )selbufpos - ((found___0 + len) - pselbuf)));
  selbufpos = (uint_t )((size_t )selbufpos - len);
  if (nselected) {
    writesel((char const   *)pselbuf, (size_t const   )(selbufpos - 1U));
  } else {
    clearselection();
  }
  return;
}
}
static int scanselforpath(char const   *path , _Bool getsize ) 
{ 
  size_t off ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  if (! *(path + 1)) {
    g_sel[0] = (char )'/';
    findselpos = pselbuf;
    return (1);
  }
  tmp = xstrsncpy((char * __restrict  )(g_sel), (char const   * __restrict  )path,
                  (size_t )4096);
  off = tmp;
  g_sel[off - 1UL] = (char )'/';
  findselpos = findinsel((char *)((void *)0), (int )off);
  if (getsize) {
    return ((int )off);
  }
  if (findselpos) {
    tmp___0 = off;
  } else {
    tmp___0 = (size_t )0;
  }
  return ((int )tmp___0);
}
}
static void endselection(_Bool endselmode ) 
{ 
  int fd ;
  ssize_t count ;
  char buf[(sizeof(patterns[3]) + 4096UL) + (unsigned long )(64 << 1)] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
  if (endselmode) {
    if (g_state.selmode) {
      g_state.selmode = (uint_t )0;
    }
  }
  if (! listpath) {
    return;
  } else
  if (! selbufpos) {
    return;
  }
  fd = create_tmp_file();
  if (fd == -1) {
    return;
  }
  seltofile(fd, (uint_t *)((void *)0));
  tmp___1 = close(fd);
  if (tmp___1) {
    tmp = __errno_location();
    tmp___0 = strerror(*tmp);
    printwait((char const   *)tmp___0, (int *)((void *)0));
    return;
  }
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )patterns[3],
           listpath, listroot, g_tmpfpath);
  spawn((char *)utils[7], buf, (char *)((void *)0), (char *)((void *)0), (ushort_t )9);
  fd = open((char const   *)(g_tmpfpath), 0);
  if (fd == -1) {
    tmp___2 = __errno_location();
    tmp___3 = strerror(*tmp___2);
    printwait((char const   *)tmp___3, (int *)((void *)0));
    tmp___6 = unlink((char const   *)(g_tmpfpath));
    if (tmp___6) {
      tmp___4 = __errno_location();
      tmp___5 = strerror(*tmp___4);
      printwait((char const   *)tmp___5, (int *)((void *)0));
    }
    return;
  }
  count = read(fd, (void *)pselbuf, (size_t )selbuflen);
  if (count < 0L) {
    tmp___7 = __errno_location();
    tmp___8 = strerror(*tmp___7);
    printwait((char const   *)tmp___8, (int *)((void *)0));
    tmp___9 = close(fd);
    if (tmp___9) {
      tmp___11 = 1;
    } else {
      tmp___10 = unlink((char const   *)(g_tmpfpath));
      if (tmp___10) {
        tmp___11 = 1;
      } else {
        tmp___11 = 0;
      }
    }
    return;
  }
  tmp___14 = close(fd);
  if (tmp___14) {
    tmp___12 = __errno_location();
    tmp___13 = strerror(*tmp___12);
    printwait((char const   *)tmp___13, (int *)((void *)0));
    return;
  } else {
    tmp___15 = unlink((char const   *)(g_tmpfpath));
    if (tmp___15) {
      tmp___12 = __errno_location();
      tmp___13 = strerror(*tmp___12);
      printwait((char const   *)tmp___13, (int *)((void *)0));
      return;
    }
  }
  selbufpos = (uint_t )count;
  count --;
  *(pselbuf + count) = (char )'\000';
  count --;
  while (count > 0L) {
    if ((int )*(pselbuf + count) == 10) {
      if ((int )*(pselbuf + (count + 1L)) == 47) {
        *(pselbuf + count) = (char )'\000';
      }
    }
    count --;
  }
  writesel((char const   *)pselbuf, (size_t const   )(selbufpos - 1U));
  return;
}
}
static int editselection(void) 
{ 
  int ret ;
  int fd ;
  int lines ;
  ssize_t count ;
  struct stat sb ;
  time_t mtime ;
  _Bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  ret = -1;
  lines = 0;
  if (! selbufpos) {
    tmp = listselfile();
    return ((int )tmp);
  }
  fd = create_tmp_file();
  if (fd == -1) {
    return (-1);
  }
  seltofile(fd, (uint_t *)((void *)0));
  tmp___0 = close(fd);
  if (tmp___0) {
    return (-1);
  }
  tmp___1 = stat((char const   * __restrict  )(g_tmpfpath), (struct stat * __restrict  )(& sb));
  if (tmp___1) {
    unlink((char const   *)(g_tmpfpath));
    return (-1);
  }
  mtime = sb.st_mtim.tv_sec;
  if (cfg.waitedit) {
    tmp___2 = enveditor;
  } else {
    tmp___2 = editor;
  }
  spawn(tmp___2, g_tmpfpath, (char *)((void *)0), (char *)((void *)0), (ushort_t )9);
  fd = open((char const   *)(g_tmpfpath), 0);
  if (fd == -1) {
    unlink((char const   *)(g_tmpfpath));
    return (-1);
  }
  fstat(fd, & sb);
  if (mtime == sb.st_mtim.tv_sec) {
    unlink((char const   *)(g_tmpfpath));
    return (1);
  }
  if (sb.st_size > (__off_t )selbufpos) {
    unlink((char const   *)(g_tmpfpath));
    goto emptyedit;
  }
  count = read(fd, (void *)pselbuf, (size_t )selbuflen);
  if (count < 0L) {
    tmp___3 = __errno_location();
    tmp___4 = strerror(*tmp___3);
    printwait((char const   *)tmp___4, (int *)((void *)0));
    tmp___7 = close(fd);
    if (tmp___7) {
      tmp___5 = __errno_location();
      tmp___6 = strerror(*tmp___5);
      printwait((char const   *)tmp___6, (int *)((void *)0));
    } else {
      tmp___8 = unlink((char const   *)(g_tmpfpath));
      if (tmp___8) {
        tmp___5 = __errno_location();
        tmp___6 = strerror(*tmp___5);
        printwait((char const   *)tmp___6, (int *)((void *)0));
      }
    }
    goto emptyedit;
  }
  tmp___11 = close(fd);
  if (tmp___11) {
    tmp___9 = __errno_location();
    tmp___10 = strerror(*tmp___9);
    printwait((char const   *)tmp___10, (int *)((void *)0));
    goto emptyedit;
  } else {
    tmp___12 = unlink((char const   *)(g_tmpfpath));
    if (tmp___12) {
      tmp___9 = __errno_location();
      tmp___10 = strerror(*tmp___9);
      printwait((char const   *)tmp___10, (int *)((void *)0));
      goto emptyedit;
    }
  }
  if (! count) {
    ret = 1;
    goto emptyedit;
  }
  resetselind();
  selbufpos = (uint_t )count;
  count --;
  *(pselbuf + count) = (char )'\000';
  count --;
  while (count > 0L) {
    if ((int )*(pselbuf + count) == 10) {
      if ((int )*(pselbuf + (count + 1L)) == 47) {
        lines ++;
        *(pselbuf + count) = (char )'\000';
      }
    }
    count --;
  }
  lines ++;
  if (lines > nselected) {
    goto emptyedit;
  }
  nselected = lines;
  writesel((char const   *)pselbuf, (size_t const   )(selbufpos - 1U));
  return (1);
  emptyedit: 
  resetselind();
  clearselection();
  return (ret);
}
}
static _Bool selsafe(void) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  if (! selpath) {
    printmsg((char const   *)messages[23]);
    return ((_Bool)0);
  }
  tmp___2 = access((char const   *)selpath, 6);
  if (tmp___2 == -1) {
    tmp___1 = __errno_location();
    if (*tmp___1 == 2) {
      printmsg((char const   *)messages[3]);
    } else {
      tmp = __errno_location();
      tmp___0 = strerror(*tmp);
      printwait((char const   *)tmp___0, (int *)((void *)0));
    }
    return ((_Bool)0);
  }
  return ((_Bool)1);
}
}
static void export_file_list(void) 
{ 
  struct entry *pdent ;
  int fd ;
  int tmp ;
  int r ;
  ssize_t tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;

  {
  if (! ndents) {
    return;
  }
  pdent = pdents;
  tmp = create_tmp_file();
  fd = tmp;
  if (fd == -1) {
    return;
  }
  r = 0;
  while (r < ndents) {
    tmp___0 = write(fd, (void const   *)pdent->name, (size_t )(pdent->__annonCompField18.nlen - 1ULL));
    if ((ullong_t )tmp___0 != pdent->__annonCompField18.nlen - 1ULL) {
      break;
    }
    if (r != ndents - 1) {
      tmp___1 = write(fd, (void const   *)"\n", (size_t )1);
      if (tmp___1 != 1L) {
        break;
      }
    }
    pdent ++;
    r ++;
  }
  close(fd);
  spawn(editor, g_tmpfpath, (char *)((void *)0), (char *)((void *)0), (ushort_t )9);
  tmp___2 = get_input((char const   *)messages[39]);
  tmp___3 = xconfirm(tmp___2);
  if (tmp___3) {
    unlink((char const   *)(g_tmpfpath));
  }
  return;
}
}
static _Bool init_fcolors(void) 
{ 
  char *f_colors ;
  char *tmp ;
  uchar_t id ;
  uchar_t tmp___0 ;
  uchar_t tmp___1 ;

  {
  tmp = getenv((char const   *)env_cfg[5]);
  f_colors = tmp;
  if (! f_colors) {
    f_colors = gcolors;
  } else
  if (! *f_colors) {
    f_colors = gcolors;
  }
  id = (uchar_t )5;
  while (1) {
    if (*f_colors) {
      if (! ((int )id <= 16)) {
        break;
      }
    } else {
      break;
    }
    tmp___0 = xchartohex((uchar_t )*f_colors);
    fcolors[id] = (uint_t )((int )tmp___0 << 4);
    f_colors ++;
    if (*f_colors) {
      tmp___1 = xchartohex((uchar_t )*f_colors);
      fcolors[id] += (uint_t )tmp___1;
      if (fcolors[id]) {
        init_pair((short )id, (short )fcolors[id], (short)-1);
      }
    } else {
      return ((_Bool)0);
    }
    f_colors ++;
    id = (uchar_t )((int )id + 1);
  }
  return ((_Bool)1);
}
}
static _Bool initcurses(void *oldmask ) 
{ 
  SCREEN *tmp ;
  WINDOW *tmp___0 ;
  char *colors ;
  char *tmp___1 ;
  uint_t *pcode ;
  _Bool ext ;
  _Bool tmp___2 ;
  char *sep ;
  char *tmp___3 ;
  uchar_t i ;
  uchar_t tmp___4 ;
  uchar_t tmp___5 ;
  uint_t tmp___6 ;
  char *tmp___7 ;

  {
  if (g_state.picker) {
    tmp = newterm((char const   *)((void *)0), stderr, stdin);
    if (! tmp) {
      msg("newterm!");
      return ((_Bool)0);
    }
  } else {
    tmp___0 = initscr();
    if (! tmp___0) {
      msg("initscr!");
      return ((_Bool)0);
    }
  }
  cbreak();
  noecho();
  nonl();
  keypad(stdscr, (_Bool)1);
  curs_set(0);
  tmp___1 = getenv((char const   *)env_cfg[4]);
  colors = tmp___1;
  if (colors) {
    goto _L___0;
  } else {
    tmp___7 = getenv("NO_COLOR");
    if (! tmp___7) {
      _L___0: /* CIL Label */ 
      ext = (_Bool)0;
      start_color();
      use_default_colors();
      if (COLORS >= 256) {
        if (! g_state.oldcolor) {
          tmp___2 = init_fcolors();
          if (! tmp___2) {
            endwin();
            msg((char const   *)env_cfg[5]);
            return ((_Bool)0);
          }
        }
      } else {
        g_state.oldcolor = (uint_t )1;
      }
      if (colors) {
        if ((int )*colors == 35) {
          tmp___3 = strchr((char const   *)colors, ';');
          sep = tmp___3;
          if (! g_state.oldcolor) {
            if (COLORS >= 256) {
              colors ++;
              ext = (_Bool)1;
              if (sep) {
                *sep = (char )'\000';
              }
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
            colors = sep;
            if (colors) {
              colors ++;
            }
          }
        }
      }
      i = (uchar_t )0;
      while ((int )i < 4) {
        pcode = & g_ctx[i].color;
        if (colors) {
          if (*colors) {
            if (ext) {
              tmp___4 = xchartohex((uchar_t )*colors);
              *pcode = (uint_t )((int )tmp___4 << 4);
              colors ++;
              if (*colors) {
                tmp___5 = xchartohex((uchar_t )*colors);
                tmp___6 = *pcode + (uint_t )tmp___5;
                *pcode = tmp___6;
                fcolors[(int )i + 1] = tmp___6;
              } else {
                endwin();
                msg((char const   *)env_cfg[4]);
                return ((_Bool)0);
              }
            } else
            if ((int )*colors < 48) {
              *pcode = (uint_t )4;
            } else
            if ((int )*colors > 55) {
              *pcode = (uint_t )4;
            } else {
              *pcode = (uint_t )((int )*colors - 48);
            }
            colors ++;
          } else {
            *pcode = (uint_t )4;
          }
        } else {
          *pcode = (uint_t )4;
        }
        init_pair((short )((int )i + 1), (short )*pcode, (short)-1);
        i = (uchar_t )((int )i + 1);
      }
    }
  }
  wtimeout(stdscr, 1000);
  set_escdelay(25);
  return ((_Bool)1);
}
}
static char *parseargs(char *cmd___0 , char **argv , int *pindex ) 
{ 
  int count ;
  size_t len ;
  size_t tmp ;
  char *line ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  count = 0;
  tmp = xstrlen((char const   * __restrict  )cmd___0);
  len = tmp + 1UL;
  tmp___0 = malloc(len);
  line = (char *)tmp___0;
  if (! line) {
    return ((char *)((void *)0));
  }
  xstrsncpy((char * __restrict  )line, (char const   * __restrict  )cmd___0, len);
  tmp___1 = count;
  count ++;
  *(argv + tmp___1) = line;
  cmd___0 = line;
  while (*line) {
    if ((int )*line == 32) {
      goto _L;
    } else
    if ((int )*line == 9) {
      _L: /* CIL Label */ 
      tmp___2 = line;
      line ++;
      *tmp___2 = (char )'\000';
      if (! *line) {
        break;
      }
      tmp___3 = count;
      count ++;
      *(argv + tmp___3) = line;
      if (count == 10) {
        count = -1;
        break;
      }
    }
    line ++;
  }
  if (count == -1) {
    free((void *)cmd___0);
    cmd___0 = (char *)((void *)0);
  } else
  if (count > 6) {
    free((void *)cmd___0);
    cmd___0 = (char *)((void *)0);
  }
  *pindex = count;
  return (cmd___0);
}
}
static void enable_signals(void) 
{ 
  struct sigaction dfl_act ;

  {
  dfl_act.__sigaction_handler.sa_handler = (void (*)(int  ))0;
  dfl_act.sa_mask.__val[0] = 0UL;
  dfl_act.sa_mask.__val[1] = 0UL;
  dfl_act.sa_mask.__val[2] = 0UL;
  dfl_act.sa_mask.__val[3] = 0UL;
  dfl_act.sa_mask.__val[4] = 0UL;
  dfl_act.sa_mask.__val[5] = 0UL;
  dfl_act.sa_mask.__val[6] = 0UL;
  dfl_act.sa_mask.__val[7] = 0UL;
  dfl_act.sa_mask.__val[8] = 0UL;
  dfl_act.sa_mask.__val[9] = 0UL;
  dfl_act.sa_mask.__val[10] = 0UL;
  dfl_act.sa_mask.__val[11] = 0UL;
  dfl_act.sa_mask.__val[12] = 0UL;
  dfl_act.sa_mask.__val[13] = 0UL;
  dfl_act.sa_mask.__val[14] = 0UL;
  dfl_act.sa_mask.__val[15] = 0UL;
  dfl_act.sa_flags = 0;
  dfl_act.sa_restorer = (void (*)(void))0;
  sigaction(1, (struct sigaction  const  * __restrict  )(& dfl_act), (struct sigaction * __restrict  )((void *)0));
  sigaction(2, (struct sigaction  const  * __restrict  )(& dfl_act), (struct sigaction * __restrict  )((void *)0));
  sigaction(3, (struct sigaction  const  * __restrict  )(& dfl_act), (struct sigaction * __restrict  )((void *)0));
  sigaction(20, (struct sigaction  const  * __restrict  )(& dfl_act), (struct sigaction * __restrict  )((void *)0));
  sigaction(28, (struct sigaction  const  * __restrict  )(& dfl_act), (struct sigaction * __restrict  )((void *)0));
  return;
}
}
static pid_t xfork(uchar_t flag ) 
{ 
  pid_t p ;
  __pid_t tmp ;
  struct sigaction __constr_expr_0 ;
  struct sigaction __constr_expr_1 ;
  struct sigaction __constr_expr_2 ;

  {
  tmp = fork();
  p = tmp;
  if (p > 0) {
    __constr_expr_0.__sigaction_handler.sa_handler = (void (*)(int  ))1;
    __constr_expr_0.sa_mask.__val[0] = 0UL;
    __constr_expr_0.sa_mask.__val[1] = 0UL;
    __constr_expr_0.sa_mask.__val[2] = 0UL;
    __constr_expr_0.sa_mask.__val[3] = 0UL;
    __constr_expr_0.sa_mask.__val[4] = 0UL;
    __constr_expr_0.sa_mask.__val[5] = 0UL;
    __constr_expr_0.sa_mask.__val[6] = 0UL;
    __constr_expr_0.sa_mask.__val[7] = 0UL;
    __constr_expr_0.sa_mask.__val[8] = 0UL;
    __constr_expr_0.sa_mask.__val[9] = 0UL;
    __constr_expr_0.sa_mask.__val[10] = 0UL;
    __constr_expr_0.sa_mask.__val[11] = 0UL;
    __constr_expr_0.sa_mask.__val[12] = 0UL;
    __constr_expr_0.sa_mask.__val[13] = 0UL;
    __constr_expr_0.sa_mask.__val[14] = 0UL;
    __constr_expr_0.sa_mask.__val[15] = 0UL;
    __constr_expr_0.sa_flags = 0;
    __constr_expr_0.sa_restorer = (void (*)(void))0;
    sigaction(1, (struct sigaction  const  * __restrict  )(& __constr_expr_0), (struct sigaction * __restrict  )(& oldsighup));
    __constr_expr_1.__sigaction_handler.sa_handler = (void (*)(int  ))0;
    __constr_expr_1.sa_mask.__val[0] = 0UL;
    __constr_expr_1.sa_mask.__val[1] = 0UL;
    __constr_expr_1.sa_mask.__val[2] = 0UL;
    __constr_expr_1.sa_mask.__val[3] = 0UL;
    __constr_expr_1.sa_mask.__val[4] = 0UL;
    __constr_expr_1.sa_mask.__val[5] = 0UL;
    __constr_expr_1.sa_mask.__val[6] = 0UL;
    __constr_expr_1.sa_mask.__val[7] = 0UL;
    __constr_expr_1.sa_mask.__val[8] = 0UL;
    __constr_expr_1.sa_mask.__val[9] = 0UL;
    __constr_expr_1.sa_mask.__val[10] = 0UL;
    __constr_expr_1.sa_mask.__val[11] = 0UL;
    __constr_expr_1.sa_mask.__val[12] = 0UL;
    __constr_expr_1.sa_mask.__val[13] = 0UL;
    __constr_expr_1.sa_mask.__val[14] = 0UL;
    __constr_expr_1.sa_mask.__val[15] = 0UL;
    __constr_expr_1.sa_flags = 0;
    __constr_expr_1.sa_restorer = (void (*)(void))0;
    sigaction(20, (struct sigaction  const  * __restrict  )(& __constr_expr_1), (struct sigaction * __restrict  )(& oldsigtstp));
    __constr_expr_2.__sigaction_handler.sa_handler = (void (*)(int  ))1;
    __constr_expr_2.sa_mask.__val[0] = 0UL;
    __constr_expr_2.sa_mask.__val[1] = 0UL;
    __constr_expr_2.sa_mask.__val[2] = 0UL;
    __constr_expr_2.sa_mask.__val[3] = 0UL;
    __constr_expr_2.sa_mask.__val[4] = 0UL;
    __constr_expr_2.sa_mask.__val[5] = 0UL;
    __constr_expr_2.sa_mask.__val[6] = 0UL;
    __constr_expr_2.sa_mask.__val[7] = 0UL;
    __constr_expr_2.sa_mask.__val[8] = 0UL;
    __constr_expr_2.sa_mask.__val[9] = 0UL;
    __constr_expr_2.sa_mask.__val[10] = 0UL;
    __constr_expr_2.sa_mask.__val[11] = 0UL;
    __constr_expr_2.sa_mask.__val[12] = 0UL;
    __constr_expr_2.sa_mask.__val[13] = 0UL;
    __constr_expr_2.sa_mask.__val[14] = 0UL;
    __constr_expr_2.sa_mask.__val[15] = 0UL;
    __constr_expr_2.sa_flags = 0;
    __constr_expr_2.sa_restorer = (void (*)(void))0;
    sigaction(28, (struct sigaction  const  * __restrict  )(& __constr_expr_2), (struct sigaction * __restrict  )(& oldsigwinch));
  } else
  if (p == 0) {
    if ((int )flag & 2) {
      p = fork();
      if (p > 0) {
        _exit(0);
      } else
      if (p == 0) {
        enable_signals();
        setsid();
        return (p);
      }
      perror("fork");
      _exit(1);
    }
    enable_signals();
  }
  if ((int )flag & 2) {
    waitpid(p, (int *)((void *)0), 0);
  }
  if (p == -1) {
    perror("fork");
  }
  return (p);
}
}
static int join(pid_t p , uchar_t flag ) 
{ 
  int status ;
  __pid_t tmp ;

  {
  status = 65535;
  if (! ((int )flag & 2)) {
    while (1) {
      tmp = waitpid(p, & status, 0);
      if (! (tmp == -1)) {
        break;
      }
    }
    if ((status & 127) == 0) {
      status = (status & 65280) >> 8;
    }
  }
  sigaction(1, (struct sigaction  const  * __restrict  )(& oldsighup), (struct sigaction * __restrict  )((void *)0));
  sigaction(20, (struct sigaction  const  * __restrict  )(& oldsigtstp), (struct sigaction * __restrict  )((void *)0));
  sigaction(28, (struct sigaction  const  * __restrict  )(& oldsigwinch), (struct sigaction * __restrict  )((void *)0));
  return (status);
}
}
static int spawn(char *file , char *arg1 , char *arg2 , char *arg3 , ushort_t flag ) 
{ 
  pid_t pid ;
  int status ;
  int retstatus ;
  char *argv[10] ;
  unsigned int tmp ;
  char *cmd___0 ;
  int tmp___0 ;
  int fd ;
  int tmp___1 ;
  int fd___0 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  ssize_t tmp___6 ;
  ssize_t tmp___7 ;

  {
  status = 0;
  retstatus = 65535;
  argv[0] = (char *)0;
  tmp = 1U;
  while (! (tmp >= 10U)) {
    argv[tmp] = (char *)0;
    tmp ++;
  }
  cmd___0 = (char *)((void *)0);
  if (! file) {
    return (retstatus);
  } else
  if (! *file) {
    return (retstatus);
  }
  if (! arg1) {
    if (arg2) {
      arg1 = arg2;
      if (arg3) {
        arg2 = arg3;
        arg3 = (char *)((void *)0);
      } else {
        arg2 = (char *)((void *)0);
      }
    }
  }
  if ((int )flag & 1) {
    cmd___0 = parseargs(file, argv, & status);
    if (! cmd___0) {
      return (-1);
    }
  } else {
    tmp___0 = status;
    status ++;
    argv[tmp___0] = file;
  }
  argv[status] = arg1;
  status ++;
  argv[status] = arg2;
  status ++;
  argv[status] = arg3;
  if ((int )flag & 8) {
    endwin();
  }
  pid = xfork((uchar_t )flag);
  if (pid == 0) {
    if ((int )flag & 4) {
      tmp___1 = open("/dev/null", 1, 128);
      fd = tmp___1;
      if ((int )flag & 64) {
        dup2(fd, 0);
      }
      dup2(fd, 1);
      dup2(fd, 2);
      close(fd);
    } else
    if ((int )flag & 256) {
      tmp___4 = isatty(1);
      if (! tmp___4) {
        tmp___2 = ctermid((char *)((void *)0));
        tmp___3 = open((char const   *)tmp___2, 1, 128);
        fd___0 = tmp___3;
        dup2(fd___0, 1);
        close(fd___0);
      }
    }
    execvp((char const   *)argv[0], (char * const  *)(argv));
    _exit(0);
  } else {
    retstatus = join(pid, (uchar_t )flag);
    if ((int )flag & 16) {
      goto _L;
    } else
    if ((int )flag & 32) {
      if (retstatus) {
        _L: /* CIL Label */ 
        tmp___5 = xstrlen((char const   * __restrict  )messages[22]);
        tmp___6 = write(1, (void const   *)messages[22], tmp___5);
        status = (int )tmp___6;
        while (1) {
          tmp___7 = read(0, (void *)(& status), (size_t )1);
          if (tmp___7 > 0L) {
            if (! (status != 10)) {
              break;
            }
          } else {
            break;
          }
        }
      }
    }
    if ((int )flag & 8) {
      wrefresh(stdscr);
    }
    free((void *)cmd___0);
  }
  return (retstatus);
}
}
static char *xgetenv(char const   * const  name , char *fallback ) 
{ 
  char *value ;
  char *tmp ;
  char *tmp___0 ;

  {
  tmp = getenv((char const   *)name);
  value = tmp;
  if (value) {
    if (*(value + 0)) {
      tmp___0 = value;
    } else {
      tmp___0 = fallback;
    }
  } else {
    tmp___0 = fallback;
  }
  return (tmp___0);
}
}
__inline static uint_t xgetenv_val(char const   *name ) 
{ 
  char *str ;
  char *tmp ;
  int tmp___0 ;

  {
  tmp = getenv(name);
  str = tmp;
  if (str) {
    if (*(str + 0)) {
      tmp___0 = atoi((char const   *)str);
      return ((uint_t )tmp___0);
    }
  }
  return ((uint_t )0);
}
}
static _Bool xdiraccess(char const   *path ) 
{ 
  DIR *dirp ;
  DIR *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
  tmp = opendir(path);
  dirp = tmp;
  if (! dirp) {
    tmp___0 = __errno_location();
    tmp___1 = strerror(*tmp___0);
    printwait((char const   *)tmp___1, (int *)((void *)0));
    return ((_Bool)0);
  }
  closedir(dirp);
  return ((_Bool)1);
}
}
static _Bool plugscript(char const   *plugin , uchar_t flags ) 
{ 
  int tmp ;

  {
  mkpath((char const   *)plgpath, plugin, g_buf);
  tmp = access((char const   *)(g_buf), 1);
  if (! tmp) {
    spawn(g_buf, (char *)((void *)0), (char *)((void *)0), (char *)((void *)0), (ushort_t )flags);
    return ((_Bool)1);
  }
  return ((_Bool)0);
}
}
static void opstr(char *buf , char *op ) 
{ 


  {
  snprintf((char * __restrict  )buf, (size_t )(4096 + (256 << 1)), (char const   * __restrict  )"xargs -0 sh -c \'%s \"$0\" \"$@\" . < /dev/tty\' < %s",
           op, selpath);
  return;
}
}
static _Bool rmmulstr(char *buf ) 
{ 
  char r ;
  char tmp ;
  int tmp___0 ;

  {
  tmp = confirm_force((_Bool)1);
  r = tmp;
  if (! r) {
    return ((_Bool)0);
  }
  if (! g_state.trash) {
    snprintf((char * __restrict  )buf, (size_t )(4096 + (256 << 1)), (char const   * __restrict  )"xargs -0 sh -c \'rm -%cr \"$0\" \"$@\" < /dev/tty\' < %s",
             (int )r, selpath);
  } else {
    if (g_state.trash == 1U) {
      tmp___0 = 18;
    } else {
      tmp___0 = 19;
    }
    snprintf((char * __restrict  )buf, (size_t )(4096 + (256 << 1)), (char const   * __restrict  )"xargs -0 %s < %s",
             utils[tmp___0], selpath);
  }
  return ((_Bool)1);
}
}
static _Bool xrm(char * const  fpath ) 
{ 
  char r ;
  char tmp ;
  char rm_opts[4] ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = confirm_force((_Bool)0);
  r = tmp;
  if (! r) {
    return ((_Bool)0);
  }
  if (! g_state.trash) {
    rm_opts[0] = (char )'-';
    rm_opts[1] = (char )'i';
    rm_opts[2] = (char )'r';
    rm_opts[3] = (char )'\000';
    rm_opts[1] = r;
    spawn((char *)"rm", rm_opts, (char *)fpath, (char *)((void *)0), (ushort_t )40);
  } else {
    if (g_state.trash == 1U) {
      tmp___0 = 18;
    } else {
      tmp___0 = 19;
    }
    spawn((char *)utils[tmp___0], (char *)fpath, (char *)((void *)0), (char *)((void *)0),
          (ushort_t )9);
  }
  tmp___1 = access((char const   *)fpath, 0);
  return ((_Bool )(tmp___1 == -1));
}
}
static void xrmfromsel(char *path , char *fpath ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  if ((pdents + cur)->__annonCompField18.flags & 1ULL) {
    tmp___0 = scanselforpath((char const   *)fpath, (_Bool)0);
    if (tmp___0) {
      clearselection();
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if ((pdents + cur)->__annonCompField18.flags & 16ULL) {
    nselected --;
    tmp = mkpath((char const   *)path, (char const   *)(pdents + cur)->name, g_sel);
    rmfromselbuf(tmp);
  }
  return;
}
}
static uint_t lines_in_file(int fd , char *buf , size_t buflen ) 
{ 
  ssize_t len ;
  uint_t count ;
  uint_t tmp ;

  {
  count = (uint_t )0;
  while (1) {
    len = read(fd, (void *)buf, buflen);
    if (! (len > 0L)) {
      break;
    }
    while (len) {
      len --;
      count += (uint_t )((int )*(buf + len) == 10);
    }
  }
  if (len < 0L) {
    tmp = (uint_t )0;
  } else {
    tmp = count;
  }
  return (tmp);
}
}
static _Bool cpmv_rename(int choice , char const   *path ) 
{ 
  int fd ;
  uint_t count ;
  uint_t lines ;
  _Bool ret ;
  char *cmd___0 ;
  char *tmp ;
  char buf[(sizeof(patterns[1]) + sizeof(cp)) + (unsigned long )(4096 << 1)] ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  count = (uint_t )0;
  lines = (uint_t )0;
  ret = (_Bool)0;
  if (choice == 99) {
    tmp = cp;
  } else {
    tmp = mv;
  }
  cmd___0 = tmp;
  fd = create_tmp_file();
  if (fd == -1) {
    return (ret);
  }
  if (! selbufpos) {
    snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"tr \'\\0\' \'\\n\' < %s > %s",
             selpath, g_tmpfpath);
    spawn((char *)utils[7], buf, (char *)((void *)0), (char *)((void *)0), (ushort_t )9);
    count = lines_in_file(fd, buf, sizeof(buf));
    if (! count) {
      goto finish;
    }
  } else {
    seltofile(fd, & count);
  }
  close(fd);
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )patterns[0],
           g_tmpfpath);
  spawn((char *)utils[7], buf, (char *)((void *)0), (char *)((void *)0), (ushort_t )9);
  if (cfg.waitedit) {
    tmp___0 = enveditor;
  } else {
    tmp___0 = editor;
  }
  spawn(tmp___0, g_tmpfpath, (char *)((void *)0), (char *)((void *)0), (ushort_t )9);
  fd = open((char const   *)(g_tmpfpath), 0);
  if (fd == -1) {
    goto finish;
  }
  lines = lines_in_file(fd, buf, sizeof(buf));
  if (! lines) {
    goto finish;
  } else
  if (2U * count != lines) {
    goto finish;
  }
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )patterns[1],
           path, g_tmpfpath, cmd___0);
  tmp___1 = spawn((char *)utils[7], buf, (char *)((void *)0), (char *)((void *)0),
                  (ushort_t )41);
  if (! tmp___1) {
    ret = (_Bool)1;
  }
  finish: 
  if (fd >= 0) {
    close(fd);
  }
  return (ret);
}
}
static _Bool cpmvrm_selection(enum action sel , char *path ) 
{ 
  int r ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;

  {
  tmp = isselfileempty();
  if (tmp) {
    if (nselected) {
      clearselection();
    }
    printmsg((char const   *)messages[3]);
    return ((_Bool)0);
  }
  tmp___0 = selsafe();
  if (! tmp___0) {
    return ((_Bool)0);
  }
  switch ((unsigned int )sel) {
  case 42U: 
  opstr(g_buf, cp);
  break;
  case 43U: 
  opstr(g_buf, mv);
  break;
  case 44U: 
  r = get_input((char const   *)messages[7]);
  if (r != 99) {
    if (r != 109) {
      printmsg((char const   *)messages[40]);
      return ((_Bool)0);
    }
  }
  tmp___1 = cpmv_rename(r, (char const   *)path);
  if (! tmp___1) {
    printmsg((char const   *)messages[5]);
    return ((_Bool)0);
  }
  break;
  default: 
  tmp___2 = rmmulstr(g_buf);
  if (! tmp___2) {
    printmsg((char const   *)messages[4]);
    return ((_Bool)0);
  }
  }
  if ((unsigned int )sel != 44U) {
    tmp___3 = spawn((char *)utils[7], g_buf, (char *)((void *)0), (char *)((void *)0),
                    (ushort_t )41);
    if (tmp___3) {
      printmsg((char const   *)messages[5]);
      return ((_Bool)0);
    }
  }
  clearselection();
  return ((_Bool)1);
}
}
static void get_archive_cmd(char *cmd___0 , char const   *archive ) 
{ 
  uchar_t i ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
  i = (uchar_t )3;
  if (! g_state.usebsdtar) {
    tmp___1 = getutil((char *)utils[1]);
    if (tmp___1) {
      i = (uchar_t )0;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    tmp___0 = getutil((char *)utils[2]);
    if (tmp___0) {
      i = (uchar_t )1;
    } else {
      tmp = is_suffix((char const   * __restrict  )archive, (char const   * __restrict  )".zip");
      if (tmp) {
        i = (uchar_t )2;
      }
    }
  }
  xstrsncpy((char * __restrict  )cmd___0, (char const   * __restrict  )archive_cmd[i],
            (size_t )16);
  return;
}
}
static void archive_selection(char const   *cmd___0 , char const   *archive , char const   *curpath ) 
{ 
  char *buf ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;

  {
  tmp = xstrlen((char const   * __restrict  )patterns[4]);
  tmp___0 = xstrlen((char const   * __restrict  )cmd___0);
  tmp___1 = xstrlen((char const   * __restrict  )archive);
  tmp___2 = xstrlen((char const   * __restrict  )curpath);
  tmp___3 = xstrlen((char const   * __restrict  )selpath);
  tmp___4 = malloc(((((tmp + tmp___0) + tmp___1) + tmp___2) + tmp___3) * sizeof(char ));
  buf = (char *)tmp___4;
  if (! buf) {
    tmp___5 = __errno_location();
    tmp___6 = strerror(*tmp___5);
    printwait((char const   *)tmp___6, (int *)((void *)0));
    return;
  }
  snprintf((char * __restrict  )buf, (size_t )(4096 + (256 << 1)), (char const   * __restrict  )patterns[4],
           curpath, selpath, cmd___0, archive);
  spawn((char *)utils[7], buf, (char *)((void *)0), (char *)((void *)0), (ushort_t )25);
  free((void *)buf);
  return;
}
}
static void write_lastdir(char const   *curpath , char const   *outfile ) 
{ 
  size_t tmp ;
  int fd ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  if (! outfile) {
    tmp = xstrlen((char const   * __restrict  )cfgpath);
    xstrsncpy((char * __restrict  )(cfgpath + tmp), (char const   * __restrict  )"/.lastd",
              (size_t )8);
  } else {
    convert_tilde(outfile, g_buf);
  }
  if (outfile) {
    if ((int const   )*(outfile + 0) == 126) {
      tmp___0 = (char const   *)(g_buf);
    } else {
      tmp___0 = outfile;
    }
    tmp___1 = tmp___0;
  } else {
    tmp___1 = (char const   *)cfgpath;
  }
  tmp___2 = open(tmp___1, 577, 438);
  fd = tmp___2;
  if (fd != -1) {
    dprintf(fd, (char const   * __restrict  )"cd \"%s\"", curpath);
    close(fd);
  }
  return;
}
}
static int xstricmp(char const   * const  s1 , char const   * const  s2 ) 
{ 
  char *p1 ;
  char *p2 ;
  long long v1 ;
  long long tmp ;
  long long v2 ;
  long long tmp___0 ;
  int tmp___1 ;

  {
  tmp = strtoll((char const   * __restrict  )s1, (char ** __restrict  )(& p1), 10);
  v1 = tmp;
  tmp___0 = strtoll((char const   * __restrict  )s2, (char ** __restrict  )(& p2),
                    10);
  v2 = tmp___0;
  if ((unsigned long )s1 != (unsigned long )p1) {
    goto _L;
  } else
  if ((unsigned long )s2 != (unsigned long )p2) {
    _L: /* CIL Label */ 
    if ((unsigned long )s1 != (unsigned long )p1) {
      if ((unsigned long )s2 != (unsigned long )p2) {
        if (v2 > v1) {
          return (-1);
        }
        if (v1 > v2) {
          return (1);
        }
      }
    }
    if ((unsigned long )s1 == (unsigned long )p1) {
      return (1);
    }
    if ((unsigned long )s2 == (unsigned long )p2) {
      return (-1);
    }
  }
  tmp___1 = strcasecmp((char const   *)s1, (char const   *)s2);
  return (tmp___1);
}
}
static int xstrverscasecmp(char const   * const  s1 , char const   * const  s2 ) ;
static uint8_t const   next_state[12]  = 
  {      (uint8_t const   )0,      (uint8_t const   )3,      (uint8_t const   )9,      (uint8_t const   )0, 
        (uint8_t const   )3,      (uint8_t const   )3,      (uint8_t const   )0,      (uint8_t const   )6, 
        (uint8_t const   )6,      (uint8_t const   )0,      (uint8_t const   )6,      (uint8_t const   )9};
static int8_t const   result_type[36]  __attribute__((__aligned__))  = 
  {      (int8_t const   )2,      (int8_t const   )2,      (int8_t const   )2,      (int8_t const   )2, 
        (int8_t const   )3,      (int8_t const   )2,      (int8_t const   )2,      (int8_t const   )2, 
        (int8_t const   )2,      (int8_t const   )2,      (int8_t const   )-1,      (int8_t const   )-1, 
        (int8_t const   )1,      (int8_t const   )3,      (int8_t const   )3,      (int8_t const   )1, 
        (int8_t const   )3,      (int8_t const   )3,      (int8_t const   )2,      (int8_t const   )2, 
        (int8_t const   )2,      (int8_t const   )2,      (int8_t const   )2,      (int8_t const   )2, 
        (int8_t const   )2,      (int8_t const   )2,      (int8_t const   )2,      (int8_t const   )2, 
        (int8_t const   )1,      (int8_t const   )1,      (int8_t const   )-1,      (int8_t const   )2, 
        (int8_t const   )2,      (int8_t const   )-1,      (int8_t const   )2,      (int8_t const   )2};
static int xstrverscasecmp(char const   * const  s1 , char const   * const  s2 ) 
{ 
  uchar_t const   *p1 ;
  uchar_t const   *p2 ;
  int state ;
  int diff ;
  uchar_t c1 ;
  uchar_t c2 ;
  uchar_t const   *tmp ;
  uchar_t const   *tmp___0 ;
  int tmp___1 ;

  {
  p1 = (uchar_t const   *)s1;
  p2 = (uchar_t const   *)s2;
  if ((unsigned long )p1 == (unsigned long )p2) {
    return (0);
  }
  if ((int const   )*p1 >= 97) {
    if ((int const   )*p1 <= 122) {
      c1 = (uchar_t )(((int const   )*p1 - 97) + 65);
    } else {
      c1 = (uchar_t )*p1;
    }
  } else {
    c1 = (uchar_t )*p1;
  }
  p1 ++;
  if ((int const   )*p2 >= 97) {
    if ((int const   )*p2 <= 122) {
      c2 = (uchar_t )(((int const   )*p2 - 97) + 65);
    } else {
      c2 = (uchar_t )*p2;
    }
  } else {
    c2 = (uchar_t )*p2;
  }
  p2 ++;
  state = ((int )c1 == 48) + (((unsigned int )c1 - 48U <= 9U) != 0);
  while (1) {
    diff = (int )c1 - (int )c2;
    if (! (diff == 0)) {
      break;
    }
    if ((int )c1 == 0) {
      return (diff);
    }
    state = (int )next_state[state];
    if ((int const   )*p1 >= 97) {
      if ((int const   )*p1 <= 122) {
        c1 = (uchar_t )(((int const   )*p1 - 97) + 65);
      } else {
        c1 = (uchar_t )*p1;
      }
    } else {
      c1 = (uchar_t )*p1;
    }
    p1 ++;
    if ((int const   )*p2 >= 97) {
      if ((int const   )*p2 <= 122) {
        c2 = (uchar_t )(((int const   )*p2 - 97) + 65);
      } else {
        c2 = (uchar_t )*p2;
      }
    } else {
      c2 = (uchar_t )*p2;
    }
    p2 ++;
    state += ((int )c1 == 48) + (((unsigned int )c1 - 48U <= 9U) != 0);
  }
  state = (int )result_type[state * 3 + (((int )c2 == 48) + (((unsigned int )c2 - 48U <= 9U) != 0))];
  switch (state) {
  case 2: 
  return (diff);
  case 3: 
  while (1) {
    tmp___0 = p1;
    p1 ++;
    if (! ((unsigned int )*tmp___0 - 48U <= 9U)) {
      break;
    }
    tmp = p2;
    p2 ++;
    if (! ((unsigned int )*tmp - 48U <= 9U)) {
      return (1);
    }
  }
  if ((unsigned int )*p2 - 48U <= 9U) {
    tmp___1 = -1;
  } else {
    tmp___1 = diff;
  }
  return (tmp___1);
  default: 
  return (state);
  }
}
}
static int (*namecmpfn)(char const   * const  s1 , char const   * const  s2 )  =    & xstricmp;
static char *(*fnstrstr)(char const   *haystack ,
                         char const   *needle )  =    (char *(*)(char const   *haystack , char const   *needle ))(& strcasestr);
static int regflags  =    ((1 << 3) | 1) | (1 << 1);
static int setfilter(regex_t *regex , char const   *filter___0 ) 
{ 
  int tmp ;

  {
  tmp = regcomp((regex_t * __restrict  )regex, (char const   * __restrict  )filter___0,
                regflags);
  return (tmp);
}
}
static int visible_re(fltrexp_t const   *fltrexp , char const   *fname ) 
{ 
  int tmp ;

  {
  tmp = regexec((regex_t const   * __restrict  )fltrexp->regex, (char const   * __restrict  )fname,
                (size_t )0, (regmatch_t * __restrict  )((void *)0), 0);
  return (tmp == 0);
}
}
static int visible_str(fltrexp_t const   *fltrexp , char const   *fname ) 
{ 
  char *tmp ;

  {
  tmp = (*fnstrstr)(fname, (char const   *)fltrexp->str);
  return ((unsigned long )tmp != (unsigned long )((void *)0));
}
}
static int (*filterfn)(fltrexp_t const   *fltr , char const   *fname )  =    & visible_str;
static void clearfilter(void) 
{ 
  char *fltr ;

  {
  fltr = g_ctx[cfg.curctx].c_fltr;
  if (*(fltr + 1)) {
    *(fltr + 47) = *(fltr + 1);
    *(fltr + 1) = (char )'\000';
  }
  return;
}
}
static int entrycmp(void const   *va , void const   *vb ) 
{ 
  struct entry  const  *pa ;
  struct entry  const  *pb ;
  char *extna ;
  char *tmp ;
  char *extnb ;
  char *tmp___0 ;
  int ret ;
  int tmp___1 ;
  int tmp___2 ;

  {
  pa = (struct entry  const  *)((pEntry )va);
  pb = (struct entry  const  *)((pEntry )vb);
  if ((pb->__annonCompField18.flags & 1ULL) != (pa->__annonCompField18.flags & 1ULL)) {
    if (pb->__annonCompField18.flags & 1ULL) {
      return (1);
    }
    return (-1);
  }
  if (cfg.timeorder) {
    if (pb->sec > pa->sec) {
      return (1);
    }
    if (pb->sec < pa->sec) {
      return (-1);
    }
    if (pb->nsec > pa->nsec) {
      return (1);
    }
    if (pb->nsec < pa->nsec) {
      return (-1);
    }
  } else
  if (cfg.sizeorder) {
    if (pb->size > pa->size) {
      return (1);
    }
    if (pb->size < pa->size) {
      return (-1);
    }
  } else
  if (cfg.blkorder) {
    if (pb->__annonCompField18.blocks > pa->__annonCompField18.blocks) {
      return (1);
    }
    if (pb->__annonCompField18.blocks < pa->__annonCompField18.blocks) {
      return (-1);
    }
  } else
  if (cfg.extnorder) {
    if (! (pb->__annonCompField18.flags & 1ULL)) {
      tmp = xextension((char const   *)pa->name, (size_t )(pa->__annonCompField18.nlen - 1ULL));
      extna = tmp;
      tmp___0 = xextension((char const   *)pb->name, (size_t )(pb->__annonCompField18.nlen - 1ULL));
      extnb = tmp___0;
      if (extna) {
        goto _L;
      } else
      if (extnb) {
        _L: /* CIL Label */ 
        if (! extna) {
          return (-1);
        }
        if (! extnb) {
          return (1);
        }
        tmp___1 = strcasecmp((char const   *)extna, (char const   *)extnb);
        ret = tmp___1;
        if (ret) {
          return (ret);
        }
      }
    }
  }
  tmp___2 = (*namecmpfn)((char const   * const  )pa->name, (char const   * const  )pb->name);
  return (tmp___2);
}
}
static int reventrycmp(void const   *va , void const   *vb ) 
{ 
  int tmp ;

  {
  if ((((pEntry )vb)->__annonCompField18.flags & 1ULL) != (((pEntry )va)->__annonCompField18.flags & 1ULL)) {
    if (((pEntry )vb)->__annonCompField18.flags & 1ULL) {
      return (1);
    }
    return (-1);
  }
  tmp = entrycmp(va, vb);
  return (- tmp);
}
}
static int (*entrycmpfn)(void const   *va , void const   *vb )  =    & entrycmp;
static int handle_alt_key(wint_t *wch ) 
{ 
  int r ;
  int tmp ;

  {
  wtimeout(stdscr, 0);
  tmp = wget_wch(stdscr, wch);
  r = tmp;
  if (r == -1) {
    *wch = (wint_t )27;
  }
  wtimeout(stdscr, -1);
  return (r);
}
}
__inline static int handle_event(void) 
{ 
  _Bool tmp ;

  {
  if (nselected) {
    tmp = isselfileempty();
    if (tmp) {
      clearselection();
    }
  }
  return (12);
}
}
static int nextsel(int presel ) 
{ 
  wint_t c ;
  int i ;
  _Bool escaped ;
  struct inotify_event *event ;
  char inotify_buf[sizeof(struct inotify_event ) * 32UL] ;
  unsigned int tmp ;
  ssize_t tmp___0 ;
  char *ptr ;
  int tmp___1 ;

  {
  c = (wint_t )presel;
  i = 0;
  escaped = (_Bool)0;
  if (c == 0U) {
    goto try_quit;
  } else
  if (c == 36U) {
    try_quit: 
    i = wget_wch(stdscr, & c);
    if (c == 410U) {
      handle_key_resize();
    }
    if (c == 27U) {
      wtimeout(stdscr, 0);
      i = wget_wch(stdscr, & c);
      if (i != -1) {
        if (c == 27U) {
          c = (wint_t )12;
        } else {
          unget_wch((wchar_t const   )c);
          c = (wint_t )';';
        }
        wtimeout(stdscr, 1000);
      } else
      if (escaped) {
        wtimeout(stdscr, 1000);
        c = (wint_t )17;
      } else {
        escaped = (_Bool)1;
        wtimeout(stdscr, 1000);
        goto try_quit;
      }
    }
    if (i == -1) {
      if (presel == 36) {
        if (cfg.filtermode) {
          c = (wint_t )'/';
        } else
        if (g_ctx[cfg.curctx].c_fltr[1]) {
          c = (wint_t )'/';
        } else {
          c = (wint_t )12;
        }
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (c == 47U) {
      clearfilter();
    } else
    if (c == 12U) {
      clearfilter();
    }
  }
  if (i == -1) {
    idle = (ushort_t )((int )idle + 1);
    if (! cfg.blkorder) {
      if (inotify_wd >= 0) {
        if ((int )idle & 1) {
          inotify_buf[0] = (char)0;
          tmp = 1U;
          while (! (tmp >= 512U)) {
            inotify_buf[tmp] = (char)0;
            tmp ++;
          }
          tmp___0 = read(inotify_fd, (void *)(inotify_buf), sizeof(struct inotify_event ) * 32UL);
          i = (int )tmp___0;
          if (i > 0) {
            ptr = inotify_buf;
            while ((unsigned long )(ptr + ((struct inotify_event *)ptr)->len) < (unsigned long )(inotify_buf + i)) {
              event = (struct inotify_event *)ptr;
              if (! event->wd) {
                break;
              }
              if (event->mask & INOTIFY_MASK) {
                tmp___1 = handle_event();
                c = (wint_t )tmp___1;
                break;
              }
              ptr += sizeof(struct inotify_event ) + (unsigned long )event->len;
            }
          }
        }
      }
    }
  } else {
    idle = (ushort_t )0;
  }
  i = 0;
  while (i < (int )(sizeof(bindings) / sizeof(bindings[0]))) {
    if (c == bindings[i].sym) {
      return ((int )bindings[i].act);
    }
    i ++;
  }
  return (0);
}
}
static int getorderstr(char *sort ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  i = 0;
  if (cfg.showhidden) {
    tmp = i;
    i ++;
    *(sort + tmp) = (char )'H';
  }
  if (cfg.timeorder) {
    tmp___0 = i;
    i ++;
    if (cfg.timetype == 2U) {
      *(sort + tmp___0) = (char )'M';
    } else {
      if (cfg.timetype == 0U) {
        tmp___1 = 'A';
      } else {
        tmp___1 = 'C';
      }
      *(sort + tmp___0) = (char )tmp___1;
    }
  } else
  if (cfg.sizeorder) {
    tmp___2 = i;
    i ++;
    *(sort + tmp___2) = (char )'S';
  } else
  if (cfg.extnorder) {
    tmp___3 = i;
    i ++;
    *(sort + tmp___3) = (char )'E';
  }
  if ((unsigned long )entrycmpfn == (unsigned long )(& reventrycmp)) {
    tmp___4 = i;
    i ++;
    *(sort + tmp___4) = (char )'R';
  }
  if ((unsigned long )namecmpfn == (unsigned long )(& xstrverscasecmp)) {
    tmp___5 = i;
    i ++;
    *(sort + tmp___5) = (char )'V';
  }
  if (i) {
    *(sort + i) = (char )' ';
  }
  return (i);
}
}
static void showfilterinfo(void) 
{ 
  int i ;
  char info[48] ;
  unsigned int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  _Bool tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;

  {
  i = 0;
  info[0] = (char )'\000';
  info[1] = (char )'\000';
  info[2] = (char )'\000';
  info[3] = (char )'\000';
  info[4] = (char )'\000';
  info[5] = (char )'\000';
  tmp = 6U;
  while (! (tmp >= 48U)) {
    info[tmp] = (char)0;
    tmp ++;
  }
  i = getorderstr(info);
  if (cfg.fileinfo) {
    if (ndents) {
      tmp___3 = get_output((char *)"file", (char *)"-b", (pdents + cur)->name, -1,
                           (_Bool)0, (_Bool)0);
      if (tmp___3) {
        tmp___0 = wmove(stdscr, (int )xlines - 2, 2);
        if (! (tmp___0 == -1)) {
          waddnstr(stdscr, (char const   *)(g_buf), -1);
        }
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if ((unsigned long )fnstrstr == (unsigned long )(& strcasestr)) {
      tmp___1 = "ic";
    } else {
      tmp___1 = "noic";
    }
    if (cfg.regex) {
      tmp___2 = "reg";
    } else {
      tmp___2 = "str";
    }
    snprintf((char * __restrict  )(info + i), (size_t )((48 - i) - 1), (char const   * __restrict  )"  %s [/], %4s [:]",
             tmp___2, tmp___1);
  }
  tmp___4 = xstrlen((char const   * __restrict  )(info));
  tmp___5 = wmove(stdscr, (int )xlines - 2, (int )((size_t )xcols - tmp___4));
  if (! (tmp___5 == -1)) {
    waddnstr(stdscr, (char const   *)(info), -1);
  }
  return;
}
}
static void showfilter(char *str ) 
{ 


  {
  wattr_on(stdscr, ((cfg.curctx + 1U) << 8) & (((1U << 8) - 1U) << 8), (void *)0);
  showfilterinfo();
  printmsg((char const   *)str);
  return;
}
}
__inline static void swap_ent(int id1 , int id2 ) 
{ 
  struct entry _dent ;
  struct entry *pdent1 ;
  struct entry *pdent2 ;

  {
  pdent1 = pdents + id1;
  pdent2 = pdents + id2;
  _dent = *pdent1;
  *pdent1 = *pdent2;
  *pdent2 = _dent;
  return;
}
}
static int fill(char const   *fltr , regex_t *re ) 
{ 
  fltrexp_t fltrexp ;
  int count ;
  int tmp ;

  {
  fltrexp.regex = (regex_t const   *)re;
  fltrexp.str = fltr;
  count = 0;
  while (count < ndents) {
    tmp = (*filterfn)((fltrexp_t const   *)(& fltrexp), (char const   *)(pdents + count)->name);
    if (tmp == 0) {
      ndents --;
      if (count != ndents) {
        swap_ent(count, ndents);
        count --;
      }
      goto __Cont;
    }
    __Cont: /* CIL Label */ 
    count ++;
  }
  return (ndents);
}
}
static int matches(char const   *fltr ) 
{ 
  regex_t re ;
  int tmp ;

  {
  if (cfg.regex) {
    tmp = setfilter(& re, fltr);
    if (tmp) {
      return (-1);
    }
  }
  ndents = fill(fltr, & re);
  if (cfg.regex) {
    regfree(& re);
  }
  qsort((void *)pdents, (size_t )ndents, sizeof(*pdents), entrycmpfn);
  return (ndents);
}
}
static int dentfind(char const   *fname , int n ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  i = 0;
  while (i < n) {
    if ((int const   )*fname != (int const   )*((pdents + i)->name)) {
      tmp___0 = -1;
    } else {
      tmp = strcmp(fname, (char const   *)(pdents + i)->name);
      tmp___0 = tmp;
    }
    if (tmp___0 == 0) {
      return (i);
    }
    i ++;
  }
  return (0);
}
}
static int filterentries(char *path , char *lastname ) 
{ 
  wchar_t *wln ;
  void *tmp ;
  char *ln ;
  wint_t ch[1] ;
  int r ;
  int total ;
  int len ;
  char *pln ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  wchar_t tmp___3 ;
  wchar_t tmp___4 ;
  wchar_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;

  {
  tmp = __builtin_alloca(sizeof(wchar_t ) * 48UL);
  wln = (wchar_t *)tmp;
  ln = g_ctx[cfg.curctx].c_fltr;
  total = ndents;
  pln = g_ctx[cfg.curctx].c_fltr + 1;
  if (ndents) {
    if ((int )*(ln + 0) == 47) {
      goto _L___1;
    } else
    if ((int )*(ln + 0) == 92) {
      _L___1: /* CIL Label */ 
      if (*pln) {
        tmp___1 = matches((char const   *)pln);
        if (tmp___1 != -1) {
          tmp___0 = dentfind((char const   *)lastname, ndents);
          move_cursor(tmp___0, 0);
          redraw(path);
        }
        if (! cfg.filtermode) {
          statusbar(path);
          return (0);
        }
        tmp___2 = mbstowcs((wchar_t * __restrict  )wln, (char const   * __restrict  )ln,
                           (size_t )48);
        len = (int )tmp___2;
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (cfg.regex) {
      tmp___3 = '\\';
    } else {
      tmp___3 = '/';
    }
    *(wln + 0) = tmp___3;
    *(ln + 0) = (char )tmp___3;
    tmp___4 = '\000';
    *(wln + 1) = tmp___4;
    *(ln + 1) = (char )tmp___4;
    len = 1;
  }
  wtimeout(stdscr, -1);
  curs_set(1);
  showfilter(ln);
  while (1) {
    r = wget_wch(stdscr, ch);
    if (! (r != -1)) {
      break;
    }
    switch (ch[0]) {
    case 410U: 
    case 0U: 
    clearoldprompt();
    redraw(path);
    showfilter(ln);
    continue;
    case 127U: 
    case 8U: 
    case 263U: 
    case 330U: 
    if (len != 1) {
      len --;
      *(wln + len) = '\000';
      wcstombs((char * __restrict  )ln, (wchar_t const   * __restrict  )wln, (size_t )48);
      ndents = total;
    } else {
      ch[0] = (wint_t )'/';
      goto end;
    }
    case 12U: 
    if (ch[0] == 12U) {
      if (*(wln + 1)) {
        *(ln + 47) = *(ln + 1);
        tmp___5 = '\000';
        *(wln + 1) = tmp___5;
        *(ln + 1) = (char )tmp___5;
        len = 1;
        ndents = total;
      } else
      if (*(ln + 47)) {
        *(ln + 1) = *(ln + 47);
        *(ln + 47) = (char )'\000';
        tmp___6 = mbstowcs((wchar_t * __restrict  )wln, (char const   * __restrict  )ln,
                           (size_t )48);
        len = (int )tmp___6;
      } else {
        goto end;
      }
    }
    cur = 0;
    tmp___7 = matches((char const   *)pln);
    if (tmp___7 != -1) {
      redraw(path);
    }
    showfilter(ln);
    continue;
    case 27U: 
    tmp___8 = handle_alt_key(ch);
    if (tmp___8 != -1) {
      if (ch[0] == 27U) {
        ch[0] = (wint_t )'q';
      } else {
        unget_wch((wchar_t const   )ch[0]);
        ch[0] = (wint_t )';';
      }
    }
    goto end;
    }
    if (r != 0) {
      break;
    }
    if (ch[0] < 128U) {
      tmp___9 = keyname((int )ch[0]);
      if ((int const   )*(tmp___9 + 0) == 94) {
        if (ch[0] != 94U) {
          goto end;
        }
      }
    }
    if (len == 1) {
      if (ch[0] == 63U) {
        goto end;
      }
      if (cfg.filtermode) {
        switch (ch[0]) {
        case 126U: 
        case 96U: 
        case 93U: 
        case 64U: 
        case 62U: 
        case 61U: 
        case 59U: 
        case 46U: 
        case 45U: 
        case 44U: 
        case 43U: 
        case 39U: 
        goto end;
        }
      }
      if (ch[0] == 58U) {
        if ((unsigned long )fnstrstr == (unsigned long )(& strcasestr)) {
          fnstrstr = (char *(*)(char const   *haystack , char const   *needle ))(& strstr);
        } else {
          fnstrstr = (char *(*)(char const   *haystack , char const   *needle ))(& strcasestr);
        }
        regflags ^= 1 << 1;
        showfilter(ln);
        continue;
      }
      if (ch[0] == 47U) {
        if ((int )*(ln + 0) == 47) {
          *(ln + 0) = (char )'\\';
        } else {
          *(ln + 0) = (char )'/';
        }
        *(wln + 0) = (wchar_t )((uchar_t )*(ln + 0));
        cfg.regex ^= 1U;
        if (cfg.regex) {
          filterfn = & visible_re;
        } else {
          filterfn = & visible_str;
        }
        showfilter(ln);
        continue;
      }
      cur = 0;
    } else
    if (len == 47) {
      continue;
    }
    *(wln + len) = (wchar_t )ch[0];
    len ++;
    *(wln + len) = '\000';
    wcstombs((char * __restrict  )ln, (wchar_t const   * __restrict  )wln, (size_t )48);
    tmp___10 = matches((char const   *)pln);
    if (tmp___10 == -1) {
      showfilter(ln);
      continue;
    }
    if (ndents == 1) {
      if (cfg.autoenter) {
        if ((pdents + 0)->__annonCompField18.flags & 1ULL) {
          ch[0] = (wint_t )343;
          cur = 0;
          goto end;
        }
      }
    }
    redraw(path);
    showfilter(ln);
  }
  end: 
  if (*(ln + 1)) {
    *(ln + 47) = *(ln + 1);
  }
  if (ndents) {
    tmp___11 = (char const   *)(pdents + cur)->name;
  } else {
    tmp___11 = "\000";
  }
  xstrsncpy((char * __restrict  )lastname, (char const   * __restrict  )tmp___11,
            (size_t )256);
  curs_set(0);
  wtimeout(stdscr, 1000);
  return ((int )ch[0]);
}
}
static char *xreadline(char const   *prefill , char const   *prompt ) 
{ 
  size_t len ;
  size_t pos ;
  int x ;
  int r ;
  int WCHAR_T_WIDTH ;
  wint_t ch[1] ;
  wchar_t *buf ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  WCHAR_T_WIDTH = (int )sizeof(wchar_t );
  tmp = malloc(sizeof(wchar_t ) * 256UL);
  buf = (wchar_t *)tmp;
  if (! buf) {
    printerr(3442);
  }
  wtimeout(stdscr, -1);
  printmsg(prompt);
  if (prefill) {
    pos = mbstowcs((wchar_t * __restrict  )buf, (char const   * __restrict  )prefill,
                   (size_t )256);
    len = pos;
  } else {
    len = (size_t )-1;
  }
  if (len == 0xffffffffffffffffUL) {
    *(buf + 0) = '\000';
    pos = (size_t )0;
    len = pos;
  }
  if ((unsigned long )((void const   *)0) != (unsigned long )((void const   *)stdscr)) {
    x = (int )stdscr->_curx;
  } else {
    x = -1;
  }
  curs_set(1);
  while (1) {
    *(buf + len) = ' ';
    wattr_on(stdscr, ((cfg.curctx + 1U) << 8) & (((1U << 8) - 1U) << 8), (void *)0);
    if (pos > (size_t )((int )xcols - x)) {
      tmp___0 = wmove(stdscr, (int )xlines - 1, x);
      if (! (tmp___0 == -1)) {
        waddnwstr(stdscr, (wchar_t const   *)(buf + ((pos - (size_t )((int )xcols - x)) + 1UL)),
                  (int )xcols - x);
      }
      wmove(stdscr, (int )xlines - 1, (int )xcols - 1);
    } else {
      tmp___1 = wmove(stdscr, (int )xlines - 1, x);
      if (! (tmp___1 == -1)) {
        waddnwstr(stdscr, (wchar_t const   *)buf, (int )(len + 1UL));
      }
      tmp___2 = wcswidth((wchar_t const   *)buf, pos);
      wmove(stdscr, (int )xlines - 1, x + tmp___2);
    }
    wattr_off(stdscr, ((cfg.curctx + 1U) << 8) & (((1U << 8) - 1U) << 8), (void *)0);
    r = wget_wch(stdscr, ch);
    if (r == -1) {
      continue;
    }
    if (r == 0) {
      switch (ch[0]) {
      case 13U: 
      case 10U: 
      case 343U: 
      goto END;
      case 4U: 
      if (pos < len) {
        pos ++;
      } else
      if (pos) {
        continue;
      } else
      if (len) {
        continue;
      } else {
        len = (size_t )0;
        goto END;
      }
      case 8U: 
      case 127U: 
      if (pos > 0UL) {
        memmove((void *)((buf + pos) - 1), (void const   *)(buf + pos), (len - pos) * (size_t )WCHAR_T_WIDTH);
        len --;
        pos --;
      }
      continue;
      case 9U: 
      if (! len) {
        if (! pos) {
          if (ndents) {
            pos = mbstowcs((wchar_t * __restrict  )buf, (char const   * __restrict  )(pdents + cur)->name,
                           (size_t )256);
            len = pos;
          }
        }
      }
      continue;
      case 6U: 
      if (pos < len) {
        pos ++;
      }
      continue;
      case 2U: 
      if (pos > 0UL) {
        pos --;
      }
      continue;
      case 23U: 
      printmsg(prompt);
      while (! (pos == 0UL)) {
        memmove((void *)((buf + pos) - 1), (void const   *)(buf + pos), (len - pos) * (size_t )WCHAR_T_WIDTH);
        pos --;
        len --;
        if (*(buf + (pos - 1UL)) != 32) {
          if (! (*(buf + (pos - 1UL)) != 47)) {
            break;
          }
        } else {
          break;
        }
      }
      continue;
      case 11U: 
      printmsg(prompt);
      len = pos;
      continue;
      case 12U: 
      printmsg(prompt);
      pos = (size_t )0;
      len = pos;
      continue;
      case 1U: 
      pos = (size_t )0;
      continue;
      case 5U: 
      pos = len;
      continue;
      case 21U: 
      printmsg(prompt);
      memmove((void *)buf, (void const   *)(buf + pos), (len - pos) * (size_t )WCHAR_T_WIDTH);
      len -= pos;
      pos = (size_t )0;
      continue;
      case 27U: 
      tmp___3 = handle_alt_key(ch);
      if (tmp___3 != -1) {
        continue;
      }
      len = (size_t )0;
      goto END;
      }
      if (ch[0] < 128U) {
        tmp___4 = keyname((int )ch[0]);
        if ((int const   )*(tmp___4 + 0) == 94) {
          continue;
        }
      }
      if (pos < 255UL) {
        memmove((void *)((buf + pos) + 1), (void const   *)(buf + pos), (len - pos) * (size_t )WCHAR_T_WIDTH);
        *(buf + pos) = (wchar_t )ch[0];
        len ++;
        pos ++;
        continue;
      }
    } else {
      switch (ch[0]) {
      case 410U: 
      clearoldprompt();
      xlines = (ushort_t )LINES;
      printmsg(prompt);
      break;
      case 260U: 
      if (pos > 0UL) {
        pos --;
      }
      break;
      case 261U: 
      if (pos < len) {
        pos ++;
      }
      break;
      case 263U: 
      if (pos > 0UL) {
        memmove((void *)((buf + pos) - 1), (void const   *)(buf + pos), (len - pos) * (size_t )WCHAR_T_WIDTH);
        len --;
        pos --;
      }
      break;
      case 330U: 
      if (pos < len) {
        memmove((void *)(buf + pos), (void const   *)((buf + pos) + 1), ((len - pos) - 1UL) * (size_t )WCHAR_T_WIDTH);
        len --;
      }
      break;
      case 360U: 
      pos = len;
      break;
      case 262U: 
      pos = (size_t )0;
      break;
      case 258U: 
      case 259U: 
      if (prompt) {
        if (lastcmd) {
          if ((int const   )*prompt != (int const   )*">>> ") {
            tmp___6 = -1;
          } else {
            tmp___5 = strcmp(prompt, ">>> ");
            tmp___6 = tmp___5;
          }
          if (tmp___6 == 0) {
            printmsg(prompt);
            pos = mbstowcs((wchar_t * __restrict  )buf, (char const   * __restrict  )lastcmd,
                           (size_t )256);
            len = pos;
          }
        }
      }
      default: 
      break;
      }
    }
  }
  END: 
  curs_set(0);
  wtimeout(stdscr, 1000);
  printmsg("");
  *(buf + len) = '\000';
  pos = wcstombs((char * __restrict  )(g_buf), (wchar_t const   * __restrict  )buf,
                 (size_t )255);
  if (pos >= 255UL) {
    g_buf[255] = (char )'\000';
  }
  free((void *)buf);
  return (g_buf);
}
}
static int xlink(char *prefix , char *path , char *curfname , char *buf , int *presel ,
                 int type ) 
{ 
  int count ;
  int choice ;
  char *psel ;
  char *fname ;
  size_t pos ;
  size_t len ;
  size_t r ;
  int (*link_fn)(char const   * , char const   * ) ;
  char lnpath[4096] ;
  char *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  count = 0;
  psel = pselbuf;
  pos = (size_t )0;
  link_fn = (int (*)(char const   * , char const   * ))((void *)0);
  choice = get_cur_or_sel();
  if (! choice) {
    return (-1);
  }
  if (type == 115) {
    link_fn = (int (*)(char const   * , char const   * ))(& symlink);
  } else {
    link_fn = (int (*)(char const   * , char const   * ))(& link);
  }
  if (choice == 99) {
    goto _L;
  } else
  if (nselected == 1) {
    _L: /* CIL Label */ 
    mkpath((char const   *)path, (char const   *)prefix, lnpath);
    if (choice == 99) {
      tmp = curfname;
    } else {
      tmp = pselbuf;
    }
    mkpath((char const   *)path, (char const   *)tmp, buf);
    tmp___0 = (*link_fn)((char const   *)buf, (char const   *)(lnpath));
    if (! tmp___0) {
      if (choice == 115) {
        clearselection();
      }
      return (1);
    }
    tmp___1 = __errno_location();
    tmp___2 = strerror(*tmp___1);
    printwait((char const   *)tmp___2, presel);
    return (-1);
  }
  while (pos < (size_t )selbufpos) {
    len = xstrlen((char const   * __restrict  )psel);
    fname = xbasename(psel);
    r = xstrsncpy((char * __restrict  )buf, (char const   * __restrict  )prefix, (size_t )256);
    xstrsncpy((char * __restrict  )((buf + r) - 1), (char const   * __restrict  )fname,
              255UL - r);
    mkpath((char const   *)path, (char const   *)buf, lnpath);
    tmp___3 = (*link_fn)((char const   *)psel, (char const   *)(lnpath));
    if (! tmp___3) {
      count ++;
    }
    pos += len + 1UL;
    psel += len + 1UL;
  }
  clearselection();
  return (count);
}
}
static _Bool parsekvpair(kv **arr , char **envcpy , uchar_t const   id , uchar_t *items ) 
{ 
  _Bool new ;
  uchar_t INCR ;
  uint_t i ;
  kv *kvarr ;
  char *ptr ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
  new = (_Bool)1;
  INCR = (uchar_t )8;
  i = (uint_t )0;
  kvarr = (kv *)((void *)0);
  tmp = getenv((char const   *)env_cfg[id]);
  ptr = tmp;
  if (! ptr) {
    return ((_Bool)1);
  } else
  if (! *ptr) {
    return ((_Bool)1);
  }
  *envcpy = xstrdup((char const   * __restrict  )ptr);
  if (! *envcpy) {
    tmp___0 = xitoa((uint_t )3716);
    perror((char const   *)tmp___0);
    return ((_Bool)0);
  }
  ptr = *envcpy;
  while (1) {
    if (*ptr) {
      if (! (i < 100U)) {
        break;
      }
    } else {
      break;
    }
    if (new) {
      if (! (i & (unsigned int )((int )INCR - 1))) {
        tmp___1 = xrealloc((void *)kvarr, sizeof(kv ) * (unsigned long )(i + (uint_t )INCR));
        kvarr = (kv *)tmp___1;
        *arr = kvarr;
        if (! kvarr) {
          tmp___2 = xitoa((uint_t )3728);
          perror((char const   *)tmp___2);
          return ((_Bool)0);
        }
        memset((void *)(kvarr + i), 0, sizeof(kv ) * (unsigned long )INCR);
      }
      (kvarr + i)->key = (int )((uchar_t )*ptr);
      ptr ++;
      if ((int )*ptr != 58) {
        return ((_Bool)0);
      } else {
        ptr ++;
        if ((int )*ptr == 0) {
          return ((_Bool)0);
        } else
        if ((int )*ptr == 59) {
          return ((_Bool)0);
        }
      }
      (kvarr + i)->off = (int )(ptr - *envcpy);
      i ++;
      new = (_Bool)0;
    }
    if ((int )*ptr == 59) {
      *ptr = (char )'\000';
      new = (_Bool)1;
    }
    ptr ++;
  }
  *items = (uchar_t )i;
  return ((_Bool )(i != 0U));
}
}
static char *get_kv_val(kv *kvarr , char *buf , int key , uchar_t max , uchar_t id ) 
{ 
  char *val ;
  int r ;
  char *tmp ;
  char *tmp___0 ;

  {
  if (! kvarr) {
    return ((char *)((void *)0));
  }
  r = 0;
  while (1) {
    if (r < (int )max) {
      if (! (kvarr + r)->key) {
        break;
      }
    } else {
      break;
    }
    if ((kvarr + r)->key == key) {
      if ((int )id == 2) {
        return (pluginstr + (kvarr + r)->off);
      }
      val = bmstr + (kvarr + r)->off;
      convert_tilde((char const   *)val, g_buf);
      if ((int )*(val + 0) == 126) {
        tmp = g_buf;
      } else {
        tmp = val;
      }
      tmp___0 = abspath((char const   *)tmp, (char const   *)((void *)0), buf);
      return (tmp___0);
    }
    r ++;
  }
  return ((char *)((void *)0));
}
}
static int get_kv_key(kv *kvarr , char *val , uchar_t max , uchar_t id ) 
{ 
  int r ;
  int tmp ;
  int tmp___0 ;

  {
  if (! kvarr) {
    return (-1);
  }
  if ((int )id != 11) {
    return (-1);
  }
  r = 0;
  while (1) {
    if (r < (int )max) {
      if (! (kvarr + r)->key) {
        break;
      }
    } else {
      break;
    }
    if ((int )*(orderstr + (kvarr + r)->off) != (int )*val) {
      tmp___0 = -1;
    } else {
      tmp = strcmp((char const   *)(orderstr + (kvarr + r)->off), (char const   *)val);
      tmp___0 = tmp;
    }
    if (tmp___0 == 0) {
      return ((kvarr + r)->key);
    }
    r ++;
  }
  return (-1);
}
}
static void resetdircolor(int flags ) 
{ 


  {
  if (g_state.dircolor) {
    if (! (flags & 1)) {
      wattr_off(stdscr, (((cfg.curctx + 1U) << 8) & (((1U << 8) - 1U) << 8)) | (1U << 21),
                (void *)0);
      g_state.dircolor = (uint_t )0;
    }
  }
  return;
}
}
static char *unescape(char const   *str , uint_t maxcols ) 
{ 
  char *wbuf ;
  char *buf ;

  {
  wbuf = g_buf;
  buf = wbuf;
  xstrsncpy((char * __restrict  )wbuf, (char const   * __restrict  )str, (size_t )maxcols);
  while (*buf) {
    if ((int )*buf <= 31) {
      *buf = (char )'?';
    } else
    if ((int )*buf == 127) {
      *buf = (char )'?';
    }
    buf ++;
  }
  return (wbuf);
}
}
static off_t get_size(off_t size , off_t *pval , int comp ) 
{ 
  off_t rem ;
  off_t quo ;

  {
  rem = *pval;
  quo = rem / 10L;
  if (rem - quo * 10L >= 5L) {
    rem = quo + 1L;
    if (rem == (off_t )comp) {
      size ++;
      rem = (off_t )0;
    }
  } else {
    rem = quo;
  }
  *pval = rem;
  return (size);
}
}
static char size_buf[12]  ;
static char *coolsize(off_t size ) 
{ 
  char const   *U ;
  off_t rem ;
  size_t ret ;
  int i ;
  char *tmp ;
  char *frac ;
  char *tmp___0 ;
  size_t toprint ;
  int tmp___1 ;
  size_t len ;
  size_t tmp___2 ;
  char tmp___3 ;
  char tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;

  {
  U = "BKMGTPEZY";
  rem = (off_t )0;
  i = 0;
  while (size >= 1024L) {
    rem = size & 1023L;
    size >>= 10;
    i ++;
  }
  if (i == 1) {
    rem = rem * 1000L >> 10;
    rem /= 10L;
    size = get_size(size, & rem, 10);
  } else
  if (i == 2) {
    rem = rem * 1000L >> 10;
    size = get_size(size, & rem, 100);
  } else
  if (i > 2) {
    rem = rem * 10000L >> 10;
    size = get_size(size, & rem, 1000);
  }
  if (i > 0) {
    if (i < 6) {
      if (rem) {
        tmp = xitoa((uint_t )size);
        ret = xstrsncpy((char * __restrict  )(size_buf), (char const   * __restrict  )tmp,
                        (size_t )12);
        size_buf[ret - 1UL] = (char )'.';
        tmp___0 = xitoa((uint_t )rem);
        frac = tmp___0;
        if (i > 3) {
          tmp___1 = 3;
        } else {
          tmp___1 = i;
        }
        toprint = (size_t )tmp___1;
        tmp___2 = xstrlen((char const   * __restrict  )frac);
        len = tmp___2;
        if (len < toprint) {
          tmp___4 = (char )'0';
          size_buf[ret + 2UL] = tmp___4;
          tmp___3 = tmp___4;
          size_buf[ret + 1UL] = tmp___3;
          size_buf[ret] = tmp___3;
          xstrsncpy((char * __restrict  )((size_buf + ret) + (toprint - len)), (char const   * __restrict  )frac,
                    len + 1UL);
        } else {
          xstrsncpy((char * __restrict  )(size_buf + ret), (char const   * __restrict  )frac,
                    toprint + 1UL);
        }
        ret += toprint;
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    if (size) {
      tmp___5 = xitoa((uint_t )size);
      tmp___6 = (char const   *)tmp___5;
    } else {
      tmp___6 = "0";
    }
    ret = xstrsncpy((char * __restrict  )(size_buf), (char const   * __restrict  )tmp___6,
                    (size_t )12);
    ret --;
  }
  size_buf[ret] = (char )*(U + i);
  size_buf[ret + 1UL] = (char )'\000';
  return (size_buf);
}
}
static char *get_lsperms(mode_t mode ) ;
static char const   * const  rwx[8]  = 
  {      (char const   * const  )"---",      (char const   * const  )"--x",      (char const   * const  )"-w-",      (char const   * const  )"-wx", 
        (char const   * const  )"r--",      (char const   * const  )"r-x",      (char const   * const  )"rw-",      (char const   * const  )"rwx"};
static char bits[11]  = {      (char )'\000'};
static char *get_lsperms(mode_t mode ) 
{ 


  {
  switch (mode & 61440U) {
  case 32768U: 
  bits[0] = (char )'-';
  break;
  case 16384U: 
  bits[0] = (char )'d';
  break;
  case 40960U: 
  bits[0] = (char )'l';
  break;
  case 49152U: 
  bits[0] = (char )'s';
  break;
  case 4096U: 
  bits[0] = (char )'p';
  break;
  case 24576U: 
  bits[0] = (char )'b';
  break;
  case 8192U: 
  bits[0] = (char )'c';
  break;
  default: 
  bits[0] = (char )'?';
  break;
  }
  xstrsncpy((char * __restrict  )(& bits[1]), (char const   * __restrict  )rwx[(mode >> 6) & 7U],
            (size_t )4);
  xstrsncpy((char * __restrict  )(& bits[4]), (char const   * __restrict  )rwx[(mode >> 3) & 7U],
            (size_t )4);
  xstrsncpy((char * __restrict  )(& bits[7]), (char const   * __restrict  )rwx[mode & 7U],
            (size_t )4);
  if (mode & 2048U) {
    if (mode & 64U) {
      bits[3] = (char )'s';
    } else {
      bits[3] = (char )'S';
    }
  }
  if (mode & 1024U) {
    if (mode & 8U) {
      bits[6] = (char )'s';
    } else {
      bits[6] = (char )'l';
    }
  }
  if (mode & 512U) {
    if (mode & 1U) {
      bits[9] = (char )'t';
    } else {
      bits[9] = (char )'T';
    }
  }
  return (bits);
}
}
static void print_time(time_t const   *timep , uchar_t const   flags ) 
{ 
  struct tm t ;
  char *tmp ;

  {
  if ((int const   )flags & 64) {
    wattr_on(stdscr, 1U << 18, (void *)0);
  }
  localtime_r((time_t const   * __restrict  )timep, (struct tm * __restrict  )(& t));
  tmp = xitoa((uint_t )(t.tm_year + 1900));
  printw("%s-%02d-%02d %02d:%02d", tmp, t.tm_mon + 1, t.tm_mday, t.tm_hour, t.tm_min);
  if ((int const   )flags & 64) {
    wattr_off(stdscr, 1U << 18, (void *)0);
  }
  return;
}
}
static char get_detail_ind(mode_t const   mode ) 
{ 


  {
  switch (mode & 61440U) {
  case 32768U: 
  case 16384U: 
  return ((char )' ');
  case 40960U: 
  return ((char )'@');
  case 49152U: 
  return ((char )'=');
  case 4096U: 
  return ((char )'|');
  case 24576U: 
  return ((char )'b');
  case 8192U: 
  return ((char )'c');
  }
  return ((char )'?');
}
}
static uchar_t get_color_pair_name_ind(struct entry  const  *ent , char *pind , int *pattr ) 
{ 
  uint_t tmp ;
  chtype tmp___0 ;
  int tmp___1 ;

  {
  switch (ent->mode & 61440U) {
  case 32768U: 
  if (! ent->size) {
    if (ent->mode & 64U) {
      *pind = (char )'*';
    }
    return ((uchar_t )16);
  }
  if (ent->__annonCompField18.flags & 2ULL) {
    if (ent->mode & 64U) {
      *pind = (char )'*';
    }
    return ((uchar_t )10);
  }
  if (ent->mode & 64U) {
    *pind = (char )'*';
    return ((uchar_t )8);
  }
  return ((uchar_t )9);
  case 16384U: 
  *pind = (char )'/';
  if (g_state.oldcolor) {
    return ((uchar_t )7);
  }
  *pattr = (int )((unsigned int )*pattr | (1U << 21));
  if (g_state.dirctx) {
    tmp = cfg.curctx + 1U;
  } else {
    tmp = (uint_t )7;
  }
  return ((uchar_t )tmp);
  case 40960U: 
  if (ent->__annonCompField18.flags & 1ULL) {
    *pind = (char )'/';
    if (g_state.oldcolor) {
      tmp___0 = 1U << 20;
    } else {
      tmp___0 = 1U << 21;
    }
    *pattr = (int )((unsigned int )*pattr | tmp___0);
  } else {
    *pind = (char )'@';
    if (g_state.oldcolor) {
      *pattr = (int )((unsigned int )*pattr | (1U << 20));
    }
  }
  if (! g_state.oldcolor) {
    goto _L;
  } else
  if (cfg.showdetail) {
    _L: /* CIL Label */ 
    if (ent->__annonCompField18.flags & 4ULL) {
      tmp___1 = 13;
    } else {
      tmp___1 = 11;
    }
    return ((uchar_t )tmp___1);
  }
  return ((uchar_t )0);
  case 49152U: 
  *pind = (char )'=';
  return ((uchar_t )15);
  case 4096U: 
  *pind = (char )'|';
  return ((uchar_t )14);
  case 24576U: 
  return ((uchar_t )5);
  case 8192U: 
  return ((uchar_t )6);
  }
  *pind = (char )'?';
  return ((uchar_t )16);
}
}
static void printent(struct entry  const  *ent , uint_t namecols , _Bool sel ) 
{ 
  char ind ;
  int attrs ;
  int type ;
  char perms[6] ;
  unsigned int tmp ;
  blkcnt_t tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  char *tmp___3 ;
  uchar_t color_pair ;
  uchar_t tmp___4 ;
  unsigned int tmp___5 ;
  ullong_t tmp___6 ;
  char *tmp___7 ;

  {
  ind = (char )'\000';
  if (cfg.showdetail) {
    type = (int )(ent->mode & 61440U);
    perms[0] = (char )' ';
    perms[1] = (char )' ';
    perms[2] = (char )(48U + ((ent->mode >> 6) & 7U));
    perms[3] = (char )(48U + ((ent->mode >> 3) & 7U));
    perms[4] = (char )(48U + (ent->mode & 7U));
    perms[5] = (char )'\000';
    waddch(stdscr, (chtype const   )' ');
    if (g_state.oldcolor) {
      resetdircolor((int )ent->__annonCompField18.flags);
      attrs = (int )(1U << 20);
    } else {
      if (fcolors[12]) {
        tmp = (12U << 8) & (((1U << 8) - 1U) << 8);
      } else {
        tmp = 0U;
      }
      attrs = (int )tmp;
    }
    if (attrs) {
      wattr_on(stdscr, (attr_t )attrs, (void *)0);
    }
    print_time(& ent->sec, (uchar_t const   )ent->__annonCompField18.flags);
    if (type == 32768) {
      goto _L;
    } else
    if (type == 16384) {
      _L: /* CIL Label */ 
      if (cfg.blkorder) {
        tmp___0 = (blkcnt_t )ent->__annonCompField18.blocks << (int )blk_shift;
      } else {
        tmp___0 = (blkcnt_t )ent->size;
      }
      tmp___1 = coolsize(tmp___0);
      tmp___3 = tmp___1;
    } else {
      tmp___2 = get_detail_ind(ent->mode);
      type = (int )((uchar_t )tmp___2);
      tmp___3 = (char *)(& type);
    }
    printw("%s%9s ", perms, tmp___3);
    if (attrs) {
      wattr_off(stdscr, (attr_t )attrs, (void *)0);
    }
  }
  attrs = 0;
  tmp___4 = get_color_pair_name_ind(ent, & ind, & attrs);
  color_pair = tmp___4;
  if (ent->__annonCompField18.flags & 16ULL) {
    tmp___5 = (43U | (1U << 18)) | (1U << 21);
  } else {
    tmp___5 = (unsigned int )' ';
  }
  waddch(stdscr, (chtype const   )tmp___5);
  if (g_state.oldcolor) {
    resetdircolor((int )ent->__annonCompField18.flags);
  } else {
    if (ent->__annonCompField18.flags & 8ULL) {
      color_pair = (uchar_t )12;
    }
    if (color_pair) {
      if (fcolors[color_pair]) {
        attrs = (int )((unsigned int )attrs | (((chtype )color_pair << 8) & (((1U << 8) - 1U) << 8)));
      }
    }
  }
  if (sel) {
    attrs = (int )((unsigned int )attrs | (1U << 18));
  }
  if (attrs) {
    wattr_on(stdscr, (attr_t )attrs, (void *)0);
  }
  if (! ind) {
    namecols ++;
  }
  if ((ullong_t const   )namecols < ent->__annonCompField18.nlen) {
    tmp___6 = (ullong_t const   )namecols;
  } else {
    tmp___6 = ent->__annonCompField18.nlen;
  }
  tmp___7 = unescape((char const   *)ent->name, (uint_t )(tmp___6 + 1ULL));
  waddnstr(stdscr, (char const   *)tmp___7, -1);
  if (attrs) {
    wattr_off(stdscr, (attr_t )attrs, (void *)0);
  }
  if (ind) {
    waddch(stdscr, (chtype const   )ind);
  }
  return;
}
}
static void savecurctx(char *path , char *curname , int nextctx ) 
{ 
  settings tmpcfg ;
  context *ctxr ;
  char tmp ;
  char tmp___0 ;
  char tmp___1 ;

  {
  tmpcfg = cfg;
  ctxr = & g_ctx[nextctx];
  if (curname) {
    xstrsncpy((char * __restrict  )(g_ctx[tmpcfg.curctx].c_name), (char const   * __restrict  )curname,
              (size_t )256);
  } else {
    g_ctx[tmpcfg.curctx].c_name[0] = (char )'\000';
  }
  g_ctx[tmpcfg.curctx].c_cfg = tmpcfg;
  if (ctxr->c_cfg.ctxactive) {
    tmpcfg = ctxr->c_cfg;
    if (order) {
      cfgsort[4] = cfgsort[nextctx];
      cfgsort[nextctx] = (uchar_t )'0';
    }
  } else {
    ctxr->c_cfg.ctxactive = (uint_t )1;
    xstrsncpy((char * __restrict  )(ctxr->c_path), (char const   * __restrict  )path,
              (size_t )4096);
    tmp___1 = (char )'\000';
    ctxr->c_fltr[1] = tmp___1;
    tmp___0 = tmp___1;
    ctxr->c_fltr[0] = tmp___0;
    tmp = tmp___0;
    ctxr->c_name[0] = tmp;
    ctxr->c_last[0] = tmp;
    ctxr->c_cfg = tmpcfg;
    if ((int )cfgsort[cfg.curctx] == 122) {
      cfgsort[nextctx] = (uchar_t )'z';
    }
  }
  tmpcfg.curctx = (uint_t )nextctx;
  cfg = tmpcfg;
  return;
}
}
static uchar_t get_free_ctx(void) 
{ 
  uchar_t r ;

  {
  r = (uchar_t )cfg.curctx;
  while (1) {
    r = (uchar_t )(((int )r + 1) & -5);
    if (g_ctx[r].c_cfg.ctxactive) {
      if (! ((uint_t )r != cfg.curctx)) {
        break;
      }
    } else {
      break;
    }
  }
  return (r);
}
}
static void set_smart_ctx(int ctx , char *nextpath , char **path , char *file , char **lastname ,
                          char **lastdir ) 
{ 
  uchar_t tmp ;

  {
  if (ctx == 43) {
    tmp = get_free_ctx();
    ctx = (int )tmp + 1;
  }
  if (ctx == 0) {
    xstrsncpy((char * __restrict  )*lastdir, (char const   * __restrict  )*path, (size_t )4096);
    xstrsncpy((char * __restrict  )*path, (char const   * __restrict  )nextpath, (size_t )4096);
  } else
  if ((uint_t )ctx == cfg.curctx + 1U) {
    xstrsncpy((char * __restrict  )*lastdir, (char const   * __restrict  )*path, (size_t )4096);
    xstrsncpy((char * __restrict  )*path, (char const   * __restrict  )nextpath, (size_t )4096);
  } else {
    ctx --;
    g_ctx[ctx].c_cfg.ctxactive = (uint_t )0;
    savecurctx(nextpath, file, ctx);
    *path = g_ctx[ctx].c_path;
    *lastdir = g_ctx[ctx].c_last;
    *lastname = g_ctx[ctx].c_name;
  }
  return;
}
}
static _Bool get_output(char *file , char *arg1 , char *arg2 , int fdout , _Bool multi ,
                        _Bool page ) 
{ 
  pid_t pid ;
  int pipefd[2] ;
  int index___0 ;
  int flags ;
  _Bool ret ;
  _Bool tmpfile___0 ;
  int tmp ;
  char *argv[10] ;
  unsigned int tmp___0 ;
  char *cmd___0 ;
  int fd ;
  ssize_t len ;
  int tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;

  {
  index___0 = 0;
  ret = (_Bool)0;
  if (fdout == -1) {
    if (page) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  tmpfile___0 = (_Bool )tmp;
  argv[0] = (char *)0;
  tmp___0 = 1U;
  while (! (tmp___0 >= 10U)) {
    argv[tmp___0] = (char *)0;
    tmp___0 ++;
  }
  cmd___0 = (char *)((void *)0);
  fd = -1;
  if (tmpfile___0) {
    fdout = create_tmp_file();
    if (fdout == -1) {
      return ((_Bool)0);
    }
  }
  if (multi) {
    cmd___0 = parseargs(file, argv, & index___0);
    if (! cmd___0) {
      return ((_Bool)0);
    }
  } else {
    tmp___1 = index___0;
    index___0 ++;
    argv[tmp___1] = file;
  }
  argv[index___0] = arg1;
  index___0 ++;
  argv[index___0] = arg2;
  tmp___2 = pipe((int *)(pipefd));
  if (tmp___2 == -1) {
    free((void *)cmd___0);
    printerr(4395);
  }
  index___0 = 0;
  while (index___0 < 2) {
    flags = fcntl(pipefd[index___0], 3, 0);
    flags |= 2048;
    fcntl(pipefd[index___0], 4, flags);
    index___0 ++;
  }
  pid = fork();
  if (pid == 0) {
    close(pipefd[0]);
    dup2(pipefd[1], 1);
    dup2(pipefd[1], 2);
    close(pipefd[1]);
    execvp((char const   *)argv[0], (char * const  *)(argv));
    _exit(0);
  }
  waitpid(pid, (int *)((void *)0), 0);
  close(pipefd[1]);
  free((void *)cmd___0);
  while (1) {
    len = read(pipefd[0], (void *)(g_buf), (size_t )((4096 + (256 << 1)) - 1));
    if (! (len > 0L)) {
      break;
    }
    ret = (_Bool)1;
    if (fdout == -1) {
      break;
    }
    tmp___3 = write(fdout, (void const   *)(g_buf), (size_t )len);
    if (tmp___3 != len) {
      break;
    }
  }
  close(pipefd[0]);
  if (! page) {
    return (ret);
  }
  if (tmpfile___0) {
    close(fdout);
    close(fd);
  }
  spawn(pager, g_tmpfpath, (char *)((void *)0), (char *)((void *)0), (ushort_t )265);
  if (tmpfile___0) {
    unlink((char const   *)(g_tmpfpath));
  }
  return ((_Bool)1);
}
}
static _Bool show_stats(char *fpath ) ;
static char * const  cmds[3]  = {      (char * const  )"file -biL",      (char * const  )"file -b",      (char * const  )"stat"};
static _Bool show_stats(char *fpath ) 
{ 
  size_t r ;
  int fd ;
  int tmp ;

  {
  r = sizeof(cmds) / sizeof(cmds[0]);
  tmp = create_tmp_file();
  fd = tmp;
  if (fd == -1) {
    return ((_Bool)0);
  }
  while (r) {
    r --;
    get_output((char *)cmds[r], fpath, (char *)((void *)0), fd, (_Bool)1, (_Bool)0);
  }
  close(fd);
  spawn(pager, g_tmpfpath, (char *)((void *)0), (char *)((void *)0), (ushort_t )265);
  unlink((char const   *)(g_tmpfpath));
  return ((_Bool)1);
}
}
static _Bool xchmod(char const   *fpath , mode_t mode ) 
{ 
  int tmp ;

  {
  if (64U & mode) {
    mode &= 4294967222U;
  } else {
    mode |= 73U;
  }
  tmp = chmod(fpath, mode);
  return ((_Bool )(tmp == 0));
}
}
static size_t get_fs_info(char const   *path , uchar_t type ) 
{ 
  struct statvfs svb ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = statvfs((char const   * __restrict  )path, (struct statvfs * __restrict  )(& svb));
  if (tmp == -1) {
    return ((size_t )0);
  }
  if ((int )type == 0) {
    tmp___0 = ffs((int )(svb.f_frsize >> 1));
    return (svb.f_bavail << tmp___0);
  }
  if ((int )type == 1) {
    tmp___1 = ffs((int )(svb.f_frsize >> 1));
    return ((svb.f_blocks - svb.f_bfree) << tmp___1);
  }
  tmp___2 = ffs((int )(svb.f_frsize >> 1));
  return (svb.f_blocks << tmp___2);
}
}
static _Bool xmktree(char *path , _Bool dir ) 
{ 
  char *p ;
  char *slash ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int fd ;
  int tmp___3 ;
  int *tmp___4 ;

  {
  p = path;
  slash = path;
  if (! p) {
    return ((_Bool)0);
  } else
  if (! *p) {
    return ((_Bool)0);
  }
  p ++;
  while ((int )*p != 0) {
    if ((int )*p == 47) {
      slash = p;
      *p = (char )'\000';
    } else {
      p ++;
      continue;
    }
    tmp = mkdir((char const   *)path, (__mode_t )511);
    if (tmp == -1) {
      tmp___0 = __errno_location();
      if (*tmp___0 != 17) {
        *slash = (char )'/';
        return ((_Bool)0);
      }
    }
    *slash = (char )'/';
    p ++;
  }
  if (dir) {
    tmp___1 = mkdir((char const   *)path, (__mode_t )511);
    if (tmp___1 == -1) {
      tmp___2 = __errno_location();
      if (*tmp___2 != 17) {
        return ((_Bool)0);
      }
    }
  } else {
    tmp___3 = open((char const   *)path, 64, 438);
    fd = tmp___3;
    if (fd == -1) {
      tmp___4 = __errno_location();
      if (*tmp___4 != 17) {
        return ((_Bool)0);
      }
    }
    close(fd);
  }
  return ((_Bool)1);
}
}
static _Bool handle_archive(char *fpath , char op ) 
{ 
  char arg[5] ;
  char *util ;
  char *outdir ;
  _Bool x_to ;
  _Bool is_atool ;
  _Bool tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  _Bool tmp___5 ;
  int tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
  arg[0] = (char )'-';
  arg[1] = (char )'t';
  arg[2] = (char )'v';
  arg[3] = (char )'f';
  arg[4] = (char )'\000';
  outdir = (char *)((void *)0);
  x_to = (_Bool)0;
  if (! g_state.usebsdtar) {
    tmp = getutil((char *)utils[1]);
    if (tmp) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  is_atool = (_Bool )tmp___0;
  if ((int )op == 120) {
    if (is_atool) {
      tmp___2 = ".";
    } else {
      tmp___1 = xbasename(fpath);
      tmp___2 = (char const   *)tmp___1;
    }
    outdir = xreadline(tmp___2, (char const   *)messages[19]);
    if (! outdir) {
      printwait((char const   *)messages[4], (int *)((void *)0));
      return ((_Bool)0);
    } else
    if (! *outdir) {
      printwait((char const   *)messages[4], (int *)((void *)0));
      return ((_Bool)0);
    }
    if ((int )*outdir == 46) {
      if (! ((int )*(outdir + 1) == 0)) {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      tmp___5 = xmktree(outdir, (_Bool)1);
      if (tmp___5) {
        tmp___6 = chdir((char const   *)outdir);
        if (tmp___6 == -1) {
          tmp___3 = __errno_location();
          tmp___4 = strerror(*tmp___3);
          printwait((char const   *)tmp___4, (int *)((void *)0));
          return ((_Bool)0);
        }
      } else {
        tmp___3 = __errno_location();
        tmp___4 = strerror(*tmp___3);
        printwait((char const   *)tmp___4, (int *)((void *)0));
        return ((_Bool)0);
      }
      outdir = getcwd((char *)((void *)0), (size_t )0);
      x_to = (_Bool)1;
    }
  }
  if (is_atool) {
    util = (char *)utils[1];
    arg[1] = op;
    arg[2] = (char )'\000';
  } else {
    tmp___8 = getutil((char *)utils[2]);
    if (tmp___8) {
      util = (char *)utils[2];
      if ((int )op == 120) {
        arg[1] = op;
      }
    } else {
      tmp___7 = is_suffix((char const   * __restrict  )fpath, (char const   * __restrict  )".zip");
      if (tmp___7) {
        util = (char *)utils[3];
        if ((int )op == 108) {
          arg[1] = (char )'v';
        } else {
          arg[1] = (char )'\000';
        }
        arg[2] = (char )'\000';
      } else {
        util = (char *)utils[4];
        if ((int )op == 120) {
          arg[1] = op;
        }
      }
    }
  }
  if ((int )op == 120) {
    spawn(util, arg, fpath, (char *)((void *)0), (ushort_t )9);
  } else {
    get_output(util, arg, fpath, -1, (_Bool)1, (_Bool)1);
  }
  if (x_to) {
    tmp___11 = xdirname(fpath);
    tmp___12 = chdir((char const   *)tmp___11);
    if (tmp___12 == -1) {
      tmp___9 = __errno_location();
      tmp___10 = strerror(*tmp___9);
      printwait((char const   *)tmp___10, (int *)((void *)0));
      free((void *)outdir);
      return ((_Bool)0);
    }
    xstrsncpy((char * __restrict  )fpath, (char const   * __restrict  )outdir, (size_t )4096);
    free((void *)outdir);
  } else
  if ((int )op == 120) {
    *(fpath + 0) = (char )'\000';
  }
  return ((_Bool)1);
}
}
static char *visit_parent(char *path , char *newpath , int *presel ) 
{ 
  char *dir ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  if ((int )*(path + 1) == 0) {
    if ((int )*(path + 0) == 47) {
      if (cfg.filtermode) {
        if (presel) {
          *presel = '/';
        }
      }
      return ((char *)((void *)0));
    }
  }
  if (newpath) {
    xstrsncpy((char * __restrict  )newpath, (char const   * __restrict  )path, (size_t )4096);
  } else {
    newpath = path;
  }
  dir = xdirname(newpath);
  tmp___1 = chdir((char const   *)dir);
  if (tmp___1 == -1) {
    tmp = __errno_location();
    tmp___0 = strerror(*tmp);
    printwait((char const   *)tmp___0, presel);
    return ((char *)((void *)0));
  }
  return (dir);
}
}
static void valid_parent(char *path , char *lastname ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  tmp = xbasename(path);
  xstrsncpy((char * __restrict  )lastname, (char const   * __restrict  )tmp, (size_t )256);
  while (1) {
    if ((int )*(path + 1) == 0) {
      if ((int )*(path + 0) == 47) {
        break;
      }
    }
    tmp___0 = visit_parent(path, (char *)((void *)0), (int *)((void *)0));
    if (tmp___0) {
      break;
    }
  }
  tmp___1 = __errno_location();
  tmp___2 = strerror(*tmp___1);
  printwait((char const   *)tmp___2, (int *)((void *)0));
  xdelay((useconds_t )350000);
  return;
}
}
static _Bool archive_mount(char *newpath ) 
{ 
  char *str ;
  char *dir ;
  char *cmd___0 ;
  char *name ;
  size_t len ;
  char mntpath[4096] ;
  _Bool tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;

  {
  str = (char *)"install archivemount";
  cmd___0 = str + 8;
  name = (pdents + cur)->name;
  len = (size_t )(pdents + cur)->__annonCompField18.nlen;
  tmp = getutil(cmd___0);
  if (! tmp) {
    printmsg((char const   *)str);
    return ((_Bool)0);
  }
  dir = xstrdup((char const   * __restrict  )name);
  if (! dir) {
    printmsg((char const   *)messages[5]);
    return ((_Bool)0);
  }
  while (len > 1UL) {
    len --;
    if ((int )*(dir + len) == 46) {
      *(dir + len) = (char )'\000';
      break;
    }
  }
  mkpath((char const   *)cfgpath, (char const   *)toks[2], mntpath);
  mkpath((char const   *)(mntpath), (char const   *)dir, newpath);
  free((void *)dir);
  tmp___2 = xmktree(newpath, (_Bool)1);
  if (! tmp___2) {
    tmp___0 = __errno_location();
    tmp___1 = strerror(*tmp___0);
    printwait((char const   *)tmp___1, (int *)((void *)0));
    return ((_Bool)0);
  }
  tmp___3 = spawn(cmd___0, name, newpath, (char *)((void *)0), (ushort_t )8);
  if (tmp___3) {
    printmsg((char const   *)messages[5]);
    return ((_Bool)0);
  }
  return ((_Bool)1);
}
}
static _Bool remote_mount(char *newpath ) 
{ 
  uchar_t flag ;
  int opt ;
  char *tmp ;
  char *env ;
  _Bool r ;
  _Bool tmp___0 ;
  _Bool s ;
  _Bool tmp___1 ;
  char mntpath[4096] ;
  char *div___0 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  _Bool tmp___5 ;
  size_t len ;
  size_t tmp___6 ;
  int tmp___7 ;

  {
  flag = (uchar_t )9;
  tmp___0 = getutil((char *)utils[10]);
  r = tmp___0;
  tmp___1 = getutil((char *)utils[9]);
  s = tmp___1;
  if (! r) {
    if (! s) {
      printmsg("install sshfs/rclone");
      return ((_Bool)0);
    }
  }
  if (r) {
    if (s) {
      opt = get_input((char const   *)messages[30]);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (! s) {
    opt = 'r';
  } else {
    opt = 's';
  }
  if (opt == 115) {
    env = xgetenv((char const   * const  )"NNN_SSHFS", (char *)utils[9]);
  } else
  if (opt == 114) {
    flag = (uchar_t )((int )flag | 6);
    env = xgetenv((char const   * const  )"NNN_RCLONE", (char *)"rclone mount");
  } else {
    printmsg((char const   *)messages[40]);
    return ((_Bool)0);
  }
  tmp = xreadline((char const   *)((void *)0), "host[:dir] > ");
  if (! *(tmp + 0)) {
    printmsg((char const   *)messages[4]);
    return ((_Bool)0);
  }
  tmp___2 = strchr((char const   *)tmp, ':');
  div___0 = tmp___2;
  if (div___0) {
    *div___0 = (char )'\000';
  }
  mkpath((char const   *)cfgpath, (char const   *)toks[2], mntpath);
  mkpath((char const   *)(mntpath), (char const   *)tmp, newpath);
  tmp___5 = xmktree(newpath, (_Bool)1);
  if (! tmp___5) {
    tmp___3 = __errno_location();
    tmp___4 = strerror(*tmp___3);
    printwait((char const   *)tmp___4, (int *)((void *)0));
    return ((_Bool)0);
  }
  if (! div___0) {
    tmp___6 = xstrlen((char const   * __restrict  )tmp);
    len = tmp___6;
    *(tmp + len) = (char )':';
    *(tmp + (len + 1UL)) = (char )'\000';
  } else {
    *div___0 = (char )':';
  }
  if (opt == 115) {
    tmp___7 = spawn(env, tmp, newpath, (char *)((void *)0), (ushort_t )flag);
    if (tmp___7) {
      printmsg((char const   *)messages[5]);
      return ((_Bool)0);
    }
  } else {
    spawn(env, tmp, newpath, (char *)((void *)0), (ushort_t )flag);
    printmsg((char const   *)messages[31]);
    xdelay((useconds_t )(350000 << 2));
  }
  return ((_Bool)1);
}
}
static _Bool unmount(char *name , char *newpath , int *presel , char *currentpath ) ;
static char cmd[12]  = 
  {      (char )'f',      (char )'u',      (char )'s',      (char )'e', 
        (char )'r',      (char )'m',      (char )'o',      (char )'u', 
        (char )'n',      (char )'t',      (char )'3',      (char )'\000'};
static _Bool found  =    (_Bool)0;
static _Bool unmount(char *name , char *newpath , int *presel , char *currentpath ) 
{ 
  char *tmp ;
  struct stat sb ;
  struct stat psb ;
  _Bool child ;
  _Bool parent ;
  _Bool hovered ;
  char mntpath[4096] ;
  _Bool tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  int tmp___6 ;
  _Bool tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
  tmp = name;
  child = (_Bool)0;
  parent = (_Bool)0;
  hovered = (_Bool)0;
  if (! found) {
    tmp___0 = getutil(cmd);
    if (! tmp___0) {
      cmd[10] = (char )'\000';
      found = (_Bool)1;
    }
  }
  mkpath((char const   *)cfgpath, (char const   *)toks[2], mntpath);
  if (tmp) {
    tmp___4 = strcmp((char const   *)(mntpath), (char const   *)currentpath);
    if (tmp___4 == 0) {
      mkpath((char const   *)(mntpath), (char const   *)tmp, newpath);
      tmp___1 = lstat((char const   * __restrict  )newpath, (struct stat * __restrict  )(& sb));
      child = (_Bool )(tmp___1 != -1);
      tmp___2 = xdirname(newpath);
      tmp___3 = lstat((char const   * __restrict  )tmp___2, (struct stat * __restrict  )(& psb));
      parent = (_Bool )(tmp___3 != -1);
      if (! child) {
        if (! parent) {
          *presel = '$';
          return ((_Bool)0);
        }
      }
    }
  }
  if (! tmp) {
    goto _L;
  } else
  if (! child) {
    goto _L;
  } else
  if (! ((sb.st_mode & 61440U) == 16384U)) {
    goto _L;
  } else
  if (child) {
    if (parent) {
      if (sb.st_dev == psb.st_dev) {
        _L: /* CIL Label */ 
        tmp = xreadline((char const   *)((void *)0), (char const   *)messages[16]);
        if (! *(tmp + 0)) {
          return ((_Bool)0);
        }
        if (name) {
          if ((int )*(tmp + 0) == 45) {
            if ((int )*(tmp + 1) == 0) {
              mkpath((char const   *)currentpath, (char const   *)name, newpath);
              hovered = (_Bool)1;
            }
          }
        }
      }
    }
  }
  if (! hovered) {
    mkpath((char const   *)(mntpath), (char const   *)tmp, newpath);
  }
  tmp___5 = xdiraccess((char const   *)newpath);
  if (! tmp___5) {
    *presel = '$';
    return ((_Bool)0);
  }
  tmp___9 = spawn(cmd, (char *)"-qu", newpath, (char *)((void *)0), (ushort_t )8);
  if (tmp___9) {
    tmp___6 = get_input((char const   *)messages[37]);
    tmp___7 = xconfirm(tmp___6);
    if (! tmp___7) {
      return ((_Bool)0);
    }
    tmp___8 = spawn(cmd, (char *)"-quz", newpath, (char *)((void *)0), (ushort_t )8);
    if (tmp___8) {
      printwait((char const   *)messages[5], presel);
      return ((_Bool)0);
    }
  }
  tmp___12 = rmdir((char const   *)newpath);
  if (tmp___12 == -1) {
    tmp___10 = __errno_location();
    tmp___11 = strerror(*tmp___10);
    printwait((char const   *)tmp___11, presel);
    return ((_Bool)0);
  }
  return ((_Bool)1);
}
}
static void lock_terminal(void) 
{ 
  char *tmp ;

  {
  tmp = xgetenv((char const   * const  )"NNN_LOCKER", (char *)utils[5]);
  spawn(tmp, (char *)((void *)0), (char *)((void *)0), (char *)((void *)0), (ushort_t )9);
  return;
}
}
static void printkv(kv *kvarr , int fd , uchar_t max , uchar_t id ) 
{ 
  char *val ;
  char *tmp ;
  uchar_t i ;

  {
  if ((int )id == 1) {
    tmp = bmstr;
  } else {
    tmp = pluginstr;
  }
  val = tmp;
  i = (uchar_t )0;
  while (1) {
    if ((int )i < (int )max) {
      if (! (kvarr + i)->key) {
        break;
      }
    } else {
      break;
    }
    dprintf(fd, (char const   * __restrict  )" %c: %s\n", (int )((char )(kvarr + i)->key),
            val + (kvarr + i)->off);
    i = (uchar_t )((int )i + 1);
  }
  return;
}
}
static void printkeys(kv *kvarr , char *buf , uchar_t max ) 
{ 
  uchar_t i ;

  {
  i = (uchar_t )0;
  while (1) {
    if ((int )i < (int )max) {
      if (! (kvarr + i)->key) {
        break;
      }
    } else {
      break;
    }
    *(buf + ((int )i << 1)) = (char )' ';
    *(buf + (((int )i << 1) + 1)) = (char )(kvarr + i)->key;
    i = (uchar_t )((int )i + 1);
  }
  *(buf + ((int )i << 1)) = (char )'\000';
  return;
}
}
static size_t handle_bookmark(char const   *bmark , char *newpath ) 
{ 
  int fd ;
  size_t r ;
  char *tmp ;
  int tmp___0 ;

  {
  fd = '\r';
  if (maxbm) {
    goto _L;
  } else
  if (bmark) {
    _L: /* CIL Label */ 
    r = xstrsncpy((char * __restrict  )(g_buf), (char const   * __restrict  )messages[34],
                  (size_t )(4096 + (256 << 1)));
    if (bmark) {
      r --;
      g_buf[r] = (char )' ';
      r ++;
      g_buf[r] = (char )',';
      r ++;
      g_buf[r] = (char )'\000';
      r ++;
    }
    printkeys(bookmark, (g_buf + r) - 1, maxbm);
    printmsg((char const   *)(g_buf));
    fd = get_input((char const   *)((void *)0));
  }
  r = (size_t )0;
  if (fd == 44) {
    if (bmark) {
      xstrsncpy((char * __restrict  )newpath, (char const   * __restrict  )bmark,
                (size_t )4096);
    } else {
      r = (size_t )27;
    }
  } else
  if (fd == 13) {
    mkpath((char const   *)cfgpath, (char const   *)toks[0], newpath);
    g_state.selbm = (uint_t )1;
  } else {
    tmp = get_kv_val(bookmark, newpath, fd, maxbm, (uchar_t )1);
    if (! tmp) {
      r = (size_t )40;
    }
  }
  if (! r) {
    tmp___0 = chdir((char const   *)newpath);
    if (tmp___0 == -1) {
      r = (size_t )24;
      if (g_state.selbm) {
        g_state.selbm = (uint_t )0;
      }
    }
  }
  return (r);
}
}
static void add_bookmark(char *path , char *newpath , int *presel ) 
{ 
  char *dir ;
  char *tmp ;
  char *tmp___0 ;
  size_t r ;
  size_t tmp___1 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  tmp = xbasename(path);
  dir = tmp;
  if (*(dir + 0)) {
    tmp___0 = dir;
  } else {
    tmp___0 = (char *)((void *)0);
  }
  dir = xreadline((char const   *)tmp___0, (char const   *)messages[43]);
  if (dir) {
    if (*dir) {
      tmp___1 = mkpath((char const   *)cfgpath, (char const   *)toks[0], newpath);
      r = tmp___1;
      *(newpath + (r - 1UL)) = (char )'/';
      xstrsncpy((char * __restrict  )(newpath + r), (char const   * __restrict  )dir,
                4096UL - r);
      tmp___6 = symlink((char const   *)path, (char const   *)newpath);
      if (tmp___6 == -1) {
        tmp___3 = __errno_location();
        tmp___4 = strerror(*tmp___3);
        tmp___5 = tmp___4;
      } else {
        tmp___5 = newpath;
      }
      printwait((char const   *)tmp___5, presel);
    } else {
      printwait((char const   *)messages[4], presel);
    }
  } else {
    printwait((char const   *)messages[4], presel);
  }
  return;
}
}
static void show_help(char const   *path ) 
{ 
  char const   *start ;
  char const   *end ;
  char helpstr[1184] ;
  int fd ;
  int tmp ;
  char *prog ;
  char *tmp___0 ;
  uchar_t tmp___1 ;
  uchar_t i ;
  size_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  uchar_t i___0 ;
  char *tmp___8 ;

  {
  helpstr[0] = (char )'0';
  helpstr[1] = (char )'\n';
  helpstr[2] = (char )'1';
  helpstr[3] = (char )'N';
  helpstr[4] = (char )'A';
  helpstr[5] = (char )'V';
  helpstr[6] = (char )'I';
  helpstr[7] = (char )'G';
  helpstr[8] = (char )'A';
  helpstr[9] = (char )'T';
  helpstr[10] = (char )'I';
  helpstr[11] = (char )'O';
  helpstr[12] = (char )'N';
  helpstr[13] = (char )'\n';
  helpstr[14] = (char )'9';
  helpstr[15] = (char )'U';
  helpstr[16] = (char )'p';
  helpstr[17] = (char )' ';
  helpstr[18] = (char )'k';
  helpstr[19] = (char )' ';
  helpstr[20] = (char )' ';
  helpstr[21] = (char )'U';
  helpstr[22] = (char )'p';
  helpstr[23] = (char )'%';
  helpstr[24] = (char )'-';
  helpstr[25] = (char )'1';
  helpstr[26] = (char )'6';
  helpstr[27] = (char )'c';
  helpstr[28] = (char )'P';
  helpstr[29] = (char )'g';
  helpstr[30] = (char )'U';
  helpstr[31] = (char )'p';
  helpstr[32] = (char )' ';
  helpstr[33] = (char )'^';
  helpstr[34] = (char )'U';
  helpstr[35] = (char )' ';
  helpstr[36] = (char )' ';
  helpstr[37] = (char )'P';
  helpstr[38] = (char )'a';
  helpstr[39] = (char )'g';
  helpstr[40] = (char )'e';
  helpstr[41] = (char )' ';
  helpstr[42] = (char )'u';
  helpstr[43] = (char )'p';
  helpstr[44] = (char )'\n';
  helpstr[45] = (char )'9';
  helpstr[46] = (char )'D';
  helpstr[47] = (char )'n';
  helpstr[48] = (char )' ';
  helpstr[49] = (char )'j';
  helpstr[50] = (char )' ';
  helpstr[51] = (char )' ';
  helpstr[52] = (char )'D';
  helpstr[53] = (char )'o';
  helpstr[54] = (char )'w';
  helpstr[55] = (char )'n';
  helpstr[56] = (char )'%';
  helpstr[57] = (char )'-';
  helpstr[58] = (char )'1';
  helpstr[59] = (char )'4';
  helpstr[60] = (char )'c';
  helpstr[61] = (char )'P';
  helpstr[62] = (char )'g';
  helpstr[63] = (char )'D';
  helpstr[64] = (char )'n';
  helpstr[65] = (char )' ';
  helpstr[66] = (char )'^';
  helpstr[67] = (char )'D';
  helpstr[68] = (char )' ';
  helpstr[69] = (char )' ';
  helpstr[70] = (char )'P';
  helpstr[71] = (char )'a';
  helpstr[72] = (char )'g';
  helpstr[73] = (char )'e';
  helpstr[74] = (char )' ';
  helpstr[75] = (char )'d';
  helpstr[76] = (char )'o';
  helpstr[77] = (char )'w';
  helpstr[78] = (char )'n';
  helpstr[79] = (char )'\n';
  helpstr[80] = (char )'9';
  helpstr[81] = (char )'L';
  helpstr[82] = (char )'t';
  helpstr[83] = (char )' ';
  helpstr[84] = (char )'h';
  helpstr[85] = (char )' ';
  helpstr[86] = (char )' ';
  helpstr[87] = (char )'P';
  helpstr[88] = (char )'a';
  helpstr[89] = (char )'r';
  helpstr[90] = (char )'e';
  helpstr[91] = (char )'n';
  helpstr[92] = (char )'t';
  helpstr[93] = (char )'%';
  helpstr[94] = (char )'-';
  helpstr[95] = (char )'1';
  helpstr[96] = (char )'2';
  helpstr[97] = (char )'c';
  helpstr[98] = (char )'~';
  helpstr[99] = (char )' ';
  helpstr[100] = (char )'`';
  helpstr[101] = (char )' ';
  helpstr[102] = (char )'@';
  helpstr[103] = (char )' ';
  helpstr[104] = (char )'-';
  helpstr[105] = (char )' ';
  helpstr[106] = (char )' ';
  helpstr[107] = (char )'~';
  helpstr[108] = (char )',';
  helpstr[109] = (char )' ';
  helpstr[110] = (char )'/';
  helpstr[111] = (char )',';
  helpstr[112] = (char )' ';
  helpstr[113] = (char )'s';
  helpstr[114] = (char )'t';
  helpstr[115] = (char )'a';
  helpstr[116] = (char )'r';
  helpstr[117] = (char )'t';
  helpstr[118] = (char )',';
  helpstr[119] = (char )' ';
  helpstr[120] = (char )'p';
  helpstr[121] = (char )'r';
  helpstr[122] = (char )'e';
  helpstr[123] = (char )'v';
  helpstr[124] = (char )'\n';
  helpstr[125] = (char )'5';
  helpstr[126] = (char )'R';
  helpstr[127] = (char )'e';
  helpstr[128] = (char )'t';
  helpstr[129] = (char )' ';
  helpstr[130] = (char )'R';
  helpstr[131] = (char )'t';
  helpstr[132] = (char )' ';
  helpstr[133] = (char )'l';
  helpstr[134] = (char )' ';
  helpstr[135] = (char )' ';
  helpstr[136] = (char )'O';
  helpstr[137] = (char )'p';
  helpstr[138] = (char )'e';
  helpstr[139] = (char )'n';
  helpstr[140] = (char )'%';
  helpstr[141] = (char )'-';
  helpstr[142] = (char )'2';
  helpstr[143] = (char )'0';
  helpstr[144] = (char )'c';
  helpstr[145] = (char )'\'';
  helpstr[146] = (char )' ';
  helpstr[147] = (char )' ';
  helpstr[148] = (char )'F';
  helpstr[149] = (char )'i';
  helpstr[150] = (char )'r';
  helpstr[151] = (char )'s';
  helpstr[152] = (char )'t';
  helpstr[153] = (char )' ';
  helpstr[154] = (char )'f';
  helpstr[155] = (char )'i';
  helpstr[156] = (char )'l';
  helpstr[157] = (char )'e';
  helpstr[158] = (char )'/';
  helpstr[159] = (char )'m';
  helpstr[160] = (char )'a';
  helpstr[161] = (char )'t';
  helpstr[162] = (char )'c';
  helpstr[163] = (char )'h';
  helpstr[164] = (char )'\n';
  helpstr[165] = (char )'9';
  helpstr[166] = (char )'g';
  helpstr[167] = (char )' ';
  helpstr[168] = (char )'^';
  helpstr[169] = (char )'A';
  helpstr[170] = (char )' ';
  helpstr[171] = (char )' ';
  helpstr[172] = (char )'T';
  helpstr[173] = (char )'o';
  helpstr[174] = (char )'p';
  helpstr[175] = (char )'%';
  helpstr[176] = (char )'-';
  helpstr[177] = (char )'2';
  helpstr[178] = (char )'1';
  helpstr[179] = (char )'c';
  helpstr[180] = (char )'J';
  helpstr[181] = (char )' ';
  helpstr[182] = (char )' ';
  helpstr[183] = (char )'J';
  helpstr[184] = (char )'u';
  helpstr[185] = (char )'m';
  helpstr[186] = (char )'p';
  helpstr[187] = (char )' ';
  helpstr[188] = (char )'t';
  helpstr[189] = (char )'o';
  helpstr[190] = (char )' ';
  helpstr[191] = (char )'e';
  helpstr[192] = (char )'n';
  helpstr[193] = (char )'t';
  helpstr[194] = (char )'r';
  helpstr[195] = (char )'y';
  helpstr[196] = (char )'/';
  helpstr[197] = (char )'o';
  helpstr[198] = (char )'f';
  helpstr[199] = (char )'f';
  helpstr[200] = (char )'s';
  helpstr[201] = (char )'e';
  helpstr[202] = (char )'t';
  helpstr[203] = (char )'\n';
  helpstr[204] = (char )'9';
  helpstr[205] = (char )'G';
  helpstr[206] = (char )' ';
  helpstr[207] = (char )'^';
  helpstr[208] = (char )'E';
  helpstr[209] = (char )' ';
  helpstr[210] = (char )' ';
  helpstr[211] = (char )'E';
  helpstr[212] = (char )'n';
  helpstr[213] = (char )'d';
  helpstr[214] = (char )'%';
  helpstr[215] = (char )'-';
  helpstr[216] = (char )'2';
  helpstr[217] = (char )'0';
  helpstr[218] = (char )'c';
  helpstr[219] = (char )'^';
  helpstr[220] = (char )'J';
  helpstr[221] = (char )' ';
  helpstr[222] = (char )' ';
  helpstr[223] = (char )'T';
  helpstr[224] = (char )'o';
  helpstr[225] = (char )'g';
  helpstr[226] = (char )'g';
  helpstr[227] = (char )'l';
  helpstr[228] = (char )'e';
  helpstr[229] = (char )' ';
  helpstr[230] = (char )'a';
  helpstr[231] = (char )'u';
  helpstr[232] = (char )'t';
  helpstr[233] = (char )'o';
  helpstr[234] = (char )'-';
  helpstr[235] = (char )'a';
  helpstr[236] = (char )'d';
  helpstr[237] = (char )'v';
  helpstr[238] = (char )'a';
  helpstr[239] = (char )'n';
  helpstr[240] = (char )'c';
  helpstr[241] = (char )'e';
  helpstr[242] = (char )' ';
  helpstr[243] = (char )'o';
  helpstr[244] = (char )'n';
  helpstr[245] = (char )' ';
  helpstr[246] = (char )'o';
  helpstr[247] = (char )'p';
  helpstr[248] = (char )'e';
  helpstr[249] = (char )'n';
  helpstr[250] = (char )'\n';
  helpstr[251] = (char )'8';
  helpstr[252] = (char )'B';
  helpstr[253] = (char )' ';
  helpstr[254] = (char )'(';
  helpstr[255] = (char )',';
  helpstr[256] = (char )')';
  helpstr[257] = (char )' ';
  helpstr[258] = (char )' ';
  helpstr[259] = (char )'B';
  helpstr[260] = (char )'o';
  helpstr[261] = (char )'o';
  helpstr[262] = (char )'k';
  helpstr[263] = (char )'(';
  helpstr[264] = (char )'m';
  helpstr[265] = (char )'a';
  helpstr[266] = (char )'r';
  helpstr[267] = (char )'k';
  helpstr[268] = (char )')';
  helpstr[269] = (char )'%';
  helpstr[270] = (char )'-';
  helpstr[271] = (char )'1';
  helpstr[272] = (char )'1';
  helpstr[273] = (char )'c';
  helpstr[274] = (char )'b';
  helpstr[275] = (char )' ';
  helpstr[276] = (char )'^';
  helpstr[277] = (char )'/';
  helpstr[278] = (char )' ';
  helpstr[279] = (char )' ';
  helpstr[280] = (char )'S';
  helpstr[281] = (char )'e';
  helpstr[282] = (char )'l';
  helpstr[283] = (char )'e';
  helpstr[284] = (char )'c';
  helpstr[285] = (char )'t';
  helpstr[286] = (char )' ';
  helpstr[287] = (char )'b';
  helpstr[288] = (char )'o';
  helpstr[289] = (char )'o';
  helpstr[290] = (char )'k';
  helpstr[291] = (char )'m';
  helpstr[292] = (char )'a';
  helpstr[293] = (char )'r';
  helpstr[294] = (char )'k';
  helpstr[295] = (char )'\n';
  helpstr[296] = (char )'a';
  helpstr[297] = (char )'1';
  helpstr[298] = (char )'-';
  helpstr[299] = (char )'4';
  helpstr[300] = (char )' ';
  helpstr[301] = (char )' ';
  helpstr[302] = (char )'C';
  helpstr[303] = (char )'o';
  helpstr[304] = (char )'n';
  helpstr[305] = (char )'t';
  helpstr[306] = (char )'e';
  helpstr[307] = (char )'x';
  helpstr[308] = (char )'t';
  helpstr[309] = (char )'%';
  helpstr[310] = (char )'-';
  helpstr[311] = (char )'1';
  helpstr[312] = (char )'1';
  helpstr[313] = (char )'c';
  helpstr[314] = (char )'(';
  helpstr[315] = (char )'S';
  helpstr[316] = (char )'h';
  helpstr[317] = (char )')';
  helpstr[318] = (char )'T';
  helpstr[319] = (char )'a';
  helpstr[320] = (char )'b';
  helpstr[321] = (char )' ';
  helpstr[322] = (char )' ';
  helpstr[323] = (char )'C';
  helpstr[324] = (char )'y';
  helpstr[325] = (char )'c';
  helpstr[326] = (char )'l';
  helpstr[327] = (char )'e';
  helpstr[328] = (char )'/';
  helpstr[329] = (char )'n';
  helpstr[330] = (char )'e';
  helpstr[331] = (char )'w';
  helpstr[332] = (char )' ';
  helpstr[333] = (char )'c';
  helpstr[334] = (char )'o';
  helpstr[335] = (char )'n';
  helpstr[336] = (char )'t';
  helpstr[337] = (char )'e';
  helpstr[338] = (char )'x';
  helpstr[339] = (char )'t';
  helpstr[340] = (char )'\n';
  helpstr[341] = (char )'6';
  helpstr[342] = (char )'2';
  helpstr[343] = (char )'E';
  helpstr[344] = (char )'s';
  helpstr[345] = (char )'c';
  helpstr[346] = (char )' ';
  helpstr[347] = (char )'^';
  helpstr[348] = (char )'Q';
  helpstr[349] = (char )' ';
  helpstr[350] = (char )' ';
  helpstr[351] = (char )'Q';
  helpstr[352] = (char )'u';
  helpstr[353] = (char )'i';
  helpstr[354] = (char )'t';
  helpstr[355] = (char )'%';
  helpstr[356] = (char )'-';
  helpstr[357] = (char )'2';
  helpstr[358] = (char )'0';
  helpstr[359] = (char )'c';
  helpstr[360] = (char )'q';
  helpstr[361] = (char )' ';
  helpstr[362] = (char )' ';
  helpstr[363] = (char )'Q';
  helpstr[364] = (char )'u';
  helpstr[365] = (char )'i';
  helpstr[366] = (char )'t';
  helpstr[367] = (char )' ';
  helpstr[368] = (char )'c';
  helpstr[369] = (char )'o';
  helpstr[370] = (char )'n';
  helpstr[371] = (char )'t';
  helpstr[372] = (char )'e';
  helpstr[373] = (char )'x';
  helpstr[374] = (char )'t';
  helpstr[375] = (char )'\n';
  helpstr[376] = (char )'b';
  helpstr[377] = (char )'^';
  helpstr[378] = (char )'G';
  helpstr[379] = (char )' ';
  helpstr[380] = (char )' ';
  helpstr[381] = (char )'Q';
  helpstr[382] = (char )'u';
  helpstr[383] = (char )'i';
  helpstr[384] = (char )'t';
  helpstr[385] = (char )'C';
  helpstr[386] = (char )'D';
  helpstr[387] = (char )'%';
  helpstr[388] = (char )'-';
  helpstr[389] = (char )'1';
  helpstr[390] = (char )'8';
  helpstr[391] = (char )'c';
  helpstr[392] = (char )'Q';
  helpstr[393] = (char )' ';
  helpstr[394] = (char )' ';
  helpstr[395] = (char )'P';
  helpstr[396] = (char )'i';
  helpstr[397] = (char )'c';
  helpstr[398] = (char )'k';
  helpstr[399] = (char )'/';
  helpstr[400] = (char )'e';
  helpstr[401] = (char )'r';
  helpstr[402] = (char )'r';
  helpstr[403] = (char )',';
  helpstr[404] = (char )' ';
  helpstr[405] = (char )'q';
  helpstr[406] = (char )'u';
  helpstr[407] = (char )'i';
  helpstr[408] = (char )'t';
  helpstr[409] = (char )'\n';
  helpstr[410] = (char )'0';
  helpstr[411] = (char )'\n';
  helpstr[412] = (char )'1';
  helpstr[413] = (char )'F';
  helpstr[414] = (char )'I';
  helpstr[415] = (char )'L';
  helpstr[416] = (char )'T';
  helpstr[417] = (char )'E';
  helpstr[418] = (char )'R';
  helpstr[419] = (char )' ';
  helpstr[420] = (char )'&';
  helpstr[421] = (char )' ';
  helpstr[422] = (char )'P';
  helpstr[423] = (char )'R';
  helpstr[424] = (char )'O';
  helpstr[425] = (char )'M';
  helpstr[426] = (char )'P';
  helpstr[427] = (char )'T';
  helpstr[428] = (char )'\n';
  helpstr[429] = (char )'c';
  helpstr[430] = (char )'/';
  helpstr[431] = (char )' ';
  helpstr[432] = (char )' ';
  helpstr[433] = (char )'F';
  helpstr[434] = (char )'i';
  helpstr[435] = (char )'l';
  helpstr[436] = (char )'t';
  helpstr[437] = (char )'e';
  helpstr[438] = (char )'r';
  helpstr[439] = (char )'%';
  helpstr[440] = (char )'-';
  helpstr[441] = (char )'1';
  helpstr[442] = (char )'7';
  helpstr[443] = (char )'c';
  helpstr[444] = (char )'^';
  helpstr[445] = (char )'N';
  helpstr[446] = (char )' ';
  helpstr[447] = (char )' ';
  helpstr[448] = (char )'T';
  helpstr[449] = (char )'o';
  helpstr[450] = (char )'g';
  helpstr[451] = (char )'g';
  helpstr[452] = (char )'l';
  helpstr[453] = (char )'e';
  helpstr[454] = (char )' ';
  helpstr[455] = (char )'t';
  helpstr[456] = (char )'y';
  helpstr[457] = (char )'p';
  helpstr[458] = (char )'e';
  helpstr[459] = (char )'-';
  helpstr[460] = (char )'t';
  helpstr[461] = (char )'o';
  helpstr[462] = (char )'-';
  helpstr[463] = (char )'n';
  helpstr[464] = (char )'a';
  helpstr[465] = (char )'v';
  helpstr[466] = (char )'\n';
  helpstr[467] = (char )'a';
  helpstr[468] = (char )'E';
  helpstr[469] = (char )'s';
  helpstr[470] = (char )'c';
  helpstr[471] = (char )' ';
  helpstr[472] = (char )' ';
  helpstr[473] = (char )'E';
  helpstr[474] = (char )'x';
  helpstr[475] = (char )'i';
  helpstr[476] = (char )'t';
  helpstr[477] = (char )' ';
  helpstr[478] = (char )'p';
  helpstr[479] = (char )'r';
  helpstr[480] = (char )'o';
  helpstr[481] = (char )'m';
  helpstr[482] = (char )'p';
  helpstr[483] = (char )'t';
  helpstr[484] = (char )'%';
  helpstr[485] = (char )'-';
  helpstr[486] = (char )'1';
  helpstr[487] = (char )'2';
  helpstr[488] = (char )'c';
  helpstr[489] = (char )'^';
  helpstr[490] = (char )'L';
  helpstr[491] = (char )' ';
  helpstr[492] = (char )' ';
  helpstr[493] = (char )'T';
  helpstr[494] = (char )'o';
  helpstr[495] = (char )'g';
  helpstr[496] = (char )'g';
  helpstr[497] = (char )'l';
  helpstr[498] = (char )'e';
  helpstr[499] = (char )' ';
  helpstr[500] = (char )'l';
  helpstr[501] = (char )'a';
  helpstr[502] = (char )'s';
  helpstr[503] = (char )'t';
  helpstr[504] = (char )' ';
  helpstr[505] = (char )'f';
  helpstr[506] = (char )'i';
  helpstr[507] = (char )'l';
  helpstr[508] = (char )'t';
  helpstr[509] = (char )'e';
  helpstr[510] = (char )'r';
  helpstr[511] = (char )'\n';
  helpstr[512] = (char )'c';
  helpstr[513] = (char )'.';
  helpstr[514] = (char )' ';
  helpstr[515] = (char )' ';
  helpstr[516] = (char )'T';
  helpstr[517] = (char )'o';
  helpstr[518] = (char )'g';
  helpstr[519] = (char )'g';
  helpstr[520] = (char )'l';
  helpstr[521] = (char )'e';
  helpstr[522] = (char )' ';
  helpstr[523] = (char )'h';
  helpstr[524] = (char )'i';
  helpstr[525] = (char )'d';
  helpstr[526] = (char )'d';
  helpstr[527] = (char )'e';
  helpstr[528] = (char )'n';
  helpstr[529] = (char )'%';
  helpstr[530] = (char )'-';
  helpstr[531] = (char )'5';
  helpstr[532] = (char )'c';
  helpstr[533] = (char )'A';
  helpstr[534] = (char )'l';
  helpstr[535] = (char )'t';
  helpstr[536] = (char )'+';
  helpstr[537] = (char )'E';
  helpstr[538] = (char )'s';
  helpstr[539] = (char )'c';
  helpstr[540] = (char )' ';
  helpstr[541] = (char )' ';
  helpstr[542] = (char )'U';
  helpstr[543] = (char )'n';
  helpstr[544] = (char )'f';
  helpstr[545] = (char )'i';
  helpstr[546] = (char )'l';
  helpstr[547] = (char )'t';
  helpstr[548] = (char )'e';
  helpstr[549] = (char )'r';
  helpstr[550] = (char )',';
  helpstr[551] = (char )' ';
  helpstr[552] = (char )'q';
  helpstr[553] = (char )'u';
  helpstr[554] = (char )'i';
  helpstr[555] = (char )'t';
  helpstr[556] = (char )' ';
  helpstr[557] = (char )'c';
  helpstr[558] = (char )'o';
  helpstr[559] = (char )'n';
  helpstr[560] = (char )'t';
  helpstr[561] = (char )'e';
  helpstr[562] = (char )'x';
  helpstr[563] = (char )'t';
  helpstr[564] = (char )'\n';
  helpstr[565] = (char )'0';
  helpstr[566] = (char )'\n';
  helpstr[567] = (char )'1';
  helpstr[568] = (char )'F';
  helpstr[569] = (char )'I';
  helpstr[570] = (char )'L';
  helpstr[571] = (char )'E';
  helpstr[572] = (char )'S';
  helpstr[573] = (char )'\n';
  helpstr[574] = (char )'9';
  helpstr[575] = (char )'o';
  helpstr[576] = (char )' ';
  helpstr[577] = (char )'^';
  helpstr[578] = (char )'O';
  helpstr[579] = (char )' ';
  helpstr[580] = (char )' ';
  helpstr[581] = (char )'O';
  helpstr[582] = (char )'p';
  helpstr[583] = (char )'e';
  helpstr[584] = (char )'n';
  helpstr[585] = (char )' ';
  helpstr[586] = (char )'w';
  helpstr[587] = (char )'i';
  helpstr[588] = (char )'t';
  helpstr[589] = (char )'h';
  helpstr[590] = (char )'%';
  helpstr[591] = (char )'-';
  helpstr[592] = (char )'1';
  helpstr[593] = (char )'5';
  helpstr[594] = (char )'c';
  helpstr[595] = (char )'n';
  helpstr[596] = (char )' ';
  helpstr[597] = (char )' ';
  helpstr[598] = (char )'C';
  helpstr[599] = (char )'r';
  helpstr[600] = (char )'e';
  helpstr[601] = (char )'a';
  helpstr[602] = (char )'t';
  helpstr[603] = (char )'e';
  helpstr[604] = (char )' ';
  helpstr[605] = (char )'n';
  helpstr[606] = (char )'e';
  helpstr[607] = (char )'w';
  helpstr[608] = (char )'/';
  helpstr[609] = (char )'l';
  helpstr[610] = (char )'i';
  helpstr[611] = (char )'n';
  helpstr[612] = (char )'k';
  helpstr[613] = (char )'\n';
  helpstr[614] = (char )'9';
  helpstr[615] = (char )'f';
  helpstr[616] = (char )' ';
  helpstr[617] = (char )'^';
  helpstr[618] = (char )'F';
  helpstr[619] = (char )' ';
  helpstr[620] = (char )' ';
  helpstr[621] = (char )'F';
  helpstr[622] = (char )'i';
  helpstr[623] = (char )'l';
  helpstr[624] = (char )'e';
  helpstr[625] = (char )' ';
  helpstr[626] = (char )'s';
  helpstr[627] = (char )'t';
  helpstr[628] = (char )'a';
  helpstr[629] = (char )'t';
  helpstr[630] = (char )'s';
  helpstr[631] = (char )'%';
  helpstr[632] = (char )'-';
  helpstr[633] = (char )'1';
  helpstr[634] = (char )'4';
  helpstr[635] = (char )'c';
  helpstr[636] = (char )'d';
  helpstr[637] = (char )' ';
  helpstr[638] = (char )' ';
  helpstr[639] = (char )'D';
  helpstr[640] = (char )'e';
  helpstr[641] = (char )'t';
  helpstr[642] = (char )'a';
  helpstr[643] = (char )'i';
  helpstr[644] = (char )'l';
  helpstr[645] = (char )' ';
  helpstr[646] = (char )'m';
  helpstr[647] = (char )'o';
  helpstr[648] = (char )'d';
  helpstr[649] = (char )'e';
  helpstr[650] = (char )' ';
  helpstr[651] = (char )'t';
  helpstr[652] = (char )'o';
  helpstr[653] = (char )'g';
  helpstr[654] = (char )'g';
  helpstr[655] = (char )'l';
  helpstr[656] = (char )'e';
  helpstr[657] = (char )'\n';
  helpstr[658] = (char )'b';
  helpstr[659] = (char )'^';
  helpstr[660] = (char )'R';
  helpstr[661] = (char )' ';
  helpstr[662] = (char )' ';
  helpstr[663] = (char )'R';
  helpstr[664] = (char )'e';
  helpstr[665] = (char )'n';
  helpstr[666] = (char )'a';
  helpstr[667] = (char )'m';
  helpstr[668] = (char )'e';
  helpstr[669] = (char )'/';
  helpstr[670] = (char )'d';
  helpstr[671] = (char )'u';
  helpstr[672] = (char )'p';
  helpstr[673] = (char )'%';
  helpstr[674] = (char )'-';
  helpstr[675] = (char )'1';
  helpstr[676] = (char )'4';
  helpstr[677] = (char )'c';
  helpstr[678] = (char )'r';
  helpstr[679] = (char )' ';
  helpstr[680] = (char )' ';
  helpstr[681] = (char )'B';
  helpstr[682] = (char )'a';
  helpstr[683] = (char )'t';
  helpstr[684] = (char )'c';
  helpstr[685] = (char )'h';
  helpstr[686] = (char )' ';
  helpstr[687] = (char )'r';
  helpstr[688] = (char )'e';
  helpstr[689] = (char )'n';
  helpstr[690] = (char )'a';
  helpstr[691] = (char )'m';
  helpstr[692] = (char )'e';
  helpstr[693] = (char )'\n';
  helpstr[694] = (char )'c';
  helpstr[695] = (char )'z';
  helpstr[696] = (char )' ';
  helpstr[697] = (char )' ';
  helpstr[698] = (char )'A';
  helpstr[699] = (char )'r';
  helpstr[700] = (char )'c';
  helpstr[701] = (char )'h';
  helpstr[702] = (char )'i';
  helpstr[703] = (char )'v';
  helpstr[704] = (char )'e';
  helpstr[705] = (char )'%';
  helpstr[706] = (char )'-';
  helpstr[707] = (char )'1';
  helpstr[708] = (char )'7';
  helpstr[709] = (char )'c';
  helpstr[710] = (char )'e';
  helpstr[711] = (char )' ';
  helpstr[712] = (char )' ';
  helpstr[713] = (char )'E';
  helpstr[714] = (char )'d';
  helpstr[715] = (char )'i';
  helpstr[716] = (char )'t';
  helpstr[717] = (char )' ';
  helpstr[718] = (char )'f';
  helpstr[719] = (char )'i';
  helpstr[720] = (char )'l';
  helpstr[721] = (char )'e';
  helpstr[722] = (char )'\n';
  helpstr[723] = (char )'c';
  helpstr[724] = (char )'*';
  helpstr[725] = (char )' ';
  helpstr[726] = (char )' ';
  helpstr[727] = (char )'T';
  helpstr[728] = (char )'o';
  helpstr[729] = (char )'g';
  helpstr[730] = (char )'g';
  helpstr[731] = (char )'l';
  helpstr[732] = (char )'e';
  helpstr[733] = (char )' ';
  helpstr[734] = (char )'e';
  helpstr[735] = (char )'x';
  helpstr[736] = (char )'e';
  helpstr[737] = (char )'%';
  helpstr[738] = (char )'-';
  helpstr[739] = (char )'1';
  helpstr[740] = (char )'4';
  helpstr[741] = (char )'c';
  helpstr[742] = (char )'>';
  helpstr[743] = (char )' ';
  helpstr[744] = (char )' ';
  helpstr[745] = (char )'E';
  helpstr[746] = (char )'x';
  helpstr[747] = (char )'p';
  helpstr[748] = (char )'o';
  helpstr[749] = (char )'r';
  helpstr[750] = (char )'t';
  helpstr[751] = (char )' ';
  helpstr[752] = (char )'l';
  helpstr[753] = (char )'i';
  helpstr[754] = (char )'s';
  helpstr[755] = (char )'t';
  helpstr[756] = (char )'\n';
  helpstr[757] = (char )'6';
  helpstr[758] = (char )'S';
  helpstr[759] = (char )'p';
  helpstr[760] = (char )'a';
  helpstr[761] = (char )'c';
  helpstr[762] = (char )'e';
  helpstr[763] = (char )' ';
  helpstr[764] = (char )'+';
  helpstr[765] = (char )' ';
  helpstr[766] = (char )' ';
  helpstr[767] = (char )'(';
  helpstr[768] = (char )'U';
  helpstr[769] = (char )'n';
  helpstr[770] = (char )')';
  helpstr[771] = (char )'s';
  helpstr[772] = (char )'e';
  helpstr[773] = (char )'l';
  helpstr[774] = (char )'e';
  helpstr[775] = (char )'c';
  helpstr[776] = (char )'t';
  helpstr[777] = (char )'%';
  helpstr[778] = (char )'-';
  helpstr[779] = (char )'1';
  helpstr[780] = (char )'2';
  helpstr[781] = (char )'c';
  helpstr[782] = (char )'m';
  helpstr[783] = (char )'-';
  helpstr[784] = (char )'m';
  helpstr[785] = (char )' ';
  helpstr[786] = (char )' ';
  helpstr[787] = (char )'S';
  helpstr[788] = (char )'e';
  helpstr[789] = (char )'l';
  helpstr[790] = (char )'e';
  helpstr[791] = (char )'c';
  helpstr[792] = (char )'t';
  helpstr[793] = (char )' ';
  helpstr[794] = (char )'r';
  helpstr[795] = (char )'a';
  helpstr[796] = (char )'n';
  helpstr[797] = (char )'g';
  helpstr[798] = (char )'e';
  helpstr[799] = (char )'/';
  helpstr[800] = (char )'c';
  helpstr[801] = (char )'l';
  helpstr[802] = (char )'e';
  helpstr[803] = (char )'a';
  helpstr[804] = (char )'r';
  helpstr[805] = (char )'\n';
  helpstr[806] = (char )'c';
  helpstr[807] = (char )'a';
  helpstr[808] = (char )' ';
  helpstr[809] = (char )' ';
  helpstr[810] = (char )'S';
  helpstr[811] = (char )'e';
  helpstr[812] = (char )'l';
  helpstr[813] = (char )'e';
  helpstr[814] = (char )'c';
  helpstr[815] = (char )'t';
  helpstr[816] = (char )' ';
  helpstr[817] = (char )'a';
  helpstr[818] = (char )'l';
  helpstr[819] = (char )'l';
  helpstr[820] = (char )'%';
  helpstr[821] = (char )'-';
  helpstr[822] = (char )'1';
  helpstr[823] = (char )'4';
  helpstr[824] = (char )'c';
  helpstr[825] = (char )'A';
  helpstr[826] = (char )' ';
  helpstr[827] = (char )' ';
  helpstr[828] = (char )'I';
  helpstr[829] = (char )'n';
  helpstr[830] = (char )'v';
  helpstr[831] = (char )'e';
  helpstr[832] = (char )'r';
  helpstr[833] = (char )'t';
  helpstr[834] = (char )' ';
  helpstr[835] = (char )'s';
  helpstr[836] = (char )'e';
  helpstr[837] = (char )'l';
  helpstr[838] = (char )'\n';
  helpstr[839] = (char )'9';
  helpstr[840] = (char )'p';
  helpstr[841] = (char )' ';
  helpstr[842] = (char )'^';
  helpstr[843] = (char )'P';
  helpstr[844] = (char )' ';
  helpstr[845] = (char )' ';
  helpstr[846] = (char )'C';
  helpstr[847] = (char )'o';
  helpstr[848] = (char )'p';
  helpstr[849] = (char )'y';
  helpstr[850] = (char )' ';
  helpstr[851] = (char )'h';
  helpstr[852] = (char )'e';
  helpstr[853] = (char )'r';
  helpstr[854] = (char )'e';
  helpstr[855] = (char )'%';
  helpstr[856] = (char )'-';
  helpstr[857] = (char )'1';
  helpstr[858] = (char )'2';
  helpstr[859] = (char )'c';
  helpstr[860] = (char )'w';
  helpstr[861] = (char )' ';
  helpstr[862] = (char )'^';
  helpstr[863] = (char )'W';
  helpstr[864] = (char )' ';
  helpstr[865] = (char )' ';
  helpstr[866] = (char )'C';
  helpstr[867] = (char )'p';
  helpstr[868] = (char )'/';
  helpstr[869] = (char )'m';
  helpstr[870] = (char )'v';
  helpstr[871] = (char )' ';
  helpstr[872] = (char )'s';
  helpstr[873] = (char )'e';
  helpstr[874] = (char )'l';
  helpstr[875] = (char )' ';
  helpstr[876] = (char )'a';
  helpstr[877] = (char )'s';
  helpstr[878] = (char )'\n';
  helpstr[879] = (char )'9';
  helpstr[880] = (char )'v';
  helpstr[881] = (char )' ';
  helpstr[882] = (char )'^';
  helpstr[883] = (char )'V';
  helpstr[884] = (char )' ';
  helpstr[885] = (char )' ';
  helpstr[886] = (char )'M';
  helpstr[887] = (char )'o';
  helpstr[888] = (char )'v';
  helpstr[889] = (char )'e';
  helpstr[890] = (char )' ';
  helpstr[891] = (char )'h';
  helpstr[892] = (char )'e';
  helpstr[893] = (char )'r';
  helpstr[894] = (char )'e';
  helpstr[895] = (char )'%';
  helpstr[896] = (char )'-';
  helpstr[897] = (char )'1';
  helpstr[898] = (char )'5';
  helpstr[899] = (char )'c';
  helpstr[900] = (char )'E';
  helpstr[901] = (char )' ';
  helpstr[902] = (char )' ';
  helpstr[903] = (char )'E';
  helpstr[904] = (char )'d';
  helpstr[905] = (char )'i';
  helpstr[906] = (char )'t';
  helpstr[907] = (char )' ';
  helpstr[908] = (char )'s';
  helpstr[909] = (char )'e';
  helpstr[910] = (char )'l';
  helpstr[911] = (char )' ';
  helpstr[912] = (char )'l';
  helpstr[913] = (char )'i';
  helpstr[914] = (char )'s';
  helpstr[915] = (char )'t';
  helpstr[916] = (char )'\n';
  helpstr[917] = (char )'9';
  helpstr[918] = (char )'x';
  helpstr[919] = (char )' ';
  helpstr[920] = (char )'^';
  helpstr[921] = (char )'X';
  helpstr[922] = (char )' ';
  helpstr[923] = (char )' ';
  helpstr[924] = (char )'D';
  helpstr[925] = (char )'e';
  helpstr[926] = (char )'l';
  helpstr[927] = (char )'e';
  helpstr[928] = (char )'t';
  helpstr[929] = (char )'e';
  helpstr[930] = (char )'%';
  helpstr[931] = (char )'-';
  helpstr[932] = (char )'1';
  helpstr[933] = (char )'6';
  helpstr[934] = (char )'c';
  helpstr[935] = (char )'E';
  helpstr[936] = (char )'s';
  helpstr[937] = (char )'c';
  helpstr[938] = (char )' ';
  helpstr[939] = (char )' ';
  helpstr[940] = (char )'S';
  helpstr[941] = (char )'e';
  helpstr[942] = (char )'n';
  helpstr[943] = (char )'d';
  helpstr[944] = (char )' ';
  helpstr[945] = (char )'t';
  helpstr[946] = (char )'o';
  helpstr[947] = (char )' ';
  helpstr[948] = (char )'F';
  helpstr[949] = (char )'I';
  helpstr[950] = (char )'F';
  helpstr[951] = (char )'O';
  helpstr[952] = (char )'\n';
  helpstr[953] = (char )'0';
  helpstr[954] = (char )'\n';
  helpstr[955] = (char )'1';
  helpstr[956] = (char )'M';
  helpstr[957] = (char )'I';
  helpstr[958] = (char )'S';
  helpstr[959] = (char )'C';
  helpstr[960] = (char )'\n';
  helpstr[961] = (char )'8';
  helpstr[962] = (char )'A';
  helpstr[963] = (char )'l';
  helpstr[964] = (char )'t';
  helpstr[965] = (char )' ';
  helpstr[966] = (char )';';
  helpstr[967] = (char )' ';
  helpstr[968] = (char )' ';
  helpstr[969] = (char )'S';
  helpstr[970] = (char )'e';
  helpstr[971] = (char )'l';
  helpstr[972] = (char )'e';
  helpstr[973] = (char )'c';
  helpstr[974] = (char )'t';
  helpstr[975] = (char )' ';
  helpstr[976] = (char )'p';
  helpstr[977] = (char )'l';
  helpstr[978] = (char )'u';
  helpstr[979] = (char )'g';
  helpstr[980] = (char )'i';
  helpstr[981] = (char )'n';
  helpstr[982] = (char )'%';
  helpstr[983] = (char )'-';
  helpstr[984] = (char )'1';
  helpstr[985] = (char )'1';
  helpstr[986] = (char )'c';
  helpstr[987] = (char )'=';
  helpstr[988] = (char )' ';
  helpstr[989] = (char )' ';
  helpstr[990] = (char )'L';
  helpstr[991] = (char )'a';
  helpstr[992] = (char )'u';
  helpstr[993] = (char )'n';
  helpstr[994] = (char )'c';
  helpstr[995] = (char )'h';
  helpstr[996] = (char )' ';
  helpstr[997] = (char )'a';
  helpstr[998] = (char )'p';
  helpstr[999] = (char )'p';
  helpstr[1000] = (char )'\n';
  helpstr[1001] = (char )'9';
  helpstr[1002] = (char )'!';
  helpstr[1003] = (char )' ';
  helpstr[1004] = (char )'^';
  helpstr[1005] = (char )']';
  helpstr[1006] = (char )' ';
  helpstr[1007] = (char )' ';
  helpstr[1008] = (char )'S';
  helpstr[1009] = (char )'h';
  helpstr[1010] = (char )'e';
  helpstr[1011] = (char )'l';
  helpstr[1012] = (char )'l';
  helpstr[1013] = (char )'%';
  helpstr[1014] = (char )'-';
  helpstr[1015] = (char )'1';
  helpstr[1016] = (char )'9';
  helpstr[1017] = (char )'c';
  helpstr[1018] = (char )']';
  helpstr[1019] = (char )' ';
  helpstr[1020] = (char )' ';
  helpstr[1021] = (char )'C';
  helpstr[1022] = (char )'m';
  helpstr[1023] = (char )'d';
  helpstr[1024] = (char )' ';
  helpstr[1025] = (char )'p';
  helpstr[1026] = (char )'r';
  helpstr[1027] = (char )'o';
  helpstr[1028] = (char )'m';
  helpstr[1029] = (char )'p';
  helpstr[1030] = (char )'t';
  helpstr[1031] = (char )'\n';
  helpstr[1032] = (char )'c';
  helpstr[1033] = (char )'c';
  helpstr[1034] = (char )' ';
  helpstr[1035] = (char )' ';
  helpstr[1036] = (char )'C';
  helpstr[1037] = (char )'o';
  helpstr[1038] = (char )'n';
  helpstr[1039] = (char )'n';
  helpstr[1040] = (char )'e';
  helpstr[1041] = (char )'c';
  helpstr[1042] = (char )'t';
  helpstr[1043] = (char )' ';
  helpstr[1044] = (char )'r';
  helpstr[1045] = (char )'e';
  helpstr[1046] = (char )'m';
  helpstr[1047] = (char )'o';
  helpstr[1048] = (char )'t';
  helpstr[1049] = (char )'e';
  helpstr[1050] = (char )'%';
  helpstr[1051] = (char )'-';
  helpstr[1052] = (char )'1';
  helpstr[1053] = (char )'0';
  helpstr[1054] = (char )'c';
  helpstr[1055] = (char )'u';
  helpstr[1056] = (char )' ';
  helpstr[1057] = (char )' ';
  helpstr[1058] = (char )'U';
  helpstr[1059] = (char )'n';
  helpstr[1060] = (char )'m';
  helpstr[1061] = (char )'o';
  helpstr[1062] = (char )'u';
  helpstr[1063] = (char )'n';
  helpstr[1064] = (char )'t';
  helpstr[1065] = (char )' ';
  helpstr[1066] = (char )'r';
  helpstr[1067] = (char )'e';
  helpstr[1068] = (char )'m';
  helpstr[1069] = (char )'o';
  helpstr[1070] = (char )'t';
  helpstr[1071] = (char )'e';
  helpstr[1072] = (char )'/';
  helpstr[1073] = (char )'a';
  helpstr[1074] = (char )'r';
  helpstr[1075] = (char )'c';
  helpstr[1076] = (char )'h';
  helpstr[1077] = (char )'i';
  helpstr[1078] = (char )'v';
  helpstr[1079] = (char )'e';
  helpstr[1080] = (char )'\n';
  helpstr[1081] = (char )'9';
  helpstr[1082] = (char )'t';
  helpstr[1083] = (char )' ';
  helpstr[1084] = (char )'^';
  helpstr[1085] = (char )'T';
  helpstr[1086] = (char )' ';
  helpstr[1087] = (char )' ';
  helpstr[1088] = (char )'S';
  helpstr[1089] = (char )'o';
  helpstr[1090] = (char )'r';
  helpstr[1091] = (char )'t';
  helpstr[1092] = (char )' ';
  helpstr[1093] = (char )'t';
  helpstr[1094] = (char )'o';
  helpstr[1095] = (char )'g';
  helpstr[1096] = (char )'g';
  helpstr[1097] = (char )'l';
  helpstr[1098] = (char )'e';
  helpstr[1099] = (char )'s';
  helpstr[1100] = (char )'%';
  helpstr[1101] = (char )'-';
  helpstr[1102] = (char )'1';
  helpstr[1103] = (char )'2';
  helpstr[1104] = (char )'c';
  helpstr[1105] = (char )'s';
  helpstr[1106] = (char )' ';
  helpstr[1107] = (char )' ';
  helpstr[1108] = (char )'M';
  helpstr[1109] = (char )'a';
  helpstr[1110] = (char )'n';
  helpstr[1111] = (char )'a';
  helpstr[1112] = (char )'g';
  helpstr[1113] = (char )'e';
  helpstr[1114] = (char )' ';
  helpstr[1115] = (char )'s';
  helpstr[1116] = (char )'e';
  helpstr[1117] = (char )'s';
  helpstr[1118] = (char )'s';
  helpstr[1119] = (char )'i';
  helpstr[1120] = (char )'o';
  helpstr[1121] = (char )'n';
  helpstr[1122] = (char )'\n';
  helpstr[1123] = (char )'c';
  helpstr[1124] = (char )'T';
  helpstr[1125] = (char )' ';
  helpstr[1126] = (char )' ';
  helpstr[1127] = (char )'S';
  helpstr[1128] = (char )'e';
  helpstr[1129] = (char )'t';
  helpstr[1130] = (char )' ';
  helpstr[1131] = (char )'t';
  helpstr[1132] = (char )'i';
  helpstr[1133] = (char )'m';
  helpstr[1134] = (char )'e';
  helpstr[1135] = (char )' ';
  helpstr[1136] = (char )'t';
  helpstr[1137] = (char )'y';
  helpstr[1138] = (char )'p';
  helpstr[1139] = (char )'e';
  helpstr[1140] = (char )'%';
  helpstr[1141] = (char )'-';
  helpstr[1142] = (char )'1';
  helpstr[1143] = (char )'1';
  helpstr[1144] = (char )'c';
  helpstr[1145] = (char )'0';
  helpstr[1146] = (char )' ';
  helpstr[1147] = (char )' ';
  helpstr[1148] = (char )'L';
  helpstr[1149] = (char )'o';
  helpstr[1150] = (char )'c';
  helpstr[1151] = (char )'k';
  helpstr[1152] = (char )'\n';
  helpstr[1153] = (char )'b';
  helpstr[1154] = (char )'^';
  helpstr[1155] = (char )'L';
  helpstr[1156] = (char )' ';
  helpstr[1157] = (char )' ';
  helpstr[1158] = (char )'R';
  helpstr[1159] = (char )'e';
  helpstr[1160] = (char )'d';
  helpstr[1161] = (char )'r';
  helpstr[1162] = (char )'a';
  helpstr[1163] = (char )'w';
  helpstr[1164] = (char )'%';
  helpstr[1165] = (char )'-';
  helpstr[1166] = (char )'1';
  helpstr[1167] = (char )'8';
  helpstr[1168] = (char )'c';
  helpstr[1169] = (char )'?';
  helpstr[1170] = (char )' ';
  helpstr[1171] = (char )' ';
  helpstr[1172] = (char )'H';
  helpstr[1173] = (char )'e';
  helpstr[1174] = (char )'l';
  helpstr[1175] = (char )'p';
  helpstr[1176] = (char )',';
  helpstr[1177] = (char )' ';
  helpstr[1178] = (char )'c';
  helpstr[1179] = (char )'o';
  helpstr[1180] = (char )'n';
  helpstr[1181] = (char )'f';
  helpstr[1182] = (char )'\n';
  helpstr[1183] = (char )'\000';
  tmp = create_tmp_file();
  fd = tmp;
  if (fd == -1) {
    return;
  }
  dprintf(fd, (char const   * __restrict  )"  |V\\_\n  /. \\\\\n (;^; ||\n   /___3\n  (___n))\n");
  tmp___0 = xgetenv(env_cfg[12], (char *)((void *)0));
  prog = tmp___0;
  if (prog) {
    get_output(prog, (char *)((void *)0), (char *)((void *)0), fd, (_Bool)1, (_Bool)0);
  }
  end = (char const   *)(helpstr);
  start = end;
  while (*end) {
    if ((int const   )*end == 10) {
      tmp___1 = xchartohex((uchar_t )*start);
      snprintf((char * __restrict  )(g_buf), (size_t )(4096 + (256 << 1)), (char const   * __restrict  )"%*c%.*s",
               (int )tmp___1, ' ', (int )(end - start), start + 1);
      dprintf(fd, (char const   * __restrict  )(g_buf), ' ');
      start = end + 1;
    }
    end ++;
  }
  dprintf(fd, (char const   * __restrict  )"\nLOCATIONS\n");
  i = (uchar_t )0;
  while ((int )i < 4) {
    if (g_ctx[i].c_cfg.ctxactive) {
      dprintf(fd, (char const   * __restrict  )" %u: %s\n", (int )i + 1, g_ctx[i].c_path);
    }
    i = (uchar_t )((int )i + 1);
  }
  tmp___2 = get_fs_info(path, (uchar_t )0);
  tmp___3 = coolsize((off_t )tmp___2);
  dprintf(fd, (char const   * __restrict  )"\nVOLUME: avail:%s ", tmp___3);
  tmp___4 = get_fs_info(path, (uchar_t )1);
  tmp___5 = coolsize((off_t )tmp___4);
  dprintf(fd, (char const   * __restrict  )"used:%s ", tmp___5);
  tmp___6 = get_fs_info(path, (uchar_t )2);
  tmp___7 = coolsize((off_t )tmp___6);
  dprintf(fd, (char const   * __restrict  )"size:%s\n\n", tmp___7);
  if (bookmark) {
    dprintf(fd, (char const   * __restrict  )"BOOKMARKS\n");
    printkv(bookmark, fd, maxbm, (uchar_t )1);
    dprintf(fd, (char const   * __restrict  )"\n");
  }
  if (plug) {
    dprintf(fd, (char const   * __restrict  )"PLUGIN KEYS\n");
    printkv(plug, fd, maxplug, (uchar_t )2);
    dprintf(fd, (char const   * __restrict  )"\n");
  }
  i___0 = (uchar_t )3;
  while ((int )i___0 <= 13) {
    tmp___8 = getenv((char const   *)env_cfg[i___0]);
    start = (char const   *)tmp___8;
    if (start) {
      dprintf(fd, (char const   * __restrict  )"%s: %s\n", env_cfg[i___0], start);
    }
    i___0 = (uchar_t )((int )i___0 + 1);
  }
  if (selpath) {
    dprintf(fd, (char const   * __restrict  )"SELECTION FILE: %s\n", selpath);
  }
  dprintf(fd, (char const   * __restrict  )"\nv%s\n%s\n", "4.6", "BSD 2-Clause\nhttps://github.com/jarun/nnn");
  close(fd);
  spawn(pager, g_tmpfpath, (char *)((void *)0), (char *)((void *)0), (ushort_t )265);
  unlink((char const   *)(g_tmpfpath));
  return;
}
}
static void setexports(void) 
{ 
  char dvar[3] ;
  char fvar[3] ;
  uchar_t i ;
  char *tmp ;

  {
  dvar[0] = (char )'d';
  dvar[1] = (char )'0';
  dvar[2] = (char )'\000';
  fvar[0] = (char )'f';
  fvar[1] = (char )'0';
  fvar[2] = (char )'\000';
  if (ndents) {
    setenv((char const   *)envs[4], (char const   *)(pdents + cur)->name, 1);
    xstrsncpy((char * __restrict  )(g_ctx[cfg.curctx].c_name), (char const   * __restrict  )(pdents + cur)->name,
              (size_t )256);
  } else
  if (g_ctx[cfg.curctx].c_name[0]) {
    g_ctx[cfg.curctx].c_name[0] = (char )'\000';
  }
  i = (uchar_t )0;
  while ((int )i < 4) {
    if (g_ctx[i].c_cfg.ctxactive) {
      fvar[1] = (char )(49 + (int )i);
      dvar[1] = fvar[1];
      setenv((char const   *)(dvar), (char const   *)(g_ctx[i].c_path), 1);
      if (g_ctx[i].c_name[0]) {
        mkpath((char const   *)(g_ctx[i].c_path), (char const   *)(g_ctx[i].c_name),
               g_buf);
        setenv((char const   *)(fvar), (char const   *)(g_buf), 1);
      }
    }
    i = (uchar_t )((int )i + 1);
  }
  tmp = xitoa(cfg.showhidden);
  setenv("NNN_INCLUDE_HIDDEN", (char const   *)tmp, 1);
  return;
}
}
static void run_cmd_as_plugin(char const   *file , char *runfile , uchar_t flags ) 
{ 
  size_t len ;
  _Bool tmp ;

  {
  xstrsncpy((char * __restrict  )(g_buf), (char const   * __restrict  )file, (size_t )4096);
  len = xstrlen((char const   * __restrict  )(g_buf));
  if (len > 1UL) {
    if ((int )g_buf[len - 1UL] == 42) {
      flags = (uchar_t )((int )flags & -17);
      g_buf[len - 1UL] = (char )'\000';
      len --;
    }
  }
  if ((int )flags & 128) {
    goto _L;
  } else
  if ((int )flags & 4) {
    _L: /* CIL Label */ 
    tmp = is_suffix((char const   * __restrict  )(g_buf), (char const   * __restrict  )" $nnn");
    if (tmp) {
      g_buf[len - 5UL] = (char )'\000';
    } else {
      runfile = (char *)((void *)0);
    }
    if ((int )flags & 128) {
      get_output(g_buf, runfile, (char *)((void *)0), -1, (_Bool)1, (_Bool)1);
    } else {
      spawn(g_buf, runfile, (char *)((void *)0), (char *)((void *)0), (ushort_t )flags);
    }
  } else {
    spawn((char *)utils[7], g_buf, (char *)((void *)0), (char *)((void *)0), (ushort_t )flags);
  }
  return;
}
}
static _Bool plctrl_init(void) 
{ 
  size_t len ;
  size_t tmp ;
  __pid_t tmp___0 ;
  char *tmp___1 ;

  {
  g_tmpfpath[(int )tmpfplen - 1] = (char )'\000';
  len = xstrsncpy((char * __restrict  )(g_pipepath), (char const   * __restrict  )(g_tmpfpath),
                  (size_t )64);
  g_pipepath[len - 1UL] = (char )'/';
  tmp = xstrsncpy((char * __restrict  )(g_pipepath + len), (char const   * __restrict  )"nnn-pipe.",
                  64UL - len);
  len = tmp + len;
  tmp___0 = getpid();
  tmp___1 = xitoa((uint_t )tmp___0);
  xstrsncpy((char * __restrict  )((g_pipepath + len) - 1), (char const   * __restrict  )tmp___1,
            64UL - len);
  setenv((char const   *)env_cfg[7], (char const   *)(g_pipepath), 1);
  return ((_Bool)0);
}
}
static void rmlistpath(void) 
{ 


  {
  if (listpath) {
    spawn((char *)utils[20], listpath, (char *)((void *)0), (char *)((void *)0), (ushort_t )5);
    if ((unsigned long )listpath != (unsigned long )initpath) {
      free((void *)listpath);
    }
    listpath = (char *)((void *)0);
  }
  return;
}
}
static ssize_t read_nointr(int fd , void *buf , size_t count ) 
{ 
  ssize_t len ;
  int *tmp ;

  {
  while (1) {
    len = read(fd, buf, count);
    if (len == -1L) {
      tmp = __errno_location();
      if (! (*tmp == 4)) {
        break;
      }
    } else {
      break;
    }
  }
  return (len);
}
}
static char *readpipe(int fd , char *ctxnum , char **path ) 
{ 
  char ctx ;
  char *nextpath ;
  ssize_t tmp ;
  ssize_t tmp___0 ;
  uchar_t tmp___1 ;
  ssize_t tmp___2 ;
  char op ;
  ssize_t len ;
  ssize_t tmp___3 ;
  size_t tmp___4 ;

  {
  nextpath = (char *)((void *)0);
  tmp = read_nointr(fd, (void *)(g_buf), (size_t )1);
  if (tmp != 1L) {
    return ((char *)((void *)0));
  }
  if ((int )g_buf[0] == 45) {
    clearselection();
    tmp___0 = read_nointr(fd, (void *)(g_buf), (size_t )1);
    if (tmp___0 != 1L) {
      return ((char *)((void *)0));
    }
  }
  if ((int )g_buf[0] == 43) {
    tmp___1 = get_free_ctx();
    ctx = (char )((int )tmp___1 + 1);
  } else
  if ((int )g_buf[0] < 48) {
    return ((char *)((void *)0));
  } else {
    ctx = (char )((int )g_buf[0] - 48);
    if ((int )ctx > 4) {
      return ((char *)((void *)0));
    }
  }
  tmp___2 = read_nointr(fd, (void *)(g_buf), (size_t )1);
  if (tmp___2 != 1L) {
    return ((char *)((void *)0));
  }
  op = g_buf[0];
  if ((int )op == 99) {
    tmp___3 = read_nointr(fd, (void *)(g_buf), (size_t )4096);
    len = tmp___3;
    if (len <= 0L) {
      return ((char *)((void *)0));
    }
    g_buf[len] = (char )'\000';
    if ((int )g_buf[0] == 47) {
      nextpath = g_buf;
      tmp___4 = xstrlen((char const   * __restrict  )(g_buf));
      len = (ssize_t )tmp___4;
      while (1) {
        len --;
        if (len) {
          if (! ((int )g_buf[len] == 47)) {
            break;
          }
        } else {
          break;
        }
        g_buf[len] = (char )'\000';
      }
    }
  } else
  if ((int )op == 108) {
    rmlistpath();
    nextpath = load_input(fd, (char const   *)*path);
  } else
  if ((int )op == 112) {
    free((void *)selpath);
    selpath = (char *)((void *)0);
    clearselection();
    g_state.picker = (uint_t )0;
    g_state.picked = (uint_t )1;
  }
  *ctxnum = ctx;
  return (nextpath);
}
}
static _Bool run_plugin(char **path , char const   *file , char *runfile , char **lastname ,
                        char **lastdir ) 
{ 
  pid_t p ;
  char ctx ;
  uchar_t flags ;
  _Bool cmd_as_plugin ;
  char *nextpath ;
  int tmp ;
  int wfd ;
  int tmp___0 ;
  char *sel ;
  char std[2] ;
  int rfd ;
  int *tmp___1 ;

  {
  ctx = (char)0;
  flags = (uchar_t )0;
  cmd_as_plugin = (_Bool)0;
  if (! g_state.pluginit) {
    plctrl_init();
    g_state.pluginit = (uint_t )1;
  }
  setexports();
  if ((int const   )*file == 33) {
    flags = (uchar_t )17;
    file ++;
    if ((int const   )*file == 124) {
      flags = (uchar_t )((int )flags | 128);
      file ++;
    } else
    if ((int const   )*file == 38) {
      flags = (uchar_t )6;
      file ++;
    }
    if (! *file) {
      return ((_Bool)0);
    }
    if ((int )flags & 4) {
      run_cmd_as_plugin(file, runfile, flags);
      return ((_Bool)1);
    } else
    if ((int )flags & 128) {
      run_cmd_as_plugin(file, runfile, flags);
      return ((_Bool)1);
    }
    cmd_as_plugin = (_Bool)1;
  }
  tmp = mkfifo((char const   *)(g_pipepath), (__mode_t )384);
  if (tmp != 0) {
    return ((_Bool)0);
  }
  endwin();
  p = fork();
  if (! p) {
    tmp___0 = open((char const   *)(g_pipepath), 524289);
    wfd = tmp___0;
    if (wfd == -1) {
      _exit(1);
    }
    if (! cmd_as_plugin) {
      sel = (char *)((void *)0);
      std[0] = (char )'-';
      std[1] = (char )'\000';
      mkpath((char const   *)plgpath, file, g_buf);
      if (g_state.picker) {
        if (selpath) {
          sel = selpath;
        } else {
          sel = std;
        }
      }
      if (runfile) {
        if (*(runfile + 0)) {
          xstrsncpy((char * __restrict  )*lastname, (char const   * __restrict  )runfile,
                    (size_t )255);
          spawn(g_buf, *lastname, *path, sel, (ushort_t )0);
        } else {
          spawn(g_buf, (char *)((void *)0), *path, sel, (ushort_t )0);
        }
      } else {
        spawn(g_buf, (char *)((void *)0), *path, sel, (ushort_t )0);
      }
    } else {
      run_cmd_as_plugin(file, runfile, flags);
    }
    close(wfd);
    _exit(0);
  }
  while (1) {
    rfd = open((char const   *)(g_pipepath), 0);
    if (rfd == -1) {
      tmp___1 = __errno_location();
      if (! (*tmp___1 == 4)) {
        break;
      }
    } else {
      break;
    }
  }
  nextpath = readpipe(rfd, & ctx, path);
  if (nextpath) {
    set_smart_ctx((int )ctx, nextpath, path, runfile, lastname, lastdir);
  }
  close(rfd);
  waitpid(p, (int *)((void *)0), 0);
  wrefresh(stdscr);
  unlink((char const   *)(g_pipepath));
  return ((_Bool)1);
}
}
static _Bool launch_app(char *newpath ) 
{ 
  int r ;
  char *tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;

  {
  r = 8;
  tmp = newpath;
  mkpath((char const   *)plgpath, (char const   *)utils[6], newpath);
  tmp___0 = getutil((char *)utils[14]);
  if (tmp___0) {
    tmp___1 = access((char const   *)newpath, 1);
    if (tmp___1 < 0) {
      tmp = xreadline((char const   *)((void *)0), (char const   *)messages[32]);
      r = 7;
    }
  } else {
    tmp = xreadline((char const   *)((void *)0), (char const   *)messages[32]);
    r = 7;
  }
  if (tmp) {
    if (*tmp) {
      if (r == 8) {
        tmp___2 = "0";
      } else {
        tmp___2 = (char const   *)((void *)0);
      }
      spawn(tmp, (char *)tmp___2, (char *)((void *)0), (char *)((void *)0), (ushort_t )r);
    }
  }
  return ((_Bool)0);
}
}
static _Bool prompt_run(void) 
{ 
  _Bool ret ;
  char *cmdline ;
  char *next ;
  int cnt_j ;
  int cnt_J ;
  int cmd_ret ;
  size_t len ;
  char const   *xargs_j ;
  char const   *xargs_J ;
  char cmd___0[(4096 + (256 << 1)) + 32] ;
  char *tmp ;

  {
  ret = (_Bool)0;
  xargs_j = "xargs -0 -I{} %s < %s";
  xargs_J = "xargs -0 %s < %s";
  while (1) {
    cmdline = xreadline((char const   *)((void *)0), ">>> ");
    if (! cmdline) {
      break;
    } else
    if (! *(cmdline + 0)) {
      break;
    }
    free((void *)lastcmd);
    lastcmd = xstrdup((char const   * __restrict  )cmdline);
    ret = (_Bool)1;
    len = xstrlen((char const   * __restrict  )cmdline);
    cnt_j = 0;
    next = cmdline;
    while (1) {
      next = strstr((char const   *)next, "%j");
      if (! next) {
        break;
      }
      cnt_j ++;
      *(next + 0) = (char )'{';
      *(next + 1) = (char )'}';
      next ++;
    }
    cnt_J = 0;
    next = cmdline;
    while (1) {
      next = strstr((char const   *)next, "%J");
      if (! next) {
        break;
      }
      cnt_J ++;
      if ((unsigned long )next == (unsigned long )((cmdline + len) - 2)) {
        *(cmdline + (len - 2UL)) = (char )'\000';
      }
      next ++;
    }
    if (cnt_j) {
      if (cnt_J) {
        break;
      }
    }
    if (cnt_j) {
      snprintf((char * __restrict  )(cmd___0), (size_t )((4096 + (256 << 1)) + 32),
               (char const   * __restrict  )xargs_j, cmdline, selpath);
    } else
    if (cnt_J) {
      snprintf((char * __restrict  )(cmd___0), (size_t )((4096 + (256 << 1)) + 32),
               (char const   * __restrict  )xargs_J, cmdline, selpath);
    }
    if (cnt_j) {
      tmp = cmd___0;
    } else
    if (cnt_J) {
      tmp = cmd___0;
    } else {
      tmp = cmdline;
    }
    cmd_ret = spawn(shell, (char *)"-c", tmp, (char *)((void *)0), (ushort_t )25);
    if (cnt_j) {
      goto _L;
    } else
    if (cnt_J) {
      _L: /* CIL Label */ 
      if (cmd_ret == 0) {
        clearselection();
      }
    }
  }
  return (ret);
}
}
static _Bool handle_cmd(enum action sel , char *newpath ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int r ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  endselection((_Bool)0);
  if ((unsigned int )sel == 56U) {
    tmp = launch_app(newpath);
    return (tmp);
  }
  setexports();
  if ((unsigned int )sel == 57U) {
    tmp___0 = prompt_run();
    return (tmp___0);
  }
  tmp___2 = getenv((char const   *)env_cfg[6]);
  tmp___1 = tmp___2;
  if (tmp___1) {
    tmp___3 = atoi((char const   *)tmp___1);
    tmp___4 = tmp___3;
  } else {
    tmp___4 = 0;
  }
  r = tmp___4;
  tmp___5 = xitoa((uint_t )(r + 1));
  setenv((char const   *)env_cfg[6], (char const   *)tmp___5, 1);
  spawn(shell, (char *)((void *)0), (char *)((void *)0), (char *)((void *)0), (ushort_t )9);
  tmp___6 = xitoa((uint_t )r);
  setenv((char const   *)env_cfg[6], (char const   *)tmp___6, 1);
  return ((_Bool)1);
}
}
static void dentfree(void) 
{ 


  {
  free((void *)pnamebuf);
  free((void *)pdents);
  free((void *)mark);
  free((void *)core_blocks);
  free((void *)core_data);
  free((void *)core_files);
  return;
}
}
static void *du_thread(void *p_data ) 
{ 
  thread_data *pdata ;
  char *path[2] ;
  ullong_t tfiles ;
  blkcnt_t tblocks ;
  struct stat *sb ;
  FTS *tree ;
  FTS *tmp ;
  FTSENT *node ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
  pdata = (thread_data *)p_data;
  path[0] = pdata->path;
  path[1] = (char *)((void *)0);
  tfiles = (ullong_t )0;
  tblocks = (blkcnt_t )0;
  tmp = fts_open((char * const  *)(path), 84, (int (*)(FTSENT const   ** , FTSENT const   ** ))0);
  tree = tmp;
  while (1) {
    node = fts_read(tree);
    if (! node) {
      break;
    }
    if ((int )node->fts_info & 1) {
      if (g_state.interrupt) {
        break;
      }
      continue;
    }
    sb = node->fts_statp;
    if (cfg.apparentsz) {
      if (sb->st_size) {
        if ((int )node->fts_info & 8) {
          if (sb->st_nlink <= 1UL) {
            tblocks += sb->st_size;
          } else {
            tmp___0 = test_set_bit((uint_t )sb->st_ino);
            if (tmp___0) {
              tblocks += sb->st_size;
            } else {
              goto _L;
            }
          }
        } else
        _L: /* CIL Label */ 
        if ((int )node->fts_info & 6) {
          tblocks += sb->st_size;
        }
      }
    } else
    if (sb->st_blocks) {
      if ((int )node->fts_info & 8) {
        if (sb->st_nlink <= 1UL) {
          tblocks += sb->st_blocks;
        } else {
          tmp___1 = test_set_bit((uint_t )sb->st_ino);
          if (tmp___1) {
            tblocks += sb->st_blocks;
          } else {
            goto _L___0;
          }
        }
      } else
      _L___0: /* CIL Label */ 
      if ((int )node->fts_info & 6) {
        tblocks += sb->st_blocks;
      }
    }
    tfiles ++;
  }
  fts_close(tree);
  if (pdata->entnum >= 0) {
    (pdents + pdata->entnum)->__annonCompField18.blocks = (ullong_t )tblocks;
  }
  if (! pdata->mntpoint) {
    *(core_blocks + pdata->core) += tblocks;
    *(core_files + pdata->core) += tfiles;
  } else {
    (*(core_files + pdata->core)) ++;
  }
  pthread_mutex_lock(& running_mutex);
  threadbmp |= 1 << (int )pdata->core;
  active_threads -= (int volatile   )1;
  pthread_mutex_unlock(& running_mutex);
  return ((void *)0);
}
}
static void dirwalk(char *path , int entnum , _Bool mountpoint ) 
{ 
  int core ;
  int tmp ;
  pthread_t tid ;
  char *tmp___0 ;

  {
  while (active_threads == (int volatile   )4) {

  }
  if (g_state.interrupt) {
    return;
  }
  pthread_mutex_lock(& running_mutex);
  tmp = ffs(threadbmp);
  core = tmp - 1;
  threadbmp &= ~ (1 << core);
  active_threads += (int volatile   )1;
  pthread_mutex_unlock(& running_mutex);
  xstrsncpy((char * __restrict  )((core_data + core)->path), (char const   * __restrict  )path,
            (size_t )4096);
  (core_data + core)->entnum = entnum;
  (core_data + core)->core = (ushort_t )core;
  (core_data + core)->mntpoint = mountpoint;
  tid = (pthread_t )0;
  pthread_create((pthread_t * __restrict  )(& tid), (pthread_attr_t const   * __restrict  )((void *)0),
                 & du_thread, (void * __restrict  )((void *)(core_data + core)));
  wmove(stdscr, (int )xlines - 1, 0);
  tmp___0 = xbasename(path);
  waddnstr(stdscr, (char const   *)tmp___0, -1);
  waddnstr(stdscr, " [^C aborts]\n", -1);
  wrefresh(stdscr);
  return;
}
}
static _Bool prep_threads(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
  if (! g_state.duinit) {
    threadbmp >>= 28;
    if (! core_blocks) {
      tmp = calloc((size_t )4, sizeof(blkcnt_t ));
      core_blocks = (blkcnt_t *)tmp;
    }
    if (! core_data) {
      tmp___0 = calloc((size_t )4, sizeof(thread_data ));
      core_data = (thread_data *)tmp___0;
    }
    if (! core_files) {
      tmp___1 = calloc((size_t )4, sizeof(ullong_t ));
      core_files = (ullong_t *)tmp___1;
    }
    if (! core_blocks) {
      tmp___2 = __errno_location();
      tmp___3 = strerror(*tmp___2);
      printwait((char const   *)tmp___3, (int *)((void *)0));
      return ((_Bool)0);
    } else
    if (! core_data) {
      tmp___2 = __errno_location();
      tmp___3 = strerror(*tmp___2);
      printwait((char const   *)tmp___3, (int *)((void *)0));
      return ((_Bool)0);
    } else
    if (! core_files) {
      tmp___2 = __errno_location();
      tmp___3 = strerror(*tmp___2);
      printwait((char const   *)tmp___3, (int *)((void *)0));
      return ((_Bool)0);
    }
    max_openfds();
    g_state.duinit = (uint_t )1;
  } else {
    memset((void *)core_blocks, 0, 4UL * sizeof(blkcnt_t ));
    memset((void *)core_data, 0, 4UL * sizeof(thread_data ));
    memset((void *)core_files, 0, 4UL * sizeof(ullong_t ));
  }
  return ((_Bool)1);
}
}
__inline static _Bool selforparent(char const   *path ) 
{ 
  int tmp ;

  {
  if ((int const   )*(path + 0) == 46) {
    if ((int const   )*(path + 1) == 0) {
      tmp = 1;
    } else
    if ((int const   )*(path + 1) == 46) {
      if ((int const   )*(path + 2) == 0) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((_Bool )tmp);
}
}
static int dentfill(char *path , struct entry **ppdents ) 
{ 
  uchar_t entflags ;
  int flags ;
  struct dirent *dp ;
  char *namep ;
  char *pnb ;
  char *buf ;
  struct entry *dentp ;
  size_t off ;
  size_t namebuflen ;
  struct stat sb_path ;
  struct stat sb ;
  DIR *dirp ;
  DIR *tmp ;
  int fd ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  int tmp___5 ;
  __off_t tmp___6 ;
  _Bool tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  int count ;
  size_t tmp___12 ;
  int tmp___13 ;
  _Bool tmp___14 ;
  int i ;
  int tmp___15 ;

  {
  entflags = (uchar_t )0;
  flags = 0;
  off = (size_t )0;
  namebuflen = (size_t )2048;
  tmp = opendir((char const   *)path);
  dirp = tmp;
  ndents = 0;
  gtimesecs = time((time_t *)((void *)0));
  if (! dirp) {
    return (0);
  }
  tmp___0 = dirfd(dirp);
  fd = tmp___0;
  if (cfg.blkorder) {
    num_files = (ullong_t )0;
    dir_blocks = (blkcnt_t )0;
    buf = g_buf;
    tmp___1 = fstatat(fd, (char const   * __restrict  )path, (struct stat * __restrict  )(& sb_path),
                      0);
    if (tmp___1 == -1) {
      goto exit;
    }
    if (! ihashbmp) {
      tmp___2 = calloc((size_t )1, (size_t )((16777215 >> 6) << 3));
      ihashbmp = (ullong_t *)tmp___2;
      if (! ihashbmp) {
        goto exit;
      }
    } else {
      memset((void *)ihashbmp, 0, (size_t )((16777215 >> 6) << 3));
    }
    tmp___3 = prep_threads();
    if (! tmp___3) {
      goto exit;
    }
    wattr_on(stdscr, ((cfg.curctx + 1U) << 8) & (((1U << 8) - 1U) << 8), (void *)0);
  }
  posix_fadvise(fd, (off_t )0, (off_t )0, 2);
  dp = readdir(dirp);
  if (! dp) {
    goto exit;
  }
  if (cfg.blkorder) {
    flags = 256;
  } else
  if ((int )dp->d_type == 0) {
    flags = 256;
  }
  while (1) {
    namep = dp->d_name;
    tmp___4 = selforparent((char const   *)namep);
    if (tmp___4) {
      goto __Cont;
    }
    if (! cfg.showhidden) {
      if ((int )*(namep + 0) == 46) {
        if (! cfg.blkorder) {
          goto __Cont;
        }
        tmp___5 = fstatat(fd, (char const   * __restrict  )namep, (struct stat * __restrict  )(& sb),
                          256);
        if (tmp___5 == -1) {
          goto __Cont;
        }
        if ((sb.st_mode & 61440U) == 16384U) {
          if (sb_path.st_dev == sb.st_dev) {
            mkpath((char const   *)path, (char const   *)namep, buf);
            dirwalk(buf, -1, (_Bool)0);
            if (g_state.interrupt) {
              goto exit;
            }
          }
        } else {
          if (sb.st_nlink <= 1UL) {
            goto _L;
          } else {
            tmp___7 = test_set_bit((uint_t )sb.st_ino);
            if (tmp___7) {
              _L: /* CIL Label */ 
              if (cfg.apparentsz) {
                tmp___6 = sb.st_size;
              } else {
                tmp___6 = sb.st_blocks;
              }
              dir_blocks += tmp___6;
            }
          }
          num_files ++;
        }
        goto __Cont;
      }
    }
    tmp___9 = fstatat(fd, (char const   * __restrict  )namep, (struct stat * __restrict  )(& sb),
                      flags);
    if (tmp___9 == -1) {
      if (flags) {
        entflags = (uchar_t )8;
        memset((void *)(& sb), 0, sizeof(struct stat ));
      } else {
        tmp___8 = fstatat(fd, (char const   * __restrict  )namep, (struct stat * __restrict  )(& sb),
                          256);
        if (tmp___8 == -1) {
          entflags = (uchar_t )8;
          memset((void *)(& sb), 0, sizeof(struct stat ));
        } else {
          entflags = (uchar_t )4;
        }
      }
    }
    if (ndents == total_dents) {
      if (cfg.blkorder) {
        while (active_threads) {

        }
      }
      total_dents += 64;
      tmp___10 = xrealloc((void *)*ppdents, (unsigned long )total_dents * sizeof(*(*ppdents)));
      *ppdents = (struct entry *)tmp___10;
      if (! *ppdents) {
        free((void *)pnamebuf);
        closedir(dirp);
        printerr(5673);
      }
    }
    if (namebuflen - off < 256UL) {
      namebuflen += 2048UL;
      pnb = pnamebuf;
      tmp___11 = xrealloc((void *)pnamebuf, namebuflen);
      pnamebuf = (char *)tmp___11;
      if (! pnamebuf) {
        free((void *)*ppdents);
        closedir(dirp);
        printerr(5687);
      }
      if ((unsigned long )pnb != (unsigned long )pnamebuf) {
        dentp = *ppdents;
        dentp->name = pnamebuf;
        count = 1;
        while (count < ndents) {
          (dentp + 1)->name = (char *)((ullong_t )((size_t )dentp->name) + dentp->__annonCompField18.nlen);
          dentp ++;
          count ++;
        }
      }
    }
    dentp = *ppdents + ndents;
    dentp->name = (char *)((size_t )pnamebuf + off);
    tmp___12 = xstrsncpy((char * __restrict  )dentp->name, (char const   * __restrict  )namep,
                         (size_t )256);
    dentp->__annonCompField18.nlen = (ullong_t )tmp___12;
    off = (size_t )((ullong_t )off + dentp->__annonCompField18.nlen);
    if (cfg.timetype == 2U) {
      dentp->sec = sb.st_mtim.tv_sec;
      dentp->nsec = (uint_t )sb.st_mtim.tv_nsec;
    } else
    if (cfg.timetype == 0U) {
      dentp->sec = sb.st_atim.tv_sec;
      dentp->nsec = (uint_t )sb.st_atim.tv_nsec;
    } else {
      dentp->sec = sb.st_ctim.tv_sec;
      dentp->nsec = (uint_t )sb.st_ctim.tv_nsec;
    }
    if (gtimesecs - sb.st_mtim.tv_sec <= 300L) {
      entflags = (uchar_t )((int )entflags | 64);
    } else
    if (gtimesecs - sb.st_ctim.tv_sec <= 300L) {
      entflags = (uchar_t )((int )entflags | 64);
    }
    if (! flags) {
      if ((int )dp->d_type == 10) {
        dentp->mode = (sb.st_mode & 4294905855U) | 40960U;
        if (listpath) {
          dentp->size = sb.st_size;
        } else {
          dentp->size = (off_t )0;
        }
      } else {
        dentp->mode = sb.st_mode;
        dentp->size = sb.st_size;
      }
    } else {
      dentp->mode = sb.st_mode;
      dentp->size = sb.st_size;
    }
    if ((sb.st_mode & 61440U) == 16384U) {
      dentp->__annonCompField18.flags = (ullong_t )0;
    } else {
      if (sb.st_nlink > 1UL) {
        tmp___13 = 2;
      } else {
        tmp___13 = 0;
      }
      dentp->__annonCompField18.flags = (ullong_t )tmp___13;
    }
    if (entflags) {
      dentp->__annonCompField18.flags |= (unsigned long long )entflags;
      entflags = (uchar_t )0;
    }
    if (cfg.blkorder) {
      if ((sb.st_mode & 61440U) == 16384U) {
        mkpath((char const   *)path, (char const   *)namep, buf);
        dirwalk(buf, ndents, (_Bool )(sb_path.st_dev != sb.st_dev));
        if (g_state.interrupt) {
          goto exit;
        }
      } else {
        if (cfg.apparentsz) {
          dentp->__annonCompField18.blocks = (ullong_t )sb.st_size;
        } else {
          dentp->__annonCompField18.blocks = (ullong_t )sb.st_blocks;
        }
        if (sb.st_nlink <= 1UL) {
          dir_blocks = (blkcnt_t )((ullong_t )dir_blocks + dentp->__annonCompField18.blocks);
        } else {
          tmp___14 = test_set_bit((uint_t )sb.st_ino);
          if (tmp___14) {
            dir_blocks = (blkcnt_t )((ullong_t )dir_blocks + dentp->__annonCompField18.blocks);
          }
        }
        num_files ++;
      }
    }
    if (flags) {
      if ((sb.st_mode & 61440U) == 40960U) {
        sb.st_mode = (__mode_t )0;
        fstatat(fd, (char const   * __restrict  )namep, (struct stat * __restrict  )(& sb),
                0);
      }
      if ((sb.st_mode & 61440U) == 16384U) {
        dentp->__annonCompField18.flags |= 1ULL;
      }
    } else
    if ((int )dp->d_type == 4) {
      dentp->__annonCompField18.flags |= 1ULL;
    } else
    if ((int )dp->d_type == 10) {
      goto _L___0;
    } else
    if ((int )dp->d_type == 0) {
      _L___0: /* CIL Label */ 
      if ((sb.st_mode & 61440U) == 16384U) {
        dentp->__annonCompField18.flags |= 1ULL;
      }
    }
    ndents ++;
    __Cont: /* CIL Label */ 
    dp = readdir(dirp);
    if (! dp) {
      break;
    }
  }
  exit: 
  if (g_state.duinit) {
    if (cfg.blkorder) {
      while (active_threads) {

      }
      wattr_off(stdscr, ((cfg.curctx + 1U) << 8) & (((1U << 8) - 1U) << 8), (void *)0);
      i = 0;
      while (i < 4) {
        num_files += *(core_files + i);
        dir_blocks += *(core_blocks + i);
        i ++;
      }
    }
  }
  tmp___15 = closedir(dirp);
  if (tmp___15 == -1) {
    printerr(5811);
  }
  return (ndents);
}
}
static void populate(char *path , char *lastname ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  ndents = dentfill(path, & pdents);
  if (! ndents) {
    return;
  }
  if (*lastname) {
    tmp = dentfind((char const   *)lastname, ndents);
    tmp___0 = tmp;
  } else {
    tmp___0 = 0;
  }
  move_cursor(tmp___0, 0);
  last_curscroll = -1;
  return;
}
}
static void move_cursor(int target , int ignore_scrolloff ) 
{ 
  int onscreen ;
  int tmp___0 ;
  int tmp___1 ;
  int delta ;
  int scrolloff ;
  int tmp___2 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  onscreen = (int )xlines - 4;
  if (ndents - 1 < target) {
    tmp___1 = ndents - 1;
  } else {
    tmp___1 = target;
  }
  if (0 > tmp___1) {
    target = 0;
  } else {
    if (ndents - 1 < target) {
      tmp___0 = ndents - 1;
    } else {
      tmp___0 = target;
    }
    target = tmp___0;
  }
  last_curscroll = curscroll;
  last = cur;
  cur = target;
  if (! ignore_scrolloff) {
    delta = target - last;
    if (3 < onscreen >> 1) {
      tmp___2 = 3;
    } else {
      tmp___2 = onscreen >> 1;
    }
    scrolloff = tmp___2;
    if (cur < curscroll + scrolloff) {
      if (delta < 0) {
        curscroll += delta;
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (cur > ((curscroll + onscreen) - scrolloff) - 1) {
      if (delta > 0) {
        curscroll += delta;
      }
    }
  }
  if (cur < ndents - onscreen) {
    tmp___5 = cur;
  } else {
    tmp___5 = ndents - onscreen;
  }
  if (curscroll < tmp___5) {
    curscroll = curscroll;
  } else {
    if (cur < ndents - onscreen) {
      tmp___4 = cur;
    } else {
      tmp___4 = ndents - onscreen;
    }
    curscroll = tmp___4;
  }
  if (cur - (onscreen - 1) > 0) {
    tmp___8 = cur - (onscreen - 1);
  } else {
    tmp___8 = 0;
  }
  if (curscroll > tmp___8) {
    curscroll = curscroll;
  } else {
    if (cur - (onscreen - 1) > 0) {
      tmp___7 = cur - (onscreen - 1);
    } else {
      tmp___7 = 0;
    }
    curscroll = tmp___7;
  }
  return;
}
}
static void handle_screen_move(enum action sel ) 
{ 
  int onscreen ;
  char *input ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int index___0 ;
  int tmp___2 ;
  int c ;
  int tmp___3 ;
  int r ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  switch ((unsigned int )sel) {
  case 4U: 
  if (cfg.rollover) {
    move_cursor((cur + 1) % ndents, 0);
  } else
  if (cur != ndents - 1) {
    move_cursor((cur + 1) % ndents, 0);
  }
  break;
  case 5U: 
  if (cfg.rollover) {
    move_cursor(((cur + ndents) - 1) % ndents, 0);
  } else
  if (cur) {
    move_cursor(((cur + ndents) - 1) % ndents, 0);
  }
  break;
  case 6U: 
  onscreen = (int )xlines - 4;
  move_cursor(curscroll + (onscreen - 1), 1);
  curscroll += onscreen - 1;
  break;
  case 8U: 
  onscreen = (int )xlines - 4;
  move_cursor(curscroll + (onscreen - 1), 1);
  curscroll += onscreen >> 1;
  break;
  case 7U: 
  onscreen = (int )xlines - 4;
  move_cursor(curscroll, 1);
  curscroll -= onscreen - 1;
  break;
  case 9U: 
  onscreen = (int )xlines - 4;
  move_cursor(curscroll, 1);
  curscroll -= onscreen >> 1;
  break;
  case 13U: 
  tmp = xreadline((char const   *)((void *)0), "jump (+n/-n/n): ");
  input = tmp;
  if (! input) {
    break;
  } else
  if (! *input) {
    break;
  }
  if ((int )*(input + 0) == 45) {
    tmp___0 = atoi((char const   *)(input + 1));
    cur -= tmp___0;
    if (cur < 0) {
      cur = 0;
    }
  } else
  if ((int )*(input + 0) == 43) {
    tmp___1 = atoi((char const   *)(input + 1));
    cur += tmp___1;
    if (cur >= ndents) {
      cur = ndents - 1;
    }
  } else {
    tmp___2 = atoi((char const   *)input);
    index___0 = tmp___2;
    if (index___0 < 1) {
      break;
    } else
    if (index___0 > ndents) {
      break;
    }
    cur = index___0 - 1;
  }
  onscreen = (int )xlines - 4;
  move_cursor(cur, 1);
  curscroll -= onscreen >> 1;
  break;
  case 10U: 
  move_cursor(0, 1);
  break;
  case 11U: 
  move_cursor(ndents - 1, 1);
  break;
  default: 
  tmp___3 = get_input((char const   *)messages[38]);
  c = tmp___3;
  if (! c) {
    break;
  }
  if (c >= 97) {
    if (c <= 122) {
      c = (c - 97) + 65;
    } else {
      c = c;
    }
  } else {
    c = c;
  }
  if ((int )*((pdents + cur)->name) >= 97) {
    if ((int )*((pdents + cur)->name) <= 122) {
      tmp___6 = ((int )*((pdents + cur)->name) - 97) + 65;
    } else {
      tmp___6 = (int )*((pdents + cur)->name);
    }
  } else {
    tmp___6 = (int )*((pdents + cur)->name);
  }
  if (c == tmp___6) {
    tmp___5 = cur + 1;
  } else {
    tmp___5 = 0;
  }
  r = tmp___5;
  while (r < ndents) {
    if (c == 39) {
      if (! ((pdents + r)->__annonCompField18.flags & 1ULL)) {
        move_cursor(r % ndents, 0);
        break;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      if ((int )*((pdents + r)->name) >= 97) {
        if ((int )*((pdents + r)->name) <= 122) {
          tmp___7 = ((int )*((pdents + r)->name) - 97) + 65;
        } else {
          tmp___7 = (int )*((pdents + r)->name);
        }
      } else {
        tmp___7 = (int )*((pdents + r)->name);
      }
      if (c == tmp___7) {
        move_cursor(r % ndents, 0);
        break;
      }
    }
    r ++;
  }
  break;
  }
  return;
}
}
static void handle_openwith(char const   *path , char const   *name , char *newpath ,
                            char *tmp ) 
{ 
  int r ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp___0 = get_input((char const   *)messages[12]);
  r = tmp___0;
  if (r == 99) {
    r = 9;
  } else {
    if (r == 103) {
      tmp___1 = 7;
    } else {
      tmp___1 = 0;
    }
    r = tmp___1;
  }
  if (r) {
    mkpath(path, name, newpath);
    spawn(tmp, newpath, (char *)((void *)0), (char *)((void *)0), (ushort_t )r);
  }
  return;
}
}
static void copynextname(char *lastname ) 
{ 
  int tmp ;
  char const   *tmp___0 ;

  {
  if (cur) {
    if (cur != ndents - 1) {
      tmp = 1;
    } else {
      tmp = -1;
    }
    cur += tmp;
    if (ndents) {
      tmp___0 = (char const   *)(pdents + cur)->name;
    } else {
      tmp___0 = "\000";
    }
    xstrsncpy((char * __restrict  )lastname, (char const   * __restrict  )tmp___0,
              (size_t )256);
  } else {
    *(lastname + 0) = (char )'\000';
  }
  return;
}
}
static int handle_context_switch(enum action sel ) 
{ 
  int r ;

  {
  r = -1;
  switch ((unsigned int )sel) {
  case 21U: 
  case 20U: 
  r = (int )cfg.curctx;
  if ((unsigned int )sel == 20U) {
    while (1) {
      r = (r + 1) & -5;
      if (! (! g_ctx[r].c_cfg.ctxactive)) {
        break;
      }
    }
  } else {
    while (1) {
      r = (r + 1) & -5;
      if (g_ctx[r].c_cfg.ctxactive) {
        if (! ((uint_t )r != cfg.curctx)) {
          break;
        }
      } else {
        break;
      }
    }
    if ((uint_t )r == cfg.curctx) {
      while (1) {
        r = (r + 3) & 3;
        if (! (! g_ctx[r].c_cfg.ctxactive)) {
          break;
        }
      }
    }
  }
  default: 
  if ((unsigned int )sel >= 22U) {
    r = (int )((unsigned int )sel - 22U);
  }
  if (cfg.curctx == (uint_t )r) {
    if ((unsigned int )sel == 20U) {
      if (r == 3) {
        r = 0;
      } else {
        r ++;
      }
    } else
    if ((unsigned int )sel == 21U) {
      if (r == 0) {
        r = 3;
      } else {
        r --;
      }
    } else {
      return (-1);
    }
  }
  }
  return (r);
}
}
static int set_sort_flags(int r ) 
{ 
  _Bool session ;
  _Bool reverse ;
  int tmp ;

  {
  session = (_Bool )(r == 0);
  reverse = (_Bool)0;
  if (r >= 65) {
    if (r <= 90) {
      if (r != 82) {
        if (r != 67) {
          reverse = (_Bool)1;
          if (r >= 65) {
            if (r <= 90) {
              r = (r - 65) + 97;
            } else {
              r = r;
            }
          } else {
            r = r;
          }
        }
      }
    }
  }
  if (session) {
    if (cfg.apparentsz) {
      cfg.apparentsz = (uint_t )0;
      r = 'a';
    } else
    if (cfg.blkorder) {
      cfg.blkorder = (uint_t )0;
      r = 'd';
    }
    if (cfg.version) {
      namecmpfn = & xstrverscasecmp;
    }
    if (cfg.reverse) {
      entrycmpfn = & reventrycmp;
    }
  } else
  if (r == 20) {
    if (cfg.timeorder) {
      r = 's';
    } else
    if (cfg.sizeorder) {
      r = 'c';
    } else {
      r = 't';
    }
  }
  switch (r) {
  case 97: 
  cfg.apparentsz ^= 1U;
  if (cfg.apparentsz) {
    cfg.blkorder = (uint_t )1;
    blk_shift = (uchar_t )0;
  } else {
    cfg.blkorder = (uint_t )0;
  }
  case 100: 
  if (r == 100) {
    if (! cfg.apparentsz) {
      cfg.blkorder ^= 1U;
    }
    cfg.apparentsz = (uint_t )0;
    tmp = ffs(512);
    blk_shift = (uchar_t )(tmp - 1);
  }
  if (cfg.blkorder) {
    cfg.showdetail = (uint_t )1;
  }
  cfg.timeorder = (uint_t )0;
  cfg.sizeorder = (uint_t )0;
  cfg.extnorder = (uint_t )0;
  if (! session) {
    cfg.reverse = (uint_t )0;
    entrycmpfn = & entrycmp;
  }
  endselection((_Bool)1);
  break;
  case 99: 
  cfg.timeorder = (uint_t )0;
  cfg.sizeorder = (uint_t )0;
  cfg.apparentsz = (uint_t )0;
  cfg.blkorder = (uint_t )0;
  cfg.extnorder = (uint_t )0;
  cfg.reverse = (uint_t )0;
  cfg.version = (uint_t )0;
  entrycmpfn = & entrycmp;
  namecmpfn = & xstricmp;
  break;
  case 101: 
  cfg.extnorder ^= 1U;
  cfg.sizeorder = (uint_t )0;
  cfg.timeorder = (uint_t )0;
  cfg.apparentsz = (uint_t )0;
  cfg.blkorder = (uint_t )0;
  cfg.reverse = (uint_t )0;
  entrycmpfn = & entrycmp;
  break;
  case 114: 
  cfg.reverse ^= 1U;
  if (cfg.reverse) {
    entrycmpfn = & reventrycmp;
  } else {
    entrycmpfn = & entrycmp;
  }
  break;
  case 115: 
  cfg.sizeorder ^= 1U;
  cfg.timeorder = (uint_t )0;
  cfg.apparentsz = (uint_t )0;
  cfg.blkorder = (uint_t )0;
  cfg.extnorder = (uint_t )0;
  cfg.reverse = (uint_t )0;
  entrycmpfn = & entrycmp;
  break;
  case 116: 
  cfg.timeorder ^= 1U;
  cfg.sizeorder = (uint_t )0;
  cfg.apparentsz = (uint_t )0;
  cfg.blkorder = (uint_t )0;
  cfg.extnorder = (uint_t )0;
  cfg.reverse = (uint_t )0;
  entrycmpfn = & entrycmp;
  break;
  case 118: 
  cfg.version ^= 1U;
  if (cfg.version) {
    namecmpfn = & xstrverscasecmp;
  } else {
    namecmpfn = & xstricmp;
  }
  cfg.timeorder = (uint_t )0;
  cfg.sizeorder = (uint_t )0;
  cfg.apparentsz = (uint_t )0;
  cfg.blkorder = (uint_t )0;
  cfg.extnorder = (uint_t )0;
  break;
  default: 
  return (0);
  }
  if (reverse) {
    cfg.reverse = (uint_t )1;
    entrycmpfn = & reventrycmp;
  }
  cfgsort[cfg.curctx] = (uchar_t )r;
  return (r);
}
}
static _Bool set_time_type(int *presel ) 
{ 
  _Bool ret ;
  char buf[32] ;
  int tmp ;
  int r ;
  int tmp___0 ;
  int tmp___1 ;

  {
  ret = (_Bool)0;
  buf[0] = (char )'\'';
  buf[1] = (char )'a';
  buf[2] = (char )'\'';
  buf[3] = (char )'c';
  buf[4] = (char )'c';
  buf[5] = (char )'e';
  buf[6] = (char )'s';
  buf[7] = (char )'s';
  buf[8] = (char )' ';
  buf[9] = (char )'/';
  buf[10] = (char )' ';
  buf[11] = (char )'\'';
  buf[12] = (char )'c';
  buf[13] = (char )'\'';
  buf[14] = (char )'h';
  buf[15] = (char )'a';
  buf[16] = (char )'n';
  buf[17] = (char )'g';
  buf[18] = (char )'e';
  buf[19] = (char )' ';
  buf[20] = (char )'/';
  buf[21] = (char )' ';
  buf[22] = (char )'\'';
  buf[23] = (char )'m';
  buf[24] = (char )'\'';
  buf[25] = (char )'o';
  buf[26] = (char )'d';
  buf[27] = (char )' ';
  buf[28] = (char )'[';
  buf[29] = (char )' ';
  buf[30] = (char )']';
  buf[31] = (char )'\000';
  if (cfg.timetype == 2U) {
    buf[sizeof(buf) - 3UL] = (char )'m';
  } else {
    if (cfg.timetype == 0U) {
      tmp = 'a';
    } else {
      tmp = 'c';
    }
    buf[sizeof(buf) - 3UL] = (char )tmp;
  }
  tmp___0 = get_input((char const   *)(buf));
  r = tmp___0;
  if (r == 97) {
    goto _L;
  } else
  if (r == 99) {
    goto _L;
  } else
  if (r == 109) {
    _L: /* CIL Label */ 
    if (r == 109) {
      r = 2;
    } else {
      if (r == 97) {
        tmp___1 = 0;
      } else {
        tmp___1 = 1;
      }
      r = tmp___1;
    }
    if (cfg.timetype != (uint_t )r) {
      cfg.timetype = (uint_t )r;
      if (cfg.filtermode) {
        *presel = '/';
      } else
      if (g_ctx[cfg.curctx].c_fltr[1]) {
        *presel = '/';
      }
      ret = (_Bool)1;
    } else {
      r = 41;
    }
  } else {
    r = 40;
  }
  if (! ret) {
    printwait((char const   *)messages[r], presel);
  }
  return (ret);
}
}
static void statusbar(char *path ) 
{ 
  int i ;
  int len ;
  char *ptr ;
  pEntry pent ;
  int tmp ;
  _Bool tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char buf[24] ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char sort[6] ;
  int tmp___7 ;
  char *tmp___8 ;
  ssize_t tmp___9 ;
  off_t tmp___10 ;
  char *tmp___11 ;
  int y ;
  char *tmp___12 ;
  struct stat sb ;
  char *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;

  {
  i = 0;
  len = 0;
  pent = pdents + cur;
  if (! ndents) {
    printmsg("0/0");
    return;
  }
  if ((pent->mode & 61440U) == 32768U) {
    i = (int )(pent->__annonCompField18.nlen - 1ULL);
    ptr = xextension((char const   *)pent->name, (size_t )i);
    if (ptr) {
      len = (int )((long )i - (ptr - pent->name));
    }
    if (! ptr) {
      ptr = (char *)"\b";
    } else
    if (len > 5) {
      ptr = (char *)"\b";
    } else
    if (len < 2) {
      ptr = (char *)"\b";
    }
  } else {
    ptr = (char *)"\b";
  }
  wattr_on(stdscr, ((cfg.curctx + 1U) << 8) & (((1U << 8) - 1U) << 8), (void *)0);
  if (cfg.fileinfo) {
    tmp___0 = get_output((char *)"file", (char *)"-b", (pdents + cur)->name, -1, (_Bool)0,
                         (_Bool)0);
    if (tmp___0) {
      tmp = wmove(stdscr, (int )xlines - 2, 2);
      if (! (tmp == -1)) {
        waddnstr(stdscr, (char const   *)(g_buf), -1);
      }
    }
  }
  wmove(stdscr, (int )xlines - 1, 0);
  tmp___1 = xitoa((uint_t )ndents);
  printw("%d/%s ", cur + 1, tmp___1);
  if (g_state.selmode) {
    goto _L;
  } else
  if (nselected) {
    _L: /* CIL Label */ 
    wattr_on(stdscr, 1U << 18, (void *)0);
    waddch(stdscr, (chtype const   )' ');
    if (g_state.rangesel) {
      waddch(stdscr, (chtype const   )'*');
    } else
    if (g_state.selmode) {
      waddch(stdscr, (chtype const   )'+');
    }
    if (nselected) {
      tmp___2 = xitoa((uint_t )nselected);
      waddnstr(stdscr, (char const   *)tmp___2, -1);
    }
    waddch(stdscr, (chtype const   )' ');
    wattr_off(stdscr, 1U << 18, (void *)0);
    waddch(stdscr, (chtype const   )' ');
  }
  if (cfg.blkorder) {
    tmp___3 = coolsize(dir_blocks << (int )blk_shift);
    xstrsncpy((char * __restrict  )(buf), (char const   * __restrict  )tmp___3, (size_t )12);
    tmp___4 = get_fs_info((char const   *)path, (uchar_t )0);
    tmp___5 = coolsize((off_t )tmp___4);
    if (cfg.apparentsz) {
      tmp___6 = 'a';
    } else {
      tmp___6 = 'd';
    }
    printw("%cu:%s avail:%s files:%llu %lluB %s\n", tmp___6, buf, tmp___5, num_files,
           pent->__annonCompField18.blocks << (int )blk_shift, ptr);
  } else {
    sort[0] = (char )'\000';
    sort[1] = (char )'\000';
    sort[2] = (char )'\000';
    sort[3] = (char )'\000';
    sort[4] = (char )'\000';
    sort[5] = (char )'\000';
    tmp___7 = getorderstr(sort);
    if (tmp___7) {
      waddnstr(stdscr, (char const   *)(sort), -1);
    }
    print_time((time_t const   *)(& pent->sec), (uchar_t const   )pent->__annonCompField18.flags);
    waddch(stdscr, (chtype const   )' ');
    tmp___8 = get_lsperms(pent->mode);
    waddnstr(stdscr, (char const   *)tmp___8, -1);
    waddch(stdscr, (chtype const   )' ');
    if ((pent->mode & 61440U) == 40960U) {
      if (! cfg.fileinfo) {
        tmp___9 = readlink((char const   * __restrict  )pent->name, (char * __restrict  )(g_buf),
                           (size_t )4096);
        i = (int )tmp___9;
        if (i >= 0) {
          tmp___10 = (off_t )i;
        } else {
          tmp___10 = pent->size;
        }
        tmp___11 = coolsize(tmp___10);
        waddnstr(stdscr, (char const   *)tmp___11, -1);
        if (i > 1) {
          waddnstr(stdscr, " ->", -1);
          if ((unsigned long )((void const   *)0) != (unsigned long )((void const   *)stdscr)) {
            len = (int )stdscr->_cury;
          } else {
            len = -1;
          }
          if ((unsigned long )((void const   *)0) != (unsigned long )((void const   *)stdscr)) {
            y = (int )stdscr->_curx;
          } else {
            y = -1;
          }
          if (i < (int )xcols - y) {
            i = i;
          } else {
            i = (int )xcols - y;
          }
          g_buf[i] = (char )'\000';
          waddnstr(stdscr, (char const   *)(g_buf), -1);
        }
      }
    } else {
      tmp___12 = coolsize(pent->size);
      waddnstr(stdscr, (char const   *)tmp___12, -1);
      waddch(stdscr, (chtype const   )' ');
      waddnstr(stdscr, (char const   *)ptr, -1);
      if (pent->__annonCompField18.flags & 2ULL) {
        tmp___15 = stat((char const   * __restrict  )pent->name, (struct stat * __restrict  )(& sb));
        if (tmp___15 != -1) {
          waddch(stdscr, (chtype const   )' ');
          tmp___13 = xitoa((uint_t )((int )sb.st_nlink));
          waddnstr(stdscr, (char const   *)tmp___13, -1);
          waddch(stdscr, (chtype const   )'-');
          tmp___14 = xitoa((uint_t )((int )sb.st_ino));
          waddnstr(stdscr, (char const   *)tmp___14, -1);
        }
      }
    }
    wclrtoeol(stdscr);
  }
  wattr_off(stdscr, ((cfg.curctx + 1U) << 8) & (((1U << 8) - 1U) << 8), (void *)0);
  wmove(stdscr, (cur + 2) - curscroll, 0);
  return;
}
}
__inline static void markhovered(void) 
{ 


  {
  if (cfg.showdetail) {
    if (ndents) {
      wmove(stdscr, (cur + 2) - curscroll, 0);
      waddch(stdscr, (chtype const   )(62U | (1U << 21)));
    }
  }
  return;
}
}
static int adjust_cols(int n ) 
{ 


  {
  if (cfg.showdetail) {
    if (n < 36) {
      cfg.showdetail ^= 1U;
    } else {
      n -= 32;
    }
  }
  return (n - 2);
}
}
static void draw_line(int ncols ) 
{ 
  _Bool dir ;

  {
  dir = (_Bool)0;
  ncols = adjust_cols(ncols);
  if (g_state.oldcolor) {
    if ((pdents + last)->__annonCompField18.flags & 1ULL) {
      wattr_on(stdscr, (((cfg.curctx + 1U) << 8) & (((1U << 8) - 1U) << 8)) | (1U << 21),
               (void *)0);
      dir = (_Bool)1;
    }
  }
  wmove(stdscr, (2 + last) - curscroll, 0);
  printent((struct entry  const  *)(pdents + last), (uint_t )ncols, (_Bool)0);
  if (g_state.oldcolor) {
    if ((pdents + cur)->__annonCompField18.flags & 1ULL) {
      if (! dir) {
        wattr_on(stdscr, (((cfg.curctx + 1U) << 8) & (((1U << 8) - 1U) << 8)) | (1U << 21),
                 (void *)0);
        dir = (_Bool)1;
      }
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (dir) {
    wattr_off(stdscr, (((cfg.curctx + 1U) << 8) & (((1U << 8) - 1U) << 8)) | (1U << 21),
              (void *)0);
    dir = (_Bool)0;
  }
  wmove(stdscr, (2 + cur) - curscroll, 0);
  printent((struct entry  const  *)(pdents + cur), (uint_t )ncols, (_Bool)1);
  if (dir) {
    wattr_off(stdscr, (((cfg.curctx + 1U) << 8) & (((1U << 8) - 1U) << 8)) | (1U << 21),
              (void *)0);
  }
  markhovered();
  return;
}
}
static void redraw(char *path ) 
{ 
  int ncols ;
  int tmp ;
  int onscreen ;
  int i ;
  int j ;
  chtype tmp___0 ;
  _Bool in_home ;
  _Bool tmp___1 ;
  char *ptr ;
  char *tmp___2 ;
  size_t tmp___3 ;
  char *base ;
  void *tmp___4 ;
  int len ;
  int tmp___5 ;

  {
  if ((unsigned long )((void const   *)0) != (unsigned long )((void const   *)stdscr)) {
    xlines = (ushort_t )((int )stdscr->_maxy + 1);
  } else {
    xlines = (ushort_t )-1;
  }
  if ((unsigned long )((void const   *)0) != (unsigned long )((void const   *)stdscr)) {
    xcols = (ushort_t )((int )stdscr->_maxx + 1);
  } else {
    xcols = (ushort_t )-1;
  }
  if ((int )xcols <= 4096) {
    tmp = (int )xcols;
  } else {
    tmp = 4096;
  }
  ncols = tmp;
  onscreen = (int )xlines - 4;
  j = 1;
  if (g_state.move) {
    g_state.move = (uint_t )0;
    if (ndents) {
      if (last_curscroll == curscroll) {
        draw_line(ncols);
        return;
      }
    }
  }
  werase(stdscr);
  move_cursor(cur, 1);
  if (ncols <= 8) {
    printmsg((char const   *)messages[29]);
    return;
  }
  i = 0;
  while (i < 4) {
    if (! g_ctx[i].c_cfg.ctxactive) {
      waddch(stdscr, (chtype const   )(i + 49));
    } else {
      if (cfg.curctx != (uint_t )i) {
        tmp___0 = 1U << 17;
      } else {
        tmp___0 = 1U << 18;
      }
      waddch(stdscr, (chtype const   )((unsigned int )(i + 49) | (((((chtype )(i + 1) << 8) & (((1U << 8) - 1U) << 8)) | (1U << 21)) | tmp___0)));
    }
    waddch(stdscr, (chtype const   )' ');
    i ++;
  }
  wattr_on(stdscr, (1U << 17) | (((cfg.curctx + 1U) << 8) & (((1U << 8) - 1U) << 8)),
           (void *)0);
  tmp___1 = set_tilde_in_path(path);
  in_home = tmp___1;
  if (in_home) {
    tmp___2 = path + ((int )homelen - 1);
  } else {
    tmp___2 = path;
  }
  ptr = tmp___2;
  tmp___3 = xstrlen((char const   * __restrict  )ptr);
  i = (int )tmp___3;
  if (i + 8 <= ncols) {
    waddnstr(stdscr, (char const   *)ptr, ncols - 8);
  } else {
    tmp___4 = xmemrchr((uchar_t * __restrict  )((uchar_t *)ptr), (uchar_t )'/', (size_t )i);
    base = (char *)tmp___4;
    if (in_home) {
      waddch(stdscr, (chtype const   )*ptr);
      ptr ++;
      i = 1;
    } else {
      i = 0;
    }
    if (ptr) {
      if ((unsigned long )base != (unsigned long )ptr) {
        while ((unsigned long )ptr < (unsigned long )base) {
          if ((int )*ptr == 47) {
            i += 2;
            if (ncols < i + 8) {
              base = (char *)((void *)0);
              break;
            }
            waddch(stdscr, (chtype const   )*ptr);
            ptr ++;
            waddch(stdscr, (chtype const   )*ptr);
          }
          ptr ++;
        }
      }
    }
    if (base) {
      waddnstr(stdscr, (char const   *)base, ncols - (8 + i));
    }
  }
  if (in_home) {
    reset_tilde_in_path(path);
  }
  wattr_off(stdscr, (1U << 17) | (((cfg.curctx + 1U) << 8) & (((1U << 8) - 1U) << 8)),
            (void *)0);
  if (curscroll > 0) {
    wmove(stdscr, 1, 0);
    waddch(stdscr, (chtype const   )'^');
  }
  if (g_state.oldcolor) {
    wattr_on(stdscr, (((cfg.curctx + 1U) << 8) & (((1U << 8) - 1U) << 8)) | (1U << 21),
             (void *)0);
    g_state.dircolor = (uint_t )1;
  }
  if (onscreen + curscroll < ndents) {
    onscreen += curscroll;
  } else {
    onscreen = ndents;
  }
  ncols = adjust_cols(ncols);
  tmp___5 = scanselforpath((char const   *)path, (_Bool)0);
  len = tmp___5;
  i = curscroll;
  while (i < onscreen) {
    j ++;
    wmove(stdscr, j, 0);
    if (len) {
      findmarkentry((size_t )len, pdents + i);
    }
    printent((struct entry  const  *)(pdents + i), (uint_t )ncols, (_Bool )(i == cur));
    i ++;
  }
  if (g_state.dircolor) {
    wattr_off(stdscr, (((cfg.curctx + 1U) << 8) & (((1U << 8) - 1U) << 8)) | (1U << 21),
              (void *)0);
    g_state.dircolor = (uint_t )0;
  }
  if (onscreen < ndents) {
    wmove(stdscr, (int )xlines - 2, 0);
    waddch(stdscr, (chtype const   )'v');
  }
  markhovered();
  return;
}
}
static _Bool cdprep(char *lastdir , char *lastname , char *path , char *newpath ) 
{ 


  {
  if (lastname) {
    *(lastname + 0) = (char )'\000';
  }
  xstrsncpy((char * __restrict  )lastdir, (char const   * __restrict  )path, (size_t )4096);
  xstrsncpy((char * __restrict  )path, (char const   * __restrict  )newpath, (size_t )4096);
  clearfilter();
  return ((_Bool )cfg.filtermode);
}
}
static _Bool browse(char *ipath , char const   *session , int pkey ) 
{ 
  char newpath[4096]  __attribute__((__aligned__)) ;
  char runfile[256]  __attribute__((__aligned__)) ;
  char *path ;
  char *lastdir ;
  char *lastname ;
  char *dir ;
  char *tmp ;
  pEntry pent ;
  enum action sel ;
  struct stat sb ;
  int r ;
  int presel ;
  int selstartid ;
  int selendid ;
  uchar_t opener_flags ;
  int tmp___0 ;
  _Bool watch ;
  _Bool cd ;
  ino_t inode ;
  char *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  __pid_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  _Bool tmp___11 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  _Bool tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  _Bool tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  size_t tmp___25 ;
  int *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  int *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  _Bool tmp___32 ;
  size_t tmp___33 ;
  _Bool tmp___34 ;
  _Bool tmp___35 ;
  _Bool tmp___36 ;
  _Bool tmp___37 ;
  _Bool tmp___38 ;
  char *tmp___39 ;
  char const   *tmp___40 ;
  int tmp___41 ;
  char const   *tmp___42 ;
  char const   *tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  size_t tmp___46 ;
  int tmp___47 ;
  char *tmp___48 ;
  _Bool tmp___49 ;
  _Bool tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  char const   *tmp___53 ;
  int tmp___54 ;
  char const   *tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___60 ;
  int tmp___61 ;
  int *tmp___62 ;
  char *tmp___63 ;
  _Bool tmp___64 ;
  int tmp___65 ;
  _Bool tmp___66 ;
  _Bool refresh___0 ;
  char *tmp___67 ;
  char const   *tmp___68 ;
  _Bool tmp___69 ;
  _Bool tmp___70 ;
  char const   *tmp___71 ;
  char const   *tmp___72 ;
  size_t tmp___73 ;
  size_t tmp___74 ;
  int *tmp___75 ;
  char *tmp___76 ;
  int tmp___77 ;
  int tmp___80 ;
  int tmp___81 ;
  _Bool tmp___82 ;
  char *tmp___83 ;
  _Bool tmp___84 ;
  char *tmp___85 ;
  char const   *tmp___86 ;
  int tmp___87 ;
  int fd ;
  int ret ;
  _Bool tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  _Bool tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  char const   *tmp___95 ;
  char const   *tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  int *tmp___99 ;
  char *tmp___100 ;
  int tmp___101 ;
  _Bool tmp___102 ;
  int tmp___103 ;
  int *tmp___104 ;
  char *tmp___105 ;
  int tmp___106 ;
  int tmp___107 ;
  _Bool tmp___108 ;
  char *tmp___109 ;
  char const   *tmp___110 ;
  int *tmp___111 ;
  char *tmp___112 ;
  _Bool tmp___113 ;
  size_t tmp___114 ;
  char *tmp___115 ;
  _Bool tmp___116 ;
  char const   *tmp___117 ;
  int tmp___118 ;
  _Bool tmp___119 ;
  char const   *tmp___120 ;
  char *tmp___121 ;
  _Bool tmp___122 ;
  _Bool tmp___123 ;
  int ctx ;
  _Bool tmp___124 ;
  char const   *tmp___125 ;

  {
  r = -1;
  selstartid = 0;
  selendid = 0;
  if (cfg.cliopener) {
    tmp___0 = 9;
  } else {
    tmp___0 = 70;
  }
  opener_flags = (uchar_t )tmp___0;
  watch = (_Bool)0;
  cd = (_Bool)1;
  inode = (ino_t )0;
  atexit(& dentfree);
  if ((unsigned long )((void const   *)0) != (unsigned long )((void const   *)stdscr)) {
    xlines = (ushort_t )((int )stdscr->_maxy + 1);
  } else {
    xlines = (ushort_t )-1;
  }
  if ((unsigned long )((void const   *)0) != (unsigned long )((void const   *)stdscr)) {
    xcols = (ushort_t )((int )stdscr->_maxx + 1);
  } else {
    xcols = (ushort_t )-1;
  }
  g_ctx[0].c_last[0] = (char )'\000';
  lastdir = g_ctx[0].c_last;
  if (g_state.initfile) {
    tmp___1 = xbasename(ipath);
    xstrsncpy((char * __restrict  )(g_ctx[0].c_name), (char const   * __restrict  )tmp___1,
              sizeof(g_ctx[0].c_name));
    xdirname(ipath);
  } else {
    g_ctx[0].c_name[0] = (char )'\000';
  }
  lastname = g_ctx[0].c_name;
  xstrsncpy((char * __restrict  )(g_ctx[0].c_path), (char const   * __restrict  )ipath,
            (size_t )4096);
  if (g_state.initfile) {
    free((void *)initpath);
    ipath = getcwd((char *)((void *)0), (size_t )0);
    initpath = ipath;
  }
  path = g_ctx[0].c_path;
  g_ctx[0].c_fltr[1] = (char )'\000';
  g_ctx[0].c_fltr[0] = g_ctx[0].c_fltr[1];
  g_ctx[0].c_cfg = cfg;
  runfile[0] = (char )'\000';
  newpath[0] = runfile[0];
  if (pkey) {
    presel = ';';
  } else {
    if (cfg.filtermode) {
      tmp___2 = '/';
    } else
    if (session) {
      if ((int )g_ctx[cfg.curctx].c_fltr[0] == 47) {
        goto _L;
      } else
      if ((int )g_ctx[cfg.curctx].c_fltr[0] == 92) {
        _L: /* CIL Label */ 
        if (g_ctx[cfg.curctx].c_fltr[1]) {
          tmp___2 = '/';
        } else {
          tmp___2 = 0;
        }
      } else {
        tmp___2 = 0;
      }
    } else {
      tmp___2 = 0;
    }
    presel = tmp___2;
  }
  tmp___3 = xrealloc((void *)pdents, (unsigned long )total_dents * sizeof(struct entry ));
  pdents = (struct entry *)tmp___3;
  if (! pdents) {
    printerr(6626);
  }
  tmp___4 = xrealloc((void *)pnamebuf, (size_t )2048);
  pnamebuf = (char *)tmp___4;
  if (! pnamebuf) {
    printerr(6631);
  }
  if (presel == 47) {
    handle_key_resize();
  }
  begin: 
  tmp___5 = chdir((char const   *)path);
  if (tmp___5 == -1) {
    valid_parent(path, lastname);
    if (cfg.filtermode) {
      presel = '/';
    } else {
      watch = (_Bool)1;
    }
  }
  if (presel == 47) {
    goto _L___0;
  } else
  if (watch) {
    _L___0: /* CIL Label */ 
    if (inotify_wd >= 0) {
      inotify_rm_watch(inotify_fd, inotify_wd);
      inotify_wd = -1;
      watch = (_Bool)0;
    }
  }
  if (order) {
    if (cd) {
      if ((int )cfgsort[cfg.curctx] != 48) {
        if ((int )cfgsort[cfg.curctx] == 122) {
          set_sort_flags('c');
        }
        if (! cfgsort[cfg.curctx]) {
          goto _L___1;
        } else
        if ((int )cfgsort[cfg.curctx] == 99) {
          _L___1: /* CIL Label */ 
          r = get_kv_key(order, path, maxorder, (uchar_t )11);
          if (r > 0) {
            set_sort_flags(r);
            cfgsort[cfg.curctx] = (uchar_t )'z';
          }
        }
      } else {
        cfgsort[cfg.curctx] = cfgsort[4];
      }
    }
  }
  cd = (_Bool)1;
  populate(path, lastname);
  if (g_state.interrupt) {
    cfg.blkorder = (uint_t )0;
    cfg.apparentsz = cfg.blkorder;
    g_state.interrupt = cfg.apparentsz;
    blk_shift = (uchar_t )9;
    presel = 12;
  }
  if (presel != 47) {
    if (inotify_wd == -1) {
      inotify_wd = inotify_add_watch(inotify_fd, (char const   *)path, INOTIFY_MASK);
    }
  }
  while (1) {
    if (presel != 47) {
      redraw(path);
      statusbar(path);
    } else
    if (! g_ctx[cfg.curctx].c_fltr[1]) {
      redraw(path);
      statusbar(path);
    }
    nochange: 
    tmp___6 = getppid();
    if (tmp___6 == 1) {
      _exit(1);
    }
    tmp___7 = chdir((char const   *)path);
    if (tmp___7 == -1) {
      goto begin;
    }
    tmp___8 = isatty(0);
    if (! tmp___8) {
      if (! g_state.picker) {
        return ((_Bool)1);
      }
    }
    tmp___9 = nextsel(presel);
    sel = (enum action )tmp___9;
    if (presel) {
      presel = 0;
    }
    switch ((unsigned int )sel) {
    case 1U: 
    dir = visit_parent(path, newpath, & presel);
    if (! dir) {
      goto nochange;
    }
    tmp___10 = xbasename(path);
    xstrsncpy((char * __restrict  )lastname, (char const   * __restrict  )tmp___10,
              (size_t )256);
    tmp___11 = cdprep(lastdir, (char *)((void *)0), path, dir);
    if (tmp___11) {
      presel = '/';
    } else {
      watch = (_Bool)1;
    }
    goto begin;
    case 2U: 
    case 3U: 
    if (! ndents) {
      cd = (_Bool)0;
      g_state.runplugin = (uint_t )0;
      g_state.selbm = g_state.runplugin;
      goto begin;
    }
    pent = pdents + cur;
    if (! g_state.selbm) {
      mkpath((char const   *)path, (char const   *)pent->name, newpath);
    } else
    if ((pent->mode & 61440U) == 40960U) {
      tmp___12 = realpath((char const   * __restrict  )pent->name, (char * __restrict  )(newpath));
      if (tmp___12) {
        tmp___13 = xstrsncpy((char * __restrict  )path, (char const   * __restrict  )lastdir,
                             (size_t )4096);
        if (! tmp___13) {
          mkpath((char const   *)path, (char const   *)pent->name, newpath);
        }
      } else {
        mkpath((char const   *)path, (char const   *)pent->name, newpath);
      }
    } else {
      mkpath((char const   *)path, (char const   *)pent->name, newpath);
    }
    g_state.selbm = (uint_t )0;
    if (pent->__annonCompField18.flags & 1ULL) {
      tmp___16 = chdir((char const   *)(newpath));
      if (tmp___16 == -1) {
        tmp___14 = __errno_location();
        tmp___15 = strerror(*tmp___14);
        printwait((char const   *)tmp___15, & presel);
        goto nochange;
      }
      tmp___17 = cdprep(lastdir, lastname, path, newpath);
      if (tmp___17) {
        presel = '/';
      } else {
        watch = (_Bool)1;
      }
      goto begin;
    }
    tmp___20 = stat((char const   * __restrict  )(newpath), (struct stat * __restrict  )(& sb));
    if (tmp___20 == -1) {
      tmp___18 = __errno_location();
      tmp___19 = strerror(*tmp___18);
      printwait((char const   *)tmp___19, & presel);
      goto nochange;
    }
    if (! ((sb.st_mode & 61440U) == 32768U)) {
      printwait((char const   *)messages[26], & presel);
      goto nochange;
    }
    if (g_state.runplugin) {
      g_state.runplugin = (uint_t )0;
      if (g_state.runctx == cfg.curctx) {
        tmp___24 = strcmp((char const   *)path, (char const   *)plgpath);
        if (! tmp___24) {
          endselection((_Bool)0);
          xstrsncpy((char * __restrict  )path, (char const   * __restrict  )lastdir,
                    (size_t )4096);
          clearfilter();
          tmp___21 = chdir((char const   *)path);
          if (tmp___21 == -1) {
            tmp___23 = 1;
          } else {
            tmp___22 = run_plugin(& path, (char const   *)pent->name, runfile, & lastname,
                                  & lastdir);
            if (tmp___22) {
              tmp___23 = 0;
            } else {
              tmp___23 = 1;
            }
          }
          if (g_state.picked) {
            return ((_Bool)0);
          }
          if (runfile[0]) {
            xstrsncpy((char * __restrict  )lastname, (char const   * __restrict  )(runfile),
                      (size_t )256);
            runfile[0] = (char )'\000';
          }
          if (cfg.filtermode) {
            presel = '/';
          } else {
            watch = (_Bool)1;
          }
          goto begin;
        }
      }
    }
    if (g_state.picker) {
      if ((unsigned int )sel == 2U) {
        if (nselected == 0) {
          tmp___25 = mkpath((char const   *)path, (char const   *)pent->name, newpath);
          appendfpath((char const   *)(newpath), (size_t const   )tmp___25);
        }
        return ((_Bool)0);
      }
    }
    if ((unsigned int )sel == 3U) {
      if (listpath) {
        if ((pent->mode & 61440U) == 40960U) {
          tmp___33 = xstrlen((char const   * __restrict  )listpath);
          tmp___34 = is_prefix((char const   * __restrict  )path, (char const   * __restrict  )listpath,
                               tmp___33);
          if (tmp___34) {
            tmp___28 = realpath((char const   * __restrict  )pent->name, (char * __restrict  )(newpath));
            if (! tmp___28) {
              tmp___26 = __errno_location();
              tmp___27 = strerror(*tmp___26);
              printwait((char const   *)tmp___27, & presel);
              goto nochange;
            }
            xdirname(newpath);
            tmp___31 = chdir((char const   *)(newpath));
            if (tmp___31 == -1) {
              tmp___29 = __errno_location();
              tmp___30 = strerror(*tmp___29);
              printwait((char const   *)tmp___30, & presel);
              goto nochange;
            }
            tmp___32 = cdprep(lastdir, (char *)((void *)0), path, newpath);
            if (tmp___32) {
              presel = '/';
            } else {
              watch = (_Bool)1;
            }
            xstrsncpy((char * __restrict  )lastname, (char const   * __restrict  )pent->name,
                      (size_t )256);
            goto begin;
          }
        }
      }
      if (cfg.nonavopen) {
        goto nochange;
      }
    }
    if (! sb.st_size) {
      printwait((char const   *)messages[25], & presel);
      goto nochange;
    }
    if (cfg.useeditor) {
      tmp___35 = get_output((char *)"file", (char *)"-biL", newpath, -1, (_Bool)0,
                            (_Bool)0);
      if (tmp___35) {
        tmp___36 = is_prefix((char const   * __restrict  )(g_buf), (char const   * __restrict  )"text/",
                             (size_t )5);
        if (tmp___36) {
          spawn(editor, newpath, (char *)((void *)0), (char *)((void *)0), (ushort_t )9);
          if (cfg.filtermode) {
            presel = '/';
            clearfilter();
          }
          continue;
        }
      }
    }
    tmp = xextension((char const   *)pent->name, (size_t )(pent->__annonCompField18.nlen - 1ULL));
    if (tmp) {
      tmp___41 = regexec((regex_t const   * __restrict  )(& archive_re), (char const   * __restrict  )tmp,
                         (size_t )0, (regmatch_t * __restrict  )((void *)0), 0);
      if (! tmp___41) {
        r = get_input((char const   *)messages[33]);
        if (r == 108) {
          goto _L___2;
        } else
        if (r == 120) {
          _L___2: /* CIL Label */ 
          mkpath((char const   *)path, (char const   *)pent->name, newpath);
          tmp___37 = handle_archive(newpath, (char )r);
          if (! tmp___37) {
            presel = '$';
            goto nochange;
          }
          if (r == 108) {
            statusbar(path);
            goto nochange;
          }
        }
        if (r == 109) {
          tmp___38 = archive_mount(newpath);
          if (! tmp___38) {
            presel = '$';
            goto nochange;
          }
        }
        if (r == 120) {
          goto _L___3;
        } else
        if (r == 109) {
          _L___3: /* CIL Label */ 
          if (newpath[0]) {
            if (ndents) {
              tmp___39 = (pdents + cur)->name;
            } else {
              tmp___39 = (char *)((void *)0);
            }
            set_smart_ctx('+', newpath, & path, tmp___39, & lastname, & lastdir);
          } else {
            if (ndents) {
              tmp___40 = (char const   *)(pdents + cur)->name;
            } else {
              tmp___40 = "\000";
            }
            xstrsncpy((char * __restrict  )lastname, (char const   * __restrict  )tmp___40,
                      (size_t )256);
          }
          clearfilter();
          goto begin;
        }
        if (r != 111) {
          printwait((char const   *)messages[40], & presel);
          goto nochange;
        }
      }
    }
    spawn(opener, newpath, (char *)((void *)0), (char *)((void *)0), (ushort_t )opener_flags);
    if (g_state.autonext) {
      if (cur != ndents - 1) {
        move_cursor((cur + 1) % ndents, 0);
      }
    }
    if (cfg.filtermode) {
      presel = '/';
      clearfilter();
    }
    continue;
    case 13U: 
    case 12U: 
    case 11U: 
    case 10U: 
    case 9U: 
    case 7U: 
    case 8U: 
    case 6U: 
    case 5U: 
    case 4U: 
    if (ndents) {
      g_state.move = (uint_t )1;
      handle_screen_move(sel);
    }
    break;
    case 17U: 
    case 16U: 
    case 15U: 
    case 14U: 
    if ((unsigned int )sel == 14U) {
      dir = home;
    } else {
      if ((unsigned int )sel == 15U) {
        tmp___43 = (char const   *)ipath;
      } else {
        if ((unsigned int )sel == 16U) {
          tmp___42 = (char const   *)lastdir;
        } else {
          tmp___42 = "/";
        }
        tmp___43 = tmp___42;
      }
      dir = (char *)tmp___43;
    }
    if (! dir) {
      printwait((char const   *)messages[27], & presel);
      goto nochange;
    } else
    if (! *dir) {
      printwait((char const   *)messages[27], & presel);
      goto nochange;
    }
    g_state.selbm = (uint_t )0;
    tmp___44 = strcmp((char const   *)path, (char const   *)dir);
    if (tmp___44 == 0) {
      if ((unsigned long )dir == (unsigned long )ipath) {
        if (cfg.filtermode) {
          presel = '/';
        }
        goto nochange;
      }
      dir = lastdir;
    }
    tmp___45 = chdir((char const   *)dir);
    if (tmp___45 == -1) {
      presel = '$';
      goto nochange;
    }
    xstrsncpy((char * __restrict  )(newpath), (char const   * __restrict  )dir, (size_t )4096);
    case 18U: 
    if ((unsigned int )sel == 18U) {
      tmp___46 = handle_bookmark((char const   *)mark, newpath);
      r = (int )tmp___46;
      if (r) {
        printwait((char const   *)messages[r], & presel);
        goto nochange;
      }
      if (g_state.selbm == 1U) {
        presel = '/';
      }
      tmp___47 = strcmp((char const   *)path, (char const   *)(newpath));
      if (tmp___47 == 0) {
        break;
      }
    }
    if (listpath) {
      if ((unsigned int )sel == 16U) {
        tmp___48 = (char *)((void *)0);
      } else {
        tmp___48 = lastname;
      }
    } else {
      tmp___48 = lastname;
    }
    tmp___49 = cdprep(lastdir, tmp___48, path, newpath);
    if (tmp___49) {
      presel = '/';
    } else {
      watch = (_Bool)1;
    }
    goto begin;
    case 19U: 
    if ((unsigned int )sel == 19U) {
      tmp___50 = remote_mount(newpath);
      if (! tmp___50) {
        presel = '$';
        goto nochange;
      }
    }
    if (ndents) {
      tmp___51 = (pdents + cur)->name;
    } else {
      tmp___51 = (char *)((void *)0);
    }
    set_smart_ctx('+', newpath, & path, tmp___51, & lastname, & lastdir);
    clearfilter();
    goto begin;
    case 25U: 
    case 24U: 
    case 23U: 
    case 22U: 
    case 21U: 
    case 20U: 
    r = handle_context_switch(sel);
    if (r < 0) {
      continue;
    }
    if (ndents) {
      tmp___52 = (pdents + cur)->name;
    } else {
      tmp___52 = (char *)((void *)0);
    }
    savecurctx(path, tmp___52, r);
    path = g_ctx[r].c_path;
    lastdir = g_ctx[r].c_last;
    lastname = g_ctx[r].c_name;
    tmp = g_ctx[r].c_fltr;
    if (cfg.filtermode) {
      presel = '/';
    } else
    if ((int )*(tmp + 0) == 47) {
      goto _L___4;
    } else
    if ((int )*(tmp + 0) == 92) {
      _L___4: /* CIL Label */ 
      if (*(tmp + 1)) {
        presel = '/';
      } else {
        watch = (_Bool)1;
      }
    } else {
      watch = (_Bool)1;
    }
    goto begin;
    case 26U: 
    free((void *)mark);
    mark = xstrdup((char const   * __restrict  )path);
    printwait((char const   *)mark, & presel);
    goto nochange;
    case 27U: 
    add_bookmark(path, newpath, & presel);
    goto nochange;
    case 28U: 
    if (inotify_wd >= 0) {
      inotify_rm_watch(inotify_fd, inotify_wd);
      inotify_wd = -1;
    }
    presel = filterentries(path, lastname);
    if (presel == 27) {
      presel = 0;
      break;
    }
    if (presel == 47) {
      cd = (_Bool)0;
      goto begin;
    }
    goto nochange;
    case 35U: 
    case 31U: 
    case 30U: 
    case 29U: 
    switch ((unsigned int )sel) {
    case 29U: 
    cfg.filtermode ^= 1U;
    if (cfg.filtermode) {
      presel = '/';
      clearfilter();
      goto nochange;
    }
    watch = (_Bool)1;
    case 30U: 
    if ((unsigned int )sel == 30U) {
      cfg.showhidden ^= 1U;
      if (cfg.filtermode) {
        presel = '/';
      }
      clearfilter();
    }
    if (ndents) {
      tmp___53 = (char const   *)(pdents + cur)->name;
    } else {
      tmp___53 = "\000";
    }
    xstrsncpy((char * __restrict  )lastname, (char const   * __restrict  )tmp___53,
              (size_t )256);
    cd = (_Bool)0;
    goto begin;
    case 31U: 
    cfg.showdetail ^= 1U;
    cfg.blkorder = (uint_t )0;
    continue;
    default: 
    tmp___54 = get_input((char const   *)messages[36]);
    r = set_sort_flags(tmp___54);
    if (! r) {
      printwait((char const   *)messages[40], & presel);
      goto nochange;
    }
    }
    if (cfg.filtermode) {
      presel = '/';
    } else
    if (g_ctx[cfg.curctx].c_fltr[1]) {
      presel = '/';
    }
    if (ndents) {
      if (ndents) {
        tmp___55 = (char const   *)(pdents + cur)->name;
      } else {
        tmp___55 = "\000";
      }
      xstrsncpy((char * __restrict  )lastname, (char const   * __restrict  )tmp___55,
                (size_t )256);
      if (r == 100) {
        presel = 0;
        goto begin;
      } else
      if (r == 97) {
        presel = 0;
        goto begin;
      }
      qsort((void *)pdents, (size_t )ndents, sizeof(*pdents), entrycmpfn);
      if (ndents) {
        tmp___56 = dentfind((char const   *)lastname, ndents);
        tmp___57 = tmp___56;
      } else {
        tmp___57 = 0;
      }
      move_cursor(tmp___57, 0);
    }
    continue;
    case 33U: 
    case 32U: 
    if (ndents) {
      if (listpath) {
        if ((int )*path != (int )*listpath) {
          tmp___61 = -1;
        } else {
          tmp___60 = strcmp((char const   *)path, (char const   *)listpath);
          tmp___61 = tmp___60;
        }
        if (tmp___61 == 0) {
          tmp = listroot;
        } else {
          tmp = path;
        }
      } else {
        tmp = path;
      }
      mkpath((char const   *)tmp, (char const   *)(pdents + cur)->name, newpath);
      if ((unsigned int )sel == 32U) {
        tmp___64 = show_stats(newpath);
        if (tmp___64) {
          goto _L___5;
        } else {
          tmp___62 = __errno_location();
          tmp___63 = strerror(*tmp___62);
          printwait((char const   *)tmp___63, & presel);
          goto nochange;
        }
      } else {
        _L___5: /* CIL Label */ 
        tmp___65 = lstat((char const   * __restrict  )(newpath), (struct stat * __restrict  )(& sb));
        if (tmp___65 == -1) {
          tmp___62 = __errno_location();
          tmp___63 = strerror(*tmp___62);
          printwait((char const   *)tmp___63, & presel);
          goto nochange;
        } else
        if ((unsigned int )sel == 33U) {
          tmp___66 = xchmod((char const   *)(newpath), sb.st_mode);
          if (! tmp___66) {
            tmp___62 = __errno_location();
            tmp___63 = strerror(*tmp___62);
            printwait((char const   *)tmp___63, & presel);
            goto nochange;
          }
        }
      }
      if ((unsigned int )sel == 33U) {
        (pdents + cur)->mode ^= 73U;
      }
    }
    break;
    case 58U: 
    case 53U: 
    case 52U: 
    case 51U: 
    case 49U: 
    case 36U: 
    refresh___0 = (_Bool)0;
    if (ndents) {
      mkpath((char const   *)path, (char const   *)(pdents + cur)->name, newpath);
    } else
    if ((unsigned int )sel == 53U) {
      goto nochange;
    }
    switch ((unsigned int )sel) {
    case 36U: 
    refresh___0 = (_Bool)1;
    break;
    case 49U: 
    endselection((_Bool)1);
    tmp___67 = xitoa(cfg.showhidden);
    setenv("NNN_INCLUDE_HIDDEN", (char const   *)tmp___67, 1);
    if (listpath) {
      tmp___68 = (char const   *)listroot;
    } else {
      tmp___68 = "";
    }
    setenv("NNN_LIST", tmp___68, 1);
    tmp___69 = getutil((char *)utils[8]);
    if (tmp___69) {
      tmp___70 = plugscript((char const   *)utils[17], (uchar_t )9);
      if (! tmp___70) {
        printwait((char const   *)messages[5], & presel);
        goto nochange;
      }
    } else {
      printwait((char const   *)messages[5], & presel);
      goto nochange;
    }
    clearselection();
    refresh___0 = (_Bool)1;
    break;
    case 51U: 
    show_help((char const   *)path);
    case 52U: 
    if ((unsigned int )sel == 52U) {
      g_state.autonext ^= 1U;
    }
    if (cfg.filtermode) {
      presel = '/';
    }
    if (ndents) {
      tmp___71 = (char const   *)(pdents + cur)->name;
    } else {
      tmp___71 = "\000";
    }
    xstrsncpy((char * __restrict  )lastname, (char const   * __restrict  )tmp___71,
              (size_t )256);
    goto nochange;
    case 53U: 
    if (! g_state.picker) {
      if (! g_state.fifomode) {
        spawn(editor, newpath, (char *)((void *)0), (char *)((void *)0), (ushort_t )9);
      }
    }
    continue;
    default: 
    lock_terminal();
    break;
    }
    if (cfg.filtermode) {
      goto _L___6;
    } else
    if (g_ctx[cfg.curctx].c_fltr[1]) {
      _L___6: /* CIL Label */ 
      if (! refresh___0) {
        presel = '/';
        goto nochange;
      }
    }
    if (ndents) {
      tmp___72 = (char const   *)(pdents + cur)->name;
    } else {
      tmp___72 = "\000";
    }
    xstrsncpy((char * __restrict  )lastname, (char const   * __restrict  )tmp___72,
              (size_t )256);
    cd = (_Bool)0;
    goto begin;
    case 37U: 
    if (! ndents) {
      goto nochange;
    }
    startselection();
    if (g_state.rangesel) {
      g_state.rangesel = (uint_t )0;
    }
    (pdents + cur)->__annonCompField18.flags ^= 16ULL;
    if ((pdents + cur)->__annonCompField18.flags & 16ULL) {
      nselected ++;
      tmp___73 = mkpath((char const   *)path, (char const   *)(pdents + cur)->name,
                        newpath);
      appendfpath((char const   *)(newpath), (size_t const   )tmp___73);
      writesel((char const   *)pselbuf, (size_t const   )(selbufpos - 1U));
    } else {
      nselected --;
      tmp___74 = mkpath((char const   *)path, (char const   *)(pdents + cur)->name,
                        g_sel);
      rmfromselbuf(tmp___74);
    }
    if (! g_state.stayonsel) {
      if (cur != ndents - 1) {
        move_cursor((cur + 1) % ndents, 0);
      }
    }
    break;
    case 38U: 
    if (! ndents) {
      goto nochange;
    }
    startselection();
    g_state.rangesel ^= 1U;
    tmp___77 = stat((char const   * __restrict  )path, (struct stat * __restrict  )(& sb));
    if (tmp___77 == -1) {
      tmp___75 = __errno_location();
      tmp___76 = strerror(*tmp___75);
      printwait((char const   *)tmp___76, & presel);
      goto nochange;
    }
    if (g_state.rangesel) {
      inode = sb.st_ino;
      selstartid = cur;
      continue;
    }
    if (inode != sb.st_ino) {
      printwait((char const   *)messages[42], & presel);
      goto nochange;
    }
    if (cur < selstartid) {
      selendid = selstartid;
      selstartid = cur;
    } else {
      selendid = cur;
    }
    if (selstartid == selendid) {
      resetselind();
      clearselection();
      break;
    }
    case 40U: 
    case 39U: 
    if ((unsigned int )sel == 39U) {
      goto _L___7;
    } else
    if ((unsigned int )sel == 40U) {
      _L___7: /* CIL Label */ 
      if (! ndents) {
        goto nochange;
      }
      startselection();
      if (g_state.rangesel) {
        g_state.rangesel = (uint_t )0;
      }
      selstartid = 0;
      selendid = ndents - 1;
    }
    if (nselected > 1000) {
      printmsg("processing...");
      wrefresh(stdscr);
    } else
    if (nselected) {
      if (ndents > 1000) {
        printmsg("processing...");
        wrefresh(stdscr);
      }
    }
    r = scanselforpath((char const   *)path, (_Bool)1);
    if ((unsigned int )sel == 40U) {
      if (findselpos) {
        invertselbuf((int const   )r);
      } else {
        addtoselbuf((int const   )r, selstartid, selendid);
      }
    } else {
      addtoselbuf((int const   )r, selstartid, selendid);
    }
    continue;
    case 41U: 
    r = editselection();
    if (r <= 0) {
      if (! r) {
        r = 3;
      } else {
        r = 5;
      }
      printwait((char const   *)messages[r], & presel);
    } else
    if (cfg.filtermode) {
      presel = '/';
    } else {
      statusbar(path);
    }
    goto nochange;
    case 45U: 
    case 44U: 
    case 43U: 
    case 42U: 
    if ((unsigned int )sel == 45U) {
      r = get_cur_or_sel();
      if (! r) {
        statusbar(path);
        goto nochange;
      }
      if (r == 99) {
        if (listpath) {
          if ((int )*path != (int )*listpath) {
            tmp___81 = -1;
          } else {
            tmp___80 = strcmp((char const   *)path, (char const   *)listpath);
            tmp___81 = tmp___80;
          }
          if (tmp___81 == 0) {
            tmp = listroot;
          } else {
            tmp = path;
          }
        } else {
          tmp = path;
        }
        mkpath((char const   *)tmp, (char const   *)(pdents + cur)->name, newpath);
        tmp___82 = xrm((char * const  )(newpath));
        if (! tmp___82) {
          continue;
        }
        xrmfromsel(tmp, newpath);
        copynextname(lastname);
        if (cfg.filtermode) {
          presel = '/';
        } else
        if (g_ctx[cfg.curctx].c_fltr[1]) {
          presel = '/';
        }
        cd = (_Bool)0;
        goto begin;
      }
    }
    if (nselected == 1) {
      if ((unsigned int )sel == 42U) {
        tmp___83 = xbasename(pselbuf);
        mkpath((char const   *)path, (char const   *)tmp___83, newpath);
      } else
      if ((unsigned int )sel == 43U) {
        tmp___83 = xbasename(pselbuf);
        mkpath((char const   *)path, (char const   *)tmp___83, newpath);
      } else {
        newpath[0] = (char )'\000';
      }
    } else {
      newpath[0] = (char )'\000';
    }
    endselection((_Bool)1);
    tmp___84 = cpmvrm_selection(sel, path);
    if (! tmp___84) {
      presel = '$';
      goto nochange;
    }
    if (cfg.filtermode) {
      presel = '/';
    }
    clearfilter();
    if (newpath[0]) {
      tmp___87 = access((char const   *)(newpath), 0);
      if (tmp___87) {
        goto _L___8;
      } else {
        tmp___85 = xbasename(newpath);
        xstrsncpy((char * __restrict  )lastname, (char const   * __restrict  )tmp___85,
                  (size_t )256);
      }
    } else {
      _L___8: /* CIL Label */ 
      if (ndents) {
        tmp___86 = (char const   *)(pdents + cur)->name;
      } else {
        tmp___86 = "\000";
      }
      xstrsncpy((char * __restrict  )lastname, (char const   * __restrict  )tmp___86,
                (size_t )256);
    }
    cd = (_Bool)0;
    goto begin;
    case 48U: 
    case 47U: 
    case 46U: 
    case 34U: 
    ret = 'n';
    if (! ndents) {
      if ((unsigned int )sel == 46U) {
        break;
      } else
      if ((unsigned int )sel == 48U) {
        break;
      }
    }
    if ((unsigned int )sel != 46U) {
      endselection((_Bool)1);
    }
    switch ((unsigned int )sel) {
    case 34U: 
    r = get_cur_or_sel();
    if (! r) {
      statusbar(path);
      goto nochange;
    }
    if (r == 115) {
      tmp___88 = selsafe();
      if (! tmp___88) {
        presel = '$';
        goto nochange;
      }
      tmp = (char *)((void *)0);
    } else {
      tmp = (pdents + cur)->name;
    }
    tmp = xreadline((char const   *)tmp, (char const   *)messages[17]);
    break;
    case 46U: 
    tmp = xreadline((char const   *)((void *)0), (char const   *)messages[18]);
    break;
    case 47U: 
    r = get_input((char const   *)messages[11]);
    if (r == 102) {
      tmp = xreadline((char const   *)((void *)0), (char const   *)messages[19]);
    } else
    if (r == 100) {
      tmp = xreadline((char const   *)((void *)0), (char const   *)messages[19]);
    } else
    if (r == 115) {
      goto _L___9;
    } else
    if (r == 104) {
      _L___9: /* CIL Label */ 
      if (nselected <= 1) {
        tmp___89 = 19;
      } else {
        tmp___89 = 20;
      }
      tmp = xreadline((char const   *)((void *)0), (char const   *)messages[tmp___89]);
    } else {
      tmp = (char *)((void *)0);
    }
    break;
    default: 
    tmp = xreadline((char const   *)(pdents + cur)->name, "");
    break;
    }
    if (! tmp) {
      break;
    } else
    if (! *tmp) {
      break;
    }
    switch ((unsigned int )sel) {
    case 34U: 
    if (r == 99) {
      tmp___90 = strcmp((char const   *)tmp, (char const   *)(pdents + cur)->name);
      if (tmp___90 == 0) {
        goto nochange;
      }
    }
    mkpath((char const   *)path, (char const   *)tmp, newpath);
    tmp___93 = access((char const   *)(newpath), 0);
    if (tmp___93 == 0) {
      tmp___91 = get_input((char const   *)messages[13]);
      tmp___92 = xconfirm(tmp___91);
      if (! tmp___92) {
        statusbar(path);
        goto nochange;
      }
    }
    get_archive_cmd(newpath, (char const   *)tmp);
    if (r == 115) {
      archive_selection((char const   *)(newpath), (char const   *)tmp, (char const   *)path);
    } else {
      spawn(newpath, tmp, (pdents + cur)->name, (char *)((void *)0), (ushort_t )25);
    }
    mkpath((char const   *)path, (char const   *)tmp, newpath);
    tmp___94 = access((char const   *)(newpath), 0);
    if (tmp___94 == 0) {
      xstrsncpy((char * __restrict  )lastname, (char const   * __restrict  )tmp, (size_t )256);
      clearfilter();
      clearselection();
      cd = (_Bool)0;
      goto begin;
    }
    continue;
    case 46U: 
    handle_openwith((char const   *)path, (char const   *)(pdents + cur)->name, newpath,
                    tmp);
    if (cfg.filtermode) {
      presel = '/';
    } else {
      statusbar(path);
    }
    if (ndents) {
      tmp___95 = (char const   *)(pdents + cur)->name;
    } else {
      tmp___95 = "\000";
    }
    xstrsncpy((char * __restrict  )lastname, (char const   * __restrict  )tmp___95,
              (size_t )256);
    goto nochange;
    case 48U: 
    tmp___98 = strcmp((char const   *)tmp, (char const   *)(pdents + cur)->name);
    if (tmp___98 == 0) {
      tmp = xreadline((char const   *)(pdents + cur)->name, (char const   *)messages[21]);
      if (! tmp) {
        goto _L___10;
      } else
      if (! *(tmp + 0)) {
        goto _L___10;
      } else {
        tmp___97 = strcmp((char const   *)tmp, (char const   *)(pdents + cur)->name);
        if (! tmp___97) {
          _L___10: /* CIL Label */ 
          if (cfg.filtermode) {
            presel = '/';
          } else {
            statusbar(path);
          }
          if (ndents) {
            tmp___96 = (char const   *)(pdents + cur)->name;
          } else {
            tmp___96 = "\000";
          }
          xstrsncpy((char * __restrict  )lastname, (char const   * __restrict  )tmp___96,
                    (size_t )256);
          goto nochange;
        }
      }
      ret = 'd';
    }
    break;
    default: 
    break;
    }
    fd = open((char const   *)path, 65536);
    if (fd == -1) {
      tmp___99 = __errno_location();
      tmp___100 = strerror(*tmp___99);
      printwait((char const   *)tmp___100, & presel);
      goto nochange;
    }
    tmp___103 = fstatat(fd, (char const   * __restrict  )tmp, (struct stat * __restrict  )(& sb),
                        256);
    if (tmp___103 == 0) {
      if ((unsigned int )sel == 48U) {
        tmp___101 = get_input((char const   *)messages[13]);
        tmp___102 = xconfirm(tmp___101);
        if (! tmp___102) {
          close(fd);
          break;
        }
      } else {
        close(fd);
        printwait((char const   *)messages[28], & presel);
        goto nochange;
      }
    }
    if ((unsigned int )sel == 48U) {
      if (ret == 100) {
        spawn((char *)"cp -rp", (pdents + cur)->name, tmp, (char *)((void *)0), (ushort_t )13);
      } else {
        tmp___106 = renameat(fd, (char const   *)(pdents + cur)->name, fd, (char const   *)tmp);
        if (tmp___106 != 0) {
          close(fd);
          tmp___104 = __errno_location();
          tmp___105 = strerror(*tmp___104);
          printwait((char const   *)tmp___105, & presel);
          goto nochange;
        }
      }
      close(fd);
      xstrsncpy((char * __restrict  )lastname, (char const   * __restrict  )tmp, (size_t )256);
    } else {
      close(fd);
      presel = 0;
      if (r == 102) {
        goto _L___12;
      } else
      if (r == 100) {
        _L___12: /* CIL Label */ 
        mkpath((char const   *)path, (char const   *)tmp, newpath);
        if (r == 102) {
          tmp___107 = 0;
        } else {
          tmp___107 = 1;
        }
        tmp___108 = xmktree(newpath, (_Bool )tmp___107);
        ret = (int )tmp___108;
      } else
      if (r == 115) {
        goto _L___11;
      } else
      if (r == 104) {
        _L___11: /* CIL Label */ 
        if (nselected > 1) {
          if ((int )*(tmp + 0) == 64) {
            if ((int )*(tmp + 1) == 0) {
              *(tmp + 0) = (char )'\000';
            }
          }
        }
        if (ndents) {
          tmp___109 = (pdents + cur)->name;
        } else {
          tmp___109 = (char *)((void *)0);
        }
        ret = xlink(tmp, path, tmp___109, newpath, & presel, r);
      }
      if (! ret) {
        printwait((char const   *)messages[5], & presel);
      }
      if (ret <= 0) {
        goto nochange;
      }
      if (r == 102) {
        xstrsncpy((char * __restrict  )lastname, (char const   * __restrict  )tmp,
                  (size_t )256);
      } else
      if (r == 100) {
        xstrsncpy((char * __restrict  )lastname, (char const   * __restrict  )tmp,
                  (size_t )256);
      } else
      if (ndents) {
        if (cfg.filtermode) {
          presel = '/';
        }
        if (ndents) {
          tmp___110 = (char const   *)(pdents + cur)->name;
        } else {
          tmp___110 = "\000";
        }
        xstrsncpy((char * __restrict  )lastname, (char const   * __restrict  )tmp___110,
                  (size_t )256);
      }
      clearfilter();
    }
    cd = (_Bool)0;
    goto begin;
    case 54U: 
    tmp___113 = xdiraccess((char const   *)plgpath);
    if (! tmp___113) {
      tmp___111 = __errno_location();
      tmp___112 = strerror(*tmp___111);
      printwait((char const   *)tmp___112, & presel);
      goto nochange;
    }
    if (! pkey) {
      tmp___114 = xstrsncpy((char * __restrict  )(g_buf), (char const   * __restrict  )messages[34],
                            (size_t )(4096 + (256 << 1)));
      r = (int )tmp___114;
      printkeys(plug, (g_buf + r) - 1, maxplug);
      printmsg((char const   *)(g_buf));
      r = get_input((char const   *)((void *)0));
    } else {
      r = pkey;
      pkey = '\000';
    }
    if (r != 13) {
      endselection((_Bool)0);
      tmp = get_kv_val(plug, (char *)((void *)0), r, maxplug, (uchar_t )2);
      if (! tmp) {
        printwait((char const   *)messages[40], & presel);
        goto nochange;
      }
      if ((int )*(tmp + 0) == 45) {
        if (*(tmp + 1)) {
          tmp ++;
          r = 0;
        } else {
          r = 1;
        }
      } else {
        r = 1;
      }
      if (ndents) {
        tmp___115 = (pdents + cur)->name;
      } else {
        tmp___115 = (char *)((void *)0);
      }
      tmp___116 = run_plugin(& path, (char const   *)tmp, tmp___115, & lastname, & lastdir);
      if (! tmp___116) {
        printwait((char const   *)messages[5], & presel);
        goto nochange;
      }
      if (g_state.picked) {
        return ((_Bool)0);
      }
      if (ndents) {
        tmp___117 = (char const   *)(pdents + cur)->name;
      } else {
        tmp___117 = "\000";
      }
      xstrsncpy((char * __restrict  )lastname, (char const   * __restrict  )tmp___117,
                (size_t )256);
      if (! r) {
        if (cfg.filtermode) {
          presel = '/';
        } else {
          statusbar(path);
        }
        goto nochange;
      }
    } else {
      g_state.runplugin ^= 1U;
      if (! g_state.runplugin) {
        tmp___118 = strcmp((char const   *)path, (char const   *)plgpath);
        if (tmp___118 == 0) {
          xstrsncpy((char * __restrict  )path, (char const   * __restrict  )lastdir,
                    (size_t )4096);
          xstrsncpy((char * __restrict  )lastname, (char const   * __restrict  )(runfile),
                    (size_t )256);
          runfile[0] = (char )'\000';
          if (cfg.filtermode) {
            presel = '/';
          } else {
            watch = (_Bool)1;
          }
          goto begin;
        }
        g_state.runplugin = (uint_t )1;
      }
      xstrsncpy((char * __restrict  )lastdir, (char const   * __restrict  )path, (size_t )4096);
      xstrsncpy((char * __restrict  )path, (char const   * __restrict  )plgpath, (size_t )4096);
      if (ndents) {
        xstrsncpy((char * __restrict  )(runfile), (char const   * __restrict  )(pdents + cur)->name,
                  (size_t )255);
      }
      g_state.runctx = cfg.curctx;
      *(lastname + 0) = (char )'\000';
    }
    if (cfg.filtermode) {
      presel = '/';
    } else {
      watch = (_Bool)1;
    }
    clearfilter();
    if (g_state.runplugin == 1U) {
      presel = '/';
    }
    goto begin;
    case 57U: 
    case 56U: 
    case 55U: 
    tmp___119 = handle_cmd(sel, newpath);
    r = (int )tmp___119;
    if (cfg.filtermode) {
      presel = '/';
    }
    if (ndents) {
      tmp___120 = (char const   *)(pdents + cur)->name;
    } else {
      tmp___120 = "\000";
    }
    xstrsncpy((char * __restrict  )lastname, (char const   * __restrict  )tmp___120,
              (size_t )256);
    if (! r) {
      goto nochange;
    }
    cd = (_Bool)0;
    goto begin;
    case 50U: 
    presel = 0;
    if (ndents) {
      tmp___121 = (pdents + cur)->name;
    } else {
      tmp___121 = (char *)((void *)0);
    }
    tmp___122 = unmount(tmp___121, newpath, & presel, path);
    if (! tmp___122) {
      if (presel == 0) {
        statusbar(path);
      }
      goto nochange;
    }
    copynextname(lastname);
    cd = (_Bool)0;
    goto begin;
    case 60U: 
    export_file_list();
    if (cfg.filtermode) {
      presel = '/';
    } else {
      statusbar(path);
    }
    goto nochange;
    case 61U: 
    tmp___123 = set_time_type(& presel);
    if (! tmp___123) {
      goto nochange;
    }
    cd = (_Bool)0;
    goto begin;
    case 65U: 
    case 64U: 
    case 63U: 
    case 62U: 
    if ((unsigned int )sel == 62U) {
      ctx = (int )cfg.curctx;
      r = (ctx - 1) & 3;
      while (1) {
        if (r != ctx) {
          if (! (! g_ctx[r].c_cfg.ctxactive)) {
            break;
          }
        } else {
          break;
        }
        r = (r - 1) & 3;
      }
      if (r != ctx) {
        g_ctx[ctx].c_cfg.ctxactive = (uint_t )0;
        path = g_ctx[r].c_path;
        lastdir = g_ctx[r].c_last;
        lastname = g_ctx[r].c_name;
        cfg = g_ctx[r].c_cfg;
        cfg.curctx = (uint_t )r;
        if (cfg.filtermode) {
          presel = '/';
        } else {
          watch = (_Bool)1;
        }
        goto begin;
      }
    } else
    if (! g_state.forcequit) {
      r = 0;
      while (r < 4) {
        if ((uint_t )r != cfg.curctx) {
          if (g_ctx[r].c_cfg.ctxactive) {
            r = get_input((char const   *)messages[15]);
            break;
          }
        }
        r ++;
      }
      if (! (r == 4)) {
        tmp___124 = xconfirm(r);
        if (! tmp___124) {
          break;
        }
      }
    }
    tmp = getenv("NNN_TMPFILE");
    if ((unsigned int )sel == 63U) {
      goto _L___13;
    } else
    if (tmp) {
      _L___13: /* CIL Label */ 
      write_lastdir((char const   *)path, (char const   *)tmp);
      if ((unsigned int )sel == 63U) {
        if (g_state.picker) {
          selbufpos = (uint_t )0;
        }
      }
    }
    if ((unsigned int )sel != 65U) {
      return ((_Bool)0);
    }
    if (selbufpos) {
      if (! g_state.picker) {
        g_state.picker = (uint_t )1;
        free((void *)selpath);
        selpath = (char *)((void *)0);
        return ((_Bool)0);
      }
    }
    return ((_Bool)1);
    default: 
    if ((int )xlines != LINES) {
      continue;
    } else
    if ((int )xcols != COLS) {
      continue;
    }
    if (idletimeout) {
      if ((uint_t )idle == idletimeout) {
        lock_terminal();
        idle = (ushort_t )0;
      }
    }
    if (ndents) {
      tmp___125 = (char const   *)(pdents + cur)->name;
    } else {
      tmp___125 = "\000";
    }
    xstrsncpy((char * __restrict  )lastname, (char const   * __restrict  )tmp___125,
              (size_t )256);
    goto nochange;
    }
  }
}
}
static char *make_tmp_tree(char **paths , ssize_t entries , char const   *prefix ) 
{ 
  int err ;
  struct stat sb ;
  char *slash ;
  char *tmp ;
  ssize_t len ;
  size_t tmp___0 ;
  char *tmpdir ;
  void *tmp___1 ;
  char *tmp___2 ;
  ssize_t i ;
  int *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;

  {
  tmp___0 = xstrlen((char const   * __restrict  )prefix);
  len = (ssize_t )tmp___0;
  tmp___1 = malloc((size_t )4096);
  tmpdir = (char *)tmp___1;
  if (! tmpdir) {
    return ((char *)((void *)0));
  }
  tmp = (tmpdir + (int )tmpfplen) - 1;
  xstrsncpy((char * __restrict  )tmpdir, (char const   * __restrict  )(g_tmpfpath),
            (size_t )tmpfplen);
  xstrsncpy((char * __restrict  )tmp, (char const   * __restrict  )"/nnnXXXXXX", (size_t )11);
  tmp += 10;
  if (! *(prefix + 1)) {
    if ((int const   )*(prefix + 0) == 47) {
      len = (ssize_t )0;
    }
  }
  tmp___2 = mkdtemp(tmpdir);
  if (! tmp___2) {
    free((void *)tmpdir);
    return ((char *)((void *)0));
  }
  listpath = tmpdir;
  i = (ssize_t )0;
  while (i < entries) {
    if (! *(paths + i)) {
      goto __Cont;
    }
    err = stat((char const   * __restrict  )*(paths + i), (struct stat * __restrict  )(& sb));
    if (err) {
      tmp___3 = __errno_location();
      if (*tmp___3 == 2) {
        goto __Cont;
      }
    }
    tmp___4 = xstrlen((char const   * __restrict  )*(paths + i));
    xstrsncpy((char * __restrict  )tmp, (char const   * __restrict  )(*(paths + i) + len),
              (tmp___4 - (size_t )len) + 1UL);
    tmp___5 = xstrlen((char const   * __restrict  )*(paths + i));
    tmp___6 = xmemrchr((uchar_t * __restrict  )((uchar_t *)tmp), (uchar_t )'/', tmp___5 - (size_t )len);
    slash = (char *)tmp___6;
    if (slash) {
      *slash = (char )'\000';
    }
    tmp___7 = access((char const   *)tmpdir, 0);
    if (tmp___7) {
      xmktree(tmpdir, (_Bool)1);
    }
    if (slash) {
      *slash = (char )'/';
    }
    symlink((char const   *)*(paths + i), (char const   *)tmpdir);
    __Cont: /* CIL Label */ 
    i ++;
  }
  *tmp = (char )'\000';
  return (tmpdir);
}
}
static char *load_input(int fd , char const   *path ) 
{ 
  ssize_t i ;
  ssize_t chunk_count ;
  ssize_t chunk ;
  ssize_t entries ;
  char *input ;
  void *tmp ;
  char *tmpdir ;
  char cwd[4096] ;
  char *next ;
  size_t offsets[1 << 14] ;
  char **paths ;
  ssize_t input_read ;
  ssize_t total_read ;
  ssize_t off ;
  int msgnum ;
  char *tmp___0 ;
  void *tmp___1 ;
  ssize_t tmp___2 ;
  void *tmp___3 ;
  char buf[512] ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  _Bool tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
  chunk_count = (ssize_t )1;
  chunk = (ssize_t )524288;
  entries = (ssize_t )0;
  tmp = malloc(sizeof(char ) * (unsigned long )chunk);
  input = (char *)tmp;
  tmpdir = (char *)((void *)0);
  paths = (char **)((void *)0);
  total_read = (ssize_t )0;
  off = (ssize_t )0;
  msgnum = 0;
  if (! input) {
    return ((char *)((void *)0));
  }
  if (! path) {
    tmp___0 = getcwd(cwd, (size_t )4096);
    if (! tmp___0) {
      free((void *)input);
      return ((char *)((void *)0));
    }
  } else {
    xstrsncpy((char * __restrict  )(cwd), (char const   * __restrict  )path, (size_t )4096);
  }
  while (1) {
    if (chunk_count < 512L) {
      if (! (! msgnum)) {
        break;
      }
    } else {
      break;
    }
    input_read = read(fd, (void *)(input + total_read), (size_t )chunk);
    if (input_read < 0L) {
      goto malloc_1;
    }
    if (input_read == 0L) {
      break;
    }
    total_read += input_read;
    chunk_count ++;
    while (off < total_read) {
      tmp___1 = memchr((void const   *)(input + off), '\000', (size_t )(total_read - off));
      next = (char *)tmp___1;
      if ((unsigned long )next == (unsigned long )((void *)0)) {
        break;
      }
      next ++;
      if (next - input == off + 1L) {
        off = next - input;
        continue;
      }
      if (entries == (ssize_t )(1 << 14)) {
        msgnum = 44;
        break;
      }
      tmp___2 = entries;
      entries ++;
      offsets[tmp___2] = (size_t )off;
      off = next - input;
    }
    if (chunk_count == 512L) {
      msgnum = 10;
      break;
    }
    if (chunk_count == (total_read - input_read) / chunk) {
      continue;
    }
    chunk_count = total_read / chunk;
    if (total_read % chunk) {
      chunk_count ++;
    }
    tmp___3 = xrealloc((void *)input, (size_t )((chunk_count + 1L) * chunk));
    input = (char *)tmp___3;
    if (! input) {
      return ((char *)((void *)0));
    }
  }
  if (msgnum) {
    while (1) {
      tmp___4 = read(fd, (void *)(buf), (size_t )512);
      if (! (tmp___4 > 0L)) {
        break;
      }
    }
  }
  if (off != total_read) {
    if (entries == (ssize_t )(1 << 14)) {
      msgnum = 44;
    } else {
      tmp___5 = entries;
      entries ++;
      offsets[tmp___5] = (size_t )off;
    }
  }
  if (! entries) {
    msgnum = 1;
    goto malloc_1;
  }
  *(input + total_read) = (char )'\000';
  tmp___6 = malloc((unsigned long )entries * sizeof(char *));
  paths = (char **)tmp___6;
  if (! paths) {
    goto malloc_1;
  }
  i = (ssize_t )0;
  while (i < entries) {
    *(paths + i) = input + offsets[i];
    i ++;
  }
  tmp___7 = malloc(sizeof(char ) * 4096UL);
  listroot = (char *)tmp___7;
  if (! listroot) {
    goto malloc_1;
  }
  *(listroot + 0) = (char )'\000';
  i = (ssize_t )0;
  while (i < entries) {
    if ((int )*(*(paths + i) + 0) == 10) {
      *(paths + i) = (char *)((void *)0);
      goto __Cont;
    } else {
      tmp___8 = selforparent((char const   *)*(paths + i));
      if (tmp___8) {
        *(paths + i) = (char *)((void *)0);
        goto __Cont;
      }
    }
    *(paths + i) = abspath((char const   *)*(paths + i), (char const   *)(cwd), (char *)((void *)0));
    if (! *(paths + i)) {
      entries = i;
      goto malloc_2;
    }
    xstrsncpy((char * __restrict  )(g_buf), (char const   * __restrict  )*(paths + i),
              (size_t )4096);
    tmp___9 = xdirname(g_buf);
    tmp___10 = common_prefix((char const   *)tmp___9, listroot);
    if (! tmp___10) {
      entries = i + 1L;
      goto malloc_2;
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  if (*(listroot + 0)) {
    tmpdir = make_tmp_tree(paths, entries, (char const   *)listroot);
  }
  malloc_2: 
  i = entries - 1L;
  while (i >= 0L) {
    free((void *)*(paths + i));
    i --;
  }
  malloc_1: 
  if (msgnum) {
    if (home) {
      printmsg((char const   *)messages[msgnum]);
      xdelay((useconds_t )(350000 << 2));
    } else {
      msg((char const   *)messages[msgnum]);
      usleep((__useconds_t )(350000 << 2));
    }
  }
  free((void *)input);
  free((void *)paths);
  return (tmpdir);
}
}
static void check_key_collision(void) 
{ 
  int key ;
  _Bool bitmap[511] ;
  unsigned int tmp ;
  ullong_t i ;
  char const   *tmp___0 ;

  {
  bitmap[0] = (_Bool)0;
  tmp = 1U;
  while (! (tmp >= 511U)) {
    bitmap[tmp] = (_Bool)0;
    tmp ++;
  }
  i = (ullong_t )0;
  while (i < (ullong_t )(sizeof(bindings) / sizeof(bindings[0]))) {
    key = (int )bindings[i].sym;
    if (bitmap[key]) {
      tmp___0 = keyname(key);
      dprintf(2, (char const   * __restrict  )"key collision! [%s]\n", tmp___0);
    } else {
      bitmap[key] = (_Bool)1;
    }
    i ++;
  }
  return;
}
}
static void usage(void) 
{ 


  {
  dprintf(1, (char const   * __restrict  )"%s: nnn [OPTIONS] [PATH]\n\nThe unorthodox terminal file manager.\n\npositional args:\n  PATH   start dir/file [default: .]\n\noptional args:\n -A      no dir auto-enter during filter\n -b key  open bookmark key (trumps -s/S)\n -B      use bsdtar for archives\n -c      cli-only NNN_OPENER (trumps -e)\n -C      8-color scheme\n -d      detail mode\n -D      dirs in context color\n -e      text in $VISUAL/$EDITOR/vi\n -E      internal edits in EDITOR\n -g      regex filters\n -H      show hidden files\n -i      show current file info\n -J      no auto-advance on selection\n -K      detect key collision\n -l val  set scroll lines\n -n      type-to-nav mode\n -o      open files only on Enter\n -p file selection file [-:stdout]\n -P key  run plugin key\n -Q      no quit confirmation\n -r      use advcpmv patched cp, mv\n -R      no rollover at edges\n -t secs timeout to lock\n -T key  sort order [a/d/e/r/s/t/v]\n -u      use selection (no prompt)\n -V      show version\n -h      show help\n\nv%s\n%s\n",
          "usage", "4.6", "BSD 2-Clause\nhttps://github.com/jarun/nnn");
  return;
}
}
static _Bool setup_config(void) 
{ 
  size_t r ;
  size_t len ;
  char *xdgcfg ;
  char *tmp ;
  _Bool xdg ;
  char *tmp___0 ;
  _Bool tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  _Bool tmp___12 ;
  char *env_sel ;
  char *tmp___13 ;
  char *tmp___14 ;
  void *tmp___15 ;
  char *tmp___16 ;

  {
  tmp = getenv("XDG_CONFIG_HOME");
  xdgcfg = tmp;
  xdg = (_Bool)0;
  if (xdgcfg) {
    if (*(xdgcfg + 0)) {
      if ((int )*(xdgcfg + 0) == 126) {
        r = xstrsncpy((char * __restrict  )(g_buf), (char const   * __restrict  )home,
                      (size_t )4096);
        xstrsncpy((char * __restrict  )((g_buf + r) - 1), (char const   * __restrict  )(xdgcfg + 1),
                  (size_t )4096);
        xdgcfg = g_buf;
      }
      tmp___1 = xdiraccess((char const   *)xdgcfg);
      if (! tmp___1) {
        tmp___0 = xitoa((uint_t )8196);
        perror((char const   *)tmp___0);
        return ((_Bool)0);
      }
      tmp___2 = xstrlen((char const   * __restrict  )xdgcfg);
      tmp___3 = xstrlen((char const   * __restrict  )"/nnn/bookmarks");
      len = (tmp___2 + tmp___3) + 1UL;
      xdg = (_Bool)1;
    }
  }
  if (! xdg) {
    tmp___4 = xstrlen((char const   * __restrict  )home);
    tmp___5 = xstrlen((char const   * __restrict  )"/.config/nnn/bookmarks");
    len = (tmp___4 + tmp___5) + 1UL;
  }
  tmp___6 = malloc(len);
  cfgpath = (char *)tmp___6;
  tmp___7 = malloc(len);
  plgpath = (char *)tmp___7;
  if (! cfgpath) {
    tmp___8 = xitoa((uint_t )8210);
    perror((char const   *)tmp___8);
    return ((_Bool)0);
  } else
  if (! plgpath) {
    tmp___8 = xitoa((uint_t )8210);
    perror((char const   *)tmp___8);
    return ((_Bool)0);
  }
  if (xdg) {
    xstrsncpy((char * __restrict  )cfgpath, (char const   * __restrict  )xdgcfg, len);
    tmp___9 = xstrlen((char const   * __restrict  )"/nnn/bookmarks");
    r = len - tmp___9;
  } else {
    r = xstrsncpy((char * __restrict  )cfgpath, (char const   * __restrict  )home,
                  len);
    xstrsncpy((char * __restrict  )((cfgpath + r) - 1), (char const   * __restrict  )"/.config",
              len - r);
    r += 8UL;
  }
  xstrsncpy((char * __restrict  )((cfgpath + r) - 1), (char const   * __restrict  )"/nnn",
            len - r);
  r = (size_t )0;
  while (r < sizeof(toks) / sizeof(toks[0])) {
    mkpath((char const   *)cfgpath, (char const   *)toks[r], plgpath);
    tmp___11 = access((char const   *)plgpath, 0);
    if (tmp___11) {
      tmp___12 = xmktree(plgpath, (_Bool)1);
      if (! tmp___12) {
        tmp___10 = xitoa((uint_t )8236);
        perror((char const   *)tmp___10);
        return ((_Bool)0);
      }
    }
    r ++;
  }
  if (! g_state.picker) {
    tmp___13 = xgetenv(env_cfg[9], (char *)((void *)0));
    env_sel = tmp___13;
    if (env_sel) {
      tmp___14 = xstrdup((char const   * __restrict  )env_sel);
      selpath = tmp___14;
    } else {
      tmp___15 = malloc(len + 3UL);
      selpath = (char *)tmp___15;
    }
    if (! selpath) {
      tmp___16 = xitoa((uint_t )8249);
      perror((char const   *)tmp___16);
      return ((_Bool)0);
    }
    if (! env_sel) {
      r = xstrsncpy((char * __restrict  )selpath, (char const   * __restrict  )cfgpath,
                    len + 3UL);
      xstrsncpy((char * __restrict  )((selpath + r) - 1), (char const   * __restrict  )"/.selection",
                (size_t )12);
    }
  }
  return ((_Bool)1);
}
}
static _Bool set_tmp_path(void) 
{ 
  char *tmp ;
  char *path ;
  char *tmp___1 ;
  char *tmp___2 ;
  _Bool tmp___3 ;
  size_t tmp___4 ;

  {
  tmp = (char *)"/tmp";
  tmp___3 = xdiraccess((char const   *)tmp);
  if (tmp___3) {
    tmp___2 = tmp;
  } else {
    tmp___1 = getenv("TMPDIR");
    tmp___2 = tmp___1;
  }
  path = tmp___2;
  if (! path) {
    msg("set TMPDIR");
    return ((_Bool)0);
  }
  tmp___4 = xstrsncpy((char * __restrict  )(g_tmpfpath), (char const   * __restrict  )path,
                      (size_t )64);
  tmpfplen = (uchar_t )tmp___4;
  return ((_Bool)1);
}
}
static void cleanup(void) 
{ 


  {
  free((void *)selpath);
  free((void *)plgpath);
  free((void *)cfgpath);
  free((void *)initpath);
  free((void *)bmstr);
  free((void *)pluginstr);
  free((void *)listroot);
  free((void *)ihashbmp);
  free((void *)bookmark);
  free((void *)plug);
  free((void *)lastcmd);
  if (g_state.pluginit) {
    unlink((char const   *)(g_pipepath));
  }
  return;
}
}
int main(int argc , char **argv ) 
{ 
  char *arg ;
  char *session ;
  int fd ;
  int opt ;
  int sort ;
  int pkey ;
  char const   *env_opts ;
  char *tmp ;
  int env_opts_id ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  _Bool tmp___10 ;
  _Bool tmp___11 ;
  _Bool tmp___12 ;
  _Bool tmp___13 ;
  char *startpath ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  size_t tmp___17 ;
  _Bool tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  struct stat sb ;
  char *tmp___21 ;
  int tmp___22 ;
  char const   *tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  uint_t tmp___26 ;
  struct sigaction act ;
  char *tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  char *tmp___32 ;
  int tmp___33 ;
  _Bool tmp___34 ;
  _Bool tmp___35 ;
  int tmp___36 ;
  char *tmp___37 ;
  size_t tmp___38 ;

  {
  arg = (char *)((void *)0);
  session = (char *)((void *)0);
  sort = 0;
  pkey = '\000';
  tmp = xgetenv(env_cfg[0], (char *)((void *)0));
  env_opts = (char const   *)tmp;
  if (env_opts) {
    tmp___0 = xstrlen((char const   * __restrict  )env_opts);
    tmp___1 = (int )tmp___0;
  } else {
    tmp___1 = -1;
  }
  env_opts_id = tmp___1;
  while (1) {
    if (env_opts_id > 0) {
      env_opts_id --;
      opt = (int )*(env_opts + env_opts_id);
    } else {
      tmp___4 = getopt(argc, (char * const  *)argv, "aAb:BcCdDeEfF:gHiJKl:nop:P:QrRs:St:T:uUVxh");
      opt = tmp___4;
    }
    if (! (opt != -1)) {
      break;
    }
    switch (opt) {
    case 65: 
    cfg.autoenter = (uint_t )0;
    break;
    case 98: 
    if (env_opts_id < 0) {
      arg = optarg;
    }
    break;
    case 66: 
    g_state.usebsdtar = (uint_t )1;
    break;
    case 99: 
    cfg.cliopener = (uint_t )1;
    break;
    case 67: 
    g_state.oldcolor = (uint_t )1;
    break;
    case 100: 
    cfg.showdetail = (uint_t )1;
    break;
    case 68: 
    g_state.dirctx = (uint_t )1;
    break;
    case 101: 
    cfg.useeditor = (uint_t )1;
    break;
    case 69: 
    cfg.waitedit = (uint_t )1;
    break;
    case 102: 
    break;
    case 103: 
    cfg.regex = (uint_t )1;
    filterfn = & visible_re;
    break;
    case 72: 
    cfg.showhidden = (uint_t )1;
    break;
    case 105: 
    cfg.fileinfo = (uint_t )1;
    break;
    case 74: 
    g_state.stayonsel = (uint_t )1;
    break;
    case 75: 
    check_key_collision();
    return (0);
    case 108: 
    if (env_opts_id < 0) {
      scroll_lines = atoi((char const   *)optarg);
    }
    break;
    case 110: 
    cfg.filtermode = (uint_t )1;
    break;
    case 111: 
    cfg.nonavopen = (uint_t )1;
    break;
    case 112: 
    if (env_opts_id >= 0) {
      break;
    }
    g_state.picker = (uint_t )1;
    if ((int )*(optarg + 0) == 45) {
      if (! ((int )*(optarg + 1) == 0)) {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      fd = open((char const   *)optarg, 65, 384);
      if (fd == -1) {
        tmp___2 = xitoa((uint_t )8416);
        perror((char const   *)tmp___2);
        return (1);
      }
      close(fd);
      selpath = abspath((char const   *)optarg, (char const   *)((void *)0), (char *)((void *)0));
      unlink((char const   *)selpath);
    }
    break;
    case 80: 
    if (env_opts_id < 0) {
      if (! *(optarg + 1)) {
        pkey = (int )((uchar_t )*(optarg + 0));
      }
    }
    break;
    case 81: 
    g_state.forcequit = (uint_t )1;
    break;
    case 114: 
    mv[5] = (char )'g';
    mv[2] = mv[5];
    cp[5] = mv[2];
    cp[2] = cp[5];
    mv[4] = (char )'-';
    cp[4] = mv[4];
    break;
    case 82: 
    cfg.rollover = (uint_t )0;
    break;
    case 116: 
    if (env_opts_id < 0) {
      tmp___3 = atoi((char const   *)optarg);
      idletimeout = (uint_t )tmp___3;
    }
    break;
    case 84: 
    if (env_opts_id < 0) {
      sort = (int )((uchar_t )*(optarg + 0));
    }
    break;
    case 117: 
    cfg.prefersel = (uint_t )1;
    break;
    case 85: 
    g_state.uidgid = (uint_t )1;
    break;
    case 86: 
    dprintf(1, (char const   * __restrict  )"%s\n", "4.6");
    return (0);
    case 120: 
    cfg.x11 = (uint_t )1;
    break;
    case 104: 
    usage();
    return (0);
    default: 
    usage();
    return (1);
    }
    if (env_opts_id == 0) {
      env_opts_id = -1;
    }
  }
  tmp___5 = set_tmp_path();
  if (! tmp___5) {
    return (1);
  }
  atexit(& cleanup);
  tmp___8 = isatty(0);
  if (! tmp___8) {
    initpath = load_input(0, (char const   *)((void *)0));
    if (! initpath) {
      return (1);
    }
    tmp___7 = isatty(1);
    if (tmp___7) {
      dup2(1, 0);
    } else {
      tmp___6 = ctermid((char *)((void *)0));
      fd = open((char const   *)tmp___6, 0, 256);
      dup2(fd, 0);
      close(fd);
    }
    if (session) {
      session = (char *)((void *)0);
    }
  }
  home = getenv("HOME");
  if (! home) {
    msg("set HOME");
    return (1);
  }
  tmp___9 = xstrlen((char const   * __restrict  )home);
  homelen = (uchar_t )tmp___9;
  tmp___10 = setup_config();
  if (! tmp___10) {
    return (1);
  }
  opener = xgetenv(env_cfg[3], (char *)utils[0]);
  tmp___11 = parsekvpair(& bookmark, & bmstr, (uchar_t const   )1, & maxbm);
  if (! tmp___11) {
    msg((char const   *)env_cfg[1]);
    return (1);
  }
  tmp___12 = parsekvpair(& plug, & pluginstr, (uchar_t const   )2, & maxplug);
  if (! tmp___12) {
    msg((char const   *)env_cfg[2]);
    return (1);
  }
  tmp___13 = parsekvpair(& order, & orderstr, (uchar_t const   )11, & maxorder);
  if (! tmp___13) {
    msg((char const   *)env_cfg[11]);
    return (1);
  }
  if (! initpath) {
    if (arg) {
      if (! *(arg + 1)) {
        initpath = get_kv_val(bookmark, (char *)((void *)0), (int )*arg, maxbm, (uchar_t )1);
      }
      if (! initpath) {
        msg((char const   *)messages[40]);
        return (1);
      }
      if (session) {
        session = (char *)((void *)0);
      }
    } else
    if (argc == optind) {
      tmp___14 = getenv("PWD");
      startpath = tmp___14;
      if (startpath) {
        tmp___15 = xstrdup((char const   * __restrict  )startpath);
        initpath = tmp___15;
      } else {
        tmp___16 = getcwd((char *)((void *)0), (size_t )0);
        initpath = tmp___16;
      }
      if (! initpath) {
        initpath = (char *)"/";
      }
    } else {
      arg = *(argv + optind);
      tmp___17 = xstrlen((char const   * __restrict  )arg);
      if (tmp___17 > 7UL) {
        tmp___18 = is_prefix((char const   * __restrict  )arg, (char const   * __restrict  )"file://",
                             (size_t )7);
        if (tmp___18) {
          arg += 7;
        }
      }
      initpath = abspath((char const   *)arg, (char const   *)((void *)0), (char *)((void *)0));
      if (! initpath) {
        tmp___19 = xitoa((uint_t )8573);
        perror((char const   *)tmp___19);
        return (1);
      }
      tmp___20 = xbasename(initpath);
      if ((int )*tmp___20 == 46) {
        cfg.showhidden = (uint_t )1;
      }
      tmp___22 = stat((char const   * __restrict  )initpath, (struct stat * __restrict  )(& sb));
      if (tmp___22 == -1) {
        tmp___21 = xitoa((uint_t )8589);
        perror((char const   *)tmp___21);
        return (1);
      }
      if (! ((sb.st_mode & 61440U) == 16384U)) {
        g_state.initfile = (uint_t )1;
      }
      if (session) {
        session = (char *)((void *)0);
      }
    }
  }
  enveditor = getenv((char const   *)env_cfg[10]);
  if (enveditor) {
    tmp___23 = (char const   * const  )enveditor;
  } else {
    tmp___23 = patterns[2];
  }
  tmp___24 = setfilter(& archive_re, (char const   *)tmp___23);
  if (tmp___24) {
    msg((char const   *)messages[35]);
    return (1);
  }
  if (cfg.cliopener) {
    cfg.useeditor = (uint_t )0;
  }
  enveditor = xgetenv(envs[2], (char *)utils[11]);
  editor = xgetenv(envs[1], enveditor);
  pager = xgetenv(envs[3], (char *)utils[12]);
  shell = xgetenv(envs[0], (char *)utils[13]);
  inotify_fd = inotify_init1(526336);
  if (inotify_fd < 0) {
    tmp___25 = xitoa((uint_t )8659);
    perror((char const   *)tmp___25);
    return (1);
  }
  tmp___26 = xgetenv_val((char const   *)env_cfg[13]);
  opt = (int )tmp___26;
  if (opt) {
    if (opt <= 2) {
      g_state.trash = (uint_t )opt;
    }
  }
  act.__sigaction_handler.sa_handler = & sigint_handler;
  act.sa_mask.__val[0] = 0UL;
  act.sa_mask.__val[1] = 0UL;
  act.sa_mask.__val[2] = 0UL;
  act.sa_mask.__val[3] = 0UL;
  act.sa_mask.__val[4] = 0UL;
  act.sa_mask.__val[5] = 0UL;
  act.sa_mask.__val[6] = 0UL;
  act.sa_mask.__val[7] = 0UL;
  act.sa_mask.__val[8] = 0UL;
  act.sa_mask.__val[9] = 0UL;
  act.sa_mask.__val[10] = 0UL;
  act.sa_mask.__val[11] = 0UL;
  act.sa_mask.__val[12] = 0UL;
  act.sa_mask.__val[13] = 0UL;
  act.sa_mask.__val[14] = 0UL;
  act.sa_mask.__val[15] = 0UL;
  act.sa_flags = 0;
  act.sa_restorer = (void (*)(void))0;
  tmp___28 = sigaction(2, (struct sigaction  const  * __restrict  )(& act), (struct sigaction * __restrict  )((void *)0));
  if (tmp___28 < 0) {
    tmp___27 = xitoa((uint_t )8685);
    perror((char const   *)tmp___27);
    return (1);
  }
  act.__sigaction_handler.sa_handler = & clean_exit_sighandler;
  tmp___30 = sigaction(15, (struct sigaction  const  * __restrict  )(& act), (struct sigaction * __restrict  )((void *)0));
  if (tmp___30 < 0) {
    tmp___29 = xitoa((uint_t )8692);
    perror((char const   *)tmp___29);
    return (1);
  } else {
    tmp___31 = sigaction(1, (struct sigaction  const  * __restrict  )(& act), (struct sigaction * __restrict  )((void *)0));
    if (tmp___31 < 0) {
      tmp___29 = xitoa((uint_t )8692);
      perror((char const   *)tmp___29);
      return (1);
    }
  }
  act.__sigaction_handler.sa_handler = (void (*)(int  ))1;
  tmp___33 = sigaction(3, (struct sigaction  const  * __restrict  )(& act), (struct sigaction * __restrict  )((void *)0));
  if (tmp___33 < 0) {
    tmp___32 = xitoa((uint_t )8699);
    perror((char const   *)tmp___32);
    return (1);
  }
  tmp___34 = initcurses((void *)0);
  if (! tmp___34) {
    return (1);
  }
  if (sort) {
    set_sort_flags(sort);
  }
  tmp___35 = browse(initpath, (char const   *)session, pkey);
  opt = (int )tmp___35;
  endwin();
  if (g_state.picker) {
    if (selbufpos) {
      if (selpath) {
        tmp___36 = open((char const   *)selpath, 577, 384);
        fd = tmp___36;
      } else {
        fd = 1;
      }
      if (fd == -1) {
        tmp___37 = xitoa((uint_t )8773);
        perror((char const   *)tmp___37);
      } else {
        tmp___38 = seltofile(fd, (uint_t *)((void *)0));
        if (tmp___38 != (size_t )selbufpos) {
          tmp___37 = xitoa((uint_t )8773);
          perror((char const   *)tmp___37);
        }
      }
      if (fd > 1) {
        close(fd);
      }
    }
  } else
  if (selpath) {
    unlink((char const   *)selpath);
  }
  rmlistpath();
  regfree(& archive_re);
  free((void *)pselbuf);
  if (inotify_wd >= 0) {
    inotify_rm_watch(inotify_fd, inotify_wd);
  }
  close(inotify_fd);
  return (opt);
}
}
#pragma merger("0","/tmp/cil-WQT8CLyu.i","")
