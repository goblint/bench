/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */
#include <stdio.h>
#include <stdlib.h>
#include <time.h> 
#include <pthread.h>
#include <sys/inotify.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/statvfs.h>
#include <string.h>
#include <dirent.h>
#include <limits.h>
#include <strings.h>
#include <regex.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fts.h>
#include <fcntl.h>
#include <stdint.h>

typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef int __pid_t;
typedef long __clock_t;
typedef unsigned long __rlim_t;
typedef long __time_t;
typedef unsigned int __useconds_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef unsigned long __fsblkcnt_t;
typedef unsigned long __fsfilcnt_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
typedef __int8_t int8_t;
typedef __uint8_t uint8_t;
typedef __uint32_t uint32_t;

typedef __rlim_t rlim_t;


struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
typedef __dev_t dev_t;
typedef __ino_t ino_t;
typedef __mode_t mode_t;
typedef __nlink_t nlink_t;
typedef __off_t off_t;
typedef __blkcnt_t blkcnt_t;
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};

typedef __pid_t pid_t;
struct __anonstruct___sigset_t_991265788 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___sigset_t_991265788 __sigset_t;
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
typedef union sigval __sigval_t;
struct __anonstruct__kill_244518854 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
struct __anonstruct__timer_490064738 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
struct __anonstruct__rt_619254530 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
struct __anonstruct__sigchld_284671705 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
struct __anonstruct__addr_bnd_5259977 {
   void *_lower ;
   void *_upper ;
};
union __anonunion__bounds_432680557 {
   struct __anonstruct__addr_bnd_5259977 _addr_bnd ;
   __uint32_t _pkey ;
};
struct __anonstruct__sigfault_40845203 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion__bounds_432680557 _bounds ;
};
struct __anonstruct__sigpoll_386613454 {
   long si_band ;
   int si_fd ;
};
struct __anonstruct__sigsys_44812255 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
union __anonunion__sifields_85651287 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_244518854 _kill ;
   struct __anonstruct__timer_490064738 _timer ;
   struct __anonstruct__rt_619254530 _rt ;
   struct __anonstruct__sigchld_284671705 _sigchld ;
   struct __anonstruct__sigfault_40845203 _sigfault ;
   struct __anonstruct__sigpoll_386613454 _sigpoll ;
   struct __anonstruct__sigsys_44812255 _sigsys ;
};
struct __anonstruct_siginfo_t_27519928 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion__sifields_85651287 _sifields ;
};
typedef struct __anonstruct_siginfo_t_27519928 siginfo_t;
union pthread_attr_t ;
typedef union pthread_attr_t pthread_attr_t;
union __anonunion___sigaction_handler_363639592 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
struct sigaction {
   union __anonunion___sigaction_handler_363639592 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
typedef unsigned long size_t;
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};

struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
struct __dirstream ;
typedef struct __dirstream DIR;
typedef __ssize_t ssize_t;
typedef __useconds_t useconds_t;
typedef unsigned long __re_long_size_t;
typedef unsigned long reg_syntax_t;
struct re_dfa_t ;

typedef struct re_pattern_buffer regex_t;
typedef int regoff_t;
struct __anonstruct_regmatch_t_1035675074 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
typedef struct __anonstruct_regmatch_t_1035675074 regmatch_t;
typedef int wchar_t;
typedef unsigned int chtype;
struct screen ;
typedef struct screen SCREEN;
struct _win_st ;
typedef struct _win_st WINDOW;
typedef chtype attr_t;
typedef unsigned int wint_t;
struct __anonstruct_cchar_t_667532103 {
   attr_t attr ;
   wchar_t chars[5] ;
   int ext_color ;
};
typedef struct __anonstruct_cchar_t_667532103 cchar_t;
struct ldat ;
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};

enum action {
    SEL_BACK = 1,
} ;

typedef unsigned int uint_t;
typedef unsigned char uchar_t;
typedef unsigned short ushort_t;
typedef unsigned long long ullong_t;
struct __anonstruct____missing_field_name_824606445 {
   ullong_t blocks : 40 ;
   ullong_t nlen : 16 ;
   ullong_t flags : 8 ;
};
struct entry {
   char *name ;
   time_t sec ;
   uint_t nsec ;
   mode_t mode ;
   off_t size ;
   struct __anonstruct____missing_field_name_824606445 __annonCompField18 ;
};
struct __anonstruct_selmark_653462436 {
   char *startpos ;
   size_t len ;
};
typedef struct __anonstruct_selmark_653462436 selmark;
struct __anonstruct_kv_1012109243 {
   int key ;
   int off ;
};
typedef struct __anonstruct_kv_1012109243 kv;
struct __anonstruct_fltrexp_t_723168813 {
   regex_t const   *regex ;
   char const   *str ;
};
typedef struct __anonstruct_fltrexp_t_723168813 fltrexp_t;
struct __anonstruct_settings_893539002 {
   uint_t apparentsz : 1 ;
   uint_t blkorder : 1 ;
   uint_t showhidden : 1 ;
   uint_t reverse : 1 ;
   uint_t curctx : 3 ;
   uint_t prefersel : 1 ;
   uint_t regex : 1 ;
   uint_t x11 : 1 ;
   uint_t timetype : 2 ;
   uint_t rollover : 1 ;
};
typedef struct __anonstruct_settings_893539002 settings;
struct __anonstruct_runstate_1070726198 {
   uint_t duinit : 1 ;
   uint_t forcequit : 1 ;
   uint_t interrupt : 1 ;
   uint_t move : 1 ;
   uint_t picked : 1 ;
   uint_t picker : 1 ;
   uint_t pluginit : 1 ;
   uint_t runplugin : 1 ;
   uint_t uidgid : 1 ;
   uint_t reserved : 5 ;
};
typedef struct __anonstruct_runstate_1070726198 runstate;
struct __anonstruct_context_430508109 {
   char c_path[4096] ;
   char c_last[4096] ;
   char c_name[256] ;
   char c_fltr[48] ;
   settings c_cfg ;
   uint_t color ;
};
typedef struct __anonstruct_context_430508109 context;
struct __anonstruct_thread_data_232432842 {
   char path[4096] ;
   int entnum ;
   ushort_t core ;
   _Bool mntpoint ;
};
typedef struct __anonstruct_thread_data_232432842 thread_data;

extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcasestr)(char const   *__haystack ,
                                                                                           char const   *__needle )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,3))) memmem)(void const   *__haystack ,
                                                                                       size_t __haystacklen ,
                                                                                       void const   *__needle ,
                                                                                       size_t __needlelen )  __attribute__((__pure__)) ;
extern char *optarg ;
extern int optind ;
extern int endwin(void) ;
extern int keypad(WINDOW * , _Bool  ) ;
extern int waddnstr(WINDOW * , char const   * , int  ) ;
extern int wattr_on(WINDOW * , attr_t  , void * ) ;
extern int wattr_off(WINDOW * , attr_t  , void * ) ;
extern int wmove(WINDOW * , int  , int  ) ;
extern int wrefresh(WINDOW * ) ;
extern void wtimeout(WINDOW * , int  ) ;
extern WINDOW *stdscr ;
extern int COLORS ;
extern int COLS ;
extern int LINES ;
extern int unget_wch(wchar_t const    ) ;
extern int waddnwstr(WINDOW * , wchar_t const   * , int  ) ;
extern int wget_wch(WINDOW * , wint_t * ) ;
static settings cfg  = 
     {0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, 0U, (uint_t )1, 0U, 0U, 0U, 0U, 0U, 0U, 0U, (uint_t )1,
    0U, 0U, 0U, 0U, 0U, (uint_t )2, 0U, 0U, (uint_t )1};
static context g_ctx[4]  __attribute__((__aligned__))  ;
static int ndents  ;
static int cur  ;
static int total_dents  =    64;
static ushort_t xlines  ;
static uchar_t maxbm  ;
static uchar_t maxplug  ;
static uchar_t maxorder  ;
static char *bmstr  ;
static char *pluginstr  ;
static char *orderstr  ;
static char *shell  ;
static char *home  ;
static char *initpath  ;
static char *cfgpath  ;
static char *selpath  ;
static char *listroot  ;
static char *plgpath  ;
static char *pnamebuf  ;
static char *pselbuf  ;
static char *mark  ;
static char *lastcmd  ;
static ullong_t *ihashbmp  ;
static struct entry *pdents  ;
static blkcnt_t dir_blocks  ;
static kv *bookmark  ;
static kv *plug  ;
static kv *order  ;
static uchar_t tmpfplen  ;
static uchar_t homelen  ;
static uchar_t blk_shift  =    (uchar_t )9;
static regex_t archive_re  ;
static int threadbmp  =    -1;
static int volatile   active_threads  ;
static pthread_mutex_t running_mutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
static pthread_mutex_t hardlink_mutex  =    {{0,
     0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
static ullong_t *core_files  ;
static blkcnt_t *core_blocks  ;
static ullong_t num_files  ;
static thread_data *core_data  ;
static struct sigaction oldsighup  ;
static struct sigaction oldsigtstp  ;
static struct sigaction oldsigwinch  ;
static char g_buf[4096 + (256 << 1)]  __attribute__((__aligned__))  ;
static char g_sel[4096]  __attribute__((__aligned__))  ;
static char g_tmpfpath[64]  __attribute__((__aligned__))  ;
static char g_pipepath[64]  __attribute__((__aligned__))  ;
static runstate g_state  ;

static int inotify_fd  ;
static int inotify_wd  =    -1;
static uint_t INOTIFY_MASK  =    (uint_t )4034;
static int spawn(char *file , char *arg1 , char *arg2 , char *arg3 , ushort_t flag ) ;
static char *load_input(int fd , char const   *path ) ;
static int set_sort_flags(int r ) ;
static void sigint_handler(int sig ) 
{ 
  {
  g_state.interrupt = (uint_t )1;
  return;
}
}
static char dst[32]  = {      (char )'\000'};

static _Bool test_set_bit(uint_t nr ) 
{ 
  ullong_t *m ;

  {
  nr &= 16777215U;
  pthread_mutex_lock(& hardlink_mutex);
  m = ihashbmp + (nr >> 6);
  if (*m & (unsigned long long )(1 << (nr & 63U))) {
    pthread_mutex_unlock(& hardlink_mutex);
    return ((_Bool)0);
  }
  *m |= (unsigned long long )(1 << (nr & 63U));
  pthread_mutex_unlock(& hardlink_mutex);
  return ((_Bool)1);
}
}

static void *xrealloc(void *pcur , size_t len ) 
{ 
  void *pmem ;
  void *tmp ;

  {
  tmp = realloc(pcur, len);
  pmem = tmp;
  return (pmem);
}
}
static size_t xstrsncpy(char * __restrict  dst___0 , char const   * __restrict  src ,
                        size_t n ) 
{ 
  char *end ;
  void *tmp ;

  {
  end = (char *)tmp;
  if (! end) {
    *(dst___0 + (n - 1UL)) = (char )'\000';
    end = (char *)(dst___0 + n);
  }
  return ((size_t )(end - (char *)dst___0));
}
}

static char *xstrdup(char const   * __restrict  s ) 
{ 
  size_t len ;
  size_t tmp ;
  char *ptr ;
  void *tmp___0 ;

  {
  len = tmp + 1UL;
  tmp___0 = malloc(len);
  ptr = (char *)tmp___0;

  return (ptr);
}
}
static char *xbasename(char *path ) 
{ 
  char *base ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  base = (char *)tmp___0;
  if (base) {
    tmp___1 = base + 1;
  } else {
    tmp___1 = path;
  }
  return (tmp___1);
}
}

static int spawn(char *file , char *arg1 , char *arg2 , char *arg3 , ushort_t flag ) 
{ 
  pid_t pid ;
  int status ;
  int retstatus ;
  char *argv[10] ;
  unsigned int tmp ;
  char *cmd___0 ;
  int tmp___0 ;
  int fd ;
  int tmp___1 ;
  int fd___0 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  ssize_t tmp___6 ;
  ssize_t tmp___7 ;

  {
  status = 0;
  retstatus = 65535;
  argv[0] = (char *)0;
  tmp = 1U;
  while (! (tmp >= 10U)) {
    argv[tmp] = (char *)0;
    tmp ++;
  }
  cmd___0 = (char *)((void *)0);
  
  argv[status] = arg1;
  status ++;
  argv[status] = arg2;
  status ++;
  argv[status] = arg3;
  if ((int )flag & 8) {
    endwin();
  }
  return (retstatus);
}
}
static char *(*fnstrstr)(char const   *haystack ,
                         char const   *needle )  =    (char *(*)(char const   *haystack , char const   *needle ))(& strcasestr);
static int regflags  =    ((1 << 3) | 1) | (1 << 1);
static int (*entrycmpfn)(void const   *va , void const   *vb )  =   1;

static _Bool parsekvpair(kv **arr , char **envcpy , uchar_t const   id , uchar_t *items ) 
{ 
  _Bool new ;
  uchar_t INCR ;
  uint_t i ;
  kv *kvarr ;
  char *ptr ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
  new = (_Bool)1;
  INCR = (uchar_t )8;
  i = (uint_t )0;
  kvarr = (kv *)((void *)0);

  *envcpy = xstrdup((char const   * __restrict  )ptr);
  ptr = *envcpy;
  while (1) {
    if (*ptr) {
      if (! (i < 100U)) {
        break;
      }
    } else {
      break;
    }
    if (new) {
      if (! (i & (unsigned int )((int )INCR - 1))) {
        tmp___1 = xrealloc((void *)kvarr, sizeof(kv ) * (unsigned long )(i + (uint_t )INCR));
        kvarr = (kv *)tmp___1;
        *arr = kvarr;
        memset((void *)(kvarr + i), 0, sizeof(kv ) * (unsigned long )INCR);
      }
      (kvarr + i)->key = (int )((uchar_t )*ptr);
      ptr ++;
      (kvarr + i)->off = (int )(ptr - *envcpy);
      i ++;
      new = (_Bool)0;
    }
    ptr ++;
  }
  return ((_Bool )(i != 0U));
}
}

static char size_buf[12]  ;

static char * const  cmds[3]  = {      (char * const  )"file -biL",      (char * const  )"file -b",      (char * const  )"stat"};

static _Bool found  =    (_Bool)0;

static _Bool plctrl_init(void) 
{ 
  size_t len ;
  size_t tmp ;
  __pid_t tmp___0 ;
  char *tmp___1 ;

  {
  g_tmpfpath[(int )tmpfplen - 1] = (char )'\000';
  len = xstrsncpy((char * __restrict  )(g_pipepath), (char const   * __restrict  )(g_tmpfpath),
                  (size_t )64);
  g_pipepath[len - 1UL] = (char )'/';
  tmp = xstrsncpy((char * __restrict  )(g_pipepath + len), (char const   * __restrict  )"nnn-pipe.",
                  64UL - len);
  len = tmp + len;
  tmp___0 = getpid();
  xstrsncpy((char * __restrict  )((g_pipepath + len) - 1), (char const   * __restrict  )tmp___1,
            64UL - len);
  return ((_Bool)0);
}
}

static char *readpipe(int fd , char *ctxnum , char **path ) 
{ 
  char ctx ;
  char *nextpath ;
  ssize_t tmp ;
  ssize_t tmp___0 ;
  uchar_t tmp___1 ;
  ssize_t tmp___2 ;
  char op ;
  ssize_t len ;
  ssize_t tmp___3 ;
  size_t tmp___4 ;

  {
  nextpath = (char *)((void *)0);
  if (tmp != 1L) {
    return ((char *)((void *)0));
  }
  if ((int )g_buf[0] == 45) {
    if (tmp___0 != 1L) {
      return ((char *)((void *)0));
    }
  }
  if (tmp___2 != 1L) {
    return ((char *)((void *)0));
  }
  op = g_buf[0];
  if ((int )op == 99) {
    len = tmp___3;
    if (len <= 0L) {
      return ((char *)((void *)0));
    }
    g_buf[len] = (char )'\000';
    if ((int )g_buf[0] == 47) {
      nextpath = g_buf;
      len = (ssize_t )tmp___4;
      while (1) {
        len --;
        if (len) {
          if (! ((int )g_buf[len] == 47)) {
            break;
          }
        } else {
          break;
        }
        g_buf[len] = (char )'\000';
      }
    }
  } else
  if ((int )op == 108) {
    nextpath = load_input(fd, (char const   *)*path);
  } else
  if ((int )op == 112) {
    free((void *)selpath);
    selpath = (char *)((void *)0);
    g_state.picker = (uint_t )0;
    g_state.picked = (uint_t )1;
  }
  *ctxnum = ctx;
  return (nextpath);
}
}
static _Bool run_plugin(char **path , char const   *file , char *runfile , char **lastname ,
                        char **lastdir ) 
{ 
  pid_t p ;
  char ctx ;
  uchar_t flags ;
  _Bool cmd_as_plugin ;
  char *nextpath ;
  int tmp ;
  int wfd ;
  int tmp___0 ;
  char *sel ;
  char std[2] ;
  int rfd ;
  int *tmp___1 ;

  {
  ctx = (char)0;
  flags = (uchar_t )0;
  cmd_as_plugin = (_Bool)0;
  if (! g_state.pluginit) {
    plctrl_init();
    g_state.pluginit = (uint_t )1;
  }
  if ((int const   )*file == 33) {
    flags = (uchar_t )17;
    file ++;
    if ((int const   )*file == 124) {
      flags = (uchar_t )((int )flags | 128);
      file ++;
    } else
    if ((int const   )*file == 38) {
      flags = (uchar_t )6;
      file ++;
    }
    if (! *file) {
      return ((_Bool)0);
    }
    cmd_as_plugin = (_Bool)1;
  }

  endwin();
  p = fork();
  nextpath = readpipe(rfd, & ctx, path);
  wrefresh(stdscr);
  unlink((char const   *)(g_pipepath));
  return ((_Bool)1);
}
}

static _Bool prompt_run(void) 
{ 
  _Bool ret ;
  char *cmdline ;
  char *next ;
  int cnt_j ;
  int cnt_J ;
  int cmd_ret ;
  size_t len ;
  char const   *xargs_j ;
  char const   *xargs_J ;
  char cmd___0[(4096 + (256 << 1)) + 32] ;
  char *tmp ;

  {
  ret = (_Bool)0;
  xargs_j = "xargs -0 -I{} %s < %s";
  xargs_J = "xargs -0 %s < %s";
  while (1) {
    free((void *)lastcmd);
    lastcmd = xstrdup((char const   * __restrict  )cmdline);
    ret = (_Bool)1;
    cnt_j = 0;
    next = cmdline;
    cnt_J = 0;
    next = cmdline;
    
    cmd_ret = spawn(shell, (char *)"-c", tmp, (char *)((void *)0), (ushort_t )25);
    
  }
}
}
static _Bool handle_cmd(enum action sel , char *newpath ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int r ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  if ((unsigned int )sel == 57U) {
    tmp___0 = prompt_run();
  }
  if (tmp___1) {
    tmp___3 = atoi((char const   *)tmp___1);
    tmp___4 = tmp___3;
  } else {
    tmp___4 = 0;
  }
  r = tmp___4;
  return ((_Bool)1);
}
}
static void dentfree(void) 
{ 


  {
  free((void *)pnamebuf);
  free((void *)pdents);
  free((void *)mark);
  free((void *)core_blocks);
  free((void *)core_data);
  free((void *)core_files);
  return;
}
}
static void *du_thread(void *p_data ) 
{ 
  thread_data *pdata ;
  char *path[2] ;
  ullong_t tfiles ;
  blkcnt_t tblocks ;
  struct stat *sb ;
  FTS *tree ;
  FTS *tmp ;
  FTSENT *node ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
  pdata = (thread_data *)p_data;
  path[0] = pdata->path;
  path[1] = (char *)((void *)0);
  tfiles = (ullong_t )0;
  tblocks = (blkcnt_t )0;
  tmp = fts_open((char * const  *)(path), 84, (int (*)(FTSENT const   ** , FTSENT const   ** ))0);
  tree = tmp;
  while (1) {
    node = fts_read(tree);
    if (! node) {
      break;
    }
    if ((int )node->fts_info & 1) {
      if (g_state.interrupt) {
        break;
      }
      continue;
    }
    sb = node->fts_statp;
    if (cfg.apparentsz) {
      if (sb->st_size) {
        if ((int )node->fts_info & 8) {
          if (sb->st_nlink <= 1UL) {
            tblocks += sb->st_size;
          } 
        } else
        _L: /* CIL Label */ 
        if ((int )node->fts_info & 6) {
          tblocks += sb->st_size;
        }
      }
    } else
    if (sb->st_blocks) {
      if ((int )node->fts_info & 8) {
        if (sb->st_nlink <= 1UL) {
          tblocks += sb->st_blocks;
        } else {
          tmp___1 = test_set_bit((uint_t )sb->st_ino);
        }
      } else
      _L___0: /* CIL Label */ 
      if ((int )node->fts_info & 6) {
        tblocks += sb->st_blocks;
      }
    }
    tfiles ++;
  }
  if (pdata->entnum >= 0) {
    (pdents + pdata->entnum)->__annonCompField18.blocks = (ullong_t )tblocks;
  }
  if (! pdata->mntpoint) {
    *(core_blocks + pdata->core) += tblocks;
    *(core_files + pdata->core) += tfiles;
  } else {
    (*(core_files + pdata->core)) ++;
  }
  pthread_mutex_lock(& running_mutex);
  threadbmp |= 1 << (int )pdata->core;
  active_threads -= (int volatile   )1;
  pthread_mutex_unlock(& running_mutex);
  return ((void *)0);
}
}
static void dirwalk(char *path , int entnum , _Bool mountpoint ) 
{ 
  int core ;
  int tmp ;
  pthread_t tid ;
  char *tmp___0 ;

  {
  while (active_threads == (int volatile   )4) {

  }
  if (g_state.interrupt) {
    return;
  }
  pthread_mutex_lock(& running_mutex);
  tmp = ffs(threadbmp);
  core = tmp - 1;
  threadbmp &= ~ (1 << core);
  active_threads += (int volatile   )1;
  pthread_mutex_unlock(& running_mutex);
  xstrsncpy((char * __restrict  )((core_data + core)->path), (char const   * __restrict  )path,
            (size_t )4096);
  (core_data + core)->entnum = entnum;
  (core_data + core)->core = (ushort_t )core;
  (core_data + core)->mntpoint = mountpoint;
  tid = (pthread_t )0;
  pthread_create((pthread_t * __restrict  )(& tid), (pthread_attr_t const   * __restrict  )((void *)0),
                 & du_thread, (void * __restrict  )((void *)(core_data + core)));
  wmove(stdscr, (int )xlines - 1, 0);
  tmp___0 = xbasename(path);
  waddnstr(stdscr, (char const   *)tmp___0, -1);
  waddnstr(stdscr, " [^C aborts]\n", -1);
  wrefresh(stdscr);
  return;
}
}
static _Bool prep_threads(void) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
  if (! g_state.duinit) {
    threadbmp >>= 28;
    if (! core_blocks) {
      tmp = calloc((size_t )4, sizeof(blkcnt_t ));
      core_blocks = (blkcnt_t *)tmp;
    }
    if (! core_data) {
      tmp___0 = calloc((size_t )4, sizeof(thread_data ));
      core_data = (thread_data *)tmp___0;
    }
    if (! core_files) {
      tmp___1 = calloc((size_t )4, sizeof(ullong_t ));
      core_files = (ullong_t *)tmp___1;
    }
    g_state.duinit = (uint_t )1;
  } else {
  memset((void *)core_blocks, 0, 4UL * sizeof(blkcnt_t ));
  memset((void *)core_data, 0, 4UL * sizeof(thread_data ));
  memset((void *)core_files, 0, 4UL * sizeof(ullong_t ));
  }
  return ((_Bool)1);
}
}

static int dentfill(char *path , struct entry **ppdents ) 
{ 
  uchar_t entflags ;
  int flags ;
  struct dirent *dp ;
  char *namep ;
  char *pnb ;
  char *buf ;
  struct entry *dentp ;
  size_t off ;
  size_t namebuflen ;
  struct stat sb_path ;
  struct stat sb ;
  DIR *dirp ;
  DIR *tmp ;
  int fd ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  int tmp___5 ;
  __off_t tmp___6 ;
  _Bool tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  int count ;
  size_t tmp___12 ;
  int tmp___13 ;
  _Bool tmp___14 ;
  int i ;
  int tmp___15 ;

  {
  entflags = (uchar_t )0;
  flags = 0;
  off = (size_t )0;
  namebuflen = (size_t )2048;
  tmp = opendir((char const   *)path);
  dirp = tmp;
  ndents = 0;
  fd = tmp___0;
  if (cfg.blkorder) {
    num_files = (ullong_t )0;
    dir_blocks = (blkcnt_t )0;
    buf = g_buf;
    tmp___1 = fstatat(fd, (char const   * __restrict  )path, (struct stat * __restrict  )(& sb_path),
                      0);
    if (tmp___1 == -1) {
      goto exit;
    }
    if (! ihashbmp) {
      tmp___2 = calloc((size_t )1, (size_t )((16777215 >> 6) << 3));
      ihashbmp = (ullong_t *)tmp___2;
      if (! ihashbmp) {
        goto exit;
      }
    } else {
      memset((void *)ihashbmp, 0, (size_t )((16777215 >> 6) << 3));
    }
    tmp___3 = prep_threads();
    if (! tmp___3) {
      goto exit;
    }
    wattr_on(stdscr, ((cfg.curctx + 1U) << 8) & (((1U << 8) - 1U) << 8), (void *)0);
  }
  posix_fadvise(fd, (off_t )0, (off_t )0, 2);
  dp = readdir(dirp);

  while (1) {
    namep = dp->d_name;
    if (! cfg.showhidden) {
      if ((int )*(namep + 0) == 46) {
        tmp___5 = fstatat(fd, (char const   * __restrict  )namep, (struct stat * __restrict  )(& sb),
                          256);
        if ((sb.st_mode & 61440U) == 16384U) {
          if (sb_path.st_dev == sb.st_dev) {
            dirwalk(buf, -1, (_Bool)0);
            if (g_state.interrupt) {
              goto exit;
            }
          }
        }
      }
    }
    tmp___9 = fstatat(fd, (char const   * __restrict  )namep, (struct stat * __restrict  )(& sb),
                      flags);
    if (tmp___9 == -1) {
      if (flags) {
      } else {
        tmp___8 = fstatat(fd, (char const   * __restrict  )namep, (struct stat * __restrict  )(& sb),
                          256);
        if (tmp___8 == -1) {
          entflags = (uchar_t )8;
          memset((void *)(& sb), 0, sizeof(struct stat ));
        } else {
          entflags = (uchar_t )4;
        }
      }
    }

    if (namebuflen - off < 256UL) {
      namebuflen += 2048UL;
      pnb = pnamebuf;
      tmp___11 = xrealloc((void *)pnamebuf, namebuflen);
      pnamebuf = (char *)tmp___11;
      if ((unsigned long )pnb != (unsigned long )pnamebuf) {
        dentp = *ppdents;
        dentp->name = pnamebuf;
        count = 1;
        while (count < ndents) {
          (dentp + 1)->name = (char *)((ullong_t )((size_t )dentp->name) + dentp->__annonCompField18.nlen);
          dentp ++;
          count ++;
        }
      }
    }
    dentp = *ppdents + ndents;
    dentp->name = (char *)((size_t )pnamebuf + off);
    tmp___12 = xstrsncpy((char * __restrict  )dentp->name, (char const   * __restrict  )namep,
                         (size_t )256);
    dentp->__annonCompField18.nlen = (ullong_t )tmp___12;
    off = (size_t )((ullong_t )off + dentp->__annonCompField18.nlen);
    if (cfg.blkorder) {
      if ((sb.st_mode & 61440U) == 16384U) {
        dirwalk(buf, ndents, (_Bool )(sb_path.st_dev != sb.st_dev));
        if (g_state.interrupt) {
          goto exit;
        }
      } else {
        if (cfg.apparentsz) {
          dentp->__annonCompField18.blocks = (ullong_t )sb.st_size;
        } else {
          dentp->__annonCompField18.blocks = (ullong_t )sb.st_blocks;
        }
        if (sb.st_nlink <= 1UL) {
          dir_blocks = (blkcnt_t )((ullong_t )dir_blocks + dentp->__annonCompField18.blocks);
        } else {
          tmp___14 = test_set_bit((uint_t )sb.st_ino);
          if (tmp___14) {
            dir_blocks = (blkcnt_t )((ullong_t )dir_blocks + dentp->__annonCompField18.blocks);
          }
        }
        num_files ++;
      }
    }

    ndents ++;
  }
  exit: 
  return (ndents);
}
}
static void populate(char *path , char *lastname ) 
{ 
  int tmp ;
  int tmp___0 ;
  {
  ndents = dentfill(path, & pdents);
  if (! ndents) {
    return;
  }
  return;
}
}
static int set_sort_flags(int r ) 
{ 
  _Bool session ;
  _Bool reverse ;
  int tmp ;

  {
  session = (_Bool )(r == 0);
  reverse = (_Bool)0;
  switch (r) {
  case 97: 
  cfg.apparentsz ^= 1U;
  if (cfg.apparentsz) {
    cfg.blkorder = (uint_t )1;
    blk_shift = (uchar_t )0;
  } else {
    cfg.blkorder = (uint_t )0;
  }
  default: 
  return (0);
  }
}
}
static _Bool browse(char *ipath , char const   *session , int pkey ) 
{ 
  char newpath[4096]  __attribute__((__aligned__)) ;
  char runfile[256]  __attribute__((__aligned__)) ;
  char *path ;
  char *lastdir ;
  char *lastname ;
  char *dir ;
  char *tmp ;
  enum action sel ;
  struct stat sb ;
  int r ;
  int presel ;
  int tmp___0 ;
  _Bool watch ;
  _Bool cd ;
  char *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  __pid_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  _Bool tmp___11 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  _Bool tmp___22 ;
  char *tmp___28 ;
  char *tmp___30 ;
  size_t tmp___33 ;
  _Bool tmp___35 ;
  _Bool refresh___0 ;
  char const   *tmp___72 ;
  int fd ;
  int ret ;
  int tmp___94 ;
  int tmp___103 ;
  int tmp___107 ;
  _Bool tmp___108 ;
  char *tmp___109 ;
  char *tmp___115 ;
  _Bool tmp___116 ;
  char const   *tmp___117 ;
  _Bool tmp___119 ;
  char const   *tmp___120 ;
  int ctx ;
  {
  r = -1;
  watch = (_Bool)0;
  cd = (_Bool)1;
  atexit(& dentfree);
  g_ctx[0].c_last[0] = (char )'\000';
  lastdir = g_ctx[0].c_last;
  lastname = g_ctx[0].c_name;
  xstrsncpy((char * __restrict  )(g_ctx[0].c_path), (char const   * __restrict  )ipath,
            (size_t )4096);
  path = g_ctx[0].c_path;
  g_ctx[0].c_fltr[1] = (char )'\000';
  g_ctx[0].c_fltr[0] = g_ctx[0].c_fltr[1];
  runfile[0] = (char )'\000';
  newpath[0] = runfile[0];
  
  tmp___3 = xrealloc((void *)pdents, (unsigned long )total_dents * sizeof(struct entry ));
  pdents = (struct entry *)tmp___3;
  tmp___4 = xrealloc((void *)pnamebuf, (size_t )2048);
  pnamebuf = (char *)tmp___4;
  begin: 
  cd = (_Bool)1;
  populate(path, lastname);
  if (g_state.interrupt) {
    cfg.blkorder = (uint_t )0;
    cfg.apparentsz = cfg.blkorder;
    g_state.interrupt = cfg.apparentsz;
    blk_shift = (uchar_t )9;
    presel = 12;
  }
  while (1) {
    nochange: 
    tmp___6 = getppid();
    switch ((unsigned int )sel) {
    case 1U: 
    tmp___10 = xbasename(path);
    xstrsncpy((char * __restrict  )lastname, (char const   * __restrict  )tmp___10,
              (size_t )256);
    if (tmp___11) {
      presel = '/';
    } else {
      watch = (_Bool)1;
    }
    goto begin;
    
    case 4U: 
    if (ndents) {
      g_state.move = (uint_t )1;
    }
    break;
    case 26U: 
    free((void *)mark);
    mark = xstrdup((char const   * __restrict  )path);
    goto nochange;

    continue;
    case 36U: 
    refresh___0 = (_Bool)0;
    switch ((unsigned int )sel) {
    case 36U: 
    refresh___0 = (_Bool)1;
    break;
    }
    xstrsncpy((char * __restrict  )lastname, (char const   * __restrict  )tmp___72,
              (size_t )256);
    cd = (_Bool)0;
    goto begin;
    case 37U: 
    if (! ndents) {
      goto nochange;
    }
    (pdents + cur)->__annonCompField18.flags ^= 16ULL;
    break;
    goto begin;
    case 54U:

    if (r != 13) {
      tmp___116 = run_plugin(& path, (char const   *)tmp, tmp___115, & lastname, & lastdir);

      if (g_state.picked) {
        return ((_Bool)0);
      }
      xstrsncpy((char * __restrict  )lastname, (char const   * __restrict  )tmp___117,
                (size_t )256);
    } else {
      g_state.runplugin ^= 1U;
      
      xstrsncpy((char * __restrict  )lastdir, (char const   * __restrict  )path, (size_t )4096);
      xstrsncpy((char * __restrict  )path, (char const   * __restrict  )plgpath, (size_t )4096);
      if (ndents) {
        xstrsncpy((char * __restrict  )(runfile), (char const   * __restrict  )(pdents + cur)->name,
                  (size_t )255);
      }
      *(lastname + 0) = (char )'\000';
    }
    if (g_state.runplugin == 1U) {
      presel = '/';
    }
    goto begin;
    case 57U: 
    case 56U: 
    case 55U: 
    tmp___119 = handle_cmd(sel, newpath);
    r = (int )tmp___119;

    xstrsncpy((char * __restrict  )lastname, (char const   * __restrict  )tmp___120,
              (size_t )256);
    if (! r) {
      goto nochange;
    }
    cd = (_Bool)0;
    goto begin;
    case 50U: 
    presel = 0;

    cd = (_Bool)0;
    goto begin;
    }
  }
}
}

static char *load_input(int fd , char const   *path ) 
{ 
  ssize_t i ;
  ssize_t chunk_count ;
  ssize_t chunk ;
  ssize_t entries ;
  char *input ;
  void *tmp ;
  char *tmpdir ;
  char cwd[4096] ;
  char *next ;
  size_t offsets[1 << 14] ;
  char **paths ;
  ssize_t input_read ;
  ssize_t total_read ;
  ssize_t off ;
  char *tmp___0 ;
  void *tmp___1 ;
  ssize_t tmp___2 ;
  void *tmp___3 ;
  char buf[512] ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  _Bool tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
  chunk_count = (ssize_t )1;
  chunk = (ssize_t )524288;
  entries = (ssize_t )0;
  tmp = malloc(sizeof(char ) * (unsigned long )chunk);
  input = (char *)tmp;
  tmpdir = (char *)((void *)0);
  paths = (char **)((void *)0);
  total_read = (ssize_t )0;
  off = (ssize_t )0;
  while (1) {
    input_read = read(fd, (void *)(input + total_read), (size_t )chunk);
    if (input_read < 0L) {
      goto malloc_1;
    }
    if (input_read == 0L) {
      break;
    }
    total_read += input_read;
    chunk_count ++;

    if (chunk_count == (total_read - input_read) / chunk) {
      continue;
    }
    chunk_count = total_read / chunk;
    if (total_read % chunk) {
      chunk_count ++;
    }
    tmp___3 = xrealloc((void *)input, (size_t )((chunk_count + 1L) * chunk));
    input = (char *)tmp___3;
  }

  *(input + total_read) = (char )'\000';
  tmp___6 = malloc((unsigned long )entries * sizeof(char *));
  paths = (char **)tmp___6;
  if (! paths) {
    goto malloc_1;
  }
  i = (ssize_t )0;
  tmp___7 = malloc(sizeof(char ) * 4096UL);
  listroot = (char *)tmp___7;
  i = (ssize_t )0;
  malloc_1: 

  free((void *)input);
  free((void *)paths);
  return (tmpdir);
}
}

static _Bool setup_config(void) 
{ 
  size_t r ;
  size_t len ;
  char *xdgcfg ;
  char *tmp ;
  _Bool xdg ;
  char *tmp___0 ;
  _Bool tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  _Bool tmp___12 ;
  char *env_sel ;
  char *tmp___13 ;
  char *tmp___14 ;
  void *tmp___15 ;
  char *tmp___16 ;

  {
  tmp = getenv("XDG_CONFIG_HOME");
  xdgcfg = tmp;
  xdg = (_Bool)0;

  tmp___6 = malloc(len);
  cfgpath = (char *)tmp___6;
  tmp___7 = malloc(len);
  plgpath = (char *)tmp___7;
  xstrsncpy((char * __restrict  )((cfgpath + r) - 1), (char const   * __restrict  )"/nnn",
            len - r);
  r = (size_t )0;
  return ((_Bool)1);
}
}

static void cleanup(void) 
{ 


  {
  free((void *)selpath);
  free((void *)plgpath);
  free((void *)cfgpath);
  free((void *)initpath);
  free((void *)bmstr);
  free((void *)pluginstr);
  free((void *)listroot);
  free((void *)ihashbmp);
  free((void *)bookmark);
  free((void *)plug);
  free((void *)lastcmd);
  if (g_state.pluginit) {
    unlink((char const   *)(g_pipepath));
  }
  return;
}
}
int main(int argc , char **argv ) 
{ 
  char *arg ;
  char *session ;
  int fd ;
  int opt ;
  int sort ;
  int pkey ;
  char const   *env_opts ;
  char *tmp ;
  int env_opts_id ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  _Bool tmp___10 ;
  _Bool tmp___11 ;
  _Bool tmp___12 ;
  _Bool tmp___13 ;
  char *startpath ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  struct stat sb ;
  struct sigaction act ;
  int tmp___28 ;
  int tmp___30 ;
  int tmp___33 ;
  _Bool tmp___35 ;

  {
  arg = (char *)((void *)0);
  session = (char *)((void *)0);
  sort = 0;
  pkey = '\000';
  env_opts = (char const   *)tmp;
  env_opts_id = tmp___1;
  while (1) {
    
    if (! (opt != -1)) {
      break;
    }
    switch (opt) {
    case 112: 
    if (env_opts_id >= 0) {
      break;
    }
    case 80: 
    if (env_opts_id < 0) {
      if (! *(optarg + 1)) {
        pkey = (int )((uchar_t )*(optarg + 0));
      }
    }
    break;
    case 81: 
    g_state.forcequit = (uint_t )1;
    break;
    case 82: 
    cfg.rollover = (uint_t )0;
    break;
    case 84: 
    if (env_opts_id < 0) {
      sort = (int )((uchar_t )*(optarg + 0));
    }
    break;
    case 117: 
    cfg.prefersel = (uint_t )1;
    break;
    case 85: 
    g_state.uidgid = (uint_t )1;
    break;
    case 86: 
    dprintf(1, (char const   * __restrict  )"%s\n", "4.6");
    return (0);
    case 120: 
    cfg.x11 = (uint_t )1;
    break;
    }
    if (env_opts_id == 0) {
      env_opts_id = -1;
    }
  }
  
  atexit(& cleanup);
  tmp___8 = isatty(0);
  
  home = getenv("HOME");
  homelen = (uchar_t )tmp___9;
  tmp___10 = setup_config();
  tmp___11 = parsekvpair(& bookmark, & bmstr, (uchar_t const   )1, & maxbm);
  tmp___12 = parsekvpair(& plug, & pluginstr, (uchar_t const   )2, & maxplug);
  tmp___13 = parsekvpair(& order, & orderstr, (uchar_t const   )11, & maxorder);
  if (! initpath) {
    if (argc == optind) {
      tmp___14 = getenv("PWD");
      startpath = tmp___14;
      if (startpath) {
        tmp___15 = xstrdup((char const   * __restrict  )startpath);
        initpath = tmp___15;
      } else {
        tmp___16 = getcwd((char *)((void *)0), (size_t )0);
        initpath = tmp___16;
      }
      if (! initpath) {
        initpath = (char *)"/";
      }
    }
  }
  act.__sigaction_handler.sa_handler = & sigint_handler;

  act.sa_restorer = (void (*)(void))0;
  tmp___28 = sigaction(2, (struct sigaction  const  * __restrict  )(& act), (struct sigaction * __restrict  )((void *)0));
  tmp___30 = sigaction(15, (struct sigaction  const  * __restrict  )(& act), (struct sigaction * __restrict  )((void *)0));

  act.__sigaction_handler.sa_handler = (void (*)(int  ))1;
  tmp___33 = sigaction(3, (struct sigaction  const  * __restrict  )(& act), (struct sigaction * __restrict  )((void *)0));
  
  if (sort) {
    set_sort_flags(sort);
  }
  tmp___35 = browse(initpath, (char const   *)session, pkey);
  opt = (int )tmp___35;
  endwin();
  free((void *)pselbuf);
  return (opt);
}
}
#pragma merger("0","/tmp/cil-WQT8CLyu.i","")