/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef __builtin_va_list __gnuc_va_list;
typedef long __off_t;
typedef long __off64_t;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef __gnuc_va_list va_list___0;
typedef double cpFloat;
struct cpVect {
   cpFloat x ;
   cpFloat y ;
};
typedef struct cpVect cpVect;
struct cpBB {
   cpFloat l ;
   cpFloat b ;
   cpFloat r ;
   cpFloat t ;
};
typedef struct cpBB cpBB;
typedef unsigned int __uint32_t;
typedef __uint32_t uint32_t;
typedef unsigned long uintptr_t;
typedef uintptr_t cpHashValue;
typedef uint32_t cpCollisionID;
typedef unsigned char cpBool;
typedef void *cpDataPointer;
typedef uintptr_t cpCollisionType;
typedef uintptr_t cpGroup;
typedef unsigned int cpBitmask;
typedef unsigned int cpTimestamp;
struct cpTransform {
   cpFloat a ;
   cpFloat b ;
   cpFloat c ;
   cpFloat d ;
   cpFloat tx ;
   cpFloat ty ;
};
typedef struct cpTransform cpTransform;
struct cpArray ;
typedef struct cpArray cpArray;
struct cpHashSet ;
typedef struct cpHashSet cpHashSet;
struct cpBody ;
typedef struct cpBody cpBody;
struct cpShape ;
typedef struct cpShape cpShape;
struct cpConstraint ;
typedef struct cpConstraint cpConstraint;
struct cpCollisionHandler ;
typedef struct cpCollisionHandler cpCollisionHandler;
struct cpContactPointSet ;
typedef struct cpContactPointSet cpContactPointSet;
struct cpArbiter ;
typedef struct cpArbiter cpArbiter;
struct cpSpace ;
typedef struct cpSpace cpSpace;
struct cpSpatialIndexClass ;
typedef struct cpSpatialIndexClass cpSpatialIndexClass;
struct cpSpatialIndex ;
typedef struct cpSpatialIndex cpSpatialIndex;
struct cpSpatialIndex {
   cpSpatialIndexClass *klass ;
   cpBB (*bbfunc)(void *obj ) ;
   cpSpatialIndex *staticIndex ;
   cpSpatialIndex *dynamicIndex ;
};
struct cpSpatialIndexClass {
   void (*destroy)(cpSpatialIndex *index ) ;
   int (*count)(cpSpatialIndex *index ) ;
   void (*each)(cpSpatialIndex *index , void (*func)(void *obj , void *data ) , void *data ) ;
   cpBool (*contains)(cpSpatialIndex *index , void *obj , cpHashValue hashid ) ;
   void (*insert)(cpSpatialIndex *index , void *obj , cpHashValue hashid ) ;
   void (*remove)(cpSpatialIndex *index , void *obj , cpHashValue hashid ) ;
   void (*reindex)(cpSpatialIndex *index ) ;
   void (*reindexObject)(cpSpatialIndex *index , void *obj , cpHashValue hashid ) ;
   void (*reindexQuery)(cpSpatialIndex *index , cpCollisionID (*func)(void *obj1 ,
                                                                      void *obj2 ,
                                                                      cpCollisionID id ,
                                                                      void *data ) ,
                        void *data ) ;
   void (*query)(cpSpatialIndex *index , void *obj , cpBB bb , cpCollisionID (*func)(void *obj1 ,
                                                                                     void *obj2 ,
                                                                                     cpCollisionID id ,
                                                                                     void *data ) ,
                 void *data ) ;
   void (*segmentQuery)(cpSpatialIndex *index , void *obj , cpVect a , cpVect b ,
                        cpFloat t_exit , cpFloat (*func)(void *obj1 , void *obj2 ,
                                                         void *data ) , void *data ) ;
};
struct __anonstruct_points_450528349 {
   cpVect pointA ;
   cpVect pointB ;
   cpFloat distance ;
};
struct cpContactPointSet {
   int count ;
   cpVect normal ;
   struct __anonstruct_points_450528349 points[2] ;
};
struct cpPointQueryInfo {
   cpShape const   *shape ;
   cpVect point ;
   cpFloat distance ;
   cpVect gradient ;
};
typedef struct cpPointQueryInfo cpPointQueryInfo;
struct cpSegmentQueryInfo {
   cpShape const   *shape ;
   cpVect point ;
   cpVect normal ;
   cpFloat alpha ;
};
typedef struct cpSegmentQueryInfo cpSegmentQueryInfo;
struct cpShapeFilter {
   cpGroup group ;
   cpBitmask categories ;
   cpBitmask mask ;
};
typedef struct cpShapeFilter cpShapeFilter;
struct cpCollisionHandler {
   cpCollisionType const   typeA ;
   cpCollisionType const   typeB ;
   cpBool (*beginFunc)(cpArbiter *arb , cpSpace *space , cpDataPointer userData ) ;
   cpBool (*preSolveFunc)(cpArbiter *arb , cpSpace *space , cpDataPointer userData ) ;
   void (*postSolveFunc)(cpArbiter *arb , cpSpace *space , cpDataPointer userData ) ;
   void (*separateFunc)(cpArbiter *arb , cpSpace *space , cpDataPointer userData ) ;
   cpDataPointer userData ;
};
struct cpArray {
   int num ;
   int max ;
   void **arr ;
};
struct __anonstruct_sleeping_590565998 {
   cpBody *root ;
   cpBody *next ;
   cpFloat idleTime ;
};
struct cpBody {
   void (*velocity_func)(cpBody *body , cpVect gravity , cpFloat damping , cpFloat dt ) ;
   void (*position_func)(cpBody *body , cpFloat dt ) ;
   cpFloat m ;
   cpFloat m_inv ;
   cpFloat i ;
   cpFloat i_inv ;
   cpVect cog ;
   cpVect p ;
   cpVect v ;
   cpVect f ;
   cpFloat a ;
   cpFloat w ;
   cpFloat t ;
   cpTransform transform ;
   cpDataPointer userData ;
   cpVect v_bias ;
   cpFloat w_bias ;
   cpSpace *space ;
   cpShape *shapeList ;
   cpArbiter *arbiterList ;
   cpConstraint *constraintList ;
   struct __anonstruct_sleeping_590565998 sleeping ;
};
enum cpArbiterState {
    CP_ARBITER_STATE_FIRST_COLLISION = 0,
    CP_ARBITER_STATE_NORMAL = 1,
    CP_ARBITER_STATE_IGNORE = 2,
    CP_ARBITER_STATE_CACHED = 3,
    CP_ARBITER_STATE_INVALIDATED = 4
} ;
struct cpArbiterThread {
   struct cpArbiter *next ;
   struct cpArbiter *prev ;
};
struct cpContact {
   cpVect r1 ;
   cpVect r2 ;
   cpFloat nMass ;
   cpFloat tMass ;
   cpFloat bounce ;
   cpFloat jnAcc ;
   cpFloat jtAcc ;
   cpFloat jBias ;
   cpFloat bias ;
   cpHashValue hash ;
};
struct cpCollisionInfo {
   cpShape const   *a ;
   cpShape const   *b ;
   cpCollisionID id ;
   cpVect n ;
   int count ;
   struct cpContact *arr ;
};
struct cpArbiter {
   cpFloat e ;
   cpFloat u ;
   cpVect surface_vr ;
   cpDataPointer data ;
   cpShape const   *a ;
   cpShape const   *b ;
   cpBody *body_a ;
   cpBody *body_b ;
   struct cpArbiterThread thread_a ;
   struct cpArbiterThread thread_b ;
   int count ;
   struct cpContact *contacts ;
   cpVect n ;
   cpCollisionHandler *handler ;
   cpCollisionHandler *handlerA ;
   cpCollisionHandler *handlerB ;
   cpBool swapped ;
   cpTimestamp stamp ;
   enum cpArbiterState state ;
};
struct cpShapeMassInfo {
   cpFloat m ;
   cpFloat i ;
   cpVect cog ;
   cpFloat area ;
};
enum cpShapeType {
    CP_CIRCLE_SHAPE = 0,
    CP_SEGMENT_SHAPE = 1,
    CP_POLY_SHAPE = 2,
    CP_NUM_SHAPES = 3
} ;
typedef enum cpShapeType cpShapeType;
struct cpShapeClass ;
typedef struct cpShapeClass cpShapeClass;
struct cpShapeClass {
   cpShapeType type ;
   cpBB (*cacheData)(cpShape *shape , cpTransform transform ) ;
   void (*destroy)(cpShape *shape ) ;
   void (*pointQuery)(cpShape const   *shape , cpVect p , cpPointQueryInfo *info ) ;
   void (*segmentQuery)(cpShape const   *shape , cpVect a , cpVect b , cpFloat radius ,
                        cpSegmentQueryInfo *info ) ;
};
struct cpShape {
   cpShapeClass const   *klass ;
   cpSpace *space ;
   cpBody *body ;
   struct cpShapeMassInfo massInfo ;
   cpBB bb ;
   cpBool sensor ;
   cpFloat e ;
   cpFloat u ;
   cpVect surfaceV ;
   cpDataPointer userData ;
   cpCollisionType type ;
   cpShapeFilter filter ;
   cpShape *next ;
   cpShape *prev ;
   cpHashValue hashid ;
};
struct cpConstraintClass {
   void (*preStep)(cpConstraint *constraint , cpFloat dt ) ;
   void (*applyCachedImpulse)(cpConstraint *constraint , cpFloat dt_coef ) ;
   void (*applyImpulse)(cpConstraint *constraint , cpFloat dt ) ;
   cpFloat (*getImpulse)(cpConstraint *constraint ) ;
};
typedef struct cpConstraintClass cpConstraintClass;
struct cpConstraint {
   cpConstraintClass const   *klass ;
   cpSpace *space ;
   cpBody *a ;
   cpBody *b ;
   cpConstraint *next_a ;
   cpConstraint *next_b ;
   cpFloat maxForce ;
   cpFloat errorBias ;
   cpFloat maxBias ;
   cpBool collideBodies ;
   void (*preSolve)(cpConstraint *constraint , cpSpace *space ) ;
   void (*postSolve)(cpConstraint *constraint , cpSpace *space ) ;
   cpDataPointer userData ;
};
struct cpContactBufferHeader ;
typedef struct cpContactBufferHeader cpContactBufferHeader;
struct cpSpace {
   int iterations ;
   cpVect gravity ;
   cpFloat damping ;
   cpFloat idleSpeedThreshold ;
   cpFloat sleepTimeThreshold ;
   cpFloat collisionSlop ;
   cpFloat collisionBias ;
   cpTimestamp collisionPersistence ;
   cpDataPointer userData ;
   cpTimestamp stamp ;
   cpFloat curr_dt ;
   cpArray *dynamicBodies ;
   cpArray *staticBodies ;
   cpArray *rousedBodies ;
   cpArray *sleepingComponents ;
   cpHashValue shapeIDCounter ;
   cpSpatialIndex *staticShapes ;
   cpSpatialIndex *dynamicShapes ;
   cpArray *constraints ;
   cpArray *arbiters ;
   cpContactBufferHeader *contactBuffersHead ;
   cpHashSet *cachedArbiters ;
   cpArray *pooledArbiters ;
   cpArray *allocatedBuffers ;
   int locked ;
   cpBool usesWildcards ;
   cpHashSet *collisionHandlers ;
   cpCollisionHandler defaultHandler ;
   cpBool skipPostStep ;
   cpArray *postStepCallbacks ;
   cpBody *staticBody ;
   cpBody _staticBody ;
};
struct cpBBTree ;
typedef struct cpBBTree cpBBTree;
struct Node ;
typedef struct Node Node;
struct Pair ;
typedef struct Pair Pair;
struct cpBBTree {
   cpSpatialIndex spatialIndex ;
   cpVect (*velocityFunc)(void *obj ) ;
   cpHashSet *leaves ;
   Node *root ;
   Node *pooledNodes ;
   Pair *pooledPairs ;
   cpArray *allocatedBuffers ;
   cpTimestamp stamp ;
};
struct __anonstruct_children_590640126 {
   Node *a ;
   Node *b ;
};
struct __anonstruct_leaf_219122021 {
   cpTimestamp stamp ;
   Pair *pairs ;
};
union __anonunion_node_125920227 {
   struct __anonstruct_children_590640126 children ;
   struct __anonstruct_leaf_219122021 leaf ;
};
struct Node {
   void *obj ;
   cpBB bb ;
   Node *parent ;
   union __anonunion_node_125920227 node ;
};
struct Thread {
   Pair *prev ;
   Node *leaf ;
   Pair *next ;
};
typedef struct Thread Thread;
struct Pair {
   Thread a ;
   Thread b ;
   cpCollisionID id ;
};
struct MarkContext {
   cpBBTree *tree ;
   Node *staticRoot ;
   cpCollisionID (*func)(void *obj1 , void *obj2 , cpCollisionID id , void *data ) ;
   void *data ;
};
typedef struct MarkContext MarkContext;
struct eachContext {
   void (*func)(void *obj , void *data ) ;
   void *data ;
};
typedef struct eachContext eachContext;
enum cpBodyType {
    CP_BODY_TYPE_DYNAMIC = 0,
    CP_BODY_TYPE_KINEMATIC = 1,
    CP_BODY_TYPE_STATIC = 2
} ;
typedef enum cpBodyType cpBodyType;
struct cpCircleShape ;
typedef struct cpCircleShape cpCircleShape;
struct cpSegmentShape ;
typedef struct cpSegmentShape cpSegmentShape;
struct cpPolyShape ;
typedef struct cpPolyShape cpPolyShape;
struct cpCircleShape {
   cpShape shape ;
   cpVect c ;
   cpVect tc ;
   cpFloat r ;
};
struct cpSegmentShape {
   cpShape shape ;
   cpVect a ;
   cpVect b ;
   cpVect n ;
   cpVect ta ;
   cpVect tb ;
   cpVect tn ;
   cpFloat r ;
   cpVect a_tangent ;
   cpVect b_tangent ;
};
struct cpSplittingPlane {
   cpVect v0 ;
   cpVect n ;
};
struct cpPolyShape {
   cpShape shape ;
   cpFloat r ;
   int count ;
   struct cpSplittingPlane *planes ;
   struct cpSplittingPlane _planes[12] ;
};
struct SupportPoint {
   cpVect p ;
   cpCollisionID index ;
};
struct MinkowskiPoint {
   cpVect a ;
   cpVect b ;
   cpVect ab ;
   cpCollisionID id ;
};
struct SupportContext {
   cpShape const   *shape1 ;
   cpShape const   *shape2 ;
   struct SupportPoint (*func1)(cpShape const   *shape , cpVect const   n ) ;
   struct SupportPoint (*func2)(cpShape const   *shape , cpVect const   n ) ;
};
struct EdgePoint {
   cpVect p ;
   cpHashValue hash ;
};
struct Edge {
   struct EdgePoint a ;
   struct EdgePoint b ;
   cpFloat r ;
   cpVect n ;
};
struct ClosestPoints {
   cpVect a ;
   cpVect b ;
   cpVect n ;
   cpFloat d ;
   cpCollisionID id ;
};
typedef void (*CollisionFunc)(cpShape const   *a , cpShape const   *b , struct cpCollisionInfo *info );
typedef void (*cpConstraintPreSolveFunc)(cpConstraint *constraint , cpSpace *space );
typedef void (*cpConstraintPostSolveFunc)(cpConstraint *constraint , cpSpace *space );
struct cpDampedRotarySpring ;
typedef struct cpDampedRotarySpring cpDampedRotarySpring;
typedef cpFloat (*cpDampedRotarySpringTorqueFunc)(struct cpConstraint *spring , cpFloat relativeAngle );
struct cpDampedRotarySpring {
   cpConstraint constraint ;
   cpFloat restAngle ;
   cpFloat stiffness ;
   cpFloat damping ;
   cpFloat (*springTorqueFunc)(struct cpConstraint *spring , cpFloat relativeAngle ) ;
   cpFloat target_wrn ;
   cpFloat w_coef ;
   cpFloat iSum ;
   cpFloat jAcc ;
};
struct cpDampedSpring ;
typedef struct cpDampedSpring cpDampedSpring;
typedef cpFloat (*cpDampedSpringForceFunc)(cpConstraint *spring , cpFloat dist );
struct cpDampedSpring {
   cpConstraint constraint ;
   cpVect anchorA ;
   cpVect anchorB ;
   cpFloat restLength ;
   cpFloat stiffness ;
   cpFloat damping ;
   cpFloat (*springForceFunc)(cpConstraint *spring , cpFloat dist ) ;
   cpFloat target_vrn ;
   cpFloat v_coef ;
   cpVect r1 ;
   cpVect r2 ;
   cpFloat nMass ;
   cpVect n ;
   cpFloat jAcc ;
};
struct cpGearJoint ;
typedef struct cpGearJoint cpGearJoint;
struct cpGearJoint {
   cpConstraint constraint ;
   cpFloat phase ;
   cpFloat ratio ;
   cpFloat ratio_inv ;
   cpFloat iSum ;
   cpFloat bias ;
   cpFloat jAcc ;
};
struct cpMat2x2 {
   cpFloat a ;
   cpFloat b ;
   cpFloat c ;
   cpFloat d ;
};
typedef struct cpMat2x2 cpMat2x2;
struct cpGrooveJoint ;
typedef struct cpGrooveJoint cpGrooveJoint;
struct cpGrooveJoint {
   cpConstraint constraint ;
   cpVect grv_n ;
   cpVect grv_a ;
   cpVect grv_b ;
   cpVect anchorB ;
   cpVect grv_tn ;
   cpFloat clamp ;
   cpVect r1 ;
   cpVect r2 ;
   cpMat2x2 k ;
   cpVect jAcc ;
   cpVect bias ;
};
struct cpHashSetBin {
   void *elt ;
   cpHashValue hash ;
   struct cpHashSetBin *next ;
};
typedef struct cpHashSetBin cpHashSetBin;
struct cpHashSet {
   unsigned int entries ;
   unsigned int size ;
   cpBool (*eql)(void const   *ptr , void const   *elt ) ;
   void *default_value ;
   cpHashSetBin **table ;
   cpHashSetBin *pooledBins ;
   cpArray *allocatedBuffers ;
};
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
struct __anonstruct___wseq32_112954846 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_886645174 {
   unsigned long long __wseq ;
   struct __anonstruct___wseq32_112954846 __wseq32 ;
};
struct __anonstruct___g1_start32_112954847 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_54864270 {
   unsigned long long __g1_start ;
   struct __anonstruct___g1_start32_112954847 __g1_start32 ;
};
struct __pthread_cond_s {
   union __anonunion____missing_field_name_886645174 __annonCompField1 ;
   union __anonunion____missing_field_name_54864270 __annonCompField2 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
typedef unsigned long pthread_t;
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
union __anonunion_pthread_condattr_t_488594145 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_condattr_t_488594145 pthread_condattr_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
union __anonunion_pthread_cond_t_951761805 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
typedef union __anonunion_pthread_cond_t_951761805 pthread_cond_t;
struct cpHastySpace ;
typedef struct cpHastySpace cpHastySpace;
struct ThreadContext {
   pthread_t thread ;
   cpHastySpace *space ;
   unsigned long thread_num ;
};
struct cpHastySpace {
   cpSpace space ;
   unsigned long num_threads ;
   unsigned long num_working ;
   unsigned long constraint_count_threshold ;
   pthread_mutex_t mutex ;
   pthread_cond_t cond_work ;
   pthread_cond_t cond_resume ;
   void (*work)(cpSpace *space , unsigned long worker , unsigned long worker_count ) ;
   struct ThreadContext workers[1] ;
};
struct cpPinJoint ;
typedef struct cpPinJoint cpPinJoint;
struct cpPinJoint {
   cpConstraint constraint ;
   cpVect anchorA ;
   cpVect anchorB ;
   cpFloat dist ;
   cpVect r1 ;
   cpVect r2 ;
   cpVect n ;
   cpFloat nMass ;
   cpFloat jnAcc ;
   cpFloat bias ;
};
struct cpPivotJoint ;
typedef struct cpPivotJoint cpPivotJoint;
struct cpPivotJoint {
   cpConstraint constraint ;
   cpVect anchorA ;
   cpVect anchorB ;
   cpVect r1 ;
   cpVect r2 ;
   cpMat2x2 k ;
   cpVect jAcc ;
   cpVect bias ;
};
struct cpPolyline {
   int count ;
   int capacity ;
   cpVect verts[] ;
};
typedef struct cpPolyline cpPolyline;
struct cpPolylineSet {
   int count ;
   int capacity ;
   cpPolyline **lines ;
};
typedef struct cpPolylineSet cpPolylineSet;
struct Notch {
   int i ;
   cpFloat d ;
   cpVect v ;
   cpVect n ;
};
struct cpRatchetJoint ;
typedef struct cpRatchetJoint cpRatchetJoint;
struct cpRatchetJoint {
   cpConstraint constraint ;
   cpFloat angle ;
   cpFloat phase ;
   cpFloat ratchet ;
   cpFloat iSum ;
   cpFloat bias ;
   cpFloat jAcc ;
};
struct cpRotaryLimitJoint ;
typedef struct cpRotaryLimitJoint cpRotaryLimitJoint;
struct cpRotaryLimitJoint {
   cpConstraint constraint ;
   cpFloat min ;
   cpFloat max ;
   cpFloat iSum ;
   cpFloat bias ;
   cpFloat jAcc ;
};
struct cpSimpleMotor ;
typedef struct cpSimpleMotor cpSimpleMotor;
struct cpSimpleMotor {
   cpConstraint constraint ;
   cpFloat rate ;
   cpFloat iSum ;
   cpFloat jAcc ;
};
struct cpSlideJoint ;
typedef struct cpSlideJoint cpSlideJoint;
struct cpSlideJoint {
   cpConstraint constraint ;
   cpVect anchorA ;
   cpVect anchorB ;
   cpFloat min ;
   cpFloat max ;
   cpVect r1 ;
   cpVect r2 ;
   cpVect n ;
   cpFloat nMass ;
   cpFloat jnAcc ;
   cpFloat bias ;
};
struct arbiterFilterContext {
   cpSpace *space ;
   cpBody *body ;
   cpShape *shape ;
};
struct spaceShapeContext {
   void (*func)(cpShape *shape , void *data ) ;
   void *data ;
};
typedef struct spaceShapeContext spaceShapeContext;
struct cpSpaceDebugColor {
   float r ;
   float g ;
   float b ;
   float a ;
};
typedef struct cpSpaceDebugColor cpSpaceDebugColor;
enum cpSpaceDebugDrawFlags {
    CP_SPACE_DEBUG_DRAW_SHAPES = 1,
    CP_SPACE_DEBUG_DRAW_CONSTRAINTS = 2,
    CP_SPACE_DEBUG_DRAW_COLLISION_POINTS = 4
} ;
typedef enum cpSpaceDebugDrawFlags cpSpaceDebugDrawFlags;
struct cpSpaceDebugDrawOptions {
   void (*drawCircle)(cpVect pos , cpFloat angle , cpFloat radius , cpSpaceDebugColor outlineColor ,
                      cpSpaceDebugColor fillColor , cpDataPointer data ) ;
   void (*drawSegment)(cpVect a , cpVect b , cpSpaceDebugColor color , cpDataPointer data ) ;
   void (*drawFatSegment)(cpVect a , cpVect b , cpFloat radius , cpSpaceDebugColor outlineColor ,
                          cpSpaceDebugColor fillColor , cpDataPointer data ) ;
   void (*drawPolygon)(int count , cpVect const   *verts , cpFloat radius , cpSpaceDebugColor outlineColor ,
                       cpSpaceDebugColor fillColor , cpDataPointer data ) ;
   void (*drawDot)(cpFloat size , cpVect pos , cpSpaceDebugColor color , cpDataPointer data ) ;
   cpSpaceDebugDrawFlags flags ;
   cpSpaceDebugColor shapeOutlineColor ;
   cpSpaceDebugColor (*colorForShape)(cpShape *shape , cpDataPointer data ) ;
   cpSpaceDebugColor constraintColor ;
   cpSpaceDebugColor collisionPointColor ;
   cpDataPointer data ;
};
typedef struct cpSpaceDebugDrawOptions cpSpaceDebugDrawOptions;
struct cpSpaceHash ;
typedef struct cpSpaceHash cpSpaceHash;
struct cpSpaceHashBin ;
typedef struct cpSpaceHashBin cpSpaceHashBin;
struct cpHandle ;
typedef struct cpHandle cpHandle;
struct cpSpaceHash {
   cpSpatialIndex spatialIndex ;
   int numcells ;
   cpFloat celldim ;
   cpSpaceHashBin **table ;
   cpHashSet *handleSet ;
   cpSpaceHashBin *pooledBins ;
   cpArray *pooledHandles ;
   cpArray *allocatedBuffers ;
   cpTimestamp stamp ;
};
struct cpHandle {
   void *obj ;
   int retain ;
   cpTimestamp stamp ;
};
struct cpSpaceHashBin {
   cpHandle *handle ;
   cpSpaceHashBin *next ;
};
struct queryRehashContext {
   cpSpaceHash *hash ;
   cpCollisionID (*func)(void *obj1 , void *obj2 , cpCollisionID id , void *data ) ;
   void *data ;
};
typedef struct queryRehashContext queryRehashContext;
struct PointQueryContext {
   cpVect point ;
   cpFloat maxDistance ;
   cpShapeFilter filter ;
   void (*func)(cpShape *shape , cpVect point , cpFloat distance , cpVect gradient ,
                void *data ) ;
};
struct SegmentQueryContext {
   cpVect start ;
   cpVect end ;
   cpFloat radius ;
   cpShapeFilter filter ;
   void (*func)(cpShape *shape , cpVect point , cpVect normal , cpFloat alpha , void *data ) ;
};
struct BBQueryContext {
   cpBB bb ;
   cpShapeFilter filter ;
   void (*func)(cpShape *shape , void *data ) ;
};
struct ShapeQueryContext {
   void (*func)(cpShape *shape , cpContactPointSet *points , void *data ) ;
   void *data ;
   cpBool anyCollision ;
};
struct cpPostStepCallback {
   void (*func)(cpSpace *space , void *key , void *data ) ;
   void *key ;
   void *data ;
};
typedef struct cpPostStepCallback cpPostStepCallback;
struct cpContactBufferHeader {
   cpTimestamp stamp ;
   cpContactBufferHeader *next ;
   unsigned int numContacts ;
};
struct cpContactBuffer {
   cpContactBufferHeader header ;
   struct cpContact contacts[(32768UL - sizeof(cpContactBufferHeader )) / sizeof(struct cpContact )] ;
};
typedef struct cpContactBuffer cpContactBuffer;
struct dynamicToStaticContext {
   cpBB (*bbfunc)(void *obj ) ;
   cpSpatialIndex *staticIndex ;
   cpCollisionID (*queryFunc)(void *obj1 , void *obj2 , cpCollisionID id , void *data ) ;
   void *data ;
};
typedef struct dynamicToStaticContext dynamicToStaticContext;
struct cpSweep1D ;
typedef struct cpSweep1D cpSweep1D;
struct Bounds {
   cpFloat min ;
   cpFloat max ;
};
typedef struct Bounds Bounds;
struct TableCell {
   void *obj ;
   Bounds bounds ;
};
typedef struct TableCell TableCell;
struct cpSweep1D {
   cpSpatialIndex spatialIndex ;
   int num ;
   int max ;
   TableCell *table ;
};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#pragma merger("0","/tmp/cil-JsKTMVd0.i","-std=gnu99,-ffast-math,-fPIC")
extern FILE *stderr ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
void cpMessage(char const   *condition , char const   *file , int line , int isError ,
               int isHardError , char const   *message  , ...) ;
__inline static cpFloat cpfabs(cpFloat f ) 
{ 
  cpFloat tmp ;

  {
  if (f < (cpFloat )0) {
    tmp = - f;
  } else {
    tmp = f;
  }
  return (tmp);
}
}
static struct cpVect  const  cpvzero  =    {(cpFloat )0.0f, (cpFloat )0.0f};
__inline static cpVect cpv(cpFloat const   x , cpFloat const   y ) 
{ 
  cpVect v ;

  {
  v.x = (cpFloat )x;
  v.y = (cpFloat )y;
  return (v);
}
}
__inline static cpVect cpvadd(cpVect const   v1 , cpVect const   v2 ) 
{ 
  cpVect tmp ;

  {
  tmp = cpv(v1.x + v2.x, v1.y + v2.y);
  return (tmp);
}
}
__inline static cpVect cpvsub(cpVect const   v1 , cpVect const   v2 ) 
{ 
  cpVect tmp ;

  {
  tmp = cpv(v1.x - v2.x, v1.y - v2.y);
  return (tmp);
}
}
__inline static cpVect cpvmult(cpVect const   v , cpFloat const   s ) 
{ 
  cpVect tmp ;

  {
  tmp = cpv(v.x * s, v.y * s);
  return (tmp);
}
}
__inline static cpFloat cpvdot(cpVect const   v1 , cpVect const   v2 ) 
{ 


  {
  return ((cpFloat )(v1.x * v2.x + v1.y * v2.y));
}
}
__inline static cpFloat cpvcross(cpVect const   v1 , cpVect const   v2 ) 
{ 


  {
  return ((cpFloat )(v1.x * v2.y - v1.y * v2.x));
}
}
__inline static cpFloat cpvlengthsq(cpVect const   v ) 
{ 
  cpFloat tmp ;

  {
  tmp = cpvdot(v, v);
  return (tmp);
}
}
__inline static cpFloat cpvlength(cpVect const   v ) 
{ 
  cpFloat tmp ;
  double tmp___0 ;

  {
  tmp = cpvdot(v, v);
  tmp___0 = sqrt(tmp);
  return (tmp___0);
}
}
__inline static cpVect cpvlerp(cpVect const   v1 , cpVect const   v2 , cpFloat const   t ) 
{ 
  cpVect tmp ;
  cpVect tmp___0 ;
  cpVect tmp___1 ;

  {
  tmp = cpvmult(v2, t);
  tmp___0 = cpvmult(v1, (cpFloat const   )1.0f - t);
  tmp___1 = cpvadd((cpVect const   )tmp___0, (cpVect const   )tmp);
  return (tmp___1);
}
}
__inline static cpFloat cpvdist(cpVect const   v1 , cpVect const   v2 ) 
{ 
  cpVect tmp ;
  cpFloat tmp___0 ;

  {
  tmp = cpvsub(v1, v2);
  tmp___0 = cpvlength((cpVect const   )tmp);
  return (tmp___0);
}
}
char const   *cpVersionString ;
cpFloat cpMomentForCircle(cpFloat m , cpFloat r1 , cpFloat r2 , cpVect offset ) ;
cpFloat cpAreaForCircle(cpFloat r1 , cpFloat r2 ) ;
cpFloat cpMomentForSegment(cpFloat m , cpVect a , cpVect b , cpFloat r ) ;
cpFloat cpAreaForSegment(cpVect a , cpVect b , cpFloat r ) ;
cpFloat cpMomentForPoly(cpFloat m , int count , cpVect const   *verts , cpVect offset ,
                        cpFloat r ) ;
cpFloat cpAreaForPoly(int const   count , cpVect const   *verts , cpFloat r ) ;
cpVect cpCentroidForPoly(int const   count , cpVect const   *verts ) ;
cpFloat cpMomentForBox(cpFloat m , cpFloat width , cpFloat height ) ;
cpFloat cpMomentForBox2(cpFloat m , cpBB box ) ;
int cpConvexHull(int count , cpVect const   *verts , cpVect *result , int *first ,
                 cpFloat tol ) ;
void cpLoopIndexes(cpVect const   *verts , int count , int *start , int *end ) ;
void cpMessage(char const   *condition , char const   *file , int line , int isError ,
               int isHardError , char const   *message  , ...) 
{ 
  char const   *tmp ;
  va_list___0 vargs ;

  {
  if (isError) {
    tmp = "Aborting due to Chipmunk error: ";
  } else {
    tmp = "Chipmunk warning: ";
  }
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp);
  __builtin_va_start(vargs, message);
  vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )message, vargs);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  __builtin_va_end(vargs);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\tFailed condition: %s\n",
          condition);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\tSource:%s:%d\n",
          file, line);
  return;
}
}
char const   *cpVersionString  =    "7.0.3";
cpFloat cpMomentForCircle(cpFloat m , cpFloat r1 , cpFloat r2 , cpVect offset ) 
{ 
  cpFloat tmp ;

  {
  tmp = cpvlengthsq((cpVect const   )offset);
  return (m * ((cpFloat )0.5f * (r1 * r1 + r2 * r2) + tmp));
}
}
cpFloat cpAreaForCircle(cpFloat r1 , cpFloat r2 ) 
{ 
  cpFloat tmp ;

  {
  tmp = cpfabs(r1 * r1 - r2 * r2);
  return (3.14159265358979323846264338327950288 * tmp);
}
}
cpFloat cpMomentForSegment(cpFloat m , cpVect a , cpVect b , cpFloat r ) 
{ 
  cpVect offset ;
  cpVect tmp ;
  cpFloat length ;
  cpFloat tmp___0 ;
  cpFloat tmp___1 ;

  {
  tmp = cpvlerp((cpVect const   )a, (cpVect const   )b, (cpFloat const   )0.5f);
  offset = tmp;
  tmp___0 = cpvdist((cpVect const   )b, (cpVect const   )a);
  length = tmp___0 + (cpFloat )2.0f * r;
  tmp___1 = cpvlengthsq((cpVect const   )offset);
  return (m * ((length * length + ((cpFloat )4.0f * r) * r) / (cpFloat )12.0f + tmp___1));
}
}
cpFloat cpAreaForSegment(cpVect a , cpVect b , cpFloat r ) 
{ 
  cpFloat tmp ;

  {
  tmp = cpvdist((cpVect const   )a, (cpVect const   )b);
  return (r * (3.14159265358979323846264338327950288 * r + (cpFloat )2.0f * tmp));
}
}
cpFloat cpMomentForPoly(cpFloat m , int count , cpVect const   *verts , cpVect offset ,
                        cpFloat r ) 
{ 
  cpFloat tmp ;
  cpFloat sum1 ;
  cpFloat sum2 ;
  int i ;
  cpVect v1 ;
  cpVect tmp___0 ;
  cpVect v2 ;
  cpVect tmp___1 ;
  cpFloat a ;
  cpFloat tmp___2 ;
  cpFloat b ;
  cpFloat tmp___3 ;
  cpFloat tmp___4 ;
  cpFloat tmp___5 ;

  {
  if (count == 2) {
    tmp = cpMomentForSegment(m, (cpVect )*(verts + 0), (cpVect )*(verts + 1), (cpFloat )0.0f);
    return (tmp);
  }
  sum1 = (cpFloat )0.0f;
  sum2 = (cpFloat )0.0f;
  i = 0;
  while (i < count) {
    tmp___0 = cpvadd(*(verts + i), (cpVect const   )offset);
    v1 = tmp___0;
    tmp___1 = cpvadd(*(verts + (i + 1) % count), (cpVect const   )offset);
    v2 = tmp___1;
    tmp___2 = cpvcross((cpVect const   )v2, (cpVect const   )v1);
    a = tmp___2;
    tmp___3 = cpvdot((cpVect const   )v1, (cpVect const   )v1);
    tmp___4 = cpvdot((cpVect const   )v1, (cpVect const   )v2);
    tmp___5 = cpvdot((cpVect const   )v2, (cpVect const   )v2);
    b = (tmp___3 + tmp___4) + tmp___5;
    sum1 += a * b;
    sum2 += a;
    i ++;
  }
  return ((m * sum1) / ((cpFloat )6.0f * sum2));
}
}
cpFloat cpAreaForPoly(int const   count , cpVect const   *verts , cpFloat r ) 
{ 
  cpFloat area ;
  cpFloat perimeter ;
  int i ;
  cpVect v1 ;
  cpVect v2 ;
  cpFloat tmp ;
  cpFloat tmp___0 ;
  cpFloat tmp___1 ;

  {
  area = (cpFloat )0.0f;
  perimeter = (cpFloat )0.0f;
  i = 0;
  while (i < (int )count) {
    v1 = *(verts + i);
    v2 = *(verts + (i + 1) % (int )count);
    tmp = cpvcross((cpVect const   )v1, (cpVect const   )v2);
    area += tmp;
    tmp___0 = cpvdist((cpVect const   )v1, (cpVect const   )v2);
    perimeter += tmp___0;
    i ++;
  }
  tmp___1 = cpfabs(r);
  return (r * (3.14159265358979323846264338327950288 * tmp___1 + perimeter) + area / (cpFloat )2.0f);
}
}
cpVect cpCentroidForPoly(int const   count , cpVect const   *verts ) 
{ 
  cpFloat sum ;
  cpVect vsum ;
  int i ;
  cpVect v1 ;
  cpVect v2 ;
  cpFloat cross ;
  cpFloat tmp ;
  cpVect tmp___0 ;
  cpVect tmp___1 ;
  cpVect tmp___2 ;

  {
  sum = (cpFloat )0.0f;
  vsum = cpvzero;
  i = 0;
  while (i < (int )count) {
    v1 = *(verts + i);
    v2 = *(verts + (i + 1) % (int )count);
    tmp = cpvcross((cpVect const   )v1, (cpVect const   )v2);
    cross = tmp;
    sum += cross;
    tmp___0 = cpvadd((cpVect const   )v1, (cpVect const   )v2);
    tmp___1 = cpvmult((cpVect const   )tmp___0, (cpFloat const   )cross);
    vsum = cpvadd((cpVect const   )vsum, (cpVect const   )tmp___1);
    i ++;
  }
  tmp___2 = cpvmult((cpVect const   )vsum, (cpFloat const   )((cpFloat )1.0f / ((cpFloat )3.0f * sum)));
  return (tmp___2);
}
}
cpFloat cpMomentForBox(cpFloat m , cpFloat width , cpFloat height ) 
{ 


  {
  return ((m * (width * width + height * height)) / (cpFloat )12.0f);
}
}
cpFloat cpMomentForBox2(cpFloat m , cpBB box ) 
{ 
  cpFloat width ;
  cpFloat height ;
  cpVect offset ;
  cpVect tmp ;
  cpVect tmp___0 ;
  cpFloat tmp___1 ;
  cpFloat tmp___2 ;

  {
  width = box.r - box.l;
  height = box.t - box.b;
  tmp = cpv((cpFloat const   )(box.l + box.r), (cpFloat const   )(box.b + box.t));
  tmp___0 = cpvmult((cpVect const   )tmp, (cpFloat const   )0.5f);
  offset = tmp___0;
  tmp___1 = cpMomentForBox(m, width, height);
  tmp___2 = cpvlengthsq((cpVect const   )offset);
  return (tmp___1 + m * tmp___2);
}
}
void cpLoopIndexes(cpVect const   *verts , int count , int *start , int *end ) 
{ 
  int tmp ;
  cpVect min ;
  cpVect max ;
  int i ;
  cpVect v ;

  {
  tmp = 0;
  *end = tmp;
  *start = tmp;
  min = *(verts + 0);
  max = min;
  i = 1;
  while (i < count) {
    v = *(verts + i);
    if (v.x < min.x) {
      min = v;
      *start = i;
    } else
    if (v.x == min.x) {
      if (v.y < min.y) {
        min = v;
        *start = i;
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (v.x > max.x) {
      max = v;
      *end = i;
    } else
    if (v.x == max.x) {
      if (v.y > max.y) {
        max = v;
        *end = i;
      }
    }
    i ++;
  }
  return;
}
}
static int QHullPartition(cpVect *verts , int count , cpVect a , cpVect b , cpFloat tol ) 
{ 
  cpFloat max ;
  int pivot ;
  cpVect delta ;
  cpVect tmp ;
  cpFloat valueTol ;
  cpFloat tmp___0 ;
  int head ;
  int tail ;
  cpFloat value ;
  cpVect tmp___1 ;
  cpFloat tmp___2 ;
  cpVect __TMP__ ;
  cpVect __TMP_____0 ;

  {
  if (count == 0) {
    return (0);
  }
  max = (cpFloat )0;
  pivot = 0;
  tmp = cpvsub((cpVect const   )b, (cpVect const   )a);
  delta = tmp;
  tmp___0 = cpvlength((cpVect const   )delta);
  valueTol = tol * tmp___0;
  head = 0;
  tail = count - 1;
  while (head <= tail) {
    tmp___1 = cpvsub((cpVect const   )*(verts + head), (cpVect const   )a);
    tmp___2 = cpvcross((cpVect const   )tmp___1, (cpVect const   )delta);
    value = tmp___2;
    if (value > valueTol) {
      if (value > max) {
        max = value;
        pivot = head;
      }
      head ++;
    } else {
      __TMP__ = *(verts + head);
      *(verts + head) = *(verts + tail);
      *(verts + tail) = __TMP__;
      tail --;
    }
  }
  if (pivot != 0) {
    __TMP_____0 = *(verts + 0);
    *(verts + 0) = *(verts + pivot);
    *(verts + pivot) = __TMP_____0;
  }
  return (head);
}
}
static int QHullReduce(cpFloat tol , cpVect *verts , int count , cpVect a , cpVect pivot ,
                       cpVect b , cpVect *result ) 
{ 
  int left_count ;
  int tmp ;
  int index___0 ;
  int tmp___0 ;
  int tmp___1 ;
  int right_count ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if (count < 0) {
    return (0);
  } else
  if (count == 0) {
    *(result + 0) = pivot;
    return (1);
  } else {
    tmp = QHullPartition(verts, count, a, pivot, tol);
    left_count = tmp;
    tmp___0 = QHullReduce(tol, verts + 1, left_count - 1, a, *(verts + 0), pivot,
                          result);
    index___0 = tmp___0;
    tmp___1 = index___0;
    index___0 ++;
    *(result + tmp___1) = pivot;
    tmp___2 = QHullPartition(verts + left_count, count - left_count, pivot, b, tol);
    right_count = tmp___2;
    tmp___3 = QHullReduce(tol, (verts + left_count) + 1, right_count - 1, pivot, *(verts + left_count),
                          b, result + index___0);
    return (index___0 + tmp___3);
  }
}
}
int cpConvexHull(int count , cpVect const   *verts , cpVect *result , int *first ,
                 cpFloat tol ) 
{ 
  int start ;
  int end ;
  cpVect __TMP__ ;
  cpVect __TMP_____0 ;
  int tmp ;
  int tmp___0 ;
  cpVect a ;
  cpVect b ;
  int tmp___1 ;

  {
  if ((unsigned long )verts != (unsigned long )result) {
    memcpy((void * __restrict  )result, (void const   * __restrict  )verts, (unsigned long )count * sizeof(cpVect ));
  }
  cpLoopIndexes(verts, count, & start, & end);
  if (start == end) {
    if (first) {
      *first = 0;
    }
    return (1);
  }
  __TMP__ = *(result + 0);
  *(result + 0) = *(result + start);
  *(result + start) = __TMP__;
  __TMP_____0 = *(result + 1);
  if (end == 0) {
    tmp = start;
  } else {
    tmp = end;
  }
  *(result + 1) = *(result + tmp);
  if (end == 0) {
    tmp___0 = start;
  } else {
    tmp___0 = end;
  }
  *(result + tmp___0) = __TMP_____0;
  a = *(result + 0);
  b = *(result + 1);
  if (first) {
    *first = start;
  }
  tmp___1 = QHullReduce(tol, result + 2, count - 2, a, b, a, result + 1);
  return (tmp___1 + 1);
}
}
#pragma merger("0","/tmp/cil-E4oi3sYO.i","-std=gnu99,-ffast-math,-fPIC")
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
__inline static cpFloat cpfmax(cpFloat a , cpFloat b ) 
{ 
  cpFloat tmp ;

  {
  if (a > b) {
    tmp = a;
  } else {
    tmp = b;
  }
  return (tmp);
}
}
__inline static cpFloat cpfmin(cpFloat a , cpFloat b ) 
{ 
  cpFloat tmp ;

  {
  if (a < b) {
    tmp = a;
  } else {
    tmp = b;
  }
  return (tmp);
}
}
__inline static cpFloat cpfclamp(cpFloat f , cpFloat min , cpFloat max ) 
{ 
  cpFloat tmp ;
  cpFloat tmp___0 ;

  {
  tmp = cpfmax(f, min);
  tmp___0 = cpfmin(tmp, max);
  return (tmp___0);
}
}
static struct cpVect  const  cpvzero___0  =    {(cpFloat )0.0f, (cpFloat )0.0f};
__inline static cpVect cpvneg(cpVect const   v ) 
{ 
  cpVect tmp ;

  {
  tmp = cpv(- v.x, - v.y);
  return (tmp);
}
}
__inline static cpVect cpvperp(cpVect const   v ) 
{ 
  cpVect tmp ;

  {
  tmp = cpv(- v.y, v.x);
  return (tmp);
}
}
__inline static cpVect cpvrotate(cpVect const   v1 , cpVect const   v2 ) 
{ 
  cpVect tmp ;

  {
  tmp = cpv(v1.x * v2.x - v1.y * v2.y, v1.x * v2.y + v1.y * v2.x);
  return (tmp);
}
}
cpFloat cpArbiterGetRestitution(cpArbiter const   *arb ) ;
void cpArbiterSetRestitution(cpArbiter *arb , cpFloat restitution ) ;
cpFloat cpArbiterGetFriction(cpArbiter const   *arb ) ;
void cpArbiterSetFriction(cpArbiter *arb , cpFloat friction ) ;
cpVect cpArbiterGetSurfaceVelocity(cpArbiter *arb ) ;
void cpArbiterSetSurfaceVelocity(cpArbiter *arb , cpVect vr ) ;
cpDataPointer cpArbiterGetUserData(cpArbiter const   *arb ) ;
void cpArbiterSetUserData(cpArbiter *arb , cpDataPointer userData ) ;
cpVect cpArbiterTotalImpulse(cpArbiter const   *arb ) ;
cpFloat cpArbiterTotalKE(cpArbiter const   *arb ) ;
cpBool cpArbiterIgnore(cpArbiter *arb ) ;
void cpArbiterGetShapes(cpArbiter const   *arb , cpShape **a , cpShape **b ) ;
void cpArbiterGetBodies(cpArbiter const   *arb , cpBody **a , cpBody **b ) ;
cpContactPointSet cpArbiterGetContactPointSet(cpArbiter const   *arb ) ;
void cpArbiterSetContactPointSet(cpArbiter *arb , cpContactPointSet *set ) ;
cpBool cpArbiterIsFirstContact(cpArbiter const   *arb ) ;
cpBool cpArbiterIsRemoval(cpArbiter const   *arb ) ;
int cpArbiterGetCount(cpArbiter const   *arb ) ;
cpVect cpArbiterGetNormal(cpArbiter const   *arb ) ;
cpVect cpArbiterGetPointA(cpArbiter const   *arb , int i ) ;
cpVect cpArbiterGetPointB(cpArbiter const   *arb , int i ) ;
cpFloat cpArbiterGetDepth(cpArbiter const   *arb , int i ) ;
cpBool cpArbiterCallWildcardBeginA(cpArbiter *arb , cpSpace *space ) ;
cpBool cpArbiterCallWildcardBeginB(cpArbiter *arb , cpSpace *space ) ;
cpBool cpArbiterCallWildcardPreSolveA(cpArbiter *arb , cpSpace *space ) ;
cpBool cpArbiterCallWildcardPreSolveB(cpArbiter *arb , cpSpace *space ) ;
void cpArbiterCallWildcardPostSolveA(cpArbiter *arb , cpSpace *space ) ;
void cpArbiterCallWildcardPostSolveB(cpArbiter *arb , cpSpace *space ) ;
void cpArbiterCallWildcardSeparateA(cpArbiter *arb , cpSpace *space ) ;
void cpArbiterCallWildcardSeparateB(cpArbiter *arb , cpSpace *space ) ;
void const   *cpHashSetFind(cpHashSet *set , cpHashValue hash , void const   *ptr ) ;
cpArbiter *cpArbiterInit(cpArbiter *arb , cpShape *a , cpShape *b ) ;
__inline static struct cpArbiterThread *cpArbiterThreadForBody(cpArbiter *arb , cpBody *body ) 
{ 
  struct cpArbiterThread *tmp ;

  {
  if ((unsigned long )arb->body_a == (unsigned long )body) {
    tmp = & arb->thread_a;
  } else {
    tmp = & arb->thread_b;
  }
  return (tmp);
}
}
void cpArbiterUnthread(cpArbiter *arb ) ;
void cpArbiterUpdate(cpArbiter *arb , struct cpCollisionInfo *info , cpSpace *space ) ;
void cpArbiterPreStep(cpArbiter *arb , cpFloat dt , cpFloat slop , cpFloat bias ) ;
void cpArbiterApplyCachedImpulse(cpArbiter *arb , cpFloat dt_coef ) ;
void cpArbiterApplyImpulse(cpArbiter *arb ) ;
__inline static cpVect relative_velocity(cpBody *a , cpBody *b , cpVect r1 , cpVect r2 ) 
{ 
  cpVect v1_sum ;
  cpVect tmp ;
  cpVect tmp___0 ;
  cpVect tmp___1 ;
  cpVect v2_sum ;
  cpVect tmp___2 ;
  cpVect tmp___3 ;
  cpVect tmp___4 ;
  cpVect tmp___5 ;

  {
  tmp = cpvperp((cpVect const   )r1);
  tmp___0 = cpvmult((cpVect const   )tmp, (cpFloat const   )a->w);
  tmp___1 = cpvadd((cpVect const   )a->v, (cpVect const   )tmp___0);
  v1_sum = tmp___1;
  tmp___2 = cpvperp((cpVect const   )r2);
  tmp___3 = cpvmult((cpVect const   )tmp___2, (cpFloat const   )b->w);
  tmp___4 = cpvadd((cpVect const   )b->v, (cpVect const   )tmp___3);
  v2_sum = tmp___4;
  tmp___5 = cpvsub((cpVect const   )v2_sum, (cpVect const   )v1_sum);
  return (tmp___5);
}
}
__inline static cpFloat normal_relative_velocity(cpBody *a , cpBody *b , cpVect r1 ,
                                                 cpVect r2 , cpVect n ) 
{ 
  cpVect tmp ;
  cpFloat tmp___0 ;

  {
  tmp = relative_velocity(a, b, r1, r2);
  tmp___0 = cpvdot((cpVect const   )tmp, (cpVect const   )n);
  return (tmp___0);
}
}
__inline static void apply_impulse(cpBody *body , cpVect j , cpVect r ) 
{ 
  cpVect tmp ;
  cpFloat tmp___0 ;

  {
  tmp = cpvmult((cpVect const   )j, (cpFloat const   )body->m_inv);
  body->v = cpvadd((cpVect const   )body->v, (cpVect const   )tmp);
  tmp___0 = cpvcross((cpVect const   )r, (cpVect const   )j);
  body->w += body->i_inv * tmp___0;
  return;
}
}
__inline static void apply_impulses(cpBody *a , cpBody *b , cpVect r1 , cpVect r2 ,
                                    cpVect j ) 
{ 
  cpVect tmp ;

  {
  tmp = cpvneg((cpVect const   )j);
  apply_impulse(a, tmp, r1);
  apply_impulse(b, j, r2);
  return;
}
}
__inline static void apply_bias_impulse(cpBody *body , cpVect j , cpVect r ) 
{ 
  cpVect tmp ;
  cpFloat tmp___0 ;

  {
  tmp = cpvmult((cpVect const   )j, (cpFloat const   )body->m_inv);
  body->v_bias = cpvadd((cpVect const   )body->v_bias, (cpVect const   )tmp);
  tmp___0 = cpvcross((cpVect const   )r, (cpVect const   )j);
  body->w_bias += body->i_inv * tmp___0;
  return;
}
}
__inline static void apply_bias_impulses(cpBody *a , cpBody *b , cpVect r1 , cpVect r2 ,
                                         cpVect j ) 
{ 
  cpVect tmp ;

  {
  tmp = cpvneg((cpVect const   )j);
  apply_bias_impulse(a, tmp, r1);
  apply_bias_impulse(b, j, r2);
  return;
}
}
__inline static cpFloat k_scalar_body(cpBody *body , cpVect r , cpVect n ) 
{ 
  cpFloat rcn ;
  cpFloat tmp ;

  {
  tmp = cpvcross((cpVect const   )r, (cpVect const   )n);
  rcn = tmp;
  return (body->m_inv + (body->i_inv * rcn) * rcn);
}
}
__inline static cpFloat k_scalar(cpBody *a , cpBody *b , cpVect r1 , cpVect r2 , cpVect n ) 
{ 
  cpFloat value ;
  cpFloat tmp ;
  cpFloat tmp___0 ;

  {
  tmp = k_scalar_body(a, r1, n);
  tmp___0 = k_scalar_body(b, r2, n);
  value = tmp + tmp___0;
  return (value);
}
}
cpCollisionHandler cpCollisionHandlerDoNothing ;
__inline static void unthreadHelper(cpArbiter *arb , cpBody *body ) 
{ 
  struct cpArbiterThread *thread ;
  struct cpArbiterThread *tmp ;
  cpArbiter *prev ;
  cpArbiter *next ;
  struct cpArbiterThread *tmp___0 ;
  struct cpArbiterThread *tmp___1 ;

  {
  tmp = cpArbiterThreadForBody(arb, body);
  thread = tmp;
  prev = thread->prev;
  next = thread->next;
  if (prev) {
    tmp___0 = cpArbiterThreadForBody(prev, body);
    tmp___0->next = next;
  } else
  if ((unsigned long )body->arbiterList == (unsigned long )arb) {
    body->arbiterList = next;
  }
  if (next) {
    tmp___1 = cpArbiterThreadForBody(next, body);
    tmp___1->prev = prev;
  }
  thread->prev = (struct cpArbiter *)((void *)0);
  thread->next = (struct cpArbiter *)((void *)0);
  return;
}
}
void cpArbiterUnthread(cpArbiter *arb ) 
{ 


  {
  unthreadHelper(arb, arb->body_a);
  unthreadHelper(arb, arb->body_b);
  return;
}
}
cpBool cpArbiterIsFirstContact(cpArbiter const   *arb ) 
{ 


  {
  return ((cpBool )((unsigned int const   )arb->state == 0U));
}
}
cpBool cpArbiterIsRemoval(cpArbiter const   *arb ) 
{ 


  {
  return ((cpBool )((unsigned int const   )arb->state == 4U));
}
}
int cpArbiterGetCount(cpArbiter const   *arb ) 
{ 
  int tmp ;

  {
  if ((unsigned int const   )arb->state < 3U) {
    tmp = arb->count;
  } else {
    tmp = (int const   )0;
  }
  return ((int )tmp);
}
}
cpVect cpArbiterGetNormal(cpArbiter const   *arb ) 
{ 
  double tmp ;
  cpVect tmp___0 ;

  {
  if (arb->swapped) {
    tmp = (double )(- 1.0f);
  } else {
    tmp = 1.0;
  }
  tmp___0 = cpvmult(arb->n, (cpFloat const   )tmp);
  return (tmp___0);
}
}
cpVect cpArbiterGetPointA(cpArbiter const   *arb , int i ) 
{ 
  int tmp ;
  cpVect tmp___0 ;

  {
  if (0 <= i) {
    tmp = cpArbiterGetCount(arb);
    if (! (i < tmp)) {
      cpMessage("0 <= i && i < cpArbiterGetCount(arb)", "../src/cpArbiter.c", 79,
                1, 1, "Index error: The specified contact index is invalid for this arbiter");
      abort();
    }
  } else {
    cpMessage("0 <= i && i < cpArbiterGetCount(arb)", "../src/cpArbiter.c", 79, 1,
              1, "Index error: The specified contact index is invalid for this arbiter");
    abort();
  }
  tmp___0 = cpvadd((cpVect const   )(arb->body_a)->p, (cpVect const   )(arb->contacts + i)->r1);
  return (tmp___0);
}
}
cpVect cpArbiterGetPointB(cpArbiter const   *arb , int i ) 
{ 
  int tmp ;
  cpVect tmp___0 ;

  {
  if (0 <= i) {
    tmp = cpArbiterGetCount(arb);
    if (! (i < tmp)) {
      cpMessage("0 <= i && i < cpArbiterGetCount(arb)", "../src/cpArbiter.c", 86,
                1, 1, "Index error: The specified contact index is invalid for this arbiter");
      abort();
    }
  } else {
    cpMessage("0 <= i && i < cpArbiterGetCount(arb)", "../src/cpArbiter.c", 86, 1,
              1, "Index error: The specified contact index is invalid for this arbiter");
    abort();
  }
  tmp___0 = cpvadd((cpVect const   )(arb->body_b)->p, (cpVect const   )(arb->contacts + i)->r2);
  return (tmp___0);
}
}
cpFloat cpArbiterGetDepth(cpArbiter const   *arb , int i ) 
{ 
  int tmp ;
  struct cpContact *con ;
  cpVect tmp___0 ;
  cpVect tmp___1 ;
  cpVect tmp___2 ;
  cpFloat tmp___3 ;

  {
  if (0 <= i) {
    tmp = cpArbiterGetCount(arb);
    if (! (i < tmp)) {
      cpMessage("0 <= i && i < cpArbiterGetCount(arb)", "../src/cpArbiter.c", 93,
                1, 1, "Index error: The specified contact index is invalid for this arbiter");
      abort();
    }
  } else {
    cpMessage("0 <= i && i < cpArbiterGetCount(arb)", "../src/cpArbiter.c", 93, 1,
              1, "Index error: The specified contact index is invalid for this arbiter");
    abort();
  }
  con = arb->contacts + i;
  tmp___0 = cpvsub((cpVect const   )(arb->body_b)->p, (cpVect const   )(arb->body_a)->p);
  tmp___1 = cpvsub((cpVect const   )con->r2, (cpVect const   )con->r1);
  tmp___2 = cpvadd((cpVect const   )tmp___1, (cpVect const   )tmp___0);
  tmp___3 = cpvdot((cpVect const   )tmp___2, arb->n);
  return (tmp___3);
}
}
cpContactPointSet cpArbiterGetContactPointSet(cpArbiter const   *arb ) 
{ 
  cpContactPointSet set ;
  cpBool swapped ;
  cpVect n ;
  cpVect tmp ;
  int i ;
  cpVect p1 ;
  cpVect tmp___0 ;
  cpVect p2 ;
  cpVect tmp___1 ;
  cpVect tmp___2 ;

  {
  set.count = cpArbiterGetCount(arb);
  swapped = (cpBool )arb->swapped;
  n = arb->n;
  if (swapped) {
    tmp = cpvneg((cpVect const   )n);
    set.normal = tmp;
  } else {
    set.normal = n;
  }
  i = 0;
  while (i < set.count) {
    tmp___0 = cpvadd((cpVect const   )(arb->body_a)->p, (cpVect const   )(arb->contacts + i)->r1);
    p1 = tmp___0;
    tmp___1 = cpvadd((cpVect const   )(arb->body_b)->p, (cpVect const   )(arb->contacts + i)->r2);
    p2 = tmp___1;
    if (swapped) {
      set.points[i].pointA = p2;
    } else {
      set.points[i].pointA = p1;
    }
    if (swapped) {
      set.points[i].pointB = p1;
    } else {
      set.points[i].pointB = p2;
    }
    tmp___2 = cpvsub((cpVect const   )p2, (cpVect const   )p1);
    set.points[i].distance = cpvdot((cpVect const   )tmp___2, (cpVect const   )n);
    i ++;
  }
  return (set);
}
}
void cpArbiterSetContactPointSet(cpArbiter *arb , cpContactPointSet *set ) 
{ 
  int count ;
  cpBool swapped ;
  cpVect tmp ;
  int i ;
  cpVect p1 ;
  cpVect p2 ;
  cpVect tmp___0 ;
  cpVect tmp___1 ;

  {
  count = set->count;
  if (! (count == arb->count)) {
    cpMessage("count == arb->count", "../src/cpArbiter.c", 126, 1, 1, "The number of contact points cannot be changed.");
    abort();
  }
  swapped = arb->swapped;
  if (swapped) {
    tmp = cpvneg((cpVect const   )set->normal);
    arb->n = tmp;
  } else {
    arb->n = set->normal;
  }
  i = 0;
  while (i < count) {
    p1 = set->points[i].pointA;
    p2 = set->points[i].pointB;
    if (swapped) {
      tmp___0 = p2;
    } else {
      tmp___0 = p1;
    }
    (arb->contacts + i)->r1 = cpvsub((cpVect const   )tmp___0, (cpVect const   )(arb->body_a)->p);
    if (swapped) {
      tmp___1 = p1;
    } else {
      tmp___1 = p2;
    }
    (arb->contacts + i)->r2 = cpvsub((cpVect const   )tmp___1, (cpVect const   )(arb->body_b)->p);
    i ++;
  }
  return;
}
}
cpVect cpArbiterTotalImpulse(cpArbiter const   *arb ) 
{ 
  struct cpContact *contacts ;
  cpVect n ;
  cpVect sum ;
  int i ;
  int count ;
  int tmp ;
  struct cpContact *con ;
  cpVect tmp___0 ;
  cpVect tmp___1 ;
  cpVect tmp___2 ;
  cpVect tmp___3 ;

  {
  contacts = (struct cpContact *)arb->contacts;
  n = arb->n;
  sum = cpvzero___0;
  i = 0;
  tmp = cpArbiterGetCount(arb);
  count = tmp;
  while (i < count) {
    con = contacts + i;
    tmp___0 = cpv((cpFloat const   )con->jnAcc, (cpFloat const   )con->jtAcc);
    tmp___1 = cpvrotate((cpVect const   )n, (cpVect const   )tmp___0);
    sum = cpvadd((cpVect const   )sum, (cpVect const   )tmp___1);
    i ++;
  }
  if (arb->swapped) {
    tmp___3 = sum;
  } else {
    tmp___2 = cpvneg((cpVect const   )sum);
    tmp___3 = tmp___2;
  }
  return (tmp___3);
  return ((cpVect )cpvzero___0);
}
}
cpFloat cpArbiterTotalKE(cpArbiter const   *arb ) 
{ 
  cpFloat eCoef ;
  cpFloat sum ;
  struct cpContact *contacts ;
  int i ;
  int count ;
  int tmp ;
  struct cpContact *con ;
  cpFloat jnAcc ;
  cpFloat jtAcc ;

  {
  eCoef = (cpFloat )(((cpFloat const   )1 - arb->e) / ((cpFloat const   )1 + arb->e));
  sum = 0.0;
  contacts = (struct cpContact *)arb->contacts;
  i = 0;
  tmp = cpArbiterGetCount(arb);
  count = tmp;
  while (i < count) {
    con = contacts + i;
    jnAcc = con->jnAcc;
    jtAcc = con->jtAcc;
    sum += ((eCoef * jnAcc) * jnAcc) / con->nMass + (jtAcc * jtAcc) / con->tMass;
    i ++;
  }
  return (sum);
}
}
cpBool cpArbiterIgnore(cpArbiter *arb ) 
{ 


  {
  arb->state = (enum cpArbiterState )2;
  return ((cpBool )0);
}
}
cpFloat cpArbiterGetRestitution(cpArbiter const   *arb ) 
{ 


  {
  return ((cpFloat )arb->e);
}
}
void cpArbiterSetRestitution(cpArbiter *arb , cpFloat restitution ) 
{ 


  {
  arb->e = restitution;
  return;
}
}
cpFloat cpArbiterGetFriction(cpArbiter const   *arb ) 
{ 


  {
  return ((cpFloat )arb->u);
}
}
void cpArbiterSetFriction(cpArbiter *arb , cpFloat friction ) 
{ 


  {
  arb->u = friction;
  return;
}
}
cpVect cpArbiterGetSurfaceVelocity(cpArbiter *arb ) 
{ 
  double tmp ;
  cpVect tmp___0 ;

  {
  if (arb->swapped) {
    tmp = (double )(- 1.0f);
  } else {
    tmp = 1.0;
  }
  tmp___0 = cpvmult((cpVect const   )arb->surface_vr, (cpFloat const   )tmp);
  return (tmp___0);
}
}
void cpArbiterSetSurfaceVelocity(cpArbiter *arb , cpVect vr ) 
{ 
  double tmp ;

  {
  if (arb->swapped) {
    tmp = (double )(- 1.0f);
  } else {
    tmp = 1.0;
  }
  arb->surface_vr = cpvmult((cpVect const   )vr, (cpFloat const   )tmp);
  return;
}
}
cpDataPointer cpArbiterGetUserData(cpArbiter const   *arb ) 
{ 


  {
  return ((cpDataPointer )arb->data);
}
}
void cpArbiterSetUserData(cpArbiter *arb , cpDataPointer userData ) 
{ 


  {
  arb->data = userData;
  return;
}
}
void cpArbiterGetShapes(cpArbiter const   *arb , cpShape **a , cpShape **b ) 
{ 


  {
  if (arb->swapped) {
    *a = (cpShape *)arb->b;
    *b = (cpShape *)arb->a;
  } else {
    *a = (cpShape *)arb->a;
    *b = (cpShape *)arb->b;
  }
  return;
}
}
void cpArbiterGetBodies(cpArbiter const   *arb , cpBody **a , cpBody **b ) 
{ 
  cpShape *shape_a ;
  cpShape *shape_b ;

  {
  cpArbiterGetShapes(arb, & shape_a, & shape_b);
  *a = shape_a->body;
  *b = shape_b->body;
  return;
}
}
cpBool cpArbiterCallWildcardBeginA(cpArbiter *arb , cpSpace *space ) 
{ 
  cpCollisionHandler *handler ;
  cpBool tmp ;

  {
  handler = arb->handlerA;
  tmp = (*(handler->beginFunc))(arb, space, handler->userData);
  return (tmp);
}
}
cpBool cpArbiterCallWildcardBeginB(cpArbiter *arb , cpSpace *space ) 
{ 
  cpCollisionHandler *handler ;
  cpBool retval ;
  cpBool tmp ;

  {
  handler = arb->handlerB;
  arb->swapped = (cpBool )(! arb->swapped);
  tmp = (*(handler->beginFunc))(arb, space, handler->userData);
  retval = tmp;
  arb->swapped = (cpBool )(! arb->swapped);
  return (retval);
}
}
cpBool cpArbiterCallWildcardPreSolveA(cpArbiter *arb , cpSpace *space ) 
{ 
  cpCollisionHandler *handler ;
  cpBool tmp ;

  {
  handler = arb->handlerA;
  tmp = (*(handler->preSolveFunc))(arb, space, handler->userData);
  return (tmp);
}
}
cpBool cpArbiterCallWildcardPreSolveB(cpArbiter *arb , cpSpace *space ) 
{ 
  cpCollisionHandler *handler ;
  cpBool retval ;
  cpBool tmp ;

  {
  handler = arb->handlerB;
  arb->swapped = (cpBool )(! arb->swapped);
  tmp = (*(handler->preSolveFunc))(arb, space, handler->userData);
  retval = tmp;
  arb->swapped = (cpBool )(! arb->swapped);
  return (retval);
}
}
void cpArbiterCallWildcardPostSolveA(cpArbiter *arb , cpSpace *space ) 
{ 
  cpCollisionHandler *handler ;

  {
  handler = arb->handlerA;
  (*(handler->postSolveFunc))(arb, space, handler->userData);
  return;
}
}
void cpArbiterCallWildcardPostSolveB(cpArbiter *arb , cpSpace *space ) 
{ 
  cpCollisionHandler *handler ;

  {
  handler = arb->handlerB;
  arb->swapped = (cpBool )(! arb->swapped);
  (*(handler->postSolveFunc))(arb, space, handler->userData);
  arb->swapped = (cpBool )(! arb->swapped);
  return;
}
}
void cpArbiterCallWildcardSeparateA(cpArbiter *arb , cpSpace *space ) 
{ 
  cpCollisionHandler *handler ;

  {
  handler = arb->handlerA;
  (*(handler->separateFunc))(arb, space, handler->userData);
  return;
}
}
void cpArbiterCallWildcardSeparateB(cpArbiter *arb , cpSpace *space ) 
{ 
  cpCollisionHandler *handler ;

  {
  handler = arb->handlerB;
  arb->swapped = (cpBool )(! arb->swapped);
  (*(handler->separateFunc))(arb, space, handler->userData);
  arb->swapped = (cpBool )(! arb->swapped);
  return;
}
}
cpArbiter *cpArbiterInit(cpArbiter *arb , cpShape *a , cpShape *b ) 
{ 


  {
  arb->handler = (cpCollisionHandler *)((void *)0);
  arb->swapped = (cpBool )0;
  arb->handler = (cpCollisionHandler *)((void *)0);
  arb->handlerA = (cpCollisionHandler *)((void *)0);
  arb->handlerB = (cpCollisionHandler *)((void *)0);
  arb->e = (cpFloat )0.0f;
  arb->u = (cpFloat )0.0f;
  arb->surface_vr = (cpVect )cpvzero___0;
  arb->count = 0;
  arb->contacts = (struct cpContact *)((void *)0);
  arb->a = (cpShape const   *)a;
  arb->body_a = a->body;
  arb->b = (cpShape const   *)b;
  arb->body_b = b->body;
  arb->thread_a.next = (struct cpArbiter *)((void *)0);
  arb->thread_b.next = (struct cpArbiter *)((void *)0);
  arb->thread_a.prev = (struct cpArbiter *)((void *)0);
  arb->thread_b.prev = (struct cpArbiter *)((void *)0);
  arb->stamp = (cpTimestamp )0;
  arb->state = (enum cpArbiterState )0;
  arb->data = (void *)0;
  return (arb);
}
}
__inline static cpCollisionHandler *cpSpaceLookupHandler(cpSpace *space , cpCollisionType a ,
                                                         cpCollisionType b , cpCollisionHandler *defaultValue ) 
{ 
  cpCollisionType types[2] ;
  cpCollisionHandler *handler ;
  void const   *tmp ;
  cpCollisionHandler *tmp___0 ;

  {
  types[0] = a;
  types[1] = b;
  tmp = cpHashSetFind(space->collisionHandlers, a * 3344921057UL ^ b * 3344921057UL,
                      (void const   *)(types));
  handler = (cpCollisionHandler *)tmp;
  if (handler) {
    tmp___0 = handler;
  } else {
    tmp___0 = defaultValue;
  }
  return (tmp___0);
}
}
void cpArbiterUpdate(cpArbiter *arb , struct cpCollisionInfo *info , cpSpace *space ) 
{ 
  cpShape const   *a ;
  cpShape const   *b ;
  int i ;
  struct cpContact *con ;
  cpFloat tmp ;
  int j ;
  struct cpContact *old ;
  cpVect surface_vr ;
  cpVect tmp___0 ;
  cpFloat tmp___1 ;
  cpVect tmp___2 ;
  cpCollisionType typeA ;
  cpCollisionType typeB ;
  cpCollisionHandler *defaultHandler ;
  cpCollisionHandler *handler ;
  cpCollisionHandler *tmp___3 ;
  cpBool swapped ;
  cpBool tmp___4 ;
  int tmp___5 ;
  cpCollisionType tmp___6 ;
  cpCollisionType tmp___7 ;

  {
  a = info->a;
  b = info->b;
  arb->a = a;
  arb->body_a = (cpBody *)a->body;
  arb->b = b;
  arb->body_b = (cpBody *)b->body;
  i = 0;
  while (i < info->count) {
    con = info->arr + i;
    con->r1 = cpvsub((cpVect const   )con->r1, (cpVect const   )(a->body)->p);
    con->r2 = cpvsub((cpVect const   )con->r2, (cpVect const   )(b->body)->p);
    tmp = (cpFloat )0.0f;
    con->jtAcc = tmp;
    con->jnAcc = tmp;
    j = 0;
    while (j < arb->count) {
      old = arb->contacts + j;
      if (con->hash == old->hash) {
        con->jnAcc = old->jnAcc;
        con->jtAcc = old->jtAcc;
      }
      j ++;
    }
    i ++;
  }
  arb->contacts = info->arr;
  arb->count = info->count;
  arb->n = info->n;
  arb->e = (cpFloat )(a->e * b->e);
  arb->u = (cpFloat )(a->u * b->u);
  tmp___0 = cpvsub(b->surfaceV, a->surfaceV);
  surface_vr = tmp___0;
  tmp___1 = cpvdot((cpVect const   )surface_vr, (cpVect const   )info->n);
  tmp___2 = cpvmult((cpVect const   )info->n, (cpFloat const   )tmp___1);
  arb->surface_vr = cpvsub((cpVect const   )surface_vr, (cpVect const   )tmp___2);
  typeA = (cpCollisionType )(info->a)->type;
  typeB = (cpCollisionType )(info->b)->type;
  defaultHandler = & space->defaultHandler;
  tmp___3 = cpSpaceLookupHandler(space, typeA, typeB, defaultHandler);
  arb->handler = tmp___3;
  handler = tmp___3;
  if (typeA != (cpCollisionType )handler->typeA) {
    if (handler->typeA != 0xffffffffffffffffUL) {
      tmp___5 = 1;
    } else {
      tmp___5 = 0;
    }
  } else {
    tmp___5 = 0;
  }
  tmp___4 = (cpBool )tmp___5;
  arb->swapped = tmp___4;
  swapped = tmp___4;
  if ((unsigned long )handler != (unsigned long )defaultHandler) {
    goto _L;
  } else
  if (space->usesWildcards) {
    _L: /* CIL Label */ 
    if (swapped) {
      tmp___6 = typeB;
    } else {
      tmp___6 = typeA;
    }
    arb->handlerA = cpSpaceLookupHandler(space, tmp___6, ~ ((cpCollisionType )0),
                                         & cpCollisionHandlerDoNothing);
    if (swapped) {
      tmp___7 = typeA;
    } else {
      tmp___7 = typeB;
    }
    arb->handlerB = cpSpaceLookupHandler(space, tmp___7, ~ ((cpCollisionType )0),
                                         & cpCollisionHandlerDoNothing);
  }
  if ((unsigned int )arb->state == 3U) {
    arb->state = (enum cpArbiterState )0;
  }
  return;
}
}
void cpArbiterPreStep(cpArbiter *arb , cpFloat dt , cpFloat slop , cpFloat bias ) 
{ 
  cpBody *a ;
  cpBody *b ;
  cpVect n ;
  cpVect body_delta ;
  cpVect tmp ;
  int i ;
  struct cpContact *con ;
  cpFloat tmp___0 ;
  cpVect tmp___1 ;
  cpFloat tmp___2 ;
  cpFloat dist ;
  cpVect tmp___3 ;
  cpVect tmp___4 ;
  cpFloat tmp___5 ;
  cpFloat tmp___6 ;
  cpFloat tmp___7 ;

  {
  a = arb->body_a;
  b = arb->body_b;
  n = arb->n;
  tmp = cpvsub((cpVect const   )b->p, (cpVect const   )a->p);
  body_delta = tmp;
  i = 0;
  while (i < arb->count) {
    con = arb->contacts + i;
    tmp___0 = k_scalar(a, b, con->r1, con->r2, n);
    con->nMass = (cpFloat )1.0f / tmp___0;
    tmp___1 = cpvperp((cpVect const   )n);
    tmp___2 = k_scalar(a, b, con->r1, con->r2, tmp___1);
    con->tMass = (cpFloat )1.0f / tmp___2;
    tmp___3 = cpvsub((cpVect const   )con->r2, (cpVect const   )con->r1);
    tmp___4 = cpvadd((cpVect const   )tmp___3, (cpVect const   )body_delta);
    tmp___5 = cpvdot((cpVect const   )tmp___4, (cpVect const   )n);
    dist = tmp___5;
    tmp___6 = cpfmin((cpFloat )0.0f, dist + slop);
    con->bias = (- bias * tmp___6) / dt;
    con->jBias = (cpFloat )0.0f;
    tmp___7 = normal_relative_velocity(a, b, con->r1, con->r2, n);
    con->bounce = tmp___7 * arb->e;
    i ++;
  }
  return;
}
}
void cpArbiterApplyCachedImpulse(cpArbiter *arb , cpFloat dt_coef ) 
{ 
  cpBool tmp ;
  cpBody *a ;
  cpBody *b ;
  cpVect n ;
  int i ;
  struct cpContact *con ;
  cpVect j ;
  cpVect tmp___0 ;
  cpVect tmp___1 ;
  cpVect tmp___2 ;

  {
  tmp = cpArbiterIsFirstContact((cpArbiter const   *)arb);
  if (tmp) {
    return;
  }
  a = arb->body_a;
  b = arb->body_b;
  n = arb->n;
  i = 0;
  while (i < arb->count) {
    con = arb->contacts + i;
    tmp___0 = cpv((cpFloat const   )con->jnAcc, (cpFloat const   )con->jtAcc);
    tmp___1 = cpvrotate((cpVect const   )n, (cpVect const   )tmp___0);
    j = tmp___1;
    tmp___2 = cpvmult((cpVect const   )j, (cpFloat const   )dt_coef);
    apply_impulses(a, b, con->r1, con->r2, tmp___2);
    i ++;
  }
  return;
}
}
void cpArbiterApplyImpulse(cpArbiter *arb ) 
{ 
  cpBody *a ;
  cpBody *b ;
  cpVect n ;
  cpVect surface_vr ;
  cpFloat friction ;
  int i ;
  struct cpContact *con ;
  cpFloat nMass ;
  cpVect r1 ;
  cpVect r2 ;
  cpVect vb1 ;
  cpVect tmp ;
  cpVect tmp___0 ;
  cpVect tmp___1 ;
  cpVect vb2 ;
  cpVect tmp___2 ;
  cpVect tmp___3 ;
  cpVect tmp___4 ;
  cpVect vr ;
  cpVect tmp___5 ;
  cpVect tmp___6 ;
  cpFloat vbn ;
  cpVect tmp___7 ;
  cpFloat tmp___8 ;
  cpFloat vrn ;
  cpFloat tmp___9 ;
  cpFloat vrt ;
  cpVect tmp___10 ;
  cpFloat tmp___11 ;
  cpFloat jbn ;
  cpFloat jbnOld ;
  cpFloat jn___0 ;
  cpFloat jnOld ;
  cpFloat jtMax ;
  cpFloat jt ;
  cpFloat jtOld ;
  cpVect tmp___12 ;
  cpVect tmp___13 ;
  cpVect tmp___14 ;

  {
  a = arb->body_a;
  b = arb->body_b;
  n = arb->n;
  surface_vr = arb->surface_vr;
  friction = arb->u;
  i = 0;
  while (i < arb->count) {
    con = arb->contacts + i;
    nMass = con->nMass;
    r1 = con->r1;
    r2 = con->r2;
    tmp = cpvperp((cpVect const   )r1);
    tmp___0 = cpvmult((cpVect const   )tmp, (cpFloat const   )a->w_bias);
    tmp___1 = cpvadd((cpVect const   )a->v_bias, (cpVect const   )tmp___0);
    vb1 = tmp___1;
    tmp___2 = cpvperp((cpVect const   )r2);
    tmp___3 = cpvmult((cpVect const   )tmp___2, (cpFloat const   )b->w_bias);
    tmp___4 = cpvadd((cpVect const   )b->v_bias, (cpVect const   )tmp___3);
    vb2 = tmp___4;
    tmp___5 = relative_velocity(a, b, r1, r2);
    tmp___6 = cpvadd((cpVect const   )tmp___5, (cpVect const   )surface_vr);
    vr = tmp___6;
    tmp___7 = cpvsub((cpVect const   )vb2, (cpVect const   )vb1);
    tmp___8 = cpvdot((cpVect const   )tmp___7, (cpVect const   )n);
    vbn = tmp___8;
    tmp___9 = cpvdot((cpVect const   )vr, (cpVect const   )n);
    vrn = tmp___9;
    tmp___10 = cpvperp((cpVect const   )n);
    tmp___11 = cpvdot((cpVect const   )vr, (cpVect const   )tmp___10);
    vrt = tmp___11;
    jbn = (con->bias - vbn) * nMass;
    jbnOld = con->jBias;
    con->jBias = cpfmax(jbnOld + jbn, (cpFloat )0.0f);
    jn___0 = - (con->bounce + vrn) * nMass;
    jnOld = con->jnAcc;
    con->jnAcc = cpfmax(jnOld + jn___0, (cpFloat )0.0f);
    jtMax = friction * con->jnAcc;
    jt = - vrt * con->tMass;
    jtOld = con->jtAcc;
    con->jtAcc = cpfclamp(jtOld + jt, - jtMax, jtMax);
    tmp___12 = cpvmult((cpVect const   )n, (cpFloat const   )(con->jBias - jbnOld));
    apply_bias_impulses(a, b, r1, r2, tmp___12);
    tmp___13 = cpv((cpFloat const   )(con->jnAcc - jnOld), (cpFloat const   )(con->jtAcc - jtOld));
    tmp___14 = cpvrotate((cpVect const   )n, (cpVect const   )tmp___13);
    apply_impulses(a, b, r1, r2, tmp___14);
    i ++;
  }
  return;
}
}
#pragma merger("0","/tmp/cil-SzZsMfSO.i","-std=gnu99,-ffast-math,-fPIC")
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
cpArray *cpArrayNew(int size ) ;
void cpArrayFree(cpArray *arr ) ;
void cpArrayPush(cpArray *arr , void *object ) ;
void *cpArrayPop(cpArray *arr ) ;
void cpArrayDeleteObj(cpArray *arr , void *obj ) ;
cpBool cpArrayContains(cpArray *arr , void *ptr ) ;
void cpArrayFreeEach(cpArray *arr , void (*freeFunc)(void * ) ) ;
cpArray *cpArrayNew(int size ) 
{ 
  cpArray *arr ;
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = calloc((size_t )1, sizeof(cpArray ));
  arr = (cpArray *)tmp;
  arr->num = 0;
  if (size) {
    arr->max = size;
  } else {
    arr->max = 4;
  }
  tmp___0 = calloc((size_t )arr->max, sizeof(void *));
  arr->arr = (void **)tmp___0;
  return (arr);
}
}
void cpArrayFree(cpArray *arr ) 
{ 


  {
  if (arr) {
    free((void *)arr->arr);
    arr->arr = (void **)((void *)0);
    free((void *)arr);
  }
  return;
}
}
void cpArrayPush(cpArray *arr , void *object ) 
{ 
  void *tmp ;

  {
  if (arr->num == arr->max) {
    arr->max = (3 * (arr->max + 1)) / 2;
    tmp = realloc((void *)arr->arr, (unsigned long )arr->max * sizeof(void *));
    arr->arr = (void **)tmp;
  }
  *(arr->arr + arr->num) = object;
  (arr->num) ++;
  return;
}
}
void *cpArrayPop(cpArray *arr ) 
{ 
  void *value ;

  {
  (arr->num) --;
  value = *(arr->arr + arr->num);
  *(arr->arr + arr->num) = (void *)0;
  return (value);
}
}
void cpArrayDeleteObj(cpArray *arr , void *obj ) 
{ 
  int i ;

  {
  i = 0;
  while (i < arr->num) {
    if ((unsigned long )*(arr->arr + i) == (unsigned long )obj) {
      (arr->num) --;
      *(arr->arr + i) = *(arr->arr + arr->num);
      *(arr->arr + arr->num) = (void *)0;
      return;
    }
    i ++;
  }
  return;
}
}
void cpArrayFreeEach(cpArray *arr , void (*freeFunc)(void * ) ) 
{ 
  int i ;

  {
  i = 0;
  while (i < arr->num) {
    (*freeFunc)(*(arr->arr + i));
    i ++;
  }
  return;
}
}
cpBool cpArrayContains(cpArray *arr , void *ptr ) 
{ 
  int i ;

  {
  i = 0;
  while (i < arr->num) {
    if ((unsigned long )*(arr->arr + i) == (unsigned long )ptr) {
      return ((cpBool )1);
    }
    i ++;
  }
  return ((cpBool )0);
}
}
/* compiler builtin: 
   float __builtin_inff(void) ;  */
#pragma merger("0","/tmp/cil-mQw6u5mj.i","-std=gnu99,-ffast-math,-fPIC")
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
__inline static cpBB cpBBNew(cpFloat const   l , cpFloat const   b , cpFloat const   r ,
                             cpFloat const   t ) 
{ 
  cpBB bb ;

  {
  bb.l = (cpFloat )l;
  bb.b = (cpFloat )b;
  bb.r = (cpFloat )r;
  bb.t = (cpFloat )t;
  return (bb);
}
}
__inline static cpBool cpBBIntersects(cpBB const   a , cpBB const   b ) 
{ 
  int tmp ;

  {
  if (a.l <= b.r) {
    if (b.l <= a.r) {
      if (a.b <= b.t) {
        if (b.b <= a.t) {
          tmp = 1;
        } else {
          tmp = 0;
        }
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((cpBool )tmp);
}
}
__inline static cpBool cpBBContainsBB(cpBB const   bb , cpBB const   other ) 
{ 
  int tmp ;

  {
  if (bb.l <= other.l) {
    if (bb.r >= other.r) {
      if (bb.b <= other.b) {
        if (bb.t >= other.t) {
          tmp = 1;
        } else {
          tmp = 0;
        }
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((cpBool )tmp);
}
}
__inline static cpBB cpBBMerge(cpBB const   a , cpBB const   b ) 
{ 
  cpFloat tmp ;
  cpFloat tmp___0 ;
  cpFloat tmp___1 ;
  cpFloat tmp___2 ;
  cpBB tmp___3 ;

  {
  tmp = cpfmax((cpFloat )a.t, (cpFloat )b.t);
  tmp___0 = cpfmax((cpFloat )a.r, (cpFloat )b.r);
  tmp___1 = cpfmin((cpFloat )a.b, (cpFloat )b.b);
  tmp___2 = cpfmin((cpFloat )a.l, (cpFloat )b.l);
  tmp___3 = cpBBNew((cpFloat const   )tmp___2, (cpFloat const   )tmp___1, (cpFloat const   )tmp___0,
                    (cpFloat const   )tmp);
  return (tmp___3);
}
}
__inline static cpFloat cpBBArea(cpBB bb ) 
{ 


  {
  return ((bb.r - bb.l) * (bb.t - bb.b));
}
}
__inline static cpFloat cpBBMergedArea(cpBB a , cpBB b ) 
{ 
  cpFloat tmp ;
  cpFloat tmp___0 ;
  cpFloat tmp___1 ;
  cpFloat tmp___2 ;

  {
  tmp = cpfmax(a.r, b.r);
  tmp___0 = cpfmin(a.l, b.l);
  tmp___1 = cpfmax(a.t, b.t);
  tmp___2 = cpfmin(a.b, b.b);
  return ((tmp - tmp___0) * (tmp___1 - tmp___2));
}
}
__inline static cpFloat cpBBSegmentQuery(cpBB bb , cpVect a , cpVect b ) 
{ 
  cpVect delta ;
  cpVect tmp ;
  cpFloat tmin ;
  float tmp___0 ;
  cpFloat tmax ;
  float tmp___1 ;
  float tmp___2 ;
  cpFloat t1 ;
  cpFloat t2 ;
  cpFloat tmp___3 ;
  cpFloat tmp___4 ;
  float tmp___5 ;
  cpFloat t1___0 ;
  cpFloat t2___0 ;
  cpFloat tmp___6 ;
  cpFloat tmp___7 ;
  cpFloat tmp___8 ;
  float tmp___9 ;

  {
  tmp = cpvsub((cpVect const   )b, (cpVect const   )a);
  delta = tmp;
  tmp___0 = __builtin_inff();
  tmin = (cpFloat )(- tmp___0);
  tmp___1 = __builtin_inff();
  tmax = (cpFloat )tmp___1;
  if (delta.x == (cpFloat )0.0f) {
    if (a.x < bb.l) {
      tmp___2 = __builtin_inff();
      return ((cpFloat )tmp___2);
    } else
    if (bb.r < a.x) {
      tmp___2 = __builtin_inff();
      return ((cpFloat )tmp___2);
    }
  } else {
    t1 = (bb.l - a.x) / delta.x;
    t2 = (bb.r - a.x) / delta.x;
    tmp___3 = cpfmin(t1, t2);
    tmin = cpfmax(tmin, tmp___3);
    tmp___4 = cpfmax(t1, t2);
    tmax = cpfmin(tmax, tmp___4);
  }
  if (delta.y == (cpFloat )0.0f) {
    if (a.y < bb.b) {
      tmp___5 = __builtin_inff();
      return ((cpFloat )tmp___5);
    } else
    if (bb.t < a.y) {
      tmp___5 = __builtin_inff();
      return ((cpFloat )tmp___5);
    }
  } else {
    t1___0 = (bb.b - a.y) / delta.y;
    t2___0 = (bb.t - a.y) / delta.y;
    tmp___6 = cpfmin(t1___0, t2___0);
    tmin = cpfmax(tmin, tmp___6);
    tmp___7 = cpfmax(t1___0, t2___0);
    tmax = cpfmin(tmax, tmp___7);
  }
  if (tmin <= tmax) {
    if ((cpFloat )0.0f <= tmax) {
      if (tmin <= (cpFloat )1.0f) {
        tmp___8 = cpfmax(tmin, (cpFloat )0.0f);
        return (tmp___8);
      } else {
        tmp___9 = __builtin_inff();
        return ((cpFloat )tmp___9);
      }
    } else {
      tmp___9 = __builtin_inff();
      return ((cpFloat )tmp___9);
    }
  } else {
    tmp___9 = __builtin_inff();
    return ((cpFloat )tmp___9);
  }
}
}
cpBBTree *cpBBTreeAlloc(void) ;
cpSpatialIndex *cpBBTreeInit(cpBBTree *tree , cpBB (*bbfunc)(void *obj ) , cpSpatialIndex *staticIndex ) ;
cpSpatialIndex *cpBBTreeNew(cpBB (*bbfunc)(void *obj ) , cpSpatialIndex *staticIndex ) ;
void cpBBTreeOptimize(cpSpatialIndex *index ) ;
void cpBBTreeSetVelocityFunc(cpSpatialIndex *index , cpVect (*func)(void *obj ) ) ;
void cpSpatialIndexCollideStatic(cpSpatialIndex *dynamicIndex , cpSpatialIndex *staticIndex ,
                                 cpCollisionID (*func)(void *obj1 , void *obj2 , cpCollisionID id ,
                                                       void *data ) , void *data ) ;
cpHashSet *cpHashSetNew(int size , cpBool (*eqlFunc)(void const   *ptr , void const   *elt ) ) ;
void cpHashSetFree(cpHashSet *set ) ;
int cpHashSetCount(cpHashSet *set ) ;
void const   *cpHashSetInsert(cpHashSet *set , cpHashValue hash , void const   *ptr ,
                              void *(*trans)(void const   *ptr , void *data ) , void *data ) ;
void const   *cpHashSetRemove(cpHashSet *set , cpHashValue hash , void const   *ptr ) ;
void cpHashSetEach(cpHashSet *set , void (*func)(void *elt , void *data ) , void *data ) ;
cpSpatialIndex *cpSpatialIndexInit(cpSpatialIndex *index , cpSpatialIndexClass *klass___12 ,
                                   cpBB (*bbfunc)(void *obj ) , cpSpatialIndex *staticIndex ) ;
__inline static cpSpatialIndexClass *Klass(void) ;
__inline static cpBB GetBB(cpBBTree *tree , void *obj ) 
{ 
  cpBB bb ;
  cpBB tmp ;
  cpVect (*velocityFunc)(void *obj ) ;
  cpFloat coef ;
  cpFloat x ;
  cpFloat y ;
  cpVect v ;
  cpVect tmp___0 ;
  cpVect tmp___1 ;
  cpFloat tmp___2 ;
  cpFloat tmp___3 ;
  cpFloat tmp___4 ;
  cpFloat tmp___5 ;
  cpBB tmp___6 ;

  {
  tmp = (*(tree->spatialIndex.bbfunc))(obj);
  bb = tmp;
  velocityFunc = tree->velocityFunc;
  if (velocityFunc) {
    coef = (cpFloat )0.1f;
    x = (bb.r - bb.l) * coef;
    y = (bb.t - bb.b) * coef;
    tmp___0 = (*velocityFunc)(obj);
    tmp___1 = cpvmult((cpVect const   )tmp___0, (cpFloat const   )0.1f);
    v = tmp___1;
    tmp___2 = cpfmax(y, v.y);
    tmp___3 = cpfmax(x, v.x);
    tmp___4 = cpfmin(- y, v.y);
    tmp___5 = cpfmin(- x, v.x);
    tmp___6 = cpBBNew((cpFloat const   )(bb.l + tmp___5), (cpFloat const   )(bb.b + tmp___4),
                      (cpFloat const   )(bb.r + tmp___3), (cpFloat const   )(bb.t + tmp___2));
    return (tmp___6);
  } else {
    return (bb);
  }
}
}
__inline static cpBBTree *GetTree(cpSpatialIndex *index ) 
{ 
  cpBBTree *tmp___0 ;
  cpSpatialIndexClass *tmp___1 ;

  {
  if (index) {
    tmp___1 = Klass();
    if ((unsigned long )index->klass == (unsigned long )tmp___1) {
      tmp___0 = (cpBBTree *)index;
    } else {
      tmp___0 = (cpBBTree *)((void *)0);
    }
  } else {
    tmp___0 = (cpBBTree *)((void *)0);
  }
  return (tmp___0);
}
}
__inline static Node *GetRootIfTree(cpSpatialIndex *index ) 
{ 
  Node *tmp___0 ;
  cpSpatialIndexClass *tmp___1 ;

  {
  if (index) {
    tmp___1 = Klass();
    if ((unsigned long )index->klass == (unsigned long )tmp___1) {
      tmp___0 = ((cpBBTree *)index)->root;
    } else {
      tmp___0 = (Node *)((void *)0);
    }
  } else {
    tmp___0 = (Node *)((void *)0);
  }
  return (tmp___0);
}
}
__inline static cpBBTree *GetMasterTree(cpBBTree *tree ) 
{ 
  cpBBTree *dynamicTree ;
  cpBBTree *tmp ;
  cpBBTree *tmp___0 ;

  {
  tmp = GetTree(tree->spatialIndex.dynamicIndex);
  dynamicTree = tmp;
  if (dynamicTree) {
    tmp___0 = dynamicTree;
  } else {
    tmp___0 = tree;
  }
  return (tmp___0);
}
}
__inline static void IncrementStamp(cpBBTree *tree ) 
{ 
  cpBBTree *dynamicTree ;
  cpBBTree *tmp ;

  {
  tmp = GetTree(tree->spatialIndex.dynamicIndex);
  dynamicTree = tmp;
  if (dynamicTree) {
    (dynamicTree->stamp) ++;
  } else {
    (tree->stamp) ++;
  }
  return;
}
}
static void PairRecycle(cpBBTree *tree , Pair *pair ) 
{ 


  {
  tree = GetMasterTree(tree);
  pair->a.next = tree->pooledPairs;
  tree->pooledPairs = pair;
  return;
}
}
static Pair *PairFromPool(cpBBTree *tree ) 
{ 
  Pair *pair ;
  int count ;
  Pair *buffer ;
  void *tmp ;
  int i ;

  {
  tree = GetMasterTree(tree);
  pair = tree->pooledPairs;
  if (pair) {
    tree->pooledPairs = pair->a.next;
    return (pair);
  } else {
    count = (int )(32768UL / sizeof(Pair ));
    if (! count) {
      cpMessage("count", "../src/cpBBTree.c", 157, 1, 1, "Internal Error: Buffer size is too small.");
      abort();
    }
    tmp = calloc((size_t )1, (size_t )32768);
    buffer = (Pair *)tmp;
    cpArrayPush(tree->allocatedBuffers, (void *)buffer);
    i = 1;
    while (i < count) {
      PairRecycle(tree, buffer + i);
      i ++;
    }
    return (buffer);
  }
}
}
__inline static void ThreadUnlink(Thread thread ) 
{ 
  Pair *next ;
  Pair *prev ;

  {
  next = thread.next;
  prev = thread.prev;
  if (next) {
    if ((unsigned long )next->a.leaf == (unsigned long )thread.leaf) {
      next->a.prev = prev;
    } else {
      next->b.prev = prev;
    }
  }
  if (prev) {
    if ((unsigned long )prev->a.leaf == (unsigned long )thread.leaf) {
      prev->a.next = next;
    } else {
      prev->b.next = next;
    }
  } else {
    (thread.leaf)->node.leaf.pairs = next;
  }
  return;
}
}
static void PairsClear(Node *leaf , cpBBTree *tree ) 
{ 
  Pair *pair ;
  Pair *next ;
  Pair *next___0 ;

  {
  pair = leaf->node.leaf.pairs;
  leaf->node.leaf.pairs = (Pair *)((void *)0);
  while (pair) {
    if ((unsigned long )pair->a.leaf == (unsigned long )leaf) {
      next = pair->a.next;
      ThreadUnlink(pair->b);
      PairRecycle(tree, pair);
      pair = next;
    } else {
      next___0 = pair->b.next;
      ThreadUnlink(pair->a);
      PairRecycle(tree, pair);
      pair = next___0;
    }
  }
  return;
}
}
static void PairInsert(Node *a , Node *b , cpBBTree *tree ) 
{ 
  Pair *nextA ;
  Pair *nextB ;
  Pair *pair ;
  Pair *tmp ;
  Pair temp ;
  Pair *tmp___0 ;

  {
  nextA = a->node.leaf.pairs;
  nextB = b->node.leaf.pairs;
  tmp = PairFromPool(tree);
  pair = tmp;
  temp.a.prev = (Pair *)((void *)0);
  temp.a.leaf = a;
  temp.a.next = nextA;
  temp.b.prev = (Pair *)((void *)0);
  temp.b.leaf = b;
  temp.b.next = nextB;
  temp.id = (cpCollisionID )0;
  tmp___0 = pair;
  b->node.leaf.pairs = tmp___0;
  a->node.leaf.pairs = tmp___0;
  *pair = temp;
  if (nextA) {
    if ((unsigned long )nextA->a.leaf == (unsigned long )a) {
      nextA->a.prev = pair;
    } else {
      nextA->b.prev = pair;
    }
  }
  if (nextB) {
    if ((unsigned long )nextB->a.leaf == (unsigned long )b) {
      nextB->a.prev = pair;
    } else {
      nextB->b.prev = pair;
    }
  }
  return;
}
}
static void NodeRecycle(cpBBTree *tree , Node *node ) 
{ 


  {
  node->parent = tree->pooledNodes;
  tree->pooledNodes = node;
  return;
}
}
static Node *NodeFromPool(cpBBTree *tree ) 
{ 
  Node *node ;
  int count ;
  Node *buffer ;
  void *tmp ;
  int i ;

  {
  node = tree->pooledNodes;
  if (node) {
    tree->pooledNodes = node->parent;
    return (node);
  } else {
    count = (int )(32768UL / sizeof(Node ));
    if (! count) {
      cpMessage("count", "../src/cpBBTree.c", 246, 1, 1, "Internal Error: Buffer size is too small.");
      abort();
    }
    tmp = calloc((size_t )1, (size_t )32768);
    buffer = (Node *)tmp;
    cpArrayPush(tree->allocatedBuffers, (void *)buffer);
    i = 1;
    while (i < count) {
      NodeRecycle(tree, buffer + i);
      i ++;
    }
    return (buffer);
  }
}
}
__inline static void NodeSetA(Node *node , Node *value ) 
{ 


  {
  node->node.children.a = value;
  value->parent = node;
  return;
}
}
__inline static void NodeSetB(Node *node , Node *value ) 
{ 


  {
  node->node.children.b = value;
  value->parent = node;
  return;
}
}
static Node *NodeNew(cpBBTree *tree , Node *a , Node *b ) 
{ 
  Node *node ;
  Node *tmp ;

  {
  tmp = NodeFromPool(tree);
  node = tmp;
  node->obj = (void *)0;
  node->bb = cpBBMerge((cpBB const   )a->bb, (cpBB const   )b->bb);
  node->parent = (Node *)((void *)0);
  NodeSetA(node, a);
  NodeSetB(node, b);
  return (node);
}
}
__inline static cpBool NodeIsLeaf(Node *node ) 
{ 


  {
  return ((cpBool )((unsigned long )node->obj != (unsigned long )((void *)0)));
}
}
__inline static Node *NodeOther(Node *node , Node *child ) 
{ 
  Node *tmp ;

  {
  if ((unsigned long )node->node.children.a == (unsigned long )child) {
    tmp = node->node.children.b;
  } else {
    tmp = node->node.children.a;
  }
  return (tmp);
}
}
__inline static void NodeReplaceChild(Node *parent , Node *child , Node *value , cpBBTree *tree ) 
{ 
  Node *node ;

  {
  if ((unsigned long )parent->node.children.a == (unsigned long )child) {
    NodeRecycle(tree, parent->node.children.a);
    NodeSetA(parent, value);
  } else {
    NodeRecycle(tree, parent->node.children.b);
    NodeSetB(parent, value);
  }
  node = parent;
  while (node) {
    node->bb = cpBBMerge((cpBB const   )(node->node.children.a)->bb, (cpBB const   )(node->node.children.b)->bb);
    node = node->parent;
  }
  return;
}
}
__inline static cpFloat cpBBProximity(cpBB a , cpBB b ) 
{ 
  cpFloat tmp ;
  cpFloat tmp___0 ;

  {
  tmp = cpfabs(((a.l + a.r) - b.l) - b.r);
  tmp___0 = cpfabs(((a.b + a.t) - b.b) - b.t);
  return (tmp + tmp___0);
}
}
static Node *SubtreeInsert(Node *subtree , Node *leaf , cpBBTree *tree ) 
{ 
  Node *tmp ;
  cpFloat cost_a ;
  cpFloat tmp___0 ;
  cpFloat tmp___1 ;
  cpFloat cost_b ;
  cpFloat tmp___2 ;
  cpFloat tmp___3 ;
  Node *tmp___4 ;
  Node *tmp___5 ;
  cpBool tmp___6 ;

  {
  if ((unsigned long )subtree == (unsigned long )((void *)0)) {
    return (leaf);
  } else {
    tmp___6 = NodeIsLeaf(subtree);
    if (tmp___6) {
      tmp = NodeNew(tree, leaf, subtree);
      return (tmp);
    } else {
      tmp___0 = cpBBArea((subtree->node.children.b)->bb);
      tmp___1 = cpBBMergedArea((subtree->node.children.a)->bb, leaf->bb);
      cost_a = tmp___0 + tmp___1;
      tmp___2 = cpBBArea((subtree->node.children.a)->bb);
      tmp___3 = cpBBMergedArea((subtree->node.children.b)->bb, leaf->bb);
      cost_b = tmp___2 + tmp___3;
      if (cost_a == cost_b) {
        cost_a = cpBBProximity((subtree->node.children.a)->bb, leaf->bb);
        cost_b = cpBBProximity((subtree->node.children.b)->bb, leaf->bb);
      }
      if (cost_b < cost_a) {
        tmp___4 = SubtreeInsert(subtree->node.children.b, leaf, tree);
        NodeSetB(subtree, tmp___4);
      } else {
        tmp___5 = SubtreeInsert(subtree->node.children.a, leaf, tree);
        NodeSetA(subtree, tmp___5);
      }
      subtree->bb = cpBBMerge((cpBB const   )subtree->bb, (cpBB const   )leaf->bb);
      return (subtree);
    }
  }
}
}
static void SubtreeQuery(Node *subtree , void *obj , cpBB bb , cpCollisionID (*func)(void *obj1 ,
                                                                                     void *obj2 ,
                                                                                     cpCollisionID id ,
                                                                                     void *data ) ,
                         void *data ) 
{ 
  cpBool tmp ;
  cpBool tmp___0 ;

  {
  tmp___0 = cpBBIntersects((cpBB const   )subtree->bb, (cpBB const   )bb);
  if (tmp___0) {
    tmp = NodeIsLeaf(subtree);
    if (tmp) {
      (*func)(obj, subtree->obj, (cpCollisionID )0, data);
    } else {
      SubtreeQuery(subtree->node.children.a, obj, bb, func, data);
      SubtreeQuery(subtree->node.children.b, obj, bb, func, data);
    }
  }
  return;
}
}
static cpFloat SubtreeSegmentQuery(Node *subtree , void *obj , cpVect a , cpVect b ,
                                   cpFloat t_exit , cpFloat (*func)(void *obj1 , void *obj2 ,
                                                                    void *data ) ,
                                   void *data ) 
{ 
  cpFloat tmp ;
  cpFloat t_a ;
  cpFloat tmp___0 ;
  cpFloat t_b ;
  cpFloat tmp___1 ;
  cpFloat tmp___2 ;
  cpFloat tmp___3 ;
  cpFloat tmp___4 ;
  cpFloat tmp___5 ;
  cpBool tmp___6 ;

  {
  tmp___6 = NodeIsLeaf(subtree);
  if (tmp___6) {
    tmp = (*func)(obj, subtree->obj, data);
    return (tmp);
  } else {
    tmp___0 = cpBBSegmentQuery((subtree->node.children.a)->bb, a, b);
    t_a = tmp___0;
    tmp___1 = cpBBSegmentQuery((subtree->node.children.b)->bb, a, b);
    t_b = tmp___1;
    if (t_a < t_b) {
      if (t_a < t_exit) {
        tmp___2 = SubtreeSegmentQuery(subtree->node.children.a, obj, a, b, t_exit,
                                      func, data);
        t_exit = cpfmin(t_exit, tmp___2);
      }
      if (t_b < t_exit) {
        tmp___3 = SubtreeSegmentQuery(subtree->node.children.b, obj, a, b, t_exit,
                                      func, data);
        t_exit = cpfmin(t_exit, tmp___3);
      }
    } else {
      if (t_b < t_exit) {
        tmp___4 = SubtreeSegmentQuery(subtree->node.children.b, obj, a, b, t_exit,
                                      func, data);
        t_exit = cpfmin(t_exit, tmp___4);
      }
      if (t_a < t_exit) {
        tmp___5 = SubtreeSegmentQuery(subtree->node.children.a, obj, a, b, t_exit,
                                      func, data);
        t_exit = cpfmin(t_exit, tmp___5);
      }
    }
    return (t_exit);
  }
}
}
static void SubtreeRecycle(cpBBTree *tree , Node *node ) 
{ 
  cpBool tmp ;

  {
  tmp = NodeIsLeaf(node);
  if (! tmp) {
    SubtreeRecycle(tree, node->node.children.a);
    SubtreeRecycle(tree, node->node.children.b);
    NodeRecycle(tree, node);
  }
  return;
}
}
__inline static Node *SubtreeRemove(Node *subtree , Node *leaf , cpBBTree *tree ) 
{ 
  Node *parent ;
  Node *other ;
  Node *tmp ;
  Node *tmp___0 ;

  {
  if ((unsigned long )leaf == (unsigned long )subtree) {
    return ((Node *)((void *)0));
  } else {
    parent = leaf->parent;
    if ((unsigned long )parent == (unsigned long )subtree) {
      tmp = NodeOther(subtree, leaf);
      other = tmp;
      other->parent = subtree->parent;
      NodeRecycle(tree, subtree);
      return (other);
    } else {
      tmp___0 = NodeOther(parent, leaf);
      NodeReplaceChild(parent->parent, parent, tmp___0, tree);
      return (subtree);
    }
  }
}
}
static void MarkLeafQuery(Node *subtree , Node *leaf , cpBool left , MarkContext *context ) 
{ 
  cpBool tmp ;
  cpBool tmp___0 ;

  {
  tmp___0 = cpBBIntersects((cpBB const   )leaf->bb, (cpBB const   )subtree->bb);
  if (tmp___0) {
    tmp = NodeIsLeaf(subtree);
    if (tmp) {
      if (left) {
        PairInsert(leaf, subtree, context->tree);
      } else {
        if (subtree->node.leaf.stamp < leaf->node.leaf.stamp) {
          PairInsert(subtree, leaf, context->tree);
        }
        (*(context->func))(leaf->obj, subtree->obj, (cpCollisionID )0, context->data);
      }
    } else {
      MarkLeafQuery(subtree->node.children.a, leaf, left, context);
      MarkLeafQuery(subtree->node.children.b, leaf, left, context);
    }
  }
  return;
}
}
static void MarkLeaf(Node *leaf , MarkContext *context ) 
{ 
  cpBBTree *tree ;
  Node *staticRoot ;
  Node *node ;
  Pair *pair ;
  cpBBTree *tmp ;

  {
  tree = context->tree;
  tmp = GetMasterTree(tree);
  if (leaf->node.leaf.stamp == tmp->stamp) {
    staticRoot = context->staticRoot;
    if (staticRoot) {
      MarkLeafQuery(staticRoot, leaf, (cpBool )0, context);
    }
    node = leaf;
    while (node->parent) {
      if ((unsigned long )node == (unsigned long )(node->parent)->node.children.a) {
        MarkLeafQuery((node->parent)->node.children.b, leaf, (cpBool )1, context);
      } else {
        MarkLeafQuery((node->parent)->node.children.a, leaf, (cpBool )0, context);
      }
      node = node->parent;
    }
  } else {
    pair = leaf->node.leaf.pairs;
    while (pair) {
      if ((unsigned long )leaf == (unsigned long )pair->b.leaf) {
        pair->id = (*(context->func))((pair->a.leaf)->obj, leaf->obj, pair->id, context->data);
        pair = pair->b.next;
      } else {
        pair = pair->a.next;
      }
    }
  }
  return;
}
}
static void MarkSubtree(Node *subtree , MarkContext *context ) 
{ 
  cpBool tmp ;

  {
  tmp = NodeIsLeaf(subtree);
  if (tmp) {
    MarkLeaf(subtree, context);
  } else {
    MarkSubtree(subtree->node.children.a, context);
    MarkSubtree(subtree->node.children.b, context);
  }
  return;
}
}
static Node *LeafNew(cpBBTree *tree , void *obj , cpBB bb ) 
{ 
  Node *node ;
  Node *tmp ;

  {
  tmp = NodeFromPool(tree);
  node = tmp;
  node->obj = obj;
  node->bb = GetBB(tree, obj);
  node->parent = (Node *)((void *)0);
  node->node.leaf.stamp = (cpTimestamp )0;
  node->node.leaf.pairs = (Pair *)((void *)0);
  return (node);
}
}
static cpBool LeafUpdate(Node *leaf , cpBBTree *tree ) 
{ 
  Node *root ;
  cpBB bb ;
  cpBB tmp ;
  cpBBTree *tmp___0 ;
  cpBool tmp___1 ;

  {
  root = tree->root;
  tmp = (*(tree->spatialIndex.bbfunc))(leaf->obj);
  bb = tmp;
  tmp___1 = cpBBContainsBB((cpBB const   )leaf->bb, (cpBB const   )bb);
  if (tmp___1) {
    return ((cpBool )0);
  } else {
    leaf->bb = GetBB(tree, leaf->obj);
    root = SubtreeRemove(root, leaf, tree);
    tree->root = SubtreeInsert(root, leaf, tree);
    PairsClear(leaf, tree);
    tmp___0 = GetMasterTree(tree);
    leaf->node.leaf.stamp = tmp___0->stamp;
    return ((cpBool )1);
  }
}
}
static cpCollisionID VoidQueryFunc(void *obj1 , void *obj2 , cpCollisionID id , void *data ) 
{ 


  {
  return (id);
}
}
static void LeafAddPairs(Node *leaf , cpBBTree *tree ) 
{ 
  cpSpatialIndex *dynamicIndex ;
  Node *dynamicRoot ;
  Node *tmp ;
  cpBBTree *dynamicTree ;
  cpBBTree *tmp___0 ;
  MarkContext context ;
  Node *staticRoot ;
  Node *tmp___1 ;
  MarkContext context___0 ;

  {
  dynamicIndex = tree->spatialIndex.dynamicIndex;
  if (dynamicIndex) {
    tmp = GetRootIfTree(dynamicIndex);
    dynamicRoot = tmp;
    if (dynamicRoot) {
      tmp___0 = GetTree(dynamicIndex);
      dynamicTree = tmp___0;
      context.tree = dynamicTree;
      context.staticRoot = (Node *)((void *)0);
      context.func = (cpCollisionID (*)(void *obj1 , void *obj2 , cpCollisionID id ,
                                        void *data ))((void *)0);
      context.data = (void *)0;
      MarkLeafQuery(dynamicRoot, leaf, (cpBool )1, & context);
    }
  } else {
    tmp___1 = GetRootIfTree(tree->spatialIndex.staticIndex);
    staticRoot = tmp___1;
    context___0.tree = tree;
    context___0.staticRoot = staticRoot;
    context___0.func = & VoidQueryFunc;
    context___0.data = (void *)0;
    MarkLeaf(leaf, & context___0);
  }
  return;
}
}
cpBBTree *cpBBTreeAlloc(void) 
{ 
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(cpBBTree ));
  return ((cpBBTree *)tmp);
}
}
static int leafSetEql(void *obj , Node *node ) 
{ 


  {
  return ((unsigned long )obj == (unsigned long )node->obj);
}
}
static void *leafSetTrans(void *obj , cpBBTree *tree ) 
{ 
  cpBB tmp ;
  Node *tmp___0 ;

  {
  tmp = (*(tree->spatialIndex.bbfunc))(obj);
  tmp___0 = LeafNew(tree, obj, tmp);
  return ((void *)tmp___0);
}
}
cpSpatialIndex *cpBBTreeInit(cpBBTree *tree , cpBB (*bbfunc)(void *obj ) , cpSpatialIndex *staticIndex ) 
{ 
  cpSpatialIndexClass *tmp ;

  {
  tmp = Klass();
  cpSpatialIndexInit((cpSpatialIndex *)tree, tmp, bbfunc, staticIndex);
  tree->velocityFunc = (cpVect (*)(void *obj ))((void *)0);
  tree->leaves = cpHashSetNew(0, (cpBool (*)(void const   *ptr , void const   *elt ))(& leafSetEql));
  tree->root = (Node *)((void *)0);
  tree->pooledNodes = (Node *)((void *)0);
  tree->allocatedBuffers = cpArrayNew(0);
  tree->stamp = (cpTimestamp )0;
  return ((cpSpatialIndex *)tree);
}
}
void cpBBTreeSetVelocityFunc(cpSpatialIndex *index , cpVect (*func)(void *obj ) ) 
{ 
  cpSpatialIndexClass *tmp ;

  {
  tmp = Klass();
  if ((unsigned long )index->klass != (unsigned long )tmp) {
    return;
  }
  ((cpBBTree *)index)->velocityFunc = func;
  return;
}
}
cpSpatialIndex *cpBBTreeNew(cpBB (*bbfunc)(void *obj ) , cpSpatialIndex *staticIndex ) 
{ 
  cpBBTree *tmp ;
  cpSpatialIndex *tmp___0 ;

  {
  tmp = cpBBTreeAlloc();
  tmp___0 = cpBBTreeInit(tmp, bbfunc, staticIndex);
  return (tmp___0);
}
}
static void cpBBTreeDestroy(cpBBTree *tree ) 
{ 


  {
  cpHashSetFree(tree->leaves);
  if (tree->allocatedBuffers) {
    cpArrayFreeEach(tree->allocatedBuffers, & free);
  }
  cpArrayFree(tree->allocatedBuffers);
  return;
}
}
static void cpBBTreeInsert(cpBBTree *tree , void *obj , cpHashValue hashid ) 
{ 
  Node *leaf ;
  void const   *tmp ;
  Node *root ;
  cpBBTree *tmp___0 ;

  {
  tmp = cpHashSetInsert(tree->leaves, hashid, (void const   *)obj, (void *(*)(void const   *ptr ,
                                                                              void *data ))(& leafSetTrans),
                        (void *)tree);
  leaf = (Node *)tmp;
  root = tree->root;
  tree->root = SubtreeInsert(root, leaf, tree);
  tmp___0 = GetMasterTree(tree);
  leaf->node.leaf.stamp = tmp___0->stamp;
  LeafAddPairs(leaf, tree);
  IncrementStamp(tree);
  return;
}
}
static void cpBBTreeRemove(cpBBTree *tree , void *obj , cpHashValue hashid ) 
{ 
  Node *leaf ;
  void const   *tmp ;

  {
  tmp = cpHashSetRemove(tree->leaves, hashid, (void const   *)obj);
  leaf = (Node *)tmp;
  tree->root = SubtreeRemove(tree->root, leaf, tree);
  PairsClear(leaf, tree);
  NodeRecycle(tree, leaf);
  return;
}
}
static cpBool cpBBTreeContains(cpBBTree *tree , void *obj , cpHashValue hashid ) 
{ 
  void const   *tmp ;

  {
  tmp = cpHashSetFind(tree->leaves, hashid, (void const   *)obj);
  return ((cpBool )((unsigned long )tmp != (unsigned long )((void *)0)));
}
}
static void LeafUpdateWrap(Node *leaf , cpBBTree *tree ) 
{ 


  {
  LeafUpdate(leaf, tree);
  return;
}
}
static void cpBBTreeReindexQuery(cpBBTree *tree , cpCollisionID (*func)(void *obj1 ,
                                                                        void *obj2 ,
                                                                        cpCollisionID id ,
                                                                        void *data ) ,
                                 void *data ) 
{ 
  cpSpatialIndex *staticIndex ;
  Node *staticRoot ;
  Node *tmp___0 ;
  cpSpatialIndexClass *tmp___1 ;
  MarkContext context ;

  {
  if (! tree->root) {
    return;
  }
  cpHashSetEach(tree->leaves, (void (*)(void *elt , void *data ))(& LeafUpdateWrap),
                (void *)tree);
  staticIndex = tree->spatialIndex.staticIndex;
  if (staticIndex) {
    tmp___1 = Klass();
    if ((unsigned long )staticIndex->klass == (unsigned long )tmp___1) {
      tmp___0 = ((cpBBTree *)staticIndex)->root;
    } else {
      tmp___0 = (Node *)((void *)0);
    }
  } else {
    tmp___0 = (Node *)((void *)0);
  }
  staticRoot = tmp___0;
  context.tree = tree;
  context.staticRoot = staticRoot;
  context.func = func;
  context.data = data;
  MarkSubtree(tree->root, & context);
  if (staticIndex) {
    if (! staticRoot) {
      cpSpatialIndexCollideStatic((cpSpatialIndex *)tree, staticIndex, func, data);
    }
  }
  IncrementStamp(tree);
  return;
}
}
static void cpBBTreeReindex(cpBBTree *tree ) 
{ 


  {
  cpBBTreeReindexQuery(tree, & VoidQueryFunc, (void *)0);
  return;
}
}
static void cpBBTreeReindexObject(cpBBTree *tree , void *obj , cpHashValue hashid ) 
{ 
  Node *leaf ;
  void const   *tmp ;
  cpBool tmp___0 ;

  {
  tmp = cpHashSetFind(tree->leaves, hashid, (void const   *)obj);
  leaf = (Node *)tmp;
  if (leaf) {
    tmp___0 = LeafUpdate(leaf, tree);
    if (tmp___0) {
      LeafAddPairs(leaf, tree);
    }
    IncrementStamp(tree);
  }
  return;
}
}
static void cpBBTreeSegmentQuery(cpBBTree *tree , void *obj , cpVect a , cpVect b ,
                                 cpFloat t_exit , cpFloat (*func)(void *obj1 , void *obj2 ,
                                                                  void *data ) , void *data ) 
{ 
  Node *root ;

  {
  root = tree->root;
  if (root) {
    SubtreeSegmentQuery(root, obj, a, b, t_exit, func, data);
  }
  return;
}
}
static void cpBBTreeQuery(cpBBTree *tree , void *obj , cpBB bb , cpCollisionID (*func)(void *obj1 ,
                                                                                       void *obj2 ,
                                                                                       cpCollisionID id ,
                                                                                       void *data ) ,
                          void *data ) 
{ 


  {
  if (tree->root) {
    SubtreeQuery(tree->root, obj, bb, func, data);
  }
  return;
}
}
static int cpBBTreeCount(cpBBTree *tree ) 
{ 
  int tmp ;

  {
  tmp = cpHashSetCount(tree->leaves);
  return (tmp);
}
}
static void each_helper(Node *node , eachContext *context ) 
{ 


  {
  (*(context->func))(node->obj, context->data);
  return;
}
}
static void cpBBTreeEach(cpBBTree *tree , void (*func)(void *obj , void *data ) ,
                         void *data ) 
{ 
  eachContext context ;

  {
  context.func = func;
  context.data = data;
  cpHashSetEach(tree->leaves, (void (*)(void *elt , void *data ))(& each_helper),
                (void *)(& context));
  return;
}
}
static cpSpatialIndexClass klass  = 
     {(void (*)(cpSpatialIndex *index ))(& cpBBTreeDestroy), (int (*)(cpSpatialIndex *index ))(& cpBBTreeCount),
    (void (*)(cpSpatialIndex *index , void (*func)(void *obj , void *data ) , void *data ))(& cpBBTreeEach),
    (cpBool (*)(cpSpatialIndex *index , void *obj , cpHashValue hashid ))(& cpBBTreeContains),
    (void (*)(cpSpatialIndex *index , void *obj , cpHashValue hashid ))(& cpBBTreeInsert),
    (void (*)(cpSpatialIndex *index , void *obj , cpHashValue hashid ))(& cpBBTreeRemove),
    (void (*)(cpSpatialIndex *index ))(& cpBBTreeReindex), (void (*)(cpSpatialIndex *index ,
                                                                     void *obj , cpHashValue hashid ))(& cpBBTreeReindexObject),
    (void (*)(cpSpatialIndex *index , cpCollisionID (*func)(void *obj1 , void *obj2 ,
                                                            cpCollisionID id , void *data ) ,
              void *data ))(& cpBBTreeReindexQuery), (void (*)(cpSpatialIndex *index ,
                                                               void *obj , cpBB bb ,
                                                               cpCollisionID (*func)(void *obj1 ,
                                                                                     void *obj2 ,
                                                                                     cpCollisionID id ,
                                                                                     void *data ) ,
                                                               void *data ))(& cpBBTreeQuery),
    (void (*)(cpSpatialIndex *index , void *obj , cpVect a , cpVect b , cpFloat t_exit ,
              cpFloat (*func)(void *obj1 , void *obj2 , void *data ) , void *data ))(& cpBBTreeSegmentQuery)};
__inline static cpSpatialIndexClass *Klass(void) 
{ 


  {
  return (& klass);
}
}
static int cpfcompare(cpFloat const   *a , cpFloat const   *b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (*a < *b) {
    tmp___0 = -1;
  } else {
    if (*b < *a) {
      tmp = 1;
    } else {
      tmp = 0;
    }
    tmp___0 = tmp;
  }
  return (tmp___0);
}
}
static void fillNodeArray(Node *node , Node ***cursor ) 
{ 


  {
  *(*cursor) = node;
  (*cursor) ++;
  return;
}
}
static Node *partitionNodes(cpBBTree *tree , Node **nodes , int count ) 
{ 
  Node *tmp ;
  cpBB bb ;
  int i ;
  cpBool splitWidth ;
  cpFloat *bounds ;
  void *tmp___0 ;
  int i___0 ;
  int i___1 ;
  cpFloat split ;
  cpBB a ;
  cpBB b ;
  int right ;
  int left ;
  Node *node ;
  cpFloat tmp___1 ;
  cpFloat tmp___2 ;
  Node *node___0 ;
  int i___2 ;
  Node *tmp___3 ;
  Node *tmp___4 ;
  Node *tmp___5 ;

  {
  if (count == 1) {
    return (*(nodes + 0));
  } else
  if (count == 2) {
    tmp = NodeNew(tree, *(nodes + 0), *(nodes + 1));
    return (tmp);
  }
  bb = (*(nodes + 0))->bb;
  i = 1;
  while (i < count) {
    bb = cpBBMerge((cpBB const   )bb, (cpBB const   )(*(nodes + i))->bb);
    i ++;
  }
  splitWidth = (cpBool )(bb.r - bb.l > bb.t - bb.b);
  tmp___0 = calloc((size_t )(count * 2), sizeof(cpFloat ));
  bounds = (cpFloat *)tmp___0;
  if (splitWidth) {
    i___0 = 0;
    while (i___0 < count) {
      *(bounds + 2 * i___0) = (*(nodes + i___0))->bb.l;
      *(bounds + (2 * i___0 + 1)) = (*(nodes + i___0))->bb.r;
      i___0 ++;
    }
  } else {
    i___1 = 0;
    while (i___1 < count) {
      *(bounds + 2 * i___1) = (*(nodes + i___1))->bb.b;
      *(bounds + (2 * i___1 + 1)) = (*(nodes + i___1))->bb.t;
      i___1 ++;
    }
  }
  qsort((void *)bounds, (size_t )(count * 2), sizeof(cpFloat ), (int (*)(void const   * ,
                                                                         void const   * ))(& cpfcompare));
  split = (*(bounds + (count - 1)) + *(bounds + count)) * (cpFloat )0.5f;
  free((void *)bounds);
  a = bb;
  b = bb;
  if (splitWidth) {
    b.l = split;
    a.r = b.l;
  } else {
    b.b = split;
    a.t = b.b;
  }
  right = count;
  left = 0;
  while (left < right) {
    node = *(nodes + left);
    tmp___1 = cpBBMergedArea(node->bb, b);
    tmp___2 = cpBBMergedArea(node->bb, a);
    if (tmp___1 < tmp___2) {
      right --;
      *(nodes + left) = *(nodes + right);
      *(nodes + right) = node;
    } else {
      left ++;
    }
  }
  if (right == count) {
    node___0 = (Node *)((void *)0);
    i___2 = 0;
    while (i___2 < count) {
      node___0 = SubtreeInsert(node___0, *(nodes + i___2), tree);
      i___2 ++;
    }
    return (node___0);
  }
  tmp___3 = partitionNodes(tree, nodes + right, count - right);
  tmp___4 = partitionNodes(tree, nodes, right);
  tmp___5 = NodeNew(tree, tmp___4, tmp___3);
  return (tmp___5);
}
}
void cpBBTreeOptimize(cpSpatialIndex *index ) 
{ 
  cpBBTree *tree ;
  Node *root ;
  int count ;
  int tmp ;
  Node **nodes ;
  void *tmp___0 ;
  Node **cursor ;

  {
  if ((unsigned long )index->klass != (unsigned long )(& klass)) {
    return;
  }
  tree = (cpBBTree *)index;
  root = tree->root;
  if (! root) {
    return;
  }
  tmp = cpBBTreeCount(tree);
  count = tmp;
  tmp___0 = calloc((size_t )count, sizeof(Node *));
  nodes = (Node **)tmp___0;
  cursor = nodes;
  cpHashSetEach(tree->leaves, (void (*)(void *elt , void *data ))(& fillNodeArray),
                (void *)(& cursor));
  SubtreeRecycle(tree, root);
  tree->root = partitionNodes(tree, nodes, count);
  free((void *)nodes);
  return;
}
}
#pragma merger("0","/tmp/cil-F_6zDrIy.i","-std=gnu99,-ffast-math,-fPIC")
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
static struct cpVect  const  cpvzero___1  =    {(cpFloat )0.0f, (cpFloat )0.0f};
__inline static cpVect cpvforangle(cpFloat const   a ) 
{ 
  double tmp ;
  double tmp___0 ;
  cpVect tmp___1 ;

  {
  tmp = sin((double )a);
  tmp___0 = cos((double )a);
  tmp___1 = cpv((cpFloat const   )tmp___0, (cpFloat const   )tmp);
  return (tmp___1);
}
}
__inline static cpFloat cpvdistsq(cpVect const   v1 , cpVect const   v2 ) 
{ 
  cpVect tmp ;
  cpFloat tmp___0 ;

  {
  tmp = cpvsub(v1, v2);
  tmp___0 = cpvlengthsq((cpVect const   )tmp);
  return (tmp___0);
}
}
__inline static cpTransform cpTransformNewTranspose(cpFloat a , cpFloat c , cpFloat tx ,
                                                    cpFloat b , cpFloat d , cpFloat ty ) 
{ 
  cpTransform t ;

  {
  t.a = a;
  t.b = b;
  t.c = c;
  t.d = d;
  t.tx = tx;
  t.ty = ty;
  return (t);
}
}
__inline static cpVect cpTransformPoint(cpTransform t , cpVect p ) 
{ 
  cpVect tmp ;

  {
  tmp = cpv((cpFloat const   )((t.a * p.x + t.c * p.y) + t.tx), (cpFloat const   )((t.b * p.x + t.d * p.y) + t.ty));
  return (tmp);
}
}
__inline static cpVect cpTransformVect(cpTransform t , cpVect v ) 
{ 
  cpVect tmp ;

  {
  tmp = cpv((cpFloat const   )(t.a * v.x + t.c * v.y), (cpFloat const   )(t.b * v.x + t.d * v.y));
  return (tmp);
}
}
__inline static cpTransform cpTransformRigidInverse(cpTransform t ) 
{ 
  cpTransform tmp ;

  {
  tmp = cpTransformNewTranspose(t.d, - t.c, t.c * t.ty - t.tx * t.d, - t.b, t.a, t.tx * t.b - t.a * t.ty);
  return (tmp);
}
}
__inline static void cpSpatialIndexInsert(cpSpatialIndex *index , void *obj , cpHashValue hashid ) 
{ 


  {
  (*((index->klass)->insert))(index, obj, hashid);
  return;
}
}
__inline static void cpSpatialIndexRemove(cpSpatialIndex *index , void *obj , cpHashValue hashid ) 
{ 


  {
  (*((index->klass)->remove))(index, obj, hashid);
  return;
}
}
cpBody *cpBodyAlloc(void) ;
cpBody *cpBodyInit(cpBody *body , cpFloat mass , cpFloat moment ) ;
cpBody *cpBodyNew(cpFloat mass , cpFloat moment ) ;
cpBody *cpBodyNewKinematic(void) ;
cpBody *cpBodyNewStatic(void) ;
void cpBodyDestroy(cpBody *body ) ;
void cpBodyFree(cpBody *body ) ;
void cpBodyActivate(cpBody *body ) ;
cpBool cpBodyIsSleeping(cpBody const   *body ) ;
cpBodyType cpBodyGetType(cpBody *body ) ;
void cpBodySetType(cpBody *body , cpBodyType type ) ;
cpSpace *cpBodyGetSpace(cpBody const   *body ) ;
cpFloat cpBodyGetMass(cpBody const   *body ) ;
void cpBodySetMass(cpBody *body , cpFloat mass ) ;
cpFloat cpBodyGetMoment(cpBody const   *body ) ;
void cpBodySetMoment(cpBody *body , cpFloat moment ) ;
cpVect cpBodyGetPosition(cpBody const   *body ) ;
void cpBodySetPosition(cpBody *body , cpVect position ) ;
cpVect cpBodyGetCenterOfGravity(cpBody const   *body ) ;
void cpBodySetCenterOfGravity(cpBody *body , cpVect cog ) ;
cpVect cpBodyGetVelocity(cpBody const   *body ) ;
void cpBodySetVelocity(cpBody *body , cpVect velocity ) ;
cpVect cpBodyGetForce(cpBody const   *body ) ;
void cpBodySetForce(cpBody *body , cpVect force ) ;
cpFloat cpBodyGetAngle(cpBody const   *body ) ;
void cpBodySetAngle(cpBody *body , cpFloat angle ) ;
cpFloat cpBodyGetAngularVelocity(cpBody const   *body ) ;
void cpBodySetAngularVelocity(cpBody *body , cpFloat angularVelocity ) ;
cpFloat cpBodyGetTorque(cpBody const   *body ) ;
void cpBodySetTorque(cpBody *body , cpFloat torque ) ;
cpVect cpBodyGetRotation(cpBody const   *body ) ;
cpDataPointer cpBodyGetUserData(cpBody const   *body ) ;
void cpBodySetUserData(cpBody *body , cpDataPointer userData ) ;
void cpBodySetVelocityUpdateFunc(cpBody *body , void (*velocityFunc)(cpBody *body ,
                                                                     cpVect gravity ,
                                                                     cpFloat damping ,
                                                                     cpFloat dt ) ) ;
void cpBodySetPositionUpdateFunc(cpBody *body , void (*positionFunc)(cpBody *body ,
                                                                     cpFloat dt ) ) ;
void cpBodyUpdateVelocity(cpBody *body , cpVect gravity , cpFloat damping , cpFloat dt ) ;
void cpBodyUpdatePosition(cpBody *body , cpFloat dt ) ;
cpVect cpBodyLocalToWorld(cpBody const   *body , cpVect const   point ) ;
cpVect cpBodyWorldToLocal(cpBody const   *body , cpVect const   point ) ;
void cpBodyApplyForceAtWorldPoint(cpBody *body , cpVect force , cpVect point ) ;
void cpBodyApplyForceAtLocalPoint(cpBody *body , cpVect force , cpVect point ) ;
void cpBodyApplyImpulseAtWorldPoint(cpBody *body , cpVect impulse , cpVect point ) ;
void cpBodyApplyImpulseAtLocalPoint(cpBody *body , cpVect impulse , cpVect point ) ;
cpVect cpBodyGetVelocityAtWorldPoint(cpBody const   *body , cpVect point ) ;
cpVect cpBodyGetVelocityAtLocalPoint(cpBody const   *body , cpVect point ) ;
cpFloat cpBodyKineticEnergy(cpBody const   *body ) ;
void cpBodyEachShape(cpBody *body , void (*func)(cpBody *body , cpShape *shape , void *data ) ,
                     void *data ) ;
void cpBodyEachConstraint(cpBody *body , void (*func)(cpBody *body , cpConstraint *constraint ,
                                                      void *data ) , void *data ) ;
void cpBodyEachArbiter(cpBody *body , void (*func)(cpBody *body , cpArbiter *arbiter ,
                                                   void *data ) , void *data ) ;
void cpBodyAddShape(cpBody *body , cpShape *shape ) ;
void cpBodyRemoveShape(cpBody *body , cpShape *shape ) ;
void cpBodyAccumulateMassFromShapes(cpBody *body ) ;
void cpBodyRemoveConstraint(cpBody *body , cpConstraint *constraint ) ;
__inline static cpArray *cpSpaceArrayForBodyType(cpSpace *space , cpBodyType type ) 
{ 
  cpArray *tmp ;

  {
  if ((unsigned int )type == 2U) {
    tmp = space->staticBodies;
  } else {
    tmp = space->dynamicBodies;
  }
  return (tmp);
}
}
__inline static cpConstraint *cpConstraintNext(cpConstraint *node , cpBody *body ) 
{ 
  cpConstraint *tmp ;

  {
  if ((unsigned long )node->a == (unsigned long )body) {
    tmp = node->next_a;
  } else {
    tmp = node->next_b;
  }
  return (tmp);
}
}
__inline static cpArbiter *cpArbiterNext(cpArbiter *node , cpBody *body ) 
{ 
  struct cpArbiter *tmp ;

  {
  if ((unsigned long )node->body_a == (unsigned long )body) {
    tmp = node->thread_a.next;
  } else {
    tmp = node->thread_b.next;
  }
  return (tmp);
}
}
cpBody *cpBodyAlloc(void) 
{ 
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(cpBody ));
  return ((cpBody *)tmp);
}
}
cpBody *cpBodyInit(cpBody *body , cpFloat mass , cpFloat moment ) 
{ 


  {
  body->space = (cpSpace *)((void *)0);
  body->shapeList = (cpShape *)((void *)0);
  body->arbiterList = (cpArbiter *)((void *)0);
  body->constraintList = (cpConstraint *)((void *)0);
  body->velocity_func = & cpBodyUpdateVelocity;
  body->position_func = & cpBodyUpdatePosition;
  body->sleeping.root = (cpBody *)((void *)0);
  body->sleeping.next = (cpBody *)((void *)0);
  body->sleeping.idleTime = (cpFloat )0.0f;
  body->p = (cpVect )cpvzero___1;
  body->v = (cpVect )cpvzero___1;
  body->f = (cpVect )cpvzero___1;
  body->w = (cpFloat )0.0f;
  body->t = (cpFloat )0.0f;
  body->v_bias = (cpVect )cpvzero___1;
  body->w_bias = (cpFloat )0.0f;
  body->userData = (void *)0;
  cpBodySetMass(body, mass);
  cpBodySetMoment(body, moment);
  cpBodySetAngle(body, (cpFloat )0.0f);
  return (body);
}
}
cpBody *cpBodyNew(cpFloat mass , cpFloat moment ) 
{ 
  cpBody *tmp ;
  cpBody *tmp___0 ;

  {
  tmp = cpBodyAlloc();
  tmp___0 = cpBodyInit(tmp, mass, moment);
  return (tmp___0);
}
}
cpBody *cpBodyNewKinematic(void) 
{ 
  cpBody *body ;
  cpBody *tmp ;

  {
  tmp = cpBodyNew((cpFloat )0.0f, (cpFloat )0.0f);
  body = tmp;
  cpBodySetType(body, (cpBodyType )1);
  return (body);
}
}
cpBody *cpBodyNewStatic(void) 
{ 
  cpBody *body ;
  cpBody *tmp ;

  {
  tmp = cpBodyNew((cpFloat )0.0f, (cpFloat )0.0f);
  body = tmp;
  cpBodySetType(body, (cpBodyType )2);
  return (body);
}
}
void cpBodyDestroy(cpBody *body ) 
{ 


  {
  return;
}
}
void cpBodyFree(cpBody *body ) 
{ 


  {
  if (body) {
    cpBodyDestroy(body);
    free((void *)body);
  }
  return;
}
}
cpBool cpBodyIsSleeping(cpBody const   *body ) 
{ 


  {
  return ((cpBool )((unsigned long )body->sleeping.root != (unsigned long )((cpBody *)0)));
}
}
cpBodyType cpBodyGetType(cpBody *body ) 
{ 
  float tmp ;
  float tmp___0 ;

  {
  tmp___0 = __builtin_inff();
  if (body->sleeping.idleTime == (cpFloat )tmp___0) {
    return ((cpBodyType )2);
  } else {
    tmp = __builtin_inff();
    if (body->m == (cpFloat )tmp) {
      return ((cpBodyType )1);
    } else {
      return ((cpBodyType )0);
    }
  }
}
}
void cpBodySetType(cpBody *body , cpBodyType type ) 
{ 
  cpBodyType oldType ;
  cpBodyType tmp ;
  float tmp___0 ;
  cpFloat tmp___1 ;
  cpFloat tmp___2 ;
  float tmp___3 ;
  cpFloat tmp___4 ;
  float tmp___5 ;
  cpFloat tmp___6 ;
  cpSpace *space ;
  cpSpace *tmp___7 ;
  cpArray *fromArray ;
  cpArray *tmp___8 ;
  cpArray *toArray ;
  cpArray *tmp___9 ;
  cpSpatialIndex *fromIndex ;
  cpSpatialIndex *tmp___10 ;
  cpSpatialIndex *toIndex ;
  cpSpatialIndex *tmp___11 ;
  cpShape *shape ;

  {
  tmp = cpBodyGetType(body);
  oldType = tmp;
  if ((unsigned int )oldType == (unsigned int )type) {
    return;
  }
  if ((unsigned int )type == 2U) {
    tmp___0 = __builtin_inff();
    body->sleeping.idleTime = (cpFloat )tmp___0;
  } else {
    body->sleeping.idleTime = (cpFloat )0.0f;
  }
  if ((unsigned int )type == 0U) {
    tmp___1 = (cpFloat )0.0f;
    body->i = tmp___1;
    body->m = tmp___1;
    tmp___3 = __builtin_inff();
    tmp___2 = (cpFloat )tmp___3;
    body->i_inv = tmp___2;
    body->m_inv = tmp___2;
    cpBodyAccumulateMassFromShapes(body);
  } else {
    tmp___5 = __builtin_inff();
    tmp___4 = (cpFloat )tmp___5;
    body->i = tmp___4;
    body->m = tmp___4;
    tmp___6 = (cpFloat )0.0f;
    body->i_inv = tmp___6;
    body->m_inv = tmp___6;
    body->v = (cpVect )cpvzero___1;
    body->w = (cpFloat )0.0f;
  }
  tmp___7 = cpBodyGetSpace((cpBody const   *)body);
  space = tmp___7;
  if ((unsigned long )space != (unsigned long )((void *)0)) {
    if (! (! space->locked)) {
      cpMessage("!space->locked", "../src/cpBody.c", 174, 1, 1, "This operation cannot be done safely during a call to cpSpaceStep() or during a query. Put these calls into a post-step callback.");
      abort();
    }
    if (! ((unsigned int )oldType == 2U)) {
      cpBodyActivate(body);
    }
    tmp___8 = cpSpaceArrayForBodyType(space, oldType);
    fromArray = tmp___8;
    tmp___9 = cpSpaceArrayForBodyType(space, type);
    toArray = tmp___9;
    if ((unsigned long )fromArray != (unsigned long )toArray) {
      cpArrayDeleteObj(fromArray, (void *)body);
      cpArrayPush(toArray, (void *)body);
    }
    if ((unsigned int )oldType == 2U) {
      tmp___10 = space->staticShapes;
    } else {
      tmp___10 = space->dynamicShapes;
    }
    fromIndex = tmp___10;
    if ((unsigned int )type == 2U) {
      tmp___11 = space->staticShapes;
    } else {
      tmp___11 = space->dynamicShapes;
    }
    toIndex = tmp___11;
    if ((unsigned long )fromIndex != (unsigned long )toIndex) {
      shape = body->shapeList;
      while (shape) {
        cpSpatialIndexRemove(fromIndex, (void *)shape, shape->hashid);
        cpSpatialIndexInsert(toIndex, (void *)shape, shape->hashid);
        shape = shape->next;
      }
    }
  }
  return;
}
}
void cpBodyAccumulateMassFromShapes(cpBody *body ) 
{ 
  cpBodyType tmp ;
  cpFloat tmp___0 ;
  cpVect pos ;
  cpVect tmp___1 ;
  cpShape *shape ;
  struct cpShapeMassInfo *info ;
  cpFloat m ;
  cpFloat msum ;
  cpFloat tmp___2 ;

  {
  if ((unsigned long )body == (unsigned long )((void *)0)) {
    return;
  } else {
    tmp = cpBodyGetType(body);
    if ((unsigned int )tmp != 0U) {
      return;
    }
  }
  tmp___0 = (cpFloat )0.0f;
  body->i = tmp___0;
  body->m = tmp___0;
  body->cog = (cpVect )cpvzero___1;
  tmp___1 = cpBodyGetPosition((cpBody const   *)body);
  pos = tmp___1;
  shape = body->shapeList;
  while (shape) {
    info = & shape->massInfo;
    m = info->m;
    if (m > (cpFloat )0.0f) {
      msum = body->m + m;
      tmp___2 = cpvdistsq((cpVect const   )body->cog, (cpVect const   )info->cog);
      body->i += m * info->i + (tmp___2 * (m * body->m)) / msum;
      body->cog = cpvlerp((cpVect const   )body->cog, (cpVect const   )info->cog,
                          (cpFloat const   )(m / msum));
      body->m = msum;
    }
    shape = shape->next;
  }
  body->m_inv = (cpFloat )1.0f / body->m;
  body->i_inv = (cpFloat )1.0f / body->i;
  cpBodySetPosition(body, pos);
  return;
}
}
cpSpace *cpBodyGetSpace(cpBody const   *body ) 
{ 


  {
  return ((cpSpace *)body->space);
}
}
cpFloat cpBodyGetMass(cpBody const   *body ) 
{ 


  {
  return ((cpFloat )body->m);
}
}
void cpBodySetMass(cpBody *body , cpFloat mass ) 
{ 
  cpBodyType tmp ;
  float tmp___0 ;
  float tmp___1 ;

  {
  tmp = cpBodyGetType(body);
  if (! ((unsigned int )tmp == 0U)) {
    cpMessage("cpBodyGetType(body) == CP_BODY_TYPE_DYNAMIC", "../src/cpBody.c", 256,
              1, 1, "You cannot set the mass of kinematic or static bodies.");
    abort();
  }
  if ((cpFloat )0.0f <= mass) {
    tmp___0 = __builtin_inff();
    if (! (mass < (cpFloat )tmp___0)) {
      cpMessage("0.0f <= mass && mass < INFINITY", "../src/cpBody.c", 257, 1, 1, "Mass must be positive and finite.");
      abort();
    }
  } else {
    cpMessage("0.0f <= mass && mass < INFINITY", "../src/cpBody.c", 257, 1, 1, "Mass must be positive and finite.");
    abort();
  }
  cpBodyActivate(body);
  body->m = mass;
  if (mass == (cpFloat )0.0f) {
    tmp___1 = __builtin_inff();
    body->m_inv = (cpFloat )tmp___1;
  } else {
    body->m_inv = (cpFloat )1.0f / mass;
  }
  return;
}
}
cpFloat cpBodyGetMoment(cpBody const   *body ) 
{ 


  {
  return ((cpFloat )body->i);
}
}
void cpBodySetMoment(cpBody *body , cpFloat moment ) 
{ 
  float tmp ;

  {
  if (! (moment >= (cpFloat )0.0f)) {
    cpMessage("moment >= 0.0f", "../src/cpBody.c", 274, 1, 1, "Moment of Inertia must be positive.");
    abort();
  }
  cpBodyActivate(body);
  body->i = moment;
  if (moment == (cpFloat )0.0f) {
    tmp = __builtin_inff();
    body->i_inv = (cpFloat )tmp;
  } else {
    body->i_inv = (cpFloat )1.0f / moment;
  }
  return;
}
}
cpVect cpBodyGetRotation(cpBody const   *body ) 
{ 
  cpVect tmp ;

  {
  tmp = cpv(body->transform.a, body->transform.b);
  return (tmp);
}
}
void cpBodyAddShape(cpBody *body , cpShape *shape ) 
{ 
  cpShape *next ;

  {
  next = body->shapeList;
  if (next) {
    next->prev = shape;
  }
  shape->next = next;
  body->shapeList = shape;
  if (shape->massInfo.m > (cpFloat )0.0f) {
    cpBodyAccumulateMassFromShapes(body);
  }
  return;
}
}
void cpBodyRemoveShape(cpBody *body , cpShape *shape ) 
{ 
  cpShape *prev ;
  cpShape *next ;
  cpBodyType tmp ;

  {
  prev = shape->prev;
  next = shape->next;
  if (prev) {
    prev->next = next;
  } else {
    body->shapeList = next;
  }
  if (next) {
    next->prev = prev;
  }
  shape->prev = (cpShape *)((void *)0);
  shape->next = (cpShape *)((void *)0);
  tmp = cpBodyGetType(body);
  if ((unsigned int )tmp == 0U) {
    if (shape->massInfo.m > (cpFloat )0.0f) {
      cpBodyAccumulateMassFromShapes(body);
    }
  }
  return;
}
}
static cpConstraint *filterConstraints(cpConstraint *node , cpBody *body , cpConstraint *filter ) 
{ 
  cpConstraint *tmp ;

  {
  if ((unsigned long )node == (unsigned long )filter) {
    tmp = cpConstraintNext(node, body);
    return (tmp);
  } else
  if ((unsigned long )node->a == (unsigned long )body) {
    node->next_a = filterConstraints(node->next_a, body, filter);
  } else {
    node->next_b = filterConstraints(node->next_b, body, filter);
  }
  return (node);
}
}
void cpBodyRemoveConstraint(cpBody *body , cpConstraint *constraint ) 
{ 


  {
  body->constraintList = filterConstraints(body->constraintList, body, constraint);
  return;
}
}
static void SetTransform(cpBody *body , cpVect p , cpFloat a ) 
{ 
  cpVect rot ;
  cpVect tmp ;
  cpVect c ;

  {
  tmp = cpvforangle((cpFloat const   )a);
  rot = tmp;
  c = body->cog;
  body->transform = cpTransformNewTranspose(rot.x, - rot.y, p.x - (c.x * rot.x - c.y * rot.y),
                                            rot.y, rot.x, p.y - (c.x * rot.y + c.y * rot.x));
  return;
}
}
__inline static cpFloat SetAngle(cpBody *body , cpFloat a ) 
{ 


  {
  body->a = a;
  return (a);
}
}
cpVect cpBodyGetPosition(cpBody const   *body ) 
{ 
  cpVect tmp ;

  {
  tmp = cpTransformPoint((cpTransform )body->transform, (cpVect )cpvzero___1);
  return (tmp);
}
}
void cpBodySetPosition(cpBody *body , cpVect position ) 
{ 
  cpVect p ;
  cpVect tmp ;
  cpVect tmp___0 ;

  {
  cpBodyActivate(body);
  tmp___0 = cpTransformVect(body->transform, body->cog);
  tmp = cpvadd((cpVect const   )tmp___0, (cpVect const   )position);
  body->p = tmp;
  p = tmp;
  SetTransform(body, p, body->a);
  return;
}
}
cpVect cpBodyGetCenterOfGravity(cpBody const   *body ) 
{ 


  {
  return ((cpVect )body->cog);
}
}
void cpBodySetCenterOfGravity(cpBody *body , cpVect cog ) 
{ 


  {
  cpBodyActivate(body);
  body->cog = cog;
  return;
}
}
cpVect cpBodyGetVelocity(cpBody const   *body ) 
{ 


  {
  return ((cpVect )body->v);
}
}
void cpBodySetVelocity(cpBody *body , cpVect velocity ) 
{ 


  {
  cpBodyActivate(body);
  body->v = velocity;
  return;
}
}
cpVect cpBodyGetForce(cpBody const   *body ) 
{ 


  {
  return ((cpVect )body->f);
}
}
void cpBodySetForce(cpBody *body , cpVect force ) 
{ 


  {
  cpBodyActivate(body);
  body->f = force;
  return;
}
}
cpFloat cpBodyGetAngle(cpBody const   *body ) 
{ 


  {
  return ((cpFloat )body->a);
}
}
void cpBodySetAngle(cpBody *body , cpFloat angle ) 
{ 


  {
  cpBodyActivate(body);
  SetAngle(body, angle);
  SetTransform(body, body->p, angle);
  return;
}
}
cpFloat cpBodyGetAngularVelocity(cpBody const   *body ) 
{ 


  {
  return ((cpFloat )body->w);
}
}
void cpBodySetAngularVelocity(cpBody *body , cpFloat angularVelocity ) 
{ 


  {
  cpBodyActivate(body);
  body->w = angularVelocity;
  return;
}
}
cpFloat cpBodyGetTorque(cpBody const   *body ) 
{ 


  {
  return ((cpFloat )body->t);
}
}
void cpBodySetTorque(cpBody *body , cpFloat torque ) 
{ 


  {
  cpBodyActivate(body);
  body->t = torque;
  return;
}
}
cpDataPointer cpBodyGetUserData(cpBody const   *body ) 
{ 


  {
  return ((cpDataPointer )body->userData);
}
}
void cpBodySetUserData(cpBody *body , cpDataPointer userData ) 
{ 


  {
  body->userData = userData;
  return;
}
}
void cpBodySetVelocityUpdateFunc(cpBody *body , void (*velocityFunc)(cpBody *body ,
                                                                     cpVect gravity ,
                                                                     cpFloat damping ,
                                                                     cpFloat dt ) ) 
{ 


  {
  body->velocity_func = velocityFunc;
  return;
}
}
void cpBodySetPositionUpdateFunc(cpBody *body , void (*positionFunc)(cpBody *body ,
                                                                     cpFloat dt ) ) 
{ 


  {
  body->position_func = positionFunc;
  return;
}
}
void cpBodyUpdateVelocity(cpBody *body , cpVect gravity , cpFloat damping , cpFloat dt ) 
{ 
  cpBodyType tmp ;
  cpVect tmp___0 ;
  cpVect tmp___1 ;
  cpVect tmp___2 ;
  cpVect tmp___3 ;

  {
  tmp = cpBodyGetType(body);
  if ((unsigned int )tmp == 1U) {
    return;
  }
  tmp___0 = cpvmult((cpVect const   )body->f, (cpFloat const   )body->m_inv);
  tmp___1 = cpvadd((cpVect const   )gravity, (cpVect const   )tmp___0);
  tmp___2 = cpvmult((cpVect const   )tmp___1, (cpFloat const   )dt);
  tmp___3 = cpvmult((cpVect const   )body->v, (cpFloat const   )damping);
  body->v = cpvadd((cpVect const   )tmp___3, (cpVect const   )tmp___2);
  body->w = body->w * damping + (body->t * body->i_inv) * dt;
  body->f = (cpVect )cpvzero___1;
  body->t = (cpFloat )0.0f;
  return;
}
}
void cpBodyUpdatePosition(cpBody *body , cpFloat dt ) 
{ 
  cpVect p ;
  cpVect tmp ;
  cpVect tmp___0 ;
  cpVect tmp___1 ;
  cpFloat a ;
  cpFloat tmp___2 ;

  {
  tmp___0 = cpvadd((cpVect const   )body->v, (cpVect const   )body->v_bias);
  tmp___1 = cpvmult((cpVect const   )tmp___0, (cpFloat const   )dt);
  tmp = cpvadd((cpVect const   )body->p, (cpVect const   )tmp___1);
  body->p = tmp;
  p = tmp;
  tmp___2 = SetAngle(body, body->a + (body->w + body->w_bias) * dt);
  a = tmp___2;
  SetTransform(body, p, a);
  body->v_bias = (cpVect )cpvzero___1;
  body->w_bias = (cpFloat )0.0f;
  return;
}
}
cpVect cpBodyLocalToWorld(cpBody const   *body , cpVect const   point ) 
{ 
  cpVect tmp ;

  {
  tmp = cpTransformPoint((cpTransform )body->transform, (cpVect )point);
  return (tmp);
}
}
cpVect cpBodyWorldToLocal(cpBody const   *body , cpVect const   point ) 
{ 
  cpTransform tmp ;
  cpVect tmp___0 ;

  {
  tmp = cpTransformRigidInverse((cpTransform )body->transform);
  tmp___0 = cpTransformPoint(tmp, (cpVect )point);
  return (tmp___0);
}
}
void cpBodyApplyForceAtWorldPoint(cpBody *body , cpVect force , cpVect point ) 
{ 
  cpVect r ;
  cpVect tmp ;
  cpVect tmp___0 ;
  cpFloat tmp___1 ;

  {
  cpBodyActivate(body);
  body->f = cpvadd((cpVect const   )body->f, (cpVect const   )force);
  tmp = cpTransformPoint(body->transform, body->cog);
  tmp___0 = cpvsub((cpVect const   )point, (cpVect const   )tmp);
  r = tmp___0;
  tmp___1 = cpvcross((cpVect const   )r, (cpVect const   )force);
  body->t += tmp___1;
  return;
}
}
void cpBodyApplyForceAtLocalPoint(cpBody *body , cpVect force , cpVect point ) 
{ 
  cpVect tmp ;
  cpVect tmp___0 ;

  {
  tmp = cpTransformPoint(body->transform, point);
  tmp___0 = cpTransformVect(body->transform, force);
  cpBodyApplyForceAtWorldPoint(body, tmp___0, tmp);
  return;
}
}
void cpBodyApplyImpulseAtWorldPoint(cpBody *body , cpVect impulse , cpVect point ) 
{ 
  cpVect r ;
  cpVect tmp ;
  cpVect tmp___0 ;

  {
  cpBodyActivate(body);
  tmp = cpTransformPoint(body->transform, body->cog);
  tmp___0 = cpvsub((cpVect const   )point, (cpVect const   )tmp);
  r = tmp___0;
  apply_impulse(body, impulse, r);
  return;
}
}
void cpBodyApplyImpulseAtLocalPoint(cpBody *body , cpVect impulse , cpVect point ) 
{ 
  cpVect tmp ;
  cpVect tmp___0 ;

  {
  tmp = cpTransformPoint(body->transform, point);
  tmp___0 = cpTransformVect(body->transform, impulse);
  cpBodyApplyImpulseAtWorldPoint(body, tmp___0, tmp);
  return;
}
}
cpVect cpBodyGetVelocityAtLocalPoint(cpBody const   *body , cpVect point ) 
{ 
  cpVect r ;
  cpVect tmp ;
  cpVect tmp___0 ;
  cpVect tmp___1 ;
  cpVect tmp___2 ;
  cpVect tmp___3 ;

  {
  tmp = cpvsub((cpVect const   )point, body->cog);
  tmp___0 = cpTransformVect((cpTransform )body->transform, tmp);
  r = tmp___0;
  tmp___1 = cpvperp((cpVect const   )r);
  tmp___2 = cpvmult((cpVect const   )tmp___1, body->w);
  tmp___3 = cpvadd(body->v, (cpVect const   )tmp___2);
  return (tmp___3);
}
}
cpVect cpBodyGetVelocityAtWorldPoint(cpBody const   *body , cpVect point ) 
{ 
  cpVect r ;
  cpVect tmp ;
  cpVect tmp___0 ;
  cpVect tmp___1 ;
  cpVect tmp___2 ;
  cpVect tmp___3 ;

  {
  tmp = cpTransformPoint((cpTransform )body->transform, (cpVect )body->cog);
  tmp___0 = cpvsub((cpVect const   )point, (cpVect const   )tmp);
  r = tmp___0;
  tmp___1 = cpvperp((cpVect const   )r);
  tmp___2 = cpvmult((cpVect const   )tmp___1, body->w);
  tmp___3 = cpvadd(body->v, (cpVect const   )tmp___2);
  return (tmp___3);
}
}
cpFloat cpBodyKineticEnergy(cpBody const   *body ) 
{ 
  cpFloat vsq ;
  cpFloat tmp ;
  cpFloat wsq ;
  cpFloat tmp___0 ;
  cpFloat tmp___1 ;

  {
  tmp = cpvdot(body->v, body->v);
  vsq = tmp;
  wsq = (cpFloat )(body->w * body->w);
  if (vsq) {
    tmp___0 = vsq * (cpFloat )body->m;
  } else {
    tmp___0 = (cpFloat )0.0f;
  }
  if (wsq) {
    tmp___1 = wsq * (cpFloat )body->i;
  } else {
    tmp___1 = (cpFloat )0.0f;
  }
  return (tmp___0 + tmp___1);
}
}
void cpBodyEachShape(cpBody *body , void (*func)(cpBody *body , cpShape *shape , void *data ) ,
                     void *data ) 
{ 
  cpShape *shape ;
  cpShape *next ;

  {
  shape = body->shapeList;
  while (shape) {
    next = shape->next;
    (*func)(body, shape, data);
    shape = next;
  }
  return;
}
}
void cpBodyEachConstraint(cpBody *body , void (*func)(cpBody *body , cpConstraint *constraint ,
                                                      void *data ) , void *data ) 
{ 
  cpConstraint *constraint ;
  cpConstraint *next ;
  cpConstraint *tmp ;

  {
  constraint = body->constraintList;
  while (constraint) {
    tmp = cpConstraintNext(constraint, body);
    next = tmp;
    (*func)(body, constraint, data);
    constraint = next;
  }
  return;
}
}
void cpBodyEachArbiter(cpBody *body , void (*func)(cpBody *body , cpArbiter *arbiter ,
                                                   void *data ) , void *data ) 
{ 
  cpArbiter *arb ;
  cpArbiter *next ;
  cpArbiter *tmp ;
  cpBool swapped ;

  {
  arb = body->arbiterList;
  while (arb) {
    tmp = cpArbiterNext(arb, body);
    next = tmp;
    swapped = arb->swapped;
    arb->swapped = (cpBool )((unsigned long )body == (unsigned long )arb->body_b);
    (*func)(body, arb, data);
    arb->swapped = swapped;
    arb = next;
  }
  return;
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#pragma merger("0","/tmp/cil-NAQO_218.i","-std=gnu99,-ffast-math,-fPIC")
__inline static cpFloat cpfclamp01(cpFloat f ) 
{ 
  cpFloat tmp ;
  cpFloat tmp___0 ;

  {
  tmp = cpfmin(f, (cpFloat )1.0f);
  tmp___0 = cpfmax((cpFloat )0.0f, tmp);
  return (tmp___0);
}
}
static struct cpVect  const  cpvzero___2  =    {(cpFloat )0.0f, (cpFloat )0.0f};
__inline static cpBool cpveql(cpVect const   v1 , cpVect const   v2 ) 
{ 
  int tmp ;

  {
  if (v1.x == v2.x) {
    if (v1.y == v2.y) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((cpBool )tmp);
}
}
__inline static cpVect cpvrperp(cpVect const   v ) 
{ 
  cpVect tmp ;

  {
  tmp = cpv(v.y, - v.x);
  return (tmp);
}
}
__inline static cpVect cpvnormalize(cpVect const   v ) 
{ 
  cpFloat tmp ;
  cpVect tmp___0 ;

  {
  tmp = cpvlength(v);
  tmp___0 = cpvmult(v, (cpFloat const   )((cpFloat )1.0f / (tmp + 2.2250738585072014e-308)));
  return (tmp___0);
}
}
__inline static cpVect cpBBCenter(cpBB bb ) 
{ 
  cpVect tmp ;
  cpVect tmp___0 ;
  cpVect tmp___1 ;

  {
  tmp = cpv((cpFloat const   )bb.r, (cpFloat const   )bb.t);
  tmp___0 = cpv((cpFloat const   )bb.l, (cpFloat const   )bb.b);
  tmp___1 = cpvlerp((cpVect const   )tmp___0, (cpVect const   )tmp, (cpFloat const   )0.5f);
  return (tmp___1);
}
}
struct cpCollisionInfo cpCollide(cpShape const   *a , cpShape const   *b , cpCollisionID id ,
                                 struct cpContact *contacts ) ;
cpBool cpCheckPointGreater(cpVect const   a , cpVect const   b , cpVect const   c ) ;
cpBool cpCheckAxis(cpVect v0 , cpVect v1 , cpVect p , cpVect n ) ;
__inline static void cpCollisionInfoPushContact(struct cpCollisionInfo *info , cpVect p1 ,
                                                cpVect p2 , cpHashValue hash ) 
{ 
  struct cpContact *con ;

  {
  con = info->arr + info->count;
  con->r1 = p1;
  con->r2 = p2;
  con->hash = hash;
  (info->count) ++;
  return;
}
}
__inline static int PolySupportPointIndex(int const   count , struct cpSplittingPlane  const  *planes ,
                                          cpVect const   n ) 
{ 
  cpFloat max ;
  float tmp ;
  int index___0 ;
  int i ;
  cpVect v ;
  cpFloat d ;
  cpFloat tmp___0 ;

  {
  tmp = __builtin_inff();
  max = (cpFloat )(- tmp);
  index___0 = 0;
  i = 0;
  while (i < (int )count) {
    v = (planes + i)->v0;
    tmp___0 = cpvdot((cpVect const   )v, n);
    d = tmp___0;
    if (d > max) {
      max = d;
      index___0 = i;
    }
    i ++;
  }
  return (index___0);
}
}
__inline static struct SupportPoint SupportPointNew(cpVect p , cpCollisionID index___0 ) 
{ 
  struct SupportPoint point ;

  {
  point.p = p;
  point.index = index___0;
  return (point);
}
}
__inline static struct SupportPoint CircleSupportPoint(cpCircleShape const   *circle ,
                                                       cpVect const   n ) 
{ 
  struct SupportPoint tmp ;

  {
  tmp = SupportPointNew((cpVect )circle->tc, (cpCollisionID )0);
  return (tmp);
}
}
__inline static struct SupportPoint SegmentSupportPoint(cpSegmentShape const   *seg___0 ,
                                                        cpVect const   n ) 
{ 
  struct SupportPoint tmp ;
  struct SupportPoint tmp___0 ;
  cpFloat tmp___1 ;
  cpFloat tmp___2 ;

  {
  tmp___1 = cpvdot(seg___0->ta, n);
  tmp___2 = cpvdot(seg___0->tb, n);
  if (tmp___1 > tmp___2) {
    tmp = SupportPointNew((cpVect )seg___0->ta, (cpCollisionID )0);
    return (tmp);
  } else {
    tmp___0 = SupportPointNew((cpVect )seg___0->tb, (cpCollisionID )1);
    return (tmp___0);
  }
}
}
__inline static struct SupportPoint PolySupportPoint(cpPolyShape const   *poly , cpVect const   n ) 
{ 
  struct cpSplittingPlane  const  *planes ;
  int i ;
  int tmp ;
  struct SupportPoint tmp___0 ;

  {
  planes = (struct cpSplittingPlane  const  *)poly->planes;
  tmp = PolySupportPointIndex(poly->count, planes, n);
  i = tmp;
  tmp___0 = SupportPointNew((cpVect )(planes + i)->v0, (cpCollisionID )i);
  return (tmp___0);
}
}
__inline static struct MinkowskiPoint MinkowskiPointNew(struct SupportPoint  const  a ,
                                                        struct SupportPoint  const  b ) 
{ 
  struct MinkowskiPoint point ;
  cpVect tmp ;

  {
  tmp = cpvsub(b.p, a.p);
  point.a = a.p;
  point.b = b.p;
  point.ab = tmp;
  point.id = (cpCollisionID )(((a.index & 255U) << 8) | (b.index & 255U));
  return (point);
}
}
__inline static struct MinkowskiPoint Support(struct SupportContext  const  *ctx ,
                                              cpVect const   n ) 
{ 
  struct SupportPoint a ;
  cpVect tmp ;
  struct SupportPoint tmp___0 ;
  struct SupportPoint b ;
  struct SupportPoint tmp___1 ;
  struct MinkowskiPoint tmp___2 ;

  {
  tmp = cpvneg(n);
  tmp___0 = (*(ctx->func1))((cpShape const   *)ctx->shape1, (cpVect const   )tmp);
  a = tmp___0;
  tmp___1 = (*(ctx->func2))((cpShape const   *)ctx->shape2, n);
  b = tmp___1;
  tmp___2 = MinkowskiPointNew((struct SupportPoint  const  )a, (struct SupportPoint  const  )b);
  return (tmp___2);
}
}
static struct Edge SupportEdgeForPoly(cpPolyShape const   *poly , cpVect const   n ) 
{ 
  int count ;
  int i1 ;
  int tmp ;
  int i0 ;
  int i2 ;
  struct cpSplittingPlane  const  *planes ;
  cpHashValue hashid ;
  struct Edge edge ;
  struct Edge edge___0 ;
  cpFloat tmp___0 ;
  cpFloat tmp___1 ;

  {
  count = (int )poly->count;
  tmp = PolySupportPointIndex(poly->count, (struct cpSplittingPlane  const  *)poly->planes,
                              n);
  i1 = tmp;
  i0 = ((i1 - 1) + count) % count;
  i2 = (i1 + 1) % count;
  planes = (struct cpSplittingPlane  const  *)poly->planes;
  hashid = (cpHashValue )poly->shape.hashid;
  tmp___0 = cpvdot(n, (planes + i1)->n);
  tmp___1 = cpvdot(n, (planes + i2)->n);
  if (tmp___0 > tmp___1) {
    edge.a.p = (planes + i0)->v0;
    edge.a.hash = hashid * 3344921057UL ^ (cpHashValue )i0 * 3344921057UL;
    edge.b.p = (planes + i1)->v0;
    edge.b.hash = hashid * 3344921057UL ^ (cpHashValue )i1 * 3344921057UL;
    edge.r = (cpFloat )poly->r;
    edge.n = (planes + i1)->n;
    return (edge);
  } else {
    edge___0.a.p = (planes + i1)->v0;
    edge___0.a.hash = hashid * 3344921057UL ^ (cpHashValue )i1 * 3344921057UL;
    edge___0.b.p = (planes + i2)->v0;
    edge___0.b.hash = hashid * 3344921057UL ^ (cpHashValue )i2 * 3344921057UL;
    edge___0.r = (cpFloat )poly->r;
    edge___0.n = (planes + i2)->n;
    return (edge___0);
  }
}
}
static struct Edge SupportEdgeForSegment(cpSegmentShape const   *seg___0 , cpVect const   n ) 
{ 
  cpHashValue hashid ;
  struct Edge edge ;
  struct Edge edge___0 ;
  cpVect tmp ;
  cpFloat tmp___0 ;

  {
  hashid = (cpHashValue )seg___0->shape.hashid;
  tmp___0 = cpvdot(seg___0->tn, n);
  if (tmp___0 > 0.0) {
    edge.a.p = seg___0->ta;
    edge.a.hash = hashid * 3344921057UL;
    edge.b.p = seg___0->tb;
    edge.b.hash = hashid * 3344921057UL ^ 3344921057UL;
    edge.r = (cpFloat )seg___0->r;
    edge.n = seg___0->tn;
    return (edge);
  } else {
    tmp = cpvneg(seg___0->tn);
    edge___0.a.p = seg___0->tb;
    edge___0.a.hash = hashid * 3344921057UL ^ 3344921057UL;
    edge___0.b.p = seg___0->ta;
    edge___0.b.hash = hashid * 3344921057UL;
    edge___0.r = (cpFloat )seg___0->r;
    edge___0.n = tmp;
    return (edge___0);
  }
}
}
__inline static cpFloat ClosestT(cpVect const   a , cpVect const   b ) 
{ 
  cpVect delta ;
  cpVect tmp ;
  cpVect tmp___0 ;
  cpFloat tmp___1 ;
  cpFloat tmp___2 ;
  cpFloat tmp___3 ;

  {
  tmp = cpvsub(b, a);
  delta = tmp;
  tmp___0 = cpvadd(a, b);
  tmp___1 = cpvdot((cpVect const   )delta, (cpVect const   )tmp___0);
  tmp___2 = cpvlengthsq((cpVect const   )delta);
  tmp___3 = cpfclamp(tmp___1 / (tmp___2 + 2.2250738585072014e-308), (cpFloat )(- 1.0f),
                     (cpFloat )1.0f);
  return (- tmp___3);
}
}
__inline static cpVect LerpT(cpVect const   a , cpVect const   b , cpFloat const   t ) 
{ 
  cpFloat ht ;
  cpVect tmp ;
  cpVect tmp___0 ;
  cpVect tmp___1 ;

  {
  ht = (cpFloat )((cpFloat const   )0.5f * t);
  tmp = cpvmult(b, (cpFloat const   )((cpFloat )0.5f + ht));
  tmp___0 = cpvmult(a, (cpFloat const   )((cpFloat )0.5f - ht));
  tmp___1 = cpvadd((cpVect const   )tmp___0, (cpVect const   )tmp);
  return (tmp___1);
}
}
__inline static struct ClosestPoints ClosestPointsNew(struct MinkowskiPoint  const  v0 ,
                                                      struct MinkowskiPoint  const  v1 ) 
{ 
  cpFloat t ;
  cpFloat tmp ;
  cpVect p ;
  cpVect tmp___0 ;
  cpVect pa ;
  cpVect tmp___1 ;
  cpVect pb ;
  cpVect tmp___2 ;
  cpCollisionID id ;
  cpVect delta ;
  cpVect tmp___3 ;
  cpVect n ;
  cpVect tmp___4 ;
  cpVect tmp___5 ;
  cpFloat d ;
  cpFloat tmp___6 ;
  struct ClosestPoints points ;
  cpFloat d2 ;
  cpFloat tmp___7 ;
  cpVect n2 ;
  cpVect tmp___8 ;
  struct ClosestPoints points___0 ;

  {
  tmp = ClosestT(v0.ab, v1.ab);
  t = tmp;
  tmp___0 = LerpT(v0.ab, v1.ab, (cpFloat const   )t);
  p = tmp___0;
  tmp___1 = LerpT(v0.a, v1.a, (cpFloat const   )t);
  pa = tmp___1;
  tmp___2 = LerpT(v0.b, v1.b, (cpFloat const   )t);
  pb = tmp___2;
  id = (cpCollisionID )(((v0.id & 65535U) << 16) | (v1.id & 65535U));
  tmp___3 = cpvsub(v1.ab, v0.ab);
  delta = tmp___3;
  tmp___4 = cpvrperp((cpVect const   )delta);
  tmp___5 = cpvnormalize((cpVect const   )tmp___4);
  n = tmp___5;
  tmp___6 = cpvdot((cpVect const   )n, (cpVect const   )p);
  d = tmp___6;
  if (d <= (cpFloat )0.0f) {
    goto _L;
  } else
  if ((cpFloat )(- 1.0f) < t) {
    if (t < (cpFloat )1.0f) {
      _L: /* CIL Label */ 
      points.a = pa;
      points.b = pb;
      points.n = n;
      points.d = d;
      points.id = id;
      return (points);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    tmp___7 = cpvlength((cpVect const   )p);
    d2 = tmp___7;
    tmp___8 = cpvmult((cpVect const   )p, (cpFloat const   )((cpFloat )1.0f / (d2 + 2.2250738585072014e-308)));
    n2 = tmp___8;
    points___0.a = pa;
    points___0.b = pb;
    points___0.n = n2;
    points___0.d = d2;
    points___0.id = id;
    return (points___0);
  }
}
}
__inline static cpFloat ClosestDist(cpVect const   v0 , cpVect const   v1 ) 
{ 
  cpFloat tmp ;
  cpVect tmp___0 ;
  cpFloat tmp___1 ;

  {
  tmp = ClosestT(v0, v1);
  tmp___0 = LerpT(v0, v1, (cpFloat const   )tmp);
  tmp___1 = cpvlengthsq((cpVect const   )tmp___0);
  return (tmp___1);
}
}
static struct ClosestPoints EPARecurse(struct SupportContext  const  *ctx , int const   count ,
                                       struct MinkowskiPoint  const  *hull , int const   iteration ) 
{ 
  int mini ;
  cpFloat minDist ;
  float tmp ;
  int j ;
  int i ;
  cpFloat d ;
  cpFloat tmp___0 ;
  struct MinkowskiPoint v0 ;
  struct MinkowskiPoint v1 ;
  struct MinkowskiPoint p ;
  cpVect tmp___1 ;
  cpVect tmp___2 ;
  struct MinkowskiPoint tmp___3 ;
  cpBool duplicate ;
  int tmp___4 ;
  struct MinkowskiPoint *hull2 ;
  void *tmp___5 ;
  int count2 ;
  int i___0 ;
  int index___0 ;
  cpVect h0 ;
  cpVect h1 ;
  cpVect h2 ;
  struct MinkowskiPoint tmp___6 ;
  cpBool tmp___7 ;
  struct ClosestPoints tmp___8 ;
  struct ClosestPoints tmp___9 ;
  cpBool tmp___10 ;

  {
  mini = 0;
  tmp = __builtin_inff();
  minDist = (cpFloat )tmp;
  j = 0;
  i = (int )(count - 1);
  while (j < (int )count) {
    tmp___0 = ClosestDist((hull + i)->ab, (hull + j)->ab);
    d = tmp___0;
    if (d < minDist) {
      minDist = d;
      mini = i;
    }
    i = j;
    j ++;
  }
  v0 = *(hull + mini);
  v1 = *(hull + (mini + 1) % (int )count);
  tmp___1 = cpvsub((cpVect const   )v1.ab, (cpVect const   )v0.ab);
  tmp___2 = cpvperp((cpVect const   )tmp___1);
  tmp___3 = Support(ctx, (cpVect const   )tmp___2);
  p = tmp___3;
  if (p.id == v0.id) {
    tmp___4 = 1;
  } else
  if (p.id == v1.id) {
    tmp___4 = 1;
  } else {
    tmp___4 = 0;
  }
  duplicate = (cpBool )tmp___4;
  if (! duplicate) {
    tmp___10 = cpCheckPointGreater((cpVect const   )v0.ab, (cpVect const   )v1.ab,
                                   (cpVect const   )p.ab);
    if (tmp___10) {
      if (iteration < 30) {
        tmp___5 = __builtin_alloca((unsigned long )(count + 1) * sizeof(struct MinkowskiPoint ));
        hull2 = (struct MinkowskiPoint *)tmp___5;
        count2 = 1;
        *(hull2 + 0) = p;
        i___0 = 0;
        while (i___0 < (int )count) {
          index___0 = ((mini + 1) + i___0) % (int )count;
          h0 = (hull2 + (count2 - 1))->ab;
          h1 = (hull + index___0)->ab;
          if (i___0 + 1 < (int )count) {
            tmp___6 = *(hull + (index___0 + 1) % (int )count);
          } else {
            tmp___6 = (struct MinkowskiPoint  const  )p;
          }
          h2 = tmp___6.ab;
          tmp___7 = cpCheckPointGreater((cpVect const   )h0, (cpVect const   )h2,
                                        (cpVect const   )h1);
          if (tmp___7) {
            *(hull2 + count2) = (struct MinkowskiPoint )*(hull + index___0);
            count2 ++;
          }
          i___0 ++;
        }
        tmp___8 = EPARecurse(ctx, (int const   )count2, (struct MinkowskiPoint  const  *)hull2,
                             iteration + 1);
        return (tmp___8);
      } else {
        tmp___9 = ClosestPointsNew((struct MinkowskiPoint  const  )v0, (struct MinkowskiPoint  const  )v1);
        return (tmp___9);
      }
    } else {
      tmp___9 = ClosestPointsNew((struct MinkowskiPoint  const  )v0, (struct MinkowskiPoint  const  )v1);
      return (tmp___9);
    }
  } else {
    tmp___9 = ClosestPointsNew((struct MinkowskiPoint  const  )v0, (struct MinkowskiPoint  const  )v1);
    return (tmp___9);
  }
}
}
static struct ClosestPoints EPA(struct SupportContext  const  *ctx , struct MinkowskiPoint  const  v0 ,
                                struct MinkowskiPoint  const  v1 , struct MinkowskiPoint  const  v2 ) 
{ 
  struct MinkowskiPoint hull[3] ;
  struct ClosestPoints tmp ;

  {
  hull[0] = v0;
  hull[1] = v1;
  hull[2] = v2;
  tmp = EPARecurse(ctx, (int const   )3, (struct MinkowskiPoint  const  *)(hull),
                   (int const   )1);
  return (tmp);
}
}
__inline static struct ClosestPoints GJKRecurse(struct SupportContext  const  *ctx ,
                                                struct MinkowskiPoint  const  v0 ,
                                                struct MinkowskiPoint  const  v1 ,
                                                int const   iteration ) 
{ 
  struct ClosestPoints tmp ;
  struct ClosestPoints tmp___0 ;
  cpFloat t ;
  cpFloat tmp___1 ;
  cpVect n ;
  cpVect tmp___2 ;
  cpVect tmp___3 ;
  cpVect tmp___4 ;
  cpVect tmp___5 ;
  cpVect tmp___6 ;
  struct MinkowskiPoint p ;
  struct MinkowskiPoint tmp___7 ;
  struct ClosestPoints tmp___8 ;
  struct ClosestPoints tmp___9 ;
  struct ClosestPoints tmp___10 ;
  struct ClosestPoints tmp___11 ;
  cpFloat tmp___12 ;
  cpFloat tmp___13 ;
  cpBool tmp___14 ;
  cpBool tmp___15 ;
  cpBool tmp___16 ;
  cpBool tmp___17 ;

  {
  if (iteration > 30) {
    tmp = ClosestPointsNew(v0, v1);
    return (tmp);
  }
  tmp___17 = cpCheckPointGreater(v1.ab, v0.ab, cpvzero___2);
  if (tmp___17) {
    tmp___0 = GJKRecurse(ctx, v1, v0, iteration);
    return (tmp___0);
  } else {
    tmp___1 = ClosestT(v0.ab, v1.ab);
    t = tmp___1;
    if ((cpFloat )(- 1.0f) < t) {
      if (t < (cpFloat )1.0f) {
        tmp___2 = cpvsub(v1.ab, v0.ab);
        tmp___3 = cpvperp((cpVect const   )tmp___2);
        tmp___6 = tmp___3;
      } else {
        tmp___4 = LerpT(v0.ab, v1.ab, (cpFloat const   )t);
        tmp___5 = cpvneg((cpVect const   )tmp___4);
        tmp___6 = tmp___5;
      }
    } else {
      tmp___4 = LerpT(v0.ab, v1.ab, (cpFloat const   )t);
      tmp___5 = cpvneg((cpVect const   )tmp___4);
      tmp___6 = tmp___5;
    }
    n = tmp___6;
    tmp___7 = Support(ctx, (cpVect const   )n);
    p = tmp___7;
    tmp___15 = cpCheckPointGreater((cpVect const   )p.ab, v0.ab, cpvzero___2);
    if (tmp___15) {
      tmp___16 = cpCheckPointGreater(v1.ab, (cpVect const   )p.ab, cpvzero___2);
      if (tmp___16) {
        tmp___8 = EPA(ctx, v0, (struct MinkowskiPoint  const  )p, v1);
        return (tmp___8);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      tmp___14 = cpCheckAxis((cpVect )v0.ab, (cpVect )v1.ab, p.ab, n);
      if (tmp___14) {
        tmp___9 = ClosestPointsNew(v0, v1);
        return (tmp___9);
      } else {
        tmp___12 = ClosestDist(v0.ab, (cpVect const   )p.ab);
        tmp___13 = ClosestDist((cpVect const   )p.ab, v1.ab);
        if (tmp___12 < tmp___13) {
          tmp___10 = GJKRecurse(ctx, v0, (struct MinkowskiPoint  const  )p, iteration + 1);
          return (tmp___10);
        } else {
          tmp___11 = GJKRecurse(ctx, (struct MinkowskiPoint  const  )p, v1, iteration + 1);
          return (tmp___11);
        }
      }
    }
  }
}
}
static struct SupportPoint ShapePoint(cpShape const   *shape , int const   i ) 
{ 
  struct SupportPoint tmp ;
  cpSegmentShape *seg___0 ;
  cpVect tmp___0 ;
  struct SupportPoint tmp___1 ;
  cpPolyShape *poly ;
  int index___0 ;
  int tmp___2 ;
  struct SupportPoint tmp___3 ;
  struct SupportPoint tmp___4 ;

  {
  switch ((unsigned int const   )(shape->klass)->type) {
  case 0U: 
  tmp = SupportPointNew(((cpCircleShape *)shape)->tc, (cpCollisionID )0);
  return (tmp);
  case 1U: 
  seg___0 = (cpSegmentShape *)shape;
  if (i == 0) {
    tmp___0 = seg___0->ta;
  } else {
    tmp___0 = seg___0->tb;
  }
  tmp___1 = SupportPointNew(tmp___0, (cpCollisionID )i);
  return (tmp___1);
  case 2U: 
  poly = (cpPolyShape *)shape;
  if (i < (int const   )poly->count) {
    tmp___2 = i;
  } else {
    tmp___2 = (int const   )0;
  }
  index___0 = (int )tmp___2;
  tmp___3 = SupportPointNew((poly->planes + index___0)->v0, (cpCollisionID )index___0);
  return (tmp___3);
  default: 
  tmp___4 = SupportPointNew((cpVect )cpvzero___2, (cpCollisionID )0);
  return (tmp___4);
  }
}
}
static struct ClosestPoints GJK(struct SupportContext  const  *ctx , cpCollisionID *id ) 
{ 
  struct MinkowskiPoint v0 ;
  struct MinkowskiPoint v1 ;
  struct SupportPoint tmp ;
  struct SupportPoint tmp___0 ;
  struct SupportPoint tmp___1 ;
  struct SupportPoint tmp___2 ;
  cpVect axis ;
  cpVect tmp___3 ;
  cpVect tmp___4 ;
  cpVect tmp___5 ;
  cpVect tmp___6 ;
  cpVect tmp___7 ;
  struct ClosestPoints points ;
  struct ClosestPoints tmp___8 ;

  {
  if (*id) {
    tmp = ShapePoint((cpShape const   *)ctx->shape2, (int const   )((*id >> 16) & 255U));
    tmp___0 = ShapePoint((cpShape const   *)ctx->shape1, (int const   )((*id >> 24) & 255U));
    v0 = MinkowskiPointNew((struct SupportPoint  const  )tmp___0, (struct SupportPoint  const  )tmp);
    tmp___1 = ShapePoint((cpShape const   *)ctx->shape2, (int const   )(*id & 255U));
    tmp___2 = ShapePoint((cpShape const   *)ctx->shape1, (int const   )((*id >> 8) & 255U));
    v1 = MinkowskiPointNew((struct SupportPoint  const  )tmp___2, (struct SupportPoint  const  )tmp___1);
  } else {
    tmp___3 = cpBBCenter((cpBB )(ctx->shape2)->bb);
    tmp___4 = cpBBCenter((cpBB )(ctx->shape1)->bb);
    tmp___5 = cpvsub((cpVect const   )tmp___4, (cpVect const   )tmp___3);
    tmp___6 = cpvperp((cpVect const   )tmp___5);
    axis = tmp___6;
    v0 = Support(ctx, (cpVect const   )axis);
    tmp___7 = cpvneg((cpVect const   )axis);
    v1 = Support(ctx, (cpVect const   )tmp___7);
  }
  tmp___8 = GJKRecurse(ctx, (struct MinkowskiPoint  const  )v0, (struct MinkowskiPoint  const  )v1,
                       (int const   )1);
  points = tmp___8;
  *id = points.id;
  return (points);
}
}
__inline static void ContactPoints(struct Edge  const  e1 , struct Edge  const  e2 ,
                                   struct ClosestPoints  const  points , struct cpCollisionInfo *info ) 
{ 
  cpFloat mindist ;
  cpVect n ;
  cpVect tmp ;
  cpFloat d_e1_a ;
  cpFloat tmp___0 ;
  cpFloat d_e1_b ;
  cpFloat tmp___1 ;
  cpFloat d_e2_a ;
  cpFloat tmp___2 ;
  cpFloat d_e2_b ;
  cpFloat tmp___3 ;
  cpFloat e1_denom ;
  cpFloat e2_denom ;
  cpVect p1 ;
  cpFloat tmp___4 ;
  cpVect tmp___5 ;
  cpVect tmp___6 ;
  cpVect tmp___7 ;
  cpVect p2 ;
  cpFloat tmp___8 ;
  cpVect tmp___9 ;
  cpVect tmp___10 ;
  cpVect tmp___11 ;
  cpFloat dist ;
  cpVect tmp___12 ;
  cpFloat tmp___13 ;
  cpHashValue hash_1a2b ;
  cpVect p1___0 ;
  cpFloat tmp___14 ;
  cpVect tmp___15 ;
  cpVect tmp___16 ;
  cpVect tmp___17 ;
  cpVect p2___0 ;
  cpFloat tmp___18 ;
  cpVect tmp___19 ;
  cpVect tmp___20 ;
  cpVect tmp___21 ;
  cpFloat dist___0 ;
  cpVect tmp___22 ;
  cpFloat tmp___23 ;
  cpHashValue hash_1b2a ;

  {
  mindist = (cpFloat )(e1.r + e2.r);
  if (points.d <= (cpFloat const   )mindist) {
    tmp = (cpVect )points.n;
    info->n = tmp;
    n = tmp;
    tmp___0 = cpvcross(e1.a.p, (cpVect const   )n);
    d_e1_a = tmp___0;
    tmp___1 = cpvcross(e1.b.p, (cpVect const   )n);
    d_e1_b = tmp___1;
    tmp___2 = cpvcross(e2.a.p, (cpVect const   )n);
    d_e2_a = tmp___2;
    tmp___3 = cpvcross(e2.b.p, (cpVect const   )n);
    d_e2_b = tmp___3;
    e1_denom = (cpFloat )1.0f / ((d_e1_b - d_e1_a) + 2.2250738585072014e-308);
    e2_denom = (cpFloat )1.0f / ((d_e2_b - d_e2_a) + 2.2250738585072014e-308);
    tmp___4 = cpfclamp01((d_e2_b - d_e1_a) * e1_denom);
    tmp___5 = cpvlerp(e1.a.p, e1.b.p, (cpFloat const   )tmp___4);
    tmp___6 = cpvmult((cpVect const   )n, e1.r);
    tmp___7 = cpvadd((cpVect const   )tmp___6, (cpVect const   )tmp___5);
    p1 = tmp___7;
    tmp___8 = cpfclamp01((d_e1_a - d_e2_a) * e2_denom);
    tmp___9 = cpvlerp(e2.a.p, e2.b.p, (cpFloat const   )tmp___8);
    tmp___10 = cpvmult((cpVect const   )n, - e2.r);
    tmp___11 = cpvadd((cpVect const   )tmp___10, (cpVect const   )tmp___9);
    p2 = tmp___11;
    tmp___12 = cpvsub((cpVect const   )p2, (cpVect const   )p1);
    tmp___13 = cpvdot((cpVect const   )tmp___12, (cpVect const   )n);
    dist = tmp___13;
    if (dist <= (cpFloat )0.0f) {
      hash_1a2b = (cpHashValue )e1.a.hash * 3344921057UL ^ (cpHashValue )e2.b.hash * 3344921057UL;
      cpCollisionInfoPushContact(info, p1, p2, hash_1a2b);
    }
    tmp___14 = cpfclamp01((d_e2_a - d_e1_a) * e1_denom);
    tmp___15 = cpvlerp(e1.a.p, e1.b.p, (cpFloat const   )tmp___14);
    tmp___16 = cpvmult((cpVect const   )n, e1.r);
    tmp___17 = cpvadd((cpVect const   )tmp___16, (cpVect const   )tmp___15);
    p1___0 = tmp___17;
    tmp___18 = cpfclamp01((d_e1_b - d_e2_a) * e2_denom);
    tmp___19 = cpvlerp(e2.a.p, e2.b.p, (cpFloat const   )tmp___18);
    tmp___20 = cpvmult((cpVect const   )n, - e2.r);
    tmp___21 = cpvadd((cpVect const   )tmp___20, (cpVect const   )tmp___19);
    p2___0 = tmp___21;
    tmp___22 = cpvsub((cpVect const   )p2___0, (cpVect const   )p1___0);
    tmp___23 = cpvdot((cpVect const   )tmp___22, (cpVect const   )n);
    dist___0 = tmp___23;
    if (dist___0 <= (cpFloat )0.0f) {
      hash_1b2a = (cpHashValue )e1.b.hash * 3344921057UL ^ (cpHashValue )e2.a.hash * 3344921057UL;
      cpCollisionInfoPushContact(info, p1___0, p2___0, hash_1b2a);
    }
  }
  return;
}
}
static void CircleToCircle(cpCircleShape const   *c1 , cpCircleShape const   *c2 ,
                           struct cpCollisionInfo *info ) 
{ 
  cpFloat mindist ;
  cpVect delta ;
  cpVect tmp ;
  cpFloat distsq ;
  cpFloat tmp___0 ;
  cpFloat dist ;
  double tmp___1 ;
  cpVect n ;
  cpVect tmp___2 ;
  cpVect tmp___3 ;
  cpVect tmp___4 ;
  cpVect tmp___5 ;
  cpVect tmp___6 ;
  cpVect tmp___7 ;
  cpVect tmp___8 ;

  {
  mindist = (cpFloat )(c1->r + c2->r);
  tmp = cpvsub(c2->tc, c1->tc);
  delta = tmp;
  tmp___0 = cpvlengthsq((cpVect const   )delta);
  distsq = tmp___0;
  if (distsq < mindist * mindist) {
    tmp___1 = sqrt(distsq);
    dist = tmp___1;
    if (dist) {
      tmp___3 = cpvmult((cpVect const   )delta, (cpFloat const   )((cpFloat )1.0f / dist));
      tmp___2 = tmp___3;
    } else {
      tmp___4 = cpv((cpFloat const   )1.0f, (cpFloat const   )0.0f);
      tmp___2 = tmp___4;
    }
    info->n = tmp___2;
    n = tmp___2;
    tmp___5 = cpvmult((cpVect const   )n, - c2->r);
    tmp___6 = cpvadd(c2->tc, (cpVect const   )tmp___5);
    tmp___7 = cpvmult((cpVect const   )n, c1->r);
    tmp___8 = cpvadd(c1->tc, (cpVect const   )tmp___7);
    cpCollisionInfoPushContact(info, tmp___8, tmp___6, (cpHashValue )0);
  }
  return;
}
}
static void CircleToSegment(cpCircleShape const   *circle , cpSegmentShape const   *segment ,
                            struct cpCollisionInfo *info ) 
{ 
  cpVect seg_a ;
  cpVect seg_b ;
  cpVect center ;
  cpVect seg_delta ;
  cpVect tmp ;
  cpFloat closest_t ;
  cpVect tmp___0 ;
  cpFloat tmp___1 ;
  cpFloat tmp___2 ;
  cpFloat tmp___3 ;
  cpVect closest ;
  cpVect tmp___4 ;
  cpVect tmp___5 ;
  cpFloat mindist ;
  cpVect delta ;
  cpVect tmp___6 ;
  cpFloat distsq ;
  cpFloat tmp___7 ;
  cpFloat dist ;
  double tmp___8 ;
  cpVect n ;
  cpVect tmp___9 ;
  cpVect tmp___10 ;
  cpVect rot ;
  cpVect tmp___11 ;
  cpVect tmp___12 ;
  cpVect tmp___13 ;
  cpVect tmp___14 ;
  cpVect tmp___15 ;
  cpVect tmp___16 ;
  cpFloat tmp___17 ;
  cpVect tmp___18 ;
  cpFloat tmp___19 ;

  {
  seg_a = segment->ta;
  seg_b = segment->tb;
  center = circle->tc;
  tmp = cpvsub((cpVect const   )seg_b, (cpVect const   )seg_a);
  seg_delta = tmp;
  tmp___0 = cpvsub((cpVect const   )center, (cpVect const   )seg_a);
  tmp___1 = cpvdot((cpVect const   )seg_delta, (cpVect const   )tmp___0);
  tmp___2 = cpvlengthsq((cpVect const   )seg_delta);
  tmp___3 = cpfclamp01(tmp___1 / tmp___2);
  closest_t = tmp___3;
  tmp___4 = cpvmult((cpVect const   )seg_delta, (cpFloat const   )closest_t);
  tmp___5 = cpvadd((cpVect const   )seg_a, (cpVect const   )tmp___4);
  closest = tmp___5;
  mindist = (cpFloat )(circle->r + segment->r);
  tmp___6 = cpvsub((cpVect const   )closest, (cpVect const   )center);
  delta = tmp___6;
  tmp___7 = cpvlengthsq((cpVect const   )delta);
  distsq = tmp___7;
  if (distsq < mindist * mindist) {
    tmp___8 = sqrt(distsq);
    dist = tmp___8;
    if (dist) {
      tmp___10 = cpvmult((cpVect const   )delta, (cpFloat const   )((cpFloat )1.0f / dist));
      tmp___9 = tmp___10;
    } else {
      tmp___9 = (cpVect )segment->tn;
    }
    info->n = tmp___9;
    n = tmp___9;
    tmp___11 = cpBodyGetRotation((cpBody const   *)segment->shape.body);
    rot = tmp___11;
    if (closest_t != (cpFloat )0.0f) {
      goto _L;
    } else {
      tmp___16 = cpvrotate(segment->a_tangent, (cpVect const   )rot);
      tmp___17 = cpvdot((cpVect const   )n, (cpVect const   )tmp___16);
      if (tmp___17 >= 0.0) {
        _L: /* CIL Label */ 
        if (closest_t != (cpFloat )1.0f) {
          tmp___12 = cpvmult((cpVect const   )n, - segment->r);
          tmp___13 = cpvadd((cpVect const   )closest, (cpVect const   )tmp___12);
          tmp___14 = cpvmult((cpVect const   )n, circle->r);
          tmp___15 = cpvadd((cpVect const   )center, (cpVect const   )tmp___14);
          cpCollisionInfoPushContact(info, tmp___15, tmp___13, (cpHashValue )0);
        } else {
          tmp___18 = cpvrotate(segment->b_tangent, (cpVect const   )rot);
          tmp___19 = cpvdot((cpVect const   )n, (cpVect const   )tmp___18);
          if (tmp___19 >= 0.0) {
            tmp___12 = cpvmult((cpVect const   )n, - segment->r);
            tmp___13 = cpvadd((cpVect const   )closest, (cpVect const   )tmp___12);
            tmp___14 = cpvmult((cpVect const   )n, circle->r);
            tmp___15 = cpvadd((cpVect const   )center, (cpVect const   )tmp___14);
            cpCollisionInfoPushContact(info, tmp___15, tmp___13, (cpHashValue )0);
          }
        }
      }
    }
  }
  return;
}
}
static void SegmentToSegment(cpSegmentShape const   *seg1 , cpSegmentShape const   *seg2 ,
                             struct cpCollisionInfo *info ) 
{ 
  struct SupportContext context ;
  struct ClosestPoints points ;
  struct ClosestPoints tmp ;
  cpVect n ;
  cpVect rot1 ;
  cpVect tmp___0 ;
  cpVect rot2 ;
  cpVect tmp___1 ;
  cpVect tmp___2 ;
  struct Edge tmp___3 ;
  struct Edge tmp___4 ;
  cpBool tmp___5 ;
  cpVect tmp___6 ;
  cpFloat tmp___7 ;
  cpBool tmp___8 ;
  cpVect tmp___9 ;
  cpFloat tmp___10 ;
  cpBool tmp___11 ;
  cpVect tmp___12 ;
  cpFloat tmp___13 ;
  cpBool tmp___14 ;
  cpVect tmp___15 ;
  cpFloat tmp___16 ;

  {
  context.shape1 = (cpShape const   *)((cpShape *)seg1);
  context.shape2 = (cpShape const   *)((cpShape *)seg2);
  context.func1 = (struct SupportPoint (*)(cpShape const   *shape , cpVect const   n ))(& SegmentSupportPoint);
  context.func2 = (struct SupportPoint (*)(cpShape const   *shape , cpVect const   n ))(& SegmentSupportPoint);
  tmp = GJK((struct SupportContext  const  *)(& context), & info->id);
  points = tmp;
  n = points.n;
  tmp___0 = cpBodyGetRotation((cpBody const   *)seg1->shape.body);
  rot1 = tmp___0;
  tmp___1 = cpBodyGetRotation((cpBody const   *)seg2->shape.body);
  rot2 = tmp___1;
  if (points.d <= (cpFloat )(seg1->r + seg2->r)) {
    tmp___5 = cpveql((cpVect const   )points.a, seg1->ta);
    if (tmp___5) {
      tmp___6 = cpvrotate(seg1->a_tangent, (cpVect const   )rot1);
      tmp___7 = cpvdot((cpVect const   )n, (cpVect const   )tmp___6);
      if (tmp___7 <= 0.0) {
        _L___1: /* CIL Label */ 
        tmp___8 = cpveql((cpVect const   )points.a, seg1->tb);
        if (tmp___8) {
          tmp___9 = cpvrotate(seg1->b_tangent, (cpVect const   )rot1);
          tmp___10 = cpvdot((cpVect const   )n, (cpVect const   )tmp___9);
          if (tmp___10 <= 0.0) {
            _L___0: /* CIL Label */ 
            tmp___11 = cpveql((cpVect const   )points.b, seg2->ta);
            if (tmp___11) {
              tmp___12 = cpvrotate(seg2->a_tangent, (cpVect const   )rot2);
              tmp___13 = cpvdot((cpVect const   )n, (cpVect const   )tmp___12);
              if (tmp___13 >= 0.0) {
                _L: /* CIL Label */ 
                tmp___14 = cpveql((cpVect const   )points.b, seg2->tb);
                if (tmp___14) {
                  tmp___15 = cpvrotate(seg2->b_tangent, (cpVect const   )rot2);
                  tmp___16 = cpvdot((cpVect const   )n, (cpVect const   )tmp___15);
                  if (tmp___16 >= 0.0) {
                    tmp___2 = cpvneg((cpVect const   )n);
                    tmp___3 = SupportEdgeForSegment(seg2, (cpVect const   )tmp___2);
                    tmp___4 = SupportEdgeForSegment(seg1, (cpVect const   )n);
                    ContactPoints((struct Edge  const  )tmp___4, (struct Edge  const  )tmp___3,
                                  (struct ClosestPoints  const  )points, info);
                  }
                } else {
                  tmp___2 = cpvneg((cpVect const   )n);
                  tmp___3 = SupportEdgeForSegment(seg2, (cpVect const   )tmp___2);
                  tmp___4 = SupportEdgeForSegment(seg1, (cpVect const   )n);
                  ContactPoints((struct Edge  const  )tmp___4, (struct Edge  const  )tmp___3,
                                (struct ClosestPoints  const  )points, info);
                }
              }
            } else {
              goto _L;
            }
          }
        } else {
          goto _L___0;
        }
      }
    } else {
      goto _L___1;
    }
  }
  return;
}
}
static void PolyToPoly(cpPolyShape const   *poly1 , cpPolyShape const   *poly2 , struct cpCollisionInfo *info ) 
{ 
  struct SupportContext context ;
  struct ClosestPoints points ;
  struct ClosestPoints tmp ;
  cpVect tmp___0 ;
  struct Edge tmp___1 ;
  struct Edge tmp___2 ;

  {
  context.shape1 = (cpShape const   *)((cpShape *)poly1);
  context.shape2 = (cpShape const   *)((cpShape *)poly2);
  context.func1 = (struct SupportPoint (*)(cpShape const   *shape , cpVect const   n ))(& PolySupportPoint);
  context.func2 = (struct SupportPoint (*)(cpShape const   *shape , cpVect const   n ))(& PolySupportPoint);
  tmp = GJK((struct SupportContext  const  *)(& context), & info->id);
  points = tmp;
  if ((points.d - (cpFloat )poly1->r) - (cpFloat )poly2->r <= 0.0) {
    tmp___0 = cpvneg((cpVect const   )points.n);
    tmp___1 = SupportEdgeForPoly(poly2, (cpVect const   )tmp___0);
    tmp___2 = SupportEdgeForPoly(poly1, (cpVect const   )points.n);
    ContactPoints((struct Edge  const  )tmp___2, (struct Edge  const  )tmp___1, (struct ClosestPoints  const  )points,
                  info);
  }
  return;
}
}
static void SegmentToPoly(cpSegmentShape const   *seg___0 , cpPolyShape const   *poly ,
                          struct cpCollisionInfo *info ) 
{ 
  struct SupportContext context ;
  struct ClosestPoints points ;
  struct ClosestPoints tmp ;
  cpVect n ;
  cpVect rot ;
  cpVect tmp___0 ;
  cpVect tmp___1 ;
  struct Edge tmp___2 ;
  struct Edge tmp___3 ;
  cpBool tmp___4 ;
  cpVect tmp___5 ;
  cpFloat tmp___6 ;
  cpBool tmp___7 ;
  cpVect tmp___8 ;
  cpFloat tmp___9 ;

  {
  context.shape1 = (cpShape const   *)((cpShape *)seg___0);
  context.shape2 = (cpShape const   *)((cpShape *)poly);
  context.func1 = (struct SupportPoint (*)(cpShape const   *shape , cpVect const   n ))(& SegmentSupportPoint);
  context.func2 = (struct SupportPoint (*)(cpShape const   *shape , cpVect const   n ))(& PolySupportPoint);
  tmp = GJK((struct SupportContext  const  *)(& context), & info->id);
  points = tmp;
  n = points.n;
  tmp___0 = cpBodyGetRotation((cpBody const   *)seg___0->shape.body);
  rot = tmp___0;
  if ((points.d - (cpFloat )seg___0->r) - (cpFloat )poly->r <= 0.0) {
    tmp___4 = cpveql((cpVect const   )points.a, seg___0->ta);
    if (tmp___4) {
      tmp___5 = cpvrotate(seg___0->a_tangent, (cpVect const   )rot);
      tmp___6 = cpvdot((cpVect const   )n, (cpVect const   )tmp___5);
      if (tmp___6 <= 0.0) {
        _L: /* CIL Label */ 
        tmp___7 = cpveql((cpVect const   )points.a, seg___0->tb);
        if (tmp___7) {
          tmp___8 = cpvrotate(seg___0->b_tangent, (cpVect const   )rot);
          tmp___9 = cpvdot((cpVect const   )n, (cpVect const   )tmp___8);
          if (tmp___9 <= 0.0) {
            tmp___1 = cpvneg((cpVect const   )n);
            tmp___2 = SupportEdgeForPoly(poly, (cpVect const   )tmp___1);
            tmp___3 = SupportEdgeForSegment(seg___0, (cpVect const   )n);
            ContactPoints((struct Edge  const  )tmp___3, (struct Edge  const  )tmp___2,
                          (struct ClosestPoints  const  )points, info);
          }
        } else {
          tmp___1 = cpvneg((cpVect const   )n);
          tmp___2 = SupportEdgeForPoly(poly, (cpVect const   )tmp___1);
          tmp___3 = SupportEdgeForSegment(seg___0, (cpVect const   )n);
          ContactPoints((struct Edge  const  )tmp___3, (struct Edge  const  )tmp___2,
                        (struct ClosestPoints  const  )points, info);
        }
      }
    } else {
      goto _L;
    }
  }
  return;
}
}
static void CircleToPoly(cpCircleShape const   *circle , cpPolyShape const   *poly ,
                         struct cpCollisionInfo *info ) 
{ 
  struct SupportContext context ;
  struct ClosestPoints points ;
  struct ClosestPoints tmp ;
  cpVect n ;
  cpVect tmp___0 ;
  cpVect tmp___1 ;
  cpVect tmp___2 ;
  cpVect tmp___3 ;
  cpVect tmp___4 ;

  {
  context.shape1 = (cpShape const   *)((cpShape *)circle);
  context.shape2 = (cpShape const   *)((cpShape *)poly);
  context.func1 = (struct SupportPoint (*)(cpShape const   *shape , cpVect const   n ))(& CircleSupportPoint);
  context.func2 = (struct SupportPoint (*)(cpShape const   *shape , cpVect const   n ))(& PolySupportPoint);
  tmp = GJK((struct SupportContext  const  *)(& context), & info->id);
  points = tmp;
  if (points.d <= (cpFloat )(circle->r + poly->r)) {
    tmp___0 = points.n;
    info->n = tmp___0;
    n = tmp___0;
    tmp___1 = cpvmult((cpVect const   )n, - poly->r);
    tmp___2 = cpvadd((cpVect const   )points.b, (cpVect const   )tmp___1);
    tmp___3 = cpvmult((cpVect const   )n, circle->r);
    tmp___4 = cpvadd((cpVect const   )points.a, (cpVect const   )tmp___3);
    cpCollisionInfoPushContact(info, tmp___4, tmp___2, (cpHashValue )0);
  }
  return;
}
}
static void CollisionError(cpShape const   *circle , cpShape const   *poly , struct cpCollisionInfo *info ) 
{ 


  {
  cpMessage("cpFalse", "../src/cpCollision.c", 684, 1, 1, "Internal Error: Shape types are not sorted.");
  abort();
}
}
static CollisionFunc const   BuiltinCollisionFuncs[9]  = 
  {      (CollisionFunc const   )((void (*)(cpShape const   *a , cpShape const   *b ,
                                        struct cpCollisionInfo *info ))(& CircleToCircle)),      (CollisionFunc const   )(& CollisionError),      (CollisionFunc const   )(& CollisionError),      (CollisionFunc const   )((void (*)(cpShape const   *a ,
                                        cpShape const   *b , struct cpCollisionInfo *info ))(& CircleToSegment)), 
        (CollisionFunc const   )((void (*)(cpShape const   *a ,
                                        cpShape const   *b , struct cpCollisionInfo *info ))(& SegmentToSegment)),      (CollisionFunc const   )(& CollisionError),      (CollisionFunc const   )((void (*)(cpShape const   *a ,
                                        cpShape const   *b , struct cpCollisionInfo *info ))(& CircleToPoly)),      (CollisionFunc const   )((void (*)(cpShape const   *a ,
                                        cpShape const   *b , struct cpCollisionInfo *info ))(& SegmentToPoly)), 
        (CollisionFunc const   )((void (*)(cpShape const   *a ,
                                        cpShape const   *b , struct cpCollisionInfo *info ))(& PolyToPoly))};
static CollisionFunc const   *CollisionFuncs  =    BuiltinCollisionFuncs;
struct cpCollisionInfo cpCollide(cpShape const   *a ,
                                 cpShape const   *b , cpCollisionID id , struct cpContact *contacts ) 
{ 
  struct cpCollisionInfo info ;

  {
  info.a = a;
  info.b = b;
  info.id = id;
  info.n = cpvzero___2;
  info.count = 0;
  info.arr = contacts;
  if ((unsigned int const   )(a->klass)->type > (unsigned int const   )(b->klass)->type) {
    info.a = b;
    info.b = a;
  }
  (*(*(CollisionFuncs + ((unsigned int const   )((info.a)->klass)->type + (unsigned int const   )((info.b)->klass)->type * 3U))))(info.a,
                                                                                                                                  info.b,
                                                                                                                                  & info);
  return (info);
}
}
#pragma merger("0","/tmp/cil-tpOaDDUp.i","-std=gnu99,-ffast-math,-fPIC")
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
void cpConstraintDestroy(cpConstraint *constraint ) ;
void cpConstraintFree(cpConstraint *constraint ) ;
cpSpace *cpConstraintGetSpace(cpConstraint const   *constraint ) ;
cpBody *cpConstraintGetBodyA(cpConstraint const   *constraint ) ;
cpBody *cpConstraintGetBodyB(cpConstraint const   *constraint ) ;
cpFloat cpConstraintGetMaxForce(cpConstraint const   *constraint ) ;
void cpConstraintSetMaxForce(cpConstraint *constraint , cpFloat maxForce ) ;
cpFloat cpConstraintGetErrorBias(cpConstraint const   *constraint ) ;
void cpConstraintSetErrorBias(cpConstraint *constraint , cpFloat errorBias ) ;
cpFloat cpConstraintGetMaxBias(cpConstraint const   *constraint ) ;
void cpConstraintSetMaxBias(cpConstraint *constraint , cpFloat maxBias ) ;
cpBool cpConstraintGetCollideBodies(cpConstraint const   *constraint ) ;
void cpConstraintSetCollideBodies(cpConstraint *constraint , cpBool collideBodies ) ;
cpConstraintPreSolveFunc cpConstraintGetPreSolveFunc(cpConstraint const   *constraint ) ;
void cpConstraintSetPreSolveFunc(cpConstraint *constraint , void (*preSolveFunc)(cpConstraint *constraint ,
                                                                                 cpSpace *space ) ) ;
cpConstraintPostSolveFunc cpConstraintGetPostSolveFunc(cpConstraint const   *constraint ) ;
void cpConstraintSetPostSolveFunc(cpConstraint *constraint , void (*postSolveFunc)(cpConstraint *constraint ,
                                                                                   cpSpace *space ) ) ;
cpDataPointer cpConstraintGetUserData(cpConstraint const   *constraint ) ;
void cpConstraintSetUserData(cpConstraint *constraint , cpDataPointer userData ) ;
cpFloat cpConstraintGetImpulse(cpConstraint *constraint ) ;
void cpConstraintInit(cpConstraint *constraint , struct cpConstraintClass  const  *klass___12 ,
                      cpBody *a , cpBody *b ) ;
__inline static void cpConstraintActivateBodies(cpConstraint *constraint ) 
{ 
  cpBody *a ;
  cpBody *b ;

  {
  a = constraint->a;
  cpBodyActivate(a);
  b = constraint->b;
  cpBodyActivate(b);
  return;
}
}
void cpConstraintDestroy(cpConstraint *constraint ) 
{ 


  {
  return;
}
}
void cpConstraintFree(cpConstraint *constraint ) 
{ 


  {
  if (constraint) {
    cpConstraintDestroy(constraint);
    free((void *)constraint);
  }
  return;
}
}
void cpConstraintInit(cpConstraint *constraint , struct cpConstraintClass  const  *klass___12 ,
                      cpBody *a , cpBody *b ) 
{ 
  float tmp ;
  float tmp___0 ;

  {
  constraint->klass = klass___12;
  constraint->a = a;
  constraint->b = b;
  constraint->space = (cpSpace *)((void *)0);
  constraint->next_a = (cpConstraint *)((void *)0);
  constraint->next_b = (cpConstraint *)((void *)0);
  tmp = __builtin_inff();
  constraint->maxForce = (cpFloat )tmp;
  constraint->errorBias = pow((double )(1.0f - 0.1f), (double )60.0f);
  tmp___0 = __builtin_inff();
  constraint->maxBias = (cpFloat )tmp___0;
  constraint->collideBodies = (cpBool )1;
  constraint->preSolve = (void (*)(cpConstraint *constraint , cpSpace *space ))((void *)0);
  constraint->postSolve = (void (*)(cpConstraint *constraint , cpSpace *space ))((void *)0);
  return;
}
}
cpSpace *cpConstraintGetSpace(cpConstraint const   *constraint ) 
{ 


  {
  return ((cpSpace *)constraint->space);
}
}
cpBody *cpConstraintGetBodyA(cpConstraint const   *constraint ) 
{ 


  {
  return ((cpBody *)constraint->a);
}
}
cpBody *cpConstraintGetBodyB(cpConstraint const   *constraint ) 
{ 


  {
  return ((cpBody *)constraint->b);
}
}
cpFloat cpConstraintGetMaxForce(cpConstraint const   *constraint ) 
{ 


  {
  return ((cpFloat )constraint->maxForce);
}
}
void cpConstraintSetMaxForce(cpConstraint *constraint , cpFloat maxForce ) 
{ 


  {
  if (! (maxForce >= (cpFloat )0.0f)) {
    cpMessage("maxForce >= 0.0f", "../src/cpConstraint.c", 86, 1, 1, "maxForce must be positive.");
    abort();
  }
  cpConstraintActivateBodies(constraint);
  constraint->maxForce = maxForce;
  return;
}
}
cpFloat cpConstraintGetErrorBias(cpConstraint const   *constraint ) 
{ 


  {
  return ((cpFloat )constraint->errorBias);
}
}
void cpConstraintSetErrorBias(cpConstraint *constraint , cpFloat errorBias ) 
{ 


  {
  if (! (errorBias >= (cpFloat )0.0f)) {
    cpMessage("errorBias >= 0.0f", "../src/cpConstraint.c", 100, 1, 1, "errorBias must be positive.");
    abort();
  }
  cpConstraintActivateBodies(constraint);
  constraint->errorBias = errorBias;
  return;
}
}
cpFloat cpConstraintGetMaxBias(cpConstraint const   *constraint ) 
{ 


  {
  return ((cpFloat )constraint->maxBias);
}
}
void cpConstraintSetMaxBias(cpConstraint *constraint , cpFloat maxBias ) 
{ 


  {
  if (! (maxBias >= (cpFloat )0.0f)) {
    cpMessage("maxBias >= 0.0f", "../src/cpConstraint.c", 114, 1, 1, "maxBias must be positive.");
    abort();
  }
  cpConstraintActivateBodies(constraint);
  constraint->maxBias = maxBias;
  return;
}
}
cpBool cpConstraintGetCollideBodies(cpConstraint const   *constraint ) 
{ 


  {
  return ((cpBool )constraint->collideBodies);
}
}
void cpConstraintSetCollideBodies(cpConstraint *constraint , cpBool collideBodies ) 
{ 


  {
  cpConstraintActivateBodies(constraint);
  constraint->collideBodies = collideBodies;
  return;
}
}
cpConstraintPreSolveFunc cpConstraintGetPreSolveFunc(cpConstraint const   *constraint ) 
{ 


  {
  return ((cpConstraintPreSolveFunc )constraint->preSolve);
}
}
void cpConstraintSetPreSolveFunc(cpConstraint *constraint , void (*preSolveFunc)(cpConstraint *constraint ,
                                                                                 cpSpace *space ) ) 
{ 


  {
  constraint->preSolve = preSolveFunc;
  return;
}
}
cpConstraintPostSolveFunc cpConstraintGetPostSolveFunc(cpConstraint const   *constraint ) 
{ 


  {
  return ((cpConstraintPostSolveFunc )constraint->postSolve);
}
}
void cpConstraintSetPostSolveFunc(cpConstraint *constraint , void (*postSolveFunc)(cpConstraint *constraint ,
                                                                                   cpSpace *space ) ) 
{ 


  {
  constraint->postSolve = postSolveFunc;
  return;
}
}
cpDataPointer cpConstraintGetUserData(cpConstraint const   *constraint ) 
{ 


  {
  return ((cpDataPointer )constraint->userData);
}
}
void cpConstraintSetUserData(cpConstraint *constraint , cpDataPointer userData ) 
{ 


  {
  constraint->userData = userData;
  return;
}
}
cpFloat cpConstraintGetImpulse(cpConstraint *constraint ) 
{ 
  cpFloat tmp ;

  {
  tmp = (*((constraint->klass)->getImpulse))(constraint);
  return (tmp);
}
}
#pragma merger("0","/tmp/cil-EE2REOUu.i","-std=gnu99,-ffast-math,-fPIC")
extern  __attribute__((__nothrow__)) double exp(double __x ) ;
cpBool cpConstraintIsDampedRotarySpring(cpConstraint const   *constraint ) ;
cpDampedRotarySpring *cpDampedRotarySpringAlloc(void) ;
cpDampedRotarySpring *cpDampedRotarySpringInit(cpDampedRotarySpring *spring , cpBody *a ,
                                               cpBody *b , cpFloat restAngle , cpFloat stiffness ,
                                               cpFloat damping ) ;
cpConstraint *cpDampedRotarySpringNew(cpBody *a , cpBody *b , cpFloat restAngle ,
                                      cpFloat stiffness , cpFloat damping ) ;
cpFloat cpDampedRotarySpringGetRestAngle(cpConstraint const   *constraint ) ;
void cpDampedRotarySpringSetRestAngle(cpConstraint *constraint , cpFloat restAngle ) ;
cpFloat cpDampedRotarySpringGetStiffness(cpConstraint const   *constraint ) ;
void cpDampedRotarySpringSetStiffness(cpConstraint *constraint , cpFloat stiffness ) ;
cpFloat cpDampedRotarySpringGetDamping(cpConstraint const   *constraint ) ;
void cpDampedRotarySpringSetDamping(cpConstraint *constraint , cpFloat damping ) ;
cpDampedRotarySpringTorqueFunc cpDampedRotarySpringGetSpringTorqueFunc(cpConstraint const   *constraint ) ;
void cpDampedRotarySpringSetSpringTorqueFunc(cpConstraint *constraint , cpFloat (*springTorqueFunc)(struct cpConstraint *spring ,
                                                                                                    cpFloat relativeAngle ) ) ;
static cpFloat defaultSpringTorque(cpDampedRotarySpring *spring , cpFloat relativeAngle ) 
{ 


  {
  return ((relativeAngle - spring->restAngle) * spring->stiffness);
}
}
static void preStep(cpDampedRotarySpring *spring , cpFloat dt ) 
{ 
  cpBody *a ;
  cpBody *b ;
  cpFloat moment ;
  double tmp ;
  cpFloat j_spring ;
  cpFloat tmp___0 ;

  {
  a = spring->constraint.a;
  b = spring->constraint.b;
  moment = a->i_inv + b->i_inv;
  spring->iSum = (cpFloat )1.0f / moment;
  tmp = exp((- spring->damping * dt) * moment);
  spring->w_coef = (double )1.0f - tmp;
  spring->target_wrn = (cpFloat )0.0f;
  tmp___0 = (*(spring->springTorqueFunc))((cpConstraint *)spring, a->a - b->a);
  j_spring = tmp___0 * dt;
  spring->jAcc = j_spring;
  a->w -= j_spring * a->i_inv;
  b->w += j_spring * b->i_inv;
  return;
}
}
static void applyCachedImpulse(cpDampedRotarySpring *spring , cpFloat dt_coef ) 
{ 


  {
  return;
}
}
static void applyImpulse(cpDampedRotarySpring *spring , cpFloat dt ) 
{ 
  cpBody *a ;
  cpBody *b ;
  cpFloat wrn ;
  cpFloat w_damp ;
  cpFloat j_damp ;

  {
  a = spring->constraint.a;
  b = spring->constraint.b;
  wrn = a->w - b->w;
  w_damp = (spring->target_wrn - wrn) * spring->w_coef;
  spring->target_wrn = wrn + w_damp;
  j_damp = w_damp * spring->iSum;
  spring->jAcc += j_damp;
  a->w += j_damp * a->i_inv;
  b->w -= j_damp * b->i_inv;
  return;
}
}
static cpFloat getImpulse(cpDampedRotarySpring *spring ) 
{ 


  {
  return (spring->jAcc);
}
}
static struct cpConstraintClass  const  klass___0  =    {(void (*)(cpConstraint *constraint , cpFloat dt ))(& preStep), (void (*)(cpConstraint *constraint ,
                                                                             cpFloat dt_coef ))(& applyCachedImpulse),
    (void (*)(cpConstraint *constraint , cpFloat dt ))(& applyImpulse), (cpFloat (*)(cpConstraint *constraint ))(& getImpulse)};
cpDampedRotarySpring *cpDampedRotarySpringAlloc(void) 
{ 
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(cpDampedRotarySpring ));
  return ((cpDampedRotarySpring *)tmp);
}
}
cpDampedRotarySpring *cpDampedRotarySpringInit(cpDampedRotarySpring *spring , cpBody *a ,
                                               cpBody *b , cpFloat restAngle , cpFloat stiffness ,
                                               cpFloat damping ) 
{ 


  {
  cpConstraintInit((cpConstraint *)spring, & klass___0, a, b);
  spring->restAngle = restAngle;
  spring->stiffness = stiffness;
  spring->damping = damping;
  spring->springTorqueFunc = (cpFloat (*)(struct cpConstraint *spring , cpFloat relativeAngle ))(& defaultSpringTorque);
  spring->jAcc = (cpFloat )0.0f;
  return (spring);
}
}
cpConstraint *cpDampedRotarySpringNew(cpBody *a , cpBody *b , cpFloat restAngle ,
                                      cpFloat stiffness , cpFloat damping ) 
{ 
  cpDampedRotarySpring *tmp ;
  cpDampedRotarySpring *tmp___0 ;

  {
  tmp = cpDampedRotarySpringAlloc();
  tmp___0 = cpDampedRotarySpringInit(tmp, a, b, restAngle, stiffness, damping);
  return ((cpConstraint *)tmp___0);
}
}
cpBool cpConstraintIsDampedRotarySpring(cpConstraint const   *constraint ) 
{ 


  {
  return ((cpBool )((unsigned long )constraint->klass == (unsigned long )(& klass___0)));
}
}
cpFloat cpDampedRotarySpringGetRestAngle(cpConstraint const   *constraint ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsDampedRotarySpring(constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsDampedRotarySpring(constraint)", "../src/cpDampedRotarySpring.c",
              123, 1, 1, "Constraint is not a damped rotary spring.");
    abort();
  }
  return (((cpDampedRotarySpring *)constraint)->restAngle);
}
}
void cpDampedRotarySpringSetRestAngle(cpConstraint *constraint , cpFloat restAngle ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsDampedRotarySpring((cpConstraint const   *)constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsDampedRotarySpring(constraint)", "../src/cpDampedRotarySpring.c",
              130, 1, 1, "Constraint is not a damped rotary spring.");
    abort();
  }
  cpConstraintActivateBodies(constraint);
  ((cpDampedRotarySpring *)constraint)->restAngle = restAngle;
  return;
}
}
cpFloat cpDampedRotarySpringGetStiffness(cpConstraint const   *constraint ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsDampedRotarySpring(constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsDampedRotarySpring(constraint)", "../src/cpDampedRotarySpring.c",
              138, 1, 1, "Constraint is not a damped rotary spring.");
    abort();
  }
  return (((cpDampedRotarySpring *)constraint)->stiffness);
}
}
void cpDampedRotarySpringSetStiffness(cpConstraint *constraint , cpFloat stiffness ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsDampedRotarySpring((cpConstraint const   *)constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsDampedRotarySpring(constraint)", "../src/cpDampedRotarySpring.c",
              145, 1, 1, "Constraint is not a damped rotary spring.");
    abort();
  }
  cpConstraintActivateBodies(constraint);
  ((cpDampedRotarySpring *)constraint)->stiffness = stiffness;
  return;
}
}
cpFloat cpDampedRotarySpringGetDamping(cpConstraint const   *constraint ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsDampedRotarySpring(constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsDampedRotarySpring(constraint)", "../src/cpDampedRotarySpring.c",
              153, 1, 1, "Constraint is not a damped rotary spring.");
    abort();
  }
  return (((cpDampedRotarySpring *)constraint)->damping);
}
}
void cpDampedRotarySpringSetDamping(cpConstraint *constraint , cpFloat damping ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsDampedRotarySpring((cpConstraint const   *)constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsDampedRotarySpring(constraint)", "../src/cpDampedRotarySpring.c",
              160, 1, 1, "Constraint is not a damped rotary spring.");
    abort();
  }
  cpConstraintActivateBodies(constraint);
  ((cpDampedRotarySpring *)constraint)->damping = damping;
  return;
}
}
cpDampedRotarySpringTorqueFunc cpDampedRotarySpringGetSpringTorqueFunc(cpConstraint const   *constraint ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsDampedRotarySpring(constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsDampedRotarySpring(constraint)", "../src/cpDampedRotarySpring.c",
              168, 1, 1, "Constraint is not a damped rotary spring.");
    abort();
  }
  return (((cpDampedRotarySpring *)constraint)->springTorqueFunc);
}
}
void cpDampedRotarySpringSetSpringTorqueFunc(cpConstraint *constraint , cpFloat (*springTorqueFunc)(struct cpConstraint *spring ,
                                                                                                    cpFloat relativeAngle ) ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsDampedRotarySpring((cpConstraint const   *)constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsDampedRotarySpring(constraint)", "../src/cpDampedRotarySpring.c",
              175, 1, 1, "Constraint is not a damped rotary spring.");
    abort();
  }
  cpConstraintActivateBodies(constraint);
  ((cpDampedRotarySpring *)constraint)->springTorqueFunc = springTorqueFunc;
  return;
}
}
#pragma merger("0","/tmp/cil-TvU2C9S4.i","-std=gnu99,-ffast-math,-fPIC")
cpBool cpConstraintIsDampedSpring(cpConstraint const   *constraint ) ;
cpDampedSpring *cpDampedSpringAlloc(void) ;
cpDampedSpring *cpDampedSpringInit(cpDampedSpring *spring , cpBody *a , cpBody *b ,
                                   cpVect anchorA , cpVect anchorB , cpFloat restLength ,
                                   cpFloat stiffness , cpFloat damping ) ;
cpConstraint *cpDampedSpringNew(cpBody *a , cpBody *b , cpVect anchorA , cpVect anchorB ,
                                cpFloat restLength , cpFloat stiffness , cpFloat damping ) ;
cpVect cpDampedSpringGetAnchorA(cpConstraint const   *constraint ) ;
void cpDampedSpringSetAnchorA(cpConstraint *constraint , cpVect anchorA ) ;
cpVect cpDampedSpringGetAnchorB(cpConstraint const   *constraint ) ;
void cpDampedSpringSetAnchorB(cpConstraint *constraint , cpVect anchorB ) ;
cpFloat cpDampedSpringGetRestLength(cpConstraint const   *constraint ) ;
void cpDampedSpringSetRestLength(cpConstraint *constraint , cpFloat restLength ) ;
cpFloat cpDampedSpringGetStiffness(cpConstraint const   *constraint ) ;
void cpDampedSpringSetStiffness(cpConstraint *constraint , cpFloat stiffness ) ;
cpFloat cpDampedSpringGetDamping(cpConstraint const   *constraint ) ;
void cpDampedSpringSetDamping(cpConstraint *constraint , cpFloat damping ) ;
cpDampedSpringForceFunc cpDampedSpringGetSpringForceFunc(cpConstraint const   *constraint ) ;
void cpDampedSpringSetSpringForceFunc(cpConstraint *constraint , cpFloat (*springForceFunc)(cpConstraint *spring ,
                                                                                            cpFloat dist ) ) ;
static cpFloat defaultSpringForce(cpDampedSpring *spring , cpFloat dist ) 
{ 


  {
  return ((spring->restLength - dist) * spring->stiffness);
}
}
static void preStep___0(cpDampedSpring *spring , cpFloat dt ) 
{ 
  cpBody *a ;
  cpBody *b ;
  cpVect tmp ;
  cpVect tmp___0 ;
  cpVect delta ;
  cpVect tmp___1 ;
  cpVect tmp___2 ;
  cpVect tmp___3 ;
  cpFloat dist ;
  cpFloat tmp___4 ;
  float tmp___5 ;
  cpFloat tmp___6 ;
  cpFloat k ;
  cpFloat tmp___7 ;
  double tmp___8 ;
  cpFloat f_spring ;
  cpFloat tmp___9 ;
  cpFloat j_spring ;
  cpFloat tmp___10 ;
  cpVect tmp___11 ;

  {
  a = spring->constraint.a;
  b = spring->constraint.b;
  tmp = cpvsub((cpVect const   )spring->anchorA, (cpVect const   )a->cog);
  spring->r1 = cpTransformVect(a->transform, tmp);
  tmp___0 = cpvsub((cpVect const   )spring->anchorB, (cpVect const   )b->cog);
  spring->r2 = cpTransformVect(b->transform, tmp___0);
  tmp___1 = cpvadd((cpVect const   )a->p, (cpVect const   )spring->r1);
  tmp___2 = cpvadd((cpVect const   )b->p, (cpVect const   )spring->r2);
  tmp___3 = cpvsub((cpVect const   )tmp___2, (cpVect const   )tmp___1);
  delta = tmp___3;
  tmp___4 = cpvlength((cpVect const   )delta);
  dist = tmp___4;
  if (dist) {
    tmp___6 = dist;
  } else {
    tmp___5 = __builtin_inff();
    tmp___6 = (cpFloat )tmp___5;
  }
  spring->n = cpvmult((cpVect const   )delta, (cpFloat const   )((cpFloat )1.0f / tmp___6));
  tmp___7 = k_scalar(a, b, spring->r1, spring->r2, spring->n);
  k = tmp___7;
  spring->nMass = (cpFloat )1.0f / k;
  spring->target_vrn = (cpFloat )0.0f;
  tmp___8 = exp((- spring->damping * dt) * k);
  spring->v_coef = (double )1.0f - tmp___8;
  tmp___9 = (*(spring->springForceFunc))((cpConstraint *)spring, dist);
  f_spring = tmp___9;
  tmp___10 = f_spring * dt;
  spring->jAcc = tmp___10;
  j_spring = tmp___10;
  tmp___11 = cpvmult((cpVect const   )spring->n, (cpFloat const   )j_spring);
  apply_impulses(a, b, spring->r1, spring->r2, tmp___11);
  return;
}
}
static void applyCachedImpulse___0(cpDampedSpring *spring , cpFloat dt_coef ) 
{ 


  {
  return;
}
}
static void applyImpulse___0(cpDampedSpring *spring , cpFloat dt ) 
{ 
  cpBody *a ;
  cpBody *b ;
  cpVect n ;
  cpVect r1 ;
  cpVect r2 ;
  cpFloat vrn ;
  cpFloat tmp ;
  cpFloat v_damp ;
  cpFloat j_damp ;
  cpVect tmp___0 ;

  {
  a = spring->constraint.a;
  b = spring->constraint.b;
  n = spring->n;
  r1 = spring->r1;
  r2 = spring->r2;
  tmp = normal_relative_velocity(a, b, r1, r2, n);
  vrn = tmp;
  v_damp = (spring->target_vrn - vrn) * spring->v_coef;
  spring->target_vrn = vrn + v_damp;
  j_damp = v_damp * spring->nMass;
  spring->jAcc += j_damp;
  tmp___0 = cpvmult((cpVect const   )spring->n, (cpFloat const   )j_damp);
  apply_impulses(a, b, spring->r1, spring->r2, tmp___0);
  return;
}
}
static cpFloat getImpulse___0(cpDampedSpring *spring ) 
{ 


  {
  return (spring->jAcc);
}
}
static struct cpConstraintClass  const  klass___1  =    {(void (*)(cpConstraint *constraint , cpFloat dt ))(& preStep___0), (void (*)(cpConstraint *constraint ,
                                                                                 cpFloat dt_coef ))(& applyCachedImpulse___0),
    (void (*)(cpConstraint *constraint , cpFloat dt ))(& applyImpulse___0), (cpFloat (*)(cpConstraint *constraint ))(& getImpulse___0)};
cpDampedSpring *cpDampedSpringAlloc(void) 
{ 
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(cpDampedSpring ));
  return ((cpDampedSpring *)tmp);
}
}
cpDampedSpring *cpDampedSpringInit(cpDampedSpring *spring , cpBody *a , cpBody *b ,
                                   cpVect anchorA , cpVect anchorB , cpFloat restLength ,
                                   cpFloat stiffness , cpFloat damping ) 
{ 


  {
  cpConstraintInit((cpConstraint *)spring, & klass___1, a, b);
  spring->anchorA = anchorA;
  spring->anchorB = anchorB;
  spring->restLength = restLength;
  spring->stiffness = stiffness;
  spring->damping = damping;
  spring->springForceFunc = (cpFloat (*)(cpConstraint *spring , cpFloat dist ))(& defaultSpringForce);
  spring->jAcc = (cpFloat )0.0f;
  return (spring);
}
}
cpConstraint *cpDampedSpringNew(cpBody *a , cpBody *b , cpVect anchorA , cpVect anchorB ,
                                cpFloat restLength , cpFloat stiffness , cpFloat damping ) 
{ 
  cpDampedSpring *tmp ;
  cpDampedSpring *tmp___0 ;

  {
  tmp = cpDampedSpringAlloc();
  tmp___0 = cpDampedSpringInit(tmp, a, b, anchorA, anchorB, restLength, stiffness,
                               damping);
  return ((cpConstraint *)tmp___0);
}
}
cpBool cpConstraintIsDampedSpring(cpConstraint const   *constraint ) 
{ 


  {
  return ((cpBool )((unsigned long )constraint->klass == (unsigned long )(& klass___1)));
}
}
cpVect cpDampedSpringGetAnchorA(cpConstraint const   *constraint ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsDampedSpring(constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsDampedSpring(constraint)", "../src/cpDampedSpring.c",
              131, 1, 1, "Constraint is not a damped spring.");
    abort();
  }
  return (((cpDampedSpring *)constraint)->anchorA);
}
}
void cpDampedSpringSetAnchorA(cpConstraint *constraint , cpVect anchorA ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsDampedSpring((cpConstraint const   *)constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsDampedSpring(constraint)", "../src/cpDampedSpring.c",
              138, 1, 1, "Constraint is not a damped spring.");
    abort();
  }
  cpConstraintActivateBodies(constraint);
  ((cpDampedSpring *)constraint)->anchorA = anchorA;
  return;
}
}
cpVect cpDampedSpringGetAnchorB(cpConstraint const   *constraint ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsDampedSpring(constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsDampedSpring(constraint)", "../src/cpDampedSpring.c",
              146, 1, 1, "Constraint is not a damped spring.");
    abort();
  }
  return (((cpDampedSpring *)constraint)->anchorB);
}
}
void cpDampedSpringSetAnchorB(cpConstraint *constraint , cpVect anchorB ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsDampedSpring((cpConstraint const   *)constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsDampedSpring(constraint)", "../src/cpDampedSpring.c",
              153, 1, 1, "Constraint is not a damped spring.");
    abort();
  }
  cpConstraintActivateBodies(constraint);
  ((cpDampedSpring *)constraint)->anchorB = anchorB;
  return;
}
}
cpFloat cpDampedSpringGetRestLength(cpConstraint const   *constraint ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsDampedSpring(constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsDampedSpring(constraint)", "../src/cpDampedSpring.c",
              161, 1, 1, "Constraint is not a damped spring.");
    abort();
  }
  return (((cpDampedSpring *)constraint)->restLength);
}
}
void cpDampedSpringSetRestLength(cpConstraint *constraint , cpFloat restLength ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsDampedSpring((cpConstraint const   *)constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsDampedSpring(constraint)", "../src/cpDampedSpring.c",
              168, 1, 1, "Constraint is not a damped spring.");
    abort();
  }
  cpConstraintActivateBodies(constraint);
  ((cpDampedSpring *)constraint)->restLength = restLength;
  return;
}
}
cpFloat cpDampedSpringGetStiffness(cpConstraint const   *constraint ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsDampedSpring(constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsDampedSpring(constraint)", "../src/cpDampedSpring.c",
              176, 1, 1, "Constraint is not a damped spring.");
    abort();
  }
  return (((cpDampedSpring *)constraint)->stiffness);
}
}
void cpDampedSpringSetStiffness(cpConstraint *constraint , cpFloat stiffness ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsDampedSpring((cpConstraint const   *)constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsDampedSpring(constraint)", "../src/cpDampedSpring.c",
              183, 1, 1, "Constraint is not a damped spring.");
    abort();
  }
  cpConstraintActivateBodies(constraint);
  ((cpDampedSpring *)constraint)->stiffness = stiffness;
  return;
}
}
cpFloat cpDampedSpringGetDamping(cpConstraint const   *constraint ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsDampedSpring(constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsDampedSpring(constraint)", "../src/cpDampedSpring.c",
              191, 1, 1, "Constraint is not a damped spring.");
    abort();
  }
  return (((cpDampedSpring *)constraint)->damping);
}
}
void cpDampedSpringSetDamping(cpConstraint *constraint , cpFloat damping ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsDampedSpring((cpConstraint const   *)constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsDampedSpring(constraint)", "../src/cpDampedSpring.c",
              198, 1, 1, "Constraint is not a damped spring.");
    abort();
  }
  cpConstraintActivateBodies(constraint);
  ((cpDampedSpring *)constraint)->damping = damping;
  return;
}
}
cpDampedSpringForceFunc cpDampedSpringGetSpringForceFunc(cpConstraint const   *constraint ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsDampedSpring(constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsDampedSpring(constraint)", "../src/cpDampedSpring.c",
              206, 1, 1, "Constraint is not a damped spring.");
    abort();
  }
  return (((cpDampedSpring *)constraint)->springForceFunc);
}
}
void cpDampedSpringSetSpringForceFunc(cpConstraint *constraint , cpFloat (*springForceFunc)(cpConstraint *spring ,
                                                                                            cpFloat dist ) ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsDampedSpring((cpConstraint const   *)constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsDampedSpring(constraint)", "../src/cpDampedSpring.c",
              213, 1, 1, "Constraint is not a damped spring.");
    abort();
  }
  cpConstraintActivateBodies(constraint);
  ((cpDampedSpring *)constraint)->springForceFunc = springForceFunc;
  return;
}
}
#pragma merger("0","/tmp/cil-85MaMWqy.i","-std=gnu99,-ffast-math,-fPIC")
cpBool cpConstraintIsGearJoint(cpConstraint const   *constraint ) ;
cpGearJoint *cpGearJointAlloc(void) ;
cpGearJoint *cpGearJointInit(cpGearJoint *joint , cpBody *a , cpBody *b , cpFloat phase ,
                             cpFloat ratio ) ;
cpConstraint *cpGearJointNew(cpBody *a , cpBody *b , cpFloat phase , cpFloat ratio ) ;
cpFloat cpGearJointGetPhase(cpConstraint const   *constraint ) ;
void cpGearJointSetPhase(cpConstraint *constraint , cpFloat phase ) ;
cpFloat cpGearJointGetRatio(cpConstraint const   *constraint ) ;
void cpGearJointSetRatio(cpConstraint *constraint , cpFloat ratio ) ;
__inline static cpFloat bias_coef(cpFloat errorBias , cpFloat dt ) 
{ 
  double tmp ;

  {
  tmp = pow(errorBias, dt);
  return ((double )1.0f - tmp);
}
}
static void preStep___1(cpGearJoint *joint , cpFloat dt ) 
{ 
  cpBody *a ;
  cpBody *b ;
  cpFloat maxBias ;
  cpFloat tmp ;

  {
  a = joint->constraint.a;
  b = joint->constraint.b;
  joint->iSum = (cpFloat )1.0f / (a->i_inv * joint->ratio_inv + joint->ratio * b->i_inv);
  maxBias = joint->constraint.maxBias;
  tmp = bias_coef(joint->constraint.errorBias, dt);
  joint->bias = cpfclamp((- tmp * ((b->a * joint->ratio - a->a) - joint->phase)) / dt,
                         - maxBias, maxBias);
  return;
}
}
static void applyCachedImpulse___1(cpGearJoint *joint , cpFloat dt_coef ) 
{ 
  cpBody *a ;
  cpBody *b ;
  cpFloat j ;

  {
  a = joint->constraint.a;
  b = joint->constraint.b;
  j = joint->jAcc * dt_coef;
  a->w -= (j * a->i_inv) * joint->ratio_inv;
  b->w += j * b->i_inv;
  return;
}
}
static void applyImpulse___1(cpGearJoint *joint , cpFloat dt ) 
{ 
  cpBody *a ;
  cpBody *b ;
  cpFloat wr ;
  cpFloat jMax ;
  cpFloat j ;
  cpFloat jOld ;

  {
  a = joint->constraint.a;
  b = joint->constraint.b;
  wr = b->w * joint->ratio - a->w;
  jMax = joint->constraint.maxForce * dt;
  j = (joint->bias - wr) * joint->iSum;
  jOld = joint->jAcc;
  joint->jAcc = cpfclamp(jOld + j, - jMax, jMax);
  j = joint->jAcc - jOld;
  a->w -= (j * a->i_inv) * joint->ratio_inv;
  b->w += j * b->i_inv;
  return;
}
}
static cpFloat getImpulse___1(cpGearJoint *joint ) 
{ 
  cpFloat tmp ;

  {
  tmp = cpfabs(joint->jAcc);
  return (tmp);
}
}
static struct cpConstraintClass  const  klass___2  =    {(void (*)(cpConstraint *constraint , cpFloat dt ))(& preStep___1), (void (*)(cpConstraint *constraint ,
                                                                                 cpFloat dt_coef ))(& applyCachedImpulse___1),
    (void (*)(cpConstraint *constraint , cpFloat dt ))(& applyImpulse___1), (cpFloat (*)(cpConstraint *constraint ))(& getImpulse___1)};
cpGearJoint *cpGearJointAlloc(void) 
{ 
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(cpGearJoint ));
  return ((cpGearJoint *)tmp);
}
}
cpGearJoint *cpGearJointInit(cpGearJoint *joint , cpBody *a , cpBody *b , cpFloat phase ,
                             cpFloat ratio ) 
{ 


  {
  cpConstraintInit((cpConstraint *)joint, & klass___2, a, b);
  joint->phase = phase;
  joint->ratio = ratio;
  joint->ratio_inv = (cpFloat )1.0f / ratio;
  joint->jAcc = (cpFloat )0.0f;
  return (joint);
}
}
cpConstraint *cpGearJointNew(cpBody *a , cpBody *b , cpFloat phase , cpFloat ratio ) 
{ 
  cpGearJoint *tmp ;
  cpGearJoint *tmp___0 ;

  {
  tmp = cpGearJointAlloc();
  tmp___0 = cpGearJointInit(tmp, a, b, phase, ratio);
  return ((cpConstraint *)tmp___0);
}
}
cpBool cpConstraintIsGearJoint(cpConstraint const   *constraint ) 
{ 


  {
  return ((cpBool )((unsigned long )constraint->klass == (unsigned long )(& klass___2)));
}
}
cpFloat cpGearJointGetPhase(cpConstraint const   *constraint ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsGearJoint(constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsGearJoint(constraint)", "../src/cpGearJoint.c", 119,
              1, 1, "Constraint is not a ratchet joint.");
    abort();
  }
  return (((cpGearJoint *)constraint)->phase);
}
}
void cpGearJointSetPhase(cpConstraint *constraint , cpFloat phase ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsGearJoint((cpConstraint const   *)constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsGearJoint(constraint)", "../src/cpGearJoint.c", 126,
              1, 1, "Constraint is not a ratchet joint.");
    abort();
  }
  cpConstraintActivateBodies(constraint);
  ((cpGearJoint *)constraint)->phase = phase;
  return;
}
}
cpFloat cpGearJointGetRatio(cpConstraint const   *constraint ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsGearJoint(constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsGearJoint(constraint)", "../src/cpGearJoint.c", 134,
              1, 1, "Constraint is not a ratchet joint.");
    abort();
  }
  return (((cpGearJoint *)constraint)->ratio);
}
}
void cpGearJointSetRatio(cpConstraint *constraint , cpFloat ratio ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsGearJoint((cpConstraint const   *)constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsGearJoint(constraint)", "../src/cpGearJoint.c", 141,
              1, 1, "Constraint is not a ratchet joint.");
    abort();
  }
  cpConstraintActivateBodies(constraint);
  ((cpGearJoint *)constraint)->ratio = ratio;
  ((cpGearJoint *)constraint)->ratio_inv = (cpFloat )1.0f / ratio;
  return;
}
}
#pragma merger("0","/tmp/cil-XhW3nV28.i","-std=gnu99,-ffast-math,-fPIC")
static struct cpVect  const  cpvzero___3  =    {(cpFloat )0.0f, (cpFloat )0.0f};
__inline static cpVect cpvproject(cpVect const   v1 , cpVect const   v2 ) 
{ 
  cpFloat tmp ;
  cpFloat tmp___0 ;
  cpVect tmp___1 ;

  {
  tmp = cpvdot(v1, v2);
  tmp___0 = cpvdot(v2, v2);
  tmp___1 = cpvmult(v2, (cpFloat const   )(tmp / tmp___0));
  return (tmp___1);
}
}
__inline static cpVect cpvclamp(cpVect const   v , cpFloat const   len ) 
{ 
  cpVect tmp___0 ;
  cpVect tmp___1 ;
  cpVect tmp___2 ;
  cpFloat tmp___3 ;

  {
  tmp___3 = cpvdot(v, v);
  if (tmp___3 > (cpFloat )(len * len)) {
    tmp___0 = cpvnormalize(v);
    tmp___1 = cpvmult((cpVect const   )tmp___0, len);
    tmp___2 = tmp___1;
  } else {
    tmp___2 = (cpVect )v;
  }
  return (tmp___2);
}
}
__inline static cpMat2x2 cpMat2x2New(cpFloat a , cpFloat b , cpFloat c , cpFloat d ) 
{ 
  cpMat2x2 m ;

  {
  m.a = a;
  m.b = b;
  m.c = c;
  m.d = d;
  return (m);
}
}
__inline static cpVect cpMat2x2Transform(cpMat2x2 m , cpVect v ) 
{ 
  cpVect tmp ;

  {
  tmp = cpv((cpFloat const   )(v.x * m.a + v.y * m.b), (cpFloat const   )(v.x * m.c + v.y * m.d));
  return (tmp);
}
}
cpBool cpConstraintIsGrooveJoint(cpConstraint const   *constraint ) ;
cpGrooveJoint *cpGrooveJointAlloc(void) ;
cpGrooveJoint *cpGrooveJointInit(cpGrooveJoint *joint , cpBody *a , cpBody *b , cpVect groove_a ,
                                 cpVect groove_b , cpVect anchorB ) ;
cpConstraint *cpGrooveJointNew(cpBody *a , cpBody *b , cpVect groove_a , cpVect groove_b ,
                               cpVect anchorB ) ;
cpVect cpGrooveJointGetGrooveA(cpConstraint const   *constraint ) ;
void cpGrooveJointSetGrooveA(cpConstraint *constraint , cpVect value ) ;
cpVect cpGrooveJointGetGrooveB(cpConstraint const   *constraint ) ;
void cpGrooveJointSetGrooveB(cpConstraint *constraint , cpVect value ) ;
cpVect cpGrooveJointGetAnchorB(cpConstraint const   *constraint ) ;
void cpGrooveJointSetAnchorB(cpConstraint *constraint , cpVect anchorB ) ;
__inline static cpMat2x2 k_tensor(cpBody *a , cpBody *b , cpVect r1 , cpVect r2 ) 
{ 
  cpFloat m_sum ;
  cpFloat k11 ;
  cpFloat k12 ;
  cpFloat k21 ;
  cpFloat k22 ;
  cpFloat a_i_inv ;
  cpFloat r1xsq ;
  cpFloat r1ysq ;
  cpFloat r1nxy ;
  cpFloat b_i_inv ;
  cpFloat r2xsq ;
  cpFloat r2ysq ;
  cpFloat r2nxy ;
  cpFloat det ;
  cpFloat det_inv ;
  cpMat2x2 tmp ;

  {
  m_sum = a->m_inv + b->m_inv;
  k11 = m_sum;
  k12 = (cpFloat )0.0f;
  k21 = (cpFloat )0.0f;
  k22 = m_sum;
  a_i_inv = a->i_inv;
  r1xsq = (r1.x * r1.x) * a_i_inv;
  r1ysq = (r1.y * r1.y) * a_i_inv;
  r1nxy = (- r1.x * r1.y) * a_i_inv;
  k11 += r1ysq;
  k12 += r1nxy;
  k21 += r1nxy;
  k22 += r1xsq;
  b_i_inv = b->i_inv;
  r2xsq = (r2.x * r2.x) * b_i_inv;
  r2ysq = (r2.y * r2.y) * b_i_inv;
  r2nxy = (- r2.x * r2.y) * b_i_inv;
  k11 += r2ysq;
  k12 += r2nxy;
  k21 += r2nxy;
  k22 += r2xsq;
  det = k11 * k22 - k12 * k21;
  det_inv = (cpFloat )1.0f / det;
  tmp = cpMat2x2New(k22 * det_inv, - k12 * det_inv, - k21 * det_inv, k11 * det_inv);
  return (tmp);
}
}
static void preStep___2(cpGrooveJoint *joint , cpFloat dt ) 
{ 
  cpBody *a ;
  cpBody *b ;
  cpVect ta ;
  cpVect tmp ;
  cpVect tb ;
  cpVect tmp___0 ;
  cpVect n ;
  cpVect tmp___1 ;
  cpFloat d ;
  cpFloat tmp___2 ;
  cpVect tmp___3 ;
  cpFloat td ;
  cpVect tmp___4 ;
  cpFloat tmp___5 ;
  cpVect tmp___6 ;
  cpVect tmp___7 ;
  cpVect tmp___8 ;
  cpVect tmp___9 ;
  cpFloat tmp___10 ;
  cpFloat tmp___11 ;
  cpVect delta ;
  cpVect tmp___12 ;
  cpVect tmp___13 ;
  cpVect tmp___14 ;
  cpFloat tmp___15 ;
  cpVect tmp___16 ;

  {
  a = joint->constraint.a;
  b = joint->constraint.b;
  tmp = cpTransformPoint(a->transform, joint->grv_a);
  ta = tmp;
  tmp___0 = cpTransformPoint(a->transform, joint->grv_b);
  tb = tmp___0;
  tmp___1 = cpTransformVect(a->transform, joint->grv_n);
  n = tmp___1;
  tmp___2 = cpvdot((cpVect const   )ta, (cpVect const   )n);
  d = tmp___2;
  joint->grv_tn = n;
  tmp___3 = cpvsub((cpVect const   )joint->anchorB, (cpVect const   )b->cog);
  joint->r2 = cpTransformVect(b->transform, tmp___3);
  tmp___4 = cpvadd((cpVect const   )b->p, (cpVect const   )joint->r2);
  tmp___5 = cpvcross((cpVect const   )tmp___4, (cpVect const   )n);
  td = tmp___5;
  tmp___11 = cpvcross((cpVect const   )ta, (cpVect const   )n);
  if (td <= tmp___11) {
    joint->clamp = (cpFloat )1.0f;
    joint->r1 = cpvsub((cpVect const   )ta, (cpVect const   )a->p);
  } else {
    tmp___10 = cpvcross((cpVect const   )tb, (cpVect const   )n);
    if (td >= tmp___10) {
      joint->clamp = (cpFloat )(- 1.0f);
      joint->r1 = cpvsub((cpVect const   )tb, (cpVect const   )a->p);
    } else {
      joint->clamp = (cpFloat )0.0f;
      tmp___6 = cpvmult((cpVect const   )n, (cpFloat const   )d);
      tmp___7 = cpvperp((cpVect const   )n);
      tmp___8 = cpvmult((cpVect const   )tmp___7, (cpFloat const   )(- td));
      tmp___9 = cpvadd((cpVect const   )tmp___8, (cpVect const   )tmp___6);
      joint->r1 = cpvsub((cpVect const   )tmp___9, (cpVect const   )a->p);
    }
  }
  joint->k = k_tensor(a, b, joint->r1, joint->r2);
  tmp___12 = cpvadd((cpVect const   )a->p, (cpVect const   )joint->r1);
  tmp___13 = cpvadd((cpVect const   )b->p, (cpVect const   )joint->r2);
  tmp___14 = cpvsub((cpVect const   )tmp___13, (cpVect const   )tmp___12);
  delta = tmp___14;
  tmp___15 = bias_coef(joint->constraint.errorBias, dt);
  tmp___16 = cpvmult((cpVect const   )delta, (cpFloat const   )(- tmp___15 / dt));
  joint->bias = cpvclamp((cpVect const   )tmp___16, (cpFloat const   )joint->constraint.maxBias);
  return;
}
}
static void applyCachedImpulse___2(cpGrooveJoint *joint , cpFloat dt_coef ) 
{ 
  cpBody *a ;
  cpBody *b ;
  cpVect tmp ;

  {
  a = joint->constraint.a;
  b = joint->constraint.b;
  tmp = cpvmult((cpVect const   )joint->jAcc, (cpFloat const   )dt_coef);
  apply_impulses(a, b, joint->r1, joint->r2, tmp);
  return;
}
}
__inline static cpVect grooveConstrain(cpGrooveJoint *joint , cpVect j , cpFloat dt ) 
{ 
  cpVect n ;
  cpVect jClamp ;
  cpVect tmp___0 ;
  cpVect tmp___1 ;
  cpFloat tmp___2 ;
  cpVect tmp___3 ;

  {
  n = joint->grv_tn;
  tmp___2 = cpvcross((cpVect const   )j, (cpVect const   )n);
  if (joint->clamp * tmp___2 > (cpFloat )0.0f) {
    tmp___1 = j;
  } else {
    tmp___0 = cpvproject((cpVect const   )j, (cpVect const   )n);
    tmp___1 = tmp___0;
  }
  jClamp = tmp___1;
  tmp___3 = cpvclamp((cpVect const   )jClamp, (cpFloat const   )(joint->constraint.maxForce * dt));
  return (tmp___3);
}
}
static void applyImpulse___2(cpGrooveJoint *joint , cpFloat dt ) 
{ 
  cpBody *a ;
  cpBody *b ;
  cpVect r1 ;
  cpVect r2 ;
  cpVect vr ;
  cpVect tmp ;
  cpVect j ;
  cpVect tmp___0 ;
  cpVect tmp___1 ;
  cpVect jOld ;
  cpVect tmp___2 ;

  {
  a = joint->constraint.a;
  b = joint->constraint.b;
  r1 = joint->r1;
  r2 = joint->r2;
  tmp = relative_velocity(a, b, r1, r2);
  vr = tmp;
  tmp___0 = cpvsub((cpVect const   )joint->bias, (cpVect const   )vr);
  tmp___1 = cpMat2x2Transform(joint->k, tmp___0);
  j = tmp___1;
  jOld = joint->jAcc;
  tmp___2 = cpvadd((cpVect const   )jOld, (cpVect const   )j);
  joint->jAcc = grooveConstrain(joint, tmp___2, dt);
  j = cpvsub((cpVect const   )joint->jAcc, (cpVect const   )jOld);
  apply_impulses(a, b, joint->r1, joint->r2, j);
  return;
}
}
static cpFloat getImpulse___2(cpGrooveJoint *joint ) 
{ 
  cpFloat tmp ;

  {
  tmp = cpvlength((cpVect const   )joint->jAcc);
  return (tmp);
}
}
static struct cpConstraintClass  const  klass___3  =    {(void (*)(cpConstraint *constraint , cpFloat dt ))(& preStep___2), (void (*)(cpConstraint *constraint ,
                                                                                 cpFloat dt_coef ))(& applyCachedImpulse___2),
    (void (*)(cpConstraint *constraint , cpFloat dt ))(& applyImpulse___2), (cpFloat (*)(cpConstraint *constraint ))(& getImpulse___2)};
cpGrooveJoint *cpGrooveJointAlloc(void) 
{ 
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(cpGrooveJoint ));
  return ((cpGrooveJoint *)tmp);
}
}
cpGrooveJoint *cpGrooveJointInit(cpGrooveJoint *joint , cpBody *a , cpBody *b , cpVect groove_a ,
                                 cpVect groove_b , cpVect anchorB ) 
{ 
  cpVect tmp ;
  cpVect tmp___0 ;

  {
  cpConstraintInit((cpConstraint *)joint, & klass___3, a, b);
  joint->grv_a = groove_a;
  joint->grv_b = groove_b;
  tmp = cpvsub((cpVect const   )groove_b, (cpVect const   )groove_a);
  tmp___0 = cpvnormalize((cpVect const   )tmp);
  joint->grv_n = cpvperp((cpVect const   )tmp___0);
  joint->anchorB = anchorB;
  joint->jAcc = (cpVect )cpvzero___3;
  return (joint);
}
}
cpConstraint *cpGrooveJointNew(cpBody *a , cpBody *b , cpVect groove_a , cpVect groove_b ,
                               cpVect anchorB ) 
{ 
  cpGrooveJoint *tmp ;
  cpGrooveJoint *tmp___0 ;

  {
  tmp = cpGrooveJointAlloc();
  tmp___0 = cpGrooveJointInit(tmp, a, b, groove_a, groove_b, anchorB);
  return ((cpConstraint *)tmp___0);
}
}
cpBool cpConstraintIsGrooveJoint(cpConstraint const   *constraint ) 
{ 


  {
  return ((cpBool )((unsigned long )constraint->klass == (unsigned long )(& klass___3)));
}
}
cpVect cpGrooveJointGetGrooveA(cpConstraint const   *constraint ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsGrooveJoint(constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsGrooveJoint(constraint)", "../src/cpGrooveJoint.c", 149,
              1, 1, "Constraint is not a groove joint.");
    abort();
  }
  return (((cpGrooveJoint *)constraint)->grv_a);
}
}
void cpGrooveJointSetGrooveA(cpConstraint *constraint , cpVect value ) 
{ 
  cpBool tmp ;
  cpGrooveJoint *g ;
  cpVect tmp___0 ;
  cpVect tmp___1 ;

  {
  tmp = cpConstraintIsGrooveJoint((cpConstraint const   *)constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsGrooveJoint(constraint)", "../src/cpGrooveJoint.c", 156,
              1, 1, "Constraint is not a groove joint.");
    abort();
  }
  g = (cpGrooveJoint *)constraint;
  g->grv_a = value;
  tmp___0 = cpvsub((cpVect const   )g->grv_b, (cpVect const   )value);
  tmp___1 = cpvnormalize((cpVect const   )tmp___0);
  g->grv_n = cpvperp((cpVect const   )tmp___1);
  cpConstraintActivateBodies(constraint);
  return;
}
}
cpVect cpGrooveJointGetGrooveB(cpConstraint const   *constraint ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsGrooveJoint(constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsGrooveJoint(constraint)", "../src/cpGrooveJoint.c", 168,
              1, 1, "Constraint is not a groove joint.");
    abort();
  }
  return (((cpGrooveJoint *)constraint)->grv_b);
}
}
void cpGrooveJointSetGrooveB(cpConstraint *constraint , cpVect value ) 
{ 
  cpBool tmp ;
  cpGrooveJoint *g ;
  cpVect tmp___0 ;
  cpVect tmp___1 ;

  {
  tmp = cpConstraintIsGrooveJoint((cpConstraint const   *)constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsGrooveJoint(constraint)", "../src/cpGrooveJoint.c", 175,
              1, 1, "Constraint is not a groove joint.");
    abort();
  }
  g = (cpGrooveJoint *)constraint;
  g->grv_b = value;
  tmp___0 = cpvsub((cpVect const   )value, (cpVect const   )g->grv_a);
  tmp___1 = cpvnormalize((cpVect const   )tmp___0);
  g->grv_n = cpvperp((cpVect const   )tmp___1);
  cpConstraintActivateBodies(constraint);
  return;
}
}
cpVect cpGrooveJointGetAnchorB(cpConstraint const   *constraint ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsGrooveJoint(constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsGrooveJoint(constraint)", "../src/cpGrooveJoint.c", 187,
              1, 1, "Constraint is not a groove joint.");
    abort();
  }
  return (((cpGrooveJoint *)constraint)->anchorB);
}
}
void cpGrooveJointSetAnchorB(cpConstraint *constraint , cpVect anchorB ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsGrooveJoint((cpConstraint const   *)constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsGrooveJoint(constraint)", "../src/cpGrooveJoint.c", 194,
              1, 1, "Constraint is not a groove joint.");
    abort();
  }
  cpConstraintActivateBodies(constraint);
  ((cpGrooveJoint *)constraint)->anchorB = anchorB;
  return;
}
}
#pragma merger("0","/tmp/cil-IAS67V_t.i","-std=gnu99,-ffast-math,-fPIC")
void cpHashSetSetDefaultValue(cpHashSet *set , void *default_value ) ;
void cpHashSetFilter(cpHashSet *set , cpBool (*func)(void *elt , void *data ) , void *data ) ;
static int primes[30]  = 
  {      5,      13,      23,      47, 
        97,      193,      389,      769, 
        1543,      3079,      6151,      12289, 
        24593,      49157,      98317,      196613, 
        393241,      786433,      1572869,      3145739, 
        6291469,      12582917,      25165843,      50331653, 
        100663319,      201326611,      402653189,      805306457, 
        1610612741,      0};
__inline static int next_prime(int n ) 
{ 
  int i ;

  {
  i = 0;
  while (n > primes[i]) {
    i ++;
    if (! primes[i]) {
      cpMessage("primes[i]", "../src/prime.h", 64, 1, 1, "Tried to resize a hash table to a size greater than 1610612741 O_o");
      abort();
    }
  }
  return (primes[i]);
}
}
void cpHashSetFree(cpHashSet *set ) 
{ 


  {
  if (set) {
    free((void *)set->table);
    cpArrayFreeEach(set->allocatedBuffers, & free);
    cpArrayFree(set->allocatedBuffers);
    free((void *)set);
  }
  return;
}
}
cpHashSet *cpHashSetNew(int size , cpBool (*eqlFunc)(void const   *ptr , void const   *elt ) ) 
{ 
  cpHashSet *set ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  tmp = calloc((size_t )1, sizeof(cpHashSet ));
  set = (cpHashSet *)tmp;
  tmp___0 = next_prime(size);
  set->size = (unsigned int )tmp___0;
  set->entries = 0U;
  set->eql = eqlFunc;
  set->default_value = (void *)0;
  tmp___1 = calloc((size_t )set->size, sizeof(cpHashSetBin *));
  set->table = (cpHashSetBin **)tmp___1;
  set->pooledBins = (cpHashSetBin *)((void *)0);
  set->allocatedBuffers = cpArrayNew(0);
  return (set);
}
}
void cpHashSetSetDefaultValue(cpHashSet *set , void *default_value ) 
{ 


  {
  set->default_value = default_value;
  return;
}
}
static int setIsFull(cpHashSet *set ) 
{ 


  {
  return (set->entries >= set->size);
}
}
static void cpHashSetResize(cpHashSet *set ) 
{ 
  unsigned int newSize ;
  int tmp ;
  cpHashSetBin **newTable ;
  void *tmp___0 ;
  unsigned int i ;
  cpHashSetBin *bin ;
  cpHashSetBin *next ;
  cpHashValue idx ;

  {
  tmp = next_prime((int )(set->size + 1U));
  newSize = (unsigned int )tmp;
  tmp___0 = calloc((size_t )newSize, sizeof(cpHashSetBin *));
  newTable = (cpHashSetBin **)tmp___0;
  i = 0U;
  while (i < set->size) {
    bin = *(set->table + i);
    while (bin) {
      next = bin->next;
      idx = bin->hash % (unsigned long )newSize;
      bin->next = *(newTable + idx);
      *(newTable + idx) = bin;
      bin = next;
    }
    i ++;
  }
  free((void *)set->table);
  set->table = newTable;
  set->size = newSize;
  return;
}
}
__inline static void recycleBin(cpHashSet *set , cpHashSetBin *bin ) 
{ 


  {
  bin->next = set->pooledBins;
  set->pooledBins = bin;
  bin->elt = (void *)0;
  return;
}
}
static cpHashSetBin *getUnusedBin(cpHashSet *set ) 
{ 
  cpHashSetBin *bin ;
  int count ;
  cpHashSetBin *buffer ;
  void *tmp ;
  int i ;

  {
  bin = set->pooledBins;
  if (bin) {
    set->pooledBins = bin->next;
    return (bin);
  } else {
    count = (int )(32768UL / sizeof(cpHashSetBin ));
    if (! count) {
      cpMessage("count", "../src/cpHashSet.c", 135, 1, 1, "Internal Error: Buffer size is too small.");
      abort();
    }
    tmp = calloc((size_t )1, (size_t )32768);
    buffer = (cpHashSetBin *)tmp;
    cpArrayPush(set->allocatedBuffers, (void *)buffer);
    i = 1;
    while (i < count) {
      recycleBin(set, buffer + i);
      i ++;
    }
    return (buffer);
  }
}
}
int cpHashSetCount(cpHashSet *set ) 
{ 


  {
  return ((int )set->entries);
}
}
void const   *cpHashSetInsert(cpHashSet *set , cpHashValue hash , void const   *ptr ,
                              void *(*trans)(void const   *ptr , void *data ) , void *data ) 
{ 
  cpHashValue idx ;
  cpHashSetBin *bin ;
  cpBool tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  idx = hash % (unsigned long )set->size;
  bin = *(set->table + idx);
  while (1) {
    if (bin) {
      tmp = (*(set->eql))(ptr, (void const   *)bin->elt);
      if (tmp) {
        break;
      }
    } else {
      break;
    }
    bin = bin->next;
  }
  if (! bin) {
    bin = getUnusedBin(set);
    bin->hash = hash;
    if (trans) {
      tmp___0 = (*trans)(ptr, data);
      bin->elt = tmp___0;
    } else {
      bin->elt = data;
    }
    bin->next = *(set->table + idx);
    *(set->table + idx) = bin;
    (set->entries) ++;
    tmp___1 = setIsFull(set);
    if (tmp___1) {
      cpHashSetResize(set);
    }
  }
  return ((void const   *)bin->elt);
}
}
void const   *cpHashSetRemove(cpHashSet *set , cpHashValue hash , void const   *ptr ) 
{ 
  cpHashValue idx ;
  cpHashSetBin **prev_ptr ;
  cpHashSetBin *bin ;
  cpBool tmp ;
  void const   *elt ;

  {
  idx = hash % (unsigned long )set->size;
  prev_ptr = set->table + idx;
  bin = *(set->table + idx);
  while (1) {
    if (bin) {
      tmp = (*(set->eql))(ptr, (void const   *)bin->elt);
      if (tmp) {
        break;
      }
    } else {
      break;
    }
    prev_ptr = & bin->next;
    bin = bin->next;
  }
  if (bin) {
    *prev_ptr = bin->next;
    (set->entries) --;
    elt = (void const   *)bin->elt;
    recycleBin(set, bin);
    return (elt);
  }
  return ((void const   *)((void *)0));
}
}
void const   *cpHashSetFind(cpHashSet *set , cpHashValue hash , void const   *ptr ) 
{ 
  cpHashValue idx ;
  cpHashSetBin *bin ;
  cpBool tmp ;
  void *tmp___0 ;

  {
  idx = hash % (unsigned long )set->size;
  bin = *(set->table + idx);
  while (1) {
    if (bin) {
      tmp = (*(set->eql))(ptr, (void const   *)bin->elt);
      if (tmp) {
        break;
      }
    } else {
      break;
    }
    bin = bin->next;
  }
  if (bin) {
    tmp___0 = bin->elt;
  } else {
    tmp___0 = set->default_value;
  }
  return ((void const   *)tmp___0);
}
}
void cpHashSetEach(cpHashSet *set , void (*func)(void *elt , void *data ) , void *data ) 
{ 
  unsigned int i ;
  cpHashSetBin *bin ;
  cpHashSetBin *next ;

  {
  i = 0U;
  while (i < set->size) {
    bin = *(set->table + i);
    while (bin) {
      next = bin->next;
      (*func)(bin->elt, data);
      bin = next;
    }
    i ++;
  }
  return;
}
}
void cpHashSetFilter(cpHashSet *set , cpBool (*func)(void *elt , void *data ) , void *data ) 
{ 
  unsigned int i ;
  cpHashSetBin **prev_ptr ;
  cpHashSetBin *bin ;
  cpHashSetBin *next ;
  cpBool tmp ;

  {
  i = 0U;
  while (i < set->size) {
    prev_ptr = set->table + i;
    bin = *(set->table + i);
    while (bin) {
      next = bin->next;
      tmp = (*func)(bin->elt, data);
      if (tmp) {
        prev_ptr = & bin->next;
      } else {
        *prev_ptr = next;
        (set->entries) --;
        recycleBin(set, bin);
      }
      bin = next;
    }
    i ++;
  }
  return;
}
}
#pragma merger("0","/tmp/cil-dMT_fb0L.i","-std=gnu99,-ffast-math,-fPIC")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                                              pthread_condattr_t const   * __restrict  __cond_attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_destroy)(pthread_cond_t *__cond ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_signal)(pthread_cond_t *__cond ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_broadcast)(pthread_cond_t *__cond ) ;
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
__inline static void cpSpatialIndexEach(cpSpatialIndex *index , void (*func)(void *obj ,
                                                                             void *data ) ,
                                        void *data ) 
{ 


  {
  (*((index->klass)->each))(index, func, data);
  return;
}
}
__inline static void cpSpatialIndexReindexQuery(cpSpatialIndex *index , cpCollisionID (*func)(void *obj1 ,
                                                                                              void *obj2 ,
                                                                                              cpCollisionID id ,
                                                                                              void *data ) ,
                                                void *data ) 
{ 


  {
  (*((index->klass)->reindexQuery))(index, func, data);
  return;
}
}
cpSpace *cpSpaceInit(cpSpace *space ) ;
void cpSpaceFree(cpSpace *space ) ;
void cpSpaceProcessComponents(cpSpace *space , cpFloat dt ) ;
void cpSpacePushFreshContactBuffer(cpSpace *space ) ;
cpBool cpSpaceArbiterSetFilter(cpArbiter *arb , cpSpace *space ) ;
void cpSpaceLock(cpSpace *space ) ;
void cpSpaceUnlock(cpSpace *space , cpBool runPostStep ) ;
void cpShapeUpdateFunc(cpShape *shape , void *unused ) ;
cpCollisionID cpSpaceCollideShapes(cpShape *a , cpShape *b , cpCollisionID id , cpSpace *space ) ;
cpSpace *cpHastySpaceNew(void) ;
void cpHastySpaceFree(cpSpace *space ) ;
void cpHastySpaceSetThreads(cpSpace *space , unsigned long threads ) ;
unsigned long cpHastySpaceGetThreads(cpSpace *space ) ;
void cpHastySpaceStep(cpSpace *space , cpFloat dt ) ;
static void *WorkerThreadLoop(struct ThreadContext *context ) 
{ 
  cpHastySpace *hasty ;
  unsigned long thread ;
  unsigned long num_threads ;
  void (*func)(cpSpace *space , unsigned long worker , unsigned long worker_count ) ;

  {
  hasty = context->space;
  thread = context->thread_num;
  num_threads = hasty->num_threads;
  while (1) {
    pthread_mutex_lock(& hasty->mutex);
    (hasty->num_working) --;
    if (hasty->num_working == 0UL) {
      pthread_cond_signal(& hasty->cond_resume);
    }
    pthread_cond_wait((pthread_cond_t * __restrict  )(& hasty->cond_work), (pthread_mutex_t * __restrict  )(& hasty->mutex));
    pthread_mutex_unlock(& hasty->mutex);
    func = hasty->work;
    if (func) {
      (*(hasty->work))(& hasty->space, thread, num_threads);
    } else {
      break;
    }
  }
  return ((void *)0);
}
}
static void RunWorkers(cpHastySpace *hasty , void (*func)(cpSpace *space , unsigned long worker ,
                                                          unsigned long worker_count ) ) 
{ 


  {
  hasty->num_working = hasty->num_threads - 1UL;
  hasty->work = func;
  if (hasty->num_working > 0UL) {
    pthread_mutex_lock(& hasty->mutex);
    pthread_cond_broadcast(& hasty->cond_work);
    pthread_mutex_unlock(& hasty->mutex);
    (*func)((cpSpace *)hasty, 0UL, hasty->num_threads);
    pthread_mutex_lock(& hasty->mutex);
    if (hasty->num_working > 0UL) {
      pthread_cond_wait((pthread_cond_t * __restrict  )(& hasty->cond_resume), (pthread_mutex_t * __restrict  )(& hasty->mutex));
    }
    pthread_mutex_unlock(& hasty->mutex);
  } else {
    (*func)((cpSpace *)hasty, 0UL, hasty->num_threads);
  }
  hasty->work = (void (*)(cpSpace *space , unsigned long worker , unsigned long worker_count ))((void *)0);
  return;
}
}
static void Solver(cpSpace *space , unsigned long worker , unsigned long worker_count ) 
{ 
  cpArray *constraints ;
  cpArray *arbiters ;
  cpFloat dt ;
  unsigned long iterations ;
  unsigned long i ;
  int j ;
  cpArbiter *arb ;
  int j___0 ;
  cpConstraint *constraint ;

  {
  constraints = space->constraints;
  arbiters = space->arbiters;
  dt = space->curr_dt;
  iterations = (((unsigned long )space->iterations + worker_count) - 1UL) / worker_count;
  i = 0UL;
  while (i < iterations) {
    j = 0;
    while (j < arbiters->num) {
      arb = (cpArbiter *)*(arbiters->arr + j);
      cpArbiterApplyImpulse(arb);
      j ++;
    }
    j___0 = 0;
    while (j___0 < constraints->num) {
      constraint = (cpConstraint *)*(constraints->arr + j___0);
      (*((constraint->klass)->applyImpulse))(constraint, dt);
      j___0 ++;
    }
    i ++;
  }
  return;
}
}
static void HaltThreads(cpHastySpace *hasty ) 
{ 
  pthread_mutex_t *mutex ;
  unsigned long i ;

  {
  mutex = & hasty->mutex;
  pthread_mutex_lock(mutex);
  hasty->work = (void (*)(cpSpace *space , unsigned long worker , unsigned long worker_count ))((void *)0);
  pthread_cond_broadcast(& hasty->cond_work);
  pthread_mutex_unlock(mutex);
  i = 0UL;
  while (i < hasty->num_threads - 1UL) {
    pthread_join(hasty->workers[i].thread, (void **)((void *)0));
    i ++;
  }
  return;
}
}
void cpHastySpaceSetThreads(cpSpace *space , unsigned long threads ) 
{ 
  cpHastySpace *hasty ;
  unsigned long i ;

  {
  hasty = (cpHastySpace *)space;
  HaltThreads(hasty);
  if (threads == 0UL) {
    threads = 1UL;
  }
  if (threads < 2UL) {
    hasty->num_threads = threads;
  } else {
    hasty->num_threads = 2UL;
  }
  hasty->num_working = hasty->num_threads - 1UL;
  if (hasty->num_working > 0UL) {
    pthread_mutex_lock(& hasty->mutex);
    i = 0UL;
    while (i < hasty->num_threads - 1UL) {
      hasty->workers[i].space = hasty;
      hasty->workers[i].thread_num = i + 1UL;
      pthread_create((pthread_t * __restrict  )(& hasty->workers[i].thread), (pthread_attr_t const   * __restrict  )((void *)0),
                     (void *(*)(void * ))(& WorkerThreadLoop), (void * __restrict  )(& hasty->workers[i]));
      i ++;
    }
    pthread_cond_wait((pthread_cond_t * __restrict  )(& hasty->cond_resume), (pthread_mutex_t * __restrict  )(& hasty->mutex));
    pthread_mutex_unlock(& hasty->mutex);
  }
  return;
}
}
unsigned long cpHastySpaceGetThreads(cpSpace *space ) 
{ 


  {
  return (((cpHastySpace *)space)->num_threads);
}
}
cpSpace *cpHastySpaceNew(void) 
{ 
  cpHastySpace *hasty ;
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(cpHastySpace ));
  hasty = (cpHastySpace *)tmp;
  cpSpaceInit((cpSpace *)hasty);
  pthread_mutex_init(& hasty->mutex, (pthread_mutexattr_t const   *)((void *)0));
  pthread_cond_init((pthread_cond_t * __restrict  )(& hasty->cond_work), (pthread_condattr_t const   * __restrict  )((void *)0));
  pthread_cond_init((pthread_cond_t * __restrict  )(& hasty->cond_resume), (pthread_condattr_t const   * __restrict  )((void *)0));
  hasty->constraint_count_threshold = 50UL;
  hasty->num_threads = 1UL;
  cpHastySpaceSetThreads((cpSpace *)hasty, 1UL);
  return ((cpSpace *)hasty);
}
}
void cpHastySpaceFree(cpSpace *space ) 
{ 
  cpHastySpace *hasty ;

  {
  hasty = (cpHastySpace *)space;
  HaltThreads(hasty);
  pthread_mutex_destroy(& hasty->mutex);
  pthread_cond_destroy(& hasty->cond_work);
  pthread_cond_destroy(& hasty->cond_resume);
  cpSpaceFree(space);
  return;
}
}
void cpHastySpaceStep(cpSpace *space , cpFloat dt ) 
{ 
  cpFloat prev_dt ;
  cpArray *bodies ;
  cpArray *constraints ;
  cpArray *arbiters ;
  int i ;
  cpArbiter *arb ;
  cpBool tmp ;
  cpBool tmp___0 ;
  int i___0 ;
  cpBody *body ;
  cpFloat slop ;
  cpFloat biasCoef ;
  double tmp___1 ;
  int i___1 ;
  int i___2 ;
  cpConstraint *constraint ;
  void (*preSolve)(cpConstraint *constraint , cpSpace *space ) ;
  cpFloat damping ;
  double tmp___2 ;
  cpVect gravity ;
  int i___3 ;
  cpBody *body___0 ;
  cpFloat dt_coef ;
  cpFloat tmp___3 ;
  int i___4 ;
  int i___5 ;
  cpConstraint *constraint___0 ;
  cpHastySpace *hasty ;
  int i___6 ;
  cpConstraint *constraint___1 ;
  void (*postSolve)(cpConstraint *constraint , cpSpace *space ) ;
  int i___7 ;
  cpArbiter *arb___0 ;
  cpCollisionHandler *handler ;

  {
  if (dt == (cpFloat )0.0f) {
    return;
  }
  (space->stamp) ++;
  prev_dt = space->curr_dt;
  space->curr_dt = dt;
  bodies = space->dynamicBodies;
  constraints = space->constraints;
  arbiters = space->arbiters;
  i = 0;
  while (i < arbiters->num) {
    arb = (cpArbiter *)*(arbiters->arr + i);
    arb->state = (enum cpArbiterState )1;
    tmp = cpBodyIsSleeping((cpBody const   *)arb->body_a);
    if (! tmp) {
      tmp___0 = cpBodyIsSleeping((cpBody const   *)arb->body_b);
      if (! tmp___0) {
        cpArbiterUnthread(arb);
      }
    }
    i ++;
  }
  arbiters->num = 0;
  cpSpaceLock(space);
  i___0 = 0;
  while (i___0 < bodies->num) {
    body = (cpBody *)*(bodies->arr + i___0);
    (*(body->position_func))(body, dt);
    i___0 ++;
  }
  cpSpacePushFreshContactBuffer(space);
  cpSpatialIndexEach(space->dynamicShapes, (void (*)(void *obj , void *data ))(& cpShapeUpdateFunc),
                     (void *)0);
  cpSpatialIndexReindexQuery(space->dynamicShapes, (cpCollisionID (*)(void *obj1 ,
                                                                      void *obj2 ,
                                                                      cpCollisionID id ,
                                                                      void *data ))(& cpSpaceCollideShapes),
                             (void *)space);
  cpSpaceUnlock(space, (cpBool )0);
  cpSpaceProcessComponents(space, dt);
  cpSpaceLock(space);
  cpHashSetFilter(space->cachedArbiters, (cpBool (*)(void *elt , void *data ))(& cpSpaceArbiterSetFilter),
                  (void *)space);
  slop = space->collisionSlop;
  tmp___1 = pow(space->collisionBias, dt);
  biasCoef = (double )1.0f - tmp___1;
  i___1 = 0;
  while (i___1 < arbiters->num) {
    cpArbiterPreStep((cpArbiter *)*(arbiters->arr + i___1), dt, slop, biasCoef);
    i___1 ++;
  }
  i___2 = 0;
  while (i___2 < constraints->num) {
    constraint = (cpConstraint *)*(constraints->arr + i___2);
    preSolve = constraint->preSolve;
    if (preSolve) {
      (*preSolve)(constraint, space);
    }
    (*((constraint->klass)->preStep))(constraint, dt);
    i___2 ++;
  }
  tmp___2 = pow(space->damping, dt);
  damping = tmp___2;
  gravity = space->gravity;
  i___3 = 0;
  while (i___3 < bodies->num) {
    body___0 = (cpBody *)*(bodies->arr + i___3);
    (*(body___0->velocity_func))(body___0, gravity, damping, dt);
    i___3 ++;
  }
  if (prev_dt == (cpFloat )0.0f) {
    tmp___3 = (cpFloat )0.0f;
  } else {
    tmp___3 = dt / prev_dt;
  }
  dt_coef = tmp___3;
  i___4 = 0;
  while (i___4 < arbiters->num) {
    cpArbiterApplyCachedImpulse((cpArbiter *)*(arbiters->arr + i___4), dt_coef);
    i___4 ++;
  }
  i___5 = 0;
  while (i___5 < constraints->num) {
    constraint___0 = (cpConstraint *)*(constraints->arr + i___5);
    (*((constraint___0->klass)->applyCachedImpulse))(constraint___0, dt_coef);
    i___5 ++;
  }
  hasty = (cpHastySpace *)space;
  if ((unsigned long )(arbiters->num + constraints->num) > hasty->constraint_count_threshold) {
    RunWorkers(hasty, & Solver);
  } else {
    Solver(space, 0UL, 1UL);
  }
  i___6 = 0;
  while (i___6 < constraints->num) {
    constraint___1 = (cpConstraint *)*(constraints->arr + i___6);
    postSolve = constraint___1->postSolve;
    if (postSolve) {
      (*postSolve)(constraint___1, space);
    }
    i___6 ++;
  }
  i___7 = 0;
  while (i___7 < arbiters->num) {
    arb___0 = (cpArbiter *)*(arbiters->arr + i___7);
    handler = arb___0->handler;
    (*(handler->postSolveFunc))(arb___0, space, handler->userData);
    i___7 ++;
  }
  cpSpaceUnlock(space, (cpBool )1);
  return;
}
}
#pragma merger("0","/tmp/cil-BaLfUipB.i","-std=gnu99,-ffast-math,-fPIC")
__inline static cpFloat cpflerp(cpFloat f1 , cpFloat f2 , cpFloat t ) 
{ 


  {
  return (f1 * ((cpFloat )1.0f - t) + f2 * t);
}
}
void cpMarchSoft(cpBB bb , unsigned long x_samples , unsigned long y_samples , cpFloat t ,
                 void (*segment)(cpVect v0 , cpVect v1 , void *data ) , void *segment_data ,
                 cpFloat (*sample)(cpVect point , void *data ) , void *sample_data ) ;
void cpMarchHard(cpBB bb , unsigned long x_samples , unsigned long y_samples , cpFloat t ,
                 void (*segment)(cpVect v0 , cpVect v1 , void *data ) , void *segment_data ,
                 cpFloat (*sample)(cpVect point , void *data ) , void *sample_data ) ;
static void cpMarchCells(cpBB bb , unsigned long x_samples , unsigned long y_samples ,
                         cpFloat t , void (*segment)(cpVect v0 , cpVect v1 , void *data ) ,
                         void *segment_data , cpFloat (*sample)(cpVect point , void *data ) ,
                         void *sample_data , void (*cell)(cpFloat t , cpFloat a ,
                                                          cpFloat b , cpFloat c ,
                                                          cpFloat d , cpFloat x0 ,
                                                          cpFloat x1 , cpFloat y0 ,
                                                          cpFloat y1 , void (*segment)(cpVect v0 ,
                                                                                       cpVect v1 ,
                                                                                       void *data ) ,
                                                          void *segment_data ) ) 
{ 
  cpFloat x_denom ;
  cpFloat y_denom ;
  cpFloat *buffer ;
  void *tmp ;
  unsigned long i ;
  cpFloat tmp___0 ;
  cpVect tmp___1 ;
  unsigned long j ;
  cpFloat y0___0 ;
  cpFloat tmp___2 ;
  cpFloat y1___0 ;
  cpFloat tmp___3 ;
  cpFloat a ;
  cpFloat b ;
  cpFloat c ;
  cpFloat d ;
  cpVect tmp___4 ;
  cpFloat tmp___5 ;
  unsigned long i___0 ;
  cpFloat x0 ;
  cpFloat tmp___6 ;
  cpFloat x1 ;
  cpFloat tmp___7 ;
  cpVect tmp___8 ;

  {
  x_denom = 1.0 / (cpFloat )(x_samples - 1UL);
  y_denom = 1.0 / (cpFloat )(y_samples - 1UL);
  tmp = calloc(x_samples, sizeof(cpFloat ));
  buffer = (cpFloat *)tmp;
  i = 0UL;
  while (i < x_samples) {
    tmp___0 = cpflerp(bb.l, bb.r, (cpFloat )i * x_denom);
    tmp___1 = cpv((cpFloat const   )tmp___0, (cpFloat const   )bb.b);
    *(buffer + i) = (*sample)(tmp___1, sample_data);
    i ++;
  }
  j = 0UL;
  while (j < y_samples - 1UL) {
    tmp___2 = cpflerp(bb.b, bb.t, (cpFloat )j * y_denom);
    y0___0 = tmp___2;
    tmp___3 = cpflerp(bb.b, bb.t, (cpFloat )(j + 1UL) * y_denom);
    y1___0 = tmp___3;
    b = *(buffer + 0);
    tmp___4 = cpv((cpFloat const   )bb.l, (cpFloat const   )y1___0);
    tmp___5 = (*sample)(tmp___4, sample_data);
    d = tmp___5;
    *(buffer + 0) = d;
    i___0 = 0UL;
    while (i___0 < x_samples - 1UL) {
      tmp___6 = cpflerp(bb.l, bb.r, (cpFloat )i___0 * x_denom);
      x0 = tmp___6;
      tmp___7 = cpflerp(bb.l, bb.r, (cpFloat )(i___0 + 1UL) * x_denom);
      x1 = tmp___7;
      a = b;
      b = *(buffer + (i___0 + 1UL));
      c = d;
      tmp___8 = cpv((cpFloat const   )x1, (cpFloat const   )y1___0);
      d = (*sample)(tmp___8, sample_data);
      *(buffer + (i___0 + 1UL)) = d;
      (*cell)(t, a, b, c, d, x0, x1, y0___0, y1___0, segment, segment_data);
      i___0 ++;
    }
    j ++;
  }
  free((void *)buffer);
  return;
}
}
__inline static void seg(cpVect v0 , cpVect v1 , void (*f)(cpVect v0 , cpVect v1 ,
                                                           void *data ) , void *data ) 
{ 
  cpBool tmp ;

  {
  tmp = cpveql((cpVect const   )v0, (cpVect const   )v1);
  if (! tmp) {
    (*f)(v1, v0, data);
  }
  return;
}
}
__inline static cpFloat midlerp(cpFloat x0 , cpFloat x1 , cpFloat s0 , cpFloat s1 ,
                                cpFloat t ) 
{ 
  cpFloat tmp ;

  {
  tmp = cpflerp(x0, x1, (t - s0) / (s1 - s0));
  return (tmp);
}
}
static void cpMarchCellSoft(cpFloat t , cpFloat a , cpFloat b , cpFloat c , cpFloat d ,
                            cpFloat x0 , cpFloat x1 , cpFloat y0___0 , cpFloat y1___0 ,
                            void (*segment)(cpVect v0 , cpVect v1 , void *data ) ,
                            void *segment_data ) 
{ 
  cpFloat tmp ;
  cpVect tmp___0 ;
  cpFloat tmp___1 ;
  cpVect tmp___2 ;
  cpFloat tmp___3 ;
  cpVect tmp___4 ;
  cpFloat tmp___5 ;
  cpVect tmp___6 ;
  cpFloat tmp___7 ;
  cpVect tmp___8 ;
  cpFloat tmp___9 ;
  cpVect tmp___10 ;
  cpFloat tmp___11 ;
  cpVect tmp___12 ;
  cpFloat tmp___13 ;
  cpVect tmp___14 ;
  cpFloat tmp___15 ;
  cpVect tmp___16 ;
  cpFloat tmp___17 ;
  cpVect tmp___18 ;
  cpFloat tmp___19 ;
  cpVect tmp___20 ;
  cpFloat tmp___21 ;
  cpVect tmp___22 ;
  cpFloat tmp___23 ;
  cpVect tmp___24 ;
  cpFloat tmp___25 ;
  cpVect tmp___26 ;
  cpFloat tmp___27 ;
  cpVect tmp___28 ;
  cpFloat tmp___29 ;
  cpVect tmp___30 ;
  cpFloat tmp___31 ;
  cpVect tmp___32 ;
  cpFloat tmp___33 ;
  cpVect tmp___34 ;
  cpFloat tmp___35 ;
  cpVect tmp___36 ;
  cpFloat tmp___37 ;
  cpVect tmp___38 ;
  cpFloat tmp___39 ;
  cpVect tmp___40 ;
  cpFloat tmp___41 ;
  cpVect tmp___42 ;
  cpFloat tmp___43 ;
  cpVect tmp___44 ;
  cpFloat tmp___45 ;
  cpVect tmp___46 ;
  cpFloat tmp___47 ;
  cpVect tmp___48 ;
  cpFloat tmp___49 ;
  cpVect tmp___50 ;
  cpFloat tmp___51 ;
  cpVect tmp___52 ;
  cpFloat tmp___53 ;
  cpVect tmp___54 ;
  cpFloat tmp___55 ;
  cpVect tmp___56 ;
  cpFloat tmp___57 ;
  cpVect tmp___58 ;
  cpFloat tmp___59 ;
  cpVect tmp___60 ;
  cpFloat tmp___61 ;
  cpVect tmp___62 ;

  {
  switch ((((a > t) | ((b > t) << 1)) | ((c > t) << 2)) | ((d > t) << 3)) {
  case 1: 
  tmp = midlerp(x0, x1, a, b, t);
  tmp___0 = cpv((cpFloat const   )tmp, (cpFloat const   )y0___0);
  tmp___1 = midlerp(y0___0, y1___0, a, c, t);
  tmp___2 = cpv((cpFloat const   )x0, (cpFloat const   )tmp___1);
  seg(tmp___2, tmp___0, segment, segment_data);
  break;
  case 2: 
  tmp___3 = midlerp(y0___0, y1___0, b, d, t);
  tmp___4 = cpv((cpFloat const   )x1, (cpFloat const   )tmp___3);
  tmp___5 = midlerp(x0, x1, a, b, t);
  tmp___6 = cpv((cpFloat const   )tmp___5, (cpFloat const   )y0___0);
  seg(tmp___6, tmp___4, segment, segment_data);
  break;
  case 3: 
  tmp___7 = midlerp(y0___0, y1___0, b, d, t);
  tmp___8 = cpv((cpFloat const   )x1, (cpFloat const   )tmp___7);
  tmp___9 = midlerp(y0___0, y1___0, a, c, t);
  tmp___10 = cpv((cpFloat const   )x0, (cpFloat const   )tmp___9);
  seg(tmp___10, tmp___8, segment, segment_data);
  break;
  case 4: 
  tmp___11 = midlerp(y0___0, y1___0, a, c, t);
  tmp___12 = cpv((cpFloat const   )x0, (cpFloat const   )tmp___11);
  tmp___13 = midlerp(x0, x1, c, d, t);
  tmp___14 = cpv((cpFloat const   )tmp___13, (cpFloat const   )y1___0);
  seg(tmp___14, tmp___12, segment, segment_data);
  break;
  case 5: 
  tmp___15 = midlerp(x0, x1, a, b, t);
  tmp___16 = cpv((cpFloat const   )tmp___15, (cpFloat const   )y0___0);
  tmp___17 = midlerp(x0, x1, c, d, t);
  tmp___18 = cpv((cpFloat const   )tmp___17, (cpFloat const   )y1___0);
  seg(tmp___18, tmp___16, segment, segment_data);
  break;
  case 6: 
  tmp___19 = midlerp(y0___0, y1___0, b, d, t);
  tmp___20 = cpv((cpFloat const   )x1, (cpFloat const   )tmp___19);
  tmp___21 = midlerp(x0, x1, a, b, t);
  tmp___22 = cpv((cpFloat const   )tmp___21, (cpFloat const   )y0___0);
  seg(tmp___22, tmp___20, segment, segment_data);
  tmp___23 = midlerp(y0___0, y1___0, a, c, t);
  tmp___24 = cpv((cpFloat const   )x0, (cpFloat const   )tmp___23);
  tmp___25 = midlerp(x0, x1, c, d, t);
  tmp___26 = cpv((cpFloat const   )tmp___25, (cpFloat const   )y1___0);
  seg(tmp___26, tmp___24, segment, segment_data);
  break;
  case 7: 
  tmp___27 = midlerp(y0___0, y1___0, b, d, t);
  tmp___28 = cpv((cpFloat const   )x1, (cpFloat const   )tmp___27);
  tmp___29 = midlerp(x0, x1, c, d, t);
  tmp___30 = cpv((cpFloat const   )tmp___29, (cpFloat const   )y1___0);
  seg(tmp___30, tmp___28, segment, segment_data);
  break;
  case 8: 
  tmp___31 = midlerp(x0, x1, c, d, t);
  tmp___32 = cpv((cpFloat const   )tmp___31, (cpFloat const   )y1___0);
  tmp___33 = midlerp(y0___0, y1___0, b, d, t);
  tmp___34 = cpv((cpFloat const   )x1, (cpFloat const   )tmp___33);
  seg(tmp___34, tmp___32, segment, segment_data);
  break;
  case 9: 
  tmp___35 = midlerp(x0, x1, a, b, t);
  tmp___36 = cpv((cpFloat const   )tmp___35, (cpFloat const   )y0___0);
  tmp___37 = midlerp(y0___0, y1___0, a, c, t);
  tmp___38 = cpv((cpFloat const   )x0, (cpFloat const   )tmp___37);
  seg(tmp___38, tmp___36, segment, segment_data);
  tmp___39 = midlerp(x0, x1, c, d, t);
  tmp___40 = cpv((cpFloat const   )tmp___39, (cpFloat const   )y1___0);
  tmp___41 = midlerp(y0___0, y1___0, b, d, t);
  tmp___42 = cpv((cpFloat const   )x1, (cpFloat const   )tmp___41);
  seg(tmp___42, tmp___40, segment, segment_data);
  break;
  case 10: 
  tmp___43 = midlerp(x0, x1, c, d, t);
  tmp___44 = cpv((cpFloat const   )tmp___43, (cpFloat const   )y1___0);
  tmp___45 = midlerp(x0, x1, a, b, t);
  tmp___46 = cpv((cpFloat const   )tmp___45, (cpFloat const   )y0___0);
  seg(tmp___46, tmp___44, segment, segment_data);
  break;
  case 11: 
  tmp___47 = midlerp(x0, x1, c, d, t);
  tmp___48 = cpv((cpFloat const   )tmp___47, (cpFloat const   )y1___0);
  tmp___49 = midlerp(y0___0, y1___0, a, c, t);
  tmp___50 = cpv((cpFloat const   )x0, (cpFloat const   )tmp___49);
  seg(tmp___50, tmp___48, segment, segment_data);
  break;
  case 12: 
  tmp___51 = midlerp(y0___0, y1___0, a, c, t);
  tmp___52 = cpv((cpFloat const   )x0, (cpFloat const   )tmp___51);
  tmp___53 = midlerp(y0___0, y1___0, b, d, t);
  tmp___54 = cpv((cpFloat const   )x1, (cpFloat const   )tmp___53);
  seg(tmp___54, tmp___52, segment, segment_data);
  break;
  case 13: 
  tmp___55 = midlerp(x0, x1, a, b, t);
  tmp___56 = cpv((cpFloat const   )tmp___55, (cpFloat const   )y0___0);
  tmp___57 = midlerp(y0___0, y1___0, b, d, t);
  tmp___58 = cpv((cpFloat const   )x1, (cpFloat const   )tmp___57);
  seg(tmp___58, tmp___56, segment, segment_data);
  break;
  case 14: 
  tmp___59 = midlerp(y0___0, y1___0, a, c, t);
  tmp___60 = cpv((cpFloat const   )x0, (cpFloat const   )tmp___59);
  tmp___61 = midlerp(x0, x1, a, b, t);
  tmp___62 = cpv((cpFloat const   )tmp___61, (cpFloat const   )y0___0);
  seg(tmp___62, tmp___60, segment, segment_data);
  break;
  default: 
  break;
  }
  return;
}
}
void cpMarchSoft(cpBB bb , unsigned long x_samples , unsigned long y_samples , cpFloat t ,
                 void (*segment)(cpVect v0 , cpVect v1 , void *data ) , void *segment_data ,
                 cpFloat (*sample)(cpVect point , void *data ) , void *sample_data ) 
{ 


  {
  cpMarchCells(bb, x_samples, y_samples, t, segment, segment_data, sample, sample_data,
               & cpMarchCellSoft);
  return;
}
}
__inline static void segs(cpVect a , cpVect b , cpVect c , void (*f)(cpVect v0 , cpVect v1 ,
                                                                     void *data ) ,
                          void *data ) 
{ 


  {
  seg(b, c, f, data);
  seg(a, b, f, data);
  return;
}
}
static void cpMarchCellHard(cpFloat t , cpFloat a , cpFloat b , cpFloat c , cpFloat d ,
                            cpFloat x0 , cpFloat x1 , cpFloat y0___0 , cpFloat y1___0 ,
                            void (*segment)(cpVect v0 , cpVect v1 , void *data ) ,
                            void *segment_data ) 
{ 
  cpFloat xm ;
  cpFloat tmp ;
  cpFloat ym ;
  cpFloat tmp___0 ;
  cpVect tmp___1 ;
  cpVect tmp___2 ;
  cpVect tmp___3 ;
  cpVect tmp___4 ;
  cpVect tmp___5 ;
  cpVect tmp___6 ;
  cpVect tmp___7 ;
  cpVect tmp___8 ;
  cpVect tmp___9 ;
  cpVect tmp___10 ;
  cpVect tmp___11 ;
  cpVect tmp___12 ;
  cpVect tmp___13 ;
  cpVect tmp___14 ;
  cpVect tmp___15 ;
  cpVect tmp___16 ;
  cpVect tmp___17 ;
  cpVect tmp___18 ;
  cpVect tmp___19 ;
  cpVect tmp___20 ;
  cpVect tmp___21 ;
  cpVect tmp___22 ;
  cpVect tmp___23 ;
  cpVect tmp___24 ;
  cpVect tmp___25 ;
  cpVect tmp___26 ;
  cpVect tmp___27 ;
  cpVect tmp___28 ;
  cpVect tmp___29 ;
  cpVect tmp___30 ;
  cpVect tmp___31 ;
  cpVect tmp___32 ;
  cpVect tmp___33 ;
  cpVect tmp___34 ;
  cpVect tmp___35 ;
  cpVect tmp___36 ;
  cpVect tmp___37 ;
  cpVect tmp___38 ;
  cpVect tmp___39 ;
  cpVect tmp___40 ;
  cpVect tmp___41 ;
  cpVect tmp___42 ;
  cpVect tmp___43 ;
  cpVect tmp___44 ;

  {
  tmp = cpflerp(x0, x1, (cpFloat )0.5f);
  xm = tmp;
  tmp___0 = cpflerp(y0___0, y1___0, (cpFloat )0.5f);
  ym = tmp___0;
  switch ((((a > t) | ((b > t) << 1)) | ((c > t) << 2)) | ((d > t) << 3)) {
  case 1: 
  tmp___1 = cpv((cpFloat const   )xm, (cpFloat const   )y0___0);
  tmp___2 = cpv((cpFloat const   )xm, (cpFloat const   )ym);
  tmp___3 = cpv((cpFloat const   )x0, (cpFloat const   )ym);
  segs(tmp___3, tmp___2, tmp___1, segment, segment_data);
  break;
  case 2: 
  tmp___4 = cpv((cpFloat const   )x1, (cpFloat const   )ym);
  tmp___5 = cpv((cpFloat const   )xm, (cpFloat const   )ym);
  tmp___6 = cpv((cpFloat const   )xm, (cpFloat const   )y0___0);
  segs(tmp___6, tmp___5, tmp___4, segment, segment_data);
  break;
  case 3: 
  tmp___7 = cpv((cpFloat const   )x1, (cpFloat const   )ym);
  tmp___8 = cpv((cpFloat const   )x0, (cpFloat const   )ym);
  seg(tmp___8, tmp___7, segment, segment_data);
  break;
  case 4: 
  tmp___9 = cpv((cpFloat const   )x0, (cpFloat const   )ym);
  tmp___10 = cpv((cpFloat const   )xm, (cpFloat const   )ym);
  tmp___11 = cpv((cpFloat const   )xm, (cpFloat const   )y1___0);
  segs(tmp___11, tmp___10, tmp___9, segment, segment_data);
  break;
  case 5: 
  tmp___12 = cpv((cpFloat const   )xm, (cpFloat const   )y0___0);
  tmp___13 = cpv((cpFloat const   )xm, (cpFloat const   )y1___0);
  seg(tmp___13, tmp___12, segment, segment_data);
  break;
  case 6: 
  tmp___14 = cpv((cpFloat const   )x0, (cpFloat const   )ym);
  tmp___15 = cpv((cpFloat const   )xm, (cpFloat const   )ym);
  tmp___16 = cpv((cpFloat const   )xm, (cpFloat const   )y0___0);
  segs(tmp___16, tmp___15, tmp___14, segment, segment_data);
  tmp___17 = cpv((cpFloat const   )x1, (cpFloat const   )ym);
  tmp___18 = cpv((cpFloat const   )xm, (cpFloat const   )ym);
  tmp___19 = cpv((cpFloat const   )xm, (cpFloat const   )y1___0);
  segs(tmp___19, tmp___18, tmp___17, segment, segment_data);
  break;
  case 7: 
  tmp___20 = cpv((cpFloat const   )x1, (cpFloat const   )ym);
  tmp___21 = cpv((cpFloat const   )xm, (cpFloat const   )ym);
  tmp___22 = cpv((cpFloat const   )xm, (cpFloat const   )y1___0);
  segs(tmp___22, tmp___21, tmp___20, segment, segment_data);
  break;
  case 8: 
  tmp___23 = cpv((cpFloat const   )xm, (cpFloat const   )y1___0);
  tmp___24 = cpv((cpFloat const   )xm, (cpFloat const   )ym);
  tmp___25 = cpv((cpFloat const   )x1, (cpFloat const   )ym);
  segs(tmp___25, tmp___24, tmp___23, segment, segment_data);
  break;
  case 9: 
  tmp___26 = cpv((cpFloat const   )xm, (cpFloat const   )y0___0);
  tmp___27 = cpv((cpFloat const   )xm, (cpFloat const   )ym);
  tmp___28 = cpv((cpFloat const   )x1, (cpFloat const   )ym);
  segs(tmp___28, tmp___27, tmp___26, segment, segment_data);
  tmp___29 = cpv((cpFloat const   )xm, (cpFloat const   )y1___0);
  tmp___30 = cpv((cpFloat const   )xm, (cpFloat const   )ym);
  tmp___31 = cpv((cpFloat const   )x0, (cpFloat const   )ym);
  segs(tmp___31, tmp___30, tmp___29, segment, segment_data);
  break;
  case 10: 
  tmp___32 = cpv((cpFloat const   )xm, (cpFloat const   )y1___0);
  tmp___33 = cpv((cpFloat const   )xm, (cpFloat const   )y0___0);
  seg(tmp___33, tmp___32, segment, segment_data);
  break;
  case 11: 
  tmp___34 = cpv((cpFloat const   )xm, (cpFloat const   )y1___0);
  tmp___35 = cpv((cpFloat const   )xm, (cpFloat const   )ym);
  tmp___36 = cpv((cpFloat const   )x0, (cpFloat const   )ym);
  segs(tmp___36, tmp___35, tmp___34, segment, segment_data);
  break;
  case 12: 
  tmp___37 = cpv((cpFloat const   )x0, (cpFloat const   )ym);
  tmp___38 = cpv((cpFloat const   )x1, (cpFloat const   )ym);
  seg(tmp___38, tmp___37, segment, segment_data);
  break;
  case 13: 
  tmp___39 = cpv((cpFloat const   )xm, (cpFloat const   )y0___0);
  tmp___40 = cpv((cpFloat const   )xm, (cpFloat const   )ym);
  tmp___41 = cpv((cpFloat const   )x1, (cpFloat const   )ym);
  segs(tmp___41, tmp___40, tmp___39, segment, segment_data);
  break;
  case 14: 
  tmp___42 = cpv((cpFloat const   )x0, (cpFloat const   )ym);
  tmp___43 = cpv((cpFloat const   )xm, (cpFloat const   )ym);
  tmp___44 = cpv((cpFloat const   )xm, (cpFloat const   )y0___0);
  segs(tmp___44, tmp___43, tmp___42, segment, segment_data);
  break;
  default: 
  break;
  }
  return;
}
}
void cpMarchHard(cpBB bb , unsigned long x_samples , unsigned long y_samples , cpFloat t ,
                 void (*segment)(cpVect v0 , cpVect v1 , void *data ) , void *segment_data ,
                 cpFloat (*sample)(cpVect point , void *data ) , void *sample_data ) 
{ 


  {
  cpMarchCells(bb, x_samples, y_samples, t, segment, segment_data, sample, sample_data,
               & cpMarchCellHard);
  return;
}
}
#pragma merger("0","/tmp/cil-BebFPtEd.i","-std=gnu99,-ffast-math,-fPIC")
cpBool cpConstraintIsPinJoint(cpConstraint const   *constraint ) ;
cpPinJoint *cpPinJointAlloc(void) ;
cpPinJoint *cpPinJointInit(cpPinJoint *joint , cpBody *a , cpBody *b , cpVect anchorA ,
                           cpVect anchorB ) ;
cpConstraint *cpPinJointNew(cpBody *a , cpBody *b , cpVect anchorA , cpVect anchorB ) ;
cpVect cpPinJointGetAnchorA(cpConstraint const   *constraint ) ;
void cpPinJointSetAnchorA(cpConstraint *constraint , cpVect anchorA ) ;
cpVect cpPinJointGetAnchorB(cpConstraint const   *constraint ) ;
void cpPinJointSetAnchorB(cpConstraint *constraint , cpVect anchorB ) ;
cpFloat cpPinJointGetDist(cpConstraint const   *constraint ) ;
void cpPinJointSetDist(cpConstraint *constraint , cpFloat dist ) ;
static void preStep___3(cpPinJoint *joint , cpFloat dt ) 
{ 
  cpBody *a ;
  cpBody *b ;
  cpVect tmp ;
  cpVect tmp___0 ;
  cpVect delta ;
  cpVect tmp___1 ;
  cpVect tmp___2 ;
  cpVect tmp___3 ;
  cpFloat dist ;
  cpFloat tmp___4 ;
  float tmp___5 ;
  cpFloat tmp___6 ;
  cpFloat tmp___7 ;
  cpFloat maxBias ;
  cpFloat tmp___8 ;

  {
  a = joint->constraint.a;
  b = joint->constraint.b;
  tmp = cpvsub((cpVect const   )joint->anchorA, (cpVect const   )a->cog);
  joint->r1 = cpTransformVect(a->transform, tmp);
  tmp___0 = cpvsub((cpVect const   )joint->anchorB, (cpVect const   )b->cog);
  joint->r2 = cpTransformVect(b->transform, tmp___0);
  tmp___1 = cpvadd((cpVect const   )a->p, (cpVect const   )joint->r1);
  tmp___2 = cpvadd((cpVect const   )b->p, (cpVect const   )joint->r2);
  tmp___3 = cpvsub((cpVect const   )tmp___2, (cpVect const   )tmp___1);
  delta = tmp___3;
  tmp___4 = cpvlength((cpVect const   )delta);
  dist = tmp___4;
  if (dist) {
    tmp___6 = dist;
  } else {
    tmp___5 = __builtin_inff();
    tmp___6 = (cpFloat )tmp___5;
  }
  joint->n = cpvmult((cpVect const   )delta, (cpFloat const   )((cpFloat )1.0f / tmp___6));
  tmp___7 = k_scalar(a, b, joint->r1, joint->r2, joint->n);
  joint->nMass = (cpFloat )1.0f / tmp___7;
  maxBias = joint->constraint.maxBias;
  tmp___8 = bias_coef(joint->constraint.errorBias, dt);
  joint->bias = cpfclamp((- tmp___8 * (dist - joint->dist)) / dt, - maxBias, maxBias);
  return;
}
}
static void applyCachedImpulse___3(cpPinJoint *joint , cpFloat dt_coef ) 
{ 
  cpBody *a ;
  cpBody *b ;
  cpVect j ;
  cpVect tmp ;

  {
  a = joint->constraint.a;
  b = joint->constraint.b;
  tmp = cpvmult((cpVect const   )joint->n, (cpFloat const   )(joint->jnAcc * dt_coef));
  j = tmp;
  apply_impulses(a, b, joint->r1, joint->r2, j);
  return;
}
}
static void applyImpulse___3(cpPinJoint *joint , cpFloat dt ) 
{ 
  cpBody *a ;
  cpBody *b ;
  cpVect n ;
  cpFloat vrn ;
  cpFloat tmp ;
  cpFloat jnMax ;
  cpFloat jn___0 ;
  cpFloat jnOld ;
  cpVect tmp___0 ;

  {
  a = joint->constraint.a;
  b = joint->constraint.b;
  n = joint->n;
  tmp = normal_relative_velocity(a, b, joint->r1, joint->r2, n);
  vrn = tmp;
  jnMax = joint->constraint.maxForce * dt;
  jn___0 = (joint->bias - vrn) * joint->nMass;
  jnOld = joint->jnAcc;
  joint->jnAcc = cpfclamp(jnOld + jn___0, - jnMax, jnMax);
  jn___0 = joint->jnAcc - jnOld;
  tmp___0 = cpvmult((cpVect const   )n, (cpFloat const   )jn___0);
  apply_impulses(a, b, joint->r1, joint->r2, tmp___0);
  return;
}
}
static cpFloat getImpulse___3(cpPinJoint *joint ) 
{ 
  cpFloat tmp ;

  {
  tmp = cpfabs(joint->jnAcc);
  return (tmp);
}
}
static struct cpConstraintClass  const  klass___4  =    {(void (*)(cpConstraint *constraint , cpFloat dt ))(& preStep___3), (void (*)(cpConstraint *constraint ,
                                                                                 cpFloat dt_coef ))(& applyCachedImpulse___3),
    (void (*)(cpConstraint *constraint , cpFloat dt ))(& applyImpulse___3), (cpFloat (*)(cpConstraint *constraint ))(& getImpulse___3)};
cpPinJoint *cpPinJointAlloc(void) 
{ 
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(cpPinJoint ));
  return ((cpPinJoint *)tmp);
}
}
cpPinJoint *cpPinJointInit(cpPinJoint *joint , cpBody *a , cpBody *b , cpVect anchorA ,
                           cpVect anchorB ) 
{ 
  cpVect p1 ;
  cpVect tmp ;
  cpVect tmp___0 ;
  cpVect p2 ;
  cpVect tmp___1 ;
  cpVect tmp___2 ;
  cpVect tmp___3 ;

  {
  cpConstraintInit((cpConstraint *)joint, & klass___4, a, b);
  joint->anchorA = anchorA;
  joint->anchorB = anchorB;
  if (a) {
    tmp = cpTransformPoint(a->transform, anchorA);
    tmp___0 = tmp;
  } else {
    tmp___0 = anchorA;
  }
  p1 = tmp___0;
  if (b) {
    tmp___1 = cpTransformPoint(b->transform, anchorB);
    tmp___2 = tmp___1;
  } else {
    tmp___2 = anchorB;
  }
  p2 = tmp___2;
  tmp___3 = cpvsub((cpVect const   )p2, (cpVect const   )p1);
  joint->dist = cpvlength((cpVect const   )tmp___3);
  joint->jnAcc = (cpFloat )0.0f;
  return (joint);
}
}
cpConstraint *cpPinJointNew(cpBody *a , cpBody *b , cpVect anchorA , cpVect anchorB ) 
{ 
  cpPinJoint *tmp ;
  cpPinJoint *tmp___0 ;

  {
  tmp = cpPinJointAlloc();
  tmp___0 = cpPinJointInit(tmp, a, b, anchorA, anchorB);
  return ((cpConstraint *)tmp___0);
}
}
cpBool cpConstraintIsPinJoint(cpConstraint const   *constraint ) 
{ 


  {
  return ((cpBool )((unsigned long )constraint->klass == (unsigned long )(& klass___4)));
}
}
cpVect cpPinJointGetAnchorA(cpConstraint const   *constraint ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsPinJoint(constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsPinJoint(constraint)", "../src/cpPinJoint.c", 132, 1,
              1, "Constraint is not a pin joint.");
    abort();
  }
  return (((cpPinJoint *)constraint)->anchorA);
}
}
void cpPinJointSetAnchorA(cpConstraint *constraint , cpVect anchorA ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsPinJoint((cpConstraint const   *)constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsPinJoint(constraint)", "../src/cpPinJoint.c", 139, 1,
              1, "Constraint is not a pin joint.");
    abort();
  }
  cpConstraintActivateBodies(constraint);
  ((cpPinJoint *)constraint)->anchorA = anchorA;
  return;
}
}
cpVect cpPinJointGetAnchorB(cpConstraint const   *constraint ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsPinJoint(constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsPinJoint(constraint)", "../src/cpPinJoint.c", 147, 1,
              1, "Constraint is not a pin joint.");
    abort();
  }
  return (((cpPinJoint *)constraint)->anchorB);
}
}
void cpPinJointSetAnchorB(cpConstraint *constraint , cpVect anchorB ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsPinJoint((cpConstraint const   *)constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsPinJoint(constraint)", "../src/cpPinJoint.c", 154, 1,
              1, "Constraint is not a pin joint.");
    abort();
  }
  cpConstraintActivateBodies(constraint);
  ((cpPinJoint *)constraint)->anchorB = anchorB;
  return;
}
}
cpFloat cpPinJointGetDist(cpConstraint const   *constraint ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsPinJoint(constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsPinJoint(constraint)", "../src/cpPinJoint.c", 162, 1,
              1, "Constraint is not a pin joint.");
    abort();
  }
  return (((cpPinJoint *)constraint)->dist);
}
}
void cpPinJointSetDist(cpConstraint *constraint , cpFloat dist ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsPinJoint((cpConstraint const   *)constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsPinJoint(constraint)", "../src/cpPinJoint.c", 169, 1,
              1, "Constraint is not a pin joint.");
    abort();
  }
  cpConstraintActivateBodies(constraint);
  ((cpPinJoint *)constraint)->dist = dist;
  return;
}
}
#pragma merger("0","/tmp/cil-JYcPKsts.i","-std=gnu99,-ffast-math,-fPIC")
static struct cpVect  const  cpvzero___4  =    {(cpFloat )0.0f, (cpFloat )0.0f};
cpBool cpConstraintIsPivotJoint(cpConstraint const   *constraint ) ;
cpPivotJoint *cpPivotJointAlloc(void) ;
cpPivotJoint *cpPivotJointInit(cpPivotJoint *joint , cpBody *a , cpBody *b , cpVect anchorA ,
                               cpVect anchorB ) ;
cpConstraint *cpPivotJointNew(cpBody *a , cpBody *b , cpVect pivot ) ;
cpConstraint *cpPivotJointNew2(cpBody *a , cpBody *b , cpVect anchorA , cpVect anchorB ) ;
cpVect cpPivotJointGetAnchorA(cpConstraint const   *constraint ) ;
void cpPivotJointSetAnchorA(cpConstraint *constraint , cpVect anchorA ) ;
cpVect cpPivotJointGetAnchorB(cpConstraint const   *constraint ) ;
void cpPivotJointSetAnchorB(cpConstraint *constraint , cpVect anchorB ) ;
static void preStep___4(cpPivotJoint *joint , cpFloat dt ) 
{ 
  cpBody *a ;
  cpBody *b ;
  cpVect tmp ;
  cpVect tmp___0 ;
  cpVect delta ;
  cpVect tmp___1 ;
  cpVect tmp___2 ;
  cpVect tmp___3 ;
  cpFloat tmp___4 ;
  cpVect tmp___5 ;

  {
  a = joint->constraint.a;
  b = joint->constraint.b;
  tmp = cpvsub((cpVect const   )joint->anchorA, (cpVect const   )a->cog);
  joint->r1 = cpTransformVect(a->transform, tmp);
  tmp___0 = cpvsub((cpVect const   )joint->anchorB, (cpVect const   )b->cog);
  joint->r2 = cpTransformVect(b->transform, tmp___0);
  joint->k = k_tensor(a, b, joint->r1, joint->r2);
  tmp___1 = cpvadd((cpVect const   )a->p, (cpVect const   )joint->r1);
  tmp___2 = cpvadd((cpVect const   )b->p, (cpVect const   )joint->r2);
  tmp___3 = cpvsub((cpVect const   )tmp___2, (cpVect const   )tmp___1);
  delta = tmp___3;
  tmp___4 = bias_coef(joint->constraint.errorBias, dt);
  tmp___5 = cpvmult((cpVect const   )delta, (cpFloat const   )(- tmp___4 / dt));
  joint->bias = cpvclamp((cpVect const   )tmp___5, (cpFloat const   )joint->constraint.maxBias);
  return;
}
}
static void applyCachedImpulse___4(cpPivotJoint *joint , cpFloat dt_coef ) 
{ 
  cpBody *a ;
  cpBody *b ;
  cpVect tmp ;

  {
  a = joint->constraint.a;
  b = joint->constraint.b;
  tmp = cpvmult((cpVect const   )joint->jAcc, (cpFloat const   )dt_coef);
  apply_impulses(a, b, joint->r1, joint->r2, tmp);
  return;
}
}
static void applyImpulse___4(cpPivotJoint *joint , cpFloat dt ) 
{ 
  cpBody *a ;
  cpBody *b ;
  cpVect r1 ;
  cpVect r2 ;
  cpVect vr ;
  cpVect tmp ;
  cpVect j ;
  cpVect tmp___0 ;
  cpVect tmp___1 ;
  cpVect jOld ;
  cpVect tmp___2 ;

  {
  a = joint->constraint.a;
  b = joint->constraint.b;
  r1 = joint->r1;
  r2 = joint->r2;
  tmp = relative_velocity(a, b, r1, r2);
  vr = tmp;
  tmp___0 = cpvsub((cpVect const   )joint->bias, (cpVect const   )vr);
  tmp___1 = cpMat2x2Transform(joint->k, tmp___0);
  j = tmp___1;
  jOld = joint->jAcc;
  tmp___2 = cpvadd((cpVect const   )joint->jAcc, (cpVect const   )j);
  joint->jAcc = cpvclamp((cpVect const   )tmp___2, (cpFloat const   )(joint->constraint.maxForce * dt));
  j = cpvsub((cpVect const   )joint->jAcc, (cpVect const   )jOld);
  apply_impulses(a, b, joint->r1, joint->r2, j);
  return;
}
}
static cpFloat getImpulse___4(cpConstraint *joint ) 
{ 
  cpFloat tmp ;

  {
  tmp = cpvlength((cpVect const   )((cpPivotJoint *)joint)->jAcc);
  return (tmp);
}
}
static struct cpConstraintClass  const  klass___5  =    {(void (*)(cpConstraint *constraint , cpFloat dt ))(& preStep___4), (void (*)(cpConstraint *constraint ,
                                                                                 cpFloat dt_coef ))(& applyCachedImpulse___4),
    (void (*)(cpConstraint *constraint , cpFloat dt ))(& applyImpulse___4), & getImpulse___4};
cpPivotJoint *cpPivotJointAlloc(void) 
{ 
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(cpPivotJoint ));
  return ((cpPivotJoint *)tmp);
}
}
cpPivotJoint *cpPivotJointInit(cpPivotJoint *joint , cpBody *a , cpBody *b , cpVect anchorA ,
                               cpVect anchorB ) 
{ 


  {
  cpConstraintInit((cpConstraint *)joint, & klass___5, a, b);
  joint->anchorA = anchorA;
  joint->anchorB = anchorB;
  joint->jAcc = (cpVect )cpvzero___4;
  return (joint);
}
}
cpConstraint *cpPivotJointNew2(cpBody *a , cpBody *b , cpVect anchorA , cpVect anchorB ) 
{ 
  cpPivotJoint *tmp ;
  cpPivotJoint *tmp___0 ;

  {
  tmp = cpPivotJointAlloc();
  tmp___0 = cpPivotJointInit(tmp, a, b, anchorA, anchorB);
  return ((cpConstraint *)tmp___0);
}
}
cpConstraint *cpPivotJointNew(cpBody *a , cpBody *b , cpVect pivot ) 
{ 
  cpVect anchorA ;
  cpVect tmp ;
  cpVect tmp___0 ;
  cpVect anchorB ;
  cpVect tmp___1 ;
  cpVect tmp___2 ;
  cpConstraint *tmp___3 ;

  {
  if (a) {
    tmp = cpBodyWorldToLocal((cpBody const   *)a, (cpVect const   )pivot);
    tmp___0 = tmp;
  } else {
    tmp___0 = pivot;
  }
  anchorA = tmp___0;
  if (b) {
    tmp___1 = cpBodyWorldToLocal((cpBody const   *)b, (cpVect const   )pivot);
    tmp___2 = tmp___1;
  } else {
    tmp___2 = pivot;
  }
  anchorB = tmp___2;
  tmp___3 = cpPivotJointNew2(a, b, anchorA, anchorB);
  return (tmp___3);
}
}
cpBool cpConstraintIsPivotJoint(cpConstraint const   *constraint ) 
{ 


  {
  return ((cpBool )((unsigned long )constraint->klass == (unsigned long )(& klass___5)));
}
}
cpVect cpPivotJointGetAnchorA(cpConstraint const   *constraint ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsPivotJoint(constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsPivotJoint(constraint)", "../src/cpPivotJoint.c", 127,
              1, 1, "Constraint is not a pivot joint.");
    abort();
  }
  return (((cpPivotJoint *)constraint)->anchorA);
}
}
void cpPivotJointSetAnchorA(cpConstraint *constraint , cpVect anchorA ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsPivotJoint((cpConstraint const   *)constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsPivotJoint(constraint)", "../src/cpPivotJoint.c", 134,
              1, 1, "Constraint is not a pivot joint.");
    abort();
  }
  cpConstraintActivateBodies(constraint);
  ((cpPivotJoint *)constraint)->anchorA = anchorA;
  return;
}
}
cpVect cpPivotJointGetAnchorB(cpConstraint const   *constraint ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsPivotJoint(constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsPivotJoint(constraint)", "../src/cpPivotJoint.c", 142,
              1, 1, "Constraint is not a pivot joint.");
    abort();
  }
  return (((cpPivotJoint *)constraint)->anchorB);
}
}
void cpPivotJointSetAnchorB(cpConstraint *constraint , cpVect anchorB ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsPivotJoint((cpConstraint const   *)constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsPivotJoint(constraint)", "../src/cpPivotJoint.c", 149,
              1, 1, "Constraint is not a pivot joint.");
    abort();
  }
  cpConstraintActivateBodies(constraint);
  ((cpPivotJoint *)constraint)->anchorB = anchorB;
  return;
}
}
#pragma merger("0","/tmp/cil-N6BoeIbi.i","-std=gnu99,-ffast-math,-fPIC")
static struct cpVect  const  cpvzero___5  =    {(cpFloat )0.0f, (cpFloat )0.0f};
cpPolyShape *cpPolyShapeAlloc(void) ;
cpPolyShape *cpPolyShapeInit(cpPolyShape *poly , cpBody *body , int count , cpVect const   *verts ,
                             cpTransform transform , cpFloat radius ) ;
cpPolyShape *cpPolyShapeInitRaw(cpPolyShape *poly , cpBody *body , int count , cpVect const   *verts ,
                                cpFloat radius ) ;
cpShape *cpPolyShapeNew(cpBody *body , int count , cpVect const   *verts , cpTransform transform ,
                        cpFloat radius ) ;
cpShape *cpPolyShapeNewRaw(cpBody *body , int count , cpVect const   *verts , cpFloat radius ) ;
cpPolyShape *cpBoxShapeInit(cpPolyShape *poly , cpBody *body , cpFloat width , cpFloat height ,
                            cpFloat radius ) ;
cpPolyShape *cpBoxShapeInit2(cpPolyShape *poly , cpBody *body , cpBB box , cpFloat radius ) ;
cpShape *cpBoxShapeNew(cpBody *body , cpFloat width , cpFloat height , cpFloat radius ) ;
cpShape *cpBoxShapeNew2(cpBody *body , cpBB box , cpFloat radius ) ;
int cpPolyShapeGetCount(cpShape const   *shape ) ;
cpVect cpPolyShapeGetVert(cpShape const   *shape , int i ) ;
cpFloat cpPolyShapeGetRadius(cpShape const   *shape ) ;
__inline static cpVect cpClosetPointOnSegment(cpVect const   p , cpVect const   a ,
                                              cpVect const   b ) 
{ 
  cpVect delta ;
  cpVect tmp ;
  cpFloat t ;
  cpVect tmp___0 ;
  cpFloat tmp___1 ;
  cpFloat tmp___2 ;
  cpFloat tmp___3 ;
  cpVect tmp___4 ;
  cpVect tmp___5 ;

  {
  tmp = cpvsub(a, b);
  delta = tmp;
  tmp___0 = cpvsub(p, b);
  tmp___1 = cpvdot((cpVect const   )delta, (cpVect const   )tmp___0);
  tmp___2 = cpvlengthsq((cpVect const   )delta);
  tmp___3 = cpfclamp01(tmp___1 / tmp___2);
  t = tmp___3;
  tmp___4 = cpvmult((cpVect const   )delta, (cpFloat const   )t);
  tmp___5 = cpvadd(b, (cpVect const   )tmp___4);
  return (tmp___5);
}
}
cpShape *cpShapeInit(cpShape *shape , cpShapeClass const   *klass___12 , cpBody *body ,
                     struct cpShapeMassInfo massInfo ) ;
__inline static void CircleSegmentQuery(cpShape *shape , cpVect center , cpFloat r1 ,
                                        cpVect a , cpVect b , cpFloat r2 , cpSegmentQueryInfo *info ) 
{ 
  cpVect da ;
  cpVect tmp ;
  cpVect db ;
  cpVect tmp___0 ;
  cpFloat rsum ;
  cpFloat qa ;
  cpFloat tmp___1 ;
  cpFloat tmp___2 ;
  cpFloat tmp___3 ;
  cpFloat qb ;
  cpFloat tmp___4 ;
  cpFloat tmp___5 ;
  cpFloat det ;
  cpFloat tmp___6 ;
  cpFloat t ;
  double tmp___7 ;
  cpVect n ;
  cpVect tmp___8 ;
  cpVect tmp___9 ;
  cpVect tmp___10 ;
  cpVect tmp___11 ;

  {
  tmp = cpvsub((cpVect const   )a, (cpVect const   )center);
  da = tmp;
  tmp___0 = cpvsub((cpVect const   )b, (cpVect const   )center);
  db = tmp___0;
  rsum = r1 + r2;
  tmp___1 = cpvdot((cpVect const   )da, (cpVect const   )da);
  tmp___2 = cpvdot((cpVect const   )da, (cpVect const   )db);
  tmp___3 = cpvdot((cpVect const   )db, (cpVect const   )db);
  qa = (tmp___1 - (cpFloat )2.0f * tmp___2) + tmp___3;
  tmp___4 = cpvdot((cpVect const   )da, (cpVect const   )db);
  tmp___5 = cpvdot((cpVect const   )da, (cpVect const   )da);
  qb = tmp___4 - tmp___5;
  tmp___6 = cpvdot((cpVect const   )da, (cpVect const   )da);
  det = qb * qb - qa * (tmp___6 - rsum * rsum);
  if (det >= (cpFloat )0.0f) {
    tmp___7 = sqrt(det);
    t = (- qb - tmp___7) / qa;
    if ((cpFloat )0.0f <= t) {
      if (t <= (cpFloat )1.0f) {
        tmp___8 = cpvlerp((cpVect const   )da, (cpVect const   )db, (cpFloat const   )t);
        tmp___9 = cpvnormalize((cpVect const   )tmp___8);
        n = tmp___9;
        info->shape = (cpShape const   *)shape;
        tmp___10 = cpvmult((cpVect const   )n, (cpFloat const   )r2);
        tmp___11 = cpvlerp((cpVect const   )a, (cpVect const   )b, (cpFloat const   )t);
        info->point = cpvsub((cpVect const   )tmp___11, (cpVect const   )tmp___10);
        info->normal = n;
        info->alpha = t;
      }
    }
  }
  return;
}
}
void cpPolyShapeSetVerts(cpShape *shape , int count , cpVect *verts , cpTransform transform ) ;
void cpPolyShapeSetVertsRaw(cpShape *shape , int count , cpVect *verts ) ;
void cpPolyShapeSetRadius(cpShape *shape , cpFloat radius ) ;
cpPolyShape *cpPolyShapeAlloc(void) 
{ 
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(cpPolyShape ));
  return ((cpPolyShape *)tmp);
}
}
static void cpPolyShapeDestroy(cpPolyShape *poly ) 
{ 


  {
  if (poly->count > 6) {
    free((void *)poly->planes);
  }
  return;
}
}
static cpBB cpPolyShapeCacheData(cpPolyShape *poly , cpTransform transform ) 
{ 
  int count ;
  struct cpSplittingPlane *dst ;
  struct cpSplittingPlane *src ;
  cpFloat l ;
  float tmp ;
  cpFloat r ;
  float tmp___0 ;
  cpFloat b ;
  float tmp___1 ;
  cpFloat t ;
  float tmp___2 ;
  int i ;
  cpVect v ;
  cpVect tmp___3 ;
  cpVect n ;
  cpVect tmp___4 ;
  cpFloat radius ;
  cpBB tmp___5 ;

  {
  count = poly->count;
  dst = poly->planes;
  src = dst + count;
  tmp = __builtin_inff();
  l = (cpFloat )tmp;
  tmp___0 = __builtin_inff();
  r = - ((cpFloat )tmp___0);
  tmp___1 = __builtin_inff();
  b = (cpFloat )tmp___1;
  tmp___2 = __builtin_inff();
  t = - ((cpFloat )tmp___2);
  i = 0;
  while (i < count) {
    tmp___3 = cpTransformPoint(transform, (src + i)->v0);
    v = tmp___3;
    tmp___4 = cpTransformVect(transform, (src + i)->n);
    n = tmp___4;
    (dst + i)->v0 = v;
    (dst + i)->n = n;
    l = cpfmin(l, v.x);
    r = cpfmax(r, v.x);
    b = cpfmin(b, v.y);
    t = cpfmax(t, v.y);
    i ++;
  }
  radius = poly->r;
  tmp___5 = cpBBNew((cpFloat const   )(l - radius), (cpFloat const   )(b - radius),
                    (cpFloat const   )(r + radius), (cpFloat const   )(t + radius));
  poly->shape.bb = tmp___5;
  return (tmp___5);
}
}
static void cpPolyShapePointQuery(cpPolyShape *poly , cpVect p , cpPointQueryInfo *info ) 
{ 
  int count ;
  struct cpSplittingPlane *planes ;
  cpFloat r ;
  cpVect v0 ;
  cpFloat minDist ;
  float tmp ;
  cpVect closestPoint ;
  cpVect closestNormal ;
  cpBool outside ;
  int i ;
  cpVect v1 ;
  cpVect tmp___0 ;
  cpFloat tmp___1 ;
  int tmp___2 ;
  cpVect closest ;
  cpVect tmp___3 ;
  cpFloat dist ;
  cpFloat tmp___4 ;
  cpFloat dist___0 ;
  cpFloat tmp___5 ;
  cpVect g ;
  cpVect tmp___6 ;
  cpVect tmp___7 ;
  cpVect tmp___8 ;

  {
  count = poly->count;
  planes = poly->planes;
  r = poly->r;
  v0 = (planes + (count - 1))->v0;
  tmp = __builtin_inff();
  minDist = (cpFloat )tmp;
  closestPoint = cpvzero___5;
  closestNormal = cpvzero___5;
  outside = (cpBool )0;
  i = 0;
  while (i < count) {
    v1 = (planes + i)->v0;
    if (outside) {
      tmp___2 = 1;
    } else {
      tmp___0 = cpvsub((cpVect const   )p, (cpVect const   )v1);
      tmp___1 = cpvdot((cpVect const   )(planes + i)->n, (cpVect const   )tmp___0);
      if (tmp___1 > (cpFloat )0.0f) {
        tmp___2 = 1;
      } else {
        tmp___2 = 0;
      }
    }
    outside = (cpBool )tmp___2;
    tmp___3 = cpClosetPointOnSegment((cpVect const   )p, (cpVect const   )v0, (cpVect const   )v1);
    closest = tmp___3;
    tmp___4 = cpvdist((cpVect const   )p, (cpVect const   )closest);
    dist = tmp___4;
    if (dist < minDist) {
      minDist = dist;
      closestPoint = closest;
      closestNormal = (planes + i)->n;
    }
    v0 = v1;
    i ++;
  }
  if (outside) {
    tmp___5 = minDist;
  } else {
    tmp___5 = - minDist;
  }
  dist___0 = tmp___5;
  tmp___6 = cpvsub((cpVect const   )p, (cpVect const   )closestPoint);
  tmp___7 = cpvmult((cpVect const   )tmp___6, (cpFloat const   )((cpFloat )1.0f / dist___0));
  g = tmp___7;
  info->shape = (cpShape const   *)((cpShape *)poly);
  tmp___8 = cpvmult((cpVect const   )g, (cpFloat const   )r);
  info->point = cpvadd((cpVect const   )closestPoint, (cpVect const   )tmp___8);
  info->distance = dist___0 - r;
  if (minDist > 1e-5) {
    info->gradient = g;
  } else {
    info->gradient = closestNormal;
  }
  return;
}
}
static void cpPolyShapeSegmentQuery(cpPolyShape *poly , cpVect a , cpVect b , cpFloat r2 ,
                                    cpSegmentQueryInfo *info ) 
{ 
  struct cpSplittingPlane *planes ;
  int count ;
  cpFloat r ;
  cpFloat rsum ;
  int i ;
  cpVect n ;
  cpFloat an ;
  cpFloat tmp ;
  cpFloat d ;
  cpFloat tmp___0 ;
  cpFloat bn ;
  cpFloat tmp___1 ;
  cpFloat t ;
  cpFloat tmp___2 ;
  cpVect point ;
  cpVect tmp___3 ;
  cpFloat dt ;
  cpFloat tmp___4 ;
  cpFloat dtMin ;
  cpFloat tmp___5 ;
  cpFloat dtMax ;
  cpFloat tmp___6 ;
  cpVect tmp___7 ;
  cpVect tmp___8 ;
  int i___0 ;
  cpSegmentQueryInfo circle_info ;

  {
  planes = poly->planes;
  count = poly->count;
  r = poly->r;
  rsum = r + r2;
  i = 0;
  while (i < count) {
    n = (planes + i)->n;
    tmp = cpvdot((cpVect const   )a, (cpVect const   )n);
    an = tmp;
    tmp___0 = cpvdot((cpVect const   )(planes + i)->v0, (cpVect const   )n);
    d = (an - tmp___0) - rsum;
    if (d < (cpFloat )0.0f) {
      goto __Cont;
    }
    tmp___1 = cpvdot((cpVect const   )b, (cpVect const   )n);
    bn = tmp___1;
    tmp___2 = cpfmax(an - bn, 2.2250738585072014e-308);
    t = d / tmp___2;
    if (t < (cpFloat )0.0f) {
      goto __Cont;
    } else
    if ((cpFloat )1.0f < t) {
      goto __Cont;
    }
    tmp___3 = cpvlerp((cpVect const   )a, (cpVect const   )b, (cpFloat const   )t);
    point = tmp___3;
    tmp___4 = cpvcross((cpVect const   )n, (cpVect const   )point);
    dt = tmp___4;
    tmp___5 = cpvcross((cpVect const   )n, (cpVect const   )(planes + ((i - 1) + count) % count)->v0);
    dtMin = tmp___5;
    tmp___6 = cpvcross((cpVect const   )n, (cpVect const   )(planes + i)->v0);
    dtMax = tmp___6;
    if (dtMin <= dt) {
      if (dt <= dtMax) {
        info->shape = (cpShape const   *)((cpShape *)poly);
        tmp___7 = cpvmult((cpVect const   )n, (cpFloat const   )r2);
        tmp___8 = cpvlerp((cpVect const   )a, (cpVect const   )b, (cpFloat const   )t);
        info->point = cpvsub((cpVect const   )tmp___8, (cpVect const   )tmp___7);
        info->normal = n;
        info->alpha = t;
      }
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  if (rsum > (cpFloat )0.0f) {
    i___0 = 0;
    while (i___0 < count) {
      circle_info.shape = (cpShape const   *)((void *)0);
      circle_info.point = b;
      circle_info.normal = cpvzero___5;
      circle_info.alpha = (cpFloat )1.0f;
      CircleSegmentQuery(& poly->shape, (planes + i___0)->v0, r, a, b, r2, & circle_info);
      if (circle_info.alpha < info->alpha) {
        *info = circle_info;
      }
      i___0 ++;
    }
  }
  return;
}
}
static void SetVerts(cpPolyShape *poly , int count , cpVect const   *verts ) 
{ 
  void *tmp ;
  int i ;
  cpVect a ;
  cpVect b ;
  cpVect n ;
  cpVect tmp___0 ;
  cpVect tmp___1 ;
  cpVect tmp___2 ;

  {
  poly->count = count;
  if (count <= 6) {
    poly->planes = poly->_planes;
  } else {
    tmp = calloc((size_t )(2 * count), sizeof(struct cpSplittingPlane ));
    poly->planes = (struct cpSplittingPlane *)tmp;
  }
  i = 0;
  while (i < count) {
    a = *(verts + ((i - 1) + count) % count);
    b = *(verts + i);
    tmp___0 = cpvsub((cpVect const   )b, (cpVect const   )a);
    tmp___1 = cpvrperp((cpVect const   )tmp___0);
    tmp___2 = cpvnormalize((cpVect const   )tmp___1);
    n = tmp___2;
    (poly->planes + (i + count))->v0 = b;
    (poly->planes + (i + count))->n = n;
    i ++;
  }
  return;
}
}
static struct cpShapeMassInfo cpPolyShapeMassInfo(cpFloat mass , int count , cpVect const   *verts ,
                                                  cpFloat radius ) 
{ 
  cpVect centroid ;
  cpVect tmp ;
  struct cpShapeMassInfo info ;
  cpVect tmp___0 ;
  cpFloat tmp___1 ;
  cpFloat tmp___2 ;

  {
  tmp = cpCentroidForPoly((int const   )count, verts);
  centroid = tmp;
  tmp___0 = cpvneg((cpVect const   )centroid);
  tmp___1 = cpMomentForPoly((cpFloat )1.0f, count, verts, tmp___0, radius);
  tmp___2 = cpAreaForPoly((int const   )count, verts, radius);
  info.m = mass;
  info.i = tmp___1;
  info.cog = centroid;
  info.area = tmp___2;
  return (info);
}
}
static struct cpShapeClass  const  polyClass  =    {(cpShapeType )2, (cpBB (*)(cpShape *shape , cpTransform transform ))(& cpPolyShapeCacheData),
    (void (*)(cpShape *shape ))(& cpPolyShapeDestroy), (void (*)(cpShape const   *shape ,
                                                                 cpVect p , cpPointQueryInfo *info ))(& cpPolyShapePointQuery),
    (void (*)(cpShape const   *shape , cpVect a , cpVect b , cpFloat radius , cpSegmentQueryInfo *info ))(& cpPolyShapeSegmentQuery)};
cpPolyShape *cpPolyShapeInit(cpPolyShape *poly ,
                             cpBody *body , int count , cpVect const   *verts , cpTransform transform ,
                             cpFloat radius ) 
{ 
  cpVect *hullVerts ;
  void *tmp ;
  int i ;
  unsigned int hullCount ;
  int tmp___0 ;
  cpPolyShape *tmp___1 ;

  {
  tmp = __builtin_alloca((unsigned long )count * sizeof(cpVect ));
  hullVerts = (cpVect *)tmp;
  i = 0;
  while (i < count) {
    *(hullVerts + i) = cpTransformPoint(transform, (cpVect )*(verts + i));
    i ++;
  }
  tmp___0 = cpConvexHull(count, (cpVect const   *)hullVerts, hullVerts, (int *)((void *)0),
                         0.0);
  hullCount = (unsigned int )tmp___0;
  tmp___1 = cpPolyShapeInitRaw(poly, body, (int )hullCount, (cpVect const   *)hullVerts,
                               radius);
  return (tmp___1);
}
}
cpPolyShape *cpPolyShapeInitRaw(cpPolyShape *poly , cpBody *body , int count , cpVect const   *verts ,
                                cpFloat radius ) 
{ 
  struct cpShapeMassInfo tmp ;

  {
  tmp = cpPolyShapeMassInfo((cpFloat )0.0f, count, verts, radius);
  cpShapeInit((cpShape *)poly, & polyClass, body, tmp);
  SetVerts(poly, count, verts);
  poly->r = radius;
  return (poly);
}
}
cpShape *cpPolyShapeNew(cpBody *body , int count , cpVect const   *verts , cpTransform transform ,
                        cpFloat radius ) 
{ 
  cpPolyShape *tmp ;
  cpPolyShape *tmp___0 ;

  {
  tmp = cpPolyShapeAlloc();
  tmp___0 = cpPolyShapeInit(tmp, body, count, verts, transform, radius);
  return ((cpShape *)tmp___0);
}
}
cpShape *cpPolyShapeNewRaw(cpBody *body , int count , cpVect const   *verts , cpFloat radius ) 
{ 
  cpPolyShape *tmp ;
  cpPolyShape *tmp___0 ;

  {
  tmp = cpPolyShapeAlloc();
  tmp___0 = cpPolyShapeInitRaw(tmp, body, count, verts, radius);
  return ((cpShape *)tmp___0);
}
}
cpPolyShape *cpBoxShapeInit(cpPolyShape *poly , cpBody *body , cpFloat width , cpFloat height ,
                            cpFloat radius ) 
{ 
  cpFloat hw ;
  cpFloat hh ;
  cpBB tmp ;
  cpPolyShape *tmp___0 ;

  {
  hw = width / (cpFloat )2.0f;
  hh = height / (cpFloat )2.0f;
  tmp = cpBBNew((cpFloat const   )(- hw), (cpFloat const   )(- hh), (cpFloat const   )hw,
                (cpFloat const   )hh);
  tmp___0 = cpBoxShapeInit2(poly, body, tmp, radius);
  return (tmp___0);
}
}
cpPolyShape *cpBoxShapeInit2(cpPolyShape *poly , cpBody *body , cpBB box , cpFloat radius ) 
{ 
  cpVect verts[4] ;
  cpVect tmp ;
  cpVect tmp___0 ;
  cpVect tmp___1 ;
  cpVect tmp___2 ;
  cpPolyShape *tmp___3 ;

  {
  tmp = cpv((cpFloat const   )box.r, (cpFloat const   )box.b);
  tmp___0 = cpv((cpFloat const   )box.r, (cpFloat const   )box.t);
  tmp___1 = cpv((cpFloat const   )box.l, (cpFloat const   )box.t);
  tmp___2 = cpv((cpFloat const   )box.l, (cpFloat const   )box.b);
  verts[0] = tmp;
  verts[1] = tmp___0;
  verts[2] = tmp___1;
  verts[3] = tmp___2;
  tmp___3 = cpPolyShapeInitRaw(poly, body, 4, (cpVect const   *)(verts), radius);
  return (tmp___3);
}
}
cpShape *cpBoxShapeNew(cpBody *body , cpFloat width , cpFloat height , cpFloat radius ) 
{ 
  cpPolyShape *tmp ;
  cpPolyShape *tmp___0 ;

  {
  tmp = cpPolyShapeAlloc();
  tmp___0 = cpBoxShapeInit(tmp, body, width, height, radius);
  return ((cpShape *)tmp___0);
}
}
cpShape *cpBoxShapeNew2(cpBody *body , cpBB box , cpFloat radius ) 
{ 
  cpPolyShape *tmp ;
  cpPolyShape *tmp___0 ;

  {
  tmp = cpPolyShapeAlloc();
  tmp___0 = cpBoxShapeInit2(tmp, body, box, radius);
  return ((cpShape *)tmp___0);
}
}
int cpPolyShapeGetCount(cpShape const   *shape ) 
{ 


  {
  if (! ((unsigned long )shape->klass == (unsigned long )(& polyClass))) {
    cpMessage("shape->klass == &polyClass", "../src/cpPolyShape.c", 262, 1, 1, "Shape is not a poly shape.");
    abort();
  }
  return (((cpPolyShape *)shape)->count);
}
}
cpVect cpPolyShapeGetVert(cpShape const   *shape , int i ) 
{ 
  int count ;
  int tmp ;

  {
  if (! ((unsigned long )shape->klass == (unsigned long )(& polyClass))) {
    cpMessage("shape->klass == &polyClass", "../src/cpPolyShape.c", 269, 1, 1, "Shape is not a poly shape.");
    abort();
  }
  tmp = cpPolyShapeGetCount(shape);
  count = tmp;
  if (0 <= i) {
    if (! (i < count)) {
      cpMessage("0 <= i && i < count", "../src/cpPolyShape.c", 272, 1, 1, "Index out of range.");
      abort();
    }
  } else {
    cpMessage("0 <= i && i < count", "../src/cpPolyShape.c", 272, 1, 1, "Index out of range.");
    abort();
  }
  return ((((cpPolyShape *)shape)->planes + (i + count))->v0);
}
}
cpFloat cpPolyShapeGetRadius(cpShape const   *shape ) 
{ 


  {
  if (! ((unsigned long )shape->klass == (unsigned long )(& polyClass))) {
    cpMessage("shape->klass == &polyClass", "../src/cpPolyShape.c", 280, 1, 1, "Shape is not a poly shape.");
    abort();
  }
  return (((cpPolyShape *)shape)->r);
}
}
void cpPolyShapeSetVerts(cpShape *shape , int count , cpVect *verts , cpTransform transform ) 
{ 
  cpVect *hullVerts ;
  void *tmp ;
  int i ;
  unsigned int hullCount ;
  int tmp___0 ;

  {
  tmp = __builtin_alloca((unsigned long )count * sizeof(cpVect ));
  hullVerts = (cpVect *)tmp;
  i = 0;
  while (i < count) {
    *(hullVerts + i) = cpTransformPoint(transform, *(verts + i));
    i ++;
  }
  tmp___0 = cpConvexHull(count, (cpVect const   *)hullVerts, hullVerts, (int *)((void *)0),
                         0.0);
  hullCount = (unsigned int )tmp___0;
  cpPolyShapeSetVertsRaw(shape, (int )hullCount, hullVerts);
  return;
}
}
void cpPolyShapeSetVertsRaw(cpShape *shape , int count , cpVect *verts ) 
{ 
  cpPolyShape *poly ;
  cpFloat mass ;

  {
  if (! ((unsigned long )shape->klass == (unsigned long )(& polyClass))) {
    cpMessage("shape->klass == &polyClass", "../src/cpPolyShape.c", 301, 1, 1, "Shape is not a poly shape.");
    abort();
  }
  poly = (cpPolyShape *)shape;
  cpPolyShapeDestroy(poly);
  SetVerts(poly, count, (cpVect const   *)verts);
  mass = shape->massInfo.m;
  shape->massInfo = cpPolyShapeMassInfo(shape->massInfo.m, count, (cpVect const   *)verts,
                                        poly->r);
  if (mass > (cpFloat )0.0f) {
    cpBodyAccumulateMassFromShapes(shape->body);
  }
  return;
}
}
void cpPolyShapeSetRadius(cpShape *shape , cpFloat radius ) 
{ 
  cpPolyShape *poly ;

  {
  if (! ((unsigned long )shape->klass == (unsigned long )(& polyClass))) {
    cpMessage("shape->klass == &polyClass", "../src/cpPolyShape.c", 315, 1, 1, "Shape is not a poly shape.");
    abort();
  }
  poly = (cpPolyShape *)shape;
  poly->r = radius;
  return;
}
}
#pragma merger("0","/tmp/cil-9EVVzoF_.i","-std=gnu99,-ffast-math,-fPIC")
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) double fabs(double __x )  __attribute__((__const__)) ;
__inline static cpBool cpvnear(cpVect const   v1 , cpVect const   v2 , cpFloat const   dist ) 
{ 
  cpFloat tmp ;

  {
  tmp = cpvdistsq(v1, v2);
  return ((cpBool )(tmp < (cpFloat )(dist * dist)));
}
}
void cpPolylineFree(cpPolyline *line ) ;
cpBool cpPolylineIsClosed(cpPolyline *line ) ;
cpPolyline *cpPolylineSimplifyCurves(cpPolyline *line , cpFloat tol ) ;
cpPolyline *cpPolylineSimplifyVertexes(cpPolyline *line , cpFloat tol ) ;
cpPolyline *cpPolylineToConvexHull(cpPolyline *line , cpFloat tol ) ;
cpPolylineSet *cpPolylineSetAlloc(void) ;
cpPolylineSet *cpPolylineSetInit(cpPolylineSet *set ) ;
cpPolylineSet *cpPolylineSetNew(void) ;
void cpPolylineSetDestroy(cpPolylineSet *set , cpBool freePolylines ) ;
void cpPolylineSetFree(cpPolylineSet *set , cpBool freePolylines ) ;
void cpPolylineSetCollectSegment(cpVect v0 , cpVect v1 , cpPolylineSet *lines ) ;
cpPolylineSet *cpPolylineConvexDecomposition(cpPolyline *line , cpFloat tol ) ;
__inline static int Next(int i , int count ) 
{ 


  {
  return ((i + 1) % count);
}
}
static int cpPolylineSizeForCapacity(int capacity ) 
{ 


  {
  return ((int )(sizeof(cpPolyline ) + (unsigned long )capacity * sizeof(cpVect )));
}
}
static cpPolyline *cpPolylineMake(int capacity ) 
{ 
  cpPolyline *line ;
  int tmp ;
  void *tmp___0 ;

  {
  if (capacity > 16) {
    capacity = capacity;
  } else {
    capacity = 16;
  }
  tmp = cpPolylineSizeForCapacity(capacity);
  tmp___0 = calloc((size_t )1, (size_t )tmp);
  line = (cpPolyline *)tmp___0;
  line->count = 0;
  line->capacity = capacity;
  return (line);
}
}
static cpPolyline *cpPolylineMake2(int capacity , cpVect a , cpVect b ) 
{ 
  cpPolyline *line ;
  cpPolyline *tmp ;

  {
  tmp = cpPolylineMake(capacity);
  line = tmp;
  line->count = 2;
  line->verts[0] = a;
  line->verts[1] = b;
  return (line);
}
}
static cpPolyline *cpPolylineShrink(cpPolyline *line ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
  line->capacity = line->count;
  tmp = cpPolylineSizeForCapacity(line->count);
  tmp___0 = realloc((void *)line, (size_t )tmp);
  return ((cpPolyline *)tmp___0);
}
}
void cpPolylineFree(cpPolyline *line ) 
{ 


  {
  free((void *)line);
  return;
}
}
static cpPolyline *cpPolylineGrow(cpPolyline *line , int count ) 
{ 
  int capacity ;
  int tmp ;
  void *tmp___0 ;

  {
  line->count += count;
  capacity = line->capacity;
  while (line->count > capacity) {
    capacity *= 2;
  }
  if (line->capacity < capacity) {
    line->capacity = capacity;
    tmp = cpPolylineSizeForCapacity(capacity);
    tmp___0 = realloc((void *)line, (size_t )tmp);
    line = (cpPolyline *)tmp___0;
  }
  return (line);
}
}
static cpPolyline *cpPolylinePush(cpPolyline *line , cpVect v ) 
{ 
  int count ;

  {
  count = line->count;
  line = cpPolylineGrow(line, 1);
  line->verts[count] = v;
  return (line);
}
}
static cpPolyline *cpPolylineEnqueue(cpPolyline *line , cpVect v ) 
{ 
  int count ;

  {
  count = line->count;
  line = cpPolylineGrow(line, 1);
  memmove((void *)(line->verts + 1), (void const   *)(line->verts), (unsigned long )count * sizeof(cpVect ));
  line->verts[0] = v;
  return (line);
}
}
cpBool cpPolylineIsClosed(cpPolyline *line ) 
{ 
  cpBool tmp ;
  int tmp___0 ;

  {
  if (line->count > 1) {
    tmp = cpveql((cpVect const   )line->verts[0], (cpVect const   )line->verts[line->count - 1]);
    if (tmp) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  return ((cpBool )tmp___0);
}
}
static cpBool cpPolylineIsShort(cpVect *points , int count , int start , int end ,
                                cpFloat min ) 
{ 
  cpFloat length ;
  int i ;
  int tmp ;
  cpFloat tmp___0 ;

  {
  length = (cpFloat )0.0f;
  i = start;
  while (i != end) {
    tmp = Next(i, count);
    tmp___0 = cpvdist((cpVect const   )*(points + i), (cpVect const   )*(points + tmp));
    length += tmp___0;
    if (length > min) {
      return ((cpBool )0);
    }
    i = Next(i, count);
  }
  return ((cpBool )1);
}
}
__inline static cpFloat Sharpness(cpVect a , cpVect b , cpVect c ) 
{ 
  cpVect tmp ;
  cpVect tmp___0 ;
  cpVect tmp___1 ;
  cpVect tmp___2 ;
  cpFloat tmp___3 ;

  {
  tmp = cpvsub((cpVect const   )c, (cpVect const   )b);
  tmp___0 = cpvnormalize((cpVect const   )tmp);
  tmp___1 = cpvsub((cpVect const   )a, (cpVect const   )b);
  tmp___2 = cpvnormalize((cpVect const   )tmp___1);
  tmp___3 = cpvdot((cpVect const   )tmp___2, (cpVect const   )tmp___0);
  return (tmp___3);
}
}
cpPolyline *cpPolylineSimplifyVertexes(cpPolyline *line , cpFloat tol ) 
{ 
  cpPolyline *reduced ;
  cpPolyline *tmp ;
  cpFloat minSharp ;
  double tmp___0 ;
  int i ;
  cpVect vert ;
  cpFloat sharp ;
  cpFloat tmp___1 ;
  cpBool tmp___2 ;
  cpFloat tmp___3 ;

  {
  tmp = cpPolylineMake2(0, line->verts[0], line->verts[1]);
  reduced = tmp;
  tmp___0 = cos(tol);
  minSharp = - tmp___0;
  i = 2;
  while (i < line->count) {
    vert = line->verts[i];
    tmp___1 = Sharpness(reduced->verts[reduced->count - 2], reduced->verts[reduced->count - 1],
                        vert);
    sharp = tmp___1;
    if (sharp <= minSharp) {
      reduced->verts[reduced->count - 1] = vert;
    } else {
      reduced = cpPolylinePush(reduced, vert);
    }
    i ++;
  }
  tmp___2 = cpPolylineIsClosed(line);
  if (tmp___2) {
    tmp___3 = Sharpness(reduced->verts[reduced->count - 2], reduced->verts[0], reduced->verts[1]);
    if (tmp___3 < minSharp) {
      reduced->verts[0] = reduced->verts[reduced->count - 2];
      (reduced->count) --;
    }
  }
  return (reduced);
}
}
static cpPolyline *DouglasPeucker(cpVect *verts , cpPolyline *reduced , int length ,
                                  int start , int end , cpFloat min , cpFloat tol ) 
{ 
  cpVect a ;
  cpVect b ;
  cpBool tmp ;
  cpBool tmp___0 ;
  cpFloat max ;
  int maxi ;
  cpVect n ;
  cpVect tmp___1 ;
  cpVect tmp___2 ;
  cpVect tmp___3 ;
  cpFloat d ;
  cpFloat tmp___4 ;
  int i ;
  int tmp___5 ;
  cpFloat dist ;
  cpFloat tmp___6 ;
  double tmp___7 ;

  {
  if (((end - start) + length) % length < 2) {
    return (reduced);
  }
  a = *(verts + start);
  b = *(verts + end);
  tmp = cpvnear((cpVect const   )a, (cpVect const   )b, (cpFloat const   )min);
  if (tmp) {
    tmp___0 = cpPolylineIsShort(verts, length, start, end, min);
    if (tmp___0) {
      return (reduced);
    }
  }
  max = 0.0;
  maxi = start;
  tmp___1 = cpvsub((cpVect const   )b, (cpVect const   )a);
  tmp___2 = cpvperp((cpVect const   )tmp___1);
  tmp___3 = cpvnormalize((cpVect const   )tmp___2);
  n = tmp___3;
  tmp___4 = cpvdot((cpVect const   )n, (cpVect const   )a);
  d = tmp___4;
  tmp___5 = Next(start, length);
  i = tmp___5;
  while (i != end) {
    tmp___6 = cpvdot((cpVect const   )n, (cpVect const   )*(verts + i));
    tmp___7 = fabs(tmp___6 - d);
    dist = tmp___7;
    if (dist > max) {
      max = dist;
      maxi = i;
    }
    i = Next(i, length);
  }
  if (max > tol) {
    reduced = DouglasPeucker(verts, reduced, length, start, maxi, min, tol);
    reduced = cpPolylinePush(reduced, *(verts + maxi));
    reduced = DouglasPeucker(verts, reduced, length, maxi, end, min, tol);
  }
  return (reduced);
}
}
cpPolyline *cpPolylineSimplifyCurves(cpPolyline *line , cpFloat tol ) 
{ 
  cpPolyline *reduced ;
  cpPolyline *tmp ;
  cpFloat min ;
  int start ;
  int end ;
  cpBool tmp___0 ;
  cpPolyline *tmp___1 ;

  {
  tmp = cpPolylineMake(line->count);
  reduced = tmp;
  min = tol / (cpFloat )2.0f;
  tmp___0 = cpPolylineIsClosed(line);
  if (tmp___0) {
    cpLoopIndexes((cpVect const   *)(line->verts), line->count - 1, & start, & end);
    reduced = cpPolylinePush(reduced, line->verts[start]);
    reduced = DouglasPeucker(line->verts, reduced, line->count - 1, start, end, min,
                             tol);
    reduced = cpPolylinePush(reduced, line->verts[end]);
    reduced = DouglasPeucker(line->verts, reduced, line->count - 1, end, start, min,
                             tol);
    reduced = cpPolylinePush(reduced, line->verts[start]);
  } else {
    reduced = cpPolylinePush(reduced, line->verts[0]);
    reduced = DouglasPeucker(line->verts, reduced, line->count, 0, line->count - 1,
                             min, tol);
    reduced = cpPolylinePush(reduced, line->verts[line->count - 1]);
  }
  tmp___1 = cpPolylineShrink(reduced);
  return (tmp___1);
}
}
cpPolylineSet *cpPolylineSetAlloc(void) 
{ 
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(cpPolylineSet ));
  return ((cpPolylineSet *)tmp);
}
}
cpPolylineSet *cpPolylineSetInit(cpPolylineSet *set ) 
{ 
  void *tmp ;

  {
  set->count = 0;
  set->capacity = 8;
  tmp = calloc((size_t )set->capacity, sizeof(cpPolyline ));
  set->lines = (cpPolyline **)tmp;
  return (set);
}
}
cpPolylineSet *cpPolylineSetNew(void) 
{ 
  cpPolylineSet *tmp ;
  cpPolylineSet *tmp___0 ;

  {
  tmp = cpPolylineSetAlloc();
  tmp___0 = cpPolylineSetInit(tmp);
  return (tmp___0);
}
}
void cpPolylineSetDestroy(cpPolylineSet *set , cpBool freePolylines ) 
{ 
  int i ;

  {
  if (freePolylines) {
    i = 0;
    while (i < set->count) {
      cpPolylineFree(*(set->lines + i));
      i ++;
    }
  }
  free((void *)set->lines);
  return;
}
}
void cpPolylineSetFree(cpPolylineSet *set , cpBool freePolylines ) 
{ 


  {
  if (set) {
    cpPolylineSetDestroy(set, freePolylines);
    free((void *)set);
  }
  return;
}
}
static int cpPolylineSetFindEnds(cpPolylineSet *set , cpVect v ) 
{ 
  int count ;
  cpPolyline **lines ;
  int i ;
  cpPolyline *line ;
  cpBool tmp ;

  {
  count = set->count;
  lines = set->lines;
  i = 0;
  while (i < count) {
    line = *(lines + i);
    tmp = cpveql((cpVect const   )line->verts[line->count - 1], (cpVect const   )v);
    if (tmp) {
      return (i);
    }
    i ++;
  }
  return (-1);
}
}
static int cpPolylineSetFindStarts(cpPolylineSet *set , cpVect v ) 
{ 
  int count ;
  cpPolyline **lines ;
  int i ;
  cpBool tmp ;

  {
  count = set->count;
  lines = set->lines;
  i = 0;
  while (i < count) {
    tmp = cpveql((cpVect const   )(*(lines + i))->verts[0], (cpVect const   )v);
    if (tmp) {
      return (i);
    }
    i ++;
  }
  return (-1);
}
}
static void cpPolylineSetPush(cpPolylineSet *set , cpPolyline *line ) 
{ 
  void *tmp ;

  {
  (set->count) ++;
  if (set->count > set->capacity) {
    set->capacity *= 2;
    tmp = realloc((void *)set->lines, (unsigned long )set->capacity * sizeof(cpPolyline ));
    set->lines = (cpPolyline **)tmp;
  }
  *(set->lines + (set->count - 1)) = line;
  return;
}
}
static void cpPolylineSetAdd(cpPolylineSet *set , cpVect v0 , cpVect v1 ) 
{ 
  cpPolyline *tmp ;

  {
  tmp = cpPolylineMake2(16, v0, v1);
  cpPolylineSetPush(set, tmp);
  return;
}
}
static void cpPolylineSetJoin(cpPolylineSet *set , int before , int after ) 
{ 
  cpPolyline *lbefore ;
  cpPolyline *lafter ;
  int count ;

  {
  lbefore = *(set->lines + before);
  lafter = *(set->lines + after);
  count = lbefore->count;
  lbefore = cpPolylineGrow(lbefore, lafter->count);
  memmove((void *)(lbefore->verts + count), (void const   *)(lafter->verts), (unsigned long )lafter->count * sizeof(cpVect ));
  *(set->lines + before) = lbefore;
  (set->count) --;
  cpPolylineFree(*(set->lines + after));
  *(set->lines + after) = *(set->lines + set->count);
  return;
}
}
void cpPolylineSetCollectSegment(cpVect v0 , cpVect v1 , cpPolylineSet *lines ) 
{ 
  int before ;
  int tmp ;
  int after ;
  int tmp___0 ;

  {
  tmp = cpPolylineSetFindEnds(lines, v0);
  before = tmp;
  tmp___0 = cpPolylineSetFindStarts(lines, v1);
  after = tmp___0;
  if (before >= 0) {
    if (after >= 0) {
      if (before == after) {
        *(lines->lines + before) = cpPolylinePush(*(lines->lines + before), v1);
      } else {
        cpPolylineSetJoin(lines, before, after);
      }
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (before >= 0) {
    *(lines->lines + before) = cpPolylinePush(*(lines->lines + before), v1);
  } else
  if (after >= 0) {
    *(lines->lines + after) = cpPolylineEnqueue(*(lines->lines + after), v0);
  } else {
    cpPolylineSetAdd(lines, v0, v1);
  }
  return;
}
}
cpPolyline *cpPolylineToConvexHull(cpPolyline *line , cpFloat tol ) 
{ 
  cpPolyline *hull ;
  cpPolyline *tmp ;
  cpPolyline *tmp___0 ;

  {
  tmp = cpPolylineMake(line->count + 1);
  hull = tmp;
  hull->count = cpConvexHull(line->count, (cpVect const   *)(line->verts), hull->verts,
                             (int *)((void *)0), tol);
  hull = cpPolylinePush(hull, hull->verts[0]);
  tmp___0 = cpPolylineShrink(hull);
  return (tmp___0);
}
}
static cpFloat FindSteiner(int count , cpVect *verts , struct Notch notch ) 
{ 
  cpFloat min ;
  float tmp ;
  cpFloat feature ;
  int i ;
  int index___0 ;
  cpVect seg_a ;
  cpVect seg_b ;
  int tmp___0 ;
  cpFloat thing_a ;
  cpVect tmp___1 ;
  cpFloat tmp___2 ;
  cpFloat thing_b ;
  cpVect tmp___3 ;
  cpFloat tmp___4 ;
  cpFloat t ;
  cpFloat dist ;
  cpVect tmp___5 ;
  cpVect tmp___6 ;
  cpFloat tmp___7 ;

  {
  tmp = __builtin_inff();
  min = (cpFloat )tmp;
  feature = - 1.0;
  i = 1;
  while (i < count - 1) {
    index___0 = (notch.i + i) % count;
    seg_a = *(verts + index___0);
    tmp___0 = Next(index___0, count);
    seg_b = *(verts + tmp___0);
    tmp___1 = cpvsub((cpVect const   )seg_a, (cpVect const   )notch.v);
    tmp___2 = cpvcross((cpVect const   )notch.n, (cpVect const   )tmp___1);
    thing_a = tmp___2;
    tmp___3 = cpvsub((cpVect const   )seg_b, (cpVect const   )notch.v);
    tmp___4 = cpvcross((cpVect const   )notch.n, (cpVect const   )tmp___3);
    thing_b = tmp___4;
    if (thing_a * thing_b <= 0.0) {
      t = thing_a / (thing_a - thing_b);
      tmp___5 = cpvlerp((cpVect const   )seg_a, (cpVect const   )seg_b, (cpFloat const   )t);
      tmp___6 = cpvsub((cpVect const   )tmp___5, (cpVect const   )notch.v);
      tmp___7 = cpvdot((cpVect const   )notch.n, (cpVect const   )tmp___6);
      dist = tmp___7;
      if (dist >= 0.0) {
        if (dist <= min) {
          min = dist;
          feature = (cpFloat )index___0 + t;
        }
      }
    }
    i ++;
  }
  return (feature);
}
}
static struct Notch DeepestNotch(int count , cpVect *verts , int hullCount , cpVect *hullVerts ,
                                 int first , cpFloat tol ) 
{ 
  struct Notch notch ;
  int j ;
  int tmp ;
  int i ;
  cpVect a ;
  cpVect b ;
  int tmp___0 ;
  cpVect n ;
  cpVect tmp___1 ;
  cpVect tmp___2 ;
  cpVect tmp___3 ;
  cpFloat d ;
  cpFloat tmp___4 ;
  cpVect v ;
  cpFloat depth ;
  cpFloat tmp___5 ;
  cpBool tmp___6 ;

  {
  notch.i = 0;
  notch.d = 0.;
  notch.v.x = 0.;
  notch.v.y = 0.;
  notch.n.x = 0.;
  notch.n.y = 0.;
  tmp = Next(first, count);
  j = tmp;
  i = 0;
  while (i < hullCount) {
    a = *(hullVerts + i);
    tmp___0 = Next(i, hullCount);
    b = *(hullVerts + tmp___0);
    tmp___1 = cpvsub((cpVect const   )a, (cpVect const   )b);
    tmp___2 = cpvrperp((cpVect const   )tmp___1);
    tmp___3 = cpvnormalize((cpVect const   )tmp___2);
    n = tmp___3;
    tmp___4 = cpvdot((cpVect const   )n, (cpVect const   )a);
    d = tmp___4;
    v = *(verts + j);
    while (1) {
      tmp___6 = cpveql((cpVect const   )v, (cpVect const   )b);
      if (tmp___6) {
        break;
      }
      tmp___5 = cpvdot((cpVect const   )n, (cpVect const   )v);
      depth = tmp___5 - d;
      if (depth > notch.d) {
        notch.d = depth;
        notch.i = j;
        notch.v = v;
        notch.n = n;
      }
      j = Next(j, count);
      v = *(verts + j);
    }
    j = Next(j, count);
    i ++;
  }
  return (notch);
}
}
__inline static int IMAX(int a , int b ) 
{ 
  int tmp ;

  {
  if (a > b) {
    tmp = a;
  } else {
    tmp = b;
  }
  return (tmp);
}
}
static void ApproximateConcaveDecomposition(cpVect *verts , int count , cpFloat tol ,
                                            cpPolylineSet *set ) 
{ 
  int first ;
  cpVect *hullVerts ;
  void *tmp ;
  int hullCount ;
  int tmp___0 ;
  struct Notch notch ;
  struct Notch tmp___1 ;
  cpFloat steiner_it ;
  cpFloat tmp___2 ;
  int steiner_i ;
  cpVect steiner ;
  int tmp___3 ;
  cpVect tmp___4 ;
  int sub1_count ;
  int sub2_count ;
  cpVect *scratch ;
  int tmp___5 ;
  void *tmp___6 ;
  int i ;
  int i___0 ;
  cpPolyline *hull ;
  cpPolyline *tmp___7 ;

  {
  tmp = __builtin_alloca((unsigned long )count * sizeof(cpVect ));
  hullVerts = (cpVect *)tmp;
  tmp___0 = cpConvexHull(count, (cpVect const   *)verts, hullVerts, & first, 0.0);
  hullCount = tmp___0;
  if (hullCount != count) {
    tmp___1 = DeepestNotch(count, verts, hullCount, hullVerts, first, tol);
    notch = tmp___1;
    if (notch.d > tol) {
      tmp___2 = FindSteiner(count, verts, notch);
      steiner_it = tmp___2;
      if (steiner_it >= 0.0) {
        steiner_i = (int )steiner_it;
        tmp___3 = Next(steiner_i, count);
        tmp___4 = cpvlerp((cpVect const   )*(verts + steiner_i), (cpVect const   )*(verts + tmp___3),
                          (cpFloat const   )(steiner_it - (cpFloat )steiner_i));
        steiner = tmp___4;
        sub1_count = ((steiner_i - notch.i) + count) % count + 1;
        sub2_count = count - ((steiner_i - notch.i) + count) % count;
        tmp___5 = IMAX(sub1_count, sub2_count);
        tmp___6 = __builtin_alloca((unsigned long )(tmp___5 + 1) * sizeof(cpVect ));
        scratch = (cpVect *)tmp___6;
        i = 0;
        while (i < sub1_count) {
          *(scratch + i) = *(verts + (notch.i + i) % count);
          i ++;
        }
        *(scratch + sub1_count) = steiner;
        ApproximateConcaveDecomposition(scratch, sub1_count + 1, tol, set);
        i___0 = 0;
        while (i___0 < sub2_count) {
          *(scratch + i___0) = *(verts + ((steiner_i + 1) + i___0) % count);
          i___0 ++;
        }
        *(scratch + sub2_count) = steiner;
        ApproximateConcaveDecomposition(scratch, sub2_count + 1, tol, set);
        return;
      }
    }
  }
  tmp___7 = cpPolylineMake(hullCount + 1);
  hull = tmp___7;
  memcpy((void * __restrict  )(hull->verts), (void const   * __restrict  )hullVerts,
         (unsigned long )hullCount * sizeof(cpVect ));
  hull->verts[hullCount] = *(hullVerts + 0);
  hull->count = hullCount + 1;
  cpPolylineSetPush(set, hull);
  return;
}
}
cpPolylineSet *cpPolylineConvexDecomposition(cpPolyline *line , cpFloat tol ) 
{ 
  cpPolylineSet *set ;
  cpPolylineSet *tmp ;

  {
  tmp = cpPolylineSetNew();
  set = tmp;
  ApproximateConcaveDecomposition(line->verts, line->count - 1, tol, set);
  return (set);
}
}
#pragma merger("0","/tmp/cil-e06_HFjD.i","-std=gnu99,-ffast-math,-fPIC")
extern  __attribute__((__nothrow__)) double floor(double __x )  __attribute__((__const__)) ;
cpBool cpConstraintIsRatchetJoint(cpConstraint const   *constraint ) ;
cpRatchetJoint *cpRatchetJointAlloc(void) ;
cpRatchetJoint *cpRatchetJointInit(cpRatchetJoint *joint , cpBody *a , cpBody *b ,
                                   cpFloat phase , cpFloat ratchet ) ;
cpConstraint *cpRatchetJointNew(cpBody *a , cpBody *b , cpFloat phase , cpFloat ratchet ) ;
cpFloat cpRatchetJointGetAngle(cpConstraint const   *constraint ) ;
void cpRatchetJointSetAngle(cpConstraint *constraint , cpFloat angle ) ;
cpFloat cpRatchetJointGetPhase(cpConstraint const   *constraint ) ;
void cpRatchetJointSetPhase(cpConstraint *constraint , cpFloat phase ) ;
cpFloat cpRatchetJointGetRatchet(cpConstraint const   *constraint ) ;
void cpRatchetJointSetRatchet(cpConstraint *constraint , cpFloat ratchet ) ;
static void preStep___5(cpRatchetJoint *joint , cpFloat dt ) 
{ 
  cpBody *a ;
  cpBody *b ;
  cpFloat angle ;
  cpFloat phase ;
  cpFloat ratchet ;
  cpFloat delta ;
  cpFloat diff ;
  cpFloat pdist ;
  double tmp ;
  cpFloat maxBias ;
  cpFloat tmp___0 ;

  {
  a = joint->constraint.a;
  b = joint->constraint.b;
  angle = joint->angle;
  phase = joint->phase;
  ratchet = joint->ratchet;
  delta = b->a - a->a;
  diff = angle - delta;
  pdist = (cpFloat )0.0f;
  if (diff * ratchet > (cpFloat )0.0f) {
    pdist = diff;
  } else {
    tmp = floor((delta - phase) / ratchet);
    joint->angle = tmp * ratchet + phase;
  }
  joint->iSum = (cpFloat )1.0f / (a->i_inv + b->i_inv);
  maxBias = joint->constraint.maxBias;
  tmp___0 = bias_coef(joint->constraint.errorBias, dt);
  joint->bias = cpfclamp((- tmp___0 * pdist) / dt, - maxBias, maxBias);
  if (! joint->bias) {
    joint->jAcc = (cpFloat )0.0f;
  }
  return;
}
}
static void applyCachedImpulse___5(cpRatchetJoint *joint , cpFloat dt_coef ) 
{ 
  cpBody *a ;
  cpBody *b ;
  cpFloat j ;

  {
  a = joint->constraint.a;
  b = joint->constraint.b;
  j = joint->jAcc * dt_coef;
  a->w -= j * a->i_inv;
  b->w += j * b->i_inv;
  return;
}
}
static void applyImpulse___5(cpRatchetJoint *joint , cpFloat dt ) 
{ 
  cpBody *a ;
  cpBody *b ;
  cpFloat wr ;
  cpFloat ratchet ;
  cpFloat jMax ;
  cpFloat j ;
  cpFloat jOld ;
  cpFloat tmp ;
  cpFloat tmp___0 ;

  {
  if (! joint->bias) {
    return;
  }
  a = joint->constraint.a;
  b = joint->constraint.b;
  wr = b->w - a->w;
  ratchet = joint->ratchet;
  jMax = joint->constraint.maxForce * dt;
  j = - (joint->bias + wr) * joint->iSum;
  jOld = joint->jAcc;
  tmp = cpfabs(ratchet);
  tmp___0 = cpfclamp((jOld + j) * ratchet, (cpFloat )0.0f, jMax * tmp);
  joint->jAcc = tmp___0 / ratchet;
  j = joint->jAcc - jOld;
  a->w -= j * a->i_inv;
  b->w += j * b->i_inv;
  return;
}
}
static cpFloat getImpulse___5(cpRatchetJoint *joint ) 
{ 
  cpFloat tmp ;

  {
  tmp = cpfabs(joint->jAcc);
  return (tmp);
}
}
static struct cpConstraintClass  const  klass___6  =    {(void (*)(cpConstraint *constraint , cpFloat dt ))(& preStep___5), (void (*)(cpConstraint *constraint ,
                                                                                 cpFloat dt_coef ))(& applyCachedImpulse___5),
    (void (*)(cpConstraint *constraint , cpFloat dt ))(& applyImpulse___5), (cpFloat (*)(cpConstraint *constraint ))(& getImpulse___5)};
cpRatchetJoint *cpRatchetJointAlloc(void) 
{ 
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(cpRatchetJoint ));
  return ((cpRatchetJoint *)tmp);
}
}
cpRatchetJoint *cpRatchetJointInit(cpRatchetJoint *joint , cpBody *a , cpBody *b ,
                                   cpFloat phase , cpFloat ratchet ) 
{ 
  cpFloat tmp ;
  cpFloat tmp___0 ;

  {
  cpConstraintInit((cpConstraint *)joint, & klass___6, a, b);
  joint->angle = (cpFloat )0.0f;
  joint->phase = phase;
  joint->ratchet = ratchet;
  if (b) {
    tmp = b->a;
  } else {
    tmp = (cpFloat )0.0f;
  }
  if (a) {
    tmp___0 = a->a;
  } else {
    tmp___0 = (cpFloat )0.0f;
  }
  joint->angle = tmp - tmp___0;
  return (joint);
}
}
cpConstraint *cpRatchetJointNew(cpBody *a , cpBody *b , cpFloat phase , cpFloat ratchet ) 
{ 
  cpRatchetJoint *tmp ;
  cpRatchetJoint *tmp___0 ;

  {
  tmp = cpRatchetJointAlloc();
  tmp___0 = cpRatchetJointInit(tmp, a, b, phase, ratchet);
  return ((cpConstraint *)tmp___0);
}
}
cpBool cpConstraintIsRatchetJoint(cpConstraint const   *constraint ) 
{ 


  {
  return ((cpBool )((unsigned long )constraint->klass == (unsigned long )(& klass___6)));
}
}
cpFloat cpRatchetJointGetAngle(cpConstraint const   *constraint ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsRatchetJoint(constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsRatchetJoint(constraint)", "../src/cpRatchetJoint.c",
              140, 1, 1, "Constraint is not a ratchet joint.");
    abort();
  }
  return (((cpRatchetJoint *)constraint)->angle);
}
}
void cpRatchetJointSetAngle(cpConstraint *constraint , cpFloat angle ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsRatchetJoint((cpConstraint const   *)constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsRatchetJoint(constraint)", "../src/cpRatchetJoint.c",
              147, 1, 1, "Constraint is not a ratchet joint.");
    abort();
  }
  cpConstraintActivateBodies(constraint);
  ((cpRatchetJoint *)constraint)->angle = angle;
  return;
}
}
cpFloat cpRatchetJointGetPhase(cpConstraint const   *constraint ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsRatchetJoint(constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsRatchetJoint(constraint)", "../src/cpRatchetJoint.c",
              155, 1, 1, "Constraint is not a ratchet joint.");
    abort();
  }
  return (((cpRatchetJoint *)constraint)->phase);
}
}
void cpRatchetJointSetPhase(cpConstraint *constraint , cpFloat phase ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsRatchetJoint((cpConstraint const   *)constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsRatchetJoint(constraint)", "../src/cpRatchetJoint.c",
              162, 1, 1, "Constraint is not a ratchet joint.");
    abort();
  }
  cpConstraintActivateBodies(constraint);
  ((cpRatchetJoint *)constraint)->phase = phase;
  return;
}
}
cpFloat cpRatchetJointGetRatchet(cpConstraint const   *constraint ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsRatchetJoint(constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsRatchetJoint(constraint)", "../src/cpRatchetJoint.c",
              169, 1, 1, "Constraint is not a ratchet joint.");
    abort();
  }
  return (((cpRatchetJoint *)constraint)->ratchet);
}
}
void cpRatchetJointSetRatchet(cpConstraint *constraint , cpFloat ratchet ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsRatchetJoint((cpConstraint const   *)constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsRatchetJoint(constraint)", "../src/cpRatchetJoint.c",
              176, 1, 1, "Constraint is not a ratchet joint.");
    abort();
  }
  cpConstraintActivateBodies(constraint);
  ((cpRatchetJoint *)constraint)->ratchet = ratchet;
  return;
}
}
#pragma merger("0","/tmp/cil-_h38TOwz.i","-std=gnu99,-ffast-math,-fPIC")
cpBool cpCheckPointGreater(cpVect const   a , cpVect const   b , cpVect const   c ) 
{ 


  {
  return ((cpBool )((b.y - a.y) * ((a.x + b.x) - (cpFloat const   )2 * c.x) > (b.x - a.x) * ((a.y + b.y) - (cpFloat const   )2 * c.y)));
}
}
cpBool cpCheckAxis(cpVect v0 , cpVect v1 , cpVect p , cpVect n ) 
{ 
  cpFloat tmp ;
  cpFloat tmp___0 ;
  cpFloat tmp___1 ;
  cpFloat tmp___2 ;

  {
  tmp = cpvdot((cpVect const   )p, (cpVect const   )n);
  tmp___0 = cpvdot((cpVect const   )v1, (cpVect const   )n);
  tmp___1 = cpvdot((cpVect const   )v0, (cpVect const   )n);
  tmp___2 = cpfmax(tmp___1, tmp___0);
  return ((cpBool )(tmp <= tmp___2));
}
}
#pragma merger("0","/tmp/cil-nm9mr77_.i","-std=gnu99,-ffast-math,-fPIC")
cpBool cpConstraintIsRotaryLimitJoint(cpConstraint const   *constraint ) ;
cpRotaryLimitJoint *cpRotaryLimitJointAlloc(void) ;
cpRotaryLimitJoint *cpRotaryLimitJointInit(cpRotaryLimitJoint *joint , cpBody *a ,
                                           cpBody *b , cpFloat min , cpFloat max ) ;
cpConstraint *cpRotaryLimitJointNew(cpBody *a , cpBody *b , cpFloat min , cpFloat max ) ;
cpFloat cpRotaryLimitJointGetMin(cpConstraint const   *constraint ) ;
void cpRotaryLimitJointSetMin(cpConstraint *constraint , cpFloat min ) ;
cpFloat cpRotaryLimitJointGetMax(cpConstraint const   *constraint ) ;
void cpRotaryLimitJointSetMax(cpConstraint *constraint , cpFloat max ) ;
static void preStep___6(cpRotaryLimitJoint *joint , cpFloat dt ) 
{ 
  cpBody *a ;
  cpBody *b ;
  cpFloat dist ;
  cpFloat pdist ;
  cpFloat maxBias ;
  cpFloat tmp ;

  {
  a = joint->constraint.a;
  b = joint->constraint.b;
  dist = b->a - a->a;
  pdist = (cpFloat )0.0f;
  if (dist > joint->max) {
    pdist = joint->max - dist;
  } else
  if (dist < joint->min) {
    pdist = joint->min - dist;
  }
  joint->iSum = (cpFloat )1.0f / (a->i_inv + b->i_inv);
  maxBias = joint->constraint.maxBias;
  tmp = bias_coef(joint->constraint.errorBias, dt);
  joint->bias = cpfclamp((- tmp * pdist) / dt, - maxBias, maxBias);
  if (! joint->bias) {
    joint->jAcc = (cpFloat )0.0f;
  }
  return;
}
}
static void applyCachedImpulse___6(cpRotaryLimitJoint *joint , cpFloat dt_coef ) 
{ 
  cpBody *a ;
  cpBody *b ;
  cpFloat j ;

  {
  a = joint->constraint.a;
  b = joint->constraint.b;
  j = joint->jAcc * dt_coef;
  a->w -= j * a->i_inv;
  b->w += j * b->i_inv;
  return;
}
}
static void applyImpulse___6(cpRotaryLimitJoint *joint , cpFloat dt ) 
{ 
  cpBody *a ;
  cpBody *b ;
  cpFloat wr ;
  cpFloat jMax ;
  cpFloat j ;
  cpFloat jOld ;

  {
  if (! joint->bias) {
    return;
  }
  a = joint->constraint.a;
  b = joint->constraint.b;
  wr = b->w - a->w;
  jMax = joint->constraint.maxForce * dt;
  j = - (joint->bias + wr) * joint->iSum;
  jOld = joint->jAcc;
  if (joint->bias < (cpFloat )0.0f) {
    joint->jAcc = cpfclamp(jOld + j, (cpFloat )0.0f, jMax);
  } else {
    joint->jAcc = cpfclamp(jOld + j, - jMax, (cpFloat )0.0f);
  }
  j = joint->jAcc - jOld;
  a->w -= j * a->i_inv;
  b->w += j * b->i_inv;
  return;
}
}
static cpFloat getImpulse___6(cpRotaryLimitJoint *joint ) 
{ 
  cpFloat tmp ;

  {
  tmp = cpfabs(joint->jAcc);
  return (tmp);
}
}
static struct cpConstraintClass  const  klass___7  =    {(void (*)(cpConstraint *constraint , cpFloat dt ))(& preStep___6), (void (*)(cpConstraint *constraint ,
                                                                                 cpFloat dt_coef ))(& applyCachedImpulse___6),
    (void (*)(cpConstraint *constraint , cpFloat dt ))(& applyImpulse___6), (cpFloat (*)(cpConstraint *constraint ))(& getImpulse___6)};
cpRotaryLimitJoint *cpRotaryLimitJointAlloc(void) 
{ 
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(cpRotaryLimitJoint ));
  return ((cpRotaryLimitJoint *)tmp);
}
}
cpRotaryLimitJoint *cpRotaryLimitJointInit(cpRotaryLimitJoint *joint , cpBody *a ,
                                           cpBody *b , cpFloat min , cpFloat max ) 
{ 


  {
  cpConstraintInit((cpConstraint *)joint, & klass___7, a, b);
  joint->min = min;
  joint->max = max;
  joint->jAcc = (cpFloat )0.0f;
  return (joint);
}
}
cpConstraint *cpRotaryLimitJointNew(cpBody *a , cpBody *b , cpFloat min , cpFloat max ) 
{ 
  cpRotaryLimitJoint *tmp ;
  cpRotaryLimitJoint *tmp___0 ;

  {
  tmp = cpRotaryLimitJointAlloc();
  tmp___0 = cpRotaryLimitJointInit(tmp, a, b, min, max);
  return ((cpConstraint *)tmp___0);
}
}
cpBool cpConstraintIsRotaryLimitJoint(cpConstraint const   *constraint ) 
{ 


  {
  return ((cpBool )((unsigned long )constraint->klass == (unsigned long )(& klass___7)));
}
}
cpFloat cpRotaryLimitJointGetMin(cpConstraint const   *constraint ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsRotaryLimitJoint(constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsRotaryLimitJoint(constraint)", "../src/cpRotaryLimitJoint.c",
              135, 1, 1, "Constraint is not a rotary limit joint.");
    abort();
  }
  return (((cpRotaryLimitJoint *)constraint)->min);
}
}
void cpRotaryLimitJointSetMin(cpConstraint *constraint , cpFloat min ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsRotaryLimitJoint((cpConstraint const   *)constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsRotaryLimitJoint(constraint)", "../src/cpRotaryLimitJoint.c",
              142, 1, 1, "Constraint is not a rotary limit joint.");
    abort();
  }
  cpConstraintActivateBodies(constraint);
  ((cpRotaryLimitJoint *)constraint)->min = min;
  return;
}
}
cpFloat cpRotaryLimitJointGetMax(cpConstraint const   *constraint ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsRotaryLimitJoint(constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsRotaryLimitJoint(constraint)", "../src/cpRotaryLimitJoint.c",
              150, 1, 1, "Constraint is not a rotary limit joint.");
    abort();
  }
  return (((cpRotaryLimitJoint *)constraint)->max);
}
}
void cpRotaryLimitJointSetMax(cpConstraint *constraint , cpFloat max ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsRotaryLimitJoint((cpConstraint const   *)constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsRotaryLimitJoint(constraint)", "../src/cpRotaryLimitJoint.c",
              157, 1, 1, "Constraint is not a rotary limit joint.");
    abort();
  }
  cpConstraintActivateBodies(constraint);
  ((cpRotaryLimitJoint *)constraint)->max = max;
  return;
}
}
#pragma merger("0","/tmp/cil-dMTN9CTn.i","-std=gnu99,-ffast-math,-fPIC")
static struct cpVect  const  cpvzero___6  =    {(cpFloat )0.0f, (cpFloat )0.0f};
__inline static cpBB cpBBNewForExtents(cpVect const   c , cpFloat const   hw , cpFloat const   hh ) 
{ 
  cpBB tmp ;

  {
  tmp = cpBBNew(c.x - hw, c.y - hh, c.x + hw, c.y + hh);
  return (tmp);
}
}
__inline static cpBB cpBBNewForCircle(cpVect const   p , cpFloat const   r ) 
{ 
  cpBB tmp ;

  {
  tmp = cpBBNewForExtents(p, r, r);
  return (tmp);
}
}
void cpShapeDestroy(cpShape *shape ) ;
void cpShapeFree(cpShape *shape ) ;
cpBB cpShapeCacheBB(cpShape *shape ) ;
cpBB cpShapeUpdate(cpShape *shape , cpTransform transform ) ;
cpFloat cpShapePointQuery(cpShape const   *shape , cpVect p , cpPointQueryInfo *info ) ;
cpBool cpShapeSegmentQuery(cpShape const   *shape , cpVect a , cpVect b , cpFloat radius ,
                           cpSegmentQueryInfo *info ) ;
cpContactPointSet cpShapesCollide(cpShape const   *a , cpShape const   *b ) ;
cpSpace *cpShapeGetSpace(cpShape const   *shape ) ;
cpBody *cpShapeGetBody(cpShape const   *shape ) ;
void cpShapeSetBody(cpShape *shape , cpBody *body ) ;
cpFloat cpShapeGetMass(cpShape *shape ) ;
void cpShapeSetMass(cpShape *shape , cpFloat mass ) ;
cpFloat cpShapeGetDensity(cpShape *shape ) ;
void cpShapeSetDensity(cpShape *shape , cpFloat density ) ;
cpFloat cpShapeGetMoment(cpShape *shape ) ;
cpFloat cpShapeGetArea(cpShape *shape ) ;
cpVect cpShapeGetCenterOfGravity(cpShape *shape ) ;
cpBB cpShapeGetBB(cpShape const   *shape ) ;
cpBool cpShapeGetSensor(cpShape const   *shape ) ;
void cpShapeSetSensor(cpShape *shape , cpBool sensor ) ;
cpFloat cpShapeGetElasticity(cpShape const   *shape ) ;
void cpShapeSetElasticity(cpShape *shape , cpFloat elasticity ) ;
cpFloat cpShapeGetFriction(cpShape const   *shape ) ;
void cpShapeSetFriction(cpShape *shape , cpFloat friction ) ;
cpVect cpShapeGetSurfaceVelocity(cpShape const   *shape ) ;
void cpShapeSetSurfaceVelocity(cpShape *shape , cpVect surfaceVelocity ) ;
cpDataPointer cpShapeGetUserData(cpShape const   *shape ) ;
void cpShapeSetUserData(cpShape *shape , cpDataPointer userData ) ;
cpCollisionType cpShapeGetCollisionType(cpShape const   *shape ) ;
void cpShapeSetCollisionType(cpShape *shape , cpCollisionType collisionType ) ;
cpShapeFilter cpShapeGetFilter(cpShape const   *shape ) ;
void cpShapeSetFilter(cpShape *shape , cpShapeFilter filter ) ;
cpCircleShape *cpCircleShapeAlloc(void) ;
cpCircleShape *cpCircleShapeInit(cpCircleShape *circle , cpBody *body , cpFloat radius ,
                                 cpVect offset ) ;
cpShape *cpCircleShapeNew(cpBody *body , cpFloat radius , cpVect offset ) ;
cpVect cpCircleShapeGetOffset(cpShape const   *shape ) ;
cpFloat cpCircleShapeGetRadius(cpShape const   *shape ) ;
cpSegmentShape *cpSegmentShapeAlloc(void) ;
cpSegmentShape *cpSegmentShapeInit(cpSegmentShape *seg___0 , cpBody *body , cpVect a ,
                                   cpVect b , cpFloat r ) ;
cpShape *cpSegmentShapeNew(cpBody *body , cpVect a , cpVect b , cpFloat r ) ;
void cpSegmentShapeSetNeighbors(cpShape *shape , cpVect prev , cpVect next ) ;
cpVect cpSegmentShapeGetA(cpShape const   *shape ) ;
cpVect cpSegmentShapeGetB(cpShape const   *shape ) ;
cpVect cpSegmentShapeGetNormal(cpShape const   *shape ) ;
cpFloat cpSegmentShapeGetRadius(cpShape const   *shape ) ;
__inline static cpBool cpShapeActive(cpShape *shape ) 
{ 
  int tmp ;

  {
  if (shape->prev) {
    tmp = 1;
  } else
  if (shape->body) {
    if ((unsigned long )(shape->body)->shapeList == (unsigned long )shape) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((cpBool )tmp);
}
}
void cpCircleShapeSetRadius(cpShape *shape , cpFloat radius ) ;
void cpCircleShapeSetOffset(cpShape *shape , cpVect offset ) ;
void cpSegmentShapeSetEndpoints(cpShape *shape , cpVect a , cpVect b ) ;
void cpSegmentShapeSetRadius(cpShape *shape , cpFloat radius ) ;
cpShape *cpShapeInit(cpShape *shape , cpShapeClass const   *klass___12 , cpBody *body ,
                     struct cpShapeMassInfo massInfo ) 
{ 


  {
  shape->klass = klass___12;
  shape->body = body;
  shape->massInfo = massInfo;
  shape->sensor = (cpBool )0;
  shape->e = (cpFloat )0.0f;
  shape->u = (cpFloat )0.0f;
  shape->surfaceV = (cpVect )cpvzero___6;
  shape->type = (cpCollisionType )0;
  shape->filter.group = (cpGroup )0;
  shape->filter.categories = ~ ((cpBitmask )0);
  shape->filter.mask = ~ ((cpBitmask )0);
  shape->userData = (void *)0;
  shape->space = (cpSpace *)((void *)0);
  shape->next = (cpShape *)((void *)0);
  shape->prev = (cpShape *)((void *)0);
  return (shape);
}
}
void cpShapeDestroy(cpShape *shape ) 
{ 


  {
  if (shape->klass) {
    if ((shape->klass)->destroy) {
      (*((shape->klass)->destroy))(shape);
    }
  }
  return;
}
}
void cpShapeFree(cpShape *shape ) 
{ 


  {
  if (shape) {
    cpShapeDestroy(shape);
    free((void *)shape);
  }
  return;
}
}
cpSpace *cpShapeGetSpace(cpShape const   *shape ) 
{ 


  {
  return ((cpSpace *)shape->space);
}
}
cpBody *cpShapeGetBody(cpShape const   *shape ) 
{ 


  {
  return ((cpBody *)shape->body);
}
}
void cpShapeSetBody(cpShape *shape , cpBody *body ) 
{ 
  cpBool tmp ;

  {
  tmp = cpShapeActive(shape);
  if (tmp) {
    cpMessage("!cpShapeActive(shape)", "../src/cpShape.c", 90, 1, 1, "You cannot change the body on an active shape. You must remove the shape from the space before changing the body.");
    abort();
  }
  shape->body = body;
  return;
}
}
cpFloat cpShapeGetMass(cpShape *shape ) 
{ 


  {
  return (shape->massInfo.m);
}
}
void cpShapeSetMass(cpShape *shape , cpFloat mass ) 
{ 
  cpBody *body ;

  {
  body = shape->body;
  cpBodyActivate(body);
  shape->massInfo.m = mass;
  cpBodyAccumulateMassFromShapes(body);
  return;
}
}
cpFloat cpShapeGetDensity(cpShape *shape ) 
{ 


  {
  return (shape->massInfo.m / shape->massInfo.area);
}
}
void cpShapeSetDensity(cpShape *shape , cpFloat density ) 
{ 


  {
  cpShapeSetMass(shape, density * shape->massInfo.area);
  return;
}
}
cpFloat cpShapeGetMoment(cpShape *shape ) 
{ 


  {
  return (shape->massInfo.m * shape->massInfo.i);
}
}
cpFloat cpShapeGetArea(cpShape *shape ) 
{ 


  {
  return (shape->massInfo.area);
}
}
cpVect cpShapeGetCenterOfGravity(cpShape *shape ) 
{ 


  {
  return (shape->massInfo.cog);
}
}
cpBB cpShapeGetBB(cpShape const   *shape ) 
{ 


  {
  return ((cpBB )shape->bb);
}
}
cpBool cpShapeGetSensor(cpShape const   *shape ) 
{ 


  {
  return ((cpBool )shape->sensor);
}
}
void cpShapeSetSensor(cpShape *shape , cpBool sensor ) 
{ 


  {
  cpBodyActivate(shape->body);
  shape->sensor = sensor;
  return;
}
}
cpFloat cpShapeGetElasticity(cpShape const   *shape ) 
{ 


  {
  return ((cpFloat )shape->e);
}
}
void cpShapeSetElasticity(cpShape *shape , cpFloat elasticity ) 
{ 


  {
  if (! (elasticity >= (cpFloat )0.0f)) {
    cpMessage("elasticity >= 0.0f", "../src/cpShape.c", 140, 1, 1, "Elasticity must be positive.");
    abort();
  }
  cpBodyActivate(shape->body);
  shape->e = elasticity;
  return;
}
}
cpFloat cpShapeGetFriction(cpShape const   *shape ) 
{ 


  {
  return ((cpFloat )shape->u);
}
}
void cpShapeSetFriction(cpShape *shape , cpFloat friction ) 
{ 


  {
  if (! (friction >= (cpFloat )0.0f)) {
    cpMessage("friction >= 0.0f", "../src/cpShape.c", 154, 1, 1, "Friction must be postive.");
    abort();
  }
  cpBodyActivate(shape->body);
  shape->u = friction;
  return;
}
}
cpVect cpShapeGetSurfaceVelocity(cpShape const   *shape ) 
{ 


  {
  return ((cpVect )shape->surfaceV);
}
}
void cpShapeSetSurfaceVelocity(cpShape *shape , cpVect surfaceVelocity ) 
{ 


  {
  cpBodyActivate(shape->body);
  shape->surfaceV = surfaceVelocity;
  return;
}
}
cpDataPointer cpShapeGetUserData(cpShape const   *shape ) 
{ 


  {
  return ((cpDataPointer )shape->userData);
}
}
void cpShapeSetUserData(cpShape *shape , cpDataPointer userData ) 
{ 


  {
  shape->userData = userData;
  return;
}
}
cpCollisionType cpShapeGetCollisionType(cpShape const   *shape ) 
{ 


  {
  return ((cpCollisionType )shape->type);
}
}
void cpShapeSetCollisionType(cpShape *shape , cpCollisionType collisionType ) 
{ 


  {
  cpBodyActivate(shape->body);
  shape->type = collisionType;
  return;
}
}
cpShapeFilter cpShapeGetFilter(cpShape const   *shape ) 
{ 


  {
  return ((cpShapeFilter )shape->filter);
}
}
void cpShapeSetFilter(cpShape *shape , cpShapeFilter filter ) 
{ 


  {
  cpBodyActivate(shape->body);
  shape->filter = filter;
  return;
}
}
cpBB cpShapeCacheBB(cpShape *shape ) 
{ 
  cpBB tmp ;

  {
  tmp = cpShapeUpdate(shape, (shape->body)->transform);
  return (tmp);
}
}
cpBB cpShapeUpdate(cpShape *shape , cpTransform transform ) 
{ 
  cpBB tmp ;

  {
  tmp = (*((shape->klass)->cacheData))(shape, transform);
  shape->bb = tmp;
  return (tmp);
}
}
cpFloat cpShapePointQuery(cpShape const   *shape , cpVect p , cpPointQueryInfo *info ) 
{ 
  cpPointQueryInfo blank ;
  float tmp ;

  {
  tmp = __builtin_inff();
  blank.shape = (cpShape const   *)((void *)0);
  blank.point = cpvzero___6;
  blank.distance = (cpFloat )tmp;
  blank.gradient = cpvzero___6;
  if (info) {
    *info = blank;
  } else {
    info = & blank;
  }
  (*((shape->klass)->pointQuery))(shape, p, info);
  return (info->distance);
}
}
cpBool cpShapeSegmentQuery(cpShape const   *shape , cpVect a , cpVect b , cpFloat radius ,
                           cpSegmentQueryInfo *info ) 
{ 
  cpSegmentQueryInfo blank ;
  cpPointQueryInfo nearest ;
  cpVect tmp ;

  {
  blank.shape = (cpShape const   *)((void *)0);
  blank.point = b;
  blank.normal = cpvzero___6;
  blank.alpha = (cpFloat )1.0f;
  if (info) {
    *info = blank;
  } else {
    info = & blank;
  }
  (*((shape->klass)->pointQuery))(shape, a, & nearest);
  if (nearest.distance <= radius) {
    info->shape = shape;
    info->alpha = 0.0;
    tmp = cpvsub((cpVect const   )a, (cpVect const   )nearest.point);
    info->normal = cpvnormalize((cpVect const   )tmp);
  } else {
    (*((shape->klass)->segmentQuery))(shape, a, b, radius, info);
  }
  return ((cpBool )((unsigned long )info->shape != (unsigned long )((void *)0)));
}
}
cpContactPointSet cpShapesCollide(cpShape const   *a , cpShape const   *b ) 
{ 
  struct cpContact contacts[2] ;
  struct cpCollisionInfo info ;
  struct cpCollisionInfo tmp ;
  cpContactPointSet set ;
  cpBool swapped ;
  cpVect tmp___0 ;
  int i ;
  cpVect p1 ;
  cpVect p2 ;
  cpVect tmp___1 ;

  {
  tmp = cpCollide(a, b, (cpCollisionID )0, contacts);
  info = tmp;
  set.count = info.count;
  swapped = (cpBool )((unsigned long )a != (unsigned long )info.a);
  if (swapped) {
    tmp___0 = cpvneg((cpVect const   )info.n);
    set.normal = tmp___0;
  } else {
    set.normal = info.n;
  }
  i = 0;
  while (i < info.count) {
    p1 = contacts[i].r1;
    p2 = contacts[i].r2;
    if (swapped) {
      set.points[i].pointA = p2;
    } else {
      set.points[i].pointA = p1;
    }
    if (swapped) {
      set.points[i].pointB = p1;
    } else {
      set.points[i].pointB = p2;
    }
    tmp___1 = cpvsub((cpVect const   )p2, (cpVect const   )p1);
    set.points[i].distance = cpvdot((cpVect const   )tmp___1, (cpVect const   )set.normal);
    i ++;
  }
  return (set);
}
}
cpCircleShape *cpCircleShapeAlloc(void) 
{ 
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(cpCircleShape ));
  return ((cpCircleShape *)tmp);
}
}
static cpBB cpCircleShapeCacheData(cpCircleShape *circle , cpTransform transform ) 
{ 
  cpVect c ;
  cpVect tmp ;
  cpBB tmp___0 ;

  {
  tmp = cpTransformPoint(transform, circle->c);
  circle->tc = tmp;
  c = tmp;
  tmp___0 = cpBBNewForCircle((cpVect const   )c, (cpFloat const   )circle->r);
  return (tmp___0);
}
}
static void cpCircleShapePointQuery(cpCircleShape *circle , cpVect p , cpPointQueryInfo *info ) 
{ 
  cpVect delta ;
  cpVect tmp ;
  cpFloat d ;
  cpFloat tmp___0 ;
  cpFloat r ;
  cpFloat r_over_d ;
  cpFloat tmp___1 ;
  cpVect tmp___2 ;
  cpVect tmp___3 ;
  cpVect tmp___4 ;

  {
  tmp = cpvsub((cpVect const   )p, (cpVect const   )circle->tc);
  delta = tmp;
  tmp___0 = cpvlength((cpVect const   )delta);
  d = tmp___0;
  r = circle->r;
  info->shape = (cpShape const   *)((cpShape *)circle);
  if (d > (cpFloat )0.0f) {
    tmp___1 = r / d;
  } else {
    tmp___1 = r;
  }
  r_over_d = tmp___1;
  tmp___2 = cpvmult((cpVect const   )delta, (cpFloat const   )r_over_d);
  info->point = cpvadd((cpVect const   )circle->tc, (cpVect const   )tmp___2);
  info->distance = d - r;
  if (d > 1e-5) {
    tmp___3 = cpvmult((cpVect const   )delta, (cpFloat const   )((cpFloat )1.0f / d));
    info->gradient = tmp___3;
  } else {
    tmp___4 = cpv((cpFloat const   )0.0f, (cpFloat const   )1.0f);
    info->gradient = tmp___4;
  }
  return;
}
}
static void cpCircleShapeSegmentQuery(cpCircleShape *circle , cpVect a , cpVect b ,
                                      cpFloat radius , cpSegmentQueryInfo *info ) 
{ 


  {
  CircleSegmentQuery((cpShape *)circle, circle->tc, circle->r, a, b, radius, info);
  return;
}
}
static struct cpShapeMassInfo cpCircleShapeMassInfo(cpFloat mass , cpFloat radius ,
                                                    cpVect center ) 
{ 
  struct cpShapeMassInfo info ;
  cpFloat tmp ;
  cpFloat tmp___0 ;

  {
  tmp = cpMomentForCircle((cpFloat )1.0f, (cpFloat )0.0f, radius, (cpVect )cpvzero___6);
  tmp___0 = cpAreaForCircle((cpFloat )0.0f, radius);
  info.m = mass;
  info.i = tmp;
  info.cog = center;
  info.area = tmp___0;
  return (info);
}
}
static struct cpShapeClass  const  cpCircleShapeClass  =    {(cpShapeType )0, (cpBB (*)(cpShape *shape , cpTransform transform ))(& cpCircleShapeCacheData),
    (void (*)(cpShape *shape ))((void *)0), (void (*)(cpShape const   *shape , cpVect p ,
                                                      cpPointQueryInfo *info ))(& cpCircleShapePointQuery),
    (void (*)(cpShape const   *shape , cpVect a , cpVect b , cpFloat radius , cpSegmentQueryInfo *info ))(& cpCircleShapeSegmentQuery)};
cpCircleShape *cpCircleShapeInit(cpCircleShape *circle ,
                                 cpBody *body , cpFloat radius , cpVect offset ) 
{ 
  struct cpShapeMassInfo tmp ;

  {
  circle->c = offset;
  circle->r = radius;
  tmp = cpCircleShapeMassInfo((cpFloat )0.0f, radius, offset);
  cpShapeInit((cpShape *)circle, & cpCircleShapeClass, body, tmp);
  return (circle);
}
}
cpShape *cpCircleShapeNew(cpBody *body , cpFloat radius , cpVect offset ) 
{ 
  cpCircleShape *tmp ;
  cpCircleShape *tmp___0 ;

  {
  tmp = cpCircleShapeAlloc();
  tmp___0 = cpCircleShapeInit(tmp, body, radius, offset);
  return ((cpShape *)tmp___0);
}
}
cpVect cpCircleShapeGetOffset(cpShape const   *shape ) 
{ 


  {
  if (! ((unsigned long )shape->klass == (unsigned long )(& cpCircleShapeClass))) {
    cpMessage("shape->klass == &cpCircleShapeClass", "../src/cpShape.c", 360, 1, 1,
              "Shape is not a circle shape.");
    abort();
  }
  return (((cpCircleShape *)shape)->c);
}
}
cpFloat cpCircleShapeGetRadius(cpShape const   *shape ) 
{ 


  {
  if (! ((unsigned long )shape->klass == (unsigned long )(& cpCircleShapeClass))) {
    cpMessage("shape->klass == &cpCircleShapeClass", "../src/cpShape.c", 367, 1, 1,
              "Shape is not a circle shape.");
    abort();
  }
  return (((cpCircleShape *)shape)->r);
}
}
cpSegmentShape *cpSegmentShapeAlloc(void) 
{ 
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(cpSegmentShape ));
  return ((cpSegmentShape *)tmp);
}
}
static cpBB cpSegmentShapeCacheData(cpSegmentShape *seg___0 , cpTransform transform ) 
{ 
  cpFloat l ;
  cpFloat r ;
  cpFloat b ;
  cpFloat t ;
  cpFloat rad ;
  cpBB tmp ;

  {
  seg___0->ta = cpTransformPoint(transform, seg___0->a);
  seg___0->tb = cpTransformPoint(transform, seg___0->b);
  seg___0->tn = cpTransformVect(transform, seg___0->n);
  if (seg___0->ta.x < seg___0->tb.x) {
    l = seg___0->ta.x;
    r = seg___0->tb.x;
  } else {
    l = seg___0->tb.x;
    r = seg___0->ta.x;
  }
  if (seg___0->ta.y < seg___0->tb.y) {
    b = seg___0->ta.y;
    t = seg___0->tb.y;
  } else {
    b = seg___0->tb.y;
    t = seg___0->ta.y;
  }
  rad = seg___0->r;
  tmp = cpBBNew((cpFloat const   )(l - rad), (cpFloat const   )(b - rad), (cpFloat const   )(r + rad),
                (cpFloat const   )(t + rad));
  return (tmp);
}
}
static void cpSegmentShapePointQuery(cpSegmentShape *seg___0 , cpVect p , cpPointQueryInfo *info ) 
{ 
  cpVect closest ;
  cpVect tmp ;
  cpVect delta ;
  cpVect tmp___0 ;
  cpFloat d ;
  cpFloat tmp___1 ;
  cpFloat r ;
  cpVect g ;
  cpVect tmp___2 ;
  cpVect tmp___3 ;
  cpVect tmp___4 ;

  {
  tmp = cpClosetPointOnSegment((cpVect const   )p, (cpVect const   )seg___0->ta, (cpVect const   )seg___0->tb);
  closest = tmp;
  tmp___0 = cpvsub((cpVect const   )p, (cpVect const   )closest);
  delta = tmp___0;
  tmp___1 = cpvlength((cpVect const   )delta);
  d = tmp___1;
  r = seg___0->r;
  tmp___2 = cpvmult((cpVect const   )delta, (cpFloat const   )((cpFloat )1.0f / d));
  g = tmp___2;
  info->shape = (cpShape const   *)((cpShape *)seg___0);
  if (d) {
    tmp___3 = cpvmult((cpVect const   )g, (cpFloat const   )r);
    tmp___4 = cpvadd((cpVect const   )closest, (cpVect const   )tmp___3);
    info->point = tmp___4;
  } else {
    info->point = closest;
  }
  info->distance = d - r;
  if (d > 1e-5) {
    info->gradient = g;
  } else {
    info->gradient = seg___0->n;
  }
  return;
}
}
static void cpSegmentShapeSegmentQuery(cpSegmentShape *seg___0 , cpVect a , cpVect b ,
                                       cpFloat r2 , cpSegmentQueryInfo *info ) 
{ 
  cpVect n ;
  cpFloat d ;
  cpVect tmp ;
  cpFloat tmp___0 ;
  cpFloat r ;
  cpVect flipped_n ;
  cpVect tmp___1 ;
  cpVect tmp___2 ;
  cpVect seg_offset ;
  cpVect tmp___3 ;
  cpVect tmp___4 ;
  cpVect seg_a ;
  cpVect tmp___5 ;
  cpVect seg_b ;
  cpVect tmp___6 ;
  cpVect delta ;
  cpVect tmp___7 ;
  cpFloat d_offset ;
  cpFloat tmp___8 ;
  cpFloat ad ;
  cpFloat bd ;
  cpFloat tmp___9 ;
  cpFloat t ;
  cpVect tmp___10 ;
  cpVect tmp___11 ;
  cpSegmentQueryInfo info1 ;
  cpSegmentQueryInfo info2 ;
  cpFloat tmp___12 ;
  cpFloat tmp___13 ;

  {
  n = seg___0->tn;
  tmp = cpvsub((cpVect const   )seg___0->ta, (cpVect const   )a);
  tmp___0 = cpvdot((cpVect const   )tmp, (cpVect const   )n);
  d = tmp___0;
  r = seg___0->r + r2;
  if (d > (cpFloat )0.0f) {
    tmp___1 = cpvneg((cpVect const   )n);
    tmp___2 = tmp___1;
  } else {
    tmp___2 = n;
  }
  flipped_n = tmp___2;
  tmp___3 = cpvmult((cpVect const   )flipped_n, (cpFloat const   )r);
  tmp___4 = cpvsub((cpVect const   )tmp___3, (cpVect const   )a);
  seg_offset = tmp___4;
  tmp___5 = cpvadd((cpVect const   )seg___0->ta, (cpVect const   )seg_offset);
  seg_a = tmp___5;
  tmp___6 = cpvadd((cpVect const   )seg___0->tb, (cpVect const   )seg_offset);
  seg_b = tmp___6;
  tmp___7 = cpvsub((cpVect const   )b, (cpVect const   )a);
  delta = tmp___7;
  tmp___12 = cpvcross((cpVect const   )delta, (cpVect const   )seg_a);
  tmp___13 = cpvcross((cpVect const   )delta, (cpVect const   )seg_b);
  if (tmp___12 * tmp___13 <= (cpFloat )0.0f) {
    if (d > (cpFloat )0.0f) {
      tmp___8 = - r;
    } else {
      tmp___8 = r;
    }
    d_offset = d + tmp___8;
    ad = - d_offset;
    tmp___9 = cpvdot((cpVect const   )delta, (cpVect const   )n);
    bd = tmp___9 - d_offset;
    if (ad * bd < (cpFloat )0.0f) {
      t = ad / (ad - bd);
      info->shape = (cpShape const   *)((cpShape *)seg___0);
      tmp___10 = cpvmult((cpVect const   )flipped_n, (cpFloat const   )r2);
      tmp___11 = cpvlerp((cpVect const   )a, (cpVect const   )b, (cpFloat const   )t);
      info->point = cpvsub((cpVect const   )tmp___11, (cpVect const   )tmp___10);
      info->normal = flipped_n;
      info->alpha = t;
    }
  } else
  if (r != (cpFloat )0.0f) {
    info1.shape = (cpShape const   *)((void *)0);
    info1.point = b;
    info1.normal = cpvzero___6;
    info1.alpha = (cpFloat )1.0f;
    info2.shape = (cpShape const   *)((void *)0);
    info2.point = b;
    info2.normal = cpvzero___6;
    info2.alpha = (cpFloat )1.0f;
    CircleSegmentQuery((cpShape *)seg___0, seg___0->ta, seg___0->r, a, b, r2, & info1);
    CircleSegmentQuery((cpShape *)seg___0, seg___0->tb, seg___0->r, a, b, r2, & info2);
    if (info1.alpha < info2.alpha) {
      *info = info1;
    } else {
      *info = info2;
    }
  }
  return;
}
}
static struct cpShapeMassInfo cpSegmentShapeMassInfo(cpFloat mass , cpVect a , cpVect b ,
                                                     cpFloat r ) 
{ 
  struct cpShapeMassInfo info ;
  cpFloat tmp ;
  cpFloat tmp___0 ;
  cpVect tmp___1 ;
  cpFloat tmp___2 ;

  {
  tmp = cpvdist((cpVect const   )a, (cpVect const   )b);
  tmp___0 = cpMomentForBox((cpFloat )1.0f, tmp + (cpFloat )2.0f * r, (cpFloat )2.0f * r);
  tmp___1 = cpvlerp((cpVect const   )a, (cpVect const   )b, (cpFloat const   )0.5f);
  tmp___2 = cpAreaForSegment(a, b, r);
  info.m = mass;
  info.i = tmp___0;
  info.cog = tmp___1;
  info.area = tmp___2;
  return (info);
}
}
static struct cpShapeClass  const  cpSegmentShapeClass  =    {(cpShapeType )1, (cpBB (*)(cpShape *shape , cpTransform transform ))(& cpSegmentShapeCacheData),
    (void (*)(cpShape *shape ))((void *)0), (void (*)(cpShape const   *shape , cpVect p ,
                                                      cpPointQueryInfo *info ))(& cpSegmentShapePointQuery),
    (void (*)(cpShape const   *shape , cpVect a , cpVect b , cpFloat radius , cpSegmentQueryInfo *info ))(& cpSegmentShapeSegmentQuery)};
cpSegmentShape *cpSegmentShapeInit(cpSegmentShape *seg___0 ,
                                   cpBody *body , cpVect a , cpVect b , cpFloat r ) 
{ 
  cpVect tmp ;
  cpVect tmp___0 ;
  struct cpShapeMassInfo tmp___1 ;

  {
  seg___0->a = a;
  seg___0->b = b;
  tmp = cpvsub((cpVect const   )b, (cpVect const   )a);
  tmp___0 = cpvnormalize((cpVect const   )tmp);
  seg___0->n = cpvrperp((cpVect const   )tmp___0);
  seg___0->r = r;
  seg___0->a_tangent = (cpVect )cpvzero___6;
  seg___0->b_tangent = (cpVect )cpvzero___6;
  tmp___1 = cpSegmentShapeMassInfo((cpFloat )0.0f, a, b, r);
  cpShapeInit((cpShape *)seg___0, & cpSegmentShapeClass, body, tmp___1);
  return (seg___0);
}
}
cpShape *cpSegmentShapeNew(cpBody *body , cpVect a , cpVect b , cpFloat r ) 
{ 
  cpSegmentShape *tmp ;
  cpSegmentShape *tmp___0 ;

  {
  tmp = cpSegmentShapeAlloc();
  tmp___0 = cpSegmentShapeInit(tmp, body, a, b, r);
  return ((cpShape *)tmp___0);
}
}
cpVect cpSegmentShapeGetA(cpShape const   *shape ) 
{ 


  {
  if (! ((unsigned long )shape->klass == (unsigned long )(& cpSegmentShapeClass))) {
    cpMessage("shape->klass == &cpSegmentShapeClass", "../src/cpShape.c", 513, 1,
              1, "Shape is not a segment shape.");
    abort();
  }
  return (((cpSegmentShape *)shape)->a);
}
}
cpVect cpSegmentShapeGetB(cpShape const   *shape ) 
{ 


  {
  if (! ((unsigned long )shape->klass == (unsigned long )(& cpSegmentShapeClass))) {
    cpMessage("shape->klass == &cpSegmentShapeClass", "../src/cpShape.c", 520, 1,
              1, "Shape is not a segment shape.");
    abort();
  }
  return (((cpSegmentShape *)shape)->b);
}
}
cpVect cpSegmentShapeGetNormal(cpShape const   *shape ) 
{ 


  {
  if (! ((unsigned long )shape->klass == (unsigned long )(& cpSegmentShapeClass))) {
    cpMessage("shape->klass == &cpSegmentShapeClass", "../src/cpShape.c", 527, 1,
              1, "Shape is not a segment shape.");
    abort();
  }
  return (((cpSegmentShape *)shape)->n);
}
}
cpFloat cpSegmentShapeGetRadius(cpShape const   *shape ) 
{ 


  {
  if (! ((unsigned long )shape->klass == (unsigned long )(& cpSegmentShapeClass))) {
    cpMessage("shape->klass == &cpSegmentShapeClass", "../src/cpShape.c", 534, 1,
              1, "Shape is not a segment shape.");
    abort();
  }
  return (((cpSegmentShape *)shape)->r);
}
}
void cpSegmentShapeSetNeighbors(cpShape *shape , cpVect prev , cpVect next ) 
{ 
  cpSegmentShape *seg___0 ;

  {
  if (! ((unsigned long )shape->klass == (unsigned long )(& cpSegmentShapeClass))) {
    cpMessage("shape->klass == &cpSegmentShapeClass", "../src/cpShape.c", 541, 1,
              1, "Shape is not a segment shape.");
    abort();
  }
  seg___0 = (cpSegmentShape *)shape;
  seg___0->a_tangent = cpvsub((cpVect const   )prev, (cpVect const   )seg___0->a);
  seg___0->b_tangent = cpvsub((cpVect const   )next, (cpVect const   )seg___0->b);
  return;
}
}
void cpCircleShapeSetRadius(cpShape *shape , cpFloat radius ) 
{ 
  cpCircleShape *circle ;
  cpFloat mass ;

  {
  if (! ((unsigned long )shape->klass == (unsigned long )(& cpCircleShapeClass))) {
    cpMessage("shape->klass == &cpCircleShapeClass", "../src/cpShape.c", 555, 1, 1,
              "Shape is not a circle shape.");
    abort();
  }
  circle = (cpCircleShape *)shape;
  circle->r = radius;
  mass = shape->massInfo.m;
  shape->massInfo = cpCircleShapeMassInfo(mass, circle->r, circle->c);
  if (mass > (cpFloat )0.0f) {
    cpBodyAccumulateMassFromShapes(shape->body);
  }
  return;
}
}
void cpCircleShapeSetOffset(cpShape *shape , cpVect offset ) 
{ 
  cpCircleShape *circle ;
  cpFloat mass ;

  {
  if (! ((unsigned long )shape->klass == (unsigned long )(& cpCircleShapeClass))) {
    cpMessage("shape->klass == &cpCircleShapeClass", "../src/cpShape.c", 568, 1, 1,
              "Shape is not a circle shape.");
    abort();
  }
  circle = (cpCircleShape *)shape;
  circle->c = offset;
  mass = shape->massInfo.m;
  shape->massInfo = cpCircleShapeMassInfo(shape->massInfo.m, circle->r, circle->c);
  if (mass > (cpFloat )0.0f) {
    cpBodyAccumulateMassFromShapes(shape->body);
  }
  return;
}
}
void cpSegmentShapeSetEndpoints(cpShape *shape , cpVect a , cpVect b ) 
{ 
  cpSegmentShape *seg___0 ;
  cpVect tmp ;
  cpVect tmp___0 ;
  cpFloat mass ;

  {
  if (! ((unsigned long )shape->klass == (unsigned long )(& cpSegmentShapeClass))) {
    cpMessage("shape->klass == &cpSegmentShapeClass", "../src/cpShape.c", 581, 1,
              1, "Shape is not a segment shape.");
    abort();
  }
  seg___0 = (cpSegmentShape *)shape;
  seg___0->a = a;
  seg___0->b = b;
  tmp = cpvsub((cpVect const   )b, (cpVect const   )a);
  tmp___0 = cpvnormalize((cpVect const   )tmp);
  seg___0->n = cpvperp((cpVect const   )tmp___0);
  mass = shape->massInfo.m;
  shape->massInfo = cpSegmentShapeMassInfo(shape->massInfo.m, seg___0->a, seg___0->b,
                                           seg___0->r);
  if (mass > (cpFloat )0.0f) {
    cpBodyAccumulateMassFromShapes(shape->body);
  }
  return;
}
}
void cpSegmentShapeSetRadius(cpShape *shape , cpFloat radius ) 
{ 
  cpSegmentShape *seg___0 ;
  cpFloat mass ;

  {
  if (! ((unsigned long )shape->klass == (unsigned long )(& cpSegmentShapeClass))) {
    cpMessage("shape->klass == &cpSegmentShapeClass", "../src/cpShape.c", 596, 1,
              1, "Shape is not a segment shape.");
    abort();
  }
  seg___0 = (cpSegmentShape *)shape;
  seg___0->r = radius;
  mass = shape->massInfo.m;
  shape->massInfo = cpSegmentShapeMassInfo(shape->massInfo.m, seg___0->a, seg___0->b,
                                           seg___0->r);
  if (mass > (cpFloat )0.0f) {
    cpBodyAccumulateMassFromShapes(shape->body);
  }
  return;
}
}
#pragma merger("0","/tmp/cil-EcU5nUuE.i","-std=gnu99,-ffast-math,-fPIC")
cpBool cpConstraintIsSimpleMotor(cpConstraint const   *constraint ) ;
cpSimpleMotor *cpSimpleMotorAlloc(void) ;
cpSimpleMotor *cpSimpleMotorInit(cpSimpleMotor *joint , cpBody *a , cpBody *b , cpFloat rate ) ;
cpConstraint *cpSimpleMotorNew(cpBody *a , cpBody *b , cpFloat rate ) ;
cpFloat cpSimpleMotorGetRate(cpConstraint const   *constraint ) ;
void cpSimpleMotorSetRate(cpConstraint *constraint , cpFloat rate ) ;
static void preStep___7(cpSimpleMotor *joint , cpFloat dt ) 
{ 
  cpBody *a ;
  cpBody *b ;

  {
  a = joint->constraint.a;
  b = joint->constraint.b;
  joint->iSum = (cpFloat )1.0f / (a->i_inv + b->i_inv);
  return;
}
}
static void applyCachedImpulse___7(cpSimpleMotor *joint , cpFloat dt_coef ) 
{ 
  cpBody *a ;
  cpBody *b ;
  cpFloat j ;

  {
  a = joint->constraint.a;
  b = joint->constraint.b;
  j = joint->jAcc * dt_coef;
  a->w -= j * a->i_inv;
  b->w += j * b->i_inv;
  return;
}
}
static void applyImpulse___7(cpSimpleMotor *joint , cpFloat dt ) 
{ 
  cpBody *a ;
  cpBody *b ;
  cpFloat wr ;
  cpFloat jMax ;
  cpFloat j ;
  cpFloat jOld ;

  {
  a = joint->constraint.a;
  b = joint->constraint.b;
  wr = (b->w - a->w) + joint->rate;
  jMax = joint->constraint.maxForce * dt;
  j = - wr * joint->iSum;
  jOld = joint->jAcc;
  joint->jAcc = cpfclamp(jOld + j, - jMax, jMax);
  j = joint->jAcc - jOld;
  a->w -= j * a->i_inv;
  b->w += j * b->i_inv;
  return;
}
}
static cpFloat getImpulse___7(cpSimpleMotor *joint ) 
{ 
  cpFloat tmp ;

  {
  tmp = cpfabs(joint->jAcc);
  return (tmp);
}
}
static struct cpConstraintClass  const  klass___8  =    {(void (*)(cpConstraint *constraint , cpFloat dt ))(& preStep___7), (void (*)(cpConstraint *constraint ,
                                                                                 cpFloat dt_coef ))(& applyCachedImpulse___7),
    (void (*)(cpConstraint *constraint , cpFloat dt ))(& applyImpulse___7), (cpFloat (*)(cpConstraint *constraint ))(& getImpulse___7)};
cpSimpleMotor *cpSimpleMotorAlloc(void) 
{ 
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(cpSimpleMotor ));
  return ((cpSimpleMotor *)tmp);
}
}
cpSimpleMotor *cpSimpleMotorInit(cpSimpleMotor *joint , cpBody *a , cpBody *b , cpFloat rate ) 
{ 


  {
  cpConstraintInit((cpConstraint *)joint, & klass___8, a, b);
  joint->rate = rate;
  joint->jAcc = (cpFloat )0.0f;
  return (joint);
}
}
cpConstraint *cpSimpleMotorNew(cpBody *a , cpBody *b , cpFloat rate ) 
{ 
  cpSimpleMotor *tmp ;
  cpSimpleMotor *tmp___0 ;

  {
  tmp = cpSimpleMotorAlloc();
  tmp___0 = cpSimpleMotorInit(tmp, a, b, rate);
  return ((cpConstraint *)tmp___0);
}
}
cpBool cpConstraintIsSimpleMotor(cpConstraint const   *constraint ) 
{ 


  {
  return ((cpBool )((unsigned long )constraint->klass == (unsigned long )(& klass___8)));
}
}
cpFloat cpSimpleMotorGetRate(cpConstraint const   *constraint ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsSimpleMotor(constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsSimpleMotor(constraint)", "../src/cpSimpleMotor.c", 113,
              1, 1, "Constraint is not a SimpleMotor.");
    abort();
  }
  return (((cpSimpleMotor *)constraint)->rate);
}
}
void cpSimpleMotorSetRate(cpConstraint *constraint , cpFloat rate ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsSimpleMotor((cpConstraint const   *)constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsSimpleMotor(constraint)", "../src/cpSimpleMotor.c", 120,
              1, 1, "Constraint is not a SimpleMotor.");
    abort();
  }
  cpConstraintActivateBodies(constraint);
  ((cpSimpleMotor *)constraint)->rate = rate;
  return;
}
}
#pragma merger("0","/tmp/cil-ed_7ZA2c.i","-std=gnu99,-ffast-math,-fPIC")
static struct cpVect  const  cpvzero___7  =    {(cpFloat )0.0f, (cpFloat )0.0f};
cpBool cpConstraintIsSlideJoint(cpConstraint const   *constraint ) ;
cpSlideJoint *cpSlideJointAlloc(void) ;
cpSlideJoint *cpSlideJointInit(cpSlideJoint *joint , cpBody *a , cpBody *b , cpVect anchorA ,
                               cpVect anchorB , cpFloat min , cpFloat max ) ;
cpConstraint *cpSlideJointNew(cpBody *a , cpBody *b , cpVect anchorA , cpVect anchorB ,
                              cpFloat min , cpFloat max ) ;
cpVect cpSlideJointGetAnchorA(cpConstraint const   *constraint ) ;
void cpSlideJointSetAnchorA(cpConstraint *constraint , cpVect anchorA ) ;
cpVect cpSlideJointGetAnchorB(cpConstraint const   *constraint ) ;
void cpSlideJointSetAnchorB(cpConstraint *constraint , cpVect anchorB ) ;
cpFloat cpSlideJointGetMin(cpConstraint const   *constraint ) ;
void cpSlideJointSetMin(cpConstraint *constraint , cpFloat min ) ;
cpFloat cpSlideJointGetMax(cpConstraint const   *constraint ) ;
void cpSlideJointSetMax(cpConstraint *constraint , cpFloat max ) ;
static void preStep___8(cpSlideJoint *joint , cpFloat dt ) 
{ 
  cpBody *a ;
  cpBody *b ;
  cpVect tmp ;
  cpVect tmp___0 ;
  cpVect delta ;
  cpVect tmp___1 ;
  cpVect tmp___2 ;
  cpVect tmp___3 ;
  cpFloat dist ;
  cpFloat tmp___4 ;
  cpFloat pdist ;
  cpVect tmp___5 ;
  cpFloat tmp___6 ;
  cpFloat maxBias ;
  cpFloat tmp___7 ;

  {
  a = joint->constraint.a;
  b = joint->constraint.b;
  tmp = cpvsub((cpVect const   )joint->anchorA, (cpVect const   )a->cog);
  joint->r1 = cpTransformVect(a->transform, tmp);
  tmp___0 = cpvsub((cpVect const   )joint->anchorB, (cpVect const   )b->cog);
  joint->r2 = cpTransformVect(b->transform, tmp___0);
  tmp___1 = cpvadd((cpVect const   )a->p, (cpVect const   )joint->r1);
  tmp___2 = cpvadd((cpVect const   )b->p, (cpVect const   )joint->r2);
  tmp___3 = cpvsub((cpVect const   )tmp___2, (cpVect const   )tmp___1);
  delta = tmp___3;
  tmp___4 = cpvlength((cpVect const   )delta);
  dist = tmp___4;
  pdist = (cpFloat )0.0f;
  if (dist > joint->max) {
    pdist = dist - joint->max;
    joint->n = cpvnormalize((cpVect const   )delta);
  } else
  if (dist < joint->min) {
    pdist = joint->min - dist;
    tmp___5 = cpvnormalize((cpVect const   )delta);
    joint->n = cpvneg((cpVect const   )tmp___5);
  } else {
    joint->n = (cpVect )cpvzero___7;
    joint->jnAcc = (cpFloat )0.0f;
  }
  tmp___6 = k_scalar(a, b, joint->r1, joint->r2, joint->n);
  joint->nMass = (cpFloat )1.0f / tmp___6;
  maxBias = joint->constraint.maxBias;
  tmp___7 = bias_coef(joint->constraint.errorBias, dt);
  joint->bias = cpfclamp((- tmp___7 * pdist) / dt, - maxBias, maxBias);
  return;
}
}
static void applyCachedImpulse___8(cpSlideJoint *joint , cpFloat dt_coef ) 
{ 
  cpBody *a ;
  cpBody *b ;
  cpVect j ;
  cpVect tmp ;

  {
  a = joint->constraint.a;
  b = joint->constraint.b;
  tmp = cpvmult((cpVect const   )joint->n, (cpFloat const   )(joint->jnAcc * dt_coef));
  j = tmp;
  apply_impulses(a, b, joint->r1, joint->r2, j);
  return;
}
}
static void applyImpulse___8(cpSlideJoint *joint , cpFloat dt ) 
{ 
  cpBool tmp ;
  cpBody *a ;
  cpBody *b ;
  cpVect n ;
  cpVect r1 ;
  cpVect r2 ;
  cpVect vr ;
  cpVect tmp___0 ;
  cpFloat vrn ;
  cpFloat tmp___1 ;
  cpFloat jn___0 ;
  cpFloat jnOld ;
  cpVect tmp___2 ;

  {
  tmp = cpveql((cpVect const   )joint->n, cpvzero___7);
  if (tmp) {
    return;
  }
  a = joint->constraint.a;
  b = joint->constraint.b;
  n = joint->n;
  r1 = joint->r1;
  r2 = joint->r2;
  tmp___0 = relative_velocity(a, b, r1, r2);
  vr = tmp___0;
  tmp___1 = cpvdot((cpVect const   )vr, (cpVect const   )n);
  vrn = tmp___1;
  jn___0 = (joint->bias - vrn) * joint->nMass;
  jnOld = joint->jnAcc;
  joint->jnAcc = cpfclamp(jnOld + jn___0, - joint->constraint.maxForce * dt, (cpFloat )0.0f);
  jn___0 = joint->jnAcc - jnOld;
  tmp___2 = cpvmult((cpVect const   )n, (cpFloat const   )jn___0);
  apply_impulses(a, b, joint->r1, joint->r2, tmp___2);
  return;
}
}
static cpFloat getImpulse___8(cpConstraint *joint ) 
{ 
  cpFloat tmp ;

  {
  tmp = cpfabs(((cpSlideJoint *)joint)->jnAcc);
  return (tmp);
}
}
static struct cpConstraintClass  const  klass___9  =    {(void (*)(cpConstraint *constraint , cpFloat dt ))(& preStep___8), (void (*)(cpConstraint *constraint ,
                                                                                 cpFloat dt_coef ))(& applyCachedImpulse___8),
    (void (*)(cpConstraint *constraint , cpFloat dt ))(& applyImpulse___8), & getImpulse___8};
cpSlideJoint *cpSlideJointAlloc(void) 
{ 
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(cpSlideJoint ));
  return ((cpSlideJoint *)tmp);
}
}
cpSlideJoint *cpSlideJointInit(cpSlideJoint *joint , cpBody *a , cpBody *b , cpVect anchorA ,
                               cpVect anchorB , cpFloat min , cpFloat max ) 
{ 


  {
  cpConstraintInit((cpConstraint *)joint, & klass___9, a, b);
  joint->anchorA = anchorA;
  joint->anchorB = anchorB;
  joint->min = min;
  joint->max = max;
  joint->jnAcc = (cpFloat )0.0f;
  return (joint);
}
}
cpConstraint *cpSlideJointNew(cpBody *a , cpBody *b , cpVect anchorA , cpVect anchorB ,
                              cpFloat min , cpFloat max ) 
{ 
  cpSlideJoint *tmp ;
  cpSlideJoint *tmp___0 ;

  {
  tmp = cpSlideJointAlloc();
  tmp___0 = cpSlideJointInit(tmp, a, b, anchorA, anchorB, min, max);
  return ((cpConstraint *)tmp___0);
}
}
cpBool cpConstraintIsSlideJoint(cpConstraint const   *constraint ) 
{ 


  {
  return ((cpBool )((unsigned long )constraint->klass == (unsigned long )(& klass___9)));
}
}
cpVect cpSlideJointGetAnchorA(cpConstraint const   *constraint ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsSlideJoint(constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsSlideJoint(constraint)", "../src/cpSlideJoint.c", 140,
              1, 1, "Constraint is not a slide joint.");
    abort();
  }
  return (((cpSlideJoint *)constraint)->anchorA);
}
}
void cpSlideJointSetAnchorA(cpConstraint *constraint , cpVect anchorA ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsSlideJoint((cpConstraint const   *)constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsSlideJoint(constraint)", "../src/cpSlideJoint.c", 147,
              1, 1, "Constraint is not a slide joint.");
    abort();
  }
  cpConstraintActivateBodies(constraint);
  ((cpSlideJoint *)constraint)->anchorA = anchorA;
  return;
}
}
cpVect cpSlideJointGetAnchorB(cpConstraint const   *constraint ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsSlideJoint(constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsSlideJoint(constraint)", "../src/cpSlideJoint.c", 155,
              1, 1, "Constraint is not a slide joint.");
    abort();
  }
  return (((cpSlideJoint *)constraint)->anchorB);
}
}
void cpSlideJointSetAnchorB(cpConstraint *constraint , cpVect anchorB ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsSlideJoint((cpConstraint const   *)constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsSlideJoint(constraint)", "../src/cpSlideJoint.c", 162,
              1, 1, "Constraint is not a slide joint.");
    abort();
  }
  cpConstraintActivateBodies(constraint);
  ((cpSlideJoint *)constraint)->anchorB = anchorB;
  return;
}
}
cpFloat cpSlideJointGetMin(cpConstraint const   *constraint ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsSlideJoint(constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsSlideJoint(constraint)", "../src/cpSlideJoint.c", 170,
              1, 1, "Constraint is not a slide joint.");
    abort();
  }
  return (((cpSlideJoint *)constraint)->min);
}
}
void cpSlideJointSetMin(cpConstraint *constraint , cpFloat min ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsSlideJoint((cpConstraint const   *)constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsSlideJoint(constraint)", "../src/cpSlideJoint.c", 177,
              1, 1, "Constraint is not a slide joint.");
    abort();
  }
  cpConstraintActivateBodies(constraint);
  ((cpSlideJoint *)constraint)->min = min;
  return;
}
}
cpFloat cpSlideJointGetMax(cpConstraint const   *constraint ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsSlideJoint(constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsSlideJoint(constraint)", "../src/cpSlideJoint.c", 185,
              1, 1, "Constraint is not a slide joint.");
    abort();
  }
  return (((cpSlideJoint *)constraint)->max);
}
}
void cpSlideJointSetMax(cpConstraint *constraint , cpFloat max ) 
{ 
  cpBool tmp ;

  {
  tmp = cpConstraintIsSlideJoint((cpConstraint const   *)constraint);
  if (! tmp) {
    cpMessage("cpConstraintIsSlideJoint(constraint)", "../src/cpSlideJoint.c", 192,
              1, 1, "Constraint is not a slide joint.");
    abort();
  }
  cpConstraintActivateBodies(constraint);
  ((cpSlideJoint *)constraint)->max = max;
  return;
}
}
#pragma merger("0","/tmp/cil-cT57BL4V.i","-std=gnu99,-ffast-math,-fPIC")
static struct cpVect  const  cpvzero___8  =    {(cpFloat )0.0f, (cpFloat )0.0f};
cpSpatialIndex *cpSpaceHashNew(cpFloat celldim , int cells , cpBB (*bbfunc)(void *obj ) ,
                               cpSpatialIndex *staticIndex ) ;
void cpSpatialIndexFree(cpSpatialIndex *index ) ;
__inline static void cpSpatialIndexReindex(cpSpatialIndex *index___0 ) 
{ 


  {
  (*((index___0->klass)->reindex))(index___0);
  return;
}
}
__inline static void cpSpatialIndexReindexObject(cpSpatialIndex *index___0 , void *obj ,
                                                 cpHashValue hashid ) 
{ 


  {
  (*((index___0->klass)->reindexObject))(index___0, obj, hashid);
  return;
}
}
void cpBodyActivateStatic(cpBody *body , cpShape *filter ) ;
cpSpace *cpSpaceAlloc(void) ;
cpSpace *cpSpaceNew(void) ;
void cpSpaceDestroy(cpSpace *space ) ;
int cpSpaceGetIterations(cpSpace const   *space ) ;
void cpSpaceSetIterations(cpSpace *space , int iterations ) ;
cpVect cpSpaceGetGravity(cpSpace const   *space ) ;
void cpSpaceSetGravity(cpSpace *space , cpVect gravity ) ;
cpFloat cpSpaceGetDamping(cpSpace const   *space ) ;
void cpSpaceSetDamping(cpSpace *space , cpFloat damping ) ;
cpFloat cpSpaceGetIdleSpeedThreshold(cpSpace const   *space ) ;
void cpSpaceSetIdleSpeedThreshold(cpSpace *space , cpFloat idleSpeedThreshold ) ;
cpFloat cpSpaceGetSleepTimeThreshold(cpSpace const   *space ) ;
void cpSpaceSetSleepTimeThreshold(cpSpace *space , cpFloat sleepTimeThreshold ) ;
cpFloat cpSpaceGetCollisionSlop(cpSpace const   *space ) ;
void cpSpaceSetCollisionSlop(cpSpace *space , cpFloat collisionSlop ) ;
cpFloat cpSpaceGetCollisionBias(cpSpace const   *space ) ;
void cpSpaceSetCollisionBias(cpSpace *space , cpFloat collisionBias ) ;
cpTimestamp cpSpaceGetCollisionPersistence(cpSpace const   *space ) ;
void cpSpaceSetCollisionPersistence(cpSpace *space , cpTimestamp collisionPersistence ) ;
cpDataPointer cpSpaceGetUserData(cpSpace const   *space ) ;
void cpSpaceSetUserData(cpSpace *space , cpDataPointer userData ) ;
cpBody *cpSpaceGetStaticBody(cpSpace const   *space ) ;
cpFloat cpSpaceGetCurrentTimeStep(cpSpace const   *space ) ;
cpBool cpSpaceIsLocked(cpSpace *space ) ;
cpCollisionHandler *cpSpaceAddDefaultCollisionHandler(cpSpace *space ) ;
cpCollisionHandler *cpSpaceAddCollisionHandler(cpSpace *space , cpCollisionType a ,
                                               cpCollisionType b ) ;
cpCollisionHandler *cpSpaceAddWildcardHandler(cpSpace *space , cpCollisionType type ) ;
cpShape *cpSpaceAddShape(cpSpace *space , cpShape *shape ) ;
cpBody *cpSpaceAddBody(cpSpace *space , cpBody *body ) ;
cpConstraint *cpSpaceAddConstraint(cpSpace *space , cpConstraint *constraint ) ;
void cpSpaceRemoveShape(cpSpace *space , cpShape *shape ) ;
void cpSpaceRemoveBody(cpSpace *space , cpBody *body ) ;
void cpSpaceRemoveConstraint(cpSpace *space , cpConstraint *constraint ) ;
cpBool cpSpaceContainsShape(cpSpace *space , cpShape *shape ) ;
cpBool cpSpaceContainsBody(cpSpace *space , cpBody *body ) ;
cpBool cpSpaceContainsConstraint(cpSpace *space , cpConstraint *constraint ) ;
void cpSpaceEachBody(cpSpace *space , void (*func)(cpBody *body , void *data ) , void *data ) ;
void cpSpaceEachShape(cpSpace *space , void (*func)(cpShape *shape , void *data ) ,
                      void *data ) ;
void cpSpaceEachConstraint(cpSpace *space , void (*func)(cpConstraint *constraint ,
                                                         void *data ) , void *data ) ;
void cpSpaceReindexStatic(cpSpace *space ) ;
void cpSpaceReindexShape(cpSpace *space , cpShape *shape ) ;
void cpSpaceReindexShapesForBody(cpSpace *space , cpBody *body ) ;
void cpSpaceUseSpatialHash(cpSpace *space , cpFloat dim , int count ) ;
void cpSpaceSetStaticBody(cpSpace *space , cpBody *body ) ;
void cpSpaceFilterArbiters(cpSpace *space , cpBody *body , cpShape *filter ) ;
static cpBool arbiterSetEql(cpShape **shapes , cpArbiter *arb ) 
{ 
  cpShape *a ;
  cpShape *b ;
  int tmp ;

  {
  a = *(shapes + 0);
  b = *(shapes + 1);
  if ((unsigned long )a == (unsigned long )arb->a) {
    if ((unsigned long )b == (unsigned long )arb->b) {
      tmp = 1;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if ((unsigned long )b == (unsigned long )arb->a) {
    if ((unsigned long )a == (unsigned long )arb->b) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((cpBool )tmp);
}
}
static cpBool handlerSetEql(cpCollisionHandler *check , cpCollisionHandler *pair ) 
{ 
  int tmp ;

  {
  if (check->typeA == pair->typeA) {
    if (check->typeB == pair->typeB) {
      tmp = 1;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (check->typeB == pair->typeA) {
    if (check->typeA == pair->typeB) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((cpBool )tmp);
}
}
static void *handlerSetTrans(cpCollisionHandler *handler , void *unused ) 
{ 
  cpCollisionHandler *copy ;
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(cpCollisionHandler ));
  copy = (cpCollisionHandler *)tmp;
  memcpy((void * __restrict  )copy, (void const   * __restrict  )handler, sizeof(cpCollisionHandler ));
  return ((void *)copy);
}
}
static cpBool DefaultBegin(cpArbiter *arb , cpSpace *space , cpDataPointer data ) 
{ 
  cpBool retA ;
  cpBool tmp ;
  cpBool retB ;
  cpBool tmp___0 ;
  int tmp___1 ;

  {
  tmp = cpArbiterCallWildcardBeginA(arb, space);
  retA = tmp;
  tmp___0 = cpArbiterCallWildcardBeginB(arb, space);
  retB = tmp___0;
  if (retA) {
    if (retB) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  return ((cpBool )tmp___1);
}
}
static cpBool DefaultPreSolve(cpArbiter *arb , cpSpace *space , cpDataPointer data ) 
{ 
  cpBool retA ;
  cpBool tmp ;
  cpBool retB ;
  cpBool tmp___0 ;
  int tmp___1 ;

  {
  tmp = cpArbiterCallWildcardPreSolveA(arb, space);
  retA = tmp;
  tmp___0 = cpArbiterCallWildcardPreSolveB(arb, space);
  retB = tmp___0;
  if (retA) {
    if (retB) {
      tmp___1 = 1;
    } else {
      tmp___1 = 0;
    }
  } else {
    tmp___1 = 0;
  }
  return ((cpBool )tmp___1);
}
}
static void DefaultPostSolve(cpArbiter *arb , cpSpace *space , cpDataPointer data ) 
{ 


  {
  cpArbiterCallWildcardPostSolveA(arb, space);
  cpArbiterCallWildcardPostSolveB(arb, space);
  return;
}
}
static void DefaultSeparate(cpArbiter *arb , cpSpace *space , cpDataPointer data ) 
{ 


  {
  cpArbiterCallWildcardSeparateA(arb, space);
  cpArbiterCallWildcardSeparateB(arb, space);
  return;
}
}
static cpCollisionHandler cpCollisionHandlerDefault  =    {(cpCollisionType const   )(~ ((cpCollisionType )0)), (cpCollisionType const   )(~ ((cpCollisionType )0)),
    & DefaultBegin, & DefaultPreSolve, & DefaultPostSolve, & DefaultSeparate, (void *)0};
static cpBool AlwaysCollide(cpArbiter *arb ,
                            cpSpace *space , cpDataPointer data ) 
{ 


  {
  return ((cpBool )1);
}
}
static void DoNothing(cpArbiter *arb , cpSpace *space , cpDataPointer data ) 
{ 


  {
  return;
}
}
cpCollisionHandler cpCollisionHandlerDoNothing  =    {(cpCollisionType const   )(~ ((cpCollisionType )0)), (cpCollisionType const   )(~ ((cpCollisionType )0)),
    & AlwaysCollide, & AlwaysCollide, & DoNothing, & DoNothing, (void *)0};
static cpVect ShapeVelocityFunc(cpShape *shape ) 
{ 


  {
  return ((shape->body)->v);
}
}
static void FreeWrap(void *ptr , void *unused ) 
{ 


  {
  free(ptr);
  return;
}
}
cpSpace *cpSpaceAlloc(void) 
{ 
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(cpSpace ));
  return ((cpSpace *)tmp);
}
}
cpSpace *cpSpaceInit(cpSpace *space ) 
{ 
  float tmp ;
  cpBody *staticBody ;
  cpBody *tmp___0 ;

  {
  space->iterations = 10;
  space->gravity = (cpVect )cpvzero___8;
  space->damping = (cpFloat )1.0f;
  space->collisionSlop = (cpFloat )0.1f;
  space->collisionBias = pow((double )(1.0f - 0.1f), (double )60.0f);
  space->collisionPersistence = (cpTimestamp )3;
  space->locked = 0;
  space->stamp = (cpTimestamp )0;
  space->shapeIDCounter = (cpHashValue )0;
  space->staticShapes = cpBBTreeNew((cpBB (*)(void *obj ))(& cpShapeGetBB), (cpSpatialIndex *)((void *)0));
  space->dynamicShapes = cpBBTreeNew((cpBB (*)(void *obj ))(& cpShapeGetBB), space->staticShapes);
  cpBBTreeSetVelocityFunc(space->dynamicShapes, (cpVect (*)(void *obj ))(& ShapeVelocityFunc));
  space->allocatedBuffers = cpArrayNew(0);
  space->dynamicBodies = cpArrayNew(0);
  space->staticBodies = cpArrayNew(0);
  space->sleepingComponents = cpArrayNew(0);
  space->rousedBodies = cpArrayNew(0);
  tmp = __builtin_inff();
  space->sleepTimeThreshold = (cpFloat )tmp;
  space->idleSpeedThreshold = (cpFloat )0.0f;
  space->arbiters = cpArrayNew(0);
  space->pooledArbiters = cpArrayNew(0);
  space->contactBuffersHead = (cpContactBufferHeader *)((void *)0);
  space->cachedArbiters = cpHashSetNew(0, (cpBool (*)(void const   *ptr , void const   *elt ))(& arbiterSetEql));
  space->constraints = cpArrayNew(0);
  space->usesWildcards = (cpBool )0;
  memcpy((void * __restrict  )(& space->defaultHandler), (void const   * __restrict  )(& cpCollisionHandlerDoNothing),
         sizeof(cpCollisionHandler ));
  space->collisionHandlers = cpHashSetNew(0, (cpBool (*)(void const   *ptr , void const   *elt ))(& handlerSetEql));
  space->postStepCallbacks = cpArrayNew(0);
  space->skipPostStep = (cpBool )0;
  tmp___0 = cpBodyInit(& space->_staticBody, (cpFloat )0.0f, (cpFloat )0.0f);
  staticBody = tmp___0;
  cpBodySetType(staticBody, (cpBodyType )2);
  cpSpaceSetStaticBody(space, staticBody);
  return (space);
}
}
cpSpace *cpSpaceNew(void) 
{ 
  cpSpace *tmp ;
  cpSpace *tmp___0 ;

  {
  tmp = cpSpaceAlloc();
  tmp___0 = cpSpaceInit(tmp);
  return (tmp___0);
}
}
static void cpBodyActivateWrap(cpBody *body , void *unused ) 
{ 


  {
  cpBodyActivate(body);
  return;
}
}
void cpSpaceDestroy(cpSpace *space ) 
{ 


  {
  cpSpaceEachBody(space, & cpBodyActivateWrap, (void *)0);
  cpSpatialIndexFree(space->staticShapes);
  cpSpatialIndexFree(space->dynamicShapes);
  cpArrayFree(space->dynamicBodies);
  cpArrayFree(space->staticBodies);
  cpArrayFree(space->sleepingComponents);
  cpArrayFree(space->rousedBodies);
  cpArrayFree(space->constraints);
  cpHashSetFree(space->cachedArbiters);
  cpArrayFree(space->arbiters);
  cpArrayFree(space->pooledArbiters);
  if (space->allocatedBuffers) {
    cpArrayFreeEach(space->allocatedBuffers, & free);
    cpArrayFree(space->allocatedBuffers);
  }
  if (space->postStepCallbacks) {
    cpArrayFreeEach(space->postStepCallbacks, & free);
    cpArrayFree(space->postStepCallbacks);
  }
  if (space->collisionHandlers) {
    cpHashSetEach(space->collisionHandlers, & FreeWrap, (void *)0);
  }
  cpHashSetFree(space->collisionHandlers);
  return;
}
}
void cpSpaceFree(cpSpace *space ) 
{ 


  {
  if (space) {
    cpSpaceDestroy(space);
    free((void *)space);
  }
  return;
}
}
int cpSpaceGetIterations(cpSpace const   *space ) 
{ 


  {
  return ((int )space->iterations);
}
}
void cpSpaceSetIterations(cpSpace *space , int iterations ) 
{ 


  {
  if (! (iterations > 0)) {
    cpMessage("iterations > 0", "../src/cpSpace.c", 243, 1, 1, "Iterations must be positive and non-zero.");
    abort();
  }
  space->iterations = iterations;
  return;
}
}
cpVect cpSpaceGetGravity(cpSpace const   *space ) 
{ 


  {
  return ((cpVect )space->gravity);
}
}
void cpSpaceSetGravity(cpSpace *space , cpVect gravity ) 
{ 
  cpArray *components ;
  int i ;

  {
  space->gravity = gravity;
  components = space->sleepingComponents;
  i = 0;
  while (i < components->num) {
    cpBodyActivate((cpBody *)*(components->arr + i));
    i ++;
  }
  return;
}
}
cpFloat cpSpaceGetDamping(cpSpace const   *space ) 
{ 


  {
  return ((cpFloat )space->damping);
}
}
void cpSpaceSetDamping(cpSpace *space , cpFloat damping ) 
{ 


  {
  if (! (damping >= 0.0)) {
    cpMessage("damping >= 0.0", "../src/cpSpace.c", 274, 1, 1, "Damping must be positive.");
    abort();
  }
  space->damping = damping;
  return;
}
}
cpFloat cpSpaceGetIdleSpeedThreshold(cpSpace const   *space ) 
{ 


  {
  return ((cpFloat )space->idleSpeedThreshold);
}
}
void cpSpaceSetIdleSpeedThreshold(cpSpace *space , cpFloat idleSpeedThreshold ) 
{ 


  {
  space->idleSpeedThreshold = idleSpeedThreshold;
  return;
}
}
cpFloat cpSpaceGetSleepTimeThreshold(cpSpace const   *space ) 
{ 


  {
  return ((cpFloat )space->sleepTimeThreshold);
}
}
void cpSpaceSetSleepTimeThreshold(cpSpace *space , cpFloat sleepTimeThreshold ) 
{ 


  {
  space->sleepTimeThreshold = sleepTimeThreshold;
  return;
}
}
cpFloat cpSpaceGetCollisionSlop(cpSpace const   *space ) 
{ 


  {
  return ((cpFloat )space->collisionSlop);
}
}
void cpSpaceSetCollisionSlop(cpSpace *space , cpFloat collisionSlop ) 
{ 


  {
  space->collisionSlop = collisionSlop;
  return;
}
}
cpFloat cpSpaceGetCollisionBias(cpSpace const   *space ) 
{ 


  {
  return ((cpFloat )space->collisionBias);
}
}
void cpSpaceSetCollisionBias(cpSpace *space , cpFloat collisionBias ) 
{ 


  {
  space->collisionBias = collisionBias;
  return;
}
}
cpTimestamp cpSpaceGetCollisionPersistence(cpSpace const   *space ) 
{ 


  {
  return ((cpTimestamp )space->collisionPersistence);
}
}
void cpSpaceSetCollisionPersistence(cpSpace *space , cpTimestamp collisionPersistence ) 
{ 


  {
  space->collisionPersistence = collisionPersistence;
  return;
}
}
cpDataPointer cpSpaceGetUserData(cpSpace const   *space ) 
{ 


  {
  return ((cpDataPointer )space->userData);
}
}
void cpSpaceSetUserData(cpSpace *space , cpDataPointer userData ) 
{ 


  {
  space->userData = userData;
  return;
}
}
cpBody *cpSpaceGetStaticBody(cpSpace const   *space ) 
{ 


  {
  return ((cpBody *)space->staticBody);
}
}
cpFloat cpSpaceGetCurrentTimeStep(cpSpace const   *space ) 
{ 


  {
  return ((cpFloat )space->curr_dt);
}
}
void cpSpaceSetStaticBody(cpSpace *space , cpBody *body ) 
{ 


  {
  if ((unsigned long )space->staticBody != (unsigned long )((void *)0)) {
    if (! ((unsigned long )(space->staticBody)->shapeList == (unsigned long )((void *)0))) {
      cpMessage("space->staticBody->shapeList == NULL", "../src/cpSpace.c", 366, 1,
                1, "Internal Error: Changing the designated static body while the old one still had shapes attached.");
      abort();
    }
    (space->staticBody)->space = (cpSpace *)((void *)0);
  }
  space->staticBody = body;
  body->space = space;
  return;
}
}
cpBool cpSpaceIsLocked(cpSpace *space ) 
{ 


  {
  return ((cpBool )(space->locked > 0));
}
}
static void cpSpaceUseWildcardDefaultHandler(cpSpace *space ) 
{ 


  {
  if (! space->usesWildcards) {
    space->usesWildcards = (cpBool )1;
    memcpy((void * __restrict  )(& space->defaultHandler), (void const   * __restrict  )(& cpCollisionHandlerDefault),
           sizeof(cpCollisionHandler ));
  }
  return;
}
}
cpCollisionHandler *cpSpaceAddDefaultCollisionHandler(cpSpace *space ) 
{ 


  {
  cpSpaceUseWildcardDefaultHandler(space);
  return (& space->defaultHandler);
}
}
cpCollisionHandler *cpSpaceAddCollisionHandler(cpSpace *space , cpCollisionType a ,
                                               cpCollisionType b ) 
{ 
  cpHashValue hash ;
  cpCollisionHandler handler ;
  void const   *tmp ;

  {
  hash = a * 3344921057UL ^ b * 3344921057UL;
  handler.typeA = a;
  handler.typeB = b;
  handler.beginFunc = & DefaultBegin;
  handler.preSolveFunc = & DefaultPreSolve;
  handler.postSolveFunc = & DefaultPostSolve;
  handler.separateFunc = & DefaultSeparate;
  handler.userData = (void *)0;
  tmp = cpHashSetInsert(space->collisionHandlers, hash, (void const   *)(& handler),
                        (void *(*)(void const   *ptr , void *data ))(& handlerSetTrans),
                        (void *)0);
  return ((cpCollisionHandler *)tmp);
}
}
cpCollisionHandler *cpSpaceAddWildcardHandler(cpSpace *space , cpCollisionType type ) 
{ 
  cpHashValue hash ;
  cpCollisionHandler handler ;
  void const   *tmp ;

  {
  cpSpaceUseWildcardDefaultHandler(space);
  hash = type * 3344921057UL ^ 18446744070364630559;
  handler.typeA = type;
  handler.typeB = ~ ((cpCollisionType )0);
  handler.beginFunc = & AlwaysCollide;
  handler.preSolveFunc = & AlwaysCollide;
  handler.postSolveFunc = & DoNothing;
  handler.separateFunc = & DoNothing;
  handler.userData = (void *)0;
  tmp = cpHashSetInsert(space->collisionHandlers, hash, (void const   *)(& handler),
                        (void *(*)(void const   *ptr , void *data ))(& handlerSetTrans),
                        (void *)0);
  return ((cpCollisionHandler *)tmp);
}
}
cpShape *cpSpaceAddShape(cpSpace *space , cpShape *shape ) 
{ 
  cpBody *body ;
  cpBool isStatic ;
  cpBodyType tmp ;
  cpHashValue tmp___0 ;
  cpSpatialIndex *tmp___1 ;

  {
  if (! ((unsigned long )shape->space != (unsigned long )space)) {
    cpMessage("shape->space != space", "../src/cpSpace.c", 420, 1, 1, "You have already added this shape to this space. You must not add it a second time.");
    abort();
  }
  if (! (! shape->space)) {
    cpMessage("!shape->space", "../src/cpSpace.c", 421, 1, 1, "You have already added this shape to another space. You cannot add it to a second.");
    abort();
  }
  if (! shape->body) {
    cpMessage("shape->body", "../src/cpSpace.c", 422, 1, 1, "The shape\'s body is not defined.");
    abort();
  }
  if (! ((unsigned long )(shape->body)->space == (unsigned long )space)) {
    cpMessage("shape->body->space == space", "../src/cpSpace.c", 423, 1, 1, "The shape\'s body must be added to the space before the shape.");
    abort();
  }
  if (! (! space->locked)) {
    cpMessage("!space->locked", "../src/cpSpace.c", 424, 1, 1, "This operation cannot be done safely during a call to cpSpaceStep() or during a query. Put these calls into a post-step callback.");
    abort();
  }
  body = shape->body;
  tmp = cpBodyGetType(body);
  isStatic = (cpBool )((unsigned int )tmp == 2U);
  if (! isStatic) {
    cpBodyActivate(body);
  }
  cpBodyAddShape(body, shape);
  tmp___0 = space->shapeIDCounter;
  (space->shapeIDCounter) ++;
  shape->hashid = tmp___0;
  cpShapeUpdate(shape, body->transform);
  if (isStatic) {
    tmp___1 = space->staticShapes;
  } else {
    tmp___1 = space->dynamicShapes;
  }
  cpSpatialIndexInsert(tmp___1, (void *)shape, shape->hashid);
  shape->space = space;
  return (shape);
}
}
cpBody *cpSpaceAddBody(cpSpace *space , cpBody *body ) 
{ 
  cpBodyType tmp ;
  cpArray *tmp___0 ;

  {
  if (! ((unsigned long )body->space != (unsigned long )space)) {
    cpMessage("body->space != space", "../src/cpSpace.c", 443, 1, 1, "You have already added this body to this space. You must not add it a second time.");
    abort();
  }
  if (! (! body->space)) {
    cpMessage("!body->space", "../src/cpSpace.c", 444, 1, 1, "You have already added this body to another space. You cannot add it to a second.");
    abort();
  }
  if (! (! space->locked)) {
    cpMessage("!space->locked", "../src/cpSpace.c", 445, 1, 1, "This operation cannot be done safely during a call to cpSpaceStep() or during a query. Put these calls into a post-step callback.");
    abort();
  }
  tmp = cpBodyGetType(body);
  tmp___0 = cpSpaceArrayForBodyType(space, tmp);
  cpArrayPush(tmp___0, (void *)body);
  body->space = space;
  return (body);
}
}
cpConstraint *cpSpaceAddConstraint(cpSpace *space , cpConstraint *constraint ) 
{ 
  cpBody *a ;
  cpBody *b ;

  {
  if (! ((unsigned long )constraint->space != (unsigned long )space)) {
    cpMessage("constraint->space != space", "../src/cpSpace.c", 456, 1, 1, "You have already added this constraint to this space. You must not add it a second time.");
    abort();
  }
  if (! (! constraint->space)) {
    cpMessage("!constraint->space", "../src/cpSpace.c", 457, 1, 1, "You have already added this constraint to another space. You cannot add it to a second.");
    abort();
  }
  if (! (! space->locked)) {
    cpMessage("!space->locked", "../src/cpSpace.c", 458, 1, 1, "This operation cannot be done safely during a call to cpSpaceStep() or during a query. Put these calls into a post-step callback.");
    abort();
  }
  a = constraint->a;
  b = constraint->b;
  if ((unsigned long )a != (unsigned long )((void *)0)) {
    if (! ((unsigned long )b != (unsigned long )((void *)0))) {
      cpMessage("a != NULL && b != NULL", "../src/cpSpace.c", 461, 1, 1, "Constraint is attached to a NULL body.");
      abort();
    }
  } else {
    cpMessage("a != NULL && b != NULL", "../src/cpSpace.c", 461, 1, 1, "Constraint is attached to a NULL body.");
    abort();
  }
  cpBodyActivate(a);
  cpBodyActivate(b);
  cpArrayPush(space->constraints, (void *)constraint);
  constraint->next_a = a->constraintList;
  a->constraintList = constraint;
  constraint->next_b = b->constraintList;
  b->constraintList = constraint;
  constraint->space = space;
  return (constraint);
}
}
static cpBool cachedArbitersFilter(cpArbiter *arb , struct arbiterFilterContext *context ) 
{ 
  cpShape *shape ;
  cpBody *body ;
  cpCollisionHandler *handler ;

  {
  shape = context->shape;
  body = context->body;
  if ((unsigned long )body == (unsigned long )arb->body_a) {
    if ((unsigned long )shape == (unsigned long )arb->a) {
      goto _L___0;
    } else
    if ((unsigned long )shape == (unsigned long )((void *)0)) {
      goto _L___0;
    } else {
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
  if ((unsigned long )body == (unsigned long )arb->body_b) {
    if ((unsigned long )shape == (unsigned long )arb->b) {
      goto _L___0;
    } else
    if ((unsigned long )shape == (unsigned long )((void *)0)) {
      _L___0: /* CIL Label */ 
      if (shape) {
        if ((unsigned int )arb->state != 3U) {
          arb->state = (enum cpArbiterState )4;
          handler = arb->handler;
          (*(handler->separateFunc))(arb, context->space, handler->userData);
        }
      }
      cpArbiterUnthread(arb);
      cpArrayDeleteObj((context->space)->arbiters, (void *)arb);
      cpArrayPush((context->space)->pooledArbiters, (void *)arb);
      return ((cpBool )0);
    }
  }
  return ((cpBool )1);
}
}
void cpSpaceFilterArbiters(cpSpace *space , cpBody *body , cpShape *filter ) 
{ 
  struct arbiterFilterContext context ;

  {
  cpSpaceLock(space);
  context.space = space;
  context.body = body;
  context.shape = filter;
  cpHashSetFilter(space->cachedArbiters, (cpBool (*)(void *elt , void *data ))(& cachedArbitersFilter),
                  (void *)(& context));
  cpSpaceUnlock(space, (cpBool )1);
  return;
}
}
void cpSpaceRemoveShape(cpSpace *space , cpShape *shape ) 
{ 
  cpBody *body ;
  cpBool tmp ;
  cpBool isStatic ;
  cpBodyType tmp___0 ;
  cpSpatialIndex *tmp___1 ;

  {
  body = shape->body;
  tmp = cpSpaceContainsShape(space, shape);
  if (! tmp) {
    cpMessage("cpSpaceContainsShape(space, shape)", "../src/cpSpace.c", 526, 1, 1,
              "Cannot remove a shape that was not added to the space. (Removed twice maybe?)");
    abort();
  }
  if (! (! space->locked)) {
    cpMessage("!space->locked", "../src/cpSpace.c", 527, 1, 1, "This operation cannot be done safely during a call to cpSpaceStep() or during a query. Put these calls into a post-step callback.");
    abort();
  }
  tmp___0 = cpBodyGetType(body);
  isStatic = (cpBool )((unsigned int )tmp___0 == 2U);
  if (isStatic) {
    cpBodyActivateStatic(body, shape);
  } else {
    cpBodyActivate(body);
  }
  cpBodyRemoveShape(body, shape);
  cpSpaceFilterArbiters(space, body, shape);
  if (isStatic) {
    tmp___1 = space->staticShapes;
  } else {
    tmp___1 = space->dynamicShapes;
  }
  cpSpatialIndexRemove(tmp___1, (void *)shape, shape->hashid);
  shape->space = (cpSpace *)((void *)0);
  shape->hashid = (cpHashValue )0;
  return;
}
}
void cpSpaceRemoveBody(cpSpace *space , cpBody *body ) 
{ 
  cpBody *tmp ;
  cpBool tmp___0 ;
  cpBodyType tmp___1 ;
  cpArray *tmp___2 ;

  {
  tmp = cpSpaceGetStaticBody((cpSpace const   *)space);
  if (! ((unsigned long )body != (unsigned long )tmp)) {
    cpMessage("body != cpSpaceGetStaticBody(space)", "../src/cpSpace.c", 546, 1, 1,
              "Cannot remove the designated static body for the space.");
    abort();
  }
  tmp___0 = cpSpaceContainsBody(space, body);
  if (! tmp___0) {
    cpMessage("cpSpaceContainsBody(space, body)", "../src/cpSpace.c", 547, 1, 1, "Cannot remove a body that was not added to the space. (Removed twice maybe?)");
    abort();
  }
  if (! (! space->locked)) {
    cpMessage("!space->locked", "../src/cpSpace.c", 550, 1, 1, "This operation cannot be done safely during a call to cpSpaceStep() or during a query. Put these calls into a post-step callback.");
    abort();
  }
  cpBodyActivate(body);
  tmp___1 = cpBodyGetType(body);
  tmp___2 = cpSpaceArrayForBodyType(space, tmp___1);
  cpArrayDeleteObj(tmp___2, (void *)body);
  body->space = (cpSpace *)((void *)0);
  return;
}
}
void cpSpaceRemoveConstraint(cpSpace *space , cpConstraint *constraint ) 
{ 
  cpBool tmp ;

  {
  tmp = cpSpaceContainsConstraint(space, constraint);
  if (! tmp) {
    cpMessage("cpSpaceContainsConstraint(space, constraint)", "../src/cpSpace.c",
              561, 1, 1, "Cannot remove a constraint that was not added to the space. (Removed twice maybe?)");
    abort();
  }
  if (! (! space->locked)) {
    cpMessage("!space->locked", "../src/cpSpace.c", 562, 1, 1, "This operation cannot be done safely during a call to cpSpaceStep() or during a query. Put these calls into a post-step callback.");
    abort();
  }
  cpBodyActivate(constraint->a);
  cpBodyActivate(constraint->b);
  cpArrayDeleteObj(space->constraints, (void *)constraint);
  cpBodyRemoveConstraint(constraint->a, constraint);
  cpBodyRemoveConstraint(constraint->b, constraint);
  constraint->space = (cpSpace *)((void *)0);
  return;
}
}
cpBool cpSpaceContainsShape(cpSpace *space , cpShape *shape ) 
{ 


  {
  return ((cpBool )((unsigned long )shape->space == (unsigned long )space));
}
}
cpBool cpSpaceContainsBody(cpSpace *space , cpBody *body ) 
{ 


  {
  return ((cpBool )((unsigned long )body->space == (unsigned long )space));
}
}
cpBool cpSpaceContainsConstraint(cpSpace *space , cpConstraint *constraint ) 
{ 


  {
  return ((cpBool )((unsigned long )constraint->space == (unsigned long )space));
}
}
void cpSpaceEachBody(cpSpace *space , void (*func)(cpBody *body , void *data ) , void *data ) 
{ 
  cpArray *bodies ;
  int i ;
  cpArray *otherBodies ;
  int i___0 ;
  cpArray *components ;
  int i___1 ;
  cpBody *root ;
  cpBody *body ;
  cpBody *next ;

  {
  cpSpaceLock(space);
  bodies = space->dynamicBodies;
  i = 0;
  while (i < bodies->num) {
    (*func)((cpBody *)*(bodies->arr + i), data);
    i ++;
  }
  otherBodies = space->staticBodies;
  i___0 = 0;
  while (i___0 < otherBodies->num) {
    (*func)((cpBody *)*(otherBodies->arr + i___0), data);
    i___0 ++;
  }
  components = space->sleepingComponents;
  i___1 = 0;
  while (i___1 < components->num) {
    root = (cpBody *)*(components->arr + i___1);
    body = root;
    while (body) {
      next = body->sleeping.next;
      (*func)(body, data);
      body = next;
    }
    i___1 ++;
  }
  cpSpaceUnlock(space, (cpBool )1);
  return;
}
}
static void spaceEachShapeIterator(cpShape *shape , spaceShapeContext *context ) 
{ 


  {
  (*(context->func))(shape, context->data);
  return;
}
}
void cpSpaceEachShape(cpSpace *space , void (*func)(cpShape *shape , void *data ) ,
                      void *data ) 
{ 
  spaceShapeContext context ;

  {
  cpSpaceLock(space);
  context.func = func;
  context.data = data;
  cpSpatialIndexEach(space->dynamicShapes, (void (*)(void *obj , void *data ))(& spaceEachShapeIterator),
                     (void *)(& context));
  cpSpatialIndexEach(space->staticShapes, (void (*)(void *obj , void *data ))(& spaceEachShapeIterator),
                     (void *)(& context));
  cpSpaceUnlock(space, (cpBool )1);
  return;
}
}
void cpSpaceEachConstraint(cpSpace *space , void (*func)(cpConstraint *constraint ,
                                                         void *data ) , void *data ) 
{ 
  cpArray *constraints ;
  int i ;

  {
  cpSpaceLock(space);
  constraints = space->constraints;
  i = 0;
  while (i < constraints->num) {
    (*func)((cpConstraint *)*(constraints->arr + i), data);
    i ++;
  }
  cpSpaceUnlock(space, (cpBool )1);
  return;
}
}
void cpSpaceReindexStatic(cpSpace *space ) 
{ 


  {
  if (! (! space->locked)) {
    cpMessage("!space->locked", "../src/cpSpace.c", 656, 1, 1, "You cannot manually reindex objects while the space is locked. Wait until the current query or step is complete.");
    abort();
  }
  cpSpatialIndexEach(space->staticShapes, (void (*)(void *obj , void *data ))(& cpShapeUpdateFunc),
                     (void *)0);
  cpSpatialIndexReindex(space->staticShapes);
  return;
}
}
void cpSpaceReindexShape(cpSpace *space , cpShape *shape ) 
{ 


  {
  if (! (! space->locked)) {
    cpMessage("!space->locked", "../src/cpSpace.c", 665, 1, 1, "You cannot manually reindex objects while the space is locked. Wait until the current query or step is complete.");
    abort();
  }
  cpShapeCacheBB(shape);
  cpSpatialIndexReindexObject(space->dynamicShapes, (void *)shape, shape->hashid);
  cpSpatialIndexReindexObject(space->staticShapes, (void *)shape, shape->hashid);
  return;
}
}
void cpSpaceReindexShapesForBody(cpSpace *space , cpBody *body ) 
{ 
  cpShape *shape ;

  {
  shape = body->shapeList;
  while (shape) {
    cpSpaceReindexShape(space, shape);
    shape = shape->next;
  }
  return;
}
}
static void copyShapes(cpShape *shape , cpSpatialIndex *index___0 ) 
{ 


  {
  cpSpatialIndexInsert(index___0, (void *)shape, shape->hashid);
  return;
}
}
void cpSpaceUseSpatialHash(cpSpace *space , cpFloat dim , int count ) 
{ 
  cpSpatialIndex *staticShapes ;
  cpSpatialIndex *tmp ;
  cpSpatialIndex *dynamicShapes ;
  cpSpatialIndex *tmp___0 ;

  {
  tmp = cpSpaceHashNew(dim, count, (cpBB (*)(void *obj ))(& cpShapeGetBB), (cpSpatialIndex *)((void *)0));
  staticShapes = tmp;
  tmp___0 = cpSpaceHashNew(dim, count, (cpBB (*)(void *obj ))(& cpShapeGetBB), staticShapes);
  dynamicShapes = tmp___0;
  cpSpatialIndexEach(space->staticShapes, (void (*)(void *obj , void *data ))(& copyShapes),
                     (void *)staticShapes);
  cpSpatialIndexEach(space->dynamicShapes, (void (*)(void *obj , void *data ))(& copyShapes),
                     (void *)dynamicShapes);
  cpSpatialIndexFree(space->staticShapes);
  cpSpatialIndexFree(space->dynamicShapes);
  space->staticShapes = staticShapes;
  space->dynamicShapes = dynamicShapes;
  return;
}
}
#pragma merger("0","/tmp/cil-koSmT08t.i","-std=gnu99,-ffast-math,-fPIC")
void cpBodySleep(cpBody *body ) ;
void cpBodySleepWithGroup(cpBody *body , cpBody *group ) ;
struct cpContact *cpContactBufferGetArray(cpSpace *space ) ;
void cpSpacePushContacts(cpSpace *space , int count ) ;
void cpSpaceActivateBody(cpSpace *space , cpBody *body ) ;
__inline static void cpSpaceUncacheArbiter(cpSpace *space , cpArbiter *arb ) 
{ 
  cpShape const   *a ;
  cpShape const   *b ;
  cpShape const   *shape_pair[2] ;
  cpHashValue arbHashID ;

  {
  a = arb->a;
  b = arb->b;
  shape_pair[0] = a;
  shape_pair[1] = b;
  arbHashID = (cpHashValue )a * 3344921057UL ^ (cpHashValue )b * 3344921057UL;
  cpHashSetRemove(space->cachedArbiters, arbHashID, (void const   *)(shape_pair));
  cpArrayDeleteObj(space->arbiters, (void *)arb);
  return;
}
}
void cpSpaceActivateBody(cpSpace *space , cpBody *body ) 
{ 
  cpBodyType tmp ;
  cpBool tmp___0 ;
  cpShape *shape ;
  cpArbiter *arb ;
  cpBody *bodyA ;
  int numContacts ;
  struct cpContact *contacts ;
  cpShape const   *a ;
  cpShape const   *b ;
  cpShape const   *shape_pair[2] ;
  cpHashValue arbHashID ;
  cpBodyType tmp___1 ;
  cpConstraint *constraint ;
  cpBody *bodyA___0 ;
  cpBodyType tmp___2 ;

  {
  tmp = cpBodyGetType(body);
  if (! ((unsigned int )tmp == 0U)) {
    cpMessage("cpBodyGetType(body) == CP_BODY_TYPE_DYNAMIC", "../src/cpSpaceComponent.c",
              31, 1, 1, "Internal error: Attempting to activate a non-dynamic body.");
    abort();
  }
  if (space->locked) {
    tmp___0 = cpArrayContains(space->rousedBodies, (void *)body);
    if (! tmp___0) {
      cpArrayPush(space->rousedBodies, (void *)body);
    }
  } else {
    cpArrayPush(space->dynamicBodies, (void *)body);
    shape = body->shapeList;
    while (shape) {
      cpSpatialIndexRemove(space->staticShapes, (void *)shape, shape->hashid);
      cpSpatialIndexInsert(space->dynamicShapes, (void *)shape, shape->hashid);
      shape = shape->next;
    }
    arb = body->arbiterList;
    while (arb) {
      bodyA = arb->body_a;
      if ((unsigned long )body == (unsigned long )bodyA) {
        goto _L;
      } else {
        tmp___1 = cpBodyGetType(bodyA);
        if ((unsigned int )tmp___1 == 2U) {
          _L: /* CIL Label */ 
          numContacts = arb->count;
          contacts = arb->contacts;
          arb->contacts = cpContactBufferGetArray(space);
          memcpy((void * __restrict  )arb->contacts, (void const   * __restrict  )contacts,
                 (unsigned long )numContacts * sizeof(struct cpContact ));
          cpSpacePushContacts(space, numContacts);
          a = arb->a;
          b = arb->b;
          shape_pair[0] = a;
          shape_pair[1] = b;
          arbHashID = (cpHashValue )a * 3344921057UL ^ (cpHashValue )b * 3344921057UL;
          cpHashSetInsert(space->cachedArbiters, arbHashID, (void const   *)(shape_pair),
                          (void *(*)(void const   *ptr , void *data ))((void *)0),
                          (void *)arb);
          arb->stamp = space->stamp;
          cpArrayPush(space->arbiters, (void *)arb);
          free((void *)contacts);
        }
      }
      arb = cpArbiterNext(arb, body);
    }
    constraint = body->constraintList;
    while (constraint) {
      bodyA___0 = constraint->a;
      if ((unsigned long )body == (unsigned long )bodyA___0) {
        cpArrayPush(space->constraints, (void *)constraint);
      } else {
        tmp___2 = cpBodyGetType(bodyA___0);
        if ((unsigned int )tmp___2 == 2U) {
          cpArrayPush(space->constraints, (void *)constraint);
        }
      }
      constraint = cpConstraintNext(constraint, body);
    }
  }
  return;
}
}
static void cpSpaceDeactivateBody(cpSpace *space , cpBody *body ) 
{ 
  cpBodyType tmp ;
  cpShape *shape ;
  cpArbiter *arb ;
  cpBody *bodyA ;
  size_t bytes ;
  struct cpContact *contacts ;
  void *tmp___0 ;
  cpBodyType tmp___1 ;
  cpConstraint *constraint ;
  cpBody *bodyA___0 ;
  cpBodyType tmp___2 ;

  {
  tmp = cpBodyGetType(body);
  if (! ((unsigned int )tmp == 0U)) {
    cpMessage("cpBodyGetType(body) == CP_BODY_TYPE_DYNAMIC", "../src/cpSpaceComponent.c",
              85, 1, 1, "Internal error: Attempting to deactivate a non-dynamic body.");
    abort();
  }
  cpArrayDeleteObj(space->dynamicBodies, (void *)body);
  shape = body->shapeList;
  while (shape) {
    cpSpatialIndexRemove(space->dynamicShapes, (void *)shape, shape->hashid);
    cpSpatialIndexInsert(space->staticShapes, (void *)shape, shape->hashid);
    shape = shape->next;
  }
  arb = body->arbiterList;
  while (arb) {
    bodyA = arb->body_a;
    if ((unsigned long )body == (unsigned long )bodyA) {
      goto _L;
    } else {
      tmp___1 = cpBodyGetType(bodyA);
      if ((unsigned int )tmp___1 == 2U) {
        _L: /* CIL Label */ 
        cpSpaceUncacheArbiter(space, arb);
        bytes = (unsigned long )arb->count * sizeof(struct cpContact );
        tmp___0 = calloc((size_t )1, bytes);
        contacts = (struct cpContact *)tmp___0;
        memcpy((void * __restrict  )contacts, (void const   * __restrict  )arb->contacts,
               bytes);
        arb->contacts = contacts;
      }
    }
    arb = cpArbiterNext(arb, body);
  }
  constraint = body->constraintList;
  while (constraint) {
    bodyA___0 = constraint->a;
    if ((unsigned long )body == (unsigned long )bodyA___0) {
      cpArrayDeleteObj(space->constraints, (void *)constraint);
    } else {
      tmp___2 = cpBodyGetType(bodyA___0);
      if ((unsigned int )tmp___2 == 2U) {
        cpArrayDeleteObj(space->constraints, (void *)constraint);
      }
    }
    constraint = cpConstraintNext(constraint, body);
  }
  return;
}
}
__inline static cpBody *ComponentRoot(cpBody *body ) 
{ 
  cpBody *tmp ;

  {
  if (body) {
    tmp = body->sleeping.root;
  } else {
    tmp = (cpBody *)((void *)0);
  }
  return (tmp);
}
}
void cpBodyActivate(cpBody *body ) 
{ 
  cpBody *root ;
  cpBody *tmp ;
  cpSpace *space ;
  cpBody *body___0 ;
  cpBody *next ;
  cpBool tmp___0 ;
  cpArbiter *arb ;
  cpBody *other ;
  cpBody *tmp___1 ;
  cpBodyType tmp___2 ;
  cpBodyType tmp___3 ;

  {
  if ((unsigned long )body != (unsigned long )((void *)0)) {
    tmp___3 = cpBodyGetType(body);
    if ((unsigned int )tmp___3 == 0U) {
      body->sleeping.idleTime = (cpFloat )0.0f;
      tmp = ComponentRoot(body);
      root = tmp;
      if (root) {
        tmp___0 = cpBodyIsSleeping((cpBody const   *)root);
        if (tmp___0) {
          space = root->space;
          body___0 = root;
          while (body___0) {
            next = body___0->sleeping.next;
            body___0->sleeping.idleTime = (cpFloat )0.0f;
            body___0->sleeping.root = (cpBody *)((void *)0);
            body___0->sleeping.next = (cpBody *)((void *)0);
            cpSpaceActivateBody(space, body___0);
            body___0 = next;
          }
          cpArrayDeleteObj(space->sleepingComponents, (void *)root);
        }
      }
      arb = body->arbiterList;
      while (arb) {
        if ((unsigned long )arb->body_a == (unsigned long )body) {
          tmp___1 = arb->body_b;
        } else {
          tmp___1 = arb->body_a;
        }
        other = tmp___1;
        tmp___2 = cpBodyGetType(other);
        if ((unsigned int )tmp___2 != 2U) {
          other->sleeping.idleTime = (cpFloat )0.0f;
        }
        arb = cpArbiterNext(arb, body);
      }
    }
  }
  return;
}
}
void cpBodyActivateStatic(cpBody *body , cpShape *filter ) 
{ 
  cpBodyType tmp ;
  cpArbiter *arb ;
  cpBody *tmp___0 ;

  {
  tmp = cpBodyGetType(body);
  if (! ((unsigned int )tmp == 2U)) {
    cpMessage("cpBodyGetType(body) == CP_BODY_TYPE_STATIC", "../src/cpSpaceComponent.c",
              158, 1, 1, "cpBodyActivateStatic() called on a non-static body.");
    abort();
  }
  arb = body->arbiterList;
  while (arb) {
    if (! filter) {
      goto _L;
    } else
    if ((unsigned long )filter == (unsigned long )arb->a) {
      goto _L;
    } else
    if ((unsigned long )filter == (unsigned long )arb->b) {
      _L: /* CIL Label */ 
      if ((unsigned long )arb->body_a == (unsigned long )body) {
        tmp___0 = arb->body_b;
      } else {
        tmp___0 = arb->body_a;
      }
      cpBodyActivate(tmp___0);
    }
    arb = cpArbiterNext(arb, body);
  }
  return;
}
}
__inline static void cpBodyPushArbiter(cpBody *body , cpArbiter *arb ) 
{ 
  cpArbiter *next ;
  struct cpArbiterThread *tmp ;
  struct cpArbiterThread *tmp___0 ;

  {
  next = body->arbiterList;
  tmp = cpArbiterThreadForBody(arb, body);
  tmp->next = next;
  if (next) {
    tmp___0 = cpArbiterThreadForBody(next, body);
    tmp___0->prev = arb;
  }
  body->arbiterList = arb;
  return;
}
}
__inline static void ComponentAdd(cpBody *root , cpBody *body ) 
{ 


  {
  body->sleeping.root = root;
  if ((unsigned long )body != (unsigned long )root) {
    body->sleeping.next = root->sleeping.next;
    root->sleeping.next = body;
  }
  return;
}
}
__inline static void FloodFillComponent(cpBody *root , cpBody *body ) 
{ 
  cpBody *other_root ;
  cpBody *tmp ;
  cpArbiter *arb ;
  cpBody *tmp___0 ;
  cpConstraint *constraint ;
  cpBody *tmp___1 ;
  cpBodyType tmp___2 ;

  {
  tmp___2 = cpBodyGetType(body);
  if ((unsigned int )tmp___2 == 0U) {
    tmp = ComponentRoot(body);
    other_root = tmp;
    if ((unsigned long )other_root == (unsigned long )((void *)0)) {
      ComponentAdd(root, body);
      arb = body->arbiterList;
      while (arb) {
        if ((unsigned long )body == (unsigned long )arb->body_a) {
          tmp___0 = arb->body_b;
        } else {
          tmp___0 = arb->body_a;
        }
        FloodFillComponent(root, tmp___0);
        arb = cpArbiterNext(arb, body);
      }
      constraint = body->constraintList;
      while (constraint) {
        if ((unsigned long )body == (unsigned long )constraint->a) {
          tmp___1 = constraint->b;
        } else {
          tmp___1 = constraint->a;
        }
        FloodFillComponent(root, tmp___1);
        constraint = cpConstraintNext(constraint, body);
      }
    }
  }
  return;
}
}
__inline static cpBool ComponentActive(cpBody *root , cpFloat threshold ) 
{ 
  cpBody *body ;

  {
  body = root;
  while (body) {
    if (body->sleeping.idleTime < threshold) {
      return ((cpBool )1);
    }
    body = body->sleeping.next;
  }
  return ((cpBool )0);
}
}
void cpSpaceProcessComponents(cpSpace *space , cpFloat dt ) 
{ 
  cpBool sleep ;
  float tmp ;
  cpArray *bodies ;
  cpFloat dv ;
  cpFloat dvsq ;
  cpFloat tmp___0 ;
  cpFloat tmp___1 ;
  int i ;
  cpBody *body ;
  cpBodyType tmp___2 ;
  cpFloat keThreshold ;
  cpFloat tmp___3 ;
  cpFloat tmp___5 ;
  cpArray *arbiters ;
  int i___0 ;
  int count ;
  cpArbiter *arb ;
  cpBody *a ;
  cpBody *b ;
  cpBodyType tmp___6 ;
  cpBool tmp___7 ;
  cpBodyType tmp___8 ;
  cpBool tmp___9 ;
  cpArray *constraints ;
  int i___1 ;
  cpConstraint *constraint ;
  cpBody *a___0 ;
  cpBody *b___0 ;
  cpBodyType tmp___10 ;
  cpBodyType tmp___11 ;
  int i___2 ;
  cpBody *body___0 ;
  cpBody *other ;
  cpBool tmp___12 ;
  cpBody *tmp___13 ;

  {
  tmp = __builtin_inff();
  sleep = (cpBool )(space->sleepTimeThreshold != (cpFloat )tmp);
  bodies = space->dynamicBodies;
  if (sleep) {
    dv = space->idleSpeedThreshold;
    if (dv) {
      tmp___1 = dv * dv;
    } else {
      tmp___0 = cpvlengthsq((cpVect const   )space->gravity);
      tmp___1 = (tmp___0 * dt) * dt;
    }
    dvsq = tmp___1;
    i = 0;
    while (i < bodies->num) {
      body = (cpBody *)*(bodies->arr + i);
      tmp___2 = cpBodyGetType(body);
      if ((unsigned int )tmp___2 != 0U) {
        goto __Cont;
      }
      if (dvsq) {
        tmp___3 = body->m * dvsq;
      } else {
        tmp___3 = (cpFloat )0.0f;
      }
      keThreshold = tmp___3;
      tmp___5 = cpBodyKineticEnergy((cpBody const   *)body);
      if (tmp___5 > keThreshold) {
        body->sleeping.idleTime = (cpFloat )0.0f;
      } else {
        body->sleeping.idleTime += dt;
      }
      __Cont: /* CIL Label */ 
      i ++;
    }
  }
  arbiters = space->arbiters;
  i___0 = 0;
  count = arbiters->num;
  while (i___0 < count) {
    arb = (cpArbiter *)*(arbiters->arr + i___0);
    a = arb->body_a;
    b = arb->body_b;
    if (sleep) {
      tmp___6 = cpBodyGetType(b);
      if ((unsigned int )tmp___6 == 1U) {
        cpBodyActivate(a);
      } else {
        tmp___7 = cpBodyIsSleeping((cpBody const   *)a);
        if (tmp___7) {
          cpBodyActivate(a);
        }
      }
      tmp___8 = cpBodyGetType(a);
      if ((unsigned int )tmp___8 == 1U) {
        cpBodyActivate(b);
      } else {
        tmp___9 = cpBodyIsSleeping((cpBody const   *)b);
        if (tmp___9) {
          cpBodyActivate(b);
        }
      }
    }
    cpBodyPushArbiter(a, arb);
    cpBodyPushArbiter(b, arb);
    i___0 ++;
  }
  if (sleep) {
    constraints = space->constraints;
    i___1 = 0;
    while (i___1 < constraints->num) {
      constraint = (cpConstraint *)*(constraints->arr + i___1);
      a___0 = constraint->a;
      b___0 = constraint->b;
      tmp___10 = cpBodyGetType(b___0);
      if ((unsigned int )tmp___10 == 1U) {
        cpBodyActivate(a___0);
      }
      tmp___11 = cpBodyGetType(a___0);
      if ((unsigned int )tmp___11 == 1U) {
        cpBodyActivate(b___0);
      }
      i___1 ++;
    }
    i___2 = 0;
    while (i___2 < bodies->num) {
      body___0 = (cpBody *)*(bodies->arr + i___2);
      tmp___13 = ComponentRoot(body___0);
      if ((unsigned long )tmp___13 == (unsigned long )((void *)0)) {
        FloodFillComponent(body___0, body___0);
        tmp___12 = ComponentActive(body___0, space->sleepTimeThreshold);
        if (! tmp___12) {
          cpArrayPush(space->sleepingComponents, (void *)body___0);
          other = body___0;
          while (other) {
            cpSpaceDeactivateBody(space, other);
            other = other->sleeping.next;
          }
          goto __Cont___0;
        }
      }
      i___2 ++;
      body___0->sleeping.root = (cpBody *)((void *)0);
      body___0->sleeping.next = (cpBody *)((void *)0);
      __Cont___0: /* CIL Label */ ;
    }
  }
  return;
}
}
void cpBodySleep(cpBody *body ) 
{ 


  {
  cpBodySleepWithGroup(body, (cpBody *)((void *)0));
  return;
}
}
void cpBodySleepWithGroup(cpBody *body , cpBody *group ) 
{ 
  cpBodyType tmp ;
  cpSpace *space ;
  cpBool tmp___0 ;
  cpFloat tmp___1 ;
  float tmp___2 ;
  cpBool tmp___3 ;
  cpBody *tmp___4 ;
  cpBody *tmp___5 ;
  cpBool tmp___6 ;
  cpShape *shape ;
  cpBody *root ;
  cpBody *tmp___7 ;

  {
  tmp = cpBodyGetType(body);
  if (! ((unsigned int )tmp == 0U)) {
    cpMessage("cpBodyGetType(body) == CP_BODY_TYPE_DYNAMIC", "../src/cpSpaceComponent.c",
              317, 1, 1, "Non-dynamic bodies cannot be put to sleep.");
    abort();
  }
  space = body->space;
  tmp___0 = cpSpaceIsLocked(space);
  if (tmp___0) {
    cpMessage("!cpSpaceIsLocked(space)", "../src/cpSpaceComponent.c", 320, 1, 1, "Bodies cannot be put to sleep during a query or a call to cpSpaceStep(). Put these calls into a post-step callback.");
    abort();
  }
  tmp___1 = cpSpaceGetSleepTimeThreshold((cpSpace const   *)space);
  tmp___2 = __builtin_inff();
  if (! (tmp___1 < (cpFloat )tmp___2)) {
    cpMessage("cpSpaceGetSleepTimeThreshold(space) < INFINITY", "../src/cpSpaceComponent.c",
              321, 1, 1, "Sleeping is not enabled on the space. You cannot sleep a body without setting a sleep time threshold on the space.");
    abort();
  }
  if (! ((unsigned long )group == (unsigned long )((void *)0))) {
    tmp___3 = cpBodyIsSleeping((cpBody const   *)group);
    if (! tmp___3) {
      cpMessage("group == NULL || cpBodyIsSleeping(group)", "../src/cpSpaceComponent.c",
                322, 1, 1, "Cannot use a non-sleeping body as a group identifier.");
      abort();
    }
  }
  tmp___6 = cpBodyIsSleeping((cpBody const   *)body);
  if (tmp___6) {
    tmp___4 = ComponentRoot(body);
    tmp___5 = ComponentRoot(group);
    if (! ((unsigned long )tmp___4 == (unsigned long )tmp___5)) {
      cpMessage("ComponentRoot(body) == ComponentRoot(group)", "../src/cpSpaceComponent.c",
                325, 1, 1, "The body is already sleeping and it\'s group cannot be reassigned.");
      abort();
    }
    return;
  }
  shape = body->shapeList;
  while (shape) {
    cpShapeCacheBB(shape);
    shape = shape->next;
  }
  cpSpaceDeactivateBody(space, body);
  if (group) {
    tmp___7 = ComponentRoot(group);
    root = tmp___7;
    body->sleeping.root = root;
    body->sleeping.next = root->sleeping.next;
    body->sleeping.idleTime = (cpFloat )0.0f;
    root->sleeping.next = body;
  } else {
    body->sleeping.root = body;
    body->sleeping.next = (cpBody *)((void *)0);
    body->sleeping.idleTime = (cpFloat )0.0f;
    cpArrayPush(space->sleepingComponents, (void *)body);
  }
  cpArrayDeleteObj(space->dynamicBodies, (void *)body);
  return;
}
}
#pragma merger("0","/tmp/cil-cEczqhoh.i","-std=gnu99,-ffast-math,-fPIC")
void cpSpaceDebugDraw(cpSpace *space , cpSpaceDebugDrawOptions *options ) ;
static void cpSpaceDebugDrawShape(cpShape *shape , cpSpaceDebugDrawOptions *options ) 
{ 
  cpBody *body ;
  cpDataPointer data ;
  cpSpaceDebugColor outline_color ;
  cpSpaceDebugColor fill_color ;
  cpSpaceDebugColor tmp ;
  cpCircleShape *circle ;
  cpSegmentShape *seg___0 ;
  cpPolyShape *poly ;
  int count ;
  struct cpSplittingPlane *planes ;
  cpVect *verts ;
  void *tmp___0 ;
  int i ;

  {
  body = shape->body;
  data = options->data;
  outline_color = options->shapeOutlineColor;
  tmp = (*(options->colorForShape))(shape, data);
  fill_color = tmp;
  switch ((unsigned int const   )(shape->klass)->type) {
  case 0U: 
  circle = (cpCircleShape *)shape;
  (*(options->drawCircle))(circle->tc, body->a, circle->r, outline_color, fill_color,
                           data);
  break;
  case 1U: 
  seg___0 = (cpSegmentShape *)shape;
  (*(options->drawFatSegment))(seg___0->ta, seg___0->tb, seg___0->r, outline_color,
                               fill_color, data);
  break;
  case 2U: 
  poly = (cpPolyShape *)shape;
  count = poly->count;
  planes = poly->planes;
  tmp___0 = __builtin_alloca((unsigned long )count * sizeof(cpVect ));
  verts = (cpVect *)tmp___0;
  i = 0;
  while (i < count) {
    *(verts + i) = (planes + i)->v0;
    i ++;
  }
  (*(options->drawPolygon))(count, (cpVect const   *)verts, poly->r, outline_color,
                            fill_color, data);
  break;
  default: 
  break;
  }
  return;
}
}
static cpVect const   spring_verts[15]  = 
  {      {(cpFloat )0.00f, (cpFloat )0.0f}, 
        {(cpFloat )0.20f, (cpFloat )0.0f}, 
        {(cpFloat )0.25f, (cpFloat )3.0f}, 
        {(cpFloat )0.30f, (cpFloat )(- 6.0f)}, 
        {(cpFloat )0.35f, (cpFloat )6.0f}, 
        {(cpFloat )0.40f, (cpFloat )(- 6.0f)}, 
        {(cpFloat )0.45f, (cpFloat )6.0f}, 
        {(cpFloat )0.50f, (cpFloat )(- 6.0f)}, 
        {(cpFloat )0.55f, (cpFloat )6.0f}, 
        {(cpFloat )0.60f, (cpFloat )(- 6.0f)}, 
        {(cpFloat )0.65f, (cpFloat )6.0f}, 
        {(cpFloat )0.70f, (cpFloat )(- 3.0f)}, 
        {(cpFloat )0.75f, (cpFloat )6.0f}, 
        {(cpFloat )0.80f, (cpFloat )0.0f}, 
        {(cpFloat )1.00f, (cpFloat )0.0f}};
static int const   spring_count  =    (int const   )(sizeof(spring_verts) / sizeof(cpVect ));
static void cpSpaceDebugDrawConstraint(cpConstraint *constraint , cpSpaceDebugDrawOptions *options ) 
{ 
  cpDataPointer data ;
  cpSpaceDebugColor color ;
  cpBody *body_a ;
  cpBody *body_b ;
  cpPinJoint *joint ;
  cpVect a ;
  cpVect tmp ;
  cpVect b ;
  cpVect tmp___0 ;
  cpSlideJoint *joint___0 ;
  cpVect a___0 ;
  cpVect tmp___1 ;
  cpVect b___0 ;
  cpVect tmp___2 ;
  cpPivotJoint *joint___1 ;
  cpVect a___1 ;
  cpVect tmp___3 ;
  cpVect b___1 ;
  cpVect tmp___4 ;
  cpGrooveJoint *joint___2 ;
  cpVect a___2 ;
  cpVect tmp___5 ;
  cpVect b___2 ;
  cpVect tmp___6 ;
  cpVect c ;
  cpVect tmp___7 ;
  cpDampedSpring *spring ;
  cpVect a___3 ;
  cpVect tmp___8 ;
  cpVect b___3 ;
  cpVect tmp___9 ;
  cpVect delta ;
  cpVect tmp___10 ;
  cpFloat cos___0 ;
  cpFloat sin___0 ;
  cpFloat s ;
  cpFloat tmp___11 ;
  cpVect r1 ;
  cpVect tmp___12 ;
  cpVect r2 ;
  cpVect tmp___13 ;
  cpVect *verts ;
  void *tmp___14 ;
  int i ;
  cpVect v ;
  cpFloat tmp___15 ;
  cpFloat tmp___16 ;
  int i___0 ;
  cpBool tmp___17 ;
  cpBool tmp___18 ;
  cpBool tmp___19 ;
  cpBool tmp___20 ;
  cpBool tmp___21 ;

  {
  data = options->data;
  color = options->constraintColor;
  body_a = constraint->a;
  body_b = constraint->b;
  tmp___21 = cpConstraintIsPinJoint((cpConstraint const   *)constraint);
  if (tmp___21) {
    joint = (cpPinJoint *)constraint;
    tmp = cpTransformPoint(body_a->transform, joint->anchorA);
    a = tmp;
    tmp___0 = cpTransformPoint(body_b->transform, joint->anchorB);
    b = tmp___0;
    (*(options->drawDot))((cpFloat )5, a, color, data);
    (*(options->drawDot))((cpFloat )5, b, color, data);
    (*(options->drawSegment))(a, b, color, data);
  } else {
    tmp___20 = cpConstraintIsSlideJoint((cpConstraint const   *)constraint);
    if (tmp___20) {
      joint___0 = (cpSlideJoint *)constraint;
      tmp___1 = cpTransformPoint(body_a->transform, joint___0->anchorA);
      a___0 = tmp___1;
      tmp___2 = cpTransformPoint(body_b->transform, joint___0->anchorB);
      b___0 = tmp___2;
      (*(options->drawDot))((cpFloat )5, a___0, color, data);
      (*(options->drawDot))((cpFloat )5, b___0, color, data);
      (*(options->drawSegment))(a___0, b___0, color, data);
    } else {
      tmp___19 = cpConstraintIsPivotJoint((cpConstraint const   *)constraint);
      if (tmp___19) {
        joint___1 = (cpPivotJoint *)constraint;
        tmp___3 = cpTransformPoint(body_a->transform, joint___1->anchorA);
        a___1 = tmp___3;
        tmp___4 = cpTransformPoint(body_b->transform, joint___1->anchorB);
        b___1 = tmp___4;
        (*(options->drawDot))((cpFloat )5, a___1, color, data);
        (*(options->drawDot))((cpFloat )5, b___1, color, data);
      } else {
        tmp___18 = cpConstraintIsGrooveJoint((cpConstraint const   *)constraint);
        if (tmp___18) {
          joint___2 = (cpGrooveJoint *)constraint;
          tmp___5 = cpTransformPoint(body_a->transform, joint___2->grv_a);
          a___2 = tmp___5;
          tmp___6 = cpTransformPoint(body_a->transform, joint___2->grv_b);
          b___2 = tmp___6;
          tmp___7 = cpTransformPoint(body_b->transform, joint___2->anchorB);
          c = tmp___7;
          (*(options->drawDot))((cpFloat )5, c, color, data);
          (*(options->drawSegment))(a___2, b___2, color, data);
        } else {
          tmp___17 = cpConstraintIsDampedSpring((cpConstraint const   *)constraint);
          if (tmp___17) {
            spring = (cpDampedSpring *)constraint;
            tmp___8 = cpTransformPoint(body_a->transform, spring->anchorA);
            a___3 = tmp___8;
            tmp___9 = cpTransformPoint(body_b->transform, spring->anchorB);
            b___3 = tmp___9;
            (*(options->drawDot))((cpFloat )5, a___3, color, data);
            (*(options->drawDot))((cpFloat )5, b___3, color, data);
            tmp___10 = cpvsub((cpVect const   )b___3, (cpVect const   )a___3);
            delta = tmp___10;
            cos___0 = delta.x;
            sin___0 = delta.y;
            tmp___11 = cpvlength((cpVect const   )delta);
            s = (cpFloat )1.0f / tmp___11;
            tmp___12 = cpv((cpFloat const   )cos___0, (cpFloat const   )(- sin___0 * s));
            r1 = tmp___12;
            tmp___13 = cpv((cpFloat const   )sin___0, (cpFloat const   )(cos___0 * s));
            r2 = tmp___13;
            tmp___14 = __builtin_alloca((unsigned long )spring_count * sizeof(cpVect ));
            verts = (cpVect *)tmp___14;
            i = 0;
            while (i < (int )spring_count) {
              v = spring_verts[i];
              tmp___15 = cpvdot((cpVect const   )v, (cpVect const   )r2);
              tmp___16 = cpvdot((cpVect const   )v, (cpVect const   )r1);
              *(verts + i) = cpv((cpFloat const   )(tmp___16 + a___3.x), (cpFloat const   )(tmp___15 + a___3.y));
              i ++;
            }
            i___0 = 0;
            while (i___0 < (int )(spring_count - 1)) {
              (*(options->drawSegment))(*(verts + i___0), *(verts + (i___0 + 1)),
                                        color, data);
              i___0 ++;
            }
          }
        }
      }
    }
  }
  return;
}
}
void cpSpaceDebugDraw(cpSpace *space , cpSpaceDebugDrawOptions *options ) 
{ 
  cpArray *arbiters ;
  cpSpaceDebugColor color ;
  void (*draw_seg)(cpVect a , cpVect b , cpSpaceDebugColor color , cpDataPointer data ) ;
  cpDataPointer data ;
  int i ;
  cpArbiter *arb ;
  cpVect n ;
  int j ;
  cpVect p1 ;
  cpVect tmp ;
  cpVect p2 ;
  cpVect tmp___0 ;
  cpFloat d ;
  cpVect a ;
  cpVect tmp___1 ;
  cpVect tmp___2 ;
  cpVect b ;
  cpVect tmp___3 ;
  cpVect tmp___4 ;

  {
  if ((unsigned int )options->flags & 1U) {
    cpSpaceEachShape(space, (void (*)(cpShape *shape , void *data ))(& cpSpaceDebugDrawShape),
                     (void *)options);
  }
  if ((unsigned int )options->flags & 2U) {
    cpSpaceEachConstraint(space, (void (*)(cpConstraint *constraint , void *data ))(& cpSpaceDebugDrawConstraint),
                          (void *)options);
  }
  if ((unsigned int )options->flags & 4U) {
    arbiters = space->arbiters;
    color = options->collisionPointColor;
    draw_seg = options->drawSegment;
    data = options->data;
    i = 0;
    while (i < arbiters->num) {
      arb = (cpArbiter *)*(arbiters->arr + i);
      n = arb->n;
      j = 0;
      while (j < arb->count) {
        tmp = cpvadd((cpVect const   )(arb->body_a)->p, (cpVect const   )(arb->contacts + j)->r1);
        p1 = tmp;
        tmp___0 = cpvadd((cpVect const   )(arb->body_b)->p, (cpVect const   )(arb->contacts + j)->r2);
        p2 = tmp___0;
        d = (cpFloat )2.0f;
        tmp___1 = cpvmult((cpVect const   )n, (cpFloat const   )(- d));
        tmp___2 = cpvadd((cpVect const   )p1, (cpVect const   )tmp___1);
        a = tmp___2;
        tmp___3 = cpvmult((cpVect const   )n, (cpFloat const   )d);
        tmp___4 = cpvadd((cpVect const   )p2, (cpVect const   )tmp___3);
        b = tmp___4;
        (*draw_seg)(a, b, color, data);
        j ++;
      }
      i ++;
    }
  }
  return;
}
}
#pragma merger("0","/tmp/cil-5QkhCU11.i","-std=gnu99,-ffast-math,-fPIC")
cpSpaceHash *cpSpaceHashAlloc(void) ;
cpSpatialIndex *cpSpaceHashInit(cpSpaceHash *hash , cpFloat celldim , int numcells ,
                                cpBB (*bbfunc)(void *obj ) , cpSpatialIndex *staticIndex ) ;
void cpSpaceHashResize(cpSpaceHash *hash , cpFloat celldim , int numcells ) ;
static int primes___0[30]  = 
  {      5,      13,      23,      47, 
        97,      193,      389,      769, 
        1543,      3079,      6151,      12289, 
        24593,      49157,      98317,      196613, 
        393241,      786433,      1572869,      3145739, 
        6291469,      12582917,      25165843,      50331653, 
        100663319,      201326611,      402653189,      805306457, 
        1610612741,      0};
__inline static int next_prime___0(int n ) 
{ 
  int i ;

  {
  i = 0;
  while (n > primes___0[i]) {
    i ++;
    if (! primes___0[i]) {
      cpMessage("primes[i]", "../src/prime.h", 64, 1, 1, "Tried to resize a hash table to a size greater than 1610612741 O_o");
      abort();
    }
  }
  return (primes___0[i]);
}
}
static cpHandle *cpHandleInit(cpHandle *hand , void *obj ) 
{ 


  {
  hand->obj = obj;
  hand->retain = 0;
  hand->stamp = (cpTimestamp )0;
  return (hand);
}
}
__inline static void cpHandleRetain(cpHandle *hand ) 
{ 


  {
  (hand->retain) ++;
  return;
}
}
__inline static void cpHandleRelease(cpHandle *hand , cpArray *pooledHandles ) 
{ 


  {
  (hand->retain) --;
  if (hand->retain == 0) {
    cpArrayPush(pooledHandles, (void *)hand);
  }
  return;
}
}
static int handleSetEql(void *obj , cpHandle *hand ) 
{ 


  {
  return ((unsigned long )obj == (unsigned long )hand->obj);
}
}
static void *handleSetTrans(void *obj , cpSpaceHash *hash ) 
{ 
  int count ;
  cpHandle *buffer ;
  void *tmp ;
  int i ;
  cpHandle *hand ;
  void *tmp___0 ;
  cpHandle *tmp___1 ;

  {
  if ((hash->pooledHandles)->num == 0) {
    count = (int )(32768UL / sizeof(cpHandle ));
    if (! count) {
      cpMessage("count", "../src/cpSpaceHash.c", 80, 1, 1, "Internal Error: Buffer size is too small.");
      abort();
    }
    tmp = calloc((size_t )1, (size_t )32768);
    buffer = (cpHandle *)tmp;
    cpArrayPush(hash->allocatedBuffers, (void *)buffer);
    i = 0;
    while (i < count) {
      cpArrayPush(hash->pooledHandles, (void *)(buffer + i));
      i ++;
    }
  }
  tmp___0 = cpArrayPop(hash->pooledHandles);
  tmp___1 = cpHandleInit((cpHandle *)tmp___0, obj);
  hand = tmp___1;
  cpHandleRetain(hand);
  return ((void *)hand);
}
}
__inline static void recycleBin___0(cpSpaceHash *hash , cpSpaceHashBin *bin ) 
{ 


  {
  bin->next = hash->pooledBins;
  hash->pooledBins = bin;
  return;
}
}
__inline static void clearTableCell(cpSpaceHash *hash , int idx ) 
{ 
  cpSpaceHashBin *bin ;
  cpSpaceHashBin *next ;

  {
  bin = *(hash->table + idx);
  while (bin) {
    next = bin->next;
    cpHandleRelease(bin->handle, hash->pooledHandles);
    recycleBin___0(hash, bin);
    bin = next;
  }
  *(hash->table + idx) = (cpSpaceHashBin *)((void *)0);
  return;
}
}
static void clearTable(cpSpaceHash *hash ) 
{ 
  int i ;

  {
  i = 0;
  while (i < hash->numcells) {
    clearTableCell(hash, i);
    i ++;
  }
  return;
}
}
__inline static cpSpaceHashBin *getEmptyBin(cpSpaceHash *hash ) 
{ 
  cpSpaceHashBin *bin ;
  int count ;
  cpSpaceHashBin *buffer ;
  void *tmp ;
  int i ;

  {
  bin = hash->pooledBins;
  if (bin) {
    hash->pooledBins = bin->next;
    return (bin);
  } else {
    count = (int )(32768UL / sizeof(cpSpaceHashBin ));
    if (! count) {
      cpMessage("count", "../src/cpSpaceHash.c", 142, 1, 1, "Internal Error: Buffer size is too small.");
      abort();
    }
    tmp = calloc((size_t )1, (size_t )32768);
    buffer = (cpSpaceHashBin *)tmp;
    cpArrayPush(hash->allocatedBuffers, (void *)buffer);
    i = 1;
    while (i < count) {
      recycleBin___0(hash, buffer + i);
      i ++;
    }
    return (buffer);
  }
}
}
cpSpaceHash *cpSpaceHashAlloc(void) 
{ 
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(cpSpaceHash ));
  return ((cpSpaceHash *)tmp);
}
}
static void cpSpaceHashAllocTable(cpSpaceHash *hash , int numcells ) 
{ 
  void *tmp ;

  {
  free((void *)hash->table);
  hash->numcells = numcells;
  tmp = calloc((size_t )numcells, sizeof(cpSpaceHashBin *));
  hash->table = (cpSpaceHashBin **)tmp;
  return;
}
}
__inline static cpSpatialIndexClass *Klass___0(void) ;
cpSpatialIndex *cpSpaceHashInit(cpSpaceHash *hash , cpFloat celldim , int numcells ,
                                cpBB (*bbfunc)(void *obj ) , cpSpatialIndex *staticIndex ) 
{ 
  cpSpatialIndexClass *tmp ;
  int tmp___0 ;

  {
  tmp = Klass___0();
  cpSpatialIndexInit((cpSpatialIndex *)hash, tmp, bbfunc, staticIndex);
  tmp___0 = next_prime___0(numcells);
  cpSpaceHashAllocTable(hash, tmp___0);
  hash->celldim = celldim;
  hash->handleSet = cpHashSetNew(0, (cpBool (*)(void const   *ptr , void const   *elt ))(& handleSetEql));
  hash->pooledHandles = cpArrayNew(0);
  hash->pooledBins = (cpSpaceHashBin *)((void *)0);
  hash->allocatedBuffers = cpArrayNew(0);
  hash->stamp = (cpTimestamp )1;
  return ((cpSpatialIndex *)hash);
}
}
cpSpatialIndex *cpSpaceHashNew(cpFloat celldim , int cells , cpBB (*bbfunc)(void *obj ) ,
                               cpSpatialIndex *staticIndex ) 
{ 
  cpSpaceHash *tmp ;
  cpSpatialIndex *tmp___0 ;

  {
  tmp = cpSpaceHashAlloc();
  tmp___0 = cpSpaceHashInit(tmp, celldim, cells, bbfunc, staticIndex);
  return (tmp___0);
}
}
static void cpSpaceHashDestroy(cpSpaceHash *hash ) 
{ 


  {
  if (hash->table) {
    clearTable(hash);
  }
  free((void *)hash->table);
  cpHashSetFree(hash->handleSet);
  cpArrayFreeEach(hash->allocatedBuffers, & free);
  cpArrayFree(hash->allocatedBuffers);
  cpArrayFree(hash->pooledHandles);
  return;
}
}
__inline static cpBool containsHandle(cpSpaceHashBin *bin , cpHandle *hand ) 
{ 


  {
  while (bin) {
    if ((unsigned long )bin->handle == (unsigned long )hand) {
      return ((cpBool )1);
    }
    bin = bin->next;
  }
  return ((cpBool )0);
}
}
__inline static cpHashValue hash_func(cpHashValue x , cpHashValue y , cpHashValue n ) 
{ 


  {
  return ((x * 1640531513UL ^ y * 2654435789UL) % n);
}
}
__inline static int floor_int(cpFloat f ) 
{ 
  int i ;
  int tmp ;

  {
  i = (int )f;
  if (f < (cpFloat )0.0f) {
    if (f != (cpFloat )i) {
      tmp = i - 1;
    } else {
      tmp = i;
    }
  } else {
    tmp = i;
  }
  return (tmp);
}
}
__inline static void hashHandle(cpSpaceHash *hash , cpHandle *hand , cpBB bb ) 
{ 
  cpFloat dim ;
  int l ;
  int tmp ;
  int r ;
  int tmp___0 ;
  int b ;
  int tmp___1 ;
  int t ;
  int tmp___2 ;
  int n ;
  int i ;
  int j ;
  cpHashValue idx ;
  cpHashValue tmp___3 ;
  cpSpaceHashBin *bin ;
  cpBool tmp___4 ;
  cpSpaceHashBin *newBin ;
  cpSpaceHashBin *tmp___5 ;

  {
  dim = hash->celldim;
  tmp = floor_int(bb.l / dim);
  l = tmp;
  tmp___0 = floor_int(bb.r / dim);
  r = tmp___0;
  tmp___1 = floor_int(bb.b / dim);
  b = tmp___1;
  tmp___2 = floor_int(bb.t / dim);
  t = tmp___2;
  n = hash->numcells;
  i = l;
  while (i <= r) {
    j = b;
    while (j <= t) {
      tmp___3 = hash_func((cpHashValue )i, (cpHashValue )j, (cpHashValue )n);
      idx = tmp___3;
      bin = *(hash->table + idx);
      tmp___4 = containsHandle(bin, hand);
      if (tmp___4) {
        goto __Cont;
      }
      cpHandleRetain(hand);
      tmp___5 = getEmptyBin(hash);
      newBin = tmp___5;
      newBin->handle = hand;
      newBin->next = bin;
      *(hash->table + idx) = newBin;
      __Cont: /* CIL Label */ 
      j ++;
    }
    i ++;
  }
  return;
}
}
static void cpSpaceHashInsert(cpSpaceHash *hash , void *obj , cpHashValue hashid ) 
{ 
  cpHandle *hand ;
  void const   *tmp ;
  cpBB tmp___0 ;

  {
  tmp = cpHashSetInsert(hash->handleSet, hashid, (void const   *)obj, (void *(*)(void const   *ptr ,
                                                                                 void *data ))(& handleSetTrans),
                        (void *)hash);
  hand = (cpHandle *)tmp;
  tmp___0 = (*(hash->spatialIndex.bbfunc))(obj);
  hashHandle(hash, hand, tmp___0);
  return;
}
}
static void cpSpaceHashRehashObject(cpSpaceHash *hash , void *obj , cpHashValue hashid ) 
{ 
  cpHandle *hand ;
  void const   *tmp ;

  {
  tmp = cpHashSetRemove(hash->handleSet, hashid, (void const   *)obj);
  hand = (cpHandle *)tmp;
  if (hand) {
    hand->obj = (void *)0;
    cpHandleRelease(hand, hash->pooledHandles);
    cpSpaceHashInsert(hash, obj, hashid);
  }
  return;
}
}
static void rehash_helper(cpHandle *hand , cpSpaceHash *hash ) 
{ 
  cpBB tmp ;

  {
  tmp = (*(hash->spatialIndex.bbfunc))(hand->obj);
  hashHandle(hash, hand, tmp);
  return;
}
}
static void cpSpaceHashRehash(cpSpaceHash *hash ) 
{ 


  {
  clearTable(hash);
  cpHashSetEach(hash->handleSet, (void (*)(void *elt , void *data ))(& rehash_helper),
                (void *)hash);
  return;
}
}
static void cpSpaceHashRemove(cpSpaceHash *hash , void *obj , cpHashValue hashid ) 
{ 
  cpHandle *hand ;
  void const   *tmp ;

  {
  tmp = cpHashSetRemove(hash->handleSet, hashid, (void const   *)obj);
  hand = (cpHandle *)tmp;
  if (hand) {
    hand->obj = (void *)0;
    cpHandleRelease(hand, hash->pooledHandles);
  }
  return;
}
}
static void eachHelper(cpHandle *hand , eachContext *context ) 
{ 


  {
  (*(context->func))(hand->obj, context->data);
  return;
}
}
static void cpSpaceHashEach(cpSpaceHash *hash , void (*func)(void *obj , void *data ) ,
                            void *data ) 
{ 
  eachContext context ;

  {
  context.func = func;
  context.data = data;
  cpHashSetEach(hash->handleSet, (void (*)(void *elt , void *data ))(& eachHelper),
                (void *)(& context));
  return;
}
}
static void remove_orphaned_handles(cpSpaceHash *hash , cpSpaceHashBin **bin_ptr ) 
{ 
  cpSpaceHashBin *bin ;
  cpHandle *hand ;
  cpSpaceHashBin *next ;

  {
  bin = *bin_ptr;
  while (bin) {
    hand = bin->handle;
    next = bin->next;
    if (! hand->obj) {
      *bin_ptr = bin->next;
      recycleBin___0(hash, bin);
      cpHandleRelease(hand, hash->pooledHandles);
    } else {
      bin_ptr = & bin->next;
    }
    bin = next;
  }
  return;
}
}
__inline static void query_helper(cpSpaceHash *hash , cpSpaceHashBin **bin_ptr , void *obj ,
                                  cpCollisionID (*func)(void *obj1 , void *obj2 ,
                                                        cpCollisionID id , void *data ) ,
                                  void *data ) 
{ 
  cpSpaceHashBin *bin ;
  cpHandle *hand ;
  void *other ;

  {
  restart: 
  bin = *bin_ptr;
  while (bin) {
    hand = bin->handle;
    other = hand->obj;
    if (! (hand->stamp == hash->stamp)) {
      if ((unsigned long )obj == (unsigned long )other) {
        goto __Cont;
      } else
      if (other) {
        (*func)(obj, other, (cpCollisionID )0, data);
        hand->stamp = hash->stamp;
      } else {
        remove_orphaned_handles(hash, bin_ptr);
        goto restart;
      }
    }
    __Cont: /* CIL Label */ 
    bin = bin->next;
  }
  return;
}
}
static void cpSpaceHashQuery(cpSpaceHash *hash , void *obj , cpBB bb , cpCollisionID (*func)(void *obj1 ,
                                                                                             void *obj2 ,
                                                                                             cpCollisionID id ,
                                                                                             void *data ) ,
                             void *data ) 
{ 
  cpFloat dim ;
  int l ;
  int tmp ;
  int r ;
  int tmp___0 ;
  int b ;
  int tmp___1 ;
  int t ;
  int tmp___2 ;
  int n ;
  cpSpaceHashBin **table ;
  int i ;
  int j ;
  cpHashValue tmp___3 ;

  {
  dim = hash->celldim;
  tmp = floor_int(bb.l / dim);
  l = tmp;
  tmp___0 = floor_int(bb.r / dim);
  r = tmp___0;
  tmp___1 = floor_int(bb.b / dim);
  b = tmp___1;
  tmp___2 = floor_int(bb.t / dim);
  t = tmp___2;
  n = hash->numcells;
  table = hash->table;
  i = l;
  while (i <= r) {
    j = b;
    while (j <= t) {
      tmp___3 = hash_func((cpHashValue )i, (cpHashValue )j, (cpHashValue )n);
      query_helper(hash, table + tmp___3, obj, func, data);
      j ++;
    }
    i ++;
  }
  (hash->stamp) ++;
  return;
}
}
static void queryRehash_helper(cpHandle *hand , queryRehashContext *context ) 
{ 
  cpSpaceHash *hash ;
  cpCollisionID (*func)(void *obj1 , void *obj2 , cpCollisionID id , void *data ) ;
  void *data ;
  cpFloat dim ;
  int n ;
  void *obj ;
  cpBB bb ;
  cpBB tmp ;
  int l ;
  int tmp___0 ;
  int r ;
  int tmp___1 ;
  int b ;
  int tmp___2 ;
  int t ;
  int tmp___3 ;
  cpSpaceHashBin **table ;
  int i ;
  int j ;
  cpHashValue idx ;
  cpHashValue tmp___4 ;
  cpSpaceHashBin *bin ;
  cpBool tmp___5 ;
  cpSpaceHashBin *newBin ;
  cpSpaceHashBin *tmp___6 ;

  {
  hash = context->hash;
  func = context->func;
  data = context->data;
  dim = hash->celldim;
  n = hash->numcells;
  obj = hand->obj;
  tmp = (*(hash->spatialIndex.bbfunc))(obj);
  bb = tmp;
  tmp___0 = floor_int(bb.l / dim);
  l = tmp___0;
  tmp___1 = floor_int(bb.r / dim);
  r = tmp___1;
  tmp___2 = floor_int(bb.b / dim);
  b = tmp___2;
  tmp___3 = floor_int(bb.t / dim);
  t = tmp___3;
  table = hash->table;
  i = l;
  while (i <= r) {
    j = b;
    while (j <= t) {
      tmp___4 = hash_func((cpHashValue )i, (cpHashValue )j, (cpHashValue )n);
      idx = tmp___4;
      bin = *(table + idx);
      tmp___5 = containsHandle(bin, hand);
      if (tmp___5) {
        goto __Cont;
      }
      cpHandleRetain(hand);
      query_helper(hash, & bin, obj, func, data);
      tmp___6 = getEmptyBin(hash);
      newBin = tmp___6;
      newBin->handle = hand;
      newBin->next = bin;
      *(table + idx) = newBin;
      __Cont: /* CIL Label */ 
      j ++;
    }
    i ++;
  }
  (hash->stamp) ++;
  return;
}
}
static void cpSpaceHashReindexQuery(cpSpaceHash *hash , cpCollisionID (*func)(void *obj1 ,
                                                                              void *obj2 ,
                                                                              cpCollisionID id ,
                                                                              void *data ) ,
                                    void *data ) 
{ 
  queryRehashContext context ;

  {
  clearTable(hash);
  context.hash = hash;
  context.func = func;
  context.data = data;
  cpHashSetEach(hash->handleSet, (void (*)(void *elt , void *data ))(& queryRehash_helper),
                (void *)(& context));
  cpSpatialIndexCollideStatic((cpSpatialIndex *)hash, hash->spatialIndex.staticIndex,
                              func, data);
  return;
}
}
__inline static cpFloat segmentQuery_helper(cpSpaceHash *hash , cpSpaceHashBin **bin_ptr ,
                                            void *obj , cpFloat (*func)(void *obj1 ,
                                                                        void *obj2 ,
                                                                        void *data ) ,
                                            void *data ) 
{ 
  cpFloat t ;
  cpSpaceHashBin *bin ;
  cpHandle *hand ;
  void *other ;
  cpFloat tmp ;

  {
  t = (cpFloat )1.0f;
  restart: 
  bin = *bin_ptr;
  while (bin) {
    hand = bin->handle;
    other = hand->obj;
    if (! (hand->stamp == hash->stamp)) {
      if (other) {
        tmp = (*func)(obj, other, data);
        t = cpfmin(t, tmp);
        hand->stamp = hash->stamp;
      } else {
        remove_orphaned_handles(hash, bin_ptr);
        goto restart;
      }
    }
    __Cont: /* CIL Label */ 
    bin = bin->next;
  }
  return (t);
}
}
static void cpSpaceHashSegmentQuery(cpSpaceHash *hash , void *obj , cpVect a , cpVect b ,
                                    cpFloat t_exit , cpFloat (*func)(void *obj1 ,
                                                                     void *obj2 ,
                                                                     void *data ) ,
                                    void *data ) 
{ 
  int cell_x ;
  int tmp ;
  int cell_y ;
  int tmp___0 ;
  cpFloat t ;
  int x_inc ;
  int y_inc ;
  cpFloat temp_v ;
  cpFloat temp_h ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  cpFloat dx ;
  cpFloat tmp___5 ;
  cpFloat dy ;
  cpFloat tmp___6 ;
  cpFloat dt_dx ;
  float tmp___7 ;
  cpFloat tmp___8 ;
  cpFloat dt_dy ;
  float tmp___9 ;
  cpFloat tmp___10 ;
  cpFloat next_h ;
  cpFloat tmp___11 ;
  cpFloat next_v ;
  cpFloat tmp___12 ;
  int n ;
  cpSpaceHashBin **table ;
  cpHashValue idx ;
  cpHashValue tmp___13 ;
  cpFloat tmp___14 ;

  {
  a = cpvmult((cpVect const   )a, (cpFloat const   )((cpFloat )1.0f / hash->celldim));
  b = cpvmult((cpVect const   )b, (cpFloat const   )((cpFloat )1.0f / hash->celldim));
  tmp = floor_int(a.x);
  cell_x = tmp;
  tmp___0 = floor_int(a.y);
  cell_y = tmp___0;
  t = (cpFloat )0;
  if (b.x > a.x) {
    x_inc = 1;
    tmp___1 = floor(a.x + (cpFloat )1.0f);
    temp_h = tmp___1 - a.x;
  } else {
    x_inc = -1;
    tmp___2 = floor(a.x);
    temp_h = a.x - tmp___2;
  }
  if (b.y > a.y) {
    y_inc = 1;
    tmp___3 = floor(a.y + (cpFloat )1.0f);
    temp_v = tmp___3 - a.y;
  } else {
    y_inc = -1;
    tmp___4 = floor(a.y);
    temp_v = a.y - tmp___4;
  }
  tmp___5 = cpfabs(b.x - a.x);
  dx = tmp___5;
  tmp___6 = cpfabs(b.y - a.y);
  dy = tmp___6;
  if (dx) {
    tmp___8 = (cpFloat )1.0f / dx;
  } else {
    tmp___7 = __builtin_inff();
    tmp___8 = (cpFloat )tmp___7;
  }
  dt_dx = tmp___8;
  if (dy) {
    tmp___10 = (cpFloat )1.0f / dy;
  } else {
    tmp___9 = __builtin_inff();
    tmp___10 = (cpFloat )tmp___9;
  }
  dt_dy = tmp___10;
  if (temp_h) {
    tmp___11 = temp_h * dt_dx;
  } else {
    tmp___11 = dt_dx;
  }
  next_h = tmp___11;
  if (temp_v) {
    tmp___12 = temp_v * dt_dy;
  } else {
    tmp___12 = dt_dy;
  }
  next_v = tmp___12;
  n = hash->numcells;
  table = hash->table;
  while (t < t_exit) {
    tmp___13 = hash_func((cpHashValue )cell_x, (cpHashValue )cell_y, (cpHashValue )n);
    idx = tmp___13;
    tmp___14 = segmentQuery_helper(hash, table + idx, obj, func, data);
    t_exit = cpfmin(t_exit, tmp___14);
    if (next_v < next_h) {
      cell_y += y_inc;
      t = next_v;
      next_v += dt_dy;
    } else {
      cell_x += x_inc;
      t = next_h;
      next_h += dt_dx;
    }
  }
  (hash->stamp) ++;
  return;
}
}
void cpSpaceHashResize(cpSpaceHash *hash , cpFloat celldim , int numcells ) 
{ 
  cpSpatialIndexClass *tmp ;
  int tmp___0 ;

  {
  tmp = Klass___0();
  if ((unsigned long )hash->spatialIndex.klass != (unsigned long )tmp) {
    return;
  }
  clearTable(hash);
  hash->celldim = celldim;
  tmp___0 = next_prime___0(numcells);
  cpSpaceHashAllocTable(hash, tmp___0);
  return;
}
}
static int cpSpaceHashCount(cpSpaceHash *hash ) 
{ 
  int tmp ;

  {
  tmp = cpHashSetCount(hash->handleSet);
  return (tmp);
}
}
static int cpSpaceHashContains(cpSpaceHash *hash , void *obj , cpHashValue hashid ) 
{ 
  void const   *tmp ;

  {
  tmp = cpHashSetFind(hash->handleSet, hashid, (void const   *)obj);
  return ((unsigned long )tmp != (unsigned long )((void *)0));
}
}
static cpSpatialIndexClass klass___10  = 
     {(void (*)(cpSpatialIndex *index ))(& cpSpaceHashDestroy), (int (*)(cpSpatialIndex *index ))(& cpSpaceHashCount),
    (void (*)(cpSpatialIndex *index , void (*func)(void *obj , void *data ) , void *data ))(& cpSpaceHashEach),
    (cpBool (*)(cpSpatialIndex *index , void *obj , cpHashValue hashid ))(& cpSpaceHashContains),
    (void (*)(cpSpatialIndex *index , void *obj , cpHashValue hashid ))(& cpSpaceHashInsert),
    (void (*)(cpSpatialIndex *index , void *obj , cpHashValue hashid ))(& cpSpaceHashRemove),
    (void (*)(cpSpatialIndex *index ))(& cpSpaceHashRehash), (void (*)(cpSpatialIndex *index ,
                                                                       void *obj ,
                                                                       cpHashValue hashid ))(& cpSpaceHashRehashObject),
    (void (*)(cpSpatialIndex *index , cpCollisionID (*func)(void *obj1 , void *obj2 ,
                                                            cpCollisionID id , void *data ) ,
              void *data ))(& cpSpaceHashReindexQuery), (void (*)(cpSpatialIndex *index ,
                                                                  void *obj , cpBB bb ,
                                                                  cpCollisionID (*func)(void *obj1 ,
                                                                                        void *obj2 ,
                                                                                        cpCollisionID id ,
                                                                                        void *data ) ,
                                                                  void *data ))(& cpSpaceHashQuery),
    (void (*)(cpSpatialIndex *index , void *obj , cpVect a , cpVect b , cpFloat t_exit ,
              cpFloat (*func)(void *obj1 , void *obj2 , void *data ) , void *data ))(& cpSpaceHashSegmentQuery)};
__inline static cpSpatialIndexClass *Klass___0(void) 
{ 


  {
  return (& klass___10);
}
}
#pragma merger("0","/tmp/cil-2_1g3wrq.i","-std=gnu99,-ffast-math,-fPIC")
static struct cpVect  const  cpvzero___9  =    {(cpFloat )0.0f, (cpFloat )0.0f};
__inline static void cpSpatialIndexQuery(cpSpatialIndex *index , void *obj , cpBB bb ,
                                         cpCollisionID (*func)(void *obj1 , void *obj2 ,
                                                               cpCollisionID id ,
                                                               void *data ) , void *data ) 
{ 


  {
  (*((index->klass)->query))(index, obj, bb, func, data);
  return;
}
}
__inline static void cpSpatialIndexSegmentQuery(cpSpatialIndex *index , void *obj ,
                                                cpVect a , cpVect b , cpFloat t_exit ,
                                                cpFloat (*func)(void *obj1 , void *obj2 ,
                                                                void *data ) , void *data ) 
{ 


  {
  (*((index->klass)->segmentQuery))(index, obj, a, b, t_exit, func, data);
  return;
}
}
void cpSpacePointQuery(cpSpace *space , cpVect point , cpFloat maxDistance , cpShapeFilter filter ,
                       void (*func)(cpShape *shape , cpVect point , cpFloat distance ,
                                    cpVect gradient , void *data ) , void *data ) ;
cpShape *cpSpacePointQueryNearest(cpSpace *space , cpVect point , cpFloat maxDistance ,
                                  cpShapeFilter filter , cpPointQueryInfo *out ) ;
void cpSpaceSegmentQuery(cpSpace *space , cpVect start , cpVect end , cpFloat radius ,
                         cpShapeFilter filter , void (*func)(cpShape *shape , cpVect point ,
                                                             cpVect normal , cpFloat alpha ,
                                                             void *data ) , void *data ) ;
cpShape *cpSpaceSegmentQueryFirst(cpSpace *space , cpVect start , cpVect end , cpFloat radius ,
                                  cpShapeFilter filter , cpSegmentQueryInfo *out ) ;
void cpSpaceBBQuery(cpSpace *space , cpBB bb , cpShapeFilter filter , void (*func)(cpShape *shape ,
                                                                                   void *data ) ,
                    void *data ) ;
cpBool cpSpaceShapeQuery(cpSpace *space , cpShape *shape , void (*func)(cpShape *shape ,
                                                                        cpContactPointSet *points ,
                                                                        void *data ) ,
                         void *data ) ;
__inline static cpBool cpShapeFilterReject(cpShapeFilter a , cpShapeFilter b ) 
{ 
  int tmp ;

  {
  if (a.group != 0UL) {
    if (a.group == b.group) {
      tmp = 1;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if ((a.categories & b.mask) == 0U) {
    tmp = 1;
  } else
  if ((b.categories & a.mask) == 0U) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  return ((cpBool )tmp);
}
}
static cpCollisionID NearestPointQuery(struct PointQueryContext *context , cpShape *shape ,
                                       cpCollisionID id , void *data ) 
{ 
  cpPointQueryInfo info ;
  cpBool tmp ;

  {
  tmp = cpShapeFilterReject(shape->filter, context->filter);
  if (! tmp) {
    cpShapePointQuery((cpShape const   *)shape, context->point, & info);
    if (info.shape) {
      if (info.distance < context->maxDistance) {
        (*(context->func))(shape, info.point, info.distance, info.gradient, data);
      }
    }
  }
  return (id);
}
}
void cpSpacePointQuery(cpSpace *space , cpVect point , cpFloat maxDistance , cpShapeFilter filter ,
                       void (*func)(cpShape *shape , cpVect point , cpFloat distance ,
                                    cpVect gradient , void *data ) , void *data ) 
{ 
  struct PointQueryContext context ;
  cpBB bb ;
  cpFloat tmp ;
  cpBB tmp___0 ;

  {
  context.point = point;
  context.maxDistance = maxDistance;
  context.filter = filter;
  context.func = func;
  tmp = cpfmax(maxDistance, (cpFloat )0.0f);
  tmp___0 = cpBBNewForCircle((cpVect const   )point, (cpFloat const   )tmp);
  bb = tmp___0;
  cpSpaceLock(space);
  cpSpatialIndexQuery(space->dynamicShapes, (void *)(& context), bb, (cpCollisionID (*)(void *obj1 ,
                                                                                        void *obj2 ,
                                                                                        cpCollisionID id ,
                                                                                        void *data ))(& NearestPointQuery),
                      data);
  cpSpatialIndexQuery(space->staticShapes, (void *)(& context), bb, (cpCollisionID (*)(void *obj1 ,
                                                                                       void *obj2 ,
                                                                                       cpCollisionID id ,
                                                                                       void *data ))(& NearestPointQuery),
                      data);
  cpSpaceUnlock(space, (cpBool )1);
  return;
}
}
static cpCollisionID NearestPointQueryNearest(struct PointQueryContext *context ,
                                              cpShape *shape , cpCollisionID id ,
                                              cpPointQueryInfo *out ) 
{ 
  cpPointQueryInfo info ;
  cpBool tmp ;

  {
  tmp = cpShapeFilterReject(shape->filter, context->filter);
  if (! tmp) {
    if (! shape->sensor) {
      cpShapePointQuery((cpShape const   *)shape, context->point, & info);
      if (info.distance < out->distance) {
        *out = info;
      }
    }
  }
  return (id);
}
}
cpShape *cpSpacePointQueryNearest(cpSpace *space , cpVect point , cpFloat maxDistance ,
                                  cpShapeFilter filter , cpPointQueryInfo *out ) 
{ 
  cpPointQueryInfo info ;
  struct PointQueryContext context ;
  cpBB bb ;
  cpFloat tmp ;
  cpBB tmp___0 ;

  {
  info.shape = (cpShape const   *)((void *)0);
  info.point = cpvzero___9;
  info.distance = maxDistance;
  info.gradient = cpvzero___9;
  if (out) {
    *out = info;
  } else {
    out = & info;
  }
  context.point = point;
  context.maxDistance = maxDistance;
  context.filter = filter;
  context.func = (void (*)(cpShape *shape , cpVect point , cpFloat distance , cpVect gradient ,
                           void *data ))((void *)0);
  tmp = cpfmax(maxDistance, (cpFloat )0.0f);
  tmp___0 = cpBBNewForCircle((cpVect const   )point, (cpFloat const   )tmp);
  bb = tmp___0;
  cpSpatialIndexQuery(space->dynamicShapes, (void *)(& context), bb, (cpCollisionID (*)(void *obj1 ,
                                                                                        void *obj2 ,
                                                                                        cpCollisionID id ,
                                                                                        void *data ))(& NearestPointQueryNearest),
                      (void *)out);
  cpSpatialIndexQuery(space->staticShapes, (void *)(& context), bb, (cpCollisionID (*)(void *obj1 ,
                                                                                       void *obj2 ,
                                                                                       cpCollisionID id ,
                                                                                       void *data ))(& NearestPointQueryNearest),
                      (void *)out);
  return ((cpShape *)out->shape);
}
}
static cpFloat SegmentQuery(struct SegmentQueryContext *context , cpShape *shape ,
                            void *data ) 
{ 
  cpSegmentQueryInfo info ;
  cpBool tmp ;
  cpBool tmp___0 ;

  {
  tmp = cpShapeFilterReject(shape->filter, context->filter);
  if (! tmp) {
    tmp___0 = cpShapeSegmentQuery((cpShape const   *)shape, context->start, context->end,
                                  context->radius, & info);
    if (tmp___0) {
      (*(context->func))(shape, info.point, info.normal, info.alpha, data);
    }
  }
  return ((cpFloat )1.0f);
}
}
void cpSpaceSegmentQuery(cpSpace *space , cpVect start , cpVect end , cpFloat radius ,
                         cpShapeFilter filter , void (*func)(cpShape *shape , cpVect point ,
                                                             cpVect normal , cpFloat alpha ,
                                                             void *data ) , void *data ) 
{ 
  struct SegmentQueryContext context ;

  {
  context.start = start;
  context.end = end;
  context.radius = radius;
  context.filter = filter;
  context.func = func;
  cpSpaceLock(space);
  cpSpatialIndexSegmentQuery(space->staticShapes, (void *)(& context), start, end,
                             (cpFloat )1.0f, (cpFloat (*)(void *obj1 , void *obj2 ,
                                                          void *data ))(& SegmentQuery),
                             data);
  cpSpatialIndexSegmentQuery(space->dynamicShapes, (void *)(& context), start, end,
                             (cpFloat )1.0f, (cpFloat (*)(void *obj1 , void *obj2 ,
                                                          void *data ))(& SegmentQuery),
                             data);
  cpSpaceUnlock(space, (cpBool )1);
  return;
}
}
static cpFloat SegmentQueryFirst(struct SegmentQueryContext *context , cpShape *shape ,
                                 cpSegmentQueryInfo *out ) 
{ 
  cpSegmentQueryInfo info ;
  cpBool tmp ;
  cpBool tmp___0 ;

  {
  tmp = cpShapeFilterReject(shape->filter, context->filter);
  if (! tmp) {
    if (! shape->sensor) {
      tmp___0 = cpShapeSegmentQuery((cpShape const   *)shape, context->start, context->end,
                                    context->radius, & info);
      if (tmp___0) {
        if (info.alpha < out->alpha) {
          *out = info;
        }
      }
    }
  }
  return (out->alpha);
}
}
cpShape *cpSpaceSegmentQueryFirst(cpSpace *space , cpVect start , cpVect end , cpFloat radius ,
                                  cpShapeFilter filter , cpSegmentQueryInfo *out ) 
{ 
  cpSegmentQueryInfo info ;
  struct SegmentQueryContext context ;

  {
  info.shape = (cpShape const   *)((void *)0);
  info.point = end;
  info.normal = cpvzero___9;
  info.alpha = (cpFloat )1.0f;
  if (out) {
    *out = info;
  } else {
    out = & info;
  }
  context.start = start;
  context.end = end;
  context.radius = radius;
  context.filter = filter;
  context.func = (void (*)(cpShape *shape , cpVect point , cpVect normal , cpFloat alpha ,
                           void *data ))((void *)0);
  cpSpatialIndexSegmentQuery(space->staticShapes, (void *)(& context), start, end,
                             (cpFloat )1.0f, (cpFloat (*)(void *obj1 , void *obj2 ,
                                                          void *data ))(& SegmentQueryFirst),
                             (void *)out);
  cpSpatialIndexSegmentQuery(space->dynamicShapes, (void *)(& context), start, end,
                             out->alpha, (cpFloat (*)(void *obj1 , void *obj2 , void *data ))(& SegmentQueryFirst),
                             (void *)out);
  return ((cpShape *)out->shape);
}
}
static cpCollisionID BBQuery(struct BBQueryContext *context , cpShape *shape , cpCollisionID id ,
                             void *data ) 
{ 
  cpBool tmp ;
  cpBool tmp___0 ;

  {
  tmp = cpShapeFilterReject(shape->filter, context->filter);
  if (! tmp) {
    tmp___0 = cpBBIntersects((cpBB const   )context->bb, (cpBB const   )shape->bb);
    if (tmp___0) {
      (*(context->func))(shape, data);
    }
  }
  return (id);
}
}
void cpSpaceBBQuery(cpSpace *space , cpBB bb , cpShapeFilter filter , void (*func)(cpShape *shape ,
                                                                                   void *data ) ,
                    void *data ) 
{ 
  struct BBQueryContext context ;

  {
  context.bb = bb;
  context.filter = filter;
  context.func = func;
  cpSpaceLock(space);
  cpSpatialIndexQuery(space->dynamicShapes, (void *)(& context), bb, (cpCollisionID (*)(void *obj1 ,
                                                                                        void *obj2 ,
                                                                                        cpCollisionID id ,
                                                                                        void *data ))(& BBQuery),
                      data);
  cpSpatialIndexQuery(space->staticShapes, (void *)(& context), bb, (cpCollisionID (*)(void *obj1 ,
                                                                                       void *obj2 ,
                                                                                       cpCollisionID id ,
                                                                                       void *data ))(& BBQuery),
                      data);
  cpSpaceUnlock(space, (cpBool )1);
  return;
}
}
static cpCollisionID ShapeQuery(cpShape *a , cpShape *b , cpCollisionID id , struct ShapeQueryContext *context ) 
{ 
  cpBool tmp ;
  cpContactPointSet set ;
  cpContactPointSet tmp___0 ;
  int tmp___1 ;

  {
  tmp = cpShapeFilterReject(a->filter, b->filter);
  if (tmp) {
    return (id);
  } else
  if ((unsigned long )a == (unsigned long )b) {
    return (id);
  }
  tmp___0 = cpShapesCollide((cpShape const   *)a, (cpShape const   *)b);
  set = tmp___0;
  if (set.count) {
    if (context->func) {
      (*(context->func))(b, & set, context->data);
    }
    if (a->sensor) {
      tmp___1 = 0;
    } else
    if (b->sensor) {
      tmp___1 = 0;
    } else {
      tmp___1 = 1;
    }
    context->anyCollision = (cpBool )tmp___1;
  }
  return (id);
}
}
cpBool cpSpaceShapeQuery(cpSpace *space , cpShape *shape , void (*func)(cpShape *shape ,
                                                                        cpContactPointSet *points ,
                                                                        void *data ) ,
                         void *data ) 
{ 
  cpBody *body ;
  cpBB bb ;
  cpBB tmp ;
  cpBB tmp___0 ;
  struct ShapeQueryContext context ;

  {
  body = shape->body;
  if (body) {
    tmp = cpShapeUpdate(shape, body->transform);
    tmp___0 = tmp;
  } else {
    tmp___0 = shape->bb;
  }
  bb = tmp___0;
  context.func = func;
  context.data = data;
  context.anyCollision = (cpBool )0;
  cpSpaceLock(space);
  cpSpatialIndexQuery(space->dynamicShapes, (void *)shape, bb, (cpCollisionID (*)(void *obj1 ,
                                                                                  void *obj2 ,
                                                                                  cpCollisionID id ,
                                                                                  void *data ))(& ShapeQuery),
                      (void *)(& context));
  cpSpatialIndexQuery(space->staticShapes, (void *)shape, bb, (cpCollisionID (*)(void *obj1 ,
                                                                                 void *obj2 ,
                                                                                 cpCollisionID id ,
                                                                                 void *data ))(& ShapeQuery),
                      (void *)(& context));
  cpSpaceUnlock(space, (cpBool )1);
  return (context.anyCollision);
}
}
#pragma merger("0","/tmp/cil-C0NziFyk.i","-std=gnu99,-ffast-math,-fPIC")
cpBool cpSpaceAddPostStepCallback(cpSpace *space , void (*func)(cpSpace *space , void *key ,
                                                                void *data ) , void *key ,
                                  void *data ) ;
void cpSpaceStep(cpSpace *space , cpFloat dt ) ;
cpPostStepCallback *cpSpaceGetPostStepCallback(cpSpace *space , void *key ) ;
cpPostStepCallback *cpSpaceGetPostStepCallback(cpSpace *space , void *key ) 
{ 
  cpArray *arr ;
  int i ;
  cpPostStepCallback *callback ;

  {
  arr = space->postStepCallbacks;
  i = 0;
  while (i < arr->num) {
    callback = (cpPostStepCallback *)*(arr->arr + i);
    if (callback) {
      if ((unsigned long )callback->key == (unsigned long )key) {
        return (callback);
      }
    }
    i ++;
  }
  return ((cpPostStepCallback *)((void *)0));
}
}
static void PostStepDoNothing(cpSpace *space , void *obj , void *data ) 
{ 


  {
  return;
}
}
cpBool cpSpaceAddPostStepCallback(cpSpace *space , void (*func)(cpSpace *space , void *key ,
                                                                void *data ) , void *key ,
                                  void *data ) 
{ 
  cpPostStepCallback *callback ;
  void *tmp ;
  cpPostStepCallback *tmp___0 ;

  {
  tmp___0 = cpSpaceGetPostStepCallback(space, key);
  if (tmp___0) {
    return ((cpBool )0);
  } else {
    tmp = calloc((size_t )1, sizeof(cpPostStepCallback ));
    callback = (cpPostStepCallback *)tmp;
    if (func) {
      callback->func = func;
    } else {
      callback->func = & PostStepDoNothing;
    }
    callback->key = key;
    callback->data = data;
    cpArrayPush(space->postStepCallbacks, (void *)callback);
    return ((cpBool )1);
  }
}
}
void cpSpaceLock(cpSpace *space ) 
{ 


  {
  (space->locked) ++;
  return;
}
}
void cpSpaceUnlock(cpSpace *space , cpBool runPostStep ) 
{ 
  cpArray *waking ;
  int i ;
  int count ;
  cpArray *arr ;
  int i___0 ;
  cpPostStepCallback *callback ;
  void (*func)(cpSpace *space , void *key , void *data ) ;

  {
  (space->locked) --;
  if (! (space->locked >= 0)) {
    cpMessage("space->locked >= 0", "../src/cpSpaceStep.c", 72, 1, 1, "Internal Error: Space lock underflow.");
    abort();
  }
  if (space->locked == 0) {
    waking = space->rousedBodies;
    i = 0;
    count = waking->num;
    while (i < count) {
      cpSpaceActivateBody(space, (cpBody *)*(waking->arr + i));
      *(waking->arr + i) = (void *)0;
      i ++;
    }
    waking->num = 0;
    if (space->locked == 0) {
      if (runPostStep) {
        if (! space->skipPostStep) {
          space->skipPostStep = (cpBool )1;
          arr = space->postStepCallbacks;
          i___0 = 0;
          while (i___0 < arr->num) {
            callback = (cpPostStepCallback *)*(arr->arr + i___0);
            func = callback->func;
            callback->func = (void (*)(cpSpace *space , void *key , void *data ))((void *)0);
            if (func) {
              (*func)(space, callback->key, callback->data);
            }
            *(arr->arr + i___0) = (void *)0;
            free((void *)callback);
            i___0 ++;
          }
          arr->num = 0;
          space->skipPostStep = (cpBool )0;
        }
      }
    }
  }
  return;
}
}
static cpContactBufferHeader *cpSpaceAllocContactBuffer(cpSpace *space ) 
{ 
  cpContactBuffer *buffer ;
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(cpContactBuffer ));
  buffer = (cpContactBuffer *)tmp;
  cpArrayPush(space->allocatedBuffers, (void *)buffer);
  return ((cpContactBufferHeader *)buffer);
}
}
static cpContactBufferHeader *cpContactBufferHeaderInit(cpContactBufferHeader *header ,
                                                        cpTimestamp stamp , cpContactBufferHeader *splice ) 
{ 


  {
  header->stamp = stamp;
  if (splice) {
    header->next = splice->next;
  } else {
    header->next = header;
  }
  header->numContacts = 0U;
  return (header);
}
}
void cpSpacePushFreshContactBuffer(cpSpace *space ) 
{ 
  cpTimestamp stamp ;
  cpContactBufferHeader *head ;
  cpContactBufferHeader *tmp ;
  cpContactBufferHeader *tail ;
  cpContactBufferHeader *buffer ;
  cpContactBufferHeader *tmp___0 ;
  cpContactBufferHeader *tmp___1 ;
  cpContactBufferHeader *tmp___2 ;

  {
  stamp = space->stamp;
  head = space->contactBuffersHead;
  if (! head) {
    tmp = cpSpaceAllocContactBuffer(space);
    space->contactBuffersHead = cpContactBufferHeaderInit(tmp, stamp, (cpContactBufferHeader *)((void *)0));
  } else
  if (stamp - (head->next)->stamp > space->collisionPersistence) {
    tail = head->next;
    space->contactBuffersHead = cpContactBufferHeaderInit(tail, stamp, tail);
  } else {
    tmp___0 = cpSpaceAllocContactBuffer(space);
    tmp___1 = cpContactBufferHeaderInit(tmp___0, stamp, head);
    buffer = tmp___1;
    tmp___2 = buffer;
    head->next = tmp___2;
    space->contactBuffersHead = tmp___2;
  }
  return;
}
}
struct cpContact *cpContactBufferGetArray(cpSpace *space ) 
{ 
  cpContactBufferHeader *head ;

  {
  if ((unsigned long )((space->contactBuffersHead)->numContacts + 2U) > (32768UL - sizeof(cpContactBufferHeader )) / sizeof(struct cpContact )) {
    cpSpacePushFreshContactBuffer(space);
  }
  head = space->contactBuffersHead;
  return (((cpContactBuffer *)head)->contacts + head->numContacts);
}
}
void cpSpacePushContacts(cpSpace *space , int count ) 
{ 


  {
  if (! (count <= 2)) {
    cpMessage("count <= CP_MAX_CONTACTS_PER_ARBITER", "../src/cpSpaceStep.c", 176,
              1, 1, "Internal Error: Contact buffer overflow!");
    abort();
  }
  (space->contactBuffersHead)->numContacts += (unsigned int )count;
  return;
}
}
static void cpSpacePopContacts(cpSpace *space , int count ) 
{ 


  {
  (space->contactBuffersHead)->numContacts -= (unsigned int )count;
  return;
}
}
static void *cpSpaceArbiterSetTrans(cpShape **shapes , cpSpace *space ) 
{ 
  int count ;
  cpArbiter *buffer ;
  void *tmp ;
  int i ;
  void *tmp___0 ;
  cpArbiter *tmp___1 ;

  {
  if ((space->pooledArbiters)->num == 0) {
    count = (int )(32768UL / sizeof(cpArbiter ));
    if (! count) {
      cpMessage("count", "../src/cpSpaceStep.c", 193, 1, 1, "Internal Error: Buffer size too small.");
      abort();
    }
    tmp = calloc((size_t )1, (size_t )32768);
    buffer = (cpArbiter *)tmp;
    cpArrayPush(space->allocatedBuffers, (void *)buffer);
    i = 0;
    while (i < count) {
      cpArrayPush(space->pooledArbiters, (void *)(buffer + i));
      i ++;
    }
  }
  tmp___0 = cpArrayPop(space->pooledArbiters);
  tmp___1 = cpArbiterInit((cpArbiter *)tmp___0, *(shapes + 0), *(shapes + 1));
  return ((void *)tmp___1);
}
}
__inline static cpBool QueryRejectConstraint(cpBody *a , cpBody *b ) 
{ 
  cpConstraint *constraint ;

  {
  constraint = a->constraintList;
  while (constraint) {
    if (! constraint->collideBodies) {
      if ((unsigned long )constraint->a == (unsigned long )a) {
        if ((unsigned long )constraint->b == (unsigned long )b) {
          return ((cpBool )1);
        } else {
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
      if ((unsigned long )constraint->a == (unsigned long )b) {
        if ((unsigned long )constraint->b == (unsigned long )a) {
          return ((cpBool )1);
        }
      }
    }
    constraint = cpConstraintNext(constraint, a);
  }
  return ((cpBool )0);
}
}
__inline static cpBool QueryReject(cpShape *a , cpShape *b ) 
{ 
  cpBool tmp ;
  cpBool tmp___0 ;
  cpBool tmp___1 ;
  int tmp___2 ;

  {
  tmp = cpBBIntersects((cpBB const   )a->bb, (cpBB const   )b->bb);
  if (tmp) {
    if ((unsigned long )a->body == (unsigned long )b->body) {
      tmp___2 = 1;
    } else {
      tmp___0 = cpShapeFilterReject(a->filter, b->filter);
      if (tmp___0) {
        tmp___2 = 1;
      } else {
        tmp___1 = QueryRejectConstraint(a->body, b->body);
        if (tmp___1) {
          tmp___2 = 1;
        } else {
          tmp___2 = 0;
        }
      }
    }
  } else {
    tmp___2 = 1;
  }
  return ((cpBool )tmp___2);
}
}
cpCollisionID cpSpaceCollideShapes(cpShape *a , cpShape *b , cpCollisionID id , cpSpace *space ) 
{ 
  cpBool tmp ;
  struct cpCollisionInfo info ;
  struct cpContact *tmp___0 ;
  struct cpCollisionInfo tmp___1 ;
  cpShape const   *shape_pair[2] ;
  cpHashValue arbHashID ;
  cpArbiter *arb ;
  void const   *tmp___2 ;
  cpCollisionHandler *handler ;
  cpBool tmp___3 ;
  cpBool tmp___4 ;
  float tmp___5 ;
  float tmp___6 ;

  {
  tmp = QueryReject(a, b);
  if (tmp) {
    return (id);
  }
  tmp___0 = cpContactBufferGetArray(space);
  tmp___1 = cpCollide((cpShape const   *)a, (cpShape const   *)b, id, tmp___0);
  info = tmp___1;
  if (info.count == 0) {
    return (info.id);
  }
  cpSpacePushContacts(space, info.count);
  shape_pair[0] = info.a;
  shape_pair[1] = info.b;
  arbHashID = (cpHashValue )info.a * 3344921057UL ^ (cpHashValue )info.b * 3344921057UL;
  tmp___2 = cpHashSetInsert(space->cachedArbiters, arbHashID, (void const   *)(shape_pair),
                            (void *(*)(void const   *ptr , void *data ))(& cpSpaceArbiterSetTrans),
                            (void *)space);
  arb = (cpArbiter *)tmp___2;
  cpArbiterUpdate(arb, & info, space);
  handler = arb->handler;
  if ((unsigned int )arb->state == 0U) {
    tmp___3 = (*(handler->beginFunc))(arb, space, handler->userData);
    if (! tmp___3) {
      cpArbiterIgnore(arb);
    }
  }
  if ((unsigned int )arb->state != 2U) {
    tmp___4 = (*(handler->preSolveFunc))(arb, space, handler->userData);
    if (tmp___4) {
      if ((unsigned int )arb->state != 2U) {
        if (a->sensor) {
          goto _L___2;
        } else
        if (b->sensor) {
          goto _L___2;
        } else {
          tmp___5 = __builtin_inff();
          if ((a->body)->m == (cpFloat )tmp___5) {
            tmp___6 = __builtin_inff();
            if ((b->body)->m == (cpFloat )tmp___6) {
              goto _L___2;
            } else {
              cpArrayPush(space->arbiters, (void *)arb);
            }
          } else {
            cpArrayPush(space->arbiters, (void *)arb);
          }
        }
      } else {
        goto _L___2;
      }
    } else {
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    cpSpacePopContacts(space, info.count);
    arb->contacts = (struct cpContact *)((void *)0);
    arb->count = 0;
    if ((unsigned int )arb->state != 2U) {
      arb->state = (enum cpArbiterState )1;
    }
  }
  arb->stamp = space->stamp;
  return (info.id);
}
}
cpBool cpSpaceArbiterSetFilter(cpArbiter *arb , cpSpace *space ) 
{ 
  cpTimestamp ticks ;
  cpBody *a ;
  cpBody *b ;
  cpBodyType tmp ;
  cpBool tmp___0 ;
  cpBodyType tmp___1 ;
  cpBool tmp___2 ;
  cpCollisionHandler *handler ;

  {
  ticks = space->stamp - arb->stamp;
  a = arb->body_a;
  b = arb->body_b;
  tmp = cpBodyGetType(a);
  if ((unsigned int )tmp == 2U) {
    goto _L;
  } else {
    tmp___0 = cpBodyIsSleeping((cpBody const   *)a);
    if (tmp___0) {
      _L: /* CIL Label */ 
      tmp___1 = cpBodyGetType(b);
      if ((unsigned int )tmp___1 == 2U) {
        return ((cpBool )1);
      } else {
        tmp___2 = cpBodyIsSleeping((cpBody const   *)b);
        if (tmp___2) {
          return ((cpBool )1);
        }
      }
    }
  }
  if (ticks >= 1U) {
    if ((unsigned int )arb->state != 3U) {
      arb->state = (enum cpArbiterState )3;
      handler = arb->handler;
      (*(handler->separateFunc))(arb, space, handler->userData);
    }
  }
  if (ticks >= space->collisionPersistence) {
    arb->contacts = (struct cpContact *)((void *)0);
    arb->count = 0;
    cpArrayPush(space->pooledArbiters, (void *)arb);
    return ((cpBool )0);
  }
  return ((cpBool )1);
}
}
void cpShapeUpdateFunc(cpShape *shape , void *unused ) 
{ 


  {
  cpShapeCacheBB(shape);
  return;
}
}
void cpSpaceStep(cpSpace *space , cpFloat dt ) 
{ 
  cpFloat prev_dt ;
  cpArray *bodies ;
  cpArray *constraints ;
  cpArray *arbiters ;
  int i ;
  cpArbiter *arb ;
  cpBool tmp ;
  cpBool tmp___0 ;
  int i___0 ;
  cpBody *body ;
  cpFloat slop ;
  cpFloat biasCoef ;
  double tmp___1 ;
  int i___1 ;
  int i___2 ;
  cpConstraint *constraint ;
  void (*preSolve)(cpConstraint *constraint , cpSpace *space ) ;
  cpFloat damping ;
  double tmp___2 ;
  cpVect gravity ;
  int i___3 ;
  cpBody *body___0 ;
  cpFloat dt_coef ;
  cpFloat tmp___3 ;
  int i___4 ;
  int i___5 ;
  cpConstraint *constraint___0 ;
  int i___6 ;
  int j ;
  int j___0 ;
  cpConstraint *constraint___1 ;
  int i___7 ;
  cpConstraint *constraint___2 ;
  void (*postSolve)(cpConstraint *constraint , cpSpace *space ) ;
  int i___8 ;
  cpArbiter *arb___0 ;
  cpCollisionHandler *handler ;

  {
  if (dt == (cpFloat )0.0f) {
    return;
  }
  (space->stamp) ++;
  prev_dt = space->curr_dt;
  space->curr_dt = dt;
  bodies = space->dynamicBodies;
  constraints = space->constraints;
  arbiters = space->arbiters;
  i = 0;
  while (i < arbiters->num) {
    arb = (cpArbiter *)*(arbiters->arr + i);
    arb->state = (enum cpArbiterState )1;
    tmp = cpBodyIsSleeping((cpBody const   *)arb->body_a);
    if (! tmp) {
      tmp___0 = cpBodyIsSleeping((cpBody const   *)arb->body_b);
      if (! tmp___0) {
        cpArbiterUnthread(arb);
      }
    }
    i ++;
  }
  arbiters->num = 0;
  cpSpaceLock(space);
  i___0 = 0;
  while (i___0 < bodies->num) {
    body = (cpBody *)*(bodies->arr + i___0);
    (*(body->position_func))(body, dt);
    i___0 ++;
  }
  cpSpacePushFreshContactBuffer(space);
  cpSpatialIndexEach(space->dynamicShapes, (void (*)(void *obj , void *data ))(& cpShapeUpdateFunc),
                     (void *)0);
  cpSpatialIndexReindexQuery(space->dynamicShapes, (cpCollisionID (*)(void *obj1 ,
                                                                      void *obj2 ,
                                                                      cpCollisionID id ,
                                                                      void *data ))(& cpSpaceCollideShapes),
                             (void *)space);
  cpSpaceUnlock(space, (cpBool )0);
  cpSpaceProcessComponents(space, dt);
  cpSpaceLock(space);
  cpHashSetFilter(space->cachedArbiters, (cpBool (*)(void *elt , void *data ))(& cpSpaceArbiterSetFilter),
                  (void *)space);
  slop = space->collisionSlop;
  tmp___1 = pow(space->collisionBias, dt);
  biasCoef = (double )1.0f - tmp___1;
  i___1 = 0;
  while (i___1 < arbiters->num) {
    cpArbiterPreStep((cpArbiter *)*(arbiters->arr + i___1), dt, slop, biasCoef);
    i___1 ++;
  }
  i___2 = 0;
  while (i___2 < constraints->num) {
    constraint = (cpConstraint *)*(constraints->arr + i___2);
    preSolve = constraint->preSolve;
    if (preSolve) {
      (*preSolve)(constraint, space);
    }
    (*((constraint->klass)->preStep))(constraint, dt);
    i___2 ++;
  }
  tmp___2 = pow(space->damping, dt);
  damping = tmp___2;
  gravity = space->gravity;
  i___3 = 0;
  while (i___3 < bodies->num) {
    body___0 = (cpBody *)*(bodies->arr + i___3);
    (*(body___0->velocity_func))(body___0, gravity, damping, dt);
    i___3 ++;
  }
  if (prev_dt == (cpFloat )0.0f) {
    tmp___3 = (cpFloat )0.0f;
  } else {
    tmp___3 = dt / prev_dt;
  }
  dt_coef = tmp___3;
  i___4 = 0;
  while (i___4 < arbiters->num) {
    cpArbiterApplyCachedImpulse((cpArbiter *)*(arbiters->arr + i___4), dt_coef);
    i___4 ++;
  }
  i___5 = 0;
  while (i___5 < constraints->num) {
    constraint___0 = (cpConstraint *)*(constraints->arr + i___5);
    (*((constraint___0->klass)->applyCachedImpulse))(constraint___0, dt_coef);
    i___5 ++;
  }
  i___6 = 0;
  while (i___6 < space->iterations) {
    j = 0;
    while (j < arbiters->num) {
      cpArbiterApplyImpulse((cpArbiter *)*(arbiters->arr + j));
      j ++;
    }
    j___0 = 0;
    while (j___0 < constraints->num) {
      constraint___1 = (cpConstraint *)*(constraints->arr + j___0);
      (*((constraint___1->klass)->applyImpulse))(constraint___1, dt);
      j___0 ++;
    }
    i___6 ++;
  }
  i___7 = 0;
  while (i___7 < constraints->num) {
    constraint___2 = (cpConstraint *)*(constraints->arr + i___7);
    postSolve = constraint___2->postSolve;
    if (postSolve) {
      (*postSolve)(constraint___2, space);
    }
    i___7 ++;
  }
  i___8 = 0;
  while (i___8 < arbiters->num) {
    arb___0 = (cpArbiter *)*(arbiters->arr + i___8);
    handler = arb___0->handler;
    (*(handler->postSolveFunc))(arb___0, space, handler->userData);
    i___8 ++;
  }
  cpSpaceUnlock(space, (cpBool )1);
  return;
}
}
#pragma merger("0","/tmp/cil-ZZE1YXu_.i","-std=gnu99,-ffast-math,-fPIC")
__inline static void cpSpatialIndexDestroy(cpSpatialIndex *index ) 
{ 


  {
  if (index->klass) {
    (*((index->klass)->destroy))(index);
  }
  return;
}
}
__inline static int cpSpatialIndexCount(cpSpatialIndex *index ) 
{ 
  int tmp ;

  {
  tmp = (*((index->klass)->count))(index);
  return (tmp);
}
}
void cpSpatialIndexFree(cpSpatialIndex *index ) 
{ 


  {
  if (index) {
    cpSpatialIndexDestroy(index);
    free((void *)index);
  }
  return;
}
}
cpSpatialIndex *cpSpatialIndexInit(cpSpatialIndex *index , cpSpatialIndexClass *klass___12 ,
                                   cpBB (*bbfunc)(void *obj ) , cpSpatialIndex *staticIndex ) 
{ 


  {
  index->klass = klass___12;
  index->bbfunc = bbfunc;
  index->staticIndex = staticIndex;
  if (staticIndex) {
    if (! (! staticIndex->dynamicIndex)) {
      cpMessage("!staticIndex->dynamicIndex", "../src/cpSpatialIndex.c", 41, 1, 1,
                "This static index is already associated with a dynamic index.");
      abort();
    }
    staticIndex->dynamicIndex = index;
  }
  return (index);
}
}
static void dynamicToStaticIter(void *obj , dynamicToStaticContext *context ) 
{ 
  cpBB tmp ;

  {
  tmp = (*(context->bbfunc))(obj);
  cpSpatialIndexQuery(context->staticIndex, obj, tmp, context->queryFunc, context->data);
  return;
}
}
void cpSpatialIndexCollideStatic(cpSpatialIndex *dynamicIndex , cpSpatialIndex *staticIndex ,
                                 cpCollisionID (*func)(void *obj1 , void *obj2 , cpCollisionID id ,
                                                       void *data ) , void *data ) 
{ 
  dynamicToStaticContext context ;
  int tmp ;

  {
  if (staticIndex) {
    tmp = cpSpatialIndexCount(staticIndex);
    if (tmp > 0) {
      context.bbfunc = dynamicIndex->bbfunc;
      context.staticIndex = staticIndex;
      context.queryFunc = func;
      context.data = data;
      cpSpatialIndexEach(dynamicIndex, (void (*)(void *obj , void *data ))(& dynamicToStaticIter),
                         (void *)(& context));
    }
  }
  return;
}
}
#pragma merger("0","/tmp/cil-4xm65C4h.i","-std=gnu99,-ffast-math,-fPIC")
__inline static cpBB cpBBExpand(cpBB const   bb , cpVect const   v ) 
{ 
  cpFloat tmp ;
  cpFloat tmp___0 ;
  cpFloat tmp___1 ;
  cpFloat tmp___2 ;
  cpBB tmp___3 ;

  {
  tmp = cpfmax((cpFloat )bb.t, (cpFloat )v.y);
  tmp___0 = cpfmax((cpFloat )bb.r, (cpFloat )v.x);
  tmp___1 = cpfmin((cpFloat )bb.b, (cpFloat )v.y);
  tmp___2 = cpfmin((cpFloat )bb.l, (cpFloat )v.x);
  tmp___3 = cpBBNew((cpFloat const   )tmp___2, (cpFloat const   )tmp___1, (cpFloat const   )tmp___0,
                    (cpFloat const   )tmp);
  return (tmp___3);
}
}
cpSweep1D *cpSweep1DAlloc(void) ;
cpSpatialIndex *cpSweep1DInit(cpSweep1D *sweep , cpBB (*bbfunc)(void *obj ) , cpSpatialIndex *staticIndex ) ;
cpSpatialIndex *cpSweep1DNew(cpBB (*bbfunc)(void *obj ) , cpSpatialIndex *staticIndex ) ;
__inline static cpSpatialIndexClass *Klass___1(void) ;
__inline static cpBool BoundsOverlap(Bounds a , Bounds b ) 
{ 
  int tmp ;

  {
  if (a.min <= b.max) {
    if (b.min <= a.max) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((cpBool )tmp);
}
}
__inline static Bounds BBToBounds(cpSweep1D *sweep , cpBB bb ) 
{ 
  Bounds bounds ;

  {
  bounds.min = bb.l;
  bounds.max = bb.r;
  return (bounds);
}
}
__inline static TableCell MakeTableCell(cpSweep1D *sweep , void *obj ) 
{ 
  TableCell cell ;
  cpBB tmp ;
  Bounds tmp___0 ;

  {
  tmp = (*(sweep->spatialIndex.bbfunc))(obj);
  tmp___0 = BBToBounds(sweep, tmp);
  cell.obj = obj;
  cell.bounds = tmp___0;
  return (cell);
}
}
cpSweep1D *cpSweep1DAlloc(void) 
{ 
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(cpSweep1D ));
  return ((cpSweep1D *)tmp);
}
}
static void ResizeTable(cpSweep1D *sweep , int size ) 
{ 
  void *tmp ;

  {
  sweep->max = size;
  tmp = realloc((void *)sweep->table, (unsigned long )size * sizeof(TableCell ));
  sweep->table = (TableCell *)tmp;
  return;
}
}
cpSpatialIndex *cpSweep1DInit(cpSweep1D *sweep , cpBB (*bbfunc)(void *obj ) , cpSpatialIndex *staticIndex ) 
{ 
  cpSpatialIndexClass *tmp ;

  {
  tmp = Klass___1();
  cpSpatialIndexInit((cpSpatialIndex *)sweep, tmp, bbfunc, staticIndex);
  sweep->num = 0;
  ResizeTable(sweep, 32);
  return ((cpSpatialIndex *)sweep);
}
}
cpSpatialIndex *cpSweep1DNew(cpBB (*bbfunc)(void *obj ) , cpSpatialIndex *staticIndex ) 
{ 
  cpSweep1D *tmp ;
  cpSpatialIndex *tmp___0 ;

  {
  tmp = cpSweep1DAlloc();
  tmp___0 = cpSweep1DInit(tmp, bbfunc, staticIndex);
  return (tmp___0);
}
}
static void cpSweep1DDestroy(cpSweep1D *sweep ) 
{ 


  {
  free((void *)sweep->table);
  sweep->table = (TableCell *)((void *)0);
  return;
}
}
static int cpSweep1DCount(cpSweep1D *sweep ) 
{ 


  {
  return (sweep->num);
}
}
static void cpSweep1DEach(cpSweep1D *sweep , void (*func)(void *obj , void *data ) ,
                          void *data ) 
{ 
  TableCell *table ;
  int i ;
  int count ;

  {
  table = sweep->table;
  i = 0;
  count = sweep->num;
  while (i < count) {
    (*func)((table + i)->obj, data);
    i ++;
  }
  return;
}
}
static int cpSweep1DContains(cpSweep1D *sweep , void *obj , cpHashValue hashid ) 
{ 
  TableCell *table ;
  int i ;
  int count ;

  {
  table = sweep->table;
  i = 0;
  count = sweep->num;
  while (i < count) {
    if ((unsigned long )(table + i)->obj == (unsigned long )obj) {
      return (1);
    }
    i ++;
  }
  return (0);
}
}
static void cpSweep1DInsert(cpSweep1D *sweep , void *obj , cpHashValue hashid ) 
{ 


  {
  if (sweep->num == sweep->max) {
    ResizeTable(sweep, sweep->max * 2);
  }
  *(sweep->table + sweep->num) = MakeTableCell(sweep, obj);
  (sweep->num) ++;
  return;
}
}
static void cpSweep1DRemove(cpSweep1D *sweep , void *obj , cpHashValue hashid ) 
{ 
  TableCell *table ;
  int i ;
  int count ;
  int num ;

  {
  table = sweep->table;
  i = 0;
  count = sweep->num;
  while (i < count) {
    if ((unsigned long )(table + i)->obj == (unsigned long )obj) {
      (sweep->num) --;
      num = sweep->num;
      *(table + i) = *(table + num);
      (table + num)->obj = (void *)0;
      return;
    }
    i ++;
  }
  return;
}
}
static void cpSweep1DReindexObject(cpSweep1D *sweep , void *obj , cpHashValue hashid ) 
{ 


  {
  return;
}
}
static void cpSweep1DReindex(cpSweep1D *sweep ) 
{ 


  {
  return;
}
}
static void cpSweep1DQuery(cpSweep1D *sweep , void *obj , cpBB bb , cpCollisionID (*func)(void *obj1 ,
                                                                                          void *obj2 ,
                                                                                          cpCollisionID id ,
                                                                                          void *data ) ,
                           void *data ) 
{ 
  Bounds bounds ;
  Bounds tmp ;
  TableCell *table ;
  int i ;
  int count ;
  TableCell cell ;
  cpBool tmp___0 ;

  {
  tmp = BBToBounds(sweep, bb);
  bounds = tmp;
  table = sweep->table;
  i = 0;
  count = sweep->num;
  while (i < count) {
    cell = *(table + i);
    tmp___0 = BoundsOverlap(bounds, cell.bounds);
    if (tmp___0) {
      if ((unsigned long )obj != (unsigned long )cell.obj) {
        (*func)(obj, cell.obj, (cpCollisionID )0, data);
      }
    }
    i ++;
  }
  return;
}
}
static void cpSweep1DSegmentQuery(cpSweep1D *sweep , void *obj , cpVect a , cpVect b ,
                                  cpFloat t_exit , cpFloat (*func)(void *obj1 , void *obj2 ,
                                                                   void *data ) ,
                                  void *data ) 
{ 
  cpBB bb ;
  cpBB tmp ;
  cpBB tmp___0 ;
  Bounds bounds ;
  Bounds tmp___1 ;
  TableCell *table ;
  int i ;
  int count ;
  TableCell cell ;
  cpBool tmp___2 ;

  {
  tmp = cpBBNew((cpFloat const   )a.x, (cpFloat const   )a.y, (cpFloat const   )a.x,
                (cpFloat const   )a.y);
  tmp___0 = cpBBExpand((cpBB const   )tmp, (cpVect const   )b);
  bb = tmp___0;
  tmp___1 = BBToBounds(sweep, bb);
  bounds = tmp___1;
  table = sweep->table;
  i = 0;
  count = sweep->num;
  while (i < count) {
    cell = *(table + i);
    tmp___2 = BoundsOverlap(bounds, cell.bounds);
    if (tmp___2) {
      (*func)(obj, cell.obj, data);
    }
    i ++;
  }
  return;
}
}
static int TableSort(TableCell *a , TableCell *b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (a->bounds.min < b->bounds.min) {
    tmp___0 = -1;
  } else {
    if (a->bounds.min > b->bounds.min) {
      tmp = 1;
    } else {
      tmp = 0;
    }
    tmp___0 = tmp;
  }
  return (tmp___0);
}
}
static void cpSweep1DReindexQuery(cpSweep1D *sweep , cpCollisionID (*func)(void *obj1 ,
                                                                           void *obj2 ,
                                                                           cpCollisionID id ,
                                                                           void *data ) ,
                                  void *data ) 
{ 
  TableCell *table ;
  int count ;
  int i ;
  int i___0 ;
  TableCell cell ;
  cpFloat max ;
  int j ;

  {
  table = sweep->table;
  count = sweep->num;
  i = 0;
  while (i < count) {
    *(table + i) = MakeTableCell(sweep, (table + i)->obj);
    i ++;
  }
  qsort((void *)table, (size_t )count, sizeof(TableCell ), (int (*)(void const   * ,
                                                                    void const   * ))(& TableSort));
  i___0 = 0;
  while (i___0 < count) {
    cell = *(table + i___0);
    max = cell.bounds.max;
    j = i___0 + 1;
    while (1) {
      if ((table + j)->bounds.min < max) {
        if (! (j < count)) {
          break;
        }
      } else {
        break;
      }
      (*func)(cell.obj, (table + j)->obj, (cpCollisionID )0, data);
      j ++;
    }
    i___0 ++;
  }
  cpSpatialIndexCollideStatic((cpSpatialIndex *)sweep, sweep->spatialIndex.staticIndex,
                              func, data);
  return;
}
}
static cpSpatialIndexClass klass___11  = 
     {(void (*)(cpSpatialIndex *index ))(& cpSweep1DDestroy), (int (*)(cpSpatialIndex *index ))(& cpSweep1DCount),
    (void (*)(cpSpatialIndex *index , void (*func)(void *obj , void *data ) , void *data ))(& cpSweep1DEach),
    (cpBool (*)(cpSpatialIndex *index , void *obj , cpHashValue hashid ))(& cpSweep1DContains),
    (void (*)(cpSpatialIndex *index , void *obj , cpHashValue hashid ))(& cpSweep1DInsert),
    (void (*)(cpSpatialIndex *index , void *obj , cpHashValue hashid ))(& cpSweep1DRemove),
    (void (*)(cpSpatialIndex *index ))(& cpSweep1DReindex), (void (*)(cpSpatialIndex *index ,
                                                                      void *obj ,
                                                                      cpHashValue hashid ))(& cpSweep1DReindexObject),
    (void (*)(cpSpatialIndex *index , cpCollisionID (*func)(void *obj1 , void *obj2 ,
                                                            cpCollisionID id , void *data ) ,
              void *data ))(& cpSweep1DReindexQuery), (void (*)(cpSpatialIndex *index ,
                                                                void *obj , cpBB bb ,
                                                                cpCollisionID (*func)(void *obj1 ,
                                                                                      void *obj2 ,
                                                                                      cpCollisionID id ,
                                                                                      void *data ) ,
                                                                void *data ))(& cpSweep1DQuery),
    (void (*)(cpSpatialIndex *index , void *obj , cpVect a , cpVect b , cpFloat t_exit ,
              cpFloat (*func)(void *obj1 , void *obj2 , void *data ) , void *data ))(& cpSweep1DSegmentQuery)};
__inline static cpSpatialIndexClass *Klass___1(void) 
{ 


  {
  return (& klass___11);
}
}
