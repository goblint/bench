/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long __int64_t;
typedef unsigned long __uint64_t;
typedef long __off_t;
typedef long __off64_t;
typedef __int8_t int8_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
typedef __uint8_t uint8_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
typedef __builtin_va_list __gnuc_va_list;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
struct __anonstruct_mm128_t_549813859 {
   uint64_t x ;
   uint64_t y ;
};
typedef struct __anonstruct_mm128_t_549813859 mm128_t;
struct __anonstruct_mm_idx_seq_t_994244248 {
   char *name ;
   uint64_t offset ;
   uint32_t len ;
   uint32_t is_alt ;
};
typedef struct __anonstruct_mm_idx_seq_t_994244248 mm_idx_seq_t;
struct mm_idx_bucket_s ;
struct mm_idx_intv_s ;
struct __anonstruct_mm_idx_t_37932985 {
   int32_t b ;
   int32_t w ;
   int32_t k ;
   int32_t flag ;
   uint32_t n_seq ;
   int32_t index ;
   int32_t n_alt ;
   mm_idx_seq_t *seq ;
   uint32_t *S ;
   struct mm_idx_bucket_s *B ;
   struct mm_idx_intv_s *I ;
   void *km ;
   void *h ;
};
typedef struct __anonstruct_mm_idx_t_37932985 mm_idx_t;
struct __anonstruct_mm_extra_t_49860175 {
   uint32_t capacity ;
   int32_t dp_score ;
   int32_t dp_max ;
   int32_t dp_max2 ;
   uint32_t n_ambi : 30 ;
   uint32_t trans_strand : 2 ;
   uint32_t n_cigar ;
   uint32_t cigar[] ;
};
typedef struct __anonstruct_mm_extra_t_49860175 mm_extra_t;
struct __anonstruct_mm_reg1_t_435689901 {
   int32_t id ;
   int32_t cnt ;
   int32_t rid ;
   int32_t score ;
   int32_t qs ;
   int32_t qe ;
   int32_t rs ;
   int32_t re ;
   int32_t parent ;
   int32_t subsc ;
   int32_t as ;
   int32_t mlen ;
   int32_t blen ;
   int32_t n_sub ;
   int32_t score0 ;
   uint32_t mapq : 8 ;
   uint32_t split : 2 ;
   uint32_t rev : 1 ;
   uint32_t inv : 1 ;
   uint32_t sam_pri : 1 ;
   uint32_t proper_frag : 1 ;
   uint32_t pe_thru : 1 ;
   uint32_t seg_split : 1 ;
   uint32_t seg_id : 8 ;
   uint32_t split_inv : 1 ;
   uint32_t is_alt : 1 ;
   uint32_t strand_retained : 1 ;
   uint32_t dummy : 5 ;
   uint32_t hash ;
   float div ;
   mm_extra_t *p ;
};
typedef struct __anonstruct_mm_reg1_t_435689901 mm_reg1_t;
struct __anonstruct_mm_mapopt_t_504735564 {
   int64_t flag ;
   int seed ;
   int sdust_thres ;
   int max_qlen ;
   int bw ;
   int bw_long ;
   int max_gap ;
   int max_gap_ref ;
   int max_frag_len ;
   int max_chain_skip ;
   int max_chain_iter ;
   int min_cnt ;
   int min_chain_score ;
   float chain_gap_scale ;
   float chain_skip_scale ;
   int rmq_size_cap ;
   int rmq_inner_dist ;
   int rmq_rescue_size ;
   float rmq_rescue_ratio ;
   float mask_level ;
   int mask_len ;
   float pri_ratio ;
   int best_n ;
   float alt_drop ;
   int a ;
   int b ;
   int q ;
   int e ;
   int q2 ;
   int e2 ;
   int sc_ambi ;
   int noncan ;
   int junc_bonus ;
   int zdrop ;
   int zdrop_inv ;
   int end_bonus ;
   int min_dp_max ;
   int min_ksw_len ;
   int anchor_ext_len ;
   int anchor_ext_shift ;
   float max_clip_ratio ;
   int rank_min_len ;
   float rank_frac ;
   int pe_ori ;
   int pe_bonus ;
   float mid_occ_frac ;
   float q_occ_frac ;
   int32_t min_mid_occ ;
   int32_t max_mid_occ ;
   int32_t mid_occ ;
   int32_t max_occ ;
   int32_t max_max_occ ;
   int32_t occ_dist ;
   int64_t mini_batch_size ;
   int64_t max_sw_mat ;
   int64_t cap_kalloc ;
   char const   *split_prefix ;
};
typedef struct __anonstruct_mm_mapopt_t_504735564 mm_mapopt_t;
union __anonunion_z_307641061 {
   float f ;
   uint32_t i ;
};
struct __anonstruct_ksw_extz_t_28989980 {
   uint32_t max : 31 ;
   uint32_t zdropped : 1 ;
   int max_q ;
   int max_t ;
   int mqe ;
   int mqe_t ;
   int mte ;
   int mte_q ;
   int score ;
   int m_cigar ;
   int n_cigar ;
   int reach_end ;
   uint32_t *cigar ;
};
typedef struct __anonstruct_ksw_extz_t_28989980 ksw_extz_t;
typedef void *voidp;
typedef __off_t off_t;
struct gzFile_s ;
typedef struct gzFile_s *gzFile;
struct gzFile_s {
   unsigned int have ;
   unsigned char *next ;
   off_t pos ;
};
struct mm_bseq_file_s ;
typedef struct mm_bseq_file_s mm_bseq_file_t;
struct __anonstruct_mm_bseq1_t_216488822 {
   int l_seq ;
   int rid ;
   char *name ;
   char *seq ;
   char *qual ;
   char *comment ;
};
typedef struct __anonstruct_mm_bseq1_t_216488822 mm_bseq1_t;
struct __kstring_t {
   size_t l ;
   size_t m ;
   char *s ;
};
typedef struct __kstring_t kstring_t;
struct __kstream_t {
   int begin ;
   int end ;
   int is_eof : 2 ;
   int bufsize : 30 ;
   gzFile f ;
   unsigned char *buf ;
};
typedef struct __kstream_t kstream_t;
struct __anonstruct_kseq_t_745567265 {
   kstring_t name ;
   kstring_t comment ;
   kstring_t seq ;
   kstring_t qual ;
   int last_char ;
   kstream_t *f ;
};
typedef struct __anonstruct_kseq_t_745567265 kseq_t;
struct mm_bseq_file_s {
   gzFile fp ;
   kseq_t *ks ;
   mm_bseq1_t s ;
};
struct __anonstruct_a_687107232 {
   size_t n ;
   size_t m ;
   mm_bseq1_t *a ;
};
struct __anonstruct_a_687107233 {
   size_t n ;
   size_t m ;
   mm_bseq1_t *a ;
};
typedef __gnuc_va_list va_list___0;
struct __anonstruct_mm_seg_t_669792804 {
   int n_u ;
   int n_a ;
   uint64_t *u ;
   mm128_t *a ;
};
typedef struct __anonstruct_mm_seg_t_669792804 mm_seg_t;
typedef long __ssize_t;
typedef __ssize_t ssize_t;
struct __anonstruct_mm128_v_892938973 {
   size_t n ;
   size_t m ;
   mm128_t *a ;
};
typedef struct __anonstruct_mm128_v_892938973 mm128_v;
struct __anonstruct_mm_idxopt_t_765247699 {
   short k ;
   short w ;
   short flag ;
   short bucket_bits ;
   int64_t mini_batch_size ;
   uint64_t batch_size ;
};
typedef struct __anonstruct_mm_idxopt_t_765247699 mm_idxopt_t;
union __anonunion_fp_221189586 {
   struct mm_bseq_file_s *seq ;
   FILE *idx ;
};
struct __anonstruct_mm_idx_reader_t_915061758 {
   int is_idx ;
   int n_parts ;
   int64_t idx_size ;
   mm_idxopt_t opt ;
   FILE *fp_out ;
   union __anonunion_fp_221189586 fp ;
};
typedef struct __anonstruct_mm_idx_reader_t_915061758 mm_idx_reader_t;
typedef unsigned int khint32_t;
typedef khint32_t khint_t;
typedef char const   *kh_cstr_t;
struct kh_idx_s {
   khint_t n_buckets ;
   khint_t size ;
   khint_t n_occupied ;
   khint_t upper_bound ;
   khint32_t *flags ;
   uint64_t *keys ;
   uint64_t *vals ;
};
typedef struct kh_idx_s kh_idx_t;
typedef kh_idx_t idxhash_t;
struct kh_str_s {
   khint_t n_buckets ;
   khint_t size ;
   khint_t n_occupied ;
   khint_t upper_bound ;
   khint32_t *flags ;
   kh_cstr_t *keys ;
   uint32_t *vals ;
};
typedef struct kh_str_s kh_str_t;
struct mm_idx_bucket_s {
   mm128_v a ;
   int32_t n ;
   uint64_t *p ;
   void *h ;
};
typedef struct mm_idx_bucket_s mm_idx_bucket_t;
struct __anonstruct_mm_idx_intv1_t_814805217 {
   int32_t st ;
   int32_t en ;
   int32_t max ;
   int32_t score : 30 ;
   int32_t strand : 2 ;
};
typedef struct __anonstruct_mm_idx_intv1_t_814805217 mm_idx_intv1_t;
struct mm_idx_intv_s {
   int32_t n ;
   int32_t m ;
   mm_idx_intv1_t *a ;
};
typedef struct mm_idx_intv_s mm_idx_intv_t;
struct __anonstruct_pipeline_t_962757189 {
   int mini_batch_size ;
   uint64_t batch_size ;
   uint64_t sum_len ;
   mm_bseq_file_t *fp ;
   mm_idx_t *mi ;
};
typedef struct __anonstruct_pipeline_t_962757189 pipeline_t;
struct __anonstruct_step_t_367897714 {
   int n_seq ;
   mm_bseq1_t *seq ;
   mm128_v a ;
};
typedef struct __anonstruct_step_t_367897714 step_t;
struct __anonstruct_rsbucket_bed_t_959080191 {
   mm_idx_intv1_t *b ;
   mm_idx_intv1_t *e ;
};
typedef struct __anonstruct_rsbucket_bed_t_959080191 rsbucket_bed_t;
struct __anonstruct_km_stat_t_75465862 {
   size_t capacity ;
   size_t available ;
   size_t n_blocks ;
   size_t n_cores ;
   size_t largest ;
};
typedef struct __anonstruct_km_stat_t_75465862 km_stat_t;
struct header_t {
   size_t size ;
   struct header_t *ptr ;
};
typedef struct header_t header_t;
struct __anonstruct_kmem_t_1048322885 {
   void *par ;
   size_t min_core_size ;
   header_t base ;
   header_t *loop_head ;
   header_t *core_head ;
};
typedef struct __anonstruct_kmem_t_1048322885 kmem_t;
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
struct __anonstruct___wseq32_112954846 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_465919411 {
   unsigned long long __wseq ;
   struct __anonstruct___wseq32_112954846 __wseq32 ;
};
struct __anonstruct___g1_start32_717608301 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_717608300 {
   unsigned long long __g1_start ;
   struct __anonstruct___g1_start32_717608301 __g1_start32 ;
};
struct __pthread_cond_s {
   union __anonunion____missing_field_name_465919411 __annonCompField1 ;
   union __anonunion____missing_field_name_717608300 __annonCompField2 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
typedef unsigned long pthread_t;
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
union __anonunion_pthread_condattr_t_488594145 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_condattr_t_488594145 pthread_condattr_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
union __anonunion_pthread_cond_t_951761805 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
typedef union __anonunion_pthread_cond_t_951761805 pthread_cond_t;
struct kt_for_t ;
struct __anonstruct_ktf_worker_t_495033186 {
   struct kt_for_t *t ;
   long i ;
};
typedef struct __anonstruct_ktf_worker_t_495033186 ktf_worker_t;
struct kt_for_t {
   int n_threads ;
   long n ;
   ktf_worker_t *w ;
   void (*func)(void * , long  , int  ) ;
   void *data ;
};
typedef struct kt_for_t kt_for_t;
struct ktp_t ;
struct __anonstruct_ktp_worker_t_323515798 {
   struct ktp_t *pl ;
   int64_t index ;
   int step ;
   void *data ;
};
typedef struct __anonstruct_ktp_worker_t_323515798 ktp_worker_t;
struct ktp_t {
   void *shared ;
   void *(*func)(void * , int  , void * ) ;
   int64_t index ;
   int n_workers ;
   int n_steps ;
   ktp_worker_t *workers ;
   pthread_mutex_t mutex ;
   pthread_cond_t cv ;
};
typedef struct ktp_t ktp_t;
union __anonunion_z_307641061___0 {
   float f ;
   uint32_t i ;
};
struct __anonstruct_head_172264678 {
   struct lc_elem_s *p[2] ;
   struct lc_elem_s *s ;
   signed char balance ;
   unsigned int size ;
};
struct lc_elem_s {
   int32_t y ;
   int64_t i ;
   double pri ;
   struct __anonstruct_head_172264678 head ;
};
typedef struct lc_elem_s lc_elem_t;
struct krmq_itr_lc_elem {
   lc_elem_t const   *stack[64] ;
   lc_elem_t const   **top ;
};
struct __anonstruct_kmp_rmq_t_90781984 {
   size_t cnt ;
   size_t n ;
   size_t max ;
   lc_elem_t **buf ;
   void *km ;
};
typedef struct __anonstruct_kmp_rmq_t_90781984 kmp_rmq_t;
typedef unsigned long __rlim_t;
struct __anonstruct_ketopt_t_498465920 {
   int ind ;
   int opt ;
   char *arg ;
   int longidx ;
   int i ;
   int pos ;
   int n_args ;
};
typedef struct __anonstruct_ketopt_t_498465920 ketopt_t;
struct __anonstruct_ko_longopt_t_483049182 {
   char *name ;
   int has_arg ;
   int val ;
};
typedef struct __anonstruct_ko_longopt_t_483049182 ko_longopt_t;
typedef __rlim_t rlim_t;
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
typedef int __rlimit_resource_t;
struct sdust_buf_s ;
typedef struct sdust_buf_s sdust_buf_t;
struct mm_tbuf_s ;
typedef struct mm_tbuf_s mm_tbuf_t;
struct __anonstruct_mm_seed_t_554224803 {
   uint32_t n ;
   uint32_t q_pos ;
   uint32_t q_span : 31 ;
   uint32_t flt : 1 ;
   uint32_t seg_id : 31 ;
   uint32_t is_tandem : 1 ;
   uint64_t const   *cr ;
};
typedef struct __anonstruct_mm_seed_t_554224803 mm_seed_t;
struct mm_tbuf_s {
   void *km ;
   int rep_len ;
   int frag_gap ;
};
struct __anonstruct_pipeline_t_219146015 {
   int n_processed ;
   int n_threads ;
   int n_fp ;
   int64_t mini_batch_size ;
   mm_mapopt_t const   *opt ;
   mm_bseq_file_t **fp ;
   mm_idx_t const   *mi ;
   kstring_t str ;
   int n_parts ;
   uint32_t *rid_shift ;
   FILE *fp_split ;
   FILE **fp_parts ;
};
typedef struct __anonstruct_pipeline_t_219146015 pipeline_t___0;
struct __anonstruct_step_t_739812150 {
   pipeline_t___0 const   *p ;
   int n_seq ;
   int n_frag ;
   mm_bseq1_t *seq ;
   int *n_reg ;
   int *seg_off ;
   int *n_seg ;
   int *rep_len ;
   int *frag_gap ;
   mm_reg1_t **reg ;
   mm_tbuf_t **buf ;
};
typedef struct __anonstruct_step_t_739812150 step_t___0;
typedef long __time_t;
typedef long __suseconds_t;
typedef long __syscall_slong_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
union __anonunion____missing_field_name_1036346496 {
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
};
union __anonunion____missing_field_name_1036346497 {
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
};
union __anonunion____missing_field_name_1036346498 {
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
};
union __anonunion____missing_field_name_1036346499 {
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
};
union __anonunion____missing_field_name_1036346500 {
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
};
union __anonunion____missing_field_name_1036346501 {
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
};
union __anonunion____missing_field_name_1036346502 {
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
};
union __anonunion____missing_field_name_1036346503 {
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
};
union __anonunion____missing_field_name_1036346504 {
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
};
union __anonunion____missing_field_name_1036346505 {
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
};
union __anonunion____missing_field_name_1036346506 {
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
};
union __anonunion____missing_field_name_1036346507 {
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
};
union __anonunion____missing_field_name_1036346508 {
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
};
union __anonunion____missing_field_name_1036346509 {
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   union __anonunion____missing_field_name_1036346496 __annonCompField3 ;
   union __anonunion____missing_field_name_1036346497 __annonCompField4 ;
   union __anonunion____missing_field_name_1036346498 __annonCompField5 ;
   union __anonunion____missing_field_name_1036346499 __annonCompField6 ;
   union __anonunion____missing_field_name_1036346500 __annonCompField7 ;
   union __anonunion____missing_field_name_1036346501 __annonCompField8 ;
   union __anonunion____missing_field_name_1036346502 __annonCompField9 ;
   union __anonunion____missing_field_name_1036346503 __annonCompField10 ;
   union __anonunion____missing_field_name_1036346504 __annonCompField11 ;
   union __anonunion____missing_field_name_1036346505 __annonCompField12 ;
   union __anonunion____missing_field_name_1036346506 __annonCompField13 ;
   union __anonunion____missing_field_name_1036346507 __annonCompField14 ;
   union __anonunion____missing_field_name_1036346508 __annonCompField15 ;
   union __anonunion____missing_field_name_1036346509 __annonCompField16 ;
};
typedef int __rusage_who_t;
struct __anonstruct_rsbucket_128x_t_473535168 {
   mm128_t *b ;
   mm128_t *e ;
};
typedef struct __anonstruct_rsbucket_128x_t_473535168 rsbucket_128x_t;
struct __anonstruct_rsbucket_64_t_1036346510 {
   uint64_t *b ;
   uint64_t *e ;
};
typedef struct __anonstruct_rsbucket_64_t_1036346510 rsbucket_64_t;
struct __anonstruct_pair_arr_t_502143112 {
   int s ;
   int rev ;
   uint64_t key ;
   mm_reg1_t *r ;
};
typedef struct __anonstruct_pair_arr_t_502143112 pair_arr_t;
struct __anonstruct_rsbucket_pair_t_1056124700 {
   pair_arr_t *b ;
   pair_arr_t *e ;
};
typedef struct __anonstruct_rsbucket_pair_t_1056124700 rsbucket_pair_t;
struct __anonstruct_sc_941540291 {
   size_t n ;
   size_t m ;
   uint64_t *a ;
};
struct __anonstruct_perf_intv_t_1051263395 {
   int start ;
   int finish ;
   int r ;
   int l ;
};
typedef struct __anonstruct_perf_intv_t_1051263395 perf_intv_t;
struct __anonstruct_perf_intv_v_95612989 {
   size_t n ;
   size_t m ;
   perf_intv_t *a ;
};
typedef struct __anonstruct_perf_intv_v_95612989 perf_intv_v;
struct __anonstruct_uint64_v_941540291 {
   size_t n ;
   size_t m ;
   uint64_t *a ;
};
typedef struct __anonstruct_uint64_v_941540291 uint64_v;
struct __anonstruct_kdq_int_t_502121680 {
   uint64_t front : 58 ;
   uint64_t bits : 6 ;
   uint64_t count ;
   uint64_t mask ;
   int *a ;
   void *km ;
};
typedef struct __anonstruct_kdq_int_t_502121680 kdq_int_t;
struct sdust_buf_s {
   kdq_int_t *w ;
   perf_intv_v P ;
   uint64_v res ;
   void *km ;
};
struct __anonstruct_tiny_queue_t_994244249 {
   int front ;
   int count ;
   int a[32] ;
};
typedef struct __anonstruct_tiny_queue_t_994244249 tiny_queue_t;
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#pragma merger("0","/tmp/cil-k0B5Y2VV.i","-g,-Wall,-O2,-Wc++-compat")
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1))) strtoll)(char const   * __restrict  __nptr ,
                                                                                          char ** __restrict  __endptr ,
                                                                                          int __base ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) atoi)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return ((int )tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long ( __attribute__((__nonnull__(1), __gnu_inline__)) atol)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long long ( __attribute__((__nonnull__(1), __gnu_inline__)) atoll)(char const   *__nptr ) 
{ 
  long long tmp ;

  {
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
  __l = (size_t )0;
  __u = __nmemb;
  while (__l < __u) {
    __idx = (__l + __u) / 2UL;
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
    __comparison = (*__compar)(__key, __p);
    if (__comparison < 0) {
      __u = __idx;
    } else
    if (__comparison > 0) {
      __l = __idx + 1UL;
    } else {
      return ((void *)__p);
    }
  }
  return ((void *)0);
}
}
extern  __attribute__((__nothrow__)) int abs(int __x )  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern double ( __attribute__((__nonnull__(1), __gnu_inline__)) atof)(char const   *__nptr ) 
{ 
  double tmp ;

  {
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) double log(double __x ) ;
extern FILE *stdin ;
extern FILE *stdout ;
extern FILE *stderr ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) ;
extern int getc(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
extern int fputc(int __c , FILE *__stream ) ;
extern int putc(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
extern int __uflow(FILE * ) ;
extern int __overflow(FILE * , int  ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) 
{ 
  int tmp ;

  {
  tmp = vfprintf((FILE * __restrict  )stdout, __fmt, __arg);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) 
{ 
  int tmp ;

  {
  tmp = getc(stdin);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(__fp);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = __fp->_IO_read_ptr;
    (__fp->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(stdin);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = stdin->_IO_read_ptr;
    (stdin->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) 
{ 
  int tmp ;

  {
  tmp = putc(__c, stdout);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = __stream->_IO_write_ptr;
    (__stream->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = stdout->_IO_write_ptr;
    (stdout->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 16) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 32) != 0);
}
}
int mm_dbg_flag ;
int mm_idx_getseq(mm_idx_t const   *mi , uint32_t rid , uint32_t st , uint32_t en ,
                  uint8_t *seq ) ;
int mm_idx_bed_junc(mm_idx_t const   *mi , int32_t ctg , int32_t st , int32_t en ,
                    uint8_t *s ) ;
unsigned char seq_nt4_table[256] ;
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) tolower)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_tolower_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
    tmp___0 = (__int32_t const   )__c;
  }
  return ((int )tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) toupper)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_toupper_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
    tmp___0 = (__int32_t const   )__c;
  }
  return ((int )tmp___0);
}
}
double mm_event_identity(mm_reg1_t const   *r ) ;
int mm_idx_getseq2(mm_idx_t const   *mi , int is_rev , uint32_t rid , uint32_t st ,
                   uint32_t en , uint8_t *seq ) ;
mm_reg1_t *mm_align_skeleton(void *km , mm_mapopt_t const   *opt , mm_idx_t const   *mi ,
                             int qlen , char const   *qstr , int *n_regs_ , mm_reg1_t *regs ,
                             mm128_t *a ) ;
void mm_split_reg(mm_reg1_t *r , mm_reg1_t *r2 , int n , int qlen , mm128_t *a , int is_qstrand ) ;
int mm_squeeze_a(void *km , int n_regs , mm_reg1_t *regs , mm128_t *a ) ;
void mm_filter_regs(mm_mapopt_t const   *opt , int qlen , int *n_regs , mm_reg1_t *regs ) ;
void mm_hit_sort(void *km , int *n_regs , mm_reg1_t *r , float alt_diff_frac ) ;
void mm_update_dp_max(int qlen , int n_regs , mm_reg1_t *regs , float frac , int a ,
                      int b ) ;
__inline static float mg_log2(float x ) 
{ 
  union __anonunion_z_307641061 z ;
  float log_2 ;

  {
  z.f = x;
  log_2 = (float )(((z.i >> 23) & 255U) - 128U);
  z.i &= (unsigned int )(~ (255 << 23));
  z.i += (uint32_t )(127 << 23);
  log_2 += (- 0.34484843f * z.f + 2.02466578f) * z.f - 0.67487759f;
  return (log_2);
}
}
extern void ksw_extz2_sse(void *km , int qlen , uint8_t const   *query , int tlen ,
                          uint8_t const   *target , int8_t m , int8_t const   *mat ,
                          int8_t q , int8_t e , int w , int zdrop , int end_bonus ,
                          int flag , ksw_extz_t *ez ) ;
extern void ksw_extd2_sse(void *km , int qlen , uint8_t const   *query , int tlen ,
                          uint8_t const   *target , int8_t m , int8_t const   *mat ,
                          int8_t gapo , int8_t gape , int8_t gapo2 , int8_t gape2 ,
                          int w , int zdrop , int end_bonus , int flag , ksw_extz_t *ez ) ;
extern void ksw_exts2_sse(void *km , int qlen , uint8_t const   *query , int tlen ,
                          uint8_t const   *target , int8_t m , int8_t const   *mat ,
                          int8_t gapo , int8_t gape , int8_t gapo2 , int8_t noncan ,
                          int zdrop , int8_t junc_bonus , int flag , uint8_t const   *junc ,
                          ksw_extz_t *ez ) ;
extern void *ksw_ll_qinit(void *km , int size , int qlen , uint8_t const   *query ,
                          int m , int8_t const   *mat ) ;
extern int ksw_ll_i16(void *q , int tlen , uint8_t const   *target , int gapo , int gape ,
                      int *qe , int *te ) ;
void *kmalloc(void *_km , size_t n_bytes ) ;
void *krealloc(void *_km , void *ap , size_t n_bytes ) ;
void kfree(void *_km , void *ap ) ;
__inline static uint32_t *ksw_push_cigar(void *km , int *n_cigar , int *m_cigar ,
                                         uint32_t *cigar , uint32_t op , int len ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
  if (*n_cigar == 0) {
    goto _L;
  } else
  if (op != (*(cigar + (*n_cigar - 1)) & 15U)) {
    _L: /* CIL Label */ 
    if (*n_cigar == *m_cigar) {
      if (*m_cigar) {
        *m_cigar <<= 1;
      } else {
        *m_cigar = 4;
      }
      tmp = krealloc(km, (void *)cigar, (size_t )(*m_cigar << 2));
      cigar = (uint32_t *)tmp;
    }
    tmp___0 = *n_cigar;
    (*n_cigar) ++;
    *(cigar + tmp___0) = (unsigned int )(len << 4) | op;
  } else {
    *(cigar + (*n_cigar - 1)) += (uint32_t )(len << 4);
  }
  return (cigar);
}
}
__inline static void ksw_reset_extz(ksw_extz_t *ez ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp___1 = -1;
  ez->mte_q = tmp___1;
  tmp___0 = tmp___1;
  ez->mqe_t = tmp___0;
  tmp = tmp___0;
  ez->max_t = tmp;
  ez->max_q = tmp;
  ez->max = (uint32_t )0;
  tmp___3 = -1073741824;
  ez->mte = tmp___3;
  tmp___2 = tmp___3;
  ez->mqe = tmp___2;
  ez->score = tmp___2;
  ez->n_cigar = 0;
  ez->zdropped = (uint32_t )0;
  ez->reach_end = 0;
  return;
}
}
static void ksw_gen_simple_mat(int m , int8_t *mat , int8_t a , int8_t b , int8_t sc_ambi ) 
{ 
  int i ;
  int j ;

  {
  if ((int )a < 0) {
    a = (int8_t )(- ((int )a));
  } else {
    a = a;
  }
  if ((int )b > 0) {
    b = (int8_t )(- ((int )b));
  } else {
    b = b;
  }
  if ((int )sc_ambi > 0) {
    sc_ambi = (int8_t )(- ((int )sc_ambi));
  } else {
    sc_ambi = sc_ambi;
  }
  i = 0;
  while (i < m - 1) {
    j = 0;
    while (j < m - 1) {
      if (i == j) {
        *(mat + (i * m + j)) = a;
      } else {
        *(mat + (i * m + j)) = b;
      }
      j ++;
    }
    *(mat + ((i * m + m) - 1)) = sc_ambi;
    i ++;
  }
  j = 0;
  while (j < m) {
    *(mat + ((m - 1) * m + j)) = sc_ambi;
    j ++;
  }
  return;
}
}
__inline static void mm_seq_rev(uint32_t len , uint8_t *seq ) 
{ 
  uint32_t i ;
  uint8_t t ;

  {
  i = (uint32_t )0;
  while (i < len >> 1) {
    t = *(seq + i);
    *(seq + i) = *(seq + ((len - 1U) - i));
    *(seq + ((len - 1U) - i)) = t;
    i ++;
  }
  return;
}
}
__inline static void update_max_zdrop(int32_t score , int i , int j , int32_t *max ,
                                      int *max_i , int *max_j , int e , int *max_zdrop ,
                                      int (*pos)[2] ) 
{ 
  int li ;
  int lj ;
  int diff ;
  int tmp ;
  int z ;

  {
  if (score < *max) {
    li = i - *max_i;
    lj = j - *max_j;
    if (li > lj) {
      tmp = li - lj;
    } else {
      tmp = lj - li;
    }
    diff = tmp;
    z = (*max - score) - diff * e;
    if (z > *max_zdrop) {
      *max_zdrop = z;
      (*(pos + 0))[0] = *max_i;
      (*(pos + 0))[1] = i;
      (*(pos + 1))[0] = *max_j;
      (*(pos + 1))[1] = j;
    }
  } else {
    *max = score;
    *max_i = i;
    *max_j = j;
  }
  return;
}
}
static int mm_test_zdrop(void *km , mm_mapopt_t const   *opt , uint8_t const   *qseq ,
                         uint8_t const   *tseq , uint32_t n_cigar , uint32_t *cigar ,
                         int8_t const   *mat ) 
{ 
  uint32_t k ;
  int32_t score ;
  int32_t max ;
  int32_t max_i ;
  int32_t max_j ;
  int32_t i ;
  int32_t j ;
  int32_t max_zdrop ;
  int pos[2][2] ;
  int q_len ;
  int t_len ;
  uint32_t l ;
  uint32_t op ;
  uint32_t len ;
  uint8_t *qseq2 ;
  void *qp ;
  int q_off ;
  int t_off ;
  void *tmp ;
  int c ;
  int tmp___0 ;

  {
  score = 0;
  max = (-0x7FFFFFFF-1);
  max_i = -1;
  max_j = -1;
  i = 0;
  j = 0;
  max_zdrop = 0;
  pos[0][0] = -1;
  pos[0][1] = -1;
  pos[1][0] = -1;
  pos[1][1] = -1;
  k = (uint32_t )0;
  score = 0;
  while (k < n_cigar) {
    op = *(cigar + k) & 15U;
    len = *(cigar + k) >> 4;
    if (op == 0U) {
      l = (uint32_t )0;
      while (l < len) {
        score += (int32_t )*(mat + ((int const   )*(tseq + ((uint32_t )i + l)) * 5 + (int const   )*(qseq + ((uint32_t )j + l))));
        update_max_zdrop(score, (int )((uint32_t )i + l), (int )((uint32_t )j + l),
                         & max, & max_i, & max_j, (int )opt->e, & max_zdrop, (int (*)[2])(pos));
        l ++;
      }
      i = (int32_t )((uint32_t )i + len);
      j = (int32_t )((uint32_t )j + len);
    } else
    if (op == 1U) {
      goto _L;
    } else
    if (op == 2U) {
      goto _L;
    } else
    if (op == 3U) {
      _L: /* CIL Label */ 
      score = (int32_t )((uint32_t )score - ((uint32_t )opt->q + (uint32_t )opt->e * len));
      if (op == 1U) {
        j = (int32_t )((uint32_t )j + len);
      } else {
        i = (int32_t )((uint32_t )i + len);
      }
      update_max_zdrop(score, i, j, & max, & max_i, & max_j, (int )opt->e, & max_zdrop,
                       (int (*)[2])(pos));
    }
    k ++;
  }
  q_len = pos[1][1] - pos[1][0];
  t_len = pos[0][1] - pos[0][0];
  if (! (opt->flag & 3149952L)) {
    if (max_zdrop > (int32_t )opt->zdrop_inv) {
      if (q_len < (int )opt->max_gap) {
        if (t_len < (int )opt->max_gap) {
          tmp = kmalloc(km, (size_t )q_len);
          qseq2 = (uint8_t *)tmp;
          i = 0;
          while (i < q_len) {
            c = (int )*(qseq + ((pos[1][1] - i) - 1));
            if (c >= 4) {
              *(qseq2 + i) = (uint8_t )4;
            } else {
              *(qseq2 + i) = (uint8_t )(3 - c);
            }
            i ++;
          }
          qp = ksw_ll_qinit(km, 2, q_len, (uint8_t const   *)qseq2, 5, mat);
          score = ksw_ll_i16(qp, t_len, tseq + pos[0][0], (int )opt->q, (int )opt->e,
                             & q_off, & t_off);
          kfree(km, (void *)qseq2);
          kfree(km, qp);
          if (score >= (int32_t )(opt->min_chain_score * opt->a)) {
            if (score >= (int32_t )opt->min_dp_max) {
              return (2);
            }
          }
        }
      }
    }
  }
  if (max_zdrop > (int32_t )opt->zdrop) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
static void mm_fix_cigar(mm_reg1_t *r , uint8_t const   *qseq , uint8_t const   *tseq ,
                         int *qshift , int *tshift ) 
{ 
  mm_extra_t *p ;
  int32_t toff ;
  int32_t qoff ;
  int32_t to_shrink ;
  uint32_t k ;
  int tmp ;
  uint32_t op ;
  uint32_t len ;
  int l ;
  int prev_len ;
  uint32_t l___0 ;
  uint32_t s[3] ;
  uint32_t op___0 ;
  int32_t l___1 ;
  int32_t tmp___1 ;
  int32_t tmp___2 ;
  int32_t l___2 ;

  {
  p = r->p;
  toff = 0;
  qoff = 0;
  to_shrink = 0;
  tmp = 0;
  *tshift = tmp;
  *qshift = tmp;
  if (p->n_cigar <= 1U) {
    return;
  }
  k = (uint32_t )0;
  while (k < p->n_cigar) {
    op = p->cigar[k] & 15U;
    len = p->cigar[k] >> 4;
    if (len == 0U) {
      to_shrink = 1;
    }
    if (op == 0U) {
      toff = (int32_t )((uint32_t )toff + len);
      qoff = (int32_t )((uint32_t )qoff + len);
    } else
    if (op == 1U) {
      goto _L;
    } else
    if (op == 2U) {
      _L: /* CIL Label */ 
      if (k > 0U) {
        if (k < p->n_cigar - 1U) {
          if ((p->cigar[k - 1U] & 15U) == 0U) {
            if ((p->cigar[k + 1U] & 15U) == 0U) {
              prev_len = (int )(p->cigar[k - 1U] >> 4);
              if (op == 1U) {
                l = 0;
                while (l < prev_len) {
                  if ((int const   )*(qseq + ((qoff - 1) - l)) != (int const   )*(qseq + ((((uint32_t )qoff + len) - 1U) - (uint32_t )l))) {
                    break;
                  }
                  l ++;
                }
              } else {
                l = 0;
                while (l < prev_len) {
                  if ((int const   )*(tseq + ((toff - 1) - l)) != (int const   )*(tseq + ((((uint32_t )toff + len) - 1U) - (uint32_t )l))) {
                    break;
                  }
                  l ++;
                }
              }
              if (l > 0) {
                p->cigar[k - 1U] -= (uint32_t )(l << 4);
                p->cigar[k + 1U] += (uint32_t )(l << 4);
                qoff -= l;
                toff -= l;
              }
              if (l == prev_len) {
                to_shrink = 1;
              }
            }
          }
        }
      }
      if (op == 1U) {
        qoff = (int32_t )((uint32_t )qoff + len);
      } else {
        toff = (int32_t )((uint32_t )toff + len);
      }
    } else
    if (op == 3U) {
      toff = (int32_t )((uint32_t )toff + len);
    }
    k ++;
  }
  if (qoff == r->qe - r->qs) {
    if (! (toff == r->re - r->rs)) {
      __assert_fail("qoff == r->qe - r->qs && toff == r->re - r->rs", "align.c", 125U,
                    "mm_fix_cigar");
    }
  } else {
    __assert_fail("qoff == r->qe - r->qs && toff == r->re - r->rs", "align.c", 125U,
                  "mm_fix_cigar");
  }
  k = (uint32_t )0;
  while (k < p->n_cigar - 2U) {
    if ((p->cigar[k] & 15U) > 0U) {
      if ((p->cigar[k] & 15U) + (p->cigar[k + 1U] & 15U) == 3U) {
        s[0] = (uint32_t )0;
        s[1] = (uint32_t )0;
        s[2] = (uint32_t )0;
        l___0 = k;
        while (l___0 < p->n_cigar) {
          op___0 = p->cigar[l___0] & 15U;
          if (op___0 == 1U) {
            s[op___0] += p->cigar[l___0] >> 4;
          } else
          if (op___0 == 2U) {
            s[op___0] += p->cigar[l___0] >> 4;
          } else
          if (p->cigar[l___0] >> 4 == 0U) {
            s[op___0] += p->cigar[l___0] >> 4;
          } else {
            break;
          }
          l___0 ++;
        }
        if (s[1] > 0U) {
          if (s[2] > 0U) {
            if (l___0 - k > 2U) {
              p->cigar[k] = (s[1] << 4) | 1U;
              p->cigar[k + 1U] = (s[2] << 4) | 2U;
              k += 2U;
              while (k < l___0) {
                p->cigar[k] &= 15U;
                k ++;
              }
              to_shrink = 1;
            }
          }
        }
        k = l___0;
      }
    }
    k ++;
  }
  if (to_shrink) {
    l___1 = 0;
    k = (uint32_t )0;
    while (k < p->n_cigar) {
      if (p->cigar[k] >> 4 != 0U) {
        tmp___1 = l___1;
        l___1 ++;
        p->cigar[tmp___1] = p->cigar[k];
      }
      k ++;
    }
    p->n_cigar = (uint32_t )l___1;
    l___1 = 0;
    k = (uint32_t )l___1;
    while (k < p->n_cigar) {
      if (k == p->n_cigar - 1U) {
        tmp___2 = l___1;
        l___1 ++;
        p->cigar[tmp___2] = p->cigar[k];
      } else
      if ((p->cigar[k] & 15U) != (p->cigar[k + 1U] & 15U)) {
        tmp___2 = l___1;
        l___1 ++;
        p->cigar[tmp___2] = p->cigar[k];
      } else {
        p->cigar[k + 1U] += (p->cigar[k] >> 4) << 4;
      }
      k ++;
    }
    p->n_cigar = (uint32_t )l___1;
  }
  if ((p->cigar[0] & 15U) == 1U) {
    goto _L___0;
  } else
  if ((p->cigar[0] & 15U) == 2U) {
    _L___0: /* CIL Label */ 
    l___2 = (int32_t )(p->cigar[0] >> 4);
    if ((p->cigar[0] & 15U) == 1U) {
      if (r->rev) {
        r->qe -= l___2;
      } else {
        r->qs += l___2;
      }
      *qshift = l___2;
    } else {
      r->rs += l___2;
      *tshift = l___2;
    }
    (p->n_cigar) --;
    memmove((void *)(p->cigar), (void const   *)(p->cigar + 1), (size_t )(p->n_cigar * 4U));
  }
  return;
}
}
static void mm_update_cigar_eqx(mm_reg1_t *r , uint8_t const   *qseq , uint8_t const   *tseq ) 
{ 
  uint32_t n_EQX ;
  uint32_t k ;
  uint32_t l ;
  uint32_t m ;
  uint32_t cap ;
  uint32_t toff ;
  uint32_t qoff ;
  uint32_t n_M ;
  mm_extra_t *p ;
  uint32_t op ;
  uint32_t len ;
  uint32_t op___0 ;
  uint32_t len___0 ;
  void *tmp ;
  uint32_t op___1 ;
  uint32_t len___1 ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;

  {
  n_EQX = (uint32_t )0;
  toff = (uint32_t )0;
  qoff = (uint32_t )0;
  n_M = (uint32_t )0;
  if ((unsigned long )r->p == (unsigned long )((mm_extra_t *)0)) {
    return;
  }
  k = (uint32_t )0;
  while (k < (r->p)->n_cigar) {
    op = (r->p)->cigar[k] & 15U;
    len = (r->p)->cigar[k] >> 4;
    if (op == 0U) {
      while (len > 0U) {
        l = (uint32_t )0;
        while (1) {
          if (l < len) {
            if (! ((int const   )*(qseq + (qoff + l)) == (int const   )*(tseq + (toff + l)))) {
              break;
            }
          } else {
            break;
          }
          l ++;
        }
        if (l > 0U) {
          n_EQX ++;
          len -= l;
          toff += l;
          qoff += l;
        }
        l = (uint32_t )0;
        while (1) {
          if (l < len) {
            if (! ((int const   )*(qseq + (qoff + l)) != (int const   )*(tseq + (toff + l)))) {
              break;
            }
          } else {
            break;
          }
          l ++;
        }
        if (l > 0U) {
          n_EQX ++;
          len -= l;
          toff += l;
          qoff += l;
        }
      }
      n_M ++;
    } else
    if (op == 1U) {
      qoff += len;
    } else
    if (op == 2U) {
      toff += len;
    } else
    if (op == 3U) {
      toff += len;
    }
    k ++;
  }
  if (n_EQX == n_M) {
    k = (uint32_t )0;
    while (k < (r->p)->n_cigar) {
      op___0 = (r->p)->cigar[k] & 15U;
      len___0 = (r->p)->cigar[k] >> 4;
      if (op___0 == 0U) {
        (r->p)->cigar[k] = (len___0 << 4) | 7U;
      }
      k ++;
    }
    return;
  }
  cap = (uint32_t )((unsigned long )((r->p)->n_cigar + (n_EQX - n_M)) + sizeof(mm_extra_t ));
  cap --;
  cap |= cap >> 1;
  cap |= cap >> 2;
  cap |= cap >> 4;
  cap |= cap >> 8;
  cap |= cap >> 16;
  cap ++;
  tmp = calloc((size_t )cap, (size_t )4);
  p = (mm_extra_t *)tmp;
  memcpy((void * __restrict  )p, (void const   * __restrict  )r->p, sizeof(mm_extra_t ));
  p->capacity = cap;
  m = (uint32_t )0;
  qoff = m;
  toff = qoff;
  k = (uint32_t )0;
  while (k < (r->p)->n_cigar) {
    op___1 = (r->p)->cigar[k] & 15U;
    len___1 = (r->p)->cigar[k] >> 4;
    if (op___1 == 0U) {
      while (len___1 > 0U) {
        l = (uint32_t )0;
        while (1) {
          if (l < len___1) {
            if (! ((int const   )*(qseq + (qoff + l)) == (int const   )*(tseq + (toff + l)))) {
              break;
            }
          } else {
            break;
          }
          l ++;
        }
        if (l > 0U) {
          tmp___0 = m;
          m ++;
          p->cigar[tmp___0] = (l << 4) | 7U;
        }
        len___1 -= l;
        toff += l;
        qoff += l;
        l = (uint32_t )0;
        while (1) {
          if (l < len___1) {
            if (! ((int const   )*(qseq + (qoff + l)) != (int const   )*(tseq + (toff + l)))) {
              break;
            }
          } else {
            break;
          }
          l ++;
        }
        if (l > 0U) {
          tmp___1 = m;
          m ++;
          p->cigar[tmp___1] = (l << 4) | 8U;
        }
        len___1 -= l;
        toff += l;
        qoff += l;
      }
      goto __Cont;
    } else
    if (op___1 == 1U) {
      qoff += len___1;
    } else
    if (op___1 == 2U) {
      toff += len___1;
    } else
    if (op___1 == 3U) {
      toff += len___1;
    }
    tmp___2 = m;
    m ++;
    p->cigar[tmp___2] = (r->p)->cigar[k];
    __Cont: /* CIL Label */ 
    k ++;
  }
  p->n_cigar = m;
  free((void *)r->p);
  r->p = p;
  return;
}
}
static void mm_update_extra(mm_reg1_t *r , uint8_t const   *qseq , uint8_t const   *tseq ,
                            int8_t const   *mat , int8_t q , int8_t e , int is_eqx ,
                            int log_gap ) 
{ 
  uint32_t k ;
  uint32_t l ;
  int32_t qshift ;
  int32_t tshift ;
  int32_t toff ;
  int32_t qoff ;
  double s ;
  double max ;
  mm_extra_t *p ;
  int32_t tmp ;
  uint32_t op ;
  uint32_t len ;
  int n_ambi ;
  int n_diff ;
  int cq ;
  int ct ;
  int n_ambi___0 ;
  float tmp___0 ;
  int n_ambi___1 ;
  float tmp___1 ;

  {
  toff = 0;
  qoff = 0;
  s = 0.0;
  max = 0.0;
  p = r->p;
  if ((unsigned long )p == (unsigned long )((mm_extra_t *)0)) {
    return;
  }
  mm_fix_cigar(r, qseq, tseq, & qshift, & tshift);
  qseq += qshift;
  tseq += tshift;
  tmp = 0;
  r->mlen = tmp;
  r->blen = tmp;
  k = (uint32_t )0;
  while (k < p->n_cigar) {
    op = p->cigar[k] & 15U;
    len = p->cigar[k] >> 4;
    if (op == 0U) {
      n_ambi = 0;
      n_diff = 0;
      l = (uint32_t )0;
      while (l < len) {
        cq = (int )*(qseq + ((uint32_t )qoff + l));
        ct = (int )*(tseq + ((uint32_t )toff + l));
        if (ct > 3) {
          n_ambi ++;
        } else
        if (cq > 3) {
          n_ambi ++;
        } else
        if (ct != cq) {
          n_diff ++;
        }
        s += (double )*(mat + (ct * 5 + cq));
        if (s < (double )0) {
          s = (double )0;
        } else
        if (max > s) {
          max = max;
        } else {
          max = s;
        }
        l ++;
      }
      r->blen = (int32_t )((uint32_t )r->blen + (len - (uint32_t )n_ambi));
      r->mlen = (int32_t )((uint32_t )r->mlen + (len - (uint32_t )(n_ambi + n_diff)));
      p->n_ambi += (uint32_t )n_ambi;
      toff = (int32_t )((uint32_t )toff + len);
      qoff = (int32_t )((uint32_t )qoff + len);
    } else
    if (op == 1U) {
      n_ambi___0 = 0;
      l = (uint32_t )0;
      while (l < len) {
        if ((int const   )*(qseq + ((uint32_t )qoff + l)) > 3) {
          n_ambi___0 ++;
        }
        l ++;
      }
      r->blen = (int32_t )((uint32_t )r->blen + (len - (uint32_t )n_ambi___0));
      p->n_ambi += (uint32_t )n_ambi___0;
      if (log_gap) {
        tmp___0 = mg_log2((float )(1.0 + (double )len));
        s -= (double )q + (double )e * (double )tmp___0;
      } else {
        s -= (double )((int )q + (int )e);
      }
      if (s < (double )0) {
        s = (double )0;
      }
      qoff = (int32_t )((uint32_t )qoff + len);
    } else
    if (op == 2U) {
      n_ambi___1 = 0;
      l = (uint32_t )0;
      while (l < len) {
        if ((int const   )*(tseq + ((uint32_t )toff + l)) > 3) {
          n_ambi___1 ++;
        }
        l ++;
      }
      r->blen = (int32_t )((uint32_t )r->blen + (len - (uint32_t )n_ambi___1));
      p->n_ambi += (uint32_t )n_ambi___1;
      if (log_gap) {
        tmp___1 = mg_log2((float )(1.0 + (double )len));
        s -= (double )q + (double )e * (double )tmp___1;
      } else {
        s -= (double )((int )q + (int )e);
      }
      if (s < (double )0) {
        s = (double )0;
      }
      toff = (int32_t )((uint32_t )toff + len);
    } else
    if (op == 3U) {
      toff = (int32_t )((uint32_t )toff + len);
    }
    k ++;
  }
  p->dp_max = (int32_t )(max + .499);
  if (qoff == r->qe - r->qs) {
    if (! (toff == r->re - r->rs)) {
      __assert_fail("qoff == r->qe - r->qs && toff == r->re - r->rs", "align.c", 287U,
                    "mm_update_extra");
    }
  } else {
    __assert_fail("qoff == r->qe - r->qs && toff == r->re - r->rs", "align.c", 287U,
                  "mm_update_extra");
  }
  if (is_eqx) {
    mm_update_cigar_eqx(r, qseq, tseq);
  }
  return;
}
}
static void mm_append_cigar(mm_reg1_t *r , uint32_t n_cigar , uint32_t *cigar ) 
{ 
  mm_extra_t *p ;
  uint32_t capacity ;
  void *tmp ;
  void *tmp___0 ;

  {
  if (n_cigar == 0U) {
    return;
  }
  if ((unsigned long )r->p == (unsigned long )((mm_extra_t *)0)) {
    capacity = (uint32_t )((unsigned long )n_cigar + sizeof(mm_extra_t ) / 4UL);
    capacity --;
    capacity |= capacity >> 1;
    capacity |= capacity >> 2;
    capacity |= capacity >> 4;
    capacity |= capacity >> 8;
    capacity |= capacity >> 16;
    capacity ++;
    tmp = calloc((size_t )capacity, (size_t )4);
    r->p = (mm_extra_t *)tmp;
    (r->p)->capacity = capacity;
  } else
  if ((unsigned long )((r->p)->n_cigar + n_cigar) + sizeof(mm_extra_t ) / 4UL > (unsigned long )(r->p)->capacity) {
    (r->p)->capacity = (uint32_t )((unsigned long )((r->p)->n_cigar + n_cigar) + sizeof(mm_extra_t ) / 4UL);
    ((r->p)->capacity) --;
    (r->p)->capacity |= (r->p)->capacity >> 1;
    (r->p)->capacity |= (r->p)->capacity >> 2;
    (r->p)->capacity |= (r->p)->capacity >> 4;
    (r->p)->capacity |= (r->p)->capacity >> 8;
    (r->p)->capacity |= (r->p)->capacity >> 16;
    ((r->p)->capacity) ++;
    tmp___0 = realloc((void *)r->p, (size_t )((r->p)->capacity * 4U));
    r->p = (mm_extra_t *)tmp___0;
  }
  p = r->p;
  if (p->n_cigar > 0U) {
    if ((p->cigar[p->n_cigar - 1U] & 15U) == (*(cigar + 0) & 15U)) {
      p->cigar[p->n_cigar - 1U] += (*(cigar + 0) >> 4) << 4;
      if (n_cigar > 1U) {
        memcpy((void * __restrict  )(p->cigar + p->n_cigar), (void const   * __restrict  )(cigar + 1),
               (size_t )((n_cigar - 1U) * 4U));
      }
      p->n_cigar += n_cigar - 1U;
    } else {
      memcpy((void * __restrict  )(p->cigar + p->n_cigar), (void const   * __restrict  )cigar,
             (size_t )(n_cigar * 4U));
      p->n_cigar += n_cigar;
    }
  } else {
    memcpy((void * __restrict  )(p->cigar + p->n_cigar), (void const   * __restrict  )cigar,
           (size_t )(n_cigar * 4U));
    p->n_cigar += n_cigar;
  }
  return;
}
}
static void mm_align_pair(void *km , mm_mapopt_t const   *opt , int qlen , uint8_t const   *qseq ,
                          int tlen , uint8_t const   *tseq , uint8_t const   *junc ,
                          int8_t const   *mat , int w , int end_bonus , int zdrop ,
                          int flag , ksw_extz_t *ez ) 
{ 
  int i ;
  int i___0 ;

  {
  if (mm_dbg_flag & 8) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"===> q=(%d,%d), e=(%d,%d), bw=%d, flag=%d, zdrop=%d <===\n",
            opt->q, opt->q2, opt->e, opt->e2, w, flag, opt->zdrop);
    i = 0;
    while (i < tlen) {
      fputc((int )*("ACGTN" + *(tseq + i)), stderr);
      i ++;
    }
    fputc('\n', stderr);
    i = 0;
    while (i < qlen) {
      fputc((int )*("ACGTN" + *(qseq + i)), stderr);
      i ++;
    }
    fputc('\n', stderr);
  }
  if (opt->max_sw_mat > 0L) {
    if ((int64_t )tlen * (int64_t )qlen > (int64_t )opt->max_sw_mat) {
      ksw_reset_extz(ez);
      ez->zdropped = (uint32_t )1;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (opt->flag & 128L) {
    ksw_exts2_sse(km, qlen, qseq, tlen, tseq, (int8_t )5, mat, (int8_t )opt->q, (int8_t )opt->e,
                  (int8_t )opt->q2, (int8_t )opt->noncan, zdrop, (int8_t )opt->junc_bonus,
                  flag, junc, ez);
  } else
  if (opt->q == opt->q2) {
    if (opt->e == opt->e2) {
      ksw_extz2_sse(km, qlen, qseq, tlen, tseq, (int8_t )5, mat, (int8_t )opt->q,
                    (int8_t )opt->e, w, zdrop, end_bonus, flag, ez);
    } else {
      ksw_extd2_sse(km, qlen, qseq, tlen, tseq, (int8_t )5, mat, (int8_t )opt->q,
                    (int8_t )opt->e, (int8_t )opt->q2, (int8_t )opt->e2, w, zdrop,
                    end_bonus, flag, ez);
    }
  } else {
    ksw_extd2_sse(km, qlen, qseq, tlen, tseq, (int8_t )5, mat, (int8_t )opt->q, (int8_t )opt->e,
                  (int8_t )opt->q2, (int8_t )opt->e2, w, zdrop, end_bonus, flag, ez);
  }
  if (mm_dbg_flag & 8) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"score=%d, cigar=",
            ez->score);
    i___0 = 0;
    while (i___0 < ez->n_cigar) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%d%c", *(ez->cigar + i___0) >> 4,
              (int const   )*("MIDNSHP=XB" + (*(ez->cigar + i___0) & 15U)));
      i___0 ++;
    }
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  }
  return;
}
}
__inline static int mm_get_hplen_back(mm_idx_t const   *mi , uint32_t rid , uint32_t x ) 
{ 
  int64_t i ;
  int64_t off0 ;
  int64_t off ;
  int c ;

  {
  off0 = (int64_t )(mi->seq + rid)->offset;
  off = off0 + (int64_t )x;
  c = (int )((*(mi->S + (off >> 3)) >> ((off & 7L) << 2)) & 15U);
  i = off - 1L;
  while (i >= off0) {
    if (((*(mi->S + (i >> 3)) >> ((i & 7L) << 2)) & 15U) != (unsigned int )c) {
      break;
    }
    i --;
  }
  return ((int )(off - i));
}
}
__inline static void mm_adjust_minier(mm_idx_t const   *mi , uint8_t * const  *qseq0 ,
                                      mm128_t *a , int32_t *r , int32_t *q ) 
{ 
  uint8_t const   *qseq ;
  int i ;
  int c ;

  {
  if (mi->flag & 1) {
    qseq = (uint8_t const   *)*(qseq0 + (a->x >> 63));
    *q = (int32_t )a->y;
    i = *q - 1;
    c = (int )*(qseq + *q);
    while (i > 0) {
      if ((int const   )*(qseq + i) != (int const   )c) {
        break;
      }
      i --;
    }
    *q = i + 1;
    c = mm_get_hplen_back(mi, (uint32_t )((a->x << 1) >> 33), (uint32_t )((int32_t )a->x));
    *r = ((int32_t )a->x + 1) - c;
  } else {
    *r = (int32_t )a->x - (int32_t )(mi->k >> 1);
    *q = (int32_t )a->y - (int32_t )(mi->k >> 1);
  }
  return;
}
}
static int *collect_long_gaps(void *km , int as1 , int cnt1 , mm128_t *a , int min_gap ,
                              int *n_ ) 
{ 
  int i ;
  int n ;
  int *K ;
  int gap ;
  void *tmp ;
  int gap___0 ;
  int tmp___0 ;

  {
  *n_ = 0;
  i = 1;
  n = 0;
  while (i < cnt1) {
    gap = (int )(((uint64_t )((int32_t )(a + (as1 + i))->y) - (a + ((as1 + i) - 1))->y) - ((uint64_t )((int32_t )(a + (as1 + i))->x) - (a + ((as1 + i) - 1))->x));
    if (gap < - min_gap) {
      n ++;
    } else
    if (gap > min_gap) {
      n ++;
    }
    i ++;
  }
  if (n <= 1) {
    return ((int *)0);
  }
  tmp = kmalloc(km, (unsigned long )n * sizeof(int ));
  K = (int *)tmp;
  i = 1;
  n = 0;
  while (i < cnt1) {
    gap___0 = (int )(((uint64_t )((int32_t )(a + (as1 + i))->y) - (a + ((as1 + i) - 1))->y) - ((uint64_t )((int32_t )(a + (as1 + i))->x) - (a + ((as1 + i) - 1))->x));
    if (gap___0 < - min_gap) {
      tmp___0 = n;
      n ++;
      *(K + tmp___0) = i;
    } else
    if (gap___0 > min_gap) {
      tmp___0 = n;
      n ++;
      *(K + tmp___0) = i;
    }
    i ++;
  }
  *n_ = n;
  return (K);
}
}
static void mm_filter_bad_seeds(void *km , int as1 , int cnt1 , mm128_t *a , int min_gap ,
                                int diff_thres , int max_ext_len , int max_ext_cnt ) 
{ 
  int max_st ;
  int max_en ;
  int n ;
  int i ;
  int k ;
  int max ;
  int *K ;
  int gap ;
  int l ;
  int n_ins ;
  int n_del ;
  int qs ;
  int rs ;
  int max_diff ;
  int max_diff_l ;
  int j ;
  int diff ;
  int tmp ;

  {
  K = collect_long_gaps(km, as1, cnt1, a, min_gap, & n);
  if ((unsigned long )K == (unsigned long )((int *)0)) {
    return;
  }
  max = 0;
  max_en = -1;
  max_st = max_en;
  k = 0;
  while (1) {
    n_ins = 0;
    n_del = 0;
    max_diff = 0;
    max_diff_l = -1;
    if (k == n) {
      goto _L;
    } else
    if (k >= max_en) {
      _L: /* CIL Label */ 
      if (max_en > 0) {
        i = *(K + max_st);
        while (i < *(K + max_en)) {
          (a + (as1 + i))->y = (uint64_t )((unsigned long long )(a + (as1 + i))->y | (1ULL << 41));
          i ++;
        }
      }
      max = 0;
      max_en = -1;
      max_st = max_en;
      if (k == n) {
        break;
      }
    }
    i = *(K + k);
    gap = ((int32_t )(a + (as1 + i))->y - (int32_t )(a + ((as1 + i) - 1))->y) - (int32_t )((a + (as1 + i))->x - (a + ((as1 + i) - 1))->x);
    if (gap > 0) {
      n_ins += gap;
    } else {
      n_del += - gap;
    }
    qs = (int32_t )(a + ((as1 + i) - 1))->y;
    rs = (int32_t )(a + ((as1 + i) - 1))->x;
    l = k + 1;
    while (1) {
      if (l < n) {
        if (! (l <= k + max_ext_cnt)) {
          break;
        }
      } else {
        break;
      }
      j = *(K + l);
      if ((int32_t )(a + (as1 + j))->y - qs > max_ext_len) {
        break;
      } else
      if ((int32_t )(a + (as1 + j))->x - rs > max_ext_len) {
        break;
      }
      gap = ((int32_t )(a + (as1 + j))->y - (int32_t )(a + ((as1 + j) - 1))->y) - (int32_t )((a + (as1 + j))->x - (a + ((as1 + j) - 1))->x);
      if (gap > 0) {
        n_ins += gap;
      } else {
        n_del += - gap;
      }
      tmp = abs(n_ins - n_del);
      diff = (n_ins + n_del) - tmp;
      if (max_diff < diff) {
        max_diff = diff;
        max_diff_l = l;
      }
      l ++;
    }
    if (max_diff > diff_thres) {
      if (max_diff > max) {
        max = max_diff;
        max_st = k;
        max_en = max_diff_l;
      }
    }
    k ++;
  }
  kfree(km, (void *)K);
  return;
}
}
static void mm_filter_bad_seeds_alt(void *km , int as1 , int cnt1 , mm128_t *a , int min_gap ,
                                    int max_ext ) 
{ 
  int n ;
  int k ;
  int *K ;
  int i ;
  int l ;
  int gap1 ;
  int re1 ;
  int qe1 ;
  int j ;
  int gap2 ;
  int q_span_pre ;
  int rs2 ;
  int qs2 ;
  int m ;
  int j___0 ;
  int end ;

  {
  K = collect_long_gaps(km, as1, cnt1, a, min_gap, & n);
  if ((unsigned long )K == (unsigned long )((int *)0)) {
    return;
  }
  k = 0;
  while (k < n) {
    i = *(K + k);
    gap1 = ((int32_t )(a + (as1 + i))->y - (int32_t )(a + ((as1 + i) - 1))->y) - ((int32_t )(a + (as1 + i))->x - (int32_t )(a + ((as1 + i) - 1))->x);
    re1 = (int32_t )(a + (as1 + i))->x;
    qe1 = (int32_t )(a + (as1 + i))->y;
    if (gap1 > 0) {
      gap1 = gap1;
    } else {
      gap1 = - gap1;
    }
    l = k + 1;
    while (l < n) {
      j = *(K + l);
      if ((int32_t )(a + (as1 + j))->y - qe1 > max_ext) {
        break;
      } else
      if ((int32_t )(a + (as1 + j))->x - re1 > max_ext) {
        break;
      }
      gap2 = ((int32_t )(a + (as1 + j))->y - (int32_t )(a + ((as1 + j) - 1))->y) - (int32_t )((a + (as1 + j))->x - (a + ((as1 + j) - 1))->x);
      q_span_pre = (int )(((a + ((as1 + j) - 1))->y >> 32) & 255UL);
      rs2 = (int32_t )(a + ((as1 + j) - 1))->x + q_span_pre;
      qs2 = (int32_t )(a + ((as1 + j) - 1))->y + q_span_pre;
      if (rs2 - re1 < qs2 - qe1) {
        m = rs2 - re1;
      } else {
        m = qs2 - qe1;
      }
      if (gap2 > 0) {
        gap2 = gap2;
      } else {
        gap2 = - gap2;
      }
      if (m > gap1 + gap2) {
        break;
      }
      re1 = (int32_t )(a + (as1 + j))->x;
      qe1 = (int32_t )(a + (as1 + j))->y;
      gap1 = gap2;
      l ++;
    }
    if (l > k + 1) {
      end = *(K + (l - 1));
      j___0 = *(K + k);
      while (j___0 < end) {
        (a + (as1 + j___0))->y = (uint64_t )((unsigned long long )(a + (as1 + j___0))->y | (1ULL << 41));
        j___0 ++;
      }
      (a + (as1 + end))->y = (uint64_t )((unsigned long long )(a + (as1 + end))->y | (1ULL << 40));
    }
    k = l;
  }
  kfree(km, (void *)K);
  return;
}
}
static void mm_fix_bad_ends(mm_reg1_t const   *r , mm128_t const   *a , int bw , int min_match ,
                            int32_t *as , int32_t *cnt ) 
{ 
  int32_t i ;
  int32_t l ;
  int32_t m ;
  int32_t lq ;
  int32_t lr ;
  int32_t min ;
  int32_t max ;
  int32_t q_span ;
  int32_t tmp ;
  int32_t lq___0 ;
  int32_t lr___0 ;
  int32_t min___0 ;
  int32_t max___0 ;
  int32_t q_span___0 ;
  int32_t tmp___0 ;

  {
  *as = (int32_t )r->as;
  *cnt = (int32_t )r->cnt;
  if (r->cnt < 3) {
    return;
  }
  l = (int32_t )(((a + r->as)->y >> 32) & 255UL);
  m = l;
  i = (int32_t )(r->as + 1);
  while (i < (int32_t )((r->as + r->cnt) - 1)) {
    q_span = (int32_t )(((a + i)->y >> 32) & 255UL);
    if ((unsigned long long )(a + i)->y & (1ULL << 40)) {
      break;
    }
    lr = (int32_t )(a + i)->x - (int32_t )(a + (i - 1))->x;
    lq = (int32_t )(a + i)->y - (int32_t )(a + (i - 1))->y;
    if (lr < lq) {
      min = lr;
    } else {
      min = lq;
    }
    if (lr > lq) {
      max = lr;
    } else {
      max = lq;
    }
    if (max - min > l >> 1) {
      *as = i;
    }
    l += min;
    if (min < q_span) {
      tmp = min;
    } else {
      tmp = q_span;
    }
    m += tmp;
    if (l >= bw << 1) {
      break;
    } else
    if (m >= min_match) {
      if (m >= bw) {
        break;
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (m >= (int32_t )(r->mlen >> 1)) {
      break;
    }
    i ++;
  }
  *cnt = (int32_t )((r->as + r->cnt) - (int32_t const   )*as);
  l = (int32_t )(((a + ((r->as + r->cnt) - 1))->y >> 32) & 255UL);
  m = l;
  i = (int32_t )((r->as + r->cnt) - 2);
  while (i > *as) {
    q_span___0 = (int32_t )(((a + (i + 1))->y >> 32) & 255UL);
    if ((unsigned long long )(a + (i + 1))->y & (1ULL << 40)) {
      break;
    }
    lr___0 = (int32_t )(a + (i + 1))->x - (int32_t )(a + i)->x;
    lq___0 = (int32_t )(a + (i + 1))->y - (int32_t )(a + i)->y;
    if (lr___0 < lq___0) {
      min___0 = lr___0;
    } else {
      min___0 = lq___0;
    }
    if (lr___0 > lq___0) {
      max___0 = lr___0;
    } else {
      max___0 = lq___0;
    }
    if (max___0 - min___0 > l >> 1) {
      *cnt = (i + 1) - *as;
    }
    l += min___0;
    if (min___0 < q_span___0) {
      tmp___0 = min___0;
    } else {
      tmp___0 = q_span___0;
    }
    m += tmp___0;
    if (l >= bw << 1) {
      break;
    } else
    if (m >= min_match) {
      if (m >= bw) {
        break;
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (m >= (int32_t )(r->mlen >> 1)) {
      break;
    }
    i --;
  }
  return;
}
}
static void mm_max_stretch(mm_reg1_t const   *r , mm128_t const   *a , int32_t *as ,
                           int32_t *cnt ) 
{ 
  int32_t i ;
  int32_t score ;
  int32_t max_score ;
  int32_t len ;
  int32_t max_i ;
  int32_t max_len ;
  int32_t lq ;
  int32_t lr ;
  int32_t q_span ;
  int32_t tmp ;

  {
  *as = (int32_t )r->as;
  *cnt = (int32_t )r->cnt;
  if (r->cnt < 2) {
    return;
  }
  max_score = -1;
  max_i = -1;
  max_len = 0;
  score = (int32_t )(((a + r->as)->y >> 32) & 255UL);
  len = 1;
  i = (int32_t )(r->as + 1);
  while (i < (int32_t )(r->as + r->cnt)) {
    q_span = (int32_t )(((a + i)->y >> 32) & 255UL);
    lr = (int32_t )(a + i)->x - (int32_t )(a + (i - 1))->x;
    lq = (int32_t )(a + i)->y - (int32_t )(a + (i - 1))->y;
    if (lq == lr) {
      if (lq < q_span) {
        tmp = lq;
      } else {
        tmp = q_span;
      }
      score += tmp;
      len ++;
    } else {
      if (score > max_score) {
        max_score = score;
        max_len = len;
        max_i = i - len;
      }
      score = q_span;
      len = 1;
    }
    i ++;
  }
  if (score > max_score) {
    max_score = score;
    max_len = len;
    max_i = i - len;
  }
  *as = max_i;
  *cnt = max_len;
  return;
}
}
static int mm_seed_ext_score(void *km , mm_mapopt_t const   *opt , mm_idx_t const   *mi ,
                             int8_t const   *mat , int qlen , uint8_t **qseq0 , mm128_t const   *a ) 
{ 
  uint8_t *qseq ;
  uint8_t *tseq ;
  int q_span ;
  int qs ;
  int qe ;
  int rs ;
  int re ;
  int rid ;
  int score ;
  int q_off ;
  int t_off ;
  int ext_len ;
  void *qp ;
  void *tmp ;

  {
  q_span = (int )((a->y >> 32) & 255UL);
  ext_len = (int )opt->anchor_ext_len;
  rid = (int )((a->x << 1) >> 33);
  re = (int )((uint32_t )a->x + 1U);
  rs = re - q_span;
  qe = (int )((uint32_t )a->y + 1U);
  qs = qe - q_span;
  if (rs - ext_len > 0) {
    rs -= ext_len;
  } else {
    rs = 0;
  }
  if (qs - ext_len > 0) {
    qs -= ext_len;
  } else {
    qs = 0;
  }
  if (re + ext_len < (int32_t )(mi->seq + rid)->len) {
    re += ext_len;
  } else {
    re = (int )(mi->seq + rid)->len;
  }
  if (qe + ext_len < qlen) {
    qe += ext_len;
  } else {
    qe = qlen;
  }
  tmp = kmalloc(km, (size_t )(re - rs));
  tseq = (uint8_t *)tmp;
  if ((long long )opt->flag & 4294967296LL) {
    qseq = *(qseq0 + 0) + qs;
    mm_idx_getseq2(mi, (int )(a->x >> 63), (uint32_t )rid, (uint32_t )rs, (uint32_t )re,
                   tseq);
  } else {
    qseq = *(qseq0 + (a->x >> 63)) + qs;
    mm_idx_getseq(mi, (uint32_t )rid, (uint32_t )rs, (uint32_t )re, tseq);
  }
  qp = ksw_ll_qinit(km, 2, qe - qs, (uint8_t const   *)qseq, 5, (int8_t const   *)mat);
  score = ksw_ll_i16(qp, re - rs, (uint8_t const   *)tseq, (int )opt->q, (int )opt->e,
                     & q_off, & t_off);
  kfree(km, (void *)tseq);
  kfree(km, qp);
  return (score);
}
}
static void mm_fix_bad_ends_splice(void *km , mm_mapopt_t const   *opt , mm_idx_t const   *mi ,
                                   mm_reg1_t const   *r , int8_t const   *mat , int qlen ,
                                   uint8_t **qseq0 , mm128_t const   *a , int *as1 ,
                                   int *cnt1 ) 
{ 
  int score ;
  double log_gap ;

  {
  *as1 = (int )r->as;
  *cnt1 = (int )r->cnt;
  if (r->cnt < 3) {
    return;
  }
  log_gap = log((double )((int32_t )(a + (r->as + 1))->x - (int32_t )(a + r->as)->x));
  if ((double )(((a + r->as)->y >> 32) & 255UL) < log_gap + (double )opt->anchor_ext_shift) {
    score = mm_seed_ext_score(km, opt, mi, mat, qlen, qseq0, a + r->as);
    if ((double )score / (double )*(mat + 0) < log_gap + (double )opt->anchor_ext_shift) {
      (*as1) ++;
      (*cnt1) --;
    }
  }
  log_gap = log((double )((int32_t )(a + ((r->as + r->cnt) - 1))->x - (int32_t )(a + ((r->as + r->cnt) - 2))->x));
  if ((double )(((a + ((r->as + r->cnt) - 1))->y >> 32) & 255UL) < log_gap + (double )opt->anchor_ext_shift) {
    score = mm_seed_ext_score(km, opt, mi, mat, qlen, qseq0, a + ((r->as + r->cnt) - 1));
    if ((double )score / (double )*(mat + 0) < log_gap + (double )opt->anchor_ext_shift) {
      (*cnt1) --;
    }
  }
  return;
}
}
static void mm_align1(void *km , mm_mapopt_t const   *opt , mm_idx_t const   *mi ,
                      int qlen , uint8_t **qseq0 , mm_reg1_t *r , mm_reg1_t *r2 ,
                      int n_a , mm128_t *a , ksw_extz_t *ez , int splice_flag ) 
{ 
  int is_sr ;
  int is_splice ;
  int32_t rid ;
  int32_t rev ;
  int32_t as1 ;
  int32_t cnt1 ;
  uint8_t *tseq ;
  uint8_t *qseq ;
  uint8_t *junc ;
  int32_t i ;
  int32_t l ;
  int32_t bw ;
  int32_t bw_long ;
  int32_t dropped ;
  int32_t extra_flag ;
  int32_t rs0 ;
  int32_t re0 ;
  int32_t qs0 ;
  int32_t qe0 ;
  int32_t rs ;
  int32_t re ;
  int32_t qs ;
  int32_t qe ;
  int32_t rs1 ;
  int32_t qs1 ;
  int32_t re1 ;
  int32_t qe1 ;
  int8_t mat[25] ;
  int tmp___1 ;
  int tmp___2 ;
  int32_t tmp___3 ;
  int32_t tmp___4 ;
  int32_t x ;
  int32_t y ;
  int32_t tmp___6 ;
  int32_t x___0 ;
  int32_t y___0 ;
  int32_t tmp___7 ;
  int max_ext ;
  int32_t tmp___8 ;
  void *tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int32_t tmp___14 ;
  int j ;
  int bw1 ;
  int zdrop_code ;
  int tmp___17 ;
  int tmp___18 ;
  uint32_t capacity ;
  void *tmp___20 ;
  int tmp___21 ;
  int32_t tmp___22 ;

  {
  is_sr = ! (! (opt->flag & 4096L));
  is_splice = ! (! (opt->flag & 128L));
  rid = (int32_t )(((a + r->as)->x << 1) >> 33);
  rev = (int32_t )((a + r->as)->x >> 63);
  dropped = 0;
  extra_flag = 0;
  if (is_sr) {
    if (! (! (mi->flag & 1))) {
      __assert_fail("!(mi->flag & MM_I_HPC)", "align.c", 583U, "mm_align1");
    }
  }
  r2->cnt = 0;
  if (r->cnt == 0) {
    return;
  }
  ksw_gen_simple_mat(5, mat, (int8_t )opt->a, (int8_t )opt->b, (int8_t )opt->sc_ambi);
  bw = (int )((double )opt->bw * 1.5 + 1.);
  bw_long = (int )((double )opt->bw_long * 1.5 + 1.);
  if (bw_long < bw) {
    bw_long = bw;
  }
  if (is_sr) {
    if (! (mi->flag & 1)) {
      mm_max_stretch((mm_reg1_t const   *)r, (mm128_t const   *)a, & as1, & cnt1);
      rs = ((int32_t )(a + as1)->x + 1) - (int32_t )(((a + as1)->y >> 32) & 255UL);
      qs = ((int32_t )(a + as1)->y + 1) - (int32_t )(((a + as1)->y >> 32) & 255UL);
      re = (int32_t )(a + ((as1 + cnt1) - 1))->x + 1;
      qe = (int32_t )(a + ((as1 + cnt1) - 1))->y + 1;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (! (opt->flag & 268435456L)) {
      if (is_splice) {
        mm_fix_bad_ends_splice(km, opt, mi, (mm_reg1_t const   *)r, (int8_t const   *)(mat),
                               qlen, qseq0, (mm128_t const   *)a, & as1, & cnt1);
      } else {
        mm_fix_bad_ends((mm_reg1_t const   *)r, (mm128_t const   *)a, (int )opt->bw,
                        (int )(opt->min_chain_score * 2), & as1, & cnt1);
      }
    } else {
      as1 = r->as;
      cnt1 = r->cnt;
    }
    mm_filter_bad_seeds(km, as1, cnt1, a, 10, 40, (int )(opt->max_gap >> 1), 10);
    mm_filter_bad_seeds_alt(km, as1, cnt1, a, 30, (int )(opt->max_gap >> 1));
    mm_adjust_minier(mi, (uint8_t * const  *)qseq0, a + as1, & rs, & qs);
    mm_adjust_minier(mi, (uint8_t * const  *)qseq0, a + ((as1 + cnt1) - 1), & re,
                     & qe);
  }
  if (! (cnt1 > 0)) {
    __assert_fail("cnt1 > 0", "align.c", 610U, "mm_align1");
  }
  if (is_splice) {
    if (splice_flag & 256) {
      if (rev) {
        tmp___1 = 512;
      } else {
        tmp___1 = 256;
      }
      extra_flag |= tmp___1;
    }
    if (splice_flag & 512) {
      if (rev) {
        tmp___2 = 256;
      } else {
        tmp___2 = 512;
      }
      extra_flag |= tmp___2;
    }
    if (opt->flag & 262144L) {
      extra_flag |= 1024;
    }
  }
  if (is_sr) {
    qs0 = 0;
    qe0 = qlen;
    l = qs;
    if (l * (int32_t )opt->a + (int32_t )opt->end_bonus > (int32_t )opt->q) {
      tmp___3 = ((l * (int32_t )opt->a + (int32_t )opt->end_bonus) - (int32_t )opt->q) / (int32_t )opt->e;
    } else {
      tmp___3 = 0;
    }
    l += tmp___3;
    if (rs - l > 0) {
      rs0 = rs - l;
    } else {
      rs0 = 0;
    }
    l = qlen - qe;
    if (l * (int32_t )opt->a + (int32_t )opt->end_bonus > (int32_t )opt->q) {
      tmp___4 = ((l * (int32_t )opt->a + (int32_t )opt->end_bonus) - (int32_t )opt->q) / (int32_t )opt->e;
    } else {
      tmp___4 = 0;
    }
    l += tmp___4;
    if (re + l < (int32_t )(mi->seq + rid)->len) {
      re0 = re + l;
    } else {
      re0 = (int32_t )(mi->seq + rid)->len;
    }
  } else {
    rs0 = ((int32_t )(a + r->as)->x + 1) - (int32_t )(((a + r->as)->y >> 32) & 255UL);
    qs0 = ((int32_t )(a + r->as)->y + 1) - (int32_t )(((a + r->as)->y >> 32) & 255UL);
    if (rs0 < 0) {
      rs0 = 0;
    }
    if (! (qs0 >= 0)) {
      __assert_fail("qs0 >= 0", "align.c", 636U, "mm_align1");
    }
    qs1 = 0;
    rs1 = qs1;
    i = r->as - 1;
    l = 0;
    while (1) {
      if (i >= 0) {
        if (! ((a + i)->x >> 32 == (a + r->as)->x >> 32)) {
          break;
        }
      } else {
        break;
      }
      x = ((int32_t )(a + i)->x + 1) - (int32_t )(((a + i)->y >> 32) & 255UL);
      y = ((int32_t )(a + i)->y + 1) - (int32_t )(((a + i)->y >> 32) & 255UL);
      if (x < rs0) {
        if (y < qs0) {
          l ++;
          if (l > (int32_t )opt->min_cnt) {
            if (rs0 - x > qs0 - y) {
              l = rs0 - x;
            } else {
              l = qs0 - y;
            }
            rs1 = rs0 - l;
            qs1 = qs0 - l;
            if (rs1 < 0) {
              rs1 = 0;
            }
            break;
          }
        }
      }
      i --;
    }
    if (qs > 0) {
      if (rs > 0) {
        if (qs < (int32_t )opt->max_gap) {
          l = qs;
        } else {
          l = (int32_t )opt->max_gap;
        }
        if (qs1 > qs - l) {
          qs1 = qs1;
        } else {
          qs1 = qs - l;
        }
        if (qs0 < qs1) {
          qs0 = qs0;
        } else {
          qs0 = qs1;
        }
        if (l * (int32_t )opt->a > (int32_t )opt->q) {
          tmp___6 = (l * (int32_t )opt->a - (int32_t )opt->q) / (int32_t )opt->e;
        } else {
          tmp___6 = 0;
        }
        l += tmp___6;
        if (l < (int32_t )opt->max_gap) {
          l = l;
        } else {
          l = (int32_t )opt->max_gap;
        }
        if (l < rs) {
          l = l;
        } else {
          l = rs;
        }
        if (rs1 > rs - l) {
          rs1 = rs1;
        } else {
          rs1 = rs - l;
        }
        if (rs0 < rs1) {
          rs0 = rs0;
        } else {
          rs0 = rs1;
        }
        if (rs0 < rs) {
          rs0 = rs0;
        } else {
          rs0 = rs;
        }
      } else {
        rs0 = rs;
        qs0 = qs;
      }
    } else {
      rs0 = rs;
      qs0 = qs;
    }
    re0 = (int32_t )(a + ((r->as + r->cnt) - 1))->x + 1;
    qe0 = (int32_t )(a + ((r->as + r->cnt) - 1))->y + 1;
    re1 = (int32_t )(mi->seq + rid)->len;
    qe1 = qlen;
    i = r->as + r->cnt;
    l = 0;
    while (1) {
      if (i < n_a) {
        if (! ((a + i)->x >> 32 == (a + r->as)->x >> 32)) {
          break;
        }
      } else {
        break;
      }
      x___0 = (int32_t )(a + i)->x + 1;
      y___0 = (int32_t )(a + i)->y + 1;
      if (x___0 > re0) {
        if (y___0 > qe0) {
          l ++;
          if (l > (int32_t )opt->min_cnt) {
            if (x___0 - re0 > y___0 - qe0) {
              l = x___0 - re0;
            } else {
              l = y___0 - qe0;
            }
            re1 = re0 + l;
            qe1 = qe0 + l;
            break;
          }
        }
      }
      i ++;
    }
    if (qe < qlen) {
      if (re < (int32_t )(mi->seq + rid)->len) {
        if (qlen - qe < (int )opt->max_gap) {
          l = qlen - qe;
        } else {
          l = (int32_t )opt->max_gap;
        }
        if (qe1 < qe + l) {
          qe1 = qe1;
        } else {
          qe1 = qe + l;
        }
        if (qe0 > qe1) {
          qe0 = qe0;
        } else {
          qe0 = qe1;
        }
        if (l * (int32_t )opt->a > (int32_t )opt->q) {
          tmp___7 = (l * (int32_t )opt->a - (int32_t )opt->q) / (int32_t )opt->e;
        } else {
          tmp___7 = 0;
        }
        l += tmp___7;
        if (l < (int32_t )opt->max_gap) {
          l = l;
        } else {
          l = (int32_t )opt->max_gap;
        }
        if (l < (int32_t )(mi->seq + rid)->len - re) {
          l = l;
        } else {
          l = (int32_t )((mi->seq + rid)->len - (uint32_t )re);
        }
        if (re1 < re + l) {
          re1 = re1;
        } else {
          re1 = re + l;
        }
        if (re0 > re1) {
          re0 = re0;
        } else {
          re0 = re1;
        }
      } else {
        re0 = re;
        qe0 = qe;
      }
    } else {
      re0 = re;
      qe0 = qe;
    }
  }
  if ((unsigned long long )(a + r->as)->y & (1ULL << 43)) {
    if (r->qs > r->rs) {
      tmp___8 = r->qs - r->rs;
    } else {
      tmp___8 = r->rs - r->qs;
    }
    max_ext = tmp___8;
    if (r->rs - rs0 > max_ext) {
      rs0 = r->rs - max_ext;
    }
    if (r->qs - qs0 > max_ext) {
      qs0 = r->qs - max_ext;
    }
    if (r->qe > r->re) {
      max_ext = r->qe - r->re;
    } else {
      max_ext = r->re - r->qe;
    }
    if (re0 - r->re > max_ext) {
      re0 = r->re + max_ext;
    }
    if (qe0 - r->qe > max_ext) {
      qe0 = r->qe + max_ext;
    }
  }
  if (! (re0 > rs0)) {
    __assert_fail("re0 > rs0", "align.c", 696U, "mm_align1");
  }
  tmp___10 = kmalloc(km, (size_t )(re0 - rs0));
  tseq = (uint8_t *)tmp___10;
  tmp___11 = kmalloc(km, (size_t )(re0 - rs0));
  junc = (uint8_t *)tmp___11;
  if (qs > 0) {
    if (rs > 0) {
      if ((long long )opt->flag & 4294967296LL) {
        qseq = *(qseq0 + 0) + qs0;
        mm_idx_getseq2(mi, rev, (uint32_t )rid, (uint32_t )rs0, (uint32_t )rs, tseq);
      } else {
        qseq = *(qseq0 + rev) + qs0;
        mm_idx_getseq(mi, (uint32_t )rid, (uint32_t )rs0, (uint32_t )rs, tseq);
      }
      mm_idx_bed_junc(mi, rid, rs0, rs, junc);
      mm_seq_rev((uint32_t )(qs - qs0), qseq);
      mm_seq_rev((uint32_t )(rs - rs0), tseq);
      mm_seq_rev((uint32_t )(rs - rs0), junc);
      if (r->split_inv) {
        tmp___12 = opt->zdrop_inv;
      } else {
        tmp___12 = opt->zdrop;
      }
      mm_align_pair(km, opt, qs - qs0, (uint8_t const   *)qseq, rs - rs0, (uint8_t const   *)tseq,
                    (uint8_t const   *)junc, (int8_t const   *)(mat), bw, (int )opt->end_bonus,
                    (int )tmp___12, ((extra_flag | 64) | 2) | 128, ez);
      if (ez->n_cigar > 0) {
        mm_append_cigar(r, (uint32_t )ez->n_cigar, ez->cigar);
        (r->p)->dp_score = (int32_t )((uint32_t )(r->p)->dp_score + ez->max);
      }
      if (ez->reach_end) {
        tmp___13 = ez->mqe_t + 1;
      } else {
        tmp___13 = ez->max_t + 1;
      }
      rs1 = rs - tmp___13;
      if (ez->reach_end) {
        tmp___14 = qs - qs0;
      } else {
        tmp___14 = ez->max_q + 1;
      }
      qs1 = qs - tmp___14;
      mm_seq_rev((uint32_t )(qs - qs0), qseq);
    } else {
      rs1 = rs;
      qs1 = qs;
    }
  } else {
    rs1 = rs;
    qs1 = qs;
  }
  re1 = rs;
  qe1 = qs;
  if (qs1 >= 0) {
    if (! (rs1 >= 0)) {
      __assert_fail("qs1 >= 0 && rs1 >= 0", "align.c", 722U, "mm_align1");
    }
  } else {
    __assert_fail("qs1 >= 0 && rs1 >= 0", "align.c", 722U, "mm_align1");
  }
  if (is_sr) {
    i = cnt1 - 1;
  } else {
    i = 1;
  }
  while (i < cnt1) {
    if ((unsigned long long )(a + (as1 + i))->y & ((1ULL << 41) | (1ULL << 42))) {
      if (i != cnt1 - 1) {
        goto __Cont;
      }
    }
    if (is_sr) {
      if (! (mi->flag & 1)) {
        re = (int32_t )(a + (as1 + i))->x + 1;
        qe = (int32_t )(a + (as1 + i))->y + 1;
      } else {
        mm_adjust_minier(mi, (uint8_t * const  *)qseq0, a + (as1 + i), & re, & qe);
      }
    } else {
      mm_adjust_minier(mi, (uint8_t * const  *)qseq0, a + (as1 + i), & re, & qe);
    }
    re1 = re;
    qe1 = qe;
    if (i == cnt1 - 1) {
      goto _L___0;
    } else
    if ((unsigned long long )(a + (as1 + i))->y & (1ULL << 40)) {
      goto _L___0;
    } else
    if (qe - qs >= (int32_t )opt->min_ksw_len) {
      if (re - rs >= (int32_t )opt->min_ksw_len) {
        _L___0: /* CIL Label */ 
        bw1 = bw_long;
        if ((unsigned long long )(a + (as1 + i))->y & (1ULL << 40)) {
          if (qe - qs > re - rs) {
            bw1 = qe - qs;
          } else {
            bw1 = re - rs;
          }
        }
        if ((long long )opt->flag & 4294967296LL) {
          qseq = *(qseq0 + 0) + qs;
          mm_idx_getseq2(mi, rev, (uint32_t )rid, (uint32_t )rs, (uint32_t )re, tseq);
        } else {
          qseq = *(qseq0 + rev) + qs;
          mm_idx_getseq(mi, (uint32_t )rid, (uint32_t )rs, (uint32_t )re, tseq);
        }
        mm_idx_bed_junc(mi, rid, rs, re, junc);
        if (is_sr) {
          if (! (qe - qs == re - rs)) {
            __assert_fail("qe - qs == re - rs", "align.c", 745U, "mm_align1");
          }
          ksw_reset_extz(ez);
          j = 0;
          ez->score = 0;
          while (j < qe - qs) {
            if ((int )*(qseq + j) >= 4) {
              ez->score += (int )opt->e2;
            } else
            if ((int )*(tseq + j) >= 4) {
              ez->score += (int )opt->e2;
            } else {
              if ((int )*(qseq + j) == (int )*(tseq + j)) {
                tmp___17 = opt->a;
              } else {
                tmp___17 = - opt->b;
              }
              ez->score += (int )tmp___17;
            }
            j ++;
          }
          ez->cigar = ksw_push_cigar(km, & ez->n_cigar, & ez->m_cigar, ez->cigar,
                                     (uint32_t )0, qe - qs);
        } else {
          mm_align_pair(km, opt, qe - qs, (uint8_t const   *)qseq, re - rs, (uint8_t const   *)tseq,
                        (uint8_t const   *)junc, (int8_t const   *)(mat), bw1, -1,
                        (int )opt->zdrop, extra_flag | 8, ez);
        }
        zdrop_code = mm_test_zdrop(km, opt, (uint8_t const   *)qseq, (uint8_t const   *)tseq,
                                   (uint32_t )ez->n_cigar, ez->cigar, (int8_t const   *)(mat));
        if (zdrop_code != 0) {
          if (zdrop_code == 2) {
            tmp___18 = opt->zdrop_inv;
          } else {
            tmp___18 = opt->zdrop;
          }
          mm_align_pair(km, opt, qe - qs, (uint8_t const   *)qseq, re - rs, (uint8_t const   *)tseq,
                        (uint8_t const   *)junc, (int8_t const   *)(mat), bw1, -1,
                        (int )tmp___18, extra_flag, ez);
        }
        if (ez->n_cigar > 0) {
          mm_append_cigar(r, (uint32_t )ez->n_cigar, ez->cigar);
        }
        if (ez->zdropped) {
          if (! r->p) {
            if (! (ez->n_cigar == 0)) {
              __assert_fail("ez->n_cigar == 0", "align.c", 763U, "mm_align1");
            }
            capacity = (uint32_t )(sizeof(mm_extra_t ) / 4UL);
            capacity --;
            capacity |= capacity >> 1;
            capacity |= capacity >> 2;
            capacity |= capacity >> 4;
            capacity |= capacity >> 8;
            capacity |= capacity >> 16;
            capacity ++;
            tmp___20 = calloc((size_t )capacity, (size_t )4);
            r->p = (mm_extra_t *)tmp___20;
            (r->p)->capacity = capacity;
          }
          j = i - 1;
          while (j >= 0) {
            if ((int32_t )(a + (as1 + j))->x <= rs + ez->max_t) {
              break;
            }
            j --;
          }
          dropped = 1;
          if (j < 0) {
            j = 0;
          }
          (r->p)->dp_score = (int32_t )((uint32_t )(r->p)->dp_score + ez->max);
          re1 = rs + (ez->max_t + 1);
          qe1 = qs + (ez->max_q + 1);
          if (cnt1 - (j + 1) >= (int32_t )opt->min_cnt) {
            mm_split_reg(r, r2, ((as1 + j) + 1) - r->as, qlen, a, ! (! ((long long )opt->flag & 4294967296LL)));
            if (zdrop_code == 2) {
              r2->split_inv = (uint32_t )1;
            }
          }
          break;
        } else {
          (r->p)->dp_score += ez->score;
        }
        rs = re;
        qs = qe;
      }
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  if (! dropped) {
    if (qe < qe0) {
      if (re < re0) {
        if ((long long )opt->flag & 4294967296LL) {
          qseq = *(qseq0 + 0) + qe;
          mm_idx_getseq2(mi, rev, (uint32_t )rid, (uint32_t )re, (uint32_t )re0, tseq);
        } else {
          qseq = *(qseq0 + rev) + qe;
          mm_idx_getseq(mi, (uint32_t )rid, (uint32_t )re, (uint32_t )re0, tseq);
        }
        mm_idx_bed_junc(mi, rid, re, re0, junc);
        mm_align_pair(km, opt, qe0 - qe, (uint8_t const   *)qseq, re0 - re, (uint8_t const   *)tseq,
                      (uint8_t const   *)junc, (int8_t const   *)(mat), bw, (int )opt->end_bonus,
                      (int )opt->zdrop, extra_flag | 64, ez);
        if (ez->n_cigar > 0) {
          mm_append_cigar(r, (uint32_t )ez->n_cigar, ez->cigar);
          (r->p)->dp_score = (int32_t )((uint32_t )(r->p)->dp_score + ez->max);
        }
        if (ez->reach_end) {
          tmp___21 = ez->mqe_t + 1;
        } else {
          tmp___21 = ez->max_t + 1;
        }
        re1 = re + tmp___21;
        if (ez->reach_end) {
          tmp___22 = qe0 - qe;
        } else {
          tmp___22 = ez->max_q + 1;
        }
        qe1 = qe + tmp___22;
      }
    }
  }
  if (! (qe1 <= qlen)) {
    __assert_fail("qe1 <= qlen", "align.c", 804U, "mm_align1");
  }
  r->rs = rs1;
  r->re = re1;
  if (! rev) {
    r->qs = qs1;
    r->qe = qe1;
  } else
  if ((long long )opt->flag & 4294967296LL) {
    r->qs = qs1;
    r->qe = qe1;
  } else {
    r->qs = qlen - qe1;
    r->qe = qlen - qs1;
  }
  if (! (re1 - rs1 <= re0 - rs0)) {
    __assert_fail("re1 - rs1 <= re0 - rs0", "align.c", 810U, "mm_align1");
  }
  if (r->p) {
    if ((long long )opt->flag & 4294967296LL) {
      mm_idx_getseq2(mi, (int )r->rev, (uint32_t )rid, (uint32_t )rs1, (uint32_t )re1,
                     tseq);
      qseq = *(qseq0 + 0) + qs1;
    } else {
      mm_idx_getseq(mi, (uint32_t )rid, (uint32_t )rs1, (uint32_t )re1, tseq);
      qseq = *(qseq0 + r->rev) + qs1;
    }
    mm_update_extra(r, (uint8_t const   *)qseq, (uint8_t const   *)tseq, (int8_t const   *)(mat),
                    (int8_t )opt->q, (int8_t )opt->e, (int )(opt->flag & 67108864L),
                    ! (opt->flag & 4096L));
    if (rev) {
      if ((r->p)->trans_strand) {
        (r->p)->trans_strand ^= 3U;
      }
    }
  }
  kfree(km, (void *)tseq);
  kfree(km, (void *)junc);
  return;
}
}
static int mm_align1_inv(void *km , mm_mapopt_t const   *opt , mm_idx_t const   *mi ,
                         int qlen , uint8_t **qseq0 , mm_reg1_t const   *r1 , mm_reg1_t const   *r2 ,
                         mm_reg1_t *r_inv , ksw_extz_t *ez ) 
{ 
  int tl ;
  int ql ;
  int score ;
  int ret ;
  int q_off ;
  int t_off ;
  uint8_t *tseq ;
  uint8_t *qseq ;
  int8_t mat[25] ;
  void *qp ;
  void *tmp ;

  {
  ret = 0;
  memset((void *)r_inv, 0, sizeof(mm_reg1_t ));
  if (! (r1->split & 1U)) {
    return (0);
  } else
  if (! (r2->split & 2U)) {
    return (0);
  }
  if (r1->id != r1->parent) {
    if (r1->parent != -2) {
      return (0);
    }
  }
  if (r2->id != r2->parent) {
    if (r2->parent != -2) {
      return (0);
    }
  }
  if (r1->rid != r2->rid) {
    return (0);
  } else
  if (r1->rev != r2->rev) {
    return (0);
  }
  if (r1->rev) {
    ql = (int )(r1->qs - r2->qe);
  } else {
    ql = (int )(r2->qs - r1->qe);
  }
  tl = (int )(r2->rs - r1->re);
  if (ql < (int )opt->min_chain_score) {
    return (0);
  } else
  if (ql > (int )opt->max_gap) {
    return (0);
  }
  if (tl < (int )opt->min_chain_score) {
    return (0);
  } else
  if (tl > (int )opt->max_gap) {
    return (0);
  }
  ksw_gen_simple_mat(5, mat, (int8_t )opt->a, (int8_t )opt->b, (int8_t )opt->sc_ambi);
  tmp = kmalloc(km, (size_t )tl);
  tseq = (uint8_t *)tmp;
  mm_idx_getseq(mi, (uint32_t )r1->rid, (uint32_t )r1->re, (uint32_t )r2->rs, tseq);
  if (r1->rev) {
    qseq = *(qseq0 + 0) + r2->qe;
  } else {
    qseq = *(qseq0 + 1) + (qlen - (int )r2->qs);
  }
  mm_seq_rev((uint32_t )ql, qseq);
  mm_seq_rev((uint32_t )tl, tseq);
  qp = ksw_ll_qinit(km, 2, ql, (uint8_t const   *)qseq, 5, (int8_t const   *)(mat));
  score = ksw_ll_i16(qp, tl, (uint8_t const   *)tseq, (int )opt->q, (int )opt->e,
                     & q_off, & t_off);
  kfree(km, qp);
  mm_seq_rev((uint32_t )ql, qseq);
  mm_seq_rev((uint32_t )tl, tseq);
  if (score < (int )opt->min_dp_max) {
    goto end_align1_inv;
  }
  q_off = ql - (q_off + 1);
  t_off = tl - (t_off + 1);
  mm_align_pair(km, opt, ql - q_off, (uint8_t const   *)(qseq + q_off), tl - t_off,
                (uint8_t const   *)(tseq + t_off), (uint8_t const   *)0, (int8_t const   *)(mat),
                (int )((double )opt->bw * 1.5), -1, (int )opt->zdrop, 64, ez);
  if (ez->n_cigar == 0) {
    goto end_align1_inv;
  }
  mm_append_cigar(r_inv, (uint32_t )ez->n_cigar, ez->cigar);
  (r_inv->p)->dp_score = (int32_t )ez->max;
  r_inv->id = -1;
  r_inv->parent = -1;
  r_inv->inv = (uint32_t )1;
  r_inv->rev = (uint32_t )(! r1->rev);
  r_inv->rid = (int32_t )r1->rid;
  r_inv->div = - 1.0f;
  if (r_inv->rev == 0U) {
    r_inv->qs = (int32_t )(r2->qe + (int32_t const   )q_off);
    r_inv->qe = (r_inv->qs + ez->max_q) + 1;
  } else {
    r_inv->qe = (int32_t )(r2->qs - (int32_t const   )q_off);
    r_inv->qs = r_inv->qe - (ez->max_q + 1);
  }
  r_inv->rs = (int32_t )(r1->re + (int32_t const   )t_off);
  r_inv->re = (r_inv->rs + ez->max_t) + 1;
  mm_update_extra(r_inv, (uint8_t const   *)(qseq + q_off), (uint8_t const   *)(tseq + t_off),
                  (int8_t const   *)(mat), (int8_t )opt->q, (int8_t )opt->e, (int )(opt->flag & 67108864L),
                  ! (opt->flag & 4096L));
  ret = 1;
  end_align1_inv: 
  kfree(km, (void *)tseq);
  return (ret);
}
}
__inline static mm_reg1_t *mm_insert_reg(mm_reg1_t const   *r , int i , int *n_regs ,
                                         mm_reg1_t *regs ) 
{ 
  void *tmp ;

  {
  tmp = realloc((void *)regs, (unsigned long )(*n_regs + 1) * sizeof(mm_reg1_t ));
  regs = (mm_reg1_t *)tmp;
  if (i + 1 != *n_regs) {
    memmove((void *)(regs + (i + 2)), (void const   *)(regs + (i + 1)), sizeof(mm_reg1_t ) * (unsigned long )((*n_regs - i) - 1));
  }
  *(regs + (i + 1)) = (mm_reg1_t )*r;
  (*n_regs) ++;
  return (regs);
}
}
__inline static void mm_count_gaps(mm_reg1_t const   *r , int32_t *n_gap_ , int32_t *n_gapo_ ) 
{ 
  uint32_t i ;
  int32_t n_gapo ;
  int32_t n_gap ;
  int32_t tmp ;
  int32_t op ;
  int32_t len ;

  {
  n_gapo = 0;
  n_gap = 0;
  tmp = -1;
  *n_gapo_ = tmp;
  *n_gap_ = tmp;
  if ((unsigned long )r->p == (unsigned long )((mm_extra_t * const  )0)) {
    return;
  }
  i = (uint32_t )0;
  while (i < (r->p)->n_cigar) {
    op = (int32_t )((r->p)->cigar[i] & 15U);
    len = (int32_t )((r->p)->cigar[i] >> 4);
    if (op == 1) {
      n_gapo ++;
      n_gap += len;
    } else
    if (op == 2) {
      n_gapo ++;
      n_gap += len;
    }
    i ++;
  }
  *n_gap_ = n_gap;
  *n_gapo_ = n_gapo;
  return;
}
}
double mm_event_identity(mm_reg1_t const   *r ) 
{ 
  int32_t n_gap ;
  int32_t n_gapo ;

  {
  if ((unsigned long )r->p == (unsigned long )((mm_extra_t * const  )0)) {
    return ((double )(- 1.0f));
  }
  mm_count_gaps(r, & n_gap, & n_gapo);
  return ((double )r->mlen / (double )((((uint32_t )r->blen + (r->p)->n_ambi) - (uint32_t )n_gap) + (uint32_t )n_gapo));
}
}
static int32_t mm_recal_max_dp(mm_reg1_t const   *r , double b2 , int32_t match_sc ) 
{ 
  uint32_t i ;
  int32_t n_gap ;
  int32_t n_gapo ;
  int32_t n_mis ;
  double gap_cost ;
  int32_t op ;
  int32_t len ;
  float tmp ;

  {
  n_gap = 0;
  n_gapo = 0;
  gap_cost = 0.0;
  if ((unsigned long )r->p == (unsigned long )((mm_extra_t * const  )0)) {
    return (-1);
  }
  i = (uint32_t )0;
  while (i < (r->p)->n_cigar) {
    op = (int32_t )((r->p)->cigar[i] & 15U);
    len = (int32_t )((r->p)->cigar[i] >> 4);
    if (op == 1) {
      tmp = mg_log2((float )(1.0 + (double )len));
      gap_cost += b2 + (double )tmp;
      n_gapo ++;
      n_gap += len;
    } else
    if (op == 2) {
      tmp = mg_log2((float )(1.0 + (double )len));
      gap_cost += b2 + (double )tmp;
      n_gapo ++;
      n_gap += len;
    }
    i ++;
  }
  n_mis = (int32_t )((((uint32_t )r->blen + (r->p)->n_ambi) - (uint32_t )r->mlen) - (uint32_t )n_gap);
  return ((int32_t )((double )match_sc * (((double )r->mlen - b2 * (double )n_mis) - gap_cost) + .499));
}
}
void mm_update_dp_max(int qlen , int n_regs , mm_reg1_t *regs , float frac , int a ,
                      int b ) 
{ 
  int32_t max ;
  int32_t max2 ;
  int32_t i ;
  int32_t max_i ;
  double div___0 ;
  double b2 ;
  mm_reg1_t *r ;
  double tmp ;
  mm_reg1_t *r___0 ;

  {
  max = -1;
  max2 = -1;
  max_i = -1;
  if (n_regs < 2) {
    return;
  }
  i = 0;
  while (i < n_regs) {
    r = regs + i;
    if ((unsigned long )r->p == (unsigned long )((mm_extra_t *)0)) {
      goto __Cont;
    }
    if ((r->p)->dp_max > max) {
      max2 = max;
      max = (r->p)->dp_max;
      max_i = i;
    } else
    if ((r->p)->dp_max > max2) {
      max2 = (r->p)->dp_max;
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  if (max_i < 0) {
    return;
  } else
  if (max < 0) {
    return;
  } else
  if (max2 < 0) {
    return;
  }
  if ((double )((regs + max_i)->qe - (regs + max_i)->qs) < (double )qlen * (double )frac) {
    return;
  }
  if ((double )max2 < (double )max * (double )frac) {
    return;
  }
  tmp = mm_event_identity((mm_reg1_t const   *)(regs + max_i));
  div___0 = 1. - tmp;
  if (div___0 < 0.02) {
    div___0 = 0.02;
  }
  b2 = 0.5 / div___0;
  if (b2 * (double )a < (double )b) {
    b2 = (double )a / (double )b;
  }
  i = 0;
  while (i < n_regs) {
    r___0 = regs + i;
    if ((unsigned long )r___0->p == (unsigned long )((mm_extra_t *)0)) {
      goto __Cont___0;
    }
    (r___0->p)->dp_max = mm_recal_max_dp((mm_reg1_t const   *)r___0, b2, a);
    if ((r___0->p)->dp_max < 0) {
      (r___0->p)->dp_max = 0;
    }
    __Cont___0: /* CIL Label */ 
    i ++;
  }
  return;
}
}
mm_reg1_t *mm_align_skeleton(void *km , mm_mapopt_t const   *opt , mm_idx_t const   *mi ,
                             int qlen , char const   *qstr , int *n_regs_ , mm_reg1_t *regs ,
                             mm128_t *a ) 
{ 
  int32_t i ;
  int32_t n_regs ;
  int32_t n_a ;
  uint8_t *qseq0[2] ;
  ksw_extz_t ez ;
  void *tmp ;
  mm_reg1_t r2 ;
  mm_reg1_t s[2] ;
  mm_reg1_t s2[2] ;
  int which ;
  int trans_strand ;
  int tmp___0 ;

  {
  n_regs = *n_regs_;
  tmp = kmalloc(km, (size_t )(qlen * 2));
  qseq0[0] = (uint8_t *)tmp;
  qseq0[1] = qseq0[0] + qlen;
  i = 0;
  while (i < qlen) {
    *(qseq0[0] + i) = seq_nt4_table[(uint8_t )*(qstr + i)];
    if ((int )*(qseq0[0] + i) < 4) {
      *(qseq0[1] + ((qlen - 1) - i)) = (uint8_t )(3 - (int )*(qseq0[0] + i));
    } else {
      *(qseq0[1] + ((qlen - 1) - i)) = (uint8_t )4;
    }
    i ++;
  }
  n_a = mm_squeeze_a(km, n_regs, regs, a);
  memset((void *)(& ez), 0, sizeof(ksw_extz_t ));
  i = 0;
  while (i < n_regs) {
    if (opt->flag & 128L) {
      if (opt->flag & 256L) {
        if (opt->flag & 512L) {
          s[1] = *(regs + i);
          s[0] = s[1];
          mm_align1(km, opt, mi, qlen, (uint8_t **)(qseq0), & s[0], & s2[0], n_a,
                    a, & ez, 256);
          mm_align1(km, opt, mi, qlen, (uint8_t **)(qseq0), & s[1], & s2[1], n_a,
                    a, & ez, 512);
          if ((s[0].p)->dp_score > (s[1].p)->dp_score) {
            which = 0;
            trans_strand = 1;
          } else
          if ((s[0].p)->dp_score < (s[1].p)->dp_score) {
            which = 1;
            trans_strand = 2;
          } else {
            trans_strand = 3;
            which = (qlen + (s[0].p)->dp_score) & 1;
          }
          if (which == 0) {
            *(regs + i) = s[0];
            r2 = s2[0];
            free((void *)s[1].p);
          } else {
            *(regs + i) = s[1];
            r2 = s2[1];
            free((void *)s[0].p);
          }
          ((regs + i)->p)->trans_strand = (uint32_t )trans_strand;
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      mm_align1(km, opt, mi, qlen, (uint8_t **)(qseq0), regs + i, & r2, n_a, a, & ez,
                (int )opt->flag);
      if (opt->flag & 128L) {
        if (opt->flag & 256L) {
          ((regs + i)->p)->trans_strand = (uint32_t )1;
        } else {
          ((regs + i)->p)->trans_strand = (uint32_t )2;
        }
      }
    }
    if (r2.cnt > 0) {
      regs = mm_insert_reg((mm_reg1_t const   *)(& r2), i, & n_regs, regs);
    }
    if (i > 0) {
      if ((regs + i)->split_inv) {
        if (! ((long long )opt->flag & 8589934592LL)) {
          tmp___0 = mm_align1_inv(km, opt, mi, qlen, (uint8_t **)(qseq0), (mm_reg1_t const   *)(regs + (i - 1)),
                                  (mm_reg1_t const   *)(regs + i), & r2, & ez);
          if (tmp___0) {
            regs = mm_insert_reg((mm_reg1_t const   *)(& r2), i, & n_regs, regs);
            i ++;
          }
        }
      }
    }
    i ++;
  }
  *n_regs_ = n_regs;
  kfree(km, (void *)qseq0[0]);
  kfree(km, (void *)ez.cigar);
  mm_filter_regs(opt, qlen, n_regs_, regs);
  if (! (opt->flag & 4096L)) {
    if (! opt->split_prefix) {
      if (qlen >= (int )opt->rank_min_len) {
        mm_update_dp_max(qlen, *n_regs_, regs, (float )opt->rank_frac, (int )opt->a,
                         (int )opt->b);
        mm_filter_regs(opt, qlen, n_regs_, regs);
      }
    }
  }
  mm_hit_sort(km, n_regs_, regs, (float )opt->alt_drop);
  return (regs);
}
}
#pragma merger("0","/tmp/cil-YjouTAlt.i","-g,-Wall,-O2,-Wc++-compat")
extern gzFile gzdopen(int fd , char const   *mode ) ;
extern int gzread(gzFile file , voidp buf , unsigned int len ) ;
extern int gzclose(gzFile file ) ;
extern gzFile gzopen(char const   * , char const   * ) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
mm_bseq_file_t *mm_bseq_open(char const   *fn ) ;
void mm_bseq_close(mm_bseq_file_t *fp ) ;
mm_bseq1_t *mm_bseq_read3(mm_bseq_file_t *fp , int64_t chunk_size , int with_qual ,
                          int with_comment , int frag_mode , int *n_ ) ;
mm_bseq1_t *mm_bseq_read2(mm_bseq_file_t *fp , int64_t chunk_size , int with_qual ,
                          int frag_mode , int *n_ ) ;
mm_bseq1_t *mm_bseq_read(mm_bseq_file_t *fp , int64_t chunk_size , int with_qual ,
                         int *n_ ) ;
mm_bseq1_t *mm_bseq_read_frag2(int n_fp , mm_bseq_file_t **fp , int64_t chunk_size ,
                               int with_qual , int with_comment , int *n_ ) ;
mm_bseq1_t *mm_bseq_read_frag(int n_fp , mm_bseq_file_t **fp , int64_t chunk_size ,
                              int with_qual , int *n_ ) ;
int mm_bseq_eof(mm_bseq_file_t *fp ) ;
unsigned char seq_comp_table[256] ;
__inline static int mm_qname_len(char const   *s ) 
{ 
  int l ;
  size_t tmp ;
  int tmp___0 ;

  {
  tmp = strlen(s);
  l = (int )tmp;
  if (l >= 3) {
    if ((int const   )*(s + (l - 1)) >= 48) {
      if ((int const   )*(s + (l - 1)) <= 57) {
        if ((int const   )*(s + (l - 2)) == 47) {
          tmp___0 = l - 2;
        } else {
          tmp___0 = l;
        }
      } else {
        tmp___0 = l;
      }
    } else {
      tmp___0 = l;
    }
  } else {
    tmp___0 = l;
  }
  return (tmp___0);
}
}
__inline static int mm_qname_same(char const   *s1 , char const   *s2 ) 
{ 
  int l1 ;
  int l2 ;
  int tmp ;
  int tmp___0 ;

  {
  l1 = mm_qname_len(s1);
  l2 = mm_qname_len(s2);
  if (l1 == l2) {
    tmp = strncmp(s1, s2, (size_t )l1);
    if (tmp == 0) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
kstream_t *ks_init(gzFile f ) 
{ 
  kstream_t *ks ;
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = calloc((size_t )1, sizeof(kstream_t ));
  ks = (kstream_t *)tmp;
  ks->f = f;
  ks->bufsize = 16384;
  tmp___0 = malloc((size_t )16384);
  ks->buf = (unsigned char *)tmp___0;
  return (ks);
}
}
void ks_destroy(kstream_t *ks ) 
{ 


  {
  if (! ks) {
    return;
  }
  free((void *)ks->buf);
  free((void *)ks);
  return;
}
}
int ks_getuntil2(kstream_t *ks , int delimiter , kstring_t *str , int *dret , int append ) 
{ 
  int i ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  if (dret) {
    *dret = 0;
  }
  if (append) {
    str->l = str->l;
  } else {
    str->l = (size_t )0;
  }
  if (ks->begin >= ks->end) {
    if (ks->is_eof) {
      return (-1);
    }
  }
  while (1) {
    if (ks->begin >= ks->end) {
      if (! ks->is_eof) {
        ks->begin = 0;
        ks->end = gzread(ks->f, (voidp )ks->buf, (unsigned int )ks->bufsize);
        if (ks->end < ks->bufsize) {
          ks->is_eof = 1;
        }
        if (ks->end == 0) {
          break;
        }
      } else {
        break;
      }
    }
    if (delimiter == 2) {
      i = ks->begin;
      while (i < ks->end) {
        if ((int )*(ks->buf + i) == 10) {
          break;
        }
        i ++;
      }
    } else
    if (delimiter > 2) {
      i = ks->begin;
      while (i < ks->end) {
        if ((int )*(ks->buf + i) == delimiter) {
          break;
        }
        i ++;
      }
    } else
    if (delimiter == 0) {
      i = ks->begin;
      while (i < ks->end) {
        tmp = __ctype_b_loc();
        if ((int const   )*(*tmp + (int )*(ks->buf + i)) & 8192) {
          break;
        }
        i ++;
      }
    } else
    if (delimiter == 1) {
      i = ks->begin;
      while (i < ks->end) {
        tmp___0 = __ctype_b_loc();
        if ((int const   )*(*tmp___0 + (int )*(ks->buf + i)) & 8192) {
          if ((int )*(ks->buf + i) != 32) {
            break;
          }
        }
        i ++;
      }
    } else {
      i = 0;
    }
    if (str->m - str->l < (size_t )((i - ks->begin) + 1)) {
      str->m = (str->l + (size_t )(i - ks->begin)) + 1UL;
      (str->m) --;
      str->m |= str->m >> 1;
      str->m |= str->m >> 2;
      str->m |= str->m >> 4;
      str->m |= str->m >> 8;
      str->m |= str->m >> 16;
      (str->m) ++;
      tmp___1 = realloc((void *)str->s, str->m);
      str->s = (char *)tmp___1;
    }
    memcpy((void * __restrict  )(str->s + str->l), (void const   * __restrict  )(ks->buf + ks->begin),
           (size_t )(i - ks->begin));
    str->l += (size_t )(i - ks->begin);
    ks->begin = i + 1;
    if (i < ks->end) {
      if (dret) {
        *dret = (int )*(ks->buf + i);
      }
      break;
    }
  }
  if ((unsigned long )str->s == (unsigned long )((char *)0)) {
    str->m = (size_t )1;
    tmp___2 = calloc((size_t )1, (size_t )1);
    str->s = (char *)tmp___2;
  } else
  if (delimiter == 2) {
    if (str->l > 1UL) {
      if ((int )*(str->s + (str->l - 1UL)) == 13) {
        (str->l) --;
      }
    }
  }
  *(str->s + str->l) = (char )'\000';
  return ((int )str->l);
}
}
__inline static int ks_getc(kstream_t *ks )  __attribute__((__unused__)) ;
__inline static int ks_getc(kstream_t *ks ) 
{ 
  int tmp ;

  {
  if (ks->is_eof) {
    if (ks->begin >= ks->end) {
      return (-1);
    }
  }
  if (ks->begin >= ks->end) {
    ks->begin = 0;
    ks->end = gzread(ks->f, (voidp )ks->buf, (unsigned int )ks->bufsize);
    if (ks->end < ks->bufsize) {
      ks->is_eof = 1;
    }
    if (ks->end == 0) {
      return (-1);
    }
  }
  tmp = ks->begin;
  (ks->begin) ++;
  return ((int )*(ks->buf + tmp));
}
}
__inline static int ks_getuntil(kstream_t *ks , int delimiter , kstring_t *str , int *dret ) 
{ 
  int tmp ;

  {
  tmp = ks_getuntil2(ks, delimiter, str, dret, 0);
  return (tmp);
}
}
kseq_t *kseq_init(gzFile fd ) 
{ 
  kseq_t *s ;
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(kseq_t ));
  s = (kseq_t *)tmp;
  s->f = ks_init(fd);
  return (s);
}
}
void kseq_destroy(kseq_t *ks ) 
{ 


  {
  if (! ks) {
    return;
  }
  free((void *)ks->name.s);
  free((void *)ks->comment.s);
  free((void *)ks->seq.s);
  free((void *)ks->qual.s);
  ks_destroy(ks->f);
  free((void *)ks);
  return;
}
}
int kseq_read(kseq_t *seq ) 
{ 
  int c ;
  kstream_t *ks ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;

  {
  ks = seq->f;
  if (seq->last_char == 0) {
    while (1) {
      c = ks_getc(ks);
      if (c != -1) {
        if (c != 62) {
          if (! (c != 64)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
    }
    if (c == -1) {
      return (-1);
    }
    seq->last_char = c;
  }
  tmp___0 = (size_t )0;
  seq->qual.l = tmp___0;
  tmp = tmp___0;
  seq->seq.l = tmp;
  seq->comment.l = tmp;
  tmp___1 = ks_getuntil(ks, 0, & seq->name, & c);
  if (tmp___1 < 0) {
    return (-1);
  }
  if (c != 10) {
    ks_getuntil(ks, 2, & seq->comment, (int *)0);
  }
  if ((unsigned long )seq->seq.s == (unsigned long )((char *)0)) {
    seq->seq.m = (size_t )256;
    tmp___2 = malloc(seq->seq.m);
    seq->seq.s = (char *)tmp___2;
  }
  while (1) {
    c = ks_getc(ks);
    if (c != -1) {
      if (c != 62) {
        if (c != 43) {
          if (! (c != 64)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    if (c == 10) {
      continue;
    }
    tmp___3 = seq->seq.l;
    (seq->seq.l) ++;
    *(seq->seq.s + tmp___3) = (char )c;
    ks_getuntil2(ks, 2, & seq->seq, (int *)0, 1);
  }
  if (c == 62) {
    seq->last_char = c;
  } else
  if (c == 64) {
    seq->last_char = c;
  }
  if (seq->seq.l + 1UL >= seq->seq.m) {
    seq->seq.m = seq->seq.l + 2UL;
    (seq->seq.m) --;
    seq->seq.m |= seq->seq.m >> 1;
    seq->seq.m |= seq->seq.m >> 2;
    seq->seq.m |= seq->seq.m >> 4;
    seq->seq.m |= seq->seq.m >> 8;
    seq->seq.m |= seq->seq.m >> 16;
    (seq->seq.m) ++;
    tmp___4 = realloc((void *)seq->seq.s, seq->seq.m);
    seq->seq.s = (char *)tmp___4;
  }
  *(seq->seq.s + seq->seq.l) = (char)0;
  if (c != 43) {
    return ((int )seq->seq.l);
  }
  if (seq->qual.m < seq->seq.m) {
    seq->qual.m = seq->seq.m;
    tmp___5 = realloc((void *)seq->qual.s, seq->qual.m);
    seq->qual.s = (char *)tmp___5;
  }
  while (1) {
    c = ks_getc(ks);
    if (c != -1) {
      if (! (c != 10)) {
        break;
      }
    } else {
      break;
    }
  }
  if (c == -1) {
    return (-2);
  }
  while (1) {
    tmp___6 = ks_getuntil2(ks, 2, & seq->qual, (int *)0, 1);
    if (tmp___6 >= 0) {
      if (! (seq->qual.l < seq->seq.l)) {
        break;
      }
    } else {
      break;
    }
  }
  seq->last_char = 0;
  if (seq->seq.l != seq->qual.l) {
    return (-2);
  }
  return ((int )seq->seq.l);
}
}
unsigned char seq_comp_table[256]  = 
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)8,      (unsigned char)9,      (unsigned char)10,      (unsigned char)11, 
        (unsigned char)12,      (unsigned char)13,      (unsigned char)14,      (unsigned char)15, 
        (unsigned char)16,      (unsigned char)17,      (unsigned char)18,      (unsigned char)19, 
        (unsigned char)20,      (unsigned char)21,      (unsigned char)22,      (unsigned char)23, 
        (unsigned char)24,      (unsigned char)25,      (unsigned char)26,      (unsigned char)27, 
        (unsigned char)28,      (unsigned char)29,      (unsigned char)30,      (unsigned char)31, 
        (unsigned char)32,      (unsigned char)33,      (unsigned char)34,      (unsigned char)35, 
        (unsigned char)36,      (unsigned char)37,      (unsigned char)38,      (unsigned char)39, 
        (unsigned char)40,      (unsigned char)41,      (unsigned char)42,      (unsigned char)43, 
        (unsigned char)44,      (unsigned char)45,      (unsigned char)46,      (unsigned char)47, 
        (unsigned char)48,      (unsigned char)49,      (unsigned char)50,      (unsigned char)51, 
        (unsigned char)52,      (unsigned char)53,      (unsigned char)54,      (unsigned char)55, 
        (unsigned char)56,      (unsigned char)57,      (unsigned char)58,      (unsigned char)59, 
        (unsigned char)60,      (unsigned char)61,      (unsigned char)62,      (unsigned char)63, 
        (unsigned char)64,      (unsigned char )'T',      (unsigned char )'V',      (unsigned char )'G', 
        (unsigned char )'H',      (unsigned char )'E',      (unsigned char )'F',      (unsigned char )'C', 
        (unsigned char )'D',      (unsigned char )'I',      (unsigned char )'J',      (unsigned char )'M', 
        (unsigned char )'L',      (unsigned char )'K',      (unsigned char )'N',      (unsigned char )'O', 
        (unsigned char )'P',      (unsigned char )'Q',      (unsigned char )'Y',      (unsigned char )'S', 
        (unsigned char )'A',      (unsigned char )'A',      (unsigned char )'B',      (unsigned char )'W', 
        (unsigned char )'X',      (unsigned char )'R',      (unsigned char )'Z',      (unsigned char)91, 
        (unsigned char)92,      (unsigned char)93,      (unsigned char)94,      (unsigned char)95, 
        (unsigned char)96,      (unsigned char )'t',      (unsigned char )'v',      (unsigned char )'g', 
        (unsigned char )'h',      (unsigned char )'e',      (unsigned char )'f',      (unsigned char )'c', 
        (unsigned char )'d',      (unsigned char )'i',      (unsigned char )'j',      (unsigned char )'m', 
        (unsigned char )'l',      (unsigned char )'k',      (unsigned char )'n',      (unsigned char )'o', 
        (unsigned char )'p',      (unsigned char )'q',      (unsigned char )'y',      (unsigned char )'s', 
        (unsigned char )'a',      (unsigned char )'a',      (unsigned char )'b',      (unsigned char )'w', 
        (unsigned char )'x',      (unsigned char )'r',      (unsigned char )'z',      (unsigned char)123, 
        (unsigned char)124,      (unsigned char)125,      (unsigned char)126,      (unsigned char)127, 
        (unsigned char)128,      (unsigned char)129,      (unsigned char)130,      (unsigned char)131, 
        (unsigned char)132,      (unsigned char)133,      (unsigned char)134,      (unsigned char)135, 
        (unsigned char)136,      (unsigned char)137,      (unsigned char)138,      (unsigned char)139, 
        (unsigned char)140,      (unsigned char)141,      (unsigned char)142,      (unsigned char)143, 
        (unsigned char)144,      (unsigned char)145,      (unsigned char)146,      (unsigned char)147, 
        (unsigned char)148,      (unsigned char)149,      (unsigned char)150,      (unsigned char)151, 
        (unsigned char)152,      (unsigned char)153,      (unsigned char)154,      (unsigned char)155, 
        (unsigned char)156,      (unsigned char)157,      (unsigned char)158,      (unsigned char)159, 
        (unsigned char)160,      (unsigned char)161,      (unsigned char)162,      (unsigned char)163, 
        (unsigned char)164,      (unsigned char)165,      (unsigned char)166,      (unsigned char)167, 
        (unsigned char)168,      (unsigned char)169,      (unsigned char)170,      (unsigned char)171, 
        (unsigned char)172,      (unsigned char)173,      (unsigned char)174,      (unsigned char)175, 
        (unsigned char)176,      (unsigned char)177,      (unsigned char)178,      (unsigned char)179, 
        (unsigned char)180,      (unsigned char)181,      (unsigned char)182,      (unsigned char)183, 
        (unsigned char)184,      (unsigned char)185,      (unsigned char)186,      (unsigned char)187, 
        (unsigned char)188,      (unsigned char)189,      (unsigned char)190,      (unsigned char)191, 
        (unsigned char)192,      (unsigned char)193,      (unsigned char)194,      (unsigned char)195, 
        (unsigned char)196,      (unsigned char)197,      (unsigned char)198,      (unsigned char)199, 
        (unsigned char)200,      (unsigned char)201,      (unsigned char)202,      (unsigned char)203, 
        (unsigned char)204,      (unsigned char)205,      (unsigned char)206,      (unsigned char)207, 
        (unsigned char)208,      (unsigned char)209,      (unsigned char)210,      (unsigned char)211, 
        (unsigned char)212,      (unsigned char)213,      (unsigned char)214,      (unsigned char)215, 
        (unsigned char)216,      (unsigned char)217,      (unsigned char)218,      (unsigned char)219, 
        (unsigned char)220,      (unsigned char)221,      (unsigned char)222,      (unsigned char)223, 
        (unsigned char)224,      (unsigned char)225,      (unsigned char)226,      (unsigned char)227, 
        (unsigned char)228,      (unsigned char)229,      (unsigned char)230,      (unsigned char)231, 
        (unsigned char)232,      (unsigned char)233,      (unsigned char)234,      (unsigned char)235, 
        (unsigned char)236,      (unsigned char)237,      (unsigned char)238,      (unsigned char)239, 
        (unsigned char)240,      (unsigned char)241,      (unsigned char)242,      (unsigned char)243, 
        (unsigned char)244,      (unsigned char)245,      (unsigned char)246,      (unsigned char)247, 
        (unsigned char)248,      (unsigned char)249,      (unsigned char)250,      (unsigned char)251, 
        (unsigned char)252,      (unsigned char)253,      (unsigned char)254,      (unsigned char)255};
mm_bseq_file_t *mm_bseq_open(char const   *fn ) 
{ 
  mm_bseq_file_t *fp ;
  gzFile f ;
  gzFile tmp___0 ;
  gzFile tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
  if (fn) {
    tmp___2 = strcmp(fn, "-");
    if (tmp___2) {
      tmp___0 = gzopen(fn, "r");
      f = tmp___0;
    } else {
      tmp___1 = gzdopen(0, "r");
      f = tmp___1;
    }
  } else {
    tmp___1 = gzdopen(0, "r");
    f = tmp___1;
  }
  if ((unsigned long )f == (unsigned long )((gzFile )0)) {
    return ((mm_bseq_file_t *)0);
  }
  tmp___3 = calloc((size_t )1, sizeof(mm_bseq_file_t ));
  fp = (mm_bseq_file_t *)tmp___3;
  fp->fp = f;
  fp->ks = kseq_init(fp->fp);
  return (fp);
}
}
void mm_bseq_close(mm_bseq_file_t *fp ) 
{ 


  {
  kseq_destroy(fp->ks);
  gzclose(fp->fp);
  free((void *)fp);
  return;
}
}
__inline static char *kstrdup(kstring_t const   *s ) 
{ 
  char *t ;
  void *tmp ;

  {
  tmp = malloc((size_t )(s->l + 1UL));
  t = (char *)tmp;
  memcpy((void * __restrict  )t, (void const   * __restrict  )s->s, (size_t )(s->l + 1UL));
  return (t);
}
}
__inline static void kseq2bseq(kseq_t *ks , mm_bseq1_t *s , int with_qual , int with_comment ) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;

  {
  if (ks->name.l == 0UL) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[WARNING]\033[1;31m empty sequence name in the input.\033[0m\n");
  }
  s->name = kstrdup((kstring_t const   *)(& ks->name));
  s->seq = kstrdup((kstring_t const   *)(& ks->seq));
  i = 0;
  while (i < (int )ks->seq.l) {
    if ((int )*(s->seq + i) == 117) {
      *(s->seq + i) = (char )((int )*(s->seq + i) - 1);
    } else
    if ((int )*(s->seq + i) == 85) {
      *(s->seq + i) = (char )((int )*(s->seq + i) - 1);
    }
    i ++;
  }
  if (with_qual) {
    if (ks->qual.l) {
      tmp = kstrdup((kstring_t const   *)(& ks->qual));
      s->qual = tmp;
    } else {
      s->qual = (char *)0;
    }
  } else {
    s->qual = (char *)0;
  }
  if (with_comment) {
    if (ks->comment.l) {
      tmp___0 = kstrdup((kstring_t const   *)(& ks->comment));
      s->comment = tmp___0;
    } else {
      s->comment = (char *)0;
    }
  } else {
    s->comment = (char *)0;
  }
  s->l_seq = (int )ks->seq.l;
  return;
}
}
mm_bseq1_t *mm_bseq_read3(mm_bseq_file_t *fp , int64_t chunk_size , int with_qual ,
                          int with_comment , int frag_mode , int *n_ ) 
{ 
  int64_t size ;
  int ret ;
  struct __anonstruct_a_687107232 a ;
  kseq_t *ks ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  mm_bseq1_t *s ;
  void *tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;

  {
  size = (int64_t )0;
  a.n = (size_t )0;
  a.m = (size_t )0;
  a.a = (mm_bseq1_t *)0;
  ks = fp->ks;
  *n_ = 0;
  if (fp->s.seq) {
    while (1) {
      if (a.m < 256UL) {
        a.m = (size_t )256;
        (a.m) --;
        a.m |= a.m >> 1;
        a.m |= a.m >> 2;
        a.m |= a.m >> 4;
        a.m |= a.m >> 8;
        a.m |= a.m >> 16;
        (a.m) ++;
        tmp = krealloc((void *)0, (void *)a.a, sizeof(mm_bseq1_t ) * a.m);
        a.a = (mm_bseq1_t *)tmp;
      }
      break;
    }
    while (1) {
      if (a.n == a.m) {
        if (a.m) {
          a.m <<= 1;
        } else {
          a.m = (size_t )2;
        }
        tmp___0 = krealloc((void *)0, (void *)a.a, sizeof(mm_bseq1_t ) * a.m);
        a.a = (mm_bseq1_t *)tmp___0;
      }
      tmp___1 = a.n;
      (a.n) ++;
      *(a.a + tmp___1) = fp->s;
      break;
    }
    size = (int64_t )fp->s.l_seq;
    memset((void *)(& fp->s), 0, sizeof(mm_bseq1_t ));
  }
  while (1) {
    ret = kseq_read(ks);
    if (! (ret >= 0)) {
      break;
    }
    if (! (ks->seq.l <= 2147483647UL)) {
      __assert_fail("ks->seq.l <= INT32_MAX", "bseq.c", 95U, "mm_bseq_read3");
    }
    if (a.m == 0UL) {
      while (1) {
        if (a.m < 256UL) {
          a.m = (size_t )256;
          (a.m) --;
          a.m |= a.m >> 1;
          a.m |= a.m >> 2;
          a.m |= a.m >> 4;
          a.m |= a.m >> 8;
          a.m |= a.m >> 16;
          (a.m) ++;
          tmp___3 = krealloc((void *)0, (void *)a.a, sizeof(mm_bseq1_t ) * a.m);
          a.a = (mm_bseq1_t *)tmp___3;
        }
        break;
      }
    }
    while (1) {
      if (a.n == a.m) {
        if (a.m) {
          a.m <<= 1;
        } else {
          a.m = (size_t )2;
        }
        tmp___4 = krealloc((void *)0, (void *)a.a, sizeof(mm_bseq1_t ) * a.m);
        a.a = (mm_bseq1_t *)tmp___4;
      }
      tmp___5 = a.n;
      (a.n) ++;
      s = a.a + tmp___5;
      break;
    }
    kseq2bseq(ks, s, with_qual, with_comment);
    size += (int64_t )s->l_seq;
    if (size >= chunk_size) {
      if (frag_mode) {
        if ((a.a + (a.n - 1UL))->l_seq < 1000000) {
          while (1) {
            ret = kseq_read(ks);
            if (! (ret >= 0)) {
              break;
            }
            kseq2bseq(ks, & fp->s, with_qual, with_comment);
            tmp___8 = mm_qname_same((char const   *)fp->s.name, (char const   *)(a.a + (a.n - 1UL))->name);
            if (tmp___8) {
              while (1) {
                if (a.n == a.m) {
                  if (a.m) {
                    a.m <<= 1;
                  } else {
                    a.m = (size_t )2;
                  }
                  tmp___6 = krealloc((void *)0, (void *)a.a, sizeof(mm_bseq1_t ) * a.m);
                  a.a = (mm_bseq1_t *)tmp___6;
                }
                tmp___7 = a.n;
                (a.n) ++;
                *(a.a + tmp___7) = fp->s;
                break;
              }
              memset((void *)(& fp->s), 0, sizeof(mm_bseq1_t ));
            } else {
              break;
            }
          }
        }
      }
      break;
    }
  }
  if (ret < -1) {
    if (a.n) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[WARNING]\033[1;31m failed to parse the FASTA/FASTQ record next to \'%s\'. Continue anyway.\033[0m\n",
              (a.a + (a.n - 1UL))->name);
    } else {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[WARNING]\033[1;31m failed to parse the first FASTA/FASTQ record. Continue anyway.\033[0m\n");
    }
  }
  *n_ = (int )a.n;
  return (a.a);
}
}
mm_bseq1_t *mm_bseq_read2(mm_bseq_file_t *fp , int64_t chunk_size , int with_qual ,
                          int frag_mode , int *n_ ) 
{ 
  mm_bseq1_t *tmp ;

  {
  tmp = mm_bseq_read3(fp, chunk_size, with_qual, 0, frag_mode, n_);
  return (tmp);
}
}
mm_bseq1_t *mm_bseq_read(mm_bseq_file_t *fp , int64_t chunk_size , int with_qual ,
                         int *n_ ) 
{ 
  mm_bseq1_t *tmp ;

  {
  tmp = mm_bseq_read2(fp, chunk_size, with_qual, 0, n_);
  return (tmp);
}
}
mm_bseq1_t *mm_bseq_read_frag2(int n_fp , mm_bseq_file_t **fp , int64_t chunk_size ,
                               int with_qual , int with_comment , int *n_ ) 
{ 
  int i ;
  int64_t size ;
  struct __anonstruct_a_687107233 a ;
  int n_read ;
  int tmp ;
  void *tmp___0 ;
  mm_bseq1_t *s ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  size = (int64_t )0;
  a.n = (size_t )0;
  a.m = (size_t )0;
  a.a = (mm_bseq1_t *)0;
  *n_ = 0;
  if (n_fp < 1) {
    return ((mm_bseq1_t *)0);
  }
  while (1) {
    n_read = 0;
    i = 0;
    while (i < n_fp) {
      tmp = kseq_read((*(fp + i))->ks);
      if (tmp >= 0) {
        n_read ++;
      }
      i ++;
    }
    if (n_read < n_fp) {
      if (n_read > 0) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[W::%s]\033[1;31m query files have different number of records; extra records skipped.\033[0m\n",
                "mm_bseq_read_frag2");
      }
      break;
    }
    if (a.m == 0UL) {
      while (1) {
        if (a.m < 256UL) {
          a.m = (size_t )256;
          (a.m) --;
          a.m |= a.m >> 1;
          a.m |= a.m >> 2;
          a.m |= a.m >> 4;
          a.m |= a.m >> 8;
          a.m |= a.m >> 16;
          (a.m) ++;
          tmp___0 = krealloc((void *)0, (void *)a.a, sizeof(mm_bseq1_t ) * a.m);
          a.a = (mm_bseq1_t *)tmp___0;
        }
        break;
      }
    }
    i = 0;
    while (i < n_fp) {
      while (1) {
        if (a.n == a.m) {
          if (a.m) {
            a.m <<= 1;
          } else {
            a.m = (size_t )2;
          }
          tmp___1 = krealloc((void *)0, (void *)a.a, sizeof(mm_bseq1_t ) * a.m);
          a.a = (mm_bseq1_t *)tmp___1;
        }
        tmp___2 = a.n;
        (a.n) ++;
        s = a.a + tmp___2;
        break;
      }
      kseq2bseq((*(fp + i))->ks, s, with_qual, with_comment);
      size += (int64_t )s->l_seq;
      i ++;
    }
    if (size >= chunk_size) {
      break;
    }
  }
  *n_ = (int )a.n;
  return (a.a);
}
}
mm_bseq1_t *mm_bseq_read_frag(int n_fp , mm_bseq_file_t **fp , int64_t chunk_size ,
                              int with_qual , int *n_ ) 
{ 
  mm_bseq1_t *tmp ;

  {
  tmp = mm_bseq_read_frag2(n_fp, fp, chunk_size, with_qual, 0, n_);
  return (tmp);
}
}
int mm_bseq_eof(mm_bseq_file_t *fp ) 
{ 
  int tmp ;

  {
  if (((fp->ks)->f)->is_eof) {
    if (((fp->ks)->f)->begin >= ((fp->ks)->f)->end) {
      if ((unsigned long )fp->s.seq == (unsigned long )((char *)0)) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
#pragma merger("0","/tmp/cil-jAmRHqMS.i","-g,-Wall,-O2,-Wc++-compat")
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
int mm_verbose ;
void mm_est_err(mm_idx_t const   *mi , int qlen , int n_regs , mm_reg1_t *regs , mm128_t const   *a ,
                int32_t n , uint64_t const   *mini_pos ) ;
__inline static int32_t get_for_qpos(int32_t qlen , mm128_t const   *a ) 
{ 
  int32_t x ;
  int32_t q_span ;

  {
  x = (int32_t )a->y;
  q_span = (int32_t )((a->y >> 32) & 255UL);
  if (a->x >> 63) {
    x = (qlen - 1) - ((x + 1) - q_span);
  }
  return (x);
}
}
static int get_mini_idx(int qlen , mm128_t const   *a , int32_t n , uint64_t const   *mini_pos ) 
{ 
  int32_t x ;
  int32_t L ;
  int32_t R ;
  int32_t m ;
  int32_t y ;

  {
  L = 0;
  R = n - 1;
  x = get_for_qpos(qlen, a);
  while (L <= R) {
    m = (int32_t )(((uint64_t )L + (uint64_t )R) >> 1);
    y = (int32_t )*(mini_pos + m);
    if (y < x) {
      L = m + 1;
    } else
    if (y > x) {
      R = m - 1;
    } else {
      return (m);
    }
  }
  return (-1);
}
}
void mm_est_err(mm_idx_t const   *mi , int qlen , int n_regs , mm_reg1_t *regs , mm128_t const   *a ,
                int32_t n , uint64_t const   *mini_pos ) 
{ 
  int i ;
  uint64_t sum_k ;
  float avg_k ;
  mm_reg1_t *r ;
  int32_t st ;
  int32_t en ;
  int32_t j ;
  int32_t k ;
  int32_t n_match ;
  int32_t n_tot ;
  int32_t l_ref ;
  mm128_t const   *tmp ;
  int32_t x ;
  mm128_t const   *tmp___0 ;
  double tmp___1 ;

  {
  sum_k = (uint64_t )0;
  if (n == 0) {
    return;
  }
  i = 0;
  while (i < n) {
    sum_k += (uint64_t )((*(mini_pos + i) >> 32) & 255UL);
    i ++;
  }
  avg_k = (float )sum_k / (float )n;
  i = 0;
  while (i < n_regs) {
    r = regs + i;
    r->div = - 1.0f;
    if (r->cnt == 0) {
      goto __Cont;
    }
    if (r->rev) {
      tmp = a + ((r->as + r->cnt) - 1);
    } else {
      tmp = a + r->as;
    }
    en = get_mini_idx(qlen, tmp, n, mini_pos);
    st = en;
    if (st < 0) {
      if (mm_verbose >= 2) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[WARNING] logic inconsistency in mm_est_err(). Please contact the developer.\n");
      }
      goto __Cont;
    }
    l_ref = (int32_t )(mi->seq + r->rid)->len;
    k = 1;
    j = st + 1;
    n_match = 1;
    while (1) {
      if (j < n) {
        if (! (k < r->cnt)) {
          break;
        }
      } else {
        break;
      }
      if (r->rev) {
        tmp___0 = a + (((r->as + r->cnt) - 1) - k);
      } else {
        tmp___0 = a + (r->as + k);
      }
      x = get_for_qpos(qlen, tmp___0);
      if (x == (int32_t )*(mini_pos + j)) {
        k ++;
        en = j;
        n_match ++;
      }
      j ++;
    }
    n_tot = (en - st) + 1;
    if ((float )r->qs > avg_k) {
      if ((float )r->rs > avg_k) {
        n_tot ++;
      }
    }
    if ((float )(qlen - r->qs) > avg_k) {
      if ((float )(l_ref - r->re) > avg_k) {
        n_tot ++;
      }
    }
    if (n_match >= n_tot) {
      r->div = 0.0f;
    } else {
      tmp___1 = pow((double )n_match / (double )n_tot, 1.0 / (double )avg_k);
      r->div = (float )(1.0 - tmp___1);
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#pragma merger("0","/tmp/cil-0r8sE3UG.i","-g,-Wall,-O2,-Wc++-compat")
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
int mm_gen_cs(void *km , char **buf , int *max_len , mm_idx_t const   *mi , mm_reg1_t const   *r ,
              char const   *seq , int no_iden ) ;
int mm_gen_MD(void *km , char **buf , int *max_len , mm_idx_t const   *mi , mm_reg1_t const   *r ,
              char const   *seq ) ;
int mm_write_sam_hdr(mm_idx_t const   *idx , char const   *rg , char const   *ver ,
                     int argc , char **argv ) ;
void mm_write_paf(kstring_t *s , mm_idx_t const   *mi , mm_bseq1_t const   *t , mm_reg1_t const   *r ,
                  void *km , int64_t opt_flag ) ;
void mm_write_paf3(kstring_t *s , mm_idx_t const   *mi , mm_bseq1_t const   *t , mm_reg1_t const   *r ,
                   void *km , int64_t opt_flag , int rep_len ) ;
void mm_write_sam(kstring_t *s , mm_idx_t const   *mi , mm_bseq1_t const   *t , mm_reg1_t const   *r ,
                  int n_regs , mm_reg1_t const   *regs ) ;
void mm_write_sam2(kstring_t *s , mm_idx_t const   *mi , mm_bseq1_t const   *t , int seg_idx ,
                   int reg_idx , int n_seg , int const   *n_regss , mm_reg1_t const   * const  *regss ,
                   void *km , int64_t opt_flag ) ;
void mm_write_sam3(kstring_t *s , mm_idx_t const   *mi , mm_bseq1_t const   *t , int seg_idx ,
                   int reg_idx , int n_seg , int const   *n_regss , mm_reg1_t const   * const  *regss ,
                   void *km , int64_t opt_flag , int rep_len ) ;
void mm_err_puts(char const   *str ) ;
static char mm_rg_id[256]  ;
__inline static void str_enlarge(kstring_t *s , int l ) 
{ 
  void *tmp ;

  {
  if ((s->l + (size_t )l) + 1UL > s->m) {
    s->m = (s->l + (size_t )l) + 1UL;
    (s->m) --;
    s->m |= s->m >> 1;
    s->m |= s->m >> 2;
    s->m |= s->m >> 4;
    s->m |= s->m >> 8;
    s->m |= s->m >> 16;
    (s->m) ++;
    tmp = realloc((void *)s->s, s->m);
    s->s = (char *)tmp;
  }
  return;
}
}
__inline static void str_copy(kstring_t *s , char const   *st , char const   *en ) 
{ 


  {
  str_enlarge(s, (int )(en - st));
  memcpy((void * __restrict  )(s->s + s->l), (void const   * __restrict  )st, (size_t )(en - st));
  s->l += (size_t )(en - st);
  return;
}
}
static void mm_sprintf_lite(kstring_t *s , char const   *fmt  , ...) 
{ 
  char buf[16] ;
  char const   *p ;
  char const   *q ;
  va_list___0 ap ;
  int c ;
  int i ;
  int l ;
  unsigned int x ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int i___0 ;
  int l___0 ;
  uint32_t x___0 ;
  uint32_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  char *r ;
  char *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  char tmp___10 ;

  {
  __builtin_va_start(ap, fmt);
  p = fmt;
  q = p;
  while (*p) {
    if ((int const   )*p == 37) {
      if ((unsigned long )p > (unsigned long )q) {
        str_copy(s, q, p);
      }
      p ++;
      if ((int const   )*p == 100) {
        l = 0;
        tmp = __builtin_va_arg(ap, int );
        c = tmp;
        if (c >= 0) {
          x = (unsigned int )c;
        } else {
          x = (unsigned int )(- c);
        }
        while (1) {
          tmp___0 = l;
          l ++;
          buf[tmp___0] = (char )(x % 10U + 48U);
          x /= 10U;
          if (! (x > 0U)) {
            break;
          }
        }
        if (c < 0) {
          tmp___1 = l;
          l ++;
          buf[tmp___1] = (char )'-';
        }
        str_enlarge(s, l);
        i = l - 1;
        while (i >= 0) {
          tmp___2 = s->l;
          (s->l) ++;
          *(s->s + tmp___2) = buf[i];
          i --;
        }
      } else
      if ((int const   )*p == 117) {
        l___0 = 0;
        tmp___3 = __builtin_va_arg(ap, uint32_t );
        x___0 = tmp___3;
        while (1) {
          tmp___4 = l___0;
          l___0 ++;
          buf[tmp___4] = (char )(x___0 % 10U + 48U);
          x___0 /= 10U;
          if (! (x___0 > 0U)) {
            break;
          }
        }
        str_enlarge(s, l___0);
        i___0 = l___0 - 1;
        while (i___0 >= 0) {
          tmp___5 = s->l;
          (s->l) ++;
          *(s->s + tmp___5) = buf[i___0];
          i___0 --;
        }
      } else
      if ((int const   )*p == 115) {
        tmp___7 = __builtin_va_arg(ap, char *);
        r = tmp___7;
        tmp___8 = strlen((char const   *)r);
        str_copy(s, (char const   *)r, (char const   *)(r + tmp___8));
      } else
      if ((int const   )*p == 99) {
        str_enlarge(s, 1);
        tmp___9 = s->l;
        (s->l) ++;
        tmp___10 = __builtin_va_arg(ap, int );
        *(s->s + tmp___9) = tmp___10;
      } else {
        abort();
      }
      q = p + 1;
    }
    p ++;
  }
  if ((unsigned long )p > (unsigned long )q) {
    str_copy(s, q, p);
  }
  __builtin_va_end(ap);
  *(s->s + s->l) = (char)0;
  return;
}
}
static char *mm_escape(char *s ) 
{ 
  char *p ;
  char *q ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  q = s;
  p = q;
  while (*p) {
    if ((int )*p == 92) {
      p ++;
      if ((int )*p == 116) {
        tmp = q;
        q ++;
        *tmp = (char )'\t';
      } else
      if ((int )*p == 92) {
        tmp___0 = q;
        q ++;
        *tmp___0 = (char )'\\';
      }
    } else {
      tmp___1 = q;
      q ++;
      *tmp___1 = *p;
    }
    p ++;
  }
  *q = (char )'\000';
  return (s);
}
}
static int sam_write_rg_line(kstring_t *str , char const   *s ) 
{ 
  char *p ;
  char *q ;
  char *r ;
  char *rg_line ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
  rg_line = (char *)0;
  memset((void *)(mm_rg_id), 0, (size_t )256);
  if ((unsigned long )s == (unsigned long )((char const   *)0)) {
    return (0);
  }
  tmp = strstr(s, "@RG");
  if ((unsigned long )tmp != (unsigned long )s) {
    if (mm_verbose >= 1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[ERROR] the read group line is not started with @RG\n");
    }
    goto err_set_rg;
  }
  tmp___0 = strstr(s, "\t");
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
    if (mm_verbose >= 1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[ERROR] the read group line contained literal <tab> characters -- replace with escaped tabs: \\t\n");
    }
    goto err_set_rg;
  }
  tmp___1 = strlen(s);
  tmp___2 = malloc(tmp___1 + 1UL);
  rg_line = (char *)tmp___2;
  strcpy((char * __restrict  )rg_line, (char const   * __restrict  )s);
  mm_escape(rg_line);
  p = strstr((char const   *)rg_line, "\tID:");
  if ((unsigned long )p == (unsigned long )((char *)0)) {
    if (mm_verbose >= 1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[ERROR] no ID within the read group line\n");
    }
    goto err_set_rg;
  }
  p += 4;
  q = p;
  while (1) {
    if (*q) {
      if ((int )*q != 9) {
        if (! ((int )*q != 10)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    q ++;
  }
  if ((q - p) + 1L > 256L) {
    if (mm_verbose >= 1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[ERROR] @RG:ID is longer than 255 characters\n");
    }
    goto err_set_rg;
  }
  q = p;
  r = mm_rg_id;
  while (1) {
    if (*q) {
      if ((int )*q != 9) {
        if (! ((int )*q != 10)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    tmp___3 = r;
    r ++;
    *tmp___3 = *q;
    q ++;
  }
  mm_sprintf_lite(str, "%s\n", rg_line);
  return (0);
  err_set_rg: 
  free((void *)rg_line);
  return (-1);
}
}
int mm_write_sam_hdr(mm_idx_t const   *idx , char const   *rg , char const   *ver ,
                     int argc , char **argv ) 
{ 
  kstring_t str ;
  int ret ;
  uint32_t i ;
  int i___0 ;

  {
  str.l = (size_t )0;
  str.m = (size_t )0;
  str.s = (char *)0;
  ret = 0;
  if (idx) {
    i = (uint32_t )0;
    while (i < (uint32_t )idx->n_seq) {
      mm_sprintf_lite(& str, "@SQ\tSN:%s\tLN:%d\n", (idx->seq + i)->name, (idx->seq + i)->len);
      i ++;
    }
  }
  if (rg) {
    ret = sam_write_rg_line(& str, rg);
  }
  mm_sprintf_lite(& str, "@PG\tID:minimap2\tPN:minimap2");
  if (ver) {
    mm_sprintf_lite(& str, "\tVN:%s", ver);
  }
  if (argc > 1) {
    mm_sprintf_lite(& str, "\tCL:minimap2");
    i___0 = 1;
    while (i___0 < argc) {
      mm_sprintf_lite(& str, " %s", *(argv + i___0));
      i___0 ++;
    }
  }
  mm_err_puts((char const   *)str.s);
  free((void *)str.s);
  return (ret);
}
}
static void write_cs_core(kstring_t *s , uint8_t const   *tseq , uint8_t const   *qseq ,
                          mm_reg1_t const   *r , char *tmp , int no_iden , int write_tag ) 
{ 
  int i ;
  int q_off ;
  int t_off ;
  int j ;
  int op ;
  int len ;
  int l_tmp ;
  int tmp___1 ;

  {
  if (write_tag) {
    mm_sprintf_lite(s, "\tcs:Z:");
  }
  t_off = 0;
  q_off = t_off;
  i = q_off;
  while (i < (int )(r->p)->n_cigar) {
    op = (int )((r->p)->cigar[i] & 15U);
    len = (int )((r->p)->cigar[i] >> 4);
    if (op >= 0) {
      if (! (op <= 3)) {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (! (op == 7)) {
      if (! (op == 8)) {
        __assert_fail("(op >= MM_CIGAR_MATCH && op <= MM_CIGAR_N_SKIP) || op == MM_CIGAR_EQ_MATCH || op == MM_CIGAR_X_MISMATCH",
                      "format.c", 147U, "write_cs_core");
      }
    }
    if (op == 0) {
      goto _L___1;
    } else
    if (op == 7) {
      goto _L___1;
    } else
    if (op == 8) {
      _L___1: /* CIL Label */ 
      l_tmp = 0;
      j = 0;
      while (j < len) {
        if ((int const   )*(qseq + (q_off + j)) != (int const   )*(tseq + (t_off + j))) {
          if (l_tmp > 0) {
            if (! no_iden) {
              *(tmp + l_tmp) = (char)0;
              mm_sprintf_lite(s, "=%s", tmp);
            } else {
              mm_sprintf_lite(s, ":%d", l_tmp);
            }
            l_tmp = 0;
          }
          mm_sprintf_lite(s, "*%c%c", (int const   )*("acgtn" + *(tseq + (t_off + j))),
                          (int const   )*("acgtn" + *(qseq + (q_off + j))));
        } else {
          tmp___1 = l_tmp;
          l_tmp ++;
          *(tmp + tmp___1) = (char )*("ACGTN" + *(qseq + (q_off + j)));
        }
        j ++;
      }
      if (l_tmp > 0) {
        if (! no_iden) {
          *(tmp + l_tmp) = (char)0;
          mm_sprintf_lite(s, "=%s", tmp);
        } else {
          mm_sprintf_lite(s, ":%d", l_tmp);
        }
      }
      q_off += len;
      t_off += len;
    } else
    if (op == 1) {
      j = 0;
      *(tmp + len) = (char)0;
      while (j < len) {
        *(tmp + j) = (char )*("acgtn" + *(qseq + (q_off + j)));
        j ++;
      }
      mm_sprintf_lite(s, "+%s", tmp);
      q_off += len;
    } else
    if (op == 2) {
      j = 0;
      *(tmp + len) = (char)0;
      while (j < len) {
        *(tmp + j) = (char )*("acgtn" + *(tseq + (t_off + j)));
        j ++;
      }
      mm_sprintf_lite(s, "-%s", tmp);
      t_off += len;
    } else {
      if (! (len >= 2)) {
        __assert_fail("len >= 2", "format.c", 180U, "write_cs_core");
      }
      mm_sprintf_lite(s, "~%c%c%d%c%c", (int const   )*("acgtn" + *(tseq + t_off)),
                      (int const   )*("acgtn" + *(tseq + (t_off + 1))), len, (int const   )*("acgtn" + *(tseq + ((t_off + len) - 2))),
                      (int const   )*("acgtn" + *(tseq + ((t_off + len) - 1))));
      t_off += len;
    }
    i ++;
  }
  if (t_off == (int )(r->re - r->rs)) {
    if (! (q_off == (int )(r->qe - r->qs))) {
      __assert_fail("t_off == r->re - r->rs && q_off == r->qe - r->qs", "format.c",
                    186U, "write_cs_core");
    }
  } else {
    __assert_fail("t_off == r->re - r->rs && q_off == r->qe - r->qs", "format.c",
                  186U, "write_cs_core");
  }
  return;
}
}
static void write_MD_core(kstring_t *s , uint8_t const   *tseq , uint8_t const   *qseq ,
                          mm_reg1_t const   *r , char *tmp , int write_tag ) 
{ 
  int i ;
  int q_off ;
  int t_off ;
  int l_MD ;
  int j ;
  int op ;
  int len ;

  {
  l_MD = 0;
  if (write_tag) {
    mm_sprintf_lite(s, "\tMD:Z:");
  }
  t_off = 0;
  q_off = t_off;
  i = q_off;
  while (i < (int )(r->p)->n_cigar) {
    op = (int )((r->p)->cigar[i] & 15U);
    len = (int )((r->p)->cigar[i] >> 4);
    if (op >= 0) {
      if (! (op <= 3)) {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (! (op == 7)) {
      if (! (op == 8)) {
        __assert_fail("(op >= MM_CIGAR_MATCH && op <= MM_CIGAR_N_SKIP) || op == MM_CIGAR_EQ_MATCH || op == MM_CIGAR_X_MISMATCH",
                      "format.c", 195U, "write_MD_core");
      }
    }
    if (op == 0) {
      goto _L___1;
    } else
    if (op == 7) {
      goto _L___1;
    } else
    if (op == 8) {
      _L___1: /* CIL Label */ 
      j = 0;
      while (j < len) {
        if ((int const   )*(qseq + (q_off + j)) != (int const   )*(tseq + (t_off + j))) {
          mm_sprintf_lite(s, "%d%c", l_MD, (int const   )*("ACGTN" + *(tseq + (t_off + j))));
          l_MD = 0;
        } else {
          l_MD ++;
        }
        j ++;
      }
      q_off += len;
      t_off += len;
    } else
    if (op == 1) {
      q_off += len;
    } else
    if (op == 2) {
      j = 0;
      *(tmp + len) = (char)0;
      while (j < len) {
        *(tmp + j) = (char )*("ACGTN" + *(tseq + (t_off + j)));
        j ++;
      }
      mm_sprintf_lite(s, "%d^%s", l_MD, tmp);
      l_MD = 0;
      t_off += len;
    } else
    if (op == 3) {
      t_off += len;
    }
    i ++;
  }
  if (l_MD > 0) {
    mm_sprintf_lite(s, "%d", l_MD);
  }
  if (t_off == (int )(r->re - r->rs)) {
    if (! (q_off == (int )(r->qe - r->qs))) {
      __assert_fail("t_off == r->re - r->rs && q_off == r->qe - r->qs", "format.c",
                    217U, "write_MD_core");
    }
  } else {
    __assert_fail("t_off == r->re - r->rs && q_off == r->qe - r->qs", "format.c",
                  217U, "write_MD_core");
  }
  return;
}
}
static void write_cs_or_MD(void *km , kstring_t *s , mm_idx_t const   *mi , mm_bseq1_t const   *t ,
                           mm_reg1_t const   *r , int no_iden , int is_MD , int write_tag ,
                           int is_qstrand ) 
{ 
  int i ;
  uint8_t *qseq ;
  uint8_t *tseq ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int32_t tmp___2 ;
  void *tmp___3 ;
  uint8_t c ;

  {
  if ((unsigned long )r->p == (unsigned long )((mm_extra_t * const  )0)) {
    return;
  }
  tmp___0 = kmalloc(km, (size_t )(r->qe - r->qs));
  qseq = (uint8_t *)tmp___0;
  tmp___1 = kmalloc(km, (size_t )(r->re - r->rs));
  tseq = (uint8_t *)tmp___1;
  if (r->re - r->rs > r->qe - r->qs) {
    tmp___2 = (r->re - r->rs) + 1;
  } else {
    tmp___2 = (r->qe - r->qs) + 1;
  }
  tmp___3 = kmalloc(km, (size_t )tmp___2);
  tmp = (char *)tmp___3;
  if (is_qstrand) {
    mm_idx_getseq2(mi, (int )r->rev, (uint32_t )r->rid, (uint32_t )r->rs, (uint32_t )r->re,
                   tseq);
    i = (int )r->qs;
    while (i < (int )r->qe) {
      *(qseq + (i - (int )r->qs)) = seq_nt4_table[(uint8_t )*(t->seq + i)];
      i ++;
    }
  } else {
    mm_idx_getseq(mi, (uint32_t )r->rid, (uint32_t )r->rs, (uint32_t )r->re, tseq);
    if (! r->rev) {
      i = (int )r->qs;
      while (i < (int )r->qe) {
        *(qseq + (i - (int )r->qs)) = seq_nt4_table[(uint8_t )*(t->seq + i)];
        i ++;
      }
    } else {
      i = (int )r->qs;
      while (i < (int )r->qe) {
        c = seq_nt4_table[(uint8_t )*(t->seq + i)];
        if ((int )c >= 4) {
          *(qseq + ((r->qe - (int32_t const   )i) - 1)) = (uint8_t )4;
        } else {
          *(qseq + ((r->qe - (int32_t const   )i) - 1)) = (uint8_t )(3 - (int )c);
        }
        i ++;
      }
    }
  }
  if (is_MD) {
    write_MD_core(s, (uint8_t const   *)tseq, (uint8_t const   *)qseq, r, tmp, write_tag);
  } else {
    write_cs_core(s, (uint8_t const   *)tseq, (uint8_t const   *)qseq, r, tmp, no_iden,
                  write_tag);
  }
  kfree(km, (void *)qseq);
  kfree(km, (void *)tseq);
  kfree(km, (void *)tmp);
  return;
}
}
int mm_gen_cs_or_MD(void *km , char **buf , int *max_len , mm_idx_t const   *mi ,
                    mm_reg1_t const   *r , char const   *seq , int is_MD , int no_iden ,
                    int is_qstrand ) 
{ 
  mm_bseq1_t t ;
  kstring_t str ;
  size_t tmp ;

  {
  str.s = *buf;
  str.l = (size_t )0;
  str.m = (size_t )*max_len;
  tmp = strlen(seq);
  t.l_seq = (int )tmp;
  t.seq = (char *)seq;
  write_cs_or_MD(km, & str, mi, (mm_bseq1_t const   *)(& t), r, no_iden, is_MD, 0,
                 is_qstrand);
  *max_len = (int )str.m;
  *buf = str.s;
  return ((int )str.l);
}
}
int mm_gen_cs(void *km , char **buf , int *max_len , mm_idx_t const   *mi , mm_reg1_t const   *r ,
              char const   *seq , int no_iden ) 
{ 
  int tmp ;

  {
  tmp = mm_gen_cs_or_MD(km, buf, max_len, mi, r, seq, 0, no_iden, 0);
  return (tmp);
}
}
int mm_gen_MD(void *km , char **buf , int *max_len , mm_idx_t const   *mi , mm_reg1_t const   *r ,
              char const   *seq ) 
{ 
  int tmp ;

  {
  tmp = mm_gen_cs_or_MD(km, buf, max_len, mi, r, seq, 1, 0, 0);
  return (tmp);
}
}
__inline static void write_tags(kstring_t *s , mm_reg1_t const   *r ) 
{ 
  int type ;
  char buf[16] ;
  double div___0 ;
  double tmp ;
  double tmp___0 ;
  char buf___0[16] ;

  {
  if (r->id == r->parent) {
    if (r->inv) {
      type = 'I';
    } else {
      type = 'P';
    }
  } else
  if (r->inv) {
    type = 'i';
  } else {
    type = 'S';
  }
  if (r->p) {
    mm_sprintf_lite(s, "\tNM:i:%d\tms:i:%d\tAS:i:%d\tnn:i:%d", (uint32_t )(r->blen - r->mlen) + (r->p)->n_ambi,
                    (r->p)->dp_max, (r->p)->dp_score, (r->p)->n_ambi);
    if ((r->p)->trans_strand == 1U) {
      mm_sprintf_lite(s, "\tts:A:%c", (int const   )*("?+-?" + (r->p)->trans_strand));
    } else
    if ((r->p)->trans_strand == 2U) {
      mm_sprintf_lite(s, "\tts:A:%c", (int const   )*("?+-?" + (r->p)->trans_strand));
    }
  }
  mm_sprintf_lite(s, "\ttp:A:%c\tcm:i:%d\ts1:i:%d", type, r->cnt, r->score);
  if (r->parent == r->id) {
    mm_sprintf_lite(s, "\ts2:i:%d", r->subsc);
  }
  if (r->p) {
    tmp = mm_event_identity(r);
    div___0 = 1.0 - tmp;
    if (div___0 == 0.0) {
      buf[0] = (char )'0';
      buf[1] = (char)0;
    } else {
      tmp___0 = mm_event_identity(r);
      snprintf((char * __restrict  )(buf), (size_t )16, (char const   * __restrict  )"%.4f",
               1.0 - tmp___0);
    }
    mm_sprintf_lite(s, "\tde:f:%s", buf);
  } else
  if (r->div >= (float const   )0.0f) {
    if (r->div <= (float const   )1.0f) {
      if (r->div == (float const   )0.0f) {
        buf___0[0] = (char )'0';
        buf___0[1] = (char)0;
      } else {
        snprintf((char * __restrict  )(buf___0), (size_t )16, (char const   * __restrict  )"%.4f",
                 (double const   )r->div);
      }
      mm_sprintf_lite(s, "\tdv:f:%s", buf___0);
    }
  }
  if (r->split) {
    mm_sprintf_lite(s, "\tzd:i:%d", r->split);
  }
  return;
}
}
void mm_write_paf3(kstring_t *s , mm_idx_t const   *mi , mm_bseq1_t const   *t , mm_reg1_t const   *r ,
                   void *km , int64_t opt_flag , int rep_len ) 
{ 
  uint32_t k ;

  {
  s->l = (size_t )0;
  if ((unsigned long )r == (unsigned long )((mm_reg1_t const   *)0)) {
    mm_sprintf_lite(s, "%s\t%d\t0\t0\t*\t*\t0\t0\t0\t0\t0\t0", t->name, t->l_seq);
    if (rep_len >= 0) {
      mm_sprintf_lite(s, "\trl:i:%d", rep_len);
    }
    return;
  }
  mm_sprintf_lite(s, "%s\t%d\t%d\t%d\t%c\t", t->name, t->l_seq, r->qs, r->qe, (int const   )*("+-" + r->rev));
  if ((mi->seq + r->rid)->name) {
    mm_sprintf_lite(s, "%s", (mi->seq + r->rid)->name);
  } else {
    mm_sprintf_lite(s, "%d", r->rid);
  }
  mm_sprintf_lite(s, "\t%d", (mi->seq + r->rid)->len);
  if ((long long )opt_flag & 4294967296LL) {
    if (r->rev) {
      mm_sprintf_lite(s, "\t%d\t%d", (mi->seq + r->rid)->len - (uint32_t )r->re, (mi->seq + r->rid)->len - (uint32_t )r->rs);
    } else {
      mm_sprintf_lite(s, "\t%d\t%d", r->rs, r->re);
    }
  } else {
    mm_sprintf_lite(s, "\t%d\t%d", r->rs, r->re);
  }
  mm_sprintf_lite(s, "\t%d\t%d", r->mlen, r->blen);
  mm_sprintf_lite(s, "\t%d", r->mapq);
  write_tags(s, r);
  if (rep_len >= 0) {
    mm_sprintf_lite(s, "\trl:i:%d", rep_len);
  }
  if (r->p) {
    if (opt_flag & 32L) {
      mm_sprintf_lite(s, "\tcg:Z:");
      k = (uint32_t )0;
      while (k < (r->p)->n_cigar) {
        mm_sprintf_lite(s, "%d%c", (r->p)->cigar[k] >> 4, (int const   )*("MIDNSHP=XB" + ((r->p)->cigar[k] & 15U)));
        k ++;
      }
    }
  }
  if (r->p) {
    if (opt_flag & 16777280L) {
      write_cs_or_MD(km, s, mi, t, r, ! (opt_flag & 2048L), (int )(opt_flag & 16777216L),
                     1, ! (! ((long long )opt_flag & 4294967296LL)));
    }
  }
  if (opt_flag & 33554432L) {
    if (t->comment) {
      mm_sprintf_lite(s, "\t%s", t->comment);
    }
  }
  return;
}
}
void mm_write_paf(kstring_t *s , mm_idx_t const   *mi , mm_bseq1_t const   *t , mm_reg1_t const   *r ,
                  void *km , int64_t opt_flag ) 
{ 


  {
  mm_write_paf3(s, mi, t, r, km, opt_flag, -1);
  return;
}
}
static void sam_write_sq(kstring_t *s , char *seq , int l , int rev , int comp ) 
{ 
  int i ;
  int c ;

  {
  if (rev) {
    str_enlarge(s, l);
    i = 0;
    while (i < l) {
      c = (int )*(seq + ((l - 1) - i));
      if (c < 128) {
        if (comp) {
          *(s->s + (s->l + (size_t )i)) = (char )seq_comp_table[c];
        } else {
          *(s->s + (s->l + (size_t )i)) = (char )c;
        }
      } else {
        *(s->s + (s->l + (size_t )i)) = (char )c;
      }
      i ++;
    }
    s->l += (size_t )l;
  } else {
    str_copy(s, (char const   *)seq, (char const   *)(seq + l));
  }
  return;
}
}
__inline static mm_reg1_t const   *get_sam_pri(int n_regs , mm_reg1_t const   *regs ) 
{ 
  int i ;

  {
  i = 0;
  while (i < n_regs) {
    if ((regs + i)->sam_pri) {
      return (regs + i);
    }
    i ++;
  }
  if (! (n_regs == 0)) {
    __assert_fail("n_regs == 0", "format.c", 359U, "get_sam_pri");
  }
  return ((mm_reg1_t const   *)((void *)0));
}
}
static void write_sam_cigar(kstring_t *s , int sam_flag , int in_tag , int qlen ,
                            mm_reg1_t const   *r , int64_t opt_flag ) 
{ 
  uint32_t k ;
  uint32_t clip_len[2] ;
  int clip_char ;
  int tmp ;
  int clip_char___0 ;
  int tmp___0 ;

  {
  if ((unsigned long )r->p == (unsigned long )((mm_extra_t * const  )0)) {
    mm_sprintf_lite(s, "*");
  } else {
    if (r->rev) {
      clip_len[0] = (uint32_t )(qlen - (int )r->qe);
    } else {
      clip_len[0] = (uint32_t )r->qs;
    }
    if (r->rev) {
      clip_len[1] = (uint32_t )r->qs;
    } else {
      clip_len[1] = (uint32_t )(qlen - (int )r->qe);
    }
    if (in_tag) {
      if (sam_flag & 2048) {
        if (! (opt_flag & 524288L)) {
          tmp = 5;
        } else {
          tmp = 4;
        }
      } else {
        tmp = 4;
      }
      clip_char = tmp;
      mm_sprintf_lite(s, "\tCG:B:I");
      if (clip_len[0]) {
        mm_sprintf_lite(s, ",%u", (clip_len[0] << 4) | (unsigned int )clip_char);
      }
      k = (uint32_t )0;
      while (k < (r->p)->n_cigar) {
        mm_sprintf_lite(s, ",%u", (r->p)->cigar[k]);
        k ++;
      }
      if (clip_len[1]) {
        mm_sprintf_lite(s, ",%u", (clip_len[1] << 4) | (unsigned int )clip_char);
      }
    } else {
      if (sam_flag & 2048) {
        if (! (opt_flag & 524288L)) {
          tmp___0 = 'H';
        } else {
          tmp___0 = 'S';
        }
      } else {
        tmp___0 = 'S';
      }
      clip_char___0 = tmp___0;
      if (clip_len[0] < (uint32_t )qlen) {
        if (! (clip_len[1] < (uint32_t )qlen)) {
          __assert_fail("clip_len[0] < qlen && clip_len[1] < qlen", "format.c", 380U,
                        "write_sam_cigar");
        }
      } else {
        __assert_fail("clip_len[0] < qlen && clip_len[1] < qlen", "format.c", 380U,
                      "write_sam_cigar");
      }
      if (clip_len[0]) {
        mm_sprintf_lite(s, "%d%c", clip_len[0], clip_char___0);
      }
      k = (uint32_t )0;
      while (k < (r->p)->n_cigar) {
        mm_sprintf_lite(s, "%d%c", (r->p)->cigar[k] >> 4, (int const   )*("MIDNSHP=XB" + ((r->p)->cigar[k] & 15U)));
        k ++;
      }
      if (clip_len[1]) {
        mm_sprintf_lite(s, "%d%c", clip_len[1], clip_char___0);
      }
    }
  }
  return;
}
}
void mm_write_sam3(kstring_t *s , mm_idx_t const   *mi , mm_bseq1_t const   *t , int seg_idx ,
                   int reg_idx , int n_seg , int const   *n_regss , mm_reg1_t const   * const  *regss ,
                   void *km , int64_t opt_flag , int rep_len ) 
{ 
  int max_bam_cigar_op ;
  int flag ;
  int n_regs ;
  int cigar_in_tag ;
  int this_rid ;
  int this_pos ;
  mm_reg1_t const   *regs ;
  mm_reg1_t const   *r_prev ;
  mm_reg1_t const   *r_next ;
  mm_reg1_t const   *r ;
  mm_reg1_t const   *tmp ;
  int i ;
  int next_sid ;
  int prev_sid ;
  int tmp___0 ;
  int n_cigar ;
  int slen ;
  int tlen ;
  int this_pos5 ;
  int32_t tmp___1 ;
  int next_pos5 ;
  int32_t tmp___2 ;
  int i___0 ;
  int n_sa ;
  mm_reg1_t const   *q ;
  int l_M ;
  int l_I ;
  int l_D ;
  int clip5 ;
  int clip3 ;

  {
  max_bam_cigar_op = 65535;
  n_regs = (int )*(n_regss + seg_idx);
  cigar_in_tag = 0;
  this_rid = -1;
  this_pos = -1;
  regs = (mm_reg1_t const   *)*(regss + seg_idx);
  r_prev = (mm_reg1_t const   *)((void *)0);
  if (n_regs > 0) {
    if (reg_idx < n_regs) {
      if (reg_idx >= 0) {
        tmp = regs + reg_idx;
      } else {
        tmp = (mm_reg1_t const   *)((void *)0);
      }
    } else {
      tmp = (mm_reg1_t const   *)((void *)0);
    }
  } else {
    tmp = (mm_reg1_t const   *)((void *)0);
  }
  r = tmp;
  if (n_seg > 1) {
    next_sid = (seg_idx + 1) % n_seg;
    r_next = get_sam_pri((int )*(n_regss + next_sid), (mm_reg1_t const   *)*(regss + next_sid));
    if (n_seg > 2) {
      i = 1;
      while (i <= n_seg - 1) {
        prev_sid = ((seg_idx + n_seg) - i) % n_seg;
        if (*(n_regss + prev_sid) > 0) {
          r_prev = get_sam_pri((int )*(n_regss + prev_sid), (mm_reg1_t const   *)*(regss + prev_sid));
          break;
        }
        i ++;
      }
    } else {
      r_prev = r_next;
    }
  } else {
    r_next = (mm_reg1_t const   *)((void *)0);
    r_prev = r_next;
  }
  s->l = (size_t )0;
  mm_sprintf_lite(s, "%s", t->name);
  if (n_seg > 1) {
    tmp___0 = mm_qname_len((char const   *)t->name);
    s->l = (size_t )tmp___0;
  }
  if (n_seg > 1) {
    flag = 1;
  } else {
    flag = 0;
  }
  if ((unsigned long )r == (unsigned long )((mm_reg1_t const   *)0)) {
    flag |= 4;
  } else {
    if (r->rev) {
      flag |= 16;
    }
    if (r->parent != r->id) {
      flag |= 256;
    } else
    if (! r->sam_pri) {
      flag |= 2048;
    }
  }
  if (n_seg > 1) {
    if (r) {
      if (r->proper_frag) {
        flag |= 2;
      }
    }
    if (seg_idx == 0) {
      flag |= 64;
    } else
    if (seg_idx == n_seg - 1) {
      flag |= 128;
    }
    if ((unsigned long )r_next == (unsigned long )((void *)0)) {
      flag |= 8;
    } else
    if (r_next->rev) {
      flag |= 32;
    }
  }
  mm_sprintf_lite(s, "\t%d", flag);
  if ((unsigned long )r == (unsigned long )((mm_reg1_t const   *)0)) {
    if (r_prev) {
      this_rid = (int )r_prev->rid;
      this_pos = (int )r_prev->rs;
      mm_sprintf_lite(s, "\t%s\t%d\t0\t*", (mi->seq + this_rid)->name, this_pos + 1);
    } else {
      mm_sprintf_lite(s, "\t*\t0\t0\t*");
    }
  } else {
    this_rid = (int )r->rid;
    this_pos = (int )r->rs;
    mm_sprintf_lite(s, "\t%s\t%d\t%d\t", (mi->seq + r->rid)->name, r->rs + 1, r->mapq);
    if (opt_flag & 65536L) {
      if (r->p) {
        if ((r->p)->n_cigar > (uint32_t )(max_bam_cigar_op - 2)) {
          n_cigar = (int )(r->p)->n_cigar;
          if (r->qs != 0) {
            n_cigar ++;
          }
          if (r->qe != t->l_seq) {
            n_cigar ++;
          }
          if (n_cigar > max_bam_cigar_op) {
            cigar_in_tag = 1;
          }
        }
      }
    }
    if (cigar_in_tag) {
      if ((flag & 2304) == 0) {
        slen = (int )t->l_seq;
      } else
      if (opt_flag & 524288L) {
        slen = (int )t->l_seq;
      } else
      if (flag & 256) {
        slen = 0;
      } else {
        slen = (int )(r->qe - r->qs);
      }
      mm_sprintf_lite(s, "%dS%dN", slen, r->re - r->rs);
    } else {
      write_sam_cigar(s, flag, 0, (int )t->l_seq, r, opt_flag);
    }
  }
  if (n_seg > 1) {
    tlen = 0;
    if (this_rid >= 0) {
      if (r_next) {
        if (this_rid == (int )r_next->rid) {
          if (r) {
            if (r->rev) {
              tmp___1 = r->re - 1;
            } else {
              tmp___1 = (int32_t const   )this_pos;
            }
            this_pos5 = (int )tmp___1;
            if (r_next->rev) {
              tmp___2 = r_next->re - 1;
            } else {
              tmp___2 = r_next->rs;
            }
            next_pos5 = (int )tmp___2;
            tlen = next_pos5 - this_pos5;
          }
          mm_sprintf_lite(s, "\t=\t");
        } else {
          mm_sprintf_lite(s, "\t%s\t", (mi->seq + r_next->rid)->name);
        }
        mm_sprintf_lite(s, "%d\t", r_next->rs + 1);
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (r_next) {
      mm_sprintf_lite(s, "\t%s\t%d\t", (mi->seq + r_next->rid)->name, r_next->rs + 1);
    } else
    if (this_rid >= 0) {
      mm_sprintf_lite(s, "\t=\t%d\t", this_pos + 1);
    } else {
      mm_sprintf_lite(s, "\t*\t0\t");
    }
    if (tlen > 0) {
      tlen ++;
    } else
    if (tlen < 0) {
      tlen --;
    }
    mm_sprintf_lite(s, "%d\t", tlen);
  } else {
    mm_sprintf_lite(s, "\t*\t0\t0\t");
  }
  if ((unsigned long )r == (unsigned long )((mm_reg1_t const   *)0)) {
    sam_write_sq(s, (char *)t->seq, (int )t->l_seq, 0, 0);
    mm_sprintf_lite(s, "\t");
    if (t->qual) {
      sam_write_sq(s, (char *)t->qual, (int )t->l_seq, 0, 0);
    } else {
      mm_sprintf_lite(s, "*");
    }
  } else
  if ((flag & 2304) == 0) {
    goto _L___0;
  } else
  if (opt_flag & 524288L) {
    _L___0: /* CIL Label */ 
    sam_write_sq(s, (char *)t->seq, (int )t->l_seq, (int )r->rev, (int )r->rev);
    mm_sprintf_lite(s, "\t");
    if (t->qual) {
      sam_write_sq(s, (char *)t->qual, (int )t->l_seq, (int )r->rev, 0);
    } else {
      mm_sprintf_lite(s, "*");
    }
  } else
  if (flag & 256) {
    mm_sprintf_lite(s, "*\t*");
  } else {
    sam_write_sq(s, (char *)(t->seq + r->qs), (int )(r->qe - r->qs), (int )r->rev,
                 (int )r->rev);
    mm_sprintf_lite(s, "\t");
    if (t->qual) {
      sam_write_sq(s, (char *)(t->qual + r->qs), (int )(r->qe - r->qs), (int )r->rev,
                   0);
    } else {
      mm_sprintf_lite(s, "*");
    }
  }
  if (mm_rg_id[0]) {
    mm_sprintf_lite(s, "\tRG:Z:%s", mm_rg_id);
  }
  if (n_seg > 2) {
    mm_sprintf_lite(s, "\tFI:i:%d", seg_idx);
  }
  if (r) {
    write_tags(s, r);
    if (r->parent == r->id) {
      if (r->p) {
        if (n_regs > 1) {
          if (regs) {
            if ((unsigned long )r >= (unsigned long )regs) {
              if (r - regs < (long )n_regs) {
                n_sa = 0;
                i___0 = 0;
                while (i___0 < n_regs) {
                  if ((long )i___0 != r - regs) {
                    if ((regs + i___0)->parent == (regs + i___0)->id) {
                      if ((regs + i___0)->p) {
                        n_sa ++;
                      }
                    }
                  }
                  i___0 ++;
                }
                if (n_sa > 0) {
                  mm_sprintf_lite(s, "\tSA:Z:");
                  i___0 = 0;
                  while (i___0 < n_regs) {
                    q = regs + i___0;
                    l_I = 0;
                    l_D = 0;
                    clip5 = 0;
                    clip3 = 0;
                    if ((unsigned long )r == (unsigned long )q) {
                      goto __Cont;
                    } else
                    if (q->parent != q->id) {
                      goto __Cont;
                    } else
                    if ((unsigned long )q->p == (unsigned long )((mm_extra_t * const  )0)) {
                      goto __Cont;
                    }
                    if (q->qe - q->qs < q->re - q->rs) {
                      l_M = (int )(q->qe - q->qs);
                      l_D = (int )((q->re - q->rs) - (int32_t const   )l_M);
                    } else {
                      l_M = (int )(q->re - q->rs);
                      l_I = (int )((q->qe - q->qs) - (int32_t const   )l_M);
                    }
                    if (q->rev) {
                      clip5 = (int )(t->l_seq - q->qe);
                    } else {
                      clip5 = (int )q->qs;
                    }
                    if (q->rev) {
                      clip3 = (int )q->qs;
                    } else {
                      clip3 = (int )(t->l_seq - q->qe);
                    }
                    mm_sprintf_lite(s, "%s,%d,%c,", (mi->seq + q->rid)->name, q->rs + 1,
                                    (int const   )*("+-" + q->rev));
                    if (clip5) {
                      mm_sprintf_lite(s, "%dS", clip5);
                    }
                    if (l_M) {
                      mm_sprintf_lite(s, "%dM", l_M);
                    }
                    if (l_I) {
                      mm_sprintf_lite(s, "%dI", l_I);
                    }
                    if (l_D) {
                      mm_sprintf_lite(s, "%dD", l_D);
                    }
                    if (clip3) {
                      mm_sprintf_lite(s, "%dS", clip3);
                    }
                    mm_sprintf_lite(s, ",%d,%d;", q->mapq, (uint32_t )(q->blen - q->mlen) + (q->p)->n_ambi);
                    __Cont: /* CIL Label */ 
                    i___0 ++;
                  }
                }
              }
            }
          }
        }
      }
    }
    if (r->p) {
      if (opt_flag & 16777280L) {
        write_cs_or_MD(km, s, mi, t, r, ! (opt_flag & 2048L), (int )(opt_flag & 16777216L),
                       1, 0);
      }
    }
    if (cigar_in_tag) {
      write_sam_cigar(s, flag, 1, (int )t->l_seq, r, opt_flag);
    }
  }
  if (rep_len >= 0) {
    mm_sprintf_lite(s, "\trl:i:%d", rep_len);
  }
  if (opt_flag & 33554432L) {
    if (t->comment) {
      mm_sprintf_lite(s, "\t%s", t->comment);
    }
  }
  *(s->s + s->l) = (char)0;
  return;
}
}
void mm_write_sam2(kstring_t *s , mm_idx_t const   *mi , mm_bseq1_t const   *t , int seg_idx ,
                   int reg_idx , int n_seg , int const   *n_regss , mm_reg1_t const   * const  *regss ,
                   void *km , int64_t opt_flag ) 
{ 


  {
  mm_write_sam3(s, mi, t, seg_idx, reg_idx, n_seg, n_regss, regss, km, opt_flag, -1);
  return;
}
}
void mm_write_sam(kstring_t *s , mm_idx_t const   *mi , mm_bseq1_t const   *t , mm_reg1_t const   *r ,
                  int n_regs , mm_reg1_t const   *regs ) 
{ 
  int i ;

  {
  i = 0;
  while (i < n_regs) {
    if ((unsigned long )r == (unsigned long )(regs + i)) {
      break;
    }
    i ++;
  }
  mm_write_sam2(s, mi, t, 0, i, 1, (int const   *)(& n_regs), (mm_reg1_t const   * const  *)(& regs),
                (void *)0, (int64_t )0);
  return;
}
}
#pragma merger("0","/tmp/cil-kRopFwxv.i","-g,-Wall,-O2,-Wc++-compat")
extern  __attribute__((__nothrow__)) float logf(float __x ) ;
void radix_sort_128x(mm128_t *beg , mm128_t *end ) ;
void radix_sort_64(uint64_t *beg , uint64_t *end ) ;
mm_reg1_t *mm_gen_regs(void *km , uint32_t hash , int qlen , int n_u , uint64_t *u ,
                       mm128_t *a , int is_qstrand ) ;
void mm_mark_alt(mm_idx_t const   *mi , int n , mm_reg1_t *r ) ;
void mm_sync_regs(void *km , int n_regs , mm_reg1_t *regs ) ;
int mm_set_sam_pri(int n , mm_reg1_t *r ) ;
void mm_set_parent(void *km , float mask_level , int mask_len , int n , mm_reg1_t *r ,
                   int sub_diff , int hard_mask_level , float alt_diff_frac ) ;
void mm_select_sub(void *km , float pri_ratio , int min_diff , int best_n , int check_strand ,
                   int min_strand_sc , int *n_ , mm_reg1_t *r ) ;
int mm_filter_strand_retained(int n_regs , mm_reg1_t *r ) ;
void mm_set_mapq(void *km , int n_regs , mm_reg1_t *regs , int min_chain_sc , int match_sc ,
                 int rep_len , int is_sr ) ;
mm_seg_t *mm_seg_gen(void *km , uint32_t hash , int n_segs , int const   *qlens ,
                     int n_regs0 , mm_reg1_t const   *regs0 , int *n_regs , mm_reg1_t **regs ,
                     mm128_t const   *a ) ;
void mm_seg_free(void *km , int n_segs , mm_seg_t *segs ) ;
void *kcalloc(void *_km , size_t count , size_t size ) ;
__inline static void mm_cal_fuzzy_len(mm_reg1_t *r , mm128_t const   *a ) 
{ 
  int i ;
  int32_t tmp ;
  int32_t tmp___0 ;
  int span ;
  int tl ;
  int ql ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp = 0;
  r->blen = tmp;
  r->mlen = tmp;
  if (r->cnt <= 0) {
    return;
  }
  tmp___0 = (int32_t )(((a + r->as)->y >> 32) & 255UL);
  r->blen = tmp___0;
  r->mlen = tmp___0;
  i = r->as + 1;
  while (i < r->as + r->cnt) {
    span = (int )(((a + i)->y >> 32) & 255UL);
    tl = (int32_t )(a + i)->x - (int32_t )(a + (i - 1))->x;
    ql = (int32_t )(a + i)->y - (int32_t )(a + (i - 1))->y;
    if (tl > ql) {
      tmp___1 = tl;
    } else {
      tmp___1 = ql;
    }
    r->blen += tmp___1;
    if (tl > span) {
      if (ql > span) {
        tmp___3 = span;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      if (tl < ql) {
        tmp___2 = tl;
      } else {
        tmp___2 = ql;
      }
      tmp___3 = tmp___2;
    }
    r->mlen += tmp___3;
    i ++;
  }
  return;
}
}
__inline static void mm_reg_set_coor(mm_reg1_t *r , int32_t qlen , mm128_t const   *a ,
                                     int is_qstrand ) 
{ 
  int32_t k ;
  int32_t q_span ;

  {
  k = r->as;
  q_span = (int32_t )(((a + k)->y >> 32) & 255UL);
  r->rev = (uint32_t )((a + k)->x >> 63);
  r->rid = (int32_t )(((a + k)->x << 1) >> 33);
  if ((int32_t )(a + k)->x + 1 > q_span) {
    r->rs = ((int32_t )(a + k)->x + 1) - q_span;
  } else {
    r->rs = 0;
  }
  r->re = (int32_t )(a + ((k + r->cnt) - 1))->x + 1;
  if (! r->rev) {
    r->qs = ((int32_t )(a + k)->y + 1) - q_span;
    r->qe = (int32_t )(a + ((k + r->cnt) - 1))->y + 1;
  } else
  if (is_qstrand) {
    r->qs = ((int32_t )(a + k)->y + 1) - q_span;
    r->qe = (int32_t )(a + ((k + r->cnt) - 1))->y + 1;
  } else {
    r->qs = qlen - ((int32_t )(a + ((k + r->cnt) - 1))->y + 1);
    r->qe = qlen - (((int32_t )(a + k)->y + 1) - q_span);
  }
  mm_cal_fuzzy_len(r, a);
  return;
}
}
__inline static uint64_t hash64(uint64_t key ) 
{ 


  {
  key = ~ key + (key << 21);
  key ^= key >> 24;
  key = (key + (key << 3)) + (key << 8);
  key ^= key >> 14;
  key = (key + (key << 2)) + (key << 4);
  key ^= key >> 28;
  key += key << 31;
  return (key);
}
}
mm_reg1_t *mm_gen_regs(void *km , uint32_t hash , int qlen , int n_u , uint64_t *u ,
                       mm128_t *a , int is_qstrand ) 
{ 
  mm128_t *z ;
  mm128_t tmp ;
  mm_reg1_t *r ;
  int i ;
  int k ;
  void *tmp___0 ;
  uint32_t h ;
  uint64_t tmp___1 ;
  uint64_t tmp___2 ;
  uint64_t tmp___3 ;
  void *tmp___4 ;
  mm_reg1_t *ri ;
  int32_t tmp___5 ;

  {
  if (n_u == 0) {
    return ((mm_reg1_t *)0);
  }
  tmp___0 = kmalloc(km, (size_t )(n_u * 16));
  z = (mm128_t *)tmp___0;
  k = 0;
  i = k;
  while (i < n_u) {
    tmp___1 = hash64((a + k)->x);
    tmp___2 = hash64((a + k)->y);
    tmp___3 = hash64((tmp___1 + tmp___2) ^ (unsigned long )hash);
    h = (uint32_t )tmp___3;
    (z + i)->x = *(u + i) ^ (unsigned long )h;
    (z + i)->y = ((uint64_t )k << 32) | (unsigned long )((int32_t )*(u + i));
    k += (int32_t )*(u + i);
    i ++;
  }
  radix_sort_128x(z, z + n_u);
  i = 0;
  while (i < n_u >> 1) {
    tmp = *(z + i);
    *(z + i) = *(z + ((n_u - 1) - i));
    *(z + ((n_u - 1) - i)) = tmp;
    i ++;
  }
  tmp___4 = calloc((size_t )n_u, sizeof(mm_reg1_t ));
  r = (mm_reg1_t *)tmp___4;
  i = 0;
  while (i < n_u) {
    ri = r + i;
    ri->id = i;
    ri->parent = -1;
    tmp___5 = (int32_t )((z + i)->x >> 32);
    ri->score0 = tmp___5;
    ri->score = tmp___5;
    ri->hash = (uint32_t )(z + i)->x;
    ri->cnt = (int32_t )(z + i)->y;
    ri->as = (int32_t )((z + i)->y >> 32);
    ri->div = - 1.0f;
    mm_reg_set_coor(ri, qlen, (mm128_t const   *)a, is_qstrand);
    i ++;
  }
  kfree(km, (void *)z);
  return (r);
}
}
void mm_mark_alt(mm_idx_t const   *mi , int n , mm_reg1_t *r ) 
{ 
  int i ;

  {
  if (mi->n_alt == 0) {
    return;
  }
  i = 0;
  while (i < n) {
    if ((mi->seq + (r + i)->rid)->is_alt) {
      (r + i)->is_alt = (uint32_t )1;
    }
    i ++;
  }
  return;
}
}
__inline static int mm_alt_score(int score , float alt_diff_frac ) 
{ 
  int tmp ;

  {
  if (score < 0) {
    return (score);
  }
  score = (int )((double )score * (1.0 - (double )alt_diff_frac) + .499);
  if (score > 0) {
    tmp = score;
  } else {
    tmp = 1;
  }
  return (tmp);
}
}
void mm_split_reg(mm_reg1_t *r , mm_reg1_t *r2 , int n , int qlen , mm128_t *a , int is_qstrand ) 
{ 


  {
  if (n <= 0) {
    return;
  } else
  if (n >= r->cnt) {
    return;
  }
  *r2 = *r;
  r2->id = -1;
  r2->sam_pri = (uint32_t )0;
  r2->p = (mm_extra_t *)0;
  r2->split_inv = (uint32_t )0;
  r2->cnt = r->cnt - n;
  r2->score = (int32_t )((double )((float )r->score * ((float )r2->cnt / (float )r->cnt)) + .499);
  r2->as = r->as + n;
  if (r->parent == r->id) {
    r2->parent = -2;
  }
  mm_reg_set_coor(r2, qlen, (mm128_t const   *)a, is_qstrand);
  r->cnt -= r2->cnt;
  r->score -= r2->score;
  mm_reg_set_coor(r, qlen, (mm128_t const   *)a, is_qstrand);
  r->split |= 1U;
  r2->split |= 2U;
  return;
}
}
void mm_set_parent(void *km , float mask_level , int mask_len , int n , mm_reg1_t *r ,
                   int sub_diff , int hard_mask_level , float alt_diff_frac ) 
{ 
  int i ;
  int j ;
  int k ;
  int *w ;
  uint64_t *cov ;
  void *tmp ;
  void *tmp___0 ;
  mm_reg1_t *ri ;
  int si ;
  int ei ;
  int n_cov ;
  int uncov_len ;
  mm_reg1_t *rp ;
  int sj ;
  int ej ;
  int tmp___1 ;
  int j___0 ;
  int x ;
  mm_reg1_t *rp___0 ;
  int sj___0 ;
  int ej___0 ;
  int min ;
  int max ;
  int ol ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int cnt_sub ;
  int sci ;
  int tmp___6 ;

  {
  if (n <= 0) {
    return;
  }
  i = 0;
  while (i < n) {
    (r + i)->id = i;
    i ++;
  }
  tmp = kmalloc(km, (unsigned long )n * sizeof(uint64_t ));
  cov = (uint64_t *)tmp;
  tmp___0 = kmalloc(km, (unsigned long )n * sizeof(int ));
  w = (int *)tmp___0;
  *(w + 0) = 0;
  (r + 0)->parent = 0;
  i = 1;
  k = 1;
  while (i < n) {
    ri = r + i;
    si = ri->qs;
    ei = ri->qe;
    n_cov = 0;
    uncov_len = 0;
    if (hard_mask_level) {
      goto skip_uncov;
    }
    j = 0;
    while (j < k) {
      rp = r + *(w + j);
      sj = rp->qs;
      ej = rp->qe;
      if (ej <= si) {
        goto __Cont;
      } else
      if (sj >= ei) {
        goto __Cont;
      }
      if (sj < si) {
        sj = si;
      }
      if (ej > ei) {
        ej = ei;
      }
      tmp___1 = n_cov;
      n_cov ++;
      *(cov + tmp___1) = ((uint64_t )sj << 32) | (unsigned long )ej;
      __Cont: /* CIL Label */ 
      j ++;
    }
    if (n_cov == 0) {
      goto set_parent_test;
    } else
    if (n_cov > 0) {
      x = si;
      radix_sort_64(cov, cov + n_cov);
      j___0 = 0;
      while (j___0 < n_cov) {
        if ((int )(*(cov + j___0) >> 32) > x) {
          uncov_len = (int )((uint64_t )uncov_len + ((*(cov + j___0) >> 32) - (uint64_t )x));
        }
        if ((int32_t )*(cov + j___0) > x) {
          x = (int32_t )*(cov + j___0);
        } else {
          x = x;
        }
        j___0 ++;
      }
      if (ei > x) {
        uncov_len += ei - x;
      }
    }
    skip_uncov: 
    j = 0;
    while (j < k) {
      rp___0 = r + *(w + j);
      sj___0 = rp___0->qs;
      ej___0 = rp___0->qe;
      if (ej___0 <= si) {
        goto __Cont___0;
      } else
      if (sj___0 >= ei) {
        goto __Cont___0;
      }
      if (ej___0 - sj___0 < ei - si) {
        min = ej___0 - sj___0;
      } else {
        min = ei - si;
      }
      if (ej___0 - sj___0 > ei - si) {
        max = ej___0 - sj___0;
      } else {
        max = ei - si;
      }
      if (si < sj___0) {
        if (ei < sj___0) {
          tmp___3 = 0;
        } else {
          if (ei < ej___0) {
            tmp___2 = ei - sj___0;
          } else {
            tmp___2 = ej___0 - sj___0;
          }
          tmp___3 = tmp___2;
        }
        ol = tmp___3;
      } else {
        if (ej___0 < si) {
          tmp___5 = 0;
        } else {
          if (ej___0 < ei) {
            tmp___4 = ej___0 - si;
          } else {
            tmp___4 = ei - si;
          }
          tmp___5 = tmp___4;
        }
        ol = tmp___5;
      }
      if ((float )ol / (float )min - (float )uncov_len / (float )max > mask_level) {
        if (uncov_len <= mask_len) {
          cnt_sub = 0;
          sci = ri->score;
          ri->parent = rp___0->parent;
          if (! rp___0->is_alt) {
            if (ri->is_alt) {
              sci = mm_alt_score(sci, alt_diff_frac);
            }
          }
          if (rp___0->subsc > sci) {
            rp___0->subsc = rp___0->subsc;
          } else {
            rp___0->subsc = sci;
          }
          if (ri->cnt >= rp___0->cnt) {
            cnt_sub = 1;
          }
          if (rp___0->p) {
            if (ri->p) {
              if (rp___0->rid != ri->rid) {
                goto _L;
              } else
              if (rp___0->rs != ri->rs) {
                goto _L;
              } else
              if (rp___0->re != ri->re) {
                goto _L;
              } else
              if (ol != min) {
                _L: /* CIL Label */ 
                sci = (ri->p)->dp_max;
                if (! rp___0->is_alt) {
                  if (ri->is_alt) {
                    sci = mm_alt_score(sci, alt_diff_frac);
                  }
                }
                if ((rp___0->p)->dp_max2 > sci) {
                  (rp___0->p)->dp_max2 = (rp___0->p)->dp_max2;
                } else {
                  (rp___0->p)->dp_max2 = sci;
                }
                if ((rp___0->p)->dp_max - (ri->p)->dp_max <= sub_diff) {
                  cnt_sub = 1;
                }
              }
            }
          }
          if (cnt_sub) {
            (rp___0->n_sub) ++;
          }
          break;
        }
      }
      __Cont___0: /* CIL Label */ 
      j ++;
    }
    set_parent_test: 
    if (j == k) {
      tmp___6 = k;
      k ++;
      *(w + tmp___6) = i;
      ri->parent = i;
      ri->n_sub = 0;
    }
    i ++;
  }
  kfree(km, (void *)cov);
  kfree(km, (void *)w);
  return;
}
}
void mm_hit_sort(void *km , int *n_regs , mm_reg1_t *r , float alt_diff_frac ) 
{ 
  int32_t i ;
  int32_t n_aux ;
  int32_t n ;
  int32_t has_cigar ;
  int32_t no_cigar ;
  mm128_t *aux ;
  mm_reg1_t *t ;
  void *tmp ;
  void *tmp___0 ;
  int score ;
  int32_t tmp___1 ;

  {
  n = *n_regs;
  has_cigar = 0;
  no_cigar = 0;
  if (n <= 1) {
    return;
  }
  tmp = kmalloc(km, (size_t )(n * 16));
  aux = (mm128_t *)tmp;
  tmp___0 = kmalloc(km, (unsigned long )n * sizeof(mm_reg1_t ));
  t = (mm_reg1_t *)tmp___0;
  n_aux = 0;
  i = n_aux;
  while (i < n) {
    if ((r + i)->inv) {
      goto _L;
    } else
    if ((r + i)->cnt > 0) {
      _L: /* CIL Label */ 
      if ((r + i)->p) {
        score = ((r + i)->p)->dp_max;
        has_cigar = 1;
      } else {
        score = (r + i)->score;
        no_cigar = 1;
      }
      if ((r + i)->is_alt) {
        score = mm_alt_score(score, alt_diff_frac);
      }
      (aux + n_aux)->x = ((uint64_t )score << 32) | (unsigned long )(r + i)->hash;
      tmp___1 = n_aux;
      n_aux ++;
      (aux + tmp___1)->y = (uint64_t )i;
    } else
    if ((r + i)->p) {
      free((void *)(r + i)->p);
      (r + i)->p = (mm_extra_t *)0;
    }
    i ++;
  }
  if (! (has_cigar + no_cigar == 1)) {
    __assert_fail("has_cigar + no_cigar == 1", "hit.c", 210U, "mm_hit_sort");
  }
  radix_sort_128x(aux, aux + n_aux);
  i = n_aux - 1;
  while (i >= 0) {
    *(t + ((n_aux - 1) - i)) = *(r + (aux + i)->y);
    i --;
  }
  memcpy((void * __restrict  )r, (void const   * __restrict  )t, sizeof(mm_reg1_t ) * (unsigned long )n_aux);
  *n_regs = n_aux;
  kfree(km, (void *)aux);
  kfree(km, (void *)t);
  return;
}
}
int mm_set_sam_pri(int n , mm_reg1_t *r ) 
{ 
  int i ;
  int n_pri ;

  {
  n_pri = 0;
  i = 0;
  while (i < n) {
    if ((r + i)->id == (r + i)->parent) {
      n_pri ++;
      (r + i)->sam_pri = (uint32_t )(n_pri == 1);
    } else {
      (r + i)->sam_pri = (uint32_t )0;
    }
    i ++;
  }
  return (n_pri);
}
}
void mm_sync_regs(void *km , int n_regs , mm_reg1_t *regs ) 
{ 
  int *tmp ;
  int i ;
  int max_id ;
  int n_tmp ;
  void *tmp___0 ;
  mm_reg1_t *r ;

  {
  max_id = -1;
  if (n_regs <= 0) {
    return;
  }
  i = 0;
  while (i < n_regs) {
    if (max_id > (regs + i)->id) {
      max_id = max_id;
    } else {
      max_id = (regs + i)->id;
    }
    i ++;
  }
  n_tmp = max_id + 1;
  tmp___0 = kmalloc(km, (unsigned long )n_tmp * sizeof(int ));
  tmp = (int *)tmp___0;
  i = 0;
  while (i < n_tmp) {
    *(tmp + i) = -1;
    i ++;
  }
  i = 0;
  while (i < n_regs) {
    if ((regs + i)->id >= 0) {
      *(tmp + (regs + i)->id) = i;
    }
    i ++;
  }
  i = 0;
  while (i < n_regs) {
    r = regs + i;
    r->id = i;
    if (r->parent == -2) {
      r->parent = i;
    } else
    if (r->parent >= 0) {
      if (*(tmp + r->parent) >= 0) {
        r->parent = *(tmp + r->parent);
      } else {
        r->parent = -1;
      }
    } else {
      r->parent = -1;
    }
    i ++;
  }
  kfree(km, (void *)tmp);
  mm_set_sam_pri(n_regs, regs);
  return;
}
}
void mm_select_sub(void *km , float pri_ratio , int min_diff , int best_n , int check_strand ,
                   int min_strand_sc , int *n_ , mm_reg1_t *r ) 
{ 
  int i ;
  int k ;
  int n ;
  int n_2nd ;
  int p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (pri_ratio > 0.0f) {
    if (*n_ > 0) {
      n = *n_;
      n_2nd = 0;
      k = 0;
      i = k;
      while (i < n) {
        p = (r + i)->parent;
        if (p == i) {
          tmp = k;
          k ++;
          *(r + tmp) = *(r + i);
        } else
        if ((r + i)->inv) {
          tmp = k;
          k ++;
          *(r + tmp) = *(r + i);
        } else
        if ((float )(r + i)->score >= (float )(r + p)->score * pri_ratio) {
          goto _L___3;
        } else
        if ((r + i)->score + min_diff >= (r + p)->score) {
          _L___3: /* CIL Label */ 
          if (n_2nd < best_n) {
            if ((r + i)->qs == (r + p)->qs) {
              if ((r + i)->qe == (r + p)->qe) {
                if ((r + i)->rid == (r + p)->rid) {
                  if ((r + i)->rs == (r + p)->rs) {
                    if ((r + i)->re == (r + p)->re) {
                      if ((r + i)->p) {
                        free((void *)(r + i)->p);
                      }
                    } else {
                      tmp___0 = k;
                      k ++;
                      *(r + tmp___0) = *(r + i);
                      n_2nd ++;
                    }
                  } else {
                    tmp___0 = k;
                    k ++;
                    *(r + tmp___0) = *(r + i);
                    n_2nd ++;
                  }
                } else {
                  tmp___0 = k;
                  k ++;
                  *(r + tmp___0) = *(r + i);
                  n_2nd ++;
                }
              } else {
                tmp___0 = k;
                k ++;
                *(r + tmp___0) = *(r + i);
                n_2nd ++;
              }
            } else {
              tmp___0 = k;
              k ++;
              *(r + tmp___0) = *(r + i);
              n_2nd ++;
            }
          } else {
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
        if (check_strand) {
          if (n_2nd < best_n) {
            if ((r + i)->score > min_strand_sc) {
              if ((r + i)->rev != (r + p)->rev) {
                (r + i)->strand_retained = (uint32_t )1;
                tmp___1 = k;
                k ++;
                *(r + tmp___1) = *(r + i);
                n_2nd ++;
              } else {
                goto _L___1;
              }
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
        if ((r + i)->p) {
          free((void *)(r + i)->p);
        }
        i ++;
      }
      if (k != n) {
        mm_sync_regs(km, k, r);
      }
      *n_ = k;
    }
  }
  return;
}
}
int mm_filter_strand_retained(int n_regs , mm_reg1_t *r ) 
{ 
  int i ;
  int k ;
  int p ;
  int tmp ;

  {
  k = 0;
  i = k;
  while (i < n_regs) {
    p = (r + i)->parent;
    if (! (r + i)->strand_retained) {
      goto _L;
    } else
    if ((r + i)->div < (r + p)->div * 5.0f) {
      goto _L;
    } else
    if ((r + i)->div < 0.01f) {
      _L: /* CIL Label */ 
      if (k < i) {
        tmp = k;
        k ++;
        *(r + tmp) = *(r + i);
      } else {
        k ++;
      }
    }
    i ++;
  }
  return (k);
}
}
void mm_filter_regs(mm_mapopt_t const   *opt , int qlen , int *n_regs , mm_reg1_t *regs ) 
{ 
  int i ;
  int k ;
  mm_reg1_t *r ;
  int flt ;
  int tmp ;

  {
  k = 0;
  i = k;
  while (i < *n_regs) {
    r = regs + i;
    flt = 0;
    if (! r->inv) {
      if (! r->seg_split) {
        if (r->cnt < (int32_t )opt->min_cnt) {
          flt = 1;
        }
      }
    }
    if (r->p) {
      if (r->mlen < (int32_t )opt->min_chain_score) {
        flt = 1;
      } else
      if ((r->p)->dp_max < (int32_t )opt->min_dp_max) {
        flt = 1;
      } else
      if ((float const   )r->qs > (float const   )qlen * opt->max_clip_ratio) {
        if ((float const   )(qlen - r->qe) > (float const   )qlen * opt->max_clip_ratio) {
          flt = 1;
        }
      }
      if (flt) {
        free((void *)r->p);
      }
    }
    if (! flt) {
      if (k < i) {
        tmp = k;
        k ++;
        *(regs + tmp) = *(regs + i);
      } else {
        k ++;
      }
    }
    i ++;
  }
  *n_regs = k;
  return;
}
}
int mm_squeeze_a(void *km , int n_regs , mm_reg1_t *regs , mm128_t *a ) 
{ 
  int i ;
  int as ;
  uint64_t *aux ;
  void *tmp ;
  mm_reg1_t *r ;

  {
  as = 0;
  tmp = kmalloc(km, (size_t )(n_regs * 8));
  aux = (uint64_t *)tmp;
  i = 0;
  while (i < n_regs) {
    *(aux + i) = ((uint64_t )(regs + i)->as << 32) | (unsigned long )i;
    i ++;
  }
  radix_sort_64(aux, aux + n_regs);
  i = 0;
  while (i < n_regs) {
    r = regs + (int32_t )*(aux + i);
    if (r->as != as) {
      memmove((void *)(a + as), (void const   *)(a + r->as), (size_t )(r->cnt * 16));
      r->as = as;
    }
    as += r->cnt;
    i ++;
  }
  kfree(km, (void *)aux);
  return (as);
}
}
mm_seg_t *mm_seg_gen(void *km , uint32_t hash , int n_segs , int const   *qlens ,
                     int n_regs0 , mm_reg1_t const   *regs0 , int *n_regs , mm_reg1_t **regs ,
                     mm128_t const   *a ) 
{ 
  int s ;
  int i ;
  int j ;
  int acc_qlen[256] ;
  int qlen_sum ;
  mm_seg_t *seg ;
  void *tmp___0 ;
  void *tmp___1 ;
  mm_reg1_t const   *r ;
  int sid ;
  mm_seg_t *sr ;
  int tmp___2 ;
  void *tmp___3 ;
  mm_reg1_t const   *r___0 ;
  int sid___0 ;
  mm128_t a1 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  qlen_sum = 0;
  if (! (n_segs <= 255)) {
    __assert_fail("n_segs <= MM_MAX_SEG", "hit.c", 336U, "mm_seg_gen");
  }
  s = 1;
  acc_qlen[0] = 0;
  while (s < n_segs) {
    acc_qlen[s] = acc_qlen[s - 1] + (int )*(qlens + (s - 1));
    s ++;
  }
  qlen_sum = acc_qlen[n_segs - 1] + (int )*(qlens + (n_segs - 1));
  tmp___0 = kcalloc(km, (size_t )n_segs, sizeof(mm_seg_t ));
  seg = (mm_seg_t *)tmp___0;
  s = 0;
  while (s < n_segs) {
    tmp___1 = kmalloc(km, (size_t )(n_regs0 * 8));
    (seg + s)->u = (uint64_t *)tmp___1;
    i = 0;
    while (i < n_regs0) {
      *((seg + s)->u + i) = (uint64_t )(regs0 + i)->score << 32;
      i ++;
    }
    s ++;
  }
  i = 0;
  while (i < n_regs0) {
    r = regs0 + i;
    j = 0;
    while (j < (int )r->cnt) {
      sid = (int )(((unsigned long long )(a + (r->as + (int32_t const   )j))->y & (255ULL << 48)) >> 48);
      (*((seg + sid)->u + i)) ++;
      ((seg + sid)->n_a) ++;
      j ++;
    }
    i ++;
  }
  s = 0;
  while (s < n_segs) {
    sr = seg + s;
    i = 0;
    sr->n_u = 0;
    while (i < n_regs0) {
      if ((int32_t )*(sr->u + i) != 0) {
        tmp___2 = sr->n_u;
        (sr->n_u) ++;
        *(sr->u + tmp___2) = *(sr->u + i);
      }
      i ++;
    }
    tmp___3 = kmalloc(km, (unsigned long )sr->n_a * sizeof(mm128_t ));
    sr->a = (mm128_t *)tmp___3;
    sr->n_a = 0;
    s ++;
  }
  i = 0;
  while (i < n_regs0) {
    r___0 = regs0 + i;
    j = 0;
    while (j < (int )r___0->cnt) {
      sid___0 = (int )(((unsigned long long )(a + (r___0->as + (int32_t const   )j))->y & (255ULL << 48)) >> 48);
      a1 = *(a + (r___0->as + (int32_t const   )j));
      if (a1.x >> 63) {
        tmp___4 = qlen_sum - (int )(*(qlens + sid___0) + (int const   )acc_qlen[sid___0]);
      } else {
        tmp___4 = acc_qlen[sid___0];
      }
      a1.y -= (uint64_t )tmp___4;
      tmp___5 = (seg + sid___0)->n_a;
      ((seg + sid___0)->n_a) ++;
      *((seg + sid___0)->a + tmp___5) = a1;
      j ++;
    }
    i ++;
  }
  s = 0;
  while (s < n_segs) {
    *(regs + s) = mm_gen_regs(km, hash, (int )*(qlens + s), (seg + s)->n_u, (seg + s)->u,
                              (seg + s)->a, 0);
    *(n_regs + s) = (seg + s)->n_u;
    i = 0;
    while (i < *(n_regs + s)) {
      (*(regs + s) + i)->seg_split = (uint32_t )1;
      (*(regs + s) + i)->seg_id = (uint32_t )s;
      i ++;
    }
    s ++;
  }
  return (seg);
}
}
void mm_seg_free(void *km , int n_segs , mm_seg_t *segs ) 
{ 
  int i ;

  {
  i = 0;
  while (i < n_segs) {
    kfree(km, (void *)(segs + i)->u);
    i ++;
  }
  i = 0;
  while (i < n_segs) {
    kfree(km, (void *)(segs + i)->a);
    i ++;
  }
  kfree(km, (void *)segs);
  return;
}
}
static void mm_set_inv_mapq(void *km , int n_regs , mm_reg1_t *regs ) 
{ 
  int i ;
  int n_aux ;
  mm128_t *aux ;
  void *tmp ;
  int tmp___0 ;
  mm_reg1_t *inv ;
  mm_reg1_t *l ;
  mm_reg1_t *r ;

  {
  if (n_regs < 3) {
    return;
  }
  i = 0;
  while (i < n_regs) {
    if ((regs + i)->inv) {
      break;
    }
    i ++;
  }
  if (i == n_regs) {
    return;
  }
  tmp = kmalloc(km, (size_t )(n_regs * 16));
  aux = (mm128_t *)tmp;
  n_aux = 0;
  i = n_aux;
  while (i < n_regs) {
    if ((regs + i)->parent == i) {
      (aux + n_aux)->y = (uint64_t )i;
      tmp___0 = n_aux;
      n_aux ++;
      (aux + tmp___0)->x = ((uint64_t )(regs + i)->rid << 32) | (unsigned long )(regs + i)->rs;
    } else
    if ((regs + i)->parent < 0) {
      (aux + n_aux)->y = (uint64_t )i;
      tmp___0 = n_aux;
      n_aux ++;
      (aux + tmp___0)->x = ((uint64_t )(regs + i)->rid << 32) | (unsigned long )(regs + i)->rs;
    }
    i ++;
  }
  radix_sort_128x(aux, aux + n_aux);
  i = 1;
  while (i < n_aux - 1) {
    inv = regs + (aux + i)->y;
    if (inv->inv) {
      l = regs + (aux + (i - 1))->y;
      r = regs + (aux + (i + 1))->y;
      if (l->mapq < r->mapq) {
        inv->mapq = l->mapq;
      } else {
        inv->mapq = r->mapq;
      }
    }
    i ++;
  }
  kfree(km, (void *)aux);
  return;
}
}
static float const   q_coef  =    (float const   )40.0f;
void mm_set_mapq(void *km , int n_regs , mm_reg1_t *regs , int min_chain_sc , int match_sc ,
                 int rep_len , int is_sr ) 
{ 
  int64_t sum_sc ;
  float uniq_ratio ;
  int i ;
  mm_reg1_t *r ;
  int mapq ;
  int subsc ;
  float pen_s1 ;
  float tmp ;
  float pen_cm ;
  float tmp___0 ;
  float identity ;
  float x ;
  float tmp___1 ;
  int mapq_alt ;
  float x___0 ;
  float identity___0 ;
  float tmp___2 ;
  float tmp___3 ;
  float tmp___4 ;

  {
  sum_sc = (int64_t )0;
  if (n_regs == 0) {
    return;
  }
  i = 0;
  while (i < n_regs) {
    if ((regs + i)->parent == (regs + i)->id) {
      sum_sc += (int64_t )(regs + i)->score;
    }
    i ++;
  }
  uniq_ratio = (float )sum_sc / (float )(sum_sc + (int64_t )rep_len);
  i = 0;
  while (i < n_regs) {
    r = regs + i;
    if (r->inv) {
      r->mapq = (uint32_t )0;
    } else
    if (r->parent == r->id) {
      if (r->score > 100) {
        tmp = 1.0f;
      } else {
        tmp = 0.01f * (float )r->score;
      }
      pen_s1 = tmp * uniq_ratio;
      if (r->cnt > 10) {
        tmp___0 = 1.0f;
      } else {
        tmp___0 = 0.1f * (float )r->cnt;
      }
      pen_cm = tmp___0;
      if (pen_s1 < pen_cm) {
        pen_cm = pen_s1;
      } else {
        pen_cm = pen_cm;
      }
      if (r->subsc > min_chain_sc) {
        subsc = r->subsc;
      } else {
        subsc = min_chain_sc;
      }
      if (r->p) {
        if ((r->p)->dp_max2 > 0) {
          if ((r->p)->dp_max > 0) {
            identity = (float )r->mlen / (float )r->blen;
            x = (((float )(r->p)->dp_max2 * (float )subsc) / (float )(r->p)->dp_max) / (float )r->score0;
            tmp___1 = logf((float )(r->p)->dp_max / (float )match_sc);
            mapq = (int )((((identity * pen_cm) * (float )q_coef) * (1.0f - x * x)) * tmp___1);
            if (! is_sr) {
              mapq_alt = (int )((((6.02f * identity) * identity) * (float )((r->p)->dp_max - (r->p)->dp_max2)) / (float )match_sc + .499f);
              if (mapq < mapq_alt) {
                mapq = mapq;
              } else {
                mapq = mapq_alt;
              }
            }
          } else {
            goto _L___0;
          }
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        x___0 = (float )subsc / (float )r->score0;
        if (r->p) {
          identity___0 = (float )r->mlen / (float )r->blen;
          tmp___2 = logf((float )(r->p)->dp_max / (float )match_sc);
          mapq = (int )((((identity___0 * pen_cm) * (float )q_coef) * (1.0f - x___0)) * tmp___2);
        } else {
          tmp___3 = logf((float )r->score);
          mapq = (int )(((pen_cm * (float )q_coef) * (1.0f - x___0)) * tmp___3);
        }
      }
      tmp___4 = logf((float )(r->n_sub + 1));
      mapq -= (int )(4.343f * tmp___4 + .499f);
      if (mapq > 0) {
        mapq = mapq;
      } else {
        mapq = 0;
      }
      if (mapq < 60) {
        r->mapq = (uint32_t )mapq;
      } else {
        r->mapq = (uint32_t )60;
      }
      if (r->p) {
        if ((r->p)->dp_max > (r->p)->dp_max2) {
          if (r->mapq == 0U) {
            r->mapq = (uint32_t )1;
          }
        }
      }
    } else {
      r->mapq = (uint32_t )0;
    }
    i ++;
  }
  mm_set_inv_mapq(km, n_regs, regs);
  return;
}
}
#pragma merger("0","/tmp/cil-OhLG71l8.i","-g,-Wall,-O2,-Wc++-compat")
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
extern int close(int __fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
extern int fclose(FILE *__stream ) ;
extern int fflush(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
extern long ftell(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
void kt_for(int n_threads , void (*func)(void * , long  , int  ) , void *data , long n ) ;
void kt_pipeline(int n_threads , void *(*func)(void * , int  , void * ) , void *shared_data ,
                 int n_steps ) ;
double mm_realtime0 ;
mm_idx_reader_t *mm_idx_reader_open(char const   *fn , mm_idxopt_t const   *opt ,
                                    char const   *fn_out ) ;
mm_idx_t *mm_idx_reader_read(mm_idx_reader_t *r , int n_threads ) ;
void mm_idx_reader_close(mm_idx_reader_t *r ) ;
int mm_idx_reader_eof(mm_idx_reader_t const   *r ) ;
int64_t mm_idx_is_idx(char const   *fn ) ;
mm_idx_t *mm_idx_load(FILE *fp ) ;
void mm_idx_dump(FILE *fp , mm_idx_t const   *mi ) ;
mm_idx_t *mm_idx_str(int w , int k , int is_hpc , int bucket_bits , int n , char const   **seq ,
                     char const   **name ) ;
void mm_idx_stat(mm_idx_t const   *mi ) ;
void mm_idx_destroy(mm_idx_t *mi ) ;
int mm_idx_index_name(mm_idx_t *mi ) ;
int mm_idx_name2id(mm_idx_t const   *mi , char const   *name ) ;
int mm_idx_alt_read(mm_idx_t *mi , char const   *fn ) ;
int mm_idx_bed_read(mm_idx_t *mi , char const   *fn , int read_junc ) ;
mm_idx_t *mm_idx_build(char const   *fn , int w , int k , int flag , int n_threads ) ;
double cputime(void) ;
double realtime(void) ;
uint32_t ks_ksmall_uint32_t(size_t n , uint32_t *arr , size_t kk ) ;
void mm_sketch(void *km , char const   *str , int len , int w , int k , uint32_t rid ,
               int is_hpc , mm128_v *p ) ;
void mm_idxopt_init(mm_idxopt_t *opt ) ;
uint64_t const   *mm_idx_get(mm_idx_t const   *mi , uint64_t minier , int *n ) ;
int32_t mm_idx_cal_max_occ(mm_idx_t const   *mi , float f ) ;
void *km_init(void) ;
void km_destroy(void *_km ) ;
static double const   __ac_HASH_UPPER  =    (double const   )0.77;
__inline static khint_t __ac_X31_hash_string(char const   *s ) 
{ 
  khint_t h ;

  {
  h = (khint_t )*s;
  if (h) {
    s ++;
    while (*s) {
      h = ((h << 5) - h) + (khint_t )*s;
      s ++;
    }
  }
  return (h);
}
}
__inline static kh_idx_t *kh_init_idx(void)  __attribute__((__unused__)) ;
__inline static kh_idx_t *kh_init_idx(void) 
{ 
  void *tmp ;

  {
  tmp = kcalloc((void *)0, (size_t )1, sizeof(kh_idx_t ));
  return ((kh_idx_t *)tmp);
}
}
__inline static void kh_destroy_idx(kh_idx_t *h )  __attribute__((__unused__)) ;
__inline static void kh_destroy_idx(kh_idx_t *h ) 
{ 


  {
  if (h) {
    kfree((void *)0, (void *)h->keys);
    kfree((void *)0, (void *)h->flags);
    kfree((void *)0, (void *)h->vals);
    kfree((void *)0, (void *)h);
  }
  return;
}
}
__inline static khint_t kh_get_idx(kh_idx_t const   *h , uint64_t key )  __attribute__((__unused__)) ;
__inline static khint_t kh_get_idx(kh_idx_t const   *h , uint64_t key ) 
{ 
  khint_t k ;
  khint_t i ;
  khint_t last ;
  khint_t mask ;
  khint_t step ;
  khint_t tmp ;

  {
  if (h->n_buckets) {
    step = (khint_t )0;
    mask = (khint_t )(h->n_buckets - 1U);
    k = (khint_t )(key >> 1);
    i = k & mask;
    last = i;
    while (1) {
      if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
        if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U)) {
          if (! (! (*(h->keys + i) >> 1 == key >> 1))) {
            break;
          }
        }
      } else {
        break;
      }
      step ++;
      i = (i + step) & mask;
      if (i == last) {
        return ((khint_t )h->n_buckets);
      }
    }
    if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 3U) {
      tmp = h->n_buckets;
    } else {
      tmp = (khint_t const   )i;
    }
    return ((khint_t )tmp);
  } else {
    return ((khint_t )0);
  }
}
}
__inline static int kh_resize_idx(kh_idx_t *h , khint_t new_n_buckets )  __attribute__((__unused__)) ;
__inline static int kh_resize_idx(kh_idx_t *h , khint_t new_n_buckets ) 
{ 
  khint32_t *new_flags ;
  khint_t j ;
  khint_t tmp ;
  void *tmp___0 ;
  khint_t tmp___1 ;
  uint64_t *new_keys ;
  void *tmp___2 ;
  uint64_t *new_vals ;
  void *tmp___3 ;
  uint64_t key ;
  uint64_t val ;
  khint_t new_mask ;
  khint_t k ;
  khint_t i ;
  khint_t step ;
  uint64_t tmp___4 ;
  uint64_t tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
  new_flags = (khint32_t *)0;
  j = (khint_t )1;
  new_n_buckets --;
  new_n_buckets |= new_n_buckets >> 1;
  new_n_buckets |= new_n_buckets >> 2;
  new_n_buckets |= new_n_buckets >> 4;
  new_n_buckets |= new_n_buckets >> 8;
  new_n_buckets |= new_n_buckets >> 16;
  new_n_buckets ++;
  if (new_n_buckets < 4U) {
    new_n_buckets = (khint_t )4;
  }
  if (h->size >= (khint_t )((double const   )new_n_buckets * __ac_HASH_UPPER + (double const   )0.5)) {
    j = (khint_t )0;
  } else {
    if (new_n_buckets < 16U) {
      tmp = (khint_t )1;
    } else {
      tmp = new_n_buckets >> 4;
    }
    tmp___0 = kmalloc((void *)0, (unsigned long )tmp * sizeof(khint32_t ));
    new_flags = (khint32_t *)tmp___0;
    if (! new_flags) {
      return (-1);
    }
    if (new_n_buckets < 16U) {
      tmp___1 = (khint_t )1;
    } else {
      tmp___1 = new_n_buckets >> 4;
    }
    memset((void *)new_flags, 170, (unsigned long )tmp___1 * sizeof(khint32_t ));
    if (h->n_buckets < new_n_buckets) {
      tmp___2 = krealloc((void *)0, (void *)h->keys, (unsigned long )new_n_buckets * sizeof(uint64_t ));
      new_keys = (uint64_t *)tmp___2;
      if (! new_keys) {
        kfree((void *)0, (void *)new_flags);
        return (-1);
      }
      h->keys = new_keys;
      tmp___3 = krealloc((void *)0, (void *)h->vals, (unsigned long )new_n_buckets * sizeof(uint64_t ));
      new_vals = (uint64_t *)tmp___3;
      if (! new_vals) {
        kfree((void *)0, (void *)new_flags);
        return (-1);
      }
      h->vals = new_vals;
    }
  }
  if (j) {
    j = (khint_t )0;
    while (j != h->n_buckets) {
      if (((*(h->flags + (j >> 4)) >> ((j & 15U) << 1)) & 3U) == 0U) {
        key = *(h->keys + j);
        new_mask = new_n_buckets - 1U;
        val = *(h->vals + j);
        *(h->flags + (j >> 4)) = (khint32_t )((unsigned long )*(h->flags + (j >> 4)) | (1UL << ((j & 15U) << 1)));
        while (1) {
          step = (khint_t )0;
          k = (khint_t )(key >> 1);
          i = k & new_mask;
          while (! ((*(new_flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
            step ++;
            i = (i + step) & new_mask;
          }
          *(new_flags + (i >> 4)) = (khint32_t )((unsigned long )*(new_flags + (i >> 4)) & ~ (2UL << ((i & 15U) << 1)));
          if (i < h->n_buckets) {
            if (((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 3U) == 0U) {
              tmp___4 = *(h->keys + i);
              *(h->keys + i) = key;
              key = tmp___4;
              tmp___5 = *(h->vals + i);
              *(h->vals + i) = val;
              val = tmp___5;
              *(h->flags + (i >> 4)) = (khint32_t )((unsigned long )*(h->flags + (i >> 4)) | (1UL << ((i & 15U) << 1)));
            } else {
              *(h->keys + i) = key;
              *(h->vals + i) = val;
              break;
            }
          } else {
            *(h->keys + i) = key;
            *(h->vals + i) = val;
            break;
          }
        }
      }
      j ++;
    }
    if (h->n_buckets > new_n_buckets) {
      tmp___6 = krealloc((void *)0, (void *)h->keys, (unsigned long )new_n_buckets * sizeof(uint64_t ));
      h->keys = (uint64_t *)tmp___6;
      tmp___7 = krealloc((void *)0, (void *)h->vals, (unsigned long )new_n_buckets * sizeof(uint64_t ));
      h->vals = (uint64_t *)tmp___7;
    }
    kfree((void *)0, (void *)h->flags);
    h->flags = new_flags;
    h->n_buckets = new_n_buckets;
    h->n_occupied = h->size;
    h->upper_bound = (khint_t )((double const   )h->n_buckets * __ac_HASH_UPPER + (double const   )0.5);
  }
  return (0);
}
}
__inline static khint_t kh_put_idx(kh_idx_t *h , uint64_t key , int *ret )  __attribute__((__unused__)) ;
__inline static khint_t kh_put_idx(kh_idx_t *h , uint64_t key , int *ret ) 
{ 
  khint_t x ;
  int tmp ;
  int tmp___0 ;
  khint_t k ;
  khint_t i ;
  khint_t site ;
  khint_t last ;
  khint_t mask ;
  khint_t step ;

  {
  if (h->n_occupied >= h->upper_bound) {
    if (h->n_buckets > h->size << 1) {
      tmp = kh_resize_idx(h, h->n_buckets - 1U);
      if (tmp < 0) {
        *ret = -1;
        return (h->n_buckets);
      }
    } else {
      tmp___0 = kh_resize_idx(h, h->n_buckets + 1U);
      if (tmp___0 < 0) {
        *ret = -1;
        return (h->n_buckets);
      }
    }
  }
  mask = h->n_buckets - 1U;
  step = (khint_t )0;
  site = h->n_buckets;
  x = site;
  k = (khint_t )(key >> 1);
  i = k & mask;
  if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U) {
    x = i;
  } else {
    last = i;
    while (1) {
      if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
        if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U)) {
          if (! (! (*(h->keys + i) >> 1 == key >> 1))) {
            break;
          }
        }
      } else {
        break;
      }
      if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U) {
        site = i;
      }
      step ++;
      i = (i + step) & mask;
      if (i == last) {
        x = site;
        break;
      }
    }
    if (x == h->n_buckets) {
      if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U) {
        if (site != h->n_buckets) {
          x = site;
        } else {
          x = i;
        }
      } else {
        x = i;
      }
    }
  }
  if ((*(h->flags + (x >> 4)) >> ((x & 15U) << 1)) & 2U) {
    *(h->keys + x) = key;
    *(h->flags + (x >> 4)) = (khint32_t )((unsigned long )*(h->flags + (x >> 4)) & ~ (3UL << ((x & 15U) << 1)));
    (h->size) ++;
    (h->n_occupied) ++;
    *ret = 1;
  } else
  if ((*(h->flags + (x >> 4)) >> ((x & 15U) << 1)) & 1U) {
    *(h->keys + x) = key;
    *(h->flags + (x >> 4)) = (khint32_t )((unsigned long )*(h->flags + (x >> 4)) & ~ (3UL << ((x & 15U) << 1)));
    (h->size) ++;
    *ret = 2;
  } else {
    *ret = 0;
  }
  return (x);
}
}
__inline static kh_str_t *kh_init_str(void)  __attribute__((__unused__)) ;
__inline static kh_str_t *kh_init_str(void) 
{ 
  void *tmp ;

  {
  tmp = kcalloc((void *)0, (size_t )1, sizeof(kh_str_t ));
  return ((kh_str_t *)tmp);
}
}
__inline static void kh_destroy_str(kh_str_t *h )  __attribute__((__unused__)) ;
__inline static void kh_destroy_str(kh_str_t *h ) 
{ 


  {
  if (h) {
    kfree((void *)0, (void *)h->keys);
    kfree((void *)0, (void *)h->flags);
    kfree((void *)0, (void *)h->vals);
    kfree((void *)0, (void *)h);
  }
  return;
}
}
__inline static khint_t kh_get_str(kh_str_t const   *h , kh_cstr_t key )  __attribute__((__unused__)) ;
__inline static khint_t kh_get_str(kh_str_t const   *h , kh_cstr_t key ) 
{ 
  khint_t k ;
  khint_t i ;
  khint_t last ;
  khint_t mask ;
  khint_t step ;
  int tmp ;
  khint_t tmp___0 ;

  {
  if (h->n_buckets) {
    step = (khint_t )0;
    mask = (khint_t )(h->n_buckets - 1U);
    k = __ac_X31_hash_string(key);
    i = k & mask;
    last = i;
    while (1) {
      if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
        if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U)) {
          tmp = strcmp(*(h->keys + i), key);
          if (tmp == 0) {
            break;
          }
        }
      } else {
        break;
      }
      step ++;
      i = (i + step) & mask;
      if (i == last) {
        return ((khint_t )h->n_buckets);
      }
    }
    if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 3U) {
      tmp___0 = h->n_buckets;
    } else {
      tmp___0 = (khint_t const   )i;
    }
    return ((khint_t )tmp___0);
  } else {
    return ((khint_t )0);
  }
}
}
__inline static int kh_resize_str(kh_str_t *h , khint_t new_n_buckets )  __attribute__((__unused__)) ;
__inline static int kh_resize_str(kh_str_t *h , khint_t new_n_buckets ) 
{ 
  khint32_t *new_flags ;
  khint_t j ;
  khint_t tmp ;
  void *tmp___0 ;
  khint_t tmp___1 ;
  kh_cstr_t *new_keys ;
  void *tmp___2 ;
  uint32_t *new_vals ;
  void *tmp___3 ;
  kh_cstr_t key ;
  uint32_t val ;
  khint_t new_mask ;
  khint_t k ;
  khint_t i ;
  khint_t step ;
  kh_cstr_t tmp___4 ;
  uint32_t tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
  new_flags = (khint32_t *)0;
  j = (khint_t )1;
  new_n_buckets --;
  new_n_buckets |= new_n_buckets >> 1;
  new_n_buckets |= new_n_buckets >> 2;
  new_n_buckets |= new_n_buckets >> 4;
  new_n_buckets |= new_n_buckets >> 8;
  new_n_buckets |= new_n_buckets >> 16;
  new_n_buckets ++;
  if (new_n_buckets < 4U) {
    new_n_buckets = (khint_t )4;
  }
  if (h->size >= (khint_t )((double const   )new_n_buckets * __ac_HASH_UPPER + (double const   )0.5)) {
    j = (khint_t )0;
  } else {
    if (new_n_buckets < 16U) {
      tmp = (khint_t )1;
    } else {
      tmp = new_n_buckets >> 4;
    }
    tmp___0 = kmalloc((void *)0, (unsigned long )tmp * sizeof(khint32_t ));
    new_flags = (khint32_t *)tmp___0;
    if (! new_flags) {
      return (-1);
    }
    if (new_n_buckets < 16U) {
      tmp___1 = (khint_t )1;
    } else {
      tmp___1 = new_n_buckets >> 4;
    }
    memset((void *)new_flags, 170, (unsigned long )tmp___1 * sizeof(khint32_t ));
    if (h->n_buckets < new_n_buckets) {
      tmp___2 = krealloc((void *)0, (void *)h->keys, (unsigned long )new_n_buckets * sizeof(kh_cstr_t ));
      new_keys = (kh_cstr_t *)tmp___2;
      if (! new_keys) {
        kfree((void *)0, (void *)new_flags);
        return (-1);
      }
      h->keys = new_keys;
      tmp___3 = krealloc((void *)0, (void *)h->vals, (unsigned long )new_n_buckets * sizeof(uint32_t ));
      new_vals = (uint32_t *)tmp___3;
      if (! new_vals) {
        kfree((void *)0, (void *)new_flags);
        return (-1);
      }
      h->vals = new_vals;
    }
  }
  if (j) {
    j = (khint_t )0;
    while (j != h->n_buckets) {
      if (((*(h->flags + (j >> 4)) >> ((j & 15U) << 1)) & 3U) == 0U) {
        key = *(h->keys + j);
        new_mask = new_n_buckets - 1U;
        val = *(h->vals + j);
        *(h->flags + (j >> 4)) = (khint32_t )((unsigned long )*(h->flags + (j >> 4)) | (1UL << ((j & 15U) << 1)));
        while (1) {
          step = (khint_t )0;
          k = __ac_X31_hash_string(key);
          i = k & new_mask;
          while (! ((*(new_flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
            step ++;
            i = (i + step) & new_mask;
          }
          *(new_flags + (i >> 4)) = (khint32_t )((unsigned long )*(new_flags + (i >> 4)) & ~ (2UL << ((i & 15U) << 1)));
          if (i < h->n_buckets) {
            if (((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 3U) == 0U) {
              tmp___4 = *(h->keys + i);
              *(h->keys + i) = key;
              key = tmp___4;
              tmp___5 = *(h->vals + i);
              *(h->vals + i) = val;
              val = tmp___5;
              *(h->flags + (i >> 4)) = (khint32_t )((unsigned long )*(h->flags + (i >> 4)) | (1UL << ((i & 15U) << 1)));
            } else {
              *(h->keys + i) = key;
              *(h->vals + i) = val;
              break;
            }
          } else {
            *(h->keys + i) = key;
            *(h->vals + i) = val;
            break;
          }
        }
      }
      j ++;
    }
    if (h->n_buckets > new_n_buckets) {
      tmp___6 = krealloc((void *)0, (void *)h->keys, (unsigned long )new_n_buckets * sizeof(kh_cstr_t ));
      h->keys = (kh_cstr_t *)tmp___6;
      tmp___7 = krealloc((void *)0, (void *)h->vals, (unsigned long )new_n_buckets * sizeof(uint32_t ));
      h->vals = (uint32_t *)tmp___7;
    }
    kfree((void *)0, (void *)h->flags);
    h->flags = new_flags;
    h->n_buckets = new_n_buckets;
    h->n_occupied = h->size;
    h->upper_bound = (khint_t )((double const   )h->n_buckets * __ac_HASH_UPPER + (double const   )0.5);
  }
  return (0);
}
}
__inline static khint_t kh_put_str(kh_str_t *h , kh_cstr_t key , int *ret )  __attribute__((__unused__)) ;
__inline static khint_t kh_put_str(kh_str_t *h , kh_cstr_t key , int *ret ) 
{ 
  khint_t x ;
  int tmp ;
  int tmp___0 ;
  khint_t k ;
  khint_t i ;
  khint_t site ;
  khint_t last ;
  khint_t mask ;
  khint_t step ;
  int tmp___1 ;

  {
  if (h->n_occupied >= h->upper_bound) {
    if (h->n_buckets > h->size << 1) {
      tmp = kh_resize_str(h, h->n_buckets - 1U);
      if (tmp < 0) {
        *ret = -1;
        return (h->n_buckets);
      }
    } else {
      tmp___0 = kh_resize_str(h, h->n_buckets + 1U);
      if (tmp___0 < 0) {
        *ret = -1;
        return (h->n_buckets);
      }
    }
  }
  mask = h->n_buckets - 1U;
  step = (khint_t )0;
  site = h->n_buckets;
  x = site;
  k = __ac_X31_hash_string(key);
  i = k & mask;
  if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U) {
    x = i;
  } else {
    last = i;
    while (1) {
      if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U)) {
        if (! ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U)) {
          tmp___1 = strcmp(*(h->keys + i), key);
          if (tmp___1 == 0) {
            break;
          }
        }
      } else {
        break;
      }
      if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 1U) {
        site = i;
      }
      step ++;
      i = (i + step) & mask;
      if (i == last) {
        x = site;
        break;
      }
    }
    if (x == h->n_buckets) {
      if ((*(h->flags + (i >> 4)) >> ((i & 15U) << 1)) & 2U) {
        if (site != h->n_buckets) {
          x = site;
        } else {
          x = i;
        }
      } else {
        x = i;
      }
    }
  }
  if ((*(h->flags + (x >> 4)) >> ((x & 15U) << 1)) & 2U) {
    *(h->keys + x) = key;
    *(h->flags + (x >> 4)) = (khint32_t )((unsigned long )*(h->flags + (x >> 4)) & ~ (3UL << ((x & 15U) << 1)));
    (h->size) ++;
    (h->n_occupied) ++;
    *ret = 1;
  } else
  if ((*(h->flags + (x >> 4)) >> ((x & 15U) << 1)) & 1U) {
    *(h->keys + x) = key;
    *(h->flags + (x >> 4)) = (khint32_t )((unsigned long )*(h->flags + (x >> 4)) & ~ (3UL << ((x & 15U) << 1)));
    (h->size) ++;
    *ret = 2;
  } else {
    *ret = 0;
  }
  return (x);
}
}
mm_idx_t *mm_idx_init(int w , int k , int b , int flag ) 
{ 
  mm_idx_t *mi ;
  void *tmp ;
  void *tmp___0 ;

  {
  if (k * 2 < b) {
    b = k * 2;
  }
  if (w < 1) {
    w = 1;
  }
  tmp = calloc((size_t )1, sizeof(mm_idx_t ));
  mi = (mm_idx_t *)tmp;
  mi->w = w;
  mi->k = k;
  mi->b = b;
  mi->flag = flag;
  tmp___0 = calloc((size_t )(1 << b), sizeof(mm_idx_bucket_t ));
  mi->B = (mm_idx_bucket_t *)tmp___0;
  if (! (mm_dbg_flag & 1)) {
    mi->km = km_init();
  }
  return (mi);
}
}
void mm_idx_destroy(mm_idx_t *mi ) 
{ 
  uint32_t i ;

  {
  if ((unsigned long )mi == (unsigned long )((mm_idx_t *)0)) {
    return;
  }
  if (mi->h) {
    kh_destroy_str((kh_str_t *)mi->h);
  }
  if (mi->B) {
    i = (uint32_t )0;
    while (i < 1U << mi->b) {
      free((void *)(mi->B + i)->p);
      free((void *)(mi->B + i)->a.a);
      kh_destroy_idx((idxhash_t *)(mi->B + i)->h);
      i ++;
    }
  }
  if (mi->I) {
    i = (uint32_t )0;
    while (i < mi->n_seq) {
      free((void *)(mi->I + i)->a);
      i ++;
    }
    free((void *)mi->I);
  }
  if (! mi->km) {
    i = (uint32_t )0;
    while (i < mi->n_seq) {
      free((void *)(mi->seq + i)->name);
      i ++;
    }
    free((void *)mi->seq);
  } else {
    km_destroy(mi->km);
  }
  free((void *)mi->B);
  free((void *)mi->S);
  free((void *)mi);
  return;
}
}
uint64_t const   *mm_idx_get(mm_idx_t const   *mi , uint64_t minier , int *n ) 
{ 
  int mask ;
  khint_t k ;
  mm_idx_bucket_t *b ;
  idxhash_t *h ;

  {
  mask = (1 << mi->b) - 1;
  b = mi->B + (minier & (unsigned long )mask);
  h = (idxhash_t *)b->h;
  *n = 0;
  if ((unsigned long )h == (unsigned long )((idxhash_t *)0)) {
    return ((uint64_t const   *)0);
  }
  k = kh_get_idx((kh_idx_t const   *)h, (minier >> mi->b) << 1);
  if (k == h->n_buckets) {
    return ((uint64_t const   *)0);
  }
  if (*(h->keys + k) & 1UL) {
    *n = 1;
    return ((uint64_t const   *)(h->vals + k));
  } else {
    *n = (int )((uint32_t )*(h->vals + k));
    return ((uint64_t const   *)(b->p + (*(h->vals + k) >> 32)));
  }
}
}
void mm_idx_stat(mm_idx_t const   *mi ) 
{ 
  int n ;
  int n1 ;
  uint32_t i ;
  uint64_t sum ;
  uint64_t len ;
  idxhash_t *h ;
  khint_t k ;
  uint32_t tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
  n = 0;
  n1 = 0;
  sum = (uint64_t )0;
  len = (uint64_t )0;
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[M::%s] kmer size: %d; skip: %d; is_hpc: %d; #seq: %d\n",
          "mm_idx_stat", mi->k, mi->w, mi->flag & 1, mi->n_seq);
  i = (uint32_t )0;
  while (i < (uint32_t )mi->n_seq) {
    len += (uint64_t )(mi->seq + i)->len;
    i ++;
  }
  i = (uint32_t )0;
  while (i < 1U << mi->b) {
    if ((mi->B + i)->h) {
      n = (int )((khint_t )n + ((idxhash_t *)(mi->B + i)->h)->size);
    }
    i ++;
  }
  i = (uint32_t )0;
  while (i < 1U << mi->b) {
    h = (idxhash_t *)(mi->B + i)->h;
    if ((unsigned long )h == (unsigned long )((idxhash_t *)0)) {
      goto __Cont;
    }
    k = (khint_t )0;
    while (k < h->n_buckets) {
      if (! ((*(h->flags + (k >> 4)) >> ((k & 15U) << 1)) & 3U)) {
        if (*(h->keys + k) & 1UL) {
          tmp = (uint32_t )1;
        } else {
          tmp = (uint32_t )*(h->vals + k);
        }
        sum += (uint64_t )tmp;
        if (*(h->keys + k) & 1UL) {
          n1 ++;
        }
      }
      k ++;
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  tmp___0 = cputime();
  tmp___1 = realtime();
  tmp___2 = realtime();
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[M::%s::%.3f*%.2f] distinct minimizers: %d (%.2f%% are singletons); average occurrences: %.3lf; average spacing: %.3lf; total length: %ld\n",
          "mm_idx_stat", tmp___2 - mm_realtime0, tmp___0 / (tmp___1 - mm_realtime0),
          n, (100.0 * (double )n1) / (double )n, (double )sum / (double )n, (double )len / (double )sum,
          (long )len);
  return;
}
}
int mm_idx_index_name(mm_idx_t *mi ) 
{ 
  kh_str_t *h ;
  uint32_t i ;
  int has_dup ;
  int absent ;
  khint_t k ;

  {
  has_dup = 0;
  if (mi->h) {
    return (0);
  }
  h = kh_init_str();
  i = (uint32_t )0;
  while (i < mi->n_seq) {
    k = kh_put_str(h, (kh_cstr_t )(mi->seq + i)->name, & absent);
    if (absent) {
      *(h->vals + k) = i;
    } else {
      has_dup = 1;
    }
    i ++;
  }
  mi->h = (void *)h;
  if (has_dup) {
    if (mm_verbose >= 2) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[WARNING] some database sequences have identical sequence names\n");
    }
  }
  return (has_dup);
}
}
int mm_idx_name2id(mm_idx_t const   *mi , char const   *name ) 
{ 
  kh_str_t *h ;
  khint_t k ;
  uint32_t tmp ;

  {
  h = (kh_str_t *)mi->h;
  if ((unsigned long )h == (unsigned long )((kh_str_t *)0)) {
    return (-2);
  }
  k = kh_get_str((kh_str_t const   *)h, name);
  if (k == h->n_buckets) {
    tmp = (uint32_t )-1;
  } else {
    tmp = *(h->vals + k);
  }
  return ((int )tmp);
}
}
int mm_idx_getseq(mm_idx_t const   *mi , uint32_t rid , uint32_t st , uint32_t en ,
                  uint8_t *seq ) 
{ 
  uint64_t i ;
  uint64_t st1 ;
  uint64_t en1 ;

  {
  if (rid >= (uint32_t )mi->n_seq) {
    return (-1);
  } else
  if (st >= (mi->seq + rid)->len) {
    return (-1);
  }
  if (en > (mi->seq + rid)->len) {
    en = (mi->seq + rid)->len;
  }
  st1 = (mi->seq + rid)->offset + (uint64_t )st;
  en1 = (mi->seq + rid)->offset + (uint64_t )en;
  i = st1;
  while (i < en1) {
    *(seq + (i - st1)) = (uint8_t )((*(mi->S + (i >> 3)) >> ((i & 7UL) << 2)) & 15U);
    i ++;
  }
  return ((int )(en - st));
}
}
int mm_idx_getseq_rev(mm_idx_t const   *mi , uint32_t rid , uint32_t st , uint32_t en ,
                      uint8_t *seq ) 
{ 
  uint64_t i ;
  uint64_t st1 ;
  uint64_t en1 ;
  mm_idx_seq_t const   *s ;
  uint8_t c ;

  {
  if (rid >= (uint32_t )mi->n_seq) {
    return (-1);
  } else
  if (st >= (mi->seq + rid)->len) {
    return (-1);
  }
  s = (mm_idx_seq_t const   *)(mi->seq + rid);
  if (en > (uint32_t )s->len) {
    en = (uint32_t )s->len;
  }
  st1 = (uint64_t )(s->offset + (uint64_t const   )(s->len - (uint32_t const   )en));
  en1 = (uint64_t )(s->offset + (uint64_t const   )(s->len - (uint32_t const   )st));
  i = st1;
  while (i < en1) {
    c = (uint8_t )((*(mi->S + (i >> 3)) >> ((i & 7UL) << 2)) & 15U);
    if ((int )c < 4) {
      *(seq + ((en1 - i) - 1UL)) = (uint8_t )(3 - (int )c);
    } else {
      *(seq + ((en1 - i) - 1UL)) = c;
    }
    i ++;
  }
  return ((int )(en - st));
}
}
int mm_idx_getseq2(mm_idx_t const   *mi , int is_rev , uint32_t rid , uint32_t st ,
                   uint32_t en , uint8_t *seq ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (is_rev) {
    tmp = mm_idx_getseq_rev(mi, rid, st, en, seq);
    return (tmp);
  } else {
    tmp___0 = mm_idx_getseq(mi, rid, st, en, seq);
    return (tmp___0);
  }
}
}
int32_t mm_idx_cal_max_occ(mm_idx_t const   *mi , float f ) 
{ 
  int i ;
  size_t n ;
  uint32_t thres ;
  khint_t *a ;
  khint_t k ;
  void *tmp ;
  idxhash_t *h ;
  size_t tmp___0 ;
  uint32_t tmp___1 ;

  {
  n = (size_t )0;
  if ((double )f <= 0.) {
    return (2147483647);
  }
  i = 0;
  while (i < 1 << mi->b) {
    if ((mi->B + i)->h) {
      n += (size_t )((idxhash_t *)(mi->B + i)->h)->size;
    }
    i ++;
  }
  tmp = malloc(n * 4UL);
  a = (uint32_t *)tmp;
  n = (size_t )0;
  i = (int )n;
  while (i < 1 << mi->b) {
    h = (idxhash_t *)(mi->B + i)->h;
    if ((unsigned long )h == (unsigned long )((idxhash_t *)0)) {
      goto __Cont;
    }
    k = (khint_t )0;
    while (k < h->n_buckets) {
      if (! (! ((*(h->flags + (k >> 4)) >> ((k & 15U) << 1)) & 3U))) {
        goto __Cont___0;
      }
      tmp___0 = n;
      n ++;
      if (*(h->keys + k) & 1UL) {
        *(a + tmp___0) = (khint_t )1;
      } else {
        *(a + tmp___0) = (uint32_t )*(h->vals + k);
      }
      __Cont___0: /* CIL Label */ 
      k ++;
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  tmp___1 = ks_ksmall_uint32_t(n, a, (size_t )((uint32_t )((1. - (double )f) * (double )n)));
  thres = tmp___1 + 1U;
  free((void *)a);
  return ((int32_t )thres);
}
}
static void worker_post(void *g , long i , int tid ) 
{ 
  int n ;
  int n_keys ;
  size_t j ;
  size_t start_a ;
  size_t start_p ;
  idxhash_t *h ;
  mm_idx_t *mi ;
  mm_idx_bucket_t *b ;
  void *tmp ;
  khint_t itr ;
  int absent ;
  mm128_t *p ;
  int k ;
  size_t tmp___2 ;

  {
  mi = (mm_idx_t *)g;
  b = mi->B + i;
  if (b->a.n == 0UL) {
    return;
  }
  radix_sort_128x(b->a.a, b->a.a + b->a.n);
  j = (size_t )1;
  n = 1;
  n_keys = 0;
  b->n = 0;
  while (j <= b->a.n) {
    if (j == b->a.n) {
      goto _L;
    } else
    if ((b->a.a + j)->x >> 8 != (b->a.a + (j - 1UL))->x >> 8) {
      _L: /* CIL Label */ 
      n_keys ++;
      if (n > 1) {
        b->n += n;
      }
      n = 1;
    } else {
      n ++;
    }
    j ++;
  }
  h = kh_init_idx();
  kh_resize_idx(h, (khint_t )n_keys);
  tmp = calloc((size_t )b->n, (size_t )8);
  b->p = (uint64_t *)tmp;
  j = (size_t )1;
  n = 1;
  start_p = (size_t )0;
  start_a = start_p;
  while (j <= b->a.n) {
    if (j == b->a.n) {
      goto _L___0;
    } else
    if ((b->a.a + j)->x >> 8 != (b->a.a + (j - 1UL))->x >> 8) {
      _L___0: /* CIL Label */ 
      p = b->a.a + (j - 1UL);
      itr = kh_put_idx(h, ((p->x >> 8) >> mi->b) << 1, & absent);
      if (absent) {
        if (! (j == start_a + (size_t )n)) {
          __assert_fail("absent && j == start_a + n", "index.c", 244U, "worker_post");
        }
      } else {
        __assert_fail("absent && j == start_a + n", "index.c", 244U, "worker_post");
      }
      if (n == 1) {
        *(h->keys + itr) |= 1UL;
        *(h->vals + itr) = p->y;
      } else {
        k = 0;
        while (k < n) {
          *(b->p + (start_p + (size_t )k)) = (b->a.a + (start_a + (size_t )k))->y;
          k ++;
        }
        radix_sort_64(b->p + start_p, b->p + (start_p + (size_t )n));
        *(h->vals + itr) = (start_p << 32) | (unsigned long )n;
        start_p += (size_t )n;
      }
      start_a = j;
      n = 1;
    } else {
      n ++;
    }
    j ++;
  }
  b->h = (void *)h;
  if (! (b->n == (int32_t )start_p)) {
    __assert_fail("b->n == (int32_t)start_p", "index.c", 260U, "worker_post");
  }
  kfree((void *)0, (void *)b->a.a);
  tmp___2 = (size_t )0;
  b->a.m = tmp___2;
  b->a.n = tmp___2;
  b->a.a = (mm128_t *)0;
  return;
}
}
static void mm_idx_post(mm_idx_t *mi , int n_threads ) 
{ 


  {
  kt_for(n_threads, & worker_post, (void *)mi, (long )(1 << mi->b));
  return;
}
}
static void mm_idx_add(mm_idx_t *mi , int n , mm128_t const   *a ) 
{ 
  int i ;
  int mask ;
  mm128_v *p ;
  void *tmp ;
  size_t tmp___0 ;

  {
  mask = (1 << mi->b) - 1;
  i = 0;
  while (i < n) {
    p = & (mi->B + (((a + i)->x >> 8) & (unsigned long const   )mask))->a;
    while (1) {
      if (p->n == p->m) {
        if (p->m) {
          p->m <<= 1;
        } else {
          p->m = (size_t )2;
        }
        tmp = krealloc((void *)0, (void *)p->a, sizeof(mm128_t ) * p->m);
        p->a = (mm128_t *)tmp;
      }
      tmp___0 = p->n;
      (p->n) ++;
      *(p->a + tmp___0) = (mm128_t )*(a + i);
      break;
    }
    i ++;
  }
  return;
}
}
static void *worker_pipeline(void *shared , int step , void *in ) 
{ 
  int i ;
  pipeline_t *p ;
  step_t *s ;
  void *tmp ;
  uint32_t old_m ;
  uint32_t m ;
  void *tmp___1 ;
  uint64_t sum_len ;
  uint64_t old_max_len ;
  uint64_t max_len ;
  void *tmp___2 ;
  mm_idx_seq_t *seq ;
  uint32_t j ;
  size_t tmp___3 ;
  void *tmp___4 ;
  uint64_t o ;
  int c ;
  uint32_t tmp___5 ;
  step_t *s___0 ;
  mm_bseq1_t *t ;
  step_t *s___1 ;

  {
  p = (pipeline_t *)shared;
  if (step == 0) {
    if (p->sum_len > p->batch_size) {
      return ((void *)0);
    }
    tmp = calloc((size_t )1, sizeof(step_t ));
    s = (step_t *)tmp;
    s->seq = mm_bseq_read(p->fp, (int64_t )p->mini_batch_size, 0, & s->n_seq);
    if (s->seq) {
      if (! ((uint64_t )(p->mi)->n_seq + (uint64_t )s->n_seq <= 4294967295UL)) {
        __assert_fail("(uint64_t)p->mi->n_seq + s->n_seq <= UINT32_MAX", "index.c",
                      313U, "worker_pipeline");
      }
      old_m = (p->mi)->n_seq;
      m = (p->mi)->n_seq + (uint32_t )s->n_seq;
      m --;
      m |= m >> 1;
      m |= m >> 2;
      m |= m >> 4;
      m |= m >> 8;
      m |= m >> 16;
      m ++;
      old_m --;
      old_m |= old_m >> 1;
      old_m |= old_m >> 2;
      old_m |= old_m >> 4;
      old_m |= old_m >> 8;
      old_m |= old_m >> 16;
      old_m ++;
      if (old_m != m) {
        tmp___1 = krealloc((p->mi)->km, (void *)(p->mi)->seq, (unsigned long )m * sizeof(mm_idx_seq_t ));
        (p->mi)->seq = (mm_idx_seq_t *)tmp___1;
      }
      if (! ((p->mi)->flag & 2)) {
        i = 0;
        sum_len = (uint64_t )0;
        while (i < s->n_seq) {
          sum_len += (uint64_t )(s->seq + i)->l_seq;
          i ++;
        }
        old_max_len = (p->sum_len + 7UL) / 8UL;
        max_len = ((p->sum_len + sum_len) + 7UL) / 8UL;
        old_max_len --;
        old_max_len |= old_max_len >> 1;
        old_max_len |= old_max_len >> 2;
        old_max_len |= old_max_len >> 4;
        old_max_len |= old_max_len >> 8;
        old_max_len |= old_max_len >> 16;
        old_max_len |= old_max_len >> 32;
        old_max_len ++;
        max_len --;
        max_len |= max_len >> 1;
        max_len |= max_len >> 2;
        max_len |= max_len >> 4;
        max_len |= max_len >> 8;
        max_len |= max_len >> 16;
        max_len |= max_len >> 32;
        max_len ++;
        if (old_max_len != max_len) {
          tmp___2 = realloc((void *)(p->mi)->S, max_len * 4UL);
          (p->mi)->S = (uint32_t *)tmp___2;
          memset((void *)((p->mi)->S + old_max_len), 0, 4UL * (max_len - old_max_len));
        }
      }
      i = 0;
      while (i < s->n_seq) {
        seq = (p->mi)->seq + (p->mi)->n_seq;
        if (! ((p->mi)->flag & 4)) {
          tmp___3 = strlen((char const   *)(s->seq + i)->name);
          tmp___4 = kmalloc((p->mi)->km, tmp___3 + 1UL);
          seq->name = (char *)tmp___4;
          strcpy((char * __restrict  )seq->name, (char const   * __restrict  )(s->seq + i)->name);
        } else {
          seq->name = (char *)0;
        }
        seq->len = (uint32_t )(s->seq + i)->l_seq;
        seq->offset = p->sum_len;
        seq->is_alt = (uint32_t )0;
        if (! ((p->mi)->flag & 2)) {
          j = (uint32_t )0;
          while (j < seq->len) {
            o = p->sum_len + (uint64_t )j;
            c = (int )seq_nt4_table[(uint8_t )*((s->seq + i)->seq + j)];
            *((p->mi)->S + (o >> 3)) |= (uint32_t )c << ((o & 7UL) << 2);
            j ++;
          }
        }
        p->sum_len += (uint64_t )seq->len;
        tmp___5 = (p->mi)->n_seq;
        ((p->mi)->n_seq) ++;
        (s->seq + i)->rid = (int )tmp___5;
        i ++;
      }
      return ((void *)s);
    } else {
      free((void *)s);
    }
  } else
  if (step == 1) {
    s___0 = (step_t *)in;
    i = 0;
    while (i < s___0->n_seq) {
      t = s___0->seq + i;
      if (t->l_seq > 0) {
        mm_sketch((void *)0, (char const   *)t->seq, t->l_seq, (p->mi)->w, (p->mi)->k,
                  (uint32_t )t->rid, (p->mi)->flag & 1, & s___0->a);
      } else
      if (mm_verbose >= 2) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[WARNING] the length database sequence \'%s\' is 0\n",
                t->name);
      }
      free((void *)t->seq);
      free((void *)t->name);
      i ++;
    }
    free((void *)s___0->seq);
    s___0->seq = (mm_bseq1_t *)0;
    return ((void *)s___0);
  } else
  if (step == 2) {
    s___1 = (step_t *)in;
    mm_idx_add(p->mi, (int )s___1->a.n, (mm128_t const   *)s___1->a.a);
    kfree((void *)0, (void *)s___1->a.a);
    free((void *)s___1);
  }
  return ((void *)0);
}
}
mm_idx_t *mm_idx_gen(mm_bseq_file_t *fp , int w , int k , int b , int flag , int mini_batch_size ,
                     int n_threads , uint64_t batch_size ) 
{ 
  pipeline_t pl ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;

  {
  if ((unsigned long )fp == (unsigned long )((mm_bseq_file_t *)0)) {
    return ((mm_idx_t *)0);
  } else {
    tmp = mm_bseq_eof(fp);
    if (tmp) {
      return ((mm_idx_t *)0);
    }
  }
  memset((void *)(& pl), 0, sizeof(pipeline_t ));
  if ((uint64_t )mini_batch_size < batch_size) {
    pl.mini_batch_size = mini_batch_size;
  } else {
    pl.mini_batch_size = (int )batch_size;
  }
  pl.batch_size = batch_size;
  pl.fp = fp;
  pl.mi = mm_idx_init(w, k, b, flag);
  if (n_threads < 3) {
    tmp___0 = n_threads;
  } else {
    tmp___0 = 3;
  }
  kt_pipeline(tmp___0, & worker_pipeline, (void *)(& pl), 3);
  if (mm_verbose >= 3) {
    tmp___1 = cputime();
    tmp___2 = realtime();
    tmp___3 = realtime();
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[M::%s::%.3f*%.2f] collected minimizers\n",
            "mm_idx_gen", tmp___3 - mm_realtime0, tmp___1 / (tmp___2 - mm_realtime0));
  }
  mm_idx_post(pl.mi, n_threads);
  if (mm_verbose >= 3) {
    tmp___4 = cputime();
    tmp___5 = realtime();
    tmp___6 = realtime();
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[M::%s::%.3f*%.2f] sorted minimizers\n",
            "mm_idx_gen", tmp___6 - mm_realtime0, tmp___4 / (tmp___5 - mm_realtime0));
  }
  return (pl.mi);
}
}
mm_idx_t *mm_idx_build(char const   *fn , int w , int k , int flag , int n_threads ) 
{ 
  mm_bseq_file_t *fp ;
  mm_idx_t *mi ;

  {
  fp = mm_bseq_open(fn);
  if ((unsigned long )fp == (unsigned long )((mm_bseq_file_t *)0)) {
    return ((mm_idx_t *)0);
  }
  mi = mm_idx_gen(fp, w, k, 14, flag, 1 << 18, n_threads, 18446744073709551615);
  mm_bseq_close(fp);
  return (mi);
}
}
mm_idx_t *mm_idx_str(int w , int k , int is_hpc , int bucket_bits , int n , char const   **seq ,
                     char const   **name ) 
{ 
  uint64_t sum_len ;
  mm128_v a ;
  mm_idx_t *mi ;
  kh_str_t *h ;
  int i ;
  int flag ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *s ;
  mm_idx_seq_t *p ;
  uint32_t j ;
  int absent ;
  size_t tmp___2 ;
  void *tmp___3 ;
  size_t tmp___5 ;
  int c ;
  uint64_t o ;

  {
  sum_len = (uint64_t )0;
  a.n = (size_t )0;
  a.m = (size_t )0;
  a.a = (mm128_t *)0;
  flag = 0;
  if (n <= 0) {
    return ((mm_idx_t *)0);
  }
  i = 0;
  while (i < n) {
    tmp = strlen(*(seq + i));
    sum_len += tmp;
    i ++;
  }
  if (is_hpc) {
    flag |= 1;
  }
  if ((unsigned long )name == (unsigned long )((char const   **)0)) {
    flag |= 4;
  }
  if (bucket_bits < 0) {
    bucket_bits = 14;
  }
  mi = mm_idx_init(w, k, bucket_bits, flag);
  mi->n_seq = (uint32_t )n;
  tmp___0 = kcalloc(mi->km, (size_t )n, sizeof(mm_idx_seq_t ));
  mi->seq = (mm_idx_seq_t *)tmp___0;
  tmp___1 = calloc((sum_len + 7UL) / 8UL, (size_t )4);
  mi->S = (uint32_t *)tmp___1;
  h = kh_init_str();
  mi->h = (void *)h;
  i = 0;
  sum_len = (uint64_t )0;
  while (i < n) {
    s = *(seq + i);
    p = mi->seq + i;
    if (name) {
      if (*(name + i)) {
        tmp___2 = strlen(*(name + i));
        tmp___3 = kmalloc(mi->km, tmp___2 + 1UL);
        p->name = (char *)tmp___3;
        strcpy((char * __restrict  )p->name, (char const   * __restrict  )*(name + i));
        kh_put_str(h, (kh_cstr_t )p->name, & absent);
        if (! absent) {
          __assert_fail("absent", "index.c", 436U, "mm_idx_str");
        }
      }
    }
    p->offset = sum_len;
    tmp___5 = strlen(s);
    p->len = (uint32_t )tmp___5;
    p->is_alt = (uint32_t )0;
    j = (uint32_t )0;
    while (j < p->len) {
      c = (int )seq_nt4_table[(uint8_t )*(s + j)];
      o = sum_len + (uint64_t )j;
      *(mi->S + (o >> 3)) |= (uint32_t )c << ((o & 7UL) << 2);
      j ++;
    }
    sum_len += (uint64_t )p->len;
    if (p->len > 0U) {
      a.n = (size_t )0;
      mm_sketch((void *)0, s, (int )p->len, w, k, (uint32_t )i, is_hpc, & a);
      mm_idx_add(mi, (int )a.n, (mm128_t const   *)a.a);
    }
    i ++;
  }
  free((void *)a.a);
  mm_idx_post(mi, 1);
  return (mi);
}
}
void mm_idx_dump(FILE *fp , mm_idx_t const   *mi ) 
{ 
  uint64_t sum_len ;
  uint32_t x[5] ;
  uint32_t i ;
  uint8_t l ;
  size_t tmp ;
  uint8_t l___0 ;
  mm_idx_bucket_t *b ;
  khint_t k ;
  idxhash_t *h ;
  uint32_t size ;
  khint_t tmp___0 ;
  uint64_t x___0[2] ;

  {
  sum_len = (uint64_t )0;
  x[0] = (uint32_t )mi->w;
  x[1] = (uint32_t )mi->k;
  x[2] = (uint32_t )mi->b;
  x[3] = (uint32_t )mi->n_seq;
  x[4] = (uint32_t )mi->flag;
  fwrite((void const   * __restrict  )"MMI\002", (size_t )1, (size_t )4, (FILE * __restrict  )fp);
  fwrite((void const   * __restrict  )(x), (size_t )4, (size_t )5, (FILE * __restrict  )fp);
  i = (uint32_t )0;
  while (i < (uint32_t )mi->n_seq) {
    if ((mi->seq + i)->name) {
      tmp = strlen((char const   *)(mi->seq + i)->name);
      l = (uint8_t )tmp;
      fwrite((void const   * __restrict  )(& l), (size_t )1, (size_t )1, (FILE * __restrict  )fp);
      fwrite((void const   * __restrict  )(mi->seq + i)->name, (size_t )1, (size_t )l,
             (FILE * __restrict  )fp);
    } else {
      l___0 = (uint8_t )0;
      fwrite((void const   * __restrict  )(& l___0), (size_t )1, (size_t )1, (FILE * __restrict  )fp);
    }
    fwrite((void const   * __restrict  )(& (mi->seq + i)->len), (size_t )4, (size_t )1,
           (FILE * __restrict  )fp);
    sum_len += (uint64_t )(mi->seq + i)->len;
    i ++;
  }
  i = (uint32_t )0;
  while (i < (uint32_t )(1 << mi->b)) {
    b = mi->B + i;
    h = (idxhash_t *)b->h;
    if (h) {
      tmp___0 = h->size;
    } else {
      tmp___0 = (khint_t )0;
    }
    size = tmp___0;
    fwrite((void const   * __restrict  )(& b->n), (size_t )4, (size_t )1, (FILE * __restrict  )fp);
    fwrite((void const   * __restrict  )b->p, (size_t )8, (size_t )b->n, (FILE * __restrict  )fp);
    fwrite((void const   * __restrict  )(& size), (size_t )4, (size_t )1, (FILE * __restrict  )fp);
    if (size == 0U) {
      goto __Cont;
    }
    k = (khint_t )0;
    while (k < h->n_buckets) {
      if (! (! ((*(h->flags + (k >> 4)) >> ((k & 15U) << 1)) & 3U))) {
        goto __Cont___0;
      }
      x___0[0] = *(h->keys + k);
      x___0[1] = *(h->vals + k);
      fwrite((void const   * __restrict  )(x___0), (size_t )8, (size_t )2, (FILE * __restrict  )fp);
      __Cont___0: /* CIL Label */ 
      k ++;
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  if (! (mi->flag & 2)) {
    fwrite((void const   * __restrict  )mi->S, (size_t )4, (sum_len + 7UL) / 8UL,
           (FILE * __restrict  )fp);
  }
  fflush(fp);
  return;
}
}
mm_idx_t *mm_idx_load(FILE *fp ) 
{ 
  char magic[4] ;
  uint32_t x[5] ;
  uint32_t i ;
  uint64_t sum_len ;
  mm_idx_t *mi ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  uint8_t l ;
  mm_idx_seq_t *s ;
  void *tmp___3 ;
  mm_idx_bucket_t *b ;
  uint32_t j ;
  uint32_t size ;
  khint_t k ;
  idxhash_t *h ;
  void *tmp___4 ;
  uint64_t x___0[2] ;
  int absent ;
  void *tmp___6 ;

  {
  sum_len = (uint64_t )0;
  tmp = fread((void * __restrict  )(magic), (size_t )1, (size_t )4, (FILE * __restrict  )fp);
  if (tmp != 4UL) {
    return ((mm_idx_t *)0);
  }
  tmp___0 = strncmp((char const   *)(magic), "MMI\002", (size_t )4);
  if (tmp___0 != 0) {
    return ((mm_idx_t *)0);
  }
  tmp___1 = fread((void * __restrict  )(x), (size_t )4, (size_t )5, (FILE * __restrict  )fp);
  if (tmp___1 != 5UL) {
    return ((mm_idx_t *)0);
  }
  mi = mm_idx_init((int )x[0], (int )x[1], (int )x[2], (int )x[4]);
  mi->n_seq = x[3];
  tmp___2 = kcalloc(mi->km, (size_t )mi->n_seq, sizeof(mm_idx_seq_t ));
  mi->seq = (mm_idx_seq_t *)tmp___2;
  i = (uint32_t )0;
  while (i < mi->n_seq) {
    s = mi->seq + i;
    fread((void * __restrict  )(& l), (size_t )1, (size_t )1, (FILE * __restrict  )fp);
    if (l) {
      tmp___3 = kmalloc(mi->km, (size_t )((int )l + 1));
      s->name = (char *)tmp___3;
      fread((void * __restrict  )s->name, (size_t )1, (size_t )l, (FILE * __restrict  )fp);
      *(s->name + l) = (char)0;
    }
    fread((void * __restrict  )(& s->len), (size_t )4, (size_t )1, (FILE * __restrict  )fp);
    s->offset = sum_len;
    s->is_alt = (uint32_t )0;
    sum_len += (uint64_t )s->len;
    i ++;
  }
  i = (uint32_t )0;
  while (i < (uint32_t )(1 << mi->b)) {
    b = mi->B + i;
    fread((void * __restrict  )(& b->n), (size_t )4, (size_t )1, (FILE * __restrict  )fp);
    tmp___4 = malloc((size_t )(b->n * 8));
    b->p = (uint64_t *)tmp___4;
    fread((void * __restrict  )b->p, (size_t )8, (size_t )b->n, (FILE * __restrict  )fp);
    fread((void * __restrict  )(& size), (size_t )4, (size_t )1, (FILE * __restrict  )fp);
    if (size == 0U) {
      goto __Cont;
    }
    h = kh_init_idx();
    b->h = (void *)h;
    kh_resize_idx(h, size);
    j = (uint32_t )0;
    while (j < size) {
      fread((void * __restrict  )(x___0), (size_t )8, (size_t )2, (FILE * __restrict  )fp);
      k = kh_put_idx(h, x___0[0], & absent);
      if (! absent) {
        __assert_fail("absent", "index.c", 547U, "mm_idx_load");
      }
      *(h->vals + k) = x___0[1];
      j ++;
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  if (! (mi->flag & 2)) {
    tmp___6 = malloc(((sum_len + 7UL) / 8UL) * 4UL);
    mi->S = (uint32_t *)tmp___6;
    fread((void * __restrict  )mi->S, (size_t )4, (sum_len + 7UL) / 8UL, (FILE * __restrict  )fp);
  }
  return (mi);
}
}
int64_t mm_idx_is_idx(char const   *fn ) 
{ 
  int fd ;
  int is_idx ;
  int64_t ret ;
  int64_t off_end ;
  char magic[4] ;
  int tmp ;
  int tmp___0 ;
  int64_t tmp___1 ;

  {
  is_idx = 0;
  tmp = strcmp(fn, "-");
  if (tmp == 0) {
    return ((int64_t )0);
  }
  fd = open(fn, 0);
  if (fd < 0) {
    return ((int64_t )-1);
  }
  off_end = lseek(fd, (__off_t )0, 2);
  if (off_end >= 4L) {
    lseek(fd, (__off_t )0, 0);
    ret = read(fd, (void *)(magic), (size_t )4);
    if (ret == 4L) {
      tmp___0 = strncmp((char const   *)(magic), "MMI\002", (size_t )4);
      if (tmp___0 == 0) {
        is_idx = 1;
      }
    }
  }
  close(fd);
  if (is_idx) {
    tmp___1 = off_end;
  } else {
    tmp___1 = (int64_t )0;
  }
  return (tmp___1);
}
}
mm_idx_reader_t *mm_idx_reader_open(char const   *fn , mm_idxopt_t const   *opt ,
                                    char const   *fn_out ) 
{ 
  int64_t is_idx ;
  mm_idx_reader_t *r ;
  void *tmp ;

  {
  is_idx = mm_idx_is_idx(fn);
  if (is_idx < 0L) {
    return ((mm_idx_reader_t *)0);
  }
  tmp = calloc((size_t )1, sizeof(mm_idx_reader_t ));
  r = (mm_idx_reader_t *)tmp;
  r->is_idx = (int )is_idx;
  if (opt) {
    r->opt = (mm_idxopt_t )*opt;
  } else {
    mm_idxopt_init(& r->opt);
  }
  if (r->is_idx) {
    r->fp.idx = fopen((char const   * __restrict  )fn, (char const   * __restrict  )"rb");
    r->idx_size = is_idx;
  } else {
    r->fp.seq = mm_bseq_open(fn);
  }
  if (fn_out) {
    r->fp_out = fopen((char const   * __restrict  )fn_out, (char const   * __restrict  )"wb");
  }
  return (r);
}
}
void mm_idx_reader_close(mm_idx_reader_t *r ) 
{ 


  {
  if (r->is_idx) {
    fclose(r->fp.idx);
  } else {
    mm_bseq_close(r->fp.seq);
  }
  if (r->fp_out) {
    fclose(r->fp_out);
  }
  free((void *)r);
  return;
}
}
mm_idx_t *mm_idx_reader_read(mm_idx_reader_t *r , int n_threads ) 
{ 
  mm_idx_t *mi ;
  int tmp ;

  {
  if (r->is_idx) {
    mi = mm_idx_load(r->fp.idx);
    if (mi) {
      if (mm_verbose >= 2) {
        if (mi->k != (int32_t )r->opt.k) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[WARNING]\033[1;31m Indexing parameters (-k, -w or -H) overridden by parameters used in the prebuilt index.\033[0m\n");
        } else
        if (mi->w != (int32_t )r->opt.w) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[WARNING]\033[1;31m Indexing parameters (-k, -w or -H) overridden by parameters used in the prebuilt index.\033[0m\n");
        } else
        if ((mi->flag & 1) != ((int )r->opt.flag & 1)) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[WARNING]\033[1;31m Indexing parameters (-k, -w or -H) overridden by parameters used in the prebuilt index.\033[0m\n");
        }
      }
    }
  } else {
    mi = mm_idx_gen(r->fp.seq, (int )r->opt.w, (int )r->opt.k, (int )r->opt.bucket_bits,
                    (int )r->opt.flag, (int )r->opt.mini_batch_size, n_threads, r->opt.batch_size);
  }
  if (mi) {
    if (r->fp_out) {
      mm_idx_dump(r->fp_out, (mm_idx_t const   *)mi);
    }
    tmp = r->n_parts;
    (r->n_parts) ++;
    mi->index = tmp;
  }
  return (mi);
}
}
int mm_idx_reader_eof(mm_idx_reader_t const   *r ) 
{ 
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if (r->is_idx) {
    tmp = feof((FILE *)r->fp.idx);
    if (tmp) {
      tmp___1 = 1;
    } else {
      tmp___0 = ftell((FILE *)r->fp.idx);
      if (tmp___0 == (long )r->idx_size) {
        tmp___1 = 1;
      } else {
        tmp___1 = 0;
      }
    }
    tmp___3 = tmp___1;
  } else {
    tmp___2 = mm_bseq_eof((mm_bseq_file_t *)r->fp.seq);
    tmp___3 = tmp___2;
  }
  return (tmp___3);
}
}
int mm_idx_alt_read(mm_idx_t *mi , char const   *fn ) 
{ 
  int n_alt ;
  gzFile fp ;
  kstream_t *ks ;
  kstring_t str ;
  gzFile tmp___0 ;
  int tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  char *p ;
  int id ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;

  {
  n_alt = 0;
  str.l = (size_t )0;
  str.m = (size_t )0;
  str.s = (char *)0;
  if (fn) {
    tmp___3 = strcmp(fn, "-");
    if (tmp___3) {
      tmp___0 = gzopen(fn, "r");
      fp = tmp___0;
    } else {
      tmp___1 = fileno(stdin);
      tmp___2 = gzdopen(tmp___1, "r");
      fp = tmp___2;
    }
  } else {
    tmp___1 = fileno(stdin);
    tmp___2 = gzdopen(tmp___1, "r");
    fp = tmp___2;
  }
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
    return (-1);
  }
  ks = ks_init(fp);
  if ((unsigned long )mi->h == (unsigned long )((void *)0)) {
    mm_idx_index_name(mi);
  }
  while (1) {
    tmp___5 = ks_getuntil(ks, 2, & str, (int *)0);
    if (! (tmp___5 >= 0)) {
      break;
    }
    p = str.s;
    while (1) {
      if (*p) {
        tmp___4 = __ctype_b_loc();
        if ((int const   )*(*tmp___4 + (int )*p) & 8192) {
          break;
        }
      } else {
        break;
      }
      p ++;
    }
    *p = (char)0;
    id = mm_idx_name2id((mm_idx_t const   *)mi, (char const   *)str.s);
    if (id >= 0) {
      (mi->seq + id)->is_alt = (uint32_t )1;
      n_alt ++;
    }
  }
  mi->n_alt = n_alt;
  if (mm_verbose >= 3) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[M::%s] found %d ALT contigs\n",
            "mm_idx_alt_read", n_alt);
  }
  return (n_alt);
}
}
void rs_insertsort_bed(mm_idx_intv1_t *beg , mm_idx_intv1_t *end ) 
{ 
  mm_idx_intv1_t *i ;
  mm_idx_intv1_t *j ;
  mm_idx_intv1_t tmp ;

  {
  i = beg + 1;
  while ((unsigned long )i < (unsigned long )end) {
    if (i->st < (i - 1)->st) {
      tmp = *i;
      j = i;
      while (1) {
        if ((unsigned long )j > (unsigned long )beg) {
          if (! (tmp.st < (j - 1)->st)) {
            break;
          }
        } else {
          break;
        }
        *j = *(j - 1);
        j --;
      }
      *j = tmp;
    }
    i ++;
  }
  return;
}
}
void rs_sort_bed(mm_idx_intv1_t *beg , mm_idx_intv1_t *end , int n_bits , int s ) 
{ 
  mm_idx_intv1_t *i ;
  int size ;
  int m ;
  rsbucket_bed_t *k ;
  rsbucket_bed_t b[1 << 8] ;
  rsbucket_bed_t *be ;
  mm_idx_intv1_t *tmp___0 ;
  rsbucket_bed_t *l ;
  mm_idx_intv1_t tmp___1 ;
  mm_idx_intv1_t swap ;
  mm_idx_intv1_t *tmp___2 ;
  mm_idx_intv1_t *tmp___3 ;

  {
  size = 1 << n_bits;
  m = size - 1;
  be = b + size;
  if (! (n_bits <= 8)) {
    __assert_fail("n_bits <= RS_MAX_BITS", "index.c", 660U, "rs_sort_bed");
  }
  k = b;
  while ((unsigned long )k != (unsigned long )be) {
    tmp___0 = beg;
    k->e = tmp___0;
    k->b = tmp___0;
    k ++;
  }
  i = beg;
  while ((unsigned long )i != (unsigned long )end) {
    (b[(i->st >> s) & m].e) ++;
    i ++;
  }
  k = b + 1;
  while ((unsigned long )k != (unsigned long )be) {
    k->e += (k - 1)->e - beg;
    k->b = (k - 1)->e;
    k ++;
  }
  k = b;
  while ((unsigned long )k != (unsigned long )be) {
    if ((unsigned long )k->b != (unsigned long )k->e) {
      l = b + (((k->b)->st >> s) & m);
      if ((unsigned long )l != (unsigned long )k) {
        tmp___1 = *(k->b);
        while (1) {
          swap = tmp___1;
          tmp___1 = *(l->b);
          tmp___2 = l->b;
          (l->b) ++;
          *tmp___2 = swap;
          l = b + ((tmp___1.st >> s) & m);
          if (! ((unsigned long )l != (unsigned long )k)) {
            break;
          }
        }
        tmp___3 = k->b;
        (k->b) ++;
        *tmp___3 = tmp___1;
      } else {
        (k->b) ++;
      }
    } else {
      k ++;
    }
  }
  b[0].b = beg;
  k = b + 1;
  while ((unsigned long )k != (unsigned long )be) {
    k->b = (k - 1)->e;
    k ++;
  }
  if (s) {
    if (s > n_bits) {
      s -= n_bits;
    } else {
      s = 0;
    }
    k = b;
    while ((unsigned long )k != (unsigned long )be) {
      if (k->e - k->b > 64L) {
        rs_sort_bed(k->b, k->e, n_bits, s);
      } else
      if (k->e - k->b > 1L) {
        rs_insertsort_bed(k->b, k->e);
      }
      k ++;
    }
  }
  return;
}
}
void radix_sort_bed(mm_idx_intv1_t *beg , mm_idx_intv1_t *end ) 
{ 


  {
  if (end - beg <= 64L) {
    rs_insertsort_bed(beg, end);
  } else {
    rs_sort_bed(beg, end, 8, 24);
  }
  return;
}
}
mm_idx_intv_t *mm_idx_read_bed(mm_idx_t const   *mi , char const   *fn , int read_junc ) 
{ 
  gzFile fp ;
  kstream_t *ks ;
  kstring_t str ;
  mm_idx_intv_t *I ;
  gzFile tmp___0 ;
  int tmp___1 ;
  gzFile tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  mm_idx_intv_t *r ;
  mm_idx_intv1_t t ;
  char *p ;
  char *q ;
  char *bl ;
  char *bs ;
  int32_t i ;
  int32_t id ;
  int32_t n_blk ;
  int32_t c ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  unsigned short const   **tmp___9 ;
  long tmp___10 ;
  int32_t st ;
  int32_t sz ;
  int32_t en ;
  long tmp___11 ;
  long tmp___12 ;
  mm_idx_intv1_t s ;
  void *tmp___13 ;
  long tmp___14 ;
  long tmp___15 ;
  int32_t tmp___16 ;
  void *tmp___17 ;
  int32_t tmp___18 ;
  int tmp___19 ;

  {
  str.l = (size_t )0;
  str.m = (size_t )0;
  str.s = (char *)0;
  if (fn) {
    tmp___3 = strcmp(fn, "-");
    if (tmp___3) {
      tmp___0 = gzopen(fn, "r");
      fp = tmp___0;
    } else {
      tmp___1 = fileno(stdin);
      tmp___2 = gzdopen(tmp___1, "r");
      fp = tmp___2;
    }
  } else {
    tmp___1 = fileno(stdin);
    tmp___2 = gzdopen(tmp___1, "r");
    fp = tmp___2;
  }
  if ((unsigned long )fp == (unsigned long )((gzFile )0)) {
    return ((mm_idx_intv_t *)0);
  }
  tmp___4 = calloc((size_t )mi->n_seq, sizeof(*I));
  I = (mm_idx_intv_t *)tmp___4;
  ks = ks_init(fp);
  while (1) {
    tmp___19 = ks_getuntil(ks, 2, & str, (int *)0);
    if (! (tmp___19 >= 0)) {
      break;
    }
    t.st = -1;
    t.en = -1;
    t.max = -1;
    t.score = -1;
    t.strand = 0;
    id = -1;
    n_blk = 0;
    q = str.s;
    p = q;
    i = 0;
    while (1) {
      if ((int )*p == 0) {
        goto _L;
      } else
      if ((int )*p == 9) {
        _L: /* CIL Label */ 
        c = (int32_t )*p;
        *p = (char)0;
        if (i == 0) {
          id = mm_idx_name2id(mi, (char const   *)q);
          if (id < 0) {
            break;
          }
        } else
        if (i == 1) {
          tmp___5 = atol((char const   *)q);
          t.st = (int32_t )tmp___5;
          if (t.st < 0) {
            break;
          }
        } else
        if (i == 2) {
          tmp___6 = atol((char const   *)q);
          t.en = (int32_t )tmp___6;
          if (t.en < 0) {
            break;
          }
        } else
        if (i == 4) {
          tmp___7 = atol((char const   *)q);
          t.score = (int32_t )tmp___7;
        } else
        if (i == 5) {
          if ((int )*q == 43) {
            t.strand = 1;
          } else {
            if ((int )*q == 45) {
              tmp___8 = -1;
            } else {
              tmp___8 = 0;
            }
            t.strand = tmp___8;
          }
        } else
        if (i == 9) {
          tmp___9 = __ctype_b_loc();
          if (! ((int const   )*(*tmp___9 + (int )*q) & 2048)) {
            break;
          }
          tmp___10 = atol((char const   *)q);
          n_blk = (int32_t )tmp___10;
        } else
        if (i == 10) {
          bl = q;
        } else
        if (i == 11) {
          bs = q;
          break;
        }
        if (c == 0) {
          break;
        }
        i ++;
        q = p + 1;
      }
      p ++;
    }
    if (id < 0) {
      continue;
    } else
    if (t.st < 0) {
      continue;
    } else
    if (t.st >= t.en) {
      continue;
    }
    r = I + id;
    if (i >= 11) {
      if (read_junc) {
        tmp___11 = strtol((char const   * __restrict  )bs, (char ** __restrict  )(& bs),
                          10);
        st = (int32_t )tmp___11;
        bs ++;
        tmp___12 = strtol((char const   * __restrict  )bl, (char ** __restrict  )(& bl),
                          10);
        sz = (int32_t )tmp___12;
        bl ++;
        en = (t.st + st) + sz;
        i = 1;
        while (i < n_blk) {
          s = t;
          if (r->n == r->m) {
            if (r->m) {
              r->m += r->m >> 1;
            } else {
              r->m = 16;
            }
            tmp___13 = realloc((void *)r->a, sizeof(*(r->a)) * (unsigned long )r->m);
            r->a = (mm_idx_intv1_t *)tmp___13;
          }
          tmp___14 = strtol((char const   * __restrict  )bs, (char ** __restrict  )(& bs),
                            10);
          st = (int32_t )tmp___14;
          bs ++;
          tmp___15 = strtol((char const   * __restrict  )bl, (char ** __restrict  )(& bl),
                            10);
          sz = (int32_t )tmp___15;
          bl ++;
          s.st = en;
          s.en = t.st + st;
          en = (t.st + st) + sz;
          if (s.en > s.st) {
            tmp___16 = r->n;
            (r->n) ++;
            *(r->a + tmp___16) = s;
          }
          i ++;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      if (r->n == r->m) {
        if (r->m) {
          r->m += r->m >> 1;
        } else {
          r->m = 16;
        }
        tmp___17 = realloc((void *)r->a, sizeof(*(r->a)) * (unsigned long )r->m);
        r->a = (mm_idx_intv1_t *)tmp___17;
      }
      tmp___18 = r->n;
      (r->n) ++;
      *(r->a + tmp___18) = t;
    }
  }
  free((void *)str.s);
  ks_destroy(ks);
  gzclose(fp);
  return (I);
}
}
int mm_idx_bed_read(mm_idx_t *mi , char const   *fn , int read_junc ) 
{ 
  int32_t i ;

  {
  if ((unsigned long )mi->h == (unsigned long )((void *)0)) {
    mm_idx_index_name(mi);
  }
  mi->I = mm_idx_read_bed((mm_idx_t const   *)mi, fn, read_junc);
  if ((unsigned long )mi->I == (unsigned long )((struct mm_idx_intv_s *)0)) {
    return (-1);
  }
  i = 0;
  while ((uint32_t )i < mi->n_seq) {
    radix_sort_bed((mi->I + i)->a, (mi->I + i)->a + (mi->I + i)->n);
    i ++;
  }
  return (0);
}
}
int mm_idx_bed_junc(mm_idx_t const   *mi , int32_t ctg , int32_t st , int32_t en ,
                    uint8_t *s ) 
{ 
  int32_t i ;
  int32_t left ;
  int32_t right ;
  mm_idx_intv_t *r ;
  int32_t mid ;

  {
  memset((void *)s, 0, (size_t )(en - st));
  if ((unsigned long )mi->I == (unsigned long )((struct mm_idx_intv_s * const  )0)) {
    return (-1);
  } else
  if (ctg < 0) {
    return (-1);
  } else
  if ((uint32_t const   )ctg >= mi->n_seq) {
    return (-1);
  }
  r = mi->I + ctg;
  left = 0;
  right = r->n;
  while (right > left) {
    mid = left + ((right - left) >> 1);
    if ((r->a + mid)->st >= st) {
      right = mid;
    } else {
      left = mid + 1;
    }
  }
  i = left;
  while (i < r->n) {
    if (st <= (r->a + i)->st) {
      if (en >= (r->a + i)->en) {
        if ((r->a + i)->strand != 0) {
          if ((r->a + i)->strand > 0) {
            *(s + ((r->a + i)->st - st)) = (uint8_t )((int )*(s + ((r->a + i)->st - st)) | 1);
            *(s + (((r->a + i)->en - 1) - st)) = (uint8_t )((int )*(s + (((r->a + i)->en - 1) - st)) | 2);
          } else {
            *(s + ((r->a + i)->st - st)) = (uint8_t )((int )*(s + ((r->a + i)->st - st)) | 8);
            *(s + (((r->a + i)->en - 1) - st)) = (uint8_t )((int )*(s + (((r->a + i)->en - 1) - st)) | 4);
          }
        }
      }
    }
    i ++;
  }
  return (left);
}
}
#pragma merger("0","/tmp/cil-pVqXK4mf.i","-g,-Wall,-O2,-Wc++-compat")
void *km_init2(void *km_par , size_t min_core_size ) ;
void km_stat(void const   *_km , km_stat_t *s ) ;
static void panic(char const   *s ) 
{ 


  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n", s);
  abort();
}
}
void *km_init2(void *km_par , size_t min_core_size ) 
{ 
  kmem_t *km ;
  void *tmp ;

  {
  tmp = kcalloc(km_par, (size_t )1, sizeof(kmem_t ));
  km = (kmem_t *)tmp;
  km->par = km_par;
  if (min_core_size > 0UL) {
    km->min_core_size = min_core_size;
  } else {
    km->min_core_size = (size_t )524288;
  }
  return ((void *)km);
}
}
void *km_init(void) 
{ 
  void *tmp ;

  {
  tmp = km_init2((void *)0, (size_t )0);
  return (tmp);
}
}
void km_destroy(void *_km ) 
{ 
  kmem_t *km ;
  void *km_par ;
  header_t *p ;
  header_t *q ;

  {
  km = (kmem_t *)_km;
  if ((unsigned long )km == (unsigned long )((void *)0)) {
    return;
  }
  km_par = km->par;
  p = km->core_head;
  while ((unsigned long )p != (unsigned long )((void *)0)) {
    q = p->ptr;
    kfree(km_par, (void *)p);
    p = q;
  }
  kfree(km_par, (void *)km);
  return;
}
}
static header_t *morecore(kmem_t *km , size_t nu ) 
{ 
  header_t *q ;
  size_t bytes ;
  size_t *p ;
  void *tmp ;

  {
  nu = (((nu + 1UL) + (km->min_core_size - 1UL)) / km->min_core_size) * km->min_core_size;
  bytes = nu * sizeof(header_t );
  tmp = kmalloc(km->par, bytes);
  q = (header_t *)tmp;
  if (! q) {
    panic("[morecore] insufficient memory");
  }
  q->ptr = km->core_head;
  q->size = nu;
  km->core_head = q;
  p = (size_t *)(q + 1);
  *p = nu - 1UL;
  kfree((void *)km, (void *)(p + 1));
  return (km->loop_head);
}
}
void kfree(void *_km , void *ap ) 
{ 
  header_t *p ;
  header_t *q ;
  kmem_t *km ;

  {
  km = (kmem_t *)_km;
  if (! ap) {
    return;
  }
  if ((unsigned long )km == (unsigned long )((void *)0)) {
    free(ap);
    return;
  }
  p = (header_t *)((size_t *)ap - 1);
  p->size = *((size_t *)ap - 1);
  q = km->loop_head;
  while (1) {
    if ((unsigned long )p > (unsigned long )q) {
      if ((unsigned long )p < (unsigned long )q->ptr) {
        break;
      }
    }
    if ((unsigned long )q >= (unsigned long )q->ptr) {
      if ((unsigned long )p > (unsigned long )q) {
        break;
      } else
      if ((unsigned long )p < (unsigned long )q->ptr) {
        break;
      }
    }
    q = q->ptr;
  }
  if ((unsigned long )(p + p->size) == (unsigned long )q->ptr) {
    p->size += (q->ptr)->size;
    p->ptr = (q->ptr)->ptr;
  } else
  if ((unsigned long )(p + p->size) > (unsigned long )q->ptr) {
    if ((unsigned long )q->ptr >= (unsigned long )p) {
      panic("[kfree] The end of the allocated block enters a free block.");
    } else {
      p->ptr = q->ptr;
    }
  } else {
    p->ptr = q->ptr;
  }
  if ((unsigned long )(q + q->size) == (unsigned long )p) {
    q->size += p->size;
    q->ptr = p->ptr;
    km->loop_head = q;
  } else
  if ((unsigned long )(q + q->size) > (unsigned long )p) {
    if ((unsigned long )p >= (unsigned long )q) {
      panic("[kfree] The end of a free block enters the allocated block.");
    } else {
      km->loop_head = p;
      q->ptr = p;
    }
  } else {
    km->loop_head = p;
    q->ptr = p;
  }
  return;
}
}
void *kmalloc(void *_km , size_t n_bytes ) 
{ 
  kmem_t *km ;
  size_t n_units ;
  header_t *p ;
  header_t *q ;
  void *tmp ;
  header_t *tmp___0 ;
  struct header_t *tmp___1 ;

  {
  km = (kmem_t *)_km;
  if (n_bytes == 0UL) {
    return ((void *)0);
  }
  if ((unsigned long )km == (unsigned long )((void *)0)) {
    tmp = malloc(n_bytes);
    return (tmp);
  }
  n_units = (((n_bytes + sizeof(size_t )) + sizeof(header_t )) - 1UL) / sizeof(header_t );
  q = km->loop_head;
  if (! q) {
    tmp___1 = & km->base;
    km->base.ptr = tmp___1;
    tmp___0 = tmp___1;
    km->loop_head = tmp___0;
    q = tmp___0;
  }
  p = q->ptr;
  while (1) {
    if (p->size >= n_units) {
      if (p->size == n_units) {
        q->ptr = p->ptr;
      } else {
        p->size -= n_units;
        p += p->size;
        *((size_t *)p) = n_units;
      }
      km->loop_head = q;
      return ((void *)((size_t *)p + 1));
    }
    if ((unsigned long )p == (unsigned long )km->loop_head) {
      p = morecore(km, n_units);
      if ((unsigned long )p == (unsigned long )((header_t *)0)) {
        return ((void *)0);
      }
    }
    q = p;
    p = p->ptr;
  }
}
}
void *kcalloc(void *_km , size_t count , size_t size ) 
{ 
  kmem_t *km ;
  void *p ;
  void *tmp ;

  {
  km = (kmem_t *)_km;
  if (size == 0UL) {
    return ((void *)0);
  } else
  if (count == 0UL) {
    return ((void *)0);
  }
  if ((unsigned long )km == (unsigned long )((void *)0)) {
    tmp = calloc(count, size);
    return (tmp);
  }
  p = kmalloc((void *)km, count * size);
  memset(p, 0, count * size);
  return (p);
}
}
void *krealloc(void *_km , void *ap , size_t n_bytes ) 
{ 
  kmem_t *km ;
  size_t cap ;
  size_t *p ;
  size_t *q ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  km = (kmem_t *)_km;
  if (n_bytes == 0UL) {
    kfree((void *)km, ap);
    return ((void *)0);
  }
  if ((unsigned long )km == (unsigned long )((void *)0)) {
    tmp = realloc(ap, n_bytes);
    return (tmp);
  }
  if ((unsigned long )ap == (unsigned long )((void *)0)) {
    tmp___0 = kmalloc((void *)km, n_bytes);
    return (tmp___0);
  }
  p = (size_t *)ap - 1;
  cap = *p * sizeof(header_t ) - sizeof(size_t );
  if (cap >= n_bytes) {
    return (ap);
  }
  tmp___1 = kmalloc((void *)km, n_bytes);
  q = (size_t *)tmp___1;
  memcpy((void * __restrict  )q, (void const   * __restrict  )ap, cap);
  kfree((void *)km, ap);
  return ((void *)q);
}
}
void km_stat(void const   *_km , km_stat_t *s ) 
{ 
  kmem_t *km ;
  header_t *p ;
  size_t size ;

  {
  km = (kmem_t *)_km;
  memset((void *)s, 0, sizeof(km_stat_t ));
  if ((unsigned long )km == (unsigned long )((void *)0)) {
    return;
  } else
  if ((unsigned long )km->loop_head == (unsigned long )((void *)0)) {
    return;
  }
  p = km->loop_head;
  while (1) {
    s->available += p->size * sizeof(header_t );
    if (p->size != 0UL) {
      (s->n_blocks) ++;
    }
    if ((unsigned long )p->ptr > (unsigned long )p) {
      if ((unsigned long )(p + p->size) > (unsigned long )p->ptr) {
        panic("[km_stat] The end of a free block enters another free block.");
      }
    }
    if ((unsigned long )p->ptr == (unsigned long )km->loop_head) {
      break;
    }
    p = p->ptr;
  }
  p = km->core_head;
  while ((unsigned long )p != (unsigned long )((void *)0)) {
    size = p->size * sizeof(header_t );
    (s->n_cores) ++;
    s->capacity += size;
    if (s->largest > size) {
      s->largest = s->largest;
    } else {
      s->largest = size;
    }
    p = p->ptr;
  }
  return;
}
}
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_add(...) ;  */
#pragma merger("0","/tmp/cil-CYkccx_g.i","-g,-Wall,-O2,-Wc++-compat")
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern  __attribute__((__noreturn__)) void pthread_exit(void *__retval ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                                              pthread_condattr_t const   * __restrict  __cond_attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_destroy)(pthread_cond_t *__cond ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_broadcast)(pthread_cond_t *__cond ) ;
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                     pthread_t __thread2 ) 
{ 


  {
  return (__thread1 == __thread2);
}
}
__inline static long steal_work(kt_for_t *t ) 
{ 
  int i ;
  int min_i ;
  long k ;
  long min ;
  long tmp ;

  {
  min_i = -1;
  min = 9223372036854775807L;
  i = 0;
  while (i < t->n_threads) {
    if (min > (t->w + i)->i) {
      min = (t->w + i)->i;
      min_i = i;
    }
    i ++;
  }
  k = (long )__sync_fetch_and_add(& (t->w + min_i)->i, t->n_threads);
  if (k >= t->n) {
    tmp = -1L;
  } else {
    tmp = k;
  }
  return (tmp);
}
}
static void *ktf_worker(void *data ) 
{ 
  ktf_worker_t *w ;
  long i ;

  {
  w = (ktf_worker_t *)data;
  while (1) {
    i = (long )__sync_fetch_and_add(& w->i, (w->t)->n_threads);
    if (i >= (w->t)->n) {
      break;
    }
    (*((w->t)->func))((w->t)->data, i, (int )(w - (w->t)->w));
  }
  while (1) {
    i = steal_work(w->t);
    if (! (i >= 0L)) {
      break;
    }
    (*((w->t)->func))((w->t)->data, i, (int )(w - (w->t)->w));
  }
  pthread_exit((void *)0);
}
}
void kt_for(int n_threads , void (*func)(void * , long  , int  ) , void *data , long n ) 
{ 
  int i ;
  kt_for_t t ;
  pthread_t *tid ;
  void *tmp ;
  void *tmp___0 ;
  long j ;

  {
  if (n_threads > 1) {
    t.func = func;
    t.data = data;
    t.n_threads = n_threads;
    t.n = n;
    tmp = calloc((size_t )n_threads, sizeof(ktf_worker_t ));
    t.w = (ktf_worker_t *)tmp;
    tmp___0 = calloc((size_t )n_threads, sizeof(pthread_t ));
    tid = (pthread_t *)tmp___0;
    i = 0;
    while (i < n_threads) {
      (t.w + i)->t = & t;
      (t.w + i)->i = (long )i;
      i ++;
    }
    i = 0;
    while (i < n_threads) {
      pthread_create((pthread_t * __restrict  )(tid + i), (pthread_attr_t const   * __restrict  )0,
                     & ktf_worker, (void * __restrict  )(t.w + i));
      i ++;
    }
    i = 0;
    while (i < n_threads) {
      pthread_join(*(tid + i), (void **)0);
      i ++;
    }
    free((void *)tid);
    free((void *)t.w);
  } else {
    j = 0L;
    while (j < n) {
      (*func)(data, j, 0);
      j ++;
    }
  }
  return;
}
}
static void *ktp_worker(void *data ) 
{ 
  ktp_worker_t *w ;
  ktp_t *p ;
  int i ;
  void *tmp ;
  int64_t tmp___0 ;

  {
  w = (ktp_worker_t *)data;
  p = w->pl;
  while (w->step < p->n_steps) {
    pthread_mutex_lock(& p->mutex);
    while (1) {
      i = 0;
      while (i < p->n_workers) {
        if ((unsigned long )w == (unsigned long )(p->workers + i)) {
          goto __Cont;
        }
        if ((p->workers + i)->step <= w->step) {
          if ((p->workers + i)->index < w->index) {
            break;
          }
        }
        __Cont: /* CIL Label */ 
        i ++;
      }
      if (i == p->n_workers) {
        break;
      }
      pthread_cond_wait((pthread_cond_t * __restrict  )(& p->cv), (pthread_mutex_t * __restrict  )(& p->mutex));
    }
    pthread_mutex_unlock(& p->mutex);
    if (w->step) {
      tmp = w->data;
    } else {
      tmp = (void *)0;
    }
    w->data = (*(p->func))(p->shared, w->step, tmp);
    pthread_mutex_lock(& p->mutex);
    if (w->step == p->n_steps - 1) {
      w->step = (w->step + 1) % p->n_steps;
    } else
    if (w->data) {
      w->step = (w->step + 1) % p->n_steps;
    } else {
      w->step = p->n_steps;
    }
    if (w->step == 0) {
      tmp___0 = p->index;
      (p->index) ++;
      w->index = tmp___0;
    }
    pthread_cond_broadcast(& p->cv);
    pthread_mutex_unlock(& p->mutex);
  }
  pthread_exit((void *)0);
}
}
void kt_pipeline(int n_threads , void *(*func)(void * , int  , void * ) , void *shared_data ,
                 int n_steps ) 
{ 
  ktp_t aux ;
  pthread_t *tid ;
  int i ;
  void *tmp ;
  ktp_worker_t *w ;
  int64_t tmp___0 ;
  void *tmp___1 ;

  {
  if (n_threads < 1) {
    n_threads = 1;
  }
  aux.n_workers = n_threads;
  aux.n_steps = n_steps;
  aux.func = func;
  aux.shared = shared_data;
  aux.index = (int64_t )0;
  pthread_mutex_init(& aux.mutex, (pthread_mutexattr_t const   *)0);
  pthread_cond_init((pthread_cond_t * __restrict  )(& aux.cv), (pthread_condattr_t const   * __restrict  )0);
  tmp = calloc((size_t )n_threads, sizeof(ktp_worker_t ));
  aux.workers = (ktp_worker_t *)tmp;
  i = 0;
  while (i < n_threads) {
    w = aux.workers + i;
    w->step = 0;
    w->pl = & aux;
    w->data = (void *)0;
    tmp___0 = aux.index;
    (aux.index) ++;
    w->index = tmp___0;
    i ++;
  }
  tmp___1 = calloc((size_t )n_threads, sizeof(pthread_t ));
  tid = (pthread_t *)tmp___1;
  i = 0;
  while (i < n_threads) {
    pthread_create((pthread_t * __restrict  )(tid + i), (pthread_attr_t const   * __restrict  )0,
                   & ktp_worker, (void * __restrict  )(aux.workers + i));
    i ++;
  }
  i = 0;
  while (i < n_threads) {
    pthread_join(*(tid + i), (void **)0);
    i ++;
  }
  free((void *)tid);
  free((void *)aux.workers);
  pthread_mutex_destroy(& aux.mutex);
  pthread_cond_destroy(& aux.cv);
  return;
}
}
#pragma merger("0","/tmp/cil-krErVBeR.i","-g,-Wall,-O2,-Wc++-compat")
mm128_t *mg_lchain_dp(int max_dist_x , int max_dist_y , int bw , int max_skip , int max_iter ,
                      int min_cnt , int min_sc , float chn_pen_gap , float chn_pen_skip ,
                      int is_cdna , int n_seg , int64_t n , mm128_t *a , int *n_u_ ,
                      uint64_t **_u , void *km ) ;
mm128_t *mg_lchain_rmq(int max_dist , int max_dist_inner , int bw , int max_chn_skip ,
                       int cap_rmq_size , int min_cnt , int min_sc , float chn_pen_gap ,
                       float chn_pen_skip , int64_t n , mm128_t *a , int *n_u_ , uint64_t **_u ,
                       void *km ) ;
__inline static float mg_log2___0(float x ) 
{ 
  union __anonunion_z_307641061___0 z ;
  float log_2 ;

  {
  z.f = x;
  log_2 = (float )(((z.i >> 23) & 255U) - 128U);
  z.i &= (unsigned int )(~ (255 << 23));
  z.i += (uint32_t )(127 << 23);
  log_2 += (- 0.34484843f * z.f + 2.02466578f) * z.f - 0.67487759f;
  return (log_2);
}
}
static int64_t mg_chain_bk_end(int32_t max_drop , mm128_t const   *z , int32_t const   *f ,
                               int64_t const   *p , int32_t *t , int64_t k ) 
{ 
  int64_t i ;
  int64_t end_i ;
  int64_t max_i ;
  int32_t max_s ;
  int32_t s ;

  {
  i = (int64_t )(z + k)->y;
  end_i = (int64_t )-1;
  max_i = i;
  max_s = 0;
  if (i < 0L) {
    return (i);
  } else
  if (*(t + i) != 0) {
    return (i);
  }
  while (1) {
    *(t + i) = 2;
    i = (int64_t )*(p + i);
    end_i = i;
    if (i < 0L) {
      s = (int32_t )(z + k)->x;
    } else {
      s = (int32_t )(z + k)->x - (int32_t )*(f + i);
    }
    if (s > max_s) {
      max_s = s;
      max_i = i;
    } else
    if (max_s - s > max_drop) {
      break;
    }
    if (i >= 0L) {
      if (! (*(t + i) == 0)) {
        break;
      }
    } else {
      break;
    }
  }
  i = (int64_t )(z + k)->y;
  while (1) {
    if (i >= 0L) {
      if (! (i != end_i)) {
        break;
      }
    } else {
      break;
    }
    *(t + i) = 0;
    i = (int64_t )*(p + i);
  }
  return (max_i);
}
}
uint64_t *mg_chain_backtrack(void *km , int64_t n , int32_t const   *f , int64_t const   *p ,
                             int32_t *v , int32_t *t , int32_t min_cnt , int32_t min_sc ,
                             int32_t max_drop , int32_t *n_u_ , int32_t *n_v_ ) 
{ 
  mm128_t *z ;
  uint64_t *u ;
  int64_t i ;
  int64_t k ;
  int64_t n_z ;
  int64_t n_v ;
  int32_t n_u ;
  int32_t tmp ;
  void *tmp___0 ;
  int64_t tmp___1 ;
  int64_t n_v0 ;
  int64_t end_i ;
  int32_t sc ;
  void *tmp___2 ;
  int64_t n_v0___0 ;
  int64_t end_i___0 ;
  int32_t sc___0 ;
  int64_t tmp___3 ;
  int32_t tmp___4 ;

  {
  tmp = 0;
  *n_v_ = tmp;
  *n_u_ = tmp;
  i = (int64_t )0;
  n_z = (int64_t )0;
  while (i < n) {
    if (*(f + i) >= (int32_t const   )min_sc) {
      n_z ++;
    }
    i ++;
  }
  if (n_z == 0L) {
    return ((uint64_t *)0);
  }
  tmp___0 = kmalloc(km, (unsigned long )n_z * sizeof(*z));
  z = (mm128_t *)tmp___0;
  i = (int64_t )0;
  k = (int64_t )0;
  while (i < n) {
    if (*(f + i) >= (int32_t const   )min_sc) {
      (z + k)->x = (uint64_t )*(f + i);
      tmp___1 = k;
      k ++;
      (z + tmp___1)->y = (uint64_t )i;
    }
    i ++;
  }
  radix_sort_128x(z, z + n_z);
  memset((void *)t, 0, (size_t )(n * 4L));
  k = n_z - 1L;
  n_u = 0;
  n_v = (int64_t )n_u;
  while (k >= 0L) {
    if (*(t + (z + k)->y) == 0) {
      n_v0 = n_v;
      end_i = mg_chain_bk_end(max_drop, (mm128_t const   *)z, f, p, t, k);
      i = (int64_t )(z + k)->y;
      while (i != end_i) {
        n_v ++;
        *(t + i) = 1;
        i = (int64_t )*(p + i);
      }
      if (i < 0L) {
        sc = (int32_t )(z + k)->x;
      } else {
        sc = (int32_t )(z + k)->x - (int32_t )*(f + i);
      }
      if (sc >= min_sc) {
        if (n_v > n_v0) {
          if (n_v - n_v0 >= (int64_t )min_cnt) {
            n_u ++;
          } else {
            n_v = n_v0;
          }
        } else {
          n_v = n_v0;
        }
      } else {
        n_v = n_v0;
      }
    }
    k --;
  }
  tmp___2 = kmalloc(km, (unsigned long )n_u * sizeof(*u));
  u = (uint64_t *)tmp___2;
  memset((void *)t, 0, (size_t )(n * 4L));
  k = n_z - 1L;
  n_u = 0;
  n_v = (int64_t )n_u;
  while (k >= 0L) {
    if (*(t + (z + k)->y) == 0) {
      n_v0___0 = n_v;
      end_i___0 = mg_chain_bk_end(max_drop, (mm128_t const   *)z, f, p, t, k);
      i = (int64_t )(z + k)->y;
      while (i != end_i___0) {
        tmp___3 = n_v;
        n_v ++;
        *(v + tmp___3) = (int32_t )i;
        *(t + i) = 1;
        i = (int64_t )*(p + i);
      }
      if (i < 0L) {
        sc___0 = (int32_t )(z + k)->x;
      } else {
        sc___0 = (int32_t )(z + k)->x - (int32_t )*(f + i);
      }
      if (sc___0 >= min_sc) {
        if (n_v > n_v0___0) {
          if (n_v - n_v0___0 >= (int64_t )min_cnt) {
            tmp___4 = n_u;
            n_u ++;
            *(u + tmp___4) = ((uint64_t )sc___0 << 32) | (unsigned long )(n_v - n_v0___0);
          } else {
            n_v = n_v0___0;
          }
        } else {
          n_v = n_v0___0;
        }
      } else {
        n_v = n_v0___0;
      }
    }
    k --;
  }
  kfree(km, (void *)z);
  if (! (n_v < 2147483647L)) {
    __assert_fail("n_v < INT32_MAX", "lchain.c", 73U, "mg_chain_backtrack");
  }
  *n_u_ = n_u;
  *n_v_ = (int32_t )n_v;
  return (u);
}
}
static mm128_t *compact_a(void *km , int32_t n_u , uint64_t *u , int32_t n_v , int32_t *v ,
                          mm128_t *a ) 
{ 
  mm128_t *b ;
  mm128_t *w ;
  uint64_t *u2 ;
  int64_t i ;
  int64_t j ;
  int64_t k ;
  void *tmp ;
  int32_t k0 ;
  int32_t ni ;
  int64_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int32_t j___0 ;
  int32_t n ;

  {
  tmp = kmalloc(km, (unsigned long )n_v * sizeof(*b));
  b = (mm128_t *)tmp;
  i = (int64_t )0;
  k = (int64_t )0;
  while (i < (int64_t )n_u) {
    k0 = (int32_t )k;
    ni = (int32_t )*(u + i);
    j = (int64_t )0;
    while (j < (int64_t )ni) {
      tmp___0 = k;
      k ++;
      *(b + tmp___0) = *(a + *(v + ((int64_t )k0 + (((int64_t )ni - j) - 1L))));
      j ++;
    }
    i ++;
  }
  kfree(km, (void *)v);
  tmp___1 = kmalloc(km, (unsigned long )n_u * sizeof(*w));
  w = (mm128_t *)tmp___1;
  k = (int64_t )0;
  i = k;
  while (i < (int64_t )n_u) {
    (w + i)->x = (b + k)->x;
    (w + i)->y = ((uint64_t )k << 32) | (unsigned long )i;
    k += (int64_t )((int32_t )*(u + i));
    i ++;
  }
  radix_sort_128x(w, w + n_u);
  tmp___2 = kmalloc(km, (unsigned long )n_u * sizeof(*u2));
  u2 = (uint64_t *)tmp___2;
  k = (int64_t )0;
  i = k;
  while (i < (int64_t )n_u) {
    j___0 = (int32_t )(w + i)->y;
    n = (int32_t )*(u + j___0);
    *(u2 + i) = *(u + j___0);
    memcpy((void * __restrict  )(a + k), (void const   * __restrict  )(b + ((w + i)->y >> 32)),
           (unsigned long )n * sizeof(mm128_t ));
    k += (int64_t )n;
    i ++;
  }
  memcpy((void * __restrict  )u, (void const   * __restrict  )u2, (size_t )(n_u * 8));
  memcpy((void * __restrict  )b, (void const   * __restrict  )a, (unsigned long )k * sizeof(mm128_t ));
  kfree(km, (void *)a);
  kfree(km, (void *)w);
  kfree(km, (void *)u2);
  return (b);
}
}
__inline static int32_t comput_sc(mm128_t const   *ai , mm128_t const   *aj , int32_t max_dist_x ,
                                  int32_t max_dist_y , int32_t bw , float chn_pen_gap ,
                                  float chn_pen_skip , int is_cdna , int n_seg ) 
{ 
  int32_t dq ;
  int32_t dr ;
  int32_t dd ;
  int32_t dg ;
  int32_t q_span ;
  int32_t sc ;
  int32_t sidi ;
  int32_t sidj ;
  float lin_pen ;
  float log_pen ;
  float tmp ;
  float tmp___0 ;

  {
  dq = (int32_t )ai->y - (int32_t )aj->y;
  sidi = (int32_t )(((unsigned long long )ai->y & (255ULL << 48)) >> 48);
  sidj = (int32_t )(((unsigned long long )aj->y & (255ULL << 48)) >> 48);
  if (dq <= 0) {
    return ((-0x7FFFFFFF-1));
  } else
  if (dq > max_dist_x) {
    return ((-0x7FFFFFFF-1));
  }
  dr = (int32_t )(ai->x - aj->x);
  if (sidi == sidj) {
    if (dr == 0) {
      return ((-0x7FFFFFFF-1));
    } else
    if (dq > max_dist_y) {
      return ((-0x7FFFFFFF-1));
    }
  }
  if (dr > dq) {
    dd = dr - dq;
  } else {
    dd = dq - dr;
  }
  if (sidi == sidj) {
    if (dd > bw) {
      return ((-0x7FFFFFFF-1));
    }
  }
  if (n_seg > 1) {
    if (! is_cdna) {
      if (sidi == sidj) {
        if (dr > max_dist_y) {
          return ((-0x7FFFFFFF-1));
        }
      }
    }
  }
  if (dr < dq) {
    dg = dr;
  } else {
    dg = dq;
  }
  q_span = (int32_t )((aj->y >> 32) & 255UL);
  if (q_span < dg) {
    sc = q_span;
  } else {
    sc = dg;
  }
  if (dd) {
    goto _L___2;
  } else
  if (dg > q_span) {
    _L___2: /* CIL Label */ 
    lin_pen = chn_pen_gap * (float )dd + chn_pen_skip * (float )dg;
    if (dd >= 1) {
      tmp = mg_log2___0((float )(dd + 1));
      log_pen = tmp;
    } else {
      log_pen = 0.0f;
    }
    if (is_cdna) {
      goto _L___1;
    } else
    if (sidi != sidj) {
      _L___1: /* CIL Label */ 
      if (sidi != sidj) {
        if (dr == 0) {
          sc ++;
        } else {
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
      if (dr > dq) {
        goto _L;
      } else
      if (sidi != sidj) {
        _L: /* CIL Label */ 
        if (lin_pen < log_pen) {
          tmp___0 = lin_pen;
        } else {
          tmp___0 = log_pen;
        }
        sc -= (int )tmp___0;
      } else {
        sc -= (int )(lin_pen + .5f * log_pen);
      }
    } else {
      sc -= (int )(lin_pen + .5f * log_pen);
    }
  }
  return (sc);
}
}
mm128_t *mg_lchain_dp(int max_dist_x , int max_dist_y , int bw , int max_skip , int max_iter ,
                      int min_cnt , int min_sc , float chn_pen_gap , float chn_pen_skip ,
                      int is_cdna , int n_seg , int64_t n , mm128_t *a , int *n_u_ ,
                      uint64_t **_u , void *km ) 
{ 
  int32_t *f ;
  int32_t *t ;
  int32_t *v ;
  int32_t n_u ;
  int32_t n_v ;
  int32_t mmax_f ;
  int32_t max_drop ;
  int64_t *p ;
  int64_t i ;
  int64_t j ;
  int64_t max_ii ;
  int64_t st ;
  int64_t n_iter ;
  uint64_t *u ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int64_t max_j ;
  int64_t end_j ;
  int32_t max_f ;
  int32_t n_skip ;
  int32_t sc ;
  int32_t max ;
  int32_t tmp___3 ;
  mm128_t *tmp___4 ;

  {
  mmax_f = 0;
  max_drop = bw;
  st = (int64_t )0;
  n_iter = (int64_t )0;
  if (_u) {
    *_u = (uint64_t *)0;
    *n_u_ = 0;
  }
  if (n == 0L) {
    kfree(km, (void *)a);
    return ((mm128_t *)0);
  } else
  if ((unsigned long )a == (unsigned long )((mm128_t *)0)) {
    kfree(km, (void *)a);
    return ((mm128_t *)0);
  }
  if (max_dist_x < bw) {
    max_dist_x = bw;
  }
  if (max_dist_y < bw) {
    if (! is_cdna) {
      max_dist_y = bw;
    }
  }
  if (is_cdna) {
    max_drop = 2147483647;
  }
  tmp = kmalloc(km, (unsigned long )n * sizeof(*p));
  p = (int64_t *)tmp;
  tmp___0 = kmalloc(km, (unsigned long )n * sizeof(*f));
  f = (int32_t *)tmp___0;
  tmp___1 = kmalloc(km, (unsigned long )n * sizeof(*v));
  v = (int32_t *)tmp___1;
  tmp___2 = kcalloc(km, (size_t )n, sizeof(*t));
  t = (int32_t *)tmp___2;
  i = (int64_t )0;
  max_ii = (int64_t )-1;
  while (i < n) {
    max_j = (int64_t )-1;
    max_f = (int32_t )(((a + i)->y >> 32) & 255UL);
    n_skip = 0;
    while (1) {
      if (st < i) {
        if (! ((a + i)->x >> 32 != (a + st)->x >> 32)) {
          if (! ((a + i)->x > (a + st)->x + (uint64_t )max_dist_x)) {
            break;
          }
        }
      } else {
        break;
      }
      st ++;
    }
    if (i - st > (int64_t )max_iter) {
      st = i - (int64_t )max_iter;
    }
    j = i - 1L;
    while (j >= st) {
      sc = comput_sc((mm128_t const   *)(a + i), (mm128_t const   *)(a + j), max_dist_x,
                     max_dist_y, bw, chn_pen_gap, chn_pen_skip, is_cdna, n_seg);
      n_iter ++;
      if (sc == (-0x7FFFFFFF-1)) {
        goto __Cont;
      }
      sc += *(f + j);
      if (sc > max_f) {
        max_f = sc;
        max_j = j;
        if (n_skip > 0) {
          n_skip --;
        }
      } else
      if (*(t + j) == (int32_t )i) {
        n_skip ++;
        if (n_skip > max_skip) {
          break;
        }
      }
      if (*(p + j) >= 0L) {
        *(t + *(p + j)) = (int32_t )i;
      }
      __Cont: /* CIL Label */ 
      j --;
    }
    end_j = j;
    if (max_ii < 0L) {
      goto _L;
    } else
    if ((a + i)->x - (a + max_ii)->x > (uint64_t )((int64_t )max_dist_x)) {
      _L: /* CIL Label */ 
      max = (-0x7FFFFFFF-1);
      max_ii = (int64_t )-1;
      j = i - 1L;
      while (j >= st) {
        if (max < *(f + j)) {
          max = *(f + j);
          max_ii = j;
        }
        j --;
      }
    }
    if (max_ii >= 0L) {
      if (max_ii < end_j) {
        tmp___3 = comput_sc((mm128_t const   *)(a + i), (mm128_t const   *)(a + max_ii),
                            max_dist_x, max_dist_y, bw, chn_pen_gap, chn_pen_skip,
                            is_cdna, n_seg);
        if (tmp___3 != (-0x7FFFFFFF-1)) {
          if (max_f < tmp___3 + *(f + max_ii)) {
            max_f = tmp___3 + *(f + max_ii);
            max_j = max_ii;
          }
        }
      }
    }
    *(f + i) = max_f;
    *(p + i) = max_j;
    if (max_j >= 0L) {
      if (*(v + max_j) > max_f) {
        *(v + i) = *(v + max_j);
      } else {
        *(v + i) = max_f;
      }
    } else {
      *(v + i) = max_f;
    }
    if (max_ii < 0L) {
      max_ii = i;
    } else
    if ((a + i)->x - (a + max_ii)->x <= (uint64_t )((int64_t )max_dist_x)) {
      if (*(f + max_ii) < *(f + i)) {
        max_ii = i;
      }
    }
    if (mmax_f < max_f) {
      mmax_f = max_f;
    }
    i ++;
  }
  u = mg_chain_backtrack(km, n, (int32_t const   *)f, (int64_t const   *)p, v, t,
                         min_cnt, min_sc, max_drop, & n_u, & n_v);
  *n_u_ = n_u;
  *_u = u;
  kfree(km, (void *)p);
  kfree(km, (void *)f);
  kfree(km, (void *)t);
  if (n_u == 0) {
    kfree(km, (void *)a);
    kfree(km, (void *)v);
    return ((mm128_t *)0);
  }
  tmp___4 = compact_a(km, n_u, u, n_v, v, a);
  return (tmp___4);
}
}
lc_elem_t *krmq_find_lc_elem(lc_elem_t const   *root , lc_elem_t const   *x , unsigned int *cnt_ ) 
{ 
  lc_elem_t const   *p ;
  unsigned int cnt ;
  int cmp ;
  int tmp ;
  unsigned int tmp___0 ;

  {
  p = root;
  cnt = 0U;
  while ((unsigned long )p != (unsigned long )((lc_elem_t const   *)0)) {
    if (x->y < p->y) {
      cmp = -1;
    } else {
      if (x->y > p->y) {
        tmp = 1;
      } else {
        tmp = (x->i > p->i) - (x->i < p->i);
      }
      cmp = tmp;
    }
    if (cmp >= 0) {
      if (p->head.p[0]) {
        tmp___0 = (p->head.p[0])->head.size;
      } else {
        tmp___0 = 0U;
      }
      cnt += tmp___0 + 1U;
    }
    if (cmp < 0) {
      p = (lc_elem_t const   *)p->head.p[0];
    } else
    if (cmp > 0) {
      p = (lc_elem_t const   *)p->head.p[1];
    } else {
      break;
    }
  }
  if (cnt_) {
    *cnt_ = cnt;
  }
  return ((lc_elem_t *)p);
}
}
lc_elem_t *krmq_interval_lc_elem(lc_elem_t const   *root , lc_elem_t const   *x ,
                                 lc_elem_t **lower , lc_elem_t **upper ) 
{ 
  lc_elem_t const   *p ;
  lc_elem_t const   *l ;
  lc_elem_t const   *u ;
  int cmp ;
  int tmp ;

  {
  p = root;
  l = (lc_elem_t const   *)0;
  u = (lc_elem_t const   *)0;
  while ((unsigned long )p != (unsigned long )((lc_elem_t const   *)0)) {
    if (x->y < p->y) {
      cmp = -1;
    } else {
      if (x->y > p->y) {
        tmp = 1;
      } else {
        tmp = (x->i > p->i) - (x->i < p->i);
      }
      cmp = tmp;
    }
    if (cmp < 0) {
      u = p;
      p = (lc_elem_t const   *)p->head.p[0];
    } else
    if (cmp > 0) {
      l = p;
      p = (lc_elem_t const   *)p->head.p[1];
    } else {
      u = p;
      l = u;
      break;
    }
  }
  if (lower) {
    *lower = (lc_elem_t *)l;
  }
  if (upper) {
    *upper = (lc_elem_t *)u;
  }
  return ((lc_elem_t *)p);
}
}
lc_elem_t *krmq_rmq_lc_elem(lc_elem_t const   *root , lc_elem_t const   *lo , lc_elem_t const   *up ) 
{ 
  lc_elem_t const   *p ;
  lc_elem_t const   *path[2][64] ;
  lc_elem_t const   *min ;
  int plen[2] ;
  int pcmp[2][64] ;
  int i ;
  int cmp ;
  int lca ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  p = root;
  plen[0] = 0;
  plen[1] = 0;
  if ((unsigned long )root == (unsigned long )((lc_elem_t const   *)0)) {
    return ((lc_elem_t *)0);
  }
  while (p) {
    if (lo->y < p->y) {
      cmp = -1;
    } else {
      if (lo->y > p->y) {
        tmp = 1;
      } else {
        tmp = (lo->i > p->i) - (lo->i < p->i);
      }
      cmp = tmp;
    }
    path[0][plen[0]] = p;
    tmp___0 = plen[0];
    (plen[0]) ++;
    pcmp[0][tmp___0] = cmp;
    if (cmp < 0) {
      p = (lc_elem_t const   *)p->head.p[0];
    } else
    if (cmp > 0) {
      p = (lc_elem_t const   *)p->head.p[1];
    } else {
      break;
    }
  }
  p = root;
  while (p) {
    if (up->y < p->y) {
      cmp = -1;
    } else {
      if (up->y > p->y) {
        tmp___1 = 1;
      } else {
        tmp___1 = (up->i > p->i) - (up->i < p->i);
      }
      cmp = tmp___1;
    }
    path[1][plen[1]] = p;
    tmp___2 = plen[1];
    (plen[1]) ++;
    pcmp[1][tmp___2] = cmp;
    if (cmp < 0) {
      p = (lc_elem_t const   *)p->head.p[0];
    } else
    if (cmp > 0) {
      p = (lc_elem_t const   *)p->head.p[1];
    } else {
      break;
    }
  }
  i = 0;
  while (1) {
    if (i < plen[0]) {
      if (! (i < plen[1])) {
        break;
      }
    } else {
      break;
    }
    if ((unsigned long )path[0][i] == (unsigned long )path[1][i]) {
      if (pcmp[0][i] <= 0) {
        if (pcmp[1][i] >= 0) {
          break;
        }
      }
    }
    i ++;
  }
  if (i == plen[0]) {
    return ((lc_elem_t *)0);
  } else
  if (i == plen[1]) {
    return ((lc_elem_t *)0);
  }
  lca = i;
  min = path[0][lca];
  i = lca + 1;
  while (i < plen[0]) {
    if (pcmp[0][i] <= 0) {
      if ((path[0][i])->pri < min->pri) {
        min = path[0][i];
      }
      if ((path[0][i])->head.p[1]) {
        if ((((path[0][i])->head.p[1])->head.s)->pri < (double )min->pri) {
          min = (lc_elem_t const   *)((path[0][i])->head.p[1])->head.s;
        }
      }
    }
    i ++;
  }
  i = lca + 1;
  while (i < plen[1]) {
    if (pcmp[1][i] >= 0) {
      if ((path[1][i])->pri < min->pri) {
        min = path[1][i];
      }
      if ((path[1][i])->head.p[0]) {
        if ((((path[1][i])->head.p[0])->head.s)->pri < (double )min->pri) {
          min = (lc_elem_t const   *)((path[1][i])->head.p[0])->head.s;
        }
      }
    }
    i ++;
  }
  return ((lc_elem_t *)min);
}
}
__inline static void krmq_update_min_lc_elem(lc_elem_t *p , lc_elem_t const   *q ,
                                             lc_elem_t const   *r ) 
{ 


  {
  if (! q) {
    p->head.s = p;
  } else
  if (p->pri < (q->head.s)->pri) {
    p->head.s = p;
  } else {
    p->head.s = (struct lc_elem_s *)q->head.s;
  }
  if (! r) {
    p->head.s = p->head.s;
  } else
  if ((p->head.s)->pri < (r->head.s)->pri) {
    p->head.s = p->head.s;
  } else {
    p->head.s = (struct lc_elem_s *)r->head.s;
  }
  return;
}
}
__inline static lc_elem_t *krmq_rotate1_lc_elem(lc_elem_t *p , int dir ) 
{ 
  int opp ;
  lc_elem_t *q ;
  lc_elem_t *s ;
  unsigned int size_p ;
  unsigned int tmp ;

  {
  opp = 1 - dir;
  q = p->head.p[opp];
  s = p->head.s;
  size_p = p->head.size;
  if (q->head.p[dir]) {
    tmp = (q->head.p[dir])->head.size;
  } else {
    tmp = 0U;
  }
  p->head.size -= q->head.size - tmp;
  q->head.size = size_p;
  krmq_update_min_lc_elem(p, (lc_elem_t const   *)p->head.p[dir], (lc_elem_t const   *)q->head.p[dir]);
  q->head.s = s;
  p->head.p[opp] = q->head.p[dir];
  q->head.p[dir] = p;
  return (q);
}
}
__inline static lc_elem_t *krmq_rotate2_lc_elem(lc_elem_t *p , int dir ) 
{ 
  int b1 ;
  int opp ;
  lc_elem_t *q ;
  lc_elem_t *r ;
  lc_elem_t *s ;
  unsigned int size_x_dir ;
  unsigned int tmp ;
  signed char tmp___0 ;

  {
  opp = 1 - dir;
  q = p->head.p[opp];
  r = q->head.p[dir];
  s = p->head.s;
  if (r->head.p[dir]) {
    tmp = (r->head.p[dir])->head.size;
  } else {
    tmp = 0U;
  }
  size_x_dir = tmp;
  r->head.size = p->head.size;
  p->head.size -= q->head.size - size_x_dir;
  q->head.size -= size_x_dir + 1U;
  krmq_update_min_lc_elem(p, (lc_elem_t const   *)p->head.p[dir], (lc_elem_t const   *)r->head.p[dir]);
  krmq_update_min_lc_elem(q, (lc_elem_t const   *)q->head.p[opp], (lc_elem_t const   *)r->head.p[opp]);
  r->head.s = s;
  p->head.p[opp] = r->head.p[dir];
  r->head.p[dir] = p;
  q->head.p[dir] = r->head.p[opp];
  r->head.p[opp] = q;
  if (dir == 0) {
    b1 = 1;
  } else {
    b1 = -1;
  }
  if ((int )r->head.balance == b1) {
    q->head.balance = (signed char)0;
    p->head.balance = (signed char )(- b1);
  } else
  if ((int )r->head.balance == 0) {
    tmp___0 = (signed char)0;
    p->head.balance = tmp___0;
    q->head.balance = tmp___0;
  } else {
    q->head.balance = (signed char )b1;
    p->head.balance = (signed char)0;
  }
  r->head.balance = (signed char)0;
  return (r);
}
}
lc_elem_t *krmq_insert_lc_elem(lc_elem_t **root_ , lc_elem_t *x , unsigned int *cnt_ ) 
{ 
  unsigned char stack[64] ;
  lc_elem_t *path[64] ;
  lc_elem_t *bp ;
  lc_elem_t *bq ;
  lc_elem_t *p ;
  lc_elem_t *q ;
  lc_elem_t *r ;
  int i ;
  int which ;
  int top ;
  int b1 ;
  int path_len ;
  unsigned int cnt ;
  int cmp ;
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct lc_elem_s *tmp___3 ;
  signed char tmp___4 ;

  {
  r = (lc_elem_t *)0;
  which = 0;
  cnt = 0U;
  bp = *root_;
  bq = (lc_elem_t *)0;
  p = bp;
  q = bq;
  path_len = 0;
  top = path_len;
  while (p) {
    if (x->y < p->y) {
      cmp = -1;
    } else {
      if (x->y > p->y) {
        tmp = 1;
      } else {
        tmp = (x->i > p->i) - (x->i < p->i);
      }
      cmp = tmp;
    }
    if (cmp >= 0) {
      if (p->head.p[0]) {
        tmp___0 = (p->head.p[0])->head.size;
      } else {
        tmp___0 = 0U;
      }
      cnt += tmp___0 + 1U;
    }
    if (cmp == 0) {
      if (cnt_) {
        *cnt_ = cnt;
      }
      return (p);
    }
    if ((int )p->head.balance != 0) {
      bq = q;
      bp = p;
      top = 0;
    }
    tmp___1 = top;
    top ++;
    which = cmp > 0;
    stack[tmp___1] = (unsigned char )which;
    tmp___2 = path_len;
    path_len ++;
    path[tmp___2] = p;
    q = p;
    p = p->head.p[which];
  }
  if (cnt_) {
    *cnt_ = cnt;
  }
  x->head.balance = (signed char)0;
  x->head.size = 1U;
  tmp___3 = (struct lc_elem_s *)0;
  x->head.p[1] = tmp___3;
  x->head.p[0] = tmp___3;
  x->head.s = x;
  if ((unsigned long )q == (unsigned long )((lc_elem_t *)0)) {
    *root_ = x;
  } else {
    q->head.p[which] = x;
  }
  if ((unsigned long )bp == (unsigned long )((lc_elem_t *)0)) {
    return (x);
  }
  i = 0;
  while (i < path_len) {
    ((path[i])->head.size) ++;
    i ++;
  }
  i = path_len - 1;
  while (i >= 0) {
    krmq_update_min_lc_elem(path[i], (lc_elem_t const   *)(path[i])->head.p[0], (lc_elem_t const   *)(path[i])->head.p[1]);
    if ((unsigned long )(path[i])->head.s != (unsigned long )x) {
      break;
    }
    i --;
  }
  p = bp;
  top = 0;
  while ((unsigned long )p != (unsigned long )x) {
    if ((int )stack[top] == 0) {
      p->head.balance = (signed char )((int )p->head.balance - 1);
    } else {
      p->head.balance = (signed char )((int )p->head.balance + 1);
    }
    p = p->head.p[stack[top]];
    top ++;
  }
  if ((int )bp->head.balance > -2) {
    if ((int )bp->head.balance < 2) {
      return (x);
    }
  }
  which = (int )bp->head.balance < 0;
  if (which == 0) {
    b1 = 1;
  } else {
    b1 = -1;
  }
  q = bp->head.p[1 - which];
  if ((int )q->head.balance == b1) {
    r = krmq_rotate1_lc_elem(bp, which);
    tmp___4 = (signed char)0;
    bp->head.balance = tmp___4;
    q->head.balance = tmp___4;
  } else {
    r = krmq_rotate2_lc_elem(bp, which);
  }
  if ((unsigned long )bq == (unsigned long )((lc_elem_t *)0)) {
    *root_ = r;
  } else {
    bq->head.p[(unsigned long )bp != (unsigned long )bq->head.p[0]] = r;
  }
  return (x);
}
}
lc_elem_t *krmq_erase_lc_elem(lc_elem_t **root_ , lc_elem_t const   *x , unsigned int *cnt_ ) 
{ 
  lc_elem_t *p ;
  lc_elem_t *path[64] ;
  lc_elem_t fake ;
  unsigned char dir[64] ;
  int i ;
  int d ;
  int cmp ;
  unsigned int cnt ;
  int tmp ;
  int which ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  lc_elem_t *q ;
  int tmp___4 ;
  lc_elem_t *r ;
  int e ;
  int tmp___5 ;
  int tmp___6 ;
  lc_elem_t *q___0 ;
  int which___0 ;
  int other ;
  int b1 ;
  int b2 ;
  lc_elem_t *r___0 ;
  signed char tmp___7 ;

  {
  d = 0;
  cnt = 0U;
  fake = *(*root_);
  fake.head.p[0] = *root_;
  fake.head.p[1] = (struct lc_elem_s *)0;
  if (cnt_) {
    *cnt_ = 0U;
  }
  if (x) {
    cmp = -1;
    p = & fake;
    while (cmp) {
      which = cmp > 0;
      if (cmp > 0) {
        if (p->head.p[0]) {
          tmp___0 = (p->head.p[0])->head.size;
        } else {
          tmp___0 = 0U;
        }
        cnt += tmp___0 + 1U;
      }
      dir[d] = (unsigned char )which;
      tmp___1 = d;
      d ++;
      path[tmp___1] = p;
      p = p->head.p[which];
      if ((unsigned long )p == (unsigned long )((lc_elem_t *)0)) {
        if (cnt_) {
          *cnt_ = 0U;
        }
        return ((lc_elem_t *)0);
      }
      if (x->y < (int32_t const   )p->y) {
        cmp = -1;
      } else {
        if (x->y > (int32_t const   )p->y) {
          tmp = 1;
        } else {
          tmp = (x->i > (int64_t const   )p->i) - (x->i < (int64_t const   )p->i);
        }
        cmp = tmp;
      }
    }
    if (p->head.p[0]) {
      tmp___2 = (p->head.p[0])->head.size;
    } else {
      tmp___2 = 0U;
    }
    cnt += tmp___2 + 1U;
  } else {
    p = & fake;
    cnt = 1U;
    while (p) {
      dir[d] = (unsigned char)0;
      tmp___3 = d;
      d ++;
      path[tmp___3] = p;
      p = p->head.p[0];
    }
    d --;
    p = path[d];
  }
  if (cnt_) {
    *cnt_ = cnt;
  }
  i = 1;
  while (i < d) {
    ((path[i])->head.size) --;
    i ++;
  }
  if ((unsigned long )p->head.p[1] == (unsigned long )((struct lc_elem_s *)0)) {
    (path[d - 1])->head.p[dir[d - 1]] = p->head.p[0];
  } else {
    q = p->head.p[1];
    if ((unsigned long )q->head.p[0] == (unsigned long )((struct lc_elem_s *)0)) {
      q->head.p[0] = p->head.p[0];
      q->head.balance = p->head.balance;
      (path[d - 1])->head.p[dir[d - 1]] = q;
      path[d] = q;
      tmp___4 = d;
      d ++;
      dir[tmp___4] = (unsigned char)1;
      q->head.size = p->head.size - 1U;
    } else {
      tmp___5 = d;
      d ++;
      e = tmp___5;
      while (1) {
        dir[d] = (unsigned char)0;
        tmp___6 = d;
        d ++;
        path[tmp___6] = q;
        r = q->head.p[0];
        if ((unsigned long )r->head.p[0] == (unsigned long )((struct lc_elem_s *)0)) {
          break;
        }
        q = r;
      }
      r->head.p[0] = p->head.p[0];
      q->head.p[0] = r->head.p[1];
      r->head.p[1] = p->head.p[1];
      r->head.balance = p->head.balance;
      (path[e - 1])->head.p[dir[e - 1]] = r;
      path[e] = r;
      dir[e] = (unsigned char)1;
      i = e + 1;
      while (i < d) {
        ((path[i])->head.size) --;
        i ++;
      }
      r->head.size = p->head.size - 1U;
    }
  }
  i = d - 1;
  while (i >= 0) {
    krmq_update_min_lc_elem(path[i], (lc_elem_t const   *)(path[i])->head.p[0], (lc_elem_t const   *)(path[i])->head.p[1]);
    i --;
  }
  while (1) {
    d --;
    if (! (d > 0)) {
      break;
    }
    q___0 = path[d];
    b1 = 1;
    b2 = 2;
    which___0 = (int )dir[d];
    other = 1 - which___0;
    if (which___0) {
      b1 = - b1;
      b2 = - b2;
    }
    q___0->head.balance = (signed char )((int )q___0->head.balance + b1);
    if ((int )q___0->head.balance == b1) {
      break;
    } else
    if ((int )q___0->head.balance == b2) {
      r___0 = q___0->head.p[other];
      if ((int )r___0->head.balance == - b1) {
        (path[d - 1])->head.p[dir[d - 1]] = krmq_rotate2_lc_elem(q___0, which___0);
      } else {
        (path[d - 1])->head.p[dir[d - 1]] = krmq_rotate1_lc_elem(q___0, which___0);
        if ((int )r___0->head.balance == 0) {
          r___0->head.balance = (signed char )(- b1);
          q___0->head.balance = (signed char )b1;
          break;
        } else {
          tmp___7 = (signed char)0;
          q___0->head.balance = tmp___7;
          r___0->head.balance = tmp___7;
        }
      }
    }
  }
  *root_ = fake.head.p[0];
  return (p);
}
}
void krmq_itr_first_lc_elem(lc_elem_t const   *root , struct krmq_itr_lc_elem *itr ) 
{ 
  lc_elem_t const   *p ;

  {
  itr->top = itr->stack - 1;
  p = root;
  while (p) {
    (itr->top) ++;
    *(itr->top) = p;
    p = (lc_elem_t const   *)p->head.p[0];
  }
  return;
}
}
int krmq_itr_find_lc_elem(lc_elem_t const   *root , lc_elem_t const   *x , struct krmq_itr_lc_elem *itr ) 
{ 
  lc_elem_t const   *p ;
  int cmp ;
  int tmp ;
  int tmp___0 ;

  {
  p = root;
  itr->top = itr->stack - 1;
  while ((unsigned long )p != (unsigned long )((lc_elem_t const   *)0)) {
    (itr->top) ++;
    *(itr->top) = p;
    if (x->y < p->y) {
      cmp = -1;
    } else {
      if (x->y > p->y) {
        tmp = 1;
      } else {
        tmp = (x->i > p->i) - (x->i < p->i);
      }
      cmp = tmp;
    }
    if (cmp < 0) {
      p = (lc_elem_t const   *)p->head.p[0];
    } else
    if (cmp > 0) {
      p = (lc_elem_t const   *)p->head.p[1];
    } else {
      break;
    }
  }
  if (p) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
int krmq_itr_next_bidir_lc_elem(struct krmq_itr_lc_elem *itr , int dir ) 
{ 
  lc_elem_t const   *p ;
  lc_elem_t const   **tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )itr->top < (unsigned long )(itr->stack)) {
    return (0);
  }
  dir = ! (! dir);
  p = (lc_elem_t const   *)(*(itr->top))->head.p[dir];
  if (p) {
    while (p) {
      (itr->top) ++;
      *(itr->top) = p;
      p = (lc_elem_t const   *)p->head.p[! dir];
    }
    return (1);
  } else {
    while (1) {
      tmp = itr->top;
      (itr->top) --;
      p = *tmp;
      if ((unsigned long )itr->top >= (unsigned long )(itr->stack)) {
        if (! ((unsigned long )p == (unsigned long )(*(itr->top))->head.p[dir])) {
          break;
        }
      } else {
        break;
      }
    }
    if ((unsigned long )itr->top < (unsigned long )(itr->stack)) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    return (tmp___0);
  }
}
}
__inline static kmp_rmq_t *kmp_init_rmq(void *km )  __attribute__((__unused__)) ;
__inline static kmp_rmq_t *kmp_init_rmq(void *km ) 
{ 
  kmp_rmq_t *mp ;
  void *tmp ;

  {
  tmp = kcalloc(km, (size_t )1, sizeof(*mp));
  mp = (kmp_rmq_t *)tmp;
  mp->km = km;
  return (mp);
}
}
__inline static lc_elem_t *kmp_alloc_rmq(kmp_rmq_t *mp )  __attribute__((__unused__)) ;
__inline static lc_elem_t *kmp_alloc_rmq(kmp_rmq_t *mp ) 
{ 
  void *tmp ;

  {
  (mp->cnt) ++;
  if (mp->n == 0UL) {
    tmp = kcalloc(mp->km, (size_t )1, sizeof(lc_elem_t ));
    return ((lc_elem_t *)tmp);
  }
  (mp->n) --;
  return (*(mp->buf + mp->n));
}
}
__inline static void kmp_free_rmq(kmp_rmq_t *mp , lc_elem_t *p )  __attribute__((__unused__)) ;
__inline static void kmp_free_rmq(kmp_rmq_t *mp , lc_elem_t *p ) 
{ 
  void *tmp ;
  size_t tmp___0 ;

  {
  (mp->cnt) --;
  if (mp->n == mp->max) {
    while (1) {
      if (mp->max >= 4UL) {
        mp->max += mp->max >> 1;
      } else {
        mp->max = (size_t )16;
      }
      tmp = krealloc(mp->km, (void *)mp->buf, mp->max * sizeof(*(mp->buf)));
      mp->buf = (lc_elem_t **)tmp;
      break;
    }
  }
  tmp___0 = mp->n;
  (mp->n) ++;
  *(mp->buf + tmp___0) = p;
  return;
}
}
__inline static int32_t comput_sc_simple(mm128_t const   *ai , mm128_t const   *aj ,
                                         float chn_pen_gap , float chn_pen_skip ,
                                         int32_t *exact , int32_t *width ) 
{ 
  int32_t dq ;
  int32_t dr ;
  int32_t dd ;
  int32_t dg ;
  int32_t q_span ;
  int32_t sc ;
  int tmp ;
  float lin_pen ;
  float log_pen ;
  float tmp___0 ;

  {
  dq = (int32_t )ai->y - (int32_t )aj->y;
  dr = (int32_t )(ai->x - aj->x);
  if (dr > dq) {
    dd = dr - dq;
  } else {
    dd = dq - dr;
  }
  *width = dd;
  if (dr < dq) {
    dg = dr;
  } else {
    dg = dq;
  }
  q_span = (int32_t )((aj->y >> 32) & 255UL);
  if (q_span < dg) {
    sc = q_span;
  } else {
    sc = dg;
  }
  if (exact) {
    if (dd == 0) {
      if (dg <= q_span) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
    *exact = tmp;
  }
  if (dd) {
    goto _L;
  } else
  if (dq > q_span) {
    _L: /* CIL Label */ 
    lin_pen = chn_pen_gap * (float )dd + chn_pen_skip * (float )dg;
    if (dd >= 1) {
      tmp___0 = mg_log2___0((float )(dd + 1));
      log_pen = tmp___0;
    } else {
      log_pen = 0.0f;
    }
    sc -= (int )(lin_pen + .5f * log_pen);
  }
  return (sc);
}
}
mm128_t *mg_lchain_rmq(int max_dist , int max_dist_inner , int bw , int max_chn_skip ,
                       int cap_rmq_size , int min_cnt , int min_sc , float chn_pen_gap ,
                       float chn_pen_skip , int64_t n , mm128_t *a , int *n_u_ , uint64_t **_u ,
                       void *km ) 
{ 
  int32_t *f ;
  int32_t *t ;
  int32_t *v ;
  int32_t n_u ;
  int32_t n_v ;
  int32_t mmax_f ;
  int32_t max_rmq_size ;
  int32_t max_drop ;
  int64_t *p ;
  int64_t i ;
  int64_t i0 ;
  int64_t st ;
  int64_t st_inner ;
  int64_t n_iter ;
  uint64_t *u ;
  lc_elem_t *root ;
  lc_elem_t *root_inner ;
  void *mem_mp ;
  kmp_rmq_t *mp ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int64_t max_j ;
  int32_t q_span ;
  int32_t max_f ;
  lc_elem_t s ;
  lc_elem_t *q ;
  lc_elem_t *r ;
  lc_elem_t lo ;
  lc_elem_t hi ;
  int64_t j ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  int32_t sc ;
  int32_t exact ;
  int32_t width ;
  int32_t n_skip ;
  int64_t j___0 ;
  int32_t tmp___6 ;
  lc_elem_t *lo___0 ;
  lc_elem_t *hi___0 ;
  lc_elem_t const   *q___0 ;
  int32_t width___0 ;
  int32_t n_rmq_iter ;
  struct krmq_itr_lc_elem itr ;
  int32_t tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___10 ;
  mm128_t *tmp___11 ;

  {
  mmax_f = 0;
  max_rmq_size = 0;
  max_drop = bw;
  st = (int64_t )0;
  st_inner = (int64_t )0;
  n_iter = (int64_t )0;
  root = (lc_elem_t *)0;
  root_inner = (lc_elem_t *)0;
  mem_mp = (void *)0;
  if (_u) {
    *_u = (uint64_t *)0;
    *n_u_ = 0;
  }
  if (n == 0L) {
    kfree(km, (void *)a);
    return ((mm128_t *)0);
  } else
  if ((unsigned long )a == (unsigned long )((mm128_t *)0)) {
    kfree(km, (void *)a);
    return ((mm128_t *)0);
  }
  if (max_dist < bw) {
    max_dist = bw;
  }
  if (max_dist_inner <= 0) {
    max_dist_inner = 0;
  } else
  if (max_dist_inner >= max_dist) {
    max_dist_inner = 0;
  }
  tmp = kmalloc(km, (unsigned long )n * sizeof(*p));
  p = (int64_t *)tmp;
  tmp___0 = kmalloc(km, (unsigned long )n * sizeof(*f));
  f = (int32_t *)tmp___0;
  tmp___1 = kcalloc(km, (size_t )n, sizeof(*t));
  t = (int32_t *)tmp___1;
  tmp___2 = kmalloc(km, (unsigned long )n * sizeof(*v));
  v = (int32_t *)tmp___2;
  mem_mp = km_init2(km, (size_t )65536);
  mp = kmp_init_rmq(mem_mp);
  i0 = (int64_t )0;
  i = i0;
  while (i < n) {
    max_j = (int64_t )-1;
    q_span = (int32_t )(((a + i)->y >> 32) & 255UL);
    max_f = q_span;
    if (i0 < i) {
      if ((a + i0)->x != (a + i)->x) {
        j = i0;
        while (j < i) {
          q = kmp_alloc_rmq(mp);
          q->y = (int32_t )(a + j)->y;
          q->i = j;
          q->pri = - ((double )*(f + j) + (0.5 * (double )chn_pen_gap) * (double )((int32_t )(a + j)->x + (int32_t )(a + j)->y));
          krmq_insert_lc_elem(& root, q, (unsigned int *)0);
          if (max_dist_inner > 0) {
            r = kmp_alloc_rmq(mp);
            *r = *q;
            krmq_insert_lc_elem(& root_inner, r, (unsigned int *)0);
          }
          j ++;
        }
        i0 = i;
      }
    }
    while (1) {
      if (st < i) {
        if (! ((a + i)->x >> 32 != (a + st)->x >> 32)) {
          if (! ((a + i)->x > (a + st)->x + (uint64_t )max_dist)) {
            if (root) {
              tmp___3 = root->head.size;
            } else {
              tmp___3 = 0U;
            }
            if (! (tmp___3 > (unsigned int )cap_rmq_size)) {
              break;
            }
          }
        }
      } else {
        break;
      }
      s.y = (int32_t )(a + st)->y;
      s.i = st;
      q = krmq_find_lc_elem((lc_elem_t const   *)root, (lc_elem_t const   *)(& s),
                            (unsigned int *)0);
      if ((unsigned long )q != (unsigned long )((lc_elem_t *)0)) {
        q = krmq_erase_lc_elem(& root, (lc_elem_t const   *)q, (unsigned int *)0);
        kmp_free_rmq(mp, q);
      }
      st ++;
    }
    if (max_dist_inner > 0) {
      while (1) {
        if (st_inner < i) {
          if (! ((a + i)->x >> 32 != (a + st_inner)->x >> 32)) {
            if (! ((a + i)->x > (a + st_inner)->x + (uint64_t )max_dist_inner)) {
              if (root_inner) {
                tmp___4 = root_inner->head.size;
              } else {
                tmp___4 = 0U;
              }
              if (! (tmp___4 > (unsigned int )cap_rmq_size)) {
                break;
              }
            }
          }
        } else {
          break;
        }
        s.y = (int32_t )(a + st_inner)->y;
        s.i = st_inner;
        q = krmq_find_lc_elem((lc_elem_t const   *)root_inner, (lc_elem_t const   *)(& s),
                              (unsigned int *)0);
        if ((unsigned long )q != (unsigned long )((lc_elem_t *)0)) {
          q = krmq_erase_lc_elem(& root_inner, (lc_elem_t const   *)q, (unsigned int *)0);
          kmp_free_rmq(mp, q);
        }
        st_inner ++;
      }
    }
    lo.i = (int64_t )2147483647;
    lo.y = (int32_t )(a + i)->y - max_dist;
    hi.i = (int64_t )0;
    hi.y = (int32_t )(a + i)->y;
    q = krmq_rmq_lc_elem((lc_elem_t const   *)root, (lc_elem_t const   *)(& lo), (lc_elem_t const   *)(& hi));
    if ((unsigned long )q != (unsigned long )((lc_elem_t *)0)) {
      n_skip = 0;
      j___0 = q->i;
      if (q->y >= lo.y) {
        if (! (q->y <= hi.y)) {
          __assert_fail("q->y >= lo.y && q->y <= hi.y", "lchain.c", 319U, "mg_lchain_rmq");
        }
      } else {
        __assert_fail("q->y >= lo.y && q->y <= hi.y", "lchain.c", 319U, "mg_lchain_rmq");
      }
      tmp___6 = comput_sc_simple((mm128_t const   *)(a + i), (mm128_t const   *)(a + j___0),
                                 chn_pen_gap, chn_pen_skip, & exact, & width);
      sc = *(f + j___0) + tmp___6;
      if (width <= bw) {
        if (sc > max_f) {
          max_f = sc;
          max_j = j___0;
        }
      }
      if (! exact) {
        if (root_inner) {
          if ((int32_t )(a + i)->y > 0) {
            s.y = (int32_t )(a + i)->y - 1;
            s.i = n;
            krmq_interval_lc_elem((lc_elem_t const   *)root_inner, (lc_elem_t const   *)(& s),
                                  & lo___0, & hi___0);
            if (lo___0) {
              n_rmq_iter = 0;
              krmq_itr_find_lc_elem((lc_elem_t const   *)root_inner, (lc_elem_t const   *)lo___0,
                                    & itr);
              while (1) {
                if ((unsigned long )itr.top < (unsigned long )(itr.stack)) {
                  q___0 = (lc_elem_t const   *)0;
                } else {
                  q___0 = *(itr.top);
                }
                if (! ((unsigned long )q___0 != (unsigned long )((lc_elem_t const   *)0))) {
                  break;
                }
                if (q___0->y < (int32_t const   )((int32_t )(a + i)->y - max_dist_inner)) {
                  break;
                }
                n_rmq_iter ++;
                j___0 = (int64_t )q___0->i;
                tmp___7 = comput_sc_simple((mm128_t const   *)(a + i), (mm128_t const   *)(a + j___0),
                                           chn_pen_gap, chn_pen_skip, (int32_t *)0,
                                           & width___0);
                sc = *(f + j___0) + tmp___7;
                if (width___0 <= bw) {
                  if (sc > max_f) {
                    max_f = sc;
                    max_j = j___0;
                    if (n_skip > 0) {
                      n_skip --;
                    }
                  } else
                  if (*(t + j___0) == (int32_t )i) {
                    n_skip ++;
                    if (n_skip > max_chn_skip) {
                      break;
                    }
                  }
                  if (*(p + j___0) >= 0L) {
                    *(t + *(p + j___0)) = (int32_t )i;
                  }
                }
                tmp___8 = krmq_itr_next_bidir_lc_elem(& itr, 0);
                if (! tmp___8) {
                  break;
                }
              }
              n_iter += (int64_t )n_rmq_iter;
            }
          }
        }
      }
    }
    if (! (max_j < 0L)) {
      if ((a + max_j)->x < (a + i)->x) {
        if (! ((int32_t )(a + max_j)->y < (int32_t )(a + i)->y)) {
          __assert_fail("max_j < 0 || (a[max_j].x < a[i].x && (int32_t)a[max_j].y < (int32_t)a[i].y)",
                        "lchain.c", 353U, "mg_lchain_rmq");
        }
      } else {
        __assert_fail("max_j < 0 || (a[max_j].x < a[i].x && (int32_t)a[max_j].y < (int32_t)a[i].y)",
                      "lchain.c", 353U, "mg_lchain_rmq");
      }
    }
    *(f + i) = max_f;
    *(p + i) = max_j;
    if (max_j >= 0L) {
      if (*(v + max_j) > max_f) {
        *(v + i) = *(v + max_j);
      } else {
        *(v + i) = max_f;
      }
    } else {
      *(v + i) = max_f;
    }
    if (mmax_f < max_f) {
      mmax_f = max_f;
    }
    if (root) {
      tmp___10 = root->head.size;
    } else {
      tmp___10 = 0U;
    }
    if ((unsigned int )max_rmq_size < tmp___10) {
      if (root) {
        max_rmq_size = (int32_t )root->head.size;
      } else {
        max_rmq_size = 0;
      }
    }
    i ++;
  }
  km_destroy(mem_mp);
  u = mg_chain_backtrack(km, n, (int32_t const   *)f, (int64_t const   *)p, v, t,
                         min_cnt, min_sc, max_drop, & n_u, & n_v);
  *n_u_ = n_u;
  *_u = u;
  kfree(km, (void *)p);
  kfree(km, (void *)f);
  kfree(km, (void *)t);
  if (n_u == 0) {
    kfree(km, (void *)a);
    kfree(km, (void *)v);
    return ((mm128_t *)0);
  }
  tmp___11 = compact_a(km, n_u, u, n_v, v, a);
  return (tmp___11);
}
}
#pragma merger("0","/tmp/cil-LNAlxmKY.i","-g,-Wall,-O2,-Wc++-compat")
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream ) ;
extern int puts(char const   *__s ) ;
extern void perror(char const   *__s ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
int mm_set_opt(char const   *preset , mm_idxopt_t *io , mm_mapopt_t *mo ) ;
int mm_check_opt(mm_idxopt_t const   *io , mm_mapopt_t const   *mo ) ;
void mm_mapopt_update(mm_mapopt_t *opt , mm_idx_t const   *mi ) ;
void mm_mapopt_max_intron_len(mm_mapopt_t *opt , int max_intron_len ) ;
int mm_map_file(mm_idx_t const   *idx , char const   *fn , mm_mapopt_t const   *opt ,
                int n_threads ) ;
int mm_map_file_frag(mm_idx_t const   *idx , int n_segs , char const   **fn , mm_mapopt_t const   *opt ,
                     int n_threads ) ;
long peakrss(void) ;
int mm_split_merge(int n_segs , char const   **fn , mm_mapopt_t const   *opt , int n_split_idx ) ;
static ketopt_t KETOPT_INIT  =    {1, 0, (char *)0, -1, 1, 0, 0};
static void ketopt_permute(char **argv , int j , int n ) 
{ 
  int k ;
  char *p ;

  {
  p = *(argv + j);
  k = 0;
  while (k < n) {
    *(argv + (j - k)) = *(argv + ((j - k) - 1));
    k ++;
  }
  *(argv + (j - k)) = p;
  return;
}
}
static int ketopt(ketopt_t *s , int argc , char **argv , int permute , char const   *ostr ,
                  ko_longopt_t const   *longopts ) 
{ 
  int opt ;
  int i0 ;
  int j ;
  int k ;
  int n_exact ;
  int n_partial ;
  ko_longopt_t const   *o ;
  ko_longopt_t const   *o_exact ;
  ko_longopt_t const   *o_partial ;
  int tmp ;
  ko_longopt_t const   *tmp___0 ;
  char *p ;
  int tmp___1 ;
  int tmp___2 ;

  {
  opt = -1;
  if (permute) {
    while (1) {
      if (s->i < argc) {
        if (! ((int )*(*(argv + s->i) + 0) != 45)) {
          if (! ((int )*(*(argv + s->i) + 1) == 0)) {
            break;
          }
        }
      } else {
        break;
      }
      (s->i) ++;
      (s->n_args) ++;
    }
  }
  s->arg = (char *)0;
  s->longidx = -1;
  i0 = s->i;
  if (s->i >= argc) {
    s->ind = s->i - s->n_args;
    return (-1);
  } else
  if ((int )*(*(argv + s->i) + 0) != 45) {
    s->ind = s->i - s->n_args;
    return (-1);
  } else
  if ((int )*(*(argv + s->i) + 1) == 0) {
    s->ind = s->i - s->n_args;
    return (-1);
  }
  if ((int )*(*(argv + s->i) + 0) == 45) {
    if ((int )*(*(argv + s->i) + 1) == 45) {
      if ((int )*(*(argv + s->i) + 2) == 0) {
        ketopt_permute(argv, s->i, s->n_args);
        (s->i) ++;
        s->ind = s->i - s->n_args;
        return (-1);
      }
      s->opt = 0;
      opt = '?';
      s->pos = -1;
      if (longopts) {
        n_exact = 0;
        n_partial = 0;
        o = (ko_longopt_t const   *)0;
        o_exact = (ko_longopt_t const   *)0;
        o_partial = (ko_longopt_t const   *)0;
        j = 2;
        while (1) {
          if ((int )*(*(argv + s->i) + j) != 0) {
            if (! ((int )*(*(argv + s->i) + j) != 61)) {
              break;
            }
          } else {
            break;
          }
          j ++;
        }
        k = 0;
        while ((unsigned long )(longopts + k)->name != (unsigned long )((char * const  )0)) {
          tmp = strncmp((char const   *)(*(argv + s->i) + 2), (char const   *)(longopts + k)->name,
                        (size_t )(j - 2));
          if (tmp == 0) {
            if ((int )*((longopts + k)->name + (j - 2)) == 0) {
              n_exact ++;
              o_exact = longopts + k;
            } else {
              n_partial ++;
              o_partial = longopts + k;
            }
          }
          k ++;
        }
        if (n_exact > 1) {
          return ('?');
        } else
        if (n_exact == 0) {
          if (n_partial > 1) {
            return ('?');
          }
        }
        if (n_exact == 1) {
          o = o_exact;
        } else {
          if (n_partial == 1) {
            tmp___0 = o_partial;
          } else {
            tmp___0 = (ko_longopt_t const   *)0;
          }
          o = tmp___0;
        }
        if (o) {
          opt = (int )o->val;
          s->opt = opt;
          s->longidx = (int )(o - longopts);
          if ((int )*(*(argv + s->i) + j) == 61) {
            s->arg = *(argv + s->i) + (j + 1);
          }
          if (o->has_arg == 1) {
            if ((int )*(*(argv + s->i) + j) == 0) {
              if (s->i < argc - 1) {
                (s->i) ++;
                s->arg = *(argv + s->i);
              } else {
                opt = ':';
              }
            }
          }
        }
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (s->pos == 0) {
      s->pos = 1;
    }
    tmp___2 = s->pos;
    (s->pos) ++;
    tmp___1 = (int )*(*(argv + s->i) + tmp___2);
    s->opt = tmp___1;
    opt = tmp___1;
    p = strchr((char const   *)((char *)ostr), opt);
    if ((unsigned long )p == (unsigned long )((char *)0)) {
      opt = '?';
    } else
    if ((int )*(p + 1) == 58) {
      if ((int )*(*(argv + s->i) + s->pos) == 0) {
        if (s->i < argc - 1) {
          (s->i) ++;
          s->arg = *(argv + s->i);
        } else {
          opt = ':';
        }
      } else {
        s->arg = *(argv + s->i) + s->pos;
      }
      s->pos = -1;
    }
  }
  if (s->pos < 0) {
    goto _L___0;
  } else
  if ((int )*(*(argv + s->i) + s->pos) == 0) {
    _L___0: /* CIL Label */ 
    (s->i) ++;
    s->pos = 0;
    if (s->n_args > 0) {
      j = i0;
      while (j < s->i) {
        ketopt_permute(argv, j, s->n_args);
        j ++;
      }
    }
  }
  s->ind = s->i - s->n_args;
  return (opt);
}
}
extern  __attribute__((__nothrow__)) int getrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit *__rlimits ) ;
extern  __attribute__((__nothrow__)) int setrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit  const  *__rlimits ) ;
void liftrlimit(void) 
{ 
  struct rlimit r ;

  {
  getrlimit(9, & r);
  r.rlim_cur = r.rlim_max;
  setrlimit(9, (struct rlimit  const  *)(& r));
  return;
}
}
static ko_longopt_t long_options[63]  = 
  {      {(char *)"bucket-bits", 1, 300}, 
        {(char *)"mb-size", 1, 'K'}, 
        {(char *)"seed", 1, 302}, 
        {(char *)"no-kalloc", 0, 303}, 
        {(char *)"print-qname", 0, 304}, 
        {(char *)"no-self", 0, 'D'}, 
        {(char *)"print-seeds", 0, 306}, 
        {(char *)"max-chain-skip", 1, 307}, 
        {(char *)"min-dp-len", 1, 308}, 
        {(char *)"print-aln-seq", 0, 309}, 
        {(char *)"splice", 0, 310}, 
        {(char *)"cost-non-gt-ag", 1, 'C'}, 
        {(char *)"no-long-join", 0, 312}, 
        {(char *)"sr", 0, 313}, 
        {(char *)"frag", 1, 314}, 
        {(char *)"secondary", 1, 315}, 
        {(char *)"cs", 2, 316}, 
        {(char *)"end-bonus", 1, 317}, 
        {(char *)"no-pairing", 0, 318}, 
        {(char *)"splice-flank", 1, 319}, 
        {(char *)"idx-no-seq", 0, 320}, 
        {(char *)"end-seed-pen", 1, 321}, 
        {(char *)"for-only", 0, 322}, 
        {(char *)"rev-only", 0, 323}, 
        {(char *)"heap-sort", 1, 324}, 
        {(char *)"all-chain", 0, 'P'}, 
        {(char *)"dual", 1, 326}, 
        {(char *)"max-clip-ratio", 1, 327}, 
        {(char *)"min-occ-floor", 1, 328}, 
        {(char *)"MD", 0, 329}, 
        {(char *)"lj-min-ratio", 1, 330}, 
        {(char *)"score-N", 1, 331}, 
        {(char *)"eqx", 0, 332}, 
        {(char *)"paf-no-hit", 0, 333}, 
        {(char *)"split-prefix", 1, 334}, 
        {(char *)"no-end-flt", 0, 335}, 
        {(char *)"hard-mask-level", 0, 336}, 
        {(char *)"cap-sw-mem", 1, 337}, 
        {(char *)"max-qlen", 1, 338}, 
        {(char *)"max-chain-iter", 1, 339}, 
        {(char *)"junc-bed", 1, 340}, 
        {(char *)"junc-bonus", 1, 341}, 
        {(char *)"sam-hit-only", 0, 342}, 
        {(char *)"chain-gap-scale", 1, 343}, 
        {(char *)"alt", 1, 344}, 
        {(char *)"alt-drop", 1, 345}, 
        {(char *)"mask-len", 1, 346}, 
        {(char *)"rmq", 2, 347}, 
        {(char *)"qstrand", 0, 348}, 
        {(char *)"cap-kalloc", 1, 349}, 
        {(char *)"q-occ-frac", 1, 350}, 
        {(char *)"chain-skip-scale", 1, 351}, 
        {(char *)"print-chains", 0, 352}, 
        {(char *)"no-hash-name", 0, 353}, 
        {(char *)"help", 0, 'h'}, 
        {(char *)"max-intron-len", 1, 'G'}, 
        {(char *)"version", 0, 'V'}, 
        {(char *)"min-count", 1, 'n'}, 
        {(char *)"min-chain-score", 1, 'm'}, 
        {(char *)"mask-level", 1, 'M'}, 
        {(char *)"min-dp-score", 1, 's'}, 
        {(char *)"sam", 0, 'a'}, 
        {(char *)0, 0, 0}};
__inline static int64_t mm_parse_num2(char const   *str , char **q ) 
{ 
  double x ;
  char *p ;

  {
  x = strtod((char const   * __restrict  )str, (char ** __restrict  )(& p));
  if ((int )*p == 71) {
    x *= 1e9;
    p ++;
  } else
  if ((int )*p == 103) {
    x *= 1e9;
    p ++;
  } else
  if ((int )*p == 77) {
    x *= 1e6;
    p ++;
  } else
  if ((int )*p == 109) {
    x *= 1e6;
    p ++;
  } else
  if ((int )*p == 75) {
    x *= 1e3;
    p ++;
  } else
  if ((int )*p == 107) {
    x *= 1e3;
    p ++;
  }
  if (q) {
    *q = p;
  }
  return ((int64_t )(x + .499));
}
}
__inline static int64_t mm_parse_num(char const   *str ) 
{ 
  int64_t tmp ;

  {
  tmp = mm_parse_num2(str, (char **)0);
  return (tmp);
}
}
__inline static void yes_or_no(mm_mapopt_t *opt , int64_t flag , int long_idx , char const   *arg ,
                               int yes_to_set ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  if (yes_to_set) {
    tmp___1 = strcmp(arg, "yes");
    if (tmp___1 == 0) {
      opt->flag |= flag;
    } else {
      tmp___2 = strcmp(arg, "y");
      if (tmp___2 == 0) {
        opt->flag |= flag;
      } else {
        tmp = strcmp(arg, "no");
        if (tmp == 0) {
          opt->flag &= ~ flag;
        } else {
          tmp___0 = strcmp(arg, "n");
          if (tmp___0 == 0) {
            opt->flag &= ~ flag;
          } else {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[WARNING]\033[1;31m option \'--%s\' only accepts \'yes\' or \'no\'.\033[0m\n",
                    long_options[long_idx].name);
          }
        }
      }
    }
  } else {
    tmp___5 = strcmp(arg, "yes");
    if (tmp___5 == 0) {
      opt->flag &= ~ flag;
    } else {
      tmp___6 = strcmp(arg, "y");
      if (tmp___6 == 0) {
        opt->flag &= ~ flag;
      } else {
        tmp___3 = strcmp(arg, "no");
        if (tmp___3 == 0) {
          opt->flag |= flag;
        } else {
          tmp___4 = strcmp(arg, "n");
          if (tmp___4 == 0) {
            opt->flag |= flag;
          } else {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[WARNING]\033[1;31m option \'--%s\' only accepts \'yes\' or \'no\'.\033[0m\n",
                    long_options[long_idx].name);
          }
        }
      }
    }
  }
  return;
}
}
int main(int argc , char **argv ) 
{ 
  char const   *opt_str ;
  ketopt_t o ;
  mm_mapopt_t opt ;
  mm_idxopt_t ipt ;
  int i ;
  int c ;
  int n_threads ;
  int n_parts ;
  int old_best_n ;
  char *fnw ;
  char *rg ;
  char *junc_bed ;
  char *s ;
  char *alt_list ;
  FILE *fp_help ;
  mm_idx_reader_t *idx_rdr ;
  mm_idx_t *mi ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int64_t tmp___2 ;
  int64_t tmp___3 ;
  int64_t tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  int64_t tmp___7 ;
  int64_t tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  FILE *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  double tmp___14 ;
  int64_t tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;
  double tmp___18 ;
  int64_t tmp___19 ;
  double tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int64_t tmp___24 ;
  int64_t tmp___25 ;
  long tmp___26 ;
  long tmp___27 ;
  double x ;
  char *p ;
  double tmp___28 ;
  long tmp___29 ;
  long tmp___30 ;
  long tmp___31 ;
  long tmp___32 ;
  long tmp___33 ;
  long tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int *tmp___37 ;
  char *tmp___38 ;
  int ret ;
  int tmp___39 ;
  double tmp___40 ;
  double tmp___41 ;
  double tmp___42 ;
  int tmp___43 ;
  long tmp___44 ;
  double tmp___45 ;
  double tmp___46 ;

  {
  opt_str = "2aSDw:k:K:t:r:f:Vv:g:G:I:d:XT:s:x:Hcp:M:n:z:A:B:O:E:m:N:Qu:R:hF:LC:yYPo:e:U:";
  o = KETOPT_INIT;
  n_threads = 3;
  old_best_n = -1;
  fnw = (char *)0;
  rg = (char *)0;
  junc_bed = (char *)0;
  alt_list = (char *)0;
  fp_help = stderr;
  mm_verbose = 3;
  liftrlimit();
  mm_realtime0 = realtime();
  mm_set_opt((char const   *)0, & ipt, & opt);
  while (1) {
    c = ketopt(& o, argc, argv, 1, opt_str, (ko_longopt_t const   *)(long_options));
    if (! (c >= 0)) {
      break;
    }
    if (c == 120) {
      tmp = mm_set_opt((char const   *)o.arg, & ipt, & opt);
      if (tmp < 0) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[ERROR] unknown preset \'%s\'\n",
                o.arg);
        return (1);
      }
    } else
    if (c == 58) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[ERROR] missing option argument\n");
      return (1);
    } else
    if (c == 63) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[ERROR] unknown option in \"%s\"\n",
              *(argv + (o.i - 1)));
      return (1);
    }
  }
  o = KETOPT_INIT;
  while (1) {
    c = ketopt(& o, argc, argv, 1, opt_str, (ko_longopt_t const   *)(long_options));
    if (! (c >= 0)) {
      break;
    }
    if (c == 119) {
      tmp___0 = atoi((char const   *)o.arg);
      ipt.w = (short )tmp___0;
    } else
    if (c == 107) {
      tmp___1 = atoi((char const   *)o.arg);
      ipt.k = (short )tmp___1;
    } else
    if (c == 72) {
      ipt.flag = (short )((int )ipt.flag | 1);
    } else
    if (c == 100) {
      fnw = o.arg;
    } else
    if (c == 116) {
      n_threads = atoi((char const   *)o.arg);
    } else
    if (c == 118) {
      mm_verbose = atoi((char const   *)o.arg);
    } else
    if (c == 103) {
      tmp___2 = mm_parse_num((char const   *)o.arg);
      opt.max_gap = (int )tmp___2;
    } else
    if (c == 71) {
      tmp___3 = mm_parse_num((char const   *)o.arg);
      mm_mapopt_max_intron_len(& opt, (int )tmp___3);
    } else
    if (c == 70) {
      tmp___4 = mm_parse_num((char const   *)o.arg);
      opt.max_frag_len = (int )tmp___4;
    } else
    if (c == 78) {
      old_best_n = opt.best_n;
      opt.best_n = atoi((char const   *)o.arg);
    } else
    if (c == 112) {
      tmp___5 = atof((char const   *)o.arg);
      opt.pri_ratio = (float )tmp___5;
    } else
    if (c == 77) {
      tmp___6 = atof((char const   *)o.arg);
      opt.mask_level = (float )tmp___6;
    } else
    if (c == 99) {
      opt.flag |= 36L;
    } else
    if (c == 68) {
      opt.flag |= 1L;
    } else
    if (c == 80) {
      opt.flag |= 8388608L;
    } else
    if (c == 88) {
      opt.flag |= 8389635L;
    } else
    if (c == 97) {
      opt.flag |= 12L;
    } else
    if (c == 81) {
      opt.flag |= 16L;
    } else
    if (c == 89) {
      opt.flag |= 524288L;
    } else
    if (c == 76) {
      opt.flag |= 65536L;
    } else
    if (c == 121) {
      opt.flag |= 33554432L;
    } else
    if (c == 84) {
      opt.sdust_thres = atoi((char const   *)o.arg);
    } else
    if (c == 110) {
      opt.min_cnt = atoi((char const   *)o.arg);
    } else
    if (c == 109) {
      opt.min_chain_score = atoi((char const   *)o.arg);
    } else
    if (c == 65) {
      opt.a = atoi((char const   *)o.arg);
    } else
    if (c == 66) {
      opt.b = atoi((char const   *)o.arg);
    } else
    if (c == 115) {
      opt.min_dp_max = atoi((char const   *)o.arg);
    } else
    if (c == 67) {
      opt.noncan = atoi((char const   *)o.arg);
    } else
    if (c == 73) {
      tmp___7 = mm_parse_num((char const   *)o.arg);
      ipt.batch_size = (uint64_t )tmp___7;
    } else
    if (c == 75) {
      opt.mini_batch_size = mm_parse_num((char const   *)o.arg);
    } else
    if (c == 101) {
      tmp___8 = mm_parse_num((char const   *)o.arg);
      opt.occ_dist = (int32_t )tmp___8;
    } else
    if (c == 82) {
      rg = o.arg;
    } else
    if (c == 104) {
      fp_help = stdout;
    } else
    if (c == 50) {
      opt.flag |= 32768L;
    } else
    if (c == 111) {
      tmp___12 = strcmp((char const   *)o.arg, "-");
      if (tmp___12 != 0) {
        tmp___11 = freopen((char const   * __restrict  )o.arg, (char const   * __restrict  )"wb",
                           (FILE * __restrict  )stdout);
        if ((unsigned long )tmp___11 == (unsigned long )((void *)0)) {
          tmp___9 = __errno_location();
          tmp___10 = strerror(*tmp___9);
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[ERROR]\033[1;31m failed to write the output to file \'%s\'\033[0m: %s\n",
                  o.arg, tmp___10);
          exit(1);
        }
      }
    } else
    if (c == 300) {
      tmp___13 = atoi((char const   *)o.arg);
      ipt.bucket_bits = (short )tmp___13;
    } else
    if (c == 302) {
      opt.seed = atoi((char const   *)o.arg);
    } else
    if (c == 303) {
      mm_dbg_flag |= 1;
    } else
    if (c == 304) {
      mm_dbg_flag |= 2;
    } else
    if (c == 306) {
      mm_dbg_flag |= 6;
      n_threads = 1;
    } else
    if (c == 307) {
      opt.max_chain_skip = atoi((char const   *)o.arg);
    } else
    if (c == 339) {
      opt.max_chain_iter = atoi((char const   *)o.arg);
    } else
    if (c == 308) {
      opt.min_ksw_len = atoi((char const   *)o.arg);
    } else
    if (c == 309) {
      mm_dbg_flag |= 10;
      n_threads = 1;
    } else
    if (c == 310) {
      opt.flag |= 128L;
    } else
    if (c == 312) {
      opt.flag |= 1024L;
    } else
    if (c == 313) {
      opt.flag |= 4096L;
    } else
    if (c == 317) {
      opt.end_bonus = atoi((char const   *)o.arg);
    } else
    if (c == 318) {
      opt.flag |= 131072L;
    } else
    if (c == 320) {
      ipt.flag = (short )((int )ipt.flag | 2);
    } else
    if (c == 321) {
      opt.anchor_ext_shift = atoi((char const   *)o.arg);
    } else
    if (c == 322) {
      opt.flag |= 1048576L;
    } else
    if (c == 323) {
      opt.flag |= 2097152L;
    } else
    if (c == 327) {
      tmp___14 = atof((char const   *)o.arg);
      opt.max_clip_ratio = (float )tmp___14;
    } else
    if (c == 328) {
      opt.min_mid_occ = atoi((char const   *)o.arg);
    } else
    if (c == 329) {
      opt.flag |= 16777216L;
    } else
    if (c == 331) {
      opt.sc_ambi = atoi((char const   *)o.arg);
    } else
    if (c == 332) {
      opt.flag |= 67108864L;
    } else
    if (c == 333) {
      opt.flag |= 134217728L;
    } else
    if (c == 334) {
      opt.split_prefix = (char const   *)o.arg;
    } else
    if (c == 335) {
      opt.flag |= 268435456L;
    } else
    if (c == 336) {
      opt.flag |= 536870912L;
    } else
    if (c == 337) {
      opt.max_sw_mat = mm_parse_num((char const   *)o.arg);
    } else
    if (c == 338) {
      tmp___15 = mm_parse_num((char const   *)o.arg);
      opt.max_qlen = (int )tmp___15;
    } else
    if (c == 340) {
      junc_bed = o.arg;
    } else
    if (c == 341) {
      opt.junc_bonus = atoi((char const   *)o.arg);
    } else
    if (c == 342) {
      opt.flag |= 1073741824L;
    } else
    if (c == 343) {
      tmp___16 = atof((char const   *)o.arg);
      opt.chain_gap_scale = (float )tmp___16;
    } else
    if (c == 351) {
      tmp___17 = atof((char const   *)o.arg);
      opt.chain_skip_scale = (float )tmp___17;
    } else
    if (c == 344) {
      alt_list = o.arg;
    } else
    if (c == 345) {
      tmp___18 = atof((char const   *)o.arg);
      opt.alt_drop = (float )tmp___18;
    } else
    if (c == 346) {
      tmp___19 = mm_parse_num((char const   *)o.arg);
      opt.mask_len = (int )tmp___19;
    } else
    if (c == 348) {
      opt.flag = (int64_t )((long long )opt.flag | 12884901888LL);
    } else
    if (c == 349) {
      opt.cap_kalloc = mm_parse_num((char const   *)o.arg);
    } else
    if (c == 350) {
      tmp___20 = atof((char const   *)o.arg);
      opt.q_occ_frac = (float )tmp___20;
    } else
    if (c == 352) {
      mm_dbg_flag |= 16;
    } else
    if (c == 353) {
      opt.flag = (int64_t )((long long )opt.flag | 17179869184LL);
    } else
    if (c == 330) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[WARNING] \033[1;31m --lj-min-ratio has been deprecated.\033[0m\n");
    } else
    if (c == 314) {
      yes_or_no(& opt, (int64_t )8192, o.longidx, (char const   *)o.arg, 1);
    } else
    if (c == 315) {
      yes_or_no(& opt, (int64_t )16384, o.longidx, (char const   *)o.arg, 0);
    } else
    if (c == 316) {
      opt.flag |= 68L;
      if ((unsigned long )o.arg == (unsigned long )((char *)0)) {
        opt.flag &= -2049L;
      } else {
        tmp___23 = strcmp((char const   *)o.arg, "short");
        if (tmp___23 == 0) {
          opt.flag &= -2049L;
        } else {
          tmp___22 = strcmp((char const   *)o.arg, "long");
          if (tmp___22 == 0) {
            opt.flag |= 2048L;
          } else {
            tmp___21 = strcmp((char const   *)o.arg, "none");
            if (tmp___21 == 0) {
              opt.flag &= -65L;
            } else
            if (mm_verbose >= 2) {
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[WARNING]\033[1;31m --cs only takes \'short\' or \'long\'. Invalid values are assumed to be \'short\'.\033[0m\n");
            }
          }
        }
      }
    } else
    if (c == 319) {
      yes_or_no(& opt, (int64_t )262144, o.longidx, (char const   *)o.arg, 1);
    } else
    if (c == 324) {
      yes_or_no(& opt, (int64_t )4194304, o.longidx, (char const   *)o.arg, 1);
    } else
    if (c == 326) {
      yes_or_no(& opt, (int64_t )2, o.longidx, (char const   *)o.arg, 0);
    } else
    if (c == 347) {
      yes_or_no(& opt, (int64_t )2147483648LL, o.longidx, (char const   *)o.arg, 1);
    } else
    if (c == 83) {
      opt.flag |= 2116L;
      if (mm_verbose >= 2) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[WARNING]\033[1;31m option -S is deprecated and may be removed in future. Please use --cs=long instead.\033[0m\n");
      }
    } else
    if (c == 86) {
      puts("2.24-r1122");
      return (0);
    } else
    if (c == 114) {
      tmp___24 = mm_parse_num2((char const   *)o.arg, & s);
      opt.bw = (int )tmp___24;
      if ((int )*s == 44) {
        tmp___25 = mm_parse_num2((char const   *)(s + 1), & s);
        opt.bw_long = (int )tmp___25;
      }
    } else
    if (c == 85) {
      tmp___26 = strtol((char const   * __restrict  )o.arg, (char ** __restrict  )(& s),
                        10);
      opt.min_mid_occ = (int32_t )tmp___26;
      if ((int )*s == 44) {
        tmp___27 = strtol((char const   * __restrict  )(s + 1), (char ** __restrict  )(& s),
                          10);
        opt.max_mid_occ = (int32_t )tmp___27;
      }
    } else
    if (c == 102) {
      x = strtod((char const   * __restrict  )o.arg, (char ** __restrict  )(& p));
      if (x < 1.0) {
        opt.mid_occ_frac = (float )x;
        opt.mid_occ = 0;
      } else {
        opt.mid_occ = (int )(x + .499);
      }
      if ((int )*p == 44) {
        tmp___28 = strtod((char const   * __restrict  )(p + 1), (char ** __restrict  )(& p));
        opt.max_occ = (int )(tmp___28 + .499);
      }
    } else
    if (c == 117) {
      if ((int )*(o.arg) == 98) {
        opt.flag |= 768L;
      } else
      if ((int )*(o.arg) == 102) {
        opt.flag |= 256L;
        opt.flag &= -513L;
      } else
      if ((int )*(o.arg) == 114) {
        opt.flag |= 512L;
        opt.flag &= -257L;
      } else
      if ((int )*(o.arg) == 110) {
        opt.flag &= -769L;
      } else {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[ERROR]\033[1;31m unrecognized cDNA direction\033[0m\n");
        return (1);
      }
    } else
    if (c == 122) {
      tmp___29 = strtol((char const   * __restrict  )o.arg, (char ** __restrict  )(& s),
                        10);
      opt.zdrop_inv = (int )tmp___29;
      opt.zdrop = opt.zdrop_inv;
      if ((int )*s == 44) {
        tmp___30 = strtol((char const   * __restrict  )(s + 1), (char ** __restrict  )(& s),
                          10);
        opt.zdrop_inv = (int )tmp___30;
      }
    } else
    if (c == 79) {
      tmp___31 = strtol((char const   * __restrict  )o.arg, (char ** __restrict  )(& s),
                        10);
      opt.q2 = (int )tmp___31;
      opt.q = opt.q2;
      if ((int )*s == 44) {
        tmp___32 = strtol((char const   * __restrict  )(s + 1), (char ** __restrict  )(& s),
                          10);
        opt.q2 = (int )tmp___32;
      }
    } else
    if (c == 69) {
      tmp___33 = strtol((char const   * __restrict  )o.arg, (char ** __restrict  )(& s),
                        10);
      opt.e2 = (int )tmp___33;
      opt.e = opt.e2;
      if ((int )*s == 44) {
        tmp___34 = strtol((char const   * __restrict  )(s + 1), (char ** __restrict  )(& s),
                          10);
        opt.e2 = (int )tmp___34;
      }
    }
  }
  if (opt.flag & 128L) {
    if (opt.flag & 8192L) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[ERROR]\033[1;31m --splice and --frag should not be specified at the same time.\033[0m\n");
      return (1);
    }
  }
  if (! fnw) {
    if (! (opt.flag & 4L)) {
      ipt.flag = (short )((int )ipt.flag | 2);
    }
  }
  tmp___35 = mm_check_opt((mm_idxopt_t const   *)(& ipt), (mm_mapopt_t const   *)(& opt));
  if (tmp___35 < 0) {
    return (1);
  }
  if (opt.best_n == 0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[WARNING]\033[1;31m changed \'-N 0\' to \'-N %d --secondary=no\'.\033[0m\n",
            old_best_n);
    opt.best_n = old_best_n;
    opt.flag |= 16384L;
  }
  if (argc == o.ind) {
    goto _L;
  } else
  if ((unsigned long )fp_help == (unsigned long )stdout) {
    _L: /* CIL Label */ 
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"Usage: minimap2 [options] <target.fa>|<target.idx> [query.fa] [...]\n");
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"Options:\n");
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"  Indexing:\n");
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    -H           use homopolymer-compressed k-mer (preferrable for PacBio)\n");
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    -k INT       k-mer size (no larger than 28) [%d]\n",
            (int )ipt.k);
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    -w INT       minimizer window size [%d]\n",
            (int )ipt.w);
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    -I NUM       split index for every ~NUM input bases [4G]\n");
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    -d FILE      dump index to FILE []\n");
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"  Mapping:\n");
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    -f FLOAT     filter out top FLOAT fraction of repetitive minimizers [%g]\n",
            (double )opt.mid_occ_frac);
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    -g NUM       stop chain enlongation if there are no minimizers in INT-bp [%d]\n",
            opt.max_gap);
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    -G NUM       max intron length (effective with -xsplice; changing -r) [200k]\n");
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    -F NUM       max fragment length (effective with -xsr or in the fragment mode) [800]\n");
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    -r NUM[,NUM] chaining/alignment bandwidth and long-join bandwidth [%d,%d]\n",
            opt.bw, opt.bw_long);
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    -n INT       minimal number of minimizers on a chain [%d]\n",
            opt.min_cnt);
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    -m INT       minimal chaining score (matching bases minus log gap penalty) [%d]\n",
            opt.min_chain_score);
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    -X           skip self and dual mappings (for the all-vs-all mode)\n");
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    -p FLOAT     min secondary-to-primary score ratio [%g]\n",
            (double )opt.pri_ratio);
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    -N INT       retain at most INT secondary alignments [%d]\n",
            opt.best_n);
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"  Alignment:\n");
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    -A INT       matching score [%d]\n",
            opt.a);
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    -B INT       mismatch penalty (larger value for lower divergence) [%d]\n",
            opt.b);
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    -O INT[,INT] gap open penalty [%d,%d]\n",
            opt.q, opt.q2);
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    -E INT[,INT] gap extension penalty; a k-long gap costs min{O1+k*E1,O2+k*E2} [%d,%d]\n",
            opt.e, opt.e2);
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    -z INT[,INT] Z-drop score and inversion Z-drop score [%d,%d]\n",
            opt.zdrop, opt.zdrop_inv);
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    -s INT       minimal peak DP alignment score [%d]\n",
            opt.min_dp_max);
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    -u CHAR      how to find GT-AG. f:transcript strand, b:both strands, n:don\'t match GT-AG [n]\n");
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"  Input/Output:\n");
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    -a           output in the SAM format (PAF by default)\n");
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    -o FILE      output alignments to FILE [stdout]\n");
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    -L           write CIGAR with >65535 ops at the CG tag\n");
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    -R STR       SAM read group line in a format like \'@RG\\tID:foo\\tSM:bar\' []\n");
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    -c           output CIGAR in PAF\n");
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    --cs[=STR]   output the cs tag; STR is \'short\' (if absent) or \'long\' [none]\n");
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    --MD         output the MD tag\n");
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    --eqx        write =/X CIGAR operators\n");
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    -Y           use soft clipping for supplementary alignments\n");
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    -t INT       number of threads [%d]\n",
            n_threads);
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    -K NUM       minibatch size for mapping [500M]\n");
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    --version    show version number\n");
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"  Preset:\n");
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"    -x STR       preset (always applied before other options; see minimap2.1 for details) []\n");
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"                 - map-pb/map-ont - PacBio CLR/Nanopore vs reference mapping\n");
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"                 - map-hifi - PacBio HiFi reads vs reference mapping\n");
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"                 - ava-pb/ava-ont - PacBio/Nanopore read overlap\n");
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"                 - asm5/asm10/asm20 - asm-to-ref mapping, for ~0.1/1/5%% sequence divergence\n");
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"                 - splice/splice:hq - long-read/Pacbio-CCS spliced alignment\n");
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"                 - sr - genomic short-read mapping\n");
    fprintf((FILE * __restrict  )fp_help, (char const   * __restrict  )"\nSee `man ./minimap2.1\' for detailed description of these and other advanced command-line options.\n");
    if ((unsigned long )fp_help == (unsigned long )stdout) {
      tmp___36 = 0;
    } else {
      tmp___36 = 1;
    }
    return (tmp___36);
  }
  if (opt.flag & 4096L) {
    if (argc - o.ind > 3) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[ERROR] incorrect input: in the sr mode, please specify no more than two query files.\n");
      return (1);
    }
  }
  idx_rdr = mm_idx_reader_open((char const   *)*(argv + o.ind), (mm_idxopt_t const   *)(& ipt),
                               (char const   *)fnw);
  if ((unsigned long )idx_rdr == (unsigned long )((mm_idx_reader_t *)0)) {
    tmp___37 = __errno_location();
    tmp___38 = strerror(*tmp___37);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[ERROR] failed to open file \'%s\': %s\n",
            *(argv + o.ind), tmp___38);
    return (1);
  }
  if (! idx_rdr->is_idx) {
    if ((unsigned long )fnw == (unsigned long )((char *)0)) {
      if (argc - o.ind < 2) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[ERROR] missing input: please specify a query file to map or option -d to keep the index\n");
        mm_idx_reader_close(idx_rdr);
        return (1);
      }
    }
  }
  if (opt.best_n == 0) {
    if (opt.flag & 4L) {
      if (mm_verbose >= 2) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[WARNING]\033[1;31m `-N 0\' reduces alignment accuracy. Please use --secondary=no to suppress secondary alignments.\033[0m\n");
      }
    }
  }
  while (1) {
    mi = mm_idx_reader_read(idx_rdr, n_threads);
    if (! ((unsigned long )mi != (unsigned long )((mm_idx_t *)0))) {
      break;
    }
    if (opt.flag & 4L) {
      if (mi->flag & 2) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[ERROR] the prebuilt index doesn\'t contain sequences.\n");
        mm_idx_destroy(mi);
        mm_idx_reader_close(idx_rdr);
        return (1);
      }
    }
    if (opt.flag & 8L) {
      if (idx_rdr->n_parts == 1) {
        tmp___39 = mm_idx_reader_eof((mm_idx_reader_t const   *)idx_rdr);
        if (tmp___39) {
          if ((unsigned long )opt.split_prefix == (unsigned long )((char const   *)0)) {
            ret = mm_write_sam_hdr((mm_idx_t const   *)mi, (char const   *)rg, "2.24-r1122",
                                   argc, argv);
          } else {
            ret = mm_write_sam_hdr((mm_idx_t const   *)0, (char const   *)rg, "2.24-r1122",
                                   argc, argv);
          }
        } else {
          ret = mm_write_sam_hdr((mm_idx_t const   *)0, (char const   *)rg, "2.24-r1122",
                                 argc, argv);
          if ((unsigned long )opt.split_prefix == (unsigned long )((char const   *)0)) {
            if (mm_verbose >= 2) {
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[WARNING]\033[1;31m For a multi-part index, no @SQ lines will be outputted. Please use --split-prefix.\033[0m\n");
            }
          }
        }
        if (ret != 0) {
          mm_idx_destroy(mi);
          mm_idx_reader_close(idx_rdr);
          return (1);
        }
      }
    }
    if (mm_verbose >= 3) {
      tmp___40 = cputime();
      tmp___41 = realtime();
      tmp___42 = realtime();
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[M::%s::%.3f*%.2f] loaded/built the index for %d target sequence(s)\n",
              "main", tmp___42 - mm_realtime0, tmp___40 / (tmp___41 - mm_realtime0),
              mi->n_seq);
    }
    if (argc != o.ind + 1) {
      mm_mapopt_update(& opt, (mm_idx_t const   *)mi);
    }
    if (mm_verbose >= 3) {
      mm_idx_stat((mm_idx_t const   *)mi);
    }
    if (junc_bed) {
      mm_idx_bed_read(mi, (char const   *)junc_bed, 1);
    }
    if (alt_list) {
      mm_idx_alt_read(mi, (char const   *)alt_list);
    }
    if (argc - (o.ind + 1) == 0) {
      mm_idx_destroy(mi);
      continue;
    }
    ret = 0;
    if (! (opt.flag & 8192L)) {
      i = o.ind + 1;
      while (i < argc) {
        ret = mm_map_file((mm_idx_t const   *)mi, (char const   *)*(argv + i), (mm_mapopt_t const   *)(& opt),
                          n_threads);
        if (ret < 0) {
          break;
        }
        i ++;
      }
    } else {
      ret = mm_map_file_frag((mm_idx_t const   *)mi, argc - (o.ind + 1), (char const   **)(argv + (o.ind + 1)),
                             (mm_mapopt_t const   *)(& opt), n_threads);
    }
    mm_idx_destroy(mi);
    if (ret < 0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: failed to map the query file\n");
      exit(1);
    }
  }
  n_parts = idx_rdr->n_parts;
  mm_idx_reader_close(idx_rdr);
  if (opt.split_prefix) {
    mm_split_merge(argc - (o.ind + 1), (char const   **)(argv + (o.ind + 1)), (mm_mapopt_t const   *)(& opt),
                   n_parts);
  }
  tmp___43 = fflush(stdout);
  if (tmp___43 == -1) {
    perror("[ERROR] failed to write the results");
    exit(1);
  }
  if (mm_verbose >= 3) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[M::%s] Version: %s\n",
            "main", "2.24-r1122");
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[M::%s] CMD:",
            "main");
    i = 0;
    while (i < argc) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" %s", *(argv + i));
      i ++;
    }
    tmp___44 = peakrss();
    tmp___45 = cputime();
    tmp___46 = realtime();
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n[M::%s] Real time: %.3f sec; CPU: %.3f sec; Peak RSS: %.3f GB\n",
            "main", tmp___46 - mm_realtime0, tmp___45, (((double )tmp___44 / 1024.0) / 1024.0) / 1024.0);
  }
  return (0);
}
}
#pragma merger("0","/tmp/cil-r3PhIPwP.i","-g,-Wall,-O2,-Wc++-compat")
sdust_buf_t *sdust_buf_init(void *km ) ;
void sdust_buf_destroy(sdust_buf_t *buf ) ;
uint64_t const   *sdust_core(uint8_t const   *seq , int l_seq , int T , int W , int *n ,
                             sdust_buf_t *buf ) ;
extern int printf(char const   * __restrict  __format  , ...) ;
mm_tbuf_t *mm_tbuf_init(void) ;
void mm_tbuf_destroy(mm_tbuf_t *b ) ;
void *mm_tbuf_get_km(mm_tbuf_t *b ) ;
mm_reg1_t *mm_map(mm_idx_t const   *mi , int qlen , char const   *seq , int *n_regs ,
                  mm_tbuf_t *b , mm_mapopt_t const   *opt , char const   *qname ) ;
void mm_map_frag(mm_idx_t const   *mi , int n_segs , int const   *qlens , char const   **seqs ,
                 int *n_regs , mm_reg1_t **regs , mm_tbuf_t *b , mm_mapopt_t const   *opt ,
                 char const   *qname ) ;
__inline static void mm_revcomp_bseq(mm_bseq1_t *s ) 
{ 
  int i ;
  int t ;
  int l ;

  {
  l = s->l_seq;
  i = 0;
  while (i < l >> 1) {
    t = (int )*(s->seq + ((l - i) - 1));
    *(s->seq + ((l - i) - 1)) = (char )seq_comp_table[(uint8_t )*(s->seq + i)];
    *(s->seq + i) = (char )seq_comp_table[t];
    i ++;
  }
  if (l & 1) {
    *(s->seq + (l >> 1)) = (char )seq_comp_table[(uint8_t )*(s->seq + (l >> 1))];
  }
  if (s->qual) {
    i = 0;
    while (i < l >> 1) {
      t = (int )*(s->qual + ((l - i) - 1));
      *(s->qual + ((l - i) - 1)) = *(s->qual + i);
      *(s->qual + i) = (char )t;
      i ++;
    }
  }
  return;
}
}
mm_seed_t *mm_collect_matches(void *km , int *_n_m , int qlen , int max_occ , int max_max_occ ,
                              int dist , mm_idx_t const   *mi , mm128_v const   *mv ,
                              int64_t *n_a , int *rep_len , int *n_mini_pos , uint64_t **mini_pos ) ;
void mm_seed_mz_flt(void *km , mm128_v *mv , int32_t q_occ_max , float q_occ_frac ) ;
void mm_select_sub_multi(void *km , float pri_ratio , float pri1 , float pri2 , int max_gap_ref ,
                         int min_diff , int best_n , int n_segs , int const   *qlens ,
                         int *n_ , mm_reg1_t *r ) ;
void mm_pair(void *km , int max_gap_ref , int pe_bonus , int sub_diff , int match_sc ,
             int const   *qlens , int *n_regs , mm_reg1_t **regs ) ;
FILE *mm_split_init(char const   *prefix , mm_idx_t const   *mi ) ;
mm_idx_t *mm_split_merge_prep(char const   *prefix , int n_splits , FILE **fp , uint32_t *n_seq_part ) ;
void mm_split_rm_tmp(char const   *prefix , int n_splits ) ;
void mm_err_fwrite(void const   *p , size_t size , size_t nitems , FILE *fp ) ;
void mm_err_fread(void *p , size_t size , size_t nitems , FILE *fp ) ;
__inline static khint_t __ac_Wang_hash(khint_t key ) 
{ 


  {
  key += ~ (key << 15);
  key ^= key >> 10;
  key += key << 3;
  key ^= key >> 6;
  key += ~ (key << 11);
  key ^= key >> 16;
  return (key);
}
}
mm_tbuf_t *mm_tbuf_init(void) 
{ 
  mm_tbuf_t *b ;
  void *tmp ;

  {
  tmp = calloc((size_t )1, sizeof(mm_tbuf_t ));
  b = (mm_tbuf_t *)tmp;
  if (! (mm_dbg_flag & 1)) {
    b->km = km_init();
  }
  return (b);
}
}
void mm_tbuf_destroy(mm_tbuf_t *b ) 
{ 


  {
  if ((unsigned long )b == (unsigned long )((mm_tbuf_t *)0)) {
    return;
  }
  km_destroy(b->km);
  free((void *)b);
  return;
}
}
void *mm_tbuf_get_km(mm_tbuf_t *b ) 
{ 


  {
  return (b->km);
}
}
static int mm_dust_minier(void *km , int n , mm128_t *a , int l_seq , char const   *seq ,
                          int sdust_thres ) 
{ 
  int n_dreg ;
  int j ;
  int k ;
  int u ;
  uint64_t const   *dreg ;
  sdust_buf_t *sdb ;
  int32_t qpos ;
  int32_t span ;
  int32_t s ;
  int32_t e ;
  int v ;
  int l ;
  int ss ;
  uint64_t tmp ;
  int ee ;
  uint32_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  u = 0;
  if (sdust_thres <= 0) {
    return (n);
  }
  sdb = sdust_buf_init(km);
  dreg = sdust_core((uint8_t const   *)seq, l_seq, sdust_thres, 64, & n_dreg, sdb);
  k = 0;
  j = k;
  while (j < n) {
    qpos = (int32_t )((uint32_t )(a + j)->y >> 1);
    span = (int32_t )((a + j)->x & 255UL);
    s = qpos - (span - 1);
    e = s + span;
    while (1) {
      if (u < n_dreg) {
        if (! ((int32_t )*(dreg + u) <= s)) {
          break;
        }
      } else {
        break;
      }
      u ++;
    }
    if (u < n_dreg) {
      if ((int32_t )(*(dreg + u) >> 32) < e) {
        l = 0;
        v = u;
        while (1) {
          if (v < n_dreg) {
            if (! ((int32_t )(*(dreg + v) >> 32) < e)) {
              break;
            }
          } else {
            break;
          }
          if (s > (int32_t )(*(dreg + v) >> 32)) {
            tmp = (uint64_t const   )s;
          } else {
            tmp = *(dreg + v) >> 32;
          }
          ss = (int )tmp;
          if (e < (int32_t )*(dreg + v)) {
            tmp___0 = (uint32_t )e;
          } else {
            tmp___0 = (uint32_t )*(dreg + v);
          }
          ee = (int )tmp___0;
          l += ee - ss;
          v ++;
        }
        if (l <= span >> 1) {
          tmp___1 = k;
          k ++;
          *(a + tmp___1) = *(a + j);
        }
      } else {
        tmp___2 = k;
        k ++;
        *(a + tmp___2) = *(a + j);
      }
    } else {
      tmp___2 = k;
      k ++;
      *(a + tmp___2) = *(a + j);
    }
    j ++;
  }
  sdust_buf_destroy(sdb);
  return (k);
}
}
static void collect_minimizers(void *km , mm_mapopt_t const   *opt , mm_idx_t const   *mi ,
                               int n_segs , int const   *qlens , char const   **seqs ,
                               mm128_v *mv ) 
{ 
  int i ;
  int n ;
  int sum ;
  size_t j ;
  int tmp ;

  {
  sum = 0;
  mv->n = (size_t )0;
  n = 0;
  i = n;
  while (i < n_segs) {
    mm_sketch(km, *(seqs + i), (int )*(qlens + i), (int )mi->w, (int )mi->k, (uint32_t )i,
              (int )(mi->flag & 1), mv);
    j = (size_t )n;
    while (j < mv->n) {
      (mv->a + j)->y += (uint64_t )(sum << 1);
      j ++;
    }
    if (opt->sdust_thres > 0) {
      tmp = mm_dust_minier(km, (int )(mv->n - (size_t )n), mv->a + n, (int )*(qlens + i),
                           *(seqs + i), (int )opt->sdust_thres);
      mv->n = (size_t )(n + tmp);
    }
    sum += (int )*(qlens + i);
    n = (int )mv->n;
    i ++;
  }
  return;
}
}
void ks_heapdown_heap(size_t i , size_t n , mm128_t *l ) 
{ 
  size_t k ;
  mm128_t tmp ;

  {
  k = i;
  tmp = *(l + i);
  while (1) {
    k = (k << 1) + 1UL;
    if (! (k < n)) {
      break;
    }
    if (k != n - 1UL) {
      if ((l + k)->x > (l + (k + 1UL))->x) {
        k ++;
      }
    }
    if ((l + k)->x > tmp.x) {
      break;
    }
    *(l + i) = *(l + k);
    i = k;
  }
  *(l + i) = tmp;
  return;
}
}
void ks_heapmake_heap(size_t lsize , mm128_t *l ) 
{ 
  size_t i ;

  {
  i = (lsize >> 1) - 1UL;
  while (i != 0xffffffffffffffffUL) {
    ks_heapdown_heap(i, lsize, l);
    i --;
  }
  return;
}
}
mm128_t ks_ksmall_heap(size_t n , mm128_t *arr , size_t kk ) 
{ 
  mm128_t *low ;
  mm128_t *high ;
  mm128_t *k ;
  mm128_t *ll ;
  mm128_t *hh ;
  mm128_t *mid ;
  mm128_t t ;
  mm128_t t___0 ;
  mm128_t t___1 ;
  mm128_t t___2 ;
  mm128_t t___3 ;
  mm128_t t___4 ;
  mm128_t t___5 ;

  {
  low = arr;
  high = (arr + n) - 1;
  k = arr + kk;
  while (1) {
    if ((unsigned long )high <= (unsigned long )low) {
      return (*k);
    }
    if ((unsigned long )high == (unsigned long )(low + 1)) {
      if (high->x > low->x) {
        t = *low;
        *low = *high;
        *high = t;
      }
      return (*k);
    }
    mid = low + (high - low) / 2L;
    if (high->x > mid->x) {
      t___0 = *mid;
      *mid = *high;
      *high = t___0;
    }
    if (high->x > low->x) {
      t___1 = *low;
      *low = *high;
      *high = t___1;
    }
    if (low->x > mid->x) {
      t___2 = *mid;
      *mid = *low;
      *low = t___2;
    }
    t___3 = *mid;
    *mid = *(low + 1);
    *(low + 1) = t___3;
    ll = low + 1;
    hh = high;
    while (1) {
      while (1) {
        ll ++;
        if (! (ll->x > low->x)) {
          break;
        }
      }
      while (1) {
        hh --;
        if (! (low->x > hh->x)) {
          break;
        }
      }
      if ((unsigned long )hh < (unsigned long )ll) {
        break;
      }
      t___4 = *ll;
      *ll = *hh;
      *hh = t___4;
    }
    t___5 = *low;
    *low = *hh;
    *hh = t___5;
    if ((unsigned long )hh <= (unsigned long )k) {
      low = ll;
    }
    if ((unsigned long )hh >= (unsigned long )k) {
      high = hh - 1;
    }
  }
}
}
__inline static int skip_seed(int flag , uint64_t r , mm_seed_t const   *q , char const   *qname ,
                              int qlen , mm_idx_t const   *mi , int *is_self ) 
{ 
  mm_idx_seq_t const   *s ;
  int cmp ;

  {
  *is_self = 0;
  if (qname) {
    if (flag & 3) {
      s = (mm_idx_seq_t const   *)(mi->seq + (r >> 32));
      cmp = strcmp(qname, (char const   *)s->name);
      if (flag & 1) {
        if (cmp == 0) {
          if ((int )s->len == qlen) {
            if ((uint32_t )r >> 1 == (uint32_t )(q->q_pos >> 1)) {
              return (1);
            }
            if ((r & 1UL) == (unsigned long )(q->q_pos & 1U)) {
              *is_self = 1;
            }
          }
        }
      }
      if (flag & 2) {
        if (cmp > 0) {
          return (1);
        }
      }
    }
  }
  if (flag & 3145728) {
    if ((r & 1UL) == (unsigned long )(q->q_pos & 1U)) {
      if (flag & 2097152) {
        return (1);
      }
    } else
    if (flag & 1048576) {
      return (1);
    }
  }
  return (0);
}
}
static mm128_t *collect_seed_hits_heap(void *km , mm_mapopt_t const   *opt , int max_occ ,
                                       mm_idx_t const   *mi , char const   *qname ,
                                       mm128_v const   *mv , int qlen , int64_t *n_a ,
                                       int *rep_len , int *n_mini_pos , uint64_t **mini_pos ) 
{ 
  int i ;
  int n_m ;
  int heap_size ;
  int64_t j ;
  int64_t n_for ;
  int64_t n_rev ;
  mm_seed_t *m ;
  mm128_t *a ;
  mm128_t *heap ;
  void *tmp ;
  void *tmp___0 ;
  mm_seed_t *q ;
  mm128_t *p ;
  uint64_t r ;
  int32_t is_self ;
  int32_t rpos ;
  int64_t tmp___1 ;
  int tmp___2 ;
  mm128_t t ;

  {
  heap_size = 0;
  n_for = (int64_t )0;
  n_rev = (int64_t )0;
  m = mm_collect_matches(km, & n_m, qlen, max_occ, (int )opt->max_max_occ, (int )opt->occ_dist,
                         mi, mv, n_a, rep_len, n_mini_pos, mini_pos);
  tmp = kmalloc(km, (unsigned long )n_m * sizeof(mm128_t ));
  heap = (mm128_t *)tmp;
  tmp___0 = kmalloc(km, (unsigned long )*n_a * sizeof(mm128_t ));
  a = (mm128_t *)tmp___0;
  i = 0;
  heap_size = 0;
  while (i < n_m) {
    if ((m + i)->n > 0U) {
      (heap + heap_size)->x = (uint64_t )*((m + i)->cr + 0);
      (heap + heap_size)->y = (uint64_t )i << 32;
      heap_size ++;
    }
    i ++;
  }
  ks_heapmake_heap((size_t )heap_size, heap);
  while (heap_size > 0) {
    q = m + (heap->y >> 32);
    r = heap->x;
    rpos = (int32_t )((uint32_t )r >> 1);
    tmp___2 = skip_seed((int )opt->flag, r, (mm_seed_t const   *)q, qname, qlen, mi,
                        & is_self);
    if (! tmp___2) {
      if ((r & 1UL) == (unsigned long )(q->q_pos & 1U)) {
        tmp___1 = n_for;
        n_for ++;
        p = a + tmp___1;
        p->x = (uint64_t )(((unsigned long long )r & 18446744069414584320) | (unsigned long long )rpos);
        p->y = ((uint64_t )q->q_span << 32) | (unsigned long )(q->q_pos >> 1);
      } else {
        n_rev ++;
        p = a + (*n_a - n_rev);
        p->x = (uint64_t )(((1ULL << 63) | ((unsigned long long )r & 18446744069414584320)) | (unsigned long long )rpos);
        p->y = ((uint64_t )q->q_span << 32) | (unsigned long )(((uint32_t )qlen - (((q->q_pos >> 1) + 1U) - q->q_span)) - 1U);
      }
      p->y |= (uint64_t )q->seg_id << 48;
      if (q->is_tandem) {
        p->y = (uint64_t )((unsigned long long )p->y | (1ULL << 42));
      }
      if (is_self) {
        p->y = (uint64_t )((unsigned long long )p->y | (1ULL << 43));
      }
    }
    if ((uint32_t )heap->y < q->n - 1U) {
      ((heap + 0)->y) ++;
      (heap + 0)->x = (uint64_t )*((m + ((heap + 0)->y >> 32))->cr + (uint32_t )(heap + 0)->y);
    } else {
      *(heap + 0) = *(heap + (heap_size - 1));
      heap_size --;
    }
    ks_heapdown_heap((size_t )0, (size_t )heap_size, heap);
  }
  kfree(km, (void *)m);
  kfree(km, (void *)heap);
  j = (int64_t )0;
  while (j < n_rev >> 1) {
    t = *(a + ((*n_a - 1L) - j));
    *(a + ((*n_a - 1L) - j)) = *(a + (*n_a - (n_rev - j)));
    *(a + (*n_a - (n_rev - j))) = t;
    j ++;
  }
  if (*n_a > n_for + n_rev) {
    memmove((void *)(a + n_for), (void const   *)((a + *n_a) - n_rev), (unsigned long )n_rev * sizeof(mm128_t ));
    *n_a = n_for + n_rev;
  }
  return (a);
}
}
static mm128_t *collect_seed_hits(void *km , mm_mapopt_t const   *opt , int max_occ ,
                                  mm_idx_t const   *mi , char const   *qname , mm128_v const   *mv ,
                                  int qlen , int64_t *n_a , int *rep_len , int *n_mini_pos ,
                                  uint64_t **mini_pos ) 
{ 
  int i ;
  int n_m ;
  mm_seed_t *m ;
  mm128_t *a ;
  void *tmp ;
  mm_seed_t *q ;
  uint64_t const   *r ;
  uint32_t k ;
  int32_t is_self ;
  int32_t rpos ;
  mm128_t *p ;
  int tmp___0 ;
  int64_t tmp___1 ;
  int32_t len ;

  {
  m = mm_collect_matches(km, & n_m, qlen, max_occ, (int )opt->max_max_occ, (int )opt->occ_dist,
                         mi, mv, n_a, rep_len, n_mini_pos, mini_pos);
  tmp = kmalloc(km, (unsigned long )*n_a * sizeof(mm128_t ));
  a = (mm128_t *)tmp;
  i = 0;
  *n_a = (int64_t )0;
  while (i < n_m) {
    q = m + i;
    r = q->cr;
    k = (uint32_t )0;
    while (k < q->n) {
      rpos = (int32_t )((uint32_t )*(r + k) >> 1);
      tmp___0 = skip_seed((int )opt->flag, (uint64_t )*(r + k), (mm_seed_t const   *)q,
                          qname, qlen, mi, & is_self);
      if (tmp___0) {
        goto __Cont;
      }
      tmp___1 = *n_a;
      (*n_a) ++;
      p = a + tmp___1;
      if ((*(r + k) & 1UL) == (unsigned long const   )(q->q_pos & 1U)) {
        p->x = (uint64_t )(((unsigned long long )*(r + k) & 18446744069414584320) | (unsigned long long )rpos);
        p->y = ((uint64_t )q->q_span << 32) | (unsigned long )(q->q_pos >> 1);
      } else
      if (! ((long long )opt->flag & 4294967296LL)) {
        p->x = (uint64_t )(((1ULL << 63) | ((unsigned long long )*(r + k) & 18446744069414584320)) | (unsigned long long )rpos);
        p->y = ((uint64_t )q->q_span << 32) | (unsigned long )(((uint32_t )qlen - (((q->q_pos >> 1) + 1U) - q->q_span)) - 1U);
      } else {
        len = (int32_t )(mi->seq + (*(r + k) >> 32))->len;
        p->x = (uint64_t )(((1ULL << 63) | ((unsigned long long )*(r + k) & 18446744069414584320)) | (unsigned long long )(((uint32_t )len - ((uint32_t )(rpos + 1) - q->q_span)) - 1U));
        p->y = ((uint64_t )q->q_span << 32) | (unsigned long )(q->q_pos >> 1);
      }
      p->y |= (uint64_t )q->seg_id << 48;
      if (q->is_tandem) {
        p->y = (uint64_t )((unsigned long long )p->y | (1ULL << 42));
      }
      if (is_self) {
        p->y = (uint64_t )((unsigned long long )p->y | (1ULL << 43));
      }
      __Cont: /* CIL Label */ 
      k ++;
    }
    i ++;
  }
  kfree(km, (void *)m);
  radix_sort_128x(a, a + *n_a);
  return (a);
}
}
static void chain_post(mm_mapopt_t const   *opt , int max_chain_gap_ref , mm_idx_t const   *mi ,
                       void *km , int qlen , int n_segs , int const   *qlens , int *n_regs ,
                       mm_reg1_t *regs , mm128_t *a ) 
{ 


  {
  if (! (opt->flag & 8388608L)) {
    mm_set_parent(km, (float )opt->mask_level, (int )opt->mask_len, *n_regs, regs,
                  (int )(opt->a * 2 + opt->b), (int )(opt->flag & 536870912L), (float )opt->alt_drop);
    if (n_segs <= 1) {
      mm_select_sub(km, (float )opt->pri_ratio, (int )(mi->k * 2), (int )opt->best_n,
                    1, (int )((double )opt->max_gap * 0.8), n_regs, regs);
    } else {
      mm_select_sub_multi(km, (float )opt->pri_ratio, 0.2f, 0.7f, max_chain_gap_ref,
                          (int )(mi->k * 2), (int )opt->best_n, n_segs, qlens, n_regs,
                          regs);
    }
  }
  return;
}
}
static mm_reg1_t *align_regs(mm_mapopt_t const   *opt , mm_idx_t const   *mi , void *km ,
                             int qlen , char const   *seq , int *n_regs , mm_reg1_t *regs ,
                             mm128_t *a ) 
{ 


  {
  if (! (opt->flag & 4L)) {
    return (regs);
  }
  regs = mm_align_skeleton(km, opt, mi, qlen, seq, n_regs, regs, a);
  if (! (opt->flag & 8388608L)) {
    mm_set_parent(km, (float )opt->mask_level, (int )opt->mask_len, *n_regs, regs,
                  (int )(opt->a * 2 + opt->b), (int )(opt->flag & 536870912L), (float )opt->alt_drop);
    mm_select_sub(km, (float )opt->pri_ratio, (int )(mi->k * 2), (int )opt->best_n,
                  0, (int )((double )opt->max_gap * 0.8), n_regs, regs);
    mm_set_sam_pri(*n_regs, regs);
  }
  return (regs);
}
}
void mm_map_frag(mm_idx_t const   *mi , int n_segs , int const   *qlens , char const   **seqs ,
                 int *n_regs , mm_reg1_t **regs , mm_tbuf_t *b , mm_mapopt_t const   *opt ,
                 char const   *qname ) 
{ 
  int i ;
  int j ;
  int rep_len ;
  int qlen_sum ;
  int n_regs0 ;
  int n_mini_pos ;
  int max_chain_gap_qry ;
  int max_chain_gap_ref ;
  int is_splice ;
  int is_sr ;
  uint32_t hash ;
  int64_t n_a ;
  uint64_t *u ;
  uint64_t *mini_pos ;
  mm128_t *a ;
  mm128_v mv ;
  mm_reg1_t *regs0 ;
  km_stat_t kmst ;
  float chn_pen_gap ;
  float chn_pen_skip ;
  khint_t tmp ;
  khint_t tmp___0 ;
  khint_t tmp___1 ;
  int tmp___2 ;
  int32_t st ;
  int32_t en ;
  int32_t i___0 ;
  int rechain ;
  int n_chained_segs ;
  int max ;
  int max_i ;
  int max_off ;
  int off ;
  int tmp___3 ;
  void *tmp___4 ;
  mm_seg_t *seg ;

  {
  is_splice = ! (! (opt->flag & 128L));
  is_sr = ! (! (opt->flag & 4096L));
  mv.n = (size_t )0;
  mv.m = (size_t )0;
  mv.a = (mm128_t *)0;
  i = 0;
  qlen_sum = 0;
  while (i < n_segs) {
    qlen_sum += (int )*(qlens + i);
    *(n_regs + i) = 0;
    *(regs + i) = (mm_reg1_t *)0;
    i ++;
  }
  if (qlen_sum == 0) {
    return;
  } else
  if (n_segs <= 0) {
    return;
  } else
  if (n_segs > 255) {
    return;
  }
  if (opt->max_qlen > 0) {
    if (qlen_sum > (int )opt->max_qlen) {
      return;
    }
  }
  if (qname) {
    if (! ((long long )opt->flag & 17179869184LL)) {
      tmp = __ac_X31_hash_string(qname);
      hash = tmp;
    } else {
      hash = (uint32_t )0;
    }
  } else {
    hash = (uint32_t )0;
  }
  tmp___0 = __ac_Wang_hash((khint_t )qlen_sum);
  tmp___1 = __ac_Wang_hash((khint_t )opt->seed);
  hash ^= tmp___0 + tmp___1;
  hash = __ac_Wang_hash(hash);
  collect_minimizers(b->km, opt, mi, n_segs, qlens, seqs, & mv);
  if (opt->q_occ_frac > (float const   )0.0f) {
    mm_seed_mz_flt(b->km, & mv, (int32_t )opt->mid_occ, (float )opt->q_occ_frac);
  }
  if (opt->flag & 4194304L) {
    a = collect_seed_hits_heap(b->km, opt, (int )opt->mid_occ, mi, qname, (mm128_v const   *)(& mv),
                               qlen_sum, & n_a, & rep_len, & n_mini_pos, & mini_pos);
  } else {
    a = collect_seed_hits(b->km, opt, (int )opt->mid_occ, mi, qname, (mm128_v const   *)(& mv),
                          qlen_sum, & n_a, & rep_len, & n_mini_pos, & mini_pos);
  }
  if (mm_dbg_flag & 4) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"RS\t%d\n",
            rep_len);
    i = 0;
    while ((int64_t )i < n_a) {
      if (i == 0) {
        tmp___2 = 0;
      } else {
        tmp___2 = ((int32_t )(a + i)->y - (int32_t )(a + (i - 1))->y) - ((int32_t )(a + i)->x - (int32_t )(a + (i - 1))->x);
      }
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"SD\t%s\t%d\t%c\t%d\t%d\t%d\n",
              (mi->seq + (((a + i)->x << 1) >> 33))->name, (int32_t )(a + i)->x, (int const   )*("+-" + ((a + i)->x >> 63)),
              (int32_t )(a + i)->y, (int32_t )(((a + i)->y >> 32) & 255UL), tmp___2);
      i ++;
    }
  }
  if (is_sr) {
    if (qlen_sum > (int )opt->max_gap) {
      max_chain_gap_qry = qlen_sum;
    } else {
      max_chain_gap_qry = (int )opt->max_gap;
    }
  } else {
    max_chain_gap_qry = (int )opt->max_gap;
  }
  if (opt->max_gap_ref > 0) {
    max_chain_gap_ref = (int )opt->max_gap_ref;
  } else
  if (opt->max_frag_len > 0) {
    max_chain_gap_ref = (int )(opt->max_frag_len - (int const   )qlen_sum);
    if (max_chain_gap_ref < (int )opt->max_gap) {
      max_chain_gap_ref = (int )opt->max_gap;
    }
  } else {
    max_chain_gap_ref = (int )opt->max_gap;
  }
  chn_pen_gap = (float )(((double )opt->chain_gap_scale * 0.01) * (double )mi->k);
  chn_pen_skip = (float )(((double )opt->chain_skip_scale * 0.01) * (double )mi->k);
  if ((long long )opt->flag & 2147483648LL) {
    a = mg_lchain_rmq((int )opt->max_gap, (int )opt->rmq_inner_dist, (int )opt->bw,
                      (int )opt->max_chain_skip, (int )opt->rmq_size_cap, (int )opt->min_cnt,
                      (int )opt->min_chain_score, chn_pen_gap, chn_pen_skip, n_a,
                      a, & n_regs0, & u, b->km);
  } else {
    a = mg_lchain_dp(max_chain_gap_ref, max_chain_gap_qry, (int )opt->bw, (int )opt->max_chain_skip,
                     (int )opt->max_chain_iter, (int )opt->min_cnt, (int )opt->min_chain_score,
                     chn_pen_gap, chn_pen_skip, is_splice, n_segs, n_a, a, & n_regs0,
                     & u, b->km);
  }
  if (opt->bw_long > opt->bw) {
    if ((opt->flag & 5248L) == 0L) {
      if (n_segs == 1) {
        if (n_regs0 > 1) {
          st = (int32_t )(a + 0)->y;
          en = (int32_t )(a + ((int32_t )*(u + 0) - 1))->y;
          if (qlen_sum - (en - st) > (int )opt->rmq_rescue_size) {
            goto _L;
          } else
          if ((float const   )(en - st) > (float const   )qlen_sum * opt->rmq_rescue_ratio) {
            _L: /* CIL Label */ 
            i___0 = 0;
            n_a = (int64_t )0;
            while (i___0 < n_regs0) {
              n_a += (int64_t )((int32_t )*(u + i___0));
              i___0 ++;
            }
            kfree(b->km, (void *)u);
            radix_sort_128x(a, a + n_a);
            a = mg_lchain_rmq((int )opt->max_gap, (int )opt->rmq_inner_dist, (int )opt->bw_long,
                              (int )opt->max_chain_skip, (int )opt->rmq_size_cap,
                              (int )opt->min_cnt, (int )opt->min_chain_score, chn_pen_gap,
                              chn_pen_skip, n_a, a, & n_regs0, & u, b->km);
          }
        } else {
          goto _L___2;
        }
      } else {
        goto _L___2;
      }
    } else {
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
  if (opt->max_occ > opt->mid_occ) {
    if (rep_len > 0) {
      if (! ((long long )opt->flag & 2147483648LL)) {
        rechain = 0;
        if (n_regs0 > 0) {
          n_chained_segs = 1;
          max = 0;
          max_i = -1;
          max_off = -1;
          off = 0;
          i = 0;
          while (i < n_regs0) {
            if (max < (int )(*(u + i) >> 32)) {
              max = (int )(*(u + i) >> 32);
              max_i = i;
              max_off = off;
            }
            off = (int )((uint32_t )off + (uint32_t )*(u + i));
            i ++;
          }
          i = 1;
          while (i < (int32_t )*(u + max_i)) {
            if (((unsigned long long )(a + (max_off + i))->y & (255ULL << 48)) != ((unsigned long long )(a + ((max_off + i) - 1))->y & (255ULL << 48))) {
              n_chained_segs ++;
            }
            i ++;
          }
          if (n_chained_segs < n_segs) {
            rechain = 1;
          }
        } else {
          rechain = 1;
        }
        if (rechain) {
          kfree(b->km, (void *)a);
          kfree(b->km, (void *)u);
          kfree(b->km, (void *)mini_pos);
          if (opt->flag & 4194304L) {
            a = collect_seed_hits_heap(b->km, opt, (int )opt->max_occ, mi, qname,
                                       (mm128_v const   *)(& mv), qlen_sum, & n_a,
                                       & rep_len, & n_mini_pos, & mini_pos);
          } else {
            a = collect_seed_hits(b->km, opt, (int )opt->max_occ, mi, qname, (mm128_v const   *)(& mv),
                                  qlen_sum, & n_a, & rep_len, & n_mini_pos, & mini_pos);
          }
          a = mg_lchain_dp(max_chain_gap_ref, max_chain_gap_qry, (int )opt->bw, (int )opt->max_chain_skip,
                           (int )opt->max_chain_iter, (int )opt->min_cnt, (int )opt->min_chain_score,
                           chn_pen_gap, chn_pen_skip, is_splice, n_segs, n_a, a, & n_regs0,
                           & u, b->km);
        }
      }
    }
  }
  b->frag_gap = max_chain_gap_ref;
  b->rep_len = rep_len;
  regs0 = mm_gen_regs(b->km, hash, qlen_sum, n_regs0, u, a, ! (! ((long long )opt->flag & 4294967296LL)));
  if (mi->n_alt) {
    mm_mark_alt(mi, n_regs0, regs0);
    mm_hit_sort(b->km, & n_regs0, regs0, (float )opt->alt_drop);
  }
  if (mm_dbg_flag & 20) {
    j = 0;
    while (j < n_regs0) {
      i = (regs0 + j)->as;
      while (i < (regs0 + j)->as + (regs0 + j)->cnt) {
        if (i == (regs0 + j)->as) {
          tmp___3 = 0;
        } else {
          tmp___3 = ((int32_t )(a + i)->y - (int32_t )(a + (i - 1))->y) - ((int32_t )(a + i)->x - (int32_t )(a + (i - 1))->x);
        }
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"CN\t%d\t%s\t%d\t%c\t%d\t%d\t%d\n",
                j, (mi->seq + (((a + i)->x << 1) >> 33))->name, (int32_t )(a + i)->x,
                (int const   )*("+-" + ((a + i)->x >> 63)), (int32_t )(a + i)->y,
                (int32_t )(((a + i)->y >> 32) & 255UL), tmp___3);
        i ++;
      }
      j ++;
    }
  }
  chain_post(opt, max_chain_gap_ref, mi, b->km, qlen_sum, n_segs, qlens, & n_regs0,
             regs0, a);
  if (! is_sr) {
    if (! ((long long )opt->flag & 4294967296LL)) {
      mm_est_err(mi, qlen_sum, n_regs0, regs0, (mm128_t const   *)a, n_mini_pos, (uint64_t const   *)mini_pos);
      n_regs0 = mm_filter_strand_retained(n_regs0, regs0);
    }
  }
  if (n_segs == 1) {
    regs0 = align_regs(opt, mi, b->km, (int )*(qlens + 0), *(seqs + 0), & n_regs0,
                       regs0, a);
    tmp___4 = realloc((void *)regs0, sizeof(*regs0) * (unsigned long )n_regs0);
    regs0 = (mm_reg1_t *)tmp___4;
    mm_set_mapq(b->km, n_regs0, regs0, (int )opt->min_chain_score, (int )opt->a, rep_len,
                is_sr);
    *(n_regs + 0) = n_regs0;
    *(regs + 0) = regs0;
  } else {
    seg = mm_seg_gen(b->km, hash, n_segs, qlens, n_regs0, (mm_reg1_t const   *)regs0,
                     n_regs, regs, (mm128_t const   *)a);
    free((void *)regs0);
    i = 0;
    while (i < n_segs) {
      mm_set_parent(b->km, (float )opt->mask_level, (int )opt->mask_len, *(n_regs + i),
                    *(regs + i), (int )(opt->a * 2 + opt->b), (int )(opt->flag & 536870912L),
                    (float )opt->alt_drop);
      *(regs + i) = align_regs(opt, mi, b->km, (int )*(qlens + i), *(seqs + i), n_regs + i,
                               *(regs + i), (seg + i)->a);
      mm_set_mapq(b->km, *(n_regs + i), *(regs + i), (int )opt->min_chain_score, (int )opt->a,
                  rep_len, is_sr);
      i ++;
    }
    mm_seg_free(b->km, n_segs, seg);
    if (n_segs == 2) {
      if (opt->pe_ori >= 0) {
        if (opt->flag & 4L) {
          mm_pair(b->km, max_chain_gap_ref, (int )opt->pe_bonus, (int )(opt->a * 2 + opt->b),
                  (int )opt->a, qlens, n_regs, regs);
        }
      }
    }
  }
  kfree(b->km, (void *)mv.a);
  kfree(b->km, (void *)a);
  kfree(b->km, (void *)u);
  kfree(b->km, (void *)mini_pos);
  if (b->km) {
    km_stat((void const   *)b->km, & kmst);
    if (mm_dbg_flag & 2) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"QM\t%s\t%d\tcap=%ld,nCore=%ld,largest=%ld\n",
              qname, qlen_sum, kmst.capacity, kmst.n_cores, kmst.largest);
    }
    if (kmst.largest > (size_t )(1U << 28)) {
      goto _L___3;
    } else
    if (opt->cap_kalloc > 0L) {
      if (kmst.capacity > (size_t )opt->cap_kalloc) {
        _L___3: /* CIL Label */ 
        if (mm_dbg_flag & 2) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[W::%s] reset thread-local memory after read %s\n",
                  "mm_map_frag", qname);
        }
        km_destroy(b->km);
        b->km = km_init();
      }
    }
  }
  return;
}
}
mm_reg1_t *mm_map(mm_idx_t const   *mi , int qlen , char const   *seq , int *n_regs ,
                  mm_tbuf_t *b , mm_mapopt_t const   *opt , char const   *qname ) 
{ 
  mm_reg1_t *regs ;

  {
  mm_map_frag(mi, 1, (int const   *)(& qlen), & seq, n_regs, & regs, b, opt, qname);
  return (regs);
}
}
static void worker_for(void *_data , long i , int tid ) 
{ 
  step_t___0 *s ;
  int qlens[255] ;
  int j ;
  int off ;
  int pe_ori ;
  char const   *qseqs[255] ;
  double t ;
  mm_tbuf_t *b ;
  int k ;
  int t___0 ;
  mm_reg1_t *r ;
  double tmp___0 ;

  {
  s = (step_t___0 *)_data;
  off = *(s->seg_off + i);
  pe_ori = (int )((s->p)->opt)->pe_ori;
  t = 0.0;
  b = *(s->buf + tid);
  if (! (*(s->n_seg + i) <= 255)) {
    __assert_fail("s->n_seg[i] <= MM_MAX_SEG", "map.c", 420U, "worker_for");
  }
  if (mm_dbg_flag & 2) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"QR\t%s\t%d\t%d\n",
            (s->seq + off)->name, tid, (s->seq + off)->l_seq);
    t = realtime();
  }
  j = 0;
  while (j < *(s->n_seg + i)) {
    if (*(s->n_seg + i) == 2) {
      if (j == 0) {
        if ((pe_ori >> 1) & 1) {
          mm_revcomp_bseq(s->seq + (off + j));
        } else {
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
      if (j == 1) {
        if (pe_ori & 1) {
          mm_revcomp_bseq(s->seq + (off + j));
        }
      }
    }
    qlens[j] = (s->seq + (off + j))->l_seq;
    qseqs[j] = (char const   *)(s->seq + (off + j))->seq;
    j ++;
  }
  if (((s->p)->opt)->flag & 131072L) {
    j = 0;
    while (j < *(s->n_seg + i)) {
      mm_map_frag((mm_idx_t const   *)(s->p)->mi, 1, (int const   *)(& qlens[j]),
                  & qseqs[j], s->n_reg + (off + j), s->reg + (off + j), b, (mm_mapopt_t const   *)(s->p)->opt,
                  (char const   *)(s->seq + (off + j))->name);
      *(s->rep_len + (off + j)) = b->rep_len;
      *(s->frag_gap + (off + j)) = b->frag_gap;
      j ++;
    }
  } else {
    mm_map_frag((mm_idx_t const   *)(s->p)->mi, *(s->n_seg + i), (int const   *)(qlens),
                qseqs, s->n_reg + off, s->reg + off, b, (mm_mapopt_t const   *)(s->p)->opt,
                (char const   *)(s->seq + off)->name);
    j = 0;
    while (j < *(s->n_seg + i)) {
      *(s->rep_len + (off + j)) = b->rep_len;
      *(s->frag_gap + (off + j)) = b->frag_gap;
      j ++;
    }
  }
  j = 0;
  while (j < *(s->n_seg + i)) {
    if (*(s->n_seg + i) == 2) {
      if (j == 0) {
        if ((pe_ori >> 1) & 1) {
          goto _L___0;
        } else {
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
      if (j == 1) {
        if (pe_ori & 1) {
          _L___0: /* CIL Label */ 
          mm_revcomp_bseq(s->seq + (off + j));
          k = 0;
          while (k < *(s->n_reg + (off + j))) {
            r = *(s->reg + (off + j)) + k;
            t___0 = r->qs;
            r->qs = qlens[j] - r->qe;
            r->qe = qlens[j] - t___0;
            r->rev = (uint32_t )(! r->rev);
            k ++;
          }
        }
      }
    }
    j ++;
  }
  if (mm_dbg_flag & 2) {
    tmp___0 = realtime();
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"QT\t%s\t%d\t%.6f\n",
            (s->seq + off)->name, tid, tmp___0 - t);
  }
  return;
}
}
static void merge_hits(step_t___0 *s ) 
{ 
  int f ;
  int i ;
  int k0 ;
  int k ;
  int max_seg ;
  int *n_reg_part ;
  int *rep_len_part ;
  int *frag_gap_part ;
  int *qlens ;
  void *km ;
  FILE **fp ;
  mm_mapopt_t const   *opt ;
  void *tmp ;
  int j ;
  int l ;
  int t ;
  int rep_len ;
  void *tmp___0 ;
  mm_reg1_t *r ;
  uint32_t capacity ;
  void *tmp___1 ;
  mm_reg1_t *r___0 ;

  {
  max_seg = 0;
  fp = (FILE **)(s->p)->fp_parts;
  opt = (mm_mapopt_t const   *)(s->p)->opt;
  km = km_init();
  f = 0;
  while (f < s->n_frag) {
    if (max_seg > *(s->n_seg + f)) {
      max_seg = max_seg;
    } else {
      max_seg = *(s->n_seg + f);
    }
    f ++;
  }
  tmp = calloc((size_t )(max_seg + (int )((s->p)->n_parts * 3)), sizeof(int ));
  qlens = (int *)tmp;
  n_reg_part = qlens + max_seg;
  rep_len_part = n_reg_part + (s->p)->n_parts;
  frag_gap_part = rep_len_part + (s->p)->n_parts;
  f = 0;
  k0 = 0;
  k = k0;
  while (f < s->n_frag) {
    k0 = k;
    i = 0;
    while (i < *(s->n_seg + f)) {
      rep_len = 0;
      *(qlens + i) = (s->seq + k)->l_seq;
      j = 0;
      *(s->n_reg + k) = 0;
      while (j < (int )(s->p)->n_parts) {
        mm_err_fread((void *)(n_reg_part + j), sizeof(int ), (size_t )1, *(fp + j));
        mm_err_fread((void *)(rep_len_part + j), sizeof(int ), (size_t )1, *(fp + j));
        mm_err_fread((void *)(frag_gap_part + j), sizeof(int ), (size_t )1, *(fp + j));
        *(s->n_reg + k) += *(n_reg_part + j);
        if (rep_len < *(rep_len_part + j)) {
          rep_len = *(rep_len_part + j);
        }
        j ++;
      }
      tmp___0 = calloc((size_t )*(s->n_reg + k), sizeof(mm_reg1_t ));
      *(s->reg + k) = (mm_reg1_t *)tmp___0;
      j = 0;
      l = 0;
      while (j < (int )(s->p)->n_parts) {
        t = 0;
        while (t < *(n_reg_part + j)) {
          r = *(s->reg + k) + l;
          mm_err_fread((void *)r, sizeof(mm_reg1_t ), (size_t )1, *(fp + j));
          r->rid = (int32_t )((uint32_t )r->rid + *((s->p)->rid_shift + j));
          if (opt->flag & 4L) {
            mm_err_fread((void *)(& capacity), (size_t )4, (size_t )1, *(fp + j));
            tmp___1 = calloc((size_t )capacity, (size_t )4);
            r->p = (mm_extra_t *)tmp___1;
            (r->p)->capacity = capacity;
            mm_err_fread((void *)r->p, (size_t )(r->p)->capacity, (size_t )4, *(fp + j));
          }
          t ++;
          l ++;
        }
        j ++;
      }
      if (! (opt->flag & 4096L)) {
        if ((s->seq + k)->l_seq >= (int )opt->rank_min_len) {
          mm_update_dp_max((s->seq + k)->l_seq, *(s->n_reg + k), *(s->reg + k), (float )opt->rank_frac,
                           (int )opt->a, (int )opt->b);
        }
      }
      j = 0;
      while (j < *(s->n_reg + k)) {
        r___0 = *(s->reg + k) + j;
        if (r___0->p) {
          (r___0->p)->dp_max2 = 0;
        }
        r___0->subsc = 0;
        r___0->n_sub = 0;
        j ++;
      }
      mm_hit_sort(km, s->n_reg + k, *(s->reg + k), (float )opt->alt_drop);
      mm_set_parent(km, (float )opt->mask_level, (int )opt->mask_len, *(s->n_reg + k),
                    *(s->reg + k), (int )(opt->a * 2 + opt->b), (int )(opt->flag & 536870912L),
                    (float )opt->alt_drop);
      if (! (opt->flag & 8388608L)) {
        mm_select_sub(km, (float )opt->pri_ratio, (int )(((s->p)->mi)->k * 2), (int )opt->best_n,
                      0, (int )((double )opt->max_gap * 0.8), s->n_reg + k, *(s->reg + k));
        mm_set_sam_pri(*(s->n_reg + k), *(s->reg + k));
      }
      mm_set_mapq(km, *(s->n_reg + k), *(s->reg + k), (int )opt->min_chain_score,
                  (int )opt->a, rep_len, ! (! (opt->flag & 4096L)));
      i ++;
      k ++;
    }
    if (*(s->n_seg + f) == 2) {
      if (opt->pe_ori >= 0) {
        if (opt->flag & 4L) {
          mm_pair(km, *(frag_gap_part + 0), (int )opt->pe_bonus, (int )(opt->a * 2 + opt->b),
                  (int )opt->a, (int const   *)qlens, s->n_reg + k0, s->reg + k0);
        }
      }
    }
    f ++;
  }
  free((void *)qlens);
  km_destroy(km);
  return;
}
}
static void *worker_pipeline___0(void *shared , int step , void *in ) 
{ 
  int i ;
  int j ;
  int k ;
  pipeline_t___0 *p ;
  int with_qual ;
  int tmp ;
  int with_comment ;
  int frag_mode ;
  int tmp___0 ;
  step_t___0 *s ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *km ;
  step_t___0 *s___0 ;
  mm_idx_t const   *mi ;
  int seg_st ;
  int seg_en ;
  mm_bseq1_t *t ;
  mm_reg1_t *r ;
  mm_reg1_t *r___0 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;

  {
  p = (pipeline_t___0 *)shared;
  if (step == 0) {
    if (! (! ((p->opt)->flag & 8L))) {
      if (! ((p->opt)->flag & 16L)) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
    with_qual = tmp;
    with_comment = ! (! ((p->opt)->flag & 33554432L));
    if (p->n_fp > 1) {
      tmp___0 = 1;
    } else
    if (! (! ((p->opt)->flag & 8192L))) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
    frag_mode = tmp___0;
    tmp___1 = calloc((size_t )1, sizeof(step_t___0 ));
    s = (step_t___0 *)tmp___1;
    if (p->n_fp > 1) {
      s->seq = mm_bseq_read_frag2(p->n_fp, p->fp, p->mini_batch_size, with_qual, with_comment,
                                  & s->n_seq);
    } else {
      s->seq = mm_bseq_read3(*(p->fp + 0), p->mini_batch_size, with_qual, with_comment,
                             frag_mode, & s->n_seq);
    }
    if (s->seq) {
      s->p = (pipeline_t___0 const   *)p;
      i = 0;
      while (i < s->n_seq) {
        tmp___2 = p->n_processed;
        (p->n_processed) ++;
        (s->seq + i)->rid = tmp___2;
        i ++;
      }
      tmp___3 = calloc((size_t )p->n_threads, sizeof(mm_tbuf_t *));
      s->buf = (mm_tbuf_t **)tmp___3;
      i = 0;
      while (i < p->n_threads) {
        *(s->buf + i) = mm_tbuf_init();
        i ++;
      }
      tmp___4 = calloc((size_t )(5 * s->n_seq), sizeof(int ));
      s->n_reg = (int *)tmp___4;
      s->seg_off = s->n_reg + s->n_seq;
      s->n_seg = s->seg_off + s->n_seq;
      s->rep_len = s->n_seg + s->n_seq;
      s->frag_gap = s->rep_len + s->n_seq;
      tmp___5 = calloc((size_t )s->n_seq, sizeof(mm_reg1_t *));
      s->reg = (mm_reg1_t **)tmp___5;
      i = 1;
      j = 0;
      while (i <= s->n_seq) {
        if (i == s->n_seq) {
          *(s->n_seg + s->n_frag) = i - j;
          tmp___6 = s->n_frag;
          (s->n_frag) ++;
          *(s->seg_off + tmp___6) = j;
          j = i;
        } else
        if (! frag_mode) {
          *(s->n_seg + s->n_frag) = i - j;
          tmp___6 = s->n_frag;
          (s->n_frag) ++;
          *(s->seg_off + tmp___6) = j;
          j = i;
        } else {
          tmp___7 = mm_qname_same((char const   *)(s->seq + (i - 1))->name, (char const   *)(s->seq + i)->name);
          if (! tmp___7) {
            *(s->n_seg + s->n_frag) = i - j;
            tmp___6 = s->n_frag;
            (s->n_frag) ++;
            *(s->seg_off + tmp___6) = j;
            j = i;
          }
        }
        i ++;
      }
      return ((void *)s);
    } else {
      free((void *)s);
    }
  } else
  if (step == 1) {
    if (p->n_parts > 0) {
      merge_hits((step_t___0 *)in);
    } else {
      kt_for(p->n_threads, & worker_for, in, (long )((step_t___0 *)in)->n_frag);
    }
    return (in);
  } else
  if (step == 2) {
    km = (void *)0;
    s___0 = (step_t___0 *)in;
    mi = p->mi;
    i = 0;
    while (i < p->n_threads) {
      mm_tbuf_destroy(*(s___0->buf + i));
      i ++;
    }
    free((void *)s___0->buf);
    if ((p->opt)->flag & 64L) {
      if (! (mm_dbg_flag & 1)) {
        km = km_init();
      }
    }
    k = 0;
    while (k < s___0->n_frag) {
      seg_st = *(s___0->seg_off + k);
      seg_en = *(s___0->seg_off + k) + *(s___0->n_seg + k);
      i = seg_st;
      while (i < seg_en) {
        t = s___0->seq + i;
        if ((p->opt)->split_prefix) {
          if (p->n_parts == 0) {
            mm_err_fwrite((void const   *)(s___0->n_reg + i), sizeof(int ), (size_t )1,
                          p->fp_split);
            mm_err_fwrite((void const   *)(s___0->rep_len + i), sizeof(int ), (size_t )1,
                          p->fp_split);
            mm_err_fwrite((void const   *)(s___0->frag_gap + i), sizeof(int ), (size_t )1,
                          p->fp_split);
            j = 0;
            while (j < *(s___0->n_reg + i)) {
              r = *(s___0->reg + i) + j;
              mm_err_fwrite((void const   *)r, sizeof(mm_reg1_t ), (size_t )1, p->fp_split);
              if ((p->opt)->flag & 4L) {
                mm_err_fwrite((void const   *)(& (r->p)->capacity), (size_t )4, (size_t )1,
                              p->fp_split);
                mm_err_fwrite((void const   *)r->p, (size_t )(r->p)->capacity, (size_t )4,
                              p->fp_split);
              }
              j ++;
            }
          } else {
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
        if (*(s___0->n_reg + i) > 0) {
          j = 0;
          while (j < *(s___0->n_reg + i)) {
            r___0 = *(s___0->reg + i) + j;
            if (! (! r___0->sam_pri)) {
              if (! (r___0->id == r___0->parent)) {
                __assert_fail("!r->sam_pri || r->id == r->parent", "map.c", 588U,
                              "worker_pipeline");
              }
            }
            if ((p->opt)->flag & 16384L) {
              if (r___0->id != r___0->parent) {
                goto __Cont;
              }
            }
            if ((p->opt)->flag & 8L) {
              mm_write_sam3(& p->str, mi, (mm_bseq1_t const   *)t, i - seg_st, j,
                            *(s___0->n_seg + k), (int const   *)(s___0->n_reg + seg_st),
                            (mm_reg1_t const   * const  *)(s___0->reg + seg_st), km,
                            (int64_t )(p->opt)->flag, *(s___0->rep_len + i));
            } else {
              mm_write_paf3(& p->str, mi, (mm_bseq1_t const   *)t, (mm_reg1_t const   *)r___0,
                            km, (int64_t )(p->opt)->flag, *(s___0->rep_len + i));
            }
            mm_err_puts((char const   *)p->str.s);
            __Cont: /* CIL Label */ 
            j ++;
          }
        } else
        if ((p->opt)->flag & 134217728L) {
          goto _L;
        } else
        if ((p->opt)->flag & 8L) {
          if (! ((p->opt)->flag & 1073741824L)) {
            _L: /* CIL Label */ 
            if ((p->opt)->flag & 8L) {
              mm_write_sam3(& p->str, mi, (mm_bseq1_t const   *)t, i - seg_st, -1,
                            *(s___0->n_seg + k), (int const   *)(s___0->n_reg + seg_st),
                            (mm_reg1_t const   * const  *)(s___0->reg + seg_st), km,
                            (int64_t )(p->opt)->flag, *(s___0->rep_len + i));
            } else {
              mm_write_paf3(& p->str, mi, (mm_bseq1_t const   *)t, (mm_reg1_t const   *)0,
                            (void *)0, (int64_t )(p->opt)->flag, *(s___0->rep_len + i));
            }
            mm_err_puts((char const   *)p->str.s);
          }
        }
        i ++;
      }
      i = seg_st;
      while (i < seg_en) {
        j = 0;
        while (j < *(s___0->n_reg + i)) {
          free((void *)(*(s___0->reg + i) + j)->p);
          j ++;
        }
        free((void *)*(s___0->reg + i));
        free((void *)(s___0->seq + i)->seq);
        free((void *)(s___0->seq + i)->name);
        if ((s___0->seq + i)->qual) {
          free((void *)(s___0->seq + i)->qual);
        }
        if ((s___0->seq + i)->comment) {
          free((void *)(s___0->seq + i)->comment);
        }
        i ++;
      }
      k ++;
    }
    free((void *)s___0->reg);
    free((void *)s___0->n_reg);
    free((void *)s___0->seq);
    km_destroy(km);
    if (mm_verbose >= 3) {
      tmp___9 = cputime();
      tmp___10 = realtime();
      tmp___11 = realtime();
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[M::%s::%.3f*%.2f] mapped %d sequences\n",
              "worker_pipeline", tmp___11 - mm_realtime0, tmp___9 / (tmp___10 - mm_realtime0),
              s___0->n_seq);
    }
    free((void *)s___0);
  }
  return ((void *)0);
}
}
static mm_bseq_file_t **open_bseqs(int n , char const   **fn ) 
{ 
  mm_bseq_file_t **fp ;
  int i ;
  int j ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  mm_bseq_file_t *tmp___2 ;

  {
  tmp = calloc((size_t )n, sizeof(mm_bseq_file_t *));
  fp = (mm_bseq_file_t **)tmp;
  i = 0;
  while (i < n) {
    tmp___2 = mm_bseq_open(*(fn + i));
    *(fp + i) = tmp___2;
    if ((unsigned long )tmp___2 == (unsigned long )((mm_bseq_file_t *)0)) {
      if (mm_verbose >= 1) {
        tmp___0 = __errno_location();
        tmp___1 = strerror(*tmp___0);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: failed to open file \'%s\': %s\n",
                *(fn + i), tmp___1);
      }
      j = 0;
      while (j < i) {
        mm_bseq_close(*(fp + j));
        j ++;
      }
      free((void *)fp);
      return ((mm_bseq_file_t **)0);
    }
    i ++;
  }
  return (fp);
}
}
int mm_map_file_frag(mm_idx_t const   *idx , int n_segs , char const   **fn , mm_mapopt_t const   *opt ,
                     int n_threads ) 
{ 
  int i ;
  int pl_threads ;
  pipeline_t___0 pl ;
  int tmp ;

  {
  if (n_segs < 1) {
    return (-1);
  }
  memset((void *)(& pl), 0, sizeof(pipeline_t___0 ));
  pl.n_fp = n_segs;
  pl.fp = open_bseqs(pl.n_fp, fn);
  if ((unsigned long )pl.fp == (unsigned long )((mm_bseq_file_t **)0)) {
    return (-1);
  }
  pl.opt = opt;
  pl.mi = idx;
  if (n_threads > 1) {
    pl.n_threads = n_threads;
  } else {
    pl.n_threads = 1;
  }
  pl.mini_batch_size = (int64_t )opt->mini_batch_size;
  if (opt->split_prefix) {
    pl.fp_split = mm_split_init((char const   *)opt->split_prefix, idx);
  }
  if (n_threads == 1) {
    pl_threads = 1;
  } else {
    if (opt->flag & 32768L) {
      tmp = 3;
    } else {
      tmp = 2;
    }
    pl_threads = tmp;
  }
  kt_pipeline(pl_threads, & worker_pipeline___0, (void *)(& pl), 3);
  free((void *)pl.str.s);
  if (pl.fp_split) {
    fclose(pl.fp_split);
  }
  i = 0;
  while (i < pl.n_fp) {
    mm_bseq_close(*(pl.fp + i));
    i ++;
  }
  free((void *)pl.fp);
  return (0);
}
}
int mm_map_file(mm_idx_t const   *idx , char const   *fn , mm_mapopt_t const   *opt ,
                int n_threads ) 
{ 
  int tmp ;

  {
  tmp = mm_map_file_frag(idx, 1, & fn, opt, n_threads);
  return (tmp);
}
}
int mm_split_merge(int n_segs , char const   **fn , mm_mapopt_t const   *opt , int n_split_idx ) 
{ 
  int i ;
  pipeline_t___0 pl ;
  mm_idx_t *mi ;
  void *tmp ;
  void *tmp___0 ;

  {
  if (n_segs < 1) {
    return (-1);
  } else
  if (n_split_idx < 1) {
    return (-1);
  }
  memset((void *)(& pl), 0, sizeof(pipeline_t___0 ));
  pl.n_fp = n_segs;
  pl.fp = open_bseqs(pl.n_fp, fn);
  if ((unsigned long )pl.fp == (unsigned long )((mm_bseq_file_t **)0)) {
    return (-1);
  }
  pl.opt = opt;
  pl.mini_batch_size = (int64_t )opt->mini_batch_size;
  pl.n_parts = n_split_idx;
  tmp = calloc((size_t )pl.n_parts, sizeof(FILE *));
  pl.fp_parts = (FILE **)tmp;
  tmp___0 = calloc((size_t )pl.n_parts, sizeof(uint32_t ));
  pl.rid_shift = (uint32_t *)tmp___0;
  mi = mm_split_merge_prep((char const   *)opt->split_prefix, n_split_idx, pl.fp_parts,
                           pl.rid_shift);
  pl.mi = (mm_idx_t const   *)mi;
  if ((unsigned long )pl.mi == (unsigned long )((mm_idx_t const   *)0)) {
    free((void *)pl.fp_parts);
    free((void *)pl.rid_shift);
    return (-1);
  }
  i = n_split_idx - 1;
  while (i > 0) {
    *(pl.rid_shift + i) = *(pl.rid_shift + (i - 1));
    i --;
  }
  *(pl.rid_shift + 0) = (uint32_t )0;
  i = 1;
  while (i < n_split_idx) {
    *(pl.rid_shift + i) += *(pl.rid_shift + (i - 1));
    i ++;
  }
  if (opt->flag & 8L) {
    i = 0;
    while (i < (int32_t )(pl.mi)->n_seq) {
      printf((char const   * __restrict  )"@SQ\tSN:%s\tLN:%d\n", ((pl.mi)->seq + i)->name,
             ((pl.mi)->seq + i)->len);
      i ++;
    }
  }
  kt_pipeline(2, & worker_pipeline___0, (void *)(& pl), 3);
  free((void *)pl.str.s);
  mm_idx_destroy(mi);
  free((void *)pl.rid_shift);
  i = 0;
  while (i < n_split_idx) {
    fclose(*(pl.fp_parts + i));
    i ++;
  }
  free((void *)pl.fp_parts);
  i = 0;
  while (i < pl.n_fp) {
    mm_bseq_close(*(pl.fp + i));
    i ++;
  }
  free((void *)pl.fp);
  mm_split_rm_tmp((char const   *)opt->split_prefix, n_split_idx);
  return (0);
}
}
#pragma merger("0","/tmp/cil-DX4QuhW4.i","-g,-Wall,-O2,-Wc++-compat")
double mm_realtime0  ;
int mm_verbose  =    1;
int mm_dbg_flag  =    0;
extern  __attribute__((__nothrow__)) int getrusage(__rusage_who_t __who , struct rusage *__usage ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         void * __restrict  __tz ) ;
double cputime(void) 
{ 
  struct rusage r ;

  {
  getrusage(0, & r);
  return ((double )(r.ru_utime.tv_sec + r.ru_stime.tv_sec) + 1e-6 * (double )(r.ru_utime.tv_usec + r.ru_stime.tv_usec));
}
}
long peakrss(void) 
{ 
  struct rusage r ;

  {
  getrusage(0, & r);
  return (r.__annonCompField3.ru_maxrss * 1024L);
}
}
double realtime(void) 
{ 
  struct timeval tp ;

  {
  gettimeofday((struct timeval * __restrict  )(& tp), (void * __restrict  )((void *)0));
  return ((double )tp.tv_sec + (double )tp.tv_usec * 1e-6);
}
}
void mm_err_puts(char const   *str ) 
{ 
  int ret ;

  {
  ret = puts(str);
  if (ret == -1) {
    perror("[ERROR] failed to write the results");
    exit(1);
  }
  return;
}
}
void mm_err_fwrite(void const   *p , size_t size , size_t nitems , FILE *fp ) 
{ 
  int ret ;
  size_t tmp ;

  {
  tmp = fwrite((void const   * __restrict  )p, size, nitems, (FILE * __restrict  )fp);
  ret = (int )tmp;
  if (ret == -1) {
    perror("[ERROR] failed to write data");
    exit(1);
  }
  return;
}
}
void mm_err_fread(void *p , size_t size , size_t nitems , FILE *fp ) 
{ 
  int ret ;
  size_t tmp ;

  {
  tmp = fread((void * __restrict  )p, size, nitems, (FILE * __restrict  )fp);
  ret = (int )tmp;
  if (ret == -1) {
    perror("[ERROR] failed to read data");
    exit(1);
  }
  return;
}
}
void rs_insertsort_128x(mm128_t *beg , mm128_t *end ) 
{ 
  mm128_t *i ;
  mm128_t *j ;
  mm128_t tmp ;

  {
  i = beg + 1;
  while ((unsigned long )i < (unsigned long )end) {
    if (i->x < (i - 1)->x) {
      tmp = *i;
      j = i;
      while (1) {
        if ((unsigned long )j > (unsigned long )beg) {
          if (! (tmp.x < (j - 1)->x)) {
            break;
          }
        } else {
          break;
        }
        *j = *(j - 1);
        j --;
      }
      *j = tmp;
    }
    i ++;
  }
  return;
}
}
void rs_sort_128x(mm128_t *beg , mm128_t *end , int n_bits , int s ) 
{ 
  mm128_t *i ;
  int size ;
  int m ;
  rsbucket_128x_t *k ;
  rsbucket_128x_t b[1 << 8] ;
  rsbucket_128x_t *be ;
  mm128_t *tmp___0 ;
  rsbucket_128x_t *l ;
  mm128_t tmp___1 ;
  mm128_t swap ;
  mm128_t *tmp___2 ;
  mm128_t *tmp___3 ;

  {
  size = 1 << n_bits;
  m = size - 1;
  be = b + size;
  if (! (n_bits <= 8)) {
    __assert_fail("n_bits <= RS_MAX_BITS", "misc.c", 156U, "rs_sort_128x");
  }
  k = b;
  while ((unsigned long )k != (unsigned long )be) {
    tmp___0 = beg;
    k->e = tmp___0;
    k->b = tmp___0;
    k ++;
  }
  i = beg;
  while ((unsigned long )i != (unsigned long )end) {
    (b[(i->x >> s) & (unsigned long )m].e) ++;
    i ++;
  }
  k = b + 1;
  while ((unsigned long )k != (unsigned long )be) {
    k->e += (k - 1)->e - beg;
    k->b = (k - 1)->e;
    k ++;
  }
  k = b;
  while ((unsigned long )k != (unsigned long )be) {
    if ((unsigned long )k->b != (unsigned long )k->e) {
      l = b + (((k->b)->x >> s) & (unsigned long )m);
      if ((unsigned long )l != (unsigned long )k) {
        tmp___1 = *(k->b);
        while (1) {
          swap = tmp___1;
          tmp___1 = *(l->b);
          tmp___2 = l->b;
          (l->b) ++;
          *tmp___2 = swap;
          l = b + ((tmp___1.x >> s) & (unsigned long )m);
          if (! ((unsigned long )l != (unsigned long )k)) {
            break;
          }
        }
        tmp___3 = k->b;
        (k->b) ++;
        *tmp___3 = tmp___1;
      } else {
        (k->b) ++;
      }
    } else {
      k ++;
    }
  }
  b[0].b = beg;
  k = b + 1;
  while ((unsigned long )k != (unsigned long )be) {
    k->b = (k - 1)->e;
    k ++;
  }
  if (s) {
    if (s > n_bits) {
      s -= n_bits;
    } else {
      s = 0;
    }
    k = b;
    while ((unsigned long )k != (unsigned long )be) {
      if (k->e - k->b > 64L) {
        rs_sort_128x(k->b, k->e, n_bits, s);
      } else
      if (k->e - k->b > 1L) {
        rs_insertsort_128x(k->b, k->e);
      }
      k ++;
    }
  }
  return;
}
}
void radix_sort_128x(mm128_t *beg , mm128_t *end ) 
{ 


  {
  if (end - beg <= 64L) {
    rs_insertsort_128x(beg, end);
  } else {
    rs_sort_128x(beg, end, 8, 56);
  }
  return;
}
}
void rs_insertsort_64(uint64_t *beg , uint64_t *end ) 
{ 
  uint64_t *i ;
  uint64_t *j ;
  uint64_t tmp ;

  {
  i = beg + 1;
  while ((unsigned long )i < (unsigned long )end) {
    if (*i < *(i - 1)) {
      tmp = *i;
      j = i;
      while (1) {
        if ((unsigned long )j > (unsigned long )beg) {
          if (! (tmp < *(j - 1))) {
            break;
          }
        } else {
          break;
        }
        *j = *(j - 1);
        j --;
      }
      *j = tmp;
    }
    i ++;
  }
  return;
}
}
void rs_sort_64(uint64_t *beg , uint64_t *end , int n_bits , int s ) 
{ 
  uint64_t *i ;
  int size ;
  int m ;
  rsbucket_64_t *k ;
  rsbucket_64_t b[1 << 8] ;
  rsbucket_64_t *be ;
  uint64_t *tmp___0 ;
  rsbucket_64_t *l ;
  uint64_t tmp___1 ;
  uint64_t swap ;
  uint64_t *tmp___2 ;
  uint64_t *tmp___3 ;

  {
  size = 1 << n_bits;
  m = size - 1;
  be = b + size;
  if (! (n_bits <= 8)) {
    __assert_fail("n_bits <= RS_MAX_BITS", "misc.c", 159U, "rs_sort_64");
  }
  k = b;
  while ((unsigned long )k != (unsigned long )be) {
    tmp___0 = beg;
    k->e = tmp___0;
    k->b = tmp___0;
    k ++;
  }
  i = beg;
  while ((unsigned long )i != (unsigned long )end) {
    (b[(*i >> s) & (unsigned long )m].e) ++;
    i ++;
  }
  k = b + 1;
  while ((unsigned long )k != (unsigned long )be) {
    k->e += (k - 1)->e - beg;
    k->b = (k - 1)->e;
    k ++;
  }
  k = b;
  while ((unsigned long )k != (unsigned long )be) {
    if ((unsigned long )k->b != (unsigned long )k->e) {
      l = b + ((*(k->b) >> s) & (unsigned long )m);
      if ((unsigned long )l != (unsigned long )k) {
        tmp___1 = *(k->b);
        while (1) {
          swap = tmp___1;
          tmp___1 = *(l->b);
          tmp___2 = l->b;
          (l->b) ++;
          *tmp___2 = swap;
          l = b + ((tmp___1 >> s) & (unsigned long )m);
          if (! ((unsigned long )l != (unsigned long )k)) {
            break;
          }
        }
        tmp___3 = k->b;
        (k->b) ++;
        *tmp___3 = tmp___1;
      } else {
        (k->b) ++;
      }
    } else {
      k ++;
    }
  }
  b[0].b = beg;
  k = b + 1;
  while ((unsigned long )k != (unsigned long )be) {
    k->b = (k - 1)->e;
    k ++;
  }
  if (s) {
    if (s > n_bits) {
      s -= n_bits;
    } else {
      s = 0;
    }
    k = b;
    while ((unsigned long )k != (unsigned long )be) {
      if (k->e - k->b > 64L) {
        rs_sort_64(k->b, k->e, n_bits, s);
      } else
      if (k->e - k->b > 1L) {
        rs_insertsort_64(k->b, k->e);
      }
      k ++;
    }
  }
  return;
}
}
void radix_sort_64(uint64_t *beg , uint64_t *end ) 
{ 


  {
  if (end - beg <= 64L) {
    rs_insertsort_64(beg, end);
  } else {
    rs_sort_64(beg, end, 8, 56);
  }
  return;
}
}
void ks_heapdown_uint32_t(size_t i , size_t n , uint32_t *l ) 
{ 
  size_t k ;
  uint32_t tmp ;

  {
  k = i;
  tmp = *(l + i);
  while (1) {
    k = (k << 1) + 1UL;
    if (! (k < n)) {
      break;
    }
    if (k != n - 1UL) {
      if (*(l + k) < *(l + (k + 1UL))) {
        k ++;
      }
    }
    if (*(l + k) < tmp) {
      break;
    }
    *(l + i) = *(l + k);
    i = k;
  }
  *(l + i) = tmp;
  return;
}
}
void ks_heapmake_uint32_t(size_t lsize , uint32_t *l ) 
{ 
  size_t i ;

  {
  i = (lsize >> 1) - 1UL;
  while (i != 0xffffffffffffffffUL) {
    ks_heapdown_uint32_t(i, lsize, l);
    i --;
  }
  return;
}
}
uint32_t ks_ksmall_uint32_t(size_t n , uint32_t *arr , size_t kk ) 
{ 
  uint32_t *low ;
  uint32_t *high ;
  uint32_t *k ;
  uint32_t *ll ;
  uint32_t *hh ;
  uint32_t *mid ;
  uint32_t t ;
  uint32_t t___0 ;
  uint32_t t___1 ;
  uint32_t t___2 ;
  uint32_t t___3 ;
  uint32_t t___4 ;
  uint32_t t___5 ;

  {
  low = arr;
  high = (arr + n) - 1;
  k = arr + kk;
  while (1) {
    if ((unsigned long )high <= (unsigned long )low) {
      return (*k);
    }
    if ((unsigned long )high == (unsigned long )(low + 1)) {
      if (*high < *low) {
        t = *low;
        *low = *high;
        *high = t;
      }
      return (*k);
    }
    mid = low + (high - low) / 2L;
    if (*high < *mid) {
      t___0 = *mid;
      *mid = *high;
      *high = t___0;
    }
    if (*high < *low) {
      t___1 = *low;
      *low = *high;
      *high = t___1;
    }
    if (*low < *mid) {
      t___2 = *mid;
      *mid = *low;
      *low = t___2;
    }
    t___3 = *mid;
    *mid = *(low + 1);
    *(low + 1) = t___3;
    ll = low + 1;
    hh = high;
    while (1) {
      while (1) {
        ll ++;
        if (! (*ll < *low)) {
          break;
        }
      }
      while (1) {
        hh --;
        if (! (*low < *hh)) {
          break;
        }
      }
      if ((unsigned long )hh < (unsigned long )ll) {
        break;
      }
      t___4 = *ll;
      *ll = *hh;
      *hh = t___4;
    }
    t___5 = *low;
    *low = *hh;
    *hh = t___5;
    if ((unsigned long )hh <= (unsigned long )k) {
      low = ll;
    }
    if ((unsigned long )hh >= (unsigned long )k) {
      high = hh - 1;
    }
  }
}
}
void ks_heapdown_uint64_t(size_t i , size_t n , uint64_t *l ) 
{ 
  size_t k ;
  uint64_t tmp ;

  {
  k = i;
  tmp = *(l + i);
  while (1) {
    k = (k << 1) + 1UL;
    if (! (k < n)) {
      break;
    }
    if (k != n - 1UL) {
      if (*(l + k) < *(l + (k + 1UL))) {
        k ++;
      }
    }
    if (*(l + k) < tmp) {
      break;
    }
    *(l + i) = *(l + k);
    i = k;
  }
  *(l + i) = tmp;
  return;
}
}
void ks_heapmake_uint64_t(size_t lsize , uint64_t *l ) 
{ 
  size_t i ;

  {
  i = (lsize >> 1) - 1UL;
  while (i != 0xffffffffffffffffUL) {
    ks_heapdown_uint64_t(i, lsize, l);
    i --;
  }
  return;
}
}
uint64_t ks_ksmall_uint64_t(size_t n , uint64_t *arr , size_t kk ) 
{ 
  uint64_t *low ;
  uint64_t *high ;
  uint64_t *k ;
  uint64_t *ll ;
  uint64_t *hh ;
  uint64_t *mid ;
  uint64_t t ;
  uint64_t t___0 ;
  uint64_t t___1 ;
  uint64_t t___2 ;
  uint64_t t___3 ;
  uint64_t t___4 ;
  uint64_t t___5 ;

  {
  low = arr;
  high = (arr + n) - 1;
  k = arr + kk;
  while (1) {
    if ((unsigned long )high <= (unsigned long )low) {
      return (*k);
    }
    if ((unsigned long )high == (unsigned long )(low + 1)) {
      if (*high < *low) {
        t = *low;
        *low = *high;
        *high = t;
      }
      return (*k);
    }
    mid = low + (high - low) / 2L;
    if (*high < *mid) {
      t___0 = *mid;
      *mid = *high;
      *high = t___0;
    }
    if (*high < *low) {
      t___1 = *low;
      *low = *high;
      *high = t___1;
    }
    if (*low < *mid) {
      t___2 = *mid;
      *mid = *low;
      *low = t___2;
    }
    t___3 = *mid;
    *mid = *(low + 1);
    *(low + 1) = t___3;
    ll = low + 1;
    hh = high;
    while (1) {
      while (1) {
        ll ++;
        if (! (*ll < *low)) {
          break;
        }
      }
      while (1) {
        hh --;
        if (! (*low < *hh)) {
          break;
        }
      }
      if ((unsigned long )hh < (unsigned long )ll) {
        break;
      }
      t___4 = *ll;
      *ll = *hh;
      *hh = t___4;
    }
    t___5 = *low;
    *low = *hh;
    *hh = t___5;
    if ((unsigned long )hh <= (unsigned long )k) {
      low = ll;
    }
    if ((unsigned long )hh >= (unsigned long )k) {
      high = hh - 1;
    }
  }
}
}
#pragma merger("0","/tmp/cil-v5ucT78J.i","-g,-Wall,-O2,-Wc++-compat")
void mm_mapopt_init(mm_mapopt_t *opt ) ;
void mm_idxopt_init(mm_idxopt_t *opt ) 
{ 


  {
  memset((void *)opt, 0, sizeof(mm_idxopt_t ));
  opt->k = (short)15;
  opt->w = (short)10;
  opt->flag = (short)0;
  opt->bucket_bits = (short)14;
  opt->mini_batch_size = (int64_t )50000000;
  opt->batch_size = (uint64_t )4000000000ULL;
  return;
}
}
void mm_mapopt_init(mm_mapopt_t *opt ) 
{ 


  {
  memset((void *)opt, 0, sizeof(mm_mapopt_t ));
  opt->seed = 11;
  opt->mid_occ_frac = 2e-4f;
  opt->min_mid_occ = 10;
  opt->max_mid_occ = 1000000;
  opt->sdust_thres = 0;
  opt->q_occ_frac = 0.01f;
  opt->min_cnt = 3;
  opt->min_chain_score = 40;
  opt->bw = 500;
  opt->bw_long = 20000;
  opt->max_gap = 5000;
  opt->max_gap_ref = -1;
  opt->max_chain_skip = 25;
  opt->max_chain_iter = 5000;
  opt->rmq_inner_dist = 1000;
  opt->rmq_size_cap = 100000;
  opt->rmq_rescue_size = 1000;
  opt->rmq_rescue_ratio = 0.1f;
  opt->chain_gap_scale = 0.8f;
  opt->chain_skip_scale = 0.0f;
  opt->max_max_occ = 4095;
  opt->occ_dist = 500;
  opt->mask_level = 0.5f;
  opt->mask_len = 2147483647;
  opt->pri_ratio = 0.8f;
  opt->best_n = 5;
  opt->alt_drop = 0.15f;
  opt->a = 2;
  opt->b = 4;
  opt->q = 4;
  opt->e = 2;
  opt->q2 = 24;
  opt->e2 = 1;
  opt->sc_ambi = 1;
  opt->zdrop = 400;
  opt->zdrop_inv = 200;
  opt->end_bonus = -1;
  opt->min_dp_max = opt->min_chain_score * opt->a;
  opt->min_ksw_len = 200;
  opt->anchor_ext_len = 20;
  opt->anchor_ext_shift = 6;
  opt->max_clip_ratio = 1.0f;
  opt->mini_batch_size = (int64_t )500000000;
  opt->max_sw_mat = (int64_t )100000000;
  opt->cap_kalloc = (int64_t )1000000000;
  opt->rank_min_len = 500;
  opt->rank_frac = 0.9f;
  opt->pe_ori = 0;
  opt->pe_bonus = 33;
  return;
}
}
void mm_mapopt_update(mm_mapopt_t *opt , mm_idx_t const   *mi ) 
{ 
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
  if (opt->flag & 256L) {
    opt->flag |= 128L;
  } else
  if (opt->flag & 512L) {
    opt->flag |= 128L;
  }
  if (opt->mid_occ <= 0) {
    opt->mid_occ = mm_idx_cal_max_occ(mi, opt->mid_occ_frac);
    if (opt->mid_occ < opt->min_mid_occ) {
      opt->mid_occ = opt->min_mid_occ;
    }
    if (opt->max_mid_occ > opt->min_mid_occ) {
      if (opt->mid_occ > opt->max_mid_occ) {
        opt->mid_occ = opt->max_mid_occ;
      }
    }
  }
  if (opt->bw_long < opt->bw) {
    opt->bw_long = opt->bw;
  }
  if (mm_verbose >= 3) {
    tmp = cputime();
    tmp___0 = realtime();
    tmp___1 = realtime();
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[M::%s::%.3f*%.2f] mid_occ = %d\n",
            "mm_mapopt_update", tmp___1 - mm_realtime0, tmp / (tmp___0 - mm_realtime0),
            opt->mid_occ);
  }
  return;
}
}
void mm_mapopt_max_intron_len(mm_mapopt_t *opt , int max_intron_len ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (opt->flag & 128L) {
    if (max_intron_len > 0) {
      tmp___0 = max_intron_len;
      opt->bw_long = tmp___0;
      tmp = tmp___0;
      opt->bw = tmp;
      opt->max_gap_ref = tmp;
    }
  }
  return;
}
}
int mm_set_opt(char const   *preset , mm_idxopt_t *io , mm_mapopt_t *mo ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;

  {
  if ((unsigned long )preset == (unsigned long )((char const   *)0)) {
    mm_idxopt_init(io);
    mm_mapopt_init(mo);
  } else {
    tmp___22 = strcmp(preset, "map-ont");
    if (! (tmp___22 == 0)) {
      tmp___21 = strcmp(preset, "ava-ont");
      if (tmp___21 == 0) {
        io->flag = (short)0;
        io->k = (short)15;
        io->w = (short)5;
        mo->flag |= 8389635L;
        mo->min_chain_score = 100;
        mo->pri_ratio = 0.0f;
        mo->max_chain_skip = 25;
        tmp = 2000;
        mo->bw_long = tmp;
        mo->bw = tmp;
        mo->occ_dist = 0;
      } else {
        tmp___19 = strcmp(preset, "map10k");
        if (tmp___19 == 0) {
          io->flag = (short )((int )io->flag | 1);
          io->k = (short)19;
        } else {
          tmp___20 = strcmp(preset, "map-pb");
          if (tmp___20 == 0) {
            io->flag = (short )((int )io->flag | 1);
            io->k = (short)19;
          } else {
            tmp___18 = strcmp(preset, "ava-pb");
            if (tmp___18 == 0) {
              io->flag = (short )((int )io->flag | 1);
              io->k = (short)19;
              io->w = (short)5;
              mo->flag |= 8389635L;
              mo->min_chain_score = 100;
              mo->pri_ratio = 0.0f;
              mo->max_chain_skip = 25;
              mo->bw_long = mo->bw;
              mo->occ_dist = 0;
            } else {
              tmp___16 = strcmp(preset, "map-hifi");
              if (tmp___16 == 0) {
                goto _L___1;
              } else {
                tmp___17 = strcmp(preset, "map-ccs");
                if (tmp___17 == 0) {
                  _L___1: /* CIL Label */ 
                  io->flag = (short)0;
                  io->k = (short)19;
                  io->w = (short)19;
                  mo->max_gap = 10000;
                  mo->a = 1;
                  mo->b = 4;
                  mo->q = 6;
                  mo->q2 = 26;
                  mo->e = 2;
                  mo->e2 = 1;
                  mo->occ_dist = 500;
                  mo->min_mid_occ = 50;
                  mo->max_mid_occ = 500;
                  mo->min_dp_max = 200;
                } else {
                  tmp___15 = strncmp(preset, "asm", (size_t )3);
                  if (tmp___15 == 0) {
                    io->flag = (short)0;
                    io->k = (short)19;
                    io->w = (short)19;
                    mo->bw = 1000;
                    mo->bw_long = 100000;
                    mo->max_gap = 10000;
                    mo->flag = (int64_t )((long long )mo->flag | 2147483648LL);
                    mo->min_mid_occ = 50;
                    mo->max_mid_occ = 500;
                    mo->min_dp_max = 200;
                    mo->best_n = 50;
                    tmp___5 = strcmp(preset, "asm5");
                    if (tmp___5 == 0) {
                      mo->a = 1;
                      mo->b = 19;
                      mo->q = 39;
                      mo->q2 = 81;
                      mo->e = 3;
                      mo->e2 = 1;
                      tmp___0 = 200;
                      mo->zdrop_inv = tmp___0;
                      mo->zdrop = tmp___0;
                    } else {
                      tmp___4 = strcmp(preset, "asm10");
                      if (tmp___4 == 0) {
                        mo->a = 1;
                        mo->b = 9;
                        mo->q = 16;
                        mo->q2 = 41;
                        mo->e = 2;
                        mo->e2 = 1;
                        tmp___1 = 200;
                        mo->zdrop_inv = tmp___1;
                        mo->zdrop = tmp___1;
                      } else {
                        tmp___3 = strcmp(preset, "asm20");
                        if (tmp___3 == 0) {
                          mo->a = 1;
                          mo->b = 4;
                          mo->q = 6;
                          mo->q2 = 26;
                          mo->e = 2;
                          mo->e2 = 1;
                          tmp___2 = 200;
                          mo->zdrop_inv = tmp___2;
                          mo->zdrop = tmp___2;
                          io->w = (short)10;
                        } else {
                          return (-1);
                        }
                      }
                    }
                  } else {
                    tmp___13 = strcmp(preset, "short");
                    if (tmp___13 == 0) {
                      goto _L___0;
                    } else {
                      tmp___14 = strcmp(preset, "sr");
                      if (tmp___14 == 0) {
                        _L___0: /* CIL Label */ 
                        io->flag = (short)0;
                        io->k = (short)21;
                        io->w = (short)11;
                        mo->flag |= 4255744L;
                        mo->pe_ori = 1;
                        mo->a = 2;
                        mo->b = 8;
                        mo->q = 12;
                        mo->e = 2;
                        mo->q2 = 24;
                        mo->e2 = 1;
                        tmp___6 = 100;
                        mo->zdrop_inv = tmp___6;
                        mo->zdrop = tmp___6;
                        mo->end_bonus = 10;
                        mo->max_frag_len = 800;
                        mo->max_gap = 100;
                        tmp___7 = 100;
                        mo->bw_long = tmp___7;
                        mo->bw = tmp___7;
                        mo->pri_ratio = 0.5f;
                        mo->min_cnt = 2;
                        mo->min_chain_score = 25;
                        mo->min_dp_max = 40;
                        mo->best_n = 20;
                        mo->mid_occ = 1000;
                        mo->max_occ = 5000;
                        mo->mini_batch_size = (int64_t )50000000;
                      } else {
                        tmp___11 = strncmp(preset, "splice", (size_t )6);
                        if (tmp___11 == 0) {
                          goto _L;
                        } else {
                          tmp___12 = strcmp(preset, "cdna");
                          if (tmp___12 == 0) {
                            _L: /* CIL Label */ 
                            io->flag = (short)0;
                            io->k = (short)15;
                            io->w = (short)5;
                            mo->flag |= 263040L;
                            mo->max_sw_mat = (int64_t )0;
                            mo->max_gap = 2000;
                            tmp___9 = 200000;
                            mo->bw_long = tmp___9;
                            tmp___8 = tmp___9;
                            mo->bw = tmp___8;
                            mo->max_gap_ref = tmp___8;
                            mo->a = 1;
                            mo->b = 2;
                            mo->q = 2;
                            mo->e = 1;
                            mo->q2 = 32;
                            mo->e2 = 0;
                            mo->noncan = 9;
                            mo->junc_bonus = 9;
                            mo->zdrop = 200;
                            mo->zdrop_inv = 100;
                            tmp___10 = strcmp(preset, "splice:hq");
                            if (tmp___10 == 0) {
                              mo->junc_bonus = 5;
                              mo->b = 4;
                              mo->q = 6;
                              mo->q2 = 24;
                            }
                          } else {
                            return (-1);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return (0);
}
}
int mm_check_opt(mm_idxopt_t const   *io , mm_mapopt_t const   *mo ) 
{ 


  {
  if (mo->bw > mo->bw_long) {
    if (mm_verbose >= 1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[ERROR]\033[1;31m with \'-rNUM1,NUM2\', NUM1 (%d) can\'t be larger than NUM2 (%d)\033[0m\n",
              mo->bw, mo->bw_long);
    }
    return (-8);
  }
  if ((long long )mo->flag & 2147483648LL) {
    if (mo->flag & 4224L) {
      if (mm_verbose >= 1) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[ERROR]\033[1;31m --rmq doesn\'t work with --sr or --splice\033[0m\n");
      }
      return (-7);
    }
  }
  if (mo->split_prefix) {
    if (mo->flag & 16777280L) {
      if (mm_verbose >= 1) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[ERROR]\033[1;31m --cs or --MD doesn\'t work with --split-prefix\033[0m\n");
      }
      return (-6);
    }
  }
  if ((int const   )io->k <= 0) {
    goto _L;
  } else
  if ((int const   )io->w <= 0) {
    _L: /* CIL Label */ 
    if (mm_verbose >= 1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[ERROR]\033[1;31m -k and -w must be positive\033[0m\n");
    }
    return (-5);
  }
  if (mo->best_n < 0) {
    if (mm_verbose >= 1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[ERROR]\033[1;31m -N must be no less than 0\033[0m\n");
    }
    return (-4);
  }
  if (mo->best_n == 0) {
    if (mm_verbose >= 2) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[WARNING]\033[1;31m \'-N 0\' reduces mapping accuracy. Please use \'--secondary=no\' instead.\033[0m\n");
    }
  }
  if (mo->pri_ratio < (float const   )0.0f) {
    goto _L___0;
  } else
  if (mo->pri_ratio > (float const   )1.0f) {
    _L___0: /* CIL Label */ 
    if (mm_verbose >= 1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[ERROR]\033[1;31m -p must be within 0 and 1 (including 0 and 1)\033[0m\n");
    }
    return (-4);
  }
  if (mo->flag & 1048576L) {
    if (mo->flag & 2097152L) {
      if (mm_verbose >= 1) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[ERROR]\033[1;31m --for-only and --rev-only can\'t be applied at the same time\033[0m\n");
      }
      return (-3);
    }
  }
  if (mo->e <= 0) {
    goto _L___1;
  } else
  if (mo->q <= 0) {
    _L___1: /* CIL Label */ 
    if (mm_verbose >= 1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[ERROR]\033[1;31m -O and -E must be positive\033[0m\n");
    }
    return (-1);
  }
  if (mo->q != mo->q2) {
    goto _L___3;
  } else
  if (mo->e != mo->e2) {
    _L___3: /* CIL Label */ 
    if (mo->e > mo->e2) {
      if (! (mo->q + mo->e < mo->q2 + mo->e2)) {
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      if (mm_verbose >= 1) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[ERROR]\033[1;31m dual gap penalties violating E1>E2 and O1+E1<O2+E2\033[0m\n");
      }
      return (-2);
    }
  }
  if ((mo->q + mo->e) + (mo->q2 + mo->e2) > 127) {
    if (mm_verbose >= 1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[ERROR]\033[1;31m scoring system violating ({-O}+{-E})+({-O2}+{-E2}) <= 127\033[0m\n");
    }
    return (-1);
  }
  if (mo->zdrop < mo->zdrop_inv) {
    if (mm_verbose >= 1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[ERROR]\033[1;31m Z-drop should not be less than inversion-Z-drop\033[0m\n");
    }
    return (-5);
  }
  if (mo->flag & 16384L) {
    if (mo->flag & 8388608L) {
      if (mm_verbose >= 1) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[ERROR]\033[1;31m -X/-P and --secondary=no can\'t be applied at the same time\033[0m\n");
      }
      return (-5);
    }
  }
  if ((long long )mo->flag & 4294967296LL) {
    if (mo->flag & 8328L) {
      goto _L___4;
    } else
    if ((int const   )io->flag & 1) {
      _L___4: /* CIL Label */ 
      if (mm_verbose >= 1) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[ERROR]\033[1;31m --qstrand doesn\'t work with -a, -H, --frag or --splice\033[0m\n");
      }
      return (-5);
    }
  }
  return (0);
}
}
#pragma merger("0","/tmp/cil-oSmTgTbi.i","-g,-Wall,-O2,-Wc++-compat")
void mm_select_sub_multi(void *km , float pri_ratio , float pri1 , float pri2 , int max_gap_ref ,
                         int min_diff , int best_n , int n_segs , int const   *qlens ,
                         int *n_ , mm_reg1_t *r ) 
{ 
  int i ;
  int k ;
  int n ;
  int n_2nd ;
  int max_dist ;
  int tmp ;
  int to_keep ;
  mm_reg1_t *p ;
  mm_reg1_t *q ;
  int is_par_both ;
  int tmp___0 ;
  int is_chi_both ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if (pri_ratio > 0.0f) {
    if (*n_ > 0) {
      n = *n_;
      n_2nd = 0;
      if (n_segs == 2) {
        tmp = (*(qlens + 0) + *(qlens + 1)) + (int const   )max_gap_ref;
      } else {
        tmp = (int const   )0;
      }
      max_dist = (int )tmp;
      k = 0;
      i = k;
      while (i < n) {
        to_keep = 0;
        if ((r + i)->parent == i) {
          to_keep = 1;
        } else
        if ((r + i)->score + min_diff >= (r + (r + i)->parent)->score) {
          to_keep = 1;
        } else {
          p = r + (r + i)->parent;
          q = r + i;
          if (p->rev == q->rev) {
            if (p->rid == q->rid) {
              if (q->re - p->rs < max_dist) {
                if (p->re - q->rs < max_dist) {
                  if ((float )q->score >= (float )p->score * pri1) {
                    to_keep = 1;
                  }
                } else {
                  goto _L___2;
                }
              } else {
                goto _L___2;
              }
            } else {
              goto _L___2;
            }
          } else {
            _L___2: /* CIL Label */ 
            if (n_segs == 2) {
              if (p->qs < (int32_t )*(qlens + 0)) {
                if (p->qe > (int32_t )*(qlens + 0)) {
                  tmp___0 = 1;
                } else {
                  tmp___0 = 0;
                }
              } else {
                tmp___0 = 0;
              }
            } else {
              tmp___0 = 0;
            }
            is_par_both = tmp___0;
            if (n_segs == 2) {
              if (q->qs < (int32_t )*(qlens + 0)) {
                if (q->qe > (int32_t )*(qlens + 0)) {
                  tmp___1 = 1;
                } else {
                  tmp___1 = 0;
                }
              } else {
                tmp___1 = 0;
              }
            } else {
              tmp___1 = 0;
            }
            is_chi_both = tmp___1;
            if (is_chi_both) {
              goto _L;
            } else
            if (is_chi_both == is_par_both) {
              _L: /* CIL Label */ 
              if ((float )q->score >= (float )p->score * pri_ratio) {
                to_keep = 1;
              }
            } else
            if ((float )q->score >= (float )p->score * pri2) {
              to_keep = 1;
            }
          }
        }
        if (to_keep) {
          if ((r + i)->parent != i) {
            tmp___2 = n_2nd;
            n_2nd ++;
            if (tmp___2 >= best_n) {
              to_keep = 0;
            }
          }
        }
        if (to_keep) {
          tmp___3 = k;
          k ++;
          *(r + tmp___3) = *(r + i);
        } else
        if ((r + i)->p) {
          free((void *)(r + i)->p);
        }
        i ++;
      }
      if (k != n) {
        mm_sync_regs(km, k, r);
      }
      *n_ = k;
    }
  }
  return;
}
}
void mm_set_pe_thru(int const   *qlens , int *n_regs , mm_reg1_t **regs ) 
{ 
  int s ;
  int i ;
  int n_pri[2] ;
  int pri[2] ;
  mm_reg1_t *p ;
  mm_reg1_t *q ;
  uint32_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  n_pri[1] = 0;
  n_pri[0] = n_pri[1];
  pri[1] = -1;
  pri[0] = pri[1];
  s = 0;
  while (s < 2) {
    i = 0;
    while (i < *(n_regs + s)) {
      if ((*(regs + s) + i)->id == (*(regs + s) + i)->parent) {
        (n_pri[s]) ++;
        pri[s] = i;
      }
      i ++;
    }
    s ++;
  }
  if (n_pri[0] == 1) {
    if (n_pri[1] == 1) {
      p = *(regs + 0) + pri[0];
      q = *(regs + 1) + pri[1];
      if (p->rid == q->rid) {
        if (p->rev == q->rev) {
          tmp___0 = abs(p->rs - q->rs);
          if (tmp___0 < 3) {
            tmp___1 = abs(p->re - q->re);
            if (tmp___1 < 3) {
              if (p->qs == 0) {
                if (*(qlens + 1) - (int const   )q->qe == 0) {
                  tmp = (uint32_t )1;
                  q->pe_thru = tmp;
                  p->pe_thru = tmp;
                } else {
                  goto _L;
                }
              } else
              _L: /* CIL Label */ 
              if (q->qs == 0) {
                if (*(qlens + 0) - (int const   )p->qe == 0) {
                  tmp = (uint32_t )1;
                  q->pe_thru = tmp;
                  p->pe_thru = tmp;
                }
              }
            }
          }
        }
      }
    }
  }
  return;
}
}
void rs_insertsort_pair(pair_arr_t *beg , pair_arr_t *end ) 
{ 
  pair_arr_t *i ;
  pair_arr_t *j ;
  pair_arr_t tmp ;

  {
  i = beg + 1;
  while ((unsigned long )i < (unsigned long )end) {
    if (i->key < (i - 1)->key) {
      tmp = *i;
      j = i;
      while (1) {
        if ((unsigned long )j > (unsigned long )beg) {
          if (! (tmp.key < (j - 1)->key)) {
            break;
          }
        } else {
          break;
        }
        *j = *(j - 1);
        j --;
      }
      *j = tmp;
    }
    i ++;
  }
  return;
}
}
void rs_sort_pair(pair_arr_t *beg , pair_arr_t *end , int n_bits , int s ) 
{ 
  pair_arr_t *i ;
  int size ;
  int m ;
  rsbucket_pair_t *k ;
  rsbucket_pair_t b[1 << 8] ;
  rsbucket_pair_t *be ;
  pair_arr_t *tmp___0 ;
  rsbucket_pair_t *l ;
  pair_arr_t tmp___1 ;
  pair_arr_t swap ;
  pair_arr_t *tmp___2 ;
  pair_arr_t *tmp___3 ;

  {
  size = 1 << n_bits;
  m = size - 1;
  be = b + size;
  if (! (n_bits <= 8)) {
    __assert_fail("n_bits <= RS_MAX_BITS", "pe.c", 74U, "rs_sort_pair");
  }
  k = b;
  while ((unsigned long )k != (unsigned long )be) {
    tmp___0 = beg;
    k->e = tmp___0;
    k->b = tmp___0;
    k ++;
  }
  i = beg;
  while ((unsigned long )i != (unsigned long )end) {
    (b[(i->key >> s) & (unsigned long )m].e) ++;
    i ++;
  }
  k = b + 1;
  while ((unsigned long )k != (unsigned long )be) {
    k->e += (k - 1)->e - beg;
    k->b = (k - 1)->e;
    k ++;
  }
  k = b;
  while ((unsigned long )k != (unsigned long )be) {
    if ((unsigned long )k->b != (unsigned long )k->e) {
      l = b + (((k->b)->key >> s) & (unsigned long )m);
      if ((unsigned long )l != (unsigned long )k) {
        tmp___1 = *(k->b);
        while (1) {
          swap = tmp___1;
          tmp___1 = *(l->b);
          tmp___2 = l->b;
          (l->b) ++;
          *tmp___2 = swap;
          l = b + ((tmp___1.key >> s) & (unsigned long )m);
          if (! ((unsigned long )l != (unsigned long )k)) {
            break;
          }
        }
        tmp___3 = k->b;
        (k->b) ++;
        *tmp___3 = tmp___1;
      } else {
        (k->b) ++;
      }
    } else {
      k ++;
    }
  }
  b[0].b = beg;
  k = b + 1;
  while ((unsigned long )k != (unsigned long )be) {
    k->b = (k - 1)->e;
    k ++;
  }
  if (s) {
    if (s > n_bits) {
      s -= n_bits;
    } else {
      s = 0;
    }
    k = b;
    while ((unsigned long )k != (unsigned long )be) {
      if (k->e - k->b > 64L) {
        rs_sort_pair(k->b, k->e, n_bits, s);
      } else
      if (k->e - k->b > 1L) {
        rs_insertsort_pair(k->b, k->e);
      }
      k ++;
    }
  }
  return;
}
}
void radix_sort_pair(pair_arr_t *beg , pair_arr_t *end ) 
{ 


  {
  if (end - beg <= 64L) {
    rs_insertsort_pair(beg, end);
  } else {
    rs_sort_pair(beg, end, 8, 56);
  }
  return;
}
}
void mm_pair(void *km , int max_gap_ref , int pe_bonus , int sub_diff , int match_sc ,
             int const   *qlens , int *n_regs , mm_reg1_t **regs ) 
{ 
  int i ;
  int j ;
  int s ;
  int n ;
  int last[2] ;
  int dp_thres ;
  int segs ;
  int max_idx[2] ;
  int64_t max ;
  pair_arr_t *a ;
  struct __anonstruct_sc_941540291 sc ;
  void *tmp ;
  int max___0 ;
  void *tmp___0 ;
  mm_reg1_t *q ;
  mm_reg1_t *r ;
  int64_t score ;
  void *tmp___1 ;
  size_t tmp___2 ;
  int n_sub ;
  int mapq_pe ;
  mm_reg1_t *r___0[2] ;
  uint32_t tmp___3 ;
  mm_reg1_t *p ;
  int mapq_pe_alt ;
  float tmp___4 ;

  {
  segs = 0;
  sc.n = (size_t )0;
  sc.m = (size_t )0;
  sc.a = (uint64_t *)0;
  tmp = kmalloc(km, (unsigned long )(*(n_regs + 0) + *(n_regs + 1)) * sizeof(pair_arr_t ));
  a = (pair_arr_t *)tmp;
  n = 0;
  s = n;
  dp_thres = 0;
  while (s < 2) {
    max___0 = 0;
    i = 0;
    while (i < *(n_regs + s)) {
      (a + n)->s = s;
      (a + n)->r = *(regs + s) + i;
      (a + n)->rev = (int )((a + n)->r)->rev;
      (a + n)->key = (((uint64_t )((a + n)->r)->rid << 32) | (unsigned long )(((a + n)->r)->rs << 1)) | (unsigned long )(s ^ (a + n)->rev);
      if (max___0 > (((a + n)->r)->p)->dp_max) {
        max___0 = max___0;
      } else {
        max___0 = (((a + n)->r)->p)->dp_max;
      }
      n ++;
      segs |= 1 << s;
      i ++;
    }
    dp_thres += max___0;
    s ++;
  }
  if (segs != 3) {
    kfree(km, (void *)a);
    return;
  }
  dp_thres -= pe_bonus;
  if (dp_thres < 0) {
    dp_thres = 0;
  }
  radix_sort_pair(a, a + n);
  max = (int64_t )-1;
  max_idx[1] = -1;
  max_idx[0] = max_idx[1];
  last[1] = -1;
  last[0] = last[1];
  while (1) {
    if (sc.m < (size_t )n) {
      sc.m = (size_t )n;
      (sc.m) --;
      sc.m |= sc.m >> 1;
      sc.m |= sc.m >> 2;
      sc.m |= sc.m >> 4;
      sc.m |= sc.m >> 8;
      sc.m |= sc.m >> 16;
      (sc.m) ++;
      tmp___0 = krealloc(km, (void *)sc.a, sizeof(uint64_t ) * sc.m);
      sc.a = (uint64_t *)tmp___0;
    }
    break;
  }
  i = 0;
  while (i < n) {
    if ((a + i)->key & 1UL) {
      if (last[(a + i)->rev] < 0) {
        goto __Cont;
      }
      r = (a + i)->r;
      q = (a + last[(a + i)->rev])->r;
      if (r->rid != q->rid) {
        goto __Cont;
      } else
      if (r->rs - q->re > max_gap_ref) {
        goto __Cont;
      }
      j = last[(a + i)->rev];
      while (j >= 0) {
        if ((a + j)->rev != (a + i)->rev) {
          goto __Cont___0;
        } else
        if ((a + j)->s == (a + i)->s) {
          goto __Cont___0;
        }
        q = (a + j)->r;
        if (r->rid != q->rid) {
          break;
        } else
        if (r->rs - q->re > max_gap_ref) {
          break;
        }
        if ((r->p)->dp_max + (q->p)->dp_max < dp_thres) {
          goto __Cont___0;
        }
        score = ((int64_t )((r->p)->dp_max + (q->p)->dp_max) << 32) | (long )(r->hash + q->hash);
        if (score > max) {
          max = score;
          max_idx[(a + j)->s] = j;
          max_idx[(a + i)->s] = i;
        }
        while (1) {
          if (sc.n == sc.m) {
            if (sc.m) {
              sc.m <<= 1;
            } else {
              sc.m = (size_t )2;
            }
            tmp___1 = krealloc(km, (void *)sc.a, sizeof(uint64_t ) * sc.m);
            sc.a = (uint64_t *)tmp___1;
          }
          tmp___2 = sc.n;
          (sc.n) ++;
          *(sc.a + tmp___2) = (uint64_t )score;
          break;
        }
        __Cont___0: /* CIL Label */ 
        j --;
      }
    } else {
      last[(a + i)->rev] = i;
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  if (sc.n > 1UL) {
    radix_sort_64(sc.a, sc.a + sc.n);
  }
  if (sc.n > 0UL) {
    if (max > 0L) {
      n_sub = 0;
      r___0[0] = (a + max_idx[0])->r;
      r___0[1] = (a + max_idx[1])->r;
      tmp___3 = (uint32_t )1;
      (r___0[1])->proper_frag = tmp___3;
      (r___0[0])->proper_frag = tmp___3;
      s = 0;
      while (s < 2) {
        if ((r___0[s])->id != (r___0[s])->parent) {
          p = *(regs + s) + (r___0[s])->parent;
          i = 0;
          while (i < *(n_regs + s)) {
            if ((*(regs + s) + i)->parent == p->id) {
              (*(regs + s) + i)->parent = (r___0[s])->id;
            }
            i ++;
          }
          p->mapq = (uint32_t )0;
        }
        if (! (r___0[s])->sam_pri) {
          i = 0;
          while (i < *(n_regs + s)) {
            (*(regs + s) + i)->sam_pri = (uint32_t )0;
            i ++;
          }
          (r___0[s])->sam_pri = (uint32_t )1;
        }
        s ++;
      }
      if ((r___0[0])->mapq > (r___0[1])->mapq) {
        mapq_pe = (int )(r___0[0])->mapq;
      } else {
        mapq_pe = (int )(r___0[1])->mapq;
      }
      i = 0;
      while (i < (int )sc.n) {
        if ((*(sc.a + i) >> 32) + (uint64_t )sub_diff >= (uint64_t )max >> 32) {
          n_sub ++;
        }
        i ++;
      }
      if (sc.n > 1UL) {
        tmp___4 = logf((float )n_sub);
        mapq_pe_alt = (int )((6.02f * (float )((uint64_t )(max >> 32) - (*(sc.a + (sc.n - 2UL)) >> 32))) / (float )match_sc - 4.343f * tmp___4);
        if (mapq_pe < mapq_pe_alt) {
          mapq_pe = mapq_pe;
        } else {
          mapq_pe = mapq_pe_alt;
        }
      }
      if ((r___0[0])->mapq < (uint32_t )mapq_pe) {
        (r___0[0])->mapq = (uint32_t )((int )((.2f * (float )(r___0[0])->mapq + .8f * (float )mapq_pe) + .499f));
      }
      if ((r___0[1])->mapq < (uint32_t )mapq_pe) {
        (r___0[1])->mapq = (uint32_t )((int )((.2f * (float )(r___0[1])->mapq + .8f * (float )mapq_pe) + .499f));
      }
      if (sc.n == 1UL) {
        if ((r___0[0])->mapq < 2U) {
          (r___0[0])->mapq = (uint32_t )2;
        }
        if ((r___0[1])->mapq < 2U) {
          (r___0[1])->mapq = (uint32_t )2;
        }
      } else
      if ((uint64_t )max >> 32 > *(sc.a + (sc.n - 2UL)) >> 32) {
        if ((r___0[0])->mapq < 1U) {
          (r___0[0])->mapq = (uint32_t )1;
        }
        if ((r___0[1])->mapq < 1U) {
          (r___0[1])->mapq = (uint32_t )1;
        }
      }
    }
  }
  kfree(km, (void *)a);
  kfree(km, (void *)sc.a);
  mm_set_pe_thru(qlens, n_regs, regs);
  return;
}
}
#pragma merger("0","/tmp/cil-mbfEdpeh.i","-g,-Wall,-O2,-Wc++-compat")
uint64_t *sdust(void *km , uint8_t const   *seq , int l_seq , int T , int W , int *n ) ;
__inline static kdq_int_t *kdq_init_int(void *km )  __attribute__((__unused__)) ;
__inline static kdq_int_t *kdq_init_int(void *km ) 
{ 
  kdq_int_t *q ;
  void *tmp ;
  void *tmp___0 ;

  {
  tmp = kcalloc(km, (size_t )1, sizeof(kdq_int_t ));
  q = (kdq_int_t *)tmp;
  q->bits = (uint64_t )2;
  q->mask = (uint64_t )((1ULL << q->bits) - 1ULL);
  tmp___0 = kmalloc(km, (unsigned long )(1 << q->bits) * sizeof(int ));
  q->a = (int *)tmp___0;
  q->km = km;
  return (q);
}
}
__inline static void kdq_destroy_int(kdq_int_t *q )  __attribute__((__unused__)) ;
__inline static void kdq_destroy_int(kdq_int_t *q ) 
{ 


  {
  if ((unsigned long )q == (unsigned long )((kdq_int_t *)0)) {
    return;
  }
  kfree(q->km, (void *)q->a);
  kfree(q->km, (void *)q);
  return;
}
}
__inline static int kdq_resize_int(kdq_int_t *q , int new_bits )  __attribute__((__unused__)) ;
__inline static int kdq_resize_int(kdq_int_t *q , int new_bits ) 
{ 
  size_t new_size ;
  size_t old_size ;
  int i ;
  void *tmp ;
  void *tmp___0 ;

  {
  new_size = (size_t )(1ULL << new_bits);
  old_size = (size_t )(1ULL << q->bits);
  if (new_size < q->count) {
    i = 0;
    while (i < 64) {
      if (1ULL << i > (unsigned long long )q->count) {
        break;
      }
      i ++;
    }
    new_bits = i;
    new_size = (size_t )(1ULL << new_bits);
  }
  if ((uint64_t )new_bits == q->bits) {
    return ((int )q->bits);
  }
  if ((uint64_t )new_bits > q->bits) {
    tmp = krealloc(q->km, (void *)q->a, (size_t )((1ULL << new_bits) * (unsigned long long )sizeof(int )));
    q->a = (int *)tmp;
  }
  if (q->front + q->count <= old_size) {
    if (q->front + q->count > new_size) {
      memmove((void *)q->a, (void const   *)(q->a + new_size), ((q->front + q->count) - new_size) * sizeof(int ));
    }
  } else {
    memmove((void *)(q->a + (new_size - (old_size - q->front))), (void const   *)(q->a + q->front),
            (old_size - q->front) * sizeof(int ));
    q->front = new_size - (old_size - q->front);
  }
  q->bits = (uint64_t )new_bits;
  q->mask = (uint64_t )((1ULL << q->bits) - 1ULL);
  if ((uint64_t )new_bits < q->bits) {
    tmp___0 = krealloc(q->km, (void *)q->a, (size_t )((1ULL << new_bits) * (unsigned long long )sizeof(int )));
    q->a = (int *)tmp___0;
  }
  return ((int )q->bits);
}
}
__inline static void kdq_push_int(kdq_int_t *q , int v )  __attribute__((__unused__)) ;
__inline static void kdq_push_int(kdq_int_t *q , int v ) 
{ 
  uint64_t tmp ;

  {
  if ((unsigned long long )q->count == 1ULL << q->bits) {
    kdq_resize_int(q, (int )(q->bits + 1UL));
  }
  tmp = q->count;
  (q->count) ++;
  *(q->a + ((tmp + q->front) & q->mask)) = v;
  return;
}
}
__inline static int *kdq_shift_int(kdq_int_t *q )  __attribute__((__unused__)) ;
__inline static int *kdq_shift_int(kdq_int_t *q ) 
{ 
  int *d ;
  uint64_t tmp ;

  {
  d = (int *)0;
  if (q->count == 0UL) {
    return ((int *)0);
  }
  tmp = q->front;
  (q->front) ++;
  d = q->a + tmp;
  q->front &= q->mask;
  (q->count) --;
  return (d);
}
}
sdust_buf_t *sdust_buf_init(void *km ) 
{ 
  sdust_buf_t *buf ;
  void *tmp ;

  {
  tmp = kcalloc(km, (size_t )1, sizeof(sdust_buf_t ));
  buf = (sdust_buf_t *)tmp;
  buf->km = km;
  buf->w = kdq_init_int(buf->km);
  kdq_resize_int(buf->w, 8);
  return (buf);
}
}
void sdust_buf_destroy(sdust_buf_t *buf ) 
{ 


  {
  if ((unsigned long )buf == (unsigned long )((sdust_buf_t *)0)) {
    return;
  }
  kdq_destroy_int(buf->w);
  kfree(buf->km, (void *)buf->P.a);
  kfree(buf->km, (void *)buf->res.a);
  kfree(buf->km, (void *)buf);
  return;
}
}
__inline static void shift_window(int t , kdq_int_t *w , int T , int W , int *L ,
                                  int *rw , int *rv , int *cw , int *cv ) 
{ 
  int s ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if ((int )w->count >= (W - 3) + 1) {
    tmp = kdq_shift_int(w);
    s = *tmp;
    (*(cw + s)) --;
    *rw -= *(cw + s);
    if (*L > (int )w->count) {
      (*L) --;
      (*(cv + s)) --;
      *rv -= *(cv + s);
    }
  }
  kdq_push_int(w, t);
  (*L) ++;
  tmp___0 = *(cw + t);
  (*(cw + t)) ++;
  *rw += tmp___0;
  tmp___1 = *(cv + t);
  (*(cv + t)) ++;
  *rv += tmp___1;
  if (*(cv + t) * 10 > T << 1) {
    while (1) {
      s = *(w->a + ((w->front + (w->count - (uint64_t )*L)) & w->mask));
      (*(cv + s)) --;
      *rv -= *(cv + s);
      (*L) --;
      if (! (s != t)) {
        break;
      }
    }
  }
  return;
}
}
__inline static void save_masked_regions(void *km , uint64_v *res , perf_intv_v *P ,
                                         int start ) 
{ 
  int i ;
  int saved ;
  perf_intv_t *p ;
  int s ;
  int f ;
  int tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
  saved = 0;
  if (P->n == 0UL) {
    return;
  } else
  if ((P->a + (P->n - 1UL))->start >= start) {
    return;
  }
  p = P->a + (P->n - 1UL);
  if (res->n) {
    s = (int )(*(res->a + (res->n - 1UL)) >> 32);
    f = (int )((uint32_t )*(res->a + (res->n - 1UL)));
    if (p->start <= f) {
      saved = 1;
      if (f > p->finish) {
        tmp = f;
      } else {
        tmp = p->finish;
      }
      *(res->a + (res->n - 1UL)) = ((uint64_t )s << 32) | (unsigned long )tmp;
    }
  }
  if (! saved) {
    while (1) {
      if (res->n == res->m) {
        if (res->m) {
          res->m <<= 1;
        } else {
          res->m = (size_t )2;
        }
        tmp___0 = krealloc(km, (void *)res->a, sizeof(uint64_t ) * res->m);
        res->a = (uint64_t *)tmp___0;
      }
      tmp___1 = res->n;
      (res->n) ++;
      *(res->a + tmp___1) = ((uint64_t )p->start << 32) | (unsigned long )p->finish;
      break;
    }
  }
  i = (int )(P->n - 1UL);
  while (1) {
    if (i >= 0) {
      if (! ((P->a + i)->start < start)) {
        break;
      }
    } else {
      break;
    }
    i --;
  }
  P->n = (size_t )(i + 1);
  return;
}
}
static void find_perfect(void *km , perf_intv_v *P , kdq_int_t const   *w , int T ,
                         int start , int L , int rv , int const   *cv ) 
{ 
  int c[1 << (3 << 1)] ;
  int r ;
  int i ;
  int max_r ;
  int max_l ;
  int j ;
  int t ;
  int new_r ;
  int new_l ;
  int tmp ;
  perf_intv_t *p ;
  void *tmp___0 ;

  {
  r = rv;
  max_r = 0;
  max_l = 0;
  memcpy((void * __restrict  )(c), (void const   * __restrict  )cv, (unsigned long )(1 << (3 << 1)) * sizeof(int ));
  i = (int )(((long )w->count - (long )L) - 1L);
  while (i >= 0) {
    t = *(w->a + ((w->front + (uint64_t const   )i) & w->mask));
    tmp = c[t];
    (c[t]) ++;
    r += tmp;
    new_r = r;
    new_l = (int )((w->count - (uint64_t const   )i) - 1UL);
    if (new_r * 10 > T * new_l) {
      j = 0;
      while (1) {
        if (j < (int )P->n) {
          if (! ((P->a + j)->start >= i + start)) {
            break;
          }
        } else {
          break;
        }
        p = P->a + j;
        if (max_r == 0) {
          max_r = p->r;
          max_l = p->l;
        } else
        if (p->r * max_l > max_r * p->l) {
          max_r = p->r;
          max_l = p->l;
        }
        j ++;
      }
      if (max_r == 0) {
        goto _L;
      } else
      if (new_r * max_l >= max_r * new_l) {
        _L: /* CIL Label */ 
        max_r = new_r;
        max_l = new_l;
        if (P->n == P->m) {
          while (1) {
            if (P->m < P->n + 1UL) {
              P->m = P->n + 1UL;
              (P->m) --;
              P->m |= P->m >> 1;
              P->m |= P->m >> 2;
              P->m |= P->m >> 4;
              P->m |= P->m >> 8;
              P->m |= P->m >> 16;
              (P->m) ++;
              tmp___0 = krealloc(km, (void *)P->a, sizeof(perf_intv_t ) * P->m);
              P->a = (perf_intv_t *)tmp___0;
            }
            break;
          }
        }
        memmove((void *)(P->a + (j + 1)), (void const   *)(P->a + j), (P->n - (size_t )j) * sizeof(perf_intv_t ));
        (P->n) ++;
        (P->a + j)->start = i + start;
        (P->a + j)->finish = (int )((w->count + 2UL) + (uint64_t const   )start);
        (P->a + j)->r = new_r;
        (P->a + j)->l = new_l;
      }
    }
    i --;
  }
  return;
}
}
uint64_t const   *sdust_core(uint8_t const   *seq , int l_seq , int T , int W , int *n ,
                             sdust_buf_t *buf ) 
{ 
  int rv ;
  int rw ;
  int L ;
  int cv[1 << (3 << 1)] ;
  int cw[1 << (3 << 1)] ;
  int i ;
  int start ;
  int l ;
  unsigned int t ;
  size_t tmp ;
  uint64_t tmp___0 ;
  size_t tmp___1 ;
  int b ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  rv = 0;
  rw = 0;
  L = 0;
  tmp = (size_t )0;
  buf->res.n = tmp;
  buf->P.n = tmp;
  tmp___0 = (uint64_t )0;
  (buf->w)->count = tmp___0;
  (buf->w)->front = tmp___0;
  memset((void *)(cv), 0, (unsigned long )(1 << (3 << 1)) * sizeof(int ));
  memset((void *)(cw), 0, (unsigned long )(1 << (3 << 1)) * sizeof(int ));
  if (l_seq < 0) {
    tmp___1 = strlen((char const   *)seq);
    l_seq = (int )tmp___1;
  }
  t = 0U;
  l = (int )t;
  i = l;
  while (i <= l_seq) {
    if (i < l_seq) {
      tmp___2 = (int )seq_nt4_table[*(seq + i)];
    } else {
      tmp___2 = 4;
    }
    b = tmp___2;
    if (b < 4) {
      l ++;
      t = ((t << 2) | (unsigned int )b) & (unsigned int )((1 << (3 << 1)) - 1);
      if (l >= 3) {
        if (l - W > 0) {
          tmp___3 = l - W;
        } else {
          tmp___3 = 0;
        }
        start = tmp___3 + ((i + 1) - l);
        save_masked_regions(buf->km, & buf->res, & buf->P, start);
        shift_window((int )t, buf->w, T, W, & L, & rw, & rv, cw, cv);
        if (rw * 10 > L * T) {
          find_perfect(buf->km, & buf->P, (kdq_int_t const   *)buf->w, T, start, L,
                       rv, (int const   *)(cv));
        }
      }
    } else {
      if ((l - W) + 1 > 0) {
        tmp___4 = (l - W) + 1;
      } else {
        tmp___4 = 0;
      }
      start = tmp___4 + ((i + 1) - l);
      while (buf->P.n) {
        tmp___5 = start;
        start ++;
        save_masked_regions(buf->km, & buf->res, & buf->P, tmp___5);
      }
      t = 0U;
      l = (int )t;
    }
    i ++;
  }
  *n = (int )buf->res.n;
  return ((uint64_t const   *)buf->res.a);
}
}
uint64_t *sdust(void *km , uint8_t const   *seq , int l_seq , int T , int W , int *n ) 
{ 
  uint64_t *ret ;
  sdust_buf_t *buf ;
  uint64_t const   *tmp ;

  {
  buf = sdust_buf_init(km);
  tmp = sdust_core(seq, l_seq, T, W, n, buf);
  ret = (uint64_t *)tmp;
  buf->res.a = (uint64_t *)0;
  sdust_buf_destroy(buf);
  return (ret);
}
}
#pragma merger("0","/tmp/cil-I9if05J1.i","-g,-Wall,-O2,-Wc++-compat")
void mm_seed_mz_flt(void *km , mm128_v *mv , int32_t q_occ_max , float q_occ_frac ) 
{ 
  mm128_t *a ;
  size_t i ;
  size_t j ;
  size_t st ;
  void *tmp ;
  int32_t cnt ;
  size_t tmp___0 ;

  {
  if (mv->n <= (size_t )q_occ_max) {
    return;
  } else
  if (q_occ_frac <= 0.0f) {
    return;
  } else
  if (q_occ_max <= 0) {
    return;
  }
  tmp = kmalloc(km, mv->n * sizeof(*a));
  a = (mm128_t *)tmp;
  i = (size_t )0;
  while (i < mv->n) {
    (a + i)->x = (mv->a + i)->x;
    (a + i)->y = i;
    i ++;
  }
  radix_sort_128x(a, a + mv->n);
  st = (size_t )0;
  i = (size_t )1;
  while (i <= mv->n) {
    if (i == mv->n) {
      goto _L;
    } else
    if ((a + i)->x != (a + st)->x) {
      _L: /* CIL Label */ 
      cnt = (int32_t )(i - st);
      if (cnt > q_occ_max) {
        if ((float )cnt > (float )mv->n * q_occ_frac) {
          j = st;
          while (j < i) {
            (mv->a + (a + j)->y)->x = (uint64_t )0;
            j ++;
          }
        }
      }
      st = i;
    }
    i ++;
  }
  kfree(km, (void *)a);
  j = (size_t )0;
  i = j;
  while (i < mv->n) {
    if ((mv->a + i)->x != 0UL) {
      tmp___0 = j;
      j ++;
      *(mv->a + tmp___0) = *(mv->a + i);
    }
    i ++;
  }
  mv->n = j;
  return;
}
}
mm_seed_t *mm_seed_collect_all(void *km , mm_idx_t const   *mi , mm128_v const   *mv ,
                               int32_t *n_m_ ) 
{ 
  mm_seed_t *m ;
  size_t i ;
  int32_t k ;
  void *tmp ;
  uint64_t const   *cr ;
  mm_seed_t *q ;
  mm128_t *p ;
  uint32_t q_pos ;
  uint32_t q_span ;
  int t ;
  int32_t tmp___0 ;
  uint32_t tmp___1 ;

  {
  tmp = kmalloc(km, (size_t )(mv->n * (size_t const   )sizeof(mm_seed_t )));
  m = (mm_seed_t *)tmp;
  k = 0;
  i = (size_t )k;
  while (i < (size_t )mv->n) {
    p = mv->a + i;
    q_pos = (uint32_t )p->y;
    q_span = (uint32_t )(p->x & 255UL);
    cr = mm_idx_get(mi, p->x >> 8, & t);
    if (t == 0) {
      goto __Cont;
    }
    tmp___0 = k;
    k ++;
    q = m + tmp___0;
    q->q_pos = q_pos;
    q->q_span = q_span;
    q->cr = cr;
    q->n = (uint32_t )t;
    q->seg_id = (uint32_t )(p->y >> 32);
    tmp___1 = (uint32_t )0;
    q->flt = tmp___1;
    q->is_tandem = tmp___1;
    if (i > 0UL) {
      if (p->x >> 8 == (mv->a + (i - 1UL))->x >> 8) {
        q->is_tandem = (uint32_t )1;
      }
    }
    if (i < (size_t )(mv->n - 1UL)) {
      if (p->x >> 8 == (mv->a + (i + 1UL))->x >> 8) {
        q->is_tandem = (uint32_t )1;
      }
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  *n_m_ = k;
  return (m);
}
}
void mm_seed_select(int32_t n , mm_seed_t *a , int len , int max_occ , int max_max_occ ,
                    int dist ) 
{ 
  int32_t i ;
  int32_t last0 ;
  int32_t m ;
  uint64_t b[128] ;
  int32_t ps ;
  uint32_t tmp ;
  int32_t pe ;
  uint32_t tmp___0 ;
  int32_t j ;
  int32_t k ;
  int32_t st ;
  int32_t en ;
  int32_t max_high_occ ;

  {
  if (n == 0) {
    return;
  } else
  if (n == 1) {
    return;
  }
  m = 0;
  i = m;
  while (i < n) {
    if ((a + i)->n > (uint32_t )max_occ) {
      m ++;
    }
    i ++;
  }
  if (m == 0) {
    return;
  }
  i = 0;
  last0 = -1;
  while (i <= n) {
    if (i == n) {
      goto _L;
    } else
    if ((a + i)->n <= (uint32_t )max_occ) {
      _L: /* CIL Label */ 
      if (i - last0 > 1) {
        if (last0 < 0) {
          tmp = (uint32_t )0;
        } else {
          tmp = (a + last0)->q_pos >> 1;
        }
        ps = (int32_t )tmp;
        if (i == n) {
          tmp___0 = (uint32_t )len;
        } else {
          tmp___0 = (a + i)->q_pos >> 1;
        }
        pe = (int32_t )tmp___0;
        st = last0 + 1;
        en = i;
        max_high_occ = (int32_t )((double )(pe - ps) / (double )dist + .499);
        if (max_high_occ > 0) {
          if (max_high_occ > 128) {
            max_high_occ = 128;
          }
          j = st;
          k = 0;
          while (1) {
            if (j < en) {
              if (! (k < max_high_occ)) {
                break;
              }
            } else {
              break;
            }
            b[k] = ((uint64_t )(a + j)->n << 32) | (unsigned long )j;
            j ++;
            k ++;
          }
          ks_heapmake_uint64_t((size_t )k, b);
          while (j < en) {
            if ((a + j)->n < (uint32_t )((int32_t )(b[0] >> 32))) {
              b[0] = ((uint64_t )(a + j)->n << 32) | (unsigned long )j;
              ks_heapdown_uint64_t((size_t )0, (size_t )k, b);
            }
            j ++;
          }
          j = 0;
          while (j < k) {
            (a + (uint32_t )b[j])->flt = (uint32_t )1;
            j ++;
          }
        }
        j = st;
        while (j < en) {
          (a + j)->flt ^= 1U;
          j ++;
        }
        j = st;
        while (j < en) {
          if ((a + j)->n > (uint32_t )max_max_occ) {
            (a + j)->flt = (uint32_t )1;
          }
          j ++;
        }
      }
      last0 = i;
    }
    i ++;
  }
  return;
}
}
mm_seed_t *mm_collect_matches(void *km , int *_n_m , int qlen , int max_occ , int max_max_occ ,
                              int dist , mm_idx_t const   *mi , mm128_v const   *mv ,
                              int64_t *n_a , int *rep_len , int *n_mini_pos , uint64_t **mini_pos ) 
{ 
  int rep_st ;
  int rep_en ;
  int n_m ;
  int n_m0 ;
  size_t i ;
  mm_seed_t *m ;
  void *tmp ;
  mm_seed_t *q ;
  int en ;
  int st ;
  int tmp___0 ;
  int tmp___1 ;

  {
  rep_st = 0;
  rep_en = 0;
  *n_mini_pos = 0;
  tmp = kmalloc(km, (size_t )(mv->n * (size_t const   )sizeof(uint64_t )));
  *mini_pos = (uint64_t *)tmp;
  m = mm_seed_collect_all(km, mi, mv, & n_m0);
  if (dist > 0) {
    if (max_max_occ > max_occ) {
      mm_seed_select(n_m0, m, qlen, max_occ, max_max_occ, dist);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    i = (size_t )0;
    while (i < (size_t )n_m0) {
      if ((m + i)->n > (uint32_t )max_occ) {
        (m + i)->flt = (uint32_t )1;
      }
      i ++;
    }
  }
  i = (size_t )0;
  n_m = 0;
  *rep_len = 0;
  *n_a = (int64_t )0;
  while (i < (size_t )n_m0) {
    q = m + i;
    if (q->flt) {
      en = (int )((q->q_pos >> 1) + 1U);
      st = (int )((uint32_t )en - q->q_span);
      if (st > rep_en) {
        *rep_len += rep_en - rep_st;
        rep_st = st;
        rep_en = en;
      } else {
        rep_en = en;
      }
    } else {
      *n_a += (int64_t )q->n;
      tmp___0 = *n_mini_pos;
      (*n_mini_pos) ++;
      *(*mini_pos + tmp___0) = ((uint64_t )q->q_span << 32) | (unsigned long )(q->q_pos >> 1);
      tmp___1 = n_m;
      n_m ++;
      *(m + tmp___1) = *q;
    }
    i ++;
  }
  *rep_len += rep_en - rep_st;
  *_n_m = n_m;
  return (m);
}
}
#pragma merger("0","/tmp/cil-CtHmYjru.i","-g,-Wall,-O2,-Wc++-compat")
unsigned char seq_nt4_table[256]  = 
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)0,      (unsigned char)4,      (unsigned char)1, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)2, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)3,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)0,      (unsigned char)4,      (unsigned char)1, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)2, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)3,      (unsigned char)3,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4, 
        (unsigned char)4,      (unsigned char)4,      (unsigned char)4,      (unsigned char)4};
__inline static uint64_t hash64___0(uint64_t key , uint64_t mask ) 
{ 


  {
  key = (~ key + (key << 21)) & mask;
  key ^= key >> 24;
  key = ((key + (key << 3)) + (key << 8)) & mask;
  key ^= key >> 14;
  key = ((key + (key << 2)) + (key << 4)) & mask;
  key ^= key >> 28;
  key = (key + (key << 31)) & mask;
  return (key);
}
}
__inline static void tq_push(tiny_queue_t *q , int x ) 
{ 
  int tmp ;

  {
  tmp = q->count;
  (q->count) ++;
  q->a[(tmp + q->front) & 31] = x;
  return;
}
}
__inline static int tq_shift(tiny_queue_t *q ) 
{ 
  int x ;
  int tmp ;

  {
  if (q->count == 0) {
    return (-1);
  }
  tmp = q->front;
  (q->front) ++;
  x = q->a[tmp];
  q->front &= 31;
  (q->count) --;
  return (x);
}
}
void mm_sketch(void *km , char const   *str , int len , int w , int k , uint32_t rid ,
               int is_hpc , mm128_v *p ) 
{ 
  uint64_t shift1 ;
  uint64_t mask ;
  uint64_t kmer[2] ;
  int i ;
  int j ;
  int l ;
  int buf_pos ;
  int min_pos ;
  int kmer_span ;
  mm128_t buf[256] ;
  mm128_t min ;
  tiny_queue_t tq ;
  void *tmp___0 ;
  int c ;
  mm128_t info ;
  int z ;
  int skip_len ;
  int tmp___1 ;
  uint64_t tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  size_t tmp___14 ;
  void *tmp___15 ;
  size_t tmp___16 ;

  {
  shift1 = (uint64_t )(2 * (k - 1));
  mask = (uint64_t )((1ULL << 2 * k) - 1ULL);
  kmer[0] = (uint64_t )0;
  kmer[1] = (uint64_t )0;
  kmer_span = 0;
  min.x = 18446744073709551615;
  min.y = 18446744073709551615;
  if (len > 0) {
    if (w > 0) {
      if (w < 256) {
        if (k > 0) {
          if (! (k <= 28)) {
            __assert_fail("len > 0 && (w > 0 && w < 256) && (k > 0 && k <= 28)", "sketch.c",
                          84U, "mm_sketch");
          }
        } else {
          __assert_fail("len > 0 && (w > 0 && w < 256) && (k > 0 && k <= 28)", "sketch.c",
                        84U, "mm_sketch");
        }
      } else {
        __assert_fail("len > 0 && (w > 0 && w < 256) && (k > 0 && k <= 28)", "sketch.c",
                      84U, "mm_sketch");
      }
    } else {
      __assert_fail("len > 0 && (w > 0 && w < 256) && (k > 0 && k <= 28)", "sketch.c",
                    84U, "mm_sketch");
    }
  } else {
    __assert_fail("len > 0 && (w > 0 && w < 256) && (k > 0 && k <= 28)", "sketch.c",
                  84U, "mm_sketch");
  }
  memset((void *)(buf), 255, (size_t )(w * 16));
  memset((void *)(& tq), 0, sizeof(tiny_queue_t ));
  while (1) {
    if (p->m < p->n + (size_t )(len / w)) {
      p->m = p->n + (size_t )(len / w);
      (p->m) --;
      p->m |= p->m >> 1;
      p->m |= p->m >> 2;
      p->m |= p->m >> 4;
      p->m |= p->m >> 8;
      p->m |= p->m >> 16;
      (p->m) ++;
      tmp___0 = krealloc(km, (void *)p->a, sizeof(mm128_t ) * p->m);
      p->a = (mm128_t *)tmp___0;
    }
    break;
  }
  min_pos = 0;
  buf_pos = min_pos;
  l = buf_pos;
  i = l;
  while (i < len) {
    c = (int )seq_nt4_table[(uint8_t )*(str + i)];
    info.x = 18446744073709551615;
    info.y = 18446744073709551615;
    if (c < 4) {
      if (is_hpc) {
        skip_len = 1;
        if (i + 1 < len) {
          if ((int )seq_nt4_table[(uint8_t )*(str + (i + 1))] == c) {
            skip_len = 2;
            while (i + skip_len < len) {
              if ((int )seq_nt4_table[(uint8_t )*(str + (i + skip_len))] != c) {
                break;
              }
              skip_len ++;
            }
            i += skip_len - 1;
          }
        }
        tq_push(& tq, skip_len);
        kmer_span += skip_len;
        if (tq.count > k) {
          tmp___1 = tq_shift(& tq);
          kmer_span -= tmp___1;
        }
      } else
      if (l + 1 < k) {
        kmer_span = l + 1;
      } else {
        kmer_span = k;
      }
      kmer[0] = ((kmer[0] << 2) | (unsigned long )c) & mask;
      kmer[1] = (uint64_t )((unsigned long long )(kmer[1] >> 2) | ((3ULL ^ (unsigned long long )c) << shift1));
      if (kmer[0] == kmer[1]) {
        goto __Cont;
      }
      if (kmer[0] < kmer[1]) {
        z = 0;
      } else {
        z = 1;
      }
      l ++;
      if (l >= k) {
        if (kmer_span < 256) {
          tmp___2 = hash64___0(kmer[z], mask);
          info.x = (tmp___2 << 8) | (unsigned long )kmer_span;
          info.y = (((uint64_t )rid << 32) | (unsigned long )((uint32_t )i << 1)) | (unsigned long )z;
        }
      }
    } else {
      l = 0;
      tq.front = 0;
      tq.count = tq.front;
      kmer_span = 0;
    }
    buf[buf_pos] = info;
    if (l == (w + k) - 1) {
      if (min.x != 18446744073709551615) {
        j = buf_pos + 1;
        while (j < w) {
          if (min.x == buf[j].x) {
            if (buf[j].y != min.y) {
              while (1) {
                if (p->n == p->m) {
                  if (p->m) {
                    p->m <<= 1;
                  } else {
                    p->m = (size_t )2;
                  }
                  tmp___3 = krealloc(km, (void *)p->a, sizeof(mm128_t ) * p->m);
                  p->a = (mm128_t *)tmp___3;
                }
                tmp___4 = p->n;
                (p->n) ++;
                *(p->a + tmp___4) = buf[j];
                break;
              }
            }
          }
          j ++;
        }
        j = 0;
        while (j < buf_pos) {
          if (min.x == buf[j].x) {
            if (buf[j].y != min.y) {
              while (1) {
                if (p->n == p->m) {
                  if (p->m) {
                    p->m <<= 1;
                  } else {
                    p->m = (size_t )2;
                  }
                  tmp___5 = krealloc(km, (void *)p->a, sizeof(mm128_t ) * p->m);
                  p->a = (mm128_t *)tmp___5;
                }
                tmp___6 = p->n;
                (p->n) ++;
                *(p->a + tmp___6) = buf[j];
                break;
              }
            }
          }
          j ++;
        }
      }
    }
    if (info.x <= min.x) {
      if (l >= w + k) {
        if (min.x != 18446744073709551615) {
          while (1) {
            if (p->n == p->m) {
              if (p->m) {
                p->m <<= 1;
              } else {
                p->m = (size_t )2;
              }
              tmp___7 = krealloc(km, (void *)p->a, sizeof(mm128_t ) * p->m);
              p->a = (mm128_t *)tmp___7;
            }
            tmp___8 = p->n;
            (p->n) ++;
            *(p->a + tmp___8) = min;
            break;
          }
        }
      }
      min = info;
      min_pos = buf_pos;
    } else
    if (buf_pos == min_pos) {
      if (l >= (w + k) - 1) {
        if (min.x != 18446744073709551615) {
          while (1) {
            if (p->n == p->m) {
              if (p->m) {
                p->m <<= 1;
              } else {
                p->m = (size_t )2;
              }
              tmp___9 = krealloc(km, (void *)p->a, sizeof(mm128_t ) * p->m);
              p->a = (mm128_t *)tmp___9;
            }
            tmp___10 = p->n;
            (p->n) ++;
            *(p->a + tmp___10) = min;
            break;
          }
        }
      }
      j = buf_pos + 1;
      min.x = 18446744073709551615;
      while (j < w) {
        if (min.x >= buf[j].x) {
          min = buf[j];
          min_pos = j;
        }
        j ++;
      }
      j = 0;
      while (j <= buf_pos) {
        if (min.x >= buf[j].x) {
          min = buf[j];
          min_pos = j;
        }
        j ++;
      }
      if (l >= (w + k) - 1) {
        if (min.x != 18446744073709551615) {
          j = buf_pos + 1;
          while (j < w) {
            if (min.x == buf[j].x) {
              if (min.y != buf[j].y) {
                while (1) {
                  if (p->n == p->m) {
                    if (p->m) {
                      p->m <<= 1;
                    } else {
                      p->m = (size_t )2;
                    }
                    tmp___11 = krealloc(km, (void *)p->a, sizeof(mm128_t ) * p->m);
                    p->a = (mm128_t *)tmp___11;
                  }
                  tmp___12 = p->n;
                  (p->n) ++;
                  *(p->a + tmp___12) = buf[j];
                  break;
                }
              }
            }
            j ++;
          }
          j = 0;
          while (j <= buf_pos) {
            if (min.x == buf[j].x) {
              if (min.y != buf[j].y) {
                while (1) {
                  if (p->n == p->m) {
                    if (p->m) {
                      p->m <<= 1;
                    } else {
                      p->m = (size_t )2;
                    }
                    tmp___13 = krealloc(km, (void *)p->a, sizeof(mm128_t ) * p->m);
                    p->a = (mm128_t *)tmp___13;
                  }
                  tmp___14 = p->n;
                  (p->n) ++;
                  *(p->a + tmp___14) = buf[j];
                  break;
                }
              }
            }
            j ++;
          }
        }
      }
    }
    buf_pos ++;
    if (buf_pos == w) {
      buf_pos = 0;
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  if (min.x != 18446744073709551615) {
    while (1) {
      if (p->n == p->m) {
        if (p->m) {
          p->m <<= 1;
        } else {
          p->m = (size_t )2;
        }
        tmp___15 = krealloc(km, (void *)p->a, sizeof(mm128_t ) * p->m);
        p->a = (mm128_t *)tmp___15;
      }
      tmp___16 = p->n;
      (p->n) ++;
      *(p->a + tmp___16) = min;
      break;
    }
  }
  return;
}
}
#pragma merger("0","/tmp/cil-ssCYuS6X.i","-g,-Wall,-O2,-Wc++-compat")
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
FILE *mm_split_init(char const   *prefix , mm_idx_t const   *mi ) 
{ 
  char *fn ;
  FILE *fp ;
  uint32_t i ;
  uint32_t k ;
  size_t tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  uint32_t l ;
  size_t tmp___3 ;

  {
  k = (uint32_t )mi->k;
  tmp = strlen(prefix);
  tmp___0 = calloc(tmp + 10UL, (size_t )1);
  fn = (char *)tmp___0;
  sprintf((char * __restrict  )fn, (char const   * __restrict  )"%s.%.4d.tmp", prefix,
          mi->index);
  fp = fopen((char const   * __restrict  )fn, (char const   * __restrict  )"wb");
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    if (mm_verbose >= 1) {
      tmp___1 = __errno_location();
      tmp___2 = strerror(*tmp___1);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[ERROR]\033[1;31m failed to write to temporary file \'%s\'\033[0m: %s\n",
              fn, tmp___2);
    }
    exit(1);
  }
  mm_err_fwrite((void const   *)(& k), (size_t )4, (size_t )1, fp);
  mm_err_fwrite((void const   *)(& mi->n_seq), (size_t )4, (size_t )1, fp);
  i = (uint32_t )0;
  while (i < (uint32_t )mi->n_seq) {
    tmp___3 = strlen((char const   *)(mi->seq + i)->name);
    l = (uint32_t )tmp___3;
    mm_err_fwrite((void const   *)(& l), (size_t )1, (size_t )4, fp);
    mm_err_fwrite((void const   *)(mi->seq + i)->name, (size_t )1, (size_t )l, fp);
    mm_err_fwrite((void const   *)(& (mi->seq + i)->len), (size_t )4, (size_t )1,
                  fp);
    i ++;
  }
  free((void *)fn);
  return (fp);
}
}
mm_idx_t *mm_split_merge_prep(char const   *prefix , int n_splits , FILE **fp , uint32_t *n_seq_part ) 
{ 
  mm_idx_t *mi ;
  char *fn ;
  int i ;
  int j ;
  size_t tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  FILE *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  uint32_t k ;
  uint32_t l ;
  void *tmp___6 ;

  {
  mi = (mm_idx_t *)0;
  if (n_splits < 1) {
    return ((mm_idx_t *)0);
  }
  tmp = strlen(prefix);
  tmp___0 = calloc(tmp + 10UL, sizeof(char ));
  fn = (char *)tmp___0;
  i = 0;
  while (i < n_splits) {
    sprintf((char * __restrict  )fn, (char const   * __restrict  )"%s.%.4d.tmp", prefix,
            i);
    tmp___3 = fopen((char const   * __restrict  )fn, (char const   * __restrict  )"rb");
    *(fp + i) = tmp___3;
    if ((unsigned long )tmp___3 == (unsigned long )((FILE *)0)) {
      if (mm_verbose >= 1) {
        tmp___1 = __errno_location();
        tmp___2 = strerror(*tmp___1);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"ERROR: failed to open temporary file \'%s\': %s\n",
                fn, tmp___2);
      }
      j = 0;
      while (j < i) {
        fclose(*(fp + j));
        j ++;
      }
      free((void *)fn);
      return ((mm_idx_t *)0);
    }
    i ++;
  }
  free((void *)fn);
  tmp___4 = calloc((size_t )1, sizeof(mm_idx_t ));
  mi = (mm_idx_t *)tmp___4;
  i = 0;
  while (i < n_splits) {
    mm_err_fread((void *)(& mi->k), (size_t )4, (size_t )1, *(fp + i));
    mm_err_fread((void *)(n_seq_part + i), (size_t )4, (size_t )1, *(fp + i));
    mi->n_seq += *(n_seq_part + i);
    i ++;
  }
  tmp___5 = calloc((size_t )mi->n_seq, sizeof(mm_idx_seq_t ));
  mi->seq = (mm_idx_seq_t *)tmp___5;
  j = 0;
  i = j;
  while (i < n_splits) {
    k = (uint32_t )0;
    while (k < *(n_seq_part + i)) {
      mm_err_fread((void *)(& l), (size_t )1, (size_t )4, *(fp + i));
      tmp___6 = calloc((size_t )(l + 1U), (size_t )1);
      (mi->seq + j)->name = (char *)tmp___6;
      mm_err_fread((void *)(mi->seq + j)->name, (size_t )1, (size_t )l, *(fp + i));
      mm_err_fread((void *)(& (mi->seq + j)->len), (size_t )4, (size_t )1, *(fp + i));
      k ++;
      j ++;
    }
    i ++;
  }
  return (mi);
}
}
void mm_split_rm_tmp(char const   *prefix , int n_splits ) 
{ 
  int i ;
  char *fn ;
  size_t tmp ;
  void *tmp___0 ;

  {
  tmp = strlen(prefix);
  tmp___0 = calloc(tmp + 10UL, sizeof(char ));
  fn = (char *)tmp___0;
  i = 0;
  while (i < n_splits) {
    sprintf((char * __restrict  )fn, (char const   * __restrict  )"%s.%.4d.tmp", prefix,
            i);
    remove((char const   *)fn);
    i ++;
  }
  free((void *)fn);
  return;
}
}
