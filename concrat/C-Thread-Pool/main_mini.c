/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

#include <pthread.h>
#include <time.h>
#include <stdlib.h>
#include <sys/prctl.h>
#include <time.h>
#include <math.h>
#include <signal.h>

struct thpool_ ;
struct bsem {
   pthread_mutex_t mutex ;
   pthread_cond_t cond ;
   int v ;
};
typedef struct bsem bsem;
struct job {
   struct job *prev ;
   void (*function)(void *arg ) ;
   void *arg ;
};
typedef struct job job;
struct jobqueue {
   pthread_mutex_t rwmutex ;
   job *front ;
   job *rear ;
   bsem *has_jobs ;
   int len ;
};
typedef struct jobqueue jobqueue;
struct thread {
   int id ;
   pthread_t pthread ;
   struct thpool_ *thpool_p ;
};
typedef struct thread thread;
struct thpool_ {
   thread **threads ;
   int volatile   num_threads_alive ;
   int volatile   num_threads_working ;
   pthread_mutex_t thcount_lock ;
   pthread_cond_t threads_all_idle ;
   jobqueue jobqueue ;
};
typedef struct thpool_ thpool_;
typedef unsigned long uintptr_t;
typedef struct thpool_ *threadpool;

struct thpool_ *thpool_init(int num_threads ) ;
int thpool_add_work(struct thpool_ *thpool_p , void (*function_p)(void * ) , void *arg_p ) ;
void thpool_wait(struct thpool_ *thpool_p ) ;
void thpool_destroy(struct thpool_ *thpool_p ) ;
int thpool_num_threads_working(struct thpool_ *thpool_p ) ;
static int volatile   threads_keepalive  ;
static int volatile   threads_on_hold  ;
static int thread_init(thpool_ *thpool_p , struct thread **thread_p , int id ) ;
static void *thread_do(struct thread *thread_p ) ;
static void thread_destroy(struct thread *thread_p ) ;
static int jobqueue_init(jobqueue *jobqueue_p ) ;
static void jobqueue_clear(jobqueue *jobqueue_p ) ;
static void jobqueue_push(jobqueue *jobqueue_p , struct job *newjob ) ;
static struct job *jobqueue_pull(jobqueue *jobqueue_p ) ;
static void jobqueue_destroy(jobqueue *jobqueue_p ) ;
static void bsem_init(struct bsem *bsem_p , int value ) ;
static void bsem_reset(struct bsem *bsem_p ) ;
static void bsem_post(struct bsem *bsem_p ) ;
static void bsem_post_all(struct bsem *bsem_p ) ;
static void bsem_wait(struct bsem *bsem_p ) ;
struct thpool_ *thpool_init(int num_threads ) 
{ 
  thpool_ *thpool_p ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int n ;

  {
  threads_on_hold = (int volatile   )0;
  threads_keepalive = (int volatile   )1;
  if (num_threads < 0) {
    num_threads = 0;
  }
  tmp = malloc(sizeof(struct thpool_ ));
  thpool_p = (struct thpool_ *)tmp;
  if ((unsigned long )thpool_p == (unsigned long )((void *)0)) {
    return ((struct thpool_ *)((void *)0));
  }
  thpool_p->num_threads_alive = (int volatile   )0;
  thpool_p->num_threads_working = (int volatile   )0;
  tmp___0 = jobqueue_init(& thpool_p->jobqueue);
  if (tmp___0 == -1) {
    free((void *)thpool_p);
    return ((struct thpool_ *)((void *)0));
  }
  tmp___1 = malloc((unsigned long )num_threads * sizeof(struct thread *));
  thpool_p->threads = (struct thread **)tmp___1;
  if ((unsigned long )thpool_p->threads == (unsigned long )((void *)0)) {
    jobqueue_destroy(& thpool_p->jobqueue);
    free((void *)thpool_p);
    return ((struct thpool_ *)((void *)0));
  }
  pthread_mutex_init(& thpool_p->thcount_lock, (pthread_mutexattr_t const   *)((void *)0));
  pthread_cond_init((pthread_cond_t * __restrict  )(& thpool_p->threads_all_idle),
                    (pthread_condattr_t const   * __restrict  )((void *)0));
  n = 0;
  while (n < num_threads) {
    thread_init(thpool_p, thpool_p->threads + n, n);
    n ++;
  }
  while (thpool_p->num_threads_alive != (int volatile   )num_threads) {

  }
  return (thpool_p);
}
}
int thpool_add_work(struct thpool_ *thpool_p , void (*function_p)(void * ) , void *arg_p ) 
{ 
  job *newjob ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct job ));
  newjob = (struct job *)tmp;
  if ((unsigned long )newjob == (unsigned long )((void *)0)) {
    return (-1);
  }
  newjob->function = function_p;
  newjob->arg = arg_p;
  jobqueue_push(& thpool_p->jobqueue, newjob);
  return (0);
}
}
void thpool_wait(struct thpool_ *thpool_p ) 
{ 


  {
  pthread_mutex_lock(& thpool_p->thcount_lock);
  while (1) {
    if (! thpool_p->jobqueue.len) {
      if (! thpool_p->num_threads_working) {
        break;
      }
    }
    pthread_cond_wait((pthread_cond_t * __restrict  )(& thpool_p->threads_all_idle),
                      (pthread_mutex_t * __restrict  )(& thpool_p->thcount_lock));
  }
  pthread_mutex_unlock(& thpool_p->thcount_lock);
  return;
}
}
void thpool_destroy(struct thpool_ *thpool_p ) 
{ 
  int volatile   threads_total ;
  double TIMEOUT ;
  time_t start ;
  time_t end ;
  double tpassed ;
  int n ;

  {
  if ((unsigned long )thpool_p == (unsigned long )((void *)0)) {
    return;
  }
  threads_total = thpool_p->num_threads_alive;
  threads_keepalive = (int volatile   )0;
  TIMEOUT = 1.0;
  tpassed = 0.0;
  time(& start);
  while (1) {
    if (tpassed < TIMEOUT) {
      if (! thpool_p->num_threads_alive) {
        break;
      }
    } else {
      break;
    }
    bsem_post_all(thpool_p->jobqueue.has_jobs);
    time(& end);
    tpassed = difftime(end, start);
  }
  while (thpool_p->num_threads_alive) {
    bsem_post_all(thpool_p->jobqueue.has_jobs);
    sleep(1U);
  }
  jobqueue_destroy(& thpool_p->jobqueue);
  n = 0;
  while (n < (int )threads_total) {
    thread_destroy(*(thpool_p->threads + n));
    n ++;
  }
  free((void *)thpool_p->threads);
  free((void *)thpool_p);
  return;
}
}

int thpool_num_threads_working(struct thpool_ *thpool_p ) 
{ 


  {
  return ((int )thpool_p->num_threads_working);
}
}
static int thread_init(thpool_ *thpool_p , struct thread **thread_p , int id ) 
{ 
  void *tmp ;

  {
  tmp = malloc(sizeof(struct thread ));
  *thread_p = (struct thread *)tmp;
  if ((unsigned long )*thread_p == (unsigned long )((void *)0)) {
    return (-1);
  }
  (*thread_p)->thpool_p = thpool_p;
  (*thread_p)->id = id;
  pthread_create((pthread_t * __restrict  )(& (*thread_p)->pthread), (pthread_attr_t const   * __restrict  )((void *)0),
                 (void *(*)(void * ))(& thread_do), (void * __restrict  )*thread_p);
  pthread_detach((*thread_p)->pthread);
  return (0);
}
}

static void *thread_do(struct thread *thread_p ) 
{ 
  char thread_name[32] ;
  unsigned int tmp ;
  thpool_ *thpool_p ;
  int tmp___0 ;
  void (*func_buff)(void * ) ;
  void *arg_buff ;
  job *job_p ;
  struct job *tmp___1 ;

  {
  thread_name[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    thread_name[tmp] = (char)0;
    tmp ++;
  }
  snprintf((char * __restrict  )(thread_name), (size_t )32, (char const   * __restrict  )"thread-pool-%d",
           thread_p->id);
  prctl(15, thread_name);
  thpool_p = thread_p->thpool_p;
  if (tmp___0 == -1) {
  }
  pthread_mutex_lock(& thpool_p->thcount_lock);
  thpool_p->num_threads_alive += (int volatile   )1;
  pthread_mutex_unlock(& thpool_p->thcount_lock);
  while (threads_keepalive) {
    bsem_wait(thpool_p->jobqueue.has_jobs);
    if (threads_keepalive) {
      pthread_mutex_lock(& thpool_p->thcount_lock);
      thpool_p->num_threads_working += (int volatile   )1;
      pthread_mutex_unlock(& thpool_p->thcount_lock);
      tmp___1 = jobqueue_pull(& thpool_p->jobqueue);
      job_p = tmp___1;
      if (job_p) {
        func_buff = job_p->function;
        arg_buff = job_p->arg;
        (*func_buff)(arg_buff);
        free((void *)job_p);
      }
      pthread_mutex_lock(& thpool_p->thcount_lock);
      thpool_p->num_threads_working -= (int volatile   )1;
      if (! thpool_p->num_threads_working) {
        pthread_cond_signal(& thpool_p->threads_all_idle);
      }
      pthread_mutex_unlock(& thpool_p->thcount_lock);
    }
  }
  pthread_mutex_lock(& thpool_p->thcount_lock);
  thpool_p->num_threads_alive -= (int volatile   )1;
  pthread_mutex_unlock(& thpool_p->thcount_lock);
  return ((void *)0);
}
}
static void thread_destroy(struct thread *thread_p ) 
{ 


  {
  free((void *)thread_p);
  return;
}
}
static int jobqueue_init(jobqueue *jobqueue_p ) 
{ 
  void *tmp ;

  {
  jobqueue_p->len = 0;
  jobqueue_p->front = (job *)((void *)0);
  jobqueue_p->rear = (job *)((void *)0);
  tmp = malloc(sizeof(struct bsem ));
  jobqueue_p->has_jobs = (struct bsem *)tmp;
  if ((unsigned long )jobqueue_p->has_jobs == (unsigned long )((void *)0)) {
    return (-1);
  }
  pthread_mutex_init(& jobqueue_p->rwmutex, (pthread_mutexattr_t const   *)((void *)0));
  bsem_init(jobqueue_p->has_jobs, 0);
  return (0);
}
}
static void jobqueue_clear(jobqueue *jobqueue_p ) 
{ 
  struct job *tmp ;

  {
  while (jobqueue_p->len) {
    tmp = jobqueue_pull(jobqueue_p);
    free((void *)tmp);
  }
  jobqueue_p->front = (job *)((void *)0);
  jobqueue_p->rear = (job *)((void *)0);
  bsem_reset(jobqueue_p->has_jobs);
  jobqueue_p->len = 0;
  return;
}
}
static void jobqueue_push(jobqueue *jobqueue_p , struct job *newjob ) 
{ 


  {
  pthread_mutex_lock(& jobqueue_p->rwmutex);
  newjob->prev = (struct job *)((void *)0);
  switch (jobqueue_p->len) {
  case 0: 
  jobqueue_p->front = newjob;
  jobqueue_p->rear = newjob;
  break;
  default: 
  (jobqueue_p->rear)->prev = newjob;
  jobqueue_p->rear = newjob;
  }
  (jobqueue_p->len) ++;
  bsem_post(jobqueue_p->has_jobs);
  pthread_mutex_unlock(& jobqueue_p->rwmutex);
  return;
}
}
static struct job *jobqueue_pull(jobqueue *jobqueue_p ) 
{ 
  job *job_p ;

  {
  pthread_mutex_lock(& jobqueue_p->rwmutex);
  job_p = jobqueue_p->front;
  switch (jobqueue_p->len) {
  case 0: 
  break;
  case 1: 
  jobqueue_p->front = (job *)((void *)0);
  jobqueue_p->rear = (job *)((void *)0);
  jobqueue_p->len = 0;
  break;
  default: 
  jobqueue_p->front = job_p->prev;
  (jobqueue_p->len) --;
  bsem_post(jobqueue_p->has_jobs);
  }
  pthread_mutex_unlock(& jobqueue_p->rwmutex);
  return (job_p);
}
}
static void jobqueue_destroy(jobqueue *jobqueue_p ) 
{ 


  {
  jobqueue_clear(jobqueue_p);
  free((void *)jobqueue_p->has_jobs);
  return;
}
}
static void bsem_init(struct bsem *bsem_p , int value ) 
{ 


  {
  if (value < 0) {
    exit(1);
  } else
  if (value > 1) {
    exit(1);
  }
  pthread_mutex_init(& bsem_p->mutex, (pthread_mutexattr_t const   *)((void *)0));
  pthread_cond_init((pthread_cond_t * __restrict  )(& bsem_p->cond), (pthread_condattr_t const   * __restrict  )((void *)0));
  bsem_p->v = value;
  return;
}
}
static void bsem_reset(struct bsem *bsem_p ) 
{ 


  {
  bsem_init(bsem_p, 0);
  return;
}
}
static void bsem_post(struct bsem *bsem_p ) 
{ 


  {
  pthread_mutex_lock(& bsem_p->mutex);
  bsem_p->v = 1;
  pthread_cond_signal(& bsem_p->cond);
  pthread_mutex_unlock(& bsem_p->mutex);
  return;
}
}
static void bsem_post_all(struct bsem *bsem_p ) 
{ 


  {
  pthread_mutex_lock(& bsem_p->mutex);
  bsem_p->v = 1;
  pthread_cond_broadcast(& bsem_p->cond);
  pthread_mutex_unlock(& bsem_p->mutex);
  return;
}
}
static void bsem_wait(struct bsem *bsem_p ) 
{ 


  {
  pthread_mutex_lock(& bsem_p->mutex);
  while (bsem_p->v != 1) {
    pthread_cond_wait((pthread_cond_t * __restrict  )(& bsem_p->cond), (pthread_mutex_t * __restrict  )(& bsem_p->mutex));
  }
  bsem_p->v = 0;
  pthread_mutex_unlock(& bsem_p->mutex);
  return;
}
}
void task(void *arg ) 
{ 
  pthread_t tmp ;

  {
  tmp = pthread_self();
  return;
}
}
int main(void) 
{ 
  threadpool thpool ;
  threadpool tmp ;
  int i ;

  {
  tmp = thpool_init(4);
  thpool = tmp;
  i = 0;
  while (i < 40) {
    thpool_add_work(thpool, & task, (void *)((uintptr_t )i));
    i ++;
  }
  thpool_wait(thpool);
  thpool_destroy(thpool);
  return (0);
}
}
