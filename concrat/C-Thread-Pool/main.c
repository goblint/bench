/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned int __uint32_t;
typedef unsigned int __uid_t;
typedef long __off_t;
typedef long __off64_t;
typedef int __pid_t;
typedef long __clock_t;
typedef long __time_t;
typedef unsigned long size_t;
struct __anonstruct___sigset_t_991265788 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___sigset_t_991265788 __sigset_t;
typedef __sigset_t sigset_t;
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
typedef union sigval __sigval_t;
struct __anonstruct__kill_244518854 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
struct __anonstruct__timer_490064738 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
struct __anonstruct__rt_619254530 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
struct __anonstruct__sigchld_284671705 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
struct __anonstruct__addr_bnd_5259977 {
   void *_lower ;
   void *_upper ;
};
union __anonunion__bounds_505112296 {
   struct __anonstruct__addr_bnd_5259977 _addr_bnd ;
   __uint32_t _pkey ;
};
struct __anonstruct__sigfault_657862099 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion__bounds_505112296 _bounds ;
};
struct __anonstruct__sigpoll_386613454 {
   long si_band ;
   int si_fd ;
};
struct __anonstruct__sigsys_44812255 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
union __anonunion__sifields_369293474 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_244518854 _kill ;
   struct __anonstruct__timer_490064738 _timer ;
   struct __anonstruct__rt_619254530 _rt ;
   struct __anonstruct__sigchld_284671705 _sigchld ;
   struct __anonstruct__sigfault_657862099 _sigfault ;
   struct __anonstruct__sigpoll_386613454 _sigpoll ;
   struct __anonstruct__sigsys_44812255 _sigsys ;
};
struct __anonstruct_siginfo_t_727121837 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion__sifields_369293474 _sifields ;
};
typedef struct __anonstruct_siginfo_t_727121837 siginfo_t;
union pthread_attr_t ;
typedef union pthread_attr_t pthread_attr_t;
union __anonunion___sigaction_handler_363639592 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
struct sigaction {
   union __anonunion___sigaction_handler_363639592 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
struct __anonstruct___wseq32_112954846 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_878880208 {
   unsigned long long __wseq ;
   struct __anonstruct___wseq32_112954846 __wseq32 ;
};
struct __anonstruct___g1_start32_1034561119 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_1034561118 {
   unsigned long long __g1_start ;
   struct __anonstruct___g1_start32_1034561119 __g1_start32 ;
};
struct __pthread_cond_s {
   union __anonunion____missing_field_name_878880208 __annonCompField1 ;
   union __anonunion____missing_field_name_1034561118 __annonCompField2 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
typedef unsigned long pthread_t;
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
union __anonunion_pthread_condattr_t_488594145 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_condattr_t_488594145 pthread_condattr_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
union __anonunion_pthread_cond_t_951761805 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
typedef union __anonunion_pthread_cond_t_951761805 pthread_cond_t;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef __time_t time_t;
struct thpool_ ;
struct bsem {
   pthread_mutex_t mutex ;
   pthread_cond_t cond ;
   int v ;
};
typedef struct bsem bsem;
struct job {
   struct job *prev ;
   void (*function)(void *arg ) ;
   void *arg ;
};
typedef struct job job;
struct jobqueue {
   pthread_mutex_t rwmutex ;
   job *front ;
   job *rear ;
   bsem *has_jobs ;
   int len ;
};
typedef struct jobqueue jobqueue;
struct thread {
   int id ;
   pthread_t pthread ;
   struct thpool_ *thpool_p ;
};
typedef struct thread thread;
struct thpool_ {
   thread **threads ;
   int volatile   num_threads_alive ;
   int volatile   num_threads_working ;
   pthread_mutex_t thcount_lock ;
   pthread_cond_t threads_all_idle ;
   jobqueue jobqueue ;
};
typedef struct thpool_ thpool_;
typedef unsigned long uintptr_t;
typedef struct thpool_ *threadpool;
#pragma merger("0","/tmp/cil-AyrgnWqJ.i","")
extern unsigned int sleep(unsigned int __seconds ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigemptyset)(sigset_t *__set ) ;
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
extern  __attribute__((__nothrow__)) int pthread_kill(pthread_t __threadid , int __signo ) ;
extern FILE *stderr ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
extern  __attribute__((__nothrow__)) double difftime(time_t __time1 , time_t __time0 )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern  __attribute__((__nothrow__)) int pthread_detach(pthread_t __th ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                                              pthread_condattr_t const   * __restrict  __cond_attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_signal)(pthread_cond_t *__cond ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_broadcast)(pthread_cond_t *__cond ) ;
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
extern  __attribute__((__nothrow__)) int prctl(int __option  , ...) ;
struct thpool_ *thpool_init(int num_threads ) ;
int thpool_add_work(struct thpool_ *thpool_p , void (*function_p)(void * ) , void *arg_p ) ;
void thpool_wait(struct thpool_ *thpool_p ) ;
void thpool_pause(struct thpool_ *thpool_p ) ;
void thpool_resume(struct thpool_ *thpool_p ) ;
void thpool_destroy(struct thpool_ *thpool_p ) ;
int thpool_num_threads_working(struct thpool_ *thpool_p ) ;
static int volatile   threads_keepalive  ;
static int volatile   threads_on_hold  ;
static int thread_init(thpool_ *thpool_p , struct thread **thread_p , int id ) ;
static void *thread_do(struct thread *thread_p ) ;
static void thread_hold(int sig_id ) ;
static void thread_destroy(struct thread *thread_p ) ;
static int jobqueue_init(jobqueue *jobqueue_p ) ;
static void jobqueue_clear(jobqueue *jobqueue_p ) ;
static void jobqueue_push(jobqueue *jobqueue_p , struct job *newjob ) ;
static struct job *jobqueue_pull(jobqueue *jobqueue_p ) ;
static void jobqueue_destroy(jobqueue *jobqueue_p ) ;
static void bsem_init(struct bsem *bsem_p , int value ) ;
static void bsem_reset(struct bsem *bsem_p ) ;
static void bsem_post(struct bsem *bsem_p ) ;
static void bsem_post_all(struct bsem *bsem_p ) ;
static void bsem_wait(struct bsem *bsem_p ) ;
struct thpool_ *thpool_init(int num_threads ) 
{ 
  thpool_ *thpool_p ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int n ;

  {
  threads_on_hold = (int volatile   )0;
  threads_keepalive = (int volatile   )1;
  if (num_threads < 0) {
    num_threads = 0;
  }
  tmp = malloc(sizeof(struct thpool_ ));
  thpool_p = (struct thpool_ *)tmp;
  if ((unsigned long )thpool_p == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"thpool_init(): Could not allocate memory for thread pool\n");
    return ((struct thpool_ *)((void *)0));
  }
  thpool_p->num_threads_alive = (int volatile   )0;
  thpool_p->num_threads_working = (int volatile   )0;
  tmp___0 = jobqueue_init(& thpool_p->jobqueue);
  if (tmp___0 == -1) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"thpool_init(): Could not allocate memory for job queue\n");
    free((void *)thpool_p);
    return ((struct thpool_ *)((void *)0));
  }
  tmp___1 = malloc((unsigned long )num_threads * sizeof(struct thread *));
  thpool_p->threads = (struct thread **)tmp___1;
  if ((unsigned long )thpool_p->threads == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"thpool_init(): Could not allocate memory for threads\n");
    jobqueue_destroy(& thpool_p->jobqueue);
    free((void *)thpool_p);
    return ((struct thpool_ *)((void *)0));
  }
  pthread_mutex_init(& thpool_p->thcount_lock, (pthread_mutexattr_t const   *)((void *)0));
  pthread_cond_init((pthread_cond_t * __restrict  )(& thpool_p->threads_all_idle),
                    (pthread_condattr_t const   * __restrict  )((void *)0));
  n = 0;
  while (n < num_threads) {
    thread_init(thpool_p, thpool_p->threads + n, n);
    n ++;
  }
  while (thpool_p->num_threads_alive != (int volatile   )num_threads) {

  }
  return (thpool_p);
}
}
int thpool_add_work(struct thpool_ *thpool_p , void (*function_p)(void * ) , void *arg_p ) 
{ 
  job *newjob ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct job ));
  newjob = (struct job *)tmp;
  if ((unsigned long )newjob == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"thpool_add_work(): Could not allocate memory for new job\n");
    return (-1);
  }
  newjob->function = function_p;
  newjob->arg = arg_p;
  jobqueue_push(& thpool_p->jobqueue, newjob);
  return (0);
}
}
void thpool_wait(struct thpool_ *thpool_p ) 
{ 


  {
  pthread_mutex_lock(& thpool_p->thcount_lock);
  while (1) {
    if (! thpool_p->jobqueue.len) {
      if (! thpool_p->num_threads_working) {
        break;
      }
    }
    pthread_cond_wait((pthread_cond_t * __restrict  )(& thpool_p->threads_all_idle),
                      (pthread_mutex_t * __restrict  )(& thpool_p->thcount_lock));
  }
  pthread_mutex_unlock(& thpool_p->thcount_lock);
  return;
}
}
void thpool_destroy(struct thpool_ *thpool_p ) 
{ 
  int volatile   threads_total ;
  double TIMEOUT ;
  time_t start ;
  time_t end ;
  double tpassed ;
  int n ;

  {
  if ((unsigned long )thpool_p == (unsigned long )((void *)0)) {
    return;
  }
  threads_total = thpool_p->num_threads_alive;
  threads_keepalive = (int volatile   )0;
  TIMEOUT = 1.0;
  tpassed = 0.0;
  time(& start);
  while (1) {
    if (tpassed < TIMEOUT) {
      if (! thpool_p->num_threads_alive) {
        break;
      }
    } else {
      break;
    }
    bsem_post_all(thpool_p->jobqueue.has_jobs);
    time(& end);
    tpassed = difftime(end, start);
  }
  while (thpool_p->num_threads_alive) {
    bsem_post_all(thpool_p->jobqueue.has_jobs);
    sleep(1U);
  }
  jobqueue_destroy(& thpool_p->jobqueue);
  n = 0;
  while (n < (int )threads_total) {
    thread_destroy(*(thpool_p->threads + n));
    n ++;
  }
  free((void *)thpool_p->threads);
  free((void *)thpool_p);
  return;
}
}
void thpool_pause(struct thpool_ *thpool_p ) 
{ 
  int n ;

  {
  n = 0;
  while (n < (int )thpool_p->num_threads_alive) {
    pthread_kill((*(thpool_p->threads + n))->pthread, 10);
    n ++;
  }
  return;
}
}
void thpool_resume(struct thpool_ *thpool_p ) 
{ 


  {
  threads_on_hold = (int volatile   )0;
  return;
}
}
int thpool_num_threads_working(struct thpool_ *thpool_p ) 
{ 


  {
  return ((int )thpool_p->num_threads_working);
}
}
static int thread_init(thpool_ *thpool_p , struct thread **thread_p , int id ) 
{ 
  void *tmp ;

  {
  tmp = malloc(sizeof(struct thread ));
  *thread_p = (struct thread *)tmp;
  if ((unsigned long )*thread_p == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"thread_init(): Could not allocate memory for thread\n");
    return (-1);
  }
  (*thread_p)->thpool_p = thpool_p;
  (*thread_p)->id = id;
  pthread_create((pthread_t * __restrict  )(& (*thread_p)->pthread), (pthread_attr_t const   * __restrict  )((void *)0),
                 (void *(*)(void * ))(& thread_do), (void * __restrict  )*thread_p);
  pthread_detach((*thread_p)->pthread);
  return (0);
}
}
static void thread_hold(int sig_id ) 
{ 


  {
  threads_on_hold = (int volatile   )1;
  while (threads_on_hold) {
    sleep(1U);
  }
  return;
}
}
static void *thread_do(struct thread *thread_p ) 
{ 
  char thread_name[32] ;
  unsigned int tmp ;
  thpool_ *thpool_p ;
  struct sigaction act ;
  int tmp___0 ;
  void (*func_buff)(void * ) ;
  void *arg_buff ;
  job *job_p ;
  struct job *tmp___1 ;

  {
  thread_name[0] = (char)0;
  tmp = 1U;
  while (! (tmp >= 32U)) {
    thread_name[tmp] = (char)0;
    tmp ++;
  }
  snprintf((char * __restrict  )(thread_name), (size_t )32, (char const   * __restrict  )"thread-pool-%d",
           thread_p->id);
  prctl(15, thread_name);
  thpool_p = thread_p->thpool_p;
  sigemptyset(& act.sa_mask);
  act.sa_flags = 0;
  act.__sigaction_handler.sa_handler = & thread_hold;
  tmp___0 = sigaction(10, (struct sigaction  const  * __restrict  )(& act), (struct sigaction * __restrict  )((void *)0));
  if (tmp___0 == -1) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"thread_do(): cannot handle SIGUSR1");
  }
  pthread_mutex_lock(& thpool_p->thcount_lock);
  thpool_p->num_threads_alive += (int volatile   )1;
  pthread_mutex_unlock(& thpool_p->thcount_lock);
  while (threads_keepalive) {
    bsem_wait(thpool_p->jobqueue.has_jobs);
    if (threads_keepalive) {
      pthread_mutex_lock(& thpool_p->thcount_lock);
      thpool_p->num_threads_working += (int volatile   )1;
      pthread_mutex_unlock(& thpool_p->thcount_lock);
      tmp___1 = jobqueue_pull(& thpool_p->jobqueue);
      job_p = tmp___1;
      if (job_p) {
        func_buff = job_p->function;
        arg_buff = job_p->arg;
        (*func_buff)(arg_buff);
        free((void *)job_p);
      }
      pthread_mutex_lock(& thpool_p->thcount_lock);
      thpool_p->num_threads_working -= (int volatile   )1;
      if (! thpool_p->num_threads_working) {
        pthread_cond_signal(& thpool_p->threads_all_idle);
      }
      pthread_mutex_unlock(& thpool_p->thcount_lock);
    }
  }
  pthread_mutex_lock(& thpool_p->thcount_lock);
  thpool_p->num_threads_alive -= (int volatile   )1;
  pthread_mutex_unlock(& thpool_p->thcount_lock);
  return ((void *)0);
}
}
static void thread_destroy(struct thread *thread_p ) 
{ 


  {
  free((void *)thread_p);
  return;
}
}
static int jobqueue_init(jobqueue *jobqueue_p ) 
{ 
  void *tmp ;

  {
  jobqueue_p->len = 0;
  jobqueue_p->front = (job *)((void *)0);
  jobqueue_p->rear = (job *)((void *)0);
  tmp = malloc(sizeof(struct bsem ));
  jobqueue_p->has_jobs = (struct bsem *)tmp;
  if ((unsigned long )jobqueue_p->has_jobs == (unsigned long )((void *)0)) {
    return (-1);
  }
  pthread_mutex_init(& jobqueue_p->rwmutex, (pthread_mutexattr_t const   *)((void *)0));
  bsem_init(jobqueue_p->has_jobs, 0);
  return (0);
}
}
static void jobqueue_clear(jobqueue *jobqueue_p ) 
{ 
  struct job *tmp ;

  {
  while (jobqueue_p->len) {
    tmp = jobqueue_pull(jobqueue_p);
    free((void *)tmp);
  }
  jobqueue_p->front = (job *)((void *)0);
  jobqueue_p->rear = (job *)((void *)0);
  bsem_reset(jobqueue_p->has_jobs);
  jobqueue_p->len = 0;
  return;
}
}
static void jobqueue_push(jobqueue *jobqueue_p , struct job *newjob ) 
{ 


  {
  pthread_mutex_lock(& jobqueue_p->rwmutex);
  newjob->prev = (struct job *)((void *)0);
  switch (jobqueue_p->len) {
  case 0: 
  jobqueue_p->front = newjob;
  jobqueue_p->rear = newjob;
  break;
  default: 
  (jobqueue_p->rear)->prev = newjob;
  jobqueue_p->rear = newjob;
  }
  (jobqueue_p->len) ++;
  bsem_post(jobqueue_p->has_jobs);
  pthread_mutex_unlock(& jobqueue_p->rwmutex);
  return;
}
}
static struct job *jobqueue_pull(jobqueue *jobqueue_p ) 
{ 
  job *job_p ;

  {
  pthread_mutex_lock(& jobqueue_p->rwmutex);
  job_p = jobqueue_p->front;
  switch (jobqueue_p->len) {
  case 0: 
  break;
  case 1: 
  jobqueue_p->front = (job *)((void *)0);
  jobqueue_p->rear = (job *)((void *)0);
  jobqueue_p->len = 0;
  break;
  default: 
  jobqueue_p->front = job_p->prev;
  (jobqueue_p->len) --;
  bsem_post(jobqueue_p->has_jobs);
  }
  pthread_mutex_unlock(& jobqueue_p->rwmutex);
  return (job_p);
}
}
static void jobqueue_destroy(jobqueue *jobqueue_p ) 
{ 


  {
  jobqueue_clear(jobqueue_p);
  free((void *)jobqueue_p->has_jobs);
  return;
}
}
static void bsem_init(struct bsem *bsem_p , int value ) 
{ 


  {
  if (value < 0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"bsem_init(): Binary semaphore can take only values 1 or 0");
    exit(1);
  } else
  if (value > 1) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"bsem_init(): Binary semaphore can take only values 1 or 0");
    exit(1);
  }
  pthread_mutex_init(& bsem_p->mutex, (pthread_mutexattr_t const   *)((void *)0));
  pthread_cond_init((pthread_cond_t * __restrict  )(& bsem_p->cond), (pthread_condattr_t const   * __restrict  )((void *)0));
  bsem_p->v = value;
  return;
}
}
static void bsem_reset(struct bsem *bsem_p ) 
{ 


  {
  bsem_init(bsem_p, 0);
  return;
}
}
static void bsem_post(struct bsem *bsem_p ) 
{ 


  {
  pthread_mutex_lock(& bsem_p->mutex);
  bsem_p->v = 1;
  pthread_cond_signal(& bsem_p->cond);
  pthread_mutex_unlock(& bsem_p->mutex);
  return;
}
}
static void bsem_post_all(struct bsem *bsem_p ) 
{ 


  {
  pthread_mutex_lock(& bsem_p->mutex);
  bsem_p->v = 1;
  pthread_cond_broadcast(& bsem_p->cond);
  pthread_mutex_unlock(& bsem_p->mutex);
  return;
}
}
static void bsem_wait(struct bsem *bsem_p ) 
{ 


  {
  pthread_mutex_lock(& bsem_p->mutex);
  while (bsem_p->v != 1) {
    pthread_cond_wait((pthread_cond_t * __restrict  )(& bsem_p->cond), (pthread_mutex_t * __restrict  )(& bsem_p->mutex));
  }
  bsem_p->v = 0;
  pthread_mutex_unlock(& bsem_p->mutex);
  return;
}
}
#pragma merger("0","/tmp/cil-O2DPwCEf.i","")
extern int printf(char const   * __restrict  __format  , ...) ;
extern int puts(char const   *__s ) ;
extern  __attribute__((__nothrow__)) pthread_t pthread_self(void)  __attribute__((__const__)) ;
void task(void *arg ) 
{ 
  pthread_t tmp ;

  {
  tmp = pthread_self();
  printf((char const   * __restrict  )"Thread #%u working on %d\n", (int )tmp, (int )arg);
  return;
}
}
int main(void) 
{ 
  threadpool thpool ;
  threadpool tmp ;
  int i ;

  {
  puts("Making threadpool with 4 threads");
  tmp = thpool_init(4);
  thpool = tmp;
  puts("Adding 40 tasks to threadpool");
  i = 0;
  while (i < 40) {
    thpool_add_work(thpool, & task, (void *)((uintptr_t )i));
    i ++;
  }
  thpool_wait(thpool);
  puts("Killing threadpool");
  thpool_destroy(thpool);
  return (0);
}
}
