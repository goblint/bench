/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef __builtin_va_list __gnuc_va_list;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long __int64_t;
typedef unsigned long __uint64_t;
typedef long __intmax_t;
typedef unsigned long __uintmax_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef int __pid_t;
typedef long __clock_t;
typedef long __time_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
typedef unsigned int __socklen_t;
typedef int __sig_atomic_t;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef __ssize_t ssize_t;
typedef __pid_t pid_t;
struct __anonstruct___sigset_t_991265788 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___sigset_t_991265788 __sigset_t;
typedef __sigset_t sigset_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
typedef long __fd_mask;
struct __anonstruct_fd_set_356711149 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
typedef struct __anonstruct_fd_set_356711149 fd_set;
typedef __int8_t int8_t;
typedef __int64_t int64_t;
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
struct __anonstruct___wseq32_112954846 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_606137648 {
   unsigned long long __wseq ;
   struct __anonstruct___wseq32_112954846 __wseq32 ;
};
struct __anonstruct___g1_start32_327815073 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_327815072 {
   unsigned long long __g1_start ;
   struct __anonstruct___g1_start32_327815073 __g1_start32 ;
};
struct __pthread_cond_s {
   union __anonunion____missing_field_name_606137648 __annonCompField1 ;
   union __anonunion____missing_field_name_327815072 __annonCompField2 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
typedef unsigned long pthread_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
union __anonunion_pthread_cond_t_951761805 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
typedef union __anonunion_pthread_cond_t_951761805 pthread_cond_t;
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
typedef __sig_atomic_t sig_atomic_t;
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
typedef union sigval __sigval_t;
struct __anonstruct__kill_244518854 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
struct __anonstruct__timer_490064738 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
struct __anonstruct__rt_619254530 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
struct __anonstruct__sigchld_284671705 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
struct __anonstruct__addr_bnd_5259977 {
   void *_lower ;
   void *_upper ;
};
union __anonunion__bounds_663225253 {
   struct __anonstruct__addr_bnd_5259977 _addr_bnd ;
   __uint32_t _pkey ;
};
struct __anonstruct__sigfault_848714866 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion__bounds_663225253 _bounds ;
};
struct __anonstruct__sigpoll_386613454 {
   long si_band ;
   int si_fd ;
};
struct __anonstruct__sigsys_44812255 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
union __anonunion__sifields_1071224287 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_244518854 _kill ;
   struct __anonstruct__timer_490064738 _timer ;
   struct __anonstruct__rt_619254530 _rt ;
   struct __anonstruct__sigchld_284671705 _sigchld ;
   struct __anonstruct__sigfault_848714866 _sigfault ;
   struct __anonstruct__sigpoll_386613454 _sigpoll ;
   struct __anonstruct__sigsys_44812255 _sigsys ;
};
struct __anonstruct_siginfo_t_257952342 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion__sifields_1071224287 _sifields ;
};
typedef struct __anonstruct_siginfo_t_257952342 siginfo_t;
typedef void (*__sighandler_t)(int  );
union __anonunion___sigaction_handler_363639592 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
struct sigaction {
   union __anonunion___sigaction_handler_363639592 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
typedef unsigned int gpg_error_t;
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
typedef __socklen_t socklen_t;
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
typedef gpg_error_t gcry_error_t;
enum gcry_ctl_cmds {
    GCRYCTL_CFB_SYNC = 3,
    GCRYCTL_RESET = 4,
    GCRYCTL_FINALIZE = 5,
    GCRYCTL_GET_KEYLEN = 6,
    GCRYCTL_GET_BLKLEN = 7,
    GCRYCTL_TEST_ALGO = 8,
    GCRYCTL_IS_SECURE = 9,
    GCRYCTL_GET_ASNOID = 10,
    GCRYCTL_ENABLE_ALGO = 11,
    GCRYCTL_DISABLE_ALGO = 12,
    GCRYCTL_DUMP_RANDOM_STATS = 13,
    GCRYCTL_DUMP_SECMEM_STATS = 14,
    GCRYCTL_GET_ALGO_NPKEY = 15,
    GCRYCTL_GET_ALGO_NSKEY = 16,
    GCRYCTL_GET_ALGO_NSIGN = 17,
    GCRYCTL_GET_ALGO_NENCR = 18,
    GCRYCTL_SET_VERBOSITY = 19,
    GCRYCTL_SET_DEBUG_FLAGS = 20,
    GCRYCTL_CLEAR_DEBUG_FLAGS = 21,
    GCRYCTL_USE_SECURE_RNDPOOL = 22,
    GCRYCTL_DUMP_MEMORY_STATS = 23,
    GCRYCTL_INIT_SECMEM = 24,
    GCRYCTL_TERM_SECMEM = 25,
    GCRYCTL_DISABLE_SECMEM_WARN = 27,
    GCRYCTL_SUSPEND_SECMEM_WARN = 28,
    GCRYCTL_RESUME_SECMEM_WARN = 29,
    GCRYCTL_DROP_PRIVS = 30,
    GCRYCTL_ENABLE_M_GUARD = 31,
    GCRYCTL_START_DUMP = 32,
    GCRYCTL_STOP_DUMP = 33,
    GCRYCTL_GET_ALGO_USAGE = 34,
    GCRYCTL_IS_ALGO_ENABLED = 35,
    GCRYCTL_DISABLE_INTERNAL_LOCKING = 36,
    GCRYCTL_DISABLE_SECMEM = 37,
    GCRYCTL_INITIALIZATION_FINISHED = 38,
    GCRYCTL_INITIALIZATION_FINISHED_P = 39,
    GCRYCTL_ANY_INITIALIZATION_P = 40,
    GCRYCTL_SET_CBC_CTS = 41,
    GCRYCTL_SET_CBC_MAC = 42,
    GCRYCTL_ENABLE_QUICK_RANDOM = 44,
    GCRYCTL_SET_RANDOM_SEED_FILE = 45,
    GCRYCTL_UPDATE_RANDOM_SEED_FILE = 46,
    GCRYCTL_SET_THREAD_CBS = 47,
    GCRYCTL_FAST_POLL = 48,
    GCRYCTL_SET_RANDOM_DAEMON_SOCKET = 49,
    GCRYCTL_USE_RANDOM_DAEMON = 50,
    GCRYCTL_FAKED_RANDOM_P = 51,
    GCRYCTL_SET_RNDEGD_SOCKET = 52,
    GCRYCTL_PRINT_CONFIG = 53,
    GCRYCTL_OPERATIONAL_P = 54,
    GCRYCTL_FIPS_MODE_P = 55,
    GCRYCTL_FORCE_FIPS_MODE = 56,
    GCRYCTL_SELFTEST = 57,
    GCRYCTL_DISABLE_HWF = 63,
    GCRYCTL_SET_ENFORCED_FIPS_FLAG = 64,
    GCRYCTL_SET_PREFERRED_RNG_TYPE = 65,
    GCRYCTL_GET_CURRENT_RNG_TYPE = 66,
    GCRYCTL_DISABLE_LOCKED_SECMEM = 67,
    GCRYCTL_DISABLE_PRIV_DROP = 68,
    GCRYCTL_SET_CCM_LENGTHS = 69,
    GCRYCTL_CLOSE_RANDOM_DEVICE = 70,
    GCRYCTL_INACTIVATE_FIPS_FLAG = 71,
    GCRYCTL_REACTIVATE_FIPS_FLAG = 72,
    GCRYCTL_SET_SBOX = 73,
    GCRYCTL_DRBG_REINIT = 74,
    GCRYCTL_SET_TAGLEN = 75,
    GCRYCTL_GET_TAGLEN = 76,
    GCRYCTL_REINIT_SYSCALL_CLAMP = 77
} ;
struct gcry_cipher_handle ;
typedef struct gcry_cipher_handle *gcry_cipher_hd_t;
struct PianoListHead {
   struct PianoListHead *next ;
};
typedef struct PianoListHead PianoListHead_t;
struct PianoUserInfo {
   char *listenerId ;
   char *authToken ;
};
typedef struct PianoUserInfo PianoUserInfo_t;
struct PianoStation {
   PianoListHead_t head ;
   char isCreator ;
   char isQuickMix ;
   char useQuickMix ;
   char *name ;
   char *id ;
   char *seedId ;
};
typedef struct PianoStation PianoStation_t;
enum __anonenum_PianoSongRating_t_787051046 {
    PIANO_RATE_NONE = 0,
    PIANO_RATE_LOVE = 1,
    PIANO_RATE_BAN = 2,
    PIANO_RATE_TIRED = 3
} ;
typedef enum __anonenum_PianoSongRating_t_787051046 PianoSongRating_t;
enum __anonenum_PianoAudioFormat_t_237414795 {
    PIANO_AF_UNKNOWN = 0,
    PIANO_AF_AACPLUS = 1,
    PIANO_AF_MP3 = 2
} ;
typedef enum __anonenum_PianoAudioFormat_t_237414795 PianoAudioFormat_t;
enum __anonenum_PianoAudioQuality_t_590322017 {
    PIANO_AQ_UNKNOWN = 0,
    PIANO_AQ_LOW = 1,
    PIANO_AQ_MEDIUM = 2,
    PIANO_AQ_HIGH = 3
} ;
typedef enum __anonenum_PianoAudioQuality_t_590322017 PianoAudioQuality_t;
struct PianoSong {
   PianoListHead_t head ;
   char *artist ;
   char *stationId ;
   char *album ;
   char *audioUrl ;
   char *coverArt ;
   char *musicId ;
   char *title ;
   char *seedId ;
   char *feedbackId ;
   char *detailUrl ;
   char *trackToken ;
   float fileGain ;
   unsigned int length ;
   PianoSongRating_t rating ;
   PianoAudioFormat_t audioFormat ;
};
typedef struct PianoSong PianoSong_t;
struct PianoGenre {
   PianoListHead_t head ;
   char *name ;
   char *musicId ;
};
typedef struct PianoGenre PianoGenre_t;
struct PianoGenreCategory {
   PianoListHead_t head ;
   char *name ;
   PianoGenre_t *genres ;
};
typedef struct PianoGenreCategory PianoGenreCategory_t;
struct PianoPartner {
   gcry_cipher_hd_t in ;
   gcry_cipher_hd_t out ;
   char *authToken ;
   char *device ;
   char *user ;
   char *password ;
   unsigned int id ;
};
typedef struct PianoPartner PianoPartner_t;
struct PianoHandle {
   PianoUserInfo_t user ;
   PianoStation_t *stations ;
   PianoGenreCategory_t *genreStations ;
   PianoPartner_t partner ;
   int timeOffset ;
};
typedef struct PianoHandle PianoHandle_t;
enum __anonenum_PianoRequestType_t_963729421 {
    PIANO_REQUEST_LOGIN = 1,
    PIANO_REQUEST_GET_STATIONS = 2,
    PIANO_REQUEST_GET_PLAYLIST = 3,
    PIANO_REQUEST_RATE_SONG = 4,
    PIANO_REQUEST_ADD_FEEDBACK = 5,
    PIANO_REQUEST_RENAME_STATION = 7,
    PIANO_REQUEST_DELETE_STATION = 8,
    PIANO_REQUEST_SEARCH = 9,
    PIANO_REQUEST_CREATE_STATION = 10,
    PIANO_REQUEST_ADD_SEED = 11,
    PIANO_REQUEST_ADD_TIRED_SONG = 12,
    PIANO_REQUEST_SET_QUICKMIX = 13,
    PIANO_REQUEST_GET_GENRE_STATIONS = 14,
    PIANO_REQUEST_TRANSFORM_STATION = 15,
    PIANO_REQUEST_EXPLAIN = 16,
    PIANO_REQUEST_BOOKMARK_SONG = 18,
    PIANO_REQUEST_BOOKMARK_ARTIST = 19,
    PIANO_REQUEST_GET_STATION_INFO = 20,
    PIANO_REQUEST_DELETE_FEEDBACK = 21,
    PIANO_REQUEST_DELETE_SEED = 22,
    PIANO_REQUEST_GET_SETTINGS = 23,
    PIANO_REQUEST_CHANGE_SETTINGS = 24,
    PIANO_REQUEST_GET_STATION_MODES = 25,
    PIANO_REQUEST_SET_STATION_MODE = 26
} ;
typedef enum __anonenum_PianoRequestType_t_963729421 PianoRequestType_t;
struct __anonstruct_PianoRequestDataLogin_t_116150752 {
   char *user ;
   char *password ;
   unsigned char step ;
};
typedef struct __anonstruct_PianoRequestDataLogin_t_116150752 PianoRequestDataLogin_t;
struct __anonstruct_PianoRequestDataGetPlaylist_t_687121421 {
   PianoStation_t *station ;
   PianoAudioQuality_t quality ;
   PianoSong_t *retPlaylist ;
};
typedef struct __anonstruct_PianoRequestDataGetPlaylist_t_687121421 PianoRequestDataGetPlaylist_t;
enum __anonenum_PianoReturn_t_816789353 {
    PIANO_RET_ERR = 0,
    PIANO_RET_OK = 1,
    PIANO_RET_INVALID_RESPONSE = 2,
    PIANO_RET_CONTINUE_REQUEST = 3,
    PIANO_RET_OUT_OF_MEMORY = 4,
    PIANO_RET_INVALID_LOGIN = 5,
    PIANO_RET_QUALITY_UNAVAILABLE = 6,
    PIANO_RET_GCRY_ERR = 7,
    PIANO_RET_P_INTERNAL = 1024,
    PIANO_RET_P_API_VERSION_NOT_SUPPORTED = 1035,
    PIANO_RET_P_BIRTH_YEAR_INVALID = 2049,
    PIANO_RET_P_BIRTH_YEAR_TOO_YOUNG = 2050,
    PIANO_RET_P_CALL_NOT_ALLOWED = 2032,
    PIANO_RET_P_CERTIFICATE_REQUIRED = 1031,
    PIANO_RET_P_COMPLIMENTARY_PERIOD_ALREADY_IN_USE = 2031,
    PIANO_RET_P_DAILY_TRIAL_LIMIT_REACHED = 2059,
    PIANO_RET_P_DEVICE_ALREADY_ASSOCIATED_TO_ACCOUNT = 2038,
    PIANO_RET_P_DEVICE_DISABLED = 2058,
    PIANO_RET_P_DEVICE_MODEL_INVALID = 2047,
    PIANO_RET_P_DEVICE_NOT_FOUND = 2033,
    PIANO_RET_P_EXPLICIT_PIN_INCORRECT = 2042,
    PIANO_RET_P_EXPLICIT_PIN_MALFORMED = 2044,
    PIANO_RET_P_INSUFFICIENT_CONNECTIVITY = 1037,
    PIANO_RET_P_INVALID_AUTH_TOKEN = 2025,
    PIANO_RET_P_INVALID_COUNTRY_CODE = 2051,
    PIANO_RET_P_INVALID_GENDER = 2051,
    PIANO_RET_P_INVALID_PARTNER_LOGIN = 2026,
    PIANO_RET_P_INVALID_PASSWORD = 2036,
    PIANO_RET_P_INVALID_SPONSOR = 2060,
    PIANO_RET_P_INVALID_USERNAME = 2035,
    PIANO_RET_P_LICENSING_RESTRICTIONS = 1036,
    PIANO_RET_P_MAINTENANCE_MODE = 1025,
    PIANO_RET_P_MAX_STATIONS_REACHED = 2029,
    PIANO_RET_P_PARAMETER_MISSING = 1033,
    PIANO_RET_P_PARAMETER_TYPE_MISMATCH = 1032,
    PIANO_RET_P_PARAMETER_VALUE_INVALID = 1034,
    PIANO_RET_P_PARTNER_NOT_AUTHORIZED = 2034,
    PIANO_RET_P_READ_ONLY_MODE = 2024,
    PIANO_RET_P_SECURE_PROTOCOL_REQUIRED = 1030,
    PIANO_RET_P_STATION_DOES_NOT_EXIST = 2030,
    PIANO_RET_P_UPGRADE_DEVICE_MODEL_INVALID = 2039,
    PIANO_RET_P_URL_PARAM_MISSING_AUTH_TOKEN = 1027,
    PIANO_RET_P_URL_PARAM_MISSING_METHOD = 1026,
    PIANO_RET_P_URL_PARAM_MISSING_PARTNER_ID = 1028,
    PIANO_RET_P_URL_PARAM_MISSING_USER_ID = 1029,
    PIANO_RET_P_USERNAME_ALREADY_EXISTS = 2037,
    PIANO_RET_P_USER_ALREADY_USED_TRIAL = 2061,
    PIANO_RET_P_LISTENER_NOT_AUTHORIZED = 2027,
    PIANO_RET_P_USER_NOT_AUTHORIZED = 2028,
    PIANO_RET_P_ZIP_CODE_INVALID = 2048,
    PIANO_RET_P_RATE_LIMIT = 2063
} ;
typedef enum __anonenum_PianoReturn_t_816789353 PianoReturn_t;
typedef void CURL;
enum __anonenum_CURLcode_1040171027 {
    CURLE_OK = 0,
    CURLE_UNSUPPORTED_PROTOCOL = 1,
    CURLE_FAILED_INIT = 2,
    CURLE_URL_MALFORMAT = 3,
    CURLE_NOT_BUILT_IN = 4,
    CURLE_COULDNT_RESOLVE_PROXY = 5,
    CURLE_COULDNT_RESOLVE_HOST = 6,
    CURLE_COULDNT_CONNECT = 7,
    CURLE_WEIRD_SERVER_REPLY = 8,
    CURLE_REMOTE_ACCESS_DENIED = 9,
    CURLE_FTP_ACCEPT_FAILED = 10,
    CURLE_FTP_WEIRD_PASS_REPLY = 11,
    CURLE_FTP_ACCEPT_TIMEOUT = 12,
    CURLE_FTP_WEIRD_PASV_REPLY = 13,
    CURLE_FTP_WEIRD_227_FORMAT = 14,
    CURLE_FTP_CANT_GET_HOST = 15,
    CURLE_HTTP2 = 16,
    CURLE_FTP_COULDNT_SET_TYPE = 17,
    CURLE_PARTIAL_FILE = 18,
    CURLE_FTP_COULDNT_RETR_FILE = 19,
    CURLE_OBSOLETE20 = 20,
    CURLE_QUOTE_ERROR = 21,
    CURLE_HTTP_RETURNED_ERROR = 22,
    CURLE_WRITE_ERROR = 23,
    CURLE_OBSOLETE24 = 24,
    CURLE_UPLOAD_FAILED = 25,
    CURLE_READ_ERROR = 26,
    CURLE_OUT_OF_MEMORY = 27,
    CURLE_OPERATION_TIMEDOUT = 28,
    CURLE_OBSOLETE29 = 29,
    CURLE_FTP_PORT_FAILED = 30,
    CURLE_FTP_COULDNT_USE_REST = 31,
    CURLE_OBSOLETE32 = 32,
    CURLE_RANGE_ERROR = 33,
    CURLE_HTTP_POST_ERROR = 34,
    CURLE_SSL_CONNECT_ERROR = 35,
    CURLE_BAD_DOWNLOAD_RESUME = 36,
    CURLE_FILE_COULDNT_READ_FILE = 37,
    CURLE_LDAP_CANNOT_BIND = 38,
    CURLE_LDAP_SEARCH_FAILED = 39,
    CURLE_OBSOLETE40 = 40,
    CURLE_FUNCTION_NOT_FOUND = 41,
    CURLE_ABORTED_BY_CALLBACK = 42,
    CURLE_BAD_FUNCTION_ARGUMENT = 43,
    CURLE_OBSOLETE44 = 44,
    CURLE_INTERFACE_FAILED = 45,
    CURLE_OBSOLETE46 = 46,
    CURLE_TOO_MANY_REDIRECTS = 47,
    CURLE_UNKNOWN_OPTION = 48,
    CURLE_TELNET_OPTION_SYNTAX = 49,
    CURLE_OBSOLETE50 = 50,
    CURLE_OBSOLETE51 = 51,
    CURLE_GOT_NOTHING = 52,
    CURLE_SSL_ENGINE_NOTFOUND = 53,
    CURLE_SSL_ENGINE_SETFAILED = 54,
    CURLE_SEND_ERROR = 55,
    CURLE_RECV_ERROR = 56,
    CURLE_OBSOLETE57 = 57,
    CURLE_SSL_CERTPROBLEM = 58,
    CURLE_SSL_CIPHER = 59,
    CURLE_PEER_FAILED_VERIFICATION = 60,
    CURLE_BAD_CONTENT_ENCODING = 61,
    CURLE_LDAP_INVALID_URL = 62,
    CURLE_FILESIZE_EXCEEDED = 63,
    CURLE_USE_SSL_FAILED = 64,
    CURLE_SEND_FAIL_REWIND = 65,
    CURLE_SSL_ENGINE_INITFAILED = 66,
    CURLE_LOGIN_DENIED = 67,
    CURLE_TFTP_NOTFOUND = 68,
    CURLE_TFTP_PERM = 69,
    CURLE_REMOTE_DISK_FULL = 70,
    CURLE_TFTP_ILLEGAL = 71,
    CURLE_TFTP_UNKNOWNID = 72,
    CURLE_REMOTE_FILE_EXISTS = 73,
    CURLE_TFTP_NOSUCHUSER = 74,
    CURLE_CONV_FAILED = 75,
    CURLE_CONV_REQD = 76,
    CURLE_SSL_CACERT_BADFILE = 77,
    CURLE_REMOTE_FILE_NOT_FOUND = 78,
    CURLE_SSH = 79,
    CURLE_SSL_SHUTDOWN_FAILED = 80,
    CURLE_AGAIN = 81,
    CURLE_SSL_CRL_BADFILE = 82,
    CURLE_SSL_ISSUER_ERROR = 83,
    CURLE_FTP_PRET_FAILED = 84,
    CURLE_RTSP_CSEQ_ERROR = 85,
    CURLE_RTSP_SESSION_ERROR = 86,
    CURLE_FTP_BAD_FILE_LIST = 87,
    CURLE_CHUNK_FAILED = 88,
    CURLE_NO_CONNECTION_AVAILABLE = 89,
    CURLE_SSL_PINNEDPUBKEYNOTMATCH = 90,
    CURLE_SSL_INVALIDCERTSTATUS = 91,
    CURLE_HTTP2_STREAM = 92,
    CURLE_RECURSIVE_API_CALL = 93,
    CURLE_AUTH_ERROR = 94,
    CURLE_HTTP3 = 95,
    CURL_LAST = 96
} ;
typedef enum __anonenum_CURLcode_1040171027 CURLcode;
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
struct ao_device ;
typedef struct ao_device ao_device;
enum AVMediaType {
    AVMEDIA_TYPE_UNKNOWN = -1,
    AVMEDIA_TYPE_VIDEO = 0,
    AVMEDIA_TYPE_AUDIO = 1,
    AVMEDIA_TYPE_DATA = 2,
    AVMEDIA_TYPE_SUBTITLE = 3,
    AVMEDIA_TYPE_ATTACHMENT = 4,
    AVMEDIA_TYPE_NB = 5
} ;
enum AVPictureType {
    AV_PICTURE_TYPE_NONE = 0,
    AV_PICTURE_TYPE_I = 1,
    AV_PICTURE_TYPE_P = 2,
    AV_PICTURE_TYPE_B = 3,
    AV_PICTURE_TYPE_S = 4,
    AV_PICTURE_TYPE_SI = 5,
    AV_PICTURE_TYPE_SP = 6,
    AV_PICTURE_TYPE_BI = 7
} ;
typedef int __gwchar_t;
struct AVRational {
   int num ;
   int den ;
};
typedef struct AVRational AVRational;
enum __anonenum_AVClassCategory_328176932 {
    AV_CLASS_CATEGORY_NA = 0,
    AV_CLASS_CATEGORY_INPUT = 1,
    AV_CLASS_CATEGORY_OUTPUT = 2,
    AV_CLASS_CATEGORY_MUXER = 3,
    AV_CLASS_CATEGORY_DEMUXER = 4,
    AV_CLASS_CATEGORY_ENCODER = 5,
    AV_CLASS_CATEGORY_DECODER = 6,
    AV_CLASS_CATEGORY_FILTER = 7,
    AV_CLASS_CATEGORY_BITSTREAM_FILTER = 8,
    AV_CLASS_CATEGORY_SWSCALER = 9,
    AV_CLASS_CATEGORY_SWRESAMPLER = 10,
    AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT = 40,
    AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT = 41,
    AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT = 42,
    AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT = 43,
    AV_CLASS_CATEGORY_DEVICE_OUTPUT = 44,
    AV_CLASS_CATEGORY_DEVICE_INPUT = 45,
    AV_CLASS_CATEGORY_NB = 46
} ;
typedef enum __anonenum_AVClassCategory_328176932 AVClassCategory;
struct AVOptionRanges ;
struct AVOption ;
struct AVClass {
   char const   *class_name ;
   char const   *(*item_name)(void *ctx ) ;
   struct AVOption  const  *option ;
   int version ;
   int log_level_offset_offset ;
   int parent_log_context_offset ;
   void *(*child_next)(void *obj , void *prev ) ;
   struct AVClass  const  *(*child_class_next)(struct AVClass  const  *prev ) ;
   AVClassCategory category ;
   AVClassCategory (*get_category)(void *ctx ) ;
   int (*query_ranges)(struct AVOptionRanges ** , void *obj , char const   *key ,
                       int flags ) ;
};
typedef struct AVClass AVClass;
enum AVPixelFormat {
    AV_PIX_FMT_NONE = -1,
    AV_PIX_FMT_YUV420P = 0,
    AV_PIX_FMT_YUYV422 = 1,
    AV_PIX_FMT_RGB24 = 2,
    AV_PIX_FMT_BGR24 = 3,
    AV_PIX_FMT_YUV422P = 4,
    AV_PIX_FMT_YUV444P = 5,
    AV_PIX_FMT_YUV410P = 6,
    AV_PIX_FMT_YUV411P = 7,
    AV_PIX_FMT_GRAY8 = 8,
    AV_PIX_FMT_MONOWHITE = 9,
    AV_PIX_FMT_MONOBLACK = 10,
    AV_PIX_FMT_PAL8 = 11,
    AV_PIX_FMT_YUVJ420P = 12,
    AV_PIX_FMT_YUVJ422P = 13,
    AV_PIX_FMT_YUVJ444P = 14,
    AV_PIX_FMT_UYVY422 = 15,
    AV_PIX_FMT_UYYVYY411 = 16,
    AV_PIX_FMT_BGR8 = 17,
    AV_PIX_FMT_BGR4 = 18,
    AV_PIX_FMT_BGR4_BYTE = 19,
    AV_PIX_FMT_RGB8 = 20,
    AV_PIX_FMT_RGB4 = 21,
    AV_PIX_FMT_RGB4_BYTE = 22,
    AV_PIX_FMT_NV12 = 23,
    AV_PIX_FMT_NV21 = 24,
    AV_PIX_FMT_ARGB = 25,
    AV_PIX_FMT_RGBA = 26,
    AV_PIX_FMT_ABGR = 27,
    AV_PIX_FMT_BGRA = 28,
    AV_PIX_FMT_GRAY16BE = 29,
    AV_PIX_FMT_GRAY16LE = 30,
    AV_PIX_FMT_YUV440P = 31,
    AV_PIX_FMT_YUVJ440P = 32,
    AV_PIX_FMT_YUVA420P = 33,
    AV_PIX_FMT_RGB48BE = 34,
    AV_PIX_FMT_RGB48LE = 35,
    AV_PIX_FMT_RGB565BE = 36,
    AV_PIX_FMT_RGB565LE = 37,
    AV_PIX_FMT_RGB555BE = 38,
    AV_PIX_FMT_RGB555LE = 39,
    AV_PIX_FMT_BGR565BE = 40,
    AV_PIX_FMT_BGR565LE = 41,
    AV_PIX_FMT_BGR555BE = 42,
    AV_PIX_FMT_BGR555LE = 43,
    AV_PIX_FMT_VAAPI_MOCO = 44,
    AV_PIX_FMT_VAAPI_IDCT = 45,
    AV_PIX_FMT_VAAPI_VLD = 46,
    AV_PIX_FMT_VAAPI = 46,
    AV_PIX_FMT_YUV420P16LE = 47,
    AV_PIX_FMT_YUV420P16BE = 48,
    AV_PIX_FMT_YUV422P16LE = 49,
    AV_PIX_FMT_YUV422P16BE = 50,
    AV_PIX_FMT_YUV444P16LE = 51,
    AV_PIX_FMT_YUV444P16BE = 52,
    AV_PIX_FMT_DXVA2_VLD = 53,
    AV_PIX_FMT_RGB444LE = 54,
    AV_PIX_FMT_RGB444BE = 55,
    AV_PIX_FMT_BGR444LE = 56,
    AV_PIX_FMT_BGR444BE = 57,
    AV_PIX_FMT_YA8 = 58,
    AV_PIX_FMT_Y400A = 58,
    AV_PIX_FMT_GRAY8A = 58,
    AV_PIX_FMT_BGR48BE = 59,
    AV_PIX_FMT_BGR48LE = 60,
    AV_PIX_FMT_YUV420P9BE = 61,
    AV_PIX_FMT_YUV420P9LE = 62,
    AV_PIX_FMT_YUV420P10BE = 63,
    AV_PIX_FMT_YUV420P10LE = 64,
    AV_PIX_FMT_YUV422P10BE = 65,
    AV_PIX_FMT_YUV422P10LE = 66,
    AV_PIX_FMT_YUV444P9BE = 67,
    AV_PIX_FMT_YUV444P9LE = 68,
    AV_PIX_FMT_YUV444P10BE = 69,
    AV_PIX_FMT_YUV444P10LE = 70,
    AV_PIX_FMT_YUV422P9BE = 71,
    AV_PIX_FMT_YUV422P9LE = 72,
    AV_PIX_FMT_GBRP = 73,
    AV_PIX_FMT_GBR24P = 73,
    AV_PIX_FMT_GBRP9BE = 74,
    AV_PIX_FMT_GBRP9LE = 75,
    AV_PIX_FMT_GBRP10BE = 76,
    AV_PIX_FMT_GBRP10LE = 77,
    AV_PIX_FMT_GBRP16BE = 78,
    AV_PIX_FMT_GBRP16LE = 79,
    AV_PIX_FMT_YUVA422P = 80,
    AV_PIX_FMT_YUVA444P = 81,
    AV_PIX_FMT_YUVA420P9BE = 82,
    AV_PIX_FMT_YUVA420P9LE = 83,
    AV_PIX_FMT_YUVA422P9BE = 84,
    AV_PIX_FMT_YUVA422P9LE = 85,
    AV_PIX_FMT_YUVA444P9BE = 86,
    AV_PIX_FMT_YUVA444P9LE = 87,
    AV_PIX_FMT_YUVA420P10BE = 88,
    AV_PIX_FMT_YUVA420P10LE = 89,
    AV_PIX_FMT_YUVA422P10BE = 90,
    AV_PIX_FMT_YUVA422P10LE = 91,
    AV_PIX_FMT_YUVA444P10BE = 92,
    AV_PIX_FMT_YUVA444P10LE = 93,
    AV_PIX_FMT_YUVA420P16BE = 94,
    AV_PIX_FMT_YUVA420P16LE = 95,
    AV_PIX_FMT_YUVA422P16BE = 96,
    AV_PIX_FMT_YUVA422P16LE = 97,
    AV_PIX_FMT_YUVA444P16BE = 98,
    AV_PIX_FMT_YUVA444P16LE = 99,
    AV_PIX_FMT_VDPAU = 100,
    AV_PIX_FMT_XYZ12LE = 101,
    AV_PIX_FMT_XYZ12BE = 102,
    AV_PIX_FMT_NV16 = 103,
    AV_PIX_FMT_NV20LE = 104,
    AV_PIX_FMT_NV20BE = 105,
    AV_PIX_FMT_RGBA64BE = 106,
    AV_PIX_FMT_RGBA64LE = 107,
    AV_PIX_FMT_BGRA64BE = 108,
    AV_PIX_FMT_BGRA64LE = 109,
    AV_PIX_FMT_YVYU422 = 110,
    AV_PIX_FMT_YA16BE = 111,
    AV_PIX_FMT_YA16LE = 112,
    AV_PIX_FMT_GBRAP = 113,
    AV_PIX_FMT_GBRAP16BE = 114,
    AV_PIX_FMT_GBRAP16LE = 115,
    AV_PIX_FMT_QSV = 116,
    AV_PIX_FMT_MMAL = 117,
    AV_PIX_FMT_D3D11VA_VLD = 118,
    AV_PIX_FMT_CUDA = 119,
    AV_PIX_FMT_0RGB = 120,
    AV_PIX_FMT_RGB0 = 121,
    AV_PIX_FMT_0BGR = 122,
    AV_PIX_FMT_BGR0 = 123,
    AV_PIX_FMT_YUV420P12BE = 124,
    AV_PIX_FMT_YUV420P12LE = 125,
    AV_PIX_FMT_YUV420P14BE = 126,
    AV_PIX_FMT_YUV420P14LE = 127,
    AV_PIX_FMT_YUV422P12BE = 128,
    AV_PIX_FMT_YUV422P12LE = 129,
    AV_PIX_FMT_YUV422P14BE = 130,
    AV_PIX_FMT_YUV422P14LE = 131,
    AV_PIX_FMT_YUV444P12BE = 132,
    AV_PIX_FMT_YUV444P12LE = 133,
    AV_PIX_FMT_YUV444P14BE = 134,
    AV_PIX_FMT_YUV444P14LE = 135,
    AV_PIX_FMT_GBRP12BE = 136,
    AV_PIX_FMT_GBRP12LE = 137,
    AV_PIX_FMT_GBRP14BE = 138,
    AV_PIX_FMT_GBRP14LE = 139,
    AV_PIX_FMT_YUVJ411P = 140,
    AV_PIX_FMT_BAYER_BGGR8 = 141,
    AV_PIX_FMT_BAYER_RGGB8 = 142,
    AV_PIX_FMT_BAYER_GBRG8 = 143,
    AV_PIX_FMT_BAYER_GRBG8 = 144,
    AV_PIX_FMT_BAYER_BGGR16LE = 145,
    AV_PIX_FMT_BAYER_BGGR16BE = 146,
    AV_PIX_FMT_BAYER_RGGB16LE = 147,
    AV_PIX_FMT_BAYER_RGGB16BE = 148,
    AV_PIX_FMT_BAYER_GBRG16LE = 149,
    AV_PIX_FMT_BAYER_GBRG16BE = 150,
    AV_PIX_FMT_BAYER_GRBG16LE = 151,
    AV_PIX_FMT_BAYER_GRBG16BE = 152,
    AV_PIX_FMT_XVMC = 153,
    AV_PIX_FMT_YUV440P10LE = 154,
    AV_PIX_FMT_YUV440P10BE = 155,
    AV_PIX_FMT_YUV440P12LE = 156,
    AV_PIX_FMT_YUV440P12BE = 157,
    AV_PIX_FMT_AYUV64LE = 158,
    AV_PIX_FMT_AYUV64BE = 159,
    AV_PIX_FMT_VIDEOTOOLBOX = 160,
    AV_PIX_FMT_P010LE = 161,
    AV_PIX_FMT_P010BE = 162,
    AV_PIX_FMT_GBRAP12BE = 163,
    AV_PIX_FMT_GBRAP12LE = 164,
    AV_PIX_FMT_GBRAP10BE = 165,
    AV_PIX_FMT_GBRAP10LE = 166,
    AV_PIX_FMT_MEDIACODEC = 167,
    AV_PIX_FMT_GRAY12BE = 168,
    AV_PIX_FMT_GRAY12LE = 169,
    AV_PIX_FMT_GRAY10BE = 170,
    AV_PIX_FMT_GRAY10LE = 171,
    AV_PIX_FMT_P016LE = 172,
    AV_PIX_FMT_P016BE = 173,
    AV_PIX_FMT_D3D11 = 174,
    AV_PIX_FMT_GRAY9BE = 175,
    AV_PIX_FMT_GRAY9LE = 176,
    AV_PIX_FMT_GBRPF32BE = 177,
    AV_PIX_FMT_GBRPF32LE = 178,
    AV_PIX_FMT_GBRAPF32BE = 179,
    AV_PIX_FMT_GBRAPF32LE = 180,
    AV_PIX_FMT_DRM_PRIME = 181,
    AV_PIX_FMT_OPENCL = 182,
    AV_PIX_FMT_GRAY14BE = 183,
    AV_PIX_FMT_GRAY14LE = 184,
    AV_PIX_FMT_GRAYF32BE = 185,
    AV_PIX_FMT_GRAYF32LE = 186,
    AV_PIX_FMT_YUVA422P12BE = 187,
    AV_PIX_FMT_YUVA422P12LE = 188,
    AV_PIX_FMT_YUVA444P12BE = 189,
    AV_PIX_FMT_YUVA444P12LE = 190,
    AV_PIX_FMT_NV24 = 191,
    AV_PIX_FMT_NV42 = 192,
    AV_PIX_FMT_NB = 193
} ;
enum AVColorPrimaries {
    AVCOL_PRI_RESERVED0 = 0,
    AVCOL_PRI_BT709 = 1,
    AVCOL_PRI_UNSPECIFIED = 2,
    AVCOL_PRI_RESERVED = 3,
    AVCOL_PRI_BT470M = 4,
    AVCOL_PRI_BT470BG = 5,
    AVCOL_PRI_SMPTE170M = 6,
    AVCOL_PRI_SMPTE240M = 7,
    AVCOL_PRI_FILM = 8,
    AVCOL_PRI_BT2020 = 9,
    AVCOL_PRI_SMPTE428 = 10,
    AVCOL_PRI_SMPTEST428_1 = 10,
    AVCOL_PRI_SMPTE431 = 11,
    AVCOL_PRI_SMPTE432 = 12,
    AVCOL_PRI_JEDEC_P22 = 22,
    AVCOL_PRI_NB = 23
} ;
enum AVColorTransferCharacteristic {
    AVCOL_TRC_RESERVED0 = 0,
    AVCOL_TRC_BT709 = 1,
    AVCOL_TRC_UNSPECIFIED = 2,
    AVCOL_TRC_RESERVED = 3,
    AVCOL_TRC_GAMMA22 = 4,
    AVCOL_TRC_GAMMA28 = 5,
    AVCOL_TRC_SMPTE170M = 6,
    AVCOL_TRC_SMPTE240M = 7,
    AVCOL_TRC_LINEAR = 8,
    AVCOL_TRC_LOG = 9,
    AVCOL_TRC_LOG_SQRT = 10,
    AVCOL_TRC_IEC61966_2_4 = 11,
    AVCOL_TRC_BT1361_ECG = 12,
    AVCOL_TRC_IEC61966_2_1 = 13,
    AVCOL_TRC_BT2020_10 = 14,
    AVCOL_TRC_BT2020_12 = 15,
    AVCOL_TRC_SMPTE2084 = 16,
    AVCOL_TRC_SMPTEST2084 = 16,
    AVCOL_TRC_SMPTE428 = 17,
    AVCOL_TRC_SMPTEST428_1 = 17,
    AVCOL_TRC_ARIB_STD_B67 = 18,
    AVCOL_TRC_NB = 19
} ;
enum AVColorSpace {
    AVCOL_SPC_RGB = 0,
    AVCOL_SPC_BT709 = 1,
    AVCOL_SPC_UNSPECIFIED = 2,
    AVCOL_SPC_RESERVED = 3,
    AVCOL_SPC_FCC = 4,
    AVCOL_SPC_BT470BG = 5,
    AVCOL_SPC_SMPTE170M = 6,
    AVCOL_SPC_SMPTE240M = 7,
    AVCOL_SPC_YCGCO = 8,
    AVCOL_SPC_YCOCG = 8,
    AVCOL_SPC_BT2020_NCL = 9,
    AVCOL_SPC_BT2020_CL = 10,
    AVCOL_SPC_SMPTE2085 = 11,
    AVCOL_SPC_CHROMA_DERIVED_NCL = 12,
    AVCOL_SPC_CHROMA_DERIVED_CL = 13,
    AVCOL_SPC_ICTCP = 14,
    AVCOL_SPC_NB = 15
} ;
enum AVColorRange {
    AVCOL_RANGE_UNSPECIFIED = 0,
    AVCOL_RANGE_MPEG = 1,
    AVCOL_RANGE_JPEG = 2,
    AVCOL_RANGE_NB = 3
} ;
enum AVChromaLocation {
    AVCHROMA_LOC_UNSPECIFIED = 0,
    AVCHROMA_LOC_LEFT = 1,
    AVCHROMA_LOC_CENTER = 2,
    AVCHROMA_LOC_TOPLEFT = 3,
    AVCHROMA_LOC_TOP = 4,
    AVCHROMA_LOC_BOTTOMLEFT = 5,
    AVCHROMA_LOC_BOTTOM = 6,
    AVCHROMA_LOC_NB = 7
} ;
enum AVSampleFormat {
    AV_SAMPLE_FMT_NONE = -1,
    AV_SAMPLE_FMT_U8 = 0,
    AV_SAMPLE_FMT_S16 = 1,
    AV_SAMPLE_FMT_S32 = 2,
    AV_SAMPLE_FMT_FLT = 3,
    AV_SAMPLE_FMT_DBL = 4,
    AV_SAMPLE_FMT_U8P = 5,
    AV_SAMPLE_FMT_S16P = 6,
    AV_SAMPLE_FMT_S32P = 7,
    AV_SAMPLE_FMT_FLTP = 8,
    AV_SAMPLE_FMT_DBLP = 9,
    AV_SAMPLE_FMT_S64 = 10,
    AV_SAMPLE_FMT_S64P = 11,
    AV_SAMPLE_FMT_NB = 12
} ;
struct AVBuffer ;
typedef struct AVBuffer AVBuffer;
struct AVBufferRef {
   AVBuffer *buffer ;
   uint8_t *data ;
   int size ;
};
typedef struct AVBufferRef AVBufferRef;
struct AVDictionary ;
typedef struct AVDictionary AVDictionary;
enum AVFrameSideDataType {
    AV_FRAME_DATA_PANSCAN = 0,
    AV_FRAME_DATA_A53_CC = 1,
    AV_FRAME_DATA_STEREO3D = 2,
    AV_FRAME_DATA_MATRIXENCODING = 3,
    AV_FRAME_DATA_DOWNMIX_INFO = 4,
    AV_FRAME_DATA_REPLAYGAIN = 5,
    AV_FRAME_DATA_DISPLAYMATRIX = 6,
    AV_FRAME_DATA_AFD = 7,
    AV_FRAME_DATA_MOTION_VECTORS = 8,
    AV_FRAME_DATA_SKIP_SAMPLES = 9,
    AV_FRAME_DATA_AUDIO_SERVICE_TYPE = 10,
    AV_FRAME_DATA_MASTERING_DISPLAY_METADATA = 11,
    AV_FRAME_DATA_GOP_TIMECODE = 12,
    AV_FRAME_DATA_SPHERICAL = 13,
    AV_FRAME_DATA_CONTENT_LIGHT_LEVEL = 14,
    AV_FRAME_DATA_ICC_PROFILE = 15,
    AV_FRAME_DATA_QP_TABLE_PROPERTIES = 16,
    AV_FRAME_DATA_QP_TABLE_DATA = 17,
    AV_FRAME_DATA_S12M_TIMECODE = 18,
    AV_FRAME_DATA_DYNAMIC_HDR_PLUS = 19,
    AV_FRAME_DATA_REGIONS_OF_INTEREST = 20
} ;
struct AVFrameSideData {
   enum AVFrameSideDataType type ;
   uint8_t *data ;
   int size ;
   AVDictionary *metadata ;
   AVBufferRef *buf ;
};
typedef struct AVFrameSideData AVFrameSideData;
struct AVFrame {
   uint8_t *data[8] ;
   int linesize[8] ;
   uint8_t **extended_data ;
   int width ;
   int height ;
   int nb_samples ;
   int format ;
   int key_frame ;
   enum AVPictureType pict_type ;
   AVRational sample_aspect_ratio ;
   int64_t pts ;
   int64_t __attribute__((__deprecated__))  pkt_pts ;
   int64_t pkt_dts ;
   int coded_picture_number ;
   int display_picture_number ;
   int quality ;
   void *opaque ;
   uint64_t __attribute__((__deprecated__))  error[8] ;
   int repeat_pict ;
   int interlaced_frame ;
   int top_field_first ;
   int palette_has_changed ;
   int64_t reordered_opaque ;
   int sample_rate ;
   uint64_t channel_layout ;
   AVBufferRef *buf[8] ;
   AVBufferRef **extended_buf ;
   int nb_extended_buf ;
   AVFrameSideData **side_data ;
   int nb_side_data ;
   int flags ;
   enum AVColorRange color_range ;
   enum AVColorPrimaries color_primaries ;
   enum AVColorTransferCharacteristic color_trc ;
   enum AVColorSpace colorspace ;
   enum AVChromaLocation chroma_location ;
   int64_t best_effort_timestamp ;
   int64_t pkt_pos ;
   int64_t pkt_duration ;
   AVDictionary *metadata ;
   int decode_error_flags ;
   int channels ;
   int pkt_size ;
   int8_t __attribute__((__deprecated__))  *qscale_table ;
   int __attribute__((__deprecated__))  qstride ;
   int __attribute__((__deprecated__))  qscale_type ;
   AVBufferRef __attribute__((__deprecated__))  *qp_table_buf ;
   AVBufferRef *hw_frames_ctx ;
   AVBufferRef *opaque_ref ;
   size_t crop_top ;
   size_t crop_bottom ;
   size_t crop_left ;
   size_t crop_right ;
   AVBufferRef *private_ref ;
};
typedef struct AVFrame AVFrame;
enum AVCodecID {
    AV_CODEC_ID_NONE = 0,
    AV_CODEC_ID_MPEG1VIDEO = 1,
    AV_CODEC_ID_MPEG2VIDEO = 2,
    AV_CODEC_ID_H261 = 3,
    AV_CODEC_ID_H263 = 4,
    AV_CODEC_ID_RV10 = 5,
    AV_CODEC_ID_RV20 = 6,
    AV_CODEC_ID_MJPEG = 7,
    AV_CODEC_ID_MJPEGB = 8,
    AV_CODEC_ID_LJPEG = 9,
    AV_CODEC_ID_SP5X = 10,
    AV_CODEC_ID_JPEGLS = 11,
    AV_CODEC_ID_MPEG4 = 12,
    AV_CODEC_ID_RAWVIDEO = 13,
    AV_CODEC_ID_MSMPEG4V1 = 14,
    AV_CODEC_ID_MSMPEG4V2 = 15,
    AV_CODEC_ID_MSMPEG4V3 = 16,
    AV_CODEC_ID_WMV1 = 17,
    AV_CODEC_ID_WMV2 = 18,
    AV_CODEC_ID_H263P = 19,
    AV_CODEC_ID_H263I = 20,
    AV_CODEC_ID_FLV1 = 21,
    AV_CODEC_ID_SVQ1 = 22,
    AV_CODEC_ID_SVQ3 = 23,
    AV_CODEC_ID_DVVIDEO = 24,
    AV_CODEC_ID_HUFFYUV = 25,
    AV_CODEC_ID_CYUV = 26,
    AV_CODEC_ID_H264 = 27,
    AV_CODEC_ID_INDEO3 = 28,
    AV_CODEC_ID_VP3 = 29,
    AV_CODEC_ID_THEORA = 30,
    AV_CODEC_ID_ASV1 = 31,
    AV_CODEC_ID_ASV2 = 32,
    AV_CODEC_ID_FFV1 = 33,
    AV_CODEC_ID_4XM = 34,
    AV_CODEC_ID_VCR1 = 35,
    AV_CODEC_ID_CLJR = 36,
    AV_CODEC_ID_MDEC = 37,
    AV_CODEC_ID_ROQ = 38,
    AV_CODEC_ID_INTERPLAY_VIDEO = 39,
    AV_CODEC_ID_XAN_WC3 = 40,
    AV_CODEC_ID_XAN_WC4 = 41,
    AV_CODEC_ID_RPZA = 42,
    AV_CODEC_ID_CINEPAK = 43,
    AV_CODEC_ID_WS_VQA = 44,
    AV_CODEC_ID_MSRLE = 45,
    AV_CODEC_ID_MSVIDEO1 = 46,
    AV_CODEC_ID_IDCIN = 47,
    AV_CODEC_ID_8BPS = 48,
    AV_CODEC_ID_SMC = 49,
    AV_CODEC_ID_FLIC = 50,
    AV_CODEC_ID_TRUEMOTION1 = 51,
    AV_CODEC_ID_VMDVIDEO = 52,
    AV_CODEC_ID_MSZH = 53,
    AV_CODEC_ID_ZLIB = 54,
    AV_CODEC_ID_QTRLE = 55,
    AV_CODEC_ID_TSCC = 56,
    AV_CODEC_ID_ULTI = 57,
    AV_CODEC_ID_QDRAW = 58,
    AV_CODEC_ID_VIXL = 59,
    AV_CODEC_ID_QPEG = 60,
    AV_CODEC_ID_PNG = 61,
    AV_CODEC_ID_PPM = 62,
    AV_CODEC_ID_PBM = 63,
    AV_CODEC_ID_PGM = 64,
    AV_CODEC_ID_PGMYUV = 65,
    AV_CODEC_ID_PAM = 66,
    AV_CODEC_ID_FFVHUFF = 67,
    AV_CODEC_ID_RV30 = 68,
    AV_CODEC_ID_RV40 = 69,
    AV_CODEC_ID_VC1 = 70,
    AV_CODEC_ID_WMV3 = 71,
    AV_CODEC_ID_LOCO = 72,
    AV_CODEC_ID_WNV1 = 73,
    AV_CODEC_ID_AASC = 74,
    AV_CODEC_ID_INDEO2 = 75,
    AV_CODEC_ID_FRAPS = 76,
    AV_CODEC_ID_TRUEMOTION2 = 77,
    AV_CODEC_ID_BMP = 78,
    AV_CODEC_ID_CSCD = 79,
    AV_CODEC_ID_MMVIDEO = 80,
    AV_CODEC_ID_ZMBV = 81,
    AV_CODEC_ID_AVS = 82,
    AV_CODEC_ID_SMACKVIDEO = 83,
    AV_CODEC_ID_NUV = 84,
    AV_CODEC_ID_KMVC = 85,
    AV_CODEC_ID_FLASHSV = 86,
    AV_CODEC_ID_CAVS = 87,
    AV_CODEC_ID_JPEG2000 = 88,
    AV_CODEC_ID_VMNC = 89,
    AV_CODEC_ID_VP5 = 90,
    AV_CODEC_ID_VP6 = 91,
    AV_CODEC_ID_VP6F = 92,
    AV_CODEC_ID_TARGA = 93,
    AV_CODEC_ID_DSICINVIDEO = 94,
    AV_CODEC_ID_TIERTEXSEQVIDEO = 95,
    AV_CODEC_ID_TIFF = 96,
    AV_CODEC_ID_GIF = 97,
    AV_CODEC_ID_DXA = 98,
    AV_CODEC_ID_DNXHD = 99,
    AV_CODEC_ID_THP = 100,
    AV_CODEC_ID_SGI = 101,
    AV_CODEC_ID_C93 = 102,
    AV_CODEC_ID_BETHSOFTVID = 103,
    AV_CODEC_ID_PTX = 104,
    AV_CODEC_ID_TXD = 105,
    AV_CODEC_ID_VP6A = 106,
    AV_CODEC_ID_AMV = 107,
    AV_CODEC_ID_VB = 108,
    AV_CODEC_ID_PCX = 109,
    AV_CODEC_ID_SUNRAST = 110,
    AV_CODEC_ID_INDEO4 = 111,
    AV_CODEC_ID_INDEO5 = 112,
    AV_CODEC_ID_MIMIC = 113,
    AV_CODEC_ID_RL2 = 114,
    AV_CODEC_ID_ESCAPE124 = 115,
    AV_CODEC_ID_DIRAC = 116,
    AV_CODEC_ID_BFI = 117,
    AV_CODEC_ID_CMV = 118,
    AV_CODEC_ID_MOTIONPIXELS = 119,
    AV_CODEC_ID_TGV = 120,
    AV_CODEC_ID_TGQ = 121,
    AV_CODEC_ID_TQI = 122,
    AV_CODEC_ID_AURA = 123,
    AV_CODEC_ID_AURA2 = 124,
    AV_CODEC_ID_V210X = 125,
    AV_CODEC_ID_TMV = 126,
    AV_CODEC_ID_V210 = 127,
    AV_CODEC_ID_DPX = 128,
    AV_CODEC_ID_MAD = 129,
    AV_CODEC_ID_FRWU = 130,
    AV_CODEC_ID_FLASHSV2 = 131,
    AV_CODEC_ID_CDGRAPHICS = 132,
    AV_CODEC_ID_R210 = 133,
    AV_CODEC_ID_ANM = 134,
    AV_CODEC_ID_BINKVIDEO = 135,
    AV_CODEC_ID_IFF_ILBM = 136,
    AV_CODEC_ID_KGV1 = 137,
    AV_CODEC_ID_YOP = 138,
    AV_CODEC_ID_VP8 = 139,
    AV_CODEC_ID_PICTOR = 140,
    AV_CODEC_ID_ANSI = 141,
    AV_CODEC_ID_A64_MULTI = 142,
    AV_CODEC_ID_A64_MULTI5 = 143,
    AV_CODEC_ID_R10K = 144,
    AV_CODEC_ID_MXPEG = 145,
    AV_CODEC_ID_LAGARITH = 146,
    AV_CODEC_ID_PRORES = 147,
    AV_CODEC_ID_JV = 148,
    AV_CODEC_ID_DFA = 149,
    AV_CODEC_ID_WMV3IMAGE = 150,
    AV_CODEC_ID_VC1IMAGE = 151,
    AV_CODEC_ID_UTVIDEO = 152,
    AV_CODEC_ID_BMV_VIDEO = 153,
    AV_CODEC_ID_VBLE = 154,
    AV_CODEC_ID_DXTORY = 155,
    AV_CODEC_ID_V410 = 156,
    AV_CODEC_ID_XWD = 157,
    AV_CODEC_ID_CDXL = 158,
    AV_CODEC_ID_XBM = 159,
    AV_CODEC_ID_ZEROCODEC = 160,
    AV_CODEC_ID_MSS1 = 161,
    AV_CODEC_ID_MSA1 = 162,
    AV_CODEC_ID_TSCC2 = 163,
    AV_CODEC_ID_MTS2 = 164,
    AV_CODEC_ID_CLLC = 165,
    AV_CODEC_ID_MSS2 = 166,
    AV_CODEC_ID_VP9 = 167,
    AV_CODEC_ID_AIC = 168,
    AV_CODEC_ID_ESCAPE130 = 169,
    AV_CODEC_ID_G2M = 170,
    AV_CODEC_ID_WEBP = 171,
    AV_CODEC_ID_HNM4_VIDEO = 172,
    AV_CODEC_ID_HEVC = 173,
    AV_CODEC_ID_FIC = 174,
    AV_CODEC_ID_ALIAS_PIX = 175,
    AV_CODEC_ID_BRENDER_PIX = 176,
    AV_CODEC_ID_PAF_VIDEO = 177,
    AV_CODEC_ID_EXR = 178,
    AV_CODEC_ID_VP7 = 179,
    AV_CODEC_ID_SANM = 180,
    AV_CODEC_ID_SGIRLE = 181,
    AV_CODEC_ID_MVC1 = 182,
    AV_CODEC_ID_MVC2 = 183,
    AV_CODEC_ID_HQX = 184,
    AV_CODEC_ID_TDSC = 185,
    AV_CODEC_ID_HQ_HQA = 186,
    AV_CODEC_ID_HAP = 187,
    AV_CODEC_ID_DDS = 188,
    AV_CODEC_ID_DXV = 189,
    AV_CODEC_ID_SCREENPRESSO = 190,
    AV_CODEC_ID_RSCC = 191,
    AV_CODEC_ID_AVS2 = 192,
    AV_CODEC_ID_Y41P = 32768,
    AV_CODEC_ID_AVRP = 32769,
    AV_CODEC_ID_012V = 32770,
    AV_CODEC_ID_AVUI = 32771,
    AV_CODEC_ID_AYUV = 32772,
    AV_CODEC_ID_TARGA_Y216 = 32773,
    AV_CODEC_ID_V308 = 32774,
    AV_CODEC_ID_V408 = 32775,
    AV_CODEC_ID_YUV4 = 32776,
    AV_CODEC_ID_AVRN = 32777,
    AV_CODEC_ID_CPIA = 32778,
    AV_CODEC_ID_XFACE = 32779,
    AV_CODEC_ID_SNOW = 32780,
    AV_CODEC_ID_SMVJPEG = 32781,
    AV_CODEC_ID_APNG = 32782,
    AV_CODEC_ID_DAALA = 32783,
    AV_CODEC_ID_CFHD = 32784,
    AV_CODEC_ID_TRUEMOTION2RT = 32785,
    AV_CODEC_ID_M101 = 32786,
    AV_CODEC_ID_MAGICYUV = 32787,
    AV_CODEC_ID_SHEERVIDEO = 32788,
    AV_CODEC_ID_YLC = 32789,
    AV_CODEC_ID_PSD = 32790,
    AV_CODEC_ID_PIXLET = 32791,
    AV_CODEC_ID_SPEEDHQ = 32792,
    AV_CODEC_ID_FMVC = 32793,
    AV_CODEC_ID_SCPR = 32794,
    AV_CODEC_ID_CLEARVIDEO = 32795,
    AV_CODEC_ID_XPM = 32796,
    AV_CODEC_ID_AV1 = 32797,
    AV_CODEC_ID_BITPACKED = 32798,
    AV_CODEC_ID_MSCC = 32799,
    AV_CODEC_ID_SRGC = 32800,
    AV_CODEC_ID_SVG = 32801,
    AV_CODEC_ID_GDV = 32802,
    AV_CODEC_ID_FITS = 32803,
    AV_CODEC_ID_IMM4 = 32804,
    AV_CODEC_ID_PROSUMER = 32805,
    AV_CODEC_ID_MWSC = 32806,
    AV_CODEC_ID_WCMV = 32807,
    AV_CODEC_ID_RASC = 32808,
    AV_CODEC_ID_HYMT = 32809,
    AV_CODEC_ID_ARBC = 32810,
    AV_CODEC_ID_AGM = 32811,
    AV_CODEC_ID_LSCR = 32812,
    AV_CODEC_ID_VP4 = 32813,
    AV_CODEC_ID_FIRST_AUDIO = 65536,
    AV_CODEC_ID_PCM_S16LE = 65536,
    AV_CODEC_ID_PCM_S16BE = 65537,
    AV_CODEC_ID_PCM_U16LE = 65538,
    AV_CODEC_ID_PCM_U16BE = 65539,
    AV_CODEC_ID_PCM_S8 = 65540,
    AV_CODEC_ID_PCM_U8 = 65541,
    AV_CODEC_ID_PCM_MULAW = 65542,
    AV_CODEC_ID_PCM_ALAW = 65543,
    AV_CODEC_ID_PCM_S32LE = 65544,
    AV_CODEC_ID_PCM_S32BE = 65545,
    AV_CODEC_ID_PCM_U32LE = 65546,
    AV_CODEC_ID_PCM_U32BE = 65547,
    AV_CODEC_ID_PCM_S24LE = 65548,
    AV_CODEC_ID_PCM_S24BE = 65549,
    AV_CODEC_ID_PCM_U24LE = 65550,
    AV_CODEC_ID_PCM_U24BE = 65551,
    AV_CODEC_ID_PCM_S24DAUD = 65552,
    AV_CODEC_ID_PCM_ZORK = 65553,
    AV_CODEC_ID_PCM_S16LE_PLANAR = 65554,
    AV_CODEC_ID_PCM_DVD = 65555,
    AV_CODEC_ID_PCM_F32BE = 65556,
    AV_CODEC_ID_PCM_F32LE = 65557,
    AV_CODEC_ID_PCM_F64BE = 65558,
    AV_CODEC_ID_PCM_F64LE = 65559,
    AV_CODEC_ID_PCM_BLURAY = 65560,
    AV_CODEC_ID_PCM_LXF = 65561,
    AV_CODEC_ID_S302M = 65562,
    AV_CODEC_ID_PCM_S8_PLANAR = 65563,
    AV_CODEC_ID_PCM_S24LE_PLANAR = 65564,
    AV_CODEC_ID_PCM_S32LE_PLANAR = 65565,
    AV_CODEC_ID_PCM_S16BE_PLANAR = 65566,
    AV_CODEC_ID_PCM_S64LE = 67584,
    AV_CODEC_ID_PCM_S64BE = 67585,
    AV_CODEC_ID_PCM_F16LE = 67586,
    AV_CODEC_ID_PCM_F24LE = 67587,
    AV_CODEC_ID_PCM_VIDC = 67588,
    AV_CODEC_ID_ADPCM_IMA_QT = 69632,
    AV_CODEC_ID_ADPCM_IMA_WAV = 69633,
    AV_CODEC_ID_ADPCM_IMA_DK3 = 69634,
    AV_CODEC_ID_ADPCM_IMA_DK4 = 69635,
    AV_CODEC_ID_ADPCM_IMA_WS = 69636,
    AV_CODEC_ID_ADPCM_IMA_SMJPEG = 69637,
    AV_CODEC_ID_ADPCM_MS = 69638,
    AV_CODEC_ID_ADPCM_4XM = 69639,
    AV_CODEC_ID_ADPCM_XA = 69640,
    AV_CODEC_ID_ADPCM_ADX = 69641,
    AV_CODEC_ID_ADPCM_EA = 69642,
    AV_CODEC_ID_ADPCM_G726 = 69643,
    AV_CODEC_ID_ADPCM_CT = 69644,
    AV_CODEC_ID_ADPCM_SWF = 69645,
    AV_CODEC_ID_ADPCM_YAMAHA = 69646,
    AV_CODEC_ID_ADPCM_SBPRO_4 = 69647,
    AV_CODEC_ID_ADPCM_SBPRO_3 = 69648,
    AV_CODEC_ID_ADPCM_SBPRO_2 = 69649,
    AV_CODEC_ID_ADPCM_THP = 69650,
    AV_CODEC_ID_ADPCM_IMA_AMV = 69651,
    AV_CODEC_ID_ADPCM_EA_R1 = 69652,
    AV_CODEC_ID_ADPCM_EA_R3 = 69653,
    AV_CODEC_ID_ADPCM_EA_R2 = 69654,
    AV_CODEC_ID_ADPCM_IMA_EA_SEAD = 69655,
    AV_CODEC_ID_ADPCM_IMA_EA_EACS = 69656,
    AV_CODEC_ID_ADPCM_EA_XAS = 69657,
    AV_CODEC_ID_ADPCM_EA_MAXIS_XA = 69658,
    AV_CODEC_ID_ADPCM_IMA_ISS = 69659,
    AV_CODEC_ID_ADPCM_G722 = 69660,
    AV_CODEC_ID_ADPCM_IMA_APC = 69661,
    AV_CODEC_ID_ADPCM_VIMA = 69662,
    AV_CODEC_ID_ADPCM_AFC = 71680,
    AV_CODEC_ID_ADPCM_IMA_OKI = 71681,
    AV_CODEC_ID_ADPCM_DTK = 71682,
    AV_CODEC_ID_ADPCM_IMA_RAD = 71683,
    AV_CODEC_ID_ADPCM_G726LE = 71684,
    AV_CODEC_ID_ADPCM_THP_LE = 71685,
    AV_CODEC_ID_ADPCM_PSX = 71686,
    AV_CODEC_ID_ADPCM_AICA = 71687,
    AV_CODEC_ID_ADPCM_IMA_DAT4 = 71688,
    AV_CODEC_ID_ADPCM_MTAF = 71689,
    AV_CODEC_ID_ADPCM_AGM = 71690,
    AV_CODEC_ID_AMR_NB = 73728,
    AV_CODEC_ID_AMR_WB = 73729,
    AV_CODEC_ID_RA_144 = 77824,
    AV_CODEC_ID_RA_288 = 77825,
    AV_CODEC_ID_ROQ_DPCM = 81920,
    AV_CODEC_ID_INTERPLAY_DPCM = 81921,
    AV_CODEC_ID_XAN_DPCM = 81922,
    AV_CODEC_ID_SOL_DPCM = 81923,
    AV_CODEC_ID_SDX2_DPCM = 83968,
    AV_CODEC_ID_GREMLIN_DPCM = 83969,
    AV_CODEC_ID_MP2 = 86016,
    AV_CODEC_ID_MP3 = 86017,
    AV_CODEC_ID_AAC = 86018,
    AV_CODEC_ID_AC3 = 86019,
    AV_CODEC_ID_DTS = 86020,
    AV_CODEC_ID_VORBIS = 86021,
    AV_CODEC_ID_DVAUDIO = 86022,
    AV_CODEC_ID_WMAV1 = 86023,
    AV_CODEC_ID_WMAV2 = 86024,
    AV_CODEC_ID_MACE3 = 86025,
    AV_CODEC_ID_MACE6 = 86026,
    AV_CODEC_ID_VMDAUDIO = 86027,
    AV_CODEC_ID_FLAC = 86028,
    AV_CODEC_ID_MP3ADU = 86029,
    AV_CODEC_ID_MP3ON4 = 86030,
    AV_CODEC_ID_SHORTEN = 86031,
    AV_CODEC_ID_ALAC = 86032,
    AV_CODEC_ID_WESTWOOD_SND1 = 86033,
    AV_CODEC_ID_GSM = 86034,
    AV_CODEC_ID_QDM2 = 86035,
    AV_CODEC_ID_COOK = 86036,
    AV_CODEC_ID_TRUESPEECH = 86037,
    AV_CODEC_ID_TTA = 86038,
    AV_CODEC_ID_SMACKAUDIO = 86039,
    AV_CODEC_ID_QCELP = 86040,
    AV_CODEC_ID_WAVPACK = 86041,
    AV_CODEC_ID_DSICINAUDIO = 86042,
    AV_CODEC_ID_IMC = 86043,
    AV_CODEC_ID_MUSEPACK7 = 86044,
    AV_CODEC_ID_MLP = 86045,
    AV_CODEC_ID_GSM_MS = 86046,
    AV_CODEC_ID_ATRAC3 = 86047,
    AV_CODEC_ID_APE = 86048,
    AV_CODEC_ID_NELLYMOSER = 86049,
    AV_CODEC_ID_MUSEPACK8 = 86050,
    AV_CODEC_ID_SPEEX = 86051,
    AV_CODEC_ID_WMAVOICE = 86052,
    AV_CODEC_ID_WMAPRO = 86053,
    AV_CODEC_ID_WMALOSSLESS = 86054,
    AV_CODEC_ID_ATRAC3P = 86055,
    AV_CODEC_ID_EAC3 = 86056,
    AV_CODEC_ID_SIPR = 86057,
    AV_CODEC_ID_MP1 = 86058,
    AV_CODEC_ID_TWINVQ = 86059,
    AV_CODEC_ID_TRUEHD = 86060,
    AV_CODEC_ID_MP4ALS = 86061,
    AV_CODEC_ID_ATRAC1 = 86062,
    AV_CODEC_ID_BINKAUDIO_RDFT = 86063,
    AV_CODEC_ID_BINKAUDIO_DCT = 86064,
    AV_CODEC_ID_AAC_LATM = 86065,
    AV_CODEC_ID_QDMC = 86066,
    AV_CODEC_ID_CELT = 86067,
    AV_CODEC_ID_G723_1 = 86068,
    AV_CODEC_ID_G729 = 86069,
    AV_CODEC_ID_8SVX_EXP = 86070,
    AV_CODEC_ID_8SVX_FIB = 86071,
    AV_CODEC_ID_BMV_AUDIO = 86072,
    AV_CODEC_ID_RALF = 86073,
    AV_CODEC_ID_IAC = 86074,
    AV_CODEC_ID_ILBC = 86075,
    AV_CODEC_ID_OPUS = 86076,
    AV_CODEC_ID_COMFORT_NOISE = 86077,
    AV_CODEC_ID_TAK = 86078,
    AV_CODEC_ID_METASOUND = 86079,
    AV_CODEC_ID_PAF_AUDIO = 86080,
    AV_CODEC_ID_ON2AVC = 86081,
    AV_CODEC_ID_DSS_SP = 86082,
    AV_CODEC_ID_CODEC2 = 86083,
    AV_CODEC_ID_FFWAVESYNTH = 88064,
    AV_CODEC_ID_SONIC = 88065,
    AV_CODEC_ID_SONIC_LS = 88066,
    AV_CODEC_ID_EVRC = 88067,
    AV_CODEC_ID_SMV = 88068,
    AV_CODEC_ID_DSD_LSBF = 88069,
    AV_CODEC_ID_DSD_MSBF = 88070,
    AV_CODEC_ID_DSD_LSBF_PLANAR = 88071,
    AV_CODEC_ID_DSD_MSBF_PLANAR = 88072,
    AV_CODEC_ID_4GV = 88073,
    AV_CODEC_ID_INTERPLAY_ACM = 88074,
    AV_CODEC_ID_XMA1 = 88075,
    AV_CODEC_ID_XMA2 = 88076,
    AV_CODEC_ID_DST = 88077,
    AV_CODEC_ID_ATRAC3AL = 88078,
    AV_CODEC_ID_ATRAC3PAL = 88079,
    AV_CODEC_ID_DOLBY_E = 88080,
    AV_CODEC_ID_APTX = 88081,
    AV_CODEC_ID_APTX_HD = 88082,
    AV_CODEC_ID_SBC = 88083,
    AV_CODEC_ID_ATRAC9 = 88084,
    AV_CODEC_ID_HCOM = 88085,
    AV_CODEC_ID_FIRST_SUBTITLE = 94208,
    AV_CODEC_ID_DVD_SUBTITLE = 94208,
    AV_CODEC_ID_DVB_SUBTITLE = 94209,
    AV_CODEC_ID_TEXT = 94210,
    AV_CODEC_ID_XSUB = 94211,
    AV_CODEC_ID_SSA = 94212,
    AV_CODEC_ID_MOV_TEXT = 94213,
    AV_CODEC_ID_HDMV_PGS_SUBTITLE = 94214,
    AV_CODEC_ID_DVB_TELETEXT = 94215,
    AV_CODEC_ID_SRT = 94216,
    AV_CODEC_ID_MICRODVD = 96256,
    AV_CODEC_ID_EIA_608 = 96257,
    AV_CODEC_ID_JACOSUB = 96258,
    AV_CODEC_ID_SAMI = 96259,
    AV_CODEC_ID_REALTEXT = 96260,
    AV_CODEC_ID_STL = 96261,
    AV_CODEC_ID_SUBVIEWER1 = 96262,
    AV_CODEC_ID_SUBVIEWER = 96263,
    AV_CODEC_ID_SUBRIP = 96264,
    AV_CODEC_ID_WEBVTT = 96265,
    AV_CODEC_ID_MPL2 = 96266,
    AV_CODEC_ID_VPLAYER = 96267,
    AV_CODEC_ID_PJS = 96268,
    AV_CODEC_ID_ASS = 96269,
    AV_CODEC_ID_HDMV_TEXT_SUBTITLE = 96270,
    AV_CODEC_ID_TTML = 96271,
    AV_CODEC_ID_ARIB_CAPTION = 96272,
    AV_CODEC_ID_FIRST_UNKNOWN = 98304,
    AV_CODEC_ID_TTF = 98304,
    AV_CODEC_ID_SCTE_35 = 98305,
    AV_CODEC_ID_BINTEXT = 100352,
    AV_CODEC_ID_XBIN = 100353,
    AV_CODEC_ID_IDF = 100354,
    AV_CODEC_ID_OTF = 100355,
    AV_CODEC_ID_SMPTE_KLV = 100356,
    AV_CODEC_ID_DVD_NAV = 100357,
    AV_CODEC_ID_TIMED_ID3 = 100358,
    AV_CODEC_ID_BIN_DATA = 100359,
    AV_CODEC_ID_PROBE = 102400,
    AV_CODEC_ID_MPEG2TS = 131072,
    AV_CODEC_ID_MPEG4SYSTEMS = 131073,
    AV_CODEC_ID_FFMETADATA = 135168,
    AV_CODEC_ID_WRAPPED_AVFRAME = 135169
} ;
struct AVProfile ;
struct AVCodecDescriptor {
   enum AVCodecID id ;
   enum AVMediaType type ;
   char const   *name ;
   char const   *long_name ;
   int props ;
   char const   * const  *mime_types ;
   struct AVProfile  const  *profiles ;
};
typedef struct AVCodecDescriptor AVCodecDescriptor;
enum AVDiscard {
    AVDISCARD_NONE = -16,
    AVDISCARD_DEFAULT = 0,
    AVDISCARD_NONREF = 8,
    AVDISCARD_BIDIR = 16,
    AVDISCARD_NONINTRA = 24,
    AVDISCARD_NONKEY = 32,
    AVDISCARD_ALL = 48
} ;
enum AVAudioServiceType {
    AV_AUDIO_SERVICE_TYPE_MAIN = 0,
    AV_AUDIO_SERVICE_TYPE_EFFECTS = 1,
    AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED = 2,
    AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED = 3,
    AV_AUDIO_SERVICE_TYPE_DIALOGUE = 4,
    AV_AUDIO_SERVICE_TYPE_COMMENTARY = 5,
    AV_AUDIO_SERVICE_TYPE_EMERGENCY = 6,
    AV_AUDIO_SERVICE_TYPE_VOICE_OVER = 7,
    AV_AUDIO_SERVICE_TYPE_KARAOKE = 8,
    AV_AUDIO_SERVICE_TYPE_NB = 9
} ;
struct RcOverride {
   int start_frame ;
   int end_frame ;
   int qscale ;
   float quality_factor ;
};
typedef struct RcOverride RcOverride;
enum AVPacketSideDataType {
    AV_PKT_DATA_PALETTE = 0,
    AV_PKT_DATA_NEW_EXTRADATA = 1,
    AV_PKT_DATA_PARAM_CHANGE = 2,
    AV_PKT_DATA_H263_MB_INFO = 3,
    AV_PKT_DATA_REPLAYGAIN = 4,
    AV_PKT_DATA_DISPLAYMATRIX = 5,
    AV_PKT_DATA_STEREO3D = 6,
    AV_PKT_DATA_AUDIO_SERVICE_TYPE = 7,
    AV_PKT_DATA_QUALITY_STATS = 8,
    AV_PKT_DATA_FALLBACK_TRACK = 9,
    AV_PKT_DATA_CPB_PROPERTIES = 10,
    AV_PKT_DATA_SKIP_SAMPLES = 11,
    AV_PKT_DATA_JP_DUALMONO = 12,
    AV_PKT_DATA_STRINGS_METADATA = 13,
    AV_PKT_DATA_SUBTITLE_POSITION = 14,
    AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL = 15,
    AV_PKT_DATA_WEBVTT_IDENTIFIER = 16,
    AV_PKT_DATA_WEBVTT_SETTINGS = 17,
    AV_PKT_DATA_METADATA_UPDATE = 18,
    AV_PKT_DATA_MPEGTS_STREAM_ID = 19,
    AV_PKT_DATA_MASTERING_DISPLAY_METADATA = 20,
    AV_PKT_DATA_SPHERICAL = 21,
    AV_PKT_DATA_CONTENT_LIGHT_LEVEL = 22,
    AV_PKT_DATA_A53_CC = 23,
    AV_PKT_DATA_ENCRYPTION_INIT_INFO = 24,
    AV_PKT_DATA_ENCRYPTION_INFO = 25,
    AV_PKT_DATA_AFD = 26,
    AV_PKT_DATA_NB = 27
} ;
struct AVPacketSideData {
   uint8_t *data ;
   int size ;
   enum AVPacketSideDataType type ;
};
typedef struct AVPacketSideData AVPacketSideData;
struct AVPacket {
   AVBufferRef *buf ;
   int64_t pts ;
   int64_t dts ;
   uint8_t *data ;
   int size ;
   int stream_index ;
   int flags ;
   AVPacketSideData *side_data ;
   int side_data_elems ;
   int64_t duration ;
   int64_t pos ;
   int64_t __attribute__((__deprecated__))  convergence_duration ;
};
typedef struct AVPacket AVPacket;
struct AVCodecInternal ;
enum AVFieldOrder {
    AV_FIELD_UNKNOWN = 0,
    AV_FIELD_PROGRESSIVE = 1,
    AV_FIELD_TT = 2,
    AV_FIELD_BB = 3,
    AV_FIELD_TB = 4,
    AV_FIELD_BT = 5
} ;
struct AVCodec ;
struct AVHWAccel ;
struct AVCodecContext {
   AVClass const   *av_class ;
   int log_level_offset ;
   enum AVMediaType codec_type ;
   struct AVCodec  const  *codec ;
   enum AVCodecID codec_id ;
   unsigned int codec_tag ;
   void *priv_data ;
   struct AVCodecInternal *internal ;
   void *opaque ;
   int64_t bit_rate ;
   int bit_rate_tolerance ;
   int global_quality ;
   int compression_level ;
   int flags ;
   int flags2 ;
   uint8_t *extradata ;
   int extradata_size ;
   AVRational time_base ;
   int ticks_per_frame ;
   int delay ;
   int width ;
   int height ;
   int coded_width ;
   int coded_height ;
   int gop_size ;
   enum AVPixelFormat pix_fmt ;
   void (*draw_horiz_band)(struct AVCodecContext *s , AVFrame const   *src , int *offset ,
                           int y , int type , int height ) ;
   enum AVPixelFormat (*get_format)(struct AVCodecContext *s , enum AVPixelFormat  const  *fmt ) ;
   int max_b_frames ;
   float b_quant_factor ;
   int __attribute__((__deprecated__))  b_frame_strategy ;
   float b_quant_offset ;
   int has_b_frames ;
   int __attribute__((__deprecated__))  mpeg_quant ;
   float i_quant_factor ;
   float i_quant_offset ;
   float lumi_masking ;
   float temporal_cplx_masking ;
   float spatial_cplx_masking ;
   float p_masking ;
   float dark_masking ;
   int slice_count ;
   int __attribute__((__deprecated__))  prediction_method ;
   int *slice_offset ;
   AVRational sample_aspect_ratio ;
   int me_cmp ;
   int me_sub_cmp ;
   int mb_cmp ;
   int ildct_cmp ;
   int dia_size ;
   int last_predictor_count ;
   int __attribute__((__deprecated__))  pre_me ;
   int me_pre_cmp ;
   int pre_dia_size ;
   int me_subpel_quality ;
   int me_range ;
   int slice_flags ;
   int mb_decision ;
   uint16_t *intra_matrix ;
   uint16_t *inter_matrix ;
   int __attribute__((__deprecated__))  scenechange_threshold ;
   int __attribute__((__deprecated__))  noise_reduction ;
   int intra_dc_precision ;
   int skip_top ;
   int skip_bottom ;
   int mb_lmin ;
   int mb_lmax ;
   int __attribute__((__deprecated__))  me_penalty_compensation ;
   int bidir_refine ;
   int __attribute__((__deprecated__))  brd_scale ;
   int keyint_min ;
   int refs ;
   int __attribute__((__deprecated__))  chromaoffset ;
   int mv0_threshold ;
   int __attribute__((__deprecated__))  b_sensitivity ;
   enum AVColorPrimaries color_primaries ;
   enum AVColorTransferCharacteristic color_trc ;
   enum AVColorSpace colorspace ;
   enum AVColorRange color_range ;
   enum AVChromaLocation chroma_sample_location ;
   int slices ;
   enum AVFieldOrder field_order ;
   int sample_rate ;
   int channels ;
   enum AVSampleFormat sample_fmt ;
   int frame_size ;
   int frame_number ;
   int block_align ;
   int cutoff ;
   uint64_t channel_layout ;
   uint64_t request_channel_layout ;
   enum AVAudioServiceType audio_service_type ;
   enum AVSampleFormat request_sample_fmt ;
   int (*get_buffer2)(struct AVCodecContext *s , AVFrame *frame , int flags ) ;
   int __attribute__((__deprecated__))  refcounted_frames ;
   float qcompress ;
   float qblur ;
   int qmin ;
   int qmax ;
   int max_qdiff ;
   int rc_buffer_size ;
   int rc_override_count ;
   RcOverride *rc_override ;
   int64_t rc_max_rate ;
   int64_t rc_min_rate ;
   float rc_max_available_vbv_use ;
   float rc_min_vbv_overflow_use ;
   int rc_initial_buffer_occupancy ;
   int __attribute__((__deprecated__))  coder_type ;
   int __attribute__((__deprecated__))  context_model ;
   int __attribute__((__deprecated__))  frame_skip_threshold ;
   int __attribute__((__deprecated__))  frame_skip_factor ;
   int __attribute__((__deprecated__))  frame_skip_exp ;
   int __attribute__((__deprecated__))  frame_skip_cmp ;
   int trellis ;
   int __attribute__((__deprecated__))  min_prediction_order ;
   int __attribute__((__deprecated__))  max_prediction_order ;
   int64_t __attribute__((__deprecated__))  timecode_frame_start ;
   void __attribute__((__deprecated__))  (*rtp_callback)(struct AVCodecContext *avctx ,
                                                         void *data , int size , int mb_nb ) ;
   int __attribute__((__deprecated__))  rtp_payload_size ;
   int __attribute__((__deprecated__))  mv_bits ;
   int __attribute__((__deprecated__))  header_bits ;
   int __attribute__((__deprecated__))  i_tex_bits ;
   int __attribute__((__deprecated__))  p_tex_bits ;
   int __attribute__((__deprecated__))  i_count ;
   int __attribute__((__deprecated__))  p_count ;
   int __attribute__((__deprecated__))  skip_count ;
   int __attribute__((__deprecated__))  misc_bits ;
   int __attribute__((__deprecated__))  frame_bits ;
   char *stats_out ;
   char *stats_in ;
   int workaround_bugs ;
   int strict_std_compliance ;
   int error_concealment ;
   int debug ;
   int err_recognition ;
   int64_t reordered_opaque ;
   struct AVHWAccel  const  *hwaccel ;
   void *hwaccel_context ;
   uint64_t error[8] ;
   int dct_algo ;
   int idct_algo ;
   int bits_per_coded_sample ;
   int bits_per_raw_sample ;
   int lowres ;
   AVFrame __attribute__((__deprecated__))  *coded_frame ;
   int thread_count ;
   int thread_type ;
   int active_thread_type ;
   int thread_safe_callbacks ;
   int (*execute)(struct AVCodecContext *c , int (*func)(struct AVCodecContext *c2 ,
                                                         void *arg ) , void *arg2 ,
                  int *ret , int count , int size ) ;
   int (*execute2)(struct AVCodecContext *c , int (*func)(struct AVCodecContext *c2 ,
                                                          void *arg , int jobnr ,
                                                          int threadnr ) , void *arg2 ,
                   int *ret , int count ) ;
   int nsse_weight ;
   int profile ;
   int level ;
   enum AVDiscard skip_loop_filter ;
   enum AVDiscard skip_idct ;
   enum AVDiscard skip_frame ;
   uint8_t *subtitle_header ;
   int subtitle_header_size ;
   uint64_t __attribute__((__deprecated__))  vbv_delay ;
   int __attribute__((__deprecated__))  side_data_only_packets ;
   int initial_padding ;
   AVRational framerate ;
   enum AVPixelFormat sw_pix_fmt ;
   AVRational pkt_timebase ;
   AVCodecDescriptor const   *codec_descriptor ;
   int64_t pts_correction_num_faulty_pts ;
   int64_t pts_correction_num_faulty_dts ;
   int64_t pts_correction_last_pts ;
   int64_t pts_correction_last_dts ;
   char *sub_charenc ;
   int sub_charenc_mode ;
   int skip_alpha ;
   int seek_preroll ;
   int debug_mv ;
   uint16_t *chroma_intra_matrix ;
   uint8_t *dump_separator ;
   char *codec_whitelist ;
   unsigned int properties ;
   AVPacketSideData *coded_side_data ;
   int nb_coded_side_data ;
   AVBufferRef *hw_frames_ctx ;
   int sub_text_format ;
   int trailing_padding ;
   int64_t max_pixels ;
   AVBufferRef *hw_device_ctx ;
   int hwaccel_flags ;
   int apply_cropping ;
   int extra_hw_frames ;
   int discard_damaged_percentage ;
};
typedef struct AVCodecContext AVCodecContext;
struct AVProfile {
   int profile ;
   char const   *name ;
};
typedef struct AVProfile AVProfile;
struct AVCodecDefault ;
typedef struct AVCodecDefault AVCodecDefault;
struct AVSubtitle ;
struct AVCodecHWConfigInternal ;
struct AVCodec {
   char const   *name ;
   char const   *long_name ;
   enum AVMediaType type ;
   enum AVCodecID id ;
   int capabilities ;
   AVRational const   *supported_framerates ;
   enum AVPixelFormat  const  *pix_fmts ;
   int const   *supported_samplerates ;
   enum AVSampleFormat  const  *sample_fmts ;
   uint64_t const   *channel_layouts ;
   uint8_t max_lowres ;
   AVClass const   *priv_class ;
   AVProfile const   *profiles ;
   char const   *wrapper_name ;
   int priv_data_size ;
   struct AVCodec *next ;
   int (*init_thread_copy)(AVCodecContext * ) ;
   int (*update_thread_context)(AVCodecContext *dst , AVCodecContext const   *src ) ;
   AVCodecDefault const   *defaults ;
   void (*init_static_data)(struct AVCodec *codec ) ;
   int (*init)(AVCodecContext * ) ;
   int (*encode_sub)(AVCodecContext * , uint8_t *buf , int buf_size , struct AVSubtitle  const  *sub ) ;
   int (*encode2)(AVCodecContext *avctx , AVPacket *avpkt , AVFrame const   *frame ,
                  int *got_packet_ptr ) ;
   int (*decode)(AVCodecContext * , void *outdata , int *outdata_size , AVPacket *avpkt ) ;
   int (*close)(AVCodecContext * ) ;
   int (*send_frame)(AVCodecContext *avctx , AVFrame const   *frame ) ;
   int (*receive_packet)(AVCodecContext *avctx , AVPacket *avpkt ) ;
   int (*receive_frame)(AVCodecContext *avctx , AVFrame *frame ) ;
   void (*flush)(AVCodecContext * ) ;
   int caps_internal ;
   char const   *bsfs ;
   struct AVCodecHWConfigInternal  const  **hw_configs ;
};
typedef struct AVCodec AVCodec;
struct MpegEncContext ;
struct AVHWAccel {
   char const   *name ;
   enum AVMediaType type ;
   enum AVCodecID id ;
   enum AVPixelFormat pix_fmt ;
   int capabilities ;
   int (*alloc_frame)(AVCodecContext *avctx , AVFrame *frame ) ;
   int (*start_frame)(AVCodecContext *avctx , uint8_t const   *buf , uint32_t buf_size ) ;
   int (*decode_params)(AVCodecContext *avctx , int type , uint8_t const   *buf ,
                        uint32_t buf_size ) ;
   int (*decode_slice)(AVCodecContext *avctx , uint8_t const   *buf , uint32_t buf_size ) ;
   int (*end_frame)(AVCodecContext *avctx ) ;
   int frame_priv_data_size ;
   void (*decode_mb)(struct MpegEncContext *s ) ;
   int (*init)(AVCodecContext *avctx ) ;
   int (*uninit)(AVCodecContext *avctx ) ;
   int priv_data_size ;
   int caps_internal ;
   int (*frame_params)(AVCodecContext *avctx , AVBufferRef *hw_frames_ctx ) ;
};
struct AVPicture {
   uint8_t __attribute__((__deprecated__))  *data[8] ;
   int __attribute__((__deprecated__))  linesize[8] ;
};
typedef struct AVPicture AVPicture;
enum AVSubtitleType {
    SUBTITLE_NONE = 0,
    SUBTITLE_BITMAP = 1,
    SUBTITLE_TEXT = 2,
    SUBTITLE_ASS = 3
} ;
struct AVSubtitleRect {
   int x ;
   int y ;
   int w ;
   int h ;
   int nb_colors ;
   AVPicture __attribute__((__deprecated__))  pict ;
   uint8_t *data[4] ;
   int linesize[4] ;
   enum AVSubtitleType type ;
   char *text ;
   char *ass ;
   int flags ;
};
typedef struct AVSubtitleRect AVSubtitleRect;
struct AVSubtitle {
   uint16_t format ;
   uint32_t start_display_time ;
   uint32_t end_display_time ;
   unsigned int num_rects ;
   AVSubtitleRect **rects ;
   int64_t pts ;
};
struct AVCodecParameters {
   enum AVMediaType codec_type ;
   enum AVCodecID codec_id ;
   uint32_t codec_tag ;
   uint8_t *extradata ;
   int extradata_size ;
   int format ;
   int64_t bit_rate ;
   int bits_per_coded_sample ;
   int bits_per_raw_sample ;
   int profile ;
   int level ;
   int width ;
   int height ;
   AVRational sample_aspect_ratio ;
   enum AVFieldOrder field_order ;
   enum AVColorRange color_range ;
   enum AVColorPrimaries color_primaries ;
   enum AVColorTransferCharacteristic color_trc ;
   enum AVColorSpace color_space ;
   enum AVChromaLocation chroma_location ;
   int video_delay ;
   uint64_t channel_layout ;
   int channels ;
   int sample_rate ;
   int block_align ;
   int frame_size ;
   int initial_padding ;
   int trailing_padding ;
   int seek_preroll ;
};
typedef struct AVCodecParameters AVCodecParameters;
enum AVPictureStructure {
    AV_PICTURE_STRUCTURE_UNKNOWN = 0,
    AV_PICTURE_STRUCTURE_TOP_FIELD = 1,
    AV_PICTURE_STRUCTURE_BOTTOM_FIELD = 2,
    AV_PICTURE_STRUCTURE_FRAME = 3
} ;
struct AVCodecParser ;
struct AVCodecParserContext {
   void *priv_data ;
   struct AVCodecParser *parser ;
   int64_t frame_offset ;
   int64_t cur_offset ;
   int64_t next_frame_offset ;
   int pict_type ;
   int repeat_pict ;
   int64_t pts ;
   int64_t dts ;
   int64_t last_pts ;
   int64_t last_dts ;
   int fetch_timestamp ;
   int cur_frame_start_index ;
   int64_t cur_frame_offset[4] ;
   int64_t cur_frame_pts[4] ;
   int64_t cur_frame_dts[4] ;
   int flags ;
   int64_t offset ;
   int64_t cur_frame_end[4] ;
   int key_frame ;
   int64_t __attribute__((__deprecated__))  convergence_duration ;
   int dts_sync_point ;
   int dts_ref_dts_delta ;
   int pts_dts_delta ;
   int64_t cur_frame_pos[4] ;
   int64_t pos ;
   int64_t last_pos ;
   int duration ;
   enum AVFieldOrder field_order ;
   enum AVPictureStructure picture_structure ;
   int output_picture_number ;
   int width ;
   int height ;
   int coded_width ;
   int coded_height ;
   int format ;
};
typedef struct AVCodecParserContext AVCodecParserContext;
struct AVCodecParser {
   int codec_ids[5] ;
   int priv_data_size ;
   int (*parser_init)(AVCodecParserContext *s ) ;
   int (*parser_parse)(AVCodecParserContext *s , AVCodecContext *avctx , uint8_t const   **poutbuf ,
                       int *poutbuf_size , uint8_t const   *buf , int buf_size ) ;
   void (*parser_close)(AVCodecParserContext *s ) ;
   int (*split)(AVCodecContext *avctx , uint8_t const   *buf , int buf_size ) ;
   struct AVCodecParser *next ;
};
struct AVIOInterruptCB {
   int (*callback)(void * ) ;
   void *opaque ;
};
typedef struct AVIOInterruptCB AVIOInterruptCB;
enum AVIODataMarkerType {
    AVIO_DATA_MARKER_HEADER = 0,
    AVIO_DATA_MARKER_SYNC_POINT = 1,
    AVIO_DATA_MARKER_BOUNDARY_POINT = 2,
    AVIO_DATA_MARKER_UNKNOWN = 3,
    AVIO_DATA_MARKER_TRAILER = 4,
    AVIO_DATA_MARKER_FLUSH_POINT = 5
} ;
struct AVIOContext {
   AVClass const   *av_class ;
   unsigned char *buffer ;
   int buffer_size ;
   unsigned char *buf_ptr ;
   unsigned char *buf_end ;
   void *opaque ;
   int (*read_packet)(void *opaque , uint8_t *buf , int buf_size ) ;
   int (*write_packet)(void *opaque , uint8_t *buf , int buf_size ) ;
   int64_t (*seek)(void *opaque , int64_t offset , int whence ) ;
   int64_t pos ;
   int eof_reached ;
   int write_flag ;
   int max_packet_size ;
   unsigned long checksum ;
   unsigned char *checksum_ptr ;
   unsigned long (*update_checksum)(unsigned long checksum , uint8_t const   *buf ,
                                    unsigned int size ) ;
   int error ;
   int (*read_pause)(void *opaque , int pause ) ;
   int64_t (*read_seek)(void *opaque , int stream_index , int64_t timestamp , int flags ) ;
   int seekable ;
   int64_t maxsize ;
   int direct ;
   int64_t bytes_read ;
   int seek_count ;
   int writeout_count ;
   int orig_buffer_size ;
   int short_seek_threshold ;
   char const   *protocol_whitelist ;
   char const   *protocol_blacklist ;
   int (*write_data_type)(void *opaque , uint8_t *buf , int buf_size , enum AVIODataMarkerType type ,
                          int64_t time ) ;
   int ignore_boundary_point ;
   enum AVIODataMarkerType current_type ;
   int64_t last_time ;
   int (*short_seek_get)(void *opaque ) ;
   int64_t written ;
   unsigned char *buf_ptr_max ;
   int min_packet_size ;
};
typedef struct AVIOContext AVIOContext;
struct AVFormatContext ;
struct AVDeviceInfoList ;
struct AVDeviceCapabilitiesQuery ;
struct AVCodecTag ;
struct AVProbeData {
   char const   *filename ;
   unsigned char *buf ;
   int buf_size ;
   char const   *mime_type ;
};
typedef struct AVProbeData AVProbeData;
struct AVOutputFormat {
   char const   *name ;
   char const   *long_name ;
   char const   *mime_type ;
   char const   *extensions ;
   enum AVCodecID audio_codec ;
   enum AVCodecID video_codec ;
   enum AVCodecID subtitle_codec ;
   int flags ;
   struct AVCodecTag  const  * const  *codec_tag ;
   AVClass const   *priv_class ;
   struct AVOutputFormat *next ;
   int priv_data_size ;
   int (*write_header)(struct AVFormatContext * ) ;
   int (*write_packet)(struct AVFormatContext * , AVPacket *pkt ) ;
   int (*write_trailer)(struct AVFormatContext * ) ;
   int (*interleave_packet)(struct AVFormatContext * , AVPacket *out , AVPacket *in ,
                            int flush ) ;
   int (*query_codec)(enum AVCodecID id , int std_compliance ) ;
   void (*get_output_timestamp)(struct AVFormatContext *s , int stream , int64_t *dts ,
                                int64_t *wall ) ;
   int (*control_message)(struct AVFormatContext *s , int type , void *data , size_t data_size ) ;
   int (*write_uncoded_frame)(struct AVFormatContext * , int stream_index , AVFrame **frame ,
                              unsigned int flags ) ;
   int (*get_device_list)(struct AVFormatContext *s , struct AVDeviceInfoList *device_list ) ;
   int (*create_device_capabilities)(struct AVFormatContext *s , struct AVDeviceCapabilitiesQuery *caps ) ;
   int (*free_device_capabilities)(struct AVFormatContext *s , struct AVDeviceCapabilitiesQuery *caps ) ;
   enum AVCodecID data_codec ;
   int (*init)(struct AVFormatContext * ) ;
   void (*deinit)(struct AVFormatContext * ) ;
   int (*check_bitstream)(struct AVFormatContext * , AVPacket const   *pkt ) ;
};
struct AVInputFormat {
   char const   *name ;
   char const   *long_name ;
   int flags ;
   char const   *extensions ;
   struct AVCodecTag  const  * const  *codec_tag ;
   AVClass const   *priv_class ;
   char const   *mime_type ;
   struct AVInputFormat *next ;
   int raw_codec_id ;
   int priv_data_size ;
   int (*read_probe)(AVProbeData const   * ) ;
   int (*read_header)(struct AVFormatContext * ) ;
   int (*read_packet)(struct AVFormatContext * , AVPacket *pkt ) ;
   int (*read_close)(struct AVFormatContext * ) ;
   int (*read_seek)(struct AVFormatContext * , int stream_index , int64_t timestamp ,
                    int flags ) ;
   int64_t (*read_timestamp)(struct AVFormatContext *s , int stream_index , int64_t *pos ,
                             int64_t pos_limit ) ;
   int (*read_play)(struct AVFormatContext * ) ;
   int (*read_pause)(struct AVFormatContext * ) ;
   int (*read_seek2)(struct AVFormatContext *s , int stream_index , int64_t min_ts ,
                     int64_t ts , int64_t max_ts , int flags ) ;
   int (*get_device_list)(struct AVFormatContext *s , struct AVDeviceInfoList *device_list ) ;
   int (*create_device_capabilities)(struct AVFormatContext *s , struct AVDeviceCapabilitiesQuery *caps ) ;
   int (*free_device_capabilities)(struct AVFormatContext *s , struct AVDeviceCapabilitiesQuery *caps ) ;
};
enum AVStreamParseType {
    AVSTREAM_PARSE_NONE = 0,
    AVSTREAM_PARSE_FULL = 1,
    AVSTREAM_PARSE_HEADERS = 2,
    AVSTREAM_PARSE_TIMESTAMPS = 3,
    AVSTREAM_PARSE_FULL_ONCE = 4,
    AVSTREAM_PARSE_FULL_RAW = 5
} ;
struct AVIndexEntry {
   int64_t pos ;
   int64_t timestamp ;
   int flags : 2 ;
   int size : 30 ;
   int min_distance ;
};
typedef struct AVIndexEntry AVIndexEntry;
struct AVStreamInternal ;
typedef struct AVStreamInternal AVStreamInternal;
struct __anonstruct_info_529918689 {
   int64_t last_dts ;
   int64_t duration_gcd ;
   int duration_count ;
   int64_t rfps_duration_sum ;
   double (*duration_error)[2][399] ;
   int64_t codec_info_duration ;
   int64_t codec_info_duration_fields ;
   int frame_delay_evidence ;
   int found_decoder ;
   int64_t last_duration ;
   int64_t fps_first_dts ;
   int fps_first_dts_idx ;
   int64_t fps_last_dts ;
   int fps_last_dts_idx ;
};
struct AVPacketList ;
struct AVStream {
   int index ;
   int id ;
   AVCodecContext __attribute__((__deprecated__))  *codec ;
   void *priv_data ;
   AVRational time_base ;
   int64_t start_time ;
   int64_t duration ;
   int64_t nb_frames ;
   int disposition ;
   enum AVDiscard discard ;
   AVRational sample_aspect_ratio ;
   AVDictionary *metadata ;
   AVRational avg_frame_rate ;
   AVPacket attached_pic ;
   AVPacketSideData *side_data ;
   int nb_side_data ;
   int event_flags ;
   AVRational r_frame_rate ;
   char __attribute__((__deprecated__))  *recommended_encoder_configuration ;
   AVCodecParameters *codecpar ;
   struct __anonstruct_info_529918689 *info ;
   int pts_wrap_bits ;
   int64_t first_dts ;
   int64_t cur_dts ;
   int64_t last_IP_pts ;
   int last_IP_duration ;
   int probe_packets ;
   int codec_info_nb_frames ;
   enum AVStreamParseType need_parsing ;
   struct AVCodecParserContext *parser ;
   struct AVPacketList *last_in_packet_buffer ;
   AVProbeData probe_data ;
   int64_t pts_buffer[17] ;
   AVIndexEntry *index_entries ;
   int nb_index_entries ;
   unsigned int index_entries_allocated_size ;
   int stream_identifier ;
   int program_num ;
   int pmt_version ;
   int pmt_stream_idx ;
   int64_t interleaver_chunk_size ;
   int64_t interleaver_chunk_duration ;
   int request_probe ;
   int skip_to_keyframe ;
   int skip_samples ;
   int64_t start_skip_samples ;
   int64_t first_discard_sample ;
   int64_t last_discard_sample ;
   int nb_decoded_frames ;
   int64_t mux_ts_offset ;
   int64_t pts_wrap_reference ;
   int pts_wrap_behavior ;
   int update_initial_durations_done ;
   int64_t pts_reorder_error[17] ;
   uint8_t pts_reorder_error_count[17] ;
   int64_t last_dts_for_order_check ;
   uint8_t dts_ordered ;
   uint8_t dts_misordered ;
   int inject_global_side_data ;
   AVRational display_aspect_ratio ;
   AVStreamInternal *internal ;
};
typedef struct AVStream AVStream;
struct AVProgram {
   int id ;
   int flags ;
   enum AVDiscard discard ;
   unsigned int *stream_index ;
   unsigned int nb_stream_indexes ;
   AVDictionary *metadata ;
   int program_num ;
   int pmt_pid ;
   int pcr_pid ;
   int pmt_version ;
   int64_t start_time ;
   int64_t end_time ;
   int64_t pts_wrap_reference ;
   int pts_wrap_behavior ;
};
typedef struct AVProgram AVProgram;
struct AVChapter {
   int id ;
   AVRational time_base ;
   int64_t start ;
   int64_t end ;
   AVDictionary *metadata ;
};
typedef struct AVChapter AVChapter;
enum AVDurationEstimationMethod {
    AVFMT_DURATION_FROM_PTS = 0,
    AVFMT_DURATION_FROM_STREAM = 1,
    AVFMT_DURATION_FROM_BITRATE = 2
} ;
struct AVFormatInternal ;
typedef struct AVFormatInternal AVFormatInternal;
struct AVFormatContext {
   AVClass const   *av_class ;
   struct AVInputFormat *iformat ;
   struct AVOutputFormat *oformat ;
   void *priv_data ;
   AVIOContext *pb ;
   int ctx_flags ;
   unsigned int nb_streams ;
   AVStream **streams ;
   char __attribute__((__deprecated__))  filename[1024] ;
   char *url ;
   int64_t start_time ;
   int64_t duration ;
   int64_t bit_rate ;
   unsigned int packet_size ;
   int max_delay ;
   int flags ;
   int64_t probesize ;
   int64_t max_analyze_duration ;
   uint8_t const   *key ;
   int keylen ;
   unsigned int nb_programs ;
   AVProgram **programs ;
   enum AVCodecID video_codec_id ;
   enum AVCodecID audio_codec_id ;
   enum AVCodecID subtitle_codec_id ;
   unsigned int max_index_size ;
   unsigned int max_picture_buffer ;
   unsigned int nb_chapters ;
   AVChapter **chapters ;
   AVDictionary *metadata ;
   int64_t start_time_realtime ;
   int fps_probe_size ;
   int error_recognition ;
   AVIOInterruptCB interrupt_callback ;
   int debug ;
   int64_t max_interleave_delta ;
   int strict_std_compliance ;
   int event_flags ;
   int max_ts_probe ;
   int avoid_negative_ts ;
   int ts_id ;
   int audio_preload ;
   int max_chunk_duration ;
   int max_chunk_size ;
   int use_wallclock_as_timestamps ;
   int avio_flags ;
   enum AVDurationEstimationMethod duration_estimation_method ;
   int64_t skip_initial_bytes ;
   unsigned int correct_ts_overflow ;
   int seek2any ;
   int flush_packets ;
   int probe_score ;
   int format_probesize ;
   char *codec_whitelist ;
   char *format_whitelist ;
   AVFormatInternal *internal ;
   int io_repositioned ;
   AVCodec *video_codec ;
   AVCodec *audio_codec ;
   AVCodec *subtitle_codec ;
   AVCodec *data_codec ;
   int metadata_header_padding ;
   void *opaque ;
   int (*control_message_cb)(struct AVFormatContext *s , int type , void *data , size_t data_size ) ;
   int64_t output_ts_offset ;
   uint8_t *dump_separator ;
   enum AVCodecID data_codec_id ;
   int __attribute__((__deprecated__))  (*open_cb)(struct AVFormatContext *s , AVIOContext **p ,
                                                   char const   *url , int flags ,
                                                   AVIOInterruptCB const   *int_cb ,
                                                   AVDictionary **options ) ;
   char *protocol_whitelist ;
   int (*io_open)(struct AVFormatContext *s , AVIOContext **pb , char const   *url ,
                  int flags , AVDictionary **options ) ;
   void (*io_close)(struct AVFormatContext *s , AVIOContext *pb ) ;
   char *protocol_blacklist ;
   int max_streams ;
   int skip_estimate_duration_from_pts ;
};
typedef struct AVFormatContext AVFormatContext;
struct AVPacketList {
   AVPacket pkt ;
   struct AVPacketList *next ;
};
struct AVFilterContext ;
typedef struct AVFilterContext AVFilterContext;
struct AVFilterLink ;
typedef struct AVFilterLink AVFilterLink;
struct AVFilterPad ;
typedef struct AVFilterPad AVFilterPad;
struct AVFilterFormats ;
typedef struct AVFilterFormats AVFilterFormats;
struct AVFilter {
   char const   *name ;
   char const   *description ;
   AVFilterPad const   *inputs ;
   AVFilterPad const   *outputs ;
   AVClass const   *priv_class ;
   int flags ;
   int (*preinit)(AVFilterContext *ctx ) ;
   int (*init)(AVFilterContext *ctx ) ;
   int (*init_dict)(AVFilterContext *ctx , AVDictionary **options ) ;
   void (*uninit)(AVFilterContext *ctx ) ;
   int (*query_formats)(AVFilterContext * ) ;
   int priv_size ;
   int flags_internal ;
   struct AVFilter *next ;
   int (*process_command)(AVFilterContext * , char const   *cmd , char const   *arg ,
                          char *res , int res_len , int flags ) ;
   int (*init_opaque)(AVFilterContext *ctx , void *opaque ) ;
   int (*activate)(AVFilterContext *ctx ) ;
};
typedef struct AVFilter AVFilter;
struct AVFilterInternal ;
typedef struct AVFilterInternal AVFilterInternal;
struct AVFilterGraph ;
struct AVFilterCommand ;
struct AVFilterContext {
   AVClass const   *av_class ;
   AVFilter const   *filter ;
   char *name ;
   AVFilterPad *input_pads ;
   AVFilterLink **inputs ;
   unsigned int nb_inputs ;
   AVFilterPad *output_pads ;
   AVFilterLink **outputs ;
   unsigned int nb_outputs ;
   void *priv ;
   struct AVFilterGraph *graph ;
   int thread_type ;
   AVFilterInternal *internal ;
   struct AVFilterCommand *command_queue ;
   char *enable_str ;
   void *enable ;
   double *var_values ;
   int is_disabled ;
   AVBufferRef *hw_device_ctx ;
   int nb_threads ;
   unsigned int ready ;
   int extra_hw_frames ;
};
struct AVFilterChannelLayouts ;
enum __anonenum_init_state_395822227 {
    AVLINK_UNINIT = 0,
    AVLINK_STARTINIT = 1,
    AVLINK_INIT = 2
} ;
struct AVFilterLink {
   AVFilterContext *src ;
   AVFilterPad *srcpad ;
   AVFilterContext *dst ;
   AVFilterPad *dstpad ;
   enum AVMediaType type ;
   int w ;
   int h ;
   AVRational sample_aspect_ratio ;
   uint64_t channel_layout ;
   int sample_rate ;
   int format ;
   AVRational time_base ;
   AVFilterFormats *in_formats ;
   AVFilterFormats *out_formats ;
   AVFilterFormats *in_samplerates ;
   AVFilterFormats *out_samplerates ;
   struct AVFilterChannelLayouts *in_channel_layouts ;
   struct AVFilterChannelLayouts *out_channel_layouts ;
   int request_samples ;
   enum __anonenum_init_state_395822227 init_state ;
   struct AVFilterGraph *graph ;
   int64_t current_pts ;
   int64_t current_pts_us ;
   int age_index ;
   AVRational frame_rate ;
   AVFrame *partial_buf ;
   int partial_buf_size ;
   int min_samples ;
   int max_samples ;
   int channels ;
   unsigned int flags ;
   int64_t frame_count_in ;
   int64_t frame_count_out ;
   void *frame_pool ;
   int frame_wanted_out ;
   AVBufferRef *hw_frames_ctx ;
   char reserved[61440] ;
};
struct AVFilterGraphInternal ;
typedef struct AVFilterGraphInternal AVFilterGraphInternal;
typedef int avfilter_action_func(AVFilterContext *ctx , void *arg , int jobnr , int nb_jobs );
typedef int avfilter_execute_func(AVFilterContext *ctx , avfilter_action_func *func ,
                                  void *arg , int *ret , int nb_jobs );
struct AVFilterGraph {
   AVClass const   *av_class ;
   AVFilterContext **filters ;
   unsigned int nb_filters ;
   char *scale_sws_opts ;
   char __attribute__((__deprecated__))  *resample_lavr_opts ;
   int thread_type ;
   int nb_threads ;
   AVFilterGraphInternal *internal ;
   void *opaque ;
   avfilter_execute_func *execute ;
   char *aresample_swr_opts ;
   AVFilterLink **sink_links ;
   int sink_links_count ;
   unsigned int disable_auto_convert ;
};
typedef struct AVFilterGraph AVFilterGraph;
enum __anonenum_BarKeyShortcutId_t_540388776 {
    BAR_KS_HELP = 0,
    BAR_KS_LOVE = 1,
    BAR_KS_BAN = 2,
    BAR_KS_ADDMUSIC = 3,
    BAR_KS_CREATESTATION = 4,
    BAR_KS_DELETESTATION = 5,
    BAR_KS_EXPLAIN = 6,
    BAR_KS_GENRESTATION = 7,
    BAR_KS_HISTORY = 8,
    BAR_KS_INFO = 9,
    BAR_KS_ADDSHARED = 10,
    BAR_KS_SKIP = 11,
    BAR_KS_PLAYPAUSE = 12,
    BAR_KS_QUIT = 13,
    BAR_KS_RENAMESTATION = 14,
    BAR_KS_SELECTSTATION = 15,
    BAR_KS_TIRED = 16,
    BAR_KS_UPCOMING = 17,
    BAR_KS_SELECTQUICKMIX = 18,
    BAR_KS_DEBUG = 19,
    BAR_KS_BOOKMARK = 20,
    BAR_KS_VOLDOWN = 21,
    BAR_KS_VOLUP = 22,
    BAR_KS_MANAGESTATION = 23,
    BAR_KS_PLAYPAUSE2 = 24,
    BAR_KS_CREATESTATIONFROMSONG = 25,
    BAR_KS_PLAY = 26,
    BAR_KS_PAUSE = 27,
    BAR_KS_VOLRESET = 28,
    BAR_KS_SETTINGS = 29,
    BAR_KS_COUNT = 30
} ;
typedef enum __anonenum_BarKeyShortcutId_t_540388776 BarKeyShortcutId_t;
enum __anonenum_BarStationSorting_t_648870747 {
    BAR_SORT_NAME_AZ = 0,
    BAR_SORT_NAME_ZA = 1,
    BAR_SORT_QUICKMIX_01_NAME_AZ = 2,
    BAR_SORT_QUICKMIX_01_NAME_ZA = 3,
    BAR_SORT_QUICKMIX_10_NAME_AZ = 4,
    BAR_SORT_QUICKMIX_10_NAME_ZA = 5,
    BAR_SORT_COUNT = 6
} ;
typedef enum __anonenum_BarStationSorting_t_648870747 BarStationSorting_t;
struct __anonstruct_BarMsgFormatStr_t_476363767 {
   char *prefix ;
   char *postfix ;
};
typedef struct __anonstruct_BarMsgFormatStr_t_476363767 BarMsgFormatStr_t;
enum __anonenum_BarUiMsg_t_774981372 {
    MSG_NONE = 0,
    MSG_INFO = 1,
    MSG_PLAYING = 2,
    MSG_TIME = 3,
    MSG_ERR = 4,
    MSG_QUESTION = 5,
    MSG_LIST = 6,
    MSG_COUNT = 7
} ;
typedef enum __anonenum_BarUiMsg_t_774981372 BarUiMsg_t;
struct __anonstruct_BarSettings_t_498659073 {
   _Bool autoselect ;
   unsigned int history ;
   unsigned int maxRetry ;
   unsigned int timeout ;
   unsigned int bufferSecs ;
   int volume ;
   float gainMul ;
   BarStationSorting_t sortOrder ;
   PianoAudioQuality_t audioQuality ;
   char *username ;
   char *password ;
   char *passwordCmd ;
   char *controlProxy ;
   char *proxy ;
   char *bindTo ;
   char *autostartStation ;
   char *eventCmd ;
   char *loveIcon ;
   char *banIcon ;
   char *tiredIcon ;
   char *atIcon ;
   char *npSongFormat ;
   char *npStationFormat ;
   char *listSongFormat ;
   char *timeFormat ;
   char *fifo ;
   char *rpcHost ;
   char *rpcTlsPort ;
   char *partnerUser ;
   char *partnerPassword ;
   char *device ;
   char *inkey ;
   char *outkey ;
   char *caBundle ;
   char *audioPipe ;
   char keys[30] ;
   int sampleRate ;
   BarMsgFormatStr_t msgFormat[7] ;
};
typedef struct __anonstruct_BarSettings_t_498659073 BarSettings_t;
enum __anonenum_BarPlayerMode_11296495 {
    PLAYER_DEAD = 0,
    PLAYER_WAITING = 1,
    PLAYER_PLAYING = 2,
    PLAYER_FINISHED = 3
} ;
typedef enum __anonenum_BarPlayerMode_11296495 BarPlayerMode;
struct __anonstruct_player_t_802006497 {
   pthread_mutex_t lock ;
   pthread_mutex_t aoplayLock ;
   pthread_cond_t cond ;
   pthread_cond_t aoplayCond ;
   _Bool doQuit ;
   _Bool doPause ;
   unsigned int songDuration ;
   unsigned int songPlayed ;
   BarPlayerMode mode ;
   AVFilterContext *fvolume ;
   AVFilterGraph *fgraph ;
   AVFormatContext *fctx ;
   AVStream *st ;
   AVCodecContext *cctx ;
   AVFilterContext *fbufsink ;
   AVFilterContext *fabuf ;
   int streamIdx ;
   int64_t lastTimestamp ;
   sig_atomic_t interrupted ;
   ao_device *aoDev ;
   double gain ;
   char *url ;
   BarSettings_t const   *settings ;
};
typedef struct __anonstruct_player_t_802006497 player_t;
enum __anonenum_BarReadlineFlags_t_696436146 {
    BAR_RL_DEFAULT = 0,
    BAR_RL_FULLRETURN = 1,
    BAR_RL_NOECHO = 2,
    BAR_RL_NOINT = 4
} ;
typedef enum __anonenum_BarReadlineFlags_t_696436146 BarReadlineFlags_t;
struct __anonstruct_BarReadlineFds_t_550597175 {
   fd_set set ;
   int maxfd ;
   int fds[2] ;
};
typedef struct __anonstruct_BarReadlineFds_t_550597175 BarReadlineFds_t;
struct __anonstruct_BarApp_t_215541748 {
   PianoHandle_t ph ;
   CURL *http ;
   player_t player ;
   BarSettings_t settings ;
   PianoSong_t *playlist ;
   PianoSong_t *songHistory ;
   PianoStation_t *curStation ;
   PianoStation_t *nextStation ;
   sig_atomic_t doQuit ;
   BarReadlineFds_t input ;
   unsigned int playerErrors ;
};
typedef struct __anonstruct_BarApp_t_215541748 BarApp_t;
enum __anonenum_BarUiDispatchContext_t_1004206478 {
    BAR_DC_UNDEFINED = 0,
    BAR_DC_GLOBAL = 1,
    BAR_DC_STATION = 2,
    BAR_DC_SONG = 4
} ;
typedef enum __anonenum_BarUiDispatchContext_t_1004206478 BarUiDispatchContext_t;
typedef unsigned long uintptr_t;
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
union __anonunion_pthread_condattr_t_488594145 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_condattr_t_488594145 pthread_condattr_t;
enum AVOptionType {
    AV_OPT_TYPE_FLAGS = 0,
    AV_OPT_TYPE_INT = 1,
    AV_OPT_TYPE_INT64 = 2,
    AV_OPT_TYPE_DOUBLE = 3,
    AV_OPT_TYPE_FLOAT = 4,
    AV_OPT_TYPE_STRING = 5,
    AV_OPT_TYPE_RATIONAL = 6,
    AV_OPT_TYPE_BINARY = 7,
    AV_OPT_TYPE_DICT = 8,
    AV_OPT_TYPE_UINT64 = 9,
    AV_OPT_TYPE_CONST = 10,
    AV_OPT_TYPE_IMAGE_SIZE = 11,
    AV_OPT_TYPE_PIXEL_FMT = 12,
    AV_OPT_TYPE_SAMPLE_FMT = 13,
    AV_OPT_TYPE_VIDEO_RATE = 14,
    AV_OPT_TYPE_DURATION = 15,
    AV_OPT_TYPE_COLOR = 16,
    AV_OPT_TYPE_CHANNEL_LAYOUT = 17,
    AV_OPT_TYPE_BOOL = 18
} ;
union __anonunion_default_val_762784759 {
   int64_t i64 ;
   double dbl ;
   char const   *str ;
   AVRational q ;
};
struct AVOption {
   char const   *name ;
   char const   *help ;
   int offset ;
   enum AVOptionType type ;
   union __anonunion_default_val_762784759 default_val ;
   double min ;
   double max ;
   int flags ;
   char const   *unit ;
};
struct AVOptionRange {
   char const   *str ;
   double value_min ;
   double value_max ;
   double component_min ;
   double component_max ;
   int is_range ;
};
typedef struct AVOptionRange AVOptionRange;
struct AVOptionRanges {
   AVOptionRange **range ;
   int nb_ranges ;
   int nb_components ;
};
typedef unsigned int uint_32;
struct ao_sample_format {
   int bits ;
   int rate ;
   int channels ;
   int byte_format ;
   char *matrix ;
};
typedef struct ao_sample_format ao_sample_format;
struct ao_option {
   char *key ;
   char *value ;
   struct ao_option *next ;
};
typedef struct ao_option ao_option;
typedef struct AVInputFormat AVInputFormat;
enum __anonenum_drainMode_989564894 {
    FILL = 0,
    DRAIN = 1,
    DONE = 2
} ;
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
struct __anonstruct_BarUiDispatchAction_t_315043967 {
   char defaultKey ;
   BarUiDispatchContext_t context ;
   void (*function)(BarApp_t * , PianoStation_t * , PianoSong_t * , BarUiDispatchContext_t  ) ;
   char const   * const  helpText ;
   char const   * const  configKey ;
};
typedef struct __anonstruct_BarUiDispatchAction_t_315043967 BarUiDispatchAction_t;
typedef unsigned char cc_t;
typedef unsigned int speed_t;
typedef unsigned int tcflag_t;
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
struct PianoArtist {
   PianoListHead_t head ;
   char *name ;
   char *musicId ;
   char *seedId ;
   int score ;
};
typedef struct PianoArtist PianoArtist_t;
struct __anonstruct_PianoStationInfo_t_433712355 {
   PianoSong_t *songSeeds ;
   PianoArtist_t *artistSeeds ;
   PianoStation_t *stationSeeds ;
   PianoSong_t *feedback ;
};
typedef struct __anonstruct_PianoStationInfo_t_433712355 PianoStationInfo_t;
struct __anonstruct_PianoSettings_t_630908213 {
   char *username ;
   _Bool explicitContentFilter ;
};
typedef struct __anonstruct_PianoSettings_t_630908213 PianoSettings_t;
struct __anonstruct_PianoStationMode_t_460202994 {
   PianoListHead_t head ;
   char *name ;
   char *description ;
   _Bool isAlgorithmic ;
   _Bool isTakeover ;
   _Bool active ;
   int id ;
};
typedef struct __anonstruct_PianoStationMode_t_460202994 PianoStationMode_t;
struct __anonstruct_PianoRequestDataRateSong_t_734572046 {
   PianoSong_t *song ;
   PianoSongRating_t rating ;
};
typedef struct __anonstruct_PianoRequestDataRateSong_t_734572046 PianoRequestDataRateSong_t;
struct __anonstruct_PianoRequestDataRenameStation_t_302001453 {
   PianoStation_t *station ;
   char *newName ;
};
typedef struct __anonstruct_PianoRequestDataRenameStation_t_302001453 PianoRequestDataRenameStation_t;
enum __anonenum_type_185732391 {
    PIANO_MUSICTYPE_INVALID = 0,
    PIANO_MUSICTYPE_SONG = 1,
    PIANO_MUSICTYPE_ARTIST = 2
} ;
struct __anonstruct_PianoRequestDataCreateStation_t_733199068 {
   char *token ;
   enum __anonenum_type_185732391 type ;
};
typedef struct __anonstruct_PianoRequestDataCreateStation_t_733199068 PianoRequestDataCreateStation_t;
struct __anonstruct_PianoRequestDataAddSeed_t_846105165 {
   PianoStation_t *station ;
   char *musicId ;
};
typedef struct __anonstruct_PianoRequestDataAddSeed_t_846105165 PianoRequestDataAddSeed_t;
struct __anonstruct_PianoRequestDataExplain_t_569239397 {
   PianoSong_t *song ;
   char *retExplain ;
};
typedef struct __anonstruct_PianoRequestDataExplain_t_569239397 PianoRequestDataExplain_t;
struct __anonstruct_PianoRequestDataGetStationInfo_t_492757416 {
   PianoStation_t *station ;
   PianoStationInfo_t info ;
};
typedef struct __anonstruct_PianoRequestDataGetStationInfo_t_492757416 PianoRequestDataGetStationInfo_t;
struct __anonstruct_PianoRequestDataDeleteSeed_t_815195772 {
   PianoSong_t *song ;
   PianoArtist_t *artist ;
   PianoStation_t *station ;
};
typedef struct __anonstruct_PianoRequestDataDeleteSeed_t_815195772 PianoRequestDataDeleteSeed_t;
enum __anonenum_PianoTristate_t_148770165 {
    PIANO_UNDEFINED = 0,
    PIANO_FALSE = 1,
    PIANO_TRUE = 2
} ;
typedef enum __anonenum_PianoTristate_t_148770165 PianoTristate_t;
struct __anonstruct_PianoRequestDataChangeSettings_t_634463242 {
   char *currentUsername ;
   char *newUsername ;
   char *currentPassword ;
   char *newPassword ;
   PianoTristate_t explicitContentFilter ;
};
typedef struct __anonstruct_PianoRequestDataChangeSettings_t_634463242 PianoRequestDataChangeSettings_t;
struct __anonstruct_PianoRequestDataGetStationModes_t_379829503 {
   PianoStation_t *station ;
   PianoStationMode_t *retModes ;
};
typedef struct __anonstruct_PianoRequestDataGetStationModes_t_379829503 PianoRequestDataGetStationModes_t;
struct __anonstruct_PianoRequestDataSetStationMode_t_201641957 {
   PianoStation_t *station ;
   unsigned int id ;
};
typedef struct __anonstruct_PianoRequestDataSetStationMode_t_201641957 PianoRequestDataSetStationMode_t;
typedef __gnuc_va_list va_list___0;
struct PianoSearchResult {
   PianoSong_t *songs ;
   PianoArtist_t *artists ;
};
typedef struct PianoSearchResult PianoSearchResult_t;
struct PianoRequest {
   PianoRequestType_t type ;
   _Bool secure ;
   void *data ;
   char urlPath[1024] ;
   char *postData ;
   char *responseData ;
};
typedef struct PianoRequest PianoRequest_t;
struct __anonstruct_PianoRequestDataSearch_t_846105164 {
   char *searchStr ;
   PianoSearchResult_t searchResult ;
};
typedef struct __anonstruct_PianoRequestDataSearch_t_846105164 PianoRequestDataSearch_t;
struct curl_slist ;
enum __anonenum_CURLoption_714703655 {
    CURLOPT_WRITEDATA = 10001,
    CURLOPT_URL = 10002,
    CURLOPT_PORT = 3,
    CURLOPT_PROXY = 10004,
    CURLOPT_USERPWD = 10005,
    CURLOPT_PROXYUSERPWD = 10006,
    CURLOPT_RANGE = 10007,
    CURLOPT_READDATA = 10009,
    CURLOPT_ERRORBUFFER = 10010,
    CURLOPT_WRITEFUNCTION = 20011,
    CURLOPT_READFUNCTION = 20012,
    CURLOPT_TIMEOUT = 13,
    CURLOPT_INFILESIZE = 14,
    CURLOPT_POSTFIELDS = 10015,
    CURLOPT_REFERER = 10016,
    CURLOPT_FTPPORT = 10017,
    CURLOPT_USERAGENT = 10018,
    CURLOPT_LOW_SPEED_LIMIT = 19,
    CURLOPT_LOW_SPEED_TIME = 20,
    CURLOPT_RESUME_FROM = 21,
    CURLOPT_COOKIE = 10022,
    CURLOPT_HTTPHEADER = 10023,
    CURLOPT_HTTPPOST = 10024,
    CURLOPT_SSLCERT = 10025,
    CURLOPT_KEYPASSWD = 10026,
    CURLOPT_CRLF = 27,
    CURLOPT_QUOTE = 10028,
    CURLOPT_HEADERDATA = 10029,
    CURLOPT_COOKIEFILE = 10031,
    CURLOPT_SSLVERSION = 32,
    CURLOPT_TIMECONDITION = 33,
    CURLOPT_TIMEVALUE = 34,
    CURLOPT_CUSTOMREQUEST = 10036,
    CURLOPT_STDERR = 10037,
    CURLOPT_POSTQUOTE = 10039,
    CURLOPT_OBSOLETE40 = 10040,
    CURLOPT_VERBOSE = 41,
    CURLOPT_HEADER = 42,
    CURLOPT_NOPROGRESS = 43,
    CURLOPT_NOBODY = 44,
    CURLOPT_FAILONERROR = 45,
    CURLOPT_UPLOAD = 46,
    CURLOPT_POST = 47,
    CURLOPT_DIRLISTONLY = 48,
    CURLOPT_APPEND = 50,
    CURLOPT_NETRC = 51,
    CURLOPT_FOLLOWLOCATION = 52,
    CURLOPT_TRANSFERTEXT = 53,
    CURLOPT_PUT = 54,
    CURLOPT_PROGRESSFUNCTION = 20056,
    CURLOPT_PROGRESSDATA = 10057,
    CURLOPT_AUTOREFERER = 58,
    CURLOPT_PROXYPORT = 59,
    CURLOPT_POSTFIELDSIZE = 60,
    CURLOPT_HTTPPROXYTUNNEL = 61,
    CURLOPT_INTERFACE = 10062,
    CURLOPT_KRBLEVEL = 10063,
    CURLOPT_SSL_VERIFYPEER = 64,
    CURLOPT_CAINFO = 10065,
    CURLOPT_MAXREDIRS = 68,
    CURLOPT_FILETIME = 69,
    CURLOPT_TELNETOPTIONS = 10070,
    CURLOPT_MAXCONNECTS = 71,
    CURLOPT_OBSOLETE72 = 72,
    CURLOPT_FRESH_CONNECT = 74,
    CURLOPT_FORBID_REUSE = 75,
    CURLOPT_RANDOM_FILE = 10076,
    CURLOPT_EGDSOCKET = 10077,
    CURLOPT_CONNECTTIMEOUT = 78,
    CURLOPT_HEADERFUNCTION = 20079,
    CURLOPT_HTTPGET = 80,
    CURLOPT_SSL_VERIFYHOST = 81,
    CURLOPT_COOKIEJAR = 10082,
    CURLOPT_SSL_CIPHER_LIST = 10083,
    CURLOPT_HTTP_VERSION = 84,
    CURLOPT_FTP_USE_EPSV = 85,
    CURLOPT_SSLCERTTYPE = 10086,
    CURLOPT_SSLKEY = 10087,
    CURLOPT_SSLKEYTYPE = 10088,
    CURLOPT_SSLENGINE = 10089,
    CURLOPT_SSLENGINE_DEFAULT = 90,
    CURLOPT_DNS_USE_GLOBAL_CACHE = 91,
    CURLOPT_DNS_CACHE_TIMEOUT = 92,
    CURLOPT_PREQUOTE = 10093,
    CURLOPT_DEBUGFUNCTION = 20094,
    CURLOPT_DEBUGDATA = 10095,
    CURLOPT_COOKIESESSION = 96,
    CURLOPT_CAPATH = 10097,
    CURLOPT_BUFFERSIZE = 98,
    CURLOPT_NOSIGNAL = 99,
    CURLOPT_SHARE = 10100,
    CURLOPT_PROXYTYPE = 101,
    CURLOPT_ACCEPT_ENCODING = 10102,
    CURLOPT_PRIVATE = 10103,
    CURLOPT_HTTP200ALIASES = 10104,
    CURLOPT_UNRESTRICTED_AUTH = 105,
    CURLOPT_FTP_USE_EPRT = 106,
    CURLOPT_HTTPAUTH = 107,
    CURLOPT_SSL_CTX_FUNCTION = 20108,
    CURLOPT_SSL_CTX_DATA = 10109,
    CURLOPT_FTP_CREATE_MISSING_DIRS = 110,
    CURLOPT_PROXYAUTH = 111,
    CURLOPT_FTP_RESPONSE_TIMEOUT = 112,
    CURLOPT_IPRESOLVE = 113,
    CURLOPT_MAXFILESIZE = 114,
    CURLOPT_INFILESIZE_LARGE = 30115,
    CURLOPT_RESUME_FROM_LARGE = 30116,
    CURLOPT_MAXFILESIZE_LARGE = 30117,
    CURLOPT_NETRC_FILE = 10118,
    CURLOPT_USE_SSL = 119,
    CURLOPT_POSTFIELDSIZE_LARGE = 30120,
    CURLOPT_TCP_NODELAY = 121,
    CURLOPT_FTPSSLAUTH = 129,
    CURLOPT_IOCTLFUNCTION = 20130,
    CURLOPT_IOCTLDATA = 10131,
    CURLOPT_FTP_ACCOUNT = 10134,
    CURLOPT_COOKIELIST = 10135,
    CURLOPT_IGNORE_CONTENT_LENGTH = 136,
    CURLOPT_FTP_SKIP_PASV_IP = 137,
    CURLOPT_FTP_FILEMETHOD = 138,
    CURLOPT_LOCALPORT = 139,
    CURLOPT_LOCALPORTRANGE = 140,
    CURLOPT_CONNECT_ONLY = 141,
    CURLOPT_CONV_FROM_NETWORK_FUNCTION = 20142,
    CURLOPT_CONV_TO_NETWORK_FUNCTION = 20143,
    CURLOPT_CONV_FROM_UTF8_FUNCTION = 20144,
    CURLOPT_MAX_SEND_SPEED_LARGE = 30145,
    CURLOPT_MAX_RECV_SPEED_LARGE = 30146,
    CURLOPT_FTP_ALTERNATIVE_TO_USER = 10147,
    CURLOPT_SOCKOPTFUNCTION = 20148,
    CURLOPT_SOCKOPTDATA = 10149,
    CURLOPT_SSL_SESSIONID_CACHE = 150,
    CURLOPT_SSH_AUTH_TYPES = 151,
    CURLOPT_SSH_PUBLIC_KEYFILE = 10152,
    CURLOPT_SSH_PRIVATE_KEYFILE = 10153,
    CURLOPT_FTP_SSL_CCC = 154,
    CURLOPT_TIMEOUT_MS = 155,
    CURLOPT_CONNECTTIMEOUT_MS = 156,
    CURLOPT_HTTP_TRANSFER_DECODING = 157,
    CURLOPT_HTTP_CONTENT_DECODING = 158,
    CURLOPT_NEW_FILE_PERMS = 159,
    CURLOPT_NEW_DIRECTORY_PERMS = 160,
    CURLOPT_POSTREDIR = 161,
    CURLOPT_SSH_HOST_PUBLIC_KEY_MD5 = 10162,
    CURLOPT_OPENSOCKETFUNCTION = 20163,
    CURLOPT_OPENSOCKETDATA = 10164,
    CURLOPT_COPYPOSTFIELDS = 10165,
    CURLOPT_PROXY_TRANSFER_MODE = 166,
    CURLOPT_SEEKFUNCTION = 20167,
    CURLOPT_SEEKDATA = 10168,
    CURLOPT_CRLFILE = 10169,
    CURLOPT_ISSUERCERT = 10170,
    CURLOPT_ADDRESS_SCOPE = 171,
    CURLOPT_CERTINFO = 172,
    CURLOPT_USERNAME = 10173,
    CURLOPT_PASSWORD = 10174,
    CURLOPT_PROXYUSERNAME = 10175,
    CURLOPT_PROXYPASSWORD = 10176,
    CURLOPT_NOPROXY = 10177,
    CURLOPT_TFTP_BLKSIZE = 178,
    CURLOPT_SOCKS5_GSSAPI_SERVICE = 10179,
    CURLOPT_SOCKS5_GSSAPI_NEC = 180,
    CURLOPT_PROTOCOLS = 181,
    CURLOPT_REDIR_PROTOCOLS = 182,
    CURLOPT_SSH_KNOWNHOSTS = 10183,
    CURLOPT_SSH_KEYFUNCTION = 20184,
    CURLOPT_SSH_KEYDATA = 10185,
    CURLOPT_MAIL_FROM = 10186,
    CURLOPT_MAIL_RCPT = 10187,
    CURLOPT_FTP_USE_PRET = 188,
    CURLOPT_RTSP_REQUEST = 189,
    CURLOPT_RTSP_SESSION_ID = 10190,
    CURLOPT_RTSP_STREAM_URI = 10191,
    CURLOPT_RTSP_TRANSPORT = 10192,
    CURLOPT_RTSP_CLIENT_CSEQ = 193,
    CURLOPT_RTSP_SERVER_CSEQ = 194,
    CURLOPT_INTERLEAVEDATA = 10195,
    CURLOPT_INTERLEAVEFUNCTION = 20196,
    CURLOPT_WILDCARDMATCH = 197,
    CURLOPT_CHUNK_BGN_FUNCTION = 20198,
    CURLOPT_CHUNK_END_FUNCTION = 20199,
    CURLOPT_FNMATCH_FUNCTION = 20200,
    CURLOPT_CHUNK_DATA = 10201,
    CURLOPT_FNMATCH_DATA = 10202,
    CURLOPT_RESOLVE = 10203,
    CURLOPT_TLSAUTH_USERNAME = 10204,
    CURLOPT_TLSAUTH_PASSWORD = 10205,
    CURLOPT_TLSAUTH_TYPE = 10206,
    CURLOPT_TRANSFER_ENCODING = 207,
    CURLOPT_CLOSESOCKETFUNCTION = 20208,
    CURLOPT_CLOSESOCKETDATA = 10209,
    CURLOPT_GSSAPI_DELEGATION = 210,
    CURLOPT_DNS_SERVERS = 10211,
    CURLOPT_ACCEPTTIMEOUT_MS = 212,
    CURLOPT_TCP_KEEPALIVE = 213,
    CURLOPT_TCP_KEEPIDLE = 214,
    CURLOPT_TCP_KEEPINTVL = 215,
    CURLOPT_SSL_OPTIONS = 216,
    CURLOPT_MAIL_AUTH = 10217,
    CURLOPT_SASL_IR = 218,
    CURLOPT_XFERINFOFUNCTION = 20219,
    CURLOPT_XOAUTH2_BEARER = 10220,
    CURLOPT_DNS_INTERFACE = 10221,
    CURLOPT_DNS_LOCAL_IP4 = 10222,
    CURLOPT_DNS_LOCAL_IP6 = 10223,
    CURLOPT_LOGIN_OPTIONS = 10224,
    CURLOPT_SSL_ENABLE_NPN = 225,
    CURLOPT_SSL_ENABLE_ALPN = 226,
    CURLOPT_EXPECT_100_TIMEOUT_MS = 227,
    CURLOPT_PROXYHEADER = 10228,
    CURLOPT_HEADEROPT = 229,
    CURLOPT_PINNEDPUBLICKEY = 10230,
    CURLOPT_UNIX_SOCKET_PATH = 10231,
    CURLOPT_SSL_VERIFYSTATUS = 232,
    CURLOPT_SSL_FALSESTART = 233,
    CURLOPT_PATH_AS_IS = 234,
    CURLOPT_PROXY_SERVICE_NAME = 10235,
    CURLOPT_SERVICE_NAME = 10236,
    CURLOPT_PIPEWAIT = 237,
    CURLOPT_DEFAULT_PROTOCOL = 10238,
    CURLOPT_STREAM_WEIGHT = 239,
    CURLOPT_STREAM_DEPENDS = 10240,
    CURLOPT_STREAM_DEPENDS_E = 10241,
    CURLOPT_TFTP_NO_OPTIONS = 242,
    CURLOPT_CONNECT_TO = 10243,
    CURLOPT_TCP_FASTOPEN = 244,
    CURLOPT_KEEP_SENDING_ON_ERROR = 245,
    CURLOPT_PROXY_CAINFO = 10246,
    CURLOPT_PROXY_CAPATH = 10247,
    CURLOPT_PROXY_SSL_VERIFYPEER = 248,
    CURLOPT_PROXY_SSL_VERIFYHOST = 249,
    CURLOPT_PROXY_SSLVERSION = 250,
    CURLOPT_PROXY_TLSAUTH_USERNAME = 10251,
    CURLOPT_PROXY_TLSAUTH_PASSWORD = 10252,
    CURLOPT_PROXY_TLSAUTH_TYPE = 10253,
    CURLOPT_PROXY_SSLCERT = 10254,
    CURLOPT_PROXY_SSLCERTTYPE = 10255,
    CURLOPT_PROXY_SSLKEY = 10256,
    CURLOPT_PROXY_SSLKEYTYPE = 10257,
    CURLOPT_PROXY_KEYPASSWD = 10258,
    CURLOPT_PROXY_SSL_CIPHER_LIST = 10259,
    CURLOPT_PROXY_CRLFILE = 10260,
    CURLOPT_PROXY_SSL_OPTIONS = 261,
    CURLOPT_PRE_PROXY = 10262,
    CURLOPT_PROXY_PINNEDPUBLICKEY = 10263,
    CURLOPT_ABSTRACT_UNIX_SOCKET = 10264,
    CURLOPT_SUPPRESS_CONNECT_HEADERS = 265,
    CURLOPT_REQUEST_TARGET = 10266,
    CURLOPT_SOCKS5_AUTH = 267,
    CURLOPT_SSH_COMPRESSION = 268,
    CURLOPT_MIMEPOST = 10269,
    CURLOPT_TIMEVALUE_LARGE = 30270,
    CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS = 271,
    CURLOPT_RESOLVER_START_FUNCTION = 20272,
    CURLOPT_RESOLVER_START_DATA = 10273,
    CURLOPT_HAPROXYPROTOCOL = 274,
    CURLOPT_DNS_SHUFFLE_ADDRESSES = 275,
    CURLOPT_TLS13_CIPHERS = 10276,
    CURLOPT_PROXY_TLS13_CIPHERS = 10277,
    CURLOPT_DISALLOW_USERNAME_IN_URL = 278,
    CURLOPT_DOH_URL = 10279,
    CURLOPT_UPLOAD_BUFFERSIZE = 280,
    CURLOPT_UPKEEP_INTERVAL_MS = 281,
    CURLOPT_CURLU = 10282,
    CURLOPT_TRAILERFUNCTION = 20283,
    CURLOPT_TRAILERDATA = 10284,
    CURLOPT_HTTP09_ALLOWED = 285,
    CURLOPT_ALTSVC_CTRL = 286,
    CURLOPT_ALTSVC = 10287,
    CURLOPT_MAXAGE_CONN = 288,
    CURLOPT_SASL_AUTHZID = 10289,
    CURLOPT_LASTENTRY = 10290
} ;
typedef enum __anonenum_CURLoption_714703655 CURLoption;
struct curl_slist {
   char *data ;
   struct curl_slist *next ;
};
typedef int (*BarSortFunc_t)(void const   * , void const   * );
struct __anonstruct_buffer_653462436 {
   char *data ;
   size_t pos ;
};
typedef struct __anonstruct_buffer_653462436 buffer;
typedef long __suseconds_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
typedef __time_t time_t;
typedef __int32_t int32_t;
struct json_object ;
typedef int json_bool;
typedef struct json_object json_object;
struct __anonstruct_PianoRequestDataAddFeedback_t_546671994 {
   char *stationId ;
   char *trackToken ;
   PianoSongRating_t rating ;
};
typedef struct __anonstruct_PianoRequestDataAddFeedback_t_546671994 PianoRequestDataAddFeedback_t;
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#pragma merger("0","/tmp/cil-ynF54xhr.i","-O2")
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1))) strtoll)(char const   * __restrict  __nptr ,
                                                                                          char ** __restrict  __endptr ,
                                                                                          int __base ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) atoi)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return ((int )tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long ( __attribute__((__nonnull__(1), __gnu_inline__)) atol)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long long ( __attribute__((__nonnull__(1), __gnu_inline__)) atoll)(char const   *__nptr ) 
{ 
  long long tmp ;

  {
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
  return (tmp);
}
}
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
  __l = (size_t )0;
  __u = __nmemb;
  while (__l < __u) {
    __idx = (__l + __u) / 2UL;
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
    __comparison = (*__compar)(__key, __p);
    if (__comparison < 0) {
      __u = __idx;
    } else
    if (__comparison > 0) {
      __l = __idx + 1UL;
    } else {
      return ((void *)__p);
    }
  }
  return ((void *)0);
}
}
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern double ( __attribute__((__nonnull__(1), __gnu_inline__)) atof)(char const   *__nptr ) 
{ 
  double tmp ;

  {
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
extern FILE *stdin ;
extern FILE *stdout ;
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
extern int getc(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
extern int putc(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
extern int puts(char const   *__s ) ;
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
extern int __uflow(FILE * ) ;
extern int __overflow(FILE * , int  ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) 
{ 
  int tmp ;

  {
  tmp = vfprintf((FILE * __restrict  )stdout, __fmt, __arg);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) 
{ 
  int tmp ;

  {
  tmp = getc(stdin);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(__fp);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = __fp->_IO_read_ptr;
    (__fp->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(stdin);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = stdin->_IO_read_ptr;
    (stdin->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) 
{ 
  int tmp ;

  {
  tmp = putc(__c, stdout);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = __stream->_IO_write_ptr;
    (__stream->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = stdout->_IO_write_ptr;
    (stdout->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
extern int close(int __fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) execl)(char const   *__path ,
                                                                                    char const   *__arg 
                                                                                    , ...) ;
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) tolower)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_tolower_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
    tmp___0 = (__int32_t const   )__c;
  }
  return ((int )tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) toupper)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_toupper_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
    tmp___0 = (__int32_t const   )__c;
  }
  return ((int )tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat)(int __ver ,
                                                                                     int __fildes ,
                                                                                     struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat)(int __ver ,
                                                                                      char const   *__filename ,
                                                                                      struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4))) __fxstatat)(int __ver ,
                                                                                         int __fildes ,
                                                                                         char const   *__filename ,
                                                                                         struct stat *__stat_buf ,
                                                                                         int __flag ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,5))) __xmknodat)(int __ver ,
                                                                                         int __fd ,
                                                                                         char const   *__path ,
                                                                                         __mode_t __mode ,
                                                                                         __dev_t *__dev ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) stat)(char const   * __restrict  __path ,
                                                                              struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __xstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) fstat)(int __fd ,
                                                                             struct stat *__statbuf ) 
{ 
  int tmp ;

  {
  tmp = __fxstat(1, __fd, __statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag ) ;
__inline extern int ( __attribute__((__nonnull__(2,3), __gnu_inline__)) fstatat)(int __fd ,
                                                                                 char const   * __restrict  __filename ,
                                                                                 struct stat * __restrict  __statbuf ,
                                                                                 int __flag ) 
{ 
  int tmp ;

  {
  tmp = __fxstatat(1, __fd, (char const   *)__filename, (struct stat *)__statbuf,
                   __flag);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) mknodat)(int __fd ,
                                                                                             char const   *__path ,
                                                                                             __mode_t __mode ,
                                                                                             __dev_t __dev ) ;
__inline extern int ( __attribute__((__gnu_inline__)) mknodat)(int __fd , char const   *__path ,
                                                               __mode_t __mode , __dev_t __dev ) 
{ 
  int tmp ;

  {
  tmp = __xmknodat(0, __fd, __path, __mode, & __dev);
  return (tmp);
}
}
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                     pthread_t __thread2 ) 
{ 


  {
  return (__thread1 == __thread2);
}
}
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) )  __asm__("__sysv_signal")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigemptyset)(sigset_t *__set ) ;
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                               struct cmsghdr *__cmsg ) ;
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                               struct cmsghdr *__cmsg ) ;
__inline extern struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                 struct cmsghdr *__cmsg ) 
{ 


  {
  if (__cmsg->cmsg_len < sizeof(struct cmsghdr )) {
    return ((struct cmsghdr *)0);
  }
  __cmsg = (struct cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)));
  if ((unsigned long )((unsigned char *)(__cmsg + 1)) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  } else
  if ((unsigned long )((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  }
  return (__cmsg);
}
}
extern char const   *gcry_check_version(char const   *req_version ) ;
extern gcry_error_t gcry_control(enum gcry_ctl_cmds CMD  , ...) ;
PianoReturn_t PianoInit(PianoHandle_t *ph , char const   *partnerUser , char const   *partnerPassword ,
                        char const   *device , char const   *inkey , char const   *outkey ) ;
void PianoDestroy(PianoHandle_t *ph ) ;
void PianoDestroyPlaylist(PianoSong_t *playlist ) ;
PianoStation_t *PianoFindStationById(PianoStation_t * const  stations , char const   * const  searchStation ) ;
char const   *PianoErrorToStr(PianoReturn_t ret ) ;
extern CURLcode curl_global_init(long flags ) ;
extern void curl_global_cleanup(void) ;
extern CURL *curl_easy_init(void) ;
extern void curl_easy_cleanup(CURL *curl ) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   * __restrict  nptr ,
                                                                                                    char ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   * __restrict  nptr ,
                                                                                                     char ** __restrict  endptr ,
                                                                                                     int base ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                    __gwchar_t ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                     __gwchar_t ** __restrict  endptr ,
                                                                                                     int base ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) __strtol_internal)(char const   * __restrict  __nptr ,
                                                                                               char ** __restrict  __endptr ,
                                                                                               int __base ,
                                                                                               int __group ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   * __restrict  nptr ,
                                                                                                    char ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern intmax_t ( __attribute__((__gnu_inline__)) strtoimax)(char const   * __restrict  nptr ,
                                                                      char ** __restrict  endptr ,
                                                                      int base ) 
{ 
  long tmp ;

  {
  tmp = __strtol_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) __strtoul_internal)(char const   * __restrict  __nptr ,
                                                                                                         char ** __restrict  __endptr ,
                                                                                                         int __base ,
                                                                                                         int __group ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   * __restrict  nptr ,
                                                                                                     char ** __restrict  endptr ,
                                                                                                     int base ) ;
__inline extern uintmax_t ( __attribute__((__gnu_inline__)) strtoumax)(char const   * __restrict  nptr ,
                                                                       char ** __restrict  endptr ,
                                                                       int base ) 
{ 
  unsigned long tmp ;

  {
  tmp = __strtoul_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) __wcstol_internal)(__gwchar_t const   * __restrict  __nptr ,
                                                                                               __gwchar_t ** __restrict  __endptr ,
                                                                                               int __base ,
                                                                                               int __group ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                    __gwchar_t ** __restrict  endptr ,
                                                                                                    int base ) ;
__inline extern intmax_t ( __attribute__((__gnu_inline__)) wcstoimax)(__gwchar_t const   * __restrict  nptr ,
                                                                      __gwchar_t ** __restrict  endptr ,
                                                                      int base ) 
{ 
  long tmp ;

  {
  tmp = __wcstol_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) __wcstoul_internal)(__gwchar_t const   * __restrict  __nptr ,
                                                                                                         __gwchar_t ** __restrict  __endptr ,
                                                                                                         int __base ,
                                                                                                         int __group ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t const   * __restrict  nptr ,
                                                                                                     __gwchar_t ** __restrict  endptr ,
                                                                                                     int base ) ;
__inline extern uintmax_t ( __attribute__((__gnu_inline__)) wcstoumax)(__gwchar_t const   * __restrict  nptr ,
                                                                       __gwchar_t ** __restrict  endptr ,
                                                                       int base ) 
{ 
  unsigned long tmp ;

  {
  tmp = __wcstoul_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
void BarSettingsInit(BarSettings_t *settings ) ;
void BarSettingsDestroy(BarSettings_t *settings ) ;
void BarSettingsRead(BarSettings_t *settings ) ;
void BarSettingsWrite(PianoStation_t *station , BarSettings_t *settings ) ;
void *BarPlayerThread(void *data ) ;
void BarPlayerInit(player_t * const  p , BarSettings_t const   * const  settings ) ;
void BarPlayerReset(player_t * const  p ) ;
void BarPlayerDestroy(player_t * const  p ) ;
BarPlayerMode BarPlayerGetMode(player_t * const  player ) ;
size_t BarReadline(char *buf , size_t const   bufSize , char const   *mask , BarReadlineFds_t *input ,
                   BarReadlineFlags_t const   flags , int timeout ) ;
size_t BarReadlineStr(char *buf , size_t const   bufSize , BarReadlineFds_t *input ,
                      BarReadlineFlags_t const   flags ) ;
sig_atomic_t *interrupted ;
__inline static _Bool debugEnable(void) 
{ 


  {
  return ((_Bool)0);
}
}
void BarTermInit(void) ;
void BarTermRestore(void) ;
void ( /* format attribute */  BarUiMsg)(BarSettings_t const   *settings , BarUiMsg_t const   type ,
                                         char const   *format  , ...) ;
PianoStation_t *BarUiSelectStation(BarApp_t *app___0 , PianoStation_t *stations ,
                                   char const   *prompt , void (*callback)(BarApp_t *app ,
                                                                           char *buf ) ,
                                   _Bool autoselect ) ;
void BarUiPrintStation(BarSettings_t const   *settings , PianoStation_t *station ) ;
void BarUiPrintSong(BarSettings_t const   *settings , PianoSong_t const   *song ,
                    PianoStation_t const   *station ) ;
void BarUiStartEventCmd(BarSettings_t const   *settings , char const   *type , PianoStation_t const   *curStation ,
                        PianoSong_t const   *curSong , player_t * const  player ,
                        PianoStation_t *stations , PianoReturn_t pRet , CURLcode wRet ) ;
_Bool BarUiPianoCall(BarApp_t * const  app___0 , PianoRequestType_t const   type ,
                     void * const  data , PianoReturn_t * const  pRet , CURLcode * const  wRet ) ;
void BarUiHistoryPrepend(BarApp_t *app___0 , PianoSong_t *song ) ;
void BarUiCustomFormat(char *dest , size_t destSize , char const   *format , char const   *formatChars ,
                       char const   **formatVals ) ;
BarKeyShortcutId_t BarUiDispatch(BarApp_t *app___0 , char const   key , PianoStation_t *selStation ,
                                 PianoSong_t *selSong , _Bool const   verbose , BarUiDispatchContext_t context ) ;
static _Bool BarMainLoginUser(BarApp_t *app___0 ) 
{ 
  PianoReturn_t pRet ;
  CURLcode wRet ;
  PianoRequestDataLogin_t reqData ;
  _Bool ret ;

  {
  reqData.user = app___0->settings.username;
  reqData.password = app___0->settings.password;
  reqData.step = (unsigned char)0;
  BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
           "Login... ");
  ret = BarUiPianoCall((BarApp_t * const  )app___0, (PianoRequestType_t const   )1,
                       (void *)(& reqData), & pRet, & wRet);
  BarUiStartEventCmd((BarSettings_t const   *)(& app___0->settings), "userlogin",
                     (PianoStation_t const   *)((void *)0), (PianoSong_t const   *)((void *)0),
                     & app___0->player, (PianoStation_t *)((void *)0), pRet, wRet);
  return (ret);
}
}
static _Bool BarMainGetLoginCredentials(BarSettings_t *settings , BarReadlineFds_t *input ) 
{ 
  _Bool usernameFromConfig ;
  char nameBuf[100] ;
  size_t tmp ;
  char passBuf[100] ;
  size_t tmp___0 ;
  pid_t chld ;
  int pipeFd[2] ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int status ;
  ssize_t len ;
  size_t tmp___9 ;

  {
  usernameFromConfig = (_Bool)1;
  if ((unsigned long )settings->username == (unsigned long )((void *)0)) {
    BarUiMsg((BarSettings_t const   *)settings, (BarUiMsg_t const   )5, "Email: ");
    tmp = BarReadlineStr(nameBuf, (size_t const   )sizeof(nameBuf), input, (BarReadlineFlags_t const   )0);
    if (tmp == 0UL) {
      return ((_Bool)0);
    }
    settings->username = strdup((char const   *)(nameBuf));
    usernameFromConfig = (_Bool)0;
  }
  if ((unsigned long )settings->password == (unsigned long )((void *)0)) {
    if (usernameFromConfig) {
      BarUiMsg((BarSettings_t const   *)settings, (BarUiMsg_t const   )5, "Email: %s\n",
               settings->username);
    }
    if ((unsigned long )settings->passwordCmd == (unsigned long )((void *)0)) {
      BarUiMsg((BarSettings_t const   *)settings, (BarUiMsg_t const   )5, "Password: ");
      tmp___0 = BarReadlineStr(passBuf, (size_t const   )sizeof(passBuf), input, (BarReadlineFlags_t const   )2);
      if (tmp___0 == 0UL) {
        puts("");
        return ((_Bool)0);
      }
      puts("");
      settings->password = strdup((char const   *)(passBuf));
    } else {
      BarUiMsg((BarSettings_t const   *)settings, (BarUiMsg_t const   )1, "Requesting password from external helper... ");
      tmp___3 = pipe((int *)(pipeFd));
      if (tmp___3 == -1) {
        tmp___1 = __errno_location();
        tmp___2 = strerror(*tmp___1);
        BarUiMsg((BarSettings_t const   *)settings, (BarUiMsg_t const   )0, "Error: %s\n",
                 tmp___2);
        return ((_Bool)0);
      }
      chld = fork();
      if (chld == 0) {
        close(pipeFd[0]);
        tmp___4 = fileno(stdout);
        dup2(pipeFd[1], tmp___4);
        execl("/bin/sh", "/bin/sh", "-c", settings->passwordCmd, (char *)((void *)0));
        tmp___5 = __errno_location();
        tmp___6 = strerror(*tmp___5);
        BarUiMsg((BarSettings_t const   *)settings, (BarUiMsg_t const   )0, "Error: %s\n",
                 tmp___6);
        close(pipeFd[1]);
        exit(1);
      } else
      if (chld == -1) {
        tmp___7 = __errno_location();
        tmp___8 = strerror(*tmp___7);
        BarUiMsg((BarSettings_t const   *)settings, (BarUiMsg_t const   )0, "Error: %s\n",
                 tmp___8);
        return ((_Bool)0);
      } else {
        close(pipeFd[1]);
        memset((void *)(passBuf), 0, sizeof(passBuf));
        read(pipeFd[0], (void *)(passBuf), sizeof(passBuf) - 1UL);
        close(pipeFd[0]);
        tmp___9 = strlen((char const   *)(passBuf));
        len = (ssize_t )(tmp___9 - 1UL);
        while (1) {
          if (len >= 0L) {
            if (! ((int )passBuf[len] == 10)) {
              break;
            }
          } else {
            break;
          }
          passBuf[len] = (char )'\000';
          len --;
        }
        waitpid(chld, & status, 0);
        if ((status & 65280) >> 8 == 0) {
          settings->password = strdup((char const   *)(passBuf));
          BarUiMsg((BarSettings_t const   *)settings, (BarUiMsg_t const   )0, "Ok.\n");
        } else {
          BarUiMsg((BarSettings_t const   *)settings, (BarUiMsg_t const   )0, "Error: Exit status %i.\n",
                   (status & 65280) >> 8);
          return ((_Bool)0);
        }
      }
    }
  }
  return ((_Bool)1);
}
}
static _Bool BarMainGetStations(BarApp_t *app___0 ) 
{ 
  PianoReturn_t pRet ;
  CURLcode wRet ;
  _Bool ret ;

  {
  BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
           "Get stations... ");
  ret = BarUiPianoCall((BarApp_t * const  )app___0, (PianoRequestType_t const   )2,
                       (void *)0, & pRet, & wRet);
  BarUiStartEventCmd((BarSettings_t const   *)(& app___0->settings), "usergetstations",
                     (PianoStation_t const   *)((void *)0), (PianoSong_t const   *)((void *)0),
                     & app___0->player, app___0->ph.stations, pRet, wRet);
  return (ret);
}
}
static void BarMainGetInitialStation(BarApp_t *app___0 ) 
{ 


  {
  if ((unsigned long )app___0->settings.autostartStation != (unsigned long )((void *)0)) {
    app___0->nextStation = PianoFindStationById((PianoStation_t * const  )app___0->ph.stations,
                                                (char const   * const  )app___0->settings.autostartStation);
    if ((unsigned long )app___0->nextStation == (unsigned long )((void *)0)) {
      BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )4,
               "Error: Autostart station not found.\n");
    }
  }
  if ((unsigned long )app___0->nextStation == (unsigned long )((void *)0)) {
    app___0->nextStation = BarUiSelectStation(app___0, app___0->ph.stations, "Select station: ",
                                              (void (*)(BarApp_t *app , char *buf ))((void *)0),
                                              app___0->settings.autoselect);
  }
  return;
}
}
static void BarMainHandleUserInput(BarApp_t *app___0 ) 
{ 
  char buf[2] ;
  size_t tmp ;

  {
  tmp = BarReadline(buf, (size_t const   )sizeof(buf), (char const   *)((void *)0),
                    & app___0->input, (BarReadlineFlags_t const   )7, 1);
  if (tmp > 0UL) {
    BarUiDispatch(app___0, (char const   )buf[0], app___0->curStation, app___0->playlist,
                  (_Bool const   )1, (BarUiDispatchContext_t )1);
  }
  return;
}
}
static void BarMainGetPlaylist(BarApp_t *app___0 ) 
{ 
  PianoReturn_t pRet ;
  CURLcode wRet ;
  PianoRequestDataGetPlaylist_t reqData ;
  _Bool tmp ;

  {
  reqData.station = app___0->nextStation;
  reqData.quality = app___0->settings.audioQuality;
  BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
           "Receiving new playlist... ");
  tmp = BarUiPianoCall((BarApp_t * const  )app___0, (PianoRequestType_t const   )3,
                       (void *)(& reqData), & pRet, & wRet);
  if (tmp) {
    app___0->playlist = reqData.retPlaylist;
    if ((unsigned long )app___0->playlist == (unsigned long )((void *)0)) {
      BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
               "No tracks left.\n");
      app___0->nextStation = (PianoStation_t *)((void *)0);
    }
  } else {
    app___0->nextStation = (PianoStation_t *)((void *)0);
  }
  app___0->curStation = app___0->nextStation;
  BarUiStartEventCmd((BarSettings_t const   *)(& app___0->settings), "stationfetchplaylist",
                     (PianoStation_t const   *)app___0->curStation, (PianoSong_t const   *)app___0->playlist,
                     & app___0->player, app___0->ph.stations, pRet, wRet);
  return;
}
}
static void BarMainStartPlayback(BarApp_t *app___0 , pthread_t *playerThread ) ;
static char const   httpPrefix[8]  = 
  {      (char const   )'h',      (char const   )'t',      (char const   )'t',      (char const   )'p', 
        (char const   )':',      (char const   )'/',      (char const   )'/',      (char const   )'\000'};
static void BarMainStartPlayback(BarApp_t *app___0 , pthread_t *playerThread ) 
{ 
  PianoSong_t const   *curSong ;
  PianoStation_t *tmp ;
  PianoStation_t *tmp___0 ;
  player_t *player ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  curSong = (PianoSong_t const   *)app___0->playlist;
  if ((app___0->curStation)->isQuickMix) {
    tmp = PianoFindStationById((PianoStation_t * const  )app___0->ph.stations, (char const   * const  )curSong->stationId);
    tmp___0 = tmp;
  } else {
    tmp___0 = (PianoStation_t *)((void *)0);
  }
  BarUiPrintSong((BarSettings_t const   *)(& app___0->settings), curSong, (PianoStation_t const   *)tmp___0);
  if ((unsigned long )curSong->audioUrl == (unsigned long )((void *)0)) {
    BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )4,
             "Invalid song url.\n");
  } else {
    tmp___1 = strlen(httpPrefix);
    tmp___2 = strncmp((char const   *)curSong->audioUrl, httpPrefix, tmp___1);
    if (tmp___2 != 0) {
      BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )4,
               "Invalid song url.\n");
    } else {
      player = & app___0->player;
      BarPlayerReset((player_t * const  )player);
      app___0->player.url = (char *)curSong->audioUrl;
      app___0->player.gain = (double )curSong->fileGain;
      app___0->player.songDuration = (unsigned int )curSong->length;
      interrupted = & app___0->player.interrupted;
      BarUiStartEventCmd((BarSettings_t const   *)(& app___0->settings), "songstart",
                         (PianoStation_t const   *)app___0->curStation, curSong, & app___0->player,
                         app___0->ph.stations, (PianoReturn_t )1, (CURLcode )0);
      app___0->player.mode = (BarPlayerMode )1;
      pthread_create((pthread_t * __restrict  )playerThread, (pthread_attr_t const   * __restrict  )((void *)0),
                     & BarPlayerThread, (void * __restrict  )(& app___0->player));
    }
  }
  return;
}
}
static void BarMainPlayerCleanup(BarApp_t *app___0 , pthread_t *playerThread ) 
{ 
  void *threadRet ;

  {
  BarUiStartEventCmd((BarSettings_t const   *)(& app___0->settings), "songfinish",
                     (PianoStation_t const   *)app___0->curStation, (PianoSong_t const   *)app___0->playlist,
                     & app___0->player, app___0->ph.stations, (PianoReturn_t )1, (CURLcode )0);
  pthread_join(*playerThread, & threadRet);
  if ((unsigned long )threadRet == (unsigned long )((void *)0)) {
    app___0->playerErrors = 0U;
  } else
  if ((unsigned long )threadRet == (unsigned long )((void *)2)) {
    (app___0->playerErrors) ++;
    if (app___0->playerErrors >= app___0->settings.maxRetry) {
      app___0->nextStation = (PianoStation_t *)((void *)0);
    }
  } else {
    app___0->nextStation = (PianoStation_t *)((void *)0);
  }
  interrupted = & app___0->doQuit;
  app___0->player.mode = (BarPlayerMode )0;
  return;
}
}
static void BarMainPrintTime(BarApp_t *app___0 ) 
{ 
  unsigned int songRemaining ;
  char sign[2] ;
  player_t *player ;
  unsigned int songDuration ;
  unsigned int songPlayed ;
  char outstr[512] ;
  char totalFormatted[16] ;
  char remainingFormatted[16] ;
  char elapsedFormatted[16] ;
  char const   *vals[4] ;

  {
  sign[0] = (char)0;
  sign[1] = (char)0;
  player = & app___0->player;
  pthread_mutex_lock(& player->lock);
  songDuration = player->songDuration;
  songPlayed = player->songPlayed;
  pthread_mutex_unlock(& player->lock);
  if (songPlayed <= songDuration) {
    songRemaining = songDuration - songPlayed;
    sign[0] = (char )'-';
  } else {
    songRemaining = songPlayed - songDuration;
    sign[0] = (char )'+';
  }
  vals[0] = (char const   *)(totalFormatted);
  vals[1] = (char const   *)(remainingFormatted);
  vals[2] = (char const   *)(elapsedFormatted);
  vals[3] = (char const   *)(sign);
  snprintf((char * __restrict  )(totalFormatted), sizeof(totalFormatted), (char const   * __restrict  )"%02u:%02u",
           songDuration / 60U, songDuration % 60U);
  snprintf((char * __restrict  )(remainingFormatted), sizeof(remainingFormatted),
           (char const   * __restrict  )"%02u:%02u", songRemaining / 60U, songRemaining % 60U);
  snprintf((char * __restrict  )(elapsedFormatted), sizeof(elapsedFormatted), (char const   * __restrict  )"%02u:%02u",
           songPlayed / 60U, songPlayed % 60U);
  BarUiCustomFormat(outstr, sizeof(outstr), (char const   *)app___0->settings.timeFormat,
                    "tres", vals);
  BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )3,
           "%s\r", outstr);
  return;
}
}
static void BarMainLoop(BarApp_t *app___0 ) 
{ 
  pthread_t playerThread ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  player_t *player ;
  BarPlayerMode tmp___2 ;
  PianoSong_t *histsong ;
  BarPlayerMode tmp___3 ;
  BarPlayerMode tmp___4 ;
  BarPlayerMode tmp___5 ;

  {
  tmp = BarMainGetLoginCredentials(& app___0->settings, & app___0->input);
  if (! tmp) {
    return;
  }
  tmp___0 = BarMainLoginUser(app___0);
  if (! tmp___0) {
    return;
  }
  tmp___1 = BarMainGetStations(app___0);
  if (! tmp___1) {
    return;
  }
  BarMainGetInitialStation(app___0);
  player = & app___0->player;
  while (! app___0->doQuit) {
    tmp___2 = BarPlayerGetMode((player_t * const  )player);
    if ((unsigned int )tmp___2 == 3U) {
      if (player->interrupted != 0) {
        app___0->doQuit = 1;
      }
      BarMainPlayerCleanup(app___0, & playerThread);
    }
    tmp___3 = BarPlayerGetMode((player_t * const  )player);
    if ((unsigned int )tmp___3 == 0U) {
      if ((unsigned long )app___0->playlist != (unsigned long )((void *)0)) {
        histsong = app___0->playlist;
        if ((unsigned long )app___0->playlist == (unsigned long )((void *)0)) {
          app___0->playlist = (PianoSong_t *)((void *)0);
        } else {
          app___0->playlist = (PianoSong_t *)((void *)(app___0->playlist)->head.next);
        }
        histsong->head.next = (struct PianoListHead *)((void *)0);
        BarUiHistoryPrepend(app___0, histsong);
      }
      if ((unsigned long )app___0->playlist == (unsigned long )((void *)0)) {
        if ((unsigned long )app___0->nextStation != (unsigned long )((void *)0)) {
          if (! app___0->doQuit) {
            if ((unsigned long )app___0->nextStation != (unsigned long )app___0->curStation) {
              BarUiPrintStation((BarSettings_t const   *)(& app___0->settings), app___0->nextStation);
            }
            BarMainGetPlaylist(app___0);
          }
        }
      }
      if ((unsigned long )app___0->playlist != (unsigned long )((void *)0)) {
        BarMainStartPlayback(app___0, & playerThread);
      }
    }
    BarMainHandleUserInput(app___0);
    tmp___4 = BarPlayerGetMode((player_t * const  )player);
    if ((unsigned int )tmp___4 == 2U) {
      BarMainPrintTime(app___0);
    }
  }
  tmp___5 = BarPlayerGetMode((player_t * const  )player);
  if ((unsigned int )tmp___5 != 0U) {
    pthread_join(playerThread, (void **)((void *)0));
  }
  return;
}
}
sig_atomic_t *interrupted  =    (sig_atomic_t *)((void *)0);
static void intHandler(int signal___0 ) 
{ 


  {
  if ((unsigned long )interrupted != (unsigned long )((void *)0)) {
    (*interrupted) ++;
  }
  return;
}
}
static void BarMainSetupSigaction(void) 
{ 
  struct sigaction act ;

  {
  act.__sigaction_handler.sa_handler = & intHandler;
  act.sa_mask.__val[0] = 0UL;
  act.sa_mask.__val[1] = 0UL;
  act.sa_mask.__val[2] = 0UL;
  act.sa_mask.__val[3] = 0UL;
  act.sa_mask.__val[4] = 0UL;
  act.sa_mask.__val[5] = 0UL;
  act.sa_mask.__val[6] = 0UL;
  act.sa_mask.__val[7] = 0UL;
  act.sa_mask.__val[8] = 0UL;
  act.sa_mask.__val[9] = 0UL;
  act.sa_mask.__val[10] = 0UL;
  act.sa_mask.__val[11] = 0UL;
  act.sa_mask.__val[12] = 0UL;
  act.sa_mask.__val[13] = 0UL;
  act.sa_mask.__val[14] = 0UL;
  act.sa_mask.__val[15] = 0UL;
  act.sa_flags = 0;
  act.sa_restorer = (void (*)(void))0;
  sigemptyset(& act.sa_mask);
  sigaction(2, (struct sigaction  const  * __restrict  )(& act), (struct sigaction * __restrict  )((void *)0));
  return;
}
}
static BarApp_t app  ;
int main(int argc , char **argv ) 
{ 
  PianoReturn_t pret ;
  char const   *tmp ;
  int __d0 ;
  int __d1 ;
  struct stat s ;

  {
  debugEnable();
  memset((void *)(& app), 0, sizeof(app));
  BarTermInit();
  signal(13, (void (*)(int  ))1);
  BarMainSetupSigaction();
  interrupted = & app.doQuit;
  gcry_check_version((char const   *)((void *)0));
  gcry_control((enum gcry_ctl_cmds )37, 0);
  gcry_control((enum gcry_ctl_cmds )38, 0);
  BarPlayerInit((player_t * const  )(& app.player), (BarSettings_t const   * const  )(& app.settings));
  BarSettingsInit(& app.settings);
  BarSettingsRead(& app.settings);
  pret = PianoInit(& app.ph, (char const   *)app.settings.partnerUser, (char const   *)app.settings.partnerPassword,
                   (char const   *)app.settings.device, (char const   *)app.settings.inkey,
                   (char const   *)app.settings.outkey);
  if ((unsigned int )pret != 1U) {
    tmp = PianoErrorToStr(pret);
    BarUiMsg((BarSettings_t const   *)(& app.settings), (BarUiMsg_t const   )4, "Initialization failed: %s\n",
             tmp);
    return (0);
  }
  BarUiMsg((BarSettings_t const   *)(& app.settings), (BarUiMsg_t const   )0, "Welcome to pianobar (2022.04.01-dev)! ");
  if ((int )app.settings.keys[0] == 0) {
    BarUiMsg((BarSettings_t const   *)(& app.settings), (BarUiMsg_t const   )0, "\n");
  } else {
    BarUiMsg((BarSettings_t const   *)(& app.settings), (BarUiMsg_t const   )0, "Press %c for a list of commands.\n",
             (int )app.settings.keys[0]);
  }
  curl_global_init((long )(1 | (1 << 1)));
  app.http = curl_easy_init();
  while (1) {
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& app.input.set.__fds_bits[0]): "memory");
    break;
  }
  app.input.fds[0] = 0;
  app.input.set.__fds_bits[app.input.fds[0] / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << app.input.fds[0] % (8 * (int )sizeof(__fd_mask )));
  app.input.fds[1] = open((char const   *)app.settings.fifo, 2);
  if (app.input.fds[1] != -1) {
    fstat(app.input.fds[1], & s);
    if (! ((s.st_mode & 61440U) == 4096U)) {
      BarUiMsg((BarSettings_t const   *)(& app.settings), (BarUiMsg_t const   )4,
               "File at %s is not a fifo\n", app.settings.fifo);
      close(app.input.fds[1]);
      app.input.fds[1] = -1;
    } else {
      app.input.set.__fds_bits[app.input.fds[1] / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << app.input.fds[1] % (8 * (int )sizeof(__fd_mask )));
      BarUiMsg((BarSettings_t const   *)(& app.settings), (BarUiMsg_t const   )1,
               "Control fifo at %s opened\n", app.settings.fifo);
    }
  }
  if (app.input.fds[0] > app.input.fds[1]) {
    app.input.maxfd = app.input.fds[0];
  } else {
    app.input.maxfd = app.input.fds[1];
  }
  (app.input.maxfd) ++;
  BarMainLoop(& app);
  if (app.input.fds[1] != -1) {
    close(app.input.fds[1]);
  }
  BarSettingsWrite(app.curStation, & app.settings);
  PianoDestroy(& app.ph);
  PianoDestroyPlaylist(app.songHistory);
  PianoDestroyPlaylist(app.playlist);
  curl_easy_cleanup(app.http);
  curl_global_cleanup();
  BarPlayerDestroy((player_t * const  )(& app.player));
  BarSettingsDestroy(& app.settings);
  BarTermRestore();
  return (0);
}
}
#pragma merger("0","/tmp/cil-WlwbE80W.i","-O2")
#pragma merger("0","/tmp/cil-_msr_KwX.i","-O2")
extern int av_strerror(int errnum , char *errbuf , size_t errbuf_size ) ;
__inline static double av_q2d(AVRational a ) 
{ 


  {
  return ((double )a.num / (double )a.den);
}
}
extern void av_log_set_level(int level ) ;
extern char const   *av_get_sample_fmt_name(enum AVSampleFormat sample_fmt ) ;
extern int av_get_bytes_per_sample(enum AVSampleFormat sample_fmt ) ;
extern int av_get_channel_layout_nb_channels(uint64_t channel_layout ) ;
extern int av_dict_set(AVDictionary **pm , char const   *key , char const   *value ,
                       int flags ) ;
extern AVFrame *av_frame_alloc(void) ;
extern void av_frame_free(AVFrame **frame ) ;
extern void av_frame_unref(AVFrame *frame ) ;
extern AVCodecContext *avcodec_alloc_context3(AVCodec const   *codec ) ;
extern int avcodec_parameters_to_context(AVCodecContext *codec , AVCodecParameters const   *par ) ;
extern int avcodec_open2(AVCodecContext *avctx , AVCodec const   *codec , AVDictionary **options ) ;
extern int avcodec_close(AVCodecContext *avctx ) ;
extern AVPacket *av_packet_alloc(void) ;
extern void av_packet_free(AVPacket **pkt ) ;
extern void av_packet_unref(AVPacket *pkt ) ;
extern AVCodec *avcodec_find_decoder(enum AVCodecID id ) ;
extern int avcodec_send_packet(AVCodecContext *avctx , AVPacket const   *avpkt ) ;
extern int avcodec_receive_frame(AVCodecContext *avctx , AVFrame *frame ) ;
extern int avfilter_link(AVFilterContext *src , unsigned int srcpad , AVFilterContext *dst ,
                         unsigned int dstpad ) ;
extern AVFilter const   *avfilter_get_by_name(char const   *name ) ;
extern AVFilterGraph *avfilter_graph_alloc(void) ;
extern int avfilter_graph_create_filter(AVFilterContext **filt_ctx , AVFilter const   *filt ,
                                        char const   *name , char const   *args ,
                                        void *opaque , AVFilterGraph *graph_ctx ) ;
extern int avfilter_graph_config(AVFilterGraph *graphctx , void *log_ctx ) ;
extern void avfilter_graph_free(AVFilterGraph **graph ) ;
extern int avfilter_graph_send_command(AVFilterGraph *graph , char const   *target ,
                                       char const   *cmd , char const   *arg , char *res ,
                                       int res_len , int flags ) ;
extern AVRational av_buffersink_get_time_base(AVFilterContext const   *ctx ) ;
extern int av_buffersink_get_frame(AVFilterContext *ctx , AVFrame *frame ) ;
extern int ( __attribute__((__warn_unused_result__)) av_buffersrc_write_frame)(AVFilterContext *ctx ,
                                                                               AVFrame const   *frame ) ;
extern int ( __attribute__((__warn_unused_result__)) av_buffersrc_add_frame)(AVFilterContext *ctx ,
                                                                             AVFrame *frame ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                                              pthread_condattr_t const   * __restrict  __cond_attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_destroy)(pthread_cond_t *__cond ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_broadcast)(pthread_cond_t *__cond ) ;
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
extern void ao_initialize(void) ;
extern void ao_shutdown(void) ;
extern ao_device *ao_open_live(int driver_id , ao_sample_format *format , ao_option *option ) ;
extern ao_device *ao_open_file(int driver_id , char const   *filename , int overwrite ,
                               ao_sample_format *format , ao_option *option ) ;
extern int ao_play(ao_device *device , char *output_samples , uint_32 num_bytes ) ;
extern int ao_close(ao_device *device ) ;
extern int ao_driver_id(char const   *short_name ) ;
extern int ao_default_driver_id(void) ;
extern AVFormatContext *avformat_alloc_context(void) ;
extern int avformat_open_input(AVFormatContext **ps , char const   *url , AVInputFormat *fmt ,
                               AVDictionary **options ) ;
extern int avformat_find_stream_info(AVFormatContext *ic , AVDictionary **options ) ;
extern int av_find_best_stream(AVFormatContext *ic , enum AVMediaType type , int wanted_stream_nb ,
                               int related_stream , AVCodec **decoder_ret , int flags ) ;
extern int av_read_frame(AVFormatContext *s , AVPacket *pkt ) ;
extern int av_seek_frame(AVFormatContext *s , int stream_index , int64_t timestamp ,
                         int flags ) ;
extern void avformat_close_input(AVFormatContext **s ) ;
void *BarAoPlayThread(void *data ) ;
void BarPlayerSetVolume(player_t * const  player ) ;
enum AVSampleFormat  const  avformat  =    (enum AVSampleFormat  const  )1;
static void printError(BarSettings_t const   * const  settings , char const   * const  msg ,
                       int ret ) 
{ 
  char avmsg[128] ;

  {
  av_strerror(ret, avmsg, sizeof(avmsg));
  BarUiMsg((BarSettings_t const   *)settings, (BarUiMsg_t const   )4, "%s (%s)\n",
           msg, avmsg);
  return;
}
}
void BarPlayerInit(player_t * const  p , BarSettings_t const   * const  settings ) 
{ 


  {
  ao_initialize();
  av_log_set_level(8);
  pthread_mutex_init(& p->lock, (pthread_mutexattr_t const   *)((void *)0));
  pthread_cond_init((pthread_cond_t * __restrict  )(& p->cond), (pthread_condattr_t const   * __restrict  )((void *)0));
  pthread_mutex_init(& p->aoplayLock, (pthread_mutexattr_t const   *)((void *)0));
  pthread_cond_init((pthread_cond_t * __restrict  )(& p->aoplayCond), (pthread_condattr_t const   * __restrict  )((void *)0));
  BarPlayerReset(p);
  p->settings = (BarSettings_t const   *)settings;
  return;
}
}
void BarPlayerDestroy(player_t * const  p ) 
{ 


  {
  pthread_cond_destroy(& p->cond);
  pthread_mutex_destroy(& p->lock);
  pthread_cond_destroy(& p->aoplayCond);
  pthread_mutex_destroy(& p->aoplayLock);
  ao_shutdown();
  return;
}
}
void BarPlayerReset(player_t * const  p ) 
{ 


  {
  p->doQuit = (_Bool)0;
  p->doPause = (_Bool)0;
  p->songDuration = 0U;
  p->songPlayed = 0U;
  p->mode = (BarPlayerMode )0;
  p->fvolume = (AVFilterContext *)((void *)0);
  p->fgraph = (AVFilterGraph *)((void *)0);
  p->fctx = (AVFormatContext *)((void *)0);
  p->st = (AVStream *)((void *)0);
  p->cctx = (AVCodecContext *)((void *)0);
  p->fbufsink = (AVFilterContext *)((void *)0);
  p->fabuf = (AVFilterContext *)((void *)0);
  p->streamIdx = -1;
  p->lastTimestamp = (int64_t )0;
  p->interrupted = 0;
  p->aoDev = (ao_device *)((void *)0);
  return;
}
}
void BarPlayerSetVolume(player_t * const  player ) 
{ 
  int ret ;
  char strbuf[16] ;

  {
  if ((unsigned int )player->mode != 2U) {
    return;
  }
  snprintf((char * __restrict  )(strbuf), sizeof(strbuf), (char const   * __restrict  )"%fdB",
           (double )(player->settings)->volume + player->gain * (double )(player->settings)->gainMul);
  ret = avfilter_graph_send_command(player->fgraph, "volume", "volume", (char const   *)(strbuf),
                                    (char *)((void *)0), 0, 0);
  if (ret < 0) {
    printError((BarSettings_t const   * const  )player->settings, (char const   * const  )"Cannot set volume",
               ret);
  }
  return;
}
}
static int intCb(void * const  data ) 
{ 
  player_t *player ;

  {
  player = (player_t *)data;
  if (player->interrupted > 1) {
    pthread_mutex_lock(& player->lock);
    player->doQuit = (_Bool)1;
    pthread_mutex_unlock(& player->lock);
    return (1);
  } else
  if (player->interrupted != 0) {
    player->interrupted = 0;
    return (1);
  } else {
    return (0);
  }
}
}
static _Bool openStream(player_t * const  player ) 
{ 
  int ret ;
  unsigned long timeout ;
  char timeoutStr[16] ;
  AVDictionary *options ;
  size_t i ;
  AVCodecContext *tmp ;
  AVCodecParameters const   *cp ;
  AVCodec *decoder ;
  AVCodec *tmp___0 ;
  unsigned int songDuration ;
  double tmp___1 ;

  {
  player->fctx = avformat_alloc_context();
  (player->fctx)->interrupt_callback.callback = (int (*)(void * ))(& intCb);
  (player->fctx)->interrupt_callback.opaque = (void *)player;
  timeout = (unsigned long )((player->settings)->timeout * 1000000U);
  ret = snprintf((char * __restrict  )(timeoutStr), sizeof(timeoutStr), (char const   * __restrict  )"%lu",
                 timeout);
  options = (AVDictionary *)((void *)0);
  av_dict_set(& options, "timeout", (char const   *)(timeoutStr), 0);
  ret = avformat_open_input(& player->fctx, (char const   *)player->url, (AVInputFormat *)((void *)0),
                            & options);
  if (ret < 0) {
    printError((BarSettings_t const   * const  )player->settings, (char const   * const  )"Unable to open audio file",
               ret);
    return ((_Bool)0);
  }
  ret = avformat_find_stream_info(player->fctx, (AVDictionary **)((void *)0));
  if (ret < 0) {
    printError((BarSettings_t const   * const  )player->settings, (char const   * const  )"find_stream_info",
               ret);
    return ((_Bool)0);
  }
  i = (size_t )0;
  while (i < (size_t )(player->fctx)->nb_streams) {
    (*((player->fctx)->streams + i))->discard = (enum AVDiscard )48;
    i ++;
  }
  player->streamIdx = av_find_best_stream(player->fctx, (enum AVMediaType )1, -1,
                                          -1, (AVCodec **)((void *)0), 0);
  if (player->streamIdx < 0) {
    printError((BarSettings_t const   * const  )player->settings, (char const   * const  )"find_best_stream",
               ret);
    return ((_Bool)0);
  }
  player->st = *((player->fctx)->streams + player->streamIdx);
  (player->st)->discard = (enum AVDiscard )0;
  tmp = avcodec_alloc_context3((AVCodec const   *)((void *)0));
  player->cctx = tmp;
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    printError((BarSettings_t const   * const  )player->settings, (char const   * const  )"avcodec_alloc_context3",
               ret);
    return ((_Bool)0);
  }
  cp = (AVCodecParameters const   *)(player->st)->codecpar;
  ret = avcodec_parameters_to_context(player->cctx, cp);
  if (ret < 0) {
    printError((BarSettings_t const   * const  )player->settings, (char const   * const  )"avcodec_parameters_to_context",
               ret);
    return ((_Bool)0);
  }
  tmp___0 = avcodec_find_decoder((enum AVCodecID )cp->codec_id);
  decoder = tmp___0;
  if ((unsigned long )decoder == (unsigned long )((void *)0)) {
    printError((BarSettings_t const   * const  )player->settings, (char const   * const  )"find_decoder",
               ret);
    return ((_Bool)0);
  }
  ret = avcodec_open2(player->cctx, (AVCodec const   *)decoder, (AVDictionary **)((void *)0));
  if (ret < 0) {
    printError((BarSettings_t const   * const  )player->settings, (char const   * const  )"codec_open2",
               ret);
    return ((_Bool)0);
  }
  if (player->lastTimestamp > 0L) {
    av_seek_frame(player->fctx, player->streamIdx, player->lastTimestamp, 0);
  }
  tmp___1 = av_q2d((player->st)->time_base);
  songDuration = (unsigned int )(tmp___1 * (double )(player->st)->duration);
  pthread_mutex_lock(& player->lock);
  player->songPlayed = 0U;
  player->songDuration = songDuration;
  pthread_mutex_unlock(& player->lock);
  return ((_Bool)1);
}
}
static int getSampleRate(player_t const   * const  player ) 
{ 
  AVCodecParameters const   *cp ;
  int tmp ;

  {
  cp = (AVCodecParameters const   *)(player->st)->codecpar;
  if ((player->settings)->sampleRate == 0) {
    tmp = cp->sample_rate;
  } else {
    tmp = (player->settings)->sampleRate;
  }
  return ((int )tmp);
}
}
static _Bool openFilter(player_t * const  player ) 
{ 
  char strbuf[256] ;
  int ret ;
  AVCodecParameters *cp ;
  AVFilterGraph *tmp ;
  AVRational time_base ;
  char const   *tmp___0 ;
  AVFilter const   *tmp___1 ;
  AVFilter const   *tmp___2 ;
  AVFilterContext *fafmt ;
  int tmp___3 ;
  char const   *tmp___4 ;
  AVFilter const   *tmp___5 ;
  AVFilter const   *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  ret = 0;
  cp = (player->st)->codecpar;
  tmp = avfilter_graph_alloc();
  player->fgraph = tmp;
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    printError((BarSettings_t const   * const  )player->settings, (char const   * const  )"graph_alloc",
               ret);
    return ((_Bool)0);
  }
  time_base = (player->st)->time_base;
  tmp___0 = av_get_sample_fmt_name((player->cctx)->sample_fmt);
  snprintf((char * __restrict  )(strbuf), sizeof(strbuf), (char const   * __restrict  )"time_base=%d/%d:sample_rate=%d:sample_fmt=%s:channel_layout=0x%lx",
           time_base.num, time_base.den, cp->sample_rate, tmp___0, cp->channel_layout);
  tmp___1 = avfilter_get_by_name("abuffer");
  ret = avfilter_graph_create_filter(& player->fabuf, tmp___1, "source", (char const   *)(strbuf),
                                     (void *)0, player->fgraph);
  if (ret < 0) {
    printError((BarSettings_t const   * const  )player->settings, (char const   * const  )"create_filter abuffer",
               ret);
    return ((_Bool)0);
  }
  tmp___2 = avfilter_get_by_name("volume");
  ret = avfilter_graph_create_filter(& player->fvolume, tmp___2, "volume", "0dB",
                                     (void *)0, player->fgraph);
  if (ret < 0) {
    printError((BarSettings_t const   * const  )player->settings, (char const   * const  )"create_filter volume",
               ret);
    return ((_Bool)0);
  }
  fafmt = (AVFilterContext *)((void *)0);
  tmp___3 = getSampleRate((player_t const   * const  )player);
  tmp___4 = av_get_sample_fmt_name((enum AVSampleFormat )avformat);
  snprintf((char * __restrict  )(strbuf), sizeof(strbuf), (char const   * __restrict  )"sample_fmts=%s:sample_rates=%d",
           tmp___4, tmp___3);
  tmp___5 = avfilter_get_by_name("aformat");
  ret = avfilter_graph_create_filter(& fafmt, tmp___5, "format", (char const   *)(strbuf),
                                     (void *)0, player->fgraph);
  if (ret < 0) {
    printError((BarSettings_t const   * const  )player->settings, (char const   * const  )"create_filter aformat",
               ret);
    return ((_Bool)0);
  }
  tmp___6 = avfilter_get_by_name("abuffersink");
  ret = avfilter_graph_create_filter(& player->fbufsink, tmp___6, "sink", (char const   *)((void *)0),
                                     (void *)0, player->fgraph);
  if (ret < 0) {
    printError((BarSettings_t const   * const  )player->settings, (char const   * const  )"create_filter abuffersink",
               ret);
    return ((_Bool)0);
  }
  tmp___7 = avfilter_link(player->fabuf, 0U, player->fvolume, 0U);
  if (tmp___7 != 0) {
    printError((BarSettings_t const   * const  )player->settings, (char const   * const  )"filter_link",
               ret);
    return ((_Bool)0);
  } else {
    tmp___8 = avfilter_link(player->fvolume, 0U, fafmt, 0U);
    if (tmp___8 != 0) {
      printError((BarSettings_t const   * const  )player->settings, (char const   * const  )"filter_link",
                 ret);
      return ((_Bool)0);
    } else {
      tmp___9 = avfilter_link(fafmt, 0U, player->fbufsink, 0U);
      if (tmp___9 != 0) {
        printError((BarSettings_t const   * const  )player->settings, (char const   * const  )"filter_link",
                   ret);
        return ((_Bool)0);
      }
    }
  }
  ret = avfilter_graph_config(player->fgraph, (void *)0);
  if (ret < 0) {
    printError((BarSettings_t const   * const  )player->settings, (char const   * const  )"graph_config",
               ret);
    return ((_Bool)0);
  }
  return ((_Bool)1);
}
}
static _Bool openDevice(player_t * const  player ) 
{ 
  AVCodecParameters const   *cp ;
  ao_sample_format aoFmt ;
  int tmp ;
  int driver ;
  struct stat st ;
  int tmp___0 ;
  ao_device *tmp___1 ;
  ao_device *tmp___2 ;

  {
  cp = (AVCodecParameters const   *)(player->st)->codecpar;
  memset((void *)(& aoFmt), 0, sizeof(aoFmt));
  tmp = av_get_bytes_per_sample((enum AVSampleFormat )avformat);
  aoFmt.bits = tmp * 8;
  aoFmt.channels = (int )cp->channels;
  aoFmt.rate = getSampleRate((player_t const   * const  )player);
  aoFmt.byte_format = 4;
  driver = -1;
  if ((player->settings)->audioPipe) {
    tmp___0 = stat((char const   * __restrict  )(player->settings)->audioPipe, (struct stat * __restrict  )(& st));
    if (tmp___0) {
      BarUiMsg(player->settings, (BarUiMsg_t const   )4, "Cannot stat audio pipe file.\n");
      return ((_Bool)0);
    }
    if (! ((st.st_mode & 61440U) == 4096U)) {
      BarUiMsg(player->settings, (BarUiMsg_t const   )4, "File is not a pipe, error.\n");
      return ((_Bool)0);
    }
    driver = ao_driver_id("raw");
    tmp___1 = ao_open_file(driver, (char const   *)(player->settings)->audioPipe,
                           1, & aoFmt, (ao_option *)((void *)0));
    player->aoDev = tmp___1;
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      BarUiMsg(player->settings, (BarUiMsg_t const   )4, "Cannot open audio pipe file.\n");
      return ((_Bool)0);
    }
  } else {
    driver = ao_default_driver_id();
    tmp___2 = ao_open_live(driver, & aoFmt, (ao_option *)((void *)0));
    player->aoDev = tmp___2;
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
      BarUiMsg(player->settings, (BarUiMsg_t const   )4, "Cannot open audio device.\n");
      return ((_Bool)0);
    }
  }
  return ((_Bool)1);
}
}
static _Bool shouldQuit(player_t * const  player ) 
{ 
  _Bool ret ;

  {
  pthread_mutex_lock(& player->lock);
  ret = player->doQuit;
  pthread_mutex_unlock(& player->lock);
  return (ret);
}
}
static void changeMode(player_t * const  player , unsigned int mode ) 
{ 


  {
  pthread_mutex_lock(& player->lock);
  player->mode = (BarPlayerMode )mode;
  pthread_mutex_unlock(& player->lock);
  return;
}
}
BarPlayerMode BarPlayerGetMode(player_t * const  player ) 
{ 
  BarPlayerMode ret ;

  {
  pthread_mutex_lock(& player->lock);
  ret = player->mode;
  pthread_mutex_unlock(& player->lock);
  return (ret);
}
}
static int play(player_t * const  player ) 
{ 
  int64_t minBufferHealth ;
  AVCodecContext *cctx ;
  AVPacket *pkt ;
  AVPacket *tmp ;
  AVFrame *frame ;
  pthread_t aoplaythread ;
  enum __anonenum_drainMode_989564894 drainMode ;
  int ret ;
  double timeBase ;
  double tmp___0 ;
  int rt ;
  int tmp___1 ;
  int rt___0 ;
  int tmp___2 ;
  int64_t bufferHealth ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;

  {
  minBufferHealth = (int64_t )(player->settings)->bufferSecs;
  cctx = player->cctx;
  tmp = av_packet_alloc();
  pkt = tmp;
  pkt->data = (uint8_t *)((void *)0);
  pkt->size = 0;
  frame = (AVFrame *)((void *)0);
  frame = av_frame_alloc();
  pthread_create((pthread_t * __restrict  )(& aoplaythread), (pthread_attr_t const   * __restrict  )((void *)0),
                 & BarAoPlayThread, (void * __restrict  )player);
  drainMode = (enum __anonenum_drainMode_989564894 )0;
  ret = 0;
  tmp___0 = av_q2d((player->st)->time_base);
  timeBase = tmp___0;
  while (1) {
    tmp___4 = shouldQuit(player);
    if (tmp___4) {
      break;
    } else
    if (! ((unsigned int )drainMode != 2U)) {
      break;
    }
    if ((unsigned int )drainMode == 0U) {
      ret = av_read_frame(player->fctx, pkt);
      if (ret == - ((int )((unsigned int )((69 | (79 << 8)) | (70 << 16)) | (32U << 24)))) {
        drainMode = (enum __anonenum_drainMode_989564894 )1;
        avcodec_send_packet(cctx, (AVPacket const   *)((void *)0));
      } else
      if (pkt->stream_index != player->streamIdx) {
        av_packet_unref(pkt);
        continue;
      } else
      if (ret < 0) {
        pthread_mutex_lock(& player->aoplayLock);
        tmp___1 = av_buffersrc_add_frame(player->fabuf, (AVFrame *)((void *)0));
        rt = tmp___1;
        pthread_cond_broadcast(& player->aoplayCond);
        pthread_mutex_unlock(& player->aoplayLock);
        break;
      } else {
        avcodec_send_packet(cctx, (AVPacket const   *)pkt);
      }
    }
    while (1) {
      tmp___3 = shouldQuit(player);
      if (tmp___3) {
        break;
      }
      ret = avcodec_receive_frame(cctx, frame);
      if (ret == - ((int )((unsigned int )((69 | (79 << 8)) | (70 << 16)) | (32U << 24)))) {
        drainMode = (enum __anonenum_drainMode_989564894 )2;
        pthread_mutex_lock(& player->aoplayLock);
        tmp___2 = av_buffersrc_add_frame(player->fabuf, (AVFrame *)((void *)0));
        rt___0 = tmp___2;
        pthread_cond_broadcast(& player->aoplayCond);
        pthread_mutex_unlock(& player->aoplayLock);
        break;
      } else
      if (ret != 0) {
        break;
      }
      if (frame->pts == (-0x7FFFFFFFFFFFFFFF-1)) {
        frame->pts = (int64_t )0;
      }
      pthread_mutex_lock(& player->aoplayLock);
      ret = av_buffersrc_write_frame(player->fabuf, (AVFrame const   *)frame);
      pthread_mutex_unlock(& player->aoplayLock);
      bufferHealth = (int64_t )0;
      while (1) {
        pthread_mutex_lock(& player->aoplayLock);
        bufferHealth = (int64_t )(timeBase * (double )(frame->pts - player->lastTimestamp));
        if (bufferHealth > minBufferHealth) {
          pthread_cond_broadcast(& player->aoplayCond);
          pthread_cond_wait((pthread_cond_t * __restrict  )(& player->aoplayCond),
                            (pthread_mutex_t * __restrict  )(& player->aoplayLock));
        }
        pthread_mutex_unlock(& player->aoplayLock);
        if (! (bufferHealth > minBufferHealth)) {
          break;
        }
      }
    }
    av_packet_unref(pkt);
  }
  av_frame_free(& frame);
  av_packet_free(& pkt);
  pthread_join(aoplaythread, (void **)((void *)0));
  return (ret);
}
}
static void finish(player_t * const  player ) 
{ 


  {
  ao_close(player->aoDev);
  player->aoDev = (ao_device *)((void *)0);
  if ((unsigned long )player->fgraph != (unsigned long )((void *)0)) {
    avfilter_graph_free(& player->fgraph);
    player->fgraph = (AVFilterGraph *)((void *)0);
  }
  if ((unsigned long )player->cctx != (unsigned long )((void *)0)) {
    avcodec_close(player->cctx);
    player->cctx = (AVCodecContext *)((void *)0);
  }
  if ((unsigned long )player->fctx != (unsigned long )((void *)0)) {
    avformat_close_input(& player->fctx);
  }
  return;
}
}
void *BarPlayerThread(void *data ) 
{ 
  player_t *player ;
  uintptr_t pret ;
  _Bool retry ;
  int tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  player = (player_t *)data;
  pret = (uintptr_t )0;
  while (1) {
    retry = (_Bool)0;
    tmp___3 = openStream((player_t * const  )player);
    if (tmp___3) {
      tmp___1 = openFilter((player_t * const  )player);
      if (tmp___1) {
        tmp___2 = openDevice((player_t * const  )player);
        if (tmp___2) {
          changeMode((player_t * const  )player, 2U);
          BarPlayerSetVolume((player_t * const  )player);
          tmp = play((player_t * const  )player);
          if (tmp == - ((int )((unsigned int )((73 | (78 << 8)) | (68 << 16)) | (65U << 24)))) {
            if (! player->interrupted) {
              tmp___0 = 1;
            } else {
              tmp___0 = 0;
            }
          } else {
            tmp___0 = 0;
          }
          retry = (_Bool )tmp___0;
        } else {
          pret = (uintptr_t )1;
        }
      } else {
        pret = (uintptr_t )1;
      }
    } else {
      pret = (uintptr_t )2;
    }
    changeMode((player_t * const  )player, 1U);
    finish((player_t * const  )player);
    if (! retry) {
      break;
    }
  }
  changeMode((player_t * const  )player, 3U);
  return ((void *)pret);
}
}
void *BarAoPlayThread(void *data ) 
{ 
  player_t *player ;
  AVFrame *filteredFrame ;
  int ret ;
  double timeBase ;
  AVRational tmp ;
  double tmp___0 ;
  double timeBaseSt ;
  double tmp___1 ;
  _Bool tmp___2 ;
  int numChannels ;
  int tmp___3 ;
  int bps ;
  int tmp___4 ;
  double timestamp ;
  unsigned int songPlayed ;
  int64_t lastTimestamp ;
  _Bool tmp___5 ;

  {
  player = (player_t *)data;
  filteredFrame = (AVFrame *)((void *)0);
  filteredFrame = av_frame_alloc();
  tmp = av_buffersink_get_time_base((AVFilterContext const   *)player->fbufsink);
  tmp___0 = av_q2d(tmp);
  timeBase = tmp___0;
  tmp___1 = av_q2d((player->st)->time_base);
  timeBaseSt = tmp___1;
  while (1) {
    tmp___5 = shouldQuit((player_t * const  )player);
    if (tmp___5) {
      break;
    }
    pthread_mutex_lock(& player->aoplayLock);
    ret = av_buffersink_get_frame(player->fbufsink, filteredFrame);
    if (ret == - ((int )((unsigned int )((69 | (79 << 8)) | (70 << 16)) | (32U << 24)))) {
      pthread_mutex_unlock(& player->aoplayLock);
      break;
    } else {
      tmp___2 = shouldQuit((player_t * const  )player);
      if (tmp___2) {
        pthread_mutex_unlock(& player->aoplayLock);
        break;
      } else
      if (ret < 0) {
        pthread_cond_broadcast(& player->aoplayCond);
        pthread_cond_wait((pthread_cond_t * __restrict  )(& player->aoplayCond), (pthread_mutex_t * __restrict  )(& player->aoplayLock));
        pthread_mutex_unlock(& player->aoplayLock);
        continue;
      }
    }
    pthread_mutex_unlock(& player->aoplayLock);
    tmp___3 = av_get_channel_layout_nb_channels(filteredFrame->channel_layout);
    numChannels = tmp___3;
    tmp___4 = av_get_bytes_per_sample((enum AVSampleFormat )filteredFrame->format);
    bps = tmp___4;
    ao_play(player->aoDev, (char *)filteredFrame->data[0], (uint_32 )((filteredFrame->nb_samples * numChannels) * bps));
    timestamp = (double )filteredFrame->pts * timeBase;
    songPlayed = (unsigned int )timestamp;
    pthread_mutex_lock(& player->lock);
    player->songPlayed = songPlayed;
    if (player->doPause) {
      while (1) {
        pthread_cond_wait((pthread_cond_t * __restrict  )(& player->cond), (pthread_mutex_t * __restrict  )(& player->lock));
        if (! player->doPause) {
          break;
        }
      }
    }
    pthread_mutex_unlock(& player->lock);
    lastTimestamp = (int64_t )(timestamp / timeBaseSt);
    pthread_mutex_lock(& player->aoplayLock);
    player->lastTimestamp = lastTimestamp;
    pthread_cond_broadcast(& player->aoplayCond);
    pthread_mutex_unlock(& player->aoplayLock);
    av_frame_unref(filteredFrame);
  }
  av_frame_free(& filteredFrame);
  return ((void *)0);
}
}
#pragma merger("0","/tmp/cil-ldqYcyxf.i","-O2")
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) setenv)(char const   *__name ,
                                                                                   char const   *__value ,
                                                                                   int __replace ) ;
extern int fclose(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
extern struct passwd *getpwuid(__uid_t __uid ) ;
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
void BarUiActHelp(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                  BarUiDispatchContext_t context ) ;
void BarUiActAddMusic(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                      BarUiDispatchContext_t context ) ;
void BarUiActBanSong(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                     BarUiDispatchContext_t context ) ;
void BarUiActCreateStation(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                           BarUiDispatchContext_t context ) ;
void BarUiActCreateStationFromSong(BarApp_t *app___0 , PianoStation_t *selStation ,
                                   PianoSong_t *selSong , BarUiDispatchContext_t context ) ;
void BarUiActAddSharedStation(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                              BarUiDispatchContext_t context ) ;
void BarUiActDeleteStation(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                           BarUiDispatchContext_t context ) ;
void BarUiActExplain(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                     BarUiDispatchContext_t context ) ;
void BarUiActStationFromGenre(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                              BarUiDispatchContext_t context ) ;
void BarUiActSongInfo(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                      BarUiDispatchContext_t context ) ;
void BarUiActLoveSong(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                      BarUiDispatchContext_t context ) ;
void BarUiActSkipSong(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                      BarUiDispatchContext_t context ) ;
void BarUiActPlay(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                  BarUiDispatchContext_t context ) ;
void BarUiActPause(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                   BarUiDispatchContext_t context ) ;
void BarUiActTogglePause(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                         BarUiDispatchContext_t context ) ;
void BarUiActRenameStation(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                           BarUiDispatchContext_t context ) ;
void BarUiActSelectStation(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                           BarUiDispatchContext_t context ) ;
void BarUiActTempBanSong(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                         BarUiDispatchContext_t context ) ;
void BarUiActPrintUpcoming(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                           BarUiDispatchContext_t context ) ;
void BarUiActSelectQuickMix(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                            BarUiDispatchContext_t context ) ;
void BarUiActQuit(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                  BarUiDispatchContext_t context ) ;
void BarUiActDebug(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                   BarUiDispatchContext_t context ) ;
void BarUiActHistory(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                     BarUiDispatchContext_t context ) ;
void BarUiActBookmark(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                      BarUiDispatchContext_t context ) ;
void BarUiActVolDown(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                     BarUiDispatchContext_t context ) ;
void BarUiActVolUp(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                   BarUiDispatchContext_t context ) ;
void BarUiActManageStation(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                           BarUiDispatchContext_t context ) ;
void BarUiActVolReset(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                      BarUiDispatchContext_t context ) ;
void BarUiActSettings(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                      BarUiDispatchContext_t context ) ;
static BarUiDispatchAction_t const   dispatchActions[30]  = 
  {      {(char )'?', (BarUiDispatchContext_t )0, & BarUiActHelp, (char const   * const  )((void *)0),
      (char const   * const  )"act_help"}, 
        {(char )'+', (BarUiDispatchContext_t )4, & BarUiActLoveSong, (char const   * const  )"love song",
      (char const   * const  )"act_songlove"}, 
        {(char )'-', (BarUiDispatchContext_t )4, & BarUiActBanSong, (char const   * const  )"ban song",
      (char const   * const  )"act_songban"}, 
        {(char )'a', (BarUiDispatchContext_t )2, & BarUiActAddMusic, (char const   * const  )"add music to station",
      (char const   * const  )"act_stationaddmusic"}, 
        {(char )'c', (BarUiDispatchContext_t )1, & BarUiActCreateStation, (char const   * const  )"create new station",
      (char const   * const  )"act_stationcreate"}, 
        {(char )'d', (BarUiDispatchContext_t )2, & BarUiActDeleteStation, (char const   * const  )"delete station",
      (char const   * const  )"act_stationdelete"}, 
        {(char )'e', (BarUiDispatchContext_t )4, & BarUiActExplain, (char const   * const  )"explain why this song is played",
      (char const   * const  )"act_songexplain"}, 
        {(char )'g', (BarUiDispatchContext_t )1, & BarUiActStationFromGenre, (char const   * const  )"add genre station",
      (char const   * const  )"act_stationaddbygenre"}, 
        {(char )'h', (BarUiDispatchContext_t )1, & BarUiActHistory, (char const   * const  )"song history",
      (char const   * const  )"act_history"}, 
        {(char )'i', (BarUiDispatchContext_t )7, & BarUiActSongInfo, (char const   * const  )"print information about song/station",
      (char const   * const  )"act_songinfo"}, 
        {(char )'j', (BarUiDispatchContext_t )1, & BarUiActAddSharedStation, (char const   * const  )"add shared station",
      (char const   * const  )"act_addshared"}, 
        {(char )'n', (BarUiDispatchContext_t )3, & BarUiActSkipSong, (char const   * const  )"next song",
      (char const   * const  )"act_songnext"}, 
        {(char )'p', (BarUiDispatchContext_t )3, & BarUiActTogglePause, (char const   * const  )"pause/resume playback",
      (char const   * const  )"act_songpausetoggle"}, 
        {(char )'q', (BarUiDispatchContext_t )1, & BarUiActQuit, (char const   * const  )"quit",
      (char const   * const  )"act_quit"}, 
        {(char )'r', (BarUiDispatchContext_t )2, & BarUiActRenameStation, (char const   * const  )"rename station",
      (char const   * const  )"act_stationrename"}, 
        {(char )'s', (BarUiDispatchContext_t )1, & BarUiActSelectStation, (char const   * const  )"change station",
      (char const   * const  )"act_stationchange"}, 
        {(char )'t', (BarUiDispatchContext_t )4, & BarUiActTempBanSong, (char const   * const  )"tired (ban song for 1 month)",
      (char const   * const  )"act_songtired"}, 
        {(char )'u', (BarUiDispatchContext_t )3, & BarUiActPrintUpcoming, (char const   * const  )"upcoming songs",
      (char const   * const  )"act_upcoming"}, 
        {(char )'x', (BarUiDispatchContext_t )2, & BarUiActSelectQuickMix, (char const   * const  )"select quickmix stations",
      (char const   * const  )"act_stationselectquickmix"}, 
        {(char )'$', (BarUiDispatchContext_t )4, & BarUiActDebug, (char const   * const  )((void *)0),
      (char const   * const  )"act_debug"}, 
        {(char )'b', (BarUiDispatchContext_t )4, & BarUiActBookmark, (char const   * const  )"bookmark song/artist",
      (char const   * const  )"act_bookmark"}, 
        {(char )'(', (BarUiDispatchContext_t )1, & BarUiActVolDown, (char const   * const  )"decrease volume",
      (char const   * const  )"act_voldown"}, 
        {(char )')', (BarUiDispatchContext_t )1, & BarUiActVolUp, (char const   * const  )"increase volume",
      (char const   * const  )"act_volup"}, 
        {(char )'=', (BarUiDispatchContext_t )2, & BarUiActManageStation, (char const   * const  )"manage station seeds/feedback/mode",
      (char const   * const  )"act_managestation"}, 
        {(char )' ', (BarUiDispatchContext_t )3, & BarUiActTogglePause, (char const   * const  )((void *)0),
      (char const   * const  )"act_songpausetoggle2"}, 
        {(char )'v', (BarUiDispatchContext_t )4, & BarUiActCreateStationFromSong, (char const   * const  )"create new station from song or artist",
      (char const   * const  )"act_stationcreatefromsong"}, 
        {(char )'P', (BarUiDispatchContext_t )3, & BarUiActPlay, (char const   * const  )"resume playback",
      (char const   * const  )"act_songplay"}, 
        {(char )'S', (BarUiDispatchContext_t )3, & BarUiActPause, (char const   * const  )"pause playback",
      (char const   * const  )"act_songpause"}, 
        {(char )'^', (BarUiDispatchContext_t )1, & BarUiActVolReset, (char const   * const  )"reset volume",
      (char const   * const  )"act_volreset"}, 
        {(char )'!', (BarUiDispatchContext_t )1, & BarUiActSettings, (char const   * const  )"change settings",
      (char const   * const  )"act_settings"}};
static char *BarSettingsGetHome(void) 
{ 
  char *home ;
  char *tmp ;
  size_t tmp___0 ;
  struct passwd *pw ;
  __uid_t tmp___1 ;
  struct passwd *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;

  {
  home = getenv("HOME");
  if ((unsigned long )home != (unsigned long )((void *)0)) {
    tmp___0 = strlen((char const   *)home);
    if (tmp___0 > 0UL) {
      tmp = strdup((char const   *)home);
      return (tmp);
    }
  }
  tmp___1 = getuid();
  tmp___2 = getpwuid(tmp___1);
  pw = tmp___2;
  if ((unsigned long )pw != (unsigned long )((void *)0)) {
    if ((unsigned long )pw->pw_dir != (unsigned long )((void *)0)) {
      tmp___4 = strlen((char const   *)pw->pw_dir);
      if (tmp___4 > 0UL) {
        tmp___3 = strdup((char const   *)pw->pw_dir);
        return (tmp___3);
      }
    }
  }
  return ((char *)((void *)0));
}
}
static char *BarGetXdgConfigDir(char const   * const  filename ) 
{ 
  char *xdgConfigDir ;
  size_t len ;
  size_t tmp ;
  size_t tmp___0 ;
  char *concat ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  xdgConfigDir = getenv("XDG_CONFIG_HOME");
  if ((unsigned long )xdgConfigDir != (unsigned long )((void *)0)) {
    tmp___2 = strlen((char const   *)xdgConfigDir);
    if (tmp___2 > 0UL) {
      tmp = strlen((char const   *)xdgConfigDir);
      tmp___0 = strlen((char const   *)filename);
      len = ((tmp + 1UL) + tmp___0) + 1UL;
      tmp___1 = malloc(len * sizeof(*concat));
      concat = (char *)tmp___1;
      snprintf((char * __restrict  )concat, len, (char const   * __restrict  )"%s/%s",
               xdgConfigDir, filename);
      return (concat);
    }
  }
  return ((char *)((void *)0));
}
}
char *BarSettingsExpandTilde(char const   * const  path , char const   * const  home ) 
{ 
  char *expanded ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  tmp___2 = strncmp((char const   *)path, "~/", (size_t )2);
  if (tmp___2 == 0) {
    tmp = strlen((char const   *)home);
    tmp___0 = strlen((char const   *)path);
    tmp___1 = malloc(((((tmp + 1UL) + tmp___0) - 2UL) + 1UL) * sizeof(*expanded));
    expanded = (char *)tmp___1;
    sprintf((char * __restrict  )expanded, (char const   * __restrict  )"%s/%s", home,
            path + 2);
    return (expanded);
  }
  tmp___3 = strdup((char const   *)path);
  return (tmp___3);
}
}
void BarSettingsInit(BarSettings_t *settings ) 
{ 


  {
  memset((void *)settings, 0, sizeof(*settings));
  return;
}
}
void BarSettingsDestroy(BarSettings_t *settings ) 
{ 
  size_t i ;

  {
  free((void *)settings->controlProxy);
  free((void *)settings->proxy);
  free((void *)settings->bindTo);
  free((void *)settings->username);
  free((void *)settings->password);
  free((void *)settings->passwordCmd);
  free((void *)settings->autostartStation);
  free((void *)settings->eventCmd);
  free((void *)settings->loveIcon);
  free((void *)settings->banIcon);
  free((void *)settings->tiredIcon);
  free((void *)settings->atIcon);
  free((void *)settings->npSongFormat);
  free((void *)settings->npStationFormat);
  free((void *)settings->listSongFormat);
  free((void *)settings->timeFormat);
  free((void *)settings->fifo);
  free((void *)settings->audioPipe);
  free((void *)settings->rpcHost);
  free((void *)settings->rpcTlsPort);
  free((void *)settings->partnerUser);
  free((void *)settings->partnerPassword);
  free((void *)settings->device);
  free((void *)settings->inkey);
  free((void *)settings->outkey);
  i = (size_t )0;
  while (i < 7UL) {
    free((void *)settings->msgFormat[i].prefix);
    free((void *)settings->msgFormat[i].postfix);
    i ++;
  }
  memset((void *)settings, 0, sizeof(*settings));
  return;
}
}
static char const   *formatMsgPrefix  =    "format_msg_";
static char const   *mapping[6]  = {      "name_az",      "name_za",      "quickmix_01_name_az",      "quickmix_01_name_za", 
        "quickmix_10_name_az",      "quickmix_10_name_za"};
static char const   *mapping___0[7]  = {      "none",      "info",      "nowplaying",      "time", 
        "err",      "question",      "list"};
void BarSettingsRead(BarSettings_t *settings ) 
{ 
  char *configfiles[2] ;
  char *userhome ;
  char *tmp ;
  char *defaultxdg ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t i ;
  size_t j ;
  FILE *configfd ;
  char line[512] ;
  size_t lineNum ;
  char *path ;
  char *tmp___3 ;
  char *ret ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *key ;
  unsigned short const   **tmp___7 ;
  char *val ;
  char *tmp___8 ;
  char *keyend ;
  size_t tmp___9 ;
  unsigned short const   **tmp___10 ;
  unsigned short const   **tmp___11 ;
  char *valend ;
  size_t tmp___12 ;
  size_t i___0 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  size_t i___1 ;
  int tmp___22 ;
  double tmp___23 ;
  int tmp___24 ;
  char const   *typeStart ;
  size_t tmp___25 ;
  size_t i___2 ;
  char const   *formatPos ;
  char *tmp___26 ;
  BarMsgFormatStr_t *format ;
  size_t prefixLen ;
  void *tmp___27 ;
  size_t postfixLen ;
  size_t tmp___28 ;
  void *tmp___29 ;
  int tmp___30 ;
  size_t tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  char *tmpProxy ;
  char *tmp___70 ;
  size_t tmp___71 ;

  {
  configfiles[0] = (char *)"pianobar/state";
  configfiles[1] = (char *)"pianobar/config";
  tmp = BarSettingsGetHome();
  userhome = tmp;
  tmp___0 = strlen((char const   *)userhome);
  tmp___1 = strlen("/.config");
  tmp___2 = malloc((tmp___0 + tmp___1) + 1UL);
  defaultxdg = (char *)tmp___2;
  sprintf((char * __restrict  )defaultxdg, (char const   * __restrict  )"%s/.config",
          userhome);
  setenv("XDG_CONFIG_HOME", (char const   *)defaultxdg, 0);
  free((void *)defaultxdg);
  settings->audioQuality = (PianoAudioQuality_t )3;
  settings->autoselect = (_Bool)1;
  settings->history = 5U;
  settings->volume = 0;
  settings->timeout = 30U;
  settings->gainMul = (float )1.0;
  settings->maxRetry = 5U;
  settings->bufferSecs = 5U;
  settings->sortOrder = (BarStationSorting_t )0;
  settings->loveIcon = strdup(" <3");
  settings->banIcon = strdup(" </3");
  settings->tiredIcon = strdup(" zZ");
  settings->atIcon = strdup(" @ ");
  settings->npSongFormat = strdup("\"%t\" by \"%a\" on \"%l\"%r%@%s");
  settings->npStationFormat = strdup("Station \"%n\" (%i)");
  settings->listSongFormat = strdup("%i) %a - %t%r");
  settings->timeFormat = strdup("%s%r/%t");
  settings->rpcHost = strdup("tuner.pandora.com");
  settings->rpcTlsPort = strdup("443");
  settings->partnerUser = strdup("android");
  settings->partnerPassword = strdup("AC7IBG09A3DTSYM4R41UJWL07VLN8JI7");
  settings->device = strdup("android-generic");
  settings->inkey = strdup("R=U!LH$O2B#");
  settings->outkey = strdup("6#26FRL$ZWD");
  settings->fifo = BarGetXdgConfigDir((char const   * const  )"pianobar/ctl");
  settings->audioPipe = (char *)((void *)0);
  settings->sampleRate = 0;
  settings->msgFormat[0].prefix = (char *)((void *)0);
  settings->msgFormat[0].postfix = (char *)((void *)0);
  settings->msgFormat[1].prefix = strdup("(i) ");
  settings->msgFormat[1].postfix = (char *)((void *)0);
  settings->msgFormat[2].prefix = strdup("|>  ");
  settings->msgFormat[2].postfix = (char *)((void *)0);
  settings->msgFormat[3].prefix = strdup("#   ");
  settings->msgFormat[3].postfix = (char *)((void *)0);
  settings->msgFormat[4].prefix = strdup("/!\\ ");
  settings->msgFormat[4].postfix = (char *)((void *)0);
  settings->msgFormat[5].prefix = strdup("[?] ");
  settings->msgFormat[5].postfix = (char *)((void *)0);
  settings->msgFormat[6].prefix = strdup("\t");
  settings->msgFormat[6].postfix = (char *)((void *)0);
  i = (size_t )0;
  while (i < 30UL) {
    settings->keys[i] = (char )dispatchActions[i].defaultKey;
    i ++;
  }
  j = (size_t )0;
  while (j < sizeof(configfiles) / sizeof(configfiles[0])) {
    lineNum = (size_t )0;
    tmp___3 = BarGetXdgConfigDir((char const   * const  )configfiles[j]);
    path = tmp___3;
    configfd = fopen((char const   * __restrict  )path, (char const   * __restrict  )"r");
    if ((unsigned long )configfd == (unsigned long )((void *)0)) {
      free((void *)path);
      goto __Cont;
    }
    while (1) {
      lineNum ++;
      tmp___4 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )configfd);
      ret = tmp___4;
      if ((unsigned long )ret == (unsigned long )((void *)0)) {
        break;
      }
      tmp___5 = strchr((char const   *)(line), '\n');
      if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
        tmp___6 = feof(configfd);
        if (! tmp___6) {
          BarUiMsg((BarSettings_t const   *)settings, (BarUiMsg_t const   )1, "Line %s:%zu too long, ignoring\n",
                   path, lineNum);
          continue;
        }
      }
      key = line;
      while (1) {
        tmp___7 = __ctype_b_loc();
        if (! ((int const   )*(*tmp___7 + (int )((unsigned char )*(key + 0))) & 8192)) {
          break;
        }
        key ++;
      }
      if ((int )*(key + 0) == 35) {
        continue;
      }
      tmp___8 = strchr((char const   *)(line), '=');
      val = tmp___8;
      if ((unsigned long )val == (unsigned long )((void *)0)) {
        if ((int )*(key + 0) != 0) {
          BarUiMsg((BarSettings_t const   *)settings, (BarUiMsg_t const   )1, "Invalid line at %s:%zu\n",
                   path, lineNum);
        }
        continue;
      }
      *val = (char )'\000';
      val ++;
      tmp___9 = strlen((char const   *)key);
      keyend = key + (tmp___9 - 1UL);
      while (1) {
        if ((unsigned long )keyend >= (unsigned long )key) {
          tmp___10 = __ctype_b_loc();
          if (! ((int const   )*(*tmp___10 + (int )((unsigned char )*keyend)) & 8192)) {
            break;
          }
        } else {
          break;
        }
        *keyend = (char )'\000';
        keyend --;
      }
      tmp___11 = __ctype_b_loc();
      if ((int const   )*(*tmp___11 + (int )((unsigned char )*(val + 0))) & 8192) {
        val ++;
      }
      tmp___12 = strlen((char const   *)val);
      valend = val + (tmp___12 - 1UL);
      while (1) {
        if ((unsigned long )valend >= (unsigned long )val) {
          if (! ((int )*valend == 13)) {
            if (! ((int )*valend == 10)) {
              break;
            }
          }
        } else {
          break;
        }
        *valend = (char )'\000';
        valend --;
      }
      tmp___69 = strcmp("control_proxy", (char const   *)key);
      if (tmp___69 == 0) {
        settings->controlProxy = strdup((char const   *)val);
      } else {
        tmp___68 = strcmp("proxy", (char const   *)key);
        if (tmp___68 == 0) {
          settings->proxy = strdup((char const   *)val);
        } else {
          tmp___67 = strcmp("bind_to", (char const   *)key);
          if (tmp___67 == 0) {
            settings->bindTo = strdup((char const   *)val);
          } else {
            tmp___66 = strcmp("user", (char const   *)key);
            if (tmp___66 == 0) {
              settings->username = strdup((char const   *)val);
            } else {
              tmp___65 = strcmp("password", (char const   *)key);
              if (tmp___65 == 0) {
                settings->password = strdup((char const   *)val);
              } else {
                tmp___64 = strcmp("password_command", (char const   *)key);
                if (tmp___64 == 0) {
                  settings->passwordCmd = strdup((char const   *)val);
                } else {
                  tmp___63 = strcmp("rpc_host", (char const   *)key);
                  if (tmp___63 == 0) {
                    free((void *)settings->rpcHost);
                    settings->rpcHost = strdup((char const   *)val);
                  } else {
                    tmp___62 = strcmp("rpc_tls_port", (char const   *)key);
                    if (tmp___62 == 0) {
                      free((void *)settings->rpcTlsPort);
                      settings->rpcTlsPort = strdup((char const   *)val);
                    } else {
                      tmp___61 = strcmp("partner_user", (char const   *)key);
                      if (tmp___61 == 0) {
                        free((void *)settings->partnerUser);
                        settings->partnerUser = strdup((char const   *)val);
                      } else {
                        tmp___60 = strcmp("partner_password", (char const   *)key);
                        if (tmp___60 == 0) {
                          free((void *)settings->partnerPassword);
                          settings->partnerPassword = strdup((char const   *)val);
                        } else {
                          tmp___59 = strcmp("device", (char const   *)key);
                          if (tmp___59 == 0) {
                            free((void *)settings->device);
                            settings->device = strdup((char const   *)val);
                          } else {
                            tmp___58 = strcmp("encrypt_password", (char const   *)key);
                            if (tmp___58 == 0) {
                              free((void *)settings->outkey);
                              settings->outkey = strdup((char const   *)val);
                            } else {
                              tmp___57 = strcmp("decrypt_password", (char const   *)key);
                              if (tmp___57 == 0) {
                                free((void *)settings->inkey);
                                settings->inkey = strdup((char const   *)val);
                              } else {
                                tmp___56 = strcmp("ca_bundle", (char const   *)key);
                                if (tmp___56 == 0) {
                                  free((void *)settings->caBundle);
                                  settings->caBundle = strdup((char const   *)val);
                                } else {
                                  tmp___55 = memcmp((void const   *)"act_", (void const   *)key,
                                                    (size_t )4);
                                  if (tmp___55 == 0) {
                                    i___0 = (size_t )0;
                                    while (i___0 < 30UL) {
                                      tmp___14 = strcmp((char const   *)dispatchActions[i___0].configKey,
                                                        (char const   *)key);
                                      if (tmp___14 == 0) {
                                        tmp___13 = strcmp((char const   *)val, "disabled");
                                        if (tmp___13 == 0) {
                                          settings->keys[i___0] = (char )'\000';
                                        } else {
                                          settings->keys[i___0] = *(val + 0);
                                        }
                                        break;
                                      }
                                      i___0 ++;
                                    }
                                  } else {
                                    tmp___54 = strcmp("audio_quality", (char const   *)key);
                                    if (tmp___54 == 0) {
                                      tmp___17 = strcmp((char const   *)val, "low");
                                      if (tmp___17 == 0) {
                                        settings->audioQuality = (PianoAudioQuality_t )1;
                                      } else {
                                        tmp___16 = strcmp((char const   *)val, "medium");
                                        if (tmp___16 == 0) {
                                          settings->audioQuality = (PianoAudioQuality_t )2;
                                        } else {
                                          tmp___15 = strcmp((char const   *)val, "high");
                                          if (tmp___15 == 0) {
                                            settings->audioQuality = (PianoAudioQuality_t )3;
                                          }
                                        }
                                      }
                                    } else {
                                      tmp___53 = strcmp("autostart_station", (char const   *)key);
                                      if (tmp___53 == 0) {
                                        free((void *)settings->autostartStation);
                                        settings->autostartStation = strdup((char const   *)val);
                                      } else {
                                        tmp___52 = strcmp("event_command", (char const   *)key);
                                        if (tmp___52 == 0) {
                                          settings->eventCmd = BarSettingsExpandTilde((char const   * const  )val,
                                                                                      (char const   * const  )userhome);
                                        } else {
                                          tmp___51 = strcmp("history", (char const   *)key);
                                          if (tmp___51 == 0) {
                                            tmp___18 = atoi((char const   *)val);
                                            settings->history = (unsigned int )tmp___18;
                                          } else {
                                            tmp___50 = strcmp("max_retry", (char const   *)key);
                                            if (tmp___50 == 0) {
                                              tmp___19 = atoi((char const   *)val);
                                              settings->maxRetry = (unsigned int )tmp___19;
                                            } else {
                                              tmp___49 = strcmp("timeout", (char const   *)key);
                                              if (tmp___49 == 0) {
                                                tmp___20 = atoi((char const   *)val);
                                                settings->timeout = (unsigned int )tmp___20;
                                              } else {
                                                tmp___48 = strcmp("buffer_seconds",
                                                                  (char const   *)key);
                                                if (tmp___48 == 0) {
                                                  tmp___21 = atoi((char const   *)val);
                                                  settings->bufferSecs = (unsigned int )tmp___21;
                                                } else {
                                                  tmp___47 = strcmp("sort", (char const   *)key);
                                                  if (tmp___47 == 0) {
                                                    i___1 = (size_t )0;
                                                    while (i___1 < 6UL) {
                                                      tmp___22 = strcmp(mapping[i___1],
                                                                        (char const   *)val);
                                                      if (tmp___22 == 0) {
                                                        settings->sortOrder = (BarStationSorting_t )i___1;
                                                        break;
                                                      }
                                                      i___1 ++;
                                                    }
                                                  } else {
                                                    tmp___46 = strcmp("love_icon",
                                                                      (char const   *)key);
                                                    if (tmp___46 == 0) {
                                                      free((void *)settings->loveIcon);
                                                      settings->loveIcon = strdup((char const   *)val);
                                                    } else {
                                                      tmp___45 = strcmp("ban_icon",
                                                                        (char const   *)key);
                                                      if (tmp___45 == 0) {
                                                        free((void *)settings->banIcon);
                                                        settings->banIcon = strdup((char const   *)val);
                                                      } else {
                                                        tmp___44 = strcmp("tired_icon",
                                                                          (char const   *)key);
                                                        if (tmp___44 == 0) {
                                                          free((void *)settings->tiredIcon);
                                                          settings->tiredIcon = strdup((char const   *)val);
                                                        } else {
                                                          tmp___43 = strcmp("at_icon",
                                                                            (char const   *)key);
                                                          if (tmp___43 == 0) {
                                                            free((void *)settings->atIcon);
                                                            settings->atIcon = strdup((char const   *)val);
                                                          } else {
                                                            tmp___42 = strcmp("volume",
                                                                              (char const   *)key);
                                                            if (tmp___42 == 0) {
                                                              settings->volume = atoi((char const   *)val);
                                                            } else {
                                                              tmp___41 = strcmp("gain_mul",
                                                                                (char const   *)key);
                                                              if (tmp___41 == 0) {
                                                                tmp___23 = atof((char const   *)val);
                                                                settings->gainMul = (float )tmp___23;
                                                              } else {
                                                                tmp___40 = strcmp("format_nowplaying_song",
                                                                                  (char const   *)key);
                                                                if (tmp___40 == 0) {
                                                                  free((void *)settings->npSongFormat);
                                                                  settings->npSongFormat = strdup((char const   *)val);
                                                                } else {
                                                                  tmp___39 = strcmp("format_nowplaying_station",
                                                                                    (char const   *)key);
                                                                  if (tmp___39 == 0) {
                                                                    free((void *)settings->npStationFormat);
                                                                    settings->npStationFormat = strdup((char const   *)val);
                                                                  } else {
                                                                    tmp___38 = strcmp("format_list_song",
                                                                                      (char const   *)key);
                                                                    if (tmp___38 == 0) {
                                                                      free((void *)settings->listSongFormat);
                                                                      settings->listSongFormat = strdup((char const   *)val);
                                                                    } else {
                                                                      tmp___37 = strcmp("format_time",
                                                                                        (char const   *)key);
                                                                      if (tmp___37 == 0) {
                                                                        free((void *)settings->timeFormat);
                                                                        settings->timeFormat = strdup((char const   *)val);
                                                                      } else {
                                                                        tmp___36 = strcmp("fifo",
                                                                                          (char const   *)key);
                                                                        if (tmp___36 == 0) {
                                                                          free((void *)settings->fifo);
                                                                          settings->fifo = BarSettingsExpandTilde((char const   * const  )val,
                                                                                                                  (char const   * const  )userhome);
                                                                        } else {
                                                                          tmp___35 = strcmp("audio_pipe",
                                                                                            (char const   *)key);
                                                                          if (tmp___35 == 0) {
                                                                            free((void *)settings->audioPipe);
                                                                            settings->audioPipe = BarSettingsExpandTilde((char const   * const  )val,
                                                                                                                         (char const   * const  )userhome);
                                                                          } else {
                                                                            tmp___34 = strcmp("autoselect",
                                                                                              (char const   *)key);
                                                                            if (tmp___34 == 0) {
                                                                              tmp___24 = atoi((char const   *)val);
                                                                              settings->autoselect = (_Bool )tmp___24;
                                                                            } else {
                                                                              tmp___33 = strcmp("sample_rate",
                                                                                                (char const   *)key);
                                                                              if (tmp___33 == 0) {
                                                                                settings->sampleRate = atoi((char const   *)val);
                                                                              } else {
                                                                                tmp___31 = strlen(formatMsgPrefix);
                                                                                tmp___32 = strncmp(formatMsgPrefix,
                                                                                                   (char const   *)key,
                                                                                                   tmp___31);
                                                                                if (tmp___32 == 0) {
                                                                                  tmp___25 = strlen(formatMsgPrefix);
                                                                                  typeStart = (char const   *)(key + tmp___25);
                                                                                  i___2 = (size_t )0;
                                                                                  while (i___2 < sizeof(mapping___0) / sizeof(mapping___0[0])) {
                                                                                    tmp___30 = strcmp(typeStart,
                                                                                                      mapping___0[i___2]);
                                                                                    if (tmp___30 == 0) {
                                                                                      tmp___26 = strstr((char const   *)val,
                                                                                                        "%s");
                                                                                      formatPos = (char const   *)tmp___26;
                                                                                      if ((unsigned long )formatPos != (unsigned long )((void *)0)) {
                                                                                        format = & settings->msgFormat[i___2];
                                                                                        free((void *)format->prefix);
                                                                                        free((void *)format->postfix);
                                                                                        prefixLen = (size_t )(formatPos - (char const   *)val);
                                                                                        tmp___27 = calloc(prefixLen + 1UL,
                                                                                                          sizeof(*(format->prefix)));
                                                                                        format->prefix = (char *)tmp___27;
                                                                                        memcpy((void * __restrict  )format->prefix,
                                                                                               (void const   * __restrict  )val,
                                                                                               prefixLen);
                                                                                        tmp___28 = strlen((char const   *)val);
                                                                                        postfixLen = (tmp___28 - (size_t )(formatPos - (char const   *)val)) - 2UL;
                                                                                        tmp___29 = calloc(postfixLen + 1UL,
                                                                                                          sizeof(*(format->postfix)));
                                                                                        format->postfix = (char *)tmp___29;
                                                                                        memcpy((void * __restrict  )format->postfix,
                                                                                               (void const   * __restrict  )(formatPos + 2),
                                                                                               postfixLen);
                                                                                      }
                                                                                      break;
                                                                                    }
                                                                                    i___2 ++;
                                                                                  }
                                                                                } else {
                                                                                  BarUiMsg((BarSettings_t const   *)settings,
                                                                                           (BarUiMsg_t const   )1,
                                                                                           "Unrecognized key %s at %s:%zu\n",
                                                                                           key,
                                                                                           path,
                                                                                           lineNum);
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    fclose(configfd);
    free((void *)path);
    __Cont: /* CIL Label */ 
    j ++;
  }
  if ((unsigned long )settings->proxy == (unsigned long )((void *)0)) {
    tmp___70 = getenv("http_proxy");
    tmpProxy = tmp___70;
    if ((unsigned long )tmpProxy != (unsigned long )((void *)0)) {
      tmp___71 = strlen((char const   *)tmpProxy);
      if (tmp___71 > 0UL) {
        settings->proxy = strdup((char const   *)tmpProxy);
      }
    }
  }
  if ((unsigned long )settings->proxy != (unsigned long )((void *)0)) {
    setenv("http_proxy", (char const   *)settings->proxy, 1);
  }
  free((void *)userhome);
  return;
}
}
void BarSettingsWrite(PianoStation_t *station , BarSettings_t *settings ) 
{ 
  FILE *fd ;
  char *path ;
  char *tmp ;

  {
  tmp = BarGetXdgConfigDir((char const   * const  )"pianobar/state");
  path = tmp;
  fd = fopen((char const   * __restrict  )path, (char const   * __restrict  )"w");
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    free((void *)path);
    return;
  }
  fputs((char const   * __restrict  )"# do not edit this file\n", (FILE * __restrict  )fd);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"volume = %i\n", settings->volume);
  if ((unsigned long )station != (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"autostart_station = %s\n",
            station->id);
  }
  fclose(fd);
  free((void *)path);
  return;
}
}
#pragma merger("0","/tmp/cil-EVW4gbZM.i","-O2")
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 16) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 32) != 0);
}
}
static struct termios restore  ;
static void BarTermHandleCont(int sig ) 
{ 


  {
  BarTermInit();
  return;
}
}
void BarTermInit(void) 
{ 
  struct termios newopt ;

  {
  tcgetattr(0, & restore);
  memcpy((void * __restrict  )(& newopt), (void const   * __restrict  )(& restore),
         sizeof(newopt));
  newopt.c_lflag &= 4294967285U;
  tcsetattr(0, 0, (struct termios  const  *)(& newopt));
  signal(18, & BarTermHandleCont);
  return;
}
}
void BarTermRestore(void) 
{ 


  {
  tcsetattr(0, 0, (struct termios  const  *)(& restore));
  return;
}
}
#pragma merger("0","/tmp/cil-UaWkmvc6.i","-O2")
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
void *PianoListGet(PianoListHead_t * const  l , size_t const   n ) ;
void PianoDestroyStationInfo(PianoStationInfo_t *info ) ;
void PianoDestroyStationMode(PianoStationMode_t * const  modes ) ;
size_t BarReadlineInt(int *ret , BarReadlineFds_t *input ) ;
_Bool BarReadlineYesNo(_Bool def , BarReadlineFds_t *input ) ;
PianoSong_t *BarUiSelectSong(BarApp_t const   * const  app___0 , PianoSong_t *startSong ,
                             BarReadlineFds_t *input ) ;
PianoArtist_t *BarUiSelectArtist(BarApp_t *app___0 , PianoArtist_t *startArtist ) ;
char *BarUiSelectMusicId(BarApp_t *app___0 , PianoStation_t *station , char const   *msg ) ;
size_t BarUiListSongs(BarApp_t const   * const  app___0 , PianoSong_t const   *song ,
                      char const   *filter ) ;
static BarUiDispatchAction_t const   dispatchActions___0[30]  = 
  {      {(char )'?', (BarUiDispatchContext_t )0, & BarUiActHelp, (char const   * const  )((void *)0),
      (char const   * const  )"act_help"}, 
        {(char )'+', (BarUiDispatchContext_t )4, & BarUiActLoveSong, (char const   * const  )"love song",
      (char const   * const  )"act_songlove"}, 
        {(char )'-', (BarUiDispatchContext_t )4, & BarUiActBanSong, (char const   * const  )"ban song",
      (char const   * const  )"act_songban"}, 
        {(char )'a', (BarUiDispatchContext_t )2, & BarUiActAddMusic, (char const   * const  )"add music to station",
      (char const   * const  )"act_stationaddmusic"}, 
        {(char )'c', (BarUiDispatchContext_t )1, & BarUiActCreateStation, (char const   * const  )"create new station",
      (char const   * const  )"act_stationcreate"}, 
        {(char )'d', (BarUiDispatchContext_t )2, & BarUiActDeleteStation, (char const   * const  )"delete station",
      (char const   * const  )"act_stationdelete"}, 
        {(char )'e', (BarUiDispatchContext_t )4, & BarUiActExplain, (char const   * const  )"explain why this song is played",
      (char const   * const  )"act_songexplain"}, 
        {(char )'g', (BarUiDispatchContext_t )1, & BarUiActStationFromGenre, (char const   * const  )"add genre station",
      (char const   * const  )"act_stationaddbygenre"}, 
        {(char )'h', (BarUiDispatchContext_t )1, & BarUiActHistory, (char const   * const  )"song history",
      (char const   * const  )"act_history"}, 
        {(char )'i', (BarUiDispatchContext_t )7, & BarUiActSongInfo, (char const   * const  )"print information about song/station",
      (char const   * const  )"act_songinfo"}, 
        {(char )'j', (BarUiDispatchContext_t )1, & BarUiActAddSharedStation, (char const   * const  )"add shared station",
      (char const   * const  )"act_addshared"}, 
        {(char )'n', (BarUiDispatchContext_t )3, & BarUiActSkipSong, (char const   * const  )"next song",
      (char const   * const  )"act_songnext"}, 
        {(char )'p', (BarUiDispatchContext_t )3, & BarUiActTogglePause, (char const   * const  )"pause/resume playback",
      (char const   * const  )"act_songpausetoggle"}, 
        {(char )'q', (BarUiDispatchContext_t )1, & BarUiActQuit, (char const   * const  )"quit",
      (char const   * const  )"act_quit"}, 
        {(char )'r', (BarUiDispatchContext_t )2, & BarUiActRenameStation, (char const   * const  )"rename station",
      (char const   * const  )"act_stationrename"}, 
        {(char )'s', (BarUiDispatchContext_t )1, & BarUiActSelectStation, (char const   * const  )"change station",
      (char const   * const  )"act_stationchange"}, 
        {(char )'t', (BarUiDispatchContext_t )4, & BarUiActTempBanSong, (char const   * const  )"tired (ban song for 1 month)",
      (char const   * const  )"act_songtired"}, 
        {(char )'u', (BarUiDispatchContext_t )3, & BarUiActPrintUpcoming, (char const   * const  )"upcoming songs",
      (char const   * const  )"act_upcoming"}, 
        {(char )'x', (BarUiDispatchContext_t )2, & BarUiActSelectQuickMix, (char const   * const  )"select quickmix stations",
      (char const   * const  )"act_stationselectquickmix"}, 
        {(char )'$', (BarUiDispatchContext_t )4, & BarUiActDebug, (char const   * const  )((void *)0),
      (char const   * const  )"act_debug"}, 
        {(char )'b', (BarUiDispatchContext_t )4, & BarUiActBookmark, (char const   * const  )"bookmark song/artist",
      (char const   * const  )"act_bookmark"}, 
        {(char )'(', (BarUiDispatchContext_t )1, & BarUiActVolDown, (char const   * const  )"decrease volume",
      (char const   * const  )"act_voldown"}, 
        {(char )')', (BarUiDispatchContext_t )1, & BarUiActVolUp, (char const   * const  )"increase volume",
      (char const   * const  )"act_volup"}, 
        {(char )'=', (BarUiDispatchContext_t )2, & BarUiActManageStation, (char const   * const  )"manage station seeds/feedback/mode",
      (char const   * const  )"act_managestation"}, 
        {(char )' ', (BarUiDispatchContext_t )3, & BarUiActTogglePause, (char const   * const  )((void *)0),
      (char const   * const  )"act_songpausetoggle2"}, 
        {(char )'v', (BarUiDispatchContext_t )4, & BarUiActCreateStationFromSong, (char const   * const  )"create new station from song or artist",
      (char const   * const  )"act_stationcreatefromsong"}, 
        {(char )'P', (BarUiDispatchContext_t )3, & BarUiActPlay, (char const   * const  )"resume playback",
      (char const   * const  )"act_songplay"}, 
        {(char )'S', (BarUiDispatchContext_t )3, & BarUiActPause, (char const   * const  )"pause playback",
      (char const   * const  )"act_songpause"}, 
        {(char )'^', (BarUiDispatchContext_t )1, & BarUiActVolReset, (char const   * const  )"reset volume",
      (char const   * const  )"act_volreset"}, 
        {(char )'!', (BarUiDispatchContext_t )1, & BarUiActSettings, (char const   * const  )"change settings",
      (char const   * const  )"act_settings"}};
__inline static void BarUiDoSkipSong(player_t * const  player ) 
{ 


  {
  pthread_mutex_lock(& player->lock);
  player->doQuit = (_Bool)1;
  player->doPause = (_Bool)0;
  pthread_cond_broadcast(& player->cond);
  pthread_mutex_unlock(& player->lock);
  pthread_mutex_lock(& player->aoplayLock);
  pthread_cond_broadcast(& player->aoplayCond);
  pthread_mutex_unlock(& player->aoplayLock);
  return;
}
}
static int BarTransformIfShared(BarApp_t *app___0 , PianoStation_t *station ) 
{ 
  PianoReturn_t pRet ;
  CURLcode wRet ;
  _Bool tmp ;

  {
  if (! station->isCreator) {
    BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
             "Transforming station... ");
    tmp = BarUiPianoCall((BarApp_t * const  )app___0, (PianoRequestType_t const   )15,
                         (void *)station, & pRet, & wRet);
    if (! tmp) {
      return (0);
    }
  }
  return (1);
}
}
void BarUiActHelp(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                  BarUiDispatchContext_t context ) 
{ 
  size_t i ;

  {
  BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )0,
           "\r");
  i = (size_t )0;
  while (i < 30UL) {
    if ((unsigned long )dispatchActions___0[i].helpText != (unsigned long )((void *)0)) {
      if (((unsigned int )context & (unsigned int )dispatchActions___0[i].context) == (unsigned int )dispatchActions___0[i].context) {
        if ((int )app___0->settings.keys[i] != 0) {
          BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )6,
                   "%c    %s\n", (int )app___0->settings.keys[i], dispatchActions___0[i].helpText);
        }
      }
    }
    i ++;
  }
  return;
}
}
void BarUiActAddMusic(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                      BarUiDispatchContext_t context ) 
{ 
  PianoReturn_t pRet ;
  CURLcode wRet ;
  PianoRequestDataAddSeed_t reqData ;
  int tmp ;

  {
  reqData.musicId = BarUiSelectMusicId(app___0, selStation, "Add artist or title to station: ");
  if ((unsigned long )reqData.musicId != (unsigned long )((void *)0)) {
    tmp = BarTransformIfShared(app___0, selStation);
    if (! tmp) {
      return;
    }
    reqData.station = selStation;
    BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
             "Adding music to station... ");
    BarUiPianoCall((BarApp_t * const  )app___0, (PianoRequestType_t const   )11, (void *)(& reqData),
                   & pRet, & wRet);
    free((void *)reqData.musicId);
    BarUiStartEventCmd((BarSettings_t const   *)(& app___0->settings), "stationaddmusic",
                       (PianoStation_t const   *)selStation, (PianoSong_t const   *)selSong,
                       & app___0->player, app___0->ph.stations, pRet, wRet);
  }
  return;
}
}
void BarUiActBanSong(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                     BarUiDispatchContext_t context ) 
{ 
  PianoReturn_t pRet ;
  CURLcode wRet ;
  PianoStation_t *realStation ;
  int tmp ;
  PianoRequestDataRateSong_t reqData ;
  _Bool tmp___0 ;

  {
  realStation = PianoFindStationById((PianoStation_t * const  )app___0->ph.stations,
                                     (char const   * const  )selSong->stationId);
  if ((unsigned long )realStation == (unsigned long )((void *)0)) {
    return;
  }
  tmp = BarTransformIfShared(app___0, realStation);
  if (! tmp) {
    return;
  }
  reqData.song = selSong;
  reqData.rating = (PianoSongRating_t )2;
  BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
           "Banning song... ");
  tmp___0 = BarUiPianoCall((BarApp_t * const  )app___0, (PianoRequestType_t const   )4,
                           (void *)(& reqData), & pRet, & wRet);
  if (tmp___0) {
    if ((unsigned long )selSong == (unsigned long )app___0->playlist) {
      BarUiDoSkipSong((player_t * const  )(& app___0->player));
    }
  }
  BarUiStartEventCmd((BarSettings_t const   *)(& app___0->settings), "songban", (PianoStation_t const   *)selStation,
                     (PianoSong_t const   *)selSong, & app___0->player, app___0->ph.stations,
                     pRet, wRet);
  return;
}
}
void BarUiActCreateStation(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                           BarUiDispatchContext_t context ) 
{ 
  PianoReturn_t pRet ;
  CURLcode wRet ;
  PianoRequestDataCreateStation_t reqData ;

  {
  reqData.type = (enum __anonenum_type_185732391 )0;
  reqData.token = BarUiSelectMusicId(app___0, (PianoStation_t *)((void *)0), "Create station from artist or title: ");
  if ((unsigned long )reqData.token != (unsigned long )((void *)0)) {
    BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
             "Creating station... ");
    BarUiPianoCall((BarApp_t * const  )app___0, (PianoRequestType_t const   )10, (void *)(& reqData),
                   & pRet, & wRet);
    free((void *)reqData.token);
    BarUiStartEventCmd((BarSettings_t const   *)(& app___0->settings), "stationcreate",
                       (PianoStation_t const   *)selStation, (PianoSong_t const   *)selSong,
                       & app___0->player, app___0->ph.stations, pRet, wRet);
  }
  return;
}
}
void BarUiActCreateStationFromSong(BarApp_t *app___0 , PianoStation_t *selStation ,
                                   PianoSong_t *selSong , BarUiDispatchContext_t context ) 
{ 
  PianoReturn_t pRet ;
  CURLcode wRet ;
  PianoRequestDataCreateStation_t reqData ;
  char selectBuf[2] ;

  {
  reqData.token = selSong->trackToken;
  reqData.type = (enum __anonenum_type_185732391 )0;
  BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )5,
           "Create station from [s]ong or [a]rtist? ");
  BarReadline(selectBuf, (size_t const   )sizeof(selectBuf), "sa", & app___0->input,
              (BarReadlineFlags_t const   )1, -1);
  switch ((int )selectBuf[0]) {
  case 115: 
  reqData.type = (enum __anonenum_type_185732391 )1;
  break;
  case 97: 
  reqData.type = (enum __anonenum_type_185732391 )2;
  break;
  }
  if ((unsigned int )reqData.type != 0U) {
    BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
             "Creating station... ");
    BarUiPianoCall((BarApp_t * const  )app___0, (PianoRequestType_t const   )10, (void *)(& reqData),
                   & pRet, & wRet);
    BarUiStartEventCmd((BarSettings_t const   *)(& app___0->settings), "stationcreate",
                       (PianoStation_t const   *)selStation, (PianoSong_t const   *)selSong,
                       & app___0->player, app___0->ph.stations, pRet, wRet);
  }
  return;
}
}
void BarUiActAddSharedStation(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                              BarUiDispatchContext_t context ) 
{ 
  PianoReturn_t pRet ;
  CURLcode wRet ;
  char stationId[50] ;
  PianoRequestDataCreateStation_t reqData ;
  size_t tmp ;

  {
  reqData.token = stationId;
  reqData.type = (enum __anonenum_type_185732391 )0;
  BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )5,
           "Station id: ");
  tmp = BarReadline(stationId, (size_t const   )sizeof(stationId), "0123456789", & app___0->input,
                    (BarReadlineFlags_t const   )0, -1);
  if (tmp > 0UL) {
    BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
             "Adding shared station... ");
    BarUiPianoCall((BarApp_t * const  )app___0, (PianoRequestType_t const   )10, (void *)(& reqData),
                   & pRet, & wRet);
    BarUiStartEventCmd((BarSettings_t const   *)(& app___0->settings), "stationaddshared",
                       (PianoStation_t const   *)selStation, (PianoSong_t const   *)selSong,
                       & app___0->player, app___0->ph.stations, pRet, wRet);
  }
  return;
}
}
static void drainPlaylist(BarApp_t * const  app___0 ) 
{ 
  void *tmp ;

  {
  BarUiDoSkipSong((player_t * const  )(& app___0->player));
  if ((unsigned long )app___0->playlist != (unsigned long )((void *)0)) {
    if ((unsigned long )app___0->playlist == (unsigned long )((void *)0)) {
      tmp = (void *)0;
    } else {
      tmp = (void *)(app___0->playlist)->head.next;
    }
    PianoDestroyPlaylist((PianoSong_t *)tmp);
    (app___0->playlist)->head.next = (struct PianoListHead *)((void *)0);
  }
  return;
}
}
void BarUiActDeleteStation(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                           BarUiDispatchContext_t context ) 
{ 
  PianoReturn_t pRet ;
  CURLcode wRet ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
  BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )5,
           "Really delete \"%s\"? [yN] ", selStation->name);
  tmp___0 = BarReadlineYesNo((_Bool)0, & app___0->input);
  if (tmp___0) {
    BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
             "Deleting station... ");
    tmp = BarUiPianoCall((BarApp_t * const  )app___0, (PianoRequestType_t const   )8,
                         (void *)selStation, & pRet, & wRet);
    if (tmp) {
      if ((unsigned long )selStation == (unsigned long )app___0->curStation) {
        drainPlaylist((BarApp_t * const  )app___0);
        app___0->nextStation = (PianoStation_t *)((void *)0);
        app___0->curStation = (PianoStation_t *)((void *)0);
        selStation = (PianoStation_t *)((void *)0);
      }
    }
    BarUiStartEventCmd((BarSettings_t const   *)(& app___0->settings), "stationdelete",
                       (PianoStation_t const   *)selStation, (PianoSong_t const   *)selSong,
                       & app___0->player, app___0->ph.stations, pRet, wRet);
  }
  return;
}
}
void BarUiActExplain(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                     BarUiDispatchContext_t context ) 
{ 
  PianoReturn_t pRet ;
  CURLcode wRet ;
  PianoRequestDataExplain_t reqData ;
  _Bool tmp ;

  {
  reqData.song = selSong;
  BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
           "Receiving explanation... ");
  tmp = BarUiPianoCall((BarApp_t * const  )app___0, (PianoRequestType_t const   )16,
                       (void *)(& reqData), & pRet, & wRet);
  if (tmp) {
    BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
             "%s\n", reqData.retExplain);
    free((void *)reqData.retExplain);
  }
  BarUiStartEventCmd((BarSettings_t const   *)(& app___0->settings), "songexplain",
                     (PianoStation_t const   *)selStation, (PianoSong_t const   *)selSong,
                     & app___0->player, app___0->ph.stations, pRet, wRet);
  return;
}
}
void BarUiActStationFromGenre(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                              BarUiDispatchContext_t context ) 
{ 
  PianoReturn_t pRet ;
  CURLcode wRet ;
  PianoGenreCategory_t const   *curCat ;
  PianoGenre_t const   *curGenre ;
  int i ;
  _Bool ret ;
  _Bool tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  PianoRequestDataCreateStation_t reqData ;

  {
  if ((unsigned long )app___0->ph.genreStations == (unsigned long )((void *)0)) {
    BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
             "Receiving genre stations... ");
    tmp = BarUiPianoCall((BarApp_t * const  )app___0, (PianoRequestType_t const   )14,
                         (void *)0, & pRet, & wRet);
    ret = tmp;
    BarUiStartEventCmd((BarSettings_t const   *)(& app___0->settings), "stationfetchgenre",
                       (PianoStation_t const   *)selStation, (PianoSong_t const   *)selSong,
                       & app___0->player, app___0->ph.stations, pRet, wRet);
    if (! ret) {
      return;
    }
  }
  curCat = (PianoGenreCategory_t const   *)app___0->ph.genreStations;
  i = 0;
  while ((unsigned long )curCat != (unsigned long )((void *)0)) {
    BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )6,
             "%2i) %s\n", i, curCat->name);
    i ++;
    curCat = (PianoGenreCategory_t const   *)((void *)curCat->head.next);
  }
  while (1) {
    BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )5,
             "Select category: ");
    tmp___0 = BarReadlineInt(& i, & app___0->input);
    if (tmp___0 == 0UL) {
      return;
    }
    tmp___1 = PianoListGet((PianoListHead_t * const  )(& (app___0->ph.genreStations)->head),
                           (size_t const   )i);
    curCat = (PianoGenreCategory_t const   *)tmp___1;
    if (! ((unsigned long )curCat == (unsigned long )((void *)0))) {
      break;
    }
  }
  i = 0;
  curGenre = (PianoGenre_t const   *)curCat->genres;
  while ((unsigned long )curGenre != (unsigned long )((void *)0)) {
    BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )6,
             "%2i) %s\n", i, curGenre->name);
    i ++;
    curGenre = (PianoGenre_t const   *)((void *)curGenre->head.next);
  }
  while (1) {
    BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )5,
             "Select genre: ");
    tmp___2 = BarReadlineInt(& i, & app___0->input);
    if (tmp___2 == 0UL) {
      return;
    }
    tmp___3 = PianoListGet((PianoListHead_t * const  )(& (curCat->genres)->head),
                           (size_t const   )i);
    curGenre = (PianoGenre_t const   *)tmp___3;
    if (! ((unsigned long )curGenre == (unsigned long )((void *)0))) {
      break;
    }
  }
  reqData.token = (char *)curGenre->musicId;
  reqData.type = (enum __anonenum_type_185732391 )0;
  BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
           "Adding genre station \"%s\"... ", curGenre->name);
  BarUiPianoCall((BarApp_t * const  )app___0, (PianoRequestType_t const   )10, (void *)(& reqData),
                 & pRet, & wRet);
  BarUiStartEventCmd((BarSettings_t const   *)(& app___0->settings), "stationaddgenre",
                     (PianoStation_t const   *)selStation, (PianoSong_t const   *)selSong,
                     & app___0->player, app___0->ph.stations, pRet, wRet);
  return;
}
}
void BarUiActSongInfo(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                      BarUiDispatchContext_t context ) 
{ 
  PianoStation_t *tmp ;
  PianoStation_t *tmp___0 ;

  {
  BarUiPrintStation((BarSettings_t const   *)(& app___0->settings), selStation);
  if (selStation->isQuickMix) {
    tmp = PianoFindStationById((PianoStation_t * const  )app___0->ph.stations, (char const   * const  )selSong->stationId);
    tmp___0 = tmp;
  } else {
    tmp___0 = (PianoStation_t *)((void *)0);
  }
  BarUiPrintSong((BarSettings_t const   *)(& app___0->settings), (PianoSong_t const   *)selSong,
                 (PianoStation_t const   *)tmp___0);
  return;
}
}
void BarUiActDebug(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                   BarUiDispatchContext_t context ) 
{ 


  {
  BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )0,
           "album:\t%s\nartist:\t%s\naudioFormat:\t%i\naudioUrl:\t%s\ncoverArt:\t%s\ndetailUrl:\t%s\nfileGain:\t%f\nmusicId:\t%s\nrating:\t%i\nstationId:\t%s\ntitle:\t%s\ntrackToken:\t%s\n",
           selSong->album, selSong->artist, (unsigned int )selSong->audioFormat, selSong->audioUrl,
           selSong->coverArt, selSong->detailUrl, (double )selSong->fileGain, selSong->musicId,
           (unsigned int )selSong->rating, selSong->stationId, selSong->title, selSong->trackToken);
  return;
}
}
void BarUiActLoveSong(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                      BarUiDispatchContext_t context ) 
{ 
  PianoReturn_t pRet ;
  CURLcode wRet ;
  PianoStation_t *realStation ;
  int tmp ;
  PianoRequestDataRateSong_t reqData ;

  {
  realStation = PianoFindStationById((PianoStation_t * const  )app___0->ph.stations,
                                     (char const   * const  )selSong->stationId);
  if ((unsigned long )realStation == (unsigned long )((void *)0)) {
    return;
  }
  tmp = BarTransformIfShared(app___0, realStation);
  if (! tmp) {
    return;
  }
  reqData.song = selSong;
  reqData.rating = (PianoSongRating_t )1;
  BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
           "Loving song... ");
  BarUiPianoCall((BarApp_t * const  )app___0, (PianoRequestType_t const   )4, (void *)(& reqData),
                 & pRet, & wRet);
  BarUiStartEventCmd((BarSettings_t const   *)(& app___0->settings), "songlove", (PianoStation_t const   *)selStation,
                     (PianoSong_t const   *)selSong, & app___0->player, app___0->ph.stations,
                     pRet, wRet);
  return;
}
}
void BarUiActSkipSong(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                      BarUiDispatchContext_t context ) 
{ 


  {
  BarUiDoSkipSong((player_t * const  )(& app___0->player));
  return;
}
}
void BarUiActPlay(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                  BarUiDispatchContext_t context ) 
{ 


  {
  pthread_mutex_lock(& app___0->player.lock);
  app___0->player.doPause = (_Bool)0;
  pthread_cond_broadcast(& app___0->player.cond);
  pthread_mutex_unlock(& app___0->player.lock);
  return;
}
}
void BarUiActPause(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                   BarUiDispatchContext_t context ) 
{ 


  {
  pthread_mutex_lock(& app___0->player.lock);
  app___0->player.doPause = (_Bool)1;
  pthread_cond_broadcast(& app___0->player.cond);
  pthread_mutex_unlock(& app___0->player.lock);
  return;
}
}
void BarUiActTogglePause(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                         BarUiDispatchContext_t context ) 
{ 


  {
  pthread_mutex_lock(& app___0->player.lock);
  app___0->player.doPause = (_Bool )(! app___0->player.doPause);
  pthread_cond_broadcast(& app___0->player.cond);
  pthread_mutex_unlock(& app___0->player.lock);
  return;
}
}
void BarUiActRenameStation(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                           BarUiDispatchContext_t context ) 
{ 
  PianoReturn_t pRet ;
  CURLcode wRet ;
  char lineBuf[100] ;
  PianoRequestDataRenameStation_t reqData ;
  int tmp ;
  size_t tmp___0 ;

  {
  BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )5,
           "New name: ");
  tmp___0 = BarReadlineStr(lineBuf, (size_t const   )sizeof(lineBuf), & app___0->input,
                           (BarReadlineFlags_t const   )0);
  if (tmp___0 > 0UL) {
    tmp = BarTransformIfShared(app___0, selStation);
    if (! tmp) {
      return;
    }
    reqData.station = selStation;
    reqData.newName = lineBuf;
    BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
             "Renaming station... ");
    BarUiPianoCall((BarApp_t * const  )app___0, (PianoRequestType_t const   )7, (void *)(& reqData),
                   & pRet, & wRet);
    BarUiStartEventCmd((BarSettings_t const   *)(& app___0->settings), "stationrename",
                       (PianoStation_t const   *)selStation, (PianoSong_t const   *)selSong,
                       & app___0->player, app___0->ph.stations, pRet, wRet);
  }
  return;
}
}
void BarUiActSelectStation(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                           BarUiDispatchContext_t context ) 
{ 
  PianoStation_t *newStation ;
  PianoStation_t *tmp ;

  {
  tmp = BarUiSelectStation(app___0, app___0->ph.stations, "Select station: ", (void (*)(BarApp_t *app ,
                                                                                        char *buf ))((void *)0),
                           app___0->settings.autoselect);
  newStation = tmp;
  if ((unsigned long )newStation != (unsigned long )((void *)0)) {
    app___0->nextStation = newStation;
    drainPlaylist((BarApp_t * const  )app___0);
  }
  return;
}
}
void BarUiActTempBanSong(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                         BarUiDispatchContext_t context ) 
{ 
  PianoReturn_t pRet ;
  CURLcode wRet ;
  _Bool tmp ;

  {
  BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
           "Putting song on shelf... ");
  tmp = BarUiPianoCall((BarApp_t * const  )app___0, (PianoRequestType_t const   )12,
                       (void *)selSong, & pRet, & wRet);
  if (tmp) {
    if ((unsigned long )selSong == (unsigned long )app___0->playlist) {
      BarUiDoSkipSong((player_t * const  )(& app___0->player));
    }
  }
  BarUiStartEventCmd((BarSettings_t const   *)(& app___0->settings), "songshelf",
                     (PianoStation_t const   *)selStation, (PianoSong_t const   *)selSong,
                     & app___0->player, app___0->ph.stations, pRet, wRet);
  return;
}
}
void BarUiActPrintUpcoming(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                           BarUiDispatchContext_t context ) 
{ 
  PianoSong_t *nextSong ;
  void *tmp ;

  {
  if ((unsigned long )selSong == (unsigned long )((void *)0)) {
    tmp = (void *)0;
  } else {
    tmp = (void *)selSong->head.next;
  }
  nextSong = (PianoSong_t *)tmp;
  if ((unsigned long )nextSong != (unsigned long )((void *)0)) {
    BarUiListSongs((BarApp_t const   * const  )app___0, (PianoSong_t const   *)nextSong,
                   (char const   *)((void *)0));
  } else {
    BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
             "No songs in queue.\n");
  }
  return;
}
}
static void BarUiActQuickmixCallback(BarApp_t *app___0 , char *buf ) 
{ 
  PianoStation_t *curStation ;

  {
  curStation = app___0->ph.stations;
  if ((int )*(buf + 0) == 0) {
    return;
  } else
  if ((int )*(buf + 1) != 0) {
    return;
  }
  switch ((int )*buf) {
  case 116: 
  while ((unsigned long )curStation != (unsigned long )((void *)0)) {
    curStation->useQuickMix = (char )(! curStation->useQuickMix);
    curStation = (PianoStation_t *)((void *)curStation->head.next);
  }
  *buf = (char )'\000';
  break;
  case 97: 
  while ((unsigned long )curStation != (unsigned long )((void *)0)) {
    curStation->useQuickMix = (char)1;
    curStation = (PianoStation_t *)((void *)curStation->head.next);
  }
  *buf = (char )'\000';
  break;
  case 110: 
  while ((unsigned long )curStation != (unsigned long )((void *)0)) {
    curStation->useQuickMix = (char)0;
    curStation = (PianoStation_t *)((void *)curStation->head.next);
  }
  *buf = (char )'\000';
  break;
  }
  return;
}
}
void BarUiActSelectQuickMix(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                            BarUiDispatchContext_t context ) 
{ 
  PianoReturn_t pRet ;
  CURLcode wRet ;
  PianoStation_t *toggleStation ;

  {
  if (selStation->isQuickMix) {
    while (1) {
      toggleStation = BarUiSelectStation(app___0, app___0->ph.stations, "Toggle QuickMix for station: ",
                                         & BarUiActQuickmixCallback, (_Bool)0);
      if (! ((unsigned long )toggleStation != (unsigned long )((void *)0))) {
        break;
      }
      toggleStation->useQuickMix = (char )(! toggleStation->useQuickMix);
    }
    BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
             "Setting QuickMix stations... ");
    BarUiPianoCall((BarApp_t * const  )app___0, (PianoRequestType_t const   )13, (void *)0,
                   & pRet, & wRet);
    BarUiStartEventCmd((BarSettings_t const   *)(& app___0->settings), "stationquickmixtoggle",
                       (PianoStation_t const   *)selStation, (PianoSong_t const   *)selSong,
                       & app___0->player, app___0->ph.stations, pRet, wRet);
  } else {
    BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )4,
             "Please select a QuickMix station first.\n");
  }
  return;
}
}
void BarUiActQuit(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                  BarUiDispatchContext_t context ) 
{ 


  {
  app___0->doQuit = 1;
  BarUiDoSkipSong((player_t * const  )(& app___0->player));
  return;
}
}
void BarUiActHistory(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                     BarUiDispatchContext_t context ) 
{ 
  char buf[2] ;
  PianoSong_t *histSong ;
  BarKeyShortcutId_t action ;
  PianoStation_t *songStation ;
  PianoStation_t *tmp ;
  size_t tmp___0 ;
  char const   *tmp___1 ;

  {
  if ((unsigned long )app___0->songHistory != (unsigned long )((void *)0)) {
    histSong = BarUiSelectSong((BarApp_t const   * const  )app___0, app___0->songHistory,
                               & app___0->input);
    if ((unsigned long )histSong != (unsigned long )((void *)0)) {
      tmp = PianoFindStationById((PianoStation_t * const  )app___0->ph.stations, (char const   * const  )histSong->stationId);
      songStation = tmp;
      if ((unsigned long )songStation == (unsigned long )((void *)0)) {
        BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )4,
                 "Station does not exist any more.\n");
        return;
      }
      while (1) {
        action = (BarKeyShortcutId_t )30;
        BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )5,
                 "What to do with this song? ");
        tmp___0 = BarReadline(buf, (size_t const   )sizeof(buf), (char const   *)((void *)0),
                              & app___0->input, (BarReadlineFlags_t const   )1, -1);
        if (tmp___0 > 0UL) {
          action = BarUiDispatch(app___0, (char const   )buf[0], songStation, histSong,
                                 (_Bool const   )0, (BarUiDispatchContext_t )0);
        }
        if (! ((unsigned int )action == 0U)) {
          break;
        }
      }
    }
  } else {
    if (app___0->settings.history == 0U) {
      tmp___1 = "History disabled.\n";
    } else {
      tmp___1 = "No history yet.\n";
    }
    BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
             tmp___1);
  }
  return;
}
}
void BarUiActBookmark(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                      BarUiDispatchContext_t context ) 
{ 
  PianoReturn_t pRet ;
  CURLcode wRet ;
  char selectBuf[2] ;

  {
  BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )5,
           "Bookmark [s]ong or [a]rtist? ");
  BarReadline(selectBuf, (size_t const   )sizeof(selectBuf), "sa", & app___0->input,
              (BarReadlineFlags_t const   )1, -1);
  if ((int )selectBuf[0] == 115) {
    BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
             "Bookmarking song... ");
    BarUiPianoCall((BarApp_t * const  )app___0, (PianoRequestType_t const   )18, (void *)selSong,
                   & pRet, & wRet);
    BarUiStartEventCmd((BarSettings_t const   *)(& app___0->settings), "songbookmark",
                       (PianoStation_t const   *)selStation, (PianoSong_t const   *)selSong,
                       & app___0->player, app___0->ph.stations, pRet, wRet);
  } else
  if ((int )selectBuf[0] == 97) {
    BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
             "Bookmarking artist... ");
    BarUiPianoCall((BarApp_t * const  )app___0, (PianoRequestType_t const   )19, (void *)selSong,
                   & pRet, & wRet);
    BarUiStartEventCmd((BarSettings_t const   *)(& app___0->settings), "artistbookmark",
                       (PianoStation_t const   *)selStation, (PianoSong_t const   *)selSong,
                       & app___0->player, app___0->ph.stations, pRet, wRet);
  }
  return;
}
}
void BarUiActVolDown(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                     BarUiDispatchContext_t context ) 
{ 


  {
  (app___0->settings.volume) --;
  BarPlayerSetVolume((player_t * const  )(& app___0->player));
  return;
}
}
void BarUiActVolUp(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                   BarUiDispatchContext_t context ) 
{ 


  {
  (app___0->settings.volume) ++;
  BarPlayerSetVolume((player_t * const  )(& app___0->player));
  return;
}
}
void BarUiActVolReset(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                      BarUiDispatchContext_t context ) 
{ 


  {
  app___0->settings.volume = 0;
  BarPlayerSetVolume((player_t * const  )(& app___0->player));
  return;
}
}
static char const   *boolToYesNo(_Bool const   value ) 
{ 
  char const   *tmp ;

  {
  if (value) {
    tmp = "yes";
  } else {
    tmp = "no";
  }
  return (tmp);
}
}
void BarUiActSettings(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                      BarUiDispatchContext_t context ) 
{ 
  PianoReturn_t pRet ;
  CURLcode wRet ;
  PianoSettings_t settings ;
  PianoRequestDataChangeSettings_t reqData ;
  _Bool modified ;
  _Bool bret ;
  _Bool tmp ;
  char const   *tmp___0 ;
  int val ;
  size_t tmp___1 ;
  char buf[80] ;
  size_t tmp___2 ;
  char buf___0[80] ;
  size_t tmp___3 ;
  _Bool tmp___5 ;

  {
  modified = (_Bool)0;
  memset((void *)(& settings), 0, sizeof(settings));
  memset((void *)(& reqData), 0, sizeof(reqData));
  BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
           "Retrieving settings... ");
  tmp = BarUiPianoCall((BarApp_t * const  )app___0, (PianoRequestType_t const   )23,
                       (void *)(& settings), & pRet, & wRet);
  bret = tmp;
  BarUiStartEventCmd((BarSettings_t const   *)(& app___0->settings), "settingsget",
                     (PianoStation_t const   *)selStation, (PianoSong_t const   *)selSong,
                     & app___0->player, app___0->ph.stations, pRet, wRet);
  if (! bret) {
    return;
  }
  BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )6,
           " 0) Username (%s)\n", settings.username);
  BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )6,
           " 1) Password (*****)\n");
  tmp___0 = boolToYesNo((_Bool const   )settings.explicitContentFilter);
  BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )6,
           " 2) Explicit content filter (%s)\n", tmp___0);
  while (1) {
    BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )5,
             "Change setting: ");
    tmp___1 = BarReadlineInt(& val, & app___0->input);
    if (tmp___1 == 0UL) {
      break;
    }
    switch (val) {
    case 0: 
    BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )5,
             "New username: ");
    tmp___2 = BarReadlineStr(buf, (size_t const   )sizeof(buf), & app___0->input,
                             (BarReadlineFlags_t const   )0);
    if (tmp___2 > 0UL) {
      reqData.newUsername = strdup((char const   *)(buf));
      modified = (_Bool)1;
    }
    break;
    case 1: 
    BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )5,
             "New password: ");
    tmp___3 = BarReadlineStr(buf___0, (size_t const   )sizeof(buf___0), & app___0->input,
                             (BarReadlineFlags_t const   )2);
    if (tmp___3 > 0UL) {
      reqData.newPassword = strdup((char const   *)(buf___0));
      modified = (_Bool)1;
    }
    puts("");
    break;
    case 2: 
    BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )5,
             "Enable explicit content filter? [yn] ");
    tmp___5 = BarReadlineYesNo(settings.explicitContentFilter, & app___0->input);
    if (tmp___5) {
      reqData.explicitContentFilter = (PianoTristate_t )2;
    } else {
      reqData.explicitContentFilter = (PianoTristate_t )1;
    }
    modified = (_Bool)1;
    break;
    default: 
    break;
    }
  }
  if (modified) {
    reqData.currentUsername = app___0->settings.username;
    reqData.currentPassword = app___0->settings.password;
    BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
             "Changing settings... ");
    BarUiPianoCall((BarApp_t * const  )app___0, (PianoRequestType_t const   )24, (void *)(& reqData),
                   & pRet, & wRet);
    BarUiStartEventCmd((BarSettings_t const   *)(& app___0->settings), "settingschange",
                       (PianoStation_t const   *)selStation, (PianoSong_t const   *)selSong,
                       & app___0->player, app___0->ph.stations, pRet, wRet);
    if ((unsigned long )reqData.newUsername != (unsigned long )((void *)0)) {
      free((void *)app___0->settings.username);
      app___0->settings.username = reqData.newUsername;
    }
    if ((unsigned long )reqData.newPassword != (unsigned long )((void *)0)) {
      free((void *)app___0->settings.password);
      app___0->settings.password = reqData.newPassword;
    }
  }
  return;
}
}
void BarUiActManageStation(BarApp_t *app___0 , PianoStation_t *selStation , PianoSong_t *selSong ,
                           BarUiDispatchContext_t context ) 
{ 
  PianoReturn_t pRet ;
  CURLcode wRet ;
  PianoRequestDataGetStationInfo_t reqData ;
  char selectBuf[2] ;
  char allowedActions[6] ;
  char *allowedPos ;
  char question[128] ;
  _Bool bret ;
  _Bool tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  PianoArtist_t *artist ;
  PianoArtist_t *tmp___5 ;
  PianoRequestDataDeleteSeed_t subReqData ;
  PianoSong_t *song ;
  PianoSong_t *tmp___6 ;
  PianoRequestDataDeleteSeed_t subReqData___0 ;
  PianoStation_t *station ;
  PianoStation_t *tmp___7 ;
  PianoRequestDataDeleteSeed_t subReqData___1 ;
  PianoSong_t *song___0 ;
  PianoSong_t *tmp___8 ;
  PianoRequestDataGetStationModes_t subReqData___2 ;
  PianoStationMode_t const   *curMode ;
  unsigned int i ;
  char const   *tmp___9 ;
  int selected ;
  size_t tmp___10 ;
  PianoStationMode_t const   *selMode ;
  void *tmp___11 ;
  PianoRequestDataSetStationMode_t subReqDataSet ;
  _Bool tmp___12 ;
  size_t tmp___13 ;

  {
  allowedPos = allowedActions;
  memset((void *)(& reqData), 0, sizeof(reqData));
  reqData.station = selStation;
  BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
           "Fetching station info... ");
  tmp = BarUiPianoCall((BarApp_t * const  )app___0, (PianoRequestType_t const   )20,
                       (void *)(& reqData), & pRet, & wRet);
  bret = tmp;
  BarUiStartEventCmd((BarSettings_t const   *)(& app___0->settings), "stationfetchinfo",
                     (PianoStation_t const   *)selStation, (PianoSong_t const   *)selSong,
                     & app___0->player, app___0->ph.stations, pRet, wRet);
  if (! bret) {
    return;
  }
  if ((unsigned long )reqData.info.artistSeeds != (unsigned long )((void *)0)) {
    strcpy((char * __restrict  )(question), (char const   * __restrict  )"Delete ");
  } else
  if ((unsigned long )reqData.info.songSeeds != (unsigned long )((void *)0)) {
    strcpy((char * __restrict  )(question), (char const   * __restrict  )"Delete ");
  } else
  if ((unsigned long )reqData.info.stationSeeds != (unsigned long )((void *)0)) {
    strcpy((char * __restrict  )(question), (char const   * __restrict  )"Delete ");
  } else
  if ((unsigned long )reqData.info.feedback != (unsigned long )((void *)0)) {
    strcpy((char * __restrict  )(question), (char const   * __restrict  )"Delete ");
  }
  if ((unsigned long )reqData.info.artistSeeds != (unsigned long )((void *)0)) {
    strcat((char * __restrict  )(question), (char const   * __restrict  )"[a]rtist");
    tmp___0 = allowedPos;
    allowedPos ++;
    *tmp___0 = (char )'a';
  }
  if ((unsigned long )reqData.info.songSeeds != (unsigned long )((void *)0)) {
    if ((unsigned long )allowedPos != (unsigned long )(allowedActions)) {
      strcat((char * __restrict  )(question), (char const   * __restrict  )"/");
    }
    strcat((char * __restrict  )(question), (char const   * __restrict  )"[s]ong");
    tmp___1 = allowedPos;
    allowedPos ++;
    *tmp___1 = (char )'s';
  }
  if ((unsigned long )reqData.info.stationSeeds != (unsigned long )((void *)0)) {
    if ((unsigned long )allowedPos != (unsigned long )(allowedActions)) {
      strcat((char * __restrict  )(question), (char const   * __restrict  )"/");
    }
    strcat((char * __restrict  )(question), (char const   * __restrict  )"s[t]ation");
    tmp___2 = allowedPos;
    allowedPos ++;
    *tmp___2 = (char )'t';
  }
  if ((unsigned long )allowedPos != (unsigned long )(allowedActions)) {
    strcat((char * __restrict  )(question), (char const   * __restrict  )" seeds");
  }
  if ((unsigned long )reqData.info.feedback != (unsigned long )((void *)0)) {
    if ((unsigned long )allowedPos != (unsigned long )(allowedActions)) {
      strcat((char * __restrict  )(question), (char const   * __restrict  )" or ");
    }
    strcat((char * __restrict  )(question), (char const   * __restrict  )"[f]eedback");
    tmp___3 = allowedPos;
    allowedPos ++;
    *tmp___3 = (char )'f';
  }
  if ((unsigned long )allowedPos != (unsigned long )(allowedActions)) {
    strcat((char * __restrict  )(question), (char const   * __restrict  )"? ");
  }
  if (! selStation->isQuickMix) {
    strcat((char * __restrict  )(question), (char const   * __restrict  )"Manage [m]ode? ");
    tmp___4 = allowedPos;
    allowedPos ++;
    *tmp___4 = (char )'m';
  }
  *allowedPos = (char )'\000';
  if ((unsigned long )allowedPos == (unsigned long )(allowedActions)) {
    BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
             "No actions available.\n");
    return;
  }
  BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )5,
           "%s", question);
  tmp___13 = BarReadline(selectBuf, (size_t const   )sizeof(selectBuf), (char const   *)(allowedActions),
                         & app___0->input, (BarReadlineFlags_t const   )1, -1);
  if (tmp___13) {
    if ((int )selectBuf[0] == 97) {
      tmp___5 = BarUiSelectArtist(app___0, reqData.info.artistSeeds);
      artist = tmp___5;
      if ((unsigned long )artist != (unsigned long )((void *)0)) {
        memset((void *)(& subReqData), 0, sizeof(subReqData));
        subReqData.artist = artist;
        BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
                 "Deleting artist seed... ");
        BarUiPianoCall((BarApp_t * const  )app___0, (PianoRequestType_t const   )22,
                       (void *)(& subReqData), & pRet, & wRet);
        BarUiStartEventCmd((BarSettings_t const   *)(& app___0->settings), "stationdeleteartistseed",
                           (PianoStation_t const   *)selStation, (PianoSong_t const   *)selSong,
                           & app___0->player, app___0->ph.stations, pRet, wRet);
      }
    } else
    if ((int )selectBuf[0] == 115) {
      tmp___6 = BarUiSelectSong((BarApp_t const   * const  )app___0, reqData.info.songSeeds,
                                & app___0->input);
      song = tmp___6;
      if ((unsigned long )song != (unsigned long )((void *)0)) {
        memset((void *)(& subReqData___0), 0, sizeof(subReqData___0));
        subReqData___0.song = song;
        BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
                 "Deleting song seed... ");
        BarUiPianoCall((BarApp_t * const  )app___0, (PianoRequestType_t const   )22,
                       (void *)(& subReqData___0), & pRet, & wRet);
        BarUiStartEventCmd((BarSettings_t const   *)(& app___0->settings), "stationdeletesongseed",
                           (PianoStation_t const   *)selStation, (PianoSong_t const   *)selSong,
                           & app___0->player, app___0->ph.stations, pRet, wRet);
      }
    } else
    if ((int )selectBuf[0] == 116) {
      tmp___7 = BarUiSelectStation(app___0, reqData.info.stationSeeds, "Delete seed station: ",
                                   (void (*)(BarApp_t *app , char *buf ))((void *)0),
                                   (_Bool)0);
      station = tmp___7;
      if ((unsigned long )station != (unsigned long )((void *)0)) {
        memset((void *)(& subReqData___1), 0, sizeof(subReqData___1));
        subReqData___1.station = station;
        BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
                 "Deleting station seed... ");
        BarUiPianoCall((BarApp_t * const  )app___0, (PianoRequestType_t const   )22,
                       (void *)(& subReqData___1), & pRet, & wRet);
        BarUiStartEventCmd((BarSettings_t const   *)(& app___0->settings), "stationdeletestationseed",
                           (PianoStation_t const   *)selStation, (PianoSong_t const   *)selSong,
                           & app___0->player, app___0->ph.stations, pRet, wRet);
      }
    } else
    if ((int )selectBuf[0] == 102) {
      tmp___8 = BarUiSelectSong((BarApp_t const   * const  )app___0, reqData.info.feedback,
                                & app___0->input);
      song___0 = tmp___8;
      if ((unsigned long )song___0 != (unsigned long )((void *)0)) {
        BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
                 "Deleting feedback... ");
        BarUiPianoCall((BarApp_t * const  )app___0, (PianoRequestType_t const   )21,
                       (void *)song___0, & pRet, & wRet);
        BarUiStartEventCmd((BarSettings_t const   *)(& app___0->settings), "stationdeletefeedback",
                           (PianoStation_t const   *)selStation, (PianoSong_t const   *)selSong,
                           & app___0->player, app___0->ph.stations, pRet, wRet);
      }
    } else
    if ((int )selectBuf[0] == 109) {
      subReqData___2.station = selStation;
      subReqData___2.retModes = (PianoStationMode_t *)0;
      BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
               "Fetching modes... ");
      BarUiPianoCall((BarApp_t * const  )app___0, (PianoRequestType_t const   )25,
                     (void *)(& subReqData___2), & pRet, & wRet);
      BarUiStartEventCmd((BarSettings_t const   *)(& app___0->settings), "stationgetmodes",
                         (PianoStation_t const   *)selStation, (PianoSong_t const   *)selSong,
                         & app___0->player, app___0->ph.stations, pRet, wRet);
      curMode = (PianoStationMode_t const   *)subReqData___2.retModes;
      i = 0U;
      while ((unsigned long )curMode != (unsigned long )((void *)0)) {
        if (curMode->active) {
          tmp___9 = " (active)";
        } else {
          tmp___9 = "";
        }
        BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )6,
                 "%2i) %s: %s%s\n", i, curMode->name, curMode->description, tmp___9);
        i ++;
        curMode = (PianoStationMode_t const   *)((void *)curMode->head.next);
      }
      BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )5,
               "Pick a new mode: ");
      while (1) {
        tmp___10 = BarReadlineInt(& selected, & app___0->input);
        if (tmp___10 == 0UL) {
          break;
        }
        tmp___11 = PianoListGet((PianoListHead_t * const  )(& (subReqData___2.retModes)->head),
                                (size_t const   )selected);
        selMode = (PianoStationMode_t const   *)tmp___11;
        if ((unsigned long )selMode != (unsigned long )((void *)0)) {
          subReqDataSet.station = selStation;
          subReqDataSet.id = (unsigned int )selected;
          BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
                   "Selecting mode \"%s\"... ", selMode->name);
          tmp___12 = BarUiPianoCall((BarApp_t * const  )app___0, (PianoRequestType_t const   )26,
                                    (void *)(& subReqDataSet), & pRet, & wRet);
          if (tmp___12) {
            drainPlaylist((BarApp_t * const  )app___0);
          }
          BarUiStartEventCmd((BarSettings_t const   *)(& app___0->settings), "stationsetmode",
                             (PianoStation_t const   *)selStation, (PianoSong_t const   *)selSong,
                             & app___0->player, app___0->ph.stations, pRet, wRet);
          break;
        }
      }
      PianoDestroyStationMode((PianoStationMode_t * const  )subReqData___2.retModes);
    }
  }
  PianoDestroyStationInfo(& reqData.info);
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#pragma merger("0","/tmp/cil-FH04i5ji.i","-O2")
extern int fflush(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) strtoul)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
size_t PianoListCount(PianoListHead_t const   * const  l ) ;
void *( __attribute__((__warn_unused_result__)) PianoListDelete)(PianoListHead_t * const  l ,
                                                                 PianoListHead_t * const  e ) ;
void *( __attribute__((__warn_unused_result__)) PianoListPrepend)(PianoListHead_t * const  l ,
                                                                  PianoListHead_t * const  e ) ;
void PianoDestroySearchResult(PianoSearchResult_t *searchResult ) ;
PianoReturn_t PianoRequest(PianoHandle_t *ph , PianoRequest_t *req , PianoRequestType_t type ) ;
PianoReturn_t PianoResponse(PianoHandle_t *ph , PianoRequest_t *req ) ;
void PianoDestroyRequest(PianoRequest_t *req ) ;
extern struct curl_slist *curl_slist_append(struct curl_slist * , char const   * ) ;
extern void curl_slist_free_all(struct curl_slist * ) ;
extern char const   *curl_easy_strerror(CURLcode  ) ;
extern CURLcode curl_easy_setopt(CURL *curl , CURLoption option  , ...) ;
extern CURLcode curl_easy_perform(CURL *curl ) ;
extern void curl_easy_reset(CURL *curl ) ;
static _Bool isnumeric(char const   *s ) 
{ 
  unsigned short const   **tmp ;

  {
  if ((int const   )*s == 0) {
    return ((_Bool)0);
  }
  while ((int const   )*s != 0) {
    tmp = __ctype_b_loc();
    if (! ((int const   )*(*tmp + (int )((unsigned char )*s)) & 2048)) {
      return ((_Bool)0);
    }
    s ++;
  }
  return ((_Bool)1);
}
}
static char const   *BarStrCaseStr(char const   *haystack , char const   *needle ) 
{ 
  char const   *needlePos ;
  int __res ;
  __int32_t const   **tmp___0 ;
  int __res___0 ;
  __int32_t const   **tmp___2 ;
  size_t tmp___3 ;

  {
  needlePos = needle;
  if ((int const   )*needle == 0) {
    return (haystack);
  }
  while ((int const   )*haystack != 0) {
    if (sizeof((unsigned char )*haystack) > 1UL) {
      __res = tolower((int )((unsigned char )*haystack));
    } else {
      tmp___0 = __ctype_tolower_loc();
      __res = (int )*(*tmp___0 + (int )((unsigned char )*haystack));
    }
    if (sizeof((unsigned char )*needlePos) > 1UL) {
      __res___0 = tolower((int )((unsigned char )*needlePos));
    } else {
      tmp___2 = __ctype_tolower_loc();
      __res___0 = (int )*(*tmp___2 + (int )((unsigned char )*needlePos));
    }
    if (__res == __res___0) {
      needlePos ++;
    } else {
      needlePos = needle;
    }
    haystack ++;
    if ((int const   )*needlePos == 0) {
      tmp___3 = strlen(needle);
      return (haystack - tmp___3);
    }
  }
  return ((char const   *)((void *)0));
}
}
void ( /* format attribute */  BarUiMsg)(BarSettings_t const   *settings , BarUiMsg_t const   type ,
                                         char const   *format  , ...) 
{ 
  va_list___0 fmtargs ;

  {
  switch ((unsigned int const   )type) {
  case 6U: 
  case 5U: 
  case 4U: 
  case 3U: 
  case 2U: 
  case 1U: 
  fputs((char const   * __restrict  )"\033[2K", (FILE * __restrict  )stdout);
  break;
  default: 
  break;
  }
  if ((unsigned long )settings->msgFormat[type].prefix != (unsigned long )((void *)0)) {
    fputs((char const   * __restrict  )settings->msgFormat[type].prefix, (FILE * __restrict  )stdout);
  }
  __builtin_va_start(fmtargs, format);
  vprintf((char const   * __restrict  )format, fmtargs);
  __builtin_va_end(fmtargs);
  if ((unsigned long )settings->msgFormat[type].postfix != (unsigned long )((void *)0)) {
    fputs((char const   * __restrict  )settings->msgFormat[type].postfix, (FILE * __restrict  )stdout);
  }
  fflush(stdout);
  return;
}
}
static size_t httpFetchCb(char *ptr , size_t size , size_t nmemb , void *userdata ) 
{ 
  buffer *buffer___0 ;
  size_t recvSize ;
  char *tmp ;
  void *tmp___0 ;
  char *newbuf ;
  void *tmp___1 ;

  {
  buffer___0 = (buffer *)userdata;
  recvSize = size * nmemb;
  if ((unsigned long )buffer___0->data == (unsigned long )((void *)0)) {
    tmp___0 = malloc(sizeof(*(buffer___0->data)) * (recvSize + 1UL));
    tmp = (char *)tmp___0;
    buffer___0->data = tmp;
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      return ((size_t )0);
    }
  } else {
    tmp___1 = realloc((void *)buffer___0->data, sizeof(*(buffer___0->data)) * ((buffer___0->pos + recvSize) + 1UL));
    newbuf = (char *)tmp___1;
    if ((unsigned long )newbuf == (unsigned long )((void *)0)) {
      free((void *)buffer___0->data);
      return ((size_t )0);
    }
    buffer___0->data = newbuf;
  }
  memcpy((void * __restrict  )(buffer___0->data + buffer___0->pos), (void const   * __restrict  )ptr,
         recvSize);
  buffer___0->pos += recvSize;
  *(buffer___0->data + buffer___0->pos) = (char )'\000';
  return (recvSize);
}
}
int progressCb(void * const  data , double dltotal , double dlnow , double ultotal ,
               double ulnow ) 
{ 
  sig_atomic_t lint ;

  {
  lint = *((sig_atomic_t *)data);
  if (lint) {
    return (1);
  } else {
    return (0);
  }
}
}
static _Bool temporaryCurlError(CURLcode const   code ) 
{ 


  {
  switch ((unsigned int const   )code) {
  case 56U: 
  case 55U: 
  case 52U: 
  case 35U: 
  case 28U: 
  case 26U: 
  case 8U: 
  case 7U: 
  case 6U: 
  case 5U: 
  return ((_Bool)1);
  default: 
  return ((_Bool)0);
  }
}
}
static CURLcode BarPianoHttpRequest(CURL * const  http , BarSettings_t const   * const  settings ,
                                    PianoRequest_t * const  req ) 
{ 
  buffer buffer___0 ;
  sig_atomic_t lint ;
  sig_atomic_t *prevint ;
  char url[2048] ;
  int ret ;
  char const   *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  CURLcode httpret ;
  CURLcode tmp___2 ;
  CURLcode tmp___3 ;
  CURLcode tmp___4 ;
  size_t tmp___5 ;
  struct curl_slist *list ;
  unsigned int retry ;
  _Bool tmp___6 ;

  {
  buffer___0.data = (char *)((void *)0);
  buffer___0.pos = (size_t )0;
  lint = 0;
  if (req->secure) {
    tmp = (char const   * const  )settings->rpcTlsPort;
  } else {
    tmp = (char const   * const  )"80";
  }
  if (req->secure) {
    tmp___0 = "https";
  } else {
    tmp___0 = "http";
  }
  tmp___1 = snprintf((char * __restrict  )(url), sizeof(url), (char const   * __restrict  )"%s://%s:%s%s",
                     tmp___0, settings->rpcHost, tmp, req->urlPath);
  ret = tmp___1;
  prevint = interrupted;
  interrupted = & lint;
  curl_easy_reset((CURL *)http);
  httpret = curl_easy_setopt((CURL *)http, (CURLoption )10002, url);
  httpret = curl_easy_setopt((CURL *)http, (CURLoption )10018, "pianobar-2022.04.01-dev");
  httpret = curl_easy_setopt((CURL *)http, (CURLoption )10015, req->postData);
  httpret = curl_easy_setopt((CURL *)http, (CURLoption )20011, & httpFetchCb);
  httpret = curl_easy_setopt((CURL *)http, (CURLoption )10001, & buffer___0);
  httpret = curl_easy_setopt((CURL *)http, (CURLoption )20056, & progressCb);
  httpret = curl_easy_setopt((CURL *)http, (CURLoption )10057, & lint);
  httpret = curl_easy_setopt((CURL *)http, (CURLoption )43, 0);
  httpret = curl_easy_setopt((CURL *)http, (CURLoption )47, 1);
  httpret = curl_easy_setopt((CURL *)http, (CURLoption )13, settings->timeout);
  if ((unsigned long )settings->caBundle != (unsigned long )((void *)0)) {
    httpret = curl_easy_setopt((CURL *)http, (CURLoption )10065, settings->caBundle);
  }
  if ((unsigned long )settings->bindTo != (unsigned long )((void *)0)) {
    tmp___2 = curl_easy_setopt((CURL *)http, (CURLoption )10062, settings->bindTo);
    if ((unsigned int )tmp___2 != 0U) {
      BarUiMsg((BarSettings_t const   *)settings, (BarUiMsg_t const   )4, "bindTo (%s) is invalid!\n",
               settings->bindTo);
    }
  }
  if ((unsigned long )settings->controlProxy != (unsigned long )((void *)0)) {
    tmp___3 = curl_easy_setopt((CURL *)http, (CURLoption )10004, settings->controlProxy);
    if ((unsigned int )tmp___3 != 0U) {
      BarUiMsg((BarSettings_t const   *)settings, (BarUiMsg_t const   )4, "Control proxy (%s) is invalid!\n",
               settings->controlProxy);
    }
  } else
  if ((unsigned long )settings->proxy != (unsigned long )((void *)0)) {
    tmp___5 = strlen((char const   *)settings->proxy);
    if (tmp___5 > 0UL) {
      tmp___4 = curl_easy_setopt((CURL *)http, (CURLoption )10004, settings->proxy);
      if ((unsigned int )tmp___4 != 0U) {
        BarUiMsg((BarSettings_t const   *)settings, (BarUiMsg_t const   )4, "Proxy (%s) is invalid!\n",
                 settings->proxy);
      }
    }
  }
  list = (struct curl_slist *)((void *)0);
  list = curl_slist_append(list, "Content-Type: text/plain");
  httpret = curl_easy_setopt((CURL *)http, (CURLoption )10023, list);
  retry = 0U;
  while (1) {
    httpret = curl_easy_perform((CURL *)http);
    retry ++;
    tmp___6 = temporaryCurlError((CURLcode const   )httpret);
    if (tmp___6) {
      free((void *)buffer___0.data);
      buffer___0.data = (char *)((void *)0);
      buffer___0.pos = (size_t )0;
      if (retry >= (unsigned int )settings->maxRetry) {
        break;
      }
    } else {
      break;
    }
  }
  curl_slist_free_all(list);
  req->responseData = buffer___0.data;
  interrupted = prevint;
  return (httpret);
}
}
_Bool BarUiPianoCall(BarApp_t * const  app___0 , PianoRequestType_t const   type ,
                     void * const  data , PianoReturn_t * const  pRet , CURLcode * const  wRet ) 
{ 
  PianoReturn_t pRetLocal ;
  CURLcode wRetLocal ;
  _Bool ret ;
  PianoRequest_t req ;
  char const   *tmp ;
  char const   *tmp___0 ;
  PianoRequestDataLogin_t reqData ;
  _Bool tmp___1 ;
  char const   *tmp___2 ;

  {
  pRetLocal = (PianoReturn_t )1;
  wRetLocal = (CURLcode )0;
  ret = (_Bool)0;
  while (1) {
    req.type = 0U;
    req.secure = (_Bool)0;
    req.data = (void *)data;
    req.urlPath[0] = (char)0;
    req.urlPath[1] = (char)0;
    req.urlPath[2] = (char)0;
    req.urlPath[3] = (char)0;
    req.urlPath[4] = (char)0;
    req.urlPath[5] = (char)0;
    req.urlPath[6] = (char)0;
    req.urlPath[7] = (char)0;
    req.urlPath[8] = (char)0;
    req.urlPath[9] = (char)0;
    req.urlPath[10] = (char)0;
    req.urlPath[11] = (char)0;
    req.urlPath[12] = (char)0;
    req.urlPath[13] = (char)0;
    req.urlPath[14] = (char)0;
    req.urlPath[15] = (char)0;
    req.urlPath[16] = (char)0;
    req.urlPath[17] = (char)0;
    req.urlPath[18] = (char)0;
    req.urlPath[19] = (char)0;
    req.urlPath[20] = (char)0;
    req.urlPath[21] = (char)0;
    req.urlPath[22] = (char)0;
    req.urlPath[23] = (char)0;
    req.urlPath[24] = (char)0;
    req.urlPath[25] = (char)0;
    req.urlPath[26] = (char)0;
    req.urlPath[27] = (char)0;
    req.urlPath[28] = (char)0;
    req.urlPath[29] = (char)0;
    req.urlPath[30] = (char)0;
    req.urlPath[31] = (char)0;
    req.urlPath[32] = (char)0;
    req.urlPath[33] = (char)0;
    req.urlPath[34] = (char)0;
    req.urlPath[35] = (char)0;
    req.urlPath[36] = (char)0;
    req.urlPath[37] = (char)0;
    req.urlPath[38] = (char)0;
    req.urlPath[39] = (char)0;
    req.urlPath[40] = (char)0;
    req.urlPath[41] = (char)0;
    req.urlPath[42] = (char)0;
    req.urlPath[43] = (char)0;
    req.urlPath[44] = (char)0;
    req.urlPath[45] = (char)0;
    req.urlPath[46] = (char)0;
    req.urlPath[47] = (char)0;
    req.urlPath[48] = (char)0;
    req.urlPath[49] = (char)0;
    req.urlPath[50] = (char)0;
    req.urlPath[51] = (char)0;
    req.urlPath[52] = (char)0;
    req.urlPath[53] = (char)0;
    req.urlPath[54] = (char)0;
    req.urlPath[55] = (char)0;
    req.urlPath[56] = (char)0;
    req.urlPath[57] = (char)0;
    req.urlPath[58] = (char)0;
    req.urlPath[59] = (char)0;
    req.urlPath[60] = (char)0;
    req.urlPath[61] = (char)0;
    req.urlPath[62] = (char)0;
    req.urlPath[63] = (char)0;
    req.urlPath[64] = (char)0;
    req.urlPath[65] = (char)0;
    req.urlPath[66] = (char)0;
    req.urlPath[67] = (char)0;
    req.urlPath[68] = (char)0;
    req.urlPath[69] = (char)0;
    req.urlPath[70] = (char)0;
    req.urlPath[71] = (char)0;
    req.urlPath[72] = (char)0;
    req.urlPath[73] = (char)0;
    req.urlPath[74] = (char)0;
    req.urlPath[75] = (char)0;
    req.urlPath[76] = (char)0;
    req.urlPath[77] = (char)0;
    req.urlPath[78] = (char)0;
    req.urlPath[79] = (char)0;
    req.urlPath[80] = (char)0;
    req.urlPath[81] = (char)0;
    req.urlPath[82] = (char)0;
    req.urlPath[83] = (char)0;
    req.urlPath[84] = (char)0;
    req.urlPath[85] = (char)0;
    req.urlPath[86] = (char)0;
    req.urlPath[87] = (char)0;
    req.urlPath[88] = (char)0;
    req.urlPath[89] = (char)0;
    req.urlPath[90] = (char)0;
    req.urlPath[91] = (char)0;
    req.urlPath[92] = (char)0;
    req.urlPath[93] = (char)0;
    req.urlPath[94] = (char)0;
    req.urlPath[95] = (char)0;
    req.urlPath[96] = (char)0;
    req.urlPath[97] = (char)0;
    req.urlPath[98] = (char)0;
    req.urlPath[99] = (char)0;
    req.urlPath[100] = (char)0;
    req.urlPath[101] = (char)0;
    req.urlPath[102] = (char)0;
    req.urlPath[103] = (char)0;
    req.urlPath[104] = (char)0;
    req.urlPath[105] = (char)0;
    req.urlPath[106] = (char)0;
    req.urlPath[107] = (char)0;
    req.urlPath[108] = (char)0;
    req.urlPath[109] = (char)0;
    req.urlPath[110] = (char)0;
    req.urlPath[111] = (char)0;
    req.urlPath[112] = (char)0;
    req.urlPath[113] = (char)0;
    req.urlPath[114] = (char)0;
    req.urlPath[115] = (char)0;
    req.urlPath[116] = (char)0;
    req.urlPath[117] = (char)0;
    req.urlPath[118] = (char)0;
    req.urlPath[119] = (char)0;
    req.urlPath[120] = (char)0;
    req.urlPath[121] = (char)0;
    req.urlPath[122] = (char)0;
    req.urlPath[123] = (char)0;
    req.urlPath[124] = (char)0;
    req.urlPath[125] = (char)0;
    req.urlPath[126] = (char)0;
    req.urlPath[127] = (char)0;
    req.urlPath[128] = (char)0;
    req.urlPath[129] = (char)0;
    req.urlPath[130] = (char)0;
    req.urlPath[131] = (char)0;
    req.urlPath[132] = (char)0;
    req.urlPath[133] = (char)0;
    req.urlPath[134] = (char)0;
    req.urlPath[135] = (char)0;
    req.urlPath[136] = (char)0;
    req.urlPath[137] = (char)0;
    req.urlPath[138] = (char)0;
    req.urlPath[139] = (char)0;
    req.urlPath[140] = (char)0;
    req.urlPath[141] = (char)0;
    req.urlPath[142] = (char)0;
    req.urlPath[143] = (char)0;
    req.urlPath[144] = (char)0;
    req.urlPath[145] = (char)0;
    req.urlPath[146] = (char)0;
    req.urlPath[147] = (char)0;
    req.urlPath[148] = (char)0;
    req.urlPath[149] = (char)0;
    req.urlPath[150] = (char)0;
    req.urlPath[151] = (char)0;
    req.urlPath[152] = (char)0;
    req.urlPath[153] = (char)0;
    req.urlPath[154] = (char)0;
    req.urlPath[155] = (char)0;
    req.urlPath[156] = (char)0;
    req.urlPath[157] = (char)0;
    req.urlPath[158] = (char)0;
    req.urlPath[159] = (char)0;
    req.urlPath[160] = (char)0;
    req.urlPath[161] = (char)0;
    req.urlPath[162] = (char)0;
    req.urlPath[163] = (char)0;
    req.urlPath[164] = (char)0;
    req.urlPath[165] = (char)0;
    req.urlPath[166] = (char)0;
    req.urlPath[167] = (char)0;
    req.urlPath[168] = (char)0;
    req.urlPath[169] = (char)0;
    req.urlPath[170] = (char)0;
    req.urlPath[171] = (char)0;
    req.urlPath[172] = (char)0;
    req.urlPath[173] = (char)0;
    req.urlPath[174] = (char)0;
    req.urlPath[175] = (char)0;
    req.urlPath[176] = (char)0;
    req.urlPath[177] = (char)0;
    req.urlPath[178] = (char)0;
    req.urlPath[179] = (char)0;
    req.urlPath[180] = (char)0;
    req.urlPath[181] = (char)0;
    req.urlPath[182] = (char)0;
    req.urlPath[183] = (char)0;
    req.urlPath[184] = (char)0;
    req.urlPath[185] = (char)0;
    req.urlPath[186] = (char)0;
    req.urlPath[187] = (char)0;
    req.urlPath[188] = (char)0;
    req.urlPath[189] = (char)0;
    req.urlPath[190] = (char)0;
    req.urlPath[191] = (char)0;
    req.urlPath[192] = (char)0;
    req.urlPath[193] = (char)0;
    req.urlPath[194] = (char)0;
    req.urlPath[195] = (char)0;
    req.urlPath[196] = (char)0;
    req.urlPath[197] = (char)0;
    req.urlPath[198] = (char)0;
    req.urlPath[199] = (char)0;
    req.urlPath[200] = (char)0;
    req.urlPath[201] = (char)0;
    req.urlPath[202] = (char)0;
    req.urlPath[203] = (char)0;
    req.urlPath[204] = (char)0;
    req.urlPath[205] = (char)0;
    req.urlPath[206] = (char)0;
    req.urlPath[207] = (char)0;
    req.urlPath[208] = (char)0;
    req.urlPath[209] = (char)0;
    req.urlPath[210] = (char)0;
    req.urlPath[211] = (char)0;
    req.urlPath[212] = (char)0;
    req.urlPath[213] = (char)0;
    req.urlPath[214] = (char)0;
    req.urlPath[215] = (char)0;
    req.urlPath[216] = (char)0;
    req.urlPath[217] = (char)0;
    req.urlPath[218] = (char)0;
    req.urlPath[219] = (char)0;
    req.urlPath[220] = (char)0;
    req.urlPath[221] = (char)0;
    req.urlPath[222] = (char)0;
    req.urlPath[223] = (char)0;
    req.urlPath[224] = (char)0;
    req.urlPath[225] = (char)0;
    req.urlPath[226] = (char)0;
    req.urlPath[227] = (char)0;
    req.urlPath[228] = (char)0;
    req.urlPath[229] = (char)0;
    req.urlPath[230] = (char)0;
    req.urlPath[231] = (char)0;
    req.urlPath[232] = (char)0;
    req.urlPath[233] = (char)0;
    req.urlPath[234] = (char)0;
    req.urlPath[235] = (char)0;
    req.urlPath[236] = (char)0;
    req.urlPath[237] = (char)0;
    req.urlPath[238] = (char)0;
    req.urlPath[239] = (char)0;
    req.urlPath[240] = (char)0;
    req.urlPath[241] = (char)0;
    req.urlPath[242] = (char)0;
    req.urlPath[243] = (char)0;
    req.urlPath[244] = (char)0;
    req.urlPath[245] = (char)0;
    req.urlPath[246] = (char)0;
    req.urlPath[247] = (char)0;
    req.urlPath[248] = (char)0;
    req.urlPath[249] = (char)0;
    req.urlPath[250] = (char)0;
    req.urlPath[251] = (char)0;
    req.urlPath[252] = (char)0;
    req.urlPath[253] = (char)0;
    req.urlPath[254] = (char)0;
    req.urlPath[255] = (char)0;
    req.urlPath[256] = (char)0;
    req.urlPath[257] = (char)0;
    req.urlPath[258] = (char)0;
    req.urlPath[259] = (char)0;
    req.urlPath[260] = (char)0;
    req.urlPath[261] = (char)0;
    req.urlPath[262] = (char)0;
    req.urlPath[263] = (char)0;
    req.urlPath[264] = (char)0;
    req.urlPath[265] = (char)0;
    req.urlPath[266] = (char)0;
    req.urlPath[267] = (char)0;
    req.urlPath[268] = (char)0;
    req.urlPath[269] = (char)0;
    req.urlPath[270] = (char)0;
    req.urlPath[271] = (char)0;
    req.urlPath[272] = (char)0;
    req.urlPath[273] = (char)0;
    req.urlPath[274] = (char)0;
    req.urlPath[275] = (char)0;
    req.urlPath[276] = (char)0;
    req.urlPath[277] = (char)0;
    req.urlPath[278] = (char)0;
    req.urlPath[279] = (char)0;
    req.urlPath[280] = (char)0;
    req.urlPath[281] = (char)0;
    req.urlPath[282] = (char)0;
    req.urlPath[283] = (char)0;
    req.urlPath[284] = (char)0;
    req.urlPath[285] = (char)0;
    req.urlPath[286] = (char)0;
    req.urlPath[287] = (char)0;
    req.urlPath[288] = (char)0;
    req.urlPath[289] = (char)0;
    req.urlPath[290] = (char)0;
    req.urlPath[291] = (char)0;
    req.urlPath[292] = (char)0;
    req.urlPath[293] = (char)0;
    req.urlPath[294] = (char)0;
    req.urlPath[295] = (char)0;
    req.urlPath[296] = (char)0;
    req.urlPath[297] = (char)0;
    req.urlPath[298] = (char)0;
    req.urlPath[299] = (char)0;
    req.urlPath[300] = (char)0;
    req.urlPath[301] = (char)0;
    req.urlPath[302] = (char)0;
    req.urlPath[303] = (char)0;
    req.urlPath[304] = (char)0;
    req.urlPath[305] = (char)0;
    req.urlPath[306] = (char)0;
    req.urlPath[307] = (char)0;
    req.urlPath[308] = (char)0;
    req.urlPath[309] = (char)0;
    req.urlPath[310] = (char)0;
    req.urlPath[311] = (char)0;
    req.urlPath[312] = (char)0;
    req.urlPath[313] = (char)0;
    req.urlPath[314] = (char)0;
    req.urlPath[315] = (char)0;
    req.urlPath[316] = (char)0;
    req.urlPath[317] = (char)0;
    req.urlPath[318] = (char)0;
    req.urlPath[319] = (char)0;
    req.urlPath[320] = (char)0;
    req.urlPath[321] = (char)0;
    req.urlPath[322] = (char)0;
    req.urlPath[323] = (char)0;
    req.urlPath[324] = (char)0;
    req.urlPath[325] = (char)0;
    req.urlPath[326] = (char)0;
    req.urlPath[327] = (char)0;
    req.urlPath[328] = (char)0;
    req.urlPath[329] = (char)0;
    req.urlPath[330] = (char)0;
    req.urlPath[331] = (char)0;
    req.urlPath[332] = (char)0;
    req.urlPath[333] = (char)0;
    req.urlPath[334] = (char)0;
    req.urlPath[335] = (char)0;
    req.urlPath[336] = (char)0;
    req.urlPath[337] = (char)0;
    req.urlPath[338] = (char)0;
    req.urlPath[339] = (char)0;
    req.urlPath[340] = (char)0;
    req.urlPath[341] = (char)0;
    req.urlPath[342] = (char)0;
    req.urlPath[343] = (char)0;
    req.urlPath[344] = (char)0;
    req.urlPath[345] = (char)0;
    req.urlPath[346] = (char)0;
    req.urlPath[347] = (char)0;
    req.urlPath[348] = (char)0;
    req.urlPath[349] = (char)0;
    req.urlPath[350] = (char)0;
    req.urlPath[351] = (char)0;
    req.urlPath[352] = (char)0;
    req.urlPath[353] = (char)0;
    req.urlPath[354] = (char)0;
    req.urlPath[355] = (char)0;
    req.urlPath[356] = (char)0;
    req.urlPath[357] = (char)0;
    req.urlPath[358] = (char)0;
    req.urlPath[359] = (char)0;
    req.urlPath[360] = (char)0;
    req.urlPath[361] = (char)0;
    req.urlPath[362] = (char)0;
    req.urlPath[363] = (char)0;
    req.urlPath[364] = (char)0;
    req.urlPath[365] = (char)0;
    req.urlPath[366] = (char)0;
    req.urlPath[367] = (char)0;
    req.urlPath[368] = (char)0;
    req.urlPath[369] = (char)0;
    req.urlPath[370] = (char)0;
    req.urlPath[371] = (char)0;
    req.urlPath[372] = (char)0;
    req.urlPath[373] = (char)0;
    req.urlPath[374] = (char)0;
    req.urlPath[375] = (char)0;
    req.urlPath[376] = (char)0;
    req.urlPath[377] = (char)0;
    req.urlPath[378] = (char)0;
    req.urlPath[379] = (char)0;
    req.urlPath[380] = (char)0;
    req.urlPath[381] = (char)0;
    req.urlPath[382] = (char)0;
    req.urlPath[383] = (char)0;
    req.urlPath[384] = (char)0;
    req.urlPath[385] = (char)0;
    req.urlPath[386] = (char)0;
    req.urlPath[387] = (char)0;
    req.urlPath[388] = (char)0;
    req.urlPath[389] = (char)0;
    req.urlPath[390] = (char)0;
    req.urlPath[391] = (char)0;
    req.urlPath[392] = (char)0;
    req.urlPath[393] = (char)0;
    req.urlPath[394] = (char)0;
    req.urlPath[395] = (char)0;
    req.urlPath[396] = (char)0;
    req.urlPath[397] = (char)0;
    req.urlPath[398] = (char)0;
    req.urlPath[399] = (char)0;
    req.urlPath[400] = (char)0;
    req.urlPath[401] = (char)0;
    req.urlPath[402] = (char)0;
    req.urlPath[403] = (char)0;
    req.urlPath[404] = (char)0;
    req.urlPath[405] = (char)0;
    req.urlPath[406] = (char)0;
    req.urlPath[407] = (char)0;
    req.urlPath[408] = (char)0;
    req.urlPath[409] = (char)0;
    req.urlPath[410] = (char)0;
    req.urlPath[411] = (char)0;
    req.urlPath[412] = (char)0;
    req.urlPath[413] = (char)0;
    req.urlPath[414] = (char)0;
    req.urlPath[415] = (char)0;
    req.urlPath[416] = (char)0;
    req.urlPath[417] = (char)0;
    req.urlPath[418] = (char)0;
    req.urlPath[419] = (char)0;
    req.urlPath[420] = (char)0;
    req.urlPath[421] = (char)0;
    req.urlPath[422] = (char)0;
    req.urlPath[423] = (char)0;
    req.urlPath[424] = (char)0;
    req.urlPath[425] = (char)0;
    req.urlPath[426] = (char)0;
    req.urlPath[427] = (char)0;
    req.urlPath[428] = (char)0;
    req.urlPath[429] = (char)0;
    req.urlPath[430] = (char)0;
    req.urlPath[431] = (char)0;
    req.urlPath[432] = (char)0;
    req.urlPath[433] = (char)0;
    req.urlPath[434] = (char)0;
    req.urlPath[435] = (char)0;
    req.urlPath[436] = (char)0;
    req.urlPath[437] = (char)0;
    req.urlPath[438] = (char)0;
    req.urlPath[439] = (char)0;
    req.urlPath[440] = (char)0;
    req.urlPath[441] = (char)0;
    req.urlPath[442] = (char)0;
    req.urlPath[443] = (char)0;
    req.urlPath[444] = (char)0;
    req.urlPath[445] = (char)0;
    req.urlPath[446] = (char)0;
    req.urlPath[447] = (char)0;
    req.urlPath[448] = (char)0;
    req.urlPath[449] = (char)0;
    req.urlPath[450] = (char)0;
    req.urlPath[451] = (char)0;
    req.urlPath[452] = (char)0;
    req.urlPath[453] = (char)0;
    req.urlPath[454] = (char)0;
    req.urlPath[455] = (char)0;
    req.urlPath[456] = (char)0;
    req.urlPath[457] = (char)0;
    req.urlPath[458] = (char)0;
    req.urlPath[459] = (char)0;
    req.urlPath[460] = (char)0;
    req.urlPath[461] = (char)0;
    req.urlPath[462] = (char)0;
    req.urlPath[463] = (char)0;
    req.urlPath[464] = (char)0;
    req.urlPath[465] = (char)0;
    req.urlPath[466] = (char)0;
    req.urlPath[467] = (char)0;
    req.urlPath[468] = (char)0;
    req.urlPath[469] = (char)0;
    req.urlPath[470] = (char)0;
    req.urlPath[471] = (char)0;
    req.urlPath[472] = (char)0;
    req.urlPath[473] = (char)0;
    req.urlPath[474] = (char)0;
    req.urlPath[475] = (char)0;
    req.urlPath[476] = (char)0;
    req.urlPath[477] = (char)0;
    req.urlPath[478] = (char)0;
    req.urlPath[479] = (char)0;
    req.urlPath[480] = (char)0;
    req.urlPath[481] = (char)0;
    req.urlPath[482] = (char)0;
    req.urlPath[483] = (char)0;
    req.urlPath[484] = (char)0;
    req.urlPath[485] = (char)0;
    req.urlPath[486] = (char)0;
    req.urlPath[487] = (char)0;
    req.urlPath[488] = (char)0;
    req.urlPath[489] = (char)0;
    req.urlPath[490] = (char)0;
    req.urlPath[491] = (char)0;
    req.urlPath[492] = (char)0;
    req.urlPath[493] = (char)0;
    req.urlPath[494] = (char)0;
    req.urlPath[495] = (char)0;
    req.urlPath[496] = (char)0;
    req.urlPath[497] = (char)0;
    req.urlPath[498] = (char)0;
    req.urlPath[499] = (char)0;
    req.urlPath[500] = (char)0;
    req.urlPath[501] = (char)0;
    req.urlPath[502] = (char)0;
    req.urlPath[503] = (char)0;
    req.urlPath[504] = (char)0;
    req.urlPath[505] = (char)0;
    req.urlPath[506] = (char)0;
    req.urlPath[507] = (char)0;
    req.urlPath[508] = (char)0;
    req.urlPath[509] = (char)0;
    req.urlPath[510] = (char)0;
    req.urlPath[511] = (char)0;
    req.urlPath[512] = (char)0;
    req.urlPath[513] = (char)0;
    req.urlPath[514] = (char)0;
    req.urlPath[515] = (char)0;
    req.urlPath[516] = (char)0;
    req.urlPath[517] = (char)0;
    req.urlPath[518] = (char)0;
    req.urlPath[519] = (char)0;
    req.urlPath[520] = (char)0;
    req.urlPath[521] = (char)0;
    req.urlPath[522] = (char)0;
    req.urlPath[523] = (char)0;
    req.urlPath[524] = (char)0;
    req.urlPath[525] = (char)0;
    req.urlPath[526] = (char)0;
    req.urlPath[527] = (char)0;
    req.urlPath[528] = (char)0;
    req.urlPath[529] = (char)0;
    req.urlPath[530] = (char)0;
    req.urlPath[531] = (char)0;
    req.urlPath[532] = (char)0;
    req.urlPath[533] = (char)0;
    req.urlPath[534] = (char)0;
    req.urlPath[535] = (char)0;
    req.urlPath[536] = (char)0;
    req.urlPath[537] = (char)0;
    req.urlPath[538] = (char)0;
    req.urlPath[539] = (char)0;
    req.urlPath[540] = (char)0;
    req.urlPath[541] = (char)0;
    req.urlPath[542] = (char)0;
    req.urlPath[543] = (char)0;
    req.urlPath[544] = (char)0;
    req.urlPath[545] = (char)0;
    req.urlPath[546] = (char)0;
    req.urlPath[547] = (char)0;
    req.urlPath[548] = (char)0;
    req.urlPath[549] = (char)0;
    req.urlPath[550] = (char)0;
    req.urlPath[551] = (char)0;
    req.urlPath[552] = (char)0;
    req.urlPath[553] = (char)0;
    req.urlPath[554] = (char)0;
    req.urlPath[555] = (char)0;
    req.urlPath[556] = (char)0;
    req.urlPath[557] = (char)0;
    req.urlPath[558] = (char)0;
    req.urlPath[559] = (char)0;
    req.urlPath[560] = (char)0;
    req.urlPath[561] = (char)0;
    req.urlPath[562] = (char)0;
    req.urlPath[563] = (char)0;
    req.urlPath[564] = (char)0;
    req.urlPath[565] = (char)0;
    req.urlPath[566] = (char)0;
    req.urlPath[567] = (char)0;
    req.urlPath[568] = (char)0;
    req.urlPath[569] = (char)0;
    req.urlPath[570] = (char)0;
    req.urlPath[571] = (char)0;
    req.urlPath[572] = (char)0;
    req.urlPath[573] = (char)0;
    req.urlPath[574] = (char)0;
    req.urlPath[575] = (char)0;
    req.urlPath[576] = (char)0;
    req.urlPath[577] = (char)0;
    req.urlPath[578] = (char)0;
    req.urlPath[579] = (char)0;
    req.urlPath[580] = (char)0;
    req.urlPath[581] = (char)0;
    req.urlPath[582] = (char)0;
    req.urlPath[583] = (char)0;
    req.urlPath[584] = (char)0;
    req.urlPath[585] = (char)0;
    req.urlPath[586] = (char)0;
    req.urlPath[587] = (char)0;
    req.urlPath[588] = (char)0;
    req.urlPath[589] = (char)0;
    req.urlPath[590] = (char)0;
    req.urlPath[591] = (char)0;
    req.urlPath[592] = (char)0;
    req.urlPath[593] = (char)0;
    req.urlPath[594] = (char)0;
    req.urlPath[595] = (char)0;
    req.urlPath[596] = (char)0;
    req.urlPath[597] = (char)0;
    req.urlPath[598] = (char)0;
    req.urlPath[599] = (char)0;
    req.urlPath[600] = (char)0;
    req.urlPath[601] = (char)0;
    req.urlPath[602] = (char)0;
    req.urlPath[603] = (char)0;
    req.urlPath[604] = (char)0;
    req.urlPath[605] = (char)0;
    req.urlPath[606] = (char)0;
    req.urlPath[607] = (char)0;
    req.urlPath[608] = (char)0;
    req.urlPath[609] = (char)0;
    req.urlPath[610] = (char)0;
    req.urlPath[611] = (char)0;
    req.urlPath[612] = (char)0;
    req.urlPath[613] = (char)0;
    req.urlPath[614] = (char)0;
    req.urlPath[615] = (char)0;
    req.urlPath[616] = (char)0;
    req.urlPath[617] = (char)0;
    req.urlPath[618] = (char)0;
    req.urlPath[619] = (char)0;
    req.urlPath[620] = (char)0;
    req.urlPath[621] = (char)0;
    req.urlPath[622] = (char)0;
    req.urlPath[623] = (char)0;
    req.urlPath[624] = (char)0;
    req.urlPath[625] = (char)0;
    req.urlPath[626] = (char)0;
    req.urlPath[627] = (char)0;
    req.urlPath[628] = (char)0;
    req.urlPath[629] = (char)0;
    req.urlPath[630] = (char)0;
    req.urlPath[631] = (char)0;
    req.urlPath[632] = (char)0;
    req.urlPath[633] = (char)0;
    req.urlPath[634] = (char)0;
    req.urlPath[635] = (char)0;
    req.urlPath[636] = (char)0;
    req.urlPath[637] = (char)0;
    req.urlPath[638] = (char)0;
    req.urlPath[639] = (char)0;
    req.urlPath[640] = (char)0;
    req.urlPath[641] = (char)0;
    req.urlPath[642] = (char)0;
    req.urlPath[643] = (char)0;
    req.urlPath[644] = (char)0;
    req.urlPath[645] = (char)0;
    req.urlPath[646] = (char)0;
    req.urlPath[647] = (char)0;
    req.urlPath[648] = (char)0;
    req.urlPath[649] = (char)0;
    req.urlPath[650] = (char)0;
    req.urlPath[651] = (char)0;
    req.urlPath[652] = (char)0;
    req.urlPath[653] = (char)0;
    req.urlPath[654] = (char)0;
    req.urlPath[655] = (char)0;
    req.urlPath[656] = (char)0;
    req.urlPath[657] = (char)0;
    req.urlPath[658] = (char)0;
    req.urlPath[659] = (char)0;
    req.urlPath[660] = (char)0;
    req.urlPath[661] = (char)0;
    req.urlPath[662] = (char)0;
    req.urlPath[663] = (char)0;
    req.urlPath[664] = (char)0;
    req.urlPath[665] = (char)0;
    req.urlPath[666] = (char)0;
    req.urlPath[667] = (char)0;
    req.urlPath[668] = (char)0;
    req.urlPath[669] = (char)0;
    req.urlPath[670] = (char)0;
    req.urlPath[671] = (char)0;
    req.urlPath[672] = (char)0;
    req.urlPath[673] = (char)0;
    req.urlPath[674] = (char)0;
    req.urlPath[675] = (char)0;
    req.urlPath[676] = (char)0;
    req.urlPath[677] = (char)0;
    req.urlPath[678] = (char)0;
    req.urlPath[679] = (char)0;
    req.urlPath[680] = (char)0;
    req.urlPath[681] = (char)0;
    req.urlPath[682] = (char)0;
    req.urlPath[683] = (char)0;
    req.urlPath[684] = (char)0;
    req.urlPath[685] = (char)0;
    req.urlPath[686] = (char)0;
    req.urlPath[687] = (char)0;
    req.urlPath[688] = (char)0;
    req.urlPath[689] = (char)0;
    req.urlPath[690] = (char)0;
    req.urlPath[691] = (char)0;
    req.urlPath[692] = (char)0;
    req.urlPath[693] = (char)0;
    req.urlPath[694] = (char)0;
    req.urlPath[695] = (char)0;
    req.urlPath[696] = (char)0;
    req.urlPath[697] = (char)0;
    req.urlPath[698] = (char)0;
    req.urlPath[699] = (char)0;
    req.urlPath[700] = (char)0;
    req.urlPath[701] = (char)0;
    req.urlPath[702] = (char)0;
    req.urlPath[703] = (char)0;
    req.urlPath[704] = (char)0;
    req.urlPath[705] = (char)0;
    req.urlPath[706] = (char)0;
    req.urlPath[707] = (char)0;
    req.urlPath[708] = (char)0;
    req.urlPath[709] = (char)0;
    req.urlPath[710] = (char)0;
    req.urlPath[711] = (char)0;
    req.urlPath[712] = (char)0;
    req.urlPath[713] = (char)0;
    req.urlPath[714] = (char)0;
    req.urlPath[715] = (char)0;
    req.urlPath[716] = (char)0;
    req.urlPath[717] = (char)0;
    req.urlPath[718] = (char)0;
    req.urlPath[719] = (char)0;
    req.urlPath[720] = (char)0;
    req.urlPath[721] = (char)0;
    req.urlPath[722] = (char)0;
    req.urlPath[723] = (char)0;
    req.urlPath[724] = (char)0;
    req.urlPath[725] = (char)0;
    req.urlPath[726] = (char)0;
    req.urlPath[727] = (char)0;
    req.urlPath[728] = (char)0;
    req.urlPath[729] = (char)0;
    req.urlPath[730] = (char)0;
    req.urlPath[731] = (char)0;
    req.urlPath[732] = (char)0;
    req.urlPath[733] = (char)0;
    req.urlPath[734] = (char)0;
    req.urlPath[735] = (char)0;
    req.urlPath[736] = (char)0;
    req.urlPath[737] = (char)0;
    req.urlPath[738] = (char)0;
    req.urlPath[739] = (char)0;
    req.urlPath[740] = (char)0;
    req.urlPath[741] = (char)0;
    req.urlPath[742] = (char)0;
    req.urlPath[743] = (char)0;
    req.urlPath[744] = (char)0;
    req.urlPath[745] = (char)0;
    req.urlPath[746] = (char)0;
    req.urlPath[747] = (char)0;
    req.urlPath[748] = (char)0;
    req.urlPath[749] = (char)0;
    req.urlPath[750] = (char)0;
    req.urlPath[751] = (char)0;
    req.urlPath[752] = (char)0;
    req.urlPath[753] = (char)0;
    req.urlPath[754] = (char)0;
    req.urlPath[755] = (char)0;
    req.urlPath[756] = (char)0;
    req.urlPath[757] = (char)0;
    req.urlPath[758] = (char)0;
    req.urlPath[759] = (char)0;
    req.urlPath[760] = (char)0;
    req.urlPath[761] = (char)0;
    req.urlPath[762] = (char)0;
    req.urlPath[763] = (char)0;
    req.urlPath[764] = (char)0;
    req.urlPath[765] = (char)0;
    req.urlPath[766] = (char)0;
    req.urlPath[767] = (char)0;
    req.urlPath[768] = (char)0;
    req.urlPath[769] = (char)0;
    req.urlPath[770] = (char)0;
    req.urlPath[771] = (char)0;
    req.urlPath[772] = (char)0;
    req.urlPath[773] = (char)0;
    req.urlPath[774] = (char)0;
    req.urlPath[775] = (char)0;
    req.urlPath[776] = (char)0;
    req.urlPath[777] = (char)0;
    req.urlPath[778] = (char)0;
    req.urlPath[779] = (char)0;
    req.urlPath[780] = (char)0;
    req.urlPath[781] = (char)0;
    req.urlPath[782] = (char)0;
    req.urlPath[783] = (char)0;
    req.urlPath[784] = (char)0;
    req.urlPath[785] = (char)0;
    req.urlPath[786] = (char)0;
    req.urlPath[787] = (char)0;
    req.urlPath[788] = (char)0;
    req.urlPath[789] = (char)0;
    req.urlPath[790] = (char)0;
    req.urlPath[791] = (char)0;
    req.urlPath[792] = (char)0;
    req.urlPath[793] = (char)0;
    req.urlPath[794] = (char)0;
    req.urlPath[795] = (char)0;
    req.urlPath[796] = (char)0;
    req.urlPath[797] = (char)0;
    req.urlPath[798] = (char)0;
    req.urlPath[799] = (char)0;
    req.urlPath[800] = (char)0;
    req.urlPath[801] = (char)0;
    req.urlPath[802] = (char)0;
    req.urlPath[803] = (char)0;
    req.urlPath[804] = (char)0;
    req.urlPath[805] = (char)0;
    req.urlPath[806] = (char)0;
    req.urlPath[807] = (char)0;
    req.urlPath[808] = (char)0;
    req.urlPath[809] = (char)0;
    req.urlPath[810] = (char)0;
    req.urlPath[811] = (char)0;
    req.urlPath[812] = (char)0;
    req.urlPath[813] = (char)0;
    req.urlPath[814] = (char)0;
    req.urlPath[815] = (char)0;
    req.urlPath[816] = (char)0;
    req.urlPath[817] = (char)0;
    req.urlPath[818] = (char)0;
    req.urlPath[819] = (char)0;
    req.urlPath[820] = (char)0;
    req.urlPath[821] = (char)0;
    req.urlPath[822] = (char)0;
    req.urlPath[823] = (char)0;
    req.urlPath[824] = (char)0;
    req.urlPath[825] = (char)0;
    req.urlPath[826] = (char)0;
    req.urlPath[827] = (char)0;
    req.urlPath[828] = (char)0;
    req.urlPath[829] = (char)0;
    req.urlPath[830] = (char)0;
    req.urlPath[831] = (char)0;
    req.urlPath[832] = (char)0;
    req.urlPath[833] = (char)0;
    req.urlPath[834] = (char)0;
    req.urlPath[835] = (char)0;
    req.urlPath[836] = (char)0;
    req.urlPath[837] = (char)0;
    req.urlPath[838] = (char)0;
    req.urlPath[839] = (char)0;
    req.urlPath[840] = (char)0;
    req.urlPath[841] = (char)0;
    req.urlPath[842] = (char)0;
    req.urlPath[843] = (char)0;
    req.urlPath[844] = (char)0;
    req.urlPath[845] = (char)0;
    req.urlPath[846] = (char)0;
    req.urlPath[847] = (char)0;
    req.urlPath[848] = (char)0;
    req.urlPath[849] = (char)0;
    req.urlPath[850] = (char)0;
    req.urlPath[851] = (char)0;
    req.urlPath[852] = (char)0;
    req.urlPath[853] = (char)0;
    req.urlPath[854] = (char)0;
    req.urlPath[855] = (char)0;
    req.urlPath[856] = (char)0;
    req.urlPath[857] = (char)0;
    req.urlPath[858] = (char)0;
    req.urlPath[859] = (char)0;
    req.urlPath[860] = (char)0;
    req.urlPath[861] = (char)0;
    req.urlPath[862] = (char)0;
    req.urlPath[863] = (char)0;
    req.urlPath[864] = (char)0;
    req.urlPath[865] = (char)0;
    req.urlPath[866] = (char)0;
    req.urlPath[867] = (char)0;
    req.urlPath[868] = (char)0;
    req.urlPath[869] = (char)0;
    req.urlPath[870] = (char)0;
    req.urlPath[871] = (char)0;
    req.urlPath[872] = (char)0;
    req.urlPath[873] = (char)0;
    req.urlPath[874] = (char)0;
    req.urlPath[875] = (char)0;
    req.urlPath[876] = (char)0;
    req.urlPath[877] = (char)0;
    req.urlPath[878] = (char)0;
    req.urlPath[879] = (char)0;
    req.urlPath[880] = (char)0;
    req.urlPath[881] = (char)0;
    req.urlPath[882] = (char)0;
    req.urlPath[883] = (char)0;
    req.urlPath[884] = (char)0;
    req.urlPath[885] = (char)0;
    req.urlPath[886] = (char)0;
    req.urlPath[887] = (char)0;
    req.urlPath[888] = (char)0;
    req.urlPath[889] = (char)0;
    req.urlPath[890] = (char)0;
    req.urlPath[891] = (char)0;
    req.urlPath[892] = (char)0;
    req.urlPath[893] = (char)0;
    req.urlPath[894] = (char)0;
    req.urlPath[895] = (char)0;
    req.urlPath[896] = (char)0;
    req.urlPath[897] = (char)0;
    req.urlPath[898] = (char)0;
    req.urlPath[899] = (char)0;
    req.urlPath[900] = (char)0;
    req.urlPath[901] = (char)0;
    req.urlPath[902] = (char)0;
    req.urlPath[903] = (char)0;
    req.urlPath[904] = (char)0;
    req.urlPath[905] = (char)0;
    req.urlPath[906] = (char)0;
    req.urlPath[907] = (char)0;
    req.urlPath[908] = (char)0;
    req.urlPath[909] = (char)0;
    req.urlPath[910] = (char)0;
    req.urlPath[911] = (char)0;
    req.urlPath[912] = (char)0;
    req.urlPath[913] = (char)0;
    req.urlPath[914] = (char)0;
    req.urlPath[915] = (char)0;
    req.urlPath[916] = (char)0;
    req.urlPath[917] = (char)0;
    req.urlPath[918] = (char)0;
    req.urlPath[919] = (char)0;
    req.urlPath[920] = (char)0;
    req.urlPath[921] = (char)0;
    req.urlPath[922] = (char)0;
    req.urlPath[923] = (char)0;
    req.urlPath[924] = (char)0;
    req.urlPath[925] = (char)0;
    req.urlPath[926] = (char)0;
    req.urlPath[927] = (char)0;
    req.urlPath[928] = (char)0;
    req.urlPath[929] = (char)0;
    req.urlPath[930] = (char)0;
    req.urlPath[931] = (char)0;
    req.urlPath[932] = (char)0;
    req.urlPath[933] = (char)0;
    req.urlPath[934] = (char)0;
    req.urlPath[935] = (char)0;
    req.urlPath[936] = (char)0;
    req.urlPath[937] = (char)0;
    req.urlPath[938] = (char)0;
    req.urlPath[939] = (char)0;
    req.urlPath[940] = (char)0;
    req.urlPath[941] = (char)0;
    req.urlPath[942] = (char)0;
    req.urlPath[943] = (char)0;
    req.urlPath[944] = (char)0;
    req.urlPath[945] = (char)0;
    req.urlPath[946] = (char)0;
    req.urlPath[947] = (char)0;
    req.urlPath[948] = (char)0;
    req.urlPath[949] = (char)0;
    req.urlPath[950] = (char)0;
    req.urlPath[951] = (char)0;
    req.urlPath[952] = (char)0;
    req.urlPath[953] = (char)0;
    req.urlPath[954] = (char)0;
    req.urlPath[955] = (char)0;
    req.urlPath[956] = (char)0;
    req.urlPath[957] = (char)0;
    req.urlPath[958] = (char)0;
    req.urlPath[959] = (char)0;
    req.urlPath[960] = (char)0;
    req.urlPath[961] = (char)0;
    req.urlPath[962] = (char)0;
    req.urlPath[963] = (char)0;
    req.urlPath[964] = (char)0;
    req.urlPath[965] = (char)0;
    req.urlPath[966] = (char)0;
    req.urlPath[967] = (char)0;
    req.urlPath[968] = (char)0;
    req.urlPath[969] = (char)0;
    req.urlPath[970] = (char)0;
    req.urlPath[971] = (char)0;
    req.urlPath[972] = (char)0;
    req.urlPath[973] = (char)0;
    req.urlPath[974] = (char)0;
    req.urlPath[975] = (char)0;
    req.urlPath[976] = (char)0;
    req.urlPath[977] = (char)0;
    req.urlPath[978] = (char)0;
    req.urlPath[979] = (char)0;
    req.urlPath[980] = (char)0;
    req.urlPath[981] = (char)0;
    req.urlPath[982] = (char)0;
    req.urlPath[983] = (char)0;
    req.urlPath[984] = (char)0;
    req.urlPath[985] = (char)0;
    req.urlPath[986] = (char)0;
    req.urlPath[987] = (char)0;
    req.urlPath[988] = (char)0;
    req.urlPath[989] = (char)0;
    req.urlPath[990] = (char)0;
    req.urlPath[991] = (char)0;
    req.urlPath[992] = (char)0;
    req.urlPath[993] = (char)0;
    req.urlPath[994] = (char)0;
    req.urlPath[995] = (char)0;
    req.urlPath[996] = (char)0;
    req.urlPath[997] = (char)0;
    req.urlPath[998] = (char)0;
    req.urlPath[999] = (char)0;
    req.urlPath[1000] = (char)0;
    req.urlPath[1001] = (char)0;
    req.urlPath[1002] = (char)0;
    req.urlPath[1003] = (char)0;
    req.urlPath[1004] = (char)0;
    req.urlPath[1005] = (char)0;
    req.urlPath[1006] = (char)0;
    req.urlPath[1007] = (char)0;
    req.urlPath[1008] = (char)0;
    req.urlPath[1009] = (char)0;
    req.urlPath[1010] = (char)0;
    req.urlPath[1011] = (char)0;
    req.urlPath[1012] = (char)0;
    req.urlPath[1013] = (char)0;
    req.urlPath[1014] = (char)0;
    req.urlPath[1015] = (char)0;
    req.urlPath[1016] = (char)0;
    req.urlPath[1017] = (char)0;
    req.urlPath[1018] = (char)0;
    req.urlPath[1019] = (char)0;
    req.urlPath[1020] = (char)0;
    req.urlPath[1021] = (char)0;
    req.urlPath[1022] = (char)0;
    req.urlPath[1023] = (char)0;
    req.postData = (char *)0;
    req.responseData = (char *)((void *)0);
    pRetLocal = PianoRequest(& app___0->ph, & req, (PianoRequestType_t )type);
    if ((unsigned int )pRetLocal != 1U) {
      tmp = PianoErrorToStr(pRetLocal);
      BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )0,
               "Error: %s\n", tmp);
      goto cleanup;
    }
    wRetLocal = BarPianoHttpRequest((CURL * const  )app___0->http, (BarSettings_t const   * const  )(& app___0->settings),
                                    (PianoRequest_t * const  )(& req));
    if ((unsigned int )wRetLocal == 42U) {
      BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )0,
               "Interrupted.\n");
      goto cleanup;
    } else
    if ((unsigned int )wRetLocal != 0U) {
      tmp___0 = curl_easy_strerror(wRetLocal);
      BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )0,
               "Network error: %s\n", tmp___0);
      goto cleanup;
    }
    pRetLocal = PianoResponse(& app___0->ph, & req);
    if ((unsigned int )pRetLocal != 3U) {
      if ((unsigned int )pRetLocal == 2025U) {
        if ((unsigned int const   )type != 1U) {
          reqData.user = app___0->settings.username;
          reqData.password = app___0->settings.password;
          reqData.step = (unsigned char)0;
          BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )0,
                   "Reauthentication required... ");
          tmp___1 = BarUiPianoCall(app___0, (PianoRequestType_t const   )1, (void * const  )(& reqData),
                                   (PianoReturn_t * const  )(& pRetLocal), (CURLcode * const  )(& wRetLocal));
          if (tmp___1) {
            pRetLocal = (PianoReturn_t )3;
            BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
                     "Trying again... ");
          } else {
            goto cleanup;
          }
        } else {
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
      if ((unsigned int )pRetLocal != 1U) {
        tmp___2 = PianoErrorToStr(pRetLocal);
        BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )0,
                 "Error: %s\n", tmp___2);
        goto cleanup;
      } else {
        BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )0,
                 "Ok.\n");
        ret = (_Bool)1;
      }
    }
    cleanup: 
    free((void *)req.responseData);
    PianoDestroyRequest(& req);
    if (! ((unsigned int )pRetLocal == 3U)) {
      break;
    }
  }
  *pRet = pRetLocal;
  *wRet = wRetLocal;
  return (ret);
}
}
__inline static int BarStationQuickmix01Cmp(void const   *a , void const   *b ) 
{ 
  PianoStation_t const   *stationA ;
  PianoStation_t const   *stationB ;

  {
  stationA = (PianoStation_t const   *)*((PianoStation_t * const  *)a);
  stationB = (PianoStation_t const   *)*((PianoStation_t * const  *)b);
  return ((int )((int const   )stationA->isQuickMix - (int const   )stationB->isQuickMix));
}
}
__inline static int BarStationNameAZCmp(void const   *a , void const   *b ) 
{ 
  PianoStation_t const   *stationA ;
  PianoStation_t const   *stationB ;
  int tmp ;

  {
  stationA = (PianoStation_t const   *)*((PianoStation_t * const  *)a);
  stationB = (PianoStation_t const   *)*((PianoStation_t * const  *)b);
  tmp = strcasecmp((char const   *)stationA->name, (char const   *)stationB->name);
  return (tmp);
}
}
static int BarStationNameZACmp(void const   *a , void const   *b ) 
{ 
  int tmp ;

  {
  tmp = BarStationNameAZCmp(b, a);
  return (tmp);
}
}
__inline static int BarStationQuickmixNameCmp(void const   *a , void const   *b ,
                                              void const   *c , void const   *d ) 
{ 
  int qmc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = BarStationQuickmix01Cmp(a, b);
  qmc = tmp;
  if (qmc == 0) {
    tmp___0 = BarStationNameAZCmp(c, d);
    tmp___1 = tmp___0;
  } else {
    tmp___1 = qmc;
  }
  return (tmp___1);
}
}
static int BarStationCmpQuickmix01NameAZ(void const   *a , void const   *b ) 
{ 
  int tmp ;

  {
  tmp = BarStationQuickmixNameCmp(a, b, a, b);
  return (tmp);
}
}
static int BarStationCmpQuickmix01NameZA(void const   *a , void const   *b ) 
{ 
  int tmp ;

  {
  tmp = BarStationQuickmixNameCmp(a, b, b, a);
  return (tmp);
}
}
static int BarStationCmpQuickmix10NameAZ(void const   *a , void const   *b ) 
{ 
  int tmp ;

  {
  tmp = BarStationQuickmixNameCmp(b, a, a, b);
  return (tmp);
}
}
static int BarStationCmpQuickmix10NameZA(void const   *a , void const   *b ) 
{ 
  int tmp ;

  {
  tmp = BarStationQuickmixNameCmp(b, a, b, a);
  return (tmp);
}
}
static PianoStation_t **BarSortedStations(PianoStation_t *unsortedStations , size_t *retStationCount ,
                                          BarStationSorting_t order ) ;
static BarSortFunc_t const   orderMapping[6]  = {      (BarSortFunc_t const   )(& BarStationNameAZCmp),      (BarSortFunc_t const   )(& BarStationNameZACmp),      (BarSortFunc_t const   )(& BarStationCmpQuickmix01NameAZ),      (BarSortFunc_t const   )(& BarStationCmpQuickmix01NameZA), 
        (BarSortFunc_t const   )(& BarStationCmpQuickmix10NameAZ),      (BarSortFunc_t const   )(& BarStationCmpQuickmix10NameZA)};
static PianoStation_t **BarSortedStations(PianoStation_t *unsortedStations , size_t *retStationCount ,
                                          BarStationSorting_t order ) 
{ 
  PianoStation_t **stationArray ;
  PianoStation_t *currStation ;
  size_t stationCount ;
  size_t i ;
  void *tmp ;

  {
  stationArray = (PianoStation_t **)((void *)0);
  currStation = (PianoStation_t *)((void *)0);
  stationCount = (size_t )0;
  stationCount = PianoListCount((PianoListHead_t const   * const  )(& unsortedStations->head));
  tmp = calloc(stationCount, sizeof(*stationArray));
  stationArray = (PianoStation_t **)tmp;
  i = (size_t )0;
  currStation = unsortedStations;
  while ((unsigned long )currStation != (unsigned long )((void *)0)) {
    *(stationArray + i) = currStation;
    i ++;
    currStation = (PianoStation_t *)((void *)currStation->head.next);
  }
  qsort((void *)stationArray, stationCount, sizeof(*stationArray), (int (*)(void const   * ,
                                                                            void const   * ))orderMapping[order]);
  *retStationCount = stationCount;
  return (stationArray);
}
}
PianoStation_t *BarUiSelectStation(BarApp_t *app___0 , PianoStation_t *stations ,
                                   char const   *prompt , void (*callback)(BarApp_t *app ,
                                                                           char *buf ) ,
                                   _Bool autoselect ) 
{ 
  PianoStation_t **sortedStations ;
  PianoStation_t *retStation ;
  size_t stationCount ;
  size_t i ;
  size_t lastDisplayed ;
  size_t displayCount ;
  char buf[100] ;
  PianoStation_t const   *currStation ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  size_t tmp___3 ;
  unsigned long selected ;
  unsigned long tmp___4 ;
  _Bool tmp___5 ;

  {
  sortedStations = (PianoStation_t **)((void *)0);
  retStation = (PianoStation_t *)((void *)0);
  if ((unsigned long )stations == (unsigned long )((void *)0)) {
    BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )4,
             "No station available.\n");
    return ((PianoStation_t *)((void *)0));
  }
  memset((void *)(buf), 0, sizeof(buf));
  sortedStations = BarSortedStations(stations, & stationCount, app___0->settings.sortOrder);
  while (1) {
    displayCount = (size_t )0;
    i = (size_t )0;
    while (i < stationCount) {
      currStation = (PianoStation_t const   *)*(sortedStations + i);
      tmp___2 = BarStrCaseStr((char const   *)currStation->name, (char const   *)(buf));
      if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
        if (! currStation->isCreator) {
          tmp = 'S';
        } else {
          tmp = ' ';
        }
        if (currStation->isQuickMix) {
          tmp___0 = 'Q';
        } else {
          tmp___0 = ' ';
        }
        if (currStation->useQuickMix) {
          tmp___1 = 'q';
        } else {
          tmp___1 = ' ';
        }
        BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )6,
                 "%2zi) %c%c%c %s\n", i, tmp___1, tmp___0, tmp, currStation->name);
        displayCount ++;
        lastDisplayed = i;
      }
      i ++;
    }
    BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )5,
             "%s", prompt);
    if (autoselect) {
      if (displayCount == 1UL) {
        if (stationCount != 1UL) {
          BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )0,
                   "%zi\n", lastDisplayed);
          retStation = *(sortedStations + lastDisplayed);
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      tmp___3 = BarReadlineStr(buf, (size_t const   )sizeof(buf), & app___0->input,
                               (BarReadlineFlags_t const   )0);
      if (tmp___3 == 0UL) {
        break;
      }
      tmp___5 = isnumeric((char const   *)(buf));
      if (tmp___5) {
        tmp___4 = strtoul((char const   * __restrict  )(buf), (char ** __restrict  )((void *)0),
                          0);
        selected = tmp___4;
        if (selected < stationCount) {
          retStation = *(sortedStations + selected);
        }
      }
      if ((unsigned long )retStation == (unsigned long )((void *)0)) {
        if ((unsigned long )callback != (unsigned long )((void *)0)) {
          (*callback)(app___0, buf);
        }
      }
    }
    if (! ((unsigned long )retStation == (unsigned long )((void *)0))) {
      break;
    }
  }
  free((void *)sortedStations);
  return (retStation);
}
}
PianoSong_t *BarUiSelectSong(BarApp_t const   * const  app___0 , PianoSong_t *startSong ,
                             BarReadlineFds_t *input ) 
{ 
  BarSettings_t const   *settings ;
  PianoSong_t *tmpSong ;
  char buf[100] ;
  size_t tmp ;
  unsigned long i ;
  unsigned long tmp___0 ;
  void *tmp___1 ;
  _Bool tmp___2 ;

  {
  settings = & app___0->settings;
  tmpSong = (PianoSong_t *)((void *)0);
  memset((void *)(buf), 0, sizeof(buf));
  while (1) {
    BarUiListSongs(app___0, (PianoSong_t const   *)startSong, (char const   *)(buf));
    BarUiMsg(settings, (BarUiMsg_t const   )5, "Select song: ");
    tmp = BarReadlineStr(buf, (size_t const   )sizeof(buf), input, (BarReadlineFlags_t const   )0);
    if (tmp == 0UL) {
      return ((PianoSong_t *)((void *)0));
    }
    tmp___2 = isnumeric((char const   *)(buf));
    if (tmp___2) {
      tmp___0 = strtoul((char const   * __restrict  )(buf), (char ** __restrict  )((void *)0),
                        0);
      i = tmp___0;
      tmp___1 = PianoListGet((PianoListHead_t * const  )(& startSong->head), (size_t const   )i);
      tmpSong = (PianoSong_t *)tmp___1;
    }
    if (! ((unsigned long )tmpSong == (unsigned long )((void *)0))) {
      break;
    }
  }
  return (tmpSong);
}
}
PianoArtist_t *BarUiSelectArtist(BarApp_t *app___0 , PianoArtist_t *startArtist ) 
{ 
  PianoArtist_t *tmpArtist ;
  char buf[100] ;
  unsigned long i ;
  char const   *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  _Bool tmp___2 ;

  {
  tmpArtist = (PianoArtist_t *)((void *)0);
  memset((void *)(buf), 0, sizeof(buf));
  while (1) {
    i = 0UL;
    tmpArtist = startArtist;
    while ((unsigned long )tmpArtist != (unsigned long )((void *)0)) {
      tmp = BarStrCaseStr((char const   *)tmpArtist->name, (char const   *)(buf));
      if ((unsigned long )tmp != (unsigned long )((void *)0)) {
        BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )6,
                 "%2lu) %s\n", i, tmpArtist->name);
      }
      i ++;
      tmpArtist = (PianoArtist_t *)((void *)tmpArtist->head.next);
    }
    BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )5,
             "Select artist: ");
    tmp___0 = BarReadlineStr(buf, (size_t const   )sizeof(buf), & app___0->input,
                             (BarReadlineFlags_t const   )0);
    if (tmp___0 == 0UL) {
      return ((PianoArtist_t *)((void *)0));
    }
    tmp___2 = isnumeric((char const   *)(buf));
    if (tmp___2) {
      i = strtoul((char const   * __restrict  )(buf), (char ** __restrict  )((void *)0),
                  0);
      tmp___1 = PianoListGet((PianoListHead_t * const  )(& startArtist->head), (size_t const   )i);
      tmpArtist = (PianoArtist_t *)tmp___1;
    }
    if (! ((unsigned long )tmpArtist == (unsigned long )((void *)0))) {
      break;
    }
  }
  return (tmpArtist);
}
}
char *BarUiSelectMusicId(BarApp_t *app___0 , PianoStation_t *station , char const   *msg ) 
{ 
  char *musicId ;
  char lineBuf[100] ;
  char selectBuf[2] ;
  PianoSearchResult_t searchResult ;
  PianoArtist_t *tmpArtist ;
  PianoSong_t *tmpSong ;
  PianoReturn_t pRet ;
  CURLcode wRet ;
  PianoRequestDataSearch_t reqData ;
  _Bool tmp ;
  size_t tmp___0 ;

  {
  musicId = (char *)((void *)0);
  BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )5,
           "%s", msg);
  tmp___0 = BarReadlineStr(lineBuf, (size_t const   )sizeof(lineBuf), & app___0->input,
                           (BarReadlineFlags_t const   )0);
  if (tmp___0 > 0UL) {
    reqData.searchStr = lineBuf;
    BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
             "Searching... ");
    tmp = BarUiPianoCall((BarApp_t * const  )app___0, (PianoRequestType_t const   )9,
                         (void * const  )(& reqData), (PianoReturn_t * const  )(& pRet),
                         (CURLcode * const  )(& wRet));
    if (! tmp) {
      return ((char *)((void *)0));
    }
    memcpy((void * __restrict  )(& searchResult), (void const   * __restrict  )(& reqData.searchResult),
           sizeof(searchResult));
    BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )0,
             "\r");
    if ((unsigned long )searchResult.songs != (unsigned long )((void *)0)) {
      if ((unsigned long )searchResult.artists != (unsigned long )((void *)0)) {
        BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )5,
                 "Is this an [a]rtist or [t]rack name? ");
        BarReadline(selectBuf, (size_t const   )sizeof(selectBuf), "at", & app___0->input,
                    (BarReadlineFlags_t const   )1, -1);
        if ((int )selectBuf[0] == 97) {
          tmpArtist = BarUiSelectArtist(app___0, searchResult.artists);
          if ((unsigned long )tmpArtist != (unsigned long )((void *)0)) {
            musicId = strdup((char const   *)tmpArtist->musicId);
          }
        } else
        if ((int )selectBuf[0] == 116) {
          tmpSong = BarUiSelectSong((BarApp_t const   * const  )app___0, searchResult.songs,
                                    & app___0->input);
          if ((unsigned long )tmpSong != (unsigned long )((void *)0)) {
            musicId = strdup((char const   *)tmpSong->musicId);
          }
        }
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if ((unsigned long )searchResult.songs != (unsigned long )((void *)0)) {
      tmpSong = BarUiSelectSong((BarApp_t const   * const  )app___0, searchResult.songs,
                                & app___0->input);
      if ((unsigned long )tmpSong != (unsigned long )((void *)0)) {
        musicId = strdup((char const   *)tmpSong->musicId);
      }
    } else
    if ((unsigned long )searchResult.artists != (unsigned long )((void *)0)) {
      tmpArtist = BarUiSelectArtist(app___0, searchResult.artists);
      if ((unsigned long )tmpArtist != (unsigned long )((void *)0)) {
        musicId = strdup((char const   *)tmpArtist->musicId);
      }
    } else {
      BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )1,
               "Nothing found...\n");
    }
    PianoDestroySearchResult(& searchResult);
  }
  return (musicId);
}
}
void BarUiCustomFormat(char *dest , size_t destSize , char const   *format , char const   *formatChars ,
                       char const   **formatVals ) 
{ 
  _Bool haveFormatChar ;
  char const   *testChar ;
  char const   *val ;

  {
  haveFormatChar = (_Bool)0;
  while (1) {
    if ((int const   )*format != 0) {
      if (! (destSize > 1UL)) {
        break;
      }
    } else {
      break;
    }
    if ((int const   )*format == 37) {
      if (! haveFormatChar) {
        haveFormatChar = (_Bool)1;
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if (haveFormatChar) {
      testChar = formatChars;
      val = (char const   *)((void *)0);
      while ((int const   )*testChar != 0) {
        if ((int const   )*testChar == (int const   )*format) {
          val = *(formatVals + (unsigned long )(testChar - formatChars) / sizeof(*testChar));
          break;
        }
        testChar ++;
      }
      if ((unsigned long )val != (unsigned long )((void *)0)) {
        while (1) {
          if ((int const   )*val != 0) {
            if (! (destSize > 1UL)) {
              break;
            }
          } else {
            break;
          }
          *dest = (char )*val;
          val ++;
          dest ++;
          destSize --;
        }
      } else {
        *dest = (char )'%';
        dest ++;
        destSize --;
        if (destSize > 1UL) {
          *dest = (char )*format;
          dest ++;
          destSize --;
        }
      }
      haveFormatChar = (_Bool)0;
    } else {
      *dest = (char )*format;
      dest ++;
      destSize --;
    }
    format ++;
  }
  *dest = (char )'\000';
  return;
}
}
static void BarUiAppendNewline(char *s , size_t maxlen ) 
{ 
  size_t len ;

  {
  len = strlen((char const   *)s);
  if (len == maxlen - 1UL) {
    *(s + (maxlen - 2UL)) = (char )'\n';
  } else {
    *(s + len) = (char )'\n';
    *(s + (len + 1UL)) = (char )'\000';
  }
  return;
}
}
void BarUiPrintStation(BarSettings_t const   *settings , PianoStation_t *station ) 
{ 
  char outstr[512] ;
  char const   *vals[2] ;

  {
  vals[0] = (char const   *)station->name;
  vals[1] = (char const   *)station->id;
  BarUiCustomFormat(outstr, sizeof(outstr), (char const   *)settings->npStationFormat,
                    "ni", vals);
  BarUiAppendNewline(outstr, sizeof(outstr));
  BarUiMsg(settings, (BarUiMsg_t const   )2, "%s", outstr);
  return;
}
}
static char const   *ratingToIcon(BarSettings_t const   * const  settings , PianoSong_t const   * const  song ) 
{ 


  {
  switch ((unsigned int const   )song->rating) {
  case 1U: 
  return ((char const   *)settings->loveIcon);
  case 2U: 
  return ((char const   *)settings->banIcon);
  case 3U: 
  return ((char const   *)settings->tiredIcon);
  default: 
  return ("");
  }
}
}
void BarUiPrintSong(BarSettings_t const   *settings , PianoSong_t const   *song ,
                    PianoStation_t const   *station ) 
{ 
  char outstr[512] ;
  char const   *vals[7] ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  tmp = ratingToIcon((BarSettings_t const   * const  )settings, (PianoSong_t const   * const  )song);
  if ((unsigned long )station != (unsigned long )((void *)0)) {
    tmp___0 = (char const   * const  )settings->atIcon;
  } else {
    tmp___0 = (char const   * const  )"";
  }
  if ((unsigned long )station != (unsigned long )((void *)0)) {
    tmp___1 = (char const   * const  )station->name;
  } else {
    tmp___1 = (char const   * const  )"";
  }
  vals[0] = (char const   *)song->title;
  vals[1] = (char const   *)song->artist;
  vals[2] = (char const   *)song->album;
  vals[3] = tmp;
  vals[4] = (char const   *)tmp___0;
  vals[5] = (char const   *)tmp___1;
  vals[6] = (char const   *)song->detailUrl;
  BarUiCustomFormat(outstr, sizeof(outstr), (char const   *)settings->npSongFormat,
                    "talr@su", vals);
  BarUiAppendNewline(outstr, sizeof(outstr));
  BarUiMsg(settings, (BarUiMsg_t const   )2, "%s", outstr);
  return;
}
}
size_t BarUiListSongs(BarApp_t const   * const  app___0 , PianoSong_t const   *song ,
                      char const   *filter ) 
{ 
  BarSettings_t const   *settings ;
  size_t i ;
  char const   *deleted ;
  char const   *empty ;
  char const   *stationName ;
  PianoStation_t const   *station ;
  PianoStation_t *tmp ;
  char outstr[512] ;
  char digits[8] ;
  char duration[8] ;
  unsigned int tmp___0 ;
  char const   *vals[7] ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  unsigned int length ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
  settings = & app___0->settings;
  i = (size_t )0;
  while ((unsigned long )song != (unsigned long )((void *)0)) {
    if ((unsigned long )filter == (unsigned long )((void *)0)) {
      goto _L___1;
    } else
    if ((unsigned long )filter != (unsigned long )((void *)0)) {
      tmp___3 = BarStrCaseStr((char const   *)song->artist, filter);
      if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
        goto _L___1;
      } else {
        tmp___4 = BarStrCaseStr((char const   *)song->title, filter);
        if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
          _L___1: /* CIL Label */ 
          deleted = "(deleted)";
          empty = "";
          stationName = empty;
          tmp = PianoFindStationById(app___0->ph.stations, (char const   * const  )song->stationId);
          station = (PianoStation_t const   *)tmp;
          if ((unsigned long )station != (unsigned long )((void *)0)) {
            if ((unsigned long )station != (unsigned long )app___0->curStation) {
              stationName = (char const   *)station->name;
            } else {
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
          if ((unsigned long )station == (unsigned long )((void *)0)) {
            if ((unsigned long )song->stationId != (unsigned long )((void *)0)) {
              stationName = deleted;
            }
          }
          duration[0] = (char )'?';
          duration[1] = (char )'?';
          duration[2] = (char )':';
          duration[3] = (char )'?';
          duration[4] = (char )'?';
          duration[5] = (char )'\000';
          tmp___0 = 6U;
          while (! (tmp___0 >= 8U)) {
            duration[tmp___0] = (char)0;
            tmp___0 ++;
          }
          tmp___1 = ratingToIcon((BarSettings_t const   * const  )settings, (PianoSong_t const   * const  )song);
          if ((unsigned long )stationName != (unsigned long )empty) {
            tmp___2 = (char const   * const  )settings->atIcon;
          } else {
            tmp___2 = (char const   * const  )"";
          }
          vals[0] = (char const   *)(digits);
          vals[1] = (char const   *)song->artist;
          vals[2] = (char const   *)song->title;
          vals[3] = tmp___1;
          vals[4] = (char const   *)(duration);
          vals[5] = (char const   *)tmp___2;
          vals[6] = stationName;
          snprintf((char * __restrict  )(digits), sizeof(digits) / sizeof(digits[0]),
                   (char const   * __restrict  )"%2zu", i);
          length = (unsigned int )song->length;
          if (length > 0U) {
            snprintf((char * __restrict  )(duration), sizeof(duration), (char const   * __restrict  )"%02u:%02u",
                     length / 60U, length % 60U);
          }
          BarUiCustomFormat(outstr, sizeof(outstr), (char const   *)settings->listSongFormat,
                            "iatrd@s", vals);
          BarUiAppendNewline(outstr, sizeof(outstr));
          BarUiMsg(settings, (BarUiMsg_t const   )6, "%s", outstr);
        }
      }
    }
    i ++;
    song = (PianoSong_t const   *)((void *)song->head.next);
  }
  return (i);
}
}
void BarUiStartEventCmd(BarSettings_t const   *settings , char const   *type , PianoStation_t const   *curStation ,
                        PianoSong_t const   *curSong , player_t * const  player ,
                        PianoStation_t *stations , PianoReturn_t pRet , CURLcode wRet ) 
{ 
  pid_t chld ;
  int pipeFd[2] ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int status ;
  PianoStation_t *songStation ;
  FILE *pipeWriteFd ;
  unsigned int songDuration ;
  unsigned int songPlayed ;
  char const   *tmp___7 ;
  unsigned int tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  PianoStation_t **sortedStations ;
  size_t stationCount ;
  size_t i ;
  PianoStation_t const   *currStation ;
  char const   *msg ;
  size_t tmp___17 ;

  {
  if ((unsigned long )settings->eventCmd == (unsigned long )((void *)0)) {
    return;
  }
  tmp___1 = pipe((int *)(pipeFd));
  if (tmp___1 == -1) {
    tmp = __errno_location();
    tmp___0 = strerror(*tmp);
    BarUiMsg(settings, (BarUiMsg_t const   )4, "Cannot create eventcmd pipe. (%s)\n",
             tmp___0);
    return;
  }
  chld = fork();
  if (chld == 0) {
    close(pipeFd[1]);
    tmp___2 = fileno(stdin);
    dup2(pipeFd[0], tmp___2);
    execl((char const   *)settings->eventCmd, (char const   *)settings->eventCmd,
          type, (char *)((void *)0));
    tmp___3 = __errno_location();
    tmp___4 = strerror(*tmp___3);
    BarUiMsg(settings, (BarUiMsg_t const   )4, "Cannot start eventcmd. (%s)\n", tmp___4);
    close(pipeFd[0]);
    exit(1);
  } else
  if (chld == -1) {
    tmp___5 = __errno_location();
    tmp___6 = strerror(*tmp___5);
    BarUiMsg(settings, (BarUiMsg_t const   )4, "Cannot fork eventcmd. (%s)\n", tmp___6);
  } else {
    songStation = (PianoStation_t *)((void *)0);
    close(pipeFd[0]);
    pipeWriteFd = fdopen(pipeFd[1], "w");
    if ((unsigned long )curSong != (unsigned long )((void *)0)) {
      if ((unsigned long )stations != (unsigned long )((void *)0)) {
        if ((unsigned long )curStation != (unsigned long )((void *)0)) {
          if (curStation->isQuickMix) {
            songStation = PianoFindStationById((PianoStation_t * const  )stations,
                                               (char const   * const  )curSong->stationId);
          }
        }
      }
    }
    pthread_mutex_lock(& player->lock);
    songDuration = player->songDuration;
    songPlayed = player->songPlayed;
    pthread_mutex_unlock(& player->lock);
    if ((unsigned long )curSong == (unsigned long )((void *)0)) {
      tmp___7 = (char const   * const  )"";
    } else {
      tmp___7 = (char const   * const  )curSong->detailUrl;
    }
    if ((unsigned long )curSong == (unsigned long )((void *)0)) {
      tmp___8 = (unsigned int const   )0;
    } else {
      tmp___8 = (unsigned int const   )curSong->rating;
    }
    tmp___9 = curl_easy_strerror(wRet);
    tmp___10 = PianoErrorToStr(pRet);
    if ((unsigned long )songStation == (unsigned long )((void *)0)) {
      tmp___11 = "";
    } else {
      tmp___11 = (char const   *)songStation->name;
    }
    if ((unsigned long )curStation == (unsigned long )((void *)0)) {
      tmp___12 = (char const   * const  )"";
    } else {
      tmp___12 = (char const   * const  )curStation->name;
    }
    if ((unsigned long )curSong == (unsigned long )((void *)0)) {
      tmp___13 = (char const   * const  )"";
    } else {
      tmp___13 = (char const   * const  )curSong->coverArt;
    }
    if ((unsigned long )curSong == (unsigned long )((void *)0)) {
      tmp___14 = (char const   * const  )"";
    } else {
      tmp___14 = (char const   * const  )curSong->album;
    }
    if ((unsigned long )curSong == (unsigned long )((void *)0)) {
      tmp___15 = (char const   * const  )"";
    } else {
      tmp___15 = (char const   * const  )curSong->title;
    }
    if ((unsigned long )curSong == (unsigned long )((void *)0)) {
      tmp___16 = (char const   * const  )"";
    } else {
      tmp___16 = (char const   * const  )curSong->artist;
    }
    fprintf((FILE * __restrict  )pipeWriteFd, (char const   * __restrict  )"artist=%s\ntitle=%s\nalbum=%s\ncoverArt=%s\nstationName=%s\nsongStationName=%s\npRet=%i\npRetStr=%s\nwRet=%i\nwRetStr=%s\nsongDuration=%u\nsongPlayed=%u\nrating=%i\ndetailUrl=%s\n",
            tmp___16, tmp___15, tmp___14, tmp___13, tmp___12, tmp___11, (unsigned int )pRet,
            tmp___10, (unsigned int )wRet, tmp___9, songDuration, songPlayed, tmp___8,
            tmp___7);
    if ((unsigned long )stations != (unsigned long )((void *)0)) {
      sortedStations = (PianoStation_t **)((void *)0);
      sortedStations = BarSortedStations(stations, & stationCount, (BarStationSorting_t )settings->sortOrder);
      fprintf((FILE * __restrict  )pipeWriteFd, (char const   * __restrict  )"stationCount=%zd\n",
              stationCount);
      i = (size_t )0;
      while (i < stationCount) {
        currStation = (PianoStation_t const   *)*(sortedStations + i);
        fprintf((FILE * __restrict  )pipeWriteFd, (char const   * __restrict  )"station%zd=%s\n",
                i, currStation->name);
        i ++;
      }
      free((void *)sortedStations);
    } else {
      msg = "stationCount=0\n";
      tmp___17 = strlen(msg);
      fwrite((void const   * __restrict  )msg, sizeof(*msg), tmp___17, (FILE * __restrict  )pipeWriteFd);
    }
    fclose(pipeWriteFd);
    waitpid(chld, & status, 0);
  }
  return;
}
}
void BarUiHistoryPrepend(BarApp_t *app___0 , PianoSong_t *song ) 
{ 
  PianoListHead_t *tmp ;
  void *tmp___0 ;
  PianoSong_t *del ;
  void *tmp___1 ;
  PianoListHead_t *tmp___2 ;
  void *tmp___3 ;

  {
  if (app___0->settings.history != 0U) {
    if ((unsigned long )app___0->songHistory == (unsigned long )((void *)0)) {
      tmp = (PianoListHead_t *)((void *)0);
    } else {
      tmp = & (app___0->songHistory)->head;
    }
    tmp___0 = PianoListPrepend((PianoListHead_t * const  )tmp, (PianoListHead_t * const  )(& song->head));
    app___0->songHistory = (PianoSong_t *)tmp___0;
    while (1) {
      tmp___1 = PianoListGet((PianoListHead_t * const  )(& (app___0->songHistory)->head),
                             (size_t const   )app___0->settings.history);
      del = (PianoSong_t *)tmp___1;
      if ((unsigned long )del != (unsigned long )((void *)0)) {
        if ((unsigned long )app___0->songHistory == (unsigned long )((void *)0)) {
          tmp___2 = (PianoListHead_t *)((void *)0);
        } else {
          tmp___2 = & (app___0->songHistory)->head;
        }
        tmp___3 = PianoListDelete((PianoListHead_t * const  )tmp___2, (PianoListHead_t * const  )(& del->head));
        app___0->songHistory = (PianoSong_t *)tmp___3;
        PianoDestroyPlaylist(del);
      } else {
        break;
      }
    }
  } else {
    PianoDestroyPlaylist(song);
  }
  return;
}
}
#pragma merger("0","/tmp/cil-9ugqDm8s.i","-O2")
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
static size_t BarReadlinePrevUtf8(char *ptr ) 
{ 
  size_t i ;

  {
  i = (size_t )0;
  while (1) {
    i ++;
    ptr --;
    if ((int )*ptr & (1 << 7)) {
      if (! (! ((int )*ptr & (1 << 6)))) {
        break;
      }
    } else {
      break;
    }
  }
  return (i);
}
}
size_t BarReadline(char *buf , size_t const   bufSize , char const   *mask , BarReadlineFds_t *input ,
                   BarReadlineFlags_t const   flags , int timeout ) 
{ 
  size_t bufLen ;
  unsigned char escapeState ;
  fd_set set ;
  _Bool echo ;
  _Bool done ;
  sig_atomic_t *prevInt ;
  sig_atomic_t localInt ;
  int curFd ;
  unsigned char chr ;
  struct timeval timeoutstruct ;
  struct timeval *tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  size_t moveSize ;
  size_t tmp___2 ;
  size_t moveSize___0 ;
  size_t tmp___3 ;
  char *tmp___4 ;

  {
  bufLen = (size_t )0;
  escapeState = (unsigned char)0;
  echo = (_Bool )(! ((unsigned int const   )flags & 2U));
  done = (_Bool)0;
  prevInt = interrupted;
  localInt = 0;
  if (! ((unsigned int const   )flags & 4U)) {
    interrupted = & localInt;
  }
  memset((void *)buf, 0, (size_t )bufSize);
  while (! done) {
    curFd = -1;
    memcpy((void * __restrict  )(& set), (void const   * __restrict  )(& input->set),
           sizeof(set));
    timeoutstruct.tv_sec = (__time_t )timeout;
    timeoutstruct.tv_usec = (__suseconds_t )0;
    if (timeout == -1) {
      tmp = (struct timeval *)((void *)0);
    } else {
      tmp = & timeoutstruct;
    }
    tmp___0 = select(input->maxfd, (fd_set * __restrict  )(& set), (fd_set * __restrict  )((void *)0),
                     (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )tmp);
    if (tmp___0 <= 0) {
      bufLen = (size_t )0;
      break;
    }
    if ((set.__fds_bits[input->fds[0] / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << input->fds[0] % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      curFd = input->fds[0];
    } else
    if (input->fds[1] != -1) {
      if ((set.__fds_bits[input->fds[1] / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << input->fds[1] % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        curFd = input->fds[1];
      }
    }
    tmp___1 = read(curFd, (void *)(& chr), sizeof(chr));
    if (tmp___1 <= 0L) {
      if (curFd == 0) {
        input->set.__fds_bits[curFd / (8 * (int )sizeof(__fd_mask ))] &= ~ ((__fd_mask )(1UL << curFd % (8 * (int )sizeof(__fd_mask ))));
      }
      continue;
    }
    switch ((int )chr) {
    case 10: 
    case 4: 
    done = (_Bool)1;
    break;
    case 21: 
    if (echo) {
      while (bufLen > 0UL) {
        tmp___2 = BarReadlinePrevUtf8(buf + bufLen);
        moveSize = tmp___2;
        fputs((char const   * __restrict  )"\033[D\033[K", (FILE * __restrict  )stdout);
        bufLen -= moveSize;
      }
      fflush(stdout);
    }
    bufLen = (size_t )0;
    break;
    case 27: 
    escapeState = (unsigned char)1;
    break;
    case 126: 
    break;
    case 127: 
    case 8: 
    if (bufLen > 0UL) {
      tmp___3 = BarReadlinePrevUtf8(buf + bufLen);
      moveSize___0 = tmp___3;
      memmove((void *)(buf + (bufLen - moveSize___0)), (void const   *)(buf + bufLen),
              moveSize___0);
      bufLen -= moveSize___0;
      if (echo) {
        fputs((char const   * __restrict  )"\033[D\033[K", (FILE * __restrict  )stdout);
        fflush(stdout);
      }
    }
    break;
    default: 
    if ((int )chr <= 31) {
      break;
    }
    if ((int )escapeState == 2) {
      escapeState = (unsigned char)0;
      break;
    }
    if ((int )escapeState == 1) {
      if ((int )chr == 91) {
        escapeState = (unsigned char)2;
        break;
      }
    }
    if ((unsigned long )mask != (unsigned long )((void *)0)) {
      tmp___4 = strchr(mask, (int )chr);
      if (! tmp___4) {
        break;
      }
    }
    if (bufLen < (size_t )(bufSize - 1UL)) {
      *(buf + bufLen) = (char )chr;
      bufLen ++;
      if (echo) {
        putchar((int )chr);
        fflush(stdout);
      }
      if (bufLen >= (size_t )(bufSize - 1UL)) {
        if ((unsigned int const   )flags & 1U) {
          done = (_Bool)1;
        }
      }
    }
    break;
    }
  }
  if (echo) {
    fputs((char const   * __restrict  )"\n", (FILE * __restrict  )stdout);
  }
  interrupted = prevInt;
  *(buf + bufLen) = (char )'\000';
  return (bufLen);
}
}
size_t BarReadlineStr(char *buf , size_t const   bufSize , BarReadlineFds_t *input ,
                      BarReadlineFlags_t const   flags ) 
{ 
  size_t tmp ;

  {
  tmp = BarReadline(buf, bufSize, (char const   *)((void *)0), input, flags, -1);
  return (tmp);
}
}
size_t BarReadlineInt(int *ret , BarReadlineFds_t *input ) 
{ 
  int rlRet ;
  char buf[16] ;
  size_t tmp ;

  {
  rlRet = 0;
  tmp = BarReadline(buf, (size_t const   )sizeof(buf), "0123456789", input, (BarReadlineFlags_t const   )0,
                    -1);
  rlRet = (int )tmp;
  *ret = atoi((char const   *)(buf));
  return ((size_t )rlRet);
}
}
_Bool BarReadlineYesNo(_Bool def , BarReadlineFds_t *input ) 
{ 
  char buf[2] ;

  {
  BarReadline(buf, (size_t const   )sizeof(buf), "yYnN", input, (BarReadlineFlags_t const   )1,
              -1);
  if ((int )buf[0] == 121) {
    return ((_Bool)1);
  } else
  if ((int )buf[0] == 89) {
    return ((_Bool)1);
  } else
  if ((int )def == 1) {
    if ((int )buf[0] == 0) {
      return ((_Bool)1);
    } else {
      return ((_Bool)0);
    }
  } else {
    return ((_Bool)0);
  }
}
}
#pragma merger("0","/tmp/cil-YEnVQXBr.i","-O2")
static BarUiDispatchAction_t const   dispatchActions___1[30]  = 
  {      {(char )'?', (BarUiDispatchContext_t )0, & BarUiActHelp, (char const   * const  )((void *)0),
      (char const   * const  )"act_help"}, 
        {(char )'+', (BarUiDispatchContext_t )4, & BarUiActLoveSong, (char const   * const  )"love song",
      (char const   * const  )"act_songlove"}, 
        {(char )'-', (BarUiDispatchContext_t )4, & BarUiActBanSong, (char const   * const  )"ban song",
      (char const   * const  )"act_songban"}, 
        {(char )'a', (BarUiDispatchContext_t )2, & BarUiActAddMusic, (char const   * const  )"add music to station",
      (char const   * const  )"act_stationaddmusic"}, 
        {(char )'c', (BarUiDispatchContext_t )1, & BarUiActCreateStation, (char const   * const  )"create new station",
      (char const   * const  )"act_stationcreate"}, 
        {(char )'d', (BarUiDispatchContext_t )2, & BarUiActDeleteStation, (char const   * const  )"delete station",
      (char const   * const  )"act_stationdelete"}, 
        {(char )'e', (BarUiDispatchContext_t )4, & BarUiActExplain, (char const   * const  )"explain why this song is played",
      (char const   * const  )"act_songexplain"}, 
        {(char )'g', (BarUiDispatchContext_t )1, & BarUiActStationFromGenre, (char const   * const  )"add genre station",
      (char const   * const  )"act_stationaddbygenre"}, 
        {(char )'h', (BarUiDispatchContext_t )1, & BarUiActHistory, (char const   * const  )"song history",
      (char const   * const  )"act_history"}, 
        {(char )'i', (BarUiDispatchContext_t )7, & BarUiActSongInfo, (char const   * const  )"print information about song/station",
      (char const   * const  )"act_songinfo"}, 
        {(char )'j', (BarUiDispatchContext_t )1, & BarUiActAddSharedStation, (char const   * const  )"add shared station",
      (char const   * const  )"act_addshared"}, 
        {(char )'n', (BarUiDispatchContext_t )3, & BarUiActSkipSong, (char const   * const  )"next song",
      (char const   * const  )"act_songnext"}, 
        {(char )'p', (BarUiDispatchContext_t )3, & BarUiActTogglePause, (char const   * const  )"pause/resume playback",
      (char const   * const  )"act_songpausetoggle"}, 
        {(char )'q', (BarUiDispatchContext_t )1, & BarUiActQuit, (char const   * const  )"quit",
      (char const   * const  )"act_quit"}, 
        {(char )'r', (BarUiDispatchContext_t )2, & BarUiActRenameStation, (char const   * const  )"rename station",
      (char const   * const  )"act_stationrename"}, 
        {(char )'s', (BarUiDispatchContext_t )1, & BarUiActSelectStation, (char const   * const  )"change station",
      (char const   * const  )"act_stationchange"}, 
        {(char )'t', (BarUiDispatchContext_t )4, & BarUiActTempBanSong, (char const   * const  )"tired (ban song for 1 month)",
      (char const   * const  )"act_songtired"}, 
        {(char )'u', (BarUiDispatchContext_t )3, & BarUiActPrintUpcoming, (char const   * const  )"upcoming songs",
      (char const   * const  )"act_upcoming"}, 
        {(char )'x', (BarUiDispatchContext_t )2, & BarUiActSelectQuickMix, (char const   * const  )"select quickmix stations",
      (char const   * const  )"act_stationselectquickmix"}, 
        {(char )'$', (BarUiDispatchContext_t )4, & BarUiActDebug, (char const   * const  )((void *)0),
      (char const   * const  )"act_debug"}, 
        {(char )'b', (BarUiDispatchContext_t )4, & BarUiActBookmark, (char const   * const  )"bookmark song/artist",
      (char const   * const  )"act_bookmark"}, 
        {(char )'(', (BarUiDispatchContext_t )1, & BarUiActVolDown, (char const   * const  )"decrease volume",
      (char const   * const  )"act_voldown"}, 
        {(char )')', (BarUiDispatchContext_t )1, & BarUiActVolUp, (char const   * const  )"increase volume",
      (char const   * const  )"act_volup"}, 
        {(char )'=', (BarUiDispatchContext_t )2, & BarUiActManageStation, (char const   * const  )"manage station seeds/feedback/mode",
      (char const   * const  )"act_managestation"}, 
        {(char )' ', (BarUiDispatchContext_t )3, & BarUiActTogglePause, (char const   * const  )((void *)0),
      (char const   * const  )"act_songpausetoggle2"}, 
        {(char )'v', (BarUiDispatchContext_t )4, & BarUiActCreateStationFromSong, (char const   * const  )"create new station from song or artist",
      (char const   * const  )"act_stationcreatefromsong"}, 
        {(char )'P', (BarUiDispatchContext_t )3, & BarUiActPlay, (char const   * const  )"resume playback",
      (char const   * const  )"act_songplay"}, 
        {(char )'S', (BarUiDispatchContext_t )3, & BarUiActPause, (char const   * const  )"pause playback",
      (char const   * const  )"act_songpause"}, 
        {(char )'^', (BarUiDispatchContext_t )1, & BarUiActVolReset, (char const   * const  )"reset volume",
      (char const   * const  )"act_volreset"}, 
        {(char )'!', (BarUiDispatchContext_t )1, & BarUiActSettings, (char const   * const  )"change settings",
      (char const   * const  )"act_settings"}};
BarKeyShortcutId_t BarUiDispatch(BarApp_t *app___0 , char const   key , PianoStation_t *selStation ,
                                 PianoSong_t *selSong , _Bool const   verbose , BarUiDispatchContext_t context ) 
{ 
  size_t i ;

  {
  if ((unsigned long )selStation != (unsigned long )((void *)0)) {
    context = (BarUiDispatchContext_t )((unsigned int )context | 2U);
  }
  if ((unsigned long )selSong != (unsigned long )((void *)0)) {
    context = (BarUiDispatchContext_t )((unsigned int )context | 4U);
  }
  i = (size_t )0;
  while (i < 30UL) {
    if ((int )app___0->settings.keys[i] != 0) {
      if ((int )app___0->settings.keys[i] == (int )key) {
        if (((unsigned int const   )dispatchActions___1[i].context & (unsigned int const   )context) == (unsigned int const   )dispatchActions___1[i].context) {
          (*(dispatchActions___1[i].function))(app___0, selStation, selSong, context);
          return ((BarKeyShortcutId_t )i);
        } else
        if (verbose) {
          if ((unsigned int const   )dispatchActions___1[i].context & 4U) {
            BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )4,
                     "No song playing.\n");
          } else
          if ((unsigned int const   )dispatchActions___1[i].context & 2U) {
            BarUiMsg((BarSettings_t const   *)(& app___0->settings), (BarUiMsg_t const   )4,
                     "No station selected.\n");
          }
          return ((BarKeyShortcutId_t )30);
        }
      }
    }
    i ++;
  }
  return ((BarKeyShortcutId_t )30);
}
}
#pragma merger("0","/tmp/cil-5xBKstWP.i","-O2")
extern gcry_error_t gcry_cipher_encrypt(gcry_cipher_hd_t h , void *out , size_t outsize ,
                                        void const   *in , size_t inlen ) ;
extern gcry_error_t gcry_cipher_decrypt(gcry_cipher_hd_t h , void *out , size_t outsize ,
                                        void const   *in , size_t inlen ) ;
char *PianoDecryptString(gcry_cipher_hd_t h , char const   * const  input , size_t * const  retSize ) ;
char *PianoEncryptString(gcry_cipher_hd_t h , char const   *s ) ;
char *PianoDecryptString(gcry_cipher_hd_t h , char const   * const  input , size_t * const  retSize ) 
{ 
  size_t inputLen ;
  size_t tmp ;
  gcry_error_t gret ;
  unsigned char *output ;
  size_t outputLen ;
  void *tmp___0 ;
  size_t i ;
  char hex[3] ;
  long tmp___1 ;

  {
  tmp = strlen((char const   *)input);
  inputLen = tmp;
  outputLen = inputLen / 2UL;
  tmp___0 = calloc(outputLen + 1UL, sizeof(*output));
  output = (unsigned char *)tmp___0;
  i = (size_t )0;
  while (i < outputLen) {
    memcpy((void * __restrict  )(hex), (void const   * __restrict  )(input + i * 2UL),
           (size_t )2);
    hex[2] = (char )'\000';
    tmp___1 = strtol((char const   * __restrict  )(hex), (char ** __restrict  )((void *)0),
                     16);
    *(output + i) = (unsigned char )tmp___1;
    i ++;
  }
  gret = gcry_cipher_decrypt(h, (void *)output, outputLen, (void const   *)((void *)0),
                             (size_t )0);
  if (gret) {
    free((void *)output);
    return ((char *)((void *)0));
  }
  *retSize = outputLen;
  return ((char *)output);
}
}
char *PianoEncryptString(gcry_cipher_hd_t h , char const   *s ) 
{ 
  unsigned char *paddedInput ;
  unsigned char *hexOutput ;
  size_t inputLen ;
  size_t tmp ;
  size_t paddedInputLen ;
  size_t tmp___0 ;
  gcry_error_t gret ;
  void *tmp___1 ;
  void *tmp___2 ;
  size_t i ;

  {
  tmp = strlen(s);
  inputLen = tmp;
  if (inputLen % 8UL == 0UL) {
    tmp___0 = inputLen;
  } else {
    tmp___0 = inputLen + (8UL - inputLen % 8UL);
  }
  paddedInputLen = tmp___0;
  tmp___1 = calloc(paddedInputLen + 1UL, sizeof(*paddedInput));
  paddedInput = (unsigned char *)tmp___1;
  memcpy((void * __restrict  )paddedInput, (void const   * __restrict  )s, inputLen);
  gret = gcry_cipher_encrypt(h, (void *)paddedInput, paddedInputLen, (void const   *)((void *)0),
                             (size_t )0);
  if (gret) {
    free((void *)paddedInput);
    return ((char *)((void *)0));
  }
  tmp___2 = calloc(paddedInputLen * 2UL + 1UL, sizeof(*hexOutput));
  hexOutput = (unsigned char *)tmp___2;
  i = (size_t )0;
  while (i < paddedInputLen) {
    snprintf((char * __restrict  )(hexOutput + i * 2UL), (size_t )3, (char const   * __restrict  )"%02x",
             (int )*(paddedInput + i));
    i ++;
  }
  free((void *)paddedInput);
  return ((char *)hexOutput);
}
}
#pragma merger("0","/tmp/cil-AcJWKnd9.i","-O2")
extern gcry_error_t gcry_cipher_open(gcry_cipher_hd_t *handle , int algo , int mode ,
                                     unsigned int flags ) ;
extern void gcry_cipher_close(gcry_cipher_hd_t h ) ;
extern gcry_error_t gcry_cipher_setkey(gcry_cipher_hd_t hd , void const   *key , size_t keylen ) ;
void PianoDestroyStation(PianoStation_t *station ) ;
void PianoDestroyUserInfo(PianoUserInfo_t *user ) ;
PianoReturn_t PianoInit(PianoHandle_t *ph , char const   *partnerUser , char const   *partnerPassword ,
                        char const   *device , char const   *inkey , char const   *outkey ) 
{ 
  gcry_error_t tmp ;
  size_t tmp___0 ;
  gcry_error_t tmp___1 ;
  gcry_error_t tmp___2 ;
  size_t tmp___3 ;
  gcry_error_t tmp___4 ;

  {
  memset((void *)ph, 0, sizeof(*ph));
  ph->partner.user = strdup(partnerUser);
  ph->partner.password = strdup(partnerPassword);
  ph->partner.device = strdup(device);
  tmp = gcry_cipher_open(& ph->partner.in, 4, 1, 0U);
  if (tmp != 0U) {
    return ((PianoReturn_t )7);
  }
  tmp___0 = strlen(inkey);
  tmp___1 = gcry_cipher_setkey(ph->partner.in, (void const   *)((unsigned char const   *)inkey),
                               tmp___0);
  if (tmp___1 != 0U) {
    return ((PianoReturn_t )7);
  }
  tmp___2 = gcry_cipher_open(& ph->partner.out, 4, 1, 0U);
  if (tmp___2 != 0U) {
    return ((PianoReturn_t )7);
  }
  tmp___3 = strlen(outkey);
  tmp___4 = gcry_cipher_setkey(ph->partner.out, (void const   *)((unsigned char const   *)outkey),
                               tmp___3);
  if (tmp___4 != 0U) {
    return ((PianoReturn_t )7);
  }
  return ((PianoReturn_t )1);
}
}
static void PianoDestroyArtists(PianoArtist_t *artists ) 
{ 
  PianoArtist_t *curArtist ;
  PianoArtist_t *lastArtist ;

  {
  curArtist = artists;
  while ((unsigned long )curArtist != (unsigned long )((void *)0)) {
    free((void *)curArtist->name);
    free((void *)curArtist->musicId);
    free((void *)curArtist->seedId);
    lastArtist = curArtist;
    curArtist = (PianoArtist_t *)curArtist->head.next;
    free((void *)lastArtist);
  }
  return;
}
}
void PianoDestroySearchResult(PianoSearchResult_t *searchResult ) 
{ 


  {
  PianoDestroyArtists(searchResult->artists);
  PianoDestroyPlaylist(searchResult->songs);
  return;
}
}
void PianoDestroyStation(PianoStation_t *station ) 
{ 


  {
  free((void *)station->name);
  free((void *)station->id);
  free((void *)station->seedId);
  memset((void *)station, 0, sizeof(*station));
  return;
}
}
static void PianoDestroyStations(PianoStation_t *stations ) 
{ 
  PianoStation_t *curStation ;
  PianoStation_t *lastStation ;

  {
  curStation = stations;
  while ((unsigned long )curStation != (unsigned long )((void *)0)) {
    lastStation = curStation;
    curStation = (PianoStation_t *)curStation->head.next;
    PianoDestroyStation(lastStation);
    free((void *)lastStation);
  }
  return;
}
}
void PianoDestroyPlaylist(PianoSong_t *playlist ) 
{ 
  PianoSong_t *curSong ;
  PianoSong_t *lastSong ;

  {
  curSong = playlist;
  while ((unsigned long )curSong != (unsigned long )((void *)0)) {
    free((void *)curSong->audioUrl);
    free((void *)curSong->coverArt);
    free((void *)curSong->artist);
    free((void *)curSong->musicId);
    free((void *)curSong->title);
    free((void *)curSong->stationId);
    free((void *)curSong->album);
    free((void *)curSong->feedbackId);
    free((void *)curSong->seedId);
    free((void *)curSong->detailUrl);
    free((void *)curSong->trackToken);
    lastSong = curSong;
    curSong = (PianoSong_t *)curSong->head.next;
    free((void *)lastSong);
  }
  return;
}
}
void PianoDestroyStationInfo(PianoStationInfo_t *info ) 
{ 


  {
  PianoDestroyPlaylist(info->feedback);
  PianoDestroyPlaylist(info->songSeeds);
  PianoDestroyArtists(info->artistSeeds);
  PianoDestroyStations(info->stationSeeds);
  return;
}
}
static void PianoDestroyGenres(PianoGenre_t *genres ) 
{ 
  PianoGenre_t *curGenre ;
  PianoGenre_t *lastGenre ;

  {
  curGenre = genres;
  while ((unsigned long )curGenre != (unsigned long )((void *)0)) {
    free((void *)curGenre->name);
    free((void *)curGenre->musicId);
    lastGenre = curGenre;
    curGenre = (PianoGenre_t *)curGenre->head.next;
    free((void *)lastGenre);
  }
  return;
}
}
void PianoDestroyUserInfo(PianoUserInfo_t *user ) 
{ 


  {
  free((void *)user->authToken);
  free((void *)user->listenerId);
  return;
}
}
static void PianoDestroyPartner(PianoPartner_t *partner ) 
{ 


  {
  free((void *)partner->user);
  free((void *)partner->password);
  free((void *)partner->device);
  free((void *)partner->authToken);
  gcry_cipher_close(partner->in);
  gcry_cipher_close(partner->out);
  memset((void *)partner, 0, sizeof(*partner));
  return;
}
}
void PianoDestroyStationMode(PianoStationMode_t * const  modes ) 
{ 
  PianoStationMode_t *curMode ;
  PianoStationMode_t *lastMode ;

  {
  curMode = (PianoStationMode_t *)modes;
  while ((unsigned long )curMode != (unsigned long )((void *)0)) {
    free((void *)curMode->name);
    free((void *)curMode->description);
    lastMode = curMode;
    curMode = (PianoStationMode_t *)curMode->head.next;
    free((void *)lastMode);
  }
  return;
}
}
void PianoDestroy(PianoHandle_t *ph ) 
{ 
  PianoGenreCategory_t *curGenreCat ;
  PianoGenreCategory_t *lastGenreCat ;

  {
  PianoDestroyUserInfo(& ph->user);
  PianoDestroyStations(ph->stations);
  PianoDestroyPartner(& ph->partner);
  curGenreCat = ph->genreStations;
  while ((unsigned long )curGenreCat != (unsigned long )((void *)0)) {
    PianoDestroyGenres(curGenreCat->genres);
    free((void *)curGenreCat->name);
    lastGenreCat = curGenreCat;
    curGenreCat = (PianoGenreCategory_t *)curGenreCat->head.next;
    free((void *)lastGenreCat);
  }
  memset((void *)ph, 0, sizeof(*ph));
  return;
}
}
void PianoDestroyRequest(PianoRequest_t *req ) 
{ 


  {
  free((void *)req->postData);
  memset((void *)req, 0, sizeof(*req));
  return;
}
}
PianoStation_t *PianoFindStationById(PianoStation_t * const  stations , char const   * const  searchStation ) 
{ 
  PianoStation_t *currStation ;
  int tmp ;

  {
  if ((unsigned long )searchStation == (unsigned long )((void *)0)) {
    return ((PianoStation_t *)((void *)0));
  }
  currStation = (PianoStation_t *)stations;
  while ((unsigned long )currStation != (unsigned long )((void *)0)) {
    tmp = strcmp((char const   *)currStation->id, (char const   *)searchStation);
    if (tmp == 0) {
      return (currStation);
    }
    currStation = (PianoStation_t *)((void *)currStation->head.next);
  }
  return ((PianoStation_t *)((void *)0));
}
}
char const   *PianoErrorToStr(PianoReturn_t ret ) 
{ 


  {
  switch ((unsigned int )ret) {
  case 1U: 
  return ("Everything is fine :)");
  break;
  case 0U: 
  return ("Unknown.");
  break;
  case 2U: 
  return ("Invalid response.");
  break;
  case 3U: ;
  return ("Fix your program.");
  break;
  case 4U: 
  return ("Out of memory.");
  break;
  case 5U: 
  return ("Wrong email address or password.");
  break;
  case 6U: 
  return ("Selected audio quality is not available.");
  break;
  case 7U: 
  return ("libgcrypt initialization failed.");
  break;
  case 1024U: 
  return ("Internal error.");
  break;
  case 2032U: 
  return ("Call not allowed.");
  break;
  case 2025U: 
  return ("Invalid auth token.");
  break;
  case 1025U: 
  return ("Maintenance mode.");
  break;
  case 2029U: 
  return ("Max number of stations reached.");
  break;
  case 2024U: 
  return ("Read only mode. Try again later.");
  break;
  case 2030U: 
  return ("Station does not exist.");
  break;
  case 2026U: 
  return ("Invalid partner login.");
  break;
  case 1036U: 
  return ("Pandora is not available in your country. Set up a control proxy (see manpage).");
  break;
  case 2034U: 
  return ("Invalid partner credentials.");
  break;
  case 2027U: 
  return ("Listener not authorized.");
  break;
  case 2063U: 
  return ("Access denied. Try again later.");
  break;
  default: 
  return ("No error message available.");
  break;
  }
  return ((char const   *)0);
}
}
#pragma merger("0","/tmp/cil-XlJmr5Xo.i","-O2")
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
extern char *curl_easy_escape(CURL *handle , char const   *string , int length ) ;
extern void curl_free(void *p ) ;
extern int json_object_put(struct json_object *obj ) ;
extern char const   *json_object_to_json_string(struct json_object *obj ) ;
extern struct json_object *json_object_new_object(void) ;
extern int json_object_object_add(struct json_object *obj , char const   *key , struct json_object *val ) ;
extern struct json_object *json_object_new_array(void) ;
extern int json_object_array_add(struct json_object *obj , struct json_object *val ) ;
extern struct json_object *json_object_new_boolean(json_bool b ) ;
extern struct json_object *json_object_new_int(int32_t i ) ;
extern struct json_object *json_object_new_string(char const   *s ) ;
PianoReturn_t PianoRequest(PianoHandle_t *ph , PianoRequest_t *req , PianoRequestType_t type ) 
{ 
  PianoReturn_t ret ;
  char const   *jsonSendBuf ;
  char const   *method ;
  json_object *j ;
  struct json_object *tmp ;
  time_t timestamp ;
  time_t tmp___0 ;
  _Bool encrypted ;
  PianoRequestDataLogin_t *logindata ;
  struct json_object *tmp___1 ;
  struct json_object *tmp___2 ;
  struct json_object *tmp___3 ;
  struct json_object *tmp___4 ;
  struct json_object *tmp___5 ;
  char *urlencAuthToken ;
  struct json_object *tmp___6 ;
  struct json_object *tmp___7 ;
  struct json_object *tmp___8 ;
  struct json_object *tmp___9 ;
  struct json_object *tmp___10 ;
  CURL *curl ;
  CURL *tmp___11 ;
  struct json_object *tmp___12 ;
  PianoRequestDataGetPlaylist_t *reqData ;
  struct json_object *tmp___13 ;
  struct json_object *tmp___14 ;
  PianoRequestDataAddFeedback_t *reqData___0 ;
  struct json_object *tmp___15 ;
  struct json_object *tmp___16 ;
  struct json_object *tmp___17 ;
  PianoRequestDataRenameStation_t *reqData___1 ;
  struct json_object *tmp___18 ;
  struct json_object *tmp___19 ;
  PianoStation_t *station ;
  struct json_object *tmp___20 ;
  PianoRequestDataSearch_t *reqData___2 ;
  struct json_object *tmp___21 ;
  PianoRequestDataCreateStation_t *reqData___3 ;
  struct json_object *tmp___22 ;
  struct json_object *tmp___23 ;
  struct json_object *tmp___24 ;
  struct json_object *tmp___25 ;
  PianoRequestDataAddSeed_t *reqData___4 ;
  struct json_object *tmp___26 ;
  struct json_object *tmp___27 ;
  PianoSong_t *song ;
  struct json_object *tmp___28 ;
  PianoStation_t *curStation ;
  json_object *a ;
  struct json_object *tmp___29 ;
  struct json_object *tmp___30 ;
  PianoStation_t *station___0 ;
  struct json_object *tmp___31 ;
  PianoRequestDataExplain_t *reqData___5 ;
  struct json_object *tmp___32 ;
  PianoSong_t *song___0 ;
  struct json_object *tmp___33 ;
  PianoSong_t *song___1 ;
  struct json_object *tmp___34 ;
  PianoRequestDataGetStationInfo_t *reqData___6 ;
  struct json_object *tmp___35 ;
  struct json_object *tmp___36 ;
  struct json_object *tmp___37 ;
  PianoRequestDataGetStationModes_t *reqData___7 ;
  PianoStation_t *station___1 ;
  struct json_object *tmp___38 ;
  PianoRequestDataSetStationMode_t *reqData___8 ;
  PianoStation_t *station___2 ;
  struct json_object *tmp___39 ;
  struct json_object *tmp___40 ;
  PianoSong_t *song___2 ;
  struct json_object *tmp___41 ;
  PianoRequestDataDeleteSeed_t *reqData___9 ;
  char *seedId ;
  struct json_object *tmp___42 ;
  PianoRequestDataChangeSettings_t *reqData___10 ;
  struct json_object *tmp___43 ;
  struct json_object *tmp___44 ;
  struct json_object *tmp___45 ;
  struct json_object *tmp___46 ;
  struct json_object *tmp___47 ;
  struct json_object *tmp___48 ;
  PianoRequestDataRateSong_t *reqData___11 ;
  PianoRequestDataAddFeedback_t transformedReqData ;
  char *urlencAuthToken___0 ;
  CURL *curl___0 ;
  CURL *tmp___49 ;
  struct json_object *tmp___50 ;
  struct json_object *tmp___51 ;
  char *tmp___52 ;

  {
  ret = (PianoReturn_t )1;
  method = (char const   *)((void *)0);
  tmp = json_object_new_object();
  j = tmp;
  tmp___0 = time((time_t *)((void *)0));
  timestamp = tmp___0 - (time_t )ph->timeOffset;
  encrypted = (_Bool)1;
  req->type = type;
  req->secure = (_Bool)0;
  switch ((unsigned int )req->type) {
  case 1U: 
  logindata = (PianoRequestDataLogin_t *)req->data;
  switch ((int )logindata->step) {
  case 0: 
  encrypted = (_Bool)0;
  req->secure = (_Bool)1;
  tmp___1 = json_object_new_string((char const   *)ph->partner.user);
  json_object_object_add(j, "username", tmp___1);
  tmp___2 = json_object_new_string((char const   *)ph->partner.password);
  json_object_object_add(j, "password", tmp___2);
  tmp___3 = json_object_new_string((char const   *)ph->partner.device);
  json_object_object_add(j, "deviceModel", tmp___3);
  tmp___4 = json_object_new_string("5");
  json_object_object_add(j, "version", tmp___4);
  tmp___5 = json_object_new_boolean(1);
  json_object_object_add(j, "includeUrls", tmp___5);
  snprintf((char * __restrict  )(req->urlPath), sizeof(req->urlPath), (char const   * __restrict  )"/services/json/?method=auth.partnerLogin");
  break;
  case 1: 
  req->secure = (_Bool)1;
  tmp___6 = json_object_new_string("user");
  json_object_object_add(j, "loginType", tmp___6);
  tmp___7 = json_object_new_string((char const   *)logindata->user);
  json_object_object_add(j, "username", tmp___7);
  tmp___8 = json_object_new_string((char const   *)logindata->password);
  json_object_object_add(j, "password", tmp___8);
  tmp___9 = json_object_new_string((char const   *)ph->partner.authToken);
  json_object_object_add(j, "partnerAuthToken", tmp___9);
  tmp___10 = json_object_new_int((int32_t )timestamp);
  json_object_object_add(j, "syncTime", tmp___10);
  tmp___11 = curl_easy_init();
  curl = tmp___11;
  urlencAuthToken = curl_easy_escape(curl, (char const   *)ph->partner.authToken,
                                     0);
  snprintf((char * __restrict  )(req->urlPath), sizeof(req->urlPath), (char const   * __restrict  )"/services/json/?method=auth.userLogin&auth_token=%s&partner_id=%i",
           urlencAuthToken, ph->partner.id);
  curl_free((void *)urlencAuthToken);
  curl_easy_cleanup(curl);
  break;
  }
  break;
  case 2U: 
  tmp___12 = json_object_new_boolean(1);
  json_object_object_add(j, "returnAllStations", tmp___12);
  method = "user.getStationList";
  break;
  case 3U: 
  reqData = (PianoRequestDataGetPlaylist_t *)req->data;
  req->secure = (_Bool)1;
  tmp___13 = json_object_new_string((char const   *)(reqData->station)->id);
  json_object_object_add(j, "stationToken", tmp___13);
  tmp___14 = json_object_new_boolean(1);
  json_object_object_add(j, "includeTrackLength", tmp___14);
  method = "station.getPlaylist";
  break;
  case 5U: 
  reqData___0 = (PianoRequestDataAddFeedback_t *)req->data;
  tmp___15 = json_object_new_string((char const   *)reqData___0->stationId);
  json_object_object_add(j, "stationToken", tmp___15);
  tmp___16 = json_object_new_string((char const   *)reqData___0->trackToken);
  json_object_object_add(j, "trackToken", tmp___16);
  tmp___17 = json_object_new_boolean((unsigned int )reqData___0->rating == 1U);
  json_object_object_add(j, "isPositive", tmp___17);
  method = "station.addFeedback";
  break;
  case 7U: 
  reqData___1 = (PianoRequestDataRenameStation_t *)req->data;
  tmp___18 = json_object_new_string((char const   *)(reqData___1->station)->id);
  json_object_object_add(j, "stationToken", tmp___18);
  tmp___19 = json_object_new_string((char const   *)reqData___1->newName);
  json_object_object_add(j, "stationName", tmp___19);
  method = "station.renameStation";
  break;
  case 8U: 
  station = (PianoStation_t *)req->data;
  tmp___20 = json_object_new_string((char const   *)station->id);
  json_object_object_add(j, "stationToken", tmp___20);
  method = "station.deleteStation";
  break;
  case 9U: 
  reqData___2 = (PianoRequestDataSearch_t *)req->data;
  tmp___21 = json_object_new_string((char const   *)reqData___2->searchStr);
  json_object_object_add(j, "searchText", tmp___21);
  method = "music.search";
  break;
  case 10U: 
  reqData___3 = (PianoRequestDataCreateStation_t *)req->data;
  if ((unsigned int )reqData___3->type == 0U) {
    tmp___22 = json_object_new_string((char const   *)reqData___3->token);
    json_object_object_add(j, "musicToken", tmp___22);
  } else {
    tmp___23 = json_object_new_string((char const   *)reqData___3->token);
    json_object_object_add(j, "trackToken", tmp___23);
    switch ((unsigned int )reqData___3->type) {
    case 1U: 
    tmp___24 = json_object_new_string("song");
    json_object_object_add(j, "musicType", tmp___24);
    break;
    case 2U: 
    tmp___25 = json_object_new_string("artist");
    json_object_object_add(j, "musicType", tmp___25);
    break;
    default: ;
    break;
    }
  }
  method = "station.createStation";
  break;
  case 11U: 
  reqData___4 = (PianoRequestDataAddSeed_t *)req->data;
  tmp___26 = json_object_new_string((char const   *)reqData___4->musicId);
  json_object_object_add(j, "musicToken", tmp___26);
  tmp___27 = json_object_new_string((char const   *)(reqData___4->station)->id);
  json_object_object_add(j, "stationToken", tmp___27);
  method = "station.addMusic";
  break;
  case 12U: 
  song = (PianoSong_t *)req->data;
  tmp___28 = json_object_new_string((char const   *)song->trackToken);
  json_object_object_add(j, "trackToken", tmp___28);
  method = "user.sleepSong";
  break;
  case 13U: 
  curStation = ph->stations;
  tmp___29 = json_object_new_array();
  a = tmp___29;
  while ((unsigned long )curStation != (unsigned long )((void *)0)) {
    if (curStation->useQuickMix) {
      if (! curStation->isQuickMix) {
        tmp___30 = json_object_new_string((char const   *)curStation->id);
        json_object_array_add(a, tmp___30);
      }
    }
    curStation = (PianoStation_t *)((void *)curStation->head.next);
  }
  json_object_object_add(j, "quickMixStationIds", a);
  method = "user.setQuickMix";
  break;
  case 14U: 
  method = "station.getGenreStations";
  break;
  case 15U: 
  station___0 = (PianoStation_t *)req->data;
  tmp___31 = json_object_new_string((char const   *)station___0->id);
  json_object_object_add(j, "stationToken", tmp___31);
  method = "station.transformSharedStation";
  break;
  case 16U: 
  reqData___5 = (PianoRequestDataExplain_t *)req->data;
  tmp___32 = json_object_new_string((char const   *)(reqData___5->song)->trackToken);
  json_object_object_add(j, "trackToken", tmp___32);
  method = "track.explainTrack";
  break;
  case 18U: 
  song___0 = (PianoSong_t *)req->data;
  tmp___33 = json_object_new_string((char const   *)song___0->trackToken);
  json_object_object_add(j, "trackToken", tmp___33);
  method = "bookmark.addSongBookmark";
  break;
  case 19U: 
  song___1 = (PianoSong_t *)req->data;
  tmp___34 = json_object_new_string((char const   *)song___1->trackToken);
  json_object_object_add(j, "trackToken", tmp___34);
  method = "bookmark.addArtistBookmark";
  break;
  case 20U: 
  reqData___6 = (PianoRequestDataGetStationInfo_t *)req->data;
  tmp___35 = json_object_new_string((char const   *)(reqData___6->station)->id);
  json_object_object_add(j, "stationToken", tmp___35);
  tmp___36 = json_object_new_boolean(1);
  json_object_object_add(j, "includeExtendedAttributes", tmp___36);
  tmp___37 = json_object_new_boolean(1);
  json_object_object_add(j, "includeExtraParams", tmp___37);
  method = "station.getStation";
  break;
  case 25U: 
  reqData___7 = (PianoRequestDataGetStationModes_t *)req->data;
  station___1 = reqData___7->station;
  tmp___38 = json_object_new_string((char const   *)station___1->id);
  json_object_object_add(j, "stationId", tmp___38);
  method = "interactiveradio.v1.getAvailableModesSimple";
  req->secure = (_Bool)1;
  break;
  case 26U: 
  reqData___8 = (PianoRequestDataSetStationMode_t *)req->data;
  station___2 = reqData___8->station;
  tmp___39 = json_object_new_string((char const   *)station___2->id);
  json_object_object_add(j, "stationId", tmp___39);
  tmp___40 = json_object_new_int((int32_t )reqData___8->id);
  json_object_object_add(j, "modeId", tmp___40);
  method = "interactiveradio.v1.setAndGetAvailableModes";
  req->secure = (_Bool)1;
  break;
  case 21U: 
  song___2 = (PianoSong_t *)req->data;
  tmp___41 = json_object_new_string((char const   *)song___2->feedbackId);
  json_object_object_add(j, "feedbackId", tmp___41);
  method = "station.deleteFeedback";
  break;
  case 22U: 
  reqData___9 = (PianoRequestDataDeleteSeed_t *)req->data;
  seedId = (char *)((void *)0);
  if ((unsigned long )reqData___9->song != (unsigned long )((void *)0)) {
    seedId = (reqData___9->song)->seedId;
  } else
  if ((unsigned long )reqData___9->artist != (unsigned long )((void *)0)) {
    seedId = (reqData___9->artist)->seedId;
  } else
  if ((unsigned long )reqData___9->station != (unsigned long )((void *)0)) {
    seedId = (reqData___9->station)->seedId;
  }
  tmp___42 = json_object_new_string((char const   *)seedId);
  json_object_object_add(j, "seedId", tmp___42);
  method = "station.deleteMusic";
  break;
  case 23U: 
  method = "user.getSettings";
  break;
  case 24U: 
  reqData___10 = (PianoRequestDataChangeSettings_t *)req->data;
  tmp___43 = json_object_new_boolean(1);
  json_object_object_add(j, "userInitiatedChange", tmp___43);
  tmp___44 = json_object_new_string((char const   *)reqData___10->currentUsername);
  json_object_object_add(j, "currentUsername", tmp___44);
  tmp___45 = json_object_new_string((char const   *)reqData___10->currentPassword);
  json_object_object_add(j, "currentPassword", tmp___45);
  if ((unsigned int )reqData___10->explicitContentFilter != 0U) {
    tmp___46 = json_object_new_boolean((unsigned int )reqData___10->explicitContentFilter == 2U);
    json_object_object_add(j, "isExplicitContentFilterEnabled", tmp___46);
  }
  if ((unsigned long )reqData___10->newUsername != (unsigned long )((void *)0)) {
    tmp___47 = json_object_new_string((char const   *)reqData___10->newUsername);
    json_object_object_add(j, "newUsername", tmp___47);
  }
  if ((unsigned long )reqData___10->newPassword != (unsigned long )((void *)0)) {
    tmp___48 = json_object_new_string((char const   *)reqData___10->newPassword);
    json_object_object_add(j, "newPassword", tmp___48);
  }
  req->secure = (_Bool)1;
  method = "user.changeSettings";
  break;
  case 4U: 
  reqData___11 = (PianoRequestDataRateSong_t *)req->data;
  transformedReqData.stationId = (reqData___11->song)->stationId;
  transformedReqData.trackToken = (reqData___11->song)->trackToken;
  transformedReqData.rating = reqData___11->rating;
  req->data = (void *)(& transformedReqData);
  ret = PianoRequest(ph, req, (PianoRequestType_t )5);
  req->type = (PianoRequestType_t )4;
  req->data = (void *)reqData___11;
  goto cleanup;
  break;
  }
  if ((unsigned long )method != (unsigned long )((void *)0)) {
    tmp___49 = curl_easy_init();
    curl___0 = tmp___49;
    urlencAuthToken___0 = curl_easy_escape(curl___0, (char const   *)ph->user.authToken,
                                           0);
    snprintf((char * __restrict  )(req->urlPath), sizeof(req->urlPath), (char const   * __restrict  )"/services/json/?method=%s&auth_token=%s&partner_id=%i&user_id=%s",
             method, urlencAuthToken___0, ph->partner.id, ph->user.listenerId);
    curl_free((void *)urlencAuthToken___0);
    curl_easy_cleanup(curl___0);
    tmp___50 = json_object_new_string((char const   *)ph->user.authToken);
    json_object_object_add(j, "userAuthToken", tmp___50);
    tmp___51 = json_object_new_int((int32_t )timestamp);
    json_object_object_add(j, "syncTime", tmp___51);
  }
  jsonSendBuf = json_object_to_json_string(j);
  if (encrypted) {
    tmp___52 = PianoEncryptString(ph->partner.out, jsonSendBuf);
    req->postData = tmp___52;
    if ((unsigned long )tmp___52 == (unsigned long )((void *)0)) {
      ret = (PianoReturn_t )4;
    }
  } else {
    req->postData = strdup(jsonSendBuf);
  }
  cleanup: 
  json_object_put(j);
  return (ret);
}
}
#pragma merger("0","/tmp/cil-nh3UrreE.i","-O2")
extern json_bool json_object_object_get_ex(struct json_object  const  *obj , char const   *key ,
                                           struct json_object **value ) ;
extern size_t json_object_array_length(struct json_object  const  *obj ) ;
extern struct json_object *json_object_array_get_idx(struct json_object  const  *obj ,
                                                     size_t idx ) ;
extern json_bool json_object_get_boolean(struct json_object  const  *obj ) ;
extern int32_t json_object_get_int(struct json_object  const  *obj ) ;
extern double json_object_get_double(struct json_object  const  *obj ) ;
extern char const   *json_object_get_string(struct json_object *obj ) ;
extern struct json_object *json_tokener_parse(char const   *str ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
void *( __attribute__((__warn_unused_result__)) PianoListAppend)(PianoListHead_t * const  l ,
                                                                 PianoListHead_t * const  e ) ;
static char *PianoJsonStrdup(json_object *j , char const   *key ) 
{ 
  json_object *v ;
  char const   *tmp ;
  char *tmp___0 ;
  json_bool tmp___1 ;

  {
  tmp___1 = json_object_object_get_ex((struct json_object  const  *)j, key, & v);
  if (tmp___1) {
    tmp = json_object_get_string(v);
    tmp___0 = strdup(tmp);
    return (tmp___0);
  } else {
    return ((char *)((void *)0));
  }
}
}
static _Bool getBoolDefault(json_object * const  j , char const   * const  key , _Bool const   def ) 
{ 
  json_object *v ;
  json_bool tmp ;
  json_bool tmp___0 ;

  {
  tmp___0 = json_object_object_get_ex((struct json_object  const  *)j, (char const   *)key,
                                      & v);
  if (tmp___0) {
    tmp = json_object_get_boolean((struct json_object  const  *)v);
    return ((_Bool )tmp);
  } else {
    return ((_Bool )def);
  }
}
}
static void PianoJsonParseStation(json_object *j , PianoStation_t *s ) 
{ 
  _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;

  {
  s->name = PianoJsonStrdup(j, "stationName");
  s->id = PianoJsonStrdup(j, "stationToken");
  tmp = getBoolDefault((json_object * const  )j, (char const   * const  )"isShared",
                       (_Bool const   )1);
  if (tmp) {
    tmp___0 = 0;
  } else {
    tmp___0 = 1;
  }
  s->isCreator = (char )tmp___0;
  tmp___1 = getBoolDefault((json_object * const  )j, (char const   * const  )"isQuickMix",
                           (_Bool const   )0);
  s->isQuickMix = (char )tmp___1;
  return;
}
}
static void PianoStrpcat(char * __restrict  dest , char const   * __restrict  src ,
                         size_t len ) 
{ 


  {
  while (1) {
    if ((int )*dest != 0) {
      if (! (len > 1UL)) {
        break;
      }
    } else {
      break;
    }
    dest ++;
    len --;
  }
  while (1) {
    if ((int const   )*src != 0) {
      if (! (len > 1UL)) {
        break;
      }
    } else {
      break;
    }
    *dest = (char )*src;
    dest ++;
    src ++;
    len --;
  }
  *dest = (char )'\000';
  return;
}
}
static char const   *qualityMap[4]  = {      "",      "lowQuality",      "mediumQuality",      "highQuality"};
static char const   *formatMap[3]  = {      "",      "aacplus",      "mp3"};
static char const   * const  keys[2]  = {      (char const   * const  )"thumbsUp",      (char const   * const  )"thumbsDown"};
PianoReturn_t PianoResponse(PianoHandle_t *ph , PianoRequest_t *req ) 
{ 
  PianoReturn_t ret ;
  json_object *j ;
  struct json_object *tmp ;
  json_object *status ;
  json_bool tmp___0 ;
  json_object *code ;
  int32_t tmp___1 ;
  PianoRequestDataLogin_t *reqData ;
  json_bool tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  json_object *result ;
  PianoRequestDataLogin_t *reqData___0 ;
  json_object *jsonTimestamp ;
  json_bool tmp___5 ;
  char const   *cryptedTimestamp ;
  char const   *tmp___6 ;
  time_t realTimestamp ;
  time_t tmp___7 ;
  char *decryptedTimestamp ;
  size_t decryptedSize ;
  unsigned long timestamp ;
  unsigned long tmp___8 ;
  json_object *partnerId ;
  json_bool tmp___9 ;
  int32_t tmp___10 ;
  json_object *stations ;
  json_object *mix ;
  json_bool tmp___11 ;
  int i ;
  PianoStation_t *tmpStation ;
  json_object *s ;
  struct json_object *tmp___12 ;
  void *tmp___13 ;
  PianoListHead_t *tmp___14 ;
  void *tmp___15 ;
  size_t tmp___16 ;
  PianoStation_t *curStation ;
  int i___0 ;
  json_object *id ;
  struct json_object *tmp___17 ;
  char const   *tmp___18 ;
  int tmp___19 ;
  size_t tmp___20 ;
  PianoRequestDataGetPlaylist_t *reqData___1 ;
  PianoSong_t *playlist ;
  json_object *items ;
  json_bool tmp___21 ;
  int i___1 ;
  json_object *s___0 ;
  struct json_object *tmp___22 ;
  PianoSong_t *song ;
  void *tmp___23 ;
  json_bool tmp___24 ;
  json_object *umap ;
  json_object *jsonEncoding ;
  json_object *qmap ;
  char const   *encoding ;
  char const   *tmp___25 ;
  size_t k ;
  int tmp___26 ;
  json_bool tmp___27 ;
  json_bool tmp___28 ;
  json_bool tmp___29 ;
  json_object *v ;
  double tmp___31 ;
  json_bool tmp___32 ;
  int32_t tmp___34 ;
  json_bool tmp___35 ;
  int32_t tmp___37 ;
  int32_t tmp___38 ;
  json_bool tmp___39 ;
  PianoListHead_t *tmp___40 ;
  void *tmp___41 ;
  size_t tmp___42 ;
  PianoRequestDataRateSong_t *reqData___2 ;
  PianoRequestDataRenameStation_t *reqData___3 ;
  PianoStation_t *station ;
  PianoListHead_t *tmp___43 ;
  void *tmp___44 ;
  PianoRequestDataSearch_t *reqData___4 ;
  PianoSearchResult_t *searchResult ;
  json_object *artists ;
  int i___2 ;
  json_object *a ;
  struct json_object *tmp___45 ;
  PianoArtist_t *artist ;
  void *tmp___46 ;
  PianoListHead_t *tmp___47 ;
  void *tmp___48 ;
  size_t tmp___49 ;
  json_bool tmp___50 ;
  json_object *songs ;
  int i___3 ;
  json_object *s___1 ;
  struct json_object *tmp___51 ;
  PianoSong_t *song___0 ;
  void *tmp___52 ;
  PianoListHead_t *tmp___53 ;
  void *tmp___54 ;
  size_t tmp___55 ;
  json_bool tmp___56 ;
  PianoStation_t *tmpStation___0 ;
  void *tmp___57 ;
  PianoStation_t *search ;
  PianoStation_t *tmp___58 ;
  PianoListHead_t *tmp___59 ;
  void *tmp___60 ;
  PianoListHead_t *tmp___61 ;
  void *tmp___62 ;
  PianoSong_t *song___1 ;
  json_object *categories ;
  int i___4 ;
  json_object *c ;
  struct json_object *tmp___63 ;
  PianoGenreCategory_t *tmpGenreCategory ;
  void *tmp___64 ;
  json_object *stations___0 ;
  int k___0 ;
  json_object *s___2 ;
  struct json_object *tmp___65 ;
  PianoGenre_t *tmpGenre ;
  void *tmp___66 ;
  PianoListHead_t *tmp___67 ;
  void *tmp___68 ;
  size_t tmp___69 ;
  json_bool tmp___70 ;
  PianoListHead_t *tmp___71 ;
  void *tmp___72 ;
  size_t tmp___73 ;
  json_bool tmp___74 ;
  PianoStation_t *station___0 ;
  PianoRequestDataExplain_t *reqData___5 ;
  size_t strSize ;
  json_object *explanations ;
  void *tmp___75 ;
  int i___5 ;
  json_object *e ;
  struct json_object *tmp___76 ;
  json_object *f ;
  json_bool tmp___77 ;
  char const   *s___3 ;
  char const   *tmp___78 ;
  size_t tmp___79 ;
  size_t tmp___80 ;
  size_t tmp___81 ;
  json_bool tmp___82 ;
  PianoSettings_t *settings ;
  PianoRequestDataGetStationInfo_t *reqData___6 ;
  PianoStationInfo_t *info ;
  json_object *music ;
  json_object *songs___0 ;
  int i___6 ;
  json_object *s___4 ;
  struct json_object *tmp___83 ;
  PianoSong_t *seedSong ;
  void *tmp___84 ;
  PianoListHead_t *tmp___85 ;
  void *tmp___86 ;
  size_t tmp___87 ;
  json_bool tmp___88 ;
  json_object *artists___0 ;
  int i___7 ;
  json_object *a___0 ;
  struct json_object *tmp___89 ;
  PianoArtist_t *seedArtist ;
  void *tmp___90 ;
  PianoListHead_t *tmp___91 ;
  void *tmp___92 ;
  size_t tmp___93 ;
  json_bool tmp___94 ;
  json_bool tmp___95 ;
  json_object *feedback ;
  size_t i___8 ;
  json_object *val ;
  json_bool tmp___96 ;
  int i___9 ;
  json_object *s___5 ;
  struct json_object *tmp___97 ;
  PianoSong_t *feedbackSong ;
  void *tmp___98 ;
  _Bool tmp___100 ;
  json_object *v___0 ;
  int32_t tmp___102 ;
  json_bool tmp___103 ;
  PianoListHead_t *tmp___104 ;
  void *tmp___105 ;
  size_t tmp___106 ;
  json_bool tmp___107 ;
  PianoRequestDataGetStationModes_t *reqData___7 ;
  int active ;
  json_object *activeMode ;
  json_bool tmp___108 ;
  json_object *availableModes ;
  int i___10 ;
  json_object *val___0 ;
  struct json_object *tmp___109 ;
  PianoStationMode_t *mode ;
  void *tmp___110 ;
  json_object *modeId ;
  json_bool tmp___111 ;
  PianoListHead_t *tmp___112 ;
  void *tmp___113 ;
  size_t tmp___114 ;
  json_bool tmp___115 ;
  PianoRequestDataSetStationMode_t *reqData___8 ;
  int active___0 ;
  json_object *activeMode___0 ;
  json_bool tmp___116 ;

  {
  ret = (PianoReturn_t )1;
  tmp = json_tokener_parse((char const   *)req->responseData);
  j = tmp;
  tmp___0 = json_object_object_get_ex((struct json_object  const  *)j, "stat", & status);
  if (! tmp___0) {
    ret = (PianoReturn_t )2;
    goto cleanup;
  }
  tmp___3 = json_object_get_string(status);
  tmp___4 = strcmp(tmp___3, "ok");
  if (tmp___4 != 0) {
    tmp___2 = json_object_object_get_ex((struct json_object  const  *)j, "code", & code);
    if (tmp___2) {
      tmp___1 = json_object_get_int((struct json_object  const  *)code);
      ret = (PianoReturn_t )(tmp___1 + 1024);
      if ((unsigned int )ret == 2026U) {
        if ((unsigned int )req->type == 1U) {
          reqData = (PianoRequestDataLogin_t *)req->data;
          if ((int )reqData->step == 1) {
            ret = (PianoReturn_t )5;
          }
        }
      }
    } else {
      ret = (PianoReturn_t )2;
    }
    goto cleanup;
  }
  result = (json_object *)((void *)0);
  json_object_object_get_ex((struct json_object  const  *)j, "result", & result);
  switch ((unsigned int )req->type) {
  case 1U: 
  reqData___0 = (PianoRequestDataLogin_t *)req->data;
  switch ((int )reqData___0->step) {
  case 0: 
  tmp___5 = json_object_object_get_ex((struct json_object  const  *)result, "syncTime",
                                      & jsonTimestamp);
  if (! tmp___5) {
    ret = (PianoReturn_t )2;
    break;
  }
  tmp___6 = json_object_get_string(jsonTimestamp);
  cryptedTimestamp = tmp___6;
  tmp___7 = time((time_t *)((void *)0));
  realTimestamp = tmp___7;
  decryptedTimestamp = (char *)((void *)0);
  ret = (PianoReturn_t )0;
  decryptedTimestamp = PianoDecryptString(ph->partner.in, (char const   * const  )cryptedTimestamp,
                                          (size_t * const  )(& decryptedSize));
  if ((unsigned long )decryptedTimestamp != (unsigned long )((void *)0)) {
    if (decryptedSize > 4UL) {
      tmp___8 = strtoul((char const   * __restrict  )(decryptedTimestamp + 4), (char ** __restrict  )((void *)0),
                        0);
      timestamp = tmp___8;
      ph->timeOffset = (int )(realTimestamp - (long )timestamp);
      ret = (PianoReturn_t )3;
    }
  }
  free((void *)decryptedTimestamp);
  ph->partner.authToken = PianoJsonStrdup(result, "partnerAuthToken");
  tmp___9 = json_object_object_get_ex((struct json_object  const  *)result, "partnerId",
                                      & partnerId);
  if (! tmp___9) {
    ret = (PianoReturn_t )2;
    break;
  }
  tmp___10 = json_object_get_int((struct json_object  const  *)partnerId);
  ph->partner.id = (unsigned int )tmp___10;
  reqData___0->step = (unsigned char )((int )reqData___0->step + 1);
  break;
  case 1: 
  if ((unsigned long )ph->user.listenerId != (unsigned long )((void *)0)) {
    PianoDestroyUserInfo(& ph->user);
  }
  ph->user.listenerId = PianoJsonStrdup(result, "userId");
  ph->user.authToken = PianoJsonStrdup(result, "userAuthToken");
  break;
  }
  break;
  case 2U: 
  mix = (json_object *)((void *)0);
  tmp___11 = json_object_object_get_ex((struct json_object  const  *)result, "stations",
                                       & stations);
  if (! tmp___11) {
    break;
  }
  i = 0;
  while (1) {
    tmp___16 = json_object_array_length((struct json_object  const  *)stations);
    if (! ((size_t )i < tmp___16)) {
      break;
    }
    tmp___12 = json_object_array_get_idx((struct json_object  const  *)stations, (size_t )i);
    s = tmp___12;
    tmp___13 = calloc((size_t )1, sizeof(*tmpStation));
    tmpStation = (PianoStation_t *)tmp___13;
    if ((unsigned long )tmpStation == (unsigned long )((void *)0)) {
      return ((PianoReturn_t )4);
    }
    PianoJsonParseStation(s, tmpStation);
    if (tmpStation->isQuickMix) {
      json_object_object_get_ex((struct json_object  const  *)s, "quickMixStationIds",
                                & mix);
    }
    if ((unsigned long )ph->stations == (unsigned long )((void *)0)) {
      tmp___14 = (PianoListHead_t *)((void *)0);
    } else {
      tmp___14 = & (ph->stations)->head;
    }
    tmp___15 = PianoListAppend((PianoListHead_t * const  )tmp___14, (PianoListHead_t * const  )(& tmpStation->head));
    ph->stations = (PianoStation_t *)tmp___15;
    i ++;
  }
  if ((unsigned long )mix != (unsigned long )((void *)0)) {
    curStation = ph->stations;
    while ((unsigned long )curStation != (unsigned long )((void *)0)) {
      i___0 = 0;
      while (1) {
        tmp___20 = json_object_array_length((struct json_object  const  *)mix);
        if (! ((size_t )i___0 < tmp___20)) {
          break;
        }
        tmp___17 = json_object_array_get_idx((struct json_object  const  *)mix, (size_t )i___0);
        id = tmp___17;
        tmp___18 = json_object_get_string(id);
        tmp___19 = strcmp(tmp___18, (char const   *)curStation->id);
        if (tmp___19 == 0) {
          curStation->useQuickMix = (char)1;
        }
        i___0 ++;
      }
      curStation = (PianoStation_t *)((void *)curStation->head.next);
    }
  }
  break;
  case 3U: 
  reqData___1 = (PianoRequestDataGetPlaylist_t *)req->data;
  playlist = (PianoSong_t *)((void *)0);
  items = (json_object *)((void *)0);
  tmp___21 = json_object_object_get_ex((struct json_object  const  *)result, "items",
                                       & items);
  if (! tmp___21) {
    break;
  }
  i___1 = 0;
  while (1) {
    tmp___42 = json_object_array_length((struct json_object  const  *)items);
    if (! ((size_t )i___1 < tmp___42)) {
      break;
    }
    tmp___22 = json_object_array_get_idx((struct json_object  const  *)items, (size_t )i___1);
    s___0 = tmp___22;
    tmp___23 = calloc((size_t )1, sizeof(*song));
    song = (PianoSong_t *)tmp___23;
    if ((unsigned long )song == (unsigned long )((void *)0)) {
      return ((PianoReturn_t )4);
    }
    tmp___24 = json_object_object_get_ex((struct json_object  const  *)s___0, "artistName",
                                         (struct json_object **)((void *)0));
    if (! tmp___24) {
      free((void *)song);
      goto __Cont;
    }
    tmp___29 = json_object_object_get_ex((struct json_object  const  *)s___0, "audioUrlMap",
                                         & umap);
    if (tmp___29) {
      tmp___27 = json_object_object_get_ex((struct json_object  const  *)umap, qualityMap[reqData___1->quality],
                                           & qmap);
      if (tmp___27) {
        tmp___28 = json_object_object_get_ex((struct json_object  const  *)qmap, "encoding",
                                             & jsonEncoding);
        if (tmp___28) {
          tmp___25 = json_object_get_string(jsonEncoding);
          encoding = tmp___25;
          k = (size_t )0;
          while (k < sizeof(formatMap) / sizeof(formatMap[0])) {
            tmp___26 = strcmp(formatMap[k], encoding);
            if (tmp___26 == 0) {
              song->audioFormat = (PianoAudioFormat_t )k;
              break;
            }
            k ++;
          }
          song->audioUrl = PianoJsonStrdup(qmap, "audioUrl");
        } else {
          ret = (PianoReturn_t )6;
          free((void *)song);
          PianoDestroyPlaylist(playlist);
          goto cleanup;
        }
      } else {
        ret = (PianoReturn_t )6;
        free((void *)song);
        PianoDestroyPlaylist(playlist);
        goto cleanup;
      }
    }
    song->artist = PianoJsonStrdup(s___0, "artistName");
    song->album = PianoJsonStrdup(s___0, "albumName");
    song->title = PianoJsonStrdup(s___0, "songName");
    song->trackToken = PianoJsonStrdup(s___0, "trackToken");
    song->stationId = PianoJsonStrdup(s___0, "stationId");
    song->coverArt = PianoJsonStrdup(s___0, "albumArtUrl");
    song->detailUrl = PianoJsonStrdup(s___0, "songDetailUrl");
    tmp___32 = json_object_object_get_ex((struct json_object  const  *)s___0, "trackGain",
                                         & v);
    if (tmp___32) {
      tmp___31 = json_object_get_double((struct json_object  const  *)v);
      song->fileGain = (float )tmp___31;
    } else {
      song->fileGain = (float )0.0;
    }
    tmp___35 = json_object_object_get_ex((struct json_object  const  *)s___0, "trackLength",
                                         & v);
    if (tmp___35) {
      tmp___34 = json_object_get_int((struct json_object  const  *)v);
      song->length = (unsigned int )tmp___34;
    } else {
      song->length = 0U;
    }
    tmp___39 = json_object_object_get_ex((struct json_object  const  *)s___0, "songRating",
                                         & v);
    if (tmp___39) {
      tmp___37 = json_object_get_int((struct json_object  const  *)v);
      tmp___38 = tmp___37;
    } else {
      tmp___38 = 0;
    }
    switch (tmp___38) {
    case 1: 
    song->rating = (PianoSongRating_t )1;
    break;
    }
    if ((unsigned long )playlist == (unsigned long )((void *)0)) {
      tmp___40 = (PianoListHead_t *)((void *)0);
    } else {
      tmp___40 = & playlist->head;
    }
    tmp___41 = PianoListAppend((PianoListHead_t * const  )tmp___40, (PianoListHead_t * const  )(& song->head));
    playlist = (PianoSong_t *)tmp___41;
    __Cont: /* CIL Label */ 
    i___1 ++;
  }
  reqData___1->retPlaylist = playlist;
  break;
  case 4U: 
  reqData___2 = (PianoRequestDataRateSong_t *)req->data;
  (reqData___2->song)->rating = reqData___2->rating;
  break;
  case 5U: ;
  break;
  case 7U: 
  reqData___3 = (PianoRequestDataRenameStation_t *)req->data;
  free((void *)(reqData___3->station)->name);
  (reqData___3->station)->name = strdup((char const   *)reqData___3->newName);
  break;
  case 8U: 
  station = (PianoStation_t *)req->data;
  if ((unsigned long )ph->stations == (unsigned long )((void *)0)) {
    tmp___43 = (PianoListHead_t *)((void *)0);
  } else {
    tmp___43 = & (ph->stations)->head;
  }
  tmp___44 = PianoListDelete((PianoListHead_t * const  )tmp___43, (PianoListHead_t * const  )(& station->head));
  ph->stations = (PianoStation_t *)tmp___44;
  PianoDestroyStation(station);
  free((void *)station);
  break;
  case 9U: 
  reqData___4 = (PianoRequestDataSearch_t *)req->data;
  searchResult = & reqData___4->searchResult;
  memset((void *)searchResult, 0, sizeof(*searchResult));
  tmp___50 = json_object_object_get_ex((struct json_object  const  *)result, "artists",
                                       & artists);
  if (tmp___50) {
    i___2 = 0;
    while (1) {
      tmp___49 = json_object_array_length((struct json_object  const  *)artists);
      if (! ((size_t )i___2 < tmp___49)) {
        break;
      }
      tmp___45 = json_object_array_get_idx((struct json_object  const  *)artists,
                                           (size_t )i___2);
      a = tmp___45;
      tmp___46 = calloc((size_t )1, sizeof(*artist));
      artist = (PianoArtist_t *)tmp___46;
      if ((unsigned long )artist == (unsigned long )((void *)0)) {
        return ((PianoReturn_t )4);
      }
      artist->name = PianoJsonStrdup(a, "artistName");
      artist->musicId = PianoJsonStrdup(a, "musicToken");
      if ((unsigned long )searchResult->artists == (unsigned long )((void *)0)) {
        tmp___47 = (PianoListHead_t *)((void *)0);
      } else {
        tmp___47 = & (searchResult->artists)->head;
      }
      tmp___48 = PianoListAppend((PianoListHead_t * const  )tmp___47, (PianoListHead_t * const  )(& artist->head));
      searchResult->artists = (PianoArtist_t *)tmp___48;
      i___2 ++;
    }
  }
  tmp___56 = json_object_object_get_ex((struct json_object  const  *)result, "songs",
                                       & songs);
  if (tmp___56) {
    i___3 = 0;
    while (1) {
      tmp___55 = json_object_array_length((struct json_object  const  *)songs);
      if (! ((size_t )i___3 < tmp___55)) {
        break;
      }
      tmp___51 = json_object_array_get_idx((struct json_object  const  *)songs, (size_t )i___3);
      s___1 = tmp___51;
      tmp___52 = calloc((size_t )1, sizeof(*song___0));
      song___0 = (PianoSong_t *)tmp___52;
      if ((unsigned long )song___0 == (unsigned long )((void *)0)) {
        return ((PianoReturn_t )4);
      }
      song___0->title = PianoJsonStrdup(s___1, "songName");
      song___0->artist = PianoJsonStrdup(s___1, "artistName");
      song___0->musicId = PianoJsonStrdup(s___1, "musicToken");
      if ((unsigned long )searchResult->songs == (unsigned long )((void *)0)) {
        tmp___53 = (PianoListHead_t *)((void *)0);
      } else {
        tmp___53 = & (searchResult->songs)->head;
      }
      tmp___54 = PianoListAppend((PianoListHead_t * const  )tmp___53, (PianoListHead_t * const  )(& song___0->head));
      searchResult->songs = (PianoSong_t *)tmp___54;
      i___3 ++;
    }
  }
  break;
  case 10U: 
  tmp___57 = calloc((size_t )1, sizeof(*tmpStation___0));
  tmpStation___0 = (PianoStation_t *)tmp___57;
  if ((unsigned long )tmpStation___0 == (unsigned long )((void *)0)) {
    return ((PianoReturn_t )4);
  }
  PianoJsonParseStation(result, tmpStation___0);
  tmp___58 = PianoFindStationById((PianoStation_t * const  )ph->stations, (char const   * const  )tmpStation___0->id);
  search = tmp___58;
  if ((unsigned long )search != (unsigned long )((void *)0)) {
    if ((unsigned long )ph->stations == (unsigned long )((void *)0)) {
      tmp___59 = (PianoListHead_t *)((void *)0);
    } else {
      tmp___59 = & (ph->stations)->head;
    }
    tmp___60 = PianoListDelete((PianoListHead_t * const  )tmp___59, (PianoListHead_t * const  )(& search->head));
    ph->stations = (PianoStation_t *)tmp___60;
    PianoDestroyStation(search);
    free((void *)search);
  }
  if ((unsigned long )ph->stations == (unsigned long )((void *)0)) {
    tmp___61 = (PianoListHead_t *)((void *)0);
  } else {
    tmp___61 = & (ph->stations)->head;
  }
  tmp___62 = PianoListAppend((PianoListHead_t * const  )tmp___61, (PianoListHead_t * const  )(& tmpStation___0->head));
  ph->stations = (PianoStation_t *)tmp___62;
  break;
  case 12U: 
  song___1 = (PianoSong_t *)req->data;
  song___1->rating = (PianoSongRating_t )3;
  break;
  case 24U: 
  case 22U: 
  case 21U: 
  case 19U: 
  case 18U: 
  case 13U: 
  case 11U: 
  break;
  case 14U: 
  tmp___74 = json_object_object_get_ex((struct json_object  const  *)result, "categories",
                                       & categories);
  if (tmp___74) {
    i___4 = 0;
    while (1) {
      tmp___73 = json_object_array_length((struct json_object  const  *)categories);
      if (! ((size_t )i___4 < tmp___73)) {
        break;
      }
      tmp___63 = json_object_array_get_idx((struct json_object  const  *)categories,
                                           (size_t )i___4);
      c = tmp___63;
      tmp___64 = calloc((size_t )1, sizeof(*tmpGenreCategory));
      tmpGenreCategory = (PianoGenreCategory_t *)tmp___64;
      if ((unsigned long )tmpGenreCategory == (unsigned long )((void *)0)) {
        return ((PianoReturn_t )4);
      }
      tmpGenreCategory->name = PianoJsonStrdup(c, "categoryName");
      tmp___70 = json_object_object_get_ex((struct json_object  const  *)c, "stations",
                                           & stations___0);
      if (tmp___70) {
        k___0 = 0;
        while (1) {
          tmp___69 = json_object_array_length((struct json_object  const  *)stations___0);
          if (! ((size_t )k___0 < tmp___69)) {
            break;
          }
          tmp___65 = json_object_array_get_idx((struct json_object  const  *)stations___0,
                                               (size_t )k___0);
          s___2 = tmp___65;
          tmp___66 = calloc((size_t )1, sizeof(*tmpGenre));
          tmpGenre = (PianoGenre_t *)tmp___66;
          if ((unsigned long )tmpGenre == (unsigned long )((void *)0)) {
            return ((PianoReturn_t )4);
          }
          tmpGenre->name = PianoJsonStrdup(s___2, "stationName");
          tmpGenre->musicId = PianoJsonStrdup(s___2, "stationToken");
          if ((unsigned long )tmpGenreCategory->genres == (unsigned long )((void *)0)) {
            tmp___67 = (PianoListHead_t *)((void *)0);
          } else {
            tmp___67 = & (tmpGenreCategory->genres)->head;
          }
          tmp___68 = PianoListAppend((PianoListHead_t * const  )tmp___67, (PianoListHead_t * const  )(& tmpGenre->head));
          tmpGenreCategory->genres = (PianoGenre_t *)tmp___68;
          k___0 ++;
        }
      }
      if ((unsigned long )ph->genreStations == (unsigned long )((void *)0)) {
        tmp___71 = (PianoListHead_t *)((void *)0);
      } else {
        tmp___71 = & (ph->genreStations)->head;
      }
      tmp___72 = PianoListAppend((PianoListHead_t * const  )tmp___71, (PianoListHead_t * const  )(& tmpGenreCategory->head));
      ph->genreStations = (PianoGenreCategory_t *)tmp___72;
      i___4 ++;
    }
  }
  break;
  case 15U: 
  station___0 = (PianoStation_t *)req->data;
  station___0->isCreator = (char)1;
  break;
  case 16U: 
  reqData___5 = (PianoRequestDataExplain_t *)req->data;
  strSize = (size_t )768;
  tmp___82 = json_object_object_get_ex((struct json_object  const  *)result, "explanations",
                                       & explanations);
  if (tmp___82) {
    tmp___75 = malloc(strSize * sizeof(*(reqData___5->retExplain)));
    reqData___5->retExplain = (char *)tmp___75;
    strncpy((char * __restrict  )reqData___5->retExplain, (char const   * __restrict  )"We\'re playing this track because it features ",
            strSize);
    i___5 = 0;
    while (1) {
      tmp___81 = json_object_array_length((struct json_object  const  *)explanations);
      if (! ((size_t )i___5 < tmp___81)) {
        break;
      }
      tmp___76 = json_object_array_get_idx((struct json_object  const  *)explanations,
                                           (size_t )i___5);
      e = tmp___76;
      tmp___77 = json_object_object_get_ex((struct json_object  const  *)e, "focusTraitName",
                                           & f);
      if (! tmp___77) {
        goto __Cont___0;
      }
      tmp___78 = json_object_get_string(f);
      s___3 = tmp___78;
      PianoStrpcat((char * __restrict  )reqData___5->retExplain, (char const   * __restrict  )s___3,
                   strSize);
      tmp___80 = json_object_array_length((struct json_object  const  *)explanations);
      if ((size_t )i___5 < tmp___80 - 2UL) {
        PianoStrpcat((char * __restrict  )reqData___5->retExplain, (char const   * __restrict  )", ",
                     strSize);
      } else {
        tmp___79 = json_object_array_length((struct json_object  const  *)explanations);
        if ((size_t )i___5 == tmp___79 - 2UL) {
          PianoStrpcat((char * __restrict  )reqData___5->retExplain, (char const   * __restrict  )" and ",
                       strSize);
        } else {
          PianoStrpcat((char * __restrict  )reqData___5->retExplain, (char const   * __restrict  )".",
                       strSize);
        }
      }
      __Cont___0: /* CIL Label */ 
      i___5 ++;
    }
  }
  break;
  case 23U: 
  settings = (PianoSettings_t *)req->data;
  settings->explicitContentFilter = getBoolDefault((json_object * const  )result,
                                                   (char const   * const  )"isExplicitContentFilterEnabled",
                                                   (_Bool const   )0);
  settings->username = PianoJsonStrdup(result, "username");
  break;
  case 20U: 
  reqData___6 = (PianoRequestDataGetStationInfo_t *)req->data;
  info = & reqData___6->info;
  tmp___95 = json_object_object_get_ex((struct json_object  const  *)result, "music",
                                       & music);
  if (tmp___95) {
    tmp___88 = json_object_object_get_ex((struct json_object  const  *)music, "songs",
                                         & songs___0);
    if (tmp___88) {
      i___6 = 0;
      while (1) {
        tmp___87 = json_object_array_length((struct json_object  const  *)songs___0);
        if (! ((size_t )i___6 < tmp___87)) {
          break;
        }
        tmp___83 = json_object_array_get_idx((struct json_object  const  *)songs___0,
                                             (size_t )i___6);
        s___4 = tmp___83;
        tmp___84 = calloc((size_t )1, sizeof(*seedSong));
        seedSong = (PianoSong_t *)tmp___84;
        if ((unsigned long )seedSong == (unsigned long )((void *)0)) {
          return ((PianoReturn_t )4);
        }
        seedSong->title = PianoJsonStrdup(s___4, "songName");
        seedSong->artist = PianoJsonStrdup(s___4, "artistName");
        seedSong->seedId = PianoJsonStrdup(s___4, "seedId");
        if ((unsigned long )info->songSeeds == (unsigned long )((void *)0)) {
          tmp___85 = (PianoListHead_t *)((void *)0);
        } else {
          tmp___85 = & (info->songSeeds)->head;
        }
        tmp___86 = PianoListAppend((PianoListHead_t * const  )tmp___85, (PianoListHead_t * const  )(& seedSong->head));
        info->songSeeds = (PianoSong_t *)tmp___86;
        i___6 ++;
      }
    }
    tmp___94 = json_object_object_get_ex((struct json_object  const  *)music, "artists",
                                         & artists___0);
    if (tmp___94) {
      i___7 = 0;
      while (1) {
        tmp___93 = json_object_array_length((struct json_object  const  *)artists___0);
        if (! ((size_t )i___7 < tmp___93)) {
          break;
        }
        tmp___89 = json_object_array_get_idx((struct json_object  const  *)artists___0,
                                             (size_t )i___7);
        a___0 = tmp___89;
        tmp___90 = calloc((size_t )1, sizeof(*seedArtist));
        seedArtist = (PianoArtist_t *)tmp___90;
        if ((unsigned long )seedArtist == (unsigned long )((void *)0)) {
          return ((PianoReturn_t )4);
        }
        seedArtist->name = PianoJsonStrdup(a___0, "artistName");
        seedArtist->seedId = PianoJsonStrdup(a___0, "seedId");
        if ((unsigned long )info->artistSeeds == (unsigned long )((void *)0)) {
          tmp___91 = (PianoListHead_t *)((void *)0);
        } else {
          tmp___91 = & (info->artistSeeds)->head;
        }
        tmp___92 = PianoListAppend((PianoListHead_t * const  )tmp___91, (PianoListHead_t * const  )(& seedArtist->head));
        info->artistSeeds = (PianoArtist_t *)tmp___92;
        i___7 ++;
      }
    }
  }
  tmp___107 = json_object_object_get_ex((struct json_object  const  *)result, "feedback",
                                        & feedback);
  if (tmp___107) {
    i___8 = (size_t )0;
    while (i___8 < sizeof(keys) / sizeof(keys[0])) {
      tmp___96 = json_object_object_get_ex((struct json_object  const  *)feedback,
                                           (char const   *)keys[i___8], & val);
      if (! tmp___96) {
        goto __Cont___1;
      }
      i___9 = 0;
      while (1) {
        tmp___106 = json_object_array_length((struct json_object  const  *)val);
        if (! ((size_t )i___9 < tmp___106)) {
          break;
        }
        tmp___97 = json_object_array_get_idx((struct json_object  const  *)val, (size_t )i___9);
        s___5 = tmp___97;
        tmp___98 = calloc((size_t )1, sizeof(*feedbackSong));
        feedbackSong = (PianoSong_t *)tmp___98;
        if ((unsigned long )feedbackSong == (unsigned long )((void *)0)) {
          return ((PianoReturn_t )4);
        }
        feedbackSong->title = PianoJsonStrdup(s___5, "songName");
        feedbackSong->artist = PianoJsonStrdup(s___5, "artistName");
        feedbackSong->feedbackId = PianoJsonStrdup(s___5, "feedbackId");
        tmp___100 = getBoolDefault((json_object * const  )s___5, (char const   * const  )"isPositive",
                                   (_Bool const   )0);
        if (tmp___100) {
          feedbackSong->rating = (PianoSongRating_t )1;
        } else {
          feedbackSong->rating = (PianoSongRating_t )2;
        }
        tmp___103 = json_object_object_get_ex((struct json_object  const  *)s___5,
                                              "trackLength", & v___0);
        if (tmp___103) {
          tmp___102 = json_object_get_int((struct json_object  const  *)v___0);
          feedbackSong->length = (unsigned int )tmp___102;
        } else {
          feedbackSong->length = 0U;
        }
        if ((unsigned long )info->feedback == (unsigned long )((void *)0)) {
          tmp___104 = (PianoListHead_t *)((void *)0);
        } else {
          tmp___104 = & (info->feedback)->head;
        }
        tmp___105 = PianoListAppend((PianoListHead_t * const  )tmp___104, (PianoListHead_t * const  )(& feedbackSong->head));
        info->feedback = (PianoSong_t *)tmp___105;
        i___9 ++;
      }
      __Cont___1: /* CIL Label */ 
      i___8 ++;
    }
  }
  break;
  case 25U: 
  reqData___7 = (PianoRequestDataGetStationModes_t *)req->data;
  active = -1;
  tmp___108 = json_object_object_get_ex((struct json_object  const  *)result, "currentModeId",
                                        & activeMode);
  if (tmp___108) {
    active = json_object_get_int((struct json_object  const  *)activeMode);
  }
  tmp___115 = json_object_object_get_ex((struct json_object  const  *)result, "availableModes",
                                        & availableModes);
  if (tmp___115) {
    i___10 = 0;
    while (1) {
      tmp___114 = json_object_array_length((struct json_object  const  *)availableModes);
      if (! ((size_t )i___10 < tmp___114)) {
        break;
      }
      tmp___109 = json_object_array_get_idx((struct json_object  const  *)availableModes,
                                            (size_t )i___10);
      val___0 = tmp___109;
      tmp___110 = calloc((size_t )1, sizeof(*mode));
      mode = (PianoStationMode_t *)tmp___110;
      if ((unsigned long )mode == (unsigned long )((void *)0)) {
        return ((PianoReturn_t )4);
      }
      tmp___111 = json_object_object_get_ex((struct json_object  const  *)val___0,
                                            "modeId", & modeId);
      if (tmp___111) {
        mode->id = json_object_get_int((struct json_object  const  *)modeId);
        mode->name = PianoJsonStrdup(val___0, "modeName");
        mode->description = PianoJsonStrdup(val___0, "modeDescription");
        mode->isAlgorithmic = getBoolDefault((json_object * const  )val___0, (char const   * const  )"isAlgorithmicMode",
                                             (_Bool const   )0);
        mode->isTakeover = getBoolDefault((json_object * const  )val___0, (char const   * const  )"isTakeoverMode",
                                          (_Bool const   )0);
        mode->active = (_Bool )(active == mode->id);
      }
      if ((unsigned long )reqData___7->retModes == (unsigned long )((void *)0)) {
        tmp___112 = (PianoListHead_t *)((void *)0);
      } else {
        tmp___112 = & (reqData___7->retModes)->head;
      }
      tmp___113 = PianoListAppend((PianoListHead_t * const  )tmp___112, (PianoListHead_t * const  )(& mode->head));
      reqData___7->retModes = (PianoStationMode_t *)tmp___113;
      i___10 ++;
    }
  }
  break;
  case 26U: 
  reqData___8 = (PianoRequestDataSetStationMode_t *)req->data;
  active___0 = -1;
  tmp___116 = json_object_object_get_ex((struct json_object  const  *)result, "currentModeId",
                                        & activeMode___0);
  if (tmp___116) {
    active___0 = json_object_get_int((struct json_object  const  *)activeMode___0);
  }
  if ((unsigned int )active___0 != reqData___8->id) {
    return ((PianoReturn_t )0);
  }
  break;
  }
  cleanup: 
  json_object_put(j);
  return (ret);
}
}
#pragma merger("0","/tmp/cil-kau0338T.i","-O2")
void *( __attribute__((__warn_unused_result__)) PianoListAppend)(PianoListHead_t * const  l ,
                                                                 PianoListHead_t * const  e ) 
{ 
  PianoListHead_t *curr ;

  {
  if ((unsigned long )l == (unsigned long )((void *)0)) {
    return ((void *)e);
  } else {
    curr = (PianoListHead_t *)l;
    while ((unsigned long )curr->next != (unsigned long )((void *)0)) {
      curr = curr->next;
    }
    curr->next = (struct PianoListHead *)e;
    return ((void *)l);
  }
}
}
void *( __attribute__((__warn_unused_result__)) PianoListPrepend)(PianoListHead_t * const  l ,
                                                                  PianoListHead_t * const  e ) 
{ 


  {
  e->next = (struct PianoListHead *)l;
  return ((void *)e);
}
}
void *( __attribute__((__warn_unused_result__)) PianoListDelete)(PianoListHead_t * const  l ,
                                                                 PianoListHead_t * const  e ) 
{ 
  PianoListHead_t *first ;
  PianoListHead_t *curr ;
  PianoListHead_t *prev ;

  {
  first = (PianoListHead_t *)l;
  curr = (PianoListHead_t *)l;
  prev = (PianoListHead_t *)((void *)0);
  while ((unsigned long )curr != (unsigned long )((void *)0)) {
    if ((unsigned long )curr == (unsigned long )e) {
      if ((unsigned long )prev != (unsigned long )((void *)0)) {
        prev->next = curr->next;
      } else {
        first = curr->next;
      }
      break;
    }
    prev = curr;
    curr = (PianoListHead_t *)((void *)curr->next);
  }
  return ((void *)first);
}
}
void *PianoListGet(PianoListHead_t * const  l , size_t const   n ) 
{ 
  PianoListHead_t *curr ;
  size_t i ;

  {
  curr = (PianoListHead_t *)l;
  i = (size_t )n;
  while ((unsigned long )curr != (unsigned long )((void *)0)) {
    if (i == 0UL) {
      return ((void *)curr);
    }
    i --;
    curr = (PianoListHead_t *)((void *)curr->next);
  }
  return ((void *)0);
}
}
size_t PianoListCount(PianoListHead_t const   * const  l ) 
{ 
  size_t count ;
  PianoListHead_t const   *curr ;

  {
  count = (size_t )0;
  curr = (PianoListHead_t const   *)l;
  while ((unsigned long )curr != (unsigned long )((void *)0)) {
    count ++;
    curr = (PianoListHead_t const   *)((void *)curr->next);
  }
  return (count);
}
}
