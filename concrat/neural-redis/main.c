/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long __int64_t;
typedef unsigned long __uint64_t;
typedef long __off_t;
typedef long __off64_t;
typedef long __time_t;
typedef long __suseconds_t;
typedef unsigned long size_t;
typedef __int64_t int64_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
typedef unsigned long pthread_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
typedef __builtin_va_list __gnuc_va_list;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef long long mstime_t;
struct RedisModuleCtx ;
typedef struct RedisModuleCtx RedisModuleCtx;
struct RedisModuleKey ;
typedef struct RedisModuleKey RedisModuleKey;
struct RedisModuleString ;
typedef struct RedisModuleString RedisModuleString;
struct RedisModuleCallReply ;
typedef struct RedisModuleCallReply RedisModuleCallReply;
struct RedisModuleIO ;
typedef struct RedisModuleIO RedisModuleIO;
struct RedisModuleType ;
typedef struct RedisModuleType RedisModuleType;
struct RedisModuleDigest ;
typedef struct RedisModuleDigest RedisModuleDigest;
struct RedisModuleBlockedClient ;
typedef struct RedisModuleBlockedClient RedisModuleBlockedClient;
struct RedisModuleTypeMethods {
   uint64_t version ;
   void *(*rdb_load)(RedisModuleIO *rdb , int encver ) ;
   void (*rdb_save)(RedisModuleIO *rdb , void *value ) ;
   void (*aof_rewrite)(RedisModuleIO *aof , RedisModuleString *key , void *value ) ;
   size_t (*mem_usage)(void *value ) ;
   void (*digest)(RedisModuleDigest *digest , void *value ) ;
   void (*free)(void *value ) ;
};
typedef struct RedisModuleTypeMethods RedisModuleTypeMethods;
struct AnnLayer {
   float *output ;
   float *error ;
   float *weight ;
   float *gradient ;
   float *sgradient ;
   float *pgradient ;
   float *delta ;
   int units ;
};
struct Ann {
   int flags ;
   int layers ;
   float rprop_nminus ;
   float rprop_nplus ;
   float rprop_maxupdate ;
   float rprop_minupdate ;
   float learn_rate ;
   float _filler_ ;
   struct AnnLayer *layer ;
};
struct NRDataset {
   uint32_t len ;
   uint32_t maxlen ;
   float *inputs ;
   float *outputs ;
};
typedef struct NRDataset NRDataset;
struct __anonstruct_NRTypeObject_124612850 {
   uint64_t id ;
   uint64_t training_total_steps ;
   uint64_t training_total_ms ;
   uint64_t training_max_cycles ;
   uint64_t training_max_ms ;
   uint32_t flags ;
   uint32_t epochs ;
   struct Ann *nn ;
   NRDataset dataset ;
   NRDataset test ;
   float dataset_error ;
   float test_error ;
   float test_class_error ;
   float *inorm ;
   float *onorm ;
};
typedef struct __anonstruct_NRTypeObject_124612850 NRTypeObject;
struct __anonstruct_NRPendingTraining_634934114 {
   RedisModuleString *key ;
   int db_id ;
   pthread_t tid ;
   int in_progress ;
   NRTypeObject *nr ;
   float dataset_error ;
   float test_error ;
   float class_error ;
   int curcycle ;
};
typedef struct __anonstruct_NRPendingTraining_634934114 NRPendingTraining;
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#pragma merger("0","/tmp/cil-29rlPXCa.i","-Wall,-W,-O3,-fno-common,-g,-ggdb,-std=c99,-fPIC")
extern FILE *stdin ;
extern FILE *stdout ;
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
extern int getc(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
extern int putc(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
extern int __uflow(FILE * ) ;
extern int __overflow(FILE * , int  ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) 
{ 
  int tmp ;

  {
  tmp = vfprintf((FILE * __restrict  )stdout, __fmt, __arg);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) 
{ 
  int tmp ;

  {
  tmp = getc(stdin);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(__fp);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = __fp->_IO_read_ptr;
    (__fp->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(stdin);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = stdin->_IO_read_ptr;
    (stdin->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) 
{ 
  int tmp ;

  {
  tmp = putc(__c, stdout);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = __stream->_IO_write_ptr;
    (__stream->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = stdout->_IO_write_ptr;
    (stdout->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 16) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 32) != 0);
}
}
void *(*RedisModule_Alloc)(size_t bytes )  ;
void *(*RedisModule_Realloc)(void *ptr , size_t bytes )  ;
void (*RedisModule_Free)(void *ptr )  ;
void *(*RedisModule_Calloc)(size_t nmemb , size_t size )  ;
char *(*RedisModule_Strdup)(char const   *str )  ;
int (*RedisModule_GetApi)(char const   * , void * )  ;
int (*RedisModule_CreateCommand)(RedisModuleCtx *ctx , char const   *name , int (*cmdfunc)(RedisModuleCtx *ctx ,
                                                                                           RedisModuleString **argv ,
                                                                                           int argc ) ,
                                 char const   *strflags , int firstkey , int lastkey ,
                                 int keystep )  ;
int (*RedisModule_SetModuleAttribs)(RedisModuleCtx *ctx , char const   *name , int ver ,
                                    int apiver )  ;
int (*RedisModule_WrongArity)(RedisModuleCtx *ctx )  ;
int (*RedisModule_ReplyWithLongLong)(RedisModuleCtx *ctx , long long ll )  ;
int (*RedisModule_GetSelectedDb)(RedisModuleCtx *ctx )  ;
int (*RedisModule_SelectDb)(RedisModuleCtx *ctx , int newid )  ;
void *(*RedisModule_OpenKey)(RedisModuleCtx *ctx , RedisModuleString *keyname , int mode )  ;
void (*RedisModule_CloseKey)(RedisModuleKey *kp )  ;
int (*RedisModule_KeyType)(RedisModuleKey *kp )  ;
size_t (*RedisModule_ValueLength)(RedisModuleKey *kp )  ;
int (*RedisModule_ListPush)(RedisModuleKey *kp , int where , RedisModuleString *ele )  ;
RedisModuleString *(*RedisModule_ListPop)(RedisModuleKey *key , int where )  ;
RedisModuleCallReply *(*RedisModule_Call)(RedisModuleCtx *ctx , char const   *cmdname ,
                                          char const   *fmt  , ...)  ;
char const   *(*RedisModule_CallReplyProto)(RedisModuleCallReply *reply , size_t *len )  ;
void (*RedisModule_FreeCallReply)(RedisModuleCallReply *reply )  ;
int (*RedisModule_CallReplyType)(RedisModuleCallReply *reply )  ;
long long (*RedisModule_CallReplyInteger)(RedisModuleCallReply *reply )  ;
size_t (*RedisModule_CallReplyLength)(RedisModuleCallReply *reply )  ;
RedisModuleCallReply *(*RedisModule_CallReplyArrayElement)(RedisModuleCallReply *reply ,
                                                           size_t idx )  ;
RedisModuleString *(*RedisModule_CreateString)(RedisModuleCtx *ctx , char const   *ptr ,
                                               size_t len )  ;
RedisModuleString *(*RedisModule_CreateStringFromLongLong)(RedisModuleCtx *ctx , long long ll )  ;
RedisModuleString *(*RedisModule_CreateStringFromString)(RedisModuleCtx *ctx , RedisModuleString const   *str )  ;
RedisModuleString *(*RedisModule_CreateStringPrintf)(RedisModuleCtx *ctx , char const   *fmt 
                                                     , ...)  ;
void (*RedisModule_FreeString)(RedisModuleCtx *ctx , RedisModuleString *str )  ;
char const   *(*RedisModule_StringPtrLen)(RedisModuleString const   *str , size_t *len )  ;
int (*RedisModule_ReplyWithError)(RedisModuleCtx *ctx , char const   *err )  ;
int (*RedisModule_ReplyWithSimpleString)(RedisModuleCtx *ctx , char const   *msg )  ;
int (*RedisModule_ReplyWithArray)(RedisModuleCtx *ctx , long len )  ;
void (*RedisModule_ReplySetArrayLength)(RedisModuleCtx *ctx , long len )  ;
int (*RedisModule_ReplyWithStringBuffer)(RedisModuleCtx *ctx , char const   *buf ,
                                         size_t len )  ;
int (*RedisModule_ReplyWithString)(RedisModuleCtx *ctx , RedisModuleString *str )  ;
int (*RedisModule_ReplyWithNull)(RedisModuleCtx *ctx )  ;
int (*RedisModule_ReplyWithDouble)(RedisModuleCtx *ctx , double d )  ;
int (*RedisModule_ReplyWithCallReply)(RedisModuleCtx *ctx , RedisModuleCallReply *reply )  ;
int (*RedisModule_StringToLongLong)(RedisModuleString const   *str , long long *ll )  ;
int (*RedisModule_StringToDouble)(RedisModuleString const   *str , double *d )  ;
void (*RedisModule_AutoMemory)(RedisModuleCtx *ctx )  ;
int (*RedisModule_Replicate)(RedisModuleCtx *ctx , char const   *cmdname , char const   *fmt 
                             , ...)  ;
int (*RedisModule_ReplicateVerbatim)(RedisModuleCtx *ctx )  ;
char const   *(*RedisModule_CallReplyStringPtr)(RedisModuleCallReply *reply , size_t *len )  ;
RedisModuleString *(*RedisModule_CreateStringFromCallReply)(RedisModuleCallReply *reply )  ;
int (*RedisModule_DeleteKey)(RedisModuleKey *key )  ;
int (*RedisModule_StringSet)(RedisModuleKey *key , RedisModuleString *str )  ;
char *(*RedisModule_StringDMA)(RedisModuleKey *key , size_t *len , int mode )  ;
int (*RedisModule_StringTruncate)(RedisModuleKey *key , size_t newlen )  ;
mstime_t (*RedisModule_GetExpire)(RedisModuleKey *key )  ;
int (*RedisModule_SetExpire)(RedisModuleKey *key , mstime_t expire )  ;
int (*RedisModule_ZsetAdd)(RedisModuleKey *key , double score , RedisModuleString *ele ,
                           int *flagsptr )  ;
int (*RedisModule_ZsetIncrby)(RedisModuleKey *key , double score , RedisModuleString *ele ,
                              int *flagsptr , double *newscore )  ;
int (*RedisModule_ZsetScore)(RedisModuleKey *key , RedisModuleString *ele , double *score )  ;
int (*RedisModule_ZsetRem)(RedisModuleKey *key , RedisModuleString *ele , int *deleted )  ;
void (*RedisModule_ZsetRangeStop)(RedisModuleKey *key )  ;
int (*RedisModule_ZsetFirstInScoreRange)(RedisModuleKey *key , double min , double max ,
                                         int minex , int maxex )  ;
int (*RedisModule_ZsetLastInScoreRange)(RedisModuleKey *key , double min , double max ,
                                        int minex , int maxex )  ;
int (*RedisModule_ZsetFirstInLexRange)(RedisModuleKey *key , RedisModuleString *min ,
                                       RedisModuleString *max )  ;
int (*RedisModule_ZsetLastInLexRange)(RedisModuleKey *key , RedisModuleString *min ,
                                      RedisModuleString *max )  ;
RedisModuleString *(*RedisModule_ZsetRangeCurrentElement)(RedisModuleKey *key , double *score )  ;
int (*RedisModule_ZsetRangeNext)(RedisModuleKey *key )  ;
int (*RedisModule_ZsetRangePrev)(RedisModuleKey *key )  ;
int (*RedisModule_ZsetRangeEndReached)(RedisModuleKey *key )  ;
int (*RedisModule_HashSet)(RedisModuleKey *key , int flags  , ...)  ;
int (*RedisModule_HashGet)(RedisModuleKey *key , int flags  , ...)  ;
int (*RedisModule_IsKeysPositionRequest)(RedisModuleCtx *ctx )  ;
void (*RedisModule_KeyAtPos)(RedisModuleCtx *ctx , int pos )  ;
unsigned long long (*RedisModule_GetClientId)(RedisModuleCtx *ctx )  ;
void *(*RedisModule_PoolAlloc)(RedisModuleCtx *ctx , size_t bytes )  ;
RedisModuleType *(*RedisModule_CreateDataType)(RedisModuleCtx *ctx , char const   *name ,
                                               int encver , RedisModuleTypeMethods *typemethods )  ;
int (*RedisModule_ModuleTypeSetValue)(RedisModuleKey *key , RedisModuleType *mt ,
                                      void *value )  ;
RedisModuleType *(*RedisModule_ModuleTypeGetType)(RedisModuleKey *key )  ;
void *(*RedisModule_ModuleTypeGetValue)(RedisModuleKey *key )  ;
void (*RedisModule_SaveUnsigned)(RedisModuleIO *io , uint64_t value )  ;
uint64_t (*RedisModule_LoadUnsigned)(RedisModuleIO *io )  ;
void (*RedisModule_SaveSigned)(RedisModuleIO *io , int64_t value )  ;
int64_t (*RedisModule_LoadSigned)(RedisModuleIO *io )  ;
void (*RedisModule_EmitAOF)(RedisModuleIO *io , char const   *cmdname , char const   *fmt 
                            , ...)  ;
void (*RedisModule_SaveString)(RedisModuleIO *io , RedisModuleString *s )  ;
void (*RedisModule_SaveStringBuffer)(RedisModuleIO *io , char const   *str , size_t len )  ;
RedisModuleString *(*RedisModule_LoadString)(RedisModuleIO *io )  ;
char *(*RedisModule_LoadStringBuffer)(RedisModuleIO *io , size_t *lenptr )  ;
void (*RedisModule_SaveDouble)(RedisModuleIO *io , double value )  ;
double (*RedisModule_LoadDouble)(RedisModuleIO *io )  ;
void (*RedisModule_SaveFloat)(RedisModuleIO *io , float value )  ;
float (*RedisModule_LoadFloat)(RedisModuleIO *io )  ;
void (*RedisModule_Log)(RedisModuleCtx *ctx , char const   *level , char const   *fmt 
                        , ...)  ;
void (*RedisModule_LogIOError)(RedisModuleIO *io , char const   *levelstr , char const   *fmt 
                               , ...)  ;
int (*RedisModule_StringAppendBuffer)(RedisModuleCtx *ctx , RedisModuleString *str ,
                                      char const   *buf , size_t len )  ;
void (*RedisModule_RetainString)(RedisModuleCtx *ctx , RedisModuleString *str )  ;
int (*RedisModule_StringCompare)(RedisModuleString *a , RedisModuleString *b )  ;
RedisModuleCtx *(*RedisModule_GetContextFromIO)(RedisModuleIO *io )  ;
RedisModuleBlockedClient *(*RedisModule_BlockClient)(RedisModuleCtx *ctx , int (*reply_callback)(RedisModuleCtx *ctx ,
                                                                                                 RedisModuleString **argv ,
                                                                                                 int argc ) ,
                                                     int (*timeout_callback)(RedisModuleCtx *ctx ,
                                                                             RedisModuleString **argv ,
                                                                             int argc ) ,
                                                     void (*free_privdata)(void * ) ,
                                                     long long timeout_ms )  ;
int (*RedisModule_UnblockClient)(RedisModuleBlockedClient *bc , void *privdata )  ;
int (*RedisModule_IsBlockedReplyRequest)(RedisModuleCtx *ctx )  ;
int (*RedisModule_IsBlockedTimeoutRequest)(RedisModuleCtx *ctx )  ;
void *(*RedisModule_GetBlockedClientPrivateData)(RedisModuleCtx *ctx )  ;
int (*RedisModule_AbortBlock)(RedisModuleBlockedClient *bc )  ;
long long (*RedisModule_Milliseconds)(void)  ;
static int RedisModule_Init(RedisModuleCtx *ctx , char const   *name , int ver , int apiver )  __attribute__((__unused__)) ;
static int RedisModule_Init(RedisModuleCtx *ctx , char const   *name , int ver , int apiver )  __attribute__((__unused__)) ;
static int RedisModule_Init(RedisModuleCtx *ctx , char const   *name , int ver , int apiver ) 
{ 
  void *getapifuncptr ;

  {
  getapifuncptr = *((void **)ctx + 0);
  RedisModule_GetApi = (int (*)(char const   * , void * ))((unsigned long )getapifuncptr);
  (*RedisModule_GetApi)("RedisModule_Alloc", (void *)((void **)(& RedisModule_Alloc)));
  (*RedisModule_GetApi)("RedisModule_Calloc", (void *)((void **)(& RedisModule_Calloc)));
  (*RedisModule_GetApi)("RedisModule_Free", (void *)((void **)(& RedisModule_Free)));
  (*RedisModule_GetApi)("RedisModule_Realloc", (void *)((void **)(& RedisModule_Realloc)));
  (*RedisModule_GetApi)("RedisModule_Strdup", (void *)((void **)(& RedisModule_Strdup)));
  (*RedisModule_GetApi)("RedisModule_CreateCommand", (void *)((void **)(& RedisModule_CreateCommand)));
  (*RedisModule_GetApi)("RedisModule_SetModuleAttribs", (void *)((void **)(& RedisModule_SetModuleAttribs)));
  (*RedisModule_GetApi)("RedisModule_WrongArity", (void *)((void **)(& RedisModule_WrongArity)));
  (*RedisModule_GetApi)("RedisModule_ReplyWithLongLong", (void *)((void **)(& RedisModule_ReplyWithLongLong)));
  (*RedisModule_GetApi)("RedisModule_ReplyWithError", (void *)((void **)(& RedisModule_ReplyWithError)));
  (*RedisModule_GetApi)("RedisModule_ReplyWithSimpleString", (void *)((void **)(& RedisModule_ReplyWithSimpleString)));
  (*RedisModule_GetApi)("RedisModule_ReplyWithArray", (void *)((void **)(& RedisModule_ReplyWithArray)));
  (*RedisModule_GetApi)("RedisModule_ReplySetArrayLength", (void *)((void **)(& RedisModule_ReplySetArrayLength)));
  (*RedisModule_GetApi)("RedisModule_ReplyWithStringBuffer", (void *)((void **)(& RedisModule_ReplyWithStringBuffer)));
  (*RedisModule_GetApi)("RedisModule_ReplyWithString", (void *)((void **)(& RedisModule_ReplyWithString)));
  (*RedisModule_GetApi)("RedisModule_ReplyWithNull", (void *)((void **)(& RedisModule_ReplyWithNull)));
  (*RedisModule_GetApi)("RedisModule_ReplyWithCallReply", (void *)((void **)(& RedisModule_ReplyWithCallReply)));
  (*RedisModule_GetApi)("RedisModule_ReplyWithDouble", (void *)((void **)(& RedisModule_ReplyWithDouble)));
  (*RedisModule_GetApi)("RedisModule_ReplySetArrayLength", (void *)((void **)(& RedisModule_ReplySetArrayLength)));
  (*RedisModule_GetApi)("RedisModule_GetSelectedDb", (void *)((void **)(& RedisModule_GetSelectedDb)));
  (*RedisModule_GetApi)("RedisModule_SelectDb", (void *)((void **)(& RedisModule_SelectDb)));
  (*RedisModule_GetApi)("RedisModule_OpenKey", (void *)((void **)(& RedisModule_OpenKey)));
  (*RedisModule_GetApi)("RedisModule_CloseKey", (void *)((void **)(& RedisModule_CloseKey)));
  (*RedisModule_GetApi)("RedisModule_KeyType", (void *)((void **)(& RedisModule_KeyType)));
  (*RedisModule_GetApi)("RedisModule_ValueLength", (void *)((void **)(& RedisModule_ValueLength)));
  (*RedisModule_GetApi)("RedisModule_ListPush", (void *)((void **)(& RedisModule_ListPush)));
  (*RedisModule_GetApi)("RedisModule_ListPop", (void *)((void **)(& RedisModule_ListPop)));
  (*RedisModule_GetApi)("RedisModule_StringToLongLong", (void *)((void **)(& RedisModule_StringToLongLong)));
  (*RedisModule_GetApi)("RedisModule_StringToDouble", (void *)((void **)(& RedisModule_StringToDouble)));
  (*RedisModule_GetApi)("RedisModule_Call", (void *)((void **)(& RedisModule_Call)));
  (*RedisModule_GetApi)("RedisModule_CallReplyProto", (void *)((void **)(& RedisModule_CallReplyProto)));
  (*RedisModule_GetApi)("RedisModule_FreeCallReply", (void *)((void **)(& RedisModule_FreeCallReply)));
  (*RedisModule_GetApi)("RedisModule_CallReplyInteger", (void *)((void **)(& RedisModule_CallReplyInteger)));
  (*RedisModule_GetApi)("RedisModule_CallReplyType", (void *)((void **)(& RedisModule_CallReplyType)));
  (*RedisModule_GetApi)("RedisModule_CallReplyLength", (void *)((void **)(& RedisModule_CallReplyLength)));
  (*RedisModule_GetApi)("RedisModule_CallReplyArrayElement", (void *)((void **)(& RedisModule_CallReplyArrayElement)));
  (*RedisModule_GetApi)("RedisModule_CallReplyStringPtr", (void *)((void **)(& RedisModule_CallReplyStringPtr)));
  (*RedisModule_GetApi)("RedisModule_CreateStringFromCallReply", (void *)((void **)(& RedisModule_CreateStringFromCallReply)));
  (*RedisModule_GetApi)("RedisModule_CreateString", (void *)((void **)(& RedisModule_CreateString)));
  (*RedisModule_GetApi)("RedisModule_CreateStringFromLongLong", (void *)((void **)(& RedisModule_CreateStringFromLongLong)));
  (*RedisModule_GetApi)("RedisModule_CreateStringFromString", (void *)((void **)(& RedisModule_CreateStringFromString)));
  (*RedisModule_GetApi)("RedisModule_CreateStringPrintf", (void *)((void **)(& RedisModule_CreateStringPrintf)));
  (*RedisModule_GetApi)("RedisModule_FreeString", (void *)((void **)(& RedisModule_FreeString)));
  (*RedisModule_GetApi)("RedisModule_StringPtrLen", (void *)((void **)(& RedisModule_StringPtrLen)));
  (*RedisModule_GetApi)("RedisModule_AutoMemory", (void *)((void **)(& RedisModule_AutoMemory)));
  (*RedisModule_GetApi)("RedisModule_Replicate", (void *)((void **)(& RedisModule_Replicate)));
  (*RedisModule_GetApi)("RedisModule_ReplicateVerbatim", (void *)((void **)(& RedisModule_ReplicateVerbatim)));
  (*RedisModule_GetApi)("RedisModule_DeleteKey", (void *)((void **)(& RedisModule_DeleteKey)));
  (*RedisModule_GetApi)("RedisModule_StringSet", (void *)((void **)(& RedisModule_StringSet)));
  (*RedisModule_GetApi)("RedisModule_StringDMA", (void *)((void **)(& RedisModule_StringDMA)));
  (*RedisModule_GetApi)("RedisModule_StringTruncate", (void *)((void **)(& RedisModule_StringTruncate)));
  (*RedisModule_GetApi)("RedisModule_GetExpire", (void *)((void **)(& RedisModule_GetExpire)));
  (*RedisModule_GetApi)("RedisModule_SetExpire", (void *)((void **)(& RedisModule_SetExpire)));
  (*RedisModule_GetApi)("RedisModule_ZsetAdd", (void *)((void **)(& RedisModule_ZsetAdd)));
  (*RedisModule_GetApi)("RedisModule_ZsetIncrby", (void *)((void **)(& RedisModule_ZsetIncrby)));
  (*RedisModule_GetApi)("RedisModule_ZsetScore", (void *)((void **)(& RedisModule_ZsetScore)));
  (*RedisModule_GetApi)("RedisModule_ZsetRem", (void *)((void **)(& RedisModule_ZsetRem)));
  (*RedisModule_GetApi)("RedisModule_ZsetRangeStop", (void *)((void **)(& RedisModule_ZsetRangeStop)));
  (*RedisModule_GetApi)("RedisModule_ZsetFirstInScoreRange", (void *)((void **)(& RedisModule_ZsetFirstInScoreRange)));
  (*RedisModule_GetApi)("RedisModule_ZsetLastInScoreRange", (void *)((void **)(& RedisModule_ZsetLastInScoreRange)));
  (*RedisModule_GetApi)("RedisModule_ZsetFirstInLexRange", (void *)((void **)(& RedisModule_ZsetFirstInLexRange)));
  (*RedisModule_GetApi)("RedisModule_ZsetLastInLexRange", (void *)((void **)(& RedisModule_ZsetLastInLexRange)));
  (*RedisModule_GetApi)("RedisModule_ZsetRangeCurrentElement", (void *)((void **)(& RedisModule_ZsetRangeCurrentElement)));
  (*RedisModule_GetApi)("RedisModule_ZsetRangeNext", (void *)((void **)(& RedisModule_ZsetRangeNext)));
  (*RedisModule_GetApi)("RedisModule_ZsetRangePrev", (void *)((void **)(& RedisModule_ZsetRangePrev)));
  (*RedisModule_GetApi)("RedisModule_ZsetRangeEndReached", (void *)((void **)(& RedisModule_ZsetRangeEndReached)));
  (*RedisModule_GetApi)("RedisModule_HashSet", (void *)((void **)(& RedisModule_HashSet)));
  (*RedisModule_GetApi)("RedisModule_HashGet", (void *)((void **)(& RedisModule_HashGet)));
  (*RedisModule_GetApi)("RedisModule_IsKeysPositionRequest", (void *)((void **)(& RedisModule_IsKeysPositionRequest)));
  (*RedisModule_GetApi)("RedisModule_KeyAtPos", (void *)((void **)(& RedisModule_KeyAtPos)));
  (*RedisModule_GetApi)("RedisModule_GetClientId", (void *)((void **)(& RedisModule_GetClientId)));
  (*RedisModule_GetApi)("RedisModule_PoolAlloc", (void *)((void **)(& RedisModule_PoolAlloc)));
  (*RedisModule_GetApi)("RedisModule_CreateDataType", (void *)((void **)(& RedisModule_CreateDataType)));
  (*RedisModule_GetApi)("RedisModule_ModuleTypeSetValue", (void *)((void **)(& RedisModule_ModuleTypeSetValue)));
  (*RedisModule_GetApi)("RedisModule_ModuleTypeGetType", (void *)((void **)(& RedisModule_ModuleTypeGetType)));
  (*RedisModule_GetApi)("RedisModule_ModuleTypeGetValue", (void *)((void **)(& RedisModule_ModuleTypeGetValue)));
  (*RedisModule_GetApi)("RedisModule_SaveUnsigned", (void *)((void **)(& RedisModule_SaveUnsigned)));
  (*RedisModule_GetApi)("RedisModule_LoadUnsigned", (void *)((void **)(& RedisModule_LoadUnsigned)));
  (*RedisModule_GetApi)("RedisModule_SaveSigned", (void *)((void **)(& RedisModule_SaveSigned)));
  (*RedisModule_GetApi)("RedisModule_LoadSigned", (void *)((void **)(& RedisModule_LoadSigned)));
  (*RedisModule_GetApi)("RedisModule_SaveString", (void *)((void **)(& RedisModule_SaveString)));
  (*RedisModule_GetApi)("RedisModule_SaveStringBuffer", (void *)((void **)(& RedisModule_SaveStringBuffer)));
  (*RedisModule_GetApi)("RedisModule_LoadString", (void *)((void **)(& RedisModule_LoadString)));
  (*RedisModule_GetApi)("RedisModule_LoadStringBuffer", (void *)((void **)(& RedisModule_LoadStringBuffer)));
  (*RedisModule_GetApi)("RedisModule_SaveDouble", (void *)((void **)(& RedisModule_SaveDouble)));
  (*RedisModule_GetApi)("RedisModule_LoadDouble", (void *)((void **)(& RedisModule_LoadDouble)));
  (*RedisModule_GetApi)("RedisModule_SaveFloat", (void *)((void **)(& RedisModule_SaveFloat)));
  (*RedisModule_GetApi)("RedisModule_LoadFloat", (void *)((void **)(& RedisModule_LoadFloat)));
  (*RedisModule_GetApi)("RedisModule_EmitAOF", (void *)((void **)(& RedisModule_EmitAOF)));
  (*RedisModule_GetApi)("RedisModule_Log", (void *)((void **)(& RedisModule_Log)));
  (*RedisModule_GetApi)("RedisModule_LogIOError", (void *)((void **)(& RedisModule_LogIOError)));
  (*RedisModule_GetApi)("RedisModule_StringAppendBuffer", (void *)((void **)(& RedisModule_StringAppendBuffer)));
  (*RedisModule_GetApi)("RedisModule_RetainString", (void *)((void **)(& RedisModule_RetainString)));
  (*RedisModule_GetApi)("RedisModule_StringCompare", (void *)((void **)(& RedisModule_StringCompare)));
  (*RedisModule_GetApi)("RedisModule_GetContextFromIO", (void *)((void **)(& RedisModule_GetContextFromIO)));
  (*RedisModule_GetApi)("RedisModule_BlockClient", (void *)((void **)(& RedisModule_BlockClient)));
  (*RedisModule_GetApi)("RedisModule_UnblockClient", (void *)((void **)(& RedisModule_UnblockClient)));
  (*RedisModule_GetApi)("RedisModule_IsBlockedReplyRequest", (void *)((void **)(& RedisModule_IsBlockedReplyRequest)));
  (*RedisModule_GetApi)("RedisModule_IsBlockedTimeoutRequest", (void *)((void **)(& RedisModule_IsBlockedTimeoutRequest)));
  (*RedisModule_GetApi)("RedisModule_GetBlockedClientPrivateData", (void *)((void **)(& RedisModule_GetBlockedClientPrivateData)));
  (*RedisModule_GetApi)("RedisModule_AbortBlock", (void *)((void **)(& RedisModule_AbortBlock)));
  (*RedisModule_GetApi)("RedisModule_Milliseconds", (void *)((void **)(& RedisModule_Milliseconds)));
  (*RedisModule_SetModuleAttribs)(ctx, name, ver, apiver);
  return (0);
}
}
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1))) strtoll)(char const   * __restrict  __nptr ,
                                                                                          char ** __restrict  __endptr ,
                                                                                          int __base ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) atoi)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return ((int )tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long ( __attribute__((__nonnull__(1), __gnu_inline__)) atol)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long long ( __attribute__((__nonnull__(1), __gnu_inline__)) atoll)(char const   *__nptr ) 
{ 
  long long tmp ;

  {
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) int rand(void) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
  __l = (size_t )0;
  __u = __nmemb;
  while (__l < __u) {
    __idx = (__l + __u) / 2UL;
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
    __comparison = (*__compar)(__key, __p);
    if (__comparison < 0) {
      __u = __idx;
    } else
    if (__comparison > 0) {
      __l = __idx + 1UL;
    } else {
      return ((void *)__p);
    }
  }
  return ((void *)0);
}
}
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern double ( __attribute__((__nonnull__(1), __gnu_inline__)) atof)(char const   *__nptr ) 
{ 
  double tmp ;

  {
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) tolower)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_tolower_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
    tmp___0 = (__int32_t const   )__c;
  }
  return ((int )tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) toupper)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_toupper_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
    tmp___0 = (__int32_t const   )__c;
  }
  return ((int )tmp___0);
}
}
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                     pthread_t __thread2 ) 
{ 


  {
  return (__thread1 == __thread2);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         void * __restrict  __tz ) ;
extern  __attribute__((__nothrow__)) double fabs(double __x )  __attribute__((__const__)) ;
void AnnFree(struct Ann *net ) ;
struct Ann *AnnCreateNet(int layers , int *units ) ;
struct Ann *AnnClone(struct Ann *net ) ;
size_t AnnCountWeights(struct Ann *net ) ;
void AnnSimulate(struct Ann *net ) ;
void AnnSetRandomWeights(struct Ann *net ) ;
float AnnTrain(struct Ann *net , float *input , float *desired , float maxerr , int maxepochs ,
               int setlen , int algo ) ;
void AnnTestError(struct Ann *net , float *input , float *desired , int setlen , float *avgerr ,
                  float *classerr ) ;
static RedisModuleType *NRType  ;
uint64_t NRNextId  =    (uint64_t )1;
static pthread_mutex_t NRPendingTrainingMutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
static NRPendingTraining NRTrainings[32]  ;
static int NRPendingTrainingCount  =    0;
long long NRMilliseconds(void) 
{ 
  struct timeval tv ;
  long long ust ;

  {
  gettimeofday((struct timeval * __restrict  )(& tv), (void * __restrict  )((void *)0));
  ust = (long long )tv.tv_sec * 1000000LL;
  ust += (long long )tv.tv_usec;
  return (ust / 1000LL);
}
}
NRTypeObject *createNRTypeObject(int flags , int *layers , int numlayers , int dset_len ,
                                 int test_len ) 
{ 
  NRTypeObject *o ;
  void *tmp ;
  uint64_t tmp___0 ;
  int ilen ;
  int olen ;
  void *tmp___1 ;
  void *tmp___2 ;
  int j ;
  int j___0 ;

  {
  tmp = (*RedisModule_Calloc)((size_t )1, sizeof(*o));
  o = (NRTypeObject *)tmp;
  tmp___0 = NRNextId;
  NRNextId ++;
  o->id = tmp___0;
  o->flags = (uint32_t )flags;
  o->nn = AnnCreateNet(numlayers, layers);
  o->dataset.maxlen = (uint32_t )dset_len;
  o->test.maxlen = (uint32_t )test_len;
  ilen = ((o->nn)->layer + ((o->nn)->layers - 1))->units - 1;
  olen = ((o->nn)->layer + 0)->units;
  tmp___1 = (*RedisModule_Calloc)((size_t )1, sizeof(float ) * (unsigned long )ilen);
  o->inorm = (float *)tmp___1;
  tmp___2 = (*RedisModule_Calloc)((size_t )1, sizeof(float ) * (unsigned long )olen);
  o->onorm = (float *)tmp___2;
  j = 0;
  while (j < ilen) {
    *(o->inorm + j) = (float )1;
    j ++;
  }
  j___0 = 0;
  while (j___0 < olen) {
    *(o->onorm + j___0) = (float )1;
    j___0 ++;
  }
  return (o);
}
}
void NRTypeInsertData(NRTypeObject *o , float *inputs , float *outputs , int target_ds ) 
{ 
  NRDataset *target ;
  float fill_a ;
  float fill_b ;
  double r ;
  int tmp ;
  double sumlen ;
  size_t idx ;
  int j ;
  int numin ;
  int numout ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  target = (NRDataset *)((void *)0);
  if (o->dataset.maxlen == 0U) {
    if (o->test.maxlen == 0U) {
      return;
    }
  }
  if (target_ds == 1) {
    target = & o->dataset;
  } else
  if (target_ds == 2) {
    target = & o->test;
  }
  if (o->dataset.maxlen == 0U) {
    target = & o->test;
  } else
  if (o->test.maxlen == 0U) {
    target = & o->dataset;
  }
  if ((unsigned long )target == (unsigned long )((void *)0)) {
    if (o->dataset.len != o->dataset.maxlen) {
      goto _L;
    } else
    if (o->test.len != o->dataset.len) {
      _L: /* CIL Label */ 
      fill_a = (float )o->dataset.len / (float )o->dataset.maxlen;
      fill_b = (float )o->test.len / (float )o->test.maxlen;
      if (fill_a <= fill_b) {
        target = & o->dataset;
      } else {
        target = & o->test;
      }
    } else {
      tmp = rand();
      r = (double )(tmp / 2147483647);
      sumlen = (double )(o->dataset.maxlen + o->test.maxlen);
      if (r < (double )o->dataset.maxlen / sumlen) {
        target = & o->dataset;
      } else {
        target = & o->test;
      }
    }
  }
  numin = ((o->nn)->layer + ((o->nn)->layers - 1))->units - 1;
  numout = ((o->nn)->layer + 0)->units;
  if (target->maxlen == target->len) {
    tmp___0 = rand();
    idx = (size_t )((unsigned int )tmp___0 % target->maxlen);
  } else {
    idx = (size_t )target->len;
    (target->len) ++;
    tmp___1 = (*RedisModule_Realloc)((void *)target->inputs, (sizeof(float ) * (unsigned long )numin) * (unsigned long )target->len);
    target->inputs = (float *)tmp___1;
    tmp___2 = (*RedisModule_Realloc)((void *)target->outputs, (sizeof(float ) * (unsigned long )numout) * (unsigned long )target->len);
    target->outputs = (float *)tmp___2;
  }
  j = 0;
  while (j < numin) {
    *(target->inputs + (idx * (size_t )numin + (size_t )j)) = *(inputs + j);
    j ++;
  }
  j = 0;
  while (j < numout) {
    *(target->outputs + (idx * (size_t )numout + (size_t )j)) = *(outputs + j);
    j ++;
  }
  return;
}
}
void NRDatasetFree(NRDataset *dset ) 
{ 


  {
  (*RedisModule_Free)((void *)dset->inputs);
  (*RedisModule_Free)((void *)dset->outputs);
  return;
}
}
void NRTypeReleaseObject(NRTypeObject *o ) 
{ 


  {
  AnnFree(o->nn);
  NRDatasetFree(& o->dataset);
  NRDatasetFree(& o->test);
  (*RedisModule_Free)((void *)o->inorm);
  (*RedisModule_Free)((void *)o->onorm);
  (*RedisModule_Free)((void *)o);
  return;
}
}
NRTypeObject *NRClone(NRTypeObject *o , int newid ) 
{ 
  NRTypeObject *copy ;
  void *tmp ;
  uint64_t tmp___0 ;
  int ilen ;
  int olen ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
  tmp = (*RedisModule_Calloc)((size_t )1, sizeof(*o));
  copy = (NRTypeObject *)tmp;
  *copy = *o;
  if (newid) {
    tmp___0 = NRNextId;
    NRNextId ++;
    copy->id = tmp___0;
  }
  copy->nn = AnnClone(o->nn);
  copy->dataset = o->dataset;
  copy->test = o->test;
  ilen = ((o->nn)->layer + ((o->nn)->layers - 1))->units - 1;
  olen = ((o->nn)->layer + 0)->units;
  tmp___1 = (*RedisModule_Alloc)((sizeof(float ) * (unsigned long )ilen) * (unsigned long )o->dataset.len);
  copy->dataset.inputs = (float *)tmp___1;
  tmp___2 = (*RedisModule_Alloc)((sizeof(float ) * (unsigned long )olen) * (unsigned long )o->dataset.len);
  copy->dataset.outputs = (float *)tmp___2;
  tmp___3 = (*RedisModule_Alloc)((sizeof(float ) * (unsigned long )ilen) * (unsigned long )o->test.len);
  copy->test.inputs = (float *)tmp___3;
  tmp___4 = (*RedisModule_Alloc)((sizeof(float ) * (unsigned long )olen) * (unsigned long )o->test.len);
  copy->test.outputs = (float *)tmp___4;
  memcpy((void * __restrict  )copy->dataset.inputs, (void const   * __restrict  )o->dataset.inputs,
         (sizeof(float ) * (unsigned long )ilen) * (unsigned long )o->dataset.len);
  memcpy((void * __restrict  )copy->dataset.outputs, (void const   * __restrict  )o->dataset.outputs,
         (sizeof(float ) * (unsigned long )olen) * (unsigned long )o->dataset.len);
  memcpy((void * __restrict  )copy->test.inputs, (void const   * __restrict  )o->test.inputs,
         (sizeof(float ) * (unsigned long )ilen) * (unsigned long )o->test.len);
  memcpy((void * __restrict  )copy->test.outputs, (void const   * __restrict  )o->test.outputs,
         (sizeof(float ) * (unsigned long )olen) * (unsigned long )o->test.len);
  tmp___5 = (*RedisModule_Alloc)(sizeof(float ) * (unsigned long )ilen);
  copy->inorm = (float *)tmp___5;
  tmp___6 = (*RedisModule_Alloc)(sizeof(float ) * (unsigned long )olen);
  copy->onorm = (float *)tmp___6;
  memcpy((void * __restrict  )copy->inorm, (void const   * __restrict  )o->inorm,
         sizeof(float ) * (unsigned long )ilen);
  memcpy((void * __restrict  )copy->onorm, (void const   * __restrict  )o->onorm,
         sizeof(float ) * (unsigned long )olen);
  return (copy);
}
}
void NRTransferWeights(RedisModuleCtx *ctx , NRTypeObject *dst , NRTypeObject *src ) 
{ 
  int ilen ;
  int olen ;

  {
  if (dst->id != src->id) {
    (*RedisModule_Log)(ctx, "warning", "NSTransferWeight(): source and destination neural network IDs don\'t match. This is unexpected, probably a bug inside the module. Weights not transferred back to the origina NN.");
    return;
  }
  AnnFree(dst->nn);
  dst->nn = AnnClone(src->nn);
  dst->training_total_steps = src->training_total_steps;
  dst->training_total_ms = src->training_total_ms;
  dst->dataset_error = src->dataset_error;
  dst->test_error = src->test_error;
  dst->test_class_error = src->test_class_error;
  dst->flags |= src->flags & (unsigned int )(1 << 5);
  ilen = ((src->nn)->layer + ((src->nn)->layers - 1))->units - 1;
  olen = ((src->nn)->layer + 0)->units;
  memcpy((void * __restrict  )dst->inorm, (void const   * __restrict  )src->inorm,
         sizeof(float ) * (unsigned long )ilen);
  memcpy((void * __restrict  )dst->onorm, (void const   * __restrict  )src->onorm,
         sizeof(float ) * (unsigned long )olen);
  return;
}
}
void *NRTrainingThreadMain(void *arg ) 
{ 
  NRPendingTraining *pt ;
  NRTypeObject *nr ;
  int training_iterations ;
  float train_error ;
  float test_error ;
  float class_error ;
  float past_train_error ;
  float past_test_error ;
  int auto_stop ;
  int backtrack ;
  uint64_t cycles ;
  long long start ;
  long long tmp ;
  long long cycle_time ;
  int overfitting_count ;
  int overfitting_limit ;
  float best_test_error ;
  int ilen ;
  int olen ;
  float *imax ;
  float *omax ;
  float *inputs ;
  float *outputs ;
  int i ;
  int i___0 ;
  uint32_t j ;
  int i___1 ;
  double tmp___0 ;
  double tmp___1 ;
  int i___2 ;
  double tmp___2 ;
  double tmp___3 ;
  int i___3 ;
  int i___4 ;
  uint32_t j___0 ;
  int i___5 ;
  int i___6 ;
  uint32_t j___1 ;
  int i___7 ;
  int i___8 ;
  struct Ann *saved ;
  float saved_error ;
  float saved_train_error ;
  float saved_class_error ;
  long long cycle_start ;
  long long tmp___4 ;
  long long tmp___5 ;
  long long total_time ;
  long long tmp___6 ;
  long long tmp___7 ;

  {
  pt = (NRPendingTraining *)arg;
  nr = pt->nr;
  training_iterations = 1;
  train_error = (float )0;
  test_error = (float )0;
  class_error = (float )0;
  past_train_error = (float )(1.0 / 0.0);
  past_test_error = (float )(1.0 / 0.0);
  auto_stop = (int )(nr->flags & (unsigned int )(1 << 4));
  backtrack = (int )(nr->flags & (unsigned int )(1 << 6));
  cycles = (uint64_t )0;
  tmp = NRMilliseconds();
  start = tmp;
  overfitting_count = 0;
  overfitting_limit = 5;
  best_test_error = (float )(1.0 / 0.0);
  nr->flags &= (unsigned int )(~ (1 << 5));
  if (nr->flags & (unsigned int )(1 << 3)) {
    if (nr->dataset.len) {
      ilen = ((nr->nn)->layer + ((nr->nn)->layers - 1))->units - 1;
      olen = ((nr->nn)->layer + 0)->units;
      imax = nr->inorm;
      omax = nr->onorm;
      inputs = nr->dataset.inputs;
      outputs = nr->dataset.outputs;
      i = 0;
      while (i < ilen) {
        *(imax + i) = (float )1;
        i ++;
      }
      i___0 = 0;
      while (i___0 < olen) {
        *(omax + i___0) = (float )1;
        i___0 ++;
      }
      j = (uint32_t )0;
      while (j < nr->dataset.len) {
        i___1 = 0;
        while (i___1 < ilen) {
          tmp___1 = fabs((double )*(inputs + i___1));
          if (tmp___1 > (double )*(imax + i___1)) {
            tmp___0 = fabs((double )*(inputs + i___1));
            *(imax + i___1) = (float )tmp___0;
          }
          i___1 ++;
        }
        i___2 = 0;
        while (i___2 < olen) {
          tmp___3 = fabs((double )*(outputs + i___2));
          if (tmp___3 > (double )*(omax + i___2)) {
            tmp___2 = fabs((double )*(outputs + i___2));
            *(omax + i___2) = (float )tmp___2;
          }
          i___2 ++;
        }
        inputs += ilen;
        outputs += olen;
        j ++;
      }
      i___3 = 0;
      while (i___3 < ilen) {
        if (*(imax + i___3) != (float )1) {
          *(imax + i___3) = (float )((double )*(imax + i___3) * 1.2);
        }
        i___3 ++;
      }
      i___4 = 0;
      while (i___4 < olen) {
        if (*(omax + i___4) != (float )1) {
          *(omax + i___4) = (float )((double )*(omax + i___4) * 1.2);
        }
        i___4 ++;
      }
      inputs = nr->dataset.inputs;
      outputs = nr->dataset.outputs;
      j___0 = (uint32_t )0;
      while (j___0 < nr->dataset.len) {
        i___5 = 0;
        while (i___5 < ilen) {
          *(inputs + i___5) /= *(nr->inorm + i___5);
          i___5 ++;
        }
        if (! (nr->flags & (unsigned int )(1 << 2))) {
          i___6 = 0;
          while (i___6 < olen) {
            *(outputs + i___6) /= *(nr->onorm + i___6);
            i___6 ++;
          }
        }
        inputs += ilen;
        outputs += olen;
        j___0 ++;
      }
      inputs = nr->test.inputs;
      outputs = nr->test.outputs;
      j___1 = (uint32_t )0;
      while (j___1 < nr->test.len) {
        i___7 = 0;
        while (i___7 < ilen) {
          *(inputs + i___7) /= *(nr->inorm + i___7);
          i___7 ++;
        }
        if (! (nr->flags & (unsigned int )(1 << 2))) {
          i___8 = 0;
          while (i___8 < olen) {
            *(outputs + i___8) /= *(nr->onorm + i___8);
            i___8 ++;
          }
        }
        inputs += ilen;
        outputs += olen;
        j___1 ++;
      }
    }
  }
  saved = (struct Ann *)((void *)0);
  while (1) {
    tmp___4 = NRMilliseconds();
    cycle_start = tmp___4;
    train_error = AnnTrain(nr->nn, nr->dataset.inputs, nr->dataset.outputs, (float )0,
                           training_iterations, (int )nr->dataset.len, 0);
    tmp___5 = NRMilliseconds();
    cycle_time = tmp___5 - cycle_start;
    nr->training_total_steps += (uint64_t )(nr->dataset.len * (uint32_t )training_iterations);
    if (auto_stop) {
      AnnTestError(nr->nn, nr->test.inputs, nr->test.outputs, (int )nr->test.len,
                   & test_error, & class_error);
      if (train_error < past_train_error) {
        if (test_error > past_test_error) {
          overfitting_count ++;
          if (overfitting_count == overfitting_limit) {
            nr->flags |= (unsigned int )(1 << 5);
            break;
          }
        } else {
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
      if (overfitting_count > 0) {
        overfitting_count --;
      }
      if (backtrack) {
        if ((unsigned long )saved == (unsigned long )((void *)0)) {
          goto _L___0;
        } else
        if (test_error < saved_error) {
          _L___0: /* CIL Label */ 
          saved_error = test_error;
          saved_train_error = train_error;
          saved_class_error = class_error;
          if (saved) {
            AnnFree(saved);
          }
          saved = AnnClone(nr->nn);
        }
      }
      if (test_error < best_test_error) {
        overfitting_count = 0;
        best_test_error = test_error;
      }
      if ((double )train_error < 0.000000000000001) {
        if ((double )test_error < 0.000000000000001) {
          break;
        }
      }
    }
    cycles ++;
    tmp___6 = NRMilliseconds();
    total_time = tmp___6 - start;
    if (nr->training_max_cycles) {
      if (cycles == nr->training_max_cycles) {
        break;
      }
    }
    if (nr->training_max_ms) {
      if (total_time > (long long )nr->training_max_ms) {
        break;
      }
    }
    if (total_time > 10000LL) {
      if (cycle_time < 100LL) {
        training_iterations ++;
      }
    }
    past_train_error = train_error;
    past_test_error = test_error;
    pthread_mutex_lock(& NRPendingTrainingMutex);
    pt->dataset_error = train_error;
    pt->test_error = test_error;
    if (nr->flags & (unsigned int )(1 << 2)) {
      pt->class_error = class_error;
    }
    pt->curcycle = (int )cycles;
    pthread_mutex_unlock(& NRPendingTrainingMutex);
  }
  if (! auto_stop) {
    AnnTestError(nr->nn, nr->test.inputs, nr->test.outputs, (int )nr->test.len, & test_error,
                 & class_error);
  }
  if (auto_stop) {
    if (backtrack) {
      if (saved) {
        if (saved_error < test_error) {
          AnnFree(nr->nn);
          nr->nn = saved;
          test_error = saved_error;
          train_error = saved_train_error;
          class_error = saved_class_error;
        } else {
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
      if (saved) {
        AnnFree(saved);
      }
    }
  }
  if (nr->flags & (unsigned int )(1 << 2)) {
    nr->test_class_error = class_error;
  }
  nr->dataset_error = train_error;
  nr->test_error = test_error;
  tmp___7 = NRMilliseconds();
  nr->training_total_ms = (uint64_t )((unsigned long long )nr->training_total_ms + (unsigned long long )(tmp___7 - start));
  pthread_mutex_lock(& NRPendingTrainingMutex);
  pt->in_progress = 0;
  pthread_mutex_unlock(& NRPendingTrainingMutex);
  return ((void *)0);
}
}
int NRStartTraining(RedisModuleCtx *ctx , RedisModuleString *key , int dbid , NRTypeObject *nr ) 
{ 
  NRPendingTraining *pt ;
  int tmp ;

  {
  pthread_mutex_lock(& NRPendingTrainingMutex);
  if (NRPendingTrainingCount == 32) {
    pthread_mutex_unlock(& NRPendingTrainingMutex);
    return (1);
  }
  pt = & NRTrainings[NRPendingTrainingCount];
  pt->key = (*RedisModule_CreateStringFromString)(ctx, (RedisModuleString const   *)key);
  (*RedisModule_RetainString)(ctx, pt->key);
  pt->db_id = dbid;
  pt->in_progress = 1;
  pt->nr = NRClone(nr, 0);
  pt->dataset_error = (float )0;
  pt->test_error = (float )0;
  pt->class_error = (float )0;
  pt->curcycle = 0;
  tmp = pthread_create((pthread_t * __restrict  )(& pt->tid), (pthread_attr_t const   * __restrict  )((void *)0),
                       & NRTrainingThreadMain, (void * __restrict  )pt);
  if (tmp != 0) {
    (*RedisModule_Log)(ctx, "warning", "Unable to create a new pthread in NRStartTraining()");
    (*RedisModule_FreeString)(ctx, pt->key);
    pt->key = (RedisModuleString *)((void *)0);
    NRTypeReleaseObject(pt->nr);
    pthread_mutex_unlock(& NRPendingTrainingMutex);
    return (1);
  }
  NRPendingTrainingCount ++;
  nr->flags |= 1U;
  nr->flags &= (unsigned int )(~ (1 << 5));
  pthread_mutex_unlock(& NRPendingTrainingMutex);
  return (0);
}
}
int NRCollectThreads(RedisModuleCtx *ctx ) 
{ 
  int collected ;
  int j ;
  NRPendingTraining *pt ;
  int orig_id ;
  int tmp ;
  RedisModuleKey *key ;
  void *tmp___0 ;
  NRTypeObject *nr ;
  void *tmp___1 ;
  RedisModuleType *tmp___2 ;

  {
  collected = 0;
  pthread_mutex_lock(& NRPendingTrainingMutex);
  j = 0;
  while (j < NRPendingTrainingCount) {
    pt = & NRTrainings[j];
    if (pt->in_progress == 0) {
      tmp = (*RedisModule_GetSelectedDb)(ctx);
      orig_id = tmp;
      if (orig_id != pt->db_id) {
        (*RedisModule_SelectDb)(ctx, pt->db_id);
      }
      tmp___0 = (*RedisModule_OpenKey)(ctx, pt->key, 1 | (1 << 1));
      key = (RedisModuleKey *)tmp___0;
      tmp___2 = (*RedisModule_ModuleTypeGetType)(key);
      if ((unsigned long )tmp___2 == (unsigned long )NRType) {
        tmp___1 = (*RedisModule_ModuleTypeGetValue)(key);
        nr = (NRTypeObject *)tmp___1;
        if (nr->id == (pt->nr)->id) {
          NRTransferWeights(ctx, nr, pt->nr);
          nr->flags &= 4294967294U;
        }
        (*RedisModule_FreeString)(ctx, pt->key);
        pt->key = (RedisModuleString *)((void *)0);
        NRTypeReleaseObject(pt->nr);
        NRPendingTrainingCount --;
        memcpy((void * __restrict  )(& NRTrainings[j]), (void const   * __restrict  )(& NRTrainings[j + 1]),
               (unsigned long )(NRPendingTrainingCount - j) * sizeof(NRTrainings[0]));
      }
      if (orig_id != pt->db_id) {
        (*RedisModule_SelectDb)(ctx, orig_id);
      }
      collected ++;
    }
    j ++;
  }
  pthread_mutex_unlock(& NRPendingTrainingMutex);
  return (collected);
}
}
int NRCreate_RedisCommand(RedisModuleCtx *ctx , RedisModuleString **argv , int argc ) 
{ 
  long long dset_size ;
  long long test_size ;
  int layers[32] ;
  int num_layers ;
  int flags ;
  int tmp ;
  char const   *nntype ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int j ;
  int stop ;
  char const   *u ;
  char const   *tmp___4 ;
  long long units ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int i ;
  int t ;
  char const   *o ;
  char const   *tmp___9 ;
  long long v ;
  int lastarg ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  RedisModuleKey *key ;
  void *tmp___17 ;
  int type ;
  int tmp___18 ;
  int tmp___19 ;
  NRTypeObject *nr ;
  NRTypeObject *tmp___20 ;
  size_t tmp___21 ;

  {
  dset_size = 0LL;
  test_size = 0LL;
  num_layers = 0;
  flags = 0;
  (*RedisModule_AutoMemory)(ctx);
  NRCollectThreads(ctx);
  if (argc < 6) {
    tmp = (*RedisModule_WrongArity)(ctx);
    return (tmp);
  }
  tmp___0 = (*RedisModule_StringPtrLen)((RedisModuleString const   *)*(argv + 2),
                                        (size_t *)((void *)0));
  nntype = tmp___0;
  tmp___3 = strcasecmp(nntype, "classifier");
  if (tmp___3) {
    tmp___2 = strcasecmp(nntype, "regressor");
    if (tmp___2) {
      tmp___1 = (*RedisModule_ReplyWithError)(ctx, "ERR invalid neural network type. Must be CLASSIFIER or REGRESSOR");
      return (tmp___1);
    } else {
      flags |= 1 << 1;
    }
  } else {
    flags |= 1 << 2;
  }
  j = 3;
  stop = 0;
  while (j < argc) {
    tmp___4 = (*RedisModule_StringPtrLen)((RedisModuleString const   *)*(argv + j),
                                          (size_t *)((void *)0));
    u = tmp___4;
    tmp___5 = strcmp(u, "->");
    if (! tmp___5) {
      stop = 1;
      j ++;
      continue;
    }
    tmp___7 = (*RedisModule_StringToLongLong)((RedisModuleString const   *)*(argv + j),
                                              & units);
    if (tmp___7 != 0) {
      tmp___6 = (*RedisModule_ReplyWithError)(ctx, "ERR invalid units count");
      return (tmp___6);
    } else
    if (units <= 0LL) {
      tmp___6 = (*RedisModule_ReplyWithError)(ctx, "ERR invalid units count");
      return (tmp___6);
    }
    tmp___8 = num_layers;
    num_layers ++;
    layers[tmp___8] = (int )units;
    j ++;
    if (stop) {
      break;
    }
  }
  i = 0;
  while (i < num_layers / 2) {
    t = layers[i];
    layers[i] = layers[(num_layers - 1) - i];
    layers[(num_layers - 1) - i] = t;
    i ++;
  }
  while (j < argc) {
    tmp___9 = (*RedisModule_StringPtrLen)((RedisModuleString const   *)*(argv + j),
                                          (size_t *)((void *)0));
    o = tmp___9;
    lastarg = j == argc - 1;
    tmp___15 = strcasecmp(o, "dataset");
    if (tmp___15) {
      tmp___16 = strcasecmp(o, "test");
      if (tmp___16) {
        _L: /* CIL Label */ 
        tmp___14 = strcasecmp(o, "normalize");
        if (tmp___14) {
          tmp___13 = (*RedisModule_ReplyWithError)(ctx, "ERR Syntax error in NR.CREATE");
          return (tmp___13);
        } else {
          flags |= 1 << 3;
        }
      } else
      _L___0: /* CIL Label */ 
      if (! lastarg) {
        tmp___11 = (*RedisModule_StringToLongLong)((RedisModuleString const   *)*(argv + (j + 1)),
                                                   & v);
        if (tmp___11 != 0) {
          tmp___10 = (*RedisModule_ReplyWithError)(ctx, "ERR invalid dataset size");
          return (tmp___10);
        } else
        if (v < 0LL) {
          tmp___10 = (*RedisModule_ReplyWithError)(ctx, "ERR invalid dataset size");
          return (tmp___10);
        }
        tmp___12 = strcasecmp(o, "dataset");
        if (tmp___12) {
          test_size = v;
        } else {
          dset_size = v;
        }
        j ++;
      } else {
        goto _L;
      }
    } else {
      goto _L___0;
    }
    j ++;
  }
  tmp___17 = (*RedisModule_OpenKey)(ctx, *(argv + 1), 1 | (1 << 1));
  key = (RedisModuleKey *)tmp___17;
  tmp___18 = (*RedisModule_KeyType)(key);
  type = tmp___18;
  if (type != 0) {
    tmp___19 = (*RedisModule_ReplyWithError)(ctx, "ERR the key name is busy");
    return (tmp___19);
  }
  tmp___20 = createNRTypeObject(flags, layers, num_layers, (int )dset_size, (int )test_size);
  nr = tmp___20;
  (*RedisModule_ModuleTypeSetValue)(key, NRType, (void *)nr);
  tmp___21 = AnnCountWeights(nr->nn);
  (*RedisModule_ReplyWithLongLong)(ctx, (long long )tmp___21);
  (*RedisModule_ReplicateVerbatim)(ctx);
  return (0);
}
}
int NRGenericRun_RedisCommand(RedisModuleCtx *ctx , RedisModuleString **argv , int argc ,
                              int output_class ) 
{ 
  int tmp ;
  RedisModuleKey *key ;
  void *tmp___0 ;
  int tmp___1 ;
  RedisModuleType *tmp___2 ;
  NRTypeObject *nr ;
  void *tmp___3 ;
  int tmp___4 ;
  int ilen ;
  int tmp___5 ;
  int j ;
  double input ;
  int tmp___6 ;
  int tmp___7 ;
  int olen ;
  float max ;
  int max_class ;
  int j___0 ;
  float output ;
  int j___1 ;
  float output___0 ;

  {
  (*RedisModule_AutoMemory)(ctx);
  NRCollectThreads(ctx);
  if (argc < 3) {
    tmp = (*RedisModule_WrongArity)(ctx);
    return (tmp);
  }
  tmp___0 = (*RedisModule_OpenKey)(ctx, *(argv + 1), 1);
  key = (RedisModuleKey *)tmp___0;
  tmp___2 = (*RedisModule_ModuleTypeGetType)(key);
  if ((unsigned long )tmp___2 != (unsigned long )NRType) {
    tmp___1 = (*RedisModule_ReplyWithError)(ctx, "WRONGTYPE Operation against a key holding the wrong kind of value");
    return (tmp___1);
  }
  tmp___3 = (*RedisModule_ModuleTypeGetValue)(key);
  nr = (NRTypeObject *)tmp___3;
  if (output_class) {
    if (! (nr->flags & (unsigned int )(1 << 2))) {
      tmp___4 = (*RedisModule_ReplyWithError)(ctx, "ERR you can\'t call NR.CLASS with a regressor network. Use this command with a classifier network");
      return (tmp___4);
    }
  }
  ilen = ((nr->nn)->layer + ((nr->nn)->layers - 1))->units - 1;
  if (argc != ilen + 2) {
    tmp___5 = (*RedisModule_ReplyWithError)(ctx, "ERR number of arguments does not match the number of inputs in the neural network");
    return (tmp___5);
  }
  j = 0;
  while (j < ilen) {
    tmp___7 = (*RedisModule_StringToDouble)((RedisModuleString const   *)*(argv + (j + 2)),
                                            & input);
    if (tmp___7 != 0) {
      tmp___6 = (*RedisModule_ReplyWithError)(ctx, "ERR invalid neural network input: must be a valid float precision floating point number");
      return (tmp___6);
    }
    if (nr->flags & (unsigned int )(1 << 3)) {
      input /= (double )*(nr->inorm + j);
    }
    *(((nr->nn)->layer + ((nr->nn)->layers - 1))->output + j) = (float )input;
    j ++;
  }
  AnnSimulate(nr->nn);
  olen = ((nr->nn)->layer + 0)->units;
  if (output_class) {
    max = *(((nr->nn)->layer + 0)->output + 0);
    max_class = 0;
    j___0 = 1;
    while (j___0 < olen) {
      output = *(((nr->nn)->layer + 0)->output + j___0);
      if (output > max) {
        max = output;
        max_class = j___0;
      }
      j___0 ++;
    }
    (*RedisModule_ReplyWithLongLong)(ctx, (long long )max_class);
  } else {
    (*RedisModule_ReplyWithArray)(ctx, (long )olen);
    j___1 = 0;
    while (j___1 < olen) {
      output___0 = *(((nr->nn)->layer + 0)->output + j___1);
      if (! (nr->flags & (unsigned int )(1 << 2))) {
        if (nr->flags & (unsigned int )(1 << 3)) {
          output___0 *= *(nr->onorm + j___1);
        }
      }
      (*RedisModule_ReplyWithDouble)(ctx, (double )output___0);
      j___1 ++;
    }
  }
  return (0);
}
}
int NRRun_RedisCommand(RedisModuleCtx *ctx , RedisModuleString **argv , int argc ) 
{ 
  int tmp ;

  {
  tmp = NRGenericRun_RedisCommand(ctx, argv, argc, 0);
  return (tmp);
}
}
int NRClass_RedisCommand(RedisModuleCtx *ctx , RedisModuleString **argv , int argc ) 
{ 
  int tmp ;

  {
  tmp = NRGenericRun_RedisCommand(ctx, argv, argc, 1);
  return (tmp);
}
}
int NRObserve_RedisCommand(RedisModuleCtx *ctx , RedisModuleString **argv , int argc ) 
{ 
  int tmp ;
  RedisModuleKey *key ;
  void *tmp___0 ;
  int tmp___1 ;
  RedisModuleType *tmp___2 ;
  NRTypeObject *nr ;
  void *tmp___3 ;
  int ilen ;
  int olen ;
  int oargs ;
  int tmp___4 ;
  int target ;
  char const   *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char const   *sep ;
  char const   *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  float *inputs ;
  void *tmp___13 ;
  float *outputs ;
  void *tmp___14 ;
  int j ;
  double val ;
  int tmp___15 ;
  int tmp___16 ;
  int classid ;
  int tmp___17 ;

  {
  (*RedisModule_AutoMemory)(ctx);
  NRCollectThreads(ctx);
  if (argc < 3) {
    tmp = (*RedisModule_WrongArity)(ctx);
    return (tmp);
  }
  tmp___0 = (*RedisModule_OpenKey)(ctx, *(argv + 1), 1 | (1 << 1));
  key = (RedisModuleKey *)tmp___0;
  tmp___2 = (*RedisModule_ModuleTypeGetType)(key);
  if ((unsigned long )tmp___2 != (unsigned long )NRType) {
    tmp___1 = (*RedisModule_ReplyWithError)(ctx, "WRONGTYPE Operation against a key holding the wrong kind of value");
    return (tmp___1);
  }
  tmp___3 = (*RedisModule_ModuleTypeGetValue)(key);
  nr = (NRTypeObject *)tmp___3;
  ilen = ((nr->nn)->layer + ((nr->nn)->layers - 1))->units - 1;
  olen = ((nr->nn)->layer + 0)->units;
  if (nr->flags & (unsigned int )(1 << 2)) {
    tmp___4 = 1;
  } else {
    tmp___4 = olen;
  }
  oargs = tmp___4;
  target = 0;
  tmp___7 = (*RedisModule_StringPtrLen)((RedisModuleString const   *)*(argv + (argc - 1)),
                                        (size_t *)((void *)0));
  tmp___8 = strcasecmp(tmp___7, "train");
  if (tmp___8) {
    tmp___5 = (*RedisModule_StringPtrLen)((RedisModuleString const   *)*(argv + (argc - 1)),
                                          (size_t *)((void *)0));
    tmp___6 = strcasecmp(tmp___5, "test");
    if (! tmp___6) {
      target = 2;
      argc --;
    }
  } else {
    target = 1;
    argc --;
  }
  if (argc != (oargs + ilen) + 3) {
    tmp___9 = (*RedisModule_ReplyWithError)(ctx, "ERR number of arguments does not match the number of inputs and outputs in the neural network");
    return (tmp___9);
  }
  tmp___10 = (*RedisModule_StringPtrLen)((RedisModuleString const   *)*(argv + (ilen + 2)),
                                         (size_t *)((void *)0));
  sep = tmp___10;
  tmp___12 = strcmp(sep, "->");
  if (tmp___12) {
    tmp___11 = (*RedisModule_ReplyWithError)(ctx, "ERR no \'->\' separtor in the correct position between inputs and outputs: are you sure your training data is correct?");
    return (tmp___11);
  }
  tmp___13 = (*RedisModule_Alloc)(sizeof(float ) * (unsigned long )ilen);
  inputs = (float *)tmp___13;
  tmp___14 = (*RedisModule_Alloc)(sizeof(float ) * (unsigned long )olen);
  outputs = (float *)tmp___14;
  j = 2;
  while (j < argc) {
    if (j == ilen + 2) {
      goto __Cont;
    }
    tmp___16 = (*RedisModule_StringToDouble)((RedisModuleString const   *)*(argv + j),
                                             & val);
    if (tmp___16 != 0) {
      (*RedisModule_Free)((void *)inputs);
      (*RedisModule_Free)((void *)outputs);
      tmp___15 = (*RedisModule_ReplyWithError)(ctx, "ERR invalid neural network input: must be a valid float precision floating point number");
      return (tmp___15);
    }
    if (j < ilen + 2) {
      *(inputs + (j - 2)) = (float )val;
    } else
    if (nr->flags & (unsigned int )(1 << 2)) {
      classid = (int )val;
      if ((double )classid != val) {
        (*RedisModule_Free)((void *)inputs);
        (*RedisModule_Free)((void *)outputs);
        tmp___17 = (*RedisModule_ReplyWithError)(ctx, "ERR classifier network output must be an integer in the range from 0 to outputs-1.");
        return (tmp___17);
      } else
      if (val >= (double )olen) {
        (*RedisModule_Free)((void *)inputs);
        (*RedisModule_Free)((void *)outputs);
        tmp___17 = (*RedisModule_ReplyWithError)(ctx, "ERR classifier network output must be an integer in the range from 0 to outputs-1.");
        return (tmp___17);
      } else
      if (val < (double )0) {
        (*RedisModule_Free)((void *)inputs);
        (*RedisModule_Free)((void *)outputs);
        tmp___17 = (*RedisModule_ReplyWithError)(ctx, "ERR classifier network output must be an integer in the range from 0 to outputs-1.");
        return (tmp___17);
      }
      memset((void *)outputs, 0, sizeof(float ) * (unsigned long )olen);
      *(outputs + classid) = (float )1;
    } else {
      *(outputs + ((j - ilen) - 3)) = (float )val;
    }
    __Cont: /* CIL Label */ 
    j ++;
  }
  NRTypeInsertData(nr, inputs, outputs, target);
  (*RedisModule_Free)((void *)inputs);
  (*RedisModule_Free)((void *)outputs);
  (*RedisModule_ReplyWithArray)(ctx, 2L);
  (*RedisModule_ReplyWithLongLong)(ctx, (long long )nr->dataset.len);
  (*RedisModule_ReplyWithLongLong)(ctx, (long long )nr->test.len);
  return (0);
}
}
int NRTrain_RedisCommand(RedisModuleCtx *ctx , RedisModuleString **argv , int argc ) 
{ 
  int tmp ;
  RedisModuleKey *key ;
  void *tmp___0 ;
  int tmp___1 ;
  RedisModuleType *tmp___2 ;
  NRTypeObject *nr ;
  void *tmp___3 ;
  int tmp___4 ;
  int j ;
  char const   *o ;
  char const   *tmp___5 ;
  long long v ;
  int lastarg ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
  (*RedisModule_AutoMemory)(ctx);
  NRCollectThreads(ctx);
  if (argc < 2) {
    tmp = (*RedisModule_WrongArity)(ctx);
    return (tmp);
  }
  tmp___0 = (*RedisModule_OpenKey)(ctx, *(argv + 1), 1 | (1 << 1));
  key = (RedisModuleKey *)tmp___0;
  tmp___2 = (*RedisModule_ModuleTypeGetType)(key);
  if ((unsigned long )tmp___2 != (unsigned long )NRType) {
    tmp___1 = (*RedisModule_ReplyWithError)(ctx, "WRONGTYPE Operation against a key holding the wrong kind of value");
    return (tmp___1);
  }
  tmp___3 = (*RedisModule_ModuleTypeGetValue)(key);
  nr = (NRTypeObject *)tmp___3;
  if (nr->flags & 1U) {
    tmp___4 = (*RedisModule_ReplyWithError)(ctx, "ERR neural network training already in progress");
    return (tmp___4);
  }
  nr->training_max_cycles = (uint64_t )0;
  nr->training_max_ms = (uint64_t )10000;
  nr->flags &= (unsigned int )(~ ((1 << 4) | (1 << 6)));
  j = 2;
  while (j < argc) {
    tmp___5 = (*RedisModule_StringPtrLen)((RedisModuleString const   *)*(argv + j),
                                          (size_t *)((void *)0));
    o = tmp___5;
    lastarg = j == argc - 1;
    tmp___14 = strcasecmp(o, "autostop");
    if (tmp___14) {
      tmp___13 = strcasecmp(o, "backtrack");
      if (tmp___13) {
        tmp___12 = strcasecmp(o, "maxcycles");
        if (tmp___12) {
          _L: /* CIL Label */ 
          tmp___11 = strcasecmp(o, "maxtime");
          if (tmp___11) {
            tmp___10 = (*RedisModule_ReplyWithError)(ctx, "ERR Syntax error in NR.TRAIN");
            return (tmp___10);
          } else
          if (! lastarg) {
            j ++;
            tmp___9 = (*RedisModule_StringToLongLong)((RedisModuleString const   *)*(argv + j),
                                                      & v);
            if (tmp___9 != 0) {
              tmp___8 = (*RedisModule_ReplyWithError)(ctx, "ERR invalid number of milliseconds of time");
              return (tmp___8);
            }
            nr->training_max_ms = (uint64_t )v;
          } else {
            tmp___10 = (*RedisModule_ReplyWithError)(ctx, "ERR Syntax error in NR.TRAIN");
            return (tmp___10);
          }
        } else
        if (! lastarg) {
          j ++;
          tmp___7 = (*RedisModule_StringToLongLong)((RedisModuleString const   *)*(argv + j),
                                                    & v);
          if (tmp___7 != 0) {
            tmp___6 = (*RedisModule_ReplyWithError)(ctx, "ERR invalid number of cycles");
            return (tmp___6);
          }
          nr->training_max_cycles = (uint64_t )v;
        } else {
          goto _L;
        }
      } else {
        nr->flags |= (unsigned int )(1 << 6);
      }
    } else {
      nr->flags |= (unsigned int )(1 << 4);
    }
    j ++;
  }
  if (nr->flags & (unsigned int )(1 << 4)) {
    if (nr->test.len == 0U) {
      tmp___15 = (*RedisModule_ReplyWithError)(ctx, "ERR Can\'t start training with AUTOSTOP option: overfitting detection requires a non zero length testing dataset");
      return (tmp___15);
    }
  }
  tmp___18 = (*RedisModule_GetSelectedDb)(ctx);
  tmp___19 = NRStartTraining(ctx, *(argv + 1), tmp___18, nr);
  if (tmp___19 == 1) {
    tmp___16 = (*RedisModule_ReplyWithError)(ctx, "ERR Can\'t train the neural network: too many NNs already training");
    return (tmp___16);
  } else {
    tmp___17 = (*RedisModule_ReplyWithSimpleString)(ctx, "Training has started");
    return (tmp___17);
  }
}
}
int NRReset_RedisCommand(RedisModuleCtx *ctx , RedisModuleString **argv , int argc ) 
{ 
  int tmp ;
  RedisModuleKey *key ;
  void *tmp___0 ;
  int tmp___1 ;
  RedisModuleType *tmp___2 ;
  NRTypeObject *nr ;
  void *tmp___3 ;
  uint64_t tmp___4 ;
  int tmp___5 ;

  {
  (*RedisModule_AutoMemory)(ctx);
  NRCollectThreads(ctx);
  if (argc != 2) {
    tmp = (*RedisModule_WrongArity)(ctx);
    return (tmp);
  }
  tmp___0 = (*RedisModule_OpenKey)(ctx, *(argv + 1), 1 | (1 << 1));
  key = (RedisModuleKey *)tmp___0;
  tmp___2 = (*RedisModule_ModuleTypeGetType)(key);
  if ((unsigned long )tmp___2 != (unsigned long )NRType) {
    tmp___1 = (*RedisModule_ReplyWithError)(ctx, "WRONGTYPE Operation against a key holding the wrong kind of value");
    return (tmp___1);
  }
  tmp___3 = (*RedisModule_ModuleTypeGetValue)(key);
  nr = (NRTypeObject *)tmp___3;
  tmp___4 = NRNextId;
  NRNextId ++;
  nr->id = tmp___4;
  nr->training_total_steps = (uint64_t )0;
  nr->training_total_ms = (uint64_t )0;
  nr->training_max_cycles = (uint64_t )0;
  nr->training_max_ms = (uint64_t )0;
  nr->dataset_error = (float )0;
  nr->test_error = (float )0;
  nr->test_class_error = (float )0;
  AnnSetRandomWeights(nr->nn);
  tmp___5 = (*RedisModule_ReplyWithSimpleString)(ctx, "OK");
  return (tmp___5);
}
}
int NRInfo_RedisCommand(RedisModuleCtx *ctx , RedisModuleString **argv , int argc ) 
{ 
  char buf[128] ;
  int tmp ;
  RedisModuleKey *key ;
  void *tmp___0 ;
  int tmp___1 ;
  RedisModuleType *tmp___2 ;
  NRTypeObject *nr ;
  void *tmp___3 ;
  int fields ;
  char const   *tmp___4 ;
  int i ;
  int units ;
  uint64_t tmp___5 ;
  char const   *tmp___6 ;

  {
  (*RedisModule_AutoMemory)(ctx);
  NRCollectThreads(ctx);
  if (argc != 2) {
    tmp = (*RedisModule_WrongArity)(ctx);
    return (tmp);
  }
  tmp___0 = (*RedisModule_OpenKey)(ctx, *(argv + 1), 1);
  key = (RedisModuleKey *)tmp___0;
  tmp___2 = (*RedisModule_ModuleTypeGetType)(key);
  if ((unsigned long )tmp___2 != (unsigned long )NRType) {
    tmp___1 = (*RedisModule_ReplyWithError)(ctx, "WRONGTYPE Operation against a key holding the wrong kind of value");
    return (tmp___1);
  }
  tmp___3 = (*RedisModule_ModuleTypeGetValue)(key);
  nr = (NRTypeObject *)tmp___3;
  fields = 15;
  if (nr->flags & (unsigned int )(1 << 2)) {
    fields ++;
  }
  (*RedisModule_ReplyWithArray)(ctx, (long )(fields * 2));
  (*RedisModule_ReplyWithSimpleString)(ctx, "id");
  (*RedisModule_ReplyWithLongLong)(ctx, (long long )nr->id);
  (*RedisModule_ReplyWithSimpleString)(ctx, "type");
  if (nr->flags & (unsigned int )(1 << 2)) {
    tmp___4 = "classifier";
  } else {
    tmp___4 = "regressor";
  }
  (*RedisModule_ReplyWithSimpleString)(ctx, tmp___4);
  (*RedisModule_ReplyWithSimpleString)(ctx, "auto-normalization");
  (*RedisModule_ReplyWithLongLong)(ctx, (long long )(! (! (nr->flags & (unsigned int )(1 << 3)))));
  (*RedisModule_ReplyWithSimpleString)(ctx, "training");
  (*RedisModule_ReplyWithLongLong)(ctx, (long long )(! (! (nr->flags & 1U))));
  (*RedisModule_ReplyWithSimpleString)(ctx, "layout");
  (*RedisModule_ReplyWithArray)(ctx, (long )(nr->nn)->layers);
  i = (nr->nn)->layers - 1;
  while (i >= 0) {
    units = ((nr->nn)->layer + i)->units;
    if (i != 0) {
      units --;
    }
    (*RedisModule_ReplyWithLongLong)(ctx, (long long )units);
    i --;
  }
  (*RedisModule_ReplyWithSimpleString)(ctx, "training-dataset-maxlen");
  (*RedisModule_ReplyWithLongLong)(ctx, (long long )nr->dataset.maxlen);
  (*RedisModule_ReplyWithSimpleString)(ctx, "training-dataset-len");
  (*RedisModule_ReplyWithLongLong)(ctx, (long long )nr->dataset.len);
  (*RedisModule_ReplyWithSimpleString)(ctx, "test-dataset-maxlen");
  (*RedisModule_ReplyWithLongLong)(ctx, (long long )nr->test.maxlen);
  (*RedisModule_ReplyWithSimpleString)(ctx, "test-dataset-len");
  (*RedisModule_ReplyWithLongLong)(ctx, (long long )nr->test.len);
  (*RedisModule_ReplyWithSimpleString)(ctx, "training-total-steps");
  (*RedisModule_ReplyWithLongLong)(ctx, (long long )nr->training_total_steps);
  (*RedisModule_ReplyWithSimpleString)(ctx, "training-total-cycles");
  if (nr->dataset.len) {
    tmp___5 = nr->training_total_steps / (uint64_t )nr->dataset.len;
  } else {
    tmp___5 = (uint64_t )0;
  }
  (*RedisModule_ReplyWithLongLong)(ctx, (long long )tmp___5);
  (*RedisModule_ReplyWithSimpleString)(ctx, "training-total-seconds");
  snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%.02f",
           (double )((float )nr->training_total_ms / (float )1000));
  (*RedisModule_ReplyWithSimpleString)(ctx, (char const   *)(buf));
  (*RedisModule_ReplyWithSimpleString)(ctx, "dataset-error");
  (*RedisModule_ReplyWithDouble)(ctx, (double )nr->dataset_error);
  (*RedisModule_ReplyWithSimpleString)(ctx, "test-error");
  (*RedisModule_ReplyWithDouble)(ctx, (double )nr->test_error);
  if (nr->flags & (unsigned int )(1 << 2)) {
    (*RedisModule_ReplyWithSimpleString)(ctx, "classification-errors-perc");
    snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%.02f",
             (double )nr->test_class_error);
    (*RedisModule_ReplyWithSimpleString)(ctx, (char const   *)(buf));
  }
  (*RedisModule_ReplyWithSimpleString)(ctx, "overfitting-detected");
  if (nr->flags & (unsigned int )(1 << 5)) {
    tmp___6 = "yes";
  } else {
    tmp___6 = "no";
  }
  (*RedisModule_ReplyWithSimpleString)(ctx, tmp___6);
  return (0);
}
}
int NRThreads_RedisCommand(RedisModuleCtx *ctx , RedisModuleString **argv , int argc ) 
{ 
  int tmp ;
  int j ;
  char buf[1024] ;
  NRPendingTraining *pt ;
  char const   *keyname ;
  char const   *tmp___0 ;

  {
  (*RedisModule_AutoMemory)(ctx);
  NRCollectThreads(ctx);
  if (argc != 1) {
    tmp = (*RedisModule_WrongArity)(ctx);
    return (tmp);
  }
  pthread_mutex_lock(& NRPendingTrainingMutex);
  (*RedisModule_ReplyWithArray)(ctx, (long )NRPendingTrainingCount);
  j = 0;
  while (j < NRPendingTrainingCount) {
    pt = & NRTrainings[j];
    tmp___0 = (*RedisModule_StringPtrLen)((RedisModuleString const   *)pt->key, (size_t *)((void *)0));
    keyname = tmp___0;
    snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"nn_id=%llu cycle=%d key=%s db=%d maxtime=%llu maxcycles=%llu trainerr=%f testerr=%f classerr=%f",
             (unsigned long long )(pt->nr)->id, pt->curcycle, keyname, pt->db_id,
             (unsigned long long )(pt->nr)->training_max_ms, (unsigned long long )(pt->nr)->training_max_cycles,
             (double )pt->dataset_error, (double )pt->test_error, (double )pt->class_error);
    (*RedisModule_ReplyWithSimpleString)(ctx, (char const   *)(buf));
    j ++;
  }
  pthread_mutex_unlock(& NRPendingTrainingMutex);
  return (0);
}
}
int NRGetdata_RedisCommand(RedisModuleCtx *ctx , RedisModuleString **argv , int argc ) 
{ 
  int tmp ;
  RedisModuleKey *key ;
  void *tmp___0 ;
  int tmp___1 ;
  RedisModuleType *tmp___2 ;
  NRTypeObject *nr ;
  void *tmp___3 ;
  int ilen ;
  int olen ;
  NRDataset *target ;
  long long idx ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int j ;
  double input ;
  int j___0 ;
  double output ;

  {
  (*RedisModule_AutoMemory)(ctx);
  NRCollectThreads(ctx);
  if (argc != 4) {
    tmp = (*RedisModule_WrongArity)(ctx);
    return (tmp);
  }
  tmp___0 = (*RedisModule_OpenKey)(ctx, *(argv + 1), 1);
  key = (RedisModuleKey *)tmp___0;
  tmp___2 = (*RedisModule_ModuleTypeGetType)(key);
  if ((unsigned long )tmp___2 != (unsigned long )NRType) {
    tmp___1 = (*RedisModule_ReplyWithError)(ctx, "WRONGTYPE Operation against a key holding the wrong kind of value");
    return (tmp___1);
  }
  tmp___3 = (*RedisModule_ModuleTypeGetValue)(key);
  nr = (NRTypeObject *)tmp___3;
  ilen = ((nr->nn)->layer + ((nr->nn)->layers - 1))->units - 1;
  olen = ((nr->nn)->layer + 0)->units;
  target = (NRDataset *)((void *)0);
  tmp___7 = (*RedisModule_StringPtrLen)((RedisModuleString const   *)*(argv + 2),
                                        (size_t *)((void *)0));
  tmp___8 = strcasecmp(tmp___7, "train");
  if (tmp___8) {
    tmp___5 = (*RedisModule_StringPtrLen)((RedisModuleString const   *)*(argv + 2),
                                          (size_t *)((void *)0));
    tmp___6 = strcasecmp(tmp___5, "test");
    if (tmp___6) {
      tmp___4 = (*RedisModule_ReplyWithError)(ctx, "ERR please specify as source either TRAIN or TEST");
      return (tmp___4);
    } else {
      target = & nr->test;
    }
  } else {
    target = & nr->dataset;
  }
  tmp___11 = (*RedisModule_StringToLongLong)((RedisModuleString const   *)*(argv + 3),
                                             & idx);
  if (tmp___11 != 0) {
    tmp___9 = (*RedisModule_ReplyWithError)(ctx, "ERR invalid row specified");
    return (tmp___9);
  } else
  if (idx < 0LL) {
    tmp___9 = (*RedisModule_ReplyWithError)(ctx, "ERR invalid row specified");
    return (tmp___9);
  } else
  if (idx >= (long long )target->maxlen) {
    tmp___10 = (*RedisModule_ReplyWithNull)(ctx);
    return (tmp___10);
  }
  (*RedisModule_ReplyWithArray)(ctx, 2L);
  (*RedisModule_ReplyWithArray)(ctx, (long )ilen);
  j = 0;
  while (j < ilen) {
    input = (double )*(target->inputs + ((long long )ilen * idx + (long long )j));
    (*RedisModule_ReplyWithDouble)(ctx, input);
    j ++;
  }
  (*RedisModule_ReplyWithArray)(ctx, (long )olen);
  j___0 = 0;
  while (j___0 < olen) {
    output = (double )*(target->outputs + ((long long )olen * idx + (long long )j___0));
    (*RedisModule_ReplyWithDouble)(ctx, output);
    j___0 ++;
  }
  return (0);
}
}
void NRTypeRdbSaveDataset(RedisModuleIO *rdb , NRDataset *ds , uint32_t ilen , uint32_t olen ) 
{ 
  uint32_t j ;
  uint32_t j___0 ;

  {
  (*RedisModule_SaveUnsigned)(rdb, (uint64_t )ds->len);
  (*RedisModule_SaveUnsigned)(rdb, (uint64_t )ds->maxlen);
  j = (uint32_t )0;
  while (j < ilen * ds->len) {
    (*RedisModule_SaveFloat)(rdb, *(ds->inputs + j));
    j ++;
  }
  j___0 = (uint32_t )0;
  while (j___0 < olen * ds->len) {
    (*RedisModule_SaveFloat)(rdb, *(ds->outputs + j___0));
    j___0 ++;
  }
  return;
}
}
void NRTypeRdbSave(RedisModuleIO *rdb , void *value ) 
{ 
  NRTypeObject *nr ;
  int j ;
  int units ;
  int j___0 ;
  int weights ;
  int i ;
  int i___0 ;
  int i___1 ;
  uint32_t ilen ;
  uint32_t olen ;
  uint32_t j___1 ;
  uint32_t j___2 ;

  {
  nr = (NRTypeObject *)value;
  (*RedisModule_SaveUnsigned)(rdb, (uint64_t )(nr->nn)->layers);
  j = 0;
  while (j < (nr->nn)->layers) {
    units = ((nr->nn)->layer + j)->units;
    if (j != 0) {
      units --;
    }
    (*RedisModule_SaveUnsigned)(rdb, (uint64_t )units);
    j ++;
  }
  (*RedisModule_SaveUnsigned)(rdb, (uint64_t )(nr->flags & (unsigned int )((((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 5))));
  (*RedisModule_SaveUnsigned)(rdb, nr->id);
  (*RedisModule_SaveUnsigned)(rdb, nr->training_total_steps);
  (*RedisModule_SaveUnsigned)(rdb, nr->training_total_ms);
  (*RedisModule_SaveUnsigned)(rdb, nr->training_max_cycles);
  (*RedisModule_SaveUnsigned)(rdb, nr->training_max_ms);
  (*RedisModule_SaveFloat)(rdb, nr->dataset_error);
  (*RedisModule_SaveFloat)(rdb, nr->test_error);
  (*RedisModule_SaveFloat)(rdb, nr->test_class_error);
  j___0 = 1;
  while (j___0 < (nr->nn)->layers) {
    weights = ((nr->nn)->layer + j___0)->units * ((nr->nn)->layer + (j___0 - 1))->units;
    i = 0;
    while (i < weights) {
      (*RedisModule_SaveFloat)(rdb, *(((nr->nn)->layer + j___0)->weight + i));
      i ++;
    }
    i___0 = 0;
    while (i___0 < weights) {
      (*RedisModule_SaveFloat)(rdb, *(((nr->nn)->layer + j___0)->delta + i___0));
      i___0 ++;
    }
    i___1 = 0;
    while (i___1 < weights) {
      (*RedisModule_SaveFloat)(rdb, *(((nr->nn)->layer + j___0)->pgradient + i___1));
      i___1 ++;
    }
    j___0 ++;
  }
  ilen = (uint32_t )(((nr->nn)->layer + ((nr->nn)->layers - 1))->units - 1);
  olen = (uint32_t )((nr->nn)->layer + 0)->units;
  j___1 = (uint32_t )0;
  while (j___1 < ilen) {
    (*RedisModule_SaveFloat)(rdb, *(nr->inorm + j___1));
    j___1 ++;
  }
  j___2 = (uint32_t )0;
  while (j___2 < olen) {
    (*RedisModule_SaveFloat)(rdb, *(nr->onorm + j___2));
    j___2 ++;
  }
  NRTypeRdbSaveDataset(rdb, & nr->dataset, ilen, olen);
  NRTypeRdbSaveDataset(rdb, & nr->test, ilen, olen);
  return;
}
}
void NRTypeRdbLoadDataset(RedisModuleIO *rdb , NRDataset *ds , uint32_t ilen , uint32_t olen ) 
{ 
  uint64_t tmp ;
  uint64_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  uint32_t j ;
  uint32_t j___0 ;

  {
  tmp = (*RedisModule_LoadUnsigned)(rdb);
  ds->len = (uint32_t )tmp;
  tmp___0 = (*RedisModule_LoadUnsigned)(rdb);
  ds->maxlen = (uint32_t )tmp___0;
  if (ds->len == 0U) {
    return;
  }
  tmp___1 = (*RedisModule_Alloc)((unsigned long )(ilen * ds->len) * sizeof(float ));
  ds->inputs = (float *)tmp___1;
  tmp___2 = (*RedisModule_Alloc)((unsigned long )(olen * ds->len) * sizeof(float ));
  ds->outputs = (float *)tmp___2;
  j = (uint32_t )0;
  while (j < ilen * ds->len) {
    *(ds->inputs + j) = (*RedisModule_LoadFloat)(rdb);
    j ++;
  }
  j___0 = (uint32_t )0;
  while (j___0 < olen * ds->len) {
    *(ds->outputs + j___0) = (*RedisModule_LoadFloat)(rdb);
    j___0 ++;
  }
  return;
}
}
void *NRTypeRdbLoad(RedisModuleIO *rdb , int encver ) 
{ 
  uint64_t numlayers ;
  uint64_t tmp ;
  int *layers ;
  void *tmp___0 ;
  uint32_t j ;
  uint64_t tmp___1 ;
  uint32_t flags ;
  uint64_t tmp___2 ;
  NRTypeObject *nr ;
  NRTypeObject *tmp___3 ;
  int j___0 ;
  int weights ;
  int i ;
  int i___0 ;
  int i___1 ;
  uint32_t ilen ;
  uint32_t olen ;
  uint32_t j___1 ;
  uint32_t j___2 ;

  {
  if (encver != 2) {
    (*RedisModule_LogIOError)(rdb, "warning", "Sorry the Neural Redis module only supports RDB files written with the encoding version %d. This file has encoding version %d, and was likely written by a previous version of this module that is now deprecated. Once the module will be stable we\'ll start supporting older versions of the encodings, in case we switch to newer encodings.",
                              2, encver);
    return ((void *)0);
  }
  tmp = (*RedisModule_LoadUnsigned)(rdb);
  numlayers = tmp;
  tmp___0 = (*RedisModule_Alloc)(sizeof(int ) * numlayers);
  layers = (int *)tmp___0;
  j = (uint32_t )0;
  while ((uint64_t )j < numlayers) {
    tmp___1 = (*RedisModule_LoadUnsigned)(rdb);
    *(layers + j) = (int )tmp___1;
    j ++;
  }
  tmp___2 = (*RedisModule_LoadUnsigned)(rdb);
  flags = (uint32_t )tmp___2;
  tmp___3 = createNRTypeObject((int )flags, layers, (int )numlayers, 0, 0);
  nr = tmp___3;
  (*RedisModule_Free)((void *)layers);
  nr->id = (*RedisModule_LoadUnsigned)(rdb);
  nr->training_total_steps = (*RedisModule_LoadUnsigned)(rdb);
  nr->training_total_ms = (*RedisModule_LoadUnsigned)(rdb);
  nr->training_max_cycles = (*RedisModule_LoadUnsigned)(rdb);
  nr->training_max_ms = (*RedisModule_LoadUnsigned)(rdb);
  nr->dataset_error = (*RedisModule_LoadFloat)(rdb);
  nr->test_error = (*RedisModule_LoadFloat)(rdb);
  nr->test_class_error = (*RedisModule_LoadFloat)(rdb);
  j___0 = 1;
  while (j___0 < (nr->nn)->layers) {
    weights = ((nr->nn)->layer + j___0)->units * ((nr->nn)->layer + (j___0 - 1))->units;
    i = 0;
    while (i < weights) {
      *(((nr->nn)->layer + j___0)->weight + i) = (*RedisModule_LoadFloat)(rdb);
      i ++;
    }
    i___0 = 0;
    while (i___0 < weights) {
      *(((nr->nn)->layer + j___0)->delta + i___0) = (*RedisModule_LoadFloat)(rdb);
      i___0 ++;
    }
    i___1 = 0;
    while (i___1 < weights) {
      *(((nr->nn)->layer + j___0)->pgradient + i___1) = (*RedisModule_LoadFloat)(rdb);
      i___1 ++;
    }
    j___0 ++;
  }
  ilen = (uint32_t )(((nr->nn)->layer + ((nr->nn)->layers - 1))->units - 1);
  olen = (uint32_t )((nr->nn)->layer + 0)->units;
  j___1 = (uint32_t )0;
  while (j___1 < ilen) {
    *(nr->inorm + j___1) = (*RedisModule_LoadFloat)(rdb);
    j___1 ++;
  }
  j___2 = (uint32_t )0;
  while (j___2 < olen) {
    *(nr->onorm + j___2) = (*RedisModule_LoadFloat)(rdb);
    j___2 ++;
  }
  NRTypeRdbLoadDataset(rdb, & nr->dataset, ilen, olen);
  NRTypeRdbLoadDataset(rdb, & nr->test, ilen, olen);
  return ((void *)nr);
}
}
void NRTypeAofRewrite(RedisModuleIO *aof , RedisModuleString *key , void *value ) 
{ 


  {
  return;
}
}
void NRTypeFree(void *value ) 
{ 


  {
  NRTypeReleaseObject((NRTypeObject *)value);
  return;
}
}
int RedisModule_OnLoad(RedisModuleCtx *ctx , RedisModuleString **argv , int argc ) 
{ 
  int tmp ;
  RedisModuleTypeMethods tm ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  tmp = RedisModule_Init(ctx, "neuralredis", 1, 1);
  if (tmp == 1) {
    return (1);
  }
  tm.version = (uint64_t )1;
  tm.rdb_load = & NRTypeRdbLoad;
  tm.rdb_save = & NRTypeRdbSave;
  tm.aof_rewrite = & NRTypeAofRewrite;
  tm.mem_usage = (size_t (*)(void *value ))0;
  tm.digest = (void (*)(RedisModuleDigest *digest , void *value ))0;
  tm.free = & NRTypeFree;
  NRType = (*RedisModule_CreateDataType)(ctx, "neural-NN", 2, & tm);
  if ((unsigned long )NRType == (unsigned long )((void *)0)) {
    return (1);
  }
  tmp___0 = (*RedisModule_CreateCommand)(ctx, "nr.create", & NRCreate_RedisCommand,
                                         "write deny-oom", 1, 1, 1);
  if (tmp___0 == 1) {
    return (1);
  }
  tmp___1 = (*RedisModule_CreateCommand)(ctx, "nr.run", & NRRun_RedisCommand, "readonly",
                                         1, 1, 1);
  if (tmp___1 == 1) {
    return (1);
  }
  tmp___2 = (*RedisModule_CreateCommand)(ctx, "nr.class", & NRClass_RedisCommand,
                                         "readonly", 1, 1, 1);
  if (tmp___2 == 1) {
    return (1);
  }
  tmp___3 = (*RedisModule_CreateCommand)(ctx, "nr.observe", & NRObserve_RedisCommand,
                                         "write deny-oom", 1, 1, 1);
  if (tmp___3 == 1) {
    return (1);
  }
  tmp___4 = (*RedisModule_CreateCommand)(ctx, "nr.info", & NRInfo_RedisCommand, "readonly",
                                         1, 1, 1);
  if (tmp___4 == 1) {
    return (1);
  }
  tmp___5 = (*RedisModule_CreateCommand)(ctx, "nr.train", & NRTrain_RedisCommand,
                                         "write", 1, 1, 1);
  if (tmp___5 == 1) {
    return (1);
  }
  tmp___6 = (*RedisModule_CreateCommand)(ctx, "nr.reset", & NRReset_RedisCommand,
                                         "write", 1, 1, 1);
  if (tmp___6 == 1) {
    return (1);
  }
  tmp___7 = (*RedisModule_CreateCommand)(ctx, "nr.threads", & NRThreads_RedisCommand,
                                         "", 1, 1, 1);
  if (tmp___7 == 1) {
    return (1);
  }
  tmp___8 = (*RedisModule_CreateCommand)(ctx, "nr.getdata", & NRGetdata_RedisCommand,
                                         "readonly", 1, 1, 1);
  if (tmp___8 == 1) {
    return (1);
  }
  return (0);
}
}
#pragma merger("0","/tmp/cil-lZgRptPS.i","-Wall,-W,-O3,-fno-common,-g,-ggdb,-std=c99,-fPIC")
extern int printf(char const   * __restrict  __format  , ...) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__)) double exp(double __x ) ;
void AnnResetLayer(struct AnnLayer *layer ) ;
struct Ann *AnnAlloc(int layers ) ;
void AnnFreeLayer(struct AnnLayer *layer ) ;
int AnnInitLayer(struct Ann *net , int i , int units , int bias ) ;
struct Ann *AnnCreateNet2(int iunits , int ounits ) ;
struct Ann *AnnCreateNet3(int iunits , int hunits , int ounits ) ;
struct Ann *AnnCreateNet4(int iunits , int hunits , int hunits2 , int ounits ) ;
void Ann2Tcl(struct Ann *net ) ;
void AnnPrint(struct Ann *net ) ;
float AnnGlobalError(struct Ann *net , float *desired ) ;
void AnnSetInput(struct Ann *net , float *input ) ;
float AnnSimulateError(struct Ann *net , float *input , float *desired ) ;
void AnnCalculateGradientsTrivial(struct Ann *net , float *desired ) ;
void AnnCalculateGradients(struct Ann *net , float *desired ) ;
void AnnSetDeltas(struct Ann *net , float val ) ;
void AnnResetSgradient(struct Ann *net ) ;
void AnnScaleWeights(struct Ann *net , float factor ) ;
void AnnUpdateDeltasGD(struct Ann *net ) ;
void AnnUpdateSgradient(struct Ann *net ) ;
void AnnAdjustWeights(struct Ann *net , int setlen ) ;
void AnnAdjustWeightsResilientBP(struct Ann *net ) ;
float AnnResilientBPEpoch(struct Ann *net , float *input , float *desired , int setlen ) ;
float AnnTrainWithAlgoFunc(struct Ann *net , float *input , float *desired , float maxerr ,
                           int maxepochs , int setlen , float (*algo_func)(struct Ann *net ,
                                                                           float *input ,
                                                                           float *desired ,
                                                                           int setlen ) ) ;
float sigmoid(float x ) 
{ 
  double tmp ;

  {
  tmp = exp((double )(- x));
  return ((float )((double )((float )1) / ((double )1 + tmp)));
}
}
float relu(float x ) 
{ 
  float tmp ;

  {
  if (x > (float )0) {
    tmp = x;
  } else {
    tmp = (float )0;
  }
  return (tmp);
}
}
void AnnResetLayer(struct AnnLayer *layer ) 
{ 


  {
  layer->units = 0;
  layer->output = (float *)((void *)0);
  layer->error = (float *)((void *)0);
  layer->weight = (float *)((void *)0);
  layer->gradient = (float *)((void *)0);
  layer->pgradient = (float *)((void *)0);
  layer->delta = (float *)((void *)0);
  layer->sgradient = (float *)((void *)0);
  return;
}
}
struct Ann *AnnAlloc(int layers ) 
{ 
  struct Ann *net ;
  int i ;
  void *tmp ;
  struct AnnLayer *tmp___0 ;
  void *tmp___1 ;

  {
  tmp = malloc(sizeof(*net));
  net = (struct Ann *)tmp;
  if ((unsigned long )net == (unsigned long )((void *)0)) {
    return ((struct Ann *)((void *)0));
  }
  tmp___1 = malloc(sizeof(struct AnnLayer ) * (unsigned long )layers);
  tmp___0 = (struct AnnLayer *)tmp___1;
  net->layer = tmp___0;
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    free((void *)net);
    return ((struct Ann *)((void *)0));
  }
  net->layers = layers;
  net->flags = 0;
  net->rprop_nminus = (float )0.5;
  net->rprop_nplus = (float )1.2;
  net->rprop_maxupdate = (float )50;
  net->rprop_minupdate = (float )0.000001;
  i = 0;
  while (i < layers) {
    AnnResetLayer(net->layer + i);
    i ++;
  }
  return (net);
}
}
void AnnFreeLayer(struct AnnLayer *layer ) 
{ 


  {
  free((void *)layer->output);
  free((void *)layer->error);
  free((void *)layer->weight);
  free((void *)layer->gradient);
  free((void *)layer->pgradient);
  free((void *)layer->delta);
  free((void *)layer->sgradient);
  AnnResetLayer(layer);
  return;
}
}
void AnnFree(struct Ann *net ) 
{ 
  int i ;

  {
  i = 0;
  while (i < net->layers) {
    AnnFreeLayer(net->layer + i);
    i ++;
  }
  free((void *)net->layer);
  free((void *)net);
  return;
}
}
int AnnInitLayer(struct Ann *net , int i , int units , int bias ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
  if (bias) {
    units ++;
  }
  tmp = malloc(sizeof(float ) * (unsigned long )units);
  (net->layer + i)->output = (float *)tmp;
  tmp___0 = malloc(sizeof(float ) * (unsigned long )units);
  (net->layer + i)->error = (float *)tmp___0;
  if (i) {
    tmp___1 = malloc((sizeof(float ) * (unsigned long )units) * (unsigned long )(net->layer + (i - 1))->units);
    (net->layer + i)->weight = (float *)tmp___1;
    tmp___2 = malloc((sizeof(float ) * (unsigned long )units) * (unsigned long )(net->layer + (i - 1))->units);
    (net->layer + i)->gradient = (float *)tmp___2;
    tmp___3 = malloc((sizeof(float ) * (unsigned long )units) * (unsigned long )(net->layer + (i - 1))->units);
    (net->layer + i)->pgradient = (float *)tmp___3;
    tmp___4 = malloc((sizeof(float ) * (unsigned long )units) * (unsigned long )(net->layer + (i - 1))->units);
    (net->layer + i)->delta = (float *)tmp___4;
    tmp___5 = malloc((sizeof(float ) * (unsigned long )units) * (unsigned long )(net->layer + (i - 1))->units);
    (net->layer + i)->sgradient = (float *)tmp___5;
  }
  (net->layer + i)->units = units;
  if ((unsigned long )(net->layer + i)->output == (unsigned long )((void *)0)) {
    AnnFreeLayer(net->layer + i);
    AnnResetLayer(net->layer + i);
    return (1);
  } else
  if ((unsigned long )(net->layer + i)->error == (unsigned long )((void *)0)) {
    AnnFreeLayer(net->layer + i);
    AnnResetLayer(net->layer + i);
    return (1);
  } else
  if (i) {
    if ((unsigned long )(net->layer + i)->weight == (unsigned long )((void *)0)) {
      AnnFreeLayer(net->layer + i);
      AnnResetLayer(net->layer + i);
      return (1);
    } else {
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
  if (i) {
    if ((unsigned long )(net->layer + i)->gradient == (unsigned long )((void *)0)) {
      AnnFreeLayer(net->layer + i);
      AnnResetLayer(net->layer + i);
      return (1);
    } else {
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
  if (i) {
    if ((unsigned long )(net->layer + i)->pgradient == (unsigned long )((void *)0)) {
      AnnFreeLayer(net->layer + i);
      AnnResetLayer(net->layer + i);
      return (1);
    } else {
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
  if (i) {
    if ((unsigned long )(net->layer + i)->sgradient == (unsigned long )((void *)0)) {
      AnnFreeLayer(net->layer + i);
      AnnResetLayer(net->layer + i);
      return (1);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (i) {
    if ((unsigned long )(net->layer + i)->delta == (unsigned long )((void *)0)) {
      AnnFreeLayer(net->layer + i);
      AnnResetLayer(net->layer + i);
      return (1);
    }
  }
  memset((void *)(net->layer + i)->output, 0, sizeof(float ) * (unsigned long )units);
  memset((void *)(net->layer + i)->error, 0, sizeof(float ) * (unsigned long )units);
  if (i) {
    memset((void *)(net->layer + i)->weight, 0, (sizeof(float ) * (unsigned long )units) * (unsigned long )(net->layer + (i - 1))->units);
    memset((void *)(net->layer + i)->gradient, 0, (sizeof(float ) * (unsigned long )units) * (unsigned long )(net->layer + (i - 1))->units);
    memset((void *)(net->layer + i)->pgradient, 0, (sizeof(float ) * (unsigned long )units) * (unsigned long )(net->layer + (i - 1))->units);
    memset((void *)(net->layer + i)->delta, 0, (sizeof(float ) * (unsigned long )units) * (unsigned long )(net->layer + (i - 1))->units);
    memset((void *)(net->layer + i)->sgradient, 0, (sizeof(float ) * (unsigned long )units) * (unsigned long )(net->layer + (i - 1))->units);
  }
  if (bias) {
    *((net->layer + i)->output + (units - 1)) = (float )1;
  }
  return (0);
}
}
struct Ann *AnnClone(struct Ann *net ) 
{ 
  struct Ann *copy ;
  int j ;
  struct AnnLayer *ldst ;
  struct AnnLayer *lsrc ;
  int units ;
  int bias ;
  int tmp ;
  int weights ;

  {
  copy = AnnAlloc(net->layers);
  if ((unsigned long )copy == (unsigned long )((void *)0)) {
    return ((struct Ann *)((void *)0));
  }
  j = 0;
  while (j < net->layers) {
    units = (net->layer + j)->units;
    bias = j > 0;
    tmp = AnnInitLayer(copy, j, units - bias, bias);
    if (tmp) {
      AnnFree(copy);
      return ((struct Ann *)((void *)0));
    }
    lsrc = net->layer + j;
    ldst = copy->layer + j;
    if (lsrc->output) {
      memcpy((void * __restrict  )ldst->output, (void const   * __restrict  )lsrc->output,
             sizeof(float ) * (unsigned long )units);
    }
    if (lsrc->error) {
      memcpy((void * __restrict  )ldst->error, (void const   * __restrict  )lsrc->error,
             sizeof(float ) * (unsigned long )units);
    }
    if (j) {
      weights = (net->layer + j)->units * (net->layer + (j - 1))->units;
      if (lsrc->weight) {
        memcpy((void * __restrict  )ldst->weight, (void const   * __restrict  )lsrc->weight,
               sizeof(float ) * (unsigned long )weights);
      }
      if (lsrc->gradient) {
        memcpy((void * __restrict  )ldst->gradient, (void const   * __restrict  )lsrc->gradient,
               sizeof(float ) * (unsigned long )weights);
      }
      if (lsrc->pgradient) {
        memcpy((void * __restrict  )ldst->pgradient, (void const   * __restrict  )lsrc->pgradient,
               sizeof(float ) * (unsigned long )weights);
      }
      if (lsrc->delta) {
        memcpy((void * __restrict  )ldst->delta, (void const   * __restrict  )lsrc->delta,
               sizeof(float ) * (unsigned long )weights);
      }
      if (lsrc->sgradient) {
        memcpy((void * __restrict  )ldst->sgradient, (void const   * __restrict  )lsrc->sgradient,
               sizeof(float ) * (unsigned long )weights);
      }
    }
    j ++;
  }
  copy->rprop_nminus = net->rprop_nminus;
  copy->rprop_nplus = net->rprop_nplus;
  copy->rprop_maxupdate = net->rprop_maxupdate;
  copy->rprop_minupdate = net->rprop_minupdate;
  copy->flags = net->flags;
  return (copy);
}
}
struct Ann *AnnCreateNet(int layers , int *units ) 
{ 
  struct Ann *net ;
  int i ;
  int tmp ;

  {
  net = AnnAlloc(layers);
  if ((unsigned long )net == (unsigned long )((void *)0)) {
    return ((struct Ann *)((void *)0));
  }
  i = 0;
  while (i < layers) {
    tmp = AnnInitLayer(net, i, *(units + i), i > 0);
    if (tmp) {
      AnnFree(net);
      return ((struct Ann *)((void *)0));
    }
    i ++;
  }
  AnnSetRandomWeights(net);
  AnnSetDeltas(net, (float )0.1);
  net->learn_rate = (float )0.1;
  return (net);
}
}
size_t AnnCountWeights(struct Ann *net ) 
{ 
  size_t weights ;
  int i ;
  int nextunits ;
  int units ;

  {
  weights = (size_t )0;
  i = net->layers - 1;
  while (i > 0) {
    nextunits = (net->layer + (i - 1))->units;
    units = (net->layer + i)->units;
    if (i > 1) {
      nextunits --;
    }
    weights += (size_t )(units * nextunits);
    i --;
  }
  return (weights);
}
}
struct Ann *AnnCreateNet4(int iunits , int hunits , int hunits2 , int ounits ) 
{ 
  int units[4] ;
  struct Ann *tmp ;

  {
  units[0] = ounits;
  units[1] = hunits2;
  units[2] = hunits;
  units[3] = iunits;
  tmp = AnnCreateNet(4, units);
  return (tmp);
}
}
struct Ann *AnnCreateNet3(int iunits , int hunits , int ounits ) 
{ 
  int units[3] ;
  struct Ann *tmp ;

  {
  units[0] = ounits;
  units[1] = hunits;
  units[2] = iunits;
  tmp = AnnCreateNet(3, units);
  return (tmp);
}
}
struct Ann *AnnCreateNet2(int iunits , int ounits ) 
{ 
  int units[2] ;
  struct Ann *tmp ;

  {
  units[0] = ounits;
  units[1] = iunits;
  tmp = AnnCreateNet(2, units);
  return (tmp);
}
}
void AnnSimulate(struct Ann *net ) 
{ 
  int i ;
  int j ;
  int k ;
  int nextunits ;
  int units ;
  float A ;
  float *w ;
  float *o ;
  float *tmp ;
  float *tmp___0 ;

  {
  i = net->layers - 1;
  while (i > 0) {
    nextunits = (net->layer + (i - 1))->units;
    units = (net->layer + i)->units;
    if (i > 1) {
      nextunits --;
    }
    j = 0;
    while (j < nextunits) {
      A = (float )0;
      w = (net->layer + i)->weight + j * units;
      o = (net->layer + i)->output;
      k = 0;
      while (k < units) {
        tmp = w;
        w ++;
        tmp___0 = o;
        o ++;
        A += *tmp * *tmp___0;
        k ++;
      }
      *((net->layer + (i - 1))->output + j) = sigmoid(A);
      j ++;
    }
    i --;
  }
  return;
}
}
void Ann2Tcl(struct Ann *net ) 
{ 
  int i ;
  int j ;
  int k ;
  int nextunits ;
  int units ;
  float W ;

  {
  printf((char const   * __restrict  )"proc ann input {\n");
  printf((char const   * __restrict  )"    set output {");
  i = 0;
  while (i < (net->layer + 0)->units) {
    printf((char const   * __restrict  )"0 ");
    i ++;
  }
  printf((char const   * __restrict  )"}\n");
  i = net->layers - 1;
  while (i > 0) {
    nextunits = (net->layer + (i - 1))->units;
    units = (net->layer + i)->units;
    if (i > 1) {
      nextunits --;
    }
    j = 0;
    while (j < nextunits) {
      if (i == 1) {
        printf((char const   * __restrict  )"    lset output %d ", j);
      } else {
        printf((char const   * __restrict  )"    set O_%d_%d", i - 1, j);
      }
      printf((char const   * __restrict  )" [expr { \\\n");
      k = 0;
      while (k < units) {
        W = *((net->layer + i)->weight + (j * (net->layer + i)->units + k));
        if (i > 1) {
          if (k == units - 1) {
            printf((char const   * __restrict  )"        (%.9f)", (double )W);
          } else {
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
        if (i == net->layers - 1) {
          printf((char const   * __restrict  )"        (%.9f*[lindex $input %d])",
                 (double )W, k);
        } else {
          printf((char const   * __restrict  )"        (%.9f*$O_%d_%d)", (double )W,
                 i, k);
        }
        if (k + 1 < units) {
          printf((char const   * __restrict  )"+ \\\n");
        }
        k ++;
      }
      printf((char const   * __restrict  )"}]\n");
      if (i == 1) {
        printf((char const   * __restrict  )"    lset output %d [expr {1/(1+exp(-[lindex $output %d]))}]\n",
               j, j);
      } else {
        printf((char const   * __restrict  )"    lset O_%d_%d [expr {1/(1+exp(-$O_%d_%d))}]\n",
               i - 1, j, i - 1, j);
      }
      j ++;
    }
    i --;
  }
  printf((char const   * __restrict  )"    return $output\n");
  printf((char const   * __restrict  )"}\n");
  return;
}
}
void AnnPrint(struct Ann *net ) 
{ 
  int i ;
  int j ;
  int k ;
  char *layertype ;
  int targets ;

  {
  i = 0;
  while (i < net->layers) {
    layertype = (char *)"Hidden";
    if (i == 0) {
      layertype = (char *)"Output";
    }
    if (i == net->layers - 1) {
      layertype = (char *)"Input";
    }
    printf((char const   * __restrict  )"%s layer %d, units %d\n", layertype, i, (net->layer + i)->units);
    if (i) {
      targets = (net->layer + (i - 1))->units - (i - 1 > 0);
      printf((char const   * __restrict  )"\tW");
      j = 0;
      while (j < (net->layer + i)->units) {
        printf((char const   * __restrict  )"(");
        k = 0;
        while (k < targets) {
          printf((char const   * __restrict  )"%f", (double )*((net->layer + i)->weight + (k * (net->layer + i)->units + j)));
          if (k != targets - 1) {
            printf((char const   * __restrict  )" ");
          }
          k ++;
        }
        printf((char const   * __restrict  )") ");
        j ++;
      }
      printf((char const   * __restrict  )"\n");
      printf((char const   * __restrict  )"\tg");
      j = 0;
      while (j < (net->layer + i)->units) {
        printf((char const   * __restrict  )"[");
        k = 0;
        while (k < targets) {
          printf((char const   * __restrict  )"%f", (double )*((net->layer + i)->gradient + (k * (net->layer + i)->units + j)));
          if (k != targets - 1) {
            printf((char const   * __restrict  )" ");
          }
          k ++;
        }
        printf((char const   * __restrict  )"] ");
        j ++;
      }
      printf((char const   * __restrict  )"\n");
      printf((char const   * __restrict  )"\tG");
      j = 0;
      while (j < (net->layer + i)->units) {
        printf((char const   * __restrict  )"[");
        k = 0;
        while (k < targets) {
          printf((char const   * __restrict  )"%f", (double )*((net->layer + i)->sgradient + (k * (net->layer + i)->units + j)));
          if (k != targets - 1) {
            printf((char const   * __restrict  )" ");
          }
          k ++;
        }
        printf((char const   * __restrict  )"] ");
        j ++;
      }
      printf((char const   * __restrict  )"\n");
      printf((char const   * __restrict  )"\tP");
      j = 0;
      while (j < (net->layer + i)->units) {
        printf((char const   * __restrict  )"[");
        k = 0;
        while (k < targets) {
          printf((char const   * __restrict  )"%f", (double )*((net->layer + i)->pgradient + (k * (net->layer + i)->units + j)));
          if (k != targets - 1) {
            printf((char const   * __restrict  )" ");
          }
          k ++;
        }
        printf((char const   * __restrict  )"] ");
        j ++;
      }
      printf((char const   * __restrict  )"\n");
      printf((char const   * __restrict  )"\tD");
      j = 0;
      while (j < (net->layer + i)->units) {
        printf((char const   * __restrict  )"|");
        k = 0;
        while (k < targets) {
          printf((char const   * __restrict  )"%f", (double )*((net->layer + i)->delta + (k * (net->layer + i)->units + j)));
          if (k != targets - 1) {
            printf((char const   * __restrict  )" ");
          }
          k ++;
        }
        printf((char const   * __restrict  )"| ");
        j ++;
      }
      printf((char const   * __restrict  )"\n");
    }
    j = 0;
    while (j < (net->layer + i)->units) {
      printf((char const   * __restrict  )"\tO: %f ", (double )*((net->layer + i)->output + j));
      j ++;
    }
    printf((char const   * __restrict  )"\n");
    printf((char const   * __restrict  )"\tE /");
    j = 0;
    while (j < (net->layer + i)->units) {
      printf((char const   * __restrict  )"%f ", (double )*((net->layer + i)->error + j));
      j ++;
    }
    printf((char const   * __restrict  )"/\n");
    i ++;
  }
  return;
}
}
float AnnGlobalError(struct Ann *net , float *desired ) 
{ 
  float e ;
  float t ;
  int i ;
  int outputs ;

  {
  outputs = (net->layer + 0)->units;
  e = (float )0;
  i = 0;
  while (i < outputs) {
    t = *(desired + i) - *((net->layer + 0)->output + i);
    e += t * t;
    i ++;
  }
  return ((float )(.5 * (double )e));
}
}
void AnnSetInput(struct Ann *net , float *input ) 
{ 
  int i ;
  int inputs ;

  {
  inputs = (net->layer + (net->layers - 1))->units - 1;
  i = 0;
  while (i < inputs) {
    *((net->layer + (net->layers - 1))->output + i) = *(input + i);
    i ++;
  }
  return;
}
}
float AnnSimulateError(struct Ann *net , float *input , float *desired ) 
{ 
  float tmp ;

  {
  AnnSetInput(net, input);
  AnnSimulate(net);
  tmp = AnnGlobalError(net, desired);
  return (tmp);
}
}
void AnnCalculateOutputError(struct Ann *net , float *desired ) 
{ 
  int units ;
  float factor ;
  int j ;

  {
  units = (net->layer + 0)->units;
  factor = (float )2 / (float )units;
  j = 0;
  while (j < units) {
    *((net->layer + 0)->error + j) = factor * (*((net->layer + 0)->output + j) - *(desired + j));
    j ++;
  }
  return;
}
}
void AnnCalculateGradientsTrivial(struct Ann *net , float *desired ) 
{ 
  int j ;
  int i ;
  int layers ;
  int units ;
  int weights ;
  float t ;
  float e1 ;
  float e2 ;

  {
  layers = net->layers;
  j = 1;
  while (j < layers) {
    units = (net->layer + j)->units;
    weights = units * (net->layer + (j - 1))->units;
    i = 0;
    while (i < weights) {
      AnnSimulate(net);
      e1 = AnnGlobalError(net, desired);
      t = *((net->layer + j)->weight + i);
      *((net->layer + j)->weight + i) = (float )((double )*((net->layer + j)->weight + i) + 0.001);
      AnnSimulate(net);
      e2 = AnnGlobalError(net, desired);
      *((net->layer + j)->weight + i) = t;
      *((net->layer + j)->gradient + i) = (float )((double )(e2 - e1) / 0.001);
      i ++;
    }
    j ++;
  }
  return;
}
}
void AnnCalculateGradients(struct Ann *net , float *desired ) 
{ 
  int j ;
  int layers ;
  struct AnnLayer *layer ;
  struct AnnLayer *prev_layer ;
  int i ;
  int units ;
  int prevunits ;
  float error_signal ;
  float ei ;
  float oi ;
  float derivative ;
  int k ;
  float *g ;
  float *w ;
  float *o ;
  float *e ;
  float *tmp ;
  float *tmp___0 ;
  float *tmp___1 ;
  float *tmp___2 ;

  {
  layers = net->layers - 1;
  AnnCalculateOutputError(net, desired);
  j = 0;
  while (j < layers) {
    layer = net->layer + j;
    prev_layer = net->layer + (j + 1);
    units = layer->units;
    prevunits = prev_layer->units;
    if (j > 1) {
      units --;
    }
    i = 0;
    while (i < prevunits) {
      *(prev_layer->error + i) = (float )0;
      i ++;
    }
    i = 0;
    while (i < units) {
      ei = *(layer->error + i);
      oi = *(layer->output + i);
      derivative = oi * ((float )1 - oi);
      error_signal = ei * derivative;
      g = prev_layer->gradient + i * prevunits;
      w = prev_layer->weight + i * prevunits;
      o = prev_layer->output;
      e = prev_layer->error;
      k = 0;
      while (k < prevunits) {
        tmp = g;
        g ++;
        tmp___0 = o;
        o ++;
        *tmp = error_signal * *tmp___0;
        k ++;
      }
      k = 0;
      while (k < prevunits) {
        tmp___1 = e;
        e ++;
        tmp___2 = w;
        w ++;
        *tmp___1 += error_signal * *tmp___2;
        k ++;
      }
      i ++;
    }
    j ++;
  }
  return;
}
}
void AnnSetDeltas(struct Ann *net , float val ) 
{ 
  int j ;
  int layers ;
  int units ;
  int weights ;
  int i ;

  {
  layers = net->layers;
  j = 1;
  while (j < layers) {
    units = (net->layer + j)->units;
    weights = units * (net->layer + (j - 1))->units;
    i = 0;
    while (i < weights) {
      *((net->layer + j)->delta + i) = val;
      i ++;
    }
    j ++;
  }
  return;
}
}
void AnnResetSgradient(struct Ann *net ) 
{ 
  int j ;
  int layers ;
  int units ;
  int weights ;

  {
  layers = net->layers;
  j = 1;
  while (j < layers) {
    units = (net->layer + j)->units;
    weights = units * (net->layer + (j - 1))->units;
    memset((void *)(net->layer + j)->sgradient, 0, sizeof(float ) * (unsigned long )weights);
    j ++;
  }
  return;
}
}
void AnnSetRandomWeights(struct Ann *net ) 
{ 
  int i ;
  int j ;
  int k ;
  int tmp ;

  {
  i = 1;
  while (i < net->layers) {
    k = 0;
    while (k < (net->layer + (i - 1))->units) {
      j = 0;
      while (j < (net->layer + i)->units) {
        tmp = rand();
        *((net->layer + i)->weight + (k * (net->layer + i)->units + j)) = (float )(- 0.05 + .1 * ((double )tmp / ((double )2147483647 + 1.0)));
        j ++;
      }
      k ++;
    }
    i ++;
  }
  return;
}
}
void AnnScaleWeights(struct Ann *net , float factor ) 
{ 
  int j ;
  int layers ;
  int units ;
  int weights ;
  int i ;

  {
  layers = net->layers;
  j = 1;
  while (j < layers) {
    units = (net->layer + j)->units;
    weights = units * (net->layer + (j - 1))->units;
    i = 0;
    while (i < weights) {
      *((net->layer + j)->weight + i) *= factor;
      i ++;
    }
    j ++;
  }
  return;
}
}
void AnnUpdateSgradient(struct Ann *net ) 
{ 
  int j ;
  int i ;
  int layers ;
  int units ;
  int weights ;

  {
  layers = net->layers;
  j = 1;
  while (j < layers) {
    units = (net->layer + j)->units;
    weights = units * (net->layer + (j - 1))->units;
    i = 0;
    while (i < weights) {
      *((net->layer + j)->sgradient + i) += *((net->layer + j)->gradient + i);
      i ++;
    }
    j ++;
  }
  return;
}
}
float sign(float n ) 
{ 


  {
  if (n > (float )0) {
    return ((float )1);
  }
  if (n < (float )0) {
    return ((float )-1);
  }
  return ((float )0);
}
}
void AnnAdjustWeightsResilientBP(struct Ann *net ) 
{ 
  int j ;
  int i ;
  int layers ;
  int units ;
  int weights ;
  float t ;
  float delta ;
  float wdelta ;
  float tmp ;
  float past_wdelta ;
  float tmp___0 ;
  float wdelta___0 ;
  float tmp___1 ;

  {
  layers = net->layers;
  j = 1;
  while (j < layers) {
    units = (net->layer + j)->units;
    weights = units * (net->layer + (j - 1))->units - (j - 1 > 0);
    i = 0;
    while (i < weights) {
      t = *((net->layer + j)->pgradient + i) * *((net->layer + j)->sgradient + i);
      delta = *((net->layer + j)->delta + i);
      if (t > (float )0) {
        if (delta * net->rprop_nplus < net->rprop_maxupdate) {
          delta *= net->rprop_nplus;
        } else {
          delta = net->rprop_maxupdate;
        }
        tmp = sign(*((net->layer + j)->sgradient + i));
        wdelta = - tmp * delta;
        *((net->layer + j)->weight + i) += wdelta;
        *((net->layer + j)->delta + i) = delta;
        *((net->layer + j)->pgradient + i) = *((net->layer + j)->sgradient + i);
      } else
      if (t < (float )0) {
        tmp___0 = sign(*((net->layer + j)->pgradient + i));
        past_wdelta = - tmp___0 * delta;
        if (delta * net->rprop_nminus > net->rprop_minupdate) {
          delta *= net->rprop_nminus;
        } else {
          delta = net->rprop_minupdate;
        }
        *((net->layer + j)->weight + i) -= past_wdelta;
        *((net->layer + j)->delta + i) = delta;
        *((net->layer + j)->pgradient + i) = (float )0;
      } else {
        tmp___1 = sign(*((net->layer + j)->sgradient + i));
        wdelta___0 = - tmp___1 * delta;
        *((net->layer + j)->weight + i) += wdelta___0;
        *((net->layer + j)->pgradient + i) = *((net->layer + j)->sgradient + i);
      }
      i ++;
    }
    j ++;
  }
  return;
}
}
float AnnResilientBPEpoch(struct Ann *net , float *input , float *desired , int setlen ) 
{ 
  float error ;
  int j ;
  int inputs ;
  int outputs ;
  float tmp ;

  {
  error = (float )0;
  inputs = (net->layer + (net->layers - 1))->units - 1;
  outputs = (net->layer + 0)->units;
  AnnResetSgradient(net);
  j = 0;
  while (j < setlen) {
    tmp = AnnSimulateError(net, input, desired);
    error += tmp;
    AnnCalculateGradients(net, desired);
    AnnUpdateSgradient(net);
    input += inputs;
    desired += outputs;
    j ++;
  }
  AnnAdjustWeightsResilientBP(net);
  return (error / (float )setlen);
}
}
void AnnUpdateDeltasGD(struct Ann *net ) 
{ 
  int j ;
  int i ;
  int layers ;
  int units ;
  int weights ;

  {
  layers = net->layers;
  j = 1;
  while (j < layers) {
    units = (net->layer + j)->units;
    weights = units * (net->layer + (j - 1))->units;
    i = 0;
    while (i < weights) {
      *((net->layer + j)->delta + i) += *((net->layer + j)->gradient + i);
      i ++;
    }
    j ++;
  }
  return;
}
}
void AnnAdjustWeights(struct Ann *net , int setlen ) 
{ 
  int j ;
  int i ;
  int layers ;
  int units ;
  int weights ;

  {
  layers = net->layers;
  j = 1;
  while (j < layers) {
    units = (net->layer + j)->units;
    weights = units * (net->layer + (j - 1))->units;
    i = 0;
    while (i < weights) {
      *((net->layer + j)->weight + i) -= (net->learn_rate / (float )setlen) * *((net->layer + j)->delta + i);
      i ++;
    }
    j ++;
  }
  return;
}
}
float AnnGDEpoch(struct Ann *net , float *input , float *desidered , int setlen ) 
{ 
  float error ;
  int j ;
  int inputs ;
  int outputs ;
  float tmp ;

  {
  error = (float )0;
  inputs = (net->layer + (net->layers - 1))->units - 1;
  outputs = (net->layer + 0)->units;
  j = 0;
  while (j < setlen) {
    AnnSetDeltas(net, (float )0);
    tmp = AnnSimulateError(net, input, desidered);
    error += tmp;
    AnnCalculateGradients(net, desidered);
    AnnUpdateDeltasGD(net);
    input += inputs;
    desidered += outputs;
    AnnAdjustWeights(net, setlen);
    j ++;
  }
  return (error / (float )setlen);
}
}
int AnnTestClassError(struct Ann *net , float *desired ) 
{ 
  int i ;
  int outputs ;
  int classid ;
  int outid ;
  float max ;
  float o ;

  {
  outputs = (net->layer + 0)->units;
  max = (float )0;
  classid = 0;
  i = 0;
  while (i < outputs) {
    if (*(desired + i) == (float )1) {
      break;
    }
    i ++;
  }
  classid = i;
  max = *((net->layer + 0)->output + 0);
  outid = 0;
  i = 1;
  while (i < outputs) {
    o = *((net->layer + 0)->output + i);
    if (o > max) {
      outid = i;
      max = o;
    }
    i ++;
  }
  return (outid != classid);
}
}
void AnnTestError(struct Ann *net , float *input , float *desired , int setlen , float *avgerr ,
                  float *classerr ) 
{ 
  float error ;
  int j ;
  int inputs ;
  int outputs ;
  int class_errors ;
  float tmp ;
  int tmp___0 ;

  {
  error = (float )0;
  inputs = (net->layer + (net->layers - 1))->units - 1;
  outputs = (net->layer + 0)->units;
  class_errors = 0;
  j = 0;
  while (j < setlen) {
    tmp = AnnSimulateError(net, input, desired);
    error += tmp;
    if (classerr) {
      tmp___0 = AnnTestClassError(net, desired);
      class_errors += tmp___0;
    }
    input += inputs;
    desired += outputs;
    j ++;
  }
  if (avgerr) {
    *avgerr = error / (float )setlen;
  }
  if (classerr) {
    *classerr = ((float )class_errors * (float )100) / (float )setlen;
  }
  return;
}
}
float AnnTrainWithAlgoFunc(struct Ann *net , float *input , float *desired , float maxerr ,
                           int maxepochs , int setlen , float (*algo_func)(struct Ann *net ,
                                                                           float *input ,
                                                                           float *desired ,
                                                                           int setlen ) ) 
{ 
  int i ;
  float e ;
  int tmp ;

  {
  i = 0;
  e = maxerr + (float )1;
  while (1) {
    tmp = i;
    i ++;
    if (tmp < maxepochs) {
      if (! (e >= maxerr)) {
        break;
      }
    } else {
      break;
    }
    e = (*algo_func)(net, input, desired, setlen);
  }
  return (e);
}
}
float AnnTrain(struct Ann *net , float *input , float *desired , float maxerr , int maxepochs ,
               int setlen , int algo ) 
{ 
  float (*algo_func)(struct Ann *net , float *input , float *desired , int setlen ) ;
  float tmp ;

  {
  if (algo == 0) {
    algo_func = & AnnResilientBPEpoch;
  } else
  if (algo == 1) {
    algo_func = & AnnGDEpoch;
  } else {
    return ((float )-1);
  }
  tmp = AnnTrainWithAlgoFunc(net, input, desired, maxerr, maxepochs, setlen, algo_func);
  return (tmp);
}
}
