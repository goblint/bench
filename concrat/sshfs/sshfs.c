/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

struct fuse_opt {
   char const   *templ ;
   unsigned long offset ;
   int value ;
};
struct fuse_args {
   int argc ;
   char **argv ;
   int allocated ;
};
typedef __builtin_va_list __gnuc_va_list;
typedef unsigned int __uint32_t;
typedef unsigned long __uint64_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef int __pid_t;
typedef long __time_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef unsigned long __fsblkcnt64_t;
typedef unsigned long __fsfilcnt64_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
typedef __dev_t dev_t;
typedef __gid_t gid_t;
typedef __mode_t mode_t;
typedef __uid_t uid_t;
typedef __off64_t off_t;
typedef __ssize_t ssize_t;
typedef __time_t time_t;
typedef unsigned long size_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
typedef unsigned long pthread_t;
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
struct fuse_file_info {
   int flags ;
   unsigned int writepage : 1 ;
   unsigned int direct_io : 1 ;
   unsigned int keep_cache : 1 ;
   unsigned int flush : 1 ;
   unsigned int nonseekable : 1 ;
   unsigned int flock_release : 1 ;
   unsigned int cache_readdir : 1 ;
   unsigned int padding : 25 ;
   unsigned int padding2 : 32 ;
   uint64_t fh ;
   uint64_t lock_owner ;
   uint32_t poll_events ;
};
struct fuse_conn_info {
   unsigned int proto_major ;
   unsigned int proto_minor ;
   unsigned int max_write ;
   unsigned int max_read ;
   unsigned int max_readahead ;
   unsigned int capable ;
   unsigned int want ;
   unsigned int max_background ;
   unsigned int congestion_threshold ;
   unsigned int time_gran ;
   unsigned int reserved[22] ;
};
struct fuse_pollhandle ;
enum fuse_buf_flags {
    FUSE_BUF_IS_FD = 2,
    FUSE_BUF_FD_SEEK = 4,
    FUSE_BUF_FD_RETRY = 8
} ;
struct fuse_buf {
   size_t size ;
   enum fuse_buf_flags flags ;
   void *mem ;
   int fd ;
   off_t pos ;
};
struct fuse_bufvec {
   size_t count ;
   size_t idx ;
   size_t off ;
   struct fuse_buf buf[1] ;
};
struct flock {
   short l_type ;
   short l_whence ;
   __off64_t l_start ;
   __off64_t l_len ;
   __pid_t l_pid ;
};
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
struct statvfs {
   unsigned long f_bsize ;
   unsigned long f_frsize ;
   __fsblkcnt64_t f_blocks ;
   __fsblkcnt64_t f_bfree ;
   __fsblkcnt64_t f_bavail ;
   __fsfilcnt64_t f_files ;
   __fsfilcnt64_t f_ffree ;
   __fsfilcnt64_t f_favail ;
   unsigned long f_fsid ;
   unsigned long f_flag ;
   unsigned long f_namemax ;
   int __f_spare[6] ;
};
enum fuse_readdir_flags {
    FUSE_READDIR_PLUS = 1
} ;
enum fuse_fill_dir_flags {
    FUSE_FILL_DIR_PLUS = 2
} ;
struct fuse_config {
   int set_gid ;
   unsigned int gid ;
   int set_uid ;
   unsigned int uid ;
   int set_mode ;
   unsigned int umask ;
   double entry_timeout ;
   double negative_timeout ;
   double attr_timeout ;
   int intr ;
   int intr_signal ;
   int remember ;
   int hard_remove ;
   int use_ino ;
   int readdir_ino ;
   int direct_io ;
   int kernel_cache ;
   int auto_cache ;
   int ac_attr_timeout_set ;
   double ac_attr_timeout ;
   int nullpath_ok ;
   int show_help ;
   char *modules ;
   int debug ;
};
struct fuse_operations {
   int (*getattr)(char const   * , struct stat * , struct fuse_file_info *fi ) ;
   int (*readlink)(char const   * , char * , size_t  ) ;
   int (*mknod)(char const   * , mode_t  , dev_t  ) ;
   int (*mkdir)(char const   * , mode_t  ) ;
   int (*unlink)(char const   * ) ;
   int (*rmdir)(char const   * ) ;
   int (*symlink)(char const   * , char const   * ) ;
   int (*rename)(char const   * , char const   * , unsigned int flags ) ;
   int (*link)(char const   * , char const   * ) ;
   int (*chmod)(char const   * , mode_t  , struct fuse_file_info *fi ) ;
   int (*chown)(char const   * , uid_t  , gid_t  , struct fuse_file_info *fi ) ;
   int (*truncate)(char const   * , off_t  , struct fuse_file_info *fi ) ;
   int (*open)(char const   * , struct fuse_file_info * ) ;
   int (*read)(char const   * , char * , size_t  , off_t  , struct fuse_file_info * ) ;
   int (*write)(char const   * , char const   * , size_t  , off_t  , struct fuse_file_info * ) ;
   int (*statfs)(char const   * , struct statvfs * ) ;
   int (*flush)(char const   * , struct fuse_file_info * ) ;
   int (*release)(char const   * , struct fuse_file_info * ) ;
   int (*fsync)(char const   * , int  , struct fuse_file_info * ) ;
   int (*setxattr)(char const   * , char const   * , char const   * , size_t  , int  ) ;
   int (*getxattr)(char const   * , char const   * , char * , size_t  ) ;
   int (*listxattr)(char const   * , char * , size_t  ) ;
   int (*removexattr)(char const   * , char const   * ) ;
   int (*opendir)(char const   * , struct fuse_file_info * ) ;
   int (*readdir)(char const   * , void * , int (*)(void *buf , char const   *name ,
                                                    struct stat  const  *stbuf , off_t off ,
                                                    enum fuse_fill_dir_flags flags ) ,
                  off_t  , struct fuse_file_info * , enum fuse_readdir_flags  ) ;
   int (*releasedir)(char const   * , struct fuse_file_info * ) ;
   int (*fsyncdir)(char const   * , int  , struct fuse_file_info * ) ;
   void *(*init)(struct fuse_conn_info *conn , struct fuse_config *cfg ) ;
   void (*destroy)(void *private_data ) ;
   int (*access)(char const   * , int  ) ;
   int (*create)(char const   * , mode_t  , struct fuse_file_info * ) ;
   int (*lock)(char const   * , struct fuse_file_info * , int cmd , struct flock * ) ;
   int (*utimens)(char const   * , struct timespec  const  *tv , struct fuse_file_info *fi ) ;
   int (*bmap)(char const   * , size_t blocksize , uint64_t *idx ) ;
   int (*ioctl)(char const   * , unsigned int cmd , void *arg , struct fuse_file_info * ,
                unsigned int flags , void *data ) ;
   int (*poll)(char const   * , struct fuse_file_info * , struct fuse_pollhandle *ph ,
               unsigned int *reventsp ) ;
   int (*write_buf)(char const   * , struct fuse_bufvec *buf , off_t off , struct fuse_file_info * ) ;
   int (*read_buf)(char const   * , struct fuse_bufvec **bufp , size_t size , off_t off ,
                   struct fuse_file_info * ) ;
   int (*flock)(char const   * , struct fuse_file_info * , int op ) ;
   int (*fallocate)(char const   * , int  , off_t  , off_t  , struct fuse_file_info * ) ;
   ssize_t (*copy_file_range)(char const   *path_in , struct fuse_file_info *fi_in ,
                              off_t offset_in , char const   *path_out , struct fuse_file_info *fi_out ,
                              off_t offset_out , size_t size , int flags ) ;
   off_t (*lseek)(char const   * , off_t off , int whence , struct fuse_file_info * ) ;
};
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef unsigned long gsize;
typedef char gchar;
typedef int gint;
typedef gint gboolean;
typedef unsigned int guint;
typedef void *gpointer;
typedef void const   *gconstpointer;
struct _GPtrArray ;
typedef struct _GPtrArray GPtrArray;
struct _GPtrArray {
   gpointer *pdata ;
   guint len ;
};
struct _GHashTable ;
typedef struct _GHashTable GHashTable;
struct cache {
   int on ;
   unsigned int stat_timeout_secs ;
   unsigned int dir_timeout_secs ;
   unsigned int link_timeout_secs ;
   unsigned int max_size ;
   unsigned int clean_interval_secs ;
   unsigned int min_clean_interval_secs ;
   struct fuse_operations *next_oper ;
   GHashTable *table ;
   pthread_mutex_t lock ;
   time_t last_cleaned ;
   uint64_t write_ctr ;
};
struct node {
   struct stat stat ;
   time_t stat_valid ;
   char **dir ;
   time_t dir_valid ;
   char *link ;
   time_t link_valid ;
   time_t valid ;
};
struct readdir_handle {
   char const   *path ;
   void *buf ;
   int (*filler)(void *buf , char const   *name , struct stat  const  *stbuf , off_t off ,
                 enum fuse_fill_dir_flags flags ) ;
   GPtrArray *dir ;
   uint64_t wrctr ;
};
struct file_handle {
   int is_open ;
   unsigned long fs_fh ;
};
typedef unsigned char __uint8_t;
typedef unsigned long __ino64_t;
typedef long __suseconds_t;
typedef long __blkcnt64_t;
typedef unsigned int __socklen_t;
typedef __uint8_t uint8_t;
struct __anonstruct___sigset_t_991265788 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___sigset_t_991265788 __sigset_t;
typedef __sigset_t sigset_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
struct __anonstruct___wseq32_112954846 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_505876810 {
   unsigned long long __wseq ;
   struct __anonstruct___wseq32_112954846 __wseq32 ;
};
struct __anonstruct___g1_start32_897626227 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_897626226 {
   unsigned long long __g1_start ;
   struct __anonstruct___g1_start32_897626227 __g1_start32 ;
};
struct __pthread_cond_s {
   union __anonunion____missing_field_name_505876810 __annonCompField1 ;
   union __anonunion____missing_field_name_897626226 __annonCompField2 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
union __anonunion_pthread_condattr_t_488594145 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_condattr_t_488594145 pthread_condattr_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
union __anonunion_pthread_cond_t_951761805 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
typedef union __anonunion_pthread_cond_t_951761805 pthread_cond_t;
struct fuse_session ;
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
struct fuse ;
typedef __socklen_t socklen_t;
union __anonunion_sem_t_991265790 {
   char __size[32] ;
   long __align ;
};
typedef union __anonunion_sem_t_991265790 sem_t;
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
typedef void (*__sighandler_t)(int  );
typedef unsigned long nfds_t;
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
typedef unsigned long gulong;
struct _GList ;
typedef struct _GList GList;
struct _GList {
   gpointer data ;
   GList *next ;
   GList *prev ;
};
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
struct conn {
   pthread_mutex_t lock_write ;
   int processing_thread_started ;
   int rfd ;
   int wfd ;
   int connver ;
   int req_count ;
   int dir_count ;
   int file_count ;
};
struct buffer {
   uint8_t *p ;
   size_t len ;
   size_t size ;
};
struct dir_handle {
   struct buffer buf ;
   struct conn *conn ;
};
struct list_head {
   struct list_head *prev ;
   struct list_head *next ;
};
struct request ;
struct request {
   unsigned int want_reply ;
   sem_t ready ;
   uint8_t reply_type ;
   uint32_t id ;
   int replied ;
   int error ;
   struct buffer reply ;
   struct timeval start ;
   void *data ;
   void (*end_func)(struct request * ) ;
   size_t len ;
   struct list_head list ;
   struct conn *conn ;
};
struct sshfs_io {
   int num_reqs ;
   pthread_cond_t finished ;
   int error ;
};
struct read_req {
   struct sshfs_io *sio ;
   struct list_head list ;
   struct buffer data ;
   size_t size ;
   ssize_t res ;
};
struct read_chunk {
   off_t offset ;
   size_t size ;
   int refs ;
   long modifver ;
   struct list_head reqs ;
   struct sshfs_io sio ;
};
struct sshfs_file {
   struct buffer handle ;
   struct list_head write_reqs ;
   pthread_cond_t write_finished ;
   int write_error ;
   struct read_chunk *readahead ;
   off_t next_pos ;
   int is_seq ;
   struct conn *conn ;
   int connver ;
   int modifver ;
};
struct conntab_entry {
   unsigned int refcount ;
   struct conn *conn ;
};
struct sshfs {
   char *directport ;
   char *ssh_command ;
   char *sftp_server ;
   struct fuse_args ssh_args ;
   char *workarounds ;
   int rename_workaround ;
   int renamexdev_workaround ;
   int truncate_workaround ;
   int buflimit_workaround ;
   int unrel_append ;
   int fstat_workaround ;
   int createmode_workaround ;
   int transform_symlinks ;
   int follow_symlinks ;
   int no_check_root ;
   int detect_uid ;
   int idmap ;
   int nomap ;
   int disable_hardlink ;
   int dir_cache ;
   int show_version ;
   int show_help ;
   int singlethread ;
   char *mountpoint ;
   char *uid_file ;
   char *gid_file ;
   GHashTable *uid_map ;
   GHashTable *gid_map ;
   GHashTable *r_uid_map ;
   GHashTable *r_gid_map ;
   unsigned int max_read ;
   unsigned int max_write ;
   unsigned int ssh_ver ;
   int sync_write ;
   int sync_read ;
   int sync_readdir ;
   int direct_io ;
   int debug ;
   int verbose ;
   int foreground ;
   int reconnect ;
   int delay_connect ;
   int passive ;
   char *host ;
   char *base_path ;
   GHashTable *reqtab ;
   GHashTable *conntab ;
   pthread_mutex_t lock ;
   unsigned int randseed ;
   int max_conns ;
   struct conn *conns ;
   int ptyfd ;
   int ptypassivefd ;
   int connvers ;
   int server_version ;
   unsigned int remote_uid ;
   unsigned int local_uid ;
   unsigned int remote_gid ;
   unsigned int local_gid ;
   int remote_uid_detected ;
   unsigned int blksize ;
   char *progname ;
   long modifver ;
   unsigned int outstanding_len ;
   unsigned int max_outstanding_len ;
   pthread_cond_t outstanding_cond ;
   int password_stdin ;
   char *password ;
   int ext_posix_rename ;
   int ext_statvfs ;
   int ext_hardlink ;
   int ext_fsync ;
   struct fuse_operations *op ;
   uint64_t bytes_sent ;
   uint64_t bytes_received ;
   uint64_t num_sent ;
   uint64_t num_received ;
   unsigned int min_rtt ;
   unsigned int max_rtt ;
   uint64_t total_rtt ;
   unsigned int num_connect ;
};
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#pragma merger("0","/tmp/cil-y_4IlKfH.i","-fdiagnostics-color=always,-Wall,-Winvalid-pch,-O2,-g,-Wall,-Wextra,-Wno-sign-compare,-Wmissing-declarations,-Wwrite-strings,-Wno-unused-result,-pthread")
extern int fuse_opt_parse(struct fuse_args *args , void *data , struct fuse_opt  const  *opts ,
                          int (*proc)(void *data , char const   *arg , int key , struct fuse_args *outargs ) ) ;
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf )  __asm__("stat64")  ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf )  __asm__("fstat64")  ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag )  __asm__("fstatat64")  ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf )  __asm__("lstat64")  ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat)(int __ver ,
                                                                                     int __fildes ,
                                                                                     struct stat *__stat_buf )  __asm__("__fxstat64")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat)(int __ver ,
                                                                                      char const   *__filename ,
                                                                                      struct stat *__stat_buf )  __asm__("__xstat64")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat)(int __ver ,
                                                                                       char const   *__filename ,
                                                                                       struct stat *__stat_buf )  __asm__("__lxstat64")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4))) __fxstatat)(int __ver ,
                                                                                         int __fildes ,
                                                                                         char const   *__filename ,
                                                                                         struct stat *__stat_buf ,
                                                                                         int __flag )  __asm__("__fxstatat64")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4))) __xmknod)(int __ver ,
                                                                                       char const   *__path ,
                                                                                       __mode_t __mode ,
                                                                                       __dev_t *__dev ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,5))) __xmknodat)(int __ver ,
                                                                                         int __fd ,
                                                                                         char const   *__path ,
                                                                                         __mode_t __mode ,
                                                                                         __dev_t *__dev ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf )  __asm__("stat64")  ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) stat)(char const   * __restrict  __path ,
                                                                              struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __xstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf )  __asm__("lstat64")  ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) lstat)(char const   * __restrict  __path ,
                                                                               struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __lxstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf )  __asm__("fstat64")  ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) fstat)(int __fd ,
                                                                             struct stat *__statbuf ) 
{ 
  int tmp ;

  {
  tmp = __fxstat(1, __fd, __statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag )  __asm__("fstatat64")  ;
__inline extern int ( __attribute__((__nonnull__(2,3), __gnu_inline__)) fstatat)(int __fd ,
                                                                                 char const   * __restrict  __filename ,
                                                                                 struct stat * __restrict  __statbuf ,
                                                                                 int __flag ) 
{ 
  int tmp ;

  {
  tmp = __fxstatat(1, __fd, (char const   *)__filename, (struct stat *)__statbuf,
                   __flag);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) mknod)(char const   *__path ,
                                                                             __mode_t __mode ,
                                                                             __dev_t __dev ) 
{ 
  int tmp ;

  {
  tmp = __xmknod(0, __path, __mode, & __dev);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) mknodat)(int __fd ,
                                                                               char const   *__path ,
                                                                               __mode_t __mode ,
                                                                               __dev_t __dev ) 
{ 
  int tmp ;

  {
  tmp = __xmknodat(0, __fd, __path, __mode, & __dev);
  return (tmp);
}
}
struct fuse_operations *cache_wrap(struct fuse_operations *oper ) ;
int cache_parse_options(struct fuse_args *args ) ;
void cache_add_attr(char const   *path , struct stat  const  *stbuf , uint64_t wrctr ) ;
void cache_invalidate(char const   *path ) ;
uint64_t cache_get_write_ctr(void) ;
extern FILE *stdin ;
extern FILE *stdout ;
extern FILE *stderr ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) ;
extern int getc(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
extern int putc(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
extern int __uflow(FILE * ) ;
extern int __overflow(FILE * , int  ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) 
{ 
  int tmp ;

  {
  tmp = vfprintf((FILE * __restrict  )stdout, __fmt, __arg);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) 
{ 
  int tmp ;

  {
  tmp = getc(stdin);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(__fp);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = __fp->_IO_read_ptr;
    (__fp->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(stdin);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = stdin->_IO_read_ptr;
    (stdin->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) 
{ 
  int tmp ;

  {
  tmp = putc(__c, stdout);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = __stream->_IO_write_ptr;
    (__stream->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = stdout->_IO_write_ptr;
    (stdout->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 16) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 32) != 0);
}
}
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1))) strtoll)(char const   * __restrict  __nptr ,
                                                                                          char ** __restrict  __endptr ,
                                                                                          int __base ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) atoi)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return ((int )tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long ( __attribute__((__nonnull__(1), __gnu_inline__)) atol)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long long ( __attribute__((__nonnull__(1), __gnu_inline__)) atoll)(char const   *__nptr ) 
{ 
  long long tmp ;

  {
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
  __l = (size_t )0;
  __u = __nmemb;
  while (__l < __u) {
    __idx = (__l + __u) / 2UL;
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
    __comparison = (*__compar)(__key, __p);
    if (__comparison < 0) {
      __u = __idx;
    } else
    if (__comparison > 0) {
      __l = __idx + 1UL;
    } else {
      return ((void *)__p);
    }
  }
  return ((void *)0);
}
}
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern double ( __attribute__((__nonnull__(1), __gnu_inline__)) atof)(char const   *__nptr ) 
{ 
  double tmp ;

  {
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern GPtrArray *g_ptr_array_new(void) ;
extern gpointer *g_ptr_array_free(GPtrArray *array , gboolean free_seg ) ;
extern void g_ptr_array_add(GPtrArray *array , gpointer data ) ;
extern void g_free(gpointer mem ) ;
extern gpointer g_malloc0(gsize n_bytes )  __attribute__((__malloc__, __alloc_size__(1))) ;
extern gpointer g_malloc0_n(gsize n_blocks , gsize n_block_bytes )  __attribute__((__malloc__,
__alloc_size__(1,2))) ;
extern GHashTable *g_hash_table_new_full(guint (*hash_func)(gconstpointer key ) ,
                                         gboolean (*key_equal_func)(gconstpointer a ,
                                                                    gconstpointer b ) ,
                                         void (*key_destroy_func)(gpointer data ) ,
                                         void (*value_destroy_func)(gpointer data ) ) ;
extern gboolean g_hash_table_insert(GHashTable *hash_table , gpointer key , gpointer value ) ;
extern gboolean g_hash_table_remove(GHashTable *hash_table , gconstpointer key ) ;
extern gpointer g_hash_table_lookup(GHashTable *hash_table , gconstpointer key ) ;
extern guint g_hash_table_foreach_remove(GHashTable *hash_table , gboolean (*func)(gpointer key ,
                                                                                   gpointer value ,
                                                                                   gpointer user_data ) ,
                                         gpointer user_data ) ;
extern guint g_hash_table_size(GHashTable *hash_table ) ;
extern gboolean g_str_equal(gconstpointer v1 , gconstpointer v2 ) ;
extern guint g_str_hash(gconstpointer v ) ;
extern gchar *g_strdup(gchar const   *str )  __attribute__((__malloc__)) ;
extern gchar *( /* format attribute */  g_strdup_printf)(gchar const   *format  , ...)  __attribute__((__malloc__)) ;
extern gchar *g_strndup(gchar const   *str , gsize n )  __attribute__((__malloc__)) ;
extern void g_strfreev(gchar **str_array ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                     pthread_t __thread2 ) 
{ 


  {
  return (__thread1 == __thread2);
}
}
static struct cache cache  ;
static void free_node(gpointer node_ ) 
{ 
  struct node *node ;

  {
  node = (struct node *)node_;
  g_strfreev(node->dir);
  g_free((gpointer )node);
  return;
}
}
static int cache_clean_entry(void *key_ , struct node *node , time_t *now ) 
{ 


  {
  if (*now > node->valid) {
    return (1);
  } else {
    return (0);
  }
}
}
static void cache_clean(void) 
{ 
  time_t now ;
  time_t tmp ;
  guint tmp___0 ;

  {
  tmp = time((time_t *)((void *)0));
  now = tmp;
  if (now > cache.last_cleaned + (time_t )cache.min_clean_interval_secs) {
    tmp___0 = g_hash_table_size(cache.table);
    if (tmp___0 > cache.max_size) {
      g_hash_table_foreach_remove(cache.table, (gboolean (*)(gpointer key , gpointer value ,
                                                             gpointer user_data ))(& cache_clean_entry),
                                  (gpointer )(& now));
      cache.last_cleaned = now;
    } else
    if (now > cache.last_cleaned + (time_t )cache.clean_interval_secs) {
      g_hash_table_foreach_remove(cache.table, (gboolean (*)(gpointer key , gpointer value ,
                                                             gpointer user_data ))(& cache_clean_entry),
                                  (gpointer )(& now));
      cache.last_cleaned = now;
    }
  }
  return;
}
}
static struct node *cache_lookup(char const   *path ) 
{ 
  gpointer tmp ;

  {
  tmp = g_hash_table_lookup(cache.table, (gconstpointer )path);
  return ((struct node *)tmp);
}
}
static void cache_purge(char const   *path ) 
{ 


  {
  g_hash_table_remove(cache.table, (gconstpointer )path);
  return;
}
}
static void cache_purge_parent(char const   *path ) 
{ 
  char const   *s ;
  char *tmp ;
  char *parent ;
  gchar *tmp___0 ;

  {
  tmp = strrchr(path, '/');
  s = (char const   *)tmp;
  if (s) {
    if ((unsigned long )s == (unsigned long )path) {
      g_hash_table_remove(cache.table, (gconstpointer )"/");
    } else {
      tmp___0 = g_strndup(path, (gsize )(s - path));
      parent = tmp___0;
      cache_purge((char const   *)parent);
      g_free((gpointer )parent);
    }
  }
  return;
}
}
void cache_invalidate(char const   *path ) 
{ 


  {
  pthread_mutex_lock(& cache.lock);
  cache_purge(path);
  pthread_mutex_unlock(& cache.lock);
  return;
}
}
static void cache_invalidate_write(char const   *path ) 
{ 


  {
  pthread_mutex_lock(& cache.lock);
  cache_purge(path);
  (cache.write_ctr) ++;
  pthread_mutex_unlock(& cache.lock);
  return;
}
}
static void cache_invalidate_dir(char const   *path ) 
{ 


  {
  pthread_mutex_lock(& cache.lock);
  cache_purge(path);
  cache_purge_parent(path);
  pthread_mutex_unlock(& cache.lock);
  return;
}
}
static int cache_del_children(char const   *key , void *val_ , char const   *path ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  tmp = strlen(path);
  tmp___0 = strncmp(key, path, tmp);
  if (tmp___0 == 0) {
    return (1);
  } else {
    return (0);
  }
}
}
static void cache_do_rename(char const   *from , char const   *to ) 
{ 


  {
  pthread_mutex_lock(& cache.lock);
  g_hash_table_foreach_remove(cache.table, (gboolean (*)(gpointer key , gpointer value ,
                                                         gpointer user_data ))(& cache_del_children),
                              (gpointer )((char *)from));
  cache_purge(from);
  cache_purge(to);
  cache_purge_parent(from);
  cache_purge_parent(to);
  pthread_mutex_unlock(& cache.lock);
  return;
}
}
static struct node *cache_get(char const   *path ) 
{ 
  struct node *node ;
  struct node *tmp ;
  char *pathcopy ;
  gchar *tmp___0 ;
  gsize __n ;
  gsize __s ;
  gpointer __p ;

  {
  tmp = cache_lookup(path);
  node = tmp;
  if ((unsigned long )node == (unsigned long )((void *)0)) {
    tmp___0 = g_strdup(path);
    pathcopy = tmp___0;
    __n = (gsize )1;
    __s = sizeof(struct node );
    if (__s == 1UL) {
      __p = g_malloc0(__n);
    } else {
      __p = g_malloc0_n(__n, __s);
    }
    node = (struct node *)__p;
    g_hash_table_insert(cache.table, (gpointer )pathcopy, (gpointer )node);
  }
  return (node);
}
}
void cache_add_attr(char const   *path , struct stat  const  *stbuf , uint64_t wrctr ) 
{ 
  struct node *node ;
  time_t tmp ;

  {
  pthread_mutex_lock(& cache.lock);
  if (wrctr == cache.write_ctr) {
    node = cache_get(path);
    node->stat = (struct stat )*stbuf;
    tmp = time((time_t *)((void *)0));
    node->stat_valid = tmp + (time_t )cache.stat_timeout_secs;
    if (node->stat_valid > node->valid) {
      node->valid = node->stat_valid;
    }
    cache_clean();
  }
  pthread_mutex_unlock(& cache.lock);
  return;
}
}
static void cache_add_dir(char const   *path , char **dir ) 
{ 
  struct node *node ;
  time_t tmp ;

  {
  pthread_mutex_lock(& cache.lock);
  node = cache_get(path);
  g_strfreev(node->dir);
  node->dir = dir;
  tmp = time((time_t *)((void *)0));
  node->dir_valid = tmp + (time_t )cache.dir_timeout_secs;
  if (node->dir_valid > node->valid) {
    node->valid = node->dir_valid;
  }
  cache_clean();
  pthread_mutex_unlock(& cache.lock);
  return;
}
}
static size_t my_strnlen(char const   *s , size_t maxsize ) 
{ 
  char const   *p ;

  {
  p = s;
  while (1) {
    if (maxsize) {
      if (! *p) {
        break;
      }
    } else {
      break;
    }
    maxsize --;
    p ++;
  }
  return ((size_t )(p - s));
}
}
static void cache_add_link(char const   *path , char const   *link , size_t size ) 
{ 
  struct node *node ;
  size_t tmp ;
  time_t tmp___0 ;

  {
  pthread_mutex_lock(& cache.lock);
  node = cache_get(path);
  g_free((gpointer )node->link);
  tmp = my_strnlen(link, size - 1UL);
  node->link = g_strndup(link, tmp);
  tmp___0 = time((time_t *)((void *)0));
  node->link_valid = tmp___0 + (time_t )cache.link_timeout_secs;
  if (node->link_valid > node->valid) {
    node->valid = node->link_valid;
  }
  cache_clean();
  pthread_mutex_unlock(& cache.lock);
  return;
}
}
static int cache_get_attr(char const   *path , struct stat *stbuf ) 
{ 
  struct node *node ;
  int err ;
  time_t now ;
  time_t tmp ;

  {
  err = -11;
  pthread_mutex_lock(& cache.lock);
  node = cache_lookup(path);
  if ((unsigned long )node != (unsigned long )((void *)0)) {
    tmp = time((time_t *)((void *)0));
    now = tmp;
    if (node->stat_valid - now >= 0L) {
      *stbuf = node->stat;
      err = 0;
    }
  }
  pthread_mutex_unlock(& cache.lock);
  return (err);
}
}
uint64_t cache_get_write_ctr(void) 
{ 
  uint64_t res ;

  {
  pthread_mutex_lock(& cache.lock);
  res = cache.write_ctr;
  pthread_mutex_unlock(& cache.lock);
  return (res);
}
}
static void *cache_init(struct fuse_conn_info *conn , struct fuse_config *cfg ) 
{ 
  void *res ;

  {
  res = (*((cache.next_oper)->init))(conn, cfg);
  cfg->nullpath_ok = 0;
  return (res);
}
}
static int cache_getattr(char const   *path , struct stat *stbuf , struct fuse_file_info *fi ) 
{ 
  int err ;
  int tmp ;
  uint64_t wrctr ;
  uint64_t tmp___0 ;

  {
  tmp = cache_get_attr(path, stbuf);
  err = tmp;
  if (err) {
    tmp___0 = cache_get_write_ctr();
    wrctr = tmp___0;
    err = (*((cache.next_oper)->getattr))(path, stbuf, fi);
    if (! err) {
      cache_add_attr(path, (struct stat  const  *)stbuf, wrctr);
    }
  }
  return (err);
}
}
static int cache_readlink(char const   *path , char *buf , size_t size ) 
{ 
  struct node *node ;
  int err ;
  time_t now ;
  time_t tmp ;

  {
  pthread_mutex_lock(& cache.lock);
  node = cache_lookup(path);
  if ((unsigned long )node != (unsigned long )((void *)0)) {
    tmp = time((time_t *)((void *)0));
    now = tmp;
    if (node->link_valid - now >= 0L) {
      strncpy((char * __restrict  )buf, (char const   * __restrict  )node->link, size - 1UL);
      *(buf + (size - 1UL)) = (char )'\000';
      pthread_mutex_unlock(& cache.lock);
      return (0);
    }
  }
  pthread_mutex_unlock(& cache.lock);
  err = (*((cache.next_oper)->readlink))(path, buf, size);
  if (! err) {
    cache_add_link(path, (char const   *)buf, size);
  }
  return (err);
}
}
static int cache_opendir(char const   *path , struct fuse_file_info *fi ) 
{ 
  struct file_handle *cfi ;
  void *tmp ;

  {
  tmp = malloc(sizeof(struct file_handle ));
  cfi = (struct file_handle *)tmp;
  if ((unsigned long )cfi == (unsigned long )((void *)0)) {
    return (-12);
  }
  cfi->is_open = 0;
  fi->fh = (unsigned long )cfi;
  return (0);
}
}
static int cache_releasedir(char const   *path , struct fuse_file_info *fi ) 
{ 
  int err ;
  struct file_handle *cfi ;

  {
  cfi = (struct file_handle *)fi->fh;
  if (cfi->is_open) {
    fi->fh = cfi->fs_fh;
    err = (*((cache.next_oper)->releasedir))(path, fi);
  } else {
    err = 0;
  }
  free((void *)cfi);
  return (err);
}
}
static int cache_dirfill(void *buf , char const   *name , struct stat  const  *stbuf ,
                         off_t off , enum fuse_fill_dir_flags flags ) 
{ 
  int err ;
  struct readdir_handle *ch ;
  gchar *tmp ;
  char *fullpath ;
  char const   *basepath ;
  char const   *tmp___0 ;

  {
  ch = (struct readdir_handle *)buf;
  err = (*(ch->filler))(ch->buf, name, stbuf, off, flags);
  if (! err) {
    tmp = g_strdup(name);
    g_ptr_array_add(ch->dir, (gpointer )tmp);
    if (stbuf->st_mode & 61440U) {
      if (! *(ch->path + 1)) {
        tmp___0 = "";
      } else {
        tmp___0 = ch->path;
      }
      basepath = tmp___0;
      fullpath = g_strdup_printf("%s/%s", basepath, name);
      cache_add_attr((char const   *)fullpath, stbuf, ch->wrctr);
      g_free((gpointer )fullpath);
    }
  }
  return (err);
}
}
static int cache_readdir(char const   *path , void *buf , int (*filler)(void *buf ,
                                                                        char const   *name ,
                                                                        struct stat  const  *stbuf ,
                                                                        off_t off ,
                                                                        enum fuse_fill_dir_flags flags ) ,
                         off_t offset , struct fuse_file_info *fi , enum fuse_readdir_flags flags ) 
{ 
  struct readdir_handle ch ;
  struct file_handle *cfi ;
  int err ;
  char **dir ;
  struct node *node ;
  time_t now ;
  time_t tmp___0 ;

  {
  if (! (offset == 0L)) {
    __assert_fail("offset == 0", "../cache.c", 367U, "cache_readdir");
  }
  pthread_mutex_lock(& cache.lock);
  node = cache_lookup(path);
  if ((unsigned long )node != (unsigned long )((void *)0)) {
    if ((unsigned long )node->dir != (unsigned long )((void *)0)) {
      tmp___0 = time((time_t *)((void *)0));
      now = tmp___0;
      if (node->dir_valid - now >= 0L) {
        dir = node->dir;
        while ((unsigned long )*dir != (unsigned long )((void *)0)) {
          (*filler)(buf, (char const   *)*dir, (struct stat  const  *)((void *)0),
                    (off_t )0, (enum fuse_fill_dir_flags )0);
          dir ++;
        }
        pthread_mutex_unlock(& cache.lock);
        return (0);
      }
    }
  }
  pthread_mutex_unlock(& cache.lock);
  cfi = (struct file_handle *)fi->fh;
  if (cfi->is_open) {
    fi->fh = cfi->fs_fh;
  } else {
    if ((cache.next_oper)->opendir) {
      err = (*((cache.next_oper)->opendir))(path, fi);
      if (err) {
        return (err);
      }
    }
    cfi->is_open = 1;
    cfi->fs_fh = fi->fh;
  }
  ch.path = path;
  ch.buf = buf;
  ch.filler = filler;
  ch.dir = g_ptr_array_new();
  ch.wrctr = cache_get_write_ctr();
  err = (*((cache.next_oper)->readdir))(path, (void *)(& ch), & cache_dirfill, offset,
                                        fi, flags);
  g_ptr_array_add(ch.dir, (void *)0);
  dir = (char **)(ch.dir)->pdata;
  if (! err) {
    cache_add_dir(path, dir);
  } else {
    g_strfreev(dir);
  }
  g_ptr_array_free(ch.dir, 0);
  return (err);
}
}
static int cache_mknod(char const   *path , mode_t mode , dev_t rdev ) 
{ 
  int err ;
  int tmp ;

  {
  tmp = (*((cache.next_oper)->mknod))(path, mode, rdev);
  err = tmp;
  if (! err) {
    cache_invalidate_dir(path);
  }
  return (err);
}
}
static int cache_mkdir(char const   *path , mode_t mode ) 
{ 
  int err ;
  int tmp ;

  {
  tmp = (*((cache.next_oper)->mkdir))(path, mode);
  err = tmp;
  if (! err) {
    cache_invalidate_dir(path);
  }
  return (err);
}
}
static int cache_unlink(char const   *path ) 
{ 
  int err ;
  int tmp ;

  {
  tmp = (*((cache.next_oper)->unlink))(path);
  err = tmp;
  if (! err) {
    cache_invalidate_dir(path);
  }
  return (err);
}
}
static int cache_rmdir(char const   *path ) 
{ 
  int err ;
  int tmp ;

  {
  tmp = (*((cache.next_oper)->rmdir))(path);
  err = tmp;
  if (! err) {
    cache_invalidate_dir(path);
  }
  return (err);
}
}
static int cache_symlink(char const   *from , char const   *to ) 
{ 
  int err ;
  int tmp ;

  {
  tmp = (*((cache.next_oper)->symlink))(from, to);
  err = tmp;
  if (! err) {
    cache_invalidate_dir(to);
  }
  return (err);
}
}
static int cache_rename(char const   *from , char const   *to , unsigned int flags ) 
{ 
  int err ;
  int tmp ;

  {
  tmp = (*((cache.next_oper)->rename))(from, to, flags);
  err = tmp;
  if (! err) {
    cache_do_rename(from, to);
  }
  return (err);
}
}
static int cache_link(char const   *from , char const   *to ) 
{ 
  int err ;
  int tmp ;

  {
  tmp = (*((cache.next_oper)->link))(from, to);
  err = tmp;
  if (! err) {
    cache_invalidate(from);
    cache_invalidate_dir(to);
  }
  return (err);
}
}
static int cache_chmod(char const   *path , mode_t mode , struct fuse_file_info *fi ) 
{ 
  int err ;
  int tmp ;

  {
  tmp = (*((cache.next_oper)->chmod))(path, mode, fi);
  err = tmp;
  if (! err) {
    cache_invalidate(path);
  }
  return (err);
}
}
static int cache_chown(char const   *path , uid_t uid , gid_t gid , struct fuse_file_info *fi ) 
{ 
  int err ;
  int tmp ;

  {
  tmp = (*((cache.next_oper)->chown))(path, uid, gid, fi);
  err = tmp;
  if (! err) {
    cache_invalidate(path);
  }
  return (err);
}
}
static int cache_utimens(char const   *path , struct timespec  const  *tv , struct fuse_file_info *fi ) 
{ 
  int err ;
  int tmp ;

  {
  tmp = (*((cache.next_oper)->utimens))(path, tv, fi);
  err = tmp;
  if (! err) {
    cache_invalidate(path);
  }
  return (err);
}
}
static int cache_write(char const   *path , char const   *buf , size_t size , off_t offset ,
                       struct fuse_file_info *fi ) 
{ 
  int res ;
  int tmp ;

  {
  tmp = (*((cache.next_oper)->write))(path, buf, size, offset, fi);
  res = tmp;
  if (res >= 0) {
    cache_invalidate_write(path);
  }
  return (res);
}
}
static int cache_create(char const   *path , mode_t mode , struct fuse_file_info *fi ) 
{ 
  int err ;
  int tmp ;

  {
  tmp = (*((cache.next_oper)->create))(path, mode, fi);
  err = tmp;
  if (! err) {
    cache_invalidate_dir(path);
  }
  return (err);
}
}
static int cache_truncate(char const   *path , off_t size , struct fuse_file_info *fi ) 
{ 
  int err ;
  int tmp ;

  {
  tmp = (*((cache.next_oper)->truncate))(path, size, fi);
  err = tmp;
  if (! err) {
    cache_invalidate(path);
  }
  return (err);
}
}
static void cache_fill(struct fuse_operations *oper , struct fuse_operations *cache_oper___0 ) 
{ 


  {
  cache_oper___0->access = oper->access;
  if (oper->chmod) {
    cache_oper___0->chmod = & cache_chmod;
  } else {
    cache_oper___0->chmod = (int (*)(char const   * , mode_t  , struct fuse_file_info *fi ))((void *)0);
  }
  if (oper->chown) {
    cache_oper___0->chown = & cache_chown;
  } else {
    cache_oper___0->chown = (int (*)(char const   * , uid_t  , gid_t  , struct fuse_file_info *fi ))((void *)0);
  }
  if (oper->create) {
    cache_oper___0->create = & cache_create;
  } else {
    cache_oper___0->create = (int (*)(char const   * , mode_t  , struct fuse_file_info * ))((void *)0);
  }
  cache_oper___0->flush = oper->flush;
  cache_oper___0->fsync = oper->fsync;
  if (oper->getattr) {
    cache_oper___0->getattr = & cache_getattr;
  } else {
    cache_oper___0->getattr = (int (*)(char const   * , struct stat * , struct fuse_file_info *fi ))((void *)0);
  }
  cache_oper___0->getxattr = oper->getxattr;
  cache_oper___0->init = & cache_init;
  if (oper->link) {
    cache_oper___0->link = & cache_link;
  } else {
    cache_oper___0->link = (int (*)(char const   * , char const   * ))((void *)0);
  }
  cache_oper___0->listxattr = oper->listxattr;
  if (oper->mkdir) {
    cache_oper___0->mkdir = & cache_mkdir;
  } else {
    cache_oper___0->mkdir = (int (*)(char const   * , mode_t  ))((void *)0);
  }
  if (oper->mknod) {
    cache_oper___0->mknod = & cache_mknod;
  } else {
    cache_oper___0->mknod = (int (*)(char const   * , mode_t  , dev_t  ))((void *)0);
  }
  cache_oper___0->open = oper->open;
  cache_oper___0->opendir = & cache_opendir;
  cache_oper___0->read = oper->read;
  if (oper->readdir) {
    cache_oper___0->readdir = & cache_readdir;
  } else {
    cache_oper___0->readdir = (int (*)(char const   * , void * , int (*)(void *buf ,
                                                                         char const   *name ,
                                                                         struct stat  const  *stbuf ,
                                                                         off_t off ,
                                                                         enum fuse_fill_dir_flags flags ) ,
                                       off_t  , struct fuse_file_info * , enum fuse_readdir_flags  ))((void *)0);
  }
  if (oper->readlink) {
    cache_oper___0->readlink = & cache_readlink;
  } else {
    cache_oper___0->readlink = (int (*)(char const   * , char * , size_t  ))((void *)0);
  }
  cache_oper___0->release = oper->release;
  cache_oper___0->releasedir = & cache_releasedir;
  cache_oper___0->removexattr = oper->removexattr;
  if (oper->rename) {
    cache_oper___0->rename = & cache_rename;
  } else {
    cache_oper___0->rename = (int (*)(char const   * , char const   * , unsigned int flags ))((void *)0);
  }
  if (oper->rmdir) {
    cache_oper___0->rmdir = & cache_rmdir;
  } else {
    cache_oper___0->rmdir = (int (*)(char const   * ))((void *)0);
  }
  cache_oper___0->setxattr = oper->setxattr;
  cache_oper___0->statfs = oper->statfs;
  if (oper->symlink) {
    cache_oper___0->symlink = & cache_symlink;
  } else {
    cache_oper___0->symlink = (int (*)(char const   * , char const   * ))((void *)0);
  }
  if (oper->truncate) {
    cache_oper___0->truncate = & cache_truncate;
  } else {
    cache_oper___0->truncate = (int (*)(char const   * , off_t  , struct fuse_file_info *fi ))((void *)0);
  }
  if (oper->unlink) {
    cache_oper___0->unlink = & cache_unlink;
  } else {
    cache_oper___0->unlink = (int (*)(char const   * ))((void *)0);
  }
  if (oper->utimens) {
    cache_oper___0->utimens = & cache_utimens;
  } else {
    cache_oper___0->utimens = (int (*)(char const   * , struct timespec  const  *tv ,
                                       struct fuse_file_info *fi ))((void *)0);
  }
  if (oper->write) {
    cache_oper___0->write = & cache_write;
  } else {
    cache_oper___0->write = (int (*)(char const   * , char const   * , size_t  , off_t  ,
                                     struct fuse_file_info * ))((void *)0);
  }
  return;
}
}
static struct fuse_operations cache_oper  ;
struct fuse_operations *cache_wrap(struct fuse_operations *oper ) 
{ 


  {
  cache.next_oper = oper;
  cache_fill(oper, & cache_oper);
  pthread_mutex_init(& cache.lock, (pthread_mutexattr_t const   *)((void *)0));
  cache.table = g_hash_table_new_full(& g_str_hash, & g_str_equal, & g_free, & free_node);
  if ((unsigned long )cache.table == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"failed to create cache\n");
    return ((struct fuse_operations *)((void *)0));
  }
  return (& cache_oper);
}
}
static struct fuse_opt  const  cache_opts[19]  = 
  {      {"dcache_timeout=%u", (unsigned long )(& ((struct cache *)0)->stat_timeout_secs),
      0}, 
        {"dcache_timeout=%u", (unsigned long )(& ((struct cache *)0)->dir_timeout_secs),
      0}, 
        {"dcache_timeout=%u", (unsigned long )(& ((struct cache *)0)->link_timeout_secs),
      0}, 
        {"dcache_stat_timeout=%u", (unsigned long )(& ((struct cache *)0)->stat_timeout_secs),
      0}, 
        {"dcache_dir_timeout=%u", (unsigned long )(& ((struct cache *)0)->dir_timeout_secs),
      0}, 
        {"dcache_link_timeout=%u", (unsigned long )(& ((struct cache *)0)->link_timeout_secs),
      0}, 
        {"dcache_max_size=%u", (unsigned long )(& ((struct cache *)0)->max_size), 0}, 
        {"dcache_clean_interval=%u",
      (unsigned long )(& ((struct cache *)0)->clean_interval_secs), 0}, 
        {"dcache_min_clean_interval=%u", (unsigned long )(& ((struct cache *)0)->min_clean_interval_secs),
      0}, 
        {"cache_timeout=%u", (unsigned long )(& ((struct cache *)0)->stat_timeout_secs),
      0}, 
        {"cache_timeout=%u", (unsigned long )(& ((struct cache *)0)->dir_timeout_secs),
      0}, 
        {"cache_timeout=%u", (unsigned long )(& ((struct cache *)0)->link_timeout_secs),
      0}, 
        {"cache_stat_timeout=%u", (unsigned long )(& ((struct cache *)0)->stat_timeout_secs),
      0}, 
        {"cache_dir_timeout=%u", (unsigned long )(& ((struct cache *)0)->dir_timeout_secs),
      0}, 
        {"cache_link_timeout=%u", (unsigned long )(& ((struct cache *)0)->link_timeout_secs),
      0}, 
        {"cache_max_size=%u", (unsigned long )(& ((struct cache *)0)->max_size), 0}, 
        {"cache_clean_interval=%u", (unsigned long )(& ((struct cache *)0)->clean_interval_secs),
      0}, 
        {"cache_min_clean_interval=%u", (unsigned long )(& ((struct cache *)0)->min_clean_interval_secs),
      0}, 
        {(char const   *)((void *)0), 0UL, 0}};
int cache_parse_options(struct fuse_args *args ) 
{ 
  int tmp ;

  {
  cache.stat_timeout_secs = 20U;
  cache.dir_timeout_secs = 20U;
  cache.link_timeout_secs = 20U;
  cache.max_size = 10000U;
  cache.clean_interval_secs = 60U;
  cache.min_clean_interval_secs = 5U;
  tmp = fuse_opt_parse(args, (void *)(& cache), cache_opts, (int (*)(void *data ,
                                                                     char const   *arg ,
                                                                     int key , struct fuse_args *outargs ))((void *)0));
  return (tmp);
}
}
#pragma merger("0","/tmp/cil-NoK3s57f.i","-fdiagnostics-color=always,-Wall,-Winvalid-pch,-O2,-g,-Wall,-Wextra,-Wno-sign-compare,-Wmissing-declarations,-Wwrite-strings,-Wno-unused-result,-pthread")
extern int fuse_opt_add_arg(struct fuse_args *args , char const   *arg ) ;
extern int fuse_opt_insert_arg(struct fuse_args *args , int pos , char const   *arg ) ;
extern void fuse_opt_free_args(struct fuse_args *args ) ;
__inline static __uint32_t __bswap_32(__uint32_t __bsx ) 
{ 


  {
  return (((((__bsx & 4278190080U) >> 24) | ((__bsx & 16711680U) >> 8)) | ((__bsx & 65280U) << 8)) | ((__bsx & 255U) << 24));
}
}
extern int fuse_daemonize(int foreground ) ;
extern char const   *fuse_pkgversion(void) ;
extern int fuse_set_signal_handlers(struct fuse_session *se ) ;
extern void fuse_remove_signal_handlers(struct fuse_session *se ) ;
extern int fcntl(int __fd , int __cmd  , ...)  __asm__("fcntl64")  ;
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat64)(int __fd , struct stat64 *__statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat64)(int __fd , char const   * __restrict  __filename , struct stat64 * __restrict  __statbuf ,
                            int __flag ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat64)(int __ver ,
                                                                                       int __fildes ,
                                                                                       struct stat64 *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat64)(int __ver ,
                                                                                        char const   *__filename ,
                                                                                        struct stat64 *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat64)(int __ver ,
                                                                                         char const   *__filename ,
                                                                                         struct stat64 *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4))) __fxstatat64)(int __ver ,
                                                                                           int __fildes ,
                                                                                           char const   *__filename ,
                                                                                           struct stat64 *__stat_buf ,
                                                                                           int __flag ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) stat64)(char const   * __restrict  __path ,
                                                                                struct stat64 * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __xstat64(1, (char const   *)__path, (struct stat64 *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) lstat64)(char const   * __restrict  __path ,
                                                                                 struct stat64 * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __lxstat64(1, (char const   *)__path, (struct stat64 *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat64)(int __fd , struct stat64 *__statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) fstat64)(int __fd ,
                                                                               struct stat64 *__statbuf ) 
{ 
  int tmp ;

  {
  tmp = __fxstat64(1, __fd, __statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat64)(int __fd , char const   * __restrict  __filename , struct stat64 * __restrict  __statbuf ,
                            int __flag ) ;
__inline extern int ( __attribute__((__nonnull__(2,3), __gnu_inline__)) fstatat64)(int __fd ,
                                                                                   char const   * __restrict  __filename ,
                                                                                   struct stat64 * __restrict  __statbuf ,
                                                                                   int __flag ) 
{ 
  int tmp ;

  {
  tmp = __fxstatat64(1, __fd, (char const   *)__filename, (struct stat64 *)__statbuf,
                     __flag);
  return (tmp);
}
}
extern ssize_t writev(int __fd , struct iovec  const  *__iovec , int __count ) ;
extern void fuse_lib_help(struct fuse_args *args ) ;
extern struct fuse *fuse_new(struct fuse_args *args , struct fuse_operations  const  *op ,
                             size_t op_size , void *private_data ) ;
extern int fuse_mount(struct fuse *f , char const   *mountpoint ) ;
extern void fuse_unmount(struct fuse *f ) ;
extern void fuse_destroy(struct fuse *f ) ;
extern int fuse_loop(struct fuse *f ) ;
extern int fuse_loop_mt_31(struct fuse *f , int clone_fd ) ;
extern struct fuse_session *fuse_get_session(struct fuse *f ) ;
extern void fuse_lowlevel_version(void) ;
extern int fuse_session_fd(struct fuse_session *se ) ;
extern int fclose(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...)  __asm__("__isoc99_sscanf")  ;
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
extern __ssize_t __getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                            int __delimiter , FILE * __restrict  __stream ) ;
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                     size_t * __restrict  __n ,
                                                                     FILE * __restrict  __stream ) ;
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
extern void perror(char const   *__s ) ;
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                     size_t * __restrict  __n ,
                                                                     FILE * __restrict  __stream ) 
{ 
  __ssize_t tmp ;

  {
  tmp = __getdelim(__lineptr, __n, '\n', __stream);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) strtoul)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
extern  __attribute__((__nothrow__)) int rand_r(unsigned int *__seed ) ;
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unsetenv)(char const   *__name ) ;
extern  __attribute__((__nothrow__)) char *realpath(char const   * __restrict  __name ,
                                                    char * __restrict  __resolved ) ;
extern  __attribute__((__nothrow__)) int grantpt(int __fd ) ;
extern  __attribute__((__nothrow__)) int unlockpt(int __fd ) ;
extern  __attribute__((__nothrow__)) char *ptsname(int __fd ) ;
extern int close(int __fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chdir)(char const   *__path ) ;
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) execvp)(char const   *__file ,
                                                                                     char * const  *__argv ) ;
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
extern  __attribute__((__nothrow__)) int getpagesize(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncasecmp)(char const   *__s1 ,
                                                                                          char const   *__s2 ,
                                                                                          size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strsep)(char ** __restrict  __stringp ,
                                                                                       char const   * __restrict  __delim ) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sem_init)(sem_t *__sem ,
                                                                                     int __pshared ,
                                                                                     unsigned int __value ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sem_destroy)(sem_t *__sem ) ;
extern int ( __attribute__((__nonnull__(1))) sem_wait)(sem_t *__sem ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sem_post)(sem_t *__sem ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern  __attribute__((__nothrow__)) int pthread_detach(pthread_t __th ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                                              pthread_condattr_t const   * __restrict  __cond_attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_broadcast)(pthread_cond_t *__cond ) ;
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                               struct cmsghdr *__cmsg ) ;
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                               struct cmsghdr *__cmsg ) ;
__inline extern struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                 struct cmsghdr *__cmsg ) 
{ 


  {
  if (__cmsg->cmsg_len < sizeof(struct cmsghdr )) {
    return ((struct cmsghdr *)0);
  }
  __cmsg = (struct cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)));
  if ((unsigned long )((unsigned char *)(__cmsg + 1)) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  } else
  if ((unsigned long )((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  }
  return (__cmsg);
}
}
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
extern  __attribute__((__nothrow__)) int socketpair(int __domain , int __type , int __protocol ,
                                                    int *__fds ) ;
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigemptyset)(sigset_t *__set ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigaddset)(sigset_t *__set ,
                                                                                      int __signo ) ;
extern  __attribute__((__nothrow__)) int pthread_sigmask(int __how , __sigset_t const   * __restrict  __newmask ,
                                                         __sigset_t * __restrict  __oldmask ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         void * __restrict  __tz ) ;
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
extern  __attribute__((__nothrow__)) void *mmap(void *__addr , size_t __len , int __prot ,
                                                int __flags , int __fd , __off64_t __offset )  __asm__("mmap64")  ;
extern  __attribute__((__nothrow__)) int munmap(void *__addr , size_t __len ) ;
extern  __attribute__((__nothrow__)) int mlock(void const   *__addr , size_t __len ) ;
extern int poll(struct pollfd *__fds , nfds_t __nfds , int __timeout ) ;
extern gpointer g_malloc(gsize n_bytes )  __attribute__((__malloc__, __alloc_size__(1))) ;
extern GList *( __attribute__((__warn_unused_result__)) g_list_append)(GList *list ,
                                                                       gpointer data ) ;
extern GList *( __attribute__((__warn_unused_result__)) g_list_delete_link)(GList *list ,
                                                                            GList *link_ ) ;
extern GList *g_list_first(GList *list ) ;
extern GHashTable *g_hash_table_new(guint (*hash_func)(gconstpointer key ) , gboolean (*key_equal_func)(gconstpointer a ,
                                                                                                        gconstpointer b ) ) ;
extern gboolean g_hash_table_replace(GHashTable *hash_table , gpointer key , gpointer value ) ;
extern gboolean g_hash_table_lookup_extended(GHashTable *hash_table , gconstpointer lookup_key ,
                                             gpointer *orig_key , gpointer *value ) ;
extern struct passwd *( __attribute__((__nonnull__(1))) getpwnam)(char const   *__name ) ;
extern struct group *getgrnam(char const   *__name ) ;
static struct sshfs sshfs  ;
static char const   *ssh_opts[62]  = 
  {      "AddressFamily",      "BatchMode",      "BindAddress",      "BindInterface", 
        "CertificateFile",      "ChallengeResponseAuthentication",      "CheckHostIP",      "Cipher", 
        "Ciphers",      "Compression",      "CompressionLevel",      "ConnectionAttempts", 
        "ConnectTimeout",      "ControlMaster",      "ControlPath",      "ControlPersist", 
        "FingerprintHash",      "GlobalKnownHostsFile",      "GSSAPIAuthentication",      "GSSAPIDelegateCredentials", 
        "HostbasedAuthentication",      "HostbasedKeyTypes",      "HostKeyAlgorithms",      "HostKeyAlias", 
        "HostName",      "IdentitiesOnly",      "IdentityFile",      "IdentityAgent", 
        "IPQoS",      "KbdInteractiveAuthentication",      "KbdInteractiveDevices",      "KexAlgorithms", 
        "LocalCommand",      "LogLevel",      "MACs",      "NoHostAuthenticationForLocalhost", 
        "NumberOfPasswordPrompts",      "PasswordAuthentication",      "PermitLocalCommand",      "PKCS11Provider", 
        "Port",      "PreferredAuthentications",      "ProxyCommand",      "ProxyJump", 
        "ProxyUseFdpass",      "PubkeyAcceptedKeyTypes",      "PubkeyAuthentication",      "RekeyLimit", 
        "RevokedHostKeys",      "RhostsRSAAuthentication",      "RSAAuthentication",      "ServerAliveCountMax", 
        "ServerAliveInterval",      "SmartcardDevice",      "StrictHostKeyChecking",      "TCPKeepAlive", 
        "UpdateHostKeys",      "UsePrivilegedPort",      "UserKnownHostsFile",      "VerifyHostKeyDNS", 
        "VisualHostKey",      (char const   *)((void *)0)};
static struct fuse_opt sshfs_opts[57]  = 
  {      {"directport=%s", (unsigned long )(& ((struct sshfs *)0)->directport), 0}, 
        {"ssh_command=%s", (unsigned long )(& ((struct sshfs *)0)->ssh_command), 0}, 
        {"sftp_server=%s", (unsigned long )(& ((struct sshfs *)0)->sftp_server), 0}, 
        {"max_read=%u", (unsigned long )(& ((struct sshfs *)0)->max_read), 0}, 
        {"max_write=%u", (unsigned long )(& ((struct sshfs *)0)->max_write), 0}, 
        {"ssh_protocol=%u", (unsigned long )(& ((struct sshfs *)0)->ssh_ver), 0}, 
        {"-1", (unsigned long )(& ((struct sshfs *)0)->ssh_ver), 1}, 
        {"workaround=%s", (unsigned long )(& ((struct sshfs *)0)->workarounds), 0}, 
        {"idmap=none", (unsigned long )(& ((struct sshfs *)0)->idmap), 0}, 
        {"idmap=user", (unsigned long )(& ((struct sshfs *)0)->idmap), 1}, 
        {"idmap=file", (unsigned long )(& ((struct sshfs *)0)->idmap), 2}, 
        {"uidfile=%s", (unsigned long )(& ((struct sshfs *)0)->uid_file), 0}, 
        {"gidfile=%s", (unsigned long )(& ((struct sshfs *)0)->gid_file), 0}, 
        {"nomap=ignore", (unsigned long )(& ((struct sshfs *)0)->nomap), 0}, 
        {"nomap=error", (unsigned long )(& ((struct sshfs *)0)->nomap), 1}, 
        {"sshfs_sync", (unsigned long )(& ((struct sshfs *)0)->sync_write), 1}, 
        {"no_readahead", (unsigned long )(& ((struct sshfs *)0)->sync_read), 1}, 
        {"sync_readdir", (unsigned long )(& ((struct sshfs *)0)->sync_readdir), 1}, 
        {"sshfs_debug", (unsigned long )(& ((struct sshfs *)0)->debug), 1}, 
        {"sshfs_verbose", (unsigned long )(& ((struct sshfs *)0)->verbose), 1}, 
        {"reconnect", (unsigned long )(& ((struct sshfs *)0)->reconnect), 1}, 
        {"transform_symlinks", (unsigned long )(& ((struct sshfs *)0)->transform_symlinks),
      1}, 
        {"follow_symlinks", (unsigned long )(& ((struct sshfs *)0)->follow_symlinks),
      1}, 
        {"no_check_root", (unsigned long )(& ((struct sshfs *)0)->no_check_root), 1}, 
        {"password_stdin",
      (unsigned long )(& ((struct sshfs *)0)->password_stdin), 1}, 
        {"delay_connect", (unsigned long )(& ((struct sshfs *)0)->delay_connect), 1}, 
        {"slave",
      (unsigned long )(& ((struct sshfs *)0)->passive), 1}, 
        {"passive", (unsigned long )(& ((struct sshfs *)0)->passive), 1}, 
        {"disable_hardlink", (unsigned long )(& ((struct sshfs *)0)->disable_hardlink),
      1}, 
        {"dir_cache=yes", (unsigned long )(& ((struct sshfs *)0)->dir_cache), 1}, 
        {"dir_cache=no", (unsigned long )(& ((struct sshfs *)0)->dir_cache), 0}, 
        {"direct_io", (unsigned long )(& ((struct sshfs *)0)->direct_io), 1}, 
        {"max_conns=%u", (unsigned long )(& ((struct sshfs *)0)->max_conns), 1}, 
        {"-h", (unsigned long )(& ((struct sshfs *)0)->show_help), 1}, 
        {"--help", (unsigned long )(& ((struct sshfs *)0)->show_help), 1}, 
        {"-V", (unsigned long )(& ((struct sshfs *)0)->show_version), 1}, 
        {"--version", (unsigned long )(& ((struct sshfs *)0)->show_version), 1}, 
        {"-d", (unsigned long )(& ((struct sshfs *)0)->debug), 1}, 
        {"debug", (unsigned long )(& ((struct sshfs *)0)->debug), 1}, 
        {"-v", (unsigned long )(& ((struct sshfs *)0)->verbose), 1}, 
        {"verbose", (unsigned long )(& ((struct sshfs *)0)->verbose), 1}, 
        {"-f", (unsigned long )(& ((struct sshfs *)0)->foreground), 1}, 
        {"-s", (unsigned long )(& ((struct sshfs *)0)->singlethread), 1}, 
        {"-p ", 4294967295UL, 0}, 
        {"-C", 4294967295UL, 1}, 
        {"-F ", 4294967295UL, 2}, 
        {"cache=yes", (unsigned long )(& ((struct sshfs *)0)->dir_cache), 1}, 
        {"cache=no", (unsigned long )(& ((struct sshfs *)0)->dir_cache), 0}, 
        {"writeback_cache=no", 4294967295UL, -4}, 
        {"unreliable_append", 4294967295UL, -4}, 
        {"auto", 4294967295UL, -4}, 
        {"noauto", 4294967295UL, -4}, 
        {"user", 4294967295UL, -4}, 
        {"nouser", 4294967295UL, -4}, 
        {"users", 4294967295UL, -4}, 
        {"_netdev", 4294967295UL, -4}, 
        {(char const   *)((void *)0), 0UL, 0}};
static struct fuse_opt workaround_opts[17]  = 
  {      {"none", (unsigned long )(& ((struct sshfs *)0)->rename_workaround), 0}, 
        {"none", (unsigned long )(& ((struct sshfs *)0)->truncate_workaround), 0}, 
        {"none", (unsigned long )(& ((struct sshfs *)0)->buflimit_workaround), 0}, 
        {"none", (unsigned long )(& ((struct sshfs *)0)->fstat_workaround), 0}, 
        {"rename", (unsigned long )(& ((struct sshfs *)0)->rename_workaround), 1}, 
        {"norename", (unsigned long )(& ((struct sshfs *)0)->rename_workaround), 0}, 
        {"renamexdev", (unsigned long )(& ((struct sshfs *)0)->renamexdev_workaround),
      1}, 
        {"norenamexdev", (unsigned long )(& ((struct sshfs *)0)->renamexdev_workaround),
      0}, 
        {"truncate", (unsigned long )(& ((struct sshfs *)0)->truncate_workaround), 1}, 
        {"notruncate",
      (unsigned long )(& ((struct sshfs *)0)->truncate_workaround), 0}, 
        {"buflimit", (unsigned long )(& ((struct sshfs *)0)->buflimit_workaround), 1}, 
        {"nobuflimit",
      (unsigned long )(& ((struct sshfs *)0)->buflimit_workaround), 0}, 
        {"fstat", (unsigned long )(& ((struct sshfs *)0)->fstat_workaround), 1}, 
        {"nofstat", (unsigned long )(& ((struct sshfs *)0)->fstat_workaround), 0}, 
        {"createmode", (unsigned long )(& ((struct sshfs *)0)->createmode_workaround),
      1}, 
        {"nocreatemode", (unsigned long )(& ((struct sshfs *)0)->createmode_workaround),
      0}, 
        {(char const   *)((void *)0), 0UL, 0}};
static char const   *type_name(uint8_t type ) 
{ 


  {
  switch ((int )type) {
  case 1: 
  return ("INIT");
  case 2: 
  return ("VERSION");
  case 3: 
  return ("OPEN");
  case 4: 
  return ("CLOSE");
  case 5: 
  return ("READ");
  case 6: 
  return ("WRITE");
  case 7: 
  return ("LSTAT");
  case 8: 
  return ("FSTAT");
  case 9: 
  return ("SETSTAT");
  case 10: 
  return ("FSETSTAT");
  case 11: 
  return ("OPENDIR");
  case 12: 
  return ("READDIR");
  case 13: 
  return ("REMOVE");
  case 14: 
  return ("MKDIR");
  case 15: 
  return ("RMDIR");
  case 16: 
  return ("REALPATH");
  case 17: 
  return ("STAT");
  case 18: 
  return ("RENAME");
  case 19: 
  return ("READLINK");
  case 20: 
  return ("SYMLINK");
  case 101: 
  return ("STATUS");
  case 102: 
  return ("HANDLE");
  case 103: 
  return ("DATA");
  case 104: 
  return ("NAME");
  case 105: 
  return ("ATTRS");
  case 200: 
  return ("EXTENDED");
  case 201: 
  return ("EXTENDED_REPLY");
  default: 
  return ("???");
  }
}
}
static void list_init(struct list_head *head ) 
{ 


  {
  head->next = head;
  head->prev = head;
  return;
}
}
static void list_add(struct list_head *new , struct list_head *head ) 
{ 
  struct list_head *prev ;
  struct list_head *next ;

  {
  prev = head;
  next = head->next;
  next->prev = new;
  new->next = next;
  new->prev = prev;
  prev->next = new;
  return;
}
}
static void list_del(struct list_head *entry ) 
{ 
  struct list_head *prev ;
  struct list_head *next ;

  {
  prev = entry->prev;
  next = entry->next;
  next->prev = prev;
  prev->next = next;
  return;
}
}
static int list_empty(struct list_head  const  *head ) 
{ 


  {
  return ((unsigned long )head->next == (unsigned long )head);
}
}
__inline static int translate_id(uint32_t *id , GHashTable *map ) 
{ 
  gpointer id_p ;
  gboolean tmp ;

  {
  tmp = g_hash_table_lookup_extended(map, (gconstpointer )((gpointer )((gulong )*id)),
                                     (gpointer *)((void *)0), & id_p);
  if (tmp) {
    *id = (guint )((gulong )id_p);
    return (0);
  }
  switch (sshfs.nomap) {
  case 1: 
  return (-1);
  case 0: 
  return (0);
  default: 
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"internal error\n");
  abort();
  }
}
}
__inline static void buf_init(struct buffer *buf , size_t size ) 
{ 
  void *tmp ;

  {
  if (size) {
    tmp = malloc(size);
    buf->p = (uint8_t *)tmp;
    if (! buf->p) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"sshfs: memory allocation failed\n");
      abort();
    }
  } else {
    buf->p = (uint8_t *)((void *)0);
  }
  buf->len = (size_t )0;
  buf->size = size;
  return;
}
}
__inline static void buf_free(struct buffer *buf ) 
{ 


  {
  free((void *)buf->p);
  return;
}
}
__inline static void buf_finish(struct buffer *buf ) 
{ 


  {
  buf->len = buf->size;
  return;
}
}
__inline static void buf_clear(struct buffer *buf ) 
{ 


  {
  buf_free(buf);
  buf_init(buf, (size_t )0);
  return;
}
}
static void buf_resize(struct buffer *buf , size_t len ) 
{ 
  void *tmp ;

  {
  buf->size = ((buf->len + len) + 63UL) & 0xffffffffffffffe0UL;
  tmp = realloc((void *)buf->p, buf->size);
  buf->p = (uint8_t *)tmp;
  if (! buf->p) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"sshfs: memory allocation failed\n");
    abort();
  }
  return;
}
}
__inline static void buf_check_add(struct buffer *buf , size_t len ) 
{ 


  {
  if (buf->len + len > buf->size) {
    buf_resize(buf, len);
  }
  return;
}
}
__inline static void buf_add_mem(struct buffer *buf , void const   *data , size_t len ) 
{ 


  {
  buf_check_add(buf, len);
  memcpy((void * __restrict  )(buf->p + buf->len), (void const   * __restrict  )data,
         len);
  buf->len += len;
  return;
}
}
__inline static void buf_add_buf(struct buffer *buf , struct buffer  const  *bufa ) 
{ 


  {
  buf_check_add(buf, (size_t )bufa->len);
  memcpy((void * __restrict  )(buf->p + buf->len), (void const   * __restrict  )bufa->p,
         (size_t )bufa->len);
  buf->len += (size_t )bufa->len;
  return;
}
}
__inline static void buf_add_uint8(struct buffer *buf , uint8_t val ) 
{ 


  {
  buf_check_add(buf, (size_t )1);
  memcpy((void * __restrict  )(buf->p + buf->len), (void const   * __restrict  )(& val),
         (size_t )1);
  (buf->len) ++;
  return;
}
}
__inline static void buf_add_uint32(struct buffer *buf , uint32_t val ) 
{ 
  uint32_t nval ;
  __uint32_t tmp ;

  {
  tmp = __bswap_32(val);
  nval = tmp;
  buf_check_add(buf, (size_t )4);
  memcpy((void * __restrict  )(buf->p + buf->len), (void const   * __restrict  )(& nval),
         (size_t )4);
  buf->len += 4UL;
  return;
}
}
__inline static void buf_add_uint64(struct buffer *buf , uint64_t val ) 
{ 


  {
  buf_add_uint32(buf, (uint32_t )(val >> 32));
  buf_add_uint32(buf, (uint32_t )(val & 4294967295UL));
  return;
}
}
__inline static void buf_add_data(struct buffer *buf , struct buffer  const  *data ) 
{ 


  {
  buf_add_uint32(buf, (uint32_t )data->len);
  buf_add_mem(buf, (void const   *)data->p, (size_t )data->len);
  return;
}
}
__inline static void buf_add_string(struct buffer *buf , char const   *str ) 
{ 
  struct buffer data ;

  {
  data.p = (uint8_t *)str;
  data.len = strlen(str);
  buf_add_data(buf, (struct buffer  const  *)(& data));
  return;
}
}
__inline static void buf_add_path(struct buffer *buf , char const   *path ) 
{ 
  char *realpath___0 ;
  size_t tmp ;

  {
  if (*(sshfs.base_path + 0)) {
    if (*(path + 1)) {
      tmp = strlen((char const   *)sshfs.base_path);
      if ((int )*(sshfs.base_path + (tmp - 1UL)) != 47) {
        realpath___0 = g_strdup_printf("%s/%s", sshfs.base_path, path + 1);
      } else {
        realpath___0 = g_strdup_printf("%s%s", sshfs.base_path, path + 1);
      }
    } else {
      realpath___0 = g_strdup((gchar const   *)sshfs.base_path);
    }
  } else
  if (*(path + 1)) {
    realpath___0 = g_strdup(path + 1);
  } else {
    realpath___0 = g_strdup(".");
  }
  buf_add_string(buf, (char const   *)realpath___0);
  g_free((gpointer )realpath___0);
  return;
}
}
static int buf_check_get(struct buffer *buf , size_t len ) 
{ 


  {
  if (buf->len + len > buf->size) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"buffer too short\n");
    return (-1);
  } else {
    return (0);
  }
}
}
__inline static int buf_get_mem(struct buffer *buf , void *data , size_t len ) 
{ 
  int tmp ;

  {
  tmp = buf_check_get(buf, len);
  if (tmp == -1) {
    return (-1);
  }
  memcpy((void * __restrict  )data, (void const   * __restrict  )(buf->p + buf->len),
         len);
  buf->len += len;
  return (0);
}
}
__inline static int buf_get_uint8(struct buffer *buf , uint8_t *val ) 
{ 
  int tmp ;

  {
  tmp = buf_get_mem(buf, (void *)val, (size_t )1);
  return (tmp);
}
}
__inline static int buf_get_uint32(struct buffer *buf , uint32_t *val ) 
{ 
  uint32_t nval ;
  int tmp ;

  {
  tmp = buf_get_mem(buf, (void *)(& nval), (size_t )4);
  if (tmp == -1) {
    return (-1);
  }
  *val = __bswap_32(nval);
  return (0);
}
}
__inline static int buf_get_uint64(struct buffer *buf , uint64_t *val ) 
{ 
  uint32_t val1 ;
  uint32_t val2 ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = buf_get_uint32(buf, & val1);
  if (tmp == -1) {
    return (-1);
  } else {
    tmp___0 = buf_get_uint32(buf, & val2);
    if (tmp___0 == -1) {
      return (-1);
    }
  }
  *val = ((uint64_t )val1 << 32) + (uint64_t )val2;
  return (0);
}
}
__inline static int buf_get_data(struct buffer *buf , struct buffer *data ) 
{ 
  uint32_t len ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = buf_get_uint32(buf, & len);
  if (tmp == -1) {
    return (-1);
  } else
  if ((size_t )len > buf->size - buf->len) {
    return (-1);
  }
  buf_init(data, (size_t )(len + 1U));
  data->size = (size_t )len;
  tmp___0 = buf_get_mem(buf, (void *)data->p, data->size);
  if (tmp___0 == -1) {
    buf_free(data);
    return (-1);
  }
  return (0);
}
}
__inline static int buf_get_string(struct buffer *buf , char **str ) 
{ 
  struct buffer data ;
  int tmp ;

  {
  tmp = buf_get_data(buf, & data);
  if (tmp == -1) {
    return (-1);
  }
  *(data.p + data.size) = (uint8_t )'\000';
  *str = (char *)data.p;
  return (0);
}
}
static int buf_get_attrs(struct buffer *buf , struct stat *stbuf , int *flagsp ) 
{ 
  uint32_t flags ;
  uint64_t size ;
  uint32_t uid ;
  uint32_t gid ;
  uint32_t atime ;
  uint32_t mtime ;
  uint32_t mode ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  uint32_t extcount ;
  unsigned int i ;
  int tmp___6 ;
  struct buffer tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  __time_t tmp___12 ;

  {
  size = (uint64_t )0;
  uid = (uint32_t )0;
  gid = (uint32_t )0;
  atime = (uint32_t )0;
  mtime = (uint32_t )0;
  mode = (uint32_t )33279;
  tmp = buf_get_uint32(buf, & flags);
  if (tmp == -1) {
    return (-5);
  }
  if (flagsp) {
    *flagsp = (int )flags;
  }
  if (flags & 1U) {
    tmp___0 = buf_get_uint64(buf, & size);
    if (tmp___0 == -1) {
      return (-5);
    }
  }
  if (flags & 2U) {
    tmp___1 = buf_get_uint32(buf, & uid);
    if (tmp___1 == -1) {
      return (-5);
    } else {
      tmp___2 = buf_get_uint32(buf, & gid);
      if (tmp___2 == -1) {
        return (-5);
      }
    }
  }
  if (flags & 4U) {
    tmp___3 = buf_get_uint32(buf, & mode);
    if (tmp___3 == -1) {
      return (-5);
    }
  }
  if (flags & 8U) {
    tmp___4 = buf_get_uint32(buf, & atime);
    if (tmp___4 == -1) {
      return (-5);
    } else {
      tmp___5 = buf_get_uint32(buf, & mtime);
      if (tmp___5 == -1) {
        return (-5);
      }
    }
  }
  if (flags & 2147483648U) {
    tmp___6 = buf_get_uint32(buf, & extcount);
    if (tmp___6 == -1) {
      return (-5);
    }
    i = 0U;
    while (i < extcount) {
      tmp___8 = buf_get_data(buf, & tmp___7);
      if (tmp___8 == -1) {
        return (-5);
      }
      buf_free(& tmp___7);
      tmp___9 = buf_get_data(buf, & tmp___7);
      if (tmp___9 == -1) {
        return (-5);
      }
      buf_free(& tmp___7);
      i ++;
    }
  }
  if (sshfs.remote_uid_detected) {
    if (uid == sshfs.remote_uid) {
      uid = sshfs.local_uid;
    }
    if (gid == sshfs.remote_gid) {
      gid = sshfs.local_gid;
    }
  }
  if (sshfs.idmap == 2) {
    if (sshfs.uid_map) {
      tmp___10 = translate_id(& uid, sshfs.uid_map);
      if (tmp___10 == -1) {
        return (-1);
      }
    }
  }
  if (sshfs.idmap == 2) {
    if (sshfs.gid_map) {
      tmp___11 = translate_id(& gid, sshfs.gid_map);
      if (tmp___11 == -1) {
        return (-1);
      }
    }
  }
  memset((void *)stbuf, 0, sizeof(struct stat ));
  stbuf->st_mode = mode;
  stbuf->st_nlink = (__nlink_t )1;
  stbuf->st_size = (__off_t )size;
  if (sshfs.blksize) {
    stbuf->st_blksize = (__blksize_t )sshfs.blksize;
    stbuf->st_blocks = (__blkcnt_t )(((unsigned long long )((size + (uint64_t )sshfs.blksize) - 1UL) & ~ ((unsigned long long )sshfs.blksize - 1ULL)) >> 9);
  }
  stbuf->st_uid = uid;
  stbuf->st_gid = gid;
  stbuf->st_atim.tv_sec = (__time_t )atime;
  tmp___12 = (__time_t )mtime;
  stbuf->st_mtim.tv_sec = tmp___12;
  stbuf->st_ctim.tv_sec = tmp___12;
  return (0);
}
}
static int buf_get_statvfs(struct buffer *buf , struct statvfs *stbuf ) 
{ 
  uint64_t bsize ;
  uint64_t frsize ;
  uint64_t blocks ;
  uint64_t bfree ;
  uint64_t bavail ;
  uint64_t files ;
  uint64_t ffree ;
  uint64_t favail ;
  uint64_t fsid ;
  uint64_t flag ;
  uint64_t namemax ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  tmp = buf_get_uint64(buf, & bsize);
  if (tmp == -1) {
    return (-1);
  } else {
    tmp___0 = buf_get_uint64(buf, & frsize);
    if (tmp___0 == -1) {
      return (-1);
    } else {
      tmp___1 = buf_get_uint64(buf, & blocks);
      if (tmp___1 == -1) {
        return (-1);
      } else {
        tmp___2 = buf_get_uint64(buf, & bfree);
        if (tmp___2 == -1) {
          return (-1);
        } else {
          tmp___3 = buf_get_uint64(buf, & bavail);
          if (tmp___3 == -1) {
            return (-1);
          } else {
            tmp___4 = buf_get_uint64(buf, & files);
            if (tmp___4 == -1) {
              return (-1);
            } else {
              tmp___5 = buf_get_uint64(buf, & ffree);
              if (tmp___5 == -1) {
                return (-1);
              } else {
                tmp___6 = buf_get_uint64(buf, & favail);
                if (tmp___6 == -1) {
                  return (-1);
                } else {
                  tmp___7 = buf_get_uint64(buf, & fsid);
                  if (tmp___7 == -1) {
                    return (-1);
                  } else {
                    tmp___8 = buf_get_uint64(buf, & flag);
                    if (tmp___8 == -1) {
                      return (-1);
                    } else {
                      tmp___9 = buf_get_uint64(buf, & namemax);
                      if (tmp___9 == -1) {
                        return (-1);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  memset((void *)stbuf, 0, sizeof(struct statvfs ));
  stbuf->f_bsize = bsize;
  stbuf->f_frsize = frsize;
  stbuf->f_blocks = blocks;
  stbuf->f_bfree = bfree;
  stbuf->f_bavail = bavail;
  stbuf->f_files = files;
  stbuf->f_ffree = ffree;
  stbuf->f_favail = favail;
  stbuf->f_namemax = namemax;
  return (0);
}
}
static int buf_get_entries(struct buffer *buf , void *dbuf , int (*filler)(void *buf ,
                                                                           char const   *name ,
                                                                           struct stat  const  *stbuf ,
                                                                           off_t off ,
                                                                           enum fuse_fill_dir_flags flags ) ) 
{ 
  uint32_t count ;
  unsigned int i ;
  int tmp ;
  int err ;
  char *name ;
  char *longname ;
  struct stat stbuf ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = buf_get_uint32(buf, & count);
  if (tmp == -1) {
    return (-5);
  }
  i = 0U;
  while (i < count) {
    err = -1;
    tmp___0 = buf_get_string(buf, & name);
    if (tmp___0 == -1) {
      return (-5);
    }
    tmp___1 = buf_get_string(buf, & longname);
    if (tmp___1 != -1) {
      free((void *)longname);
      err = buf_get_attrs(buf, & stbuf, (int *)((void *)0));
      if (! err) {
        if (sshfs.follow_symlinks) {
          if ((stbuf.st_mode & 61440U) == 40960U) {
            stbuf.st_mode = (__mode_t )0;
          }
        }
        (*filler)(dbuf, (char const   *)name, (struct stat  const  *)(& stbuf), (off_t )0,
                  (enum fuse_fill_dir_flags )0);
      }
    }
    free((void *)name);
    if (err) {
      return (err);
    }
    i ++;
  }
  return (0);
}
}
static void ssh_add_arg(char const   *arg ) 
{ 
  int tmp ;

  {
  tmp = fuse_opt_add_arg(& sshfs.ssh_args, arg);
  if (tmp == -1) {
    _exit(1);
  }
  return;
}
}
static int pty_expect_loop(struct conn *conn ) 
{ 
  int res ;
  char buf[256] ;
  char const   *passwd_str ;
  int timeout ;
  int passwd_len ;
  size_t tmp ;
  int len ;
  char c ;
  struct pollfd fds[2] ;
  ssize_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t size ;
  int tmp___3 ;

  {
  passwd_str = "assword:";
  timeout = 60000;
  tmp = strlen(passwd_str);
  passwd_len = (int )tmp;
  len = 0;
  while (1) {
    fds[0].fd = conn->rfd;
    fds[0].events = (short)1;
    fds[1].fd = sshfs.ptyfd;
    fds[1].events = (short)1;
    res = poll(fds, (nfds_t )2, timeout);
    if (res == -1) {
      perror("poll");
      return (-1);
    }
    if (res == 0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Timeout waiting for prompt\n");
      return (-1);
    }
    if (fds[0].revents) {
      break;
    }
    tmp___0 = read(sshfs.ptyfd, (void *)(& c), (size_t )1);
    res = (int )tmp___0;
    if (res == -1) {
      perror("read");
      return (-1);
    }
    if (res == 0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"EOF while waiting for prompt\n");
      return (-1);
    }
    buf[len] = c;
    len ++;
    if (len == passwd_len) {
      tmp___2 = memcmp((void const   *)(buf), (void const   *)passwd_str, (size_t )passwd_len);
      if (tmp___2 == 0) {
        tmp___1 = strlen((char const   *)sshfs.password);
        write(sshfs.ptyfd, (void const   *)sshfs.password, tmp___1);
      }
      memmove((void *)(buf), (void const   *)(buf + 1), (size_t )(passwd_len - 1));
      len --;
    }
  }
  if (! sshfs.reconnect) {
    tmp___3 = getpagesize();
    size = (size_t )tmp___3;
    memset((void *)sshfs.password, 0, size);
    munmap((void *)sshfs.password, size);
    sshfs.password = (char *)((void *)0);
  }
  return (0);
}
}
static struct conn *get_conn(struct sshfs_file  const  *sf , char const   *path ) 
{ 
  struct conntab_entry *ce ;
  int i ;
  gpointer tmp ;
  struct conn *conn ;
  int best_index ;
  uint64_t best_score ;
  uint64_t score ;
  int tmp___0 ;

  {
  if (sshfs.max_conns == 1) {
    return (sshfs.conns + 0);
  }
  if ((unsigned long )sf != (unsigned long )((void *)0)) {
    return ((struct conn *)sf->conn);
  }
  if ((unsigned long )path != (unsigned long )((void *)0)) {
    pthread_mutex_lock(& sshfs.lock);
    tmp = g_hash_table_lookup(sshfs.conntab, (gconstpointer )path);
    ce = (struct conntab_entry *)tmp;
    if ((unsigned long )ce != (unsigned long )((void *)0)) {
      conn = ce->conn;
      pthread_mutex_unlock(& sshfs.lock);
      return (conn);
    }
    pthread_mutex_unlock(& sshfs.lock);
  }
  best_index = 0;
  best_score = (uint64_t )(~ 0ULL);
  i = 0;
  while (i < sshfs.max_conns) {
    if ((sshfs.conns + i)->rfd >= 0) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
    score = ((((uint64_t )(sshfs.conns + i)->req_count << 43) + ((uint64_t )(sshfs.conns + i)->dir_count << 22)) + ((uint64_t )(sshfs.conns + i)->file_count << 1)) + (uint64_t )tmp___0;
    if (score < best_score) {
      best_index = i;
      best_score = score;
    }
    i ++;
  }
  return (sshfs.conns + best_index);
}
}
static int pty_master(char **name ) 
{ 
  int mfd ;
  int tmp ;
  int tmp___0 ;

  {
  mfd = open("/dev/ptmx", 258);
  if (mfd == -1) {
    perror("failed to open pty");
    return (-1);
  }
  tmp = grantpt(mfd);
  if (tmp != 0) {
    perror("grantpt");
    return (-1);
  }
  tmp___0 = unlockpt(mfd);
  if (tmp___0 != 0) {
    perror("unlockpt");
    return (-1);
  }
  *name = ptsname(mfd);
  return (mfd);
}
}
static void replace_arg(char **argp , char const   *newarg ) 
{ 


  {
  free((void *)*argp);
  *argp = strdup(newarg);
  if ((unsigned long )*argp == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"sshfs: memory allocation failed\n");
    abort();
  }
  return;
}
}
static int start_ssh(struct conn *conn ) 
{ 
  char *ptyname ;
  int sockpair[2] ;
  int pid ;
  int tmp ;
  int devnull ;
  int tmp___0 ;
  int tmp___1 ;
  __pid_t tmp___2 ;
  int sfd ;
  int i ;
  int *tmp___3 ;
  char *tmp___4 ;

  {
  ptyname = (char *)((void *)0);
  if (sshfs.password_stdin) {
    sshfs.ptyfd = pty_master(& ptyname);
    if (sshfs.ptyfd == -1) {
      return (-1);
    }
    sshfs.ptypassivefd = open((char const   *)ptyname, 258);
    if (sshfs.ptypassivefd == -1) {
      return (-1);
    }
  }
  tmp = socketpair(1, 1, 0, (int *)(sockpair));
  if (tmp == -1) {
    perror("failed to create socket pair");
    return (-1);
  }
  conn->rfd = sockpair[0];
  conn->wfd = sockpair[0];
  pid = fork();
  if (pid == -1) {
    perror("failed to fork");
    close(sockpair[1]);
    return (-1);
  } else
  if (pid == 0) {
    devnull = open("/dev/null", 1);
    tmp___0 = dup2(sockpair[1], 0);
    if (tmp___0 == -1) {
      perror("failed to redirect input/output");
      _exit(1);
    } else {
      tmp___1 = dup2(sockpair[1], 1);
      if (tmp___1 == -1) {
        perror("failed to redirect input/output");
        _exit(1);
      }
    }
    if (! sshfs.verbose) {
      if (! sshfs.foreground) {
        if (devnull != -1) {
          dup2(devnull, 2);
        }
      }
    }
    close(devnull);
    close(sockpair[0]);
    close(sockpair[1]);
    tmp___2 = fork();
    switch (tmp___2) {
    case -1: 
    perror("failed to fork");
    _exit(1);
    case 0: 
    break;
    default: 
    _exit(0);
    }
    chdir("/");
    unsetenv("OLDPWD");
    if (sshfs.password_stdin) {
      setsid();
      sfd = open((char const   *)ptyname, 2);
      if (sfd == -1) {
        perror((char const   *)ptyname);
        _exit(1);
      }
      close(sfd);
      close(sshfs.ptypassivefd);
      close(sshfs.ptyfd);
    }
    if (sshfs.debug) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"executing");
      i = 0;
      while (i < sshfs.ssh_args.argc) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" <%s>",
                *(sshfs.ssh_args.argv + i));
        i ++;
      }
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
    }
    execvp((char const   *)*(sshfs.ssh_args.argv + 0), (char * const  *)sshfs.ssh_args.argv);
    tmp___3 = __errno_location();
    tmp___4 = strerror(*tmp___3);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"failed to execute \'%s\': %s\n",
            *(sshfs.ssh_args.argv + 0), tmp___4);
    _exit(1);
  }
  waitpid(pid, (int *)((void *)0), 0);
  close(sockpair[1]);
  return (0);
}
}
static int connect_passive(struct conn *conn ) 
{ 


  {
  conn->rfd = 0;
  conn->wfd = 1;
  return (0);
}
}
static int connect_to(struct conn *conn , char *host , char *port ) 
{ 
  int err ;
  int sock ;
  int opt ;
  struct addrinfo *ai ;
  struct addrinfo hint ;
  char const   *tmp ;

  {
  memset((void *)(& hint), 0, sizeof(hint));
  hint.ai_family = 2;
  hint.ai_socktype = 1;
  err = getaddrinfo((char const   * __restrict  )host, (char const   * __restrict  )port,
                    (struct addrinfo  const  * __restrict  )(& hint), (struct addrinfo ** __restrict  )(& ai));
  if (err) {
    tmp = gai_strerror(err);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"failed to resolve %s:%s: %s\n",
            host, port, tmp);
    return (-1);
  }
  sock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
  if (sock == -1) {
    perror("failed to create socket");
    freeaddrinfo(ai);
    return (-1);
  }
  err = connect(sock, (struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen);
  if (err == -1) {
    perror("failed to connect");
    freeaddrinfo(ai);
    close(sock);
    return (-1);
  }
  opt = 1;
  err = setsockopt(sock, 6, 1, (void const   *)(& opt), (socklen_t )sizeof(opt));
  if (err == -1) {
    perror("warning: failed to set TCP_NODELAY");
  }
  freeaddrinfo(ai);
  conn->rfd = sock;
  conn->wfd = sock;
  return (0);
}
}
static int do_write(struct conn *conn , struct iovec *iov , size_t count ) 
{ 
  int res ;
  ssize_t tmp ;

  {
  while (count) {
    tmp = writev(conn->wfd, (struct iovec  const  *)iov, (int )count);
    res = (int )tmp;
    if (res == -1) {
      perror("write");
      return (-1);
    } else
    if (res == 0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"zero write\n");
      return (-1);
    }
    while (1) {
      if ((size_t )((unsigned int )res) < iov->iov_len) {
        iov->iov_len -= (size_t )res;
        iov->iov_base += res;
        break;
      } else {
        res = (int )((size_t )res - iov->iov_len);
        count --;
        iov ++;
      }
      if (! count) {
        break;
      }
    }
  }
  return (0);
}
}
static uint32_t idctr  ;
static uint32_t sftp_get_id(void) 
{ 
  uint32_t tmp ;

  {
  tmp = idctr;
  idctr ++;
  return (tmp);
}
}
static void buf_to_iov(struct buffer  const  *buf , struct iovec *iov ) 
{ 


  {
  iov->iov_base = (void *)buf->p;
  iov->iov_len = (size_t )buf->len;
  return;
}
}
static size_t iov_length(struct iovec  const  *iov , unsigned long nr_segs ) 
{ 
  unsigned long seg ;
  size_t ret ;

  {
  ret = (size_t )0;
  seg = 0UL;
  while (seg < nr_segs) {
    ret += (size_t )(iov + seg)->iov_len;
    seg ++;
  }
  return (ret);
}
}
static int sftp_send_iov(struct conn *conn , uint8_t type , uint32_t id , struct iovec *iov ,
                         size_t count ) 
{ 
  int res ;
  struct buffer buf ;
  struct iovec iovout[3] ;
  unsigned int i ;
  unsigned int nout ;
  size_t tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
  nout = 0U;
  if (! (count <= 2UL)) {
    __assert_fail("count <= SFTP_MAX_IOV - 1", "../sshfs.c", 1344U, "sftp_send_iov");
  }
  buf_init(& buf, (size_t )9);
  tmp___0 = iov_length((struct iovec  const  *)iov, count);
  buf_add_uint32(& buf, (uint32_t )(tmp___0 + 5UL));
  buf_add_uint8(& buf, type);
  buf_add_uint32(& buf, id);
  tmp___1 = nout;
  nout ++;
  buf_to_iov((struct buffer  const  *)(& buf), & iovout[tmp___1]);
  i = 0U;
  while ((size_t )i < count) {
    tmp___2 = nout;
    nout ++;
    iovout[tmp___2] = *(iov + i);
    i ++;
  }
  pthread_mutex_lock(& conn->lock_write);
  res = do_write(conn, iovout, (size_t )nout);
  pthread_mutex_unlock(& conn->lock_write);
  buf_free(& buf);
  return (res);
}
}
static int do_read(struct conn *conn , struct buffer *buf ) 
{ 
  int res ;
  uint8_t *p ;
  size_t size ;
  ssize_t tmp ;

  {
  p = buf->p;
  size = buf->size;
  while (size) {
    tmp = read(conn->rfd, (void *)p, size);
    res = (int )tmp;
    if (res == -1) {
      perror("read");
      return (-1);
    } else
    if (res == 0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"remote host has disconnected\n");
      return (-1);
    }
    size -= (size_t )res;
    p += res;
  }
  return (0);
}
}
static int sftp_read(struct conn *conn , uint8_t *type , struct buffer *buf ) 
{ 
  int res ;
  struct buffer buf2 ;
  uint32_t len ;
  int tmp ;
  int tmp___0 ;

  {
  buf_init(& buf2, (size_t )5);
  res = do_read(conn, & buf2);
  if (res != -1) {
    tmp = buf_get_uint32(& buf2, & len);
    if (tmp == -1) {
      return (-1);
    }
    if (len > (uint32_t )(1 << 17)) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"reply len too large: %u\n",
              len);
      return (-1);
    }
    tmp___0 = buf_get_uint8(& buf2, type);
    if (tmp___0 == -1) {
      return (-1);
    }
    buf_init(buf, (size_t )(len - 1U));
    res = do_read(conn, buf);
  }
  buf_free(& buf2);
  return (res);
}
}
static void request_free(struct request *req ) 
{ 


  {
  if (req->end_func) {
    (*(req->end_func))(req);
  }
  ((req->conn)->req_count) --;
  buf_free(& req->reply);
  sem_destroy(& req->ready);
  g_free((gpointer )req);
  return;
}
}
static void chunk_free(struct read_chunk *chunk ) 
{ 
  struct read_req *rreq ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
  while (1) {
    tmp = list_empty((struct list_head  const  *)(& chunk->reqs));
    if (tmp) {
      break;
    }
    __mptr = (struct list_head  const  *)chunk->reqs.prev;
    rreq = (struct read_req *)((char *)__mptr - (unsigned long )(& ((struct read_req *)0)->list));
    list_del(& rreq->list);
    buf_free(& rreq->data);
    g_free((gpointer )rreq);
  }
  g_free((gpointer )chunk);
  return;
}
}
static void chunk_put(struct read_chunk *chunk ) 
{ 


  {
  if (chunk) {
    (chunk->refs) --;
    if (! chunk->refs) {
      chunk_free(chunk);
    }
  }
  return;
}
}
static void chunk_put_locked(struct read_chunk *chunk ) 
{ 


  {
  pthread_mutex_lock(& sshfs.lock);
  chunk_put(chunk);
  pthread_mutex_unlock(& sshfs.lock);
  return;
}
}
static int clean_req(void *key , struct request *req , gpointer user_data ) 
{ 
  struct conn *conn ;

  {
  conn = (struct conn *)user_data;
  if ((unsigned long )req->conn != (unsigned long )conn) {
    return (0);
  }
  req->error = -5;
  if (req->want_reply) {
    sem_post(& req->ready);
  } else {
    request_free(req);
  }
  return (1);
}
}
static int process_one_request(struct conn *conn ) 
{ 
  int res ;
  struct buffer buf ;
  uint8_t type ;
  struct request *req ;
  uint32_t id ;
  int tmp ;
  gpointer tmp___0 ;
  int was_over ;
  struct timeval now ;
  unsigned int difftime___0 ;
  unsigned int msgsize ;
  char const   *tmp___1 ;

  {
  buf_init(& buf, (size_t )0);
  res = sftp_read(conn, & type, & buf);
  if (res == -1) {
    return (-1);
  }
  tmp = buf_get_uint32(& buf, & id);
  if (tmp == -1) {
    return (-1);
  }
  pthread_mutex_lock(& sshfs.lock);
  tmp___0 = g_hash_table_lookup(sshfs.reqtab, (gconstpointer )((gpointer )((gulong )id)));
  req = (struct request *)tmp___0;
  if ((unsigned long )req == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"request %i not found\n",
            id);
  } else {
    was_over = sshfs.outstanding_len > sshfs.max_outstanding_len;
    sshfs.outstanding_len = (unsigned int )((size_t )sshfs.outstanding_len - req->len);
    if (was_over) {
      if (sshfs.outstanding_len <= sshfs.max_outstanding_len) {
        pthread_cond_broadcast(& sshfs.outstanding_cond);
      }
    }
    g_hash_table_remove(sshfs.reqtab, (gconstpointer )((gpointer )((gulong )id)));
  }
  pthread_mutex_unlock(& sshfs.lock);
  if ((unsigned long )req != (unsigned long )((void *)0)) {
    if (sshfs.debug) {
      msgsize = (unsigned int )(buf.size + 5UL);
      gettimeofday((struct timeval * __restrict  )(& now), (void * __restrict  )((void *)0));
      difftime___0 = (unsigned int )((now.tv_sec - req->start.tv_sec) * 1000L);
      difftime___0 = (unsigned int )((__suseconds_t )difftime___0 + (now.tv_usec - req->start.tv_usec) / 1000L);
      while (1) {
        if (sshfs.debug) {
          tmp___1 = type_name(type);
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  [%05i] %14s %8ubytes (%ims)\n",
                  id, tmp___1, msgsize, difftime___0);
        }
        break;
      }
      if (difftime___0 < sshfs.min_rtt) {
        sshfs.min_rtt = difftime___0;
      } else
      if (! sshfs.num_received) {
        sshfs.min_rtt = difftime___0;
      }
      if (difftime___0 > sshfs.max_rtt) {
        sshfs.max_rtt = difftime___0;
      }
      sshfs.total_rtt += (uint64_t )difftime___0;
      (sshfs.num_received) ++;
      sshfs.bytes_received += (uint64_t )msgsize;
    }
    req->reply = buf;
    req->reply_type = type;
    req->replied = 1;
    if (req->want_reply) {
      sem_post(& req->ready);
    } else {
      pthread_mutex_lock(& sshfs.lock);
      request_free(req);
      pthread_mutex_unlock(& sshfs.lock);
    }
  } else {
    buf_free(& buf);
  }
  return (0);
}
}
static void close_conn(struct conn *conn ) 
{ 


  {
  close(conn->rfd);
  if (conn->rfd != conn->wfd) {
    close(conn->wfd);
  }
  conn->rfd = -1;
  conn->wfd = -1;
  if (sshfs.ptyfd != -1) {
    close(sshfs.ptyfd);
    sshfs.ptyfd = -1;
  }
  if (sshfs.ptypassivefd != -1) {
    close(sshfs.ptypassivefd);
    sshfs.ptypassivefd = -1;
  }
  return;
}
}
static void *process_requests(void *data_ ) 
{ 
  struct conn *conn ;
  int tmp ;
  __pid_t tmp___0 ;

  {
  conn = (struct conn *)data_;
  while (1) {
    tmp = process_one_request(conn);
    if (tmp == -1) {
      break;
    }
  }
  pthread_mutex_lock(& sshfs.lock);
  conn->processing_thread_started = 0;
  close_conn(conn);
  g_hash_table_foreach_remove(sshfs.reqtab, (gboolean (*)(gpointer key , gpointer value ,
                                                          gpointer user_data ))(& clean_req),
                              (gpointer )conn);
  (sshfs.connvers) ++;
  conn->connver = sshfs.connvers;
  sshfs.outstanding_len = 0U;
  pthread_cond_broadcast(& sshfs.outstanding_cond);
  pthread_mutex_unlock(& sshfs.lock);
  if (! sshfs.reconnect) {
    tmp___0 = getpid();
    kill(tmp___0, 15);
  }
  return ((void *)0);
}
}
static int sftp_init_reply_ok(struct conn *conn , struct buffer *buf , uint32_t *version ) 
{ 
  uint32_t len ;
  uint8_t type ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct buffer buf2 ;
  int tmp___2 ;
  char *ext ;
  char *extdata ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  tmp = buf_get_uint32(buf, & len);
  if (tmp == -1) {
    return (-1);
  }
  if (len < 5U) {
    return (1);
  } else
  if (len > (uint32_t )(1 << 17)) {
    return (1);
  }
  tmp___0 = buf_get_uint8(buf, & type);
  if (tmp___0 == -1) {
    return (-1);
  }
  if ((int )type != 2) {
    return (1);
  }
  tmp___1 = buf_get_uint32(buf, version);
  if (tmp___1 == -1) {
    return (-1);
  }
  while (1) {
    if (sshfs.debug) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Server version: %u\n",
              *version);
    }
    break;
  }
  if (len > 5U) {
    buf_init(& buf2, (size_t )(len - 5U));
    tmp___2 = do_read(conn, & buf2);
    if (tmp___2 == -1) {
      buf_free(& buf2);
      return (-1);
    }
    while (1) {
      ext = (char *)((void *)0);
      extdata = (char *)((void *)0);
      tmp___3 = buf_get_string(& buf2, & ext);
      if (tmp___3 == -1) {
        buf_free(& buf2);
        free((void *)ext);
        free((void *)extdata);
        return (-1);
      } else {
        tmp___4 = buf_get_string(& buf2, & extdata);
        if (tmp___4 == -1) {
          buf_free(& buf2);
          free((void *)ext);
          free((void *)extdata);
          return (-1);
        }
      }
      while (1) {
        if (sshfs.debug) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Extension: %s <%s>\n",
                  ext, extdata);
        }
        break;
      }
      tmp___5 = strcmp((char const   *)ext, "posix-rename@openssh.com");
      if (tmp___5 == 0) {
        tmp___6 = strcmp((char const   *)extdata, "1");
        if (tmp___6 == 0) {
          sshfs.ext_posix_rename = 1;
          sshfs.rename_workaround = 0;
        }
      }
      tmp___7 = strcmp((char const   *)ext, "statvfs@openssh.com");
      if (tmp___7 == 0) {
        tmp___8 = strcmp((char const   *)extdata, "2");
        if (tmp___8 == 0) {
          sshfs.ext_statvfs = 1;
        }
      }
      tmp___9 = strcmp((char const   *)ext, "hardlink@openssh.com");
      if (tmp___9 == 0) {
        tmp___10 = strcmp((char const   *)extdata, "1");
        if (tmp___10 == 0) {
          sshfs.ext_hardlink = 1;
        }
      }
      tmp___11 = strcmp((char const   *)ext, "fsync@openssh.com");
      if (tmp___11 == 0) {
        tmp___12 = strcmp((char const   *)extdata, "1");
        if (tmp___12 == 0) {
          sshfs.ext_fsync = 1;
        }
      }
      free((void *)ext);
      free((void *)extdata);
      if (! (buf2.len < buf2.size)) {
        break;
      }
    }
    buf_free(& buf2);
  }
  return (0);
}
}
static int sftp_find_init_reply(struct conn *conn , uint32_t *version ) 
{ 
  int res ;
  struct buffer buf ;
  struct buffer buf2 ;

  {
  buf_init(& buf, (size_t )9);
  res = do_read(conn, & buf);
  while (res != -1) {
    res = sftp_init_reply_ok(conn, & buf, version);
    if (res <= 0) {
      break;
    }
    while (1) {
      if (sshfs.debug) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%c", (int )*(buf.p));
      }
      break;
    }
    memmove((void *)buf.p, (void const   *)(buf.p + 1), buf.size - 1UL);
    buf.len = (size_t )0;
    buf2.p = (buf.p + buf.size) - 1;
    buf2.size = (size_t )1;
    res = do_read(conn, & buf2);
  }
  buf_free(& buf);
  return (res);
}
}
static int sftp_init(struct conn *conn ) 
{ 
  int res ;
  uint32_t version ;
  struct buffer buf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  res = -1;
  version = (uint32_t )0;
  buf_init(& buf, (size_t )0);
  tmp = sftp_send_iov(conn, (uint8_t )1, (uint32_t )3, (struct iovec *)((void *)0),
                      (size_t )0);
  if (tmp == -1) {
    goto out;
  }
  if (sshfs.password_stdin) {
    tmp___0 = pty_expect_loop(conn);
    if (tmp___0 == -1) {
      goto out;
    }
  }
  tmp___1 = sftp_find_init_reply(conn, & version);
  if (tmp___1 == -1) {
    goto out;
  }
  sshfs.server_version = (int )version;
  if (version > 3U) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Warning: server uses version: %i, we support: %i\n",
            version, 3);
  }
  res = 0;
  out: 
  buf_free(& buf);
  return (res);
}
}
static int sftp_error_to_errno(uint32_t error ) 
{ 


  {
  switch (error) {
  case 0U: 
  return (0);
  case 2U: 
  return (2);
  case 3U: 
  return (13);
  case 4U: 
  return (1);
  case 5U: 
  return (74);
  case 6U: 
  return (107);
  case 7U: 
  return (103);
  case 8U: 
  return (95);
  default: 
  return (5);
  }
}
}
static void sftp_detect_uid(struct conn *conn ) 
{ 
  int flags ;
  uint32_t id ;
  uint32_t tmp ;
  uint32_t replid ;
  uint8_t type ;
  struct buffer buf ;
  struct stat stbuf ;
  struct iovec iov[1] ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  uint32_t serr ;
  int tmp___3 ;
  int tmp___4 ;

  {
  tmp = sftp_get_id();
  id = tmp;
  buf_init(& buf, (size_t )5);
  buf_add_string(& buf, ".");
  buf_to_iov((struct buffer  const  *)(& buf), & iov[0]);
  tmp___0 = sftp_send_iov(conn, (uint8_t )17, id, iov, (size_t )1);
  if (tmp___0 == -1) {
    goto out;
  }
  buf_clear(& buf);
  tmp___1 = sftp_read(conn, & type, & buf);
  if (tmp___1 == -1) {
    goto out;
  }
  if ((int )type != 105) {
    if ((int )type != 101) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"protocol error\n");
      goto out;
    }
  }
  tmp___2 = buf_get_uint32(& buf, & replid);
  if (tmp___2 == -1) {
    goto out;
  }
  if (replid != id) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"bad reply ID\n");
    goto out;
  }
  if ((int )type == 101) {
    tmp___3 = buf_get_uint32(& buf, & serr);
    if (tmp___3 == -1) {
      goto out;
    }
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"failed to stat home directory (%i)\n",
            serr);
    goto out;
  }
  tmp___4 = buf_get_attrs(& buf, & stbuf, & flags);
  if (tmp___4 != 0) {
    goto out;
  }
  if (! (flags & 2)) {
    goto out;
  }
  sshfs.remote_uid = stbuf.st_uid;
  sshfs.local_uid = getuid();
  sshfs.remote_gid = stbuf.st_gid;
  sshfs.local_gid = getgid();
  sshfs.remote_uid_detected = 1;
  while (1) {
    if (sshfs.debug) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"remote_uid = %i\n",
              sshfs.remote_uid);
    }
    break;
  }
  out: 
  if (! sshfs.remote_uid_detected) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"failed to detect remote user ID\n");
  }
  buf_free(& buf);
  return;
}
}
static int sftp_check_root(struct conn *conn , char const   *base_path ) 
{ 
  int flags ;
  uint32_t id ;
  uint32_t tmp ;
  uint32_t replid ;
  uint8_t type ;
  struct buffer buf ;
  struct stat stbuf ;
  struct iovec iov[1] ;
  int err ;
  char const   *remote_dir ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  uint32_t serr ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int err2 ;
  int tmp___7 ;

  {
  tmp = sftp_get_id();
  id = tmp;
  err = -1;
  if (*(base_path + 0)) {
    tmp___0 = base_path;
  } else {
    tmp___0 = ".";
  }
  remote_dir = tmp___0;
  buf_init(& buf, (size_t )0);
  buf_add_string(& buf, remote_dir);
  buf_to_iov((struct buffer  const  *)(& buf), & iov[0]);
  tmp___1 = sftp_send_iov(conn, (uint8_t )7, id, iov, (size_t )1);
  if (tmp___1 == -1) {
    goto out;
  }
  buf_clear(& buf);
  tmp___2 = sftp_read(conn, & type, & buf);
  if (tmp___2 == -1) {
    goto out;
  }
  if ((int )type != 105) {
    if ((int )type != 101) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"protocol error\n");
      goto out;
    }
  }
  tmp___3 = buf_get_uint32(& buf, & replid);
  if (tmp___3 == -1) {
    goto out;
  }
  if (replid != id) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"bad reply ID\n");
    goto out;
  }
  if ((int )type == 101) {
    tmp___4 = buf_get_uint32(& buf, & serr);
    if (tmp___4 == -1) {
      goto out;
    }
    tmp___5 = sftp_error_to_errno(serr);
    tmp___6 = strerror(tmp___5);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%s: %s\n",
            sshfs.host, remote_dir, tmp___6);
    goto out;
  }
  tmp___7 = buf_get_attrs(& buf, & stbuf, & flags);
  err2 = tmp___7;
  if (err2) {
    err = err2;
    goto out;
  }
  if (! (flags & 4)) {
    goto out;
  }
  if (! ((stbuf.st_mode & 61440U) == 16384U)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%s: Not a directory\n",
            sshfs.host, remote_dir);
    goto out;
  }
  err = 0;
  out: 
  buf_free(& buf);
  return (err);
}
}
static int connect_remote(struct conn *conn ) 
{ 
  int err ;

  {
  if (sshfs.passive) {
    err = connect_passive(conn);
  } else
  if (sshfs.directport) {
    err = connect_to(conn, sshfs.host, sshfs.directport);
  } else {
    err = start_ssh(conn);
  }
  if (! err) {
    err = sftp_init(conn);
  }
  if (err) {
    close_conn(conn);
  } else {
    (sshfs.num_connect) ++;
  }
  return (err);
}
}
static int start_processing_thread(struct conn *conn ) 
{ 
  int err ;
  pthread_t thread_id ;
  sigset_t oldset ;
  sigset_t newset ;
  char *tmp ;

  {
  if (conn->processing_thread_started) {
    return (0);
  }
  if (conn->rfd == -1) {
    err = connect_remote(conn);
    if (err) {
      return (-5);
    }
  }
  if (sshfs.detect_uid) {
    sftp_detect_uid(conn);
    sshfs.detect_uid = 0;
  }
  sigemptyset(& newset);
  sigaddset(& newset, 15);
  sigaddset(& newset, 2);
  sigaddset(& newset, 1);
  sigaddset(& newset, 3);
  pthread_sigmask(0, (__sigset_t const   * __restrict  )(& newset), (__sigset_t * __restrict  )(& oldset));
  err = pthread_create((pthread_t * __restrict  )(& thread_id), (pthread_attr_t const   * __restrict  )((void *)0),
                       & process_requests, (void * __restrict  )conn);
  if (err) {
    tmp = strerror(err);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"failed to create thread: %s\n",
            tmp);
    return (-5);
  }
  pthread_detach(thread_id);
  pthread_sigmask(2, (__sigset_t const   * __restrict  )(& oldset), (__sigset_t * __restrict  )((void *)0));
  conn->processing_thread_started = 1;
  return (0);
}
}
static void *sshfs_init(struct fuse_conn_info *conn , struct fuse_config *cfg ) 
{ 
  int tmp ;

  {
  if (conn->capable & 1U) {
    sshfs.sync_read = 1;
  }
  if (sshfs.truncate_workaround) {
    tmp = 0;
  } else
  if (sshfs.fstat_workaround) {
    tmp = 0;
  } else {
    tmp = 1;
  }
  cfg->nullpath_ok = tmp;
  if (sshfs.max_conns > 1) {
    cfg->nullpath_ok = 0;
  }
  conn->capable |= (unsigned int )(1 << 4);
  if (! sshfs.delay_connect) {
    start_processing_thread(sshfs.conns + 0);
  }
  conn->time_gran = 1000000000U;
  return ((void *)0);
}
}
static int sftp_request_wait(struct request *req , uint8_t type , uint8_t expect_type ,
                             struct buffer *outbuf ) 
{ 
  int err ;
  int tmp ;
  uint32_t serr ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (req->error) {
    err = req->error;
    goto out;
  }
  while (1) {
    tmp = sem_wait(& req->ready);
    if (! tmp) {
      break;
    }
  }
  if (req->error) {
    err = req->error;
    goto out;
  }
  err = -5;
  if ((int )req->reply_type != (int )expect_type) {
    if ((int )req->reply_type != 101) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"protocol error\n");
      goto out;
    }
  }
  if ((int )req->reply_type == 101) {
    tmp___0 = buf_get_uint32(& req->reply, & serr);
    if (tmp___0 == -1) {
      goto out;
    }
    switch (serr) {
    case 0U: 
    if ((int )expect_type == 101) {
      err = 0;
    } else {
      err = -5;
    }
    break;
    case 1U: 
    if ((int )type == 5) {
      err = 1;
    } else
    if ((int )type == 12) {
      err = 1;
    } else {
      err = -5;
    }
    break;
    case 4U: 
    if ((int )type == 15) {
      err = -39;
    } else {
      err = -1;
    }
    break;
    default: 
    tmp___1 = sftp_error_to_errno(serr);
    err = - tmp___1;
    }
  } else {
    buf_init(outbuf, req->reply.size - req->reply.len);
    buf_get_mem(& req->reply, (void *)outbuf->p, outbuf->size);
    err = 0;
  }
  out: 
  pthread_mutex_lock(& sshfs.lock);
  request_free(req);
  pthread_mutex_unlock(& sshfs.lock);
  return (err);
}
}
static int sftp_request_send(struct conn *conn , uint8_t type , struct iovec *iov ,
                             size_t count , void (*begin_func)(struct request * ) ,
                             void (*end_func)(struct request * ) , int want_reply ,
                             void *data , struct request **reqp ) 
{ 
  int err ;
  uint32_t id ;
  struct request *req ;
  gsize __n ;
  gsize __s ;
  gpointer __p ;
  size_t tmp ;
  char const   *tmp___0 ;
  gboolean rmed ;
  int tmp___1 ;

  {
  __n = (gsize )1;
  __s = sizeof(struct request );
  if (__s == 1UL) {
    __p = g_malloc0(__n);
  } else {
    __p = g_malloc0_n(__n, __s);
  }
  req = (struct request *)__p;
  req->want_reply = (unsigned int )want_reply;
  req->end_func = end_func;
  req->data = data;
  sem_init(& req->ready, 0, 0U);
  buf_init(& req->reply, (size_t )0);
  pthread_mutex_lock(& sshfs.lock);
  if (begin_func) {
    (*begin_func)(req);
  }
  id = sftp_get_id();
  req->id = id;
  req->conn = conn;
  ((req->conn)->req_count) ++;
  err = start_processing_thread(conn);
  if (err) {
    pthread_mutex_unlock(& sshfs.lock);
    goto out;
  }
  tmp = iov_length((struct iovec  const  *)iov, count);
  req->len = tmp + 9UL;
  sshfs.outstanding_len = (unsigned int )((size_t )sshfs.outstanding_len + req->len);
  while (sshfs.outstanding_len > sshfs.max_outstanding_len) {
    pthread_cond_wait((pthread_cond_t * __restrict  )(& sshfs.outstanding_cond), (pthread_mutex_t * __restrict  )(& sshfs.lock));
  }
  g_hash_table_insert(sshfs.reqtab, (gpointer )((gulong )id), (gpointer )req);
  if (sshfs.debug) {
    gettimeofday((struct timeval * __restrict  )(& req->start), (void * __restrict  )((void *)0));
    (sshfs.num_sent) ++;
    sshfs.bytes_sent += req->len;
  }
  while (1) {
    if (sshfs.debug) {
      tmp___0 = type_name(type);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"[%05i] %s\n",
              id, tmp___0);
    }
    break;
  }
  pthread_mutex_unlock(& sshfs.lock);
  err = -5;
  tmp___1 = sftp_send_iov(conn, type, id, iov, count);
  if (tmp___1 == -1) {
    pthread_mutex_lock(& sshfs.lock);
    rmed = g_hash_table_remove(sshfs.reqtab, (gconstpointer )((gpointer )((gulong )id)));
    pthread_mutex_unlock(& sshfs.lock);
    if (! rmed) {
      if (! want_reply) {
        return (err);
      }
    }
    goto out;
  }
  if (want_reply) {
    *reqp = req;
  }
  return (0);
  out: 
  req->error = err;
  if (! want_reply) {
    sftp_request_wait(req, type, (uint8_t )0, (struct buffer *)((void *)0));
  } else {
    *reqp = req;
  }
  return (err);
}
}
static int sftp_request_iov(struct conn *conn , uint8_t type , struct iovec *iov ,
                            size_t count , uint8_t expect_type , struct buffer *outbuf ) 
{ 
  int err ;
  struct request *req ;
  int tmp ;

  {
  err = sftp_request_send(conn, type, iov, count, (void (*)(struct request * ))((void *)0),
                          (void (*)(struct request * ))((void *)0), (int )expect_type,
                          (void *)0, & req);
  if ((int )expect_type == 0) {
    return (err);
  }
  tmp = sftp_request_wait(req, type, expect_type, outbuf);
  return (tmp);
}
}
static int sftp_request(struct conn *conn , uint8_t type , struct buffer  const  *buf ,
                        uint8_t expect_type , struct buffer *outbuf ) 
{ 
  struct iovec iov ;
  int tmp ;

  {
  buf_to_iov(buf, & iov);
  tmp = sftp_request_iov(conn, type, & iov, (size_t )1, expect_type, outbuf);
  return (tmp);
}
}
static int sshfs_access(char const   *path , int mask ) 
{ 
  struct stat stbuf ;
  int err ;

  {
  err = 0;
  if (mask & 1) {
    err = (*((sshfs.op)->getattr))(path, & stbuf, (struct fuse_file_info *)((void *)0));
    if (! err) {
      if ((stbuf.st_mode & 61440U) == 32768U) {
        if (! (stbuf.st_mode & (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3)))) {
          err = -13;
        }
      }
    }
  }
  return (err);
}
}
static int count_components(char const   *p ) 
{ 
  int ctr ;

  {
  while ((int const   )*p == 47) {
    p ++;
  }
  ctr = 0;
  while (*p) {
    while (1) {
      if (*p) {
        if (! ((int const   )*p != 47)) {
          break;
        }
      } else {
        break;
      }
      p ++;
    }
    while ((int const   )*p == 47) {
      p ++;
    }
    ctr ++;
  }
  return (ctr);
}
}
static void strip_common(char const   **sp , char const   **tp ) 
{ 
  char const   *s ;
  char const   *t ;

  {
  s = *sp;
  t = *tp;
  while (1) {
    while ((int const   )*s == 47) {
      s ++;
    }
    while ((int const   )*t == 47) {
      t ++;
    }
    *tp = t;
    *sp = s;
    while (1) {
      if ((int const   )*s == (int const   )*t) {
        if (*s) {
          if (! ((int const   )*s != 47)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      s ++;
      t ++;
    }
    if ((int const   )*s == (int const   )*t) {
      if (! *s) {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (! *s) {
      if (! ((int const   )*t == 47)) {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if ((int const   )*s == 47) {
      if (! (! *t)) {
        break;
      }
    } else {
      break;
    }
  }
  return;
}
}
static void transform_symlink(char const   *path , char **linkp ) 
{ 
  char const   *l ;
  char const   *b ;
  char *newlink ;
  char *s ;
  int dotdots ;
  int i ;
  size_t tmp ;
  void *tmp___0 ;

  {
  l = (char const   *)*linkp;
  b = (char const   *)sshfs.base_path;
  if ((int const   )*(l + 0) != 47) {
    return;
  } else
  if ((int const   )*(b + 0) != 47) {
    return;
  }
  strip_common(& l, & b);
  if (*b) {
    return;
  }
  strip_common(& l, & path);
  dotdots = count_components(path);
  if (! dotdots) {
    return;
  }
  dotdots --;
  tmp = strlen(l);
  tmp___0 = malloc(((size_t )(dotdots * 3) + tmp) + 2UL);
  newlink = (char *)tmp___0;
  if (! newlink) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"sshfs: memory allocation failed\n");
    abort();
  }
  s = newlink;
  i = 0;
  while (i < dotdots) {
    strcpy((char * __restrict  )s, (char const   * __restrict  )"../");
    i ++;
    s += 3;
  }
  if (*(l + 0)) {
    strcpy((char * __restrict  )s, (char const   * __restrict  )l);
  } else
  if (! dotdots) {
    strcpy((char * __restrict  )s, (char const   * __restrict  )".");
  } else {
    *(s + 0) = (char )'\000';
  }
  free((void *)*linkp);
  *linkp = newlink;
  return;
}
}
static int sshfs_readlink(char const   *path , char *linkbuf , size_t size ) 
{ 
  int err ;
  struct buffer buf ;
  struct buffer name ;
  struct conn *tmp___0 ;
  uint32_t count ;
  char *link___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (! (size > 0UL)) {
    __assert_fail("size > 0", "../sshfs.c", 2154U, "sshfs_readlink");
  }
  if (sshfs.server_version < 3) {
    return (-1);
  }
  buf_init(& buf, (size_t )0);
  buf_add_path(& buf, path);
  tmp___0 = get_conn((struct sshfs_file  const  *)((void *)0), (char const   *)((void *)0));
  err = sftp_request(tmp___0, (uint8_t )19, (struct buffer  const  *)(& buf), (uint8_t )104,
                     & name);
  if (! err) {
    err = -5;
    tmp___1 = buf_get_uint32(& name, & count);
    if (tmp___1 != -1) {
      if (count == 1U) {
        tmp___2 = buf_get_string(& name, & link___0);
        if (tmp___2 != -1) {
          if (sshfs.transform_symlinks) {
            transform_symlink(path, & link___0);
          }
          strncpy((char * __restrict  )linkbuf, (char const   * __restrict  )link___0,
                  size - 1UL);
          *(linkbuf + (size - 1UL)) = (char )'\000';
          free((void *)link___0);
          err = 0;
        }
      }
    }
    buf_free(& name);
  }
  buf_free(& buf);
  return (err);
}
}
static int sftp_readdir_send(struct conn *conn , struct request **req , struct buffer *handle ) 
{ 
  struct iovec iov ;
  int tmp ;

  {
  buf_to_iov((struct buffer  const  *)handle, & iov);
  tmp = sftp_request_send(conn, (uint8_t )12, & iov, (size_t )1, (void (*)(struct request * ))((void *)0),
                          (void (*)(struct request * ))((void *)0), 104, (void *)0,
                          req);
  return (tmp);
}
}
static int sshfs_req_pending(struct request *req ) 
{ 
  gpointer tmp ;

  {
  tmp = g_hash_table_lookup(sshfs.reqtab, (gconstpointer )((gpointer )((gulong )req->id)));
  if (tmp) {
    return (1);
  } else {
    return (0);
  }
}
}
static int sftp_readdir_async(struct conn *conn , struct buffer *handle , void *buf ,
                              off_t offset , int (*filler)(void *buf , char const   *name ,
                                                           struct stat  const  *stbuf ,
                                                           off_t off , enum fuse_fill_dir_flags flags ) ) 
{ 
  int err ;
  int outstanding ;
  int max ;
  GList *list ;
  int done ;
  struct request *req ;
  struct buffer name ;
  int tmperr ;
  GList *first ;
  int want_reply ;
  int tmp___0 ;

  {
  err = 0;
  outstanding = 0;
  max = 2;
  list = (GList *)((void *)0);
  done = 0;
  if (! (offset == 0L)) {
    __assert_fail("offset == 0", "../sshfs.c", 2210U, "sftp_readdir_async");
  }
  while (1) {
    if (! (! done)) {
      if (! outstanding) {
        break;
      }
    }
    while (1) {
      if (! done) {
        if (! (outstanding < max)) {
          break;
        }
      } else {
        break;
      }
      tmperr = sftp_readdir_send(conn, & req, handle);
      if (tmperr) {
        if (! done) {
          err = tmperr;
          done = 1;
          break;
        }
      }
      list = g_list_append(list, (gpointer )req);
      outstanding ++;
    }
    if (outstanding) {
      first = g_list_first(list);
      req = (struct request *)first->data;
      list = g_list_delete_link(list, first);
      outstanding --;
      if (done) {
        pthread_mutex_lock(& sshfs.lock);
        tmp___0 = sshfs_req_pending(req);
        if (tmp___0) {
          req->want_reply = 0U;
        }
        want_reply = (int )req->want_reply;
        pthread_mutex_unlock(& sshfs.lock);
        if (! want_reply) {
          continue;
        }
      }
      tmperr = sftp_request_wait(req, (uint8_t )12, (uint8_t )104, & name);
      if (tmperr) {
        if (! done) {
          err = tmperr;
          if (err == 1) {
            err = 0;
          }
          done = 1;
        }
      }
      if (! done) {
        err = buf_get_entries(& name, buf, filler);
        buf_free(& name);
        if (max < 32) {
          max ++;
        }
        if (err) {
          done = 1;
        }
      }
    }
  }
  if (! ((unsigned long )list == (unsigned long )((void *)0))) {
    __assert_fail("list == NULL", "../sshfs.c", 2273U, "sftp_readdir_async");
  }
  return (err);
}
}
static int sftp_readdir_sync(struct conn *conn , struct buffer *handle , void *buf ,
                             off_t offset , int (*filler)(void *buf , char const   *name ,
                                                          struct stat  const  *stbuf ,
                                                          off_t off , enum fuse_fill_dir_flags flags ) ) 
{ 
  int err ;
  struct buffer name ;

  {
  if (! (offset == 0L)) {
    __assert_fail("offset == 0", "../sshfs.c", 2282U, "sftp_readdir_sync");
  }
  while (1) {
    err = sftp_request(conn, (uint8_t )12, (struct buffer  const  *)handle, (uint8_t )104,
                       & name);
    if (! err) {
      err = buf_get_entries(& name, buf, filler);
      buf_free(& name);
    }
    if (! (! err)) {
      break;
    }
  }
  if (err == 1) {
    err = 0;
  }
  return (err);
}
}
static int sshfs_opendir(char const   *path , struct fuse_file_info *fi ) 
{ 
  int err ;
  struct conn *conn ;
  struct buffer buf ;
  struct dir_handle *handle ;
  gsize __n ;
  gsize __s ;
  gpointer __p ;

  {
  __n = (gsize )1;
  __s = sizeof(struct dir_handle );
  if (__s == 1UL) {
    __p = g_malloc0(__n);
  } else {
    __p = g_malloc0_n(__n, __s);
  }
  handle = (struct dir_handle *)__p;
  if ((unsigned long )handle == (unsigned long )((void *)0)) {
    return (-12);
  }
  conn = get_conn((struct sshfs_file  const  *)((void *)0), (char const   *)((void *)0));
  buf_init(& buf, (size_t )0);
  buf_add_path(& buf, path);
  err = sftp_request(conn, (uint8_t )11, (struct buffer  const  *)(& buf), (uint8_t )102,
                     & handle->buf);
  if (! err) {
    buf_finish(& handle->buf);
    pthread_mutex_lock(& sshfs.lock);
    handle->conn = conn;
    ((handle->conn)->dir_count) ++;
    pthread_mutex_unlock(& sshfs.lock);
    fi->fh = (unsigned long )handle;
  } else {
    g_free((gpointer )handle);
  }
  buf_free(& buf);
  return (err);
}
}
static int sshfs_readdir(char const   *path , void *dbuf , int (*filler)(void *buf ,
                                                                         char const   *name ,
                                                                         struct stat  const  *stbuf ,
                                                                         off_t off ,
                                                                         enum fuse_fill_dir_flags flags ) ,
                         off_t offset , struct fuse_file_info *fi , enum fuse_readdir_flags flags ) 
{ 
  int err ;
  struct dir_handle *handle ;

  {
  handle = (struct dir_handle *)fi->fh;
  if (sshfs.sync_readdir) {
    err = sftp_readdir_sync(handle->conn, & handle->buf, dbuf, offset, filler);
  } else {
    err = sftp_readdir_async(handle->conn, & handle->buf, dbuf, offset, filler);
  }
  return (err);
}
}
static int sshfs_releasedir(char const   *path , struct fuse_file_info *fi ) 
{ 
  int err ;
  struct dir_handle *handle ;

  {
  handle = (struct dir_handle *)fi->fh;
  err = sftp_request(handle->conn, (uint8_t )4, (struct buffer  const  *)(& handle->buf),
                     (uint8_t )0, (struct buffer *)((void *)0));
  pthread_mutex_lock(& sshfs.lock);
  ((handle->conn)->dir_count) --;
  pthread_mutex_unlock(& sshfs.lock);
  buf_free(& handle->buf);
  g_free((gpointer )handle);
  return (err);
}
}
static int sshfs_mkdir(char const   *path , mode_t mode ) 
{ 
  int err ;
  struct buffer buf ;
  struct conn *tmp ;
  int tmp___0 ;

  {
  buf_init(& buf, (size_t )0);
  buf_add_path(& buf, path);
  buf_add_uint32(& buf, (uint32_t )4);
  buf_add_uint32(& buf, mode);
  tmp = get_conn((struct sshfs_file  const  *)((void *)0), (char const   *)((void *)0));
  err = sftp_request(tmp, (uint8_t )14, (struct buffer  const  *)(& buf), (uint8_t )101,
                     (struct buffer *)((void *)0));
  buf_free(& buf);
  if (err == -1) {
    tmp___0 = (*((sshfs.op)->access))(path, 4);
    if (tmp___0 == 0) {
      return (-17);
    }
  }
  return (err);
}
}
static int sshfs_mknod(char const   *path , mode_t mode , dev_t rdev ) 
{ 
  int err ;
  struct conn *conn ;
  struct buffer buf ;
  struct buffer handle ;
  int err2 ;

  {
  if ((mode & 61440U) != 32768U) {
    return (-1);
  }
  conn = get_conn((struct sshfs_file  const  *)((void *)0), (char const   *)((void *)0));
  buf_init(& buf, (size_t )0);
  buf_add_path(& buf, path);
  buf_add_uint32(& buf, (uint32_t )42);
  buf_add_uint32(& buf, (uint32_t )4);
  buf_add_uint32(& buf, mode);
  err = sftp_request(conn, (uint8_t )3, (struct buffer  const  *)(& buf), (uint8_t )102,
                     & handle);
  if (! err) {
    buf_finish(& handle);
    err2 = sftp_request(conn, (uint8_t )4, (struct buffer  const  *)(& handle), (uint8_t )101,
                        (struct buffer *)((void *)0));
    if (! err) {
      err = err2;
    }
    buf_free(& handle);
  }
  buf_free(& buf);
  return (err);
}
}
static int sshfs_symlink(char const   *from , char const   *to ) 
{ 
  int err ;
  struct buffer buf ;
  struct conn *tmp ;

  {
  if (sshfs.server_version < 3) {
    return (-1);
  }
  buf_init(& buf, (size_t )0);
  buf_add_string(& buf, from);
  buf_add_path(& buf, to);
  tmp = get_conn((struct sshfs_file  const  *)((void *)0), (char const   *)((void *)0));
  err = sftp_request(tmp, (uint8_t )20, (struct buffer  const  *)(& buf), (uint8_t )101,
                     (struct buffer *)((void *)0));
  buf_free(& buf);
  return (err);
}
}
static int sshfs_unlink(char const   *path ) 
{ 
  int err ;
  struct buffer buf ;
  struct conn *tmp ;

  {
  buf_init(& buf, (size_t )0);
  buf_add_path(& buf, path);
  tmp = get_conn((struct sshfs_file  const  *)((void *)0), (char const   *)((void *)0));
  err = sftp_request(tmp, (uint8_t )13, (struct buffer  const  *)(& buf), (uint8_t )101,
                     (struct buffer *)((void *)0));
  buf_free(& buf);
  return (err);
}
}
static int sshfs_rmdir(char const   *path ) 
{ 
  int err ;
  struct buffer buf ;
  struct conn *tmp ;

  {
  buf_init(& buf, (size_t )0);
  buf_add_path(& buf, path);
  tmp = get_conn((struct sshfs_file  const  *)((void *)0), (char const   *)((void *)0));
  err = sftp_request(tmp, (uint8_t )15, (struct buffer  const  *)(& buf), (uint8_t )101,
                     (struct buffer *)((void *)0));
  buf_free(& buf);
  return (err);
}
}
static int sshfs_do_rename(char const   *from , char const   *to ) 
{ 
  int err ;
  struct buffer buf ;
  struct conn *tmp ;

  {
  buf_init(& buf, (size_t )0);
  buf_add_path(& buf, from);
  buf_add_path(& buf, to);
  tmp = get_conn((struct sshfs_file  const  *)((void *)0), (char const   *)((void *)0));
  err = sftp_request(tmp, (uint8_t )18, (struct buffer  const  *)(& buf), (uint8_t )101,
                     (struct buffer *)((void *)0));
  buf_free(& buf);
  return (err);
}
}
static int sshfs_ext_posix_rename(char const   *from , char const   *to ) 
{ 
  int err ;
  struct buffer buf ;
  struct conn *tmp ;

  {
  buf_init(& buf, (size_t )0);
  buf_add_string(& buf, "posix-rename@openssh.com");
  buf_add_path(& buf, from);
  buf_add_path(& buf, to);
  tmp = get_conn((struct sshfs_file  const  *)((void *)0), (char const   *)((void *)0));
  err = sftp_request(tmp, (uint8_t )200, (struct buffer  const  *)(& buf), (uint8_t )101,
                     (struct buffer *)((void *)0));
  buf_free(& buf);
  return (err);
}
}
static void random_string(char *str , int length ) 
{ 
  int i ;
  char *tmp ;
  int tmp___0 ;

  {
  i = 0;
  while (i < length) {
    tmp = str;
    str ++;
    tmp___0 = rand_r(& sshfs.randseed);
    *tmp = (char )(48 + tmp___0 % 10);
    i ++;
  }
  *str = (char )'\000';
  return;
}
}
static int sshfs_rename(char const   *from , char const   *to , unsigned int flags ) 
{ 
  int err ;
  struct conntab_entry *ce ;
  size_t tolen ;
  size_t tmp ;
  int tmperr ;
  char totmp[4096] ;
  gpointer tmp___0 ;
  gchar *tmp___1 ;

  {
  if (flags != 0U) {
    return (-22);
  }
  if (sshfs.ext_posix_rename) {
    err = sshfs_ext_posix_rename(from, to);
  } else {
    err = sshfs_do_rename(from, to);
  }
  if (err == -1) {
    if (sshfs.rename_workaround) {
      tmp = strlen(to);
      tolen = tmp;
      if (tolen + 8UL < 4096UL) {
        strcpy((char * __restrict  )(totmp), (char const   * __restrict  )to);
        random_string(totmp + tolen, 8);
        tmperr = sshfs_do_rename(to, (char const   *)(totmp));
        if (! tmperr) {
          err = sshfs_do_rename(from, to);
          if (! err) {
            err = sshfs_unlink((char const   *)(totmp));
          } else {
            sshfs_do_rename((char const   *)(totmp), to);
          }
        }
      }
    }
  }
  if (err == -1) {
    if (sshfs.renamexdev_workaround) {
      err = -18;
    }
  }
  if (! err) {
    if (sshfs.max_conns > 1) {
      pthread_mutex_lock(& sshfs.lock);
      tmp___0 = g_hash_table_lookup(sshfs.conntab, (gconstpointer )from);
      ce = (struct conntab_entry *)tmp___0;
      if ((unsigned long )ce != (unsigned long )((void *)0)) {
        tmp___1 = g_strdup(to);
        g_hash_table_replace(sshfs.conntab, (gpointer )tmp___1, (gpointer )ce);
        g_hash_table_remove(sshfs.conntab, (gconstpointer )from);
      }
      pthread_mutex_unlock(& sshfs.lock);
    }
  }
  return (err);
}
}
static int sshfs_link(char const   *from , char const   *to ) 
{ 
  int err ;
  struct buffer buf ;
  struct conn *tmp ;

  {
  err = -38;
  if (sshfs.ext_hardlink) {
    if (! sshfs.disable_hardlink) {
      buf_init(& buf, (size_t )0);
      buf_add_string(& buf, "hardlink@openssh.com");
      buf_add_path(& buf, from);
      buf_add_path(& buf, to);
      tmp = get_conn((struct sshfs_file  const  *)((void *)0), (char const   *)((void *)0));
      err = sftp_request(tmp, (uint8_t )200, (struct buffer  const  *)(& buf), (uint8_t )101,
                         (struct buffer *)((void *)0));
      buf_free(& buf);
    }
  }
  return (err);
}
}
__inline static int sshfs_file_is_conn(struct sshfs_file *sf ) 
{ 
  int ret ;

  {
  pthread_mutex_lock(& sshfs.lock);
  ret = sf->connver == (sf->conn)->connver;
  pthread_mutex_unlock(& sshfs.lock);
  return (ret);
}
}
__inline static struct sshfs_file *get_sshfs_file(struct fuse_file_info *fi ) 
{ 


  {
  return ((struct sshfs_file *)fi->fh);
}
}
static int sshfs_chmod(char const   *path , mode_t mode , struct fuse_file_info *fi ) 
{ 
  int err ;
  struct buffer buf ;
  struct sshfs_file *sf ;
  int tmp ;
  int tmp___0 ;
  struct conn *tmp___1 ;

  {
  sf = (struct sshfs_file *)((void *)0);
  if ((unsigned long )fi != (unsigned long )((void *)0)) {
    sf = get_sshfs_file(fi);
    tmp = sshfs_file_is_conn(sf);
    if (! tmp) {
      return (-5);
    }
  }
  buf_init(& buf, (size_t )0);
  if ((unsigned long )sf == (unsigned long )((void *)0)) {
    buf_add_path(& buf, path);
  } else {
    buf_add_buf(& buf, (struct buffer  const  *)(& sf->handle));
  }
  buf_add_uint32(& buf, (uint32_t )4);
  buf_add_uint32(& buf, mode);
  if ((unsigned long )sf == (unsigned long )((void *)0)) {
    tmp___0 = 9;
  } else {
    tmp___0 = 10;
  }
  tmp___1 = get_conn((struct sshfs_file  const  *)sf, (char const   *)((void *)0));
  err = sftp_request(tmp___1, (uint8_t )tmp___0, (struct buffer  const  *)(& buf),
                     (uint8_t )101, (struct buffer *)((void *)0));
  buf_free(& buf);
  return (err);
}
}
static int sshfs_chown(char const   *path , uid_t uid , gid_t gid , struct fuse_file_info *fi ) 
{ 
  int err ;
  struct buffer buf ;
  struct sshfs_file *sf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct conn *tmp___3 ;

  {
  sf = (struct sshfs_file *)((void *)0);
  if ((unsigned long )fi != (unsigned long )((void *)0)) {
    sf = get_sshfs_file(fi);
    tmp = sshfs_file_is_conn(sf);
    if (! tmp) {
      return (-5);
    }
  }
  if (sshfs.remote_uid_detected) {
    if (uid == sshfs.local_uid) {
      uid = sshfs.remote_uid;
    }
    if (gid == sshfs.local_gid) {
      gid = sshfs.remote_gid;
    }
  }
  if (sshfs.idmap == 2) {
    if (sshfs.r_uid_map) {
      tmp___0 = translate_id(& uid, sshfs.r_uid_map);
      if (tmp___0 == -1) {
        return (-1);
      }
    }
  }
  if (sshfs.idmap == 2) {
    if (sshfs.r_gid_map) {
      tmp___1 = translate_id(& gid, sshfs.r_gid_map);
      if (tmp___1 == -1) {
        return (-1);
      }
    }
  }
  buf_init(& buf, (size_t )0);
  if ((unsigned long )sf == (unsigned long )((void *)0)) {
    buf_add_path(& buf, path);
  } else {
    buf_add_buf(& buf, (struct buffer  const  *)(& sf->handle));
  }
  buf_add_uint32(& buf, (uint32_t )2);
  buf_add_uint32(& buf, uid);
  buf_add_uint32(& buf, gid);
  if ((unsigned long )sf == (unsigned long )((void *)0)) {
    tmp___2 = 9;
  } else {
    tmp___2 = 10;
  }
  tmp___3 = get_conn((struct sshfs_file  const  *)sf, (char const   *)((void *)0));
  err = sftp_request(tmp___3, (uint8_t )tmp___2, (struct buffer  const  *)(& buf),
                     (uint8_t )101, (struct buffer *)((void *)0));
  buf_free(& buf);
  return (err);
}
}
static int sshfs_truncate_workaround(char const   *path , off_t size , struct fuse_file_info *fi ) ;
static void sshfs_inc_modifver(void) 
{ 


  {
  pthread_mutex_lock(& sshfs.lock);
  (sshfs.modifver) ++;
  pthread_mutex_unlock(& sshfs.lock);
  return;
}
}
static int sshfs_utimens(char const   *path , struct timespec  const  *tv , struct fuse_file_info *fi ) 
{ 
  int err ;
  struct buffer buf ;
  struct sshfs_file *sf ;
  time_t asec ;
  time_t msec ;
  struct timeval now ;
  int tmp ;
  int tmp___0 ;
  struct conn *tmp___1 ;

  {
  sf = (struct sshfs_file *)((void *)0);
  asec = (time_t )(tv + 0)->tv_sec;
  msec = (time_t )(tv + 1)->tv_sec;
  gettimeofday((struct timeval * __restrict  )(& now), (void * __restrict  )((void *)0));
  if (asec == 0L) {
    asec = now.tv_sec;
  }
  if (msec == 0L) {
    msec = now.tv_sec;
  }
  if ((unsigned long )fi != (unsigned long )((void *)0)) {
    sf = get_sshfs_file(fi);
    tmp = sshfs_file_is_conn(sf);
    if (! tmp) {
      return (-5);
    }
  }
  buf_init(& buf, (size_t )0);
  if ((unsigned long )sf == (unsigned long )((void *)0)) {
    buf_add_path(& buf, path);
  } else {
    buf_add_buf(& buf, (struct buffer  const  *)(& sf->handle));
  }
  buf_add_uint32(& buf, (uint32_t )8);
  buf_add_uint32(& buf, (uint32_t )asec);
  buf_add_uint32(& buf, (uint32_t )msec);
  if ((unsigned long )sf == (unsigned long )((void *)0)) {
    tmp___0 = 9;
  } else {
    tmp___0 = 10;
  }
  tmp___1 = get_conn((struct sshfs_file  const  *)sf, path);
  err = sftp_request(tmp___1, (uint8_t )tmp___0, (struct buffer  const  *)(& buf),
                     (uint8_t )101, (struct buffer *)((void *)0));
  buf_free(& buf);
  return (err);
}
}
static int sshfs_open_common(char const   *path , mode_t mode , struct fuse_file_info *fi ) 
{ 
  int err ;
  int err2 ;
  struct buffer buf ;
  struct buffer outbuf ;
  struct stat stbuf ;
  struct sshfs_file *sf ;
  struct request *open_req ;
  struct conntab_entry *ce ;
  uint32_t pflags ;
  struct iovec iov ;
  uint8_t type ;
  uint64_t wrctr ;
  gsize __n ;
  gsize __s ;
  gpointer __p ;
  gpointer tmp ;
  gpointer tmp___0 ;
  gchar *tmp___1 ;

  {
  pflags = (uint32_t )0;
  wrctr = (uint64_t )0;
  if (sshfs.dir_cache) {
    wrctr = cache_get_write_ctr();
  }
  if (sshfs.direct_io) {
    fi->direct_io = 1U;
  }
  if ((fi->flags & 3) == 0) {
    pflags = (uint32_t )1;
  } else
  if ((fi->flags & 3) == 1) {
    pflags = (uint32_t )2;
  } else
  if ((fi->flags & 3) == 2) {
    pflags = (uint32_t )3;
  } else {
    return (-22);
  }
  if (fi->flags & 64) {
    pflags |= 8U;
  }
  if (fi->flags & 128) {
    pflags |= 32U;
  }
  if (fi->flags & 512) {
    pflags |= 16U;
  }
  if (fi->flags & 1024) {
    pflags |= 4U;
  }
  __n = (gsize )1;
  __s = sizeof(struct sshfs_file );
  if (__s == 1UL) {
    __p = g_malloc0(__n);
  } else {
    __p = g_malloc0_n(__n, __s);
  }
  sf = (struct sshfs_file *)__p;
  list_init(& sf->write_reqs);
  pthread_cond_init((pthread_cond_t * __restrict  )(& sf->write_finished), (pthread_condattr_t const   * __restrict  )((void *)0));
  sf->is_seq = 0;
  sf->next_pos = (off_t )0;
  pthread_mutex_lock(& sshfs.lock);
  sf->modifver = (int )sshfs.modifver;
  if (sshfs.max_conns > 1) {
    tmp = g_hash_table_lookup(sshfs.conntab, (gconstpointer )path);
    ce = (struct conntab_entry *)tmp;
    if (! ce) {
      tmp___0 = g_malloc(sizeof(struct conntab_entry ));
      ce = (struct conntab_entry *)tmp___0;
      ce->refcount = 0U;
      ce->conn = get_conn((struct sshfs_file  const  *)((void *)0), (char const   *)((void *)0));
      tmp___1 = g_strdup(path);
      g_hash_table_insert(sshfs.conntab, (gpointer )tmp___1, (gpointer )ce);
    }
    sf->conn = ce->conn;
    (ce->refcount) ++;
    ((sf->conn)->file_count) ++;
    if (! ((sf->conn)->file_count > 0)) {
      __assert_fail("sf->conn->file_count > 0", "../sshfs.c", 2763U, "sshfs_open_common");
    }
  } else {
    sf->conn = sshfs.conns + 0;
    ce = (struct conntab_entry *)((void *)0);
  }
  sf->connver = (sf->conn)->connver;
  pthread_mutex_unlock(& sshfs.lock);
  buf_init(& buf, (size_t )0);
  buf_add_path(& buf, path);
  buf_add_uint32(& buf, pflags);
  buf_add_uint32(& buf, (uint32_t )4);
  buf_add_uint32(& buf, mode);
  buf_to_iov((struct buffer  const  *)(& buf), & iov);
  sftp_request_send(sf->conn, (uint8_t )3, & iov, (size_t )1, (void (*)(struct request * ))((void *)0),
                    (void (*)(struct request * ))((void *)0), 1, (void *)0, & open_req);
  buf_clear(& buf);
  buf_add_path(& buf, path);
  if (sshfs.follow_symlinks) {
    type = (uint8_t )17;
  } else {
    type = (uint8_t )7;
  }
  err2 = sftp_request(sf->conn, type, (struct buffer  const  *)(& buf), (uint8_t )105,
                      & outbuf);
  if (! err2) {
    err2 = buf_get_attrs(& outbuf, & stbuf, (int *)((void *)0));
    buf_free(& outbuf);
  }
  err = sftp_request_wait(open_req, (uint8_t )3, (uint8_t )102, & sf->handle);
  if (! err) {
    if (err2) {
      buf_finish(& sf->handle);
      sftp_request(sf->conn, (uint8_t )4, (struct buffer  const  *)(& sf->handle),
                   (uint8_t )0, (struct buffer *)((void *)0));
      buf_free(& sf->handle);
      err = err2;
    }
  }
  if (! err) {
    if (sshfs.dir_cache) {
      cache_add_attr(path, (struct stat  const  *)(& stbuf), wrctr);
    }
    buf_finish(& sf->handle);
    fi->fh = (unsigned long )sf;
  } else {
    if (sshfs.dir_cache) {
      cache_invalidate(path);
    }
    if (sshfs.max_conns > 1) {
      pthread_mutex_lock(& sshfs.lock);
      ((sf->conn)->file_count) --;
      (ce->refcount) --;
      if (ce->refcount == 0U) {
        g_hash_table_remove(sshfs.conntab, (gconstpointer )path);
        g_free((gpointer )ce);
      }
      pthread_mutex_unlock(& sshfs.lock);
    }
    g_free((gpointer )sf);
  }
  buf_free(& buf);
  return (err);
}
}
static int sshfs_open(char const   *path , struct fuse_file_info *fi ) 
{ 
  int tmp ;

  {
  tmp = sshfs_open_common(path, (mode_t )0, fi);
  return (tmp);
}
}
static int sshfs_flush(char const   *path , struct fuse_file_info *fi ) 
{ 
  int err ;
  struct sshfs_file *sf ;
  struct sshfs_file *tmp ;
  struct list_head write_reqs ;
  struct list_head *curr_list ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = get_sshfs_file(fi);
  sf = tmp;
  tmp___0 = sshfs_file_is_conn(sf);
  if (! tmp___0) {
    return (-5);
  }
  if (sshfs.sync_write) {
    return (0);
  }
  pthread_mutex_lock(& sshfs.lock);
  tmp___2 = list_empty((struct list_head  const  *)(& sf->write_reqs));
  if (! tmp___2) {
    curr_list = sf->write_reqs.prev;
    list_del(& sf->write_reqs);
    list_init(& sf->write_reqs);
    list_add(& write_reqs, curr_list);
    while (1) {
      tmp___1 = list_empty((struct list_head  const  *)(& write_reqs));
      if (tmp___1) {
        break;
      }
      pthread_cond_wait((pthread_cond_t * __restrict  )(& sf->write_finished), (pthread_mutex_t * __restrict  )(& sshfs.lock));
    }
  }
  err = sf->write_error;
  sf->write_error = 0;
  pthread_mutex_unlock(& sshfs.lock);
  return (err);
}
}
static int sshfs_fsync(char const   *path , int isdatasync , struct fuse_file_info *fi ) 
{ 
  int err ;
  struct buffer buf ;
  struct sshfs_file *sf ;
  struct sshfs_file *tmp ;

  {
  err = sshfs_flush(path, fi);
  if (err) {
    return (err);
  }
  if (! sshfs.ext_fsync) {
    return (err);
  }
  tmp = get_sshfs_file(fi);
  sf = tmp;
  buf_init(& buf, (size_t )0);
  buf_add_string(& buf, "fsync@openssh.com");
  buf_add_buf(& buf, (struct buffer  const  *)(& sf->handle));
  err = sftp_request(sf->conn, (uint8_t )200, (struct buffer  const  *)(& buf), (uint8_t )101,
                     (struct buffer *)((void *)0));
  buf_free(& buf);
  return (err);
}
}
static int sshfs_release(char const   *path , struct fuse_file_info *fi ) 
{ 
  struct sshfs_file *sf ;
  struct sshfs_file *tmp ;
  struct buffer *handle ;
  struct conntab_entry *ce ;
  int tmp___0 ;
  gpointer tmp___1 ;

  {
  tmp = get_sshfs_file(fi);
  sf = tmp;
  handle = & sf->handle;
  tmp___0 = sshfs_file_is_conn(sf);
  if (tmp___0) {
    sshfs_flush(path, fi);
    sftp_request(sf->conn, (uint8_t )4, (struct buffer  const  *)handle, (uint8_t )0,
                 (struct buffer *)((void *)0));
  }
  buf_free(handle);
  chunk_put_locked(sf->readahead);
  if (sshfs.max_conns > 1) {
    pthread_mutex_lock(& sshfs.lock);
    ((sf->conn)->file_count) --;
    tmp___1 = g_hash_table_lookup(sshfs.conntab, (gconstpointer )path);
    ce = (struct conntab_entry *)tmp___1;
    (ce->refcount) --;
    if (ce->refcount == 0U) {
      g_hash_table_remove(sshfs.conntab, (gconstpointer )path);
      g_free((gpointer )ce);
    }
    pthread_mutex_unlock(& sshfs.lock);
  }
  g_free((gpointer )sf);
  return (0);
}
}
static void sshfs_read_end(struct request *req ) 
{ 
  struct read_req *rreq ;
  uint32_t serr ;
  int tmp ;
  int tmp___0 ;
  uint32_t retsize ;
  int tmp___1 ;
  int tmp___2 ;

  {
  rreq = (struct read_req *)req->data;
  if (req->error) {
    rreq->res = (ssize_t )req->error;
  } else
  if (req->replied) {
    rreq->res = (ssize_t )-5;
    if ((int )req->reply_type == 101) {
      tmp___0 = buf_get_uint32(& req->reply, & serr);
      if (tmp___0 != -1) {
        if (serr == 1U) {
          rreq->res = (ssize_t )0;
        } else {
          tmp = sftp_error_to_errno(serr);
          rreq->res = (ssize_t )(- tmp);
        }
      }
    } else
    if ((int )req->reply_type == 103) {
      tmp___2 = buf_get_uint32(& req->reply, & retsize);
      if (tmp___2 != -1) {
        if ((size_t )retsize > rreq->size) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"long read\n");
        } else {
          tmp___1 = buf_check_get(& req->reply, (size_t )retsize);
          if (tmp___1 != -1) {
            rreq->res = (ssize_t )retsize;
            rreq->data = req->reply;
            buf_init(& req->reply, (size_t )0);
          }
        }
      }
    } else {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"protocol error\n");
    }
  } else {
    rreq->res = (ssize_t )-5;
  }
  ((rreq->sio)->num_reqs) --;
  if (! (rreq->sio)->num_reqs) {
    pthread_cond_broadcast(& (rreq->sio)->finished);
  }
  return;
}
}
static void sshfs_read_begin(struct request *req ) 
{ 
  struct read_req *rreq ;

  {
  rreq = (struct read_req *)req->data;
  ((rreq->sio)->num_reqs) ++;
  return;
}
}
static struct read_chunk *sshfs_send_read(struct sshfs_file *sf , size_t size , off_t offset ) 
{ 
  struct read_chunk *chunk ;
  gsize __n ;
  gsize __s ;
  gpointer __p ;
  struct buffer *handle ;
  int err ;
  struct buffer buf ;
  struct iovec iov[1] ;
  struct read_req *rreq ;
  size_t bsize ;
  size_t tmp ;
  gsize __n___0 ;
  gsize __s___0 ;
  gpointer __p___0 ;

  {
  __n = (gsize )1;
  __s = sizeof(struct read_chunk );
  if (__s == 1UL) {
    __p = g_malloc0(__n);
  } else {
    __p = g_malloc0_n(__n, __s);
  }
  chunk = (struct read_chunk *)__p;
  handle = & sf->handle;
  pthread_cond_init((pthread_cond_t * __restrict  )(& chunk->sio.finished), (pthread_condattr_t const   * __restrict  )((void *)0));
  list_init(& chunk->reqs);
  chunk->size = size;
  chunk->offset = offset;
  chunk->refs = 1;
  while (size) {
    if (size < (size_t )sshfs.max_read) {
      tmp = size;
    } else {
      tmp = (size_t )sshfs.max_read;
    }
    bsize = tmp;
    __n___0 = (gsize )1;
    __s___0 = sizeof(struct read_req );
    if (__s___0 == 1UL) {
      __p___0 = g_malloc0(__n___0);
    } else {
      __p___0 = g_malloc0_n(__n___0, __s___0);
    }
    rreq = (struct read_req *)__p___0;
    rreq->sio = & chunk->sio;
    rreq->size = bsize;
    buf_init(& rreq->data, (size_t )0);
    list_add(& rreq->list, & chunk->reqs);
    buf_init(& buf, (size_t )0);
    buf_add_buf(& buf, (struct buffer  const  *)handle);
    buf_add_uint64(& buf, (uint64_t )offset);
    buf_add_uint32(& buf, (uint32_t )bsize);
    buf_to_iov((struct buffer  const  *)(& buf), & iov[0]);
    err = sftp_request_send(sf->conn, (uint8_t )5, iov, (size_t )1, & sshfs_read_begin,
                            & sshfs_read_end, 0, (void *)rreq, (struct request **)((void *)0));
    buf_free(& buf);
    if (err) {
      break;
    }
    size -= bsize;
    offset = (off_t )((size_t )offset + bsize);
  }
  return (chunk);
}
}
static int wait_chunk(struct read_chunk *chunk , char *buf , size_t size ) 
{ 
  int res ;
  struct read_req *rreq ;
  struct list_head  const  *__mptr ;
  int tmp ;

  {
  res = 0;
  pthread_mutex_lock(& sshfs.lock);
  while (chunk->sio.num_reqs) {
    pthread_cond_wait((pthread_cond_t * __restrict  )(& chunk->sio.finished), (pthread_mutex_t * __restrict  )(& sshfs.lock));
  }
  pthread_mutex_unlock(& sshfs.lock);
  if (chunk->sio.error) {
    if (chunk->sio.error != 1) {
      res = chunk->sio.error;
    }
    goto out;
  }
  while (1) {
    tmp = list_empty((struct list_head  const  *)(& chunk->reqs));
    if (tmp) {
      break;
    } else
    if (! size) {
      break;
    }
    __mptr = (struct list_head  const  *)chunk->reqs.prev;
    rreq = (struct read_req *)((char *)__mptr - (unsigned long )(& ((struct read_req *)0)->list));
    if (rreq->res < 0L) {
      chunk->sio.error = (int )rreq->res;
      break;
    }
    if (rreq->res == 0L) {
      chunk->sio.error = 1;
      break;
    } else
    if (size < (size_t )rreq->res) {
      buf_get_mem(& rreq->data, (void *)buf, size);
      rreq->res = (ssize_t )((size_t )rreq->res - size);
      rreq->size -= size;
      res = (int )((size_t )res + size);
      break;
    } else {
      buf_get_mem(& rreq->data, (void *)buf, (size_t )rreq->res);
      res = (int )((ssize_t )res + rreq->res);
      if ((size_t )rreq->res < rreq->size) {
        chunk->sio.error = 1;
        break;
      }
      buf += rreq->res;
      size -= (size_t )rreq->res;
      list_del(& rreq->list);
      buf_free(& rreq->data);
      g_free((gpointer )rreq);
    }
  }
  if (res > 0) {
    chunk->offset += (off_t )res;
    chunk->size -= (size_t )res;
  }
  out: 
  chunk_put_locked(chunk);
  return (res);
}
}
static int sshfs_sync_read(struct sshfs_file *sf , char *buf , size_t size , off_t offset ) 
{ 
  struct read_chunk *chunk ;
  int tmp ;

  {
  chunk = sshfs_send_read(sf, size, offset);
  tmp = wait_chunk(chunk, buf, size);
  return (tmp);
}
}
static void submit_read(struct sshfs_file *sf , size_t size , off_t offset , struct read_chunk **chunkp ) 
{ 
  struct read_chunk *chunk ;

  {
  chunk = sshfs_send_read(sf, size, offset);
  pthread_mutex_lock(& sshfs.lock);
  chunk->modifver = sshfs.modifver;
  chunk_put(*chunkp);
  *chunkp = chunk;
  (chunk->refs) ++;
  pthread_mutex_unlock(& sshfs.lock);
  return;
}
}
static struct read_chunk *search_read_chunk(struct sshfs_file *sf , off_t offset ) 
{ 
  struct read_chunk *ch ;

  {
  ch = sf->readahead;
  if (ch) {
    if (ch->offset == offset) {
      if (ch->modifver == sshfs.modifver) {
        (ch->refs) ++;
        return (ch);
      } else {
        return ((struct read_chunk *)((void *)0));
      }
    } else {
      return ((struct read_chunk *)((void *)0));
    }
  } else {
    return ((struct read_chunk *)((void *)0));
  }
}
}
static int sshfs_async_read(struct sshfs_file *sf , char *rbuf , size_t size , off_t offset ) 
{ 
  int res ;
  size_t total ;
  struct read_chunk *chunk ;
  struct read_chunk *chunk_prev ;
  size_t origsize ;
  int curr_is_seq ;
  int tmp ;
  size_t prev_size ;

  {
  res = 0;
  total = (size_t )0;
  chunk_prev = (struct read_chunk *)((void *)0);
  origsize = size;
  pthread_mutex_lock(& sshfs.lock);
  curr_is_seq = sf->is_seq;
  if (sf->next_pos == offset) {
    if ((long )sf->modifver == sshfs.modifver) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  sf->is_seq = tmp;
  sf->next_pos = (off_t )((size_t )offset + size);
  sf->modifver = (int )sshfs.modifver;
  chunk = search_read_chunk(sf, offset);
  pthread_mutex_unlock(& sshfs.lock);
  if (chunk) {
    if (chunk->size < size) {
      chunk_prev = chunk;
      size -= chunk->size;
      offset = (off_t )((size_t )offset + chunk->size);
      chunk = (struct read_chunk *)((void *)0);
    }
  }
  if (! chunk) {
    submit_read(sf, size, offset, & chunk);
  }
  if (curr_is_seq) {
    if (chunk) {
      if (chunk->size <= size) {
        submit_read(sf, origsize, (off_t )((size_t )offset + size), & sf->readahead);
      }
    }
  }
  if (chunk_prev) {
    prev_size = chunk_prev->size;
    res = wait_chunk(chunk_prev, rbuf, prev_size);
    if (res < (int )prev_size) {
      chunk_put_locked(chunk);
      return (res);
    }
    rbuf += res;
    total += (size_t )res;
  }
  res = wait_chunk(chunk, rbuf, size);
  if (res > 0) {
    total += (size_t )res;
  }
  if (res < 0) {
    return (res);
  }
  return ((int )total);
}
}
static int sshfs_read(char const   *path , char *rbuf , size_t size , off_t offset ,
                      struct fuse_file_info *fi ) 
{ 
  struct sshfs_file *sf ;
  struct sshfs_file *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  tmp = get_sshfs_file(fi);
  sf = tmp;
  tmp___0 = sshfs_file_is_conn(sf);
  if (! tmp___0) {
    return (-5);
  }
  if (sshfs.sync_read) {
    tmp___1 = sshfs_sync_read(sf, rbuf, size, offset);
    return (tmp___1);
  } else {
    tmp___2 = sshfs_async_read(sf, rbuf, size, offset);
    return (tmp___2);
  }
}
}
static void sshfs_write_begin(struct request *req ) 
{ 
  struct sshfs_file *sf ;

  {
  sf = (struct sshfs_file *)req->data;
  list_add(& req->list, & sf->write_reqs);
  return;
}
}
static void sshfs_write_end(struct request *req ) 
{ 
  uint32_t serr ;
  struct sshfs_file *sf ;
  int tmp ;

  {
  sf = (struct sshfs_file *)req->data;
  if (req->error) {
    sf->write_error = req->error;
  } else
  if (req->replied) {
    if ((int )req->reply_type != 101) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"protocol error\n");
    } else {
      tmp = buf_get_uint32(& req->reply, & serr);
      if (tmp != -1) {
        if (serr != 0U) {
          sf->write_error = -5;
        }
      }
    }
  }
  list_del(& req->list);
  pthread_cond_broadcast(& sf->write_finished);
  return;
}
}
static int sshfs_async_write(struct sshfs_file *sf , char const   *wbuf , size_t size ,
                             off_t offset ) 
{ 
  int err ;
  struct buffer *handle ;
  struct buffer buf ;
  struct iovec iov[2] ;
  size_t bsize ;
  size_t tmp ;

  {
  err = 0;
  handle = & sf->handle;
  while (1) {
    if (! err) {
      if (! size) {
        break;
      }
    } else {
      break;
    }
    if (size < (size_t )sshfs.max_write) {
      tmp = size;
    } else {
      tmp = (size_t )sshfs.max_write;
    }
    bsize = tmp;
    buf_init(& buf, (size_t )0);
    buf_add_buf(& buf, (struct buffer  const  *)handle);
    buf_add_uint64(& buf, (uint64_t )offset);
    buf_add_uint32(& buf, (uint32_t )bsize);
    buf_to_iov((struct buffer  const  *)(& buf), & iov[0]);
    iov[1].iov_base = (void *)wbuf;
    iov[1].iov_len = bsize;
    err = sftp_request_send(sf->conn, (uint8_t )6, iov, (size_t )2, & sshfs_write_begin,
                            & sshfs_write_end, 0, (void *)sf, (struct request **)((void *)0));
    buf_free(& buf);
    size -= bsize;
    wbuf += bsize;
    offset = (off_t )((size_t )offset + bsize);
  }
  return (err);
}
}
static void sshfs_sync_write_begin(struct request *req ) 
{ 
  struct sshfs_io *sio ;

  {
  sio = (struct sshfs_io *)req->data;
  (sio->num_reqs) ++;
  return;
}
}
static void sshfs_sync_write_end(struct request *req ) 
{ 
  uint32_t serr ;
  struct sshfs_io *sio ;
  int tmp ;

  {
  sio = (struct sshfs_io *)req->data;
  if (req->error) {
    sio->error = req->error;
  } else
  if (req->replied) {
    if ((int )req->reply_type != 101) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"protocol error\n");
    } else {
      tmp = buf_get_uint32(& req->reply, & serr);
      if (tmp != -1) {
        if (serr != 0U) {
          sio->error = -5;
        }
      }
    }
  }
  (sio->num_reqs) --;
  if (! sio->num_reqs) {
    pthread_cond_broadcast(& sio->finished);
  }
  return;
}
}
static int sshfs_sync_write(struct sshfs_file *sf , char const   *wbuf , size_t size ,
                            off_t offset ) 
{ 
  int err ;
  struct buffer *handle ;
  struct sshfs_io sio ;
  struct buffer buf ;
  struct iovec iov[2] ;
  size_t bsize ;
  size_t tmp ;

  {
  err = 0;
  handle = & sf->handle;
  sio.num_reqs = 0;
  sio.finished.__data.__annonCompField1.__wseq = 0ULL;
  sio.finished.__data.__annonCompField2.__g1_start = 0ULL;
  sio.finished.__data.__g_refs[0] = 0U;
  sio.finished.__data.__g_refs[1] = 0U;
  sio.finished.__data.__g_size[0] = 0U;
  sio.finished.__data.__g_size[1] = 0U;
  sio.finished.__data.__g1_orig_size = 0U;
  sio.finished.__data.__wrefs = 0U;
  sio.finished.__data.__g_signals[0] = 0U;
  sio.finished.__data.__g_signals[1] = 0U;
  sio.error = 0;
  pthread_cond_init((pthread_cond_t * __restrict  )(& sio.finished), (pthread_condattr_t const   * __restrict  )((void *)0));
  while (1) {
    if (! err) {
      if (! size) {
        break;
      }
    } else {
      break;
    }
    if (size < (size_t )sshfs.max_write) {
      tmp = size;
    } else {
      tmp = (size_t )sshfs.max_write;
    }
    bsize = tmp;
    buf_init(& buf, (size_t )0);
    buf_add_buf(& buf, (struct buffer  const  *)handle);
    buf_add_uint64(& buf, (uint64_t )offset);
    buf_add_uint32(& buf, (uint32_t )bsize);
    buf_to_iov((struct buffer  const  *)(& buf), & iov[0]);
    iov[1].iov_base = (void *)wbuf;
    iov[1].iov_len = bsize;
    err = sftp_request_send(sf->conn, (uint8_t )6, iov, (size_t )2, & sshfs_sync_write_begin,
                            & sshfs_sync_write_end, 0, (void *)(& sio), (struct request **)((void *)0));
    buf_free(& buf);
    size -= bsize;
    wbuf += bsize;
    offset = (off_t )((size_t )offset + bsize);
  }
  pthread_mutex_lock(& sshfs.lock);
  while (sio.num_reqs) {
    pthread_cond_wait((pthread_cond_t * __restrict  )(& sio.finished), (pthread_mutex_t * __restrict  )(& sshfs.lock));
  }
  pthread_mutex_unlock(& sshfs.lock);
  if (! err) {
    err = sio.error;
  }
  return (err);
}
}
static int sshfs_write(char const   *path , char const   *wbuf , size_t size , off_t offset ,
                       struct fuse_file_info *fi ) 
{ 
  int err ;
  struct sshfs_file *sf ;
  struct sshfs_file *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = get_sshfs_file(fi);
  sf = tmp;
  tmp___0 = sshfs_file_is_conn(sf);
  if (! tmp___0) {
    return (-5);
  }
  sshfs_inc_modifver();
  if (! sshfs.sync_write) {
    if (! sf->write_error) {
      err = sshfs_async_write(sf, wbuf, size, offset);
    } else {
      err = sshfs_sync_write(sf, wbuf, size, offset);
    }
  } else {
    err = sshfs_sync_write(sf, wbuf, size, offset);
  }
  if (err) {
    tmp___1 = err;
  } else {
    tmp___1 = (int )size;
  }
  return (tmp___1);
}
}
static int sshfs_ext_statvfs(char const   *path , struct statvfs *stbuf ) 
{ 
  int err ;
  struct buffer buf ;
  struct buffer outbuf ;
  struct conn *tmp ;
  int tmp___0 ;

  {
  buf_init(& buf, (size_t )0);
  buf_add_string(& buf, "statvfs@openssh.com");
  buf_add_path(& buf, path);
  tmp = get_conn((struct sshfs_file  const  *)((void *)0), (char const   *)((void *)0));
  err = sftp_request(tmp, (uint8_t )200, (struct buffer  const  *)(& buf), (uint8_t )201,
                     & outbuf);
  if (! err) {
    tmp___0 = buf_get_statvfs(& outbuf, stbuf);
    if (tmp___0 == -1) {
      err = -5;
    }
    buf_free(& outbuf);
  }
  buf_free(& buf);
  return (err);
}
}
static int sshfs_statfs(char const   *path , struct statvfs *buf ) 
{ 
  int tmp ;
  __fsblkcnt64_t tmp___0 ;
  __fsblkcnt64_t tmp___1 ;
  __fsfilcnt64_t tmp___2 ;

  {
  if (sshfs.ext_statvfs) {
    tmp = sshfs_ext_statvfs(path, buf);
    return (tmp);
  }
  buf->f_namemax = 255UL;
  buf->f_bsize = (unsigned long )sshfs.blksize;
  buf->f_frsize = buf->f_bsize;
  tmp___1 = (__fsblkcnt64_t )(1073741824000ULL / (unsigned long long )buf->f_frsize);
  buf->f_bavail = tmp___1;
  tmp___0 = tmp___1;
  buf->f_bfree = tmp___0;
  buf->f_blocks = tmp___0;
  tmp___2 = (__fsfilcnt64_t )1000000000;
  buf->f_ffree = tmp___2;
  buf->f_files = tmp___2;
  return (0);
}
}
static int sshfs_create(char const   *path , mode_t mode , struct fuse_file_info *fi ) 
{ 
  int tmp ;

  {
  if (sshfs.createmode_workaround) {
    mode = (mode_t )0;
  }
  tmp = sshfs_open_common(path, mode, fi);
  return (tmp);
}
}
static int sshfs_truncate(char const   *path , off_t size , struct fuse_file_info *fi ) 
{ 
  int err ;
  struct buffer buf ;
  struct sshfs_file *sf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct conn *tmp___2 ;

  {
  sf = (struct sshfs_file *)((void *)0);
  if ((unsigned long )fi != (unsigned long )((void *)0)) {
    sf = get_sshfs_file(fi);
    tmp = sshfs_file_is_conn(sf);
    if (! tmp) {
      return (-5);
    }
  }
  sshfs_inc_modifver();
  if (sshfs.truncate_workaround) {
    tmp___0 = sshfs_truncate_workaround(path, size, fi);
    return (tmp___0);
  }
  buf_init(& buf, (size_t )0);
  if ((unsigned long )sf != (unsigned long )((void *)0)) {
    buf_add_buf(& buf, (struct buffer  const  *)(& sf->handle));
  } else {
    buf_add_path(& buf, path);
  }
  buf_add_uint32(& buf, (uint32_t )1);
  buf_add_uint64(& buf, (uint64_t )size);
  if ((unsigned long )sf == (unsigned long )((void *)0)) {
    tmp___1 = 9;
  } else {
    tmp___1 = 10;
  }
  tmp___2 = get_conn((struct sshfs_file  const  *)sf, path);
  err = sftp_request(tmp___2, (uint8_t )tmp___1, (struct buffer  const  *)(& buf),
                     (uint8_t )101, (struct buffer *)((void *)0));
  buf_free(& buf);
  return (err);
}
}
static int sshfs_getattr(char const   *path , struct stat *stbuf , struct fuse_file_info *fi ) 
{ 
  int err ;
  struct buffer buf ;
  struct buffer outbuf ;
  struct sshfs_file *sf ;
  int tmp ;
  int tmp___0 ;
  struct conn *tmp___1 ;

  {
  sf = (struct sshfs_file *)((void *)0);
  if ((unsigned long )fi != (unsigned long )((void *)0)) {
    if (! sshfs.fstat_workaround) {
      sf = get_sshfs_file(fi);
      tmp = sshfs_file_is_conn(sf);
      if (! tmp) {
        return (-5);
      }
    }
  }
  buf_init(& buf, (size_t )0);
  if ((unsigned long )sf == (unsigned long )((void *)0)) {
    buf_add_path(& buf, path);
    if (sshfs.follow_symlinks) {
      tmp___0 = 17;
    } else {
      tmp___0 = 7;
    }
    tmp___1 = get_conn((struct sshfs_file  const  *)sf, path);
    err = sftp_request(tmp___1, (uint8_t )tmp___0, (struct buffer  const  *)(& buf),
                       (uint8_t )105, & outbuf);
  } else {
    buf_add_buf(& buf, (struct buffer  const  *)(& sf->handle));
    err = sftp_request(sf->conn, (uint8_t )8, (struct buffer  const  *)(& buf), (uint8_t )105,
                       & outbuf);
  }
  if (! err) {
    err = buf_get_attrs(& outbuf, stbuf, (int *)((void *)0));
    buf_free(& outbuf);
  }
  buf_free(& buf);
  return (err);
}
}
static int sshfs_truncate_zero(char const   *path ) 
{ 
  int err ;
  struct fuse_file_info fi ;

  {
  fi.flags = 513;
  err = sshfs_open(path, & fi);
  if (! err) {
    sshfs_release(path, & fi);
  }
  return (err);
}
}
static size_t calc_buf_size(off_t size , off_t offset ) 
{ 
  off_t tmp ;

  {
  if (offset + (off_t )sshfs.max_read < size) {
    tmp = (off_t )sshfs.max_read;
  } else {
    tmp = size - offset;
  }
  return ((size_t )tmp);
}
}
static int sshfs_truncate_shrink(char const   *path , off_t size ) 
{ 
  int res ;
  char *data ;
  off_t offset ;
  struct fuse_file_info fi ;
  void *tmp ;
  size_t bufsize ;
  size_t tmp___0 ;
  size_t bufsize___0 ;
  size_t tmp___1 ;

  {
  tmp = calloc((size_t )size, (size_t )1);
  data = (char *)tmp;
  if (! data) {
    return (-12);
  }
  fi.flags = 0;
  res = sshfs_open(path, & fi);
  if (res) {
    goto out;
  }
  offset = (off_t )0;
  while (offset < size) {
    tmp___0 = calc_buf_size(size, offset);
    bufsize = tmp___0;
    res = sshfs_read(path, data + offset, bufsize, offset, & fi);
    if (res <= 0) {
      break;
    }
    offset += (off_t )res;
  }
  sshfs_release(path, & fi);
  if (res < 0) {
    goto out;
  }
  fi.flags = 513;
  res = sshfs_open(path, & fi);
  if (res) {
    goto out;
  }
  offset = (off_t )0;
  while (offset < size) {
    tmp___1 = calc_buf_size(size, offset);
    bufsize___0 = tmp___1;
    res = sshfs_write(path, (char const   *)(data + offset), bufsize___0, offset,
                      & fi);
    if (res < 0) {
      break;
    }
    offset += (off_t )res;
  }
  if (res >= 0) {
    res = sshfs_flush(path, & fi);
  }
  sshfs_release(path, & fi);
  out: 
  free((void *)data);
  return (res);
}
}
static int sshfs_truncate_extend(char const   *path , off_t size , struct fuse_file_info *fi ) 
{ 
  int res ;
  char c ;
  struct fuse_file_info tmpfi ;
  struct fuse_file_info *openfi ;

  {
  c = (char)0;
  openfi = fi;
  if (! fi) {
    openfi = & tmpfi;
    openfi->flags = 1;
    res = sshfs_open(path, openfi);
    if (res) {
      return (res);
    }
  }
  res = sshfs_write(path, (char const   *)(& c), (size_t )1, size - 1L, openfi);
  if (res == 1) {
    res = sshfs_flush(path, openfi);
  }
  if (! fi) {
    sshfs_release(path, openfi);
  }
  return (res);
}
}
static int sshfs_truncate_workaround(char const   *path , off_t size , struct fuse_file_info *fi ) 
{ 
  int tmp ;
  struct stat stbuf ;
  int err ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (size == 0L) {
    tmp = sshfs_truncate_zero(path);
    return (tmp);
  } else {
    err = sshfs_getattr(path, & stbuf, fi);
    if (err) {
      return (err);
    }
    if (stbuf.st_size == size) {
      return (0);
    } else
    if (stbuf.st_size > size) {
      tmp___0 = sshfs_truncate_shrink(path, size);
      return (tmp___0);
    } else {
      tmp___1 = sshfs_truncate_extend(path, size, fi);
      return (tmp___1);
    }
  }
}
}
static int processing_init(void) 
{ 
  int i ;

  {
  signal(13, (void (*)(int  ))1);
  pthread_mutex_init(& sshfs.lock, (pthread_mutexattr_t const   *)((void *)0));
  i = 0;
  while (i < sshfs.max_conns) {
    pthread_mutex_init(& (sshfs.conns + i)->lock_write, (pthread_mutexattr_t const   *)((void *)0));
    i ++;
  }
  pthread_cond_init((pthread_cond_t * __restrict  )(& sshfs.outstanding_cond), (pthread_condattr_t const   * __restrict  )((void *)0));
  sshfs.reqtab = g_hash_table_new((guint (*)(gconstpointer key ))((void *)0), (gboolean (*)(gconstpointer a ,
                                                                                            gconstpointer b ))((void *)0));
  if (! sshfs.reqtab) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"failed to create hash table\n");
    return (-1);
  }
  if (sshfs.max_conns > 1) {
    sshfs.conntab = g_hash_table_new_full(& g_str_hash, & g_str_equal, & g_free, (void (*)(gpointer data ))((void *)0));
    if (! sshfs.conntab) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"failed to create hash table\n");
      return (-1);
    }
  }
  return (0);
}
}
static struct fuse_operations sshfs_oper  = 
     {& sshfs_getattr, & sshfs_readlink, & sshfs_mknod, & sshfs_mkdir, & sshfs_unlink,
    & sshfs_rmdir, & sshfs_symlink, & sshfs_rename, & sshfs_link, & sshfs_chmod, & sshfs_chown,
    & sshfs_truncate, & sshfs_open, & sshfs_read, & sshfs_write, & sshfs_statfs, & sshfs_flush,
    & sshfs_release, & sshfs_fsync, (int (*)(char const   * , char const   * , char const   * ,
                                             size_t  , int  ))0, (int (*)(char const   * ,
                                                                          char const   * ,
                                                                          char * ,
                                                                          size_t  ))0,
    (int (*)(char const   * , char * , size_t  ))0, (int (*)(char const   * , char const   * ))0,
    & sshfs_opendir, & sshfs_readdir, & sshfs_releasedir, (int (*)(char const   * ,
                                                                   int  , struct fuse_file_info * ))0,
    & sshfs_init, (void (*)(void *private_data ))0, & sshfs_access, & sshfs_create,
    (int (*)(char const   * , struct fuse_file_info * , int cmd , struct flock * ))0,
    & sshfs_utimens, (int (*)(char const   * , size_t blocksize , uint64_t *idx ))0,
    (int (*)(char const   * , unsigned int cmd , void *arg , struct fuse_file_info * ,
             unsigned int flags , void *data ))0, (int (*)(char const   * , struct fuse_file_info * ,
                                                           struct fuse_pollhandle *ph ,
                                                           unsigned int *reventsp ))0,
    (int (*)(char const   * , struct fuse_bufvec *buf , off_t off , struct fuse_file_info * ))0,
    (int (*)(char const   * , struct fuse_bufvec **bufp , size_t size , off_t off ,
             struct fuse_file_info * ))0, (int (*)(char const   * , struct fuse_file_info * ,
                                                   int op ))0, (int (*)(char const   * ,
                                                                        int  , off_t  ,
                                                                        off_t  , struct fuse_file_info * ))0,
    (ssize_t (*)(char const   *path_in , struct fuse_file_info *fi_in , off_t offset_in ,
                 char const   *path_out , struct fuse_file_info *fi_out , off_t offset_out ,
                 size_t size , int flags ))0, (off_t (*)(char const   * , off_t off ,
                                                         int whence , struct fuse_file_info * ))0};
static void usage(char const   *progname ) 
{ 


  {
  printf((char const   * __restrict  )"usage: %s [user@]host:[dir] mountpoint [options]\n\n    -h   --help            print help\n    -V   --version         print version\n    -f                     foreground operation\n    -s                     disable multi-threaded operation\n    -p PORT                equivalent to \'-o port=PORT\'\n    -C                     equivalent to \'-o compression=yes\'\n    -F ssh_configfile      specifies alternative ssh configuration file\n    -1                     equivalent to \'-o ssh_protocol=1\'\n    -o opt,[opt...]        mount options\n    -o reconnect           reconnect to server\n    -o delay_connect       delay connection to server\n    -o sshfs_sync          synchronous writes\n    -o no_readahead        synchronous reads (no speculative readahead)\n    -o sync_readdir        synchronous readdir\n    -d, --debug            print some debugging information (implies -f)\n    -v, --verbose          print ssh replies and messages\n    -o dir_cache=BOOL      enable caching of directory contents (names,\n                           attributes, symlink targets) {yes,no} (default: yes)\n    -o dcache_max_size=N   sets the maximum size of the directory cache (default: 10000)\n    -o dcache_timeout=N    sets timeout for directory cache in seconds (default: 20)\n    -o dcache_{stat,link,dir}_timeout=N\n                           sets separate timeout for {attributes, symlinks, names}\n    -o dcache_clean_interval=N\n                           sets the interval for automatic cleaning of the\n                           cache (default: 60)\n    -o dcache_min_clean_interval=N\n                           sets the interval for forced cleaning of the\n                           cache if full (default: 5)\n    -o direct_io           enable direct i/o\n    -o workaround=LIST     colon separated list of workarounds\n             none             no workarounds enabled\n             [no]rename       fix renaming to existing file (default: off)\n             [no]renamexdev   fix moving across filesystems (default: off)\n             [no]truncate     fix truncate for old servers (default: off)\n             [no]buflimit     fix buffer fillup bug in server (default: off)\n             [no]fstat        always use stat() instead of fstat() (default: off)\n             [no]createmode   always pass mode 0 to create (default: off)\n    -o idmap=TYPE          user/group ID mapping (default: none)\n             none             no translation of the ID space\n             user             only translate UID/GID of connecting user\n             file             translate UIDs/GIDs contained in uidfile/gidfile\n    -o uidfile=FILE        file containing username:remote_uid mappings\n    -o gidfile=FILE        file containing groupname:remote_gid mappings\n    -o nomap=TYPE          with idmap=file, how to handle missing mappings\n             ignore           don\'t do any re-mapping\n             error            return an error (default)\n    -o ssh_command=CMD     execute CMD instead of \'ssh\'\n    -o ssh_protocol=N      ssh protocol to use (default: 2)\n    -o sftp_server=SERV    path to sftp server or subsystem (default: sftp)\n    -o directport=PORT     directly connect to PORT bypassing ssh\n    -o passive             communicate over stdin and stdout bypassing network\n    -o disable_hardlink    link(2) will return with errno set to ENOSYS\n    -o transform_symlinks  transform absolute symlinks to relative\n    -o follow_symlinks     follow symlinks on the server\n    -o no_check_root       don\'t check for existence of \'dir\' on server\n    -o password_stdin      read password from stdin (only for pam_mount!)\n    -o max_conns=N         open parallel SSH connections\n    -o SSHOPT=VAL          ssh options (see man ssh_config)\n\nFUSE Options:\n",
         progname);
  return;
}
}
static int is_ssh_opt(char const   *arg ) 
{ 
  unsigned int arglen ;
  size_t tmp ;
  char const   **o ;
  unsigned int olen ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  if ((int const   )*(arg + 0) != 45) {
    tmp = strlen(arg);
    arglen = (unsigned int )tmp;
    o = ssh_opts;
    while (*o) {
      tmp___0 = strlen(*o);
      olen = (unsigned int )tmp___0;
      if (arglen > olen) {
        if ((int const   )*(arg + olen) == 61) {
          tmp___1 = strncasecmp(arg, *o, (size_t )olen);
          if (tmp___1 == 0) {
            return (1);
          }
        }
      }
      o ++;
    }
  }
  return (0);
}
}
static int sshfs_opt_proc(void *data , char const   *arg , int key , struct fuse_args *outargs ) 
{ 
  char *tmp ;
  int tmp___0 ;
  int fd ;
  int len ;
  int tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  switch (key) {
  case -1: 
  tmp___0 = is_ssh_opt(arg);
  if (tmp___0) {
    tmp = g_strdup_printf("-o%s", arg);
    ssh_add_arg((char const   *)tmp);
    g_free((gpointer )tmp);
    return (0);
  }
  return (1);
  case -2: 
  if (! sshfs.host) {
    tmp___5 = strchr(arg, ':');
    if (tmp___5) {
      sshfs.host = strdup(arg);
      return (0);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (! sshfs.mountpoint) {
    tmp___1 = sscanf((char const   * __restrict  )arg, (char const   * __restrict  )"/dev/fd/%u%n",
                     & fd, & len);
    if (tmp___1 == 1) {
      tmp___2 = strlen(arg);
      if ((size_t )len == tmp___2) {
        sshfs.mountpoint = strdup(arg);
      } else {
        sshfs.mountpoint = realpath((char const   * __restrict  )arg, (char * __restrict  )((void *)0));
      }
    } else {
      sshfs.mountpoint = realpath((char const   * __restrict  )arg, (char * __restrict  )((void *)0));
    }
    if (! sshfs.mountpoint) {
      tmp___3 = __errno_location();
      tmp___4 = strerror(*tmp___3);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"sshfs: bad mount point `%s\': %s\n",
              arg, tmp___4);
      return (-1);
    }
    return (0);
  }
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"sshfs: invalid argument `%s\'\n",
          arg);
  return (-1);
  case 0: 
  tmp = g_strdup_printf("-oPort=%s", arg + 2);
  ssh_add_arg((char const   *)tmp);
  g_free((gpointer )tmp);
  return (0);
  case 1: 
  ssh_add_arg("-oCompression=yes");
  return (0);
  case 2: 
  tmp = g_strdup_printf("-F%s", arg + 2);
  ssh_add_arg((char const   *)tmp);
  g_free((gpointer )tmp);
  return (0);
  default: 
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"internal error\n");
  abort();
  }
}
}
static int workaround_opt_proc(void *data , char const   *arg , int key , struct fuse_args *outargs ) 
{ 


  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"unknown workaround: \'%s\'\n",
          arg);
  return (-1);
}
}
static int parse_workarounds(void) 
{ 
  int res ;
  char argv0[1] ;
  char argv1[3] ;
  char *argv[4] ;
  struct fuse_args args ;
  char *s ;

  {
  argv0[0] = (char )'\000';
  argv1[0] = (char )'-';
  argv1[1] = (char )'o';
  argv1[2] = (char )'\000';
  argv[0] = argv0;
  argv[1] = argv1;
  argv[2] = sshfs.workarounds;
  argv[3] = (char *)((void *)0);
  args.argc = 3;
  args.argv = argv;
  args.allocated = 0;
  s = sshfs.workarounds;
  if (! s) {
    return (0);
  }
  while (1) {
    s = strchr((char const   *)s, ':');
    if (! s) {
      break;
    }
    *s = (char )',';
  }
  res = fuse_opt_parse(& args, (void *)(& sshfs), (struct fuse_opt  const  *)(workaround_opts),
                       & workaround_opt_proc);
  fuse_opt_free_args(& args);
  return (res);
}
}
static int read_password(void) 
{ 
  int size ;
  int tmp ;
  int max_password ;
  int tmp___0 ;
  int n ;
  void *tmp___1 ;
  int tmp___2 ;
  int res ;
  ssize_t tmp___3 ;

  {
  tmp = getpagesize();
  size = tmp;
  if (1024 < size - 1) {
    tmp___0 = 1024;
  } else {
    tmp___0 = size - 1;
  }
  max_password = tmp___0;
  tmp___1 = mmap((void *)0, (size_t )size, 3, 8226, -1, (__off64_t )0);
  sshfs.password = (char *)tmp___1;
  if ((unsigned long )sshfs.password == (unsigned long )((void *)-1)) {
    perror("Failed to allocate locked page for password");
    return (-1);
  }
  tmp___2 = mlock((void const   *)sshfs.password, (size_t )size);
  if (tmp___2 != 0) {
    memset((void *)sshfs.password, 0, (size_t )size);
    munmap((void *)sshfs.password, (size_t )size);
    sshfs.password = (char *)((void *)0);
    perror("Failed to allocate locked page for password");
    return (-1);
  }
  n = 0;
  while (n < max_password) {
    tmp___3 = read(0, (void *)(sshfs.password + n), (size_t )1);
    res = (int )tmp___3;
    if (res == -1) {
      perror("Reading password");
      return (-1);
    }
    if (res == 0) {
      *(sshfs.password + n) = (char )'\n';
      break;
    }
    if ((int )*(sshfs.password + n) == 10) {
      break;
    }
    n ++;
  }
  if (n == max_password) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Password too long\n");
    return (-1);
  }
  *(sshfs.password + (n + 1)) = (char )'\000';
  ssh_add_arg("-oNumberOfPasswordPrompts=1");
  return (0);
}
}
static char *tokenize_on_space(char *str ) ;
static char *pos  =    (char *)((void *)0);
static char *tokenize_on_space(char *str ) 
{ 
  char *start ;

  {
  start = (char *)((void *)0);
  if (str) {
    pos = str;
  }
  if (! pos) {
    return ((char *)((void *)0));
  }
  while ((int )*pos == 32) {
    pos ++;
  }
  start = pos;
  while (1) {
    if (pos) {
      if (! ((int )*pos != 0)) {
        break;
      }
    } else {
      break;
    }
    if ((int )*pos == 32) {
      if ((int )*(pos - 1) != 92) {
        break;
      }
    }
    pos ++;
  }
  if ((int )*pos == 0) {
    pos = (char *)((void *)0);
  } else {
    *pos = (char )'\000';
    pos ++;
  }
  return (start);
}
}
static void set_ssh_command(void) 
{ 
  char *token ;
  int i ;
  int tmp ;

  {
  token = (char *)((void *)0);
  i = 0;
  token = tokenize_on_space(sshfs.ssh_command);
  while ((unsigned long )token != (unsigned long )((void *)0)) {
    if (i == 0) {
      replace_arg(sshfs.ssh_args.argv + 0, (char const   *)token);
    } else {
      tmp = fuse_opt_insert_arg(& sshfs.ssh_args, i, (char const   *)token);
      if (tmp == -1) {
        _exit(1);
      }
    }
    i ++;
    token = tokenize_on_space((char *)((void *)0));
  }
  return;
}
}
static char *find_base_path(void) 
{ 
  char *s ;
  char *d ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  s = sshfs.host;
  d = s;
  while (1) {
    if (*s) {
      if (! ((int )*s != 58)) {
        break;
      }
    } else {
      break;
    }
    if ((int )*s == 91) {
      s ++;
      while ((int )*s != 93) {
        if (! *s) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"missing \']\' in hostname\n");
          exit(1);
        }
        tmp = d;
        d ++;
        *tmp = *s;
        s ++;
      }
    } else {
      tmp___0 = d;
      d ++;
      *tmp___0 = *s;
    }
    s ++;
  }
  tmp___1 = d;
  d ++;
  *tmp___1 = (char )'\000';
  s ++;
  return (s);
}
}
static char *fsname_escape_commas(char *fsnameold ) 
{ 
  char *fsname ;
  size_t tmp ;
  gpointer tmp___0 ;
  char *d ;
  char *s ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  tmp = strlen((char const   *)fsnameold);
  tmp___0 = g_malloc(tmp * 2UL + 1UL);
  fsname = (char *)tmp___0;
  d = fsname;
  s = fsnameold;
  while (*s) {
    if ((int )*s == 92) {
      tmp___1 = d;
      d ++;
      *tmp___1 = (char )'\\';
    } else
    if ((int )*s == 44) {
      tmp___1 = d;
      d ++;
      *tmp___1 = (char )'\\';
    }
    tmp___2 = d;
    d ++;
    *tmp___2 = *s;
    s ++;
  }
  *d = (char )'\000';
  g_free((gpointer )fsnameold);
  return (fsname);
}
}
static int ssh_connect(void) 
{ 
  int res ;
  int tmp ;
  int tmp___0 ;

  {
  res = processing_init();
  if (res == -1) {
    return (-1);
  }
  if (! sshfs.delay_connect) {
    tmp = connect_remote(sshfs.conns + 0);
    if (tmp == -1) {
      return (-1);
    }
    if (! sshfs.no_check_root) {
      tmp___0 = sftp_check_root(sshfs.conns + 0, (char const   *)sshfs.base_path);
      if (tmp___0 != 0) {
        return (-1);
      }
    }
  }
  return (0);
}
}
static void parse_idmap_line(char *line , char const   *filename , unsigned int const   lineno ,
                             uint32_t *ret_id , char **ret_name , int const   eof ) 
{ 
  char *p ;
  char *tokens[3] ;
  char *tok ;
  int i ;
  char *name_tok ;
  char *id_tok ;
  int *tmp ;
  uint32_t remote_id ;
  unsigned long tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
  p = line;
  p = strrchr((char const   *)line, '\n');
  if (p) {
    *p = (char )'\000';
  } else
  if (! eof) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%u: line too long\n",
            filename, lineno);
    exit(1);
  }
  i = 0;
  while (1) {
    tok = strsep((char ** __restrict  )(& line), (char const   * __restrict  )":");
    if (tok) {
      if (! (i < 3)) {
        break;
      }
    } else {
      break;
    }
    tokens[i] = tok;
    i ++;
  }
  if (i == 2) {
    name_tok = tokens[0];
    id_tok = tokens[1];
  } else
  if (i >= 3) {
    name_tok = tokens[0];
    id_tok = tokens[2];
  } else {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s:%u: unknown format\n",
            filename, lineno);
    exit(1);
  }
  tmp = __errno_location();
  *tmp = 0;
  tmp___0 = strtoul((char const   * __restrict  )id_tok, (char ** __restrict  )((void *)0),
                    10);
  remote_id = (uint32_t )tmp___0;
  tmp___3 = __errno_location();
  if (*tmp___3) {
    tmp___1 = __errno_location();
    tmp___2 = strerror(*tmp___1);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid id number on line %u of \'%s\': %s\n",
            lineno, filename, tmp___2);
    exit(1);
  }
  *ret_name = strdup((char const   *)name_tok);
  *ret_id = remote_id;
  return;
}
}
static void read_id_map(char *file , uint32_t *(*map_fn)(char * ) , char const   *name_id ,
                        GHashTable **idmap , GHashTable **r_idmap ) 
{ 
  FILE *fp ;
  char line[2048] ;
  unsigned int lineno ;
  uid_t local_uid ;
  __uid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  struct stat st ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  uint32_t remote_id ;
  char *name ;
  int tmp___6 ;
  uint32_t *local_id ;
  uint32_t *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
  *idmap = g_hash_table_new((guint (*)(gconstpointer key ))((void *)0), (gboolean (*)(gconstpointer a ,
                                                                                      gconstpointer b ))((void *)0));
  *r_idmap = g_hash_table_new((guint (*)(gconstpointer key ))((void *)0), (gboolean (*)(gconstpointer a ,
                                                                                        gconstpointer b ))((void *)0));
  lineno = 0U;
  tmp = getuid();
  local_uid = tmp;
  fp = fopen((char const   * __restrict  )file, (char const   * __restrict  )"r");
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    tmp___0 = __errno_location();
    tmp___1 = strerror(*tmp___0);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"failed to open \'%s\': %s\n",
            file, tmp___1);
    exit(1);
  }
  tmp___4 = fileno(fp);
  tmp___5 = fstat(tmp___4, & st);
  if (tmp___5 == -1) {
    tmp___2 = __errno_location();
    tmp___3 = strerror(*tmp___2);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"failed to stat \'%s\': %s\n",
            file, tmp___3);
    exit(1);
  }
  if (st.st_uid != local_uid) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\'%s\' is not owned by uid %lu\n",
            file, (unsigned long )local_uid);
    exit(1);
  }
  if (st.st_mode & (unsigned int )(128 >> 3)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\'%s\' is writable by other users\n",
            file);
    exit(1);
  } else
  if (st.st_mode & (unsigned int )((128 >> 3) >> 3)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\'%s\' is writable by other users\n",
            file);
    exit(1);
  }
  while (1) {
    tmp___8 = fgets((char * __restrict  )(line), 2048, (FILE * __restrict  )fp);
    if (! ((unsigned long )tmp___8 != (unsigned long )((void *)0))) {
      break;
    }
    lineno ++;
    if ((int )line[0] == 10) {
      continue;
    } else
    if ((int )line[0] == 0) {
      continue;
    }
    tmp___6 = feof(fp);
    parse_idmap_line(line, (char const   *)file, (unsigned int const   )lineno, & remote_id,
                     & name, (int const   )tmp___6);
    tmp___7 = (*map_fn)(name);
    local_id = tmp___7;
    if ((unsigned long )local_id == (unsigned long )((void *)0)) {
      while (1) {
        if (sshfs.debug) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s(%u): no local %s\n",
                  name, remote_id, name_id);
        }
        break;
      }
      free((void *)name);
      continue;
    }
    while (1) {
      if (sshfs.debug) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: remote %s %u => local %s %u\n",
                name, name_id, remote_id, name_id, *local_id);
      }
      break;
    }
    g_hash_table_insert(*idmap, (gpointer )((gulong )remote_id), (gpointer )((gulong )*local_id));
    g_hash_table_insert(*r_idmap, (gpointer )((gulong )*local_id), (gpointer )((gulong )remote_id));
    free((void *)name);
    free((void *)local_id);
  }
  tmp___11 = fclose(fp);
  if (tmp___11 == -1) {
    tmp___9 = __errno_location();
    tmp___10 = strerror(*tmp___9);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"failed to close \'%s\': %s",
            file, tmp___10);
    exit(1);
  }
  return;
}
}
static uint32_t *username_to_uid(char *name ) 
{ 
  int *tmp ;
  struct passwd *pw ;
  struct passwd *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  uint32_t *r ;
  void *tmp___4 ;

  {
  tmp = __errno_location();
  *tmp = 0;
  tmp___0 = getpwnam((char const   *)name);
  pw = tmp___0;
  if ((unsigned long )pw == (unsigned long )((void *)0)) {
    tmp___1 = __errno_location();
    if (*tmp___1 == 0) {
      return ((uint32_t *)((void *)0));
    }
    tmp___2 = __errno_location();
    tmp___3 = strerror(*tmp___2);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed to look up user \'%s\': %s\n",
            name, tmp___3);
    exit(1);
  }
  tmp___4 = malloc(sizeof(uint32_t ));
  r = (uint32_t *)tmp___4;
  if ((unsigned long )r == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"sshfs: memory allocation failed\n");
    abort();
  }
  *r = pw->pw_uid;
  return (r);
}
}
static uint32_t *groupname_to_gid(char *name ) 
{ 
  int *tmp ;
  struct group *gr ;
  struct group *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  uint32_t *r ;
  void *tmp___4 ;

  {
  tmp = __errno_location();
  *tmp = 0;
  tmp___0 = getgrnam((char const   *)name);
  gr = tmp___0;
  if ((unsigned long )gr == (unsigned long )((void *)0)) {
    tmp___1 = __errno_location();
    if (*tmp___1 == 0) {
      return ((uint32_t *)((void *)0));
    }
    tmp___2 = __errno_location();
    tmp___3 = strerror(*tmp___2);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Failed to look up group \'%s\': %s\n",
            name, tmp___3);
    exit(1);
  }
  tmp___4 = malloc(sizeof(uint32_t ));
  r = (uint32_t *)tmp___4;
  if ((unsigned long )r == (unsigned long )((void *)0)) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"sshfs: memory allocation failed\n");
    abort();
  }
  *r = gr->gr_gid;
  return (r);
}
}
__inline static void load_uid_map(void) 
{ 


  {
  read_id_map(sshfs.uid_file, & username_to_uid, "uid", & sshfs.uid_map, & sshfs.r_uid_map);
  return;
}
}
__inline static void load_gid_map(void) 
{ 


  {
  read_id_map(sshfs.gid_file, & groupname_to_gid, "gid", & sshfs.gid_map, & sshfs.r_gid_map);
  return;
}
}
int main(int argc , char **argv ) 
{ 
  int res ;
  struct fuse_args args ;
  char *tmp ;
  char *fsname ;
  char const   *sftp_server ;
  struct fuse *fuse ;
  struct fuse_session *se ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  gsize __n ;
  gsize __s ;
  gpointer __p ;
  char *tmp___5 ;
  char *tmp___6 ;
  time_t tmp___7 ;
  int tmp___8 ;
  unsigned int avg_rtt ;

  {
  args.argc = argc;
  args.argv = argv;
  args.allocated = 0;
  sshfs.blksize = 4096U;
  sshfs.max_read = 32768U;
  sshfs.max_write = 32768U;
  sshfs.rename_workaround = 0;
  sshfs.renamexdev_workaround = 0;
  sshfs.truncate_workaround = 0;
  sshfs.buflimit_workaround = 0;
  sshfs.createmode_workaround = 0;
  sshfs.ssh_ver = 2U;
  sshfs.progname = *(argv + 0);
  sshfs.max_conns = 1;
  sshfs.ptyfd = -1;
  sshfs.dir_cache = 1;
  sshfs.show_help = 0;
  sshfs.show_version = 0;
  sshfs.singlethread = 0;
  sshfs.foreground = 0;
  sshfs.ptypassivefd = -1;
  sshfs.delay_connect = 0;
  sshfs.passive = 0;
  sshfs.detect_uid = 0;
  tmp___1 = strcmp("none", "none");
  if (tmp___1 == 0) {
    sshfs.idmap = 0;
  } else {
    tmp___0 = strcmp("none", "user");
    if (tmp___0 == 0) {
      sshfs.idmap = 1;
    } else {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"bad idmap default value built into sshfs; assuming none (bad logic in configure script?)\n");
      sshfs.idmap = 0;
    }
  }
  sshfs.nomap = 1;
  ssh_add_arg("ssh");
  ssh_add_arg("-x");
  ssh_add_arg("-a");
  ssh_add_arg("-oClearAllForwardings=yes");
  tmp___2 = fuse_opt_parse(& args, (void *)(& sshfs), (struct fuse_opt  const  *)(sshfs_opts),
                           & sshfs_opt_proc);
  if (tmp___2 == -1) {
    exit(1);
  } else {
    tmp___3 = parse_workarounds();
    if (tmp___3 == -1) {
      exit(1);
    }
  }
  if (sshfs.show_version) {
    printf((char const   * __restrict  )"SSHFS version %s\n", "3.7.3");
    tmp___4 = fuse_pkgversion();
    printf((char const   * __restrict  )"FUSE library version %s\n", tmp___4);
    fuse_lowlevel_version();
    exit(0);
  }
  if (sshfs.show_help) {
    usage((char const   *)*(args.argv + 0));
    fuse_lib_help(& args);
    exit(0);
  } else
  if (! sshfs.host) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"missing host\n");
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"see `%s -h\' for usage\n",
            *(argv + 0));
    exit(1);
  } else
  if (! sshfs.mountpoint) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"error: no mountpoint specified\n");
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"see `%s -h\' for usage\n",
            *(argv + 0));
    exit(1);
  }
  if (sshfs.idmap == 1) {
    sshfs.detect_uid = 1;
  } else
  if (sshfs.idmap == 2) {
    sshfs.uid_map = (GHashTable *)((void *)0);
    sshfs.gid_map = (GHashTable *)((void *)0);
    sshfs.r_uid_map = (GHashTable *)((void *)0);
    sshfs.r_gid_map = (GHashTable *)((void *)0);
    if (! sshfs.uid_file) {
      if (! sshfs.gid_file) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"need a uidfile or gidfile with idmap=file\n");
        exit(1);
      }
    }
    if (sshfs.uid_file) {
      load_uid_map();
    }
    if (sshfs.gid_file) {
      load_gid_map();
    }
  }
  free((void *)sshfs.uid_file);
  free((void *)sshfs.gid_file);
  while (1) {
    if (sshfs.debug) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"SSHFS version %s\n",
              "3.7.3");
    }
    break;
  }
  if (sshfs.passive) {
    sshfs.foreground = 1;
  }
  if (sshfs.passive) {
    if (sshfs.password_stdin) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"the password_stdin and passive options cannot both be specified\n");
      exit(1);
    }
  }
  if (sshfs.password_stdin) {
    res = read_password();
    if (res == -1) {
      exit(1);
    }
  }
  if (sshfs.debug) {
    sshfs.foreground = 1;
  }
  if (sshfs.buflimit_workaround) {
    sshfs.max_outstanding_len = 8388608U;
  } else {
    sshfs.max_outstanding_len = (unsigned int )(~ 0);
  }
  if (sshfs.max_conns > 1) {
    if (sshfs.buflimit_workaround) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"buflimit workaround is not supported with parallel connections\n");
      exit(1);
    }
    if (sshfs.password_stdin) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"password_stdin option cannot be specified with parallel connections\n");
      exit(1);
    }
    if (sshfs.passive) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"passive option cannot be specified with parallel connections\n");
      exit(1);
    }
  } else
  if (sshfs.max_conns <= 0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"value of max_conns option must be at least 1\n");
    exit(1);
  }
  __n = (gsize )sshfs.max_conns;
  __s = sizeof(struct conn );
  if (__s == 1UL) {
    __p = g_malloc0(__n);
  } else {
    __p = g_malloc0_n(__n, __s);
  }
  sshfs.conns = (struct conn *)__p;
  i = 0;
  while (i < sshfs.max_conns) {
    (sshfs.conns + i)->rfd = -1;
    (sshfs.conns + i)->wfd = -1;
    i ++;
  }
  fsname = g_strdup((gchar const   *)sshfs.host);
  tmp___5 = find_base_path();
  sshfs.base_path = g_strdup((gchar const   *)tmp___5);
  if (sshfs.ssh_command) {
    set_ssh_command();
  }
  tmp = g_strdup_printf("-%i", sshfs.ssh_ver);
  ssh_add_arg((char const   *)tmp);
  g_free((gpointer )tmp);
  ssh_add_arg((char const   *)sshfs.host);
  if (sshfs.sftp_server) {
    sftp_server = (char const   *)sshfs.sftp_server;
  } else
  if (sshfs.ssh_ver == 1U) {
    sftp_server = "/usr/lib/sftp-server";
  } else {
    sftp_server = "sftp";
  }
  if (sshfs.ssh_ver != 1U) {
    tmp___6 = strchr(sftp_server, '/');
    if ((unsigned long )tmp___6 == (unsigned long )((void *)0)) {
      ssh_add_arg("-s");
    }
  }
  ssh_add_arg(sftp_server);
  free((void *)sshfs.sftp_server);
  res = cache_parse_options(& args);
  if (res == -1) {
    exit(1);
  }
  tmp___7 = time((time_t *)0);
  sshfs.randseed = (unsigned int )tmp___7;
  if (sshfs.max_read > 65536U) {
    sshfs.max_read = 65536U;
  }
  if (sshfs.max_write > 65536U) {
    sshfs.max_write = 65536U;
  }
  fsname = fsname_escape_commas(fsname);
  tmp = g_strdup_printf("-osubtype=sshfs,fsname=%s", fsname);
  fuse_opt_insert_arg(& args, 1, (char const   *)tmp);
  g_free((gpointer )tmp);
  g_free((gpointer )fsname);
  if (sshfs.dir_cache) {
    sshfs.op = cache_wrap(& sshfs_oper);
  } else {
    sshfs.op = & sshfs_oper;
  }
  fuse = fuse_new(& args, (struct fuse_operations  const  *)sshfs.op, sizeof(struct fuse_operations ),
                  (void *)0);
  if ((unsigned long )fuse == (unsigned long )((void *)0)) {
    exit(1);
  }
  se = fuse_get_session(fuse);
  res = fuse_set_signal_handlers(se);
  if (res != 0) {
    fuse_destroy(fuse);
    exit(1);
  }
  res = fuse_mount(fuse, (char const   *)sshfs.mountpoint);
  if (res != 0) {
    fuse_destroy(fuse);
    exit(1);
  }
  tmp___8 = fuse_session_fd(se);
  res = fcntl(tmp___8, 2, 1);
  if (res == -1) {
    perror("WARNING: failed to set FD_CLOEXEC on fuse device");
  }
  res = ssh_connect();
  if (res == -1) {
    fuse_unmount(fuse);
    fuse_destroy(fuse);
    exit(1);
  }
  res = fuse_daemonize(sshfs.foreground);
  if (res == -1) {
    fuse_unmount(fuse);
    fuse_destroy(fuse);
    exit(1);
  }
  if (sshfs.singlethread) {
    res = fuse_loop(fuse);
  } else {
    res = fuse_loop_mt_31(fuse, 0);
  }
  if (res != 0) {
    res = 1;
  } else {
    res = 0;
  }
  fuse_remove_signal_handlers(se);
  fuse_unmount(fuse);
  fuse_destroy(fuse);
  if (sshfs.debug) {
    avg_rtt = 0U;
    if (sshfs.num_sent) {
      avg_rtt = (unsigned int )(sshfs.total_rtt / sshfs.num_sent);
    }
    while (1) {
      if (sshfs.debug) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\nsent:               %llu messages, %llu bytes\nreceived:           %llu messages, %llu bytes\nrtt min/max/avg:    %ums/%ums/%ums\nnum connect:        %u\n",
                (unsigned long long )sshfs.num_sent, (unsigned long long )sshfs.bytes_sent,
                (unsigned long long )sshfs.num_received, (unsigned long long )sshfs.bytes_received,
                sshfs.min_rtt, sshfs.max_rtt, avg_rtt, sshfs.num_connect);
      }
      break;
    }
  }
  fuse_opt_free_args(& args);
  fuse_opt_free_args(& sshfs.ssh_args);
  free((void *)sshfs.directport);
  return (res);
}
}
