/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef int __int32_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned long __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef long __time_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __blkcnt64_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
typedef __ino_t ino_t;
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
typedef unsigned long size_t;
typedef __builtin_va_list __gnuc_va_list;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef __ssize_t ssize_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
typedef unsigned long pthread_t;
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
struct ignores {
   char **extensions ;
   size_t extensions_len ;
   char **names ;
   size_t names_len ;
   char **slash_names ;
   size_t slash_names_len ;
   char **regexes ;
   size_t regexes_len ;
   char **invert_regexes ;
   size_t invert_regexes_len ;
   char **slash_regexes ;
   size_t slash_regexes_len ;
   char const   *dirname ;
   size_t dirname_len ;
   char *abs_path ;
   size_t abs_path_len ;
   struct ignores *parent ;
};
typedef struct ignores ignores;
struct real_pcre ;
typedef struct real_pcre pcre;
struct pcre_extra {
   unsigned long flags ;
   void *study_data ;
   unsigned long match_limit ;
   void *callout_data ;
   unsigned char const   *tables ;
   unsigned long match_limit_recursion ;
   unsigned char **mark ;
   void *executable_jit ;
};
typedef struct pcre_extra pcre_extra;
enum case_behavior {
    CASE_DEFAULT = 0,
    CASE_SENSITIVE = 1,
    CASE_INSENSITIVE = 2,
    CASE_SMART = 3,
    CASE_SENSITIVE_RETRY_INSENSITIVE = 4
} ;
struct __anonstruct_cli_options_661676448 {
   int ackmate ;
   pcre *ackmate_dir_filter ;
   pcre_extra *ackmate_dir_filter_extra ;
   size_t after ;
   size_t before ;
   enum case_behavior casing ;
   char const   *file_search_string ;
   int match_files ;
   pcre *file_search_regex ;
   pcre_extra *file_search_regex_extra ;
   int color ;
   char *color_line_number ;
   char *color_match ;
   char *color_path ;
   int color_win_ansi ;
   int column ;
   int context ;
   int follow_symlinks ;
   int invert_match ;
   int literal ;
   int literal_starts_wordchar ;
   int literal_ends_wordchar ;
   size_t max_matches_per_file ;
   int max_search_depth ;
   int mmap ;
   int multiline ;
   int one_dev ;
   int only_matching ;
   char path_sep ;
   int path_to_ignore ;
   int print_break ;
   int print_count ;
   int print_filename_only ;
   int print_nonmatching_files ;
   int print_path ;
   int print_all_paths ;
   int print_line_numbers ;
   int print_long_lines ;
   int passthrough ;
   pcre *re ;
   pcre_extra *re_extra ;
   int recurse_dirs ;
   int search_all_files ;
   int skip_vcs_ignores ;
   int search_binary_files ;
   int search_zip_files ;
   int search_hidden_files ;
   int search_stream ;
   int stats ;
   size_t stream_line_num ;
   int match_found ;
   ino_t stdout_inode ;
   char *query ;
   int query_len ;
   char *pager ;
   int paths_len ;
   int parallel ;
   int use_thread_affinity ;
   int vimgrep ;
   size_t width ;
   int word_regexp ;
   int workers ;
};
typedef struct __anonstruct_cli_options_661676448 cli_options;
struct __anonstruct_scandir_baton_t_387049375 {
   ignores const   *ig ;
   char const   *base_path ;
   size_t base_path_len ;
   char const   *path_start ;
};
typedef struct __anonstruct_scandir_baton_t_387049375 scandir_baton_t;
typedef __gnuc_va_list va_list___0;
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
enum log_level {
    LOG_LEVEL_DEBUG = 10,
    LOG_LEVEL_MSG = 20,
    LOG_LEVEL_WARN = 30,
    LOG_LEVEL_ERR = 40,
    LOG_LEVEL_NONE = 100
} ;
struct __anonstruct_lang_spec_t_527861670 {
   char const   *name ;
   char const   *extensions[12] ;
};
typedef struct __anonstruct_lang_spec_t_527861670 lang_spec_t;
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
typedef struct option option_t;
struct __anonstruct_match_t_73278319 {
   size_t start ;
   size_t end ;
};
typedef struct __anonstruct_match_t_73278319 match_t;
struct print_context {
   size_t line ;
   char **context_prev_lines ;
   size_t prev_line ;
   size_t last_prev_line ;
   size_t prev_line_offset ;
   size_t line_preceding_current_match_offset ;
   size_t lines_since_last_match ;
   size_t last_printed_match ;
   int in_a_match ;
   int printing_a_match ;
};
struct __dirstream ;
typedef struct __dirstream DIR;
typedef unsigned char __uint8_t;
typedef unsigned short __uint16_t;
typedef unsigned int __uint32_t;
typedef long __suseconds_t;
typedef __off_t off_t;
typedef __dev_t dev_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
struct __anonstruct___wseq32_112954846 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_180959546 {
   unsigned long long __wseq ;
   struct __anonstruct___wseq32_112954846 __wseq32 ;
};
struct __anonstruct___g1_start32_575217031 {
   unsigned int __low ;
   unsigned int __high ;
};
union __anonunion____missing_field_name_575217030 {
   unsigned long long __g1_start ;
   struct __anonstruct___g1_start32_575217031 __g1_start32 ;
};
struct __pthread_cond_s {
   union __anonunion____missing_field_name_180959546 __annonCompField1 ;
   union __anonunion____missing_field_name_575217030 __annonCompField2 ;
   unsigned int __g_refs[2] ;
   unsigned int __g_size[2] ;
   unsigned int __g1_orig_size ;
   unsigned int __wrefs ;
   unsigned int __g_signals[2] ;
};
union __anonunion_pthread_cond_t_951761805 {
   struct __pthread_cond_s __data ;
   char __size[48] ;
   long long __align ;
};
typedef union __anonunion_pthread_cond_t_951761805 pthread_cond_t;
enum __anonenum_ag_compression_type_847750060 {
    AG_NO_COMPRESSION = 0,
    AG_GZIP = 1,
    AG_COMPRESS = 2,
    AG_ZIP = 3,
    AG_XZ = 4
} ;
typedef enum __anonenum_ag_compression_type_847750060 ag_compression_type;
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
struct __anonstruct_ag_stats_416475514 {
   size_t total_bytes ;
   size_t total_files ;
   size_t total_matches ;
   size_t total_file_matches ;
   struct timeval time_start ;
   struct timeval time_end ;
};
typedef struct __anonstruct_ag_stats_416475514 ag_stats;
typedef long ptrdiff_t;
struct UT_hash_handle ;
struct UT_hash_bucket {
   struct UT_hash_handle *hh_head ;
   unsigned int count ;
   unsigned int expand_mult ;
};
typedef struct UT_hash_bucket UT_hash_bucket;
struct UT_hash_table {
   UT_hash_bucket *buckets ;
   unsigned int num_buckets ;
   unsigned int log2_num_buckets ;
   unsigned int num_items ;
   struct UT_hash_handle *tail ;
   ptrdiff_t hho ;
   unsigned int ideal_chain_maxlen ;
   unsigned int nonideal_items ;
   unsigned int ineff_expands ;
   unsigned int noexpand ;
   uint32_t signature ;
};
typedef struct UT_hash_table UT_hash_table;
struct UT_hash_handle {
   struct UT_hash_table *tbl ;
   void *prev ;
   void *next ;
   struct UT_hash_handle *hh_prev ;
   struct UT_hash_handle *hh_next ;
   void *key ;
   unsigned int keylen ;
   unsigned int hashv ;
};
typedef struct UT_hash_handle UT_hash_handle;
struct work_queue_t {
   char *path ;
   struct work_queue_t *next ;
};
typedef struct work_queue_t work_queue_t;
struct __anonstruct_dirkey_t_583383409 {
   dev_t dev ;
   ino_t ino ;
};
typedef struct __anonstruct_dirkey_t_583383409 dirkey_t;
struct __anonstruct_symdir_t_545766974 {
   dirkey_t key ;
   UT_hash_handle hh ;
};
typedef struct __anonstruct_symdir_t_545766974 symdir_t;
union __anonunion_word_t_677777955 {
   char as_chars[sizeof(uint16_t )] ;
   uint16_t as_word ;
};
typedef union __anonunion_word_t_677777955 word_t;
typedef unsigned long __uint64_t;
typedef long __intmax_t;
typedef unsigned long __uintmax_t;
typedef __uint64_t uint64_t;
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
typedef int __gwchar_t;
enum __anonenum_lzma_reserved_enum_264666109 {
    LZMA_RESERVED_ENUM = 0
} ;
typedef enum __anonenum_lzma_reserved_enum_264666109 lzma_reserved_enum;
enum __anonenum_lzma_ret_557241514 {
    LZMA_OK = 0,
    LZMA_STREAM_END = 1,
    LZMA_NO_CHECK = 2,
    LZMA_UNSUPPORTED_CHECK = 3,
    LZMA_GET_CHECK = 4,
    LZMA_MEM_ERROR = 5,
    LZMA_MEMLIMIT_ERROR = 6,
    LZMA_FORMAT_ERROR = 7,
    LZMA_OPTIONS_ERROR = 8,
    LZMA_DATA_ERROR = 9,
    LZMA_BUF_ERROR = 10,
    LZMA_PROG_ERROR = 11
} ;
typedef enum __anonenum_lzma_ret_557241514 lzma_ret;
enum __anonenum_lzma_action_853458044 {
    LZMA_RUN = 0,
    LZMA_SYNC_FLUSH = 1,
    LZMA_FULL_FLUSH = 2,
    LZMA_FULL_BARRIER = 4,
    LZMA_FINISH = 3
} ;
typedef enum __anonenum_lzma_action_853458044 lzma_action;
struct __anonstruct_lzma_allocator_1021999983 {
   void *(*alloc)(void *opaque , size_t nmemb , size_t size ) ;
   void (*free)(void *opaque , void *ptr ) ;
   void *opaque ;
};
typedef struct __anonstruct_lzma_allocator_1021999983 lzma_allocator;
struct lzma_internal_s ;
typedef struct lzma_internal_s lzma_internal;
struct __anonstruct_lzma_stream_354570162 {
   uint8_t const   *next_in ;
   size_t avail_in ;
   uint64_t total_in ;
   uint8_t *next_out ;
   size_t avail_out ;
   uint64_t total_out ;
   lzma_allocator const   *allocator ;
   lzma_internal *internal ;
   void *reserved_ptr1 ;
   void *reserved_ptr2 ;
   void *reserved_ptr3 ;
   void *reserved_ptr4 ;
   uint64_t reserved_int1 ;
   uint64_t reserved_int2 ;
   size_t reserved_int3 ;
   size_t reserved_int4 ;
   lzma_reserved_enum reserved_enum1 ;
   lzma_reserved_enum reserved_enum2 ;
};
typedef struct __anonstruct_lzma_stream_354570162 lzma_stream;
typedef unsigned char Byte;
typedef unsigned int uInt;
typedef unsigned long uLong;
typedef Byte Bytef;
typedef void *voidpf;
struct internal_state ;
struct z_stream_s {
   Bytef const   *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char const   *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
typedef struct z_stream_s z_stream;
typedef z_stream *z_streamp;
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
union __anonunion_pthread_condattr_t_488594145 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_condattr_t_488594145 pthread_condattr_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
typedef unsigned long __cpu_mask;
struct __anonstruct_cpu_set_t_826868708 {
   __cpu_mask __bits[1024UL / (8UL * sizeof(__cpu_mask ))] ;
};
typedef struct __anonstruct_cpu_set_t_826868708 cpu_set_t;
struct __anonstruct_worker_t_846662689 {
   pthread_t thread ;
   int id ;
};
typedef struct __anonstruct_worker_t_846662689 worker_t;
typedef __off64_t off64_t;
typedef __ssize_t cookie_read_function_t(void *__cookie , char *__buf , size_t __nbytes );
typedef __ssize_t cookie_write_function_t(void *__cookie , char const   *__buf , size_t __nbytes );
typedef int cookie_seek_function_t(void *__cookie , __off64_t *__pos , int __w );
typedef int cookie_close_function_t(void *__cookie );
struct _IO_cookie_io_functions_t {
   cookie_read_function_t *read ;
   cookie_write_function_t *write ;
   cookie_seek_function_t *seek ;
   cookie_close_function_t *close ;
};
typedef struct _IO_cookie_io_functions_t cookie_io_functions_t;
union __anonunion_stream_340362379 {
   z_stream gz ;
   lzma_stream lzma ;
};
struct zfile {
   FILE *in ;
   uint64_t logic_offset ;
   uint64_t decode_offset ;
   uint64_t actual_len ;
   uint32_t outbuf_start ;
   ag_compression_type ctype ;
   union __anonunion_stream_340362379 stream ;
   uint8_t inbuf[32768] ;
   uint8_t outbuf[262144] ;
   _Bool eof ;
};
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#pragma merger("0","/tmp/cil-fMhTdVGC.i","-g,-O2,-pthread,-Wall,-Wextra,-Wformat=2,-Wno-format-nonliteral,-Wshadow,-Wpointer-arith,-Wcast-qual,-Wmissing-prototypes,-Wno-missing-braces,-std=gnu89")
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int toupper(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
__inline extern int tolower(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_tolower_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
    tmp___0 = (__int32_t const   )__c;
  }
  return ((int )tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) int toupper(int __c ) ;
__inline extern int toupper(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_toupper_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
    tmp___0 = (__int32_t const   )__c;
  }
  return ((int )tmp___0);
}
}
extern FILE *stdin ;
extern FILE *stdout ;
extern int fclose(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
__inline extern int vprintf(char const   * __restrict  __fmt , __gnuc_va_list __arg ) ;
extern int getc(FILE *__stream ) ;
__inline extern int getchar(void) ;
__inline extern int getc_unlocked(FILE *__fp ) ;
__inline extern int getchar_unlocked(void) ;
__inline extern int fgetc_unlocked(FILE *__fp ) ;
extern int putc(int __c , FILE *__stream ) ;
__inline extern int putchar(int __c ) ;
__inline extern int fputc_unlocked(int __c , FILE *__stream ) ;
__inline extern int putc_unlocked(int __c , FILE *__stream ) ;
__inline extern int putchar_unlocked(int __c ) ;
extern __ssize_t __getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                            int __delimiter , FILE * __restrict  __stream ) ;
__inline extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                                  FILE * __restrict  __stream ) ;
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream ) ;
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream ) ;
extern int __uflow(FILE * ) ;
extern int __overflow(FILE * , int  ) ;
__inline extern int vprintf(char const   * __restrict  __fmt , __gnuc_va_list __arg ) 
{ 
  int tmp ;

  {
  tmp = vfprintf((FILE * __restrict  )stdout, __fmt, __arg);
  return (tmp);
}
}
__inline extern int getchar(void) 
{ 
  int tmp ;

  {
  tmp = getc(stdin);
  return (tmp);
}
}
__inline extern int fgetc_unlocked(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(__fp);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = __fp->_IO_read_ptr;
    (__fp->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int getchar_unlocked(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(stdin);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = stdin->_IO_read_ptr;
    (stdin->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int putchar(int __c ) 
{ 
  int tmp ;

  {
  tmp = putc(__c, stdout);
  return (tmp);
}
}
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = __stream->_IO_write_ptr;
    (__stream->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern int putchar_unlocked(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = stdout->_IO_write_ptr;
    (stdout->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                                  FILE * __restrict  __stream ) 
{ 
  __ssize_t tmp ;

  {
  tmp = __getdelim(__lineptr, __n, '\n', __stream);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream ) ;
__inline extern int feof_unlocked(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 16) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream ) ;
__inline extern int ferror_unlocked(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 32) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1))) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1))) strtoll)(char const   * __restrict  __nptr ,
                                                                                          char ** __restrict  __endptr ,
                                                                                          int __base ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__nonnull__(1))) atoi)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return ((int )tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long ( __attribute__((__nonnull__(1))) atol)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1))) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long long ( __attribute__((__nonnull__(1))) atoll)(char const   *__nptr ) 
{ 
  long long tmp ;

  {
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5))) bsearch)(void const   *__key ,
                                                                     void const   *__base ,
                                                                     size_t __nmemb ,
                                                                     size_t __size ,
                                                                     int (*__compar)(void const   * ,
                                                                                     void const   * ) ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5))) bsearch)(void const   *__key ,
                                                                     void const   *__base ,
                                                                     size_t __nmemb ,
                                                                     size_t __size ,
                                                                     int (*__compar)(void const   * ,
                                                                                     void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
  __l = (size_t )0;
  __u = __nmemb;
  while (__l < __u) {
    __idx = (__l + __u) / 2UL;
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
    __comparison = (*__compar)(__key, __p);
    if (__comparison < 0) {
      __u = __idx;
    } else
    if (__comparison > 0) {
      __l = __idx + 1UL;
    } else {
      return ((void *)__p);
    }
  }
  return ((void *)0);
}
}
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern double ( __attribute__((__nonnull__(1))) atof)(char const   *__nptr ) 
{ 
  double tmp ;

  {
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __path ,
                                                                                            struct stat * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat)(int __fd ,
                                                                                           struct stat *__statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat64)(char const   * __restrict  __path ,
                                                                                              struct stat64 * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat64)(int __fd ,
                                                                                             struct stat64 *__statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) fstatat)(int __fd ,
                                                                                               char const   * __restrict  __filename ,
                                                                                               struct stat * __restrict  __statbuf ,
                                                                                               int __flag ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) fstatat64)(int __fd ,
                                                                                                 char const   * __restrict  __filename ,
                                                                                                 struct stat64 * __restrict  __statbuf ,
                                                                                                 int __flag ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) lstat)(char const   * __restrict  __path ,
                                                                                             struct stat * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) lstat64)(char const   * __restrict  __path ,
                                                                                               struct stat64 * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mknod)(char const   *__path ,
                                                                                           __mode_t __mode ,
                                                                                           __dev_t __dev ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) mknodat)(int __fd ,
                                                                                             char const   *__path ,
                                                                                             __mode_t __mode ,
                                                                                             __dev_t __dev ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat)(int __ver ,
                                                                                     int __fildes ,
                                                                                     struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat)(int __ver ,
                                                                                      char const   *__filename ,
                                                                                      struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat)(int __ver ,
                                                                                       char const   *__filename ,
                                                                                       struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4))) __fxstatat)(int __ver ,
                                                                                         int __fildes ,
                                                                                         char const   *__filename ,
                                                                                         struct stat *__stat_buf ,
                                                                                         int __flag ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat64)(int __ver ,
                                                                                       int __fildes ,
                                                                                       struct stat64 *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat64)(int __ver ,
                                                                                        char const   *__filename ,
                                                                                        struct stat64 *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat64)(int __ver ,
                                                                                         char const   *__filename ,
                                                                                         struct stat64 *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4))) __fxstatat64)(int __ver ,
                                                                                           int __fildes ,
                                                                                           char const   *__filename ,
                                                                                           struct stat64 *__stat_buf ,
                                                                                           int __flag ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4))) __xmknod)(int __ver ,
                                                                                       char const   *__path ,
                                                                                       __mode_t __mode ,
                                                                                       __dev_t *__dev ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,5))) __xmknodat)(int __ver ,
                                                                                         int __fd ,
                                                                                         char const   *__path ,
                                                                                         __mode_t __mode ,
                                                                                         __dev_t *__dev ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __path ,
                                                                                            struct stat * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2))) stat)(char const   * __restrict  __path ,
                                                              struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __xstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) lstat)(char const   * __restrict  __path ,
                                                                                             struct stat * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2))) lstat)(char const   * __restrict  __path ,
                                                               struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __lxstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat)(int __fd ,
                                                                                           struct stat *__statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(2))) fstat)(int __fd , struct stat *__statbuf ) 
{ 
  int tmp ;

  {
  tmp = __fxstat(1, __fd, __statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) fstatat)(int __fd ,
                                                                                               char const   * __restrict  __filename ,
                                                                                               struct stat * __restrict  __statbuf ,
                                                                                               int __flag ) ;
__inline extern int ( __attribute__((__nonnull__(2,3))) fstatat)(int __fd , char const   * __restrict  __filename ,
                                                                 struct stat * __restrict  __statbuf ,
                                                                 int __flag ) 
{ 
  int tmp ;

  {
  tmp = __fxstatat(1, __fd, (char const   *)__filename, (struct stat *)__statbuf,
                   __flag);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mknod)(char const   *__path ,
                                                                                           __mode_t __mode ,
                                                                                           __dev_t __dev ) ;
__inline extern int ( __attribute__((__nonnull__(1))) mknod)(char const   *__path ,
                                                             __mode_t __mode , __dev_t __dev ) 
{ 
  int tmp ;

  {
  tmp = __xmknod(0, __path, __mode, & __dev);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) mknodat)(int __fd ,
                                                                                             char const   *__path ,
                                                                                             __mode_t __mode ,
                                                                                             __dev_t __dev ) ;
__inline extern int ( __attribute__((__nonnull__(2))) mknodat)(int __fd , char const   *__path ,
                                                               __mode_t __mode , __dev_t __dev ) 
{ 
  int tmp ;

  {
  tmp = __xmknodat(0, __fd, __path, __mode, & __dev);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) stat64)(char const   * __restrict  __path ,
                                                                                              struct stat64 * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2))) stat64)(char const   * __restrict  __path ,
                                                                struct stat64 * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __xstat64(1, (char const   *)__path, (struct stat64 *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) lstat64)(char const   * __restrict  __path ,
                                                                                               struct stat64 * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2))) lstat64)(char const   * __restrict  __path ,
                                                                 struct stat64 * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __lxstat64(1, (char const   *)__path, (struct stat64 *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) fstat64)(int __fd ,
                                                                                             struct stat64 *__statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(2))) fstat64)(int __fd , struct stat64 *__statbuf ) 
{ 
  int tmp ;

  {
  tmp = __fxstat64(1, __fd, __statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) fstatat64)(int __fd ,
                                                                                                 char const   * __restrict  __filename ,
                                                                                                 struct stat64 * __restrict  __statbuf ,
                                                                                                 int __flag ) ;
__inline extern int ( __attribute__((__nonnull__(2,3))) fstatat64)(int __fd , char const   * __restrict  __filename ,
                                                                   struct stat64 * __restrict  __statbuf ,
                                                                   int __flag ) 
{ 
  int tmp ;

  {
  tmp = __fxstatat64(1, __fd, (char const   *)__filename, (struct stat64 *)__statbuf,
                     __flag);
  return (tmp);
}
}
ignores *root_ignores  ;
char const   *evil_hardcoded_ignore_files[3] ;
char const   *ignore_pattern_files[5] ;
ignores *init_ignore(ignores *parent , char const   *dirname , size_t const   dirname_len ) ;
void cleanup_ignore(ignores *ig ) ;
void add_ignore_pattern(ignores *ig , char const   *pattern ) ;
void load_ignore_patterns(ignores *ig , char const   *path ) ;
int filename_filter(char const   *path , struct dirent  const  *dir , void *baton ) ;
int is_empty(ignores *ig ) ;
__inline extern  __attribute__((__nothrow__)) int pthread_equal(pthread_t __thread1 ,
                                                                pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int pthread_equal(pthread_t __thread1 ,
                                                                pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern int pthread_equal(pthread_t __thread1 , pthread_t __thread2 ) 
{ 


  {
  return (__thread1 == __thread2);
}
}
void log_debug(char const   *fmt  , ...) ;
extern int pcre_exec(pcre const   * , pcre_extra const   * , char const   * , int  ,
                     int  , int  , int * , int  ) ;
cli_options opts ;
void *ag_malloc(size_t size ) ;
void *ag_realloc(void *ptr , size_t size ) ;
char *ag_strndup(char const   *s , size_t size ) ;
void free_strings(char **strs , size_t const   strs_len ) ;
int is_fnmatch(char const   *filename ) ;
int binary_search(char const   *needle , char **haystack , int start , int end ) ;
int is_directory(char const   *path , struct dirent  const  *d ) ;
int is_symlink(char const   *path , struct dirent  const  *d ) ;
int is_named_pipe(char const   *path , struct dirent  const  *d ) ;
void ag_asprintf(char **ret , char const   *fmt  , ...) ;
extern int fnmatch(char const   *__pattern , char const   *__name , int __flags ) ;
int const   fnmatch_flags  =    (int const   )1;
char const   *evil_hardcoded_ignore_files[3]  = {      ".",      "..",      (char const   *)((void *)0)};
char const   *ignore_pattern_files[5]  = {      ".ignore",      ".gitignore",      ".git/info/exclude",      ".hgignore", 
        (char const   *)((void *)0)};
int is_empty(ignores *ig ) 
{ 


  {
  return ((((ig->extensions_len + ig->names_len) + ig->slash_names_len) + ig->regexes_len) + ig->slash_regexes_len == 0UL);
}
}
ignores *init_ignore(ignores *parent , char const   *dirname , size_t const   dirname_len ) 
{ 
  ignores *ig ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  tmp = ag_malloc(sizeof(ignores ));
  ig = (ignores *)tmp;
  ig->extensions = (char **)((void *)0);
  ig->extensions_len = (size_t )0;
  ig->names = (char **)((void *)0);
  ig->names_len = (size_t )0;
  ig->slash_names = (char **)((void *)0);
  ig->slash_names_len = (size_t )0;
  ig->regexes = (char **)((void *)0);
  ig->regexes_len = (size_t )0;
  ig->invert_regexes = (char **)((void *)0);
  ig->invert_regexes_len = (size_t )0;
  ig->slash_regexes = (char **)((void *)0);
  ig->slash_regexes_len = (size_t )0;
  ig->dirname = dirname;
  ig->dirname_len = (size_t )dirname_len;
  if (parent) {
    tmp___0 = is_empty(parent);
    if (tmp___0) {
      if (parent->parent) {
        ig->parent = parent->parent;
      } else {
        ig->parent = parent;
      }
    } else {
      ig->parent = parent;
    }
  } else {
    ig->parent = parent;
  }
  if (parent) {
    if (parent->abs_path_len > 0UL) {
      ag_asprintf(& ig->abs_path, "%s/%s", parent->abs_path, dirname);
      ig->abs_path_len = (parent->abs_path_len + 1UL) + (size_t )dirname_len;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (dirname_len == 1UL) {
    if ((int const   )*(dirname + 0) == 46) {
      tmp___1 = ag_malloc(sizeof(char ));
      ig->abs_path = (char *)tmp___1;
      *(ig->abs_path + 0) = (char )'\000';
      ig->abs_path_len = (size_t )0;
    } else {
      ag_asprintf(& ig->abs_path, "%s", dirname);
      ig->abs_path_len = (size_t )dirname_len;
    }
  } else {
    ag_asprintf(& ig->abs_path, "%s", dirname);
    ig->abs_path_len = (size_t )dirname_len;
  }
  return (ig);
}
}
void cleanup_ignore(ignores *ig ) 
{ 


  {
  if ((unsigned long )ig == (unsigned long )((void *)0)) {
    return;
  }
  free_strings(ig->extensions, (size_t const   )ig->extensions_len);
  free_strings(ig->names, (size_t const   )ig->names_len);
  free_strings(ig->slash_names, (size_t const   )ig->slash_names_len);
  free_strings(ig->regexes, (size_t const   )ig->regexes_len);
  free_strings(ig->invert_regexes, (size_t const   )ig->invert_regexes_len);
  free_strings(ig->slash_regexes, (size_t const   )ig->slash_regexes_len);
  if (ig->abs_path) {
    free((void *)ig->abs_path);
  }
  free((void *)ig);
  return;
}
}
void add_ignore_pattern(ignores *ig , char const   *pattern ) 
{ 
  int i ;
  int pattern_len ;
  int tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  char ***patterns_p ;
  size_t *patterns_len ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char **patterns ;
  void *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;

  {
  tmp = strncmp(pattern, "./", (size_t )2);
  if (tmp == 0) {
    pattern ++;
  }
  tmp___0 = strlen(pattern);
  pattern_len = (int )tmp___0;
  while (pattern_len > 0) {
    tmp___1 = __ctype_b_loc();
    if (! ((int const   )*(*tmp___1 + (int )*(pattern + (pattern_len - 1))) & 8192)) {
      break;
    }
    pattern_len --;
  }
  if (pattern_len == 0) {
    log_debug("Pattern is empty. Not adding any ignores.");
    return;
  }
  tmp___4 = is_fnmatch(pattern);
  if (tmp___4) {
    if ((int const   )*(pattern + 0) == 42) {
      if ((int const   )*(pattern + 1) == 46) {
        tmp___2 = strchr(pattern + 2, '.');
        if (tmp___2) {
          tmp___3 = is_fnmatch(pattern + 2);
          if (tmp___3) {
            goto _L___1;
          } else {
            patterns_p = & ig->extensions;
            patterns_len = & ig->extensions_len;
            pattern += 2;
            pattern_len -= 2;
          }
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
    if ((int const   )*(pattern + 0) == 47) {
      patterns_p = & ig->slash_regexes;
      patterns_len = & ig->slash_regexes_len;
      pattern ++;
      pattern_len --;
    } else
    if ((int const   )*(pattern + 0) == 33) {
      patterns_p = & ig->invert_regexes;
      patterns_len = & ig->invert_regexes_len;
      pattern ++;
      pattern_len --;
    } else {
      patterns_p = & ig->regexes;
      patterns_len = & ig->regexes_len;
    }
  } else
  if ((int const   )*(pattern + 0) == 47) {
    patterns_p = & ig->slash_names;
    patterns_len = & ig->slash_names_len;
    pattern ++;
    pattern_len --;
  } else {
    patterns_p = & ig->names;
    patterns_len = & ig->names_len;
  }
  (*patterns_len) ++;
  tmp___5 = ag_realloc((void *)*patterns_p, *patterns_len * sizeof(char *));
  patterns = (char **)tmp___5;
  *patterns_p = patterns;
  i = (int )(*patterns_len - 1UL);
  while (i > 0) {
    tmp___6 = strcmp(pattern, (char const   *)*(patterns + (i - 1)));
    if (tmp___6 > 0) {
      break;
    }
    *(patterns + i) = *(patterns + (i - 1));
    i --;
  }
  *(patterns + i) = ag_strndup(pattern, (size_t )pattern_len);
  if ((unsigned long )ig == (unsigned long )root_ignores) {
    tmp___7 = "root ignores";
  } else {
    tmp___7 = (char const   *)ig->abs_path;
  }
  log_debug("added ignore pattern %s to %s", pattern, tmp___7);
  return;
}
}
void load_ignore_patterns(ignores *ig , char const   *path ) 
{ 
  FILE *fp ;
  char *line ;
  ssize_t line_len ;
  size_t line_cap ;

  {
  fp = (FILE *)((void *)0);
  fp = fopen((char const   * __restrict  )path, (char const   * __restrict  )"r");
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    log_debug("Skipping ignore file %s: not readable", path);
    return;
  }
  log_debug("Loading ignore file %s.", path);
  line = (char *)((void *)0);
  line_len = (ssize_t )0;
  line_cap = (size_t )0;
  while (1) {
    line_len = getline((char ** __restrict  )(& line), (size_t * __restrict  )(& line_cap),
                       (FILE * __restrict  )fp);
    if (! (line_len > 0L)) {
      break;
    }
    if (line_len == 0L) {
      continue;
    } else
    if ((int )*(line + 0) == 10) {
      continue;
    } else
    if ((int )*(line + 0) == 35) {
      continue;
    }
    if ((int )*(line + (line_len - 1L)) == 10) {
      *(line + (line_len - 1L)) = (char )'\000';
    }
    add_ignore_pattern(ig, (char const   *)line);
  }
  free((void *)line);
  fclose(fp);
  return;
}
}
static int ackmate_dir_match(char const   *dir_name ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  if ((unsigned long )opts.ackmate_dir_filter == (unsigned long )((void *)0)) {
    return (0);
  }
  tmp = strlen(dir_name);
  tmp___0 = pcre_exec((pcre const   *)opts.ackmate_dir_filter, (pcre_extra const   *)((void *)0),
                      dir_name, (int )tmp, 0, 0, (int *)((void *)0), 0);
  return (tmp___0);
}
}
static int path_ignore_search(ignores const   *ig , char const   *path , char const   *filename ) 
{ 
  char *temp ;
  int temp_start_pos ;
  size_t i ;
  int match_pos ;
  char const   *tmp ;
  char *slash_filename ;
  char *pos ;
  char *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int rv ;
  int tmp___6 ;

  {
  match_pos = binary_search(filename, (char **)ig->names, 0, (int )ig->names_len);
  if (match_pos >= 0) {
    log_debug("file %s ignored because name matches static pattern %s", filename,
              *(ig->names + match_pos));
    return (1);
  }
  if ((int const   )*(path + 0) == 46) {
    tmp = path + 1;
  } else {
    tmp = path;
  }
  ag_asprintf(& temp, "%s/%s", tmp, filename);
  if ((int )*(temp + 0) == 47) {
    temp_start_pos = 1;
  } else {
    temp_start_pos = 0;
  }
  tmp___3 = strncmp((char const   *)(temp + temp_start_pos), (char const   *)ig->abs_path,
                    (size_t )ig->abs_path_len);
  if (tmp___3 == 0) {
    slash_filename = (temp + temp_start_pos) + ig->abs_path_len;
    if ((int )*(slash_filename + 0) == 47) {
      slash_filename ++;
    }
    match_pos = binary_search((char const   *)slash_filename, (char **)ig->names,
                              0, (int )ig->names_len);
    if (match_pos >= 0) {
      log_debug("file %s ignored because name matches static pattern %s", temp, *(ig->names + match_pos));
      free((void *)temp);
      return (1);
    }
    match_pos = binary_search((char const   *)slash_filename, (char **)ig->slash_names,
                              0, (int )ig->slash_names_len);
    if (match_pos >= 0) {
      log_debug("file %s ignored because name matches slash static pattern %s", slash_filename,
                *(ig->slash_names + match_pos));
      free((void *)temp);
      return (1);
    }
    i = (size_t )0;
    while (i < (size_t )ig->names_len) {
      tmp___0 = strstr((char const   *)slash_filename, (char const   *)*(ig->names + i));
      pos = tmp___0;
      if ((unsigned long )pos == (unsigned long )slash_filename) {
        goto _L;
      } else
      if (pos) {
        if ((int )*(pos - 1) == 47) {
          _L: /* CIL Label */ 
          tmp___1 = strlen((char const   *)*(ig->names + i));
          pos += tmp___1;
          if ((int )*pos == 0) {
            log_debug("file %s ignored because path somewhere matches name %s", slash_filename,
                      *(ig->names + i));
            free((void *)temp);
            return (1);
          } else
          if ((int )*pos == 47) {
            log_debug("file %s ignored because path somewhere matches name %s", slash_filename,
                      *(ig->names + i));
            free((void *)temp);
            return (1);
          }
        }
      }
      log_debug("pattern %s doesn\'t match path %s", *(ig->names + i), slash_filename);
      i ++;
    }
    i = (size_t )0;
    while (i < (size_t )ig->slash_regexes_len) {
      tmp___2 = fnmatch((char const   *)*(ig->slash_regexes + i), (char const   *)slash_filename,
                        (int )fnmatch_flags);
      if (tmp___2 == 0) {
        log_debug("file %s ignored because name matches slash regex pattern %s", slash_filename,
                  *(ig->slash_regexes + i));
        free((void *)temp);
        return (1);
      }
      log_debug("pattern %s doesn\'t match slash file %s", *(ig->slash_regexes + i),
                slash_filename);
      i ++;
    }
  }
  i = (size_t )0;
  while (i < (size_t )ig->invert_regexes_len) {
    tmp___4 = fnmatch((char const   *)*(ig->invert_regexes + i), filename, (int )fnmatch_flags);
    if (tmp___4 == 0) {
      log_debug("file %s not ignored because name matches regex pattern !%s", filename,
                *(ig->invert_regexes + i));
      free((void *)temp);
      return (0);
    }
    log_debug("pattern !%s doesn\'t match file %s", *(ig->invert_regexes + i), filename);
    i ++;
  }
  i = (size_t )0;
  while (i < (size_t )ig->regexes_len) {
    tmp___5 = fnmatch((char const   *)*(ig->regexes + i), filename, (int )fnmatch_flags);
    if (tmp___5 == 0) {
      log_debug("file %s ignored because name matches regex pattern %s", filename,
                *(ig->regexes + i));
      free((void *)temp);
      return (1);
    }
    log_debug("pattern %s doesn\'t match file %s", *(ig->regexes + i), filename);
    i ++;
  }
  tmp___6 = ackmate_dir_match((char const   *)temp);
  rv = tmp___6;
  free((void *)temp);
  return (rv);
}
}
int filename_filter(char const   *path , struct dirent  const  *dir , void *baton ) 
{ 
  char const   *filename ;
  size_t i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  scandir_baton_t *scandir_baton ;
  char const   *path_start ;
  char const   *extension ;
  char *tmp___2 ;
  size_t filename_len ;
  int tmp___3 ;
  ignores const   *ig ;
  int match_pos ;
  int tmp___4 ;
  int tmp___5 ;
  char *temp ;
  int rv ;
  int tmp___6 ;
  int tmp___7 ;

  {
  filename = (char const   *)(dir->d_name);
  if (! opts.search_hidden_files) {
    if ((int const   )*(filename + 0) == 46) {
      return (0);
    }
  }
  i = (size_t )0;
  while ((unsigned long )evil_hardcoded_ignore_files[i] != (unsigned long )((void *)0)) {
    tmp = strcmp(filename, evil_hardcoded_ignore_files[i]);
    if (tmp == 0) {
      return (0);
    }
    i ++;
  }
  if (! opts.follow_symlinks) {
    tmp___0 = is_symlink(path, dir);
    if (tmp___0) {
      log_debug("File %s ignored becaused it\'s a symlink", dir->d_name);
      return (0);
    }
  }
  tmp___1 = is_named_pipe(path, dir);
  if (tmp___1) {
    log_debug("%s ignored because it\'s a named pipe or socket", path);
    return (0);
  }
  if (opts.search_all_files) {
    if (! opts.path_to_ignore) {
      return (1);
    }
  }
  scandir_baton = (scandir_baton_t *)baton;
  path_start = scandir_baton->path_start;
  tmp___2 = strchr(filename, '.');
  extension = (char const   *)tmp___2;
  if (extension) {
    if (*(extension + 1)) {
      extension ++;
    } else {
      extension = (char const   *)((void *)0);
    }
  }
  filename_len = (size_t )0;
  tmp___3 = strncmp(filename, "./", (size_t )2);
  if (tmp___3 == 0) {
    filename_len = strlen(filename);
    filename ++;
    filename_len --;
  }
  ig = scandir_baton->ig;
  while ((unsigned long )ig != (unsigned long )((void *)0)) {
    if (extension) {
      tmp___4 = binary_search(extension, (char **)ig->extensions, 0, (int )ig->extensions_len);
      match_pos = tmp___4;
      if (match_pos >= 0) {
        log_debug("file %s ignored because name matches extension %s", filename, *(ig->extensions + match_pos));
        return (0);
      }
    }
    tmp___5 = path_ignore_search(ig, path_start, filename);
    if (tmp___5) {
      return (0);
    }
    tmp___7 = is_directory(path, dir);
    if (tmp___7) {
      if (! filename_len) {
        filename_len = strlen(filename);
      }
      if ((int const   )*(filename + (filename_len - 1UL)) != 47) {
        ag_asprintf(& temp, "%s/", filename);
        tmp___6 = path_ignore_search(ig, path_start, (char const   *)temp);
        rv = tmp___6;
        free((void *)temp);
        if (rv) {
          return (0);
        }
      }
    }
    ig = (ignores const   *)ig->parent;
  }
  log_debug("%s not ignored", filename);
  return (1);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#pragma merger("0","/tmp/cil-CVA2jAtB.i","-g,-O2,-pthread,-Wall,-Wextra,-Wformat=2,-Wno-format-nonliteral,-Wshadow,-Wpointer-arith,-Wcast-qual,-Wmissing-prototypes,-Wno-missing-braces,-std=gnu89")
extern FILE *stderr ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
pthread_mutex_t print_mtx ;
void set_log_level(enum log_level threshold ) ;
void log_msg(char const   *fmt  , ...) ;
void log_warn(char const   *fmt  , ...) ;
void log_err(char const   *fmt  , ...) ;
void vplog(unsigned int const   level , char const   *fmt , va_list___0 args ) ;
void plog(unsigned int const   level , char const   *fmt  , ...) ;
FILE *out_fd ;
pthread_mutex_t print_mtx  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
static enum log_level log_threshold  =    (enum log_level )40;
void set_log_level(enum log_level threshold ) 
{ 


  {
  log_threshold = threshold;
  return;
}
}
void log_debug(char const   *fmt  , ...) 
{ 
  va_list___0 args ;

  {
  __builtin_va_start(args, fmt);
  vplog((unsigned int const   )10, fmt, args);
  __builtin_va_end(args);
  return;
}
}
void log_msg(char const   *fmt  , ...) 
{ 
  va_list___0 args ;

  {
  __builtin_va_start(args, fmt);
  vplog((unsigned int const   )20, fmt, args);
  __builtin_va_end(args);
  return;
}
}
void log_warn(char const   *fmt  , ...) 
{ 
  va_list___0 args ;

  {
  __builtin_va_start(args, fmt);
  vplog((unsigned int const   )30, fmt, args);
  __builtin_va_end(args);
  return;
}
}
void log_err(char const   *fmt  , ...) 
{ 
  va_list___0 args ;

  {
  __builtin_va_start(args, fmt);
  vplog((unsigned int const   )40, fmt, args);
  __builtin_va_end(args);
  return;
}
}
void vplog(unsigned int const   level , char const   *fmt , va_list___0 args ) 
{ 
  FILE *stream ;

  {
  if (level < (unsigned int const   )log_threshold) {
    return;
  }
  pthread_mutex_lock(& print_mtx);
  stream = out_fd;
  switch (level) {
  case 10U: 
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"DEBUG: ");
  break;
  case 20U: 
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"MSG: ");
  break;
  case 30U: 
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"WARN: ");
  break;
  case 40U: 
  stream = stderr;
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"ERR: ");
  break;
  }
  vfprintf((FILE * __restrict  )stream, (char const   * __restrict  )fmt, args);
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"\n");
  pthread_mutex_unlock(& print_mtx);
  return;
}
}
void plog(unsigned int const   level , char const   *fmt  , ...) 
{ 
  va_list___0 args ;

  {
  __builtin_va_start(args, fmt);
  vplog(level, fmt, args);
  __builtin_va_end(args);
  return;
}
}
#pragma merger("0","/tmp/cil-u3AcdJ1R.i","-g,-O2,-pthread,-Wall,-Wextra,-Wformat=2,-Wno-format-nonliteral,-Wshadow,-Wpointer-arith,-Wcast-qual,-Wmissing-prototypes,-Wno-missing-braces,-std=gnu89")
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
extern void perror(char const   *__s ) ;
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
extern FILE *popen(char const   *__command , char const   *__modes ) ;
extern int pclose(FILE *__stream ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
extern  __attribute__((__nothrow__)) char *realpath(char const   * __restrict  __name ,
                                                    char * __restrict  __resolved ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
extern char *optarg ;
extern int optind ;
lang_spec_t langs[138] ;
size_t get_lang_count(void) ;
char *make_lang_regex(char *ext_array , size_t num_exts ) ;
size_t combine_file_extensions(size_t *extension_index , size_t len , char **exts ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) getopt_long)(int ___argc ,
                                                                                          char * const  *___argv ,
                                                                                          char const   *__shortopts ,
                                                                                          struct option  const  *__longopts ,
                                                                                          int *__longind ) ;
extern void (*pcre_free)(void * ) ;
cli_options opts  ;
void usage(void) ;
void print_version(void) ;
void init_options(void) ;
void parse_options(int argc , char **argv , char ***base_paths , char ***paths ) ;
void cleanup_options(void) ;
void *ag_calloc(size_t count , size_t size ) ;
char *ag_strdup(char const   *s ) ;
void compile_study(pcre **re , pcre_extra **re_extra , char *q , int const   pcre_opts ,
                   int const   study_opts ) ;
int is_regex(char const   *query ) ;
int is_lowercase(char const   *s ) ;
void die(char const   *fmt  , ...) ;
char const   *color_line_number  =    "\033[1;33m";
char const   *color_match  =    "\033[30;43m";
char const   *color_path  =    "\033[1;32m";
void usage(void) 
{ 


  {
  printf((char const   * __restrict  )"\n");
  printf((char const   * __restrict  )"Usage: ag [FILE-TYPE] [OPTIONS] PATTERN [PATH]\n\n");
  printf((char const   * __restrict  )"  Recursively search for PATTERN in PATH.\n");
  printf((char const   * __restrict  )"  Like grep or ack, but faster.\n\n");
  printf((char const   * __restrict  )"Example:\n  ag -i foo /bar/\n\n");
  printf((char const   * __restrict  )"Output Options:\n     --ackmate            Print results in AckMate-parseable format\n  -A --after [LINES]      Print lines after match (Default: 2)\n  -B --before [LINES]     Print lines before match (Default: 2)\n     --[no]break          Print newlines between matches in different files\n                          (Enabled by default)\n  -c --count              Only print the number of matches in each file.\n                          (This often differs from the number of matching lines)\n     --[no]color          Print color codes in results (Enabled by default)\n     --color-line-number  Color codes for line numbers (Default: 1;33)\n     --color-match        Color codes for result match numbers (Default: 30;43)\n     --color-path         Color codes for path names (Default: 1;32)\n");
  printf((char const   * __restrict  )"     --column             Print column numbers in results\n     --[no]filename       Print file names (Enabled unless searching a single file)\n  -H --[no]heading        Print file names before each file\'s matches\n                          (Enabled by default)\n  -C --context [LINES]    Print lines before and after matches (Default: 2)\n     --[no]group          Same as --[no]break --[no]heading\n  -g --filename-pattern PATTERN\n                          Print filenames matching PATTERN\n  -l --files-with-matches Only print filenames that contain matches\n                          (don\'t print the matching lines)\n  -L --files-without-matches\n                          Only print filenames that don\'t contain matches\n     --print-all-files    Print headings for all files searched, even those that\n                          don\'t contain matches\n     --[no]numbers        Print line numbers. Default is to omit line numbers\n                          when searching streams\n  -o --only-matching      Prints only the matching part of the lines\n     --print-long-lines   Print matches on very long lines (Default: >2k characters)\n     --passthrough        When searching a stream, print all lines even if they\n                          don\'t match\n     --silent             Suppress all log messages, including errors\n     --stats              Print stats (files scanned, time taken, etc.)\n     --stats-only         Print stats and nothing else.\n                          (Same as --count when searching a single file)\n     --vimgrep            Print results like vim\'s :vimgrep /pattern/g would\n                          (it reports every match on the line)\n  -0 --null --print0      Separate filenames with null (for \'xargs -0\')\n\nSearch Options:\n  -a --all-types          Search all files (doesn\'t include hidden files\n                          or patterns from ignore files)\n  -D --debug              Ridiculous debugging (probably not useful)\n     --depth NUM          Search up to NUM directories deep (Default: 25)\n  -f --follow             Follow symlinks\n  -F --fixed-strings      Alias for --literal for compatibility with grep\n  -G --file-search-regex  PATTERN Limit search to filenames matching PATTERN\n     --hidden             Search hidden files (obeys .*ignore files)\n  -i --ignore-case        Match case insensitively\n     --ignore PATTERN     Ignore files/directories matching PATTERN\n                          (literal file/directory names also allowed)\n     --ignore-dir NAME    Alias for --ignore for compatibility with ack.\n  -m --max-count NUM      Skip the rest of a file after NUM matches (Default: 10,000)\n     --one-device         Don\'t follow links to other devices.\n  -p --path-to-ignore STRING\n                          Use .ignore file at STRING\n  -Q --literal            Don\'t parse PATTERN as a regular expression\n  -s --case-sensitive     Match case sensitively\n  -S --smart-case         Match case insensitively unless PATTERN contains\n                          uppercase characters (Enabled by default)\n     --search-binary      Search binary files for matches\n  -t --all-text           Search all text files (doesn\'t include hidden files)\n  -u --unrestricted       Search all files (ignore .ignore, .gitignore, etc.;\n                          searches binary and hidden files as well)\n  -U --skip-vcs-ignores   Ignore VCS ignore files\n                          (.gitignore, .hgignore; still obey .ignore)\n  -v --invert-match\n  -w --word-regexp        Only match whole words\n  -W --width NUM          Truncate match lines after NUM characters\n  -z --search-zip         Search contents of compressed (e.g., gzip) files\n\n");
  printf((char const   * __restrict  )"File Types:\nThe search can be restricted to certain types of files. Example:\n  ag --html needle\n  - Searches for \'needle\' in files with suffix .htm, .html, .shtml or .xhtml.\n\nFor a list of supported file types run:\n  ag --list-file-types\n\nag was originally created by Geoff Greer. More information (and the latest release)\ncan be found at http://geoff.greer.fm/ag\n");
  return;
}
}
void print_version(void) 
{ 
  char jit ;
  char lzma ;
  char zlib ;

  {
  jit = (char )'-';
  lzma = (char )'-';
  zlib = (char )'-';
  jit = (char )'+';
  lzma = (char )'+';
  zlib = (char )'+';
  printf((char const   * __restrict  )"ag version %s\n\n", "2.2.0");
  printf((char const   * __restrict  )"Features:\n");
  printf((char const   * __restrict  )"  %cjit %clzma %czlib\n", (int )jit, (int )lzma,
         (int )zlib);
  return;
}
}
void init_options(void) 
{ 
  char *term ;
  char *tmp ;
  int tmp___0 ;

  {
  tmp = getenv("TERM");
  term = tmp;
  memset((void *)(& opts), 0, sizeof(opts));
  opts.casing = (enum case_behavior )0;
  opts.color = 1;
  if (term) {
    tmp___0 = strcmp((char const   *)term, "dumb");
    if (! tmp___0) {
      opts.color = 0;
    }
  }
  opts.color_win_ansi = 0;
  opts.max_matches_per_file = (size_t )0;
  opts.max_search_depth = 25;
  opts.mmap = 1;
  opts.multiline = 1;
  opts.width = (size_t )0;
  opts.path_sep = (char )'\n';
  opts.print_break = 1;
  opts.print_path = 0;
  opts.print_all_paths = 0;
  opts.print_line_numbers = 1;
  opts.recurse_dirs = 1;
  opts.color_path = ag_strdup(color_path);
  opts.color_match = ag_strdup(color_match);
  opts.color_line_number = ag_strdup(color_line_number);
  opts.use_thread_affinity = 1;
  return;
}
}
void cleanup_options(void) 
{ 


  {
  free((void *)opts.color_path);
  free((void *)opts.color_match);
  free((void *)opts.color_line_number);
  if (opts.query) {
    free((void *)opts.query);
  }
  (*pcre_free)((void *)opts.re);
  if (opts.re_extra) {
    (*pcre_free)((void *)opts.re_extra);
  }
  if (opts.ackmate_dir_filter) {
    (*pcre_free)((void *)opts.ackmate_dir_filter);
  }
  if (opts.ackmate_dir_filter_extra) {
    (*pcre_free)((void *)opts.ackmate_dir_filter_extra);
  }
  if (opts.file_search_regex) {
    (*pcre_free)((void *)opts.file_search_regex);
  }
  if (opts.file_search_regex_extra) {
    (*pcre_free)((void *)opts.file_search_regex_extra);
  }
  return;
}
}
void parse_options(int argc , char **argv , char ***base_paths , char ***paths ) 
{ 
  int ch ;
  size_t i ;
  int path_len ;
  int base_path_len ;
  int useless ;
  int group ;
  int help ;
  int version ;
  int list_file_types ;
  int opt_index ;
  char *num_end ;
  char const   *home_dir ;
  char *tmp ;
  char *ignore_file_path ;
  int accepts_query ;
  int needs_query ;
  struct stat statbuf ;
  int rv ;
  size_t lang_count ;
  size_t lang_num ;
  int has_filetype ;
  size_t longopts_len ;
  size_t full_len ;
  option_t *longopts ;
  char *lang_regex ;
  size_t *ext_index ;
  char *extensions ;
  size_t num_exts ;
  option_t base_longopts[92] ;
  void *tmp___0 ;
  void *tmp___1 ;
  option_t opt ;
  option_t __constr_expr_0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *file_search_regex ;
  long tmp___6 ;
  int *tmp___7 ;
  long tmp___8 ;
  int *tmp___9 ;
  long tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  long tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  size_t tmp___32 ;
  int tmp___33 ;
  int pcre_opts ;
  int tmp___34 ;
  char *old_file_search_regex ;
  size_t lang_index ;
  int j ;
  FILE *gitconfig_file ;
  size_t buf_len ;
  char *gitconfig_res ;
  void *tmp___35 ;
  size_t tmp___36 ;
  int tmp___37 ;
  char const   *config_home ;
  char *tmp___38 ;
  size_t tmp___39 ;
  size_t tmp___40 ;
  int tmp___41 ;
  char *path ;
  char *base_path ;
  char *tmp___42 ;
  void *tmp___43 ;
  void *tmp___44 ;
  size_t tmp___45 ;
  void *tmp___46 ;
  size_t tmp___47 ;
  void *tmp___48 ;
  void *tmp___49 ;
  void *tmp___50 ;
  void *tmp___51 ;

  {
  path_len = 0;
  base_path_len = 0;
  useless = 0;
  group = 1;
  help = 0;
  version = 0;
  list_file_types = 0;
  opt_index = 0;
  tmp = getenv("HOME");
  home_dir = (char const   *)tmp;
  ignore_file_path = (char *)((void *)0);
  accepts_query = 1;
  needs_query = 1;
  lang_num = (size_t )0;
  has_filetype = 0;
  lang_regex = (char *)((void *)0);
  ext_index = (size_t *)((void *)0);
  extensions = (char *)((void *)0);
  num_exts = (size_t )0;
  init_options();
  base_longopts[0].name = "ackmate";
  base_longopts[0].has_arg = 0;
  base_longopts[0].flag = & opts.ackmate;
  base_longopts[0].val = 1;
  base_longopts[1].name = "ackmate-dir-filter";
  base_longopts[1].has_arg = 1;
  base_longopts[1].flag = (int *)((void *)0);
  base_longopts[1].val = 0;
  base_longopts[2].name = "affinity";
  base_longopts[2].has_arg = 0;
  base_longopts[2].flag = & opts.use_thread_affinity;
  base_longopts[2].val = 1;
  base_longopts[3].name = "after";
  base_longopts[3].has_arg = 2;
  base_longopts[3].flag = (int *)((void *)0);
  base_longopts[3].val = 'A';
  base_longopts[4].name = "all-text";
  base_longopts[4].has_arg = 0;
  base_longopts[4].flag = (int *)((void *)0);
  base_longopts[4].val = 't';
  base_longopts[5].name = "all-types";
  base_longopts[5].has_arg = 0;
  base_longopts[5].flag = (int *)((void *)0);
  base_longopts[5].val = 'a';
  base_longopts[6].name = "before";
  base_longopts[6].has_arg = 2;
  base_longopts[6].flag = (int *)((void *)0);
  base_longopts[6].val = 'B';
  base_longopts[7].name = "break";
  base_longopts[7].has_arg = 0;
  base_longopts[7].flag = & opts.print_break;
  base_longopts[7].val = 1;
  base_longopts[8].name = "case-sensitive";
  base_longopts[8].has_arg = 0;
  base_longopts[8].flag = (int *)((void *)0);
  base_longopts[8].val = 's';
  base_longopts[9].name = "color";
  base_longopts[9].has_arg = 0;
  base_longopts[9].flag = & opts.color;
  base_longopts[9].val = 1;
  base_longopts[10].name = "color-line-number";
  base_longopts[10].has_arg = 1;
  base_longopts[10].flag = (int *)((void *)0);
  base_longopts[10].val = 0;
  base_longopts[11].name = "color-match";
  base_longopts[11].has_arg = 1;
  base_longopts[11].flag = (int *)((void *)0);
  base_longopts[11].val = 0;
  base_longopts[12].name = "color-path";
  base_longopts[12].has_arg = 1;
  base_longopts[12].flag = (int *)((void *)0);
  base_longopts[12].val = 0;
  base_longopts[13].name = "color-win-ansi";
  base_longopts[13].has_arg = 0;
  base_longopts[13].flag = & opts.color_win_ansi;
  base_longopts[13].val = 1;
  base_longopts[14].name = "column";
  base_longopts[14].has_arg = 0;
  base_longopts[14].flag = & opts.column;
  base_longopts[14].val = 1;
  base_longopts[15].name = "context";
  base_longopts[15].has_arg = 2;
  base_longopts[15].flag = (int *)((void *)0);
  base_longopts[15].val = 'C';
  base_longopts[16].name = "count";
  base_longopts[16].has_arg = 0;
  base_longopts[16].flag = (int *)((void *)0);
  base_longopts[16].val = 'c';
  base_longopts[17].name = "debug";
  base_longopts[17].has_arg = 0;
  base_longopts[17].flag = (int *)((void *)0);
  base_longopts[17].val = 'D';
  base_longopts[18].name = "depth";
  base_longopts[18].has_arg = 1;
  base_longopts[18].flag = (int *)((void *)0);
  base_longopts[18].val = 0;
  base_longopts[19].name = "filename";
  base_longopts[19].has_arg = 0;
  base_longopts[19].flag = (int *)((void *)0);
  base_longopts[19].val = 0;
  base_longopts[20].name = "filename-pattern";
  base_longopts[20].has_arg = 1;
  base_longopts[20].flag = (int *)((void *)0);
  base_longopts[20].val = 'g';
  base_longopts[21].name = "file-search-regex";
  base_longopts[21].has_arg = 1;
  base_longopts[21].flag = (int *)((void *)0);
  base_longopts[21].val = 'G';
  base_longopts[22].name = "files-with-matches";
  base_longopts[22].has_arg = 0;
  base_longopts[22].flag = (int *)((void *)0);
  base_longopts[22].val = 'l';
  base_longopts[23].name = "files-without-matches";
  base_longopts[23].has_arg = 0;
  base_longopts[23].flag = (int *)((void *)0);
  base_longopts[23].val = 'L';
  base_longopts[24].name = "fixed-strings";
  base_longopts[24].has_arg = 0;
  base_longopts[24].flag = (int *)((void *)0);
  base_longopts[24].val = 'F';
  base_longopts[25].name = "follow";
  base_longopts[25].has_arg = 0;
  base_longopts[25].flag = & opts.follow_symlinks;
  base_longopts[25].val = 1;
  base_longopts[26].name = "group";
  base_longopts[26].has_arg = 0;
  base_longopts[26].flag = & group;
  base_longopts[26].val = 1;
  base_longopts[27].name = "heading";
  base_longopts[27].has_arg = 0;
  base_longopts[27].flag = & opts.print_path;
  base_longopts[27].val = 2;
  base_longopts[28].name = "help";
  base_longopts[28].has_arg = 0;
  base_longopts[28].flag = (int *)((void *)0);
  base_longopts[28].val = 'h';
  base_longopts[29].name = "hidden";
  base_longopts[29].has_arg = 0;
  base_longopts[29].flag = & opts.search_hidden_files;
  base_longopts[29].val = 1;
  base_longopts[30].name = "ignore";
  base_longopts[30].has_arg = 1;
  base_longopts[30].flag = (int *)((void *)0);
  base_longopts[30].val = 0;
  base_longopts[31].name = "ignore-case";
  base_longopts[31].has_arg = 0;
  base_longopts[31].flag = (int *)((void *)0);
  base_longopts[31].val = 'i';
  base_longopts[32].name = "ignore-dir";
  base_longopts[32].has_arg = 1;
  base_longopts[32].flag = (int *)((void *)0);
  base_longopts[32].val = 0;
  base_longopts[33].name = "invert-match";
  base_longopts[33].has_arg = 0;
  base_longopts[33].flag = (int *)((void *)0);
  base_longopts[33].val = 'v';
  base_longopts[34].name = "line-numbers";
  base_longopts[34].has_arg = 0;
  base_longopts[34].flag = & opts.print_line_numbers;
  base_longopts[34].val = 2;
  base_longopts[35].name = "list-file-types";
  base_longopts[35].has_arg = 0;
  base_longopts[35].flag = & list_file_types;
  base_longopts[35].val = 1;
  base_longopts[36].name = "literal";
  base_longopts[36].has_arg = 0;
  base_longopts[36].flag = (int *)((void *)0);
  base_longopts[36].val = 'Q';
  base_longopts[37].name = "match";
  base_longopts[37].has_arg = 0;
  base_longopts[37].flag = & useless;
  base_longopts[37].val = 0;
  base_longopts[38].name = "max-count";
  base_longopts[38].has_arg = 1;
  base_longopts[38].flag = (int *)((void *)0);
  base_longopts[38].val = 'm';
  base_longopts[39].name = "mmap";
  base_longopts[39].has_arg = 0;
  base_longopts[39].flag = & opts.mmap;
  base_longopts[39].val = 1;
  base_longopts[40].name = "multiline";
  base_longopts[40].has_arg = 0;
  base_longopts[40].flag = & opts.multiline;
  base_longopts[40].val = 1;
  base_longopts[41].name = "no-affinity";
  base_longopts[41].has_arg = 0;
  base_longopts[41].flag = & opts.use_thread_affinity;
  base_longopts[41].val = 0;
  base_longopts[42].name = "noaffinity";
  base_longopts[42].has_arg = 0;
  base_longopts[42].flag = & opts.use_thread_affinity;
  base_longopts[42].val = 0;
  base_longopts[43].name = "no-break";
  base_longopts[43].has_arg = 0;
  base_longopts[43].flag = & opts.print_break;
  base_longopts[43].val = 0;
  base_longopts[44].name = "nobreak";
  base_longopts[44].has_arg = 0;
  base_longopts[44].flag = & opts.print_break;
  base_longopts[44].val = 0;
  base_longopts[45].name = "no-color";
  base_longopts[45].has_arg = 0;
  base_longopts[45].flag = & opts.color;
  base_longopts[45].val = 0;
  base_longopts[46].name = "nocolor";
  base_longopts[46].has_arg = 0;
  base_longopts[46].flag = & opts.color;
  base_longopts[46].val = 0;
  base_longopts[47].name = "no-filename";
  base_longopts[47].has_arg = 0;
  base_longopts[47].flag = (int *)((void *)0);
  base_longopts[47].val = 0;
  base_longopts[48].name = "nofilename";
  base_longopts[48].has_arg = 0;
  base_longopts[48].flag = (int *)((void *)0);
  base_longopts[48].val = 0;
  base_longopts[49].name = "no-follow";
  base_longopts[49].has_arg = 0;
  base_longopts[49].flag = & opts.follow_symlinks;
  base_longopts[49].val = 0;
  base_longopts[50].name = "nofollow";
  base_longopts[50].has_arg = 0;
  base_longopts[50].flag = & opts.follow_symlinks;
  base_longopts[50].val = 0;
  base_longopts[51].name = "no-group";
  base_longopts[51].has_arg = 0;
  base_longopts[51].flag = & group;
  base_longopts[51].val = 0;
  base_longopts[52].name = "nogroup";
  base_longopts[52].has_arg = 0;
  base_longopts[52].flag = & group;
  base_longopts[52].val = 0;
  base_longopts[53].name = "no-heading";
  base_longopts[53].has_arg = 0;
  base_longopts[53].flag = & opts.print_path;
  base_longopts[53].val = 3;
  base_longopts[54].name = "noheading";
  base_longopts[54].has_arg = 0;
  base_longopts[54].flag = & opts.print_path;
  base_longopts[54].val = 3;
  base_longopts[55].name = "no-mmap";
  base_longopts[55].has_arg = 0;
  base_longopts[55].flag = & opts.mmap;
  base_longopts[55].val = 0;
  base_longopts[56].name = "nommap";
  base_longopts[56].has_arg = 0;
  base_longopts[56].flag = & opts.mmap;
  base_longopts[56].val = 0;
  base_longopts[57].name = "no-multiline";
  base_longopts[57].has_arg = 0;
  base_longopts[57].flag = & opts.multiline;
  base_longopts[57].val = 0;
  base_longopts[58].name = "nomultiline";
  base_longopts[58].has_arg = 0;
  base_longopts[58].flag = & opts.multiline;
  base_longopts[58].val = 0;
  base_longopts[59].name = "no-numbers";
  base_longopts[59].has_arg = 0;
  base_longopts[59].flag = & opts.print_line_numbers;
  base_longopts[59].val = 0;
  base_longopts[60].name = "nonumbers";
  base_longopts[60].has_arg = 0;
  base_longopts[60].flag = & opts.print_line_numbers;
  base_longopts[60].val = 0;
  base_longopts[61].name = "no-pager";
  base_longopts[61].has_arg = 0;
  base_longopts[61].flag = (int *)((void *)0);
  base_longopts[61].val = 0;
  base_longopts[62].name = "nopager";
  base_longopts[62].has_arg = 0;
  base_longopts[62].flag = (int *)((void *)0);
  base_longopts[62].val = 0;
  base_longopts[63].name = "no-recurse";
  base_longopts[63].has_arg = 0;
  base_longopts[63].flag = (int *)((void *)0);
  base_longopts[63].val = 'n';
  base_longopts[64].name = "norecurse";
  base_longopts[64].has_arg = 0;
  base_longopts[64].flag = (int *)((void *)0);
  base_longopts[64].val = 'n';
  base_longopts[65].name = "null";
  base_longopts[65].has_arg = 0;
  base_longopts[65].flag = (int *)((void *)0);
  base_longopts[65].val = '0';
  base_longopts[66].name = "numbers";
  base_longopts[66].has_arg = 0;
  base_longopts[66].flag = & opts.print_line_numbers;
  base_longopts[66].val = 2;
  base_longopts[67].name = "only-matching";
  base_longopts[67].has_arg = 0;
  base_longopts[67].flag = (int *)((void *)0);
  base_longopts[67].val = 'o';
  base_longopts[68].name = "one-device";
  base_longopts[68].has_arg = 0;
  base_longopts[68].flag = & opts.one_dev;
  base_longopts[68].val = 1;
  base_longopts[69].name = "pager";
  base_longopts[69].has_arg = 1;
  base_longopts[69].flag = (int *)((void *)0);
  base_longopts[69].val = 0;
  base_longopts[70].name = "parallel";
  base_longopts[70].has_arg = 0;
  base_longopts[70].flag = & opts.parallel;
  base_longopts[70].val = 1;
  base_longopts[71].name = "passthrough";
  base_longopts[71].has_arg = 0;
  base_longopts[71].flag = & opts.passthrough;
  base_longopts[71].val = 1;
  base_longopts[72].name = "passthru";
  base_longopts[72].has_arg = 0;
  base_longopts[72].flag = & opts.passthrough;
  base_longopts[72].val = 1;
  base_longopts[73].name = "path-to-ignore";
  base_longopts[73].has_arg = 1;
  base_longopts[73].flag = (int *)((void *)0);
  base_longopts[73].val = 'p';
  base_longopts[74].name = "print0";
  base_longopts[74].has_arg = 0;
  base_longopts[74].flag = (int *)((void *)0);
  base_longopts[74].val = '0';
  base_longopts[75].name = "print-all-files";
  base_longopts[75].has_arg = 0;
  base_longopts[75].flag = (int *)((void *)0);
  base_longopts[75].val = 0;
  base_longopts[76].name = "print-long-lines";
  base_longopts[76].has_arg = 0;
  base_longopts[76].flag = & opts.print_long_lines;
  base_longopts[76].val = 1;
  base_longopts[77].name = "recurse";
  base_longopts[77].has_arg = 0;
  base_longopts[77].flag = (int *)((void *)0);
  base_longopts[77].val = 'r';
  base_longopts[78].name = "search-binary";
  base_longopts[78].has_arg = 0;
  base_longopts[78].flag = & opts.search_binary_files;
  base_longopts[78].val = 1;
  base_longopts[79].name = "search-files";
  base_longopts[79].has_arg = 0;
  base_longopts[79].flag = & opts.search_stream;
  base_longopts[79].val = 0;
  base_longopts[80].name = "search-zip";
  base_longopts[80].has_arg = 0;
  base_longopts[80].flag = & opts.search_zip_files;
  base_longopts[80].val = 1;
  base_longopts[81].name = "silent";
  base_longopts[81].has_arg = 0;
  base_longopts[81].flag = (int *)((void *)0);
  base_longopts[81].val = 0;
  base_longopts[82].name = "skip-vcs-ignores";
  base_longopts[82].has_arg = 0;
  base_longopts[82].flag = (int *)((void *)0);
  base_longopts[82].val = 'U';
  base_longopts[83].name = "smart-case";
  base_longopts[83].has_arg = 0;
  base_longopts[83].flag = (int *)((void *)0);
  base_longopts[83].val = 'S';
  base_longopts[84].name = "stats";
  base_longopts[84].has_arg = 0;
  base_longopts[84].flag = & opts.stats;
  base_longopts[84].val = 1;
  base_longopts[85].name = "stats-only";
  base_longopts[85].has_arg = 0;
  base_longopts[85].flag = (int *)((void *)0);
  base_longopts[85].val = 0;
  base_longopts[86].name = "unrestricted";
  base_longopts[86].has_arg = 0;
  base_longopts[86].flag = (int *)((void *)0);
  base_longopts[86].val = 'u';
  base_longopts[87].name = "version";
  base_longopts[87].has_arg = 0;
  base_longopts[87].flag = & version;
  base_longopts[87].val = 1;
  base_longopts[88].name = "vimgrep";
  base_longopts[88].has_arg = 0;
  base_longopts[88].flag = & opts.vimgrep;
  base_longopts[88].val = 1;
  base_longopts[89].name = "width";
  base_longopts[89].has_arg = 1;
  base_longopts[89].flag = (int *)((void *)0);
  base_longopts[89].val = 'W';
  base_longopts[90].name = "word-regexp";
  base_longopts[90].has_arg = 0;
  base_longopts[90].flag = (int *)((void *)0);
  base_longopts[90].val = 'w';
  base_longopts[91].name = "workers";
  base_longopts[91].has_arg = 1;
  base_longopts[91].flag = (int *)((void *)0);
  base_longopts[91].val = 0;
  lang_count = get_lang_count();
  longopts_len = sizeof(base_longopts) / sizeof(option_t );
  full_len = (longopts_len + lang_count) + 1UL;
  tmp___0 = ag_malloc(full_len * sizeof(option_t ));
  longopts = (option_t *)tmp___0;
  memcpy((void * __restrict  )longopts, (void const   * __restrict  )(base_longopts),
         sizeof(base_longopts));
  tmp___1 = ag_malloc(sizeof(size_t ) * lang_count);
  ext_index = (size_t *)tmp___1;
  memset((void *)ext_index, 0, sizeof(size_t ) * lang_count);
  i = (size_t )0;
  while (i < lang_count) {
    opt.name = langs[i].name;
    opt.has_arg = 0;
    opt.flag = (int *)((void *)0);
    opt.val = 0;
    *(longopts + (i + longopts_len)) = opt;
    i ++;
  }
  __constr_expr_0.name = (char const   *)((void *)0);
  __constr_expr_0.has_arg = 0;
  __constr_expr_0.flag = (int *)((void *)0);
  __constr_expr_0.val = 0;
  *(longopts + (full_len - 1UL)) = __constr_expr_0;
  if (argc < 2) {
    usage();
    cleanup_ignore(root_ignores);
    cleanup_options();
    exit(1);
  }
  tmp___2 = fileno(stdin);
  rv = fstat(tmp___2, & statbuf);
  if (rv == 0) {
    if ((statbuf.st_mode & 61440U) == 4096U) {
      opts.search_stream = 1;
    } else
    if ((statbuf.st_mode & 61440U) == 32768U) {
      opts.search_stream = 1;
    }
  }
  tmp___4 = fileno(stdout);
  tmp___5 = isatty(tmp___4);
  if (! tmp___5) {
    opts.color = 0;
    group = 0;
    tmp___3 = fileno(stdout);
    rv = fstat(tmp___3, & statbuf);
    if (rv != 0) {
      die("Error fstat()ing stdout");
    }
    opts.stdout_inode = statbuf.st_ino;
  }
  file_search_regex = (char *)((void *)0);
  while (1) {
    ch = getopt_long(argc, (char * const  *)argv, "A:aB:C:cDG:g:FfHhiLlm:nop:QRrSsvVtuUwW:z0",
                     (struct option  const  *)longopts, & opt_index);
    if (! (ch != -1)) {
      break;
    }
    switch (ch) {
    case 65: 
    if (optarg) {
      tmp___6 = strtol((char const   * __restrict  )optarg, (char ** __restrict  )(& num_end),
                       10);
      opts.after = (size_t )tmp___6;
      if ((unsigned long )num_end == (unsigned long )optarg) {
        optind --;
        opts.after = (size_t )2;
      } else
      if ((int )*num_end != 0) {
        optind --;
        opts.after = (size_t )2;
      } else {
        tmp___7 = __errno_location();
        if (*tmp___7 == 34) {
          optind --;
          opts.after = (size_t )2;
        }
      }
    } else {
      opts.after = (size_t )2;
    }
    break;
    case 97: 
    opts.search_all_files = 1;
    opts.search_binary_files = 1;
    break;
    case 66: 
    if (optarg) {
      tmp___8 = strtol((char const   * __restrict  )optarg, (char ** __restrict  )(& num_end),
                       10);
      opts.before = (size_t )tmp___8;
      if ((unsigned long )num_end == (unsigned long )optarg) {
        optind --;
        opts.before = (size_t )2;
      } else
      if ((int )*num_end != 0) {
        optind --;
        opts.before = (size_t )2;
      } else {
        tmp___9 = __errno_location();
        if (*tmp___9 == 34) {
          optind --;
          opts.before = (size_t )2;
        }
      }
    } else {
      opts.before = (size_t )2;
    }
    break;
    case 67: 
    if (optarg) {
      tmp___10 = strtol((char const   * __restrict  )optarg, (char ** __restrict  )(& num_end),
                        10);
      opts.context = (int )tmp___10;
      if ((unsigned long )num_end == (unsigned long )optarg) {
        optind --;
        opts.context = 2;
      } else
      if ((int )*num_end != 0) {
        optind --;
        opts.context = 2;
      } else {
        tmp___11 = __errno_location();
        if (*tmp___11 == 34) {
          optind --;
          opts.context = 2;
        }
      }
    } else {
      opts.context = 2;
    }
    break;
    case 99: 
    opts.print_count = 1;
    opts.print_filename_only = 1;
    break;
    case 68: 
    set_log_level((enum log_level )10);
    break;
    case 102: 
    opts.follow_symlinks = 1;
    break;
    case 103: 
    accepts_query = 0;
    needs_query = accepts_query;
    opts.match_files = 1;
    case 71: 
    if (file_search_regex) {
      log_err("File search regex (-g or -G) already specified.");
      usage();
      exit(1);
    }
    file_search_regex = ag_strdup((char const   *)optarg);
    break;
    case 72: 
    opts.print_path = 2;
    break;
    case 104: 
    help = 1;
    break;
    case 105: 
    opts.casing = (enum case_behavior )2;
    break;
    case 76: 
    opts.print_nonmatching_files = 1;
    opts.print_path = 2;
    break;
    case 108: 
    needs_query = 0;
    opts.print_filename_only = 1;
    opts.print_path = 2;
    break;
    case 109: 
    tmp___12 = atoi((char const   *)optarg);
    opts.max_matches_per_file = (size_t )tmp___12;
    break;
    case 110: 
    opts.recurse_dirs = 0;
    break;
    case 112: 
    opts.path_to_ignore = 1;
    load_ignore_patterns(root_ignores, (char const   *)optarg);
    break;
    case 111: 
    opts.only_matching = 1;
    break;
    case 81: 
    case 70: 
    opts.literal = 1;
    break;
    case 114: 
    case 82: 
    opts.recurse_dirs = 1;
    break;
    case 83: 
    opts.casing = (enum case_behavior )3;
    break;
    case 115: 
    opts.casing = (enum case_behavior )1;
    break;
    case 116: 
    opts.search_all_files = 1;
    break;
    case 117: 
    opts.search_binary_files = 1;
    opts.search_all_files = 1;
    opts.search_hidden_files = 1;
    break;
    case 85: 
    opts.skip_vcs_ignores = 1;
    break;
    case 118: 
    opts.invert_match = 1;
    opts.color = 0;
    break;
    case 86: 
    version = 1;
    break;
    case 119: 
    opts.word_regexp = 1;
    break;
    case 87: 
    tmp___13 = strtol((char const   * __restrict  )optarg, (char ** __restrict  )(& num_end),
                      10);
    opts.width = (size_t )tmp___13;
    if ((unsigned long )num_end == (unsigned long )optarg) {
      die("Invalid width\n");
    } else
    if ((int )*num_end != 0) {
      die("Invalid width\n");
    } else {
      tmp___14 = __errno_location();
      if (*tmp___14 == 34) {
        die("Invalid width\n");
      }
    }
    break;
    case 122: 
    opts.search_zip_files = 1;
    break;
    case 48: 
    opts.path_sep = (char )'\000';
    break;
    case 0: 
    tmp___31 = strcmp((longopts + opt_index)->name, "ackmate-dir-filter");
    if (tmp___31 == 0) {
      compile_study(& opts.ackmate_dir_filter, & opts.ackmate_dir_filter_extra, optarg,
                    (int const   )0, (int const   )0);
      break;
    } else {
      tmp___30 = strcmp((longopts + opt_index)->name, "depth");
      if (tmp___30 == 0) {
        opts.max_search_depth = atoi((char const   *)optarg);
        break;
      } else {
        tmp___29 = strcmp((longopts + opt_index)->name, "filename");
        if (tmp___29 == 0) {
          opts.print_path = 0;
          opts.print_line_numbers = 1;
          break;
        } else {
          tmp___28 = strcmp((longopts + opt_index)->name, "ignore-dir");
          if (tmp___28 == 0) {
            add_ignore_pattern(root_ignores, (char const   *)optarg);
            break;
          } else {
            tmp___27 = strcmp((longopts + opt_index)->name, "ignore");
            if (tmp___27 == 0) {
              add_ignore_pattern(root_ignores, (char const   *)optarg);
              break;
            } else {
              tmp___25 = strcmp((longopts + opt_index)->name, "no-filename");
              if (tmp___25 == 0) {
                opts.print_path = 4;
                opts.print_line_numbers = 0;
                break;
              } else {
                tmp___26 = strcmp((longopts + opt_index)->name, "nofilename");
                if (tmp___26 == 0) {
                  opts.print_path = 4;
                  opts.print_line_numbers = 0;
                  break;
                } else {
                  tmp___23 = strcmp((longopts + opt_index)->name, "no-pager");
                  if (tmp___23 == 0) {
                    out_fd = stdout;
                    opts.pager = (char *)((void *)0);
                    break;
                  } else {
                    tmp___24 = strcmp((longopts + opt_index)->name, "nopager");
                    if (tmp___24 == 0) {
                      out_fd = stdout;
                      opts.pager = (char *)((void *)0);
                      break;
                    } else {
                      tmp___22 = strcmp((longopts + opt_index)->name, "pager");
                      if (tmp___22 == 0) {
                        opts.pager = optarg;
                        break;
                      } else {
                        tmp___21 = strcmp((longopts + opt_index)->name, "print-all-files");
                        if (tmp___21 == 0) {
                          opts.print_all_paths = 1;
                          break;
                        } else {
                          tmp___20 = strcmp((longopts + opt_index)->name, "workers");
                          if (tmp___20 == 0) {
                            opts.workers = atoi((char const   *)optarg);
                            break;
                          } else {
                            tmp___19 = strcmp((longopts + opt_index)->name, "color-line-number");
                            if (tmp___19 == 0) {
                              free((void *)opts.color_line_number);
                              ag_asprintf(& opts.color_line_number, "\033[%sm", optarg);
                              break;
                            } else {
                              tmp___18 = strcmp((longopts + opt_index)->name, "color-match");
                              if (tmp___18 == 0) {
                                free((void *)opts.color_match);
                                ag_asprintf(& opts.color_match, "\033[%sm", optarg);
                                break;
                              } else {
                                tmp___17 = strcmp((longopts + opt_index)->name, "color-path");
                                if (tmp___17 == 0) {
                                  free((void *)opts.color_path);
                                  ag_asprintf(& opts.color_path, "\033[%sm", optarg);
                                  break;
                                } else {
                                  tmp___16 = strcmp((longopts + opt_index)->name,
                                                    "silent");
                                  if (tmp___16 == 0) {
                                    set_log_level((enum log_level )100);
                                    break;
                                  } else {
                                    tmp___15 = strcmp((longopts + opt_index)->name,
                                                      "stats-only");
                                    if (tmp___15 == 0) {
                                      opts.print_filename_only = 1;
                                      opts.print_path = 4;
                                      opts.stats = 1;
                                      break;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if ((unsigned long )(longopts + opt_index)->flag != (unsigned long )((int *)0)) {
      break;
    }
    i = (size_t )0;
    while (i < lang_count) {
      tmp___33 = strcmp((longopts + opt_index)->name, langs[i].name);
      if (tmp___33 == 0) {
        has_filetype = 1;
        tmp___32 = lang_num;
        lang_num ++;
        *(ext_index + tmp___32) = i;
        break;
      }
      i ++;
    }
    if (i != lang_count) {
      break;
    }
    log_err("option %s does not take a value", (longopts + opt_index)->name);
    default: 
    usage();
    exit(1);
    }
  }
  if ((unsigned int )opts.casing == 0U) {
    opts.casing = (enum case_behavior )3;
  }
  if (file_search_regex) {
    pcre_opts = 0;
    if ((unsigned int )opts.casing == 2U) {
      pcre_opts |= 1;
    } else
    if ((unsigned int )opts.casing == 3U) {
      tmp___34 = is_lowercase((char const   *)file_search_regex);
      if (tmp___34) {
        pcre_opts |= 1;
      }
    }
    if (opts.word_regexp) {
      old_file_search_regex = file_search_regex;
      ag_asprintf(& file_search_regex, "\\b%s\\b", file_search_regex);
      free((void *)old_file_search_regex);
    }
    compile_study(& opts.file_search_regex, & opts.file_search_regex_extra, file_search_regex,
                  (int const   )pcre_opts, (int const   )0);
    free((void *)file_search_regex);
  }
  if (has_filetype) {
    num_exts = combine_file_extensions(ext_index, lang_num, & extensions);
    lang_regex = make_lang_regex(extensions, num_exts);
    compile_study(& opts.file_search_regex, & opts.file_search_regex_extra, lang_regex,
                  (int const   )0, (int const   )0);
  }
  if (extensions) {
    free((void *)extensions);
  }
  free((void *)ext_index);
  if (lang_regex) {
    free((void *)lang_regex);
  }
  free((void *)longopts);
  argc -= optind;
  argv += optind;
  if (opts.pager) {
    out_fd = popen((char const   *)opts.pager, "w");
    if (! out_fd) {
      perror("Failed to run pager");
      exit(1);
    }
  }
  if (help) {
    usage();
    exit(0);
  }
  if (version) {
    print_version();
    exit(0);
  }
  if (list_file_types) {
    printf((char const   * __restrict  )"The following file types are supported:\n");
    lang_index = (size_t )0;
    while (lang_index < lang_count) {
      printf((char const   * __restrict  )"  --%s\n    ", langs[lang_index].name);
      j = 0;
      while (1) {
        if (j < 12) {
          if (! langs[lang_index].extensions[j]) {
            break;
          }
        } else {
          break;
        }
        printf((char const   * __restrict  )"  .%s", langs[lang_index].extensions[j]);
        j ++;
      }
      printf((char const   * __restrict  )"\n\n");
      lang_index ++;
    }
    exit(0);
  }
  if (needs_query) {
    if (argc == 0) {
      log_err("What do you want to search for?");
      exit(1);
    }
  }
  if (home_dir) {
    if (! opts.search_all_files) {
      log_debug("Found user\'s home dir: %s", home_dir);
      ag_asprintf(& ignore_file_path, "%s/.agignore", home_dir);
      load_ignore_patterns(root_ignores, (char const   *)ignore_file_path);
      free((void *)ignore_file_path);
    }
  }
  if (! opts.skip_vcs_ignores) {
    gitconfig_file = (FILE *)((void *)0);
    buf_len = (size_t )0;
    gitconfig_res = (char *)((void *)0);
    gitconfig_file = popen("git config -z --path --get core.excludesfile 2>/dev/null",
                           "r");
    if ((unsigned long )gitconfig_file != (unsigned long )((void *)0)) {
      while (1) {
        tmp___35 = ag_realloc((void *)gitconfig_res, buf_len + 65UL);
        gitconfig_res = (char *)tmp___35;
        tmp___36 = fread((void * __restrict  )(gitconfig_res + buf_len), (size_t )1,
                         (size_t )64, (FILE * __restrict  )gitconfig_file);
        buf_len += tmp___36;
        tmp___37 = feof(gitconfig_file);
        if (tmp___37) {
          break;
        } else
        if (buf_len > 0UL) {
          if (! (buf_len % 64UL == 0UL)) {
            break;
          }
        } else {
          break;
        }
      }
      *(gitconfig_res + buf_len) = (char )'\000';
      if (buf_len == 0UL) {
        free((void *)gitconfig_res);
        tmp___38 = getenv("XDG_CONFIG_HOME");
        config_home = (char const   *)tmp___38;
        if (config_home) {
          ag_asprintf(& gitconfig_res, "%s/%s", config_home, "git/ignore");
        } else
        if (home_dir) {
          ag_asprintf(& gitconfig_res, "%s/%s", home_dir, ".config/git/ignore");
        } else {
          gitconfig_res = ag_strdup("");
        }
      }
      log_debug("global core.excludesfile: %s", gitconfig_res);
      load_ignore_patterns(root_ignores, (char const   *)gitconfig_res);
      free((void *)gitconfig_res);
      pclose(gitconfig_file);
    }
  }
  if (opts.context > 0) {
    opts.before = (size_t )opts.context;
    opts.after = (size_t )opts.context;
  }
  if (opts.ackmate) {
    opts.color = 0;
    opts.print_break = 1;
    group = 1;
    opts.search_stream = 0;
  }
  if (opts.vimgrep) {
    opts.color = 0;
    opts.print_break = 0;
    group = 1;
    opts.search_stream = 0;
    opts.print_path = 4;
  }
  if (opts.parallel) {
    opts.search_stream = 0;
  }
  if (! (opts.print_path != 0)) {
    if (! (opts.print_break == 0)) {
      if (group) {
        opts.print_break = 1;
      } else {
        opts.print_path = 1;
        opts.print_break = 0;
      }
    }
  }
  if (opts.search_stream) {
    opts.print_break = 0;
    opts.print_path = 4;
    if (opts.print_line_numbers != 2) {
      opts.print_line_numbers = 0;
    }
  }
  if (accepts_query) {
    if (argc > 0) {
      if (! needs_query) {
        tmp___39 = strlen((char const   *)*(argv + 0));
        if (tmp___39 == 0UL) {
          opts.query = ag_strdup(".");
        } else {
          opts.query = ag_strdup((char const   *)*(argv + 0));
        }
      } else {
        opts.query = ag_strdup((char const   *)*(argv + 0));
      }
      argc --;
      argv ++;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (! needs_query) {
    opts.query = ag_strdup(".");
  }
  tmp___40 = strlen((char const   *)opts.query);
  opts.query_len = (int )tmp___40;
  log_debug("Query is %s", opts.query);
  if (opts.query_len == 0) {
    log_err("Error: No query. What do you want to search for?");
    exit(1);
  }
  tmp___41 = is_regex((char const   *)opts.query);
  if (! tmp___41) {
    opts.literal = 1;
  }
  path = (char *)((void *)0);
  base_path = (char *)((void *)0);
  tmp___42 = (char *)((void *)0);
  opts.paths_len = argc;
  if (argc > 0) {
    tmp___43 = ag_calloc(sizeof(char *), (size_t )(argc + 1));
    *paths = (char **)tmp___43;
    tmp___44 = ag_calloc(sizeof(char *), (size_t )(argc + 1));
    *base_paths = (char **)tmp___44;
    i = (size_t )0;
    while (i < (size_t )argc) {
      path = ag_strdup((char const   *)*(argv + i));
      tmp___45 = strlen((char const   *)path);
      path_len = (int )tmp___45;
      if (path_len > 1) {
        if ((int )*(path + (path_len - 1)) == 47) {
          *(path + (path_len - 1)) = (char )'\000';
        }
      }
      *(*paths + i) = path;
      tmp___46 = ag_malloc((size_t )4096);
      tmp___42 = (char *)tmp___46;
      base_path = realpath((char const   * __restrict  )path, (char * __restrict  )tmp___42);
      if (base_path) {
        tmp___47 = strlen((char const   *)base_path);
        base_path_len = (int )tmp___47;
        if (base_path_len > 1) {
          if ((int )*(base_path + (base_path_len - 1)) != 47) {
            tmp___48 = ag_realloc((void *)base_path, (size_t )(base_path_len + 2));
            base_path = (char *)tmp___48;
            *(base_path + base_path_len) = (char )'/';
            *(base_path + (base_path_len + 1)) = (char )'\000';
          }
        }
      }
      *(*base_paths + i) = base_path;
      i ++;
    }
    opts.search_stream = 0;
  } else {
    path = ag_strdup(".");
    tmp___49 = ag_malloc(sizeof(char *) * 2UL);
    *paths = (char **)tmp___49;
    tmp___50 = ag_malloc(sizeof(char *) * 2UL);
    *base_paths = (char **)tmp___50;
    *(*paths + 0) = path;
    tmp___51 = ag_malloc((size_t )4096);
    tmp___42 = (char *)tmp___51;
    *(*base_paths + 0) = realpath((char const   * __restrict  )path, (char * __restrict  )tmp___42);
    i = (size_t )1;
  }
  *(*paths + i) = (char *)((void *)0);
  *(*base_paths + i) = (char *)((void *)0);
  return;
}
}
#pragma merger("0","/tmp/cil-7Ha3I0Ah.i","-g,-O2,-pthread,-Wall,-Wextra,-Wformat=2,-Wno-format-nonliteral,-Wshadow,-Wpointer-arith,-Wcast-qual,-Wmissing-prototypes,-Wno-missing-braces,-std=gnu89")
extern int fflush(FILE *__stream ) ;
extern int fputc(int __c , FILE *__stream ) ;
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
void print_init_context(void) ;
void print_cleanup_context(void) ;
void print_context_append(char const   *line , size_t len ) ;
void print_trailing_context(char const   *path , char const   *buf , size_t n ) ;
void print_path(char const   *path , char const   sep ) ;
void print_path_count(char const   *path , char const   sep , size_t const   count ) ;
void print_line(char const   *buf , size_t buf_pos , size_t prev_line_offset ) ;
void print_binary_file_matches(char const   *path ) ;
void print_file_matches(char const   *path , char const   *buf , size_t const   buf_len ,
                        match_t const   *matches , size_t const   matches_len ) ;
void print_line_number(size_t line , char const   sep ) ;
void print_column_number(match_t const   *matches , size_t last_printed_match , size_t prev_line_offset ,
                         char const   sep ) ;
void print_file_separator(void) ;
char const   *normalize_path(char const   *path ) ;
int first_file_match  =    1;
char const   *color_reset  =    "\033[0m\033[K";
char const   *truncate_marker  =    " [...]";
 __thread  struct print_context print_context  ;
void print_init_context(void) 
{ 
  void *tmp ;

  {
  if ((unsigned long )print_context.context_prev_lines != (unsigned long )((void *)0)) {
    return;
  }
  tmp = ag_calloc(sizeof(char *), opts.before + 1UL);
  print_context.context_prev_lines = (char **)tmp;
  print_context.line = (size_t )1;
  print_context.prev_line = (size_t )0;
  print_context.last_prev_line = (size_t )0;
  print_context.prev_line_offset = (size_t )0;
  print_context.line_preceding_current_match_offset = (size_t )0;
  print_context.lines_since_last_match = (size_t )2147483647;
  print_context.last_printed_match = (size_t )0;
  print_context.in_a_match = 0;
  print_context.printing_a_match = 0;
  return;
}
}
void print_cleanup_context(void) 
{ 
  size_t i ;

  {
  if ((unsigned long )print_context.context_prev_lines == (unsigned long )((void *)0)) {
    return;
  }
  i = (size_t )0;
  while (i < opts.before) {
    if ((unsigned long )*(print_context.context_prev_lines + i) != (unsigned long )((void *)0)) {
      free((void *)*(print_context.context_prev_lines + i));
    }
    i ++;
  }
  free((void *)print_context.context_prev_lines);
  print_context.context_prev_lines = (char **)((void *)0);
  return;
}
}
void print_context_append(char const   *line , size_t len ) 
{ 


  {
  if (opts.before == 0UL) {
    return;
  }
  if ((unsigned long )*(print_context.context_prev_lines + print_context.last_prev_line) != (unsigned long )((void *)0)) {
    free((void *)*(print_context.context_prev_lines + print_context.last_prev_line));
  }
  *(print_context.context_prev_lines + print_context.last_prev_line) = ag_strndup(line,
                                                                                  len);
  print_context.last_prev_line = (print_context.last_prev_line + 1UL) % opts.before;
  return;
}
}
void print_trailing_context(char const   *path , char const   *buf , size_t n ) 
{ 
  char sep ;

  {
  sep = (char )'-';
  if (opts.ackmate) {
    sep = (char )':';
  } else
  if (opts.vimgrep) {
    sep = (char )':';
  }
  if (print_context.lines_since_last_match != 0UL) {
    if (print_context.lines_since_last_match <= opts.after) {
      if (opts.print_path == 3) {
        print_path(path, (char const   )':');
      }
      print_line_number(print_context.line, (char const   )sep);
      fwrite((void const   * __restrict  )buf, (size_t )1, n, (FILE * __restrict  )out_fd);
      fputc('\n', out_fd);
    }
  }
  (print_context.line) ++;
  if (! print_context.in_a_match) {
    if (print_context.lines_since_last_match < 2147483647UL) {
      (print_context.lines_since_last_match) ++;
    }
  }
  return;
}
}
void print_path(char const   *path , char const   sep ) 
{ 


  {
  if (opts.print_path == 4) {
    if (! opts.vimgrep) {
      return;
    }
  }
  path = normalize_path(path);
  if (opts.ackmate) {
    fprintf((FILE * __restrict  )out_fd, (char const   * __restrict  )":%s%c", path,
            (int const   )sep);
  } else
  if (opts.vimgrep) {
    fprintf((FILE * __restrict  )out_fd, (char const   * __restrict  )"%s%c", path,
            (int const   )sep);
  } else
  if (opts.color) {
    fprintf((FILE * __restrict  )out_fd, (char const   * __restrict  )"%s%s%s%c",
            opts.color_path, path, color_reset, (int const   )sep);
  } else {
    fprintf((FILE * __restrict  )out_fd, (char const   * __restrict  )"%s%c", path,
            (int const   )sep);
  }
  return;
}
}
void print_path_count(char const   *path , char const   sep , size_t const   count ) 
{ 


  {
  if (*path) {
    print_path(path, (char const   )':');
  }
  if (opts.color) {
    fprintf((FILE * __restrict  )out_fd, (char const   * __restrict  )"%s%lu%s%c",
            opts.color_line_number, (unsigned long )count, color_reset, (int const   )sep);
  } else {
    fprintf((FILE * __restrict  )out_fd, (char const   * __restrict  )"%lu%c", (unsigned long )count,
            (int const   )sep);
  }
  return;
}
}
void print_line(char const   *buf , size_t buf_pos , size_t prev_line_offset ) 
{ 
  size_t write_chars ;

  {
  write_chars = (buf_pos - prev_line_offset) + 1UL;
  if (opts.width > 0UL) {
    if (opts.width < write_chars) {
      write_chars = opts.width;
    }
  }
  fwrite((void const   * __restrict  )(buf + prev_line_offset), (size_t )1, write_chars,
         (FILE * __restrict  )out_fd);
  return;
}
}
void print_binary_file_matches(char const   *path ) 
{ 


  {
  path = normalize_path(path);
  print_file_separator();
  fprintf((FILE * __restrict  )out_fd, (char const   * __restrict  )"Binary file %s matches.\n",
          path);
  return;
}
}
void print_file_matches(char const   *path , char const   *buf , size_t const   buf_len ,
                        match_t const   *matches , size_t const   matches_len ) 
{ 
  size_t cur_match ;
  ssize_t lines_to_print ;
  char sep ;
  size_t i ;
  size_t j ;
  int blanks_between_matches ;
  int tmp ;
  size_t start ;
  int printed_match ;

  {
  cur_match = (size_t )0;
  lines_to_print = (ssize_t )0;
  sep = (char )'-';
  if (opts.context) {
    tmp = 1;
  } else
  if (opts.after) {
    tmp = 1;
  } else
  if (opts.before) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  blanks_between_matches = tmp;
  if (opts.ackmate) {
    sep = (char )':';
  } else
  if (opts.vimgrep) {
    sep = (char )':';
  }
  print_file_separator();
  if (opts.print_path == 0) {
    opts.print_path = 2;
  } else
  if (opts.print_path == 1) {
    opts.print_path = 3;
  }
  if (opts.print_path == 2) {
    if (opts.print_count) {
      print_path_count(path, (char const   )opts.path_sep, matches_len);
    } else {
      print_path(path, (char const   )opts.path_sep);
    }
  }
  i = (size_t )0;
  while (1) {
    if (i <= (size_t )buf_len) {
      if (! (cur_match < (size_t )matches_len)) {
        if (! (print_context.lines_since_last_match <= opts.after)) {
          break;
        }
      }
    } else {
      break;
    }
    if (cur_match < (size_t )matches_len) {
      if (i == (size_t )(matches + cur_match)->start) {
        print_context.in_a_match = 1;
        if (cur_match > 0UL) {
          if (blanks_between_matches) {
            if (print_context.lines_since_last_match > (opts.before + opts.after) + 1UL) {
              fprintf((FILE * __restrict  )out_fd, (char const   * __restrict  )"--\n");
            }
          }
        }
        if (print_context.lines_since_last_match > 0UL) {
          if (opts.before > 0UL) {
            lines_to_print = (ssize_t )(print_context.lines_since_last_match - (opts.after + 1UL));
            if (lines_to_print < 0L) {
              lines_to_print = (ssize_t )0;
            } else
            if ((size_t )lines_to_print > opts.before) {
              lines_to_print = (ssize_t )opts.before;
            }
            j = opts.before - (size_t )lines_to_print;
            while (j < opts.before) {
              print_context.prev_line = (print_context.last_prev_line + j) % opts.before;
              if ((unsigned long )*(print_context.context_prev_lines + print_context.prev_line) != (unsigned long )((void *)0)) {
                if (opts.print_path == 3) {
                  print_path(path, (char const   )':');
                }
                print_line_number(print_context.line - (opts.before - j), (char const   )sep);
                fprintf((FILE * __restrict  )out_fd, (char const   * __restrict  )"%s\n",
                        *(print_context.context_prev_lines + print_context.prev_line));
              }
              j ++;
            }
          }
        }
        print_context.lines_since_last_match = (size_t )0;
      }
    }
    if (cur_match < (size_t )matches_len) {
      if (i == (size_t )(matches + cur_match)->end) {
        cur_match ++;
        print_context.in_a_match = 0;
      }
    }
    if (i == (size_t )buf_len) {
      goto _L;
    } else
    if ((int const   )*(buf + i) == 10) {
      _L: /* CIL Label */ 
      if (opts.before > 0UL) {
        print_context_append(buf + print_context.prev_line_offset, i - print_context.prev_line_offset);
      }
    }
    if (i == (size_t )buf_len) {
      goto _L___1;
    } else
    if ((int const   )*(buf + i) == 10) {
      _L___1: /* CIL Label */ 
      if (print_context.lines_since_last_match == 0UL) {
        if (opts.print_path == 3) {
          if (! opts.search_stream) {
            print_path(path, (char const   )':');
          }
        }
        if (opts.ackmate) {
          print_line_number(print_context.line, (char const   )';');
          while (print_context.last_printed_match < cur_match) {
            start = (size_t )((matches + print_context.last_printed_match)->start - (size_t const   )print_context.line_preceding_current_match_offset);
            fprintf((FILE * __restrict  )out_fd, (char const   * __restrict  )"%lu %lu",
                    start, (matches + print_context.last_printed_match)->end - (matches + print_context.last_printed_match)->start);
            if (print_context.last_printed_match == cur_match - 1UL) {
              fputc(':', out_fd);
            } else {
              fputc(',', out_fd);
            }
            (print_context.last_printed_match) ++;
          }
          print_line(buf, i, print_context.prev_line_offset);
        } else
        if (opts.vimgrep) {
          while (print_context.last_printed_match < cur_match) {
            print_path(path, (char const   )sep);
            print_line_number(print_context.line, (char const   )sep);
            print_column_number(matches, print_context.last_printed_match, print_context.prev_line_offset,
                                (char const   )sep);
            print_line(buf, i, print_context.prev_line_offset);
            (print_context.last_printed_match) ++;
          }
        } else {
          print_line_number(print_context.line, (char const   )':');
          printed_match = 0;
          if (opts.column) {
            print_column_number(matches, print_context.last_printed_match, print_context.prev_line_offset,
                                (char const   )':');
          }
          if (print_context.printing_a_match) {
            if (opts.color) {
              fprintf((FILE * __restrict  )out_fd, (char const   * __restrict  )"%s",
                      opts.color_match);
            }
          }
          j = print_context.prev_line_offset;
          while (j <= i) {
            if (print_context.last_printed_match < (size_t )matches_len) {
              if (j == (size_t )(matches + print_context.last_printed_match)->end) {
                if (opts.color) {
                  fprintf((FILE * __restrict  )out_fd, (char const   * __restrict  )"%s",
                          color_reset);
                }
                print_context.printing_a_match = 0;
                (print_context.last_printed_match) ++;
                printed_match = 1;
                if (opts.only_matching) {
                  fputc('\n', out_fd);
                }
              }
            }
            if (j < (size_t )buf_len) {
              if (opts.width > 0UL) {
                if (j - print_context.prev_line_offset >= opts.width) {
                  if (j < i) {
                    fputs((char const   * __restrict  )truncate_marker, (FILE * __restrict  )out_fd);
                  }
                  fputc('\n', out_fd);
                  j = i;
                  print_context.last_printed_match = (size_t )matches_len;
                }
              }
            }
            if (print_context.last_printed_match < (size_t )matches_len) {
              if (j == (size_t )(matches + print_context.last_printed_match)->start) {
                if (opts.only_matching) {
                  if (printed_match) {
                    if (opts.print_path == 3) {
                      print_path(path, (char const   )':');
                    }
                    print_line_number(print_context.line, (char const   )':');
                    if (opts.column) {
                      print_column_number(matches, print_context.last_printed_match,
                                          print_context.prev_line_offset, (char const   )':');
                    }
                  }
                }
                if (opts.color) {
                  fprintf((FILE * __restrict  )out_fd, (char const   * __restrict  )"%s",
                          opts.color_match);
                }
                print_context.printing_a_match = 1;
              }
            }
            if (j < (size_t )buf_len) {
              if (! opts.only_matching) {
                goto _L___0;
              } else
              if (print_context.printing_a_match) {
                _L___0: /* CIL Label */ 
                if (opts.width == 0UL) {
                  fputc((int )*(buf + j), out_fd);
                } else
                if (j - print_context.prev_line_offset < opts.width) {
                  fputc((int )*(buf + j), out_fd);
                }
              }
            }
            j ++;
          }
          if (print_context.printing_a_match) {
            if (opts.color) {
              fprintf((FILE * __restrict  )out_fd, (char const   * __restrict  )"%s",
                      color_reset);
            }
          }
        }
      }
      if (opts.search_stream) {
        print_context.last_printed_match = (size_t )0;
        break;
      }
      print_trailing_context(path, buf + print_context.prev_line_offset, i - print_context.prev_line_offset);
      print_context.prev_line_offset = i + 1UL;
      if (! print_context.in_a_match) {
        print_context.line_preceding_current_match_offset = i + 1UL;
      }
      if (i == (size_t )buf_len) {
        if ((int const   )*(buf + (i - 1UL)) != 10) {
          fputc('\n', out_fd);
        }
      }
    }
    i ++;
  }
  if (opts.stdout_inode) {
    fflush(out_fd);
  }
  return;
}
}
void print_line_number(size_t line , char const   sep ) 
{ 


  {
  if (! opts.print_line_numbers) {
    return;
  }
  if (opts.color) {
    fprintf((FILE * __restrict  )out_fd, (char const   * __restrict  )"%s%lu%s%c",
            opts.color_line_number, line, color_reset, (int const   )sep);
  } else {
    fprintf((FILE * __restrict  )out_fd, (char const   * __restrict  )"%lu%c", line,
            (int const   )sep);
  }
  return;
}
}
void print_column_number(match_t const   *matches , size_t last_printed_match , size_t prev_line_offset ,
                         char const   sep ) 
{ 
  size_t column ;

  {
  column = (size_t )0;
  if (prev_line_offset <= (size_t )(matches + last_printed_match)->start) {
    column = (size_t )(((matches + last_printed_match)->start - (size_t const   )prev_line_offset) + 1UL);
  }
  fprintf((FILE * __restrict  )out_fd, (char const   * __restrict  )"%lu%c", column,
          (int const   )sep);
  return;
}
}
void print_file_separator(void) 
{ 


  {
  if (first_file_match == 0) {
    if (opts.print_break) {
      fprintf((FILE * __restrict  )out_fd, (char const   * __restrict  )"\n");
    }
  }
  first_file_match = 0;
  return;
}
}
char const   *normalize_path(char const   *path ) 
{ 
  size_t tmp ;

  {
  tmp = strlen(path);
  if (tmp < 3UL) {
    return (path);
  }
  if ((int const   )*(path + 0) == 46) {
    if ((int const   )*(path + 1) == 47) {
      return (path + 2);
    }
  }
  if ((int const   )*(path + 0) == 47) {
    if ((int const   )*(path + 1) == 47) {
      return (path + 1);
    }
  }
  return (path);
}
}
#pragma merger("0","/tmp/cil-oyoI849O.i","-g,-O2,-pthread,-Wall,-Wextra,-Wformat=2,-Wno-format-nonliteral,-Wshadow,-Wpointer-arith,-Wcast-qual,-Wmissing-prototypes,-Wno-missing-braces,-std=gnu89")
#pragma merger("0","/tmp/cil-xZl5atQ_.i","-g,-O2,-pthread,-Wall,-Wextra,-Wformat=2,-Wno-format-nonliteral,-Wshadow,-Wpointer-arith,-Wcast-qual,-Wmissing-prototypes,-Wno-missing-braces,-std=gnu89")
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
int ag_scandir(char const   *dirname , struct dirent ***namelist , int (*filter)(char const   *path ,
                                                                                 struct dirent  const  * ,
                                                                                 void * ) ,
               void *baton ) ;
int ag_scandir(char const   *dirname , struct dirent ***namelist , int (*filter)(char const   *path ,
                                                                                 struct dirent  const  * ,
                                                                                 void * ) ,
               void *baton ) 
{ 
  DIR *dirp ;
  struct dirent **names ;
  struct dirent *entry ;
  struct dirent *d ;
  int names_len ;
  int results_len ;
  void *tmp ;
  int tmp___0 ;
  struct dirent **tmp_names ;
  void *tmp___1 ;
  void *tmp___2 ;
  int i ;

  {
  dirp = (DIR *)((void *)0);
  names = (struct dirent **)((void *)0);
  names_len = 32;
  results_len = 0;
  dirp = opendir(dirname);
  if ((unsigned long )dirp == (unsigned long )((void *)0)) {
    goto fail;
  }
  tmp = malloc(sizeof(struct dirent *) * (unsigned long )names_len);
  names = (struct dirent **)tmp;
  if ((unsigned long )names == (unsigned long )((void *)0)) {
    goto fail;
  }
  while (1) {
    entry = readdir(dirp);
    if (! ((unsigned long )entry != (unsigned long )((void *)0))) {
      break;
    }
    tmp___0 = (*filter)(dirname, (struct dirent  const  *)entry, baton);
    if (tmp___0 == 0) {
      continue;
    }
    if (results_len >= names_len) {
      tmp_names = names;
      names_len *= 2;
      tmp___1 = realloc((void *)names, sizeof(struct dirent *) * (unsigned long )names_len);
      names = (struct dirent **)tmp___1;
      if ((unsigned long )names == (unsigned long )((void *)0)) {
        free((void *)tmp_names);
        goto fail;
      }
    }
    tmp___2 = malloc((size_t )entry->d_reclen);
    d = (struct dirent *)tmp___2;
    if ((unsigned long )d == (unsigned long )((void *)0)) {
      goto fail;
    }
    memcpy((void * __restrict  )d, (void const   * __restrict  )entry, (size_t )entry->d_reclen);
    *(names + results_len) = d;
    results_len ++;
  }
  closedir(dirp);
  *namelist = names;
  return (results_len);
  fail: 
  if (dirp) {
    closedir(dirp);
  }
  if ((unsigned long )names != (unsigned long )((void *)0)) {
    i = 0;
    while (i < results_len) {
      free((void *)*(names + i));
      i ++;
    }
    free((void *)names);
  }
  return (-1);
}
}
#pragma merger("0","/tmp/cil-0umNM7eC.i","-g,-O2,-pthread,-Wall,-Wextra,-Wformat=2,-Wno-format-nonliteral,-Wshadow,-Wpointer-arith,-Wcast-qual,-Wmissing-prototypes,-Wno-missing-braces,-std=gnu89")
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
extern  __attribute__((__nothrow__)) void *mmap(void *__addr , size_t __len , int __prot ,
                                                int __flags , int __fd , __off_t __offset ) ;
extern  __attribute__((__nothrow__)) int munmap(void *__addr , size_t __len ) ;
extern  __attribute__((__nothrow__)) int madvise(void *__addr , size_t __len , int __advice ) ;
extern int close(int __fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern  __attribute__((__noreturn__)) void pthread_exit(void *__retval ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_signal)(pthread_cond_t *__cond ) ;
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
ag_compression_type is_zipped(void const   *buf , int const   buf_len ) ;
FILE *decompress_open(int fd , char const   *mode , ag_compression_type ctype ) ;
ag_stats stats ;
size_t ag_min(size_t a , size_t b ) ;
char const   *boyer_moore_strnstr(char const   *s , char const   *find , size_t const   s_len ,
                                  size_t const   f_len , size_t const   *alpha_skip_lookup___0 ,
                                  size_t const   *find_skip_lookup___0 , int const   case_insensitive ) ;
char const __attribute__((__no_sanitize__("alignment")))  *hash_strnstr(char const   *s ,
                                                                        char const   *find ,
                                                                        size_t const   s_len ,
                                                                        size_t const   f_len ,
                                                                        uint8_t *h_table___0 ,
                                                                        int const   case_sensitive ) ;
size_t invert_matches(char const   *buf , size_t const   buf_len , match_t *matches ,
                      size_t matches_len ) ;
void realloc_matches(match_t **matches , size_t *matches_size , size_t matches_len ) ;
int is_binary(void const   *buf , size_t const   buf_len ) ;
int is_wordchar(char ch ) ;
ssize_t buf_getline(char const   **line , char const   *buf , size_t const   buf_len ,
                    size_t const   buf_offset ) ;
size_t alpha_skip_lookup[256]  ;
size_t *find_skip_lookup  ;
uint8_t h_table[65536]  __attribute__((__aligned__(64)))  ;
work_queue_t *work_queue ;
work_queue_t *work_queue_tail ;
int done_adding_files ;
pthread_cond_t files_ready ;
pthread_mutex_t stats_mtx ;
pthread_mutex_t work_queue_mtx ;
symdir_t *symhash ;
ssize_t search_buf(char const   *buf , size_t const   buf_len , char const   *dir_full_path ) ;
ssize_t search_stream(FILE *stream , char const   *path ) ;
void search_file(char const   *file_full_path ) ;
void *search_file_worker(void *i ) ;
void search_dir(ignores *ig , char const   *base_path , char const   *path , int const   depth ,
                dev_t original_dev ) ;
work_queue_t *work_queue  =    (work_queue_t *)((void *)0);
work_queue_t *work_queue_tail  =    (work_queue_t *)((void *)0);
int done_adding_files  =    0;
pthread_cond_t files_ready  =    {{{0ULL}, {0ULL}, {0U, 0U}, {0U, 0U}, 0U, 0U, {0U, 0U}}};
pthread_mutex_t stats_mtx  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
pthread_mutex_t work_queue_mtx  =    {{0,
     0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
symdir_t *symhash  =    (symdir_t *)((void *)0);
ssize_t search_buf(char const   *buf ,
                   size_t const   buf_len , char const   *dir_full_path ) 
{ 
  int binary ;
  size_t buf_offset ;
  size_t matches_len ;
  match_t *matches ;
  size_t matches_size ;
  size_t matches_spare ;
  void *tmp ;
  void *tmp___0 ;
  char const   *match_ptr ;
  char const   *start ;
  char const   *end ;
  int tmp___1 ;
  int tmp___2 ;
  int offset_vector[3] ;
  int tmp___3 ;
  char const   *line ;
  size_t line_len ;
  ssize_t tmp___4 ;
  size_t line_offset ;
  int rv ;
  int tmp___5 ;
  size_t line_to_buf ;

  {
  binary = -1;
  buf_offset = (size_t )0;
  if (opts.search_stream) {
    binary = 0;
  } else
  if (! opts.search_binary_files) {
    if (opts.mmap) {
      binary = is_binary((void const   *)buf, buf_len);
      if (binary) {
        log_debug("File %s is binary. Skipping...", dir_full_path);
        return ((ssize_t )-1);
      }
    }
  }
  matches_len = (size_t )0;
  if (opts.invert_match) {
    matches_size = (size_t )100;
    tmp = ag_malloc(matches_size * sizeof(match_t ));
    matches = (match_t *)tmp;
    matches_spare = (size_t )1;
  } else {
    matches_size = (size_t )0;
    matches = (match_t *)((void *)0);
    matches_spare = (size_t )0;
  }
  if (! opts.literal) {
    if (opts.query_len == 1) {
      if ((int )*(opts.query + 0) == 46) {
        matches_size = (size_t )1;
        if ((unsigned long )matches == (unsigned long )((void *)0)) {
          tmp___0 = ag_malloc(matches_size * sizeof(match_t ));
          matches = (match_t *)tmp___0;
        } else {
          matches = matches;
        }
        (matches + 0)->start = (size_t )0;
        (matches + 0)->end = (size_t )buf_len;
        matches_len = (size_t )1;
      } else {
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
  if (opts.literal) {
    match_ptr = buf;
    while (buf_offset < (size_t )buf_len) {
      if ((size_t )opts.query_len < 2UL * sizeof(uint16_t ) - 1UL) {
        match_ptr = boyer_moore_strnstr(match_ptr, (char const   *)opts.query, buf_len - (size_t const   )buf_offset,
                                        (size_t const   )opts.query_len, (size_t const   *)(alpha_skip_lookup),
                                        (size_t const   *)find_skip_lookup, (int const   )((unsigned int )opts.casing == 2U));
      } else
      if (opts.query_len >= 255) {
        match_ptr = boyer_moore_strnstr(match_ptr, (char const   *)opts.query, buf_len - (size_t const   )buf_offset,
                                        (size_t const   )opts.query_len, (size_t const   *)(alpha_skip_lookup),
                                        (size_t const   *)find_skip_lookup, (int const   )((unsigned int )opts.casing == 2U));
      } else {
        match_ptr = (char const   *)hash_strnstr(match_ptr, (char const   *)opts.query,
                                                 buf_len - (size_t const   )buf_offset,
                                                 (size_t const   )opts.query_len,
                                                 h_table, (int const   )((unsigned int )opts.casing == 1U));
      }
      if ((unsigned long )match_ptr == (unsigned long )((void *)0)) {
        break;
      }
      if (opts.word_regexp) {
        start = match_ptr;
        end = match_ptr + opts.query_len;
        if ((unsigned long )start == (unsigned long )buf) {
          goto _L;
        } else {
          tmp___1 = is_wordchar((char )*(start - 1));
          if (tmp___1 != opts.literal_starts_wordchar) {
            _L: /* CIL Label */ 
            if (! ((unsigned long )end == (unsigned long )(buf + buf_len))) {
              tmp___2 = is_wordchar((char )*end);
              if (! (tmp___2 != opts.literal_ends_wordchar)) {
                match_ptr += (*(find_skip_lookup + 0) - (size_t )opts.query_len) + 1UL;
                buf_offset = (size_t )(match_ptr - buf);
                continue;
              }
            }
          } else {
            match_ptr += (*(find_skip_lookup + 0) - (size_t )opts.query_len) + 1UL;
            buf_offset = (size_t )(match_ptr - buf);
            continue;
          }
        }
      }
      realloc_matches(& matches, & matches_size, matches_len + matches_spare);
      (matches + matches_len)->start = (size_t )(match_ptr - buf);
      (matches + matches_len)->end = (matches + matches_len)->start + (size_t )opts.query_len;
      buf_offset = (matches + matches_len)->end;
      log_debug("Match found. File %s, offset %lu bytes.", dir_full_path, (matches + matches_len)->start);
      matches_len ++;
      match_ptr += opts.query_len;
      if (opts.max_matches_per_file > 0UL) {
        if (matches_len >= opts.max_matches_per_file) {
          log_err("Too many matches in %s. Skipping the rest of this file.", dir_full_path);
          break;
        }
      }
    }
  } else
  if (opts.multiline) {
    while (1) {
      if (buf_offset < (size_t )buf_len) {
        tmp___3 = pcre_exec((pcre const   *)opts.re, (pcre_extra const   *)opts.re_extra,
                            buf, (int )buf_len, (int )buf_offset, 0, offset_vector,
                            3);
        if (! (tmp___3 >= 0)) {
          break;
        }
      } else {
        break;
      }
      log_debug("Regex match found. File %s, offset %i bytes.", dir_full_path, offset_vector[0]);
      buf_offset = (size_t )offset_vector[1];
      if (offset_vector[0] == offset_vector[1]) {
        buf_offset ++;
        log_debug("Regex match is of length zero. Advancing offset one byte.");
      }
      realloc_matches(& matches, & matches_size, matches_len + matches_spare);
      (matches + matches_len)->start = (size_t )offset_vector[0];
      (matches + matches_len)->end = (size_t )offset_vector[1];
      matches_len ++;
      if (opts.max_matches_per_file > 0UL) {
        if (matches_len >= opts.max_matches_per_file) {
          log_err("Too many matches in %s. Skipping the rest of this file.", dir_full_path);
          break;
        }
      }
    }
  } else {
    while (buf_offset < (size_t )buf_len) {
      tmp___4 = buf_getline(& line, buf, buf_len, (size_t const   )buf_offset);
      line_len = (size_t )tmp___4;
      if (! line) {
        break;
      }
      line_offset = (size_t )0;
      while (line_offset < line_len) {
        tmp___5 = pcre_exec((pcre const   *)opts.re, (pcre_extra const   *)opts.re_extra,
                            line, (int )line_len, (int )line_offset, 0, offset_vector,
                            3);
        rv = tmp___5;
        if (rv < 0) {
          break;
        }
        line_to_buf = buf_offset + line_offset;
        log_debug("Regex match found. File %s, offset %i bytes.", dir_full_path, offset_vector[0]);
        line_offset = (size_t )offset_vector[1];
        if (offset_vector[0] == offset_vector[1]) {
          line_offset ++;
          log_debug("Regex match is of length zero. Advancing offset one byte.");
        }
        realloc_matches(& matches, & matches_size, matches_len + matches_spare);
        (matches + matches_len)->start = (size_t )offset_vector[0] + line_to_buf;
        (matches + matches_len)->end = (size_t )offset_vector[1] + line_to_buf;
        matches_len ++;
        if (opts.max_matches_per_file > 0UL) {
          if (matches_len >= opts.max_matches_per_file) {
            log_err("Too many matches in %s. Skipping the rest of this file.", dir_full_path);
            goto multiline_done;
          }
        }
      }
      buf_offset += line_len + 1UL;
    }
  }
  multiline_done: 
  if (opts.invert_match) {
    matches_len = invert_matches(buf, buf_len, matches, matches_len);
  }
  if (opts.stats) {
    pthread_mutex_lock(& stats_mtx);
    stats.total_bytes += (size_t )buf_len;
    (stats.total_files) ++;
    stats.total_matches += matches_len;
    if (matches_len > 0UL) {
      (stats.total_file_matches) ++;
    }
    pthread_mutex_unlock(& stats_mtx);
  }
  if (! opts.print_nonmatching_files) {
    if (matches_len > 0UL) {
      goto _L___3;
    } else
    if (opts.print_all_paths) {
      _L___3: /* CIL Label */ 
      if (binary == -1) {
        if (! opts.print_filename_only) {
          binary = is_binary((void const   *)buf, buf_len);
        }
      }
      pthread_mutex_lock(& print_mtx);
      if (opts.print_filename_only) {
        if (opts.print_count) {
          print_path_count(dir_full_path, (char const   )opts.path_sep, (size_t const   )matches_len);
        } else {
          print_path(dir_full_path, (char const   )opts.path_sep);
        }
      } else
      if (binary) {
        print_binary_file_matches(dir_full_path);
      } else {
        print_file_matches(dir_full_path, buf, buf_len, (match_t const   *)matches,
                           (size_t const   )matches_len);
      }
      pthread_mutex_unlock(& print_mtx);
      opts.match_found = 1;
    } else {
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
  if (opts.search_stream) {
    if (opts.passthrough) {
      fprintf((FILE * __restrict  )out_fd, (char const   * __restrict  )"%s", buf);
    } else {
      log_debug("No match in %s", dir_full_path);
    }
  } else {
    log_debug("No match in %s", dir_full_path);
  }
  if (matches_len == 0UL) {
    if (opts.search_stream) {
      print_context_append(buf, (size_t )(buf_len - 1UL));
    }
  }
  if (matches_size > 0UL) {
    free((void *)matches);
  }
  return ((ssize_t )matches_len);
}
}
ssize_t search_stream(FILE *stream , char const   *path ) 
{ 
  char *line ;
  ssize_t matches_count ;
  ssize_t line_len ;
  size_t line_cap ;
  size_t i ;
  ssize_t result ;

  {
  line = (char *)((void *)0);
  matches_count = (ssize_t )0;
  line_len = (ssize_t )0;
  line_cap = (size_t )0;
  print_init_context();
  i = (size_t )1;
  while (1) {
    line_len = getline((char ** __restrict  )(& line), (size_t * __restrict  )(& line_cap),
                       (FILE * __restrict  )stream);
    if (! (line_len > 0L)) {
      break;
    }
    opts.stream_line_num = i;
    result = search_buf((char const   *)line, (size_t const   )line_len, path);
    if (result > 0L) {
      if (matches_count == -1L) {
        matches_count = (ssize_t )0;
      }
      matches_count += result;
    } else
    if (matches_count <= 0L) {
      if (result == -1L) {
        matches_count = (ssize_t )-1;
      }
    }
    if ((int )*(line + (line_len - 1L)) == 10) {
      line_len --;
    }
    print_trailing_context(path, (char const   *)line, (size_t )line_len);
    i ++;
  }
  free((void *)line);
  print_cleanup_context();
  return (matches_count);
}
}
void search_file(char const   *file_full_path ) 
{ 
  int fd ;
  off_t f_len ;
  char *buf ;
  struct stat statbuf ;
  int rv ;
  int matches_count ;
  FILE *fp ;
  int *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  void *tmp___6 ;
  ssize_t bytes_read ;
  size_t tmp___7 ;
  ssize_t tmp___8 ;
  int tmp___9 ;
  ssize_t tmp___10 ;
  ag_compression_type zip_type ;
  ag_compression_type tmp___11 ;
  ssize_t tmp___12 ;
  ssize_t tmp___13 ;

  {
  fd = -1;
  f_len = (off_t )0;
  buf = (char *)((void *)0);
  rv = 0;
  matches_count = -1;
  fp = (FILE *)((void *)0);
  rv = stat((char const   * __restrict  )file_full_path, (struct stat * __restrict  )(& statbuf));
  if (rv != 0) {
    log_err("Skipping %s: Error fstat()ing file.", file_full_path);
    goto cleanup;
  }
  if (opts.stdout_inode != 0UL) {
    if (opts.stdout_inode == statbuf.st_ino) {
      log_debug("Skipping %s: stdout is redirected to it", file_full_path);
      goto cleanup;
    }
  }
  if (! ((statbuf.st_mode & 61440U) == 32768U)) {
    if (! ((statbuf.st_mode & 61440U) == 4096U)) {
      log_err("Skipping %s: Mode %u is not a file.", file_full_path, statbuf.st_mode);
      goto cleanup;
    }
  }
  fd = open(file_full_path, 0);
  if (fd < 0) {
    tmp = __errno_location();
    tmp___0 = strerror(*tmp);
    log_err("Skipping %s: Error opening file: %s", file_full_path, tmp___0);
    goto cleanup;
  }
  rv = fstat(fd, & statbuf);
  if (rv != 0) {
    log_err("Skipping %s: Error fstat()ing file.", file_full_path);
    goto cleanup;
  }
  if (opts.stdout_inode != 0UL) {
    if (opts.stdout_inode == statbuf.st_ino) {
      log_debug("Skipping %s: stdout is redirected to it", file_full_path);
      goto cleanup;
    }
  }
  if (! ((statbuf.st_mode & 61440U) == 32768U)) {
    if (! ((statbuf.st_mode & 61440U) == 4096U)) {
      log_err("Skipping %s: Mode %u is not a file.", file_full_path, statbuf.st_mode);
      goto cleanup;
    }
  }
  print_init_context();
  if (statbuf.st_mode & 4096U) {
    log_debug("%s is a named pipe. stream searching", file_full_path);
    fp = fdopen(fd, "r");
    tmp___1 = search_stream(fp, file_full_path);
    matches_count = (int )tmp___1;
    fclose(fp);
    goto cleanup;
  }
  f_len = statbuf.st_size;
  if (f_len == 0L) {
    if ((int )*(opts.query + 0) == 46) {
      if (opts.query_len == 1) {
        if (! opts.literal) {
          if (opts.search_all_files) {
            tmp___2 = search_buf((char const   *)buf, (size_t const   )f_len, file_full_path);
            matches_count = (int )tmp___2;
          } else {
            log_debug("Skipping %s: file is empty.", file_full_path);
          }
        } else {
          log_debug("Skipping %s: file is empty.", file_full_path);
        }
      } else {
        log_debug("Skipping %s: file is empty.", file_full_path);
      }
    } else {
      log_debug("Skipping %s: file is empty.", file_full_path);
    }
    goto cleanup;
  }
  if (! opts.literal) {
    if (f_len > 2147483647L) {
      log_err("Skipping %s: pcre_exec() can\'t handle files larger than %i bytes.",
              file_full_path, 2147483647);
      goto cleanup;
    }
  }
  if (opts.mmap) {
    tmp___3 = mmap((void *)0, (size_t )f_len, 1, 2, fd, (__off_t )0);
    buf = (char *)tmp___3;
    if ((unsigned long )buf == (unsigned long )((void *)-1)) {
      tmp___4 = __errno_location();
      tmp___5 = strerror(*tmp___4);
      log_err("File %s failed to load: %s.", file_full_path, tmp___5);
      goto cleanup;
    }
    madvise((void *)buf, (size_t )f_len, 2);
  } else {
    tmp___6 = ag_malloc((size_t )f_len);
    buf = (char *)tmp___6;
    bytes_read = (ssize_t )0;
    if (! opts.search_binary_files) {
      tmp___7 = ag_min((size_t )f_len, (size_t )512);
      tmp___8 = read(fd, (void *)buf, tmp___7);
      bytes_read += tmp___8;
      tmp___9 = is_binary((void const   *)buf, (size_t const   )f_len);
      if (tmp___9) {
        log_debug("File %s is binary. Skipping...", file_full_path);
        goto cleanup;
      }
    }
    while (bytes_read < f_len) {
      tmp___10 = read(fd, (void *)(buf + bytes_read), (size_t )f_len);
      bytes_read += tmp___10;
    }
    if (bytes_read != f_len) {
      die("File %s read(): expected to read %u bytes but read %u", file_full_path,
          f_len, bytes_read);
    }
  }
  if (opts.search_zip_files) {
    tmp___11 = is_zipped((void const   *)buf, (int const   )f_len);
    zip_type = tmp___11;
    if ((unsigned int )zip_type != 0U) {
      log_debug("%s is a compressed file. stream searching", file_full_path);
      fp = decompress_open(fd, "r", zip_type);
      tmp___12 = search_stream(fp, file_full_path);
      matches_count = (int )tmp___12;
      fclose(fp);
      goto cleanup;
    }
  }
  tmp___13 = search_buf((char const   *)buf, (size_t const   )f_len, file_full_path);
  matches_count = (int )tmp___13;
  cleanup: 
  if (opts.print_nonmatching_files) {
    if (matches_count == 0) {
      pthread_mutex_lock(& print_mtx);
      print_path(file_full_path, (char const   )opts.path_sep);
      pthread_mutex_unlock(& print_mtx);
      opts.match_found = 1;
    }
  }
  print_cleanup_context();
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
    if (opts.mmap) {
      if ((unsigned long )buf != (unsigned long )((void *)-1)) {
        munmap((void *)buf, (size_t )f_len);
      }
    } else {
      free((void *)buf);
    }
  }
  if (fd != -1) {
    close(fd);
  }
  return;
}
}
void *search_file_worker(void *i ) 
{ 
  work_queue_t *queue_item ;
  int worker_id ;

  {
  worker_id = *((int *)i);
  log_debug("Worker %i started", worker_id);
  while (1) {
    pthread_mutex_lock(& work_queue_mtx);
    while ((unsigned long )work_queue == (unsigned long )((void *)0)) {
      if (done_adding_files) {
        pthread_mutex_unlock(& work_queue_mtx);
        log_debug("Worker %i finished.", worker_id);
        pthread_exit((void *)0);
      }
      pthread_cond_wait((pthread_cond_t * __restrict  )(& files_ready), (pthread_mutex_t * __restrict  )(& work_queue_mtx));
    }
    queue_item = work_queue;
    work_queue = work_queue->next;
    if ((unsigned long )work_queue == (unsigned long )((void *)0)) {
      work_queue_tail = (work_queue_t *)((void *)0);
    }
    pthread_mutex_unlock(& work_queue_mtx);
    search_file((char const   *)queue_item->path);
    free((void *)queue_item->path);
    free((void *)queue_item);
  }
}
}
static int check_symloop_enter(char const   *path , dirkey_t *outkey ) 
{ 
  struct stat buf ;
  symdir_t *item_found ;
  symdir_t *new_item ;
  int res ;
  int tmp ;
  unsigned int _hf_bkt ;
  unsigned int _hf_hashv ;
  unsigned int _hj_i ;
  unsigned int _hj_j ;
  unsigned int _hj_k ;
  unsigned char *_hj_key ;
  int tmp___0 ;
  void *tmp___1 ;
  unsigned int _ha_bkt ;
  void *tmp___2 ;
  void *tmp___3 ;
  unsigned int _hj_i___0 ;
  unsigned int _hj_j___0 ;
  unsigned int _hj_k___0 ;
  unsigned char *_hj_key___0 ;
  unsigned int _he_bkt ;
  unsigned int _he_bkt_i ;
  struct UT_hash_handle *_he_thh ;
  struct UT_hash_handle *_he_hh_nxt ;
  UT_hash_bucket *_he_new_buckets ;
  UT_hash_bucket *_he_newbkt ;
  void *tmp___4 ;
  int tmp___5 ;

  {
  item_found = (symdir_t *)((void *)0);
  new_item = (symdir_t *)((void *)0);
  memset((void *)outkey, 0, sizeof(dirkey_t ));
  outkey->dev = (dev_t )0;
  outkey->ino = (ino_t )0;
  tmp = stat((char const   * __restrict  )path, (struct stat * __restrict  )(& buf));
  res = tmp;
  if (res != 0) {
    log_err("Error stat()ing: %s", path);
    return (-1);
  }
  outkey->dev = buf.st_dev;
  outkey->ino = buf.st_ino;
  while (1) {
    item_found = (symdir_t *)((void *)0);
    if (symhash) {
      while (1) {
        _hj_key = (unsigned char *)outkey;
        _hf_hashv = 4276993775U;
        _hj_j = 2654435769U;
        _hj_i = _hj_j;
        _hj_k = (unsigned int )sizeof(dirkey_t );
        while (_hj_k >= 12U) {
          _hj_i += (((unsigned int )*(_hj_key + 0) + ((unsigned int )*(_hj_key + 1) << 8)) + ((unsigned int )*(_hj_key + 2) << 16)) + ((unsigned int )*(_hj_key + 3) << 24);
          _hj_j += (((unsigned int )*(_hj_key + 4) + ((unsigned int )*(_hj_key + 5) << 8)) + ((unsigned int )*(_hj_key + 6) << 16)) + ((unsigned int )*(_hj_key + 7) << 24);
          _hf_hashv += (((unsigned int )*(_hj_key + 8) + ((unsigned int )*(_hj_key + 9) << 8)) + ((unsigned int )*(_hj_key + 10) << 16)) + ((unsigned int )*(_hj_key + 11) << 24);
          while (1) {
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 13;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 8;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 13;
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 12;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 16;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 5;
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 3;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 10;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 15;
            break;
          }
          _hj_key += 12;
          _hj_k -= 12U;
        }
        _hf_hashv = (unsigned int )((unsigned long )_hf_hashv + sizeof(dirkey_t ));
        switch (_hj_k) {
        case 11U: 
        _hf_hashv += (unsigned int )*(_hj_key + 10) << 24;
        case 10U: 
        _hf_hashv += (unsigned int )*(_hj_key + 9) << 16;
        case 9U: 
        _hf_hashv += (unsigned int )*(_hj_key + 8) << 8;
        case 8U: 
        _hj_j += (unsigned int )*(_hj_key + 7) << 24;
        case 7U: 
        _hj_j += (unsigned int )*(_hj_key + 6) << 16;
        case 6U: 
        _hj_j += (unsigned int )*(_hj_key + 5) << 8;
        case 5U: 
        _hj_j += (unsigned int )*(_hj_key + 4);
        case 4U: 
        _hj_i += (unsigned int )*(_hj_key + 3) << 24;
        case 3U: 
        _hj_i += (unsigned int )*(_hj_key + 2) << 16;
        case 2U: 
        _hj_i += (unsigned int )*(_hj_key + 1) << 8;
        case 1U: 
        _hj_i += (unsigned int )*(_hj_key + 0);
        }
        while (1) {
          _hj_i -= _hj_j;
          _hj_i -= _hf_hashv;
          _hj_i ^= _hf_hashv >> 13;
          _hj_j -= _hf_hashv;
          _hj_j -= _hj_i;
          _hj_j ^= _hj_i << 8;
          _hf_hashv -= _hj_i;
          _hf_hashv -= _hj_j;
          _hf_hashv ^= _hj_j >> 13;
          _hj_i -= _hj_j;
          _hj_i -= _hf_hashv;
          _hj_i ^= _hf_hashv >> 12;
          _hj_j -= _hf_hashv;
          _hj_j -= _hj_i;
          _hj_j ^= _hj_i << 16;
          _hf_hashv -= _hj_i;
          _hf_hashv -= _hj_j;
          _hf_hashv ^= _hj_j >> 5;
          _hj_i -= _hj_j;
          _hj_i -= _hf_hashv;
          _hj_i ^= _hf_hashv >> 3;
          _hj_j -= _hf_hashv;
          _hj_j -= _hj_i;
          _hj_j ^= _hj_i << 10;
          _hf_hashv -= _hj_i;
          _hf_hashv -= _hj_j;
          _hf_hashv ^= _hj_j >> 15;
          break;
        }
        _hf_bkt = _hf_hashv & ((symhash->hh.tbl)->num_buckets - 1U);
        break;
      }
      while (1) {
        if (((symhash->hh.tbl)->buckets + _hf_bkt)->hh_head) {
          while (1) {
            item_found = (symdir_t *)((void *)((char *)((symhash->hh.tbl)->buckets + _hf_bkt)->hh_head - (symhash->hh.tbl)->hho));
            break;
          }
        } else {
          item_found = (symdir_t *)((void *)0);
        }
        while (item_found) {
          if ((unsigned long )item_found->hh.keylen == sizeof(dirkey_t )) {
            tmp___0 = memcmp((void const   *)item_found->hh.key, (void const   *)outkey,
                             sizeof(dirkey_t ));
            if (tmp___0 == 0) {
              break;
            }
          }
          if (item_found->hh.hh_next) {
            while (1) {
              item_found = (symdir_t *)((void *)((char *)item_found->hh.hh_next - (symhash->hh.tbl)->hho));
              break;
            }
          } else {
            item_found = (symdir_t *)((void *)0);
          }
        }
        break;
      }
    }
    break;
  }
  if (item_found) {
    return (1);
  }
  tmp___1 = ag_malloc(sizeof(symdir_t ));
  new_item = (symdir_t *)tmp___1;
  memcpy((void * __restrict  )(& new_item->key), (void const   * __restrict  )outkey,
         sizeof(dirkey_t ));
  while (1) {
    new_item->hh.next = (void *)0;
    new_item->hh.key = (void *)((char *)(& new_item->key));
    new_item->hh.keylen = (unsigned int )sizeof(dirkey_t );
    if (! symhash) {
      symhash = new_item;
      symhash->hh.prev = (void *)0;
      while (1) {
        tmp___2 = malloc(sizeof(UT_hash_table ));
        symhash->hh.tbl = (UT_hash_table *)tmp___2;
        if (! symhash->hh.tbl) {
          exit(-1);
        }
        memset((void *)symhash->hh.tbl, 0, sizeof(UT_hash_table ));
        (symhash->hh.tbl)->tail = & symhash->hh;
        (symhash->hh.tbl)->num_buckets = 32U;
        (symhash->hh.tbl)->log2_num_buckets = 5U;
        (symhash->hh.tbl)->hho = (char *)(& symhash->hh) - (char *)symhash;
        tmp___3 = malloc(32UL * sizeof(struct UT_hash_bucket ));
        (symhash->hh.tbl)->buckets = (UT_hash_bucket *)tmp___3;
        if (! (symhash->hh.tbl)->buckets) {
          exit(-1);
        }
        memset((void *)(symhash->hh.tbl)->buckets, 0, 32UL * sizeof(struct UT_hash_bucket ));
        (symhash->hh.tbl)->signature = 2685476833U;
        break;
      }
    } else {
      ((symhash->hh.tbl)->tail)->next = (void *)new_item;
      new_item->hh.prev = (void *)((char *)(symhash->hh.tbl)->tail - (symhash->hh.tbl)->hho);
      (symhash->hh.tbl)->tail = & new_item->hh;
    }
    ((symhash->hh.tbl)->num_items) ++;
    new_item->hh.tbl = symhash->hh.tbl;
    while (1) {
      _hj_key___0 = (unsigned char *)(& new_item->key);
      new_item->hh.hashv = 4276993775U;
      _hj_j___0 = 2654435769U;
      _hj_i___0 = _hj_j___0;
      _hj_k___0 = (unsigned int )sizeof(dirkey_t );
      while (_hj_k___0 >= 12U) {
        _hj_i___0 += (((unsigned int )*(_hj_key___0 + 0) + ((unsigned int )*(_hj_key___0 + 1) << 8)) + ((unsigned int )*(_hj_key___0 + 2) << 16)) + ((unsigned int )*(_hj_key___0 + 3) << 24);
        _hj_j___0 += (((unsigned int )*(_hj_key___0 + 4) + ((unsigned int )*(_hj_key___0 + 5) << 8)) + ((unsigned int )*(_hj_key___0 + 6) << 16)) + ((unsigned int )*(_hj_key___0 + 7) << 24);
        new_item->hh.hashv += (((unsigned int )*(_hj_key___0 + 8) + ((unsigned int )*(_hj_key___0 + 9) << 8)) + ((unsigned int )*(_hj_key___0 + 10) << 16)) + ((unsigned int )*(_hj_key___0 + 11) << 24);
        while (1) {
          _hj_i___0 -= _hj_j___0;
          _hj_i___0 -= new_item->hh.hashv;
          _hj_i___0 ^= new_item->hh.hashv >> 13;
          _hj_j___0 -= new_item->hh.hashv;
          _hj_j___0 -= _hj_i___0;
          _hj_j___0 ^= _hj_i___0 << 8;
          new_item->hh.hashv -= _hj_i___0;
          new_item->hh.hashv -= _hj_j___0;
          new_item->hh.hashv ^= _hj_j___0 >> 13;
          _hj_i___0 -= _hj_j___0;
          _hj_i___0 -= new_item->hh.hashv;
          _hj_i___0 ^= new_item->hh.hashv >> 12;
          _hj_j___0 -= new_item->hh.hashv;
          _hj_j___0 -= _hj_i___0;
          _hj_j___0 ^= _hj_i___0 << 16;
          new_item->hh.hashv -= _hj_i___0;
          new_item->hh.hashv -= _hj_j___0;
          new_item->hh.hashv ^= _hj_j___0 >> 5;
          _hj_i___0 -= _hj_j___0;
          _hj_i___0 -= new_item->hh.hashv;
          _hj_i___0 ^= new_item->hh.hashv >> 3;
          _hj_j___0 -= new_item->hh.hashv;
          _hj_j___0 -= _hj_i___0;
          _hj_j___0 ^= _hj_i___0 << 10;
          new_item->hh.hashv -= _hj_i___0;
          new_item->hh.hashv -= _hj_j___0;
          new_item->hh.hashv ^= _hj_j___0 >> 15;
          break;
        }
        _hj_key___0 += 12;
        _hj_k___0 -= 12U;
      }
      new_item->hh.hashv = (unsigned int )((unsigned long )new_item->hh.hashv + sizeof(dirkey_t ));
      switch (_hj_k___0) {
      case 11U: 
      new_item->hh.hashv += (unsigned int )*(_hj_key___0 + 10) << 24;
      case 10U: 
      new_item->hh.hashv += (unsigned int )*(_hj_key___0 + 9) << 16;
      case 9U: 
      new_item->hh.hashv += (unsigned int )*(_hj_key___0 + 8) << 8;
      case 8U: 
      _hj_j___0 += (unsigned int )*(_hj_key___0 + 7) << 24;
      case 7U: 
      _hj_j___0 += (unsigned int )*(_hj_key___0 + 6) << 16;
      case 6U: 
      _hj_j___0 += (unsigned int )*(_hj_key___0 + 5) << 8;
      case 5U: 
      _hj_j___0 += (unsigned int )*(_hj_key___0 + 4);
      case 4U: 
      _hj_i___0 += (unsigned int )*(_hj_key___0 + 3) << 24;
      case 3U: 
      _hj_i___0 += (unsigned int )*(_hj_key___0 + 2) << 16;
      case 2U: 
      _hj_i___0 += (unsigned int )*(_hj_key___0 + 1) << 8;
      case 1U: 
      _hj_i___0 += (unsigned int )*(_hj_key___0 + 0);
      }
      while (1) {
        _hj_i___0 -= _hj_j___0;
        _hj_i___0 -= new_item->hh.hashv;
        _hj_i___0 ^= new_item->hh.hashv >> 13;
        _hj_j___0 -= new_item->hh.hashv;
        _hj_j___0 -= _hj_i___0;
        _hj_j___0 ^= _hj_i___0 << 8;
        new_item->hh.hashv -= _hj_i___0;
        new_item->hh.hashv -= _hj_j___0;
        new_item->hh.hashv ^= _hj_j___0 >> 13;
        _hj_i___0 -= _hj_j___0;
        _hj_i___0 -= new_item->hh.hashv;
        _hj_i___0 ^= new_item->hh.hashv >> 12;
        _hj_j___0 -= new_item->hh.hashv;
        _hj_j___0 -= _hj_i___0;
        _hj_j___0 ^= _hj_i___0 << 16;
        new_item->hh.hashv -= _hj_i___0;
        new_item->hh.hashv -= _hj_j___0;
        new_item->hh.hashv ^= _hj_j___0 >> 5;
        _hj_i___0 -= _hj_j___0;
        _hj_i___0 -= new_item->hh.hashv;
        _hj_i___0 ^= new_item->hh.hashv >> 3;
        _hj_j___0 -= new_item->hh.hashv;
        _hj_j___0 -= _hj_i___0;
        _hj_j___0 ^= _hj_i___0 << 10;
        new_item->hh.hashv -= _hj_i___0;
        new_item->hh.hashv -= _hj_j___0;
        new_item->hh.hashv ^= _hj_j___0 >> 15;
        break;
      }
      _ha_bkt = new_item->hh.hashv & ((symhash->hh.tbl)->num_buckets - 1U);
      break;
    }
    while (1) {
      (((symhash->hh.tbl)->buckets + _ha_bkt)->count) ++;
      new_item->hh.hh_next = ((symhash->hh.tbl)->buckets + _ha_bkt)->hh_head;
      new_item->hh.hh_prev = (struct UT_hash_handle *)((void *)0);
      if (((symhash->hh.tbl)->buckets + _ha_bkt)->hh_head) {
        (((symhash->hh.tbl)->buckets + _ha_bkt)->hh_head)->hh_prev = & new_item->hh;
      }
      ((symhash->hh.tbl)->buckets + _ha_bkt)->hh_head = & new_item->hh;
      if (((symhash->hh.tbl)->buckets + _ha_bkt)->count >= (((symhash->hh.tbl)->buckets + _ha_bkt)->expand_mult + 1U) * 10U) {
        if ((new_item->hh.tbl)->noexpand != 1U) {
          while (1) {
            tmp___4 = malloc((unsigned long )(2U * (new_item->hh.tbl)->num_buckets) * sizeof(struct UT_hash_bucket ));
            _he_new_buckets = (UT_hash_bucket *)tmp___4;
            if (! _he_new_buckets) {
              exit(-1);
            }
            memset((void *)_he_new_buckets, 0, (unsigned long )(2U * (new_item->hh.tbl)->num_buckets) * sizeof(struct UT_hash_bucket ));
            if ((new_item->hh.tbl)->num_items & ((new_item->hh.tbl)->num_buckets * 2U - 1U)) {
              tmp___5 = 1;
            } else {
              tmp___5 = 0;
            }
            (new_item->hh.tbl)->ideal_chain_maxlen = ((new_item->hh.tbl)->num_items >> ((new_item->hh.tbl)->log2_num_buckets + 1U)) + (unsigned int )tmp___5;
            (new_item->hh.tbl)->nonideal_items = 0U;
            _he_bkt_i = 0U;
            while (_he_bkt_i < (new_item->hh.tbl)->num_buckets) {
              _he_thh = ((new_item->hh.tbl)->buckets + _he_bkt_i)->hh_head;
              while (_he_thh) {
                _he_hh_nxt = _he_thh->hh_next;
                while (1) {
                  _he_bkt = _he_thh->hashv & ((new_item->hh.tbl)->num_buckets * 2U - 1U);
                  break;
                }
                _he_newbkt = _he_new_buckets + _he_bkt;
                (_he_newbkt->count) ++;
                if (_he_newbkt->count > (new_item->hh.tbl)->ideal_chain_maxlen) {
                  ((new_item->hh.tbl)->nonideal_items) ++;
                  _he_newbkt->expand_mult = _he_newbkt->count / (new_item->hh.tbl)->ideal_chain_maxlen;
                }
                _he_thh->hh_prev = (struct UT_hash_handle *)((void *)0);
                _he_thh->hh_next = _he_newbkt->hh_head;
                if (_he_newbkt->hh_head) {
                  (_he_newbkt->hh_head)->hh_prev = _he_thh;
                }
                _he_newbkt->hh_head = _he_thh;
                _he_thh = _he_hh_nxt;
              }
              _he_bkt_i ++;
            }
            free((void *)(new_item->hh.tbl)->buckets);
            (new_item->hh.tbl)->num_buckets *= 2U;
            ((new_item->hh.tbl)->log2_num_buckets) ++;
            (new_item->hh.tbl)->buckets = _he_new_buckets;
            if ((new_item->hh.tbl)->nonideal_items > (new_item->hh.tbl)->num_items >> 1) {
              ((new_item->hh.tbl)->ineff_expands) ++;
            } else {
              (new_item->hh.tbl)->ineff_expands = 0U;
            }
            if ((new_item->hh.tbl)->ineff_expands > 1U) {
              (new_item->hh.tbl)->noexpand = 1U;
            }
            break;
          }
        }
      }
      break;
    }
    break;
  }
  return (0);
}
}
static int check_symloop_leave(dirkey_t *dirkey ) 
{ 
  symdir_t *item_found ;
  unsigned int _hf_bkt ;
  unsigned int _hf_hashv ;
  unsigned int _hj_i ;
  unsigned int _hj_j ;
  unsigned int _hj_k ;
  unsigned char *_hj_key ;
  int tmp ;
  unsigned int _hd_bkt ;
  struct UT_hash_handle *_hd_hh_del ;

  {
  item_found = (symdir_t *)((void *)0);
  if (dirkey->dev == 0UL) {
    if (dirkey->ino == 0UL) {
      return (-1);
    }
  }
  while (1) {
    item_found = (symdir_t *)((void *)0);
    if (symhash) {
      while (1) {
        _hj_key = (unsigned char *)dirkey;
        _hf_hashv = 4276993775U;
        _hj_j = 2654435769U;
        _hj_i = _hj_j;
        _hj_k = (unsigned int )sizeof(dirkey_t );
        while (_hj_k >= 12U) {
          _hj_i += (((unsigned int )*(_hj_key + 0) + ((unsigned int )*(_hj_key + 1) << 8)) + ((unsigned int )*(_hj_key + 2) << 16)) + ((unsigned int )*(_hj_key + 3) << 24);
          _hj_j += (((unsigned int )*(_hj_key + 4) + ((unsigned int )*(_hj_key + 5) << 8)) + ((unsigned int )*(_hj_key + 6) << 16)) + ((unsigned int )*(_hj_key + 7) << 24);
          _hf_hashv += (((unsigned int )*(_hj_key + 8) + ((unsigned int )*(_hj_key + 9) << 8)) + ((unsigned int )*(_hj_key + 10) << 16)) + ((unsigned int )*(_hj_key + 11) << 24);
          while (1) {
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 13;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 8;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 13;
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 12;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 16;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 5;
            _hj_i -= _hj_j;
            _hj_i -= _hf_hashv;
            _hj_i ^= _hf_hashv >> 3;
            _hj_j -= _hf_hashv;
            _hj_j -= _hj_i;
            _hj_j ^= _hj_i << 10;
            _hf_hashv -= _hj_i;
            _hf_hashv -= _hj_j;
            _hf_hashv ^= _hj_j >> 15;
            break;
          }
          _hj_key += 12;
          _hj_k -= 12U;
        }
        _hf_hashv = (unsigned int )((unsigned long )_hf_hashv + sizeof(dirkey_t ));
        switch (_hj_k) {
        case 11U: 
        _hf_hashv += (unsigned int )*(_hj_key + 10) << 24;
        case 10U: 
        _hf_hashv += (unsigned int )*(_hj_key + 9) << 16;
        case 9U: 
        _hf_hashv += (unsigned int )*(_hj_key + 8) << 8;
        case 8U: 
        _hj_j += (unsigned int )*(_hj_key + 7) << 24;
        case 7U: 
        _hj_j += (unsigned int )*(_hj_key + 6) << 16;
        case 6U: 
        _hj_j += (unsigned int )*(_hj_key + 5) << 8;
        case 5U: 
        _hj_j += (unsigned int )*(_hj_key + 4);
        case 4U: 
        _hj_i += (unsigned int )*(_hj_key + 3) << 24;
        case 3U: 
        _hj_i += (unsigned int )*(_hj_key + 2) << 16;
        case 2U: 
        _hj_i += (unsigned int )*(_hj_key + 1) << 8;
        case 1U: 
        _hj_i += (unsigned int )*(_hj_key + 0);
        }
        while (1) {
          _hj_i -= _hj_j;
          _hj_i -= _hf_hashv;
          _hj_i ^= _hf_hashv >> 13;
          _hj_j -= _hf_hashv;
          _hj_j -= _hj_i;
          _hj_j ^= _hj_i << 8;
          _hf_hashv -= _hj_i;
          _hf_hashv -= _hj_j;
          _hf_hashv ^= _hj_j >> 13;
          _hj_i -= _hj_j;
          _hj_i -= _hf_hashv;
          _hj_i ^= _hf_hashv >> 12;
          _hj_j -= _hf_hashv;
          _hj_j -= _hj_i;
          _hj_j ^= _hj_i << 16;
          _hf_hashv -= _hj_i;
          _hf_hashv -= _hj_j;
          _hf_hashv ^= _hj_j >> 5;
          _hj_i -= _hj_j;
          _hj_i -= _hf_hashv;
          _hj_i ^= _hf_hashv >> 3;
          _hj_j -= _hf_hashv;
          _hj_j -= _hj_i;
          _hj_j ^= _hj_i << 10;
          _hf_hashv -= _hj_i;
          _hf_hashv -= _hj_j;
          _hf_hashv ^= _hj_j >> 15;
          break;
        }
        _hf_bkt = _hf_hashv & ((symhash->hh.tbl)->num_buckets - 1U);
        break;
      }
      while (1) {
        if (((symhash->hh.tbl)->buckets + _hf_bkt)->hh_head) {
          while (1) {
            item_found = (symdir_t *)((void *)((char *)((symhash->hh.tbl)->buckets + _hf_bkt)->hh_head - (symhash->hh.tbl)->hho));
            break;
          }
        } else {
          item_found = (symdir_t *)((void *)0);
        }
        while (item_found) {
          if ((unsigned long )item_found->hh.keylen == sizeof(dirkey_t )) {
            tmp = memcmp((void const   *)item_found->hh.key, (void const   *)dirkey,
                         sizeof(dirkey_t ));
            if (tmp == 0) {
              break;
            }
          }
          if (item_found->hh.hh_next) {
            while (1) {
              item_found = (symdir_t *)((void *)((char *)item_found->hh.hh_next - (symhash->hh.tbl)->hho));
              break;
            }
          } else {
            item_found = (symdir_t *)((void *)0);
          }
        }
        break;
      }
    }
    break;
  }
  if (! item_found) {
    log_err("item not found! weird stuff...\n");
    return (-1);
  }
  while (1) {
    if ((unsigned long )item_found->hh.prev == (unsigned long )((void *)0)) {
      if ((unsigned long )item_found->hh.next == (unsigned long )((void *)0)) {
        free((void *)(symhash->hh.tbl)->buckets);
        free((void *)symhash->hh.tbl);
        symhash = (symdir_t *)((void *)0);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      _hd_hh_del = & item_found->hh;
      if ((unsigned long )item_found == (unsigned long )((void *)((char *)(symhash->hh.tbl)->tail - (symhash->hh.tbl)->hho))) {
        (symhash->hh.tbl)->tail = (UT_hash_handle *)((ptrdiff_t )item_found->hh.prev + (symhash->hh.tbl)->hho);
      }
      if (item_found->hh.prev) {
        ((UT_hash_handle *)((ptrdiff_t )item_found->hh.prev + (symhash->hh.tbl)->hho))->next = item_found->hh.next;
      } else {
        while (1) {
          symhash = (symdir_t *)item_found->hh.next;
          break;
        }
      }
      if (_hd_hh_del->next) {
        ((UT_hash_handle *)((ptrdiff_t )_hd_hh_del->next + (symhash->hh.tbl)->hho))->prev = _hd_hh_del->prev;
      }
      while (1) {
        _hd_bkt = _hd_hh_del->hashv & ((symhash->hh.tbl)->num_buckets - 1U);
        break;
      }
      (((symhash->hh.tbl)->buckets + _hd_bkt)->count) --;
      if ((unsigned long )((symhash->hh.tbl)->buckets + _hd_bkt)->hh_head == (unsigned long )_hd_hh_del) {
        ((symhash->hh.tbl)->buckets + _hd_bkt)->hh_head = _hd_hh_del->hh_next;
      }
      if (_hd_hh_del->hh_prev) {
        (_hd_hh_del->hh_prev)->hh_next = _hd_hh_del->hh_next;
      }
      if (_hd_hh_del->hh_next) {
        (_hd_hh_del->hh_next)->hh_prev = _hd_hh_del->hh_prev;
      }
      ((symhash->hh.tbl)->num_items) --;
    }
    break;
  }
  free((void *)item_found);
  return (0);
}
}
void search_dir(ignores *ig , char const   *base_path , char const   *path , int const   depth ,
                dev_t original_dev ) 
{ 
  struct dirent **dir_list ;
  struct dirent *dir ;
  scandir_baton_t scandir_baton ;
  int results ;
  size_t base_path_len ;
  char const   *path_start ;
  char *dir_full_path ;
  char const   *ignore_file ;
  int i ;
  int symres ;
  dirkey_t current_dirkey ;
  int tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int offset_vector[3] ;
  int rc ;
  work_queue_t *queue_item ;
  struct stat s ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  ignores *child_ig ;
  size_t tmp___8 ;
  int tmp___9 ;

  {
  dir_list = (struct dirent **)((void *)0);
  dir = (struct dirent *)((void *)0);
  results = 0;
  base_path_len = (size_t )0;
  path_start = path;
  dir_full_path = (char *)((void *)0);
  ignore_file = (char const   *)((void *)0);
  symres = check_symloop_enter(path, & current_dirkey);
  if (symres == 1) {
    log_err("Recursive directory loop: %s", path);
    return;
  }
  i = 0;
  while (1) {
    if (opts.skip_vcs_ignores) {
      tmp = i == 0;
    } else {
      tmp = (unsigned long )ignore_pattern_files[i] != (unsigned long )((void *)0);
    }
    if (! tmp) {
      break;
    }
    ignore_file = ignore_pattern_files[i];
    ag_asprintf(& dir_full_path, "%s/%s", path, ignore_file);
    load_ignore_patterns(ig, (char const   *)dir_full_path);
    free((void *)dir_full_path);
    dir_full_path = (char *)((void *)0);
    i ++;
  }
  if (base_path) {
    tmp___0 = strlen(base_path);
    base_path_len = tmp___0;
  } else {
    base_path_len = (size_t )0;
  }
  i = 0;
  while (1) {
    if ((size_t )i < base_path_len) {
      if (*(path + i)) {
        if (! ((int const   )*(base_path + i) == (int const   )*(path + i))) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    path_start = (path + i) + 1;
    i ++;
  }
  log_debug("search_dir: path is \'%s\', base_path is \'%s\', path_start is \'%s\'",
            path, base_path, path_start);
  scandir_baton.ig = (ignores const   *)ig;
  scandir_baton.base_path = base_path;
  scandir_baton.base_path_len = base_path_len;
  scandir_baton.path_start = path_start;
  results = ag_scandir(path, & dir_list, & filename_filter, (void *)(& scandir_baton));
  if (results == 0) {
    log_debug("No results found in directory %s", path);
    goto search_dir_cleanup;
  } else
  if (results == -1) {
    tmp___3 = __errno_location();
    if (*tmp___3 == 20) {
      if (depth == 0) {
        if (opts.paths_len == 1) {
          if (opts.print_path == 0) {
            opts.print_path = 4;
          } else
          if (opts.print_path == 1) {
            opts.print_path = 4;
          }
          if (opts.only_matching) {
            if (opts.print_path == 4) {
              opts.print_line_numbers = 0;
            }
          }
        }
      }
      search_file(path);
    } else {
      tmp___1 = __errno_location();
      tmp___2 = strerror(*tmp___1);
      log_err("Error opening directory %s: %s", path, tmp___2);
    }
    goto search_dir_cleanup;
  }
  rc = 0;
  i = 0;
  while (i < results) {
    queue_item = (work_queue_t *)((void *)0);
    dir = *(dir_list + i);
    ag_asprintf(& dir_full_path, "%s/%s", path, dir->d_name);
    if (opts.one_dev) {
      tmp___4 = lstat((char const   * __restrict  )dir_full_path, (struct stat * __restrict  )(& s));
      if (tmp___4 != 0) {
        log_err("Failed to get device information for %s. Skipping...", dir->d_name);
        goto cleanup;
      }
      if (s.st_dev != original_dev) {
        log_debug("File %s crosses a device boundary (is probably a mount point.) Skipping...",
                  dir->d_name);
        goto cleanup;
      }
    }
    if (! opts.follow_symlinks) {
      tmp___5 = is_symlink(path, (struct dirent  const  *)dir);
      if (tmp___5) {
        log_debug("File %s ignored becaused it\'s a symlink", dir->d_name);
        goto cleanup;
      }
    }
    tmp___9 = is_directory(path, (struct dirent  const  *)dir);
    if (tmp___9) {
      if (opts.recurse_dirs) {
        if (depth < (int const   )opts.max_search_depth) {
          log_debug("Searching dir %s", dir_full_path);
          tmp___8 = strlen((char const   *)(dir->d_name));
          child_ig = init_ignore(ig, (char const   *)(dir->d_name), (size_t const   )tmp___8);
          search_dir(child_ig, base_path, (char const   *)dir_full_path, depth + 1,
                     original_dev);
          cleanup_ignore(child_ig);
        } else
        if (opts.max_search_depth == -1) {
          log_debug("Searching dir %s", dir_full_path);
          tmp___8 = strlen((char const   *)(dir->d_name));
          child_ig = init_ignore(ig, (char const   *)(dir->d_name), (size_t const   )tmp___8);
          search_dir(child_ig, base_path, (char const   *)dir_full_path, depth + 1,
                     original_dev);
          cleanup_ignore(child_ig);
        } else
        if (opts.max_search_depth == 25) {
          log_err("Skipping %s. Use the --depth option to search deeper.", dir_full_path);
        } else {
          log_debug("Skipping %s. Use the --depth option to search deeper.", dir_full_path);
        }
      }
    } else {
      if (opts.file_search_regex) {
        tmp___6 = strlen((char const   *)dir_full_path);
        rc = pcre_exec((pcre const   *)opts.file_search_regex, (pcre_extra const   *)((void *)0),
                       (char const   *)dir_full_path, (int )tmp___6, 0, 0, offset_vector,
                       3);
        if (rc < 0) {
          log_debug("Skipping %s due to file_search_regex.", dir_full_path);
          goto cleanup;
        } else
        if (opts.match_files) {
          log_debug("match_files: file_search_regex matched for %s.", dir_full_path);
          pthread_mutex_lock(& print_mtx);
          print_path((char const   *)dir_full_path, (char const   )opts.path_sep);
          pthread_mutex_unlock(& print_mtx);
          opts.match_found = 1;
          goto cleanup;
        }
      }
      tmp___7 = ag_malloc(sizeof(work_queue_t ));
      queue_item = (work_queue_t *)tmp___7;
      queue_item->path = dir_full_path;
      queue_item->next = (struct work_queue_t *)((void *)0);
      pthread_mutex_lock(& work_queue_mtx);
      if ((unsigned long )work_queue_tail == (unsigned long )((void *)0)) {
        work_queue = queue_item;
      } else {
        work_queue_tail->next = queue_item;
      }
      work_queue_tail = queue_item;
      pthread_cond_signal(& files_ready);
      pthread_mutex_unlock(& work_queue_mtx);
      log_debug("%s added to work queue", dir_full_path);
    }
    cleanup: 
    free((void *)dir);
    dir = (struct dirent *)((void *)0);
    if ((unsigned long )queue_item == (unsigned long )((void *)0)) {
      free((void *)dir_full_path);
      dir_full_path = (char *)((void *)0);
    }
    i ++;
  }
  search_dir_cleanup: 
  check_symloop_leave(& current_dirkey);
  free((void *)dir_list);
  dir_list = (struct dirent **)((void *)0);
  return;
}
}
#pragma merger("0","/tmp/cil-tIhAL0io.i","-g,-O2,-pthread,-Wall,-Wextra,-Wformat=2,-Wno-format-nonliteral,-Wshadow,-Wpointer-arith,-Wcast-qual,-Wmissing-prototypes,-Wno-missing-braces,-std=gnu89")
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
lang_spec_t langs[138]  = 
  {      {"actionscript", {"as", "mxml"}}, 
        {"ada", {"ada", "adb", "ads"}}, 
        {"asciidoc", {"adoc", "ad", "asc", "asciidoc"}}, 
        {"apl", {"apl"}}, 
        {"asm", {"asm", "s"}}, 
        {"asp", {"asp", "asa", "aspx", "asax", "ashx", "ascx", "asmx"}}, 
        {"aspx", {"asp", "asa", "aspx", "asax", "ashx", "ascx", "asmx"}}, 
        {"batch", {"bat", "cmd"}}, 
        {"bazel", {"bazel"}}, 
        {"bitbake", {"bb", "bbappend", "bbclass", "inc"}}, 
        {"cc", {"c", "h", "xs"}}, 
        {"cfmx", {"cfc", "cfm", "cfml"}}, 
        {"chpl", {"chpl"}}, 
        {"clojure", {"clj", "cljs", "cljc", "cljx", "edn"}}, 
        {"coffee", {"coffee", "cjsx"}}, 
        {"config", {"config"}}, 
        {"coq", {"coq", "g", "v"}}, 
        {"cpp", {"cpp", "cc", "C", "cxx", "m", "hpp", "hh", "h", "H", "hxx", "tpp"}}, 
        {"crystal",
      {"cr", "ecr"}}, 
        {"csharp", {"cs"}}, 
        {"cshtml", {"cshtml"}}, 
        {"css", {"css"}}, 
        {"cython", {"pyx", "pxd", "pxi"}}, 
        {"delphi", {"pas", "int", "dfm", "nfm", "dof", "dpk", "dpr", "dproj", "groupproj",
                 "bdsgroup", "bdsproj"}}, 
        {"dlang", {"d", "di"}}, 
        {"dot", {"dot", "gv"}}, 
        {"dts", {"dts", "dtsi"}}, 
        {"ebuild", {"ebuild", "eclass"}}, 
        {"elisp", {"el"}}, 
        {"elixir", {"ex", "eex", "exs"}}, 
        {"elm", {"elm"}}, 
        {"erlang", {"erl", "hrl"}}, 
        {"factor", {"factor"}}, 
        {"fortran", {"f", "F", "f77", "f90", "F90", "f95", "f03", "for", "ftn", "fpp",
                  "FPP"}}, 
        {"fsharp", {"fs", "fsi", "fsx"}}, 
        {"gettext", {"po", "pot", "mo"}}, 
        {"glsl", {"vert", "tesc", "tese", "geom", "frag", "comp"}}, 
        {"go", {"go"}}, 
        {"gradle", {"gradle"}}, 
        {"groovy", {"groovy", "gtmpl", "gpp", "grunit", "gradle"}}, 
        {"haml", {"haml"}}, 
        {"handlebars", {"hbs"}}, 
        {"haskell", {"hs", "hsig", "lhs"}}, 
        {"haxe", {"hx"}}, 
        {"hh", {"h"}}, 
        {"html", {"htm", "html", "shtml", "xhtml"}}, 
        {"idris", {"idr", "ipkg", "lidr"}}, 
        {"ini", {"ini"}}, 
        {"ipython", {"ipynb"}}, 
        {"isabelle", {"thy"}}, 
        {"j", {"ijs"}}, 
        {"jade", {"jade"}}, 
        {"java", {"java", "properties"}}, 
        {"jinja2", {"j2"}}, 
        {"js", {"es6", "js", "jsx", "vue"}}, 
        {"json", {"json"}}, 
        {"jsp", {"jsp", "jspx", "jhtm", "jhtml", "jspf", "tag", "tagf"}}, 
        {"julia", {"jl"}}, 
        {"kotlin", {"kt"}}, 
        {"less", {"less"}}, 
        {"liquid", {"liquid"}}, 
        {"lisp", {"lisp", "lsp"}}, 
        {"log", {"log"}}, 
        {"lua", {"lua"}}, 
        {"m4", {"m4"}}, 
        {"make", {"Makefiles", "mk", "mak"}}, 
        {"mako", {"mako"}}, 
        {"markdown", {"markdown", "mdown", "mdwn", "mkdn", "mkd", "md"}}, 
        {"mason", {"mas", "mhtml", "mpl", "mtxt"}}, 
        {"matlab", {"m"}}, 
        {"mathematica", {"m", "wl"}}, 
        {"md", {"markdown", "mdown", "mdwn", "mkdn", "mkd", "md"}}, 
        {"mercury", {"m", "moo"}}, 
        {"naccess", {"asa", "rsa"}}, 
        {"nim", {"nim"}}, 
        {"nix", {"nix"}}, 
        {"objc", {"m", "h"}}, 
        {"objcpp", {"mm", "h"}}, 
        {"ocaml", {"ml", "mli", "mll", "mly"}}, 
        {"octave", {"m"}}, 
        {"org", {"org"}}, 
        {"parrot", {"pir", "pasm", "pmc", "ops", "pod", "pg", "tg"}}, 
        {"pdb", {"pdb"}}, 
        {"perl", {"pl", "pm", "pm6", "pod", "t"}}, 
        {"php", {"php", "phpt", "php3", "php4", "php5", "phtml"}}, 
        {"pike", {"pike", "pmod"}}, 
        {"plist", {"plist"}}, 
        {"plone", {"pt", "cpt", "metadata", "cpy", "py", "xml", "zcml"}}, 
        {"powershell", {"ps1"}}, 
        {"proto", {"proto"}}, 
        {"ps1", {"ps1"}}, 
        {"pug", {"pug"}}, 
        {"puppet", {"pp"}}, 
        {"python", {"py"}}, 
        {"qml", {"qml"}}, 
        {"racket", {"rkt", "ss", "scm"}}, 
        {"rake", {"Rakefile"}}, 
        {"razor", {"cshtml"}}, 
        {"restructuredtext", {"rst"}}, 
        {"rs", {"rs"}}, 
        {"r", {"r", "R", "Rmd", "Rnw", "Rtex", "Rrst"}}, 
        {"rdoc", {"rdoc"}}, 
        {"ruby", {"rb", "rhtml", "rjs", "rxml", "erb", "rake", "spec"}}, 
        {"rust", {"rs"}}, 
        {"salt", {"sls"}}, 
        {"sass", {"sass", "scss"}}, 
        {"scala", {"scala"}}, 
        {"scheme", {"scm", "ss"}}, 
        {"shell", {"sh", "bash", "csh", "tcsh", "ksh", "zsh", "fish"}}, 
        {"smalltalk", {"st"}}, 
        {"sml", {"sml", "fun", "mlb", "sig"}}, 
        {"sql", {"sql", "ctl"}}, 
        {"stata", {"do", "ado"}}, 
        {"stylus", {"styl"}}, 
        {"swift", {"swift"}}, 
        {"tcl", {"tcl", "itcl", "itk"}}, 
        {"terraform", {"tf", "tfvars"}}, 
        {"tex", {"tex", "cls", "sty"}}, 
        {"thrift", {"thrift"}}, 
        {"tla", {"tla"}}, 
        {"tt", {"tt", "tt2", "ttml"}}, 
        {"toml", {"toml"}}, 
        {"ts", {"ts", "tsx"}}, 
        {"twig", {"twig"}}, 
        {"vala", {"vala", "vapi"}}, 
        {"vb", {"bas", "cls", "frm", "ctl", "vb", "resx"}}, 
        {"velocity", {"vm", "vtl", "vsl"}}, 
        {"verilog", {"v", "vh", "sv", "svh"}}, 
        {"vhdl", {"vhd", "vhdl"}}, 
        {"vim", {"vim"}}, 
        {"vue", {"vue"}}, 
        {"wix", {"wxi", "wxs"}}, 
        {"wsdl", {"wsdl"}}, 
        {"wadl", {"wadl"}}, 
        {"xml", {"xml", "dtd", "xsl", "xslt", "xsd", "ent", "tld", "plist", "wsdl"}}, 
        {"yaml",
      {"yaml", "yml"}}, 
        {"zeek", {"zeek", "bro", "bif"}}, 
        {"zephir", {"zep"}}};
size_t get_lang_count(void) 
{ 


  {
  return (sizeof(langs) / sizeof(lang_spec_t ));
}
}
char *make_lang_regex(char *ext_array , size_t num_exts ) 
{ 
  int regex_capacity ;
  char *regex ;
  void *tmp ;
  int regex_length ;
  int subsequent ;
  char *extension ;
  size_t i ;
  int extension_length ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  regex_capacity = 100;
  tmp = ag_malloc((size_t )regex_capacity);
  regex = (char *)tmp;
  regex_length = 3;
  subsequent = 0;
  strcpy((char * __restrict  )regex, (char const   * __restrict  )"\\.(");
  i = (size_t )0;
  while (i < num_exts) {
    extension = ext_array + i * 20UL;
    tmp___0 = strlen((char const   *)extension);
    extension_length = (int )tmp___0;
    while (((regex_length + extension_length) + 3) + subsequent > regex_capacity) {
      regex_capacity *= 2;
      tmp___1 = ag_realloc((void *)regex, (size_t )regex_capacity);
      regex = (char *)tmp___1;
    }
    if (subsequent) {
      tmp___2 = regex_length;
      regex_length ++;
      *(regex + tmp___2) = (char )'|';
    } else {
      subsequent = 1;
    }
    strcpy((char * __restrict  )(regex + regex_length), (char const   * __restrict  )extension);
    regex_length += extension_length;
    i ++;
  }
  tmp___3 = regex_length;
  regex_length ++;
  *(regex + tmp___3) = (char )')';
  tmp___4 = regex_length;
  regex_length ++;
  *(regex + tmp___4) = (char )'$';
  tmp___5 = regex_length;
  regex_length ++;
  *(regex + tmp___5) = (char)0;
  return (regex);
}
}
size_t combine_file_extensions(size_t *extension_index , size_t len , char **exts ) 
{ 
  size_t ext_capacity ;
  void *tmp ;
  size_t num_of_extensions ;
  size_t i ;
  size_t j ;
  char const   *ext ;
  char *pos ;
  size_t tmp___0 ;

  {
  ext_capacity = (size_t )100;
  tmp = ag_malloc(ext_capacity * 20UL);
  *exts = (char *)tmp;
  memset((void *)*exts, 0, ext_capacity * 20UL);
  num_of_extensions = (size_t )0;
  i = (size_t )0;
  while (i < len) {
    j = (size_t )0;
    ext = langs[*(extension_index + i)].extensions[j];
    while (! (num_of_extensions == ext_capacity)) {
      pos = *exts + num_of_extensions * 20UL;
      tmp___0 = strlen(ext);
      strncpy((char * __restrict  )pos, (char const   * __restrict  )ext, tmp___0);
      num_of_extensions ++;
      j ++;
      ext = langs[*(extension_index + i)].extensions[j];
      if (! ext) {
        break;
      }
    }
    i ++;
  }
  return (num_of_extensions);
}
}
#pragma merger("0","/tmp/cil-UpuX0x6J.i","-g,-O2,-pthread,-Wall,-Wextra,-Wformat=2,-Wno-format-nonliteral,-Wshadow,-Wpointer-arith,-Wcast-qual,-Wmissing-prototypes,-Wno-missing-braces,-std=gnu89")
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vasprintf)(char ** __restrict  __ptr ,
                                                                              char const   * __restrict  __f ,
                                                                              __gnuc_va_list __arg ) ;
extern  __attribute__((__nothrow__)) void flockfile(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) void funlockfile(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strndup)(char const   *__string ,
                                                                                      size_t __n )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strpbrk)(char const   *__s ,
                                                                                        char const   *__accept )  __attribute__((__pure__)) ;
extern pcre *pcre_compile(char const   * , int  , char const   ** , int * , unsigned char const   * ) ;
extern pcre_extra *pcre_study(pcre const   * , int  , char const   ** ) ;
ag_stats stats  ;
void generate_alpha_skip(char const   *find , size_t f_len , size_t *skip_lookup ,
                         int const   case_sensitive ) ;
int is_prefix(char const   *s , size_t const   s_len , size_t const   pos , int const   case_sensitive ) ;
size_t suffix_len(char const   *s , size_t const   s_len , size_t const   pos , int const   case_sensitive ) ;
void generate_find_skip(char const   *find , size_t const   f_len , size_t **skip_lookup ,
                        int const   case_sensitive ) ;
void generate_hash(char const   *find , size_t const   f_len , uint8_t *h_table___0 ,
                   int const   case_sensitive ) ;
size_t ag_max(size_t a , size_t b ) ;
void init_wordchar_table(void) ;
char *fgetln(FILE *fp , size_t *lenp ) ;
size_t strlcpy(char *dst , char const   *src , size_t size ) ;
FILE *out_fd  =    (FILE *)((void *)0);
void *ag_malloc(size_t size ) 
{ 
  void *ptr ;
  void *tmp ;

  {
  tmp = malloc(size);
  ptr = tmp;
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    die("Memory allocation failed.");
  }
  return (ptr);
}
}
void *ag_realloc(void *ptr , size_t size ) 
{ 
  void *new_ptr ;
  void *tmp ;

  {
  tmp = realloc(ptr, size);
  new_ptr = tmp;
  if ((unsigned long )new_ptr == (unsigned long )((void *)0)) {
    die("Memory allocation failed.");
  }
  return (new_ptr);
}
}
void *ag_calloc(size_t count , size_t size ) 
{ 
  void *ptr ;
  void *tmp ;

  {
  tmp = calloc(count, size);
  ptr = tmp;
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    die("Memory allocation failed.");
  }
  return (ptr);
}
}
char *ag_strdup(char const   *s ) 
{ 
  char *str ;
  char *tmp ;

  {
  tmp = strdup(s);
  str = tmp;
  if ((unsigned long )str == (unsigned long )((void *)0)) {
    die("Memory allocation failed.");
  }
  return (str);
}
}
char *ag_strndup(char const   *s , size_t size ) 
{ 
  char *str ;

  {
  str = (char *)((void *)0);
  str = strndup(s, size);
  if ((unsigned long )str == (unsigned long )((void *)0)) {
    die("Memory allocation failed.");
  }
  return (str);
}
}
void free_strings(char **strs , size_t const   strs_len ) 
{ 
  size_t i ;

  {
  if ((unsigned long )strs == (unsigned long )((void *)0)) {
    return;
  }
  i = (size_t )0;
  while (i < (size_t )strs_len) {
    free((void *)*(strs + i));
    i ++;
  }
  free((void *)strs);
  return;
}
}
void generate_alpha_skip(char const   *find , size_t f_len , size_t *skip_lookup ,
                         int const   case_sensitive ) 
{ 
  size_t i ;
  int __res ;
  __int32_t const   **tmp___0 ;
  int __res___0 ;
  __int32_t const   **tmp___2 ;

  {
  i = (size_t )0;
  while (i < 256UL) {
    *(skip_lookup + i) = f_len;
    i ++;
  }
  f_len --;
  i = (size_t )0;
  while (i < f_len) {
    if (case_sensitive) {
      *(skip_lookup + (unsigned char )*(find + i)) = f_len - i;
    } else {
      if (sizeof(*(find + i)) > 1UL) {
        __res = tolower((int )*(find + i));
      } else {
        tmp___0 = __ctype_tolower_loc();
        __res = (int )*(*tmp___0 + (int )*(find + i));
      }
      *(skip_lookup + (unsigned char )__res) = f_len - i;
      if (sizeof(*(find + i)) > 1UL) {
        __res___0 = toupper((int )*(find + i));
      } else {
        tmp___2 = __ctype_toupper_loc();
        __res___0 = (int )*(*tmp___2 + (int )*(find + i));
      }
      *(skip_lookup + (unsigned char )__res___0) = f_len - i;
    }
    i ++;
  }
  return;
}
}
int is_prefix(char const   *s , size_t const   s_len , size_t const   pos , int const   case_sensitive ) 
{ 
  size_t i ;
  int __res ;
  __int32_t const   **tmp___0 ;
  int __res___0 ;
  __int32_t const   **tmp___2 ;

  {
  i = (size_t )0;
  while (pos + (size_t const   )i < s_len) {
    if (case_sensitive) {
      if ((int const   )*(s + i) != (int const   )*(s + (i + (size_t )pos))) {
        return (0);
      }
    } else {
      if (sizeof(*(s + i)) > 1UL) {
        __res = tolower((int )*(s + i));
      } else {
        tmp___0 = __ctype_tolower_loc();
        __res = (int )*(*tmp___0 + (int )*(s + i));
      }
      if (sizeof(*(s + (i + (size_t )pos))) > 1UL) {
        __res___0 = tolower((int )*(s + (i + (size_t )pos)));
      } else {
        tmp___2 = __ctype_tolower_loc();
        __res___0 = (int )*(*tmp___2 + (int )*(s + (i + (size_t )pos)));
      }
      if (__res != __res___0) {
        return (0);
      }
    }
    i ++;
  }
  return (1);
}
}
size_t suffix_len(char const   *s , size_t const   s_len , size_t const   pos , int const   case_sensitive ) 
{ 
  size_t i ;
  int __res ;
  __int32_t const   **tmp___0 ;
  int __res___0 ;
  __int32_t const   **tmp___2 ;

  {
  i = (size_t )0;
  while (i < (size_t )pos) {
    if (case_sensitive) {
      if ((int const   )*(s + (pos - (size_t const   )i)) != (int const   )*(s + ((s_len - (size_t const   )i) - 1UL))) {
        break;
      }
    } else {
      if (sizeof(*(s + (pos - (size_t const   )i))) > 1UL) {
        __res = tolower((int )*(s + (pos - (size_t const   )i)));
      } else {
        tmp___0 = __ctype_tolower_loc();
        __res = (int )*(*tmp___0 + (int )*(s + (pos - (size_t const   )i)));
      }
      if (sizeof(*(s + ((s_len - (size_t const   )i) - 1UL))) > 1UL) {
        __res___0 = tolower((int )*(s + ((s_len - (size_t const   )i) - 1UL)));
      } else {
        tmp___2 = __ctype_tolower_loc();
        __res___0 = (int )*(*tmp___2 + (int )*(s + ((s_len - (size_t const   )i) - 1UL)));
      }
      if (__res != __res___0) {
        break;
      }
    }
    i ++;
  }
  return (i);
}
}
void generate_find_skip(char const   *find , size_t const   f_len , size_t **skip_lookup ,
                        int const   case_sensitive ) 
{ 
  size_t i ;
  size_t s_len ;
  size_t *sl ;
  void *tmp ;
  size_t last_prefix ;
  int tmp___0 ;

  {
  tmp = ag_malloc((size_t )(f_len * (size_t const   )sizeof(size_t )));
  sl = (size_t *)tmp;
  *skip_lookup = sl;
  last_prefix = (size_t )f_len;
  i = last_prefix;
  while (i > 0UL) {
    tmp___0 = is_prefix(find, f_len, (size_t const   )i, case_sensitive);
    if (tmp___0) {
      last_prefix = i;
    }
    *(sl + (i - 1UL)) = last_prefix + (size_t )(f_len - (size_t const   )i);
    i --;
  }
  i = (size_t )0;
  while (i < (size_t )f_len) {
    s_len = suffix_len(find, f_len, (size_t const   )i, case_sensitive);
    if ((int const   )*(find + (i - s_len)) != (int const   )*(find + ((f_len - 1UL) - (size_t const   )s_len))) {
      *(sl + ((f_len - 1UL) - (size_t const   )s_len)) = (size_t )(((f_len - 1UL) - (size_t const   )i) + (size_t const   )s_len);
    }
    i ++;
  }
  return;
}
}
size_t ag_max(size_t a , size_t b ) 
{ 


  {
  if (b > a) {
    return (b);
  }
  return (a);
}
}
size_t ag_min(size_t a , size_t b ) 
{ 


  {
  if (b < a) {
    return (b);
  }
  return (a);
}
}
void generate_hash(char const   *find , size_t const   f_len , uint8_t *h_table___0 ,
                   int const   case_sensitive ) 
{ 
  int i ;
  int caps_set ;
  word_t word ;
  int cap_index ;
  size_t h ;

  {
  i = (int )(f_len - (size_t const   )sizeof(uint16_t ));
  while (i >= 0) {
    caps_set = 0;
    while (caps_set < 1 << sizeof(uint16_t )) {
      memcpy((void * __restrict  )(& word.as_chars), (void const   * __restrict  )(find + i),
             sizeof(uint16_t ));
      cap_index = 0;
      while (caps_set >> cap_index) {
        if ((caps_set >> cap_index) & 1) {
          word.as_chars[cap_index] = (char )((int )word.as_chars[cap_index] - 32);
        }
        cap_index ++;
      }
      h = (size_t )((int )word.as_word % 65536);
      while (*(h_table___0 + h)) {
        h = (h + 1UL) % 65536UL;
      }
      *(h_table___0 + h) = (uint8_t )(i + 1);
      if (case_sensitive) {
        break;
      }
      caps_set ++;
    }
    i --;
  }
  return;
}
}
char const   *boyer_moore_strnstr(char const   *s , char const   *find , size_t const   s_len ,
                                  size_t const   f_len , size_t const   *alpha_skip_lookup___0 ,
                                  size_t const   *find_skip_lookup___0 , int const   case_insensitive ) 
{ 
  ssize_t i ;
  size_t pos ;
  int __res ;
  __int32_t const   **tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
  pos = (size_t )(f_len - 1UL);
  while (pos < (size_t )s_len) {
    i = (ssize_t )(f_len - 1UL);
    while (1) {
      if (i >= 0L) {
        if (case_insensitive) {
          if (sizeof(*(s + pos)) > 1UL) {
            __res = tolower((int )*(s + pos));
          } else {
            tmp___0 = __ctype_tolower_loc();
            __res = (int )*(*tmp___0 + (int )*(s + pos));
          }
          tmp___1 = __res;
        } else {
          tmp___1 = (int )*(s + pos);
        }
        if (! (tmp___1 == (int )*(find + i))) {
          break;
        }
      } else {
        break;
      }
      pos --;
      i --;
    }
    if (i < 0L) {
      return ((s + pos) + 1);
    }
    tmp___2 = ag_max((size_t )*(alpha_skip_lookup___0 + (unsigned char )*(s + pos)),
                     (size_t )*(find_skip_lookup___0 + i));
    pos += tmp___2;
  }
  return ((char const   *)((void *)0));
}
}
char const __attribute__((__no_sanitize__("alignment")))  *hash_strnstr(char const   *s ,
                                                                        char const   *find ,
                                                                        size_t const   s_len ,
                                                                        size_t const   f_len ,
                                                                        uint8_t *h_table___0 ,
                                                                        int const   case_sensitive ) 
{ 
  size_t step ;
  size_t s_i ;
  size_t h ;
  char const   *R ;
  size_t i ;
  int __res ;
  __int32_t const   **tmp___0 ;
  int tmp___1 ;
  size_t i___0 ;
  char const   *R___0 ;
  char s_c ;
  int __res___0 ;
  __int32_t const   **tmp___3 ;
  int tmp___4 ;

  {
  if (s_len < f_len) {
    return ((char const __attribute__((__no_sanitize__("alignment")))  *)((void *)0));
  }
  step = (size_t )((f_len - (size_t const   )sizeof(uint16_t )) + 1UL);
  s_i = (size_t )(f_len - (size_t const   )sizeof(uint16_t ));
  while (s_i <= (size_t )(s_len - f_len)) {
    h = (size_t )((int const   )*((uint16_t const   *)(s + s_i)) % 65536);
    while (*(h_table___0 + h)) {
      R = (s + s_i) - ((int )*(h_table___0 + h) - 1);
      i = (size_t )0;
      while (i < (size_t )f_len) {
        if (case_sensitive) {
          tmp___1 = (int const   )*(R + i);
        } else {
          if (sizeof(*(R + i)) > 1UL) {
            __res = tolower((int )*(R + i));
          } else {
            tmp___0 = __ctype_tolower_loc();
            __res = (int )*(*tmp___0 + (int )*(R + i));
          }
          tmp___1 = (int const   )__res;
        }
        if (tmp___1 != (int const   )*(find + i)) {
          goto next_hash_cell;
        }
        i ++;
      }
      return ((char const __attribute__((__no_sanitize__("alignment")))  *)R);
      next_hash_cell: 
      h = (h + 1UL) % 65536UL;
    }
    s_i += step;
  }
  s_i = (s_i - step) + 1UL;
  while (s_i <= (size_t )(s_len - f_len)) {
    R___0 = s + s_i;
    i___0 = (size_t )0;
    while (i___0 < (size_t )f_len) {
      if (case_sensitive) {
        tmp___4 = (int const   )*(R___0 + i___0);
      } else {
        if (sizeof(*(R___0 + i___0)) > 1UL) {
          __res___0 = tolower((int )*(R___0 + i___0));
        } else {
          tmp___3 = __ctype_tolower_loc();
          __res___0 = (int )*(*tmp___3 + (int )*(R___0 + i___0));
        }
        tmp___4 = (int const   )__res___0;
      }
      s_c = (char )tmp___4;
      if ((int )s_c != (int )*(find + i___0)) {
        goto next_start;
      }
      i___0 ++;
    }
    return ((char const __attribute__((__no_sanitize__("alignment")))  *)R___0);
    next_start: 
    s_i ++;
  }
  return ((char const __attribute__((__no_sanitize__("alignment")))  *)((void *)0));
}
}
size_t invert_matches(char const   *buf , size_t const   buf_len , match_t *matches ,
                      size_t matches_len ) 
{ 
  size_t i ;
  size_t match_read_index ;
  size_t inverted_match_count ;
  size_t inverted_match_start ;
  size_t last_line_end ;
  int in_inverted_match ;
  match_t next_match ;

  {
  match_read_index = (size_t )0;
  inverted_match_count = (size_t )0;
  inverted_match_start = (size_t )0;
  last_line_end = (size_t )0;
  in_inverted_match = 1;
  log_debug("Inverting %u matches.", matches_len);
  if (matches_len > 0UL) {
    next_match = *(matches + 0);
  } else {
    next_match.start = (size_t )(buf_len + 1UL);
  }
  if (matches_len == 0UL) {
    (matches + 0)->start = (size_t )0;
    (matches + 0)->end = (size_t )(buf_len - 1UL);
    return ((size_t )1);
  }
  i = (size_t )0;
  while (i < (size_t )buf_len) {
    if (i == next_match.start) {
      i = next_match.end - 1UL;
      match_read_index ++;
      if (match_read_index < matches_len) {
        next_match = *(matches + match_read_index);
      }
      if (in_inverted_match) {
        if (last_line_end > inverted_match_start) {
          (matches + inverted_match_count)->start = inverted_match_start;
          (matches + inverted_match_count)->end = last_line_end - 1UL;
          inverted_match_count ++;
        }
      }
      in_inverted_match = 0;
    } else
    if (i == (size_t )(buf_len - 1UL)) {
      if (in_inverted_match) {
        (matches + inverted_match_count)->start = inverted_match_start;
        (matches + inverted_match_count)->end = i;
        inverted_match_count ++;
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if ((int const   )*(buf + i) == 10) {
      last_line_end = i + 1UL;
      if (! in_inverted_match) {
        inverted_match_start = last_line_end;
      }
      in_inverted_match = 1;
    }
    i ++;
  }
  i = (size_t )0;
  while (i < matches_len) {
    log_debug("Inverted match %i start %i end %i.", i, (matches + i)->start, (matches + i)->end);
    i ++;
  }
  return (inverted_match_count);
}
}
void realloc_matches(match_t **matches , size_t *matches_size , size_t matches_len ) 
{ 
  void *tmp ;

  {
  if (matches_len < *matches_size) {
    return;
  }
  if (*matches) {
    *matches_size *= 2UL;
  } else {
    *matches_size = (size_t )100;
  }
  tmp = ag_realloc((void *)*matches, *matches_size * sizeof(match_t ));
  *matches = (match_t *)tmp;
  return;
}
}
void compile_study(pcre **re , pcre_extra **re_extra , char *q , int const   pcre_opts ,
                   int const   study_opts ) 
{ 
  char const   *pcre_err ;
  int pcre_err_offset ;

  {
  pcre_err = (char const   *)((void *)0);
  pcre_err_offset = 0;
  *re = pcre_compile((char const   *)q, (int )pcre_opts, & pcre_err, & pcre_err_offset,
                     (unsigned char const   *)((void *)0));
  if ((unsigned long )*re == (unsigned long )((void *)0)) {
    die("Bad regex! pcre_compile() failed at position %i: %s\nIf you meant to search for a literal string, run ag with -Q",
        pcre_err_offset, pcre_err);
  }
  *re_extra = pcre_study((pcre const   *)*re, (int )study_opts, & pcre_err);
  if ((unsigned long )*re_extra == (unsigned long )((void *)0)) {
    log_debug("pcre_study returned nothing useful. Error: %s", pcre_err);
  }
  return;
}
}
int is_binary(void const   *buf , size_t const   buf_len ) 
{ 
  size_t suspicious_bytes ;
  size_t total_bytes ;
  size_t tmp ;
  unsigned char const   *buf_c ;
  size_t i ;
  int tmp___0 ;

  {
  suspicious_bytes = (size_t )0;
  if (buf_len > 512UL) {
    tmp = (size_t const   )512;
  } else {
    tmp = buf_len;
  }
  total_bytes = (size_t )tmp;
  buf_c = (unsigned char const   *)buf;
  if (buf_len == 0UL) {
    return (0);
  }
  if (buf_len >= 3UL) {
    if ((int const   )*(buf_c + 0) == 239) {
      if ((int const   )*(buf_c + 1) == 187) {
        if ((int const   )*(buf_c + 2) == 191) {
          return (0);
        }
      }
    }
  }
  if (buf_len >= 5UL) {
    tmp___0 = strncmp((char const   *)buf, "%PDF-", (size_t )5);
    if (tmp___0 == 0) {
      return (1);
    }
  }
  i = (size_t )0;
  while (i < total_bytes) {
    if ((int const   )*(buf_c + i) == 0) {
      return (1);
    } else
    if ((int const   )*(buf_c + i) < 7) {
      goto _L___2;
    } else
    if ((int const   )*(buf_c + i) > 14) {
      _L___2: /* CIL Label */ 
      if ((int const   )*(buf_c + i) < 32) {
        goto _L___1;
      } else
      if ((int const   )*(buf_c + i) > 127) {
        _L___1: /* CIL Label */ 
        if ((int const   )*(buf_c + i) > 193) {
          if ((int const   )*(buf_c + i) < 224) {
            if (i + 1UL < total_bytes) {
              i ++;
              if ((int const   )*(buf_c + i) > 127) {
                if ((int const   )*(buf_c + i) < 192) {
                  goto __Cont;
                }
              }
            } else {
              goto _L___0;
            }
          } else {
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
        if ((int const   )*(buf_c + i) > 223) {
          if ((int const   )*(buf_c + i) < 240) {
            if (i + 2UL < total_bytes) {
              i ++;
              if ((int const   )*(buf_c + i) > 127) {
                if ((int const   )*(buf_c + i) < 192) {
                  if ((int const   )*(buf_c + (i + 1UL)) > 127) {
                    if ((int const   )*(buf_c + (i + 1UL)) < 192) {
                      i ++;
                      goto __Cont;
                    }
                  }
                }
              }
            }
          }
        }
        suspicious_bytes ++;
        if (i >= 32UL) {
          if ((suspicious_bytes * 100UL) / total_bytes > 10UL) {
            return (1);
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
    i ++;
  }
  if ((suspicious_bytes * 100UL) / total_bytes > 10UL) {
    return (1);
  }
  return (0);
}
}
int is_regex(char const   *query ) 
{ 
  char regex_chars[13] ;
  char *tmp ;

  {
  regex_chars[0] = (char )'$';
  regex_chars[1] = (char )'(';
  regex_chars[2] = (char )')';
  regex_chars[3] = (char )'*';
  regex_chars[4] = (char )'+';
  regex_chars[5] = (char )'.';
  regex_chars[6] = (char )'?';
  regex_chars[7] = (char )'[';
  regex_chars[8] = (char )'\\';
  regex_chars[9] = (char )'^';
  regex_chars[10] = (char )'{';
  regex_chars[11] = (char )'|';
  regex_chars[12] = (char )'\000';
  tmp = strpbrk(query, (char const   *)(regex_chars));
  return ((unsigned long )tmp != (unsigned long )((void *)0));
}
}
int is_fnmatch(char const   *filename ) 
{ 
  char fnmatch_chars[6] ;
  char *tmp ;

  {
  fnmatch_chars[0] = (char )'!';
  fnmatch_chars[1] = (char )'*';
  fnmatch_chars[2] = (char )'?';
  fnmatch_chars[3] = (char )'[';
  fnmatch_chars[4] = (char )']';
  fnmatch_chars[5] = (char )'\000';
  tmp = strpbrk(filename, (char const   *)(fnmatch_chars));
  return ((unsigned long )tmp != (unsigned long )((void *)0));
}
}
int binary_search(char const   *needle , char **haystack , int start , int end ) 
{ 
  int mid ;
  int rc ;
  int tmp ;
  int tmp___0 ;

  {
  if (start == end) {
    return (-1);
  }
  mid = start + (end - start) / 2;
  rc = strcmp(needle, (char const   *)*(haystack + mid));
  if (rc < 0) {
    tmp = binary_search(needle, haystack, start, mid);
    return (tmp);
  } else
  if (rc > 0) {
    tmp___0 = binary_search(needle, haystack, mid + 1, end);
    return (tmp___0);
  }
  return (mid);
}
}
static int wordchar_table[256]  ;
void init_wordchar_table(void) 
{ 
  int i ;
  char ch ;
  int tmp ;

  {
  i = 0;
  while (i < 256) {
    ch = (char )i;
    if (97 <= (int )ch) {
      if ((int )ch <= 122) {
        tmp = 1;
      } else {
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
    if (65 <= (int )ch) {
      if ((int )ch <= 90) {
        tmp = 1;
      } else {
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
    if (48 <= (int )ch) {
      if ((int )ch <= 57) {
        tmp = 1;
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if ((int )ch == 95) {
      tmp = 1;
    } else {
      tmp = 0;
    }
    wordchar_table[i] = tmp;
    i ++;
  }
  return;
}
}
int is_wordchar(char ch ) 
{ 


  {
  return (wordchar_table[(unsigned char )ch]);
}
}
int is_lowercase(char const   *s ) 
{ 
  int i ;
  unsigned short const   **tmp ;

  {
  i = 0;
  while ((int const   )*(s + i) != 0) {
    if (! (((int const   )*(s + i) & -128) == 0)) {
      return (0);
    } else {
      tmp = __ctype_b_loc();
      if ((int const   )*(*tmp + (int )*(s + i)) & 256) {
        return (0);
      }
    }
    i ++;
  }
  return (1);
}
}
int is_directory(char const   *path , struct dirent  const  *d ) 
{ 
  char *full_path ;
  struct stat s ;
  int tmp ;
  int is_dir ;

  {
  if ((int const   )d->d_type != 0) {
    if ((int const   )d->d_type != 10) {
      return ((int const   )d->d_type == 4);
    }
  }
  ag_asprintf(& full_path, "%s/%s", path, d->d_name);
  tmp = stat((char const   * __restrict  )full_path, (struct stat * __restrict  )(& s));
  if (tmp != 0) {
    free((void *)full_path);
    return (0);
  }
  is_dir = (s.st_mode & 61440U) == 16384U;
  free((void *)full_path);
  return (is_dir);
}
}
int is_symlink(char const   *path , struct dirent  const  *d ) 
{ 
  char *full_path ;
  struct stat s ;
  int tmp ;

  {
  if ((int const   )d->d_type != 0) {
    return ((int const   )d->d_type == 10);
  }
  ag_asprintf(& full_path, "%s/%s", path, d->d_name);
  tmp = lstat((char const   * __restrict  )full_path, (struct stat * __restrict  )(& s));
  if (tmp != 0) {
    free((void *)full_path);
    return (0);
  }
  free((void *)full_path);
  return ((s.st_mode & 61440U) == 40960U);
}
}
int is_named_pipe(char const   *path , struct dirent  const  *d ) 
{ 
  int tmp ;
  char *full_path ;
  struct stat s ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if ((int const   )d->d_type != 0) {
    if ((int const   )d->d_type != 10) {
      if ((int const   )d->d_type == 1) {
        tmp = 1;
      } else
      if ((int const   )d->d_type == 12) {
        tmp = 1;
      } else {
        tmp = 0;
      }
      return (tmp);
    }
  }
  ag_asprintf(& full_path, "%s/%s", path, d->d_name);
  tmp___0 = stat((char const   * __restrict  )full_path, (struct stat * __restrict  )(& s));
  if (tmp___0 != 0) {
    free((void *)full_path);
    return (0);
  }
  free((void *)full_path);
  if ((s.st_mode & 61440U) == 4096U) {
    tmp___1 = 1;
  } else
  if ((s.st_mode & 61440U) == 49152U) {
    tmp___1 = 1;
  } else {
    tmp___1 = 0;
  }
  return (tmp___1);
}
}
void ag_asprintf(char **ret , char const   *fmt  , ...) 
{ 
  va_list___0 args ;
  int tmp ;

  {
  __builtin_va_start(args, fmt);
  tmp = vasprintf((char ** __restrict  )ret, (char const   * __restrict  )fmt, args);
  if (tmp == -1) {
    die("vasprintf returned -1");
  }
  __builtin_va_end(args);
  return;
}
}
void die(char const   *fmt  , ...) 
{ 
  va_list___0 args ;

  {
  __builtin_va_start(args, fmt);
  vplog((unsigned int const   )40, fmt, args);
  __builtin_va_end(args);
  exit(2);
}
}
char *fgetln(FILE *fp , size_t *lenp ) 
{ 
  char *buf ;
  int c ;
  int used ;
  int len ;
  size_t nsize ;
  char *newbuf ;
  void *tmp ;
  int tmp___0 ;

  {
  buf = (char *)((void *)0);
  used = 0;
  len = 0;
  flockfile(fp);
  while (1) {
    c = getc_unlocked(fp);
    if (! (c != -1)) {
      break;
    }
    if (! buf) {
      goto _L;
    } else
    if (len >= used) {
      _L: /* CIL Label */ 
      nsize = (size_t )(used + 8192);
      tmp = realloc((void *)buf, nsize);
      newbuf = (char *)tmp;
      if (! newbuf) {
        funlockfile(fp);
        if (buf) {
          free((void *)buf);
        }
        return ((char *)((void *)0));
      }
      buf = newbuf;
      used = (int )nsize;
    }
    tmp___0 = len;
    len ++;
    *(buf + tmp___0) = (char )c;
    if (c == 10) {
      break;
    }
  }
  funlockfile(fp);
  *lenp = (size_t )len;
  return (buf);
}
}
ssize_t buf_getline(char const   **line , char const   *buf , size_t const   buf_len ,
                    size_t const   buf_offset ) 
{ 
  char const   *cur ;
  ssize_t i ;

  {
  cur = buf + buf_offset;
  i = (ssize_t )0;
  while (1) {
    if (buf_offset + (size_t const   )i < buf_len) {
      if (! ((int const   )*(cur + i) != 10)) {
        break;
      }
    } else {
      break;
    }
    i ++;
  }
  *line = cur;
  return (i);
}
}
size_t strlcpy(char *dst , char const   *src , size_t size ) 
{ 
  char *d ;
  char const   *s ;
  size_t n ;
  char *tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  d = dst;
  s = src;
  n = size;
  if (n != 0UL) {
    while (1) {
      n --;
      if (! (n != 0UL)) {
        break;
      }
      tmp = d;
      d ++;
      tmp___1 = s;
      s ++;
      tmp___0 = (char )*tmp___1;
      *tmp = tmp___0;
      if ((int )tmp___0 == 0) {
        break;
      }
    }
  }
  if (n == 0UL) {
    if (size != 0UL) {
      *d = (char )'\000';
    }
    while (1) {
      tmp___2 = s;
      s ++;
      if (! *tmp___2) {
        break;
      }
    }
  }
  return ((size_t )((s - src) - 1L));
}
}
#pragma merger("0","/tmp/cil-QgWQGBLc.i","-g,-O2,-pthread,-Wall,-Wextra,-Wformat=2,-Wno-format-nonliteral,-Wshadow,-Wpointer-arith,-Wcast-qual,-Wmissing-prototypes,-Wno-missing-braces,-std=gnu89")
extern  __attribute__((__nothrow__)) int getpagesize(void)  __attribute__((__const__)) ;
void *decompress(ag_compression_type const   zip_type , void const   *buf , int const   buf_len ,
                 char const   *dir_full_path , int *new_buf_len ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t strtoimax(char const   * __restrict  nptr ,
                                                                 char ** __restrict  endptr ,
                                                                 int base ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t strtoumax(char const   * __restrict  nptr ,
                                                                  char ** __restrict  endptr ,
                                                                  int base ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t wcstoimax(__gwchar_t const   * __restrict  nptr ,
                                                                 __gwchar_t ** __restrict  endptr ,
                                                                 int base ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t wcstoumax(__gwchar_t const   * __restrict  nptr ,
                                                                  __gwchar_t ** __restrict  endptr ,
                                                                  int base ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) __strtol_internal)(char const   * __restrict  __nptr ,
                                                                                               char ** __restrict  __endptr ,
                                                                                               int __base ,
                                                                                               int __group ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t strtoimax(char const   * __restrict  nptr ,
                                                                 char ** __restrict  endptr ,
                                                                 int base ) ;
__inline extern intmax_t strtoimax(char const   * __restrict  nptr , char ** __restrict  endptr ,
                                   int base ) 
{ 
  long tmp ;

  {
  tmp = __strtol_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) __strtoul_internal)(char const   * __restrict  __nptr ,
                                                                                                         char ** __restrict  __endptr ,
                                                                                                         int __base ,
                                                                                                         int __group ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t strtoumax(char const   * __restrict  nptr ,
                                                                  char ** __restrict  endptr ,
                                                                  int base ) ;
__inline extern uintmax_t strtoumax(char const   * __restrict  nptr , char ** __restrict  endptr ,
                                    int base ) 
{ 
  unsigned long tmp ;

  {
  tmp = __strtoul_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) __wcstol_internal)(__gwchar_t const   * __restrict  __nptr ,
                                                                                               __gwchar_t ** __restrict  __endptr ,
                                                                                               int __base ,
                                                                                               int __group ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t wcstoimax(__gwchar_t const   * __restrict  nptr ,
                                                                 __gwchar_t ** __restrict  endptr ,
                                                                 int base ) ;
__inline extern intmax_t wcstoimax(__gwchar_t const   * __restrict  nptr , __gwchar_t ** __restrict  endptr ,
                                   int base ) 
{ 
  long tmp ;

  {
  tmp = __wcstol_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) __wcstoul_internal)(__gwchar_t const   * __restrict  __nptr ,
                                                                                                         __gwchar_t ** __restrict  __endptr ,
                                                                                                         int __base ,
                                                                                                         int __group ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t wcstoumax(__gwchar_t const   * __restrict  nptr ,
                                                                  __gwchar_t ** __restrict  endptr ,
                                                                  int base ) ;
__inline extern uintmax_t wcstoumax(__gwchar_t const   * __restrict  nptr , __gwchar_t ** __restrict  endptr ,
                                    int base ) 
{ 
  unsigned long tmp ;

  {
  tmp = __wcstoul_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) lzma_ret ( __attribute__((__warn_unused_result__)) lzma_code)(lzma_stream *strm ,
                                                                                                   lzma_action action ) ;
extern  __attribute__((__nothrow__)) void lzma_end(lzma_stream *strm ) ;
extern  __attribute__((__nothrow__)) lzma_ret ( __attribute__((__warn_unused_result__)) lzma_auto_decoder)(lzma_stream *strm ,
                                                                                                           uint64_t memlimit ,
                                                                                                           uint32_t flags ) ;
uint8_t const   XZ_HEADER_MAGIC[6]  = {      (uint8_t const   )253,      (uint8_t const   )'7',      (uint8_t const   )'z',      (uint8_t const   )'X', 
        (uint8_t const   )'Z',      (uint8_t const   )0};
uint8_t const   LZMA_HEADER_SOMETIMES[3]  = {      (uint8_t const   )93,      (uint8_t const   )0,      (uint8_t const   )0};
extern int inflate(z_streamp strm , int flush ) ;
extern int inflateEnd(z_streamp strm ) ;
extern int inflateInit2_(z_streamp strm , int windowBits , char const   *version ,
                         int stream_size ) ;
static void *decompress_zlib(void const   *buf , int const   buf_len , char const   *dir_full_path ,
                             int *new_buf_len ) 
{ 
  int ret ;
  unsigned char *result ;
  size_t result_size ;
  size_t pagesize ;
  z_stream stream ;
  int tmp ;
  int tmp___0 ;
  unsigned char *tmp_result ;
  void *tmp___1 ;

  {
  ret = 0;
  result = (unsigned char *)((void *)0);
  result_size = (size_t )0;
  pagesize = (size_t )0;
  log_debug("Decompressing zlib file %s", dir_full_path);
  stream.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))0;
  stream.zfree = (void (*)(voidpf opaque , voidpf address ))0;
  stream.opaque = (voidpf )0;
  stream.avail_in = (uInt )0;
  stream.next_in = (Bytef const   *)0;
  tmp = inflateInit2_(& stream, 47, "1.2.11", (int )sizeof(z_stream ));
  if (tmp != 0) {
    log_err("Unable to initialize zlib: %s", stream.msg);
    goto error_out;
  }
  stream.avail_in = (uInt )buf_len;
  stream.next_in = (Bytef const   *)((Bytef *)buf);
  tmp___0 = getpagesize();
  pagesize = (size_t )tmp___0;
  result_size = (((size_t )buf_len + pagesize) - 1UL) & ~ (pagesize - 1UL);
  while (1) {
    while (1) {
      tmp_result = result;
      result_size *= 2UL;
      tmp___1 = realloc((void *)result, result_size * sizeof(unsigned char ));
      result = (unsigned char *)tmp___1;
      if ((unsigned long )result == (unsigned long )((void *)0)) {
        free((void *)tmp_result);
        log_err("Unable to allocate %d bytes to decompress file %s", result_size * sizeof(unsigned char ),
                dir_full_path);
        inflateEnd(& stream);
        goto error_out;
      }
      stream.avail_out = (uInt )(result_size / 2UL);
      stream.next_out = result + stream.total_out;
      ret = inflate(& stream, 2);
      log_debug("inflate ret = %d", ret);
      switch (ret) {
      case -2: 
      log_err("Found stream error while decompressing zlib stream: %s", stream.msg);
      inflateEnd(& stream);
      goto error_out;
      case -4: 
      case -3: 
      case 2: 
      log_err("Found mem/data error while decompressing zlib stream: %s", stream.msg);
      inflateEnd(& stream);
      goto error_out;
      }
      if (! (stream.avail_out == 0U)) {
        break;
      }
    }
    if (! (ret == 0)) {
      break;
    }
  }
  *new_buf_len = (int )stream.total_out;
  inflateEnd(& stream);
  if (ret == 1) {
    return ((void *)result);
  }
  error_out: 
  *new_buf_len = 0;
  return ((void *)0);
}
}
static void *decompress_lzw(void const   *buf , int const   buf_len , char const   *dir_full_path ,
                            int *new_buf_len ) 
{ 


  {
  log_err("LZW (UNIX compress) files not yet supported: %s", dir_full_path);
  *new_buf_len = 0;
  return ((void *)0);
}
}
static void *decompress_zip(void const   *buf , int const   buf_len , char const   *dir_full_path ,
                            int *new_buf_len ) 
{ 


  {
  log_err("Zip files not yet supported: %s", dir_full_path);
  *new_buf_len = 0;
  return ((void *)0);
}
}
static void *decompress_lzma(void const   *buf , int const   buf_len , char const   *dir_full_path ,
                             int *new_buf_len ) 
{ 
  lzma_stream stream ;
  lzma_ret lzrt ;
  unsigned char *result ;
  size_t result_size ;
  size_t pagesize ;
  int tmp ;
  unsigned char *tmp_result ;
  void *tmp___0 ;

  {
  stream.next_in = (uint8_t const   *)((void *)0);
  stream.avail_in = (size_t )0;
  stream.total_in = (uint64_t )0;
  stream.next_out = (uint8_t *)((void *)0);
  stream.avail_out = (size_t )0;
  stream.total_out = (uint64_t )0;
  stream.allocator = (lzma_allocator const   *)((void *)0);
  stream.internal = (lzma_internal *)((void *)0);
  stream.reserved_ptr1 = (void *)0;
  stream.reserved_ptr2 = (void *)0;
  stream.reserved_ptr3 = (void *)0;
  stream.reserved_ptr4 = (void *)0;
  stream.reserved_int1 = (uint64_t )0;
  stream.reserved_int2 = (uint64_t )0;
  stream.reserved_int3 = (size_t )0;
  stream.reserved_int4 = (size_t )0;
  stream.reserved_enum1 = (lzma_reserved_enum )0;
  stream.reserved_enum2 = (lzma_reserved_enum )0;
  result = (unsigned char *)((void *)0);
  result_size = (size_t )0;
  pagesize = (size_t )0;
  stream.avail_in = (size_t )buf_len;
  stream.next_in = (uint8_t const   *)buf;
  lzrt = lzma_auto_decoder(& stream, (uint64_t )-1, (uint32_t )0);
  if ((unsigned int )lzrt != 0U) {
    log_err("Unable to initialize lzma_auto_decoder: %d", (unsigned int )lzrt);
    goto error_out;
  }
  tmp = getpagesize();
  pagesize = (size_t )tmp;
  result_size = (((size_t )buf_len + pagesize) - 1UL) & ~ (pagesize - 1UL);
  while (1) {
    while (1) {
      tmp_result = result;
      result_size *= 2UL;
      tmp___0 = realloc((void *)result, result_size * sizeof(unsigned char ));
      result = (unsigned char *)tmp___0;
      if ((unsigned long )result == (unsigned long )((void *)0)) {
        free((void *)tmp_result);
        log_err("Unable to allocate %d bytes to decompress file %s", result_size * sizeof(unsigned char ),
                dir_full_path);
        goto error_out;
      }
      stream.avail_out = result_size / 2UL;
      stream.next_out = result + stream.total_out;
      lzrt = lzma_code(& stream, (lzma_action )0);
      log_debug("lzma_code ret = %d", (unsigned int )lzrt);
      switch ((unsigned int )lzrt) {
      case 1U: 
      case 0U: 
      break;
      default: 
      log_err("Found mem/data error while decompressing xz/lzma stream: %d", (unsigned int )lzrt);
      goto error_out;
      }
      if (! (stream.avail_out == 0UL)) {
        break;
      }
    }
    if (! ((unsigned int )lzrt == 0U)) {
      break;
    }
  }
  *new_buf_len = (int )stream.total_out;
  if ((unsigned int )lzrt == 1U) {
    lzma_end(& stream);
    return ((void *)result);
  }
  error_out: 
  lzma_end(& stream);
  *new_buf_len = 0;
  if (result) {
    free((void *)result);
  }
  return ((void *)0);
}
}
void *decompress(ag_compression_type const   zip_type , void const   *buf , int const   buf_len ,
                 char const   *dir_full_path , int *new_buf_len ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  switch ((unsigned int const   )zip_type) {
  case 1U: 
  tmp = decompress_zlib(buf, buf_len, dir_full_path, new_buf_len);
  return (tmp);
  case 2U: 
  tmp___0 = decompress_lzw(buf, buf_len, dir_full_path, new_buf_len);
  return (tmp___0);
  case 3U: 
  tmp___1 = decompress_zip(buf, buf_len, dir_full_path, new_buf_len);
  return (tmp___1);
  case 4U: 
  tmp___2 = decompress_lzma(buf, buf_len, dir_full_path, new_buf_len);
  return (tmp___2);
  case 0U: 
  log_err("File %s is not compressed", dir_full_path);
  break;
  default: 
  log_err("Unsupported compression type: %d", (unsigned int const   )zip_type);
  }
  *new_buf_len = 0;
  return ((void *)0);
}
}
ag_compression_type is_zipped(void const   *buf , int const   buf_len ) 
{ 
  unsigned char const   *buf_c ;
  int tmp ;
  int tmp___0 ;

  {
  buf_c = (unsigned char const   *)buf;
  if (buf_len == 0) {
    return ((ag_compression_type )0);
  }
  if (buf_len >= 2) {
    if ((int const   )*(buf_c + 0) == 31) {
      if ((int const   )*(buf_c + 1) == 139) {
        log_debug("Found gzip-based stream");
        return ((ag_compression_type )1);
      } else
      if ((int const   )*(buf_c + 1) == 155) {
        log_debug("Found compress-based stream");
        return ((ag_compression_type )2);
      }
    }
  }
  if (buf_len >= 4) {
    if ((int const   )*(buf_c + 0) == 80) {
      if ((int const   )*(buf_c + 1) == 75) {
        if ((int const   )*(buf_c + 2) == 3) {
          if ((int const   )*(buf_c + 3) == 4) {
            log_debug("Found zip-based stream");
            return ((ag_compression_type )3);
          }
        }
      }
    }
  }
  if (buf_len >= 6) {
    tmp = memcmp((void const   *)(XZ_HEADER_MAGIC), (void const   *)buf_c, (size_t )6);
    if (tmp == 0) {
      log_debug("Found xz based stream");
      return ((ag_compression_type )4);
    }
  }
  if (buf_len >= 3) {
    tmp___0 = memcmp((void const   *)(LZMA_HEADER_SOMETIMES), (void const   *)buf_c,
                     (size_t )3);
    if (tmp___0 == 0) {
      log_debug("Found lzma-based stream");
      return ((ag_compression_type )4);
    }
  }
  return ((ag_compression_type )0);
}
}
/* compiler builtin: 
   void *__builtin_memset(void * , int  , int  ) ;  */
#pragma merger("0","/tmp/cil-sYMNLkb7.i","-g,-O2,-pthread,-Wall,-Wextra,-Wformat=2,-Wno-format-nonliteral,-Wshadow,-Wpointer-arith,-Wcast-qual,-Wmissing-prototypes,-Wno-missing-braces,-std=gnu89")
extern int pcre_config(int  , void * ) ;
extern char const   *pcre_version(void) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         void * __restrict  __tz ) ;
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) pthread_setaffinity_np)(pthread_t __th ,
                                                                                                   size_t __cpusetsize ,
                                                                                                   cpu_set_t const   *__cpuset ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                                              pthread_condattr_t const   * __restrict  __cond_attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_destroy)(pthread_cond_t *__cond ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_broadcast)(pthread_cond_t *__cond ) ;
int main(int argc , char **argv ) 
{ 
  char **base_paths ;
  char **paths ;
  int i ;
  int pcre_opts ;
  int study_opts ;
  worker_t *workers ;
  int workers_len ;
  int num_cores ;
  char const   *tmp ;
  int has_jit ;
  long tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___7 ;
  char *c ;
  int __res ;
  __int32_t const   **tmp___9 ;
  char *word_regexp_query ;
  size_t tmp___10 ;
  int rv ;
  int tmp___11 ;
  char *tmp___12 ;
  cpu_set_t cpu_set ;
  size_t __cpu ;
  char *tmp___13 ;
  ignores *ig ;
  ignores *tmp___14 ;
  struct stat s ;
  int tmp___15 ;
  int tmp___16 ;
  double time_diff ;

  {
  base_paths = (char **)((void *)0);
  paths = (char **)((void *)0);
  pcre_opts = 2;
  study_opts = 0;
  workers = (worker_t *)((void *)0);
  set_log_level((enum log_level )30);
  work_queue = (work_queue_t *)((void *)0);
  work_queue_tail = (work_queue_t *)((void *)0);
  root_ignores = init_ignore((ignores *)((void *)0), "", (size_t const   )0);
  out_fd = stdout;
  parse_options(argc, argv, & base_paths, & paths);
  tmp = pcre_version();
  log_debug("PCRE Version: %s", tmp);
  if (opts.stats) {
    memset((void *)(& stats), 0, sizeof(stats));
    gettimeofday((struct timeval * __restrict  )(& stats.time_start), (void * __restrict  )((void *)0));
  }
  has_jit = 0;
  pcre_config(9, (void *)(& has_jit));
  if (has_jit) {
    study_opts |= 1;
  }
  tmp___0 = sysconf(84);
  num_cores = (int )tmp___0;
  if (num_cores < 8) {
    workers_len = num_cores;
  } else {
    workers_len = 8;
  }
  if (opts.literal) {
    workers_len --;
  }
  if (opts.workers) {
    workers_len = opts.workers;
  }
  if (workers_len < 1) {
    workers_len = 1;
  }
  log_debug("Using %i workers", workers_len);
  done_adding_files = 0;
  tmp___1 = ag_calloc((size_t )workers_len, sizeof(worker_t ));
  workers = (worker_t *)tmp___1;
  tmp___2 = pthread_cond_init((pthread_cond_t * __restrict  )(& files_ready), (pthread_condattr_t const   * __restrict  )((void *)0));
  if (tmp___2) {
    die("pthread_cond_init failed!");
  }
  tmp___3 = pthread_mutex_init(& print_mtx, (pthread_mutexattr_t const   *)((void *)0));
  if (tmp___3) {
    die("pthread_mutex_init failed!");
  }
  if (opts.stats) {
    tmp___4 = pthread_mutex_init(& stats_mtx, (pthread_mutexattr_t const   *)((void *)0));
    if (tmp___4) {
      die("pthread_mutex_init failed!");
    }
  }
  tmp___5 = pthread_mutex_init(& work_queue_mtx, (pthread_mutexattr_t const   *)((void *)0));
  if (tmp___5) {
    die("pthread_mutex_init failed!");
  }
  if ((unsigned int )opts.casing == 3U) {
    tmp___7 = is_lowercase((char const   *)opts.query);
    if (tmp___7) {
      opts.casing = (enum case_behavior )2;
    } else {
      opts.casing = (enum case_behavior )1;
    }
  }
  if (opts.literal) {
    if ((unsigned int )opts.casing == 2U) {
      c = opts.query;
      while ((int )*c != 0) {
        if (sizeof(*c) > 1UL) {
          __res = tolower((int )*c);
        } else {
          tmp___9 = __ctype_tolower_loc();
          __res = (int )*(*tmp___9 + (int )*c);
        }
        *c = (char )__res;
        c ++;
      }
    }
    generate_alpha_skip((char const   *)opts.query, (size_t )opts.query_len, alpha_skip_lookup,
                        (int const   )((unsigned int )opts.casing == 1U));
    find_skip_lookup = (size_t *)((void *)0);
    generate_find_skip((char const   *)opts.query, (size_t const   )opts.query_len,
                       & find_skip_lookup, (int const   )((unsigned int )opts.casing == 1U));
    generate_hash((char const   *)opts.query, (size_t const   )opts.query_len, h_table,
                  (int const   )((unsigned int )opts.casing == 1U));
    if (opts.word_regexp) {
      init_wordchar_table();
      opts.literal_starts_wordchar = is_wordchar(*(opts.query + 0));
      opts.literal_ends_wordchar = is_wordchar(*(opts.query + (opts.query_len - 1)));
    }
  } else {
    if ((unsigned int )opts.casing == 2U) {
      pcre_opts |= 1;
    }
    if (opts.word_regexp) {
      ag_asprintf(& word_regexp_query, "\\b(?:%s)\\b", opts.query);
      free((void *)opts.query);
      opts.query = word_regexp_query;
      tmp___10 = strlen((char const   *)opts.query);
      opts.query_len = (int )tmp___10;
    }
    compile_study(& opts.re, & opts.re_extra, opts.query, (int const   )pcre_opts,
                  (int const   )study_opts);
  }
  if (opts.search_stream) {
    search_stream(stdin, "");
  } else {
    i = 0;
    while (i < workers_len) {
      (workers + i)->id = i;
      tmp___11 = pthread_create((pthread_t * __restrict  )(& (workers + i)->thread),
                                (pthread_attr_t const   * __restrict  )((void *)0),
                                & search_file_worker, (void * __restrict  )(& (workers + i)->id));
      rv = tmp___11;
      if (rv != 0) {
        tmp___12 = strerror(rv);
        die("Error in pthread_create(): %s", tmp___12);
      }
      if (opts.use_thread_affinity) {
        while (1) {
          __builtin_memset((void *)(& cpu_set), '\000', (int )sizeof(cpu_set_t ));
          break;
        }
        __cpu = (size_t )(i % num_cores);
        if (__cpu / 8UL < sizeof(cpu_set_t )) {
          cpu_set.__bits[__cpu / (8UL * sizeof(__cpu_mask ))] |= 1UL << __cpu % (8UL * sizeof(__cpu_mask ));
        }
        rv = pthread_setaffinity_np((workers + i)->thread, sizeof(cpu_set), (cpu_set_t const   *)(& cpu_set));
        if (rv) {
          tmp___13 = strerror(rv);
          log_err("Error in pthread_setaffinity_np(): %s", tmp___13);
          log_err("Performance may be affected. Use --noaffinity to suppress this message.");
        } else {
          log_debug("Thread %i set to CPU %i", i, i);
        }
      } else {
        log_debug("Thread affinity disabled.");
      }
      i ++;
    }
    i = 0;
    while ((unsigned long )*(paths + i) != (unsigned long )((void *)0)) {
      log_debug("searching path %s for %s", *(paths + i), opts.query);
      symhash = (symdir_t *)((void *)0);
      tmp___14 = init_ignore(root_ignores, "", (size_t const   )0);
      ig = tmp___14;
      s.st_dev = (__dev_t )0;
      s.st_ino = 0UL;
      s.st_nlink = 0UL;
      s.st_mode = 0U;
      s.st_uid = 0U;
      s.st_gid = 0U;
      s.__pad0 = 0;
      s.st_rdev = 0UL;
      s.st_size = 0L;
      s.st_blksize = 0L;
      s.st_blocks = 0L;
      s.st_atim.tv_sec = 0L;
      s.st_atim.tv_nsec = 0L;
      s.st_mtim.tv_sec = 0L;
      s.st_mtim.tv_nsec = 0L;
      s.st_ctim.tv_sec = 0L;
      s.st_ctim.tv_nsec = 0L;
      s.__glibc_reserved[0] = 0L;
      s.__glibc_reserved[1] = 0L;
      s.__glibc_reserved[2] = 0L;
      if (opts.one_dev) {
        tmp___15 = lstat((char const   * __restrict  )*(paths + i), (struct stat * __restrict  )(& s));
        if (tmp___15 == -1) {
          log_err("Failed to get device information for path %s. Skipping...", *(paths + i));
        }
      }
      search_dir(ig, (char const   *)*(base_paths + i), (char const   *)*(paths + i),
                 (int const   )0, s.st_dev);
      cleanup_ignore(ig);
      i ++;
    }
    pthread_mutex_lock(& work_queue_mtx);
    done_adding_files = 1;
    pthread_cond_broadcast(& files_ready);
    pthread_mutex_unlock(& work_queue_mtx);
    i = 0;
    while (i < workers_len) {
      tmp___16 = pthread_join((workers + i)->thread, (void **)((void *)0));
      if (tmp___16) {
        die("pthread_join failed!");
      }
      i ++;
    }
  }
  if (opts.stats) {
    gettimeofday((struct timeval * __restrict  )(& stats.time_end), (void * __restrict  )((void *)0));
    time_diff = (double )((stats.time_end.tv_sec * 1000000L + stats.time_end.tv_usec) - (stats.time_start.tv_sec * 1000000L + stats.time_start.tv_usec));
    time_diff /= (double )1000000;
    printf((char const   * __restrict  )"%zu matches\n%zu files contained matches\n%zu files searched\n%zu bytes searched\n%f seconds\n",
           stats.total_matches, stats.total_file_matches, stats.total_files, stats.total_bytes,
           time_diff);
    pthread_mutex_destroy(& stats_mtx);
  }
  if (opts.pager) {
    pclose(out_fd);
  }
  cleanup_options();
  pthread_cond_destroy(& files_ready);
  pthread_mutex_destroy(& work_queue_mtx);
  pthread_mutex_destroy(& print_mtx);
  cleanup_ignore(root_ignores);
  free((void *)workers);
  i = 0;
  while ((unsigned long )*(paths + i) != (unsigned long )((void *)0)) {
    free((void *)*(paths + i));
    free((void *)*(base_paths + i));
    i ++;
  }
  free((void *)base_paths);
  free((void *)paths);
  if (find_skip_lookup) {
    free((void *)find_skip_lookup);
  }
  return (! opts.match_found);
}
}
#pragma merger("0","/tmp/cil-c5yistYM.i","-g,-O2,-pthread,-Wall,-Wextra,-Wformat=2,-Wno-format-nonliteral,-Wshadow,-Wpointer-arith,-Wcast-qual,-Wmissing-prototypes,-Wno-missing-braces,-std=gnu89")
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
extern  __attribute__((__nothrow__)) FILE *fopencookie(void * __restrict  __magic_cookie ,
                                                       char const   * __restrict  __modes ,
                                                       cookie_io_functions_t __io_funcs ) ;
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
extern void ( /* format attribute */  warn)(char const   *__format  , ...) ;
extern char const   *zError(int  ) ;
static __ssize_t zfile_read(void *cookie_ , char *buf , size_t size ) ;
static int zfile_seek(void *cookie_ , __off64_t *offset_ , int whence ) ;
static int zfile_close(void *cookie_ ) ;
static struct _IO_cookie_io_functions_t  const  zfile_io  =    {& zfile_read, (cookie_write_function_t *)((void *)0), & zfile_seek, & zfile_close};
static int zfile_cookie_init(struct zfile *cookie ) 
{ 
  lzma_ret lzrc ;
  int rc ;
  char const   *tmp___1 ;
  lzma_stream __constr_expr_1 ;

  {
  if (! (cookie->logic_offset == 0UL)) {
    __assert_fail("cookie->logic_offset == 0", "src/zfile.c", 82U, "zfile_cookie_init");
  }
  if (! (cookie->decode_offset == 0UL)) {
    __assert_fail("cookie->decode_offset == 0", "src/zfile.c", 83U, "zfile_cookie_init");
  }
  cookie->actual_len = (uint64_t )0;
  switch ((unsigned int )cookie->ctype) {
  case 1U: 
  memset((void *)(& cookie->stream.gz), 0, sizeof(cookie->stream.gz));
  rc = inflateInit2_(& cookie->stream.gz, 47, "1.2.11", (int )sizeof(z_stream ));
  if (rc != 0) {
    tmp___1 = zError(rc);
    log_err("Unable to initialize zlib: %s", tmp___1);
    return (5);
  }
  cookie->stream.gz.next_in = (Bytef *)((void *)0);
  cookie->stream.gz.avail_in = (uInt )0;
  cookie->stream.gz.next_out = cookie->outbuf;
  cookie->stream.gz.avail_out = (uInt )sizeof(cookie->outbuf);
  break;
  case 4U: 
  __constr_expr_1.next_in = (uint8_t const   *)((void *)0);
  __constr_expr_1.avail_in = (size_t )0;
  __constr_expr_1.total_in = (uint64_t )0;
  __constr_expr_1.next_out = (uint8_t *)((void *)0);
  __constr_expr_1.avail_out = (size_t )0;
  __constr_expr_1.total_out = (uint64_t )0;
  __constr_expr_1.allocator = (lzma_allocator const   *)((void *)0);
  __constr_expr_1.internal = (lzma_internal *)((void *)0);
  __constr_expr_1.reserved_ptr1 = (void *)0;
  __constr_expr_1.reserved_ptr2 = (void *)0;
  __constr_expr_1.reserved_ptr3 = (void *)0;
  __constr_expr_1.reserved_ptr4 = (void *)0;
  __constr_expr_1.reserved_int1 = (uint64_t )0;
  __constr_expr_1.reserved_int2 = (uint64_t )0;
  __constr_expr_1.reserved_int3 = (size_t )0;
  __constr_expr_1.reserved_int4 = (size_t )0;
  __constr_expr_1.reserved_enum1 = (lzma_reserved_enum )0;
  __constr_expr_1.reserved_enum2 = (lzma_reserved_enum )0;
  cookie->stream.lzma = __constr_expr_1;
  lzrc = lzma_auto_decoder(& cookie->stream.lzma, (uint64_t )-1, (uint32_t )0);
  if ((unsigned int )lzrc != 0U) {
    log_err("Unable to initialize lzma_auto_decoder: %d", (unsigned int )lzrc);
    return (5);
  }
  cookie->stream.lzma.next_in = (uint8_t const   *)((void *)0);
  cookie->stream.lzma.avail_in = (size_t )0;
  cookie->stream.lzma.next_out = cookie->outbuf;
  cookie->stream.lzma.avail_out = sizeof(cookie->outbuf);
  break;
  default: 
  log_err("Unsupported compression type: %d", (unsigned int )cookie->ctype);
  return (22);
  }
  cookie->outbuf_start = (uint32_t )0;
  cookie->eof = (_Bool)0;
  return (0);
}
}
static void zfile_cookie_cleanup(struct zfile *cookie ) 
{ 


  {
  switch ((unsigned int )cookie->ctype) {
  case 1U: 
  inflateEnd(& cookie->stream.gz);
  break;
  case 4U: 
  lzma_end(& cookie->stream.lzma);
  break;
  default: 
  break;
  }
  return;
}
}
FILE *decompress_open(int fd , char const   *mode , ag_compression_type ctype ) 
{ 
  struct zfile *cookie ;
  FILE *res ;
  FILE *in ;
  int error ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
  cookie = (struct zfile *)((void *)0);
  res = (FILE *)((void *)0);
  in = res;
  tmp___0 = strstr(mode, "w");
  if (tmp___0) {
    tmp = __errno_location();
    *tmp = 22;
    goto out;
  } else {
    tmp___1 = strstr(mode, "a");
    if (tmp___1) {
      tmp = __errno_location();
      *tmp = 22;
      goto out;
    }
  }
  in = fdopen(fd, mode);
  if ((unsigned long )in == (unsigned long )((void *)0)) {
    goto out;
  }
  tmp___2 = malloc(sizeof(*cookie));
  cookie = (struct zfile *)tmp___2;
  if ((unsigned long )cookie == (unsigned long )((void *)0)) {
    tmp___3 = __errno_location();
    *tmp___3 = 12;
    goto out;
  }
  cookie->in = in;
  cookie->logic_offset = (uint64_t )0;
  cookie->decode_offset = (uint64_t )0;
  cookie->ctype = ctype;
  error = zfile_cookie_init(cookie);
  if (error != 0) {
    tmp___4 = __errno_location();
    *tmp___4 = error;
    goto out;
  }
  res = fopencookie((void * __restrict  )cookie, (char const   * __restrict  )mode,
                    (cookie_io_functions_t )zfile_io);
  out: 
  if ((unsigned long )res == (unsigned long )((void *)0)) {
    if ((unsigned long )in != (unsigned long )((void *)0)) {
      fclose(in);
    }
    if ((unsigned long )cookie != (unsigned long )((void *)0)) {
      free((void *)cookie);
    }
  }
  return (res);
}
}
static __ssize_t zfile_read(void *cookie_ , char *buf , size_t size ) 
{ 
  struct zfile *cookie ;
  size_t nb ;
  size_t ignorebytes ;
  ssize_t total ;
  lzma_ret lzret ;
  int ret ;
  size_t inflated ;
  size_t left ;
  Bytef *tmp___1 ;
  size_t ignoreskip ;
  size_t _a ;
  size_t _b ;
  size_t tmp___2 ;
  size_t toread ;
  size_t _a___0 ;
  size_t _b___0 ;
  size_t tmp___3 ;
  Bytef *tmp___4 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  char const   *tmp___9 ;
  Bytef *tmp___10 ;
  int tmp___11 ;

  {
  cookie = (struct zfile *)cookie_;
  total = (ssize_t )0;
  if (! (size <= 9223372036854775807UL)) {
    __assert_fail("size <= SSIZE_MAX", "src/zfile.c", 213U, "zfile_read");
  }
  if (size == 0UL) {
    return ((__ssize_t )0);
  }
  if (cookie->eof) {
    return ((__ssize_t )0);
  }
  ret = 0;
  lzret = (lzma_ret )0;
  ignorebytes = cookie->logic_offset - cookie->decode_offset;
  if (! (ignorebytes == 0UL)) {
    __assert_fail("ignorebytes == 0", "src/zfile.c", 225U, "zfile_read");
  }
  while (1) {
    while (1) {
      if ((unsigned int )cookie->ctype == 1U) {
        tmp___4 = cookie->stream.gz.next_out;
      } else {
        tmp___4 = cookie->stream.lzma.next_out;
      }
      if (! ((unsigned long )tmp___4 > (unsigned long )(& cookie->outbuf[cookie->outbuf_start]))) {
        break;
      }
      if ((unsigned int )cookie->ctype == 1U) {
        tmp___1 = cookie->stream.gz.next_out;
      } else {
        tmp___1 = cookie->stream.lzma.next_out;
      }
      left = (size_t )(tmp___1 - & cookie->outbuf[cookie->outbuf_start]);
      _a = ignorebytes;
      _b = left;
      if (_a < _b) {
        tmp___2 = _a;
      } else {
        tmp___2 = _b;
      }
      ignoreskip = tmp___2;
      if (ignoreskip > 0UL) {
        ignorebytes -= ignoreskip;
        left -= ignoreskip;
        cookie->outbuf_start = (uint32_t )((size_t )cookie->outbuf_start + ignoreskip);
        cookie->decode_offset += ignoreskip;
      }
      if (ignorebytes > 0UL) {
        break;
      }
      _a___0 = left;
      _b___0 = size;
      if (_a___0 < _b___0) {
        tmp___3 = _a___0;
      } else {
        tmp___3 = _b___0;
      }
      toread = tmp___3;
      memcpy((void * __restrict  )buf, (void const   * __restrict  )(& cookie->outbuf[cookie->outbuf_start]),
             toread);
      buf += toread;
      size -= toread;
      left -= toread;
      cookie->outbuf_start = (uint32_t )((size_t )cookie->outbuf_start + toread);
      cookie->decode_offset += toread;
      cookie->logic_offset += toread;
      total = (ssize_t )((size_t )total + toread);
      if (size == 0UL) {
        break;
      }
    }
    if (size == 0UL) {
      break;
    }
    if (! ((unsigned long )cookie->stream.gz.next_out == (unsigned long )(& cookie->outbuf[cookie->outbuf_start]))) {
      __assert_fail("cookie->stream.gz.next_out == &cookie->outbuf[cookie->outbuf_start]",
                    "src/zfile.c", 273U, "zfile_read");
    }
    if ((unsigned int )cookie->ctype == 4U) {
      if ((unsigned int )lzret == 1U) {
        cookie->eof = (_Bool)1;
        break;
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if ((unsigned int )cookie->ctype == 1U) {
      if (ret == 1) {
        cookie->eof = (_Bool)1;
        break;
      }
    }
    if ((unsigned int )cookie->ctype == 1U) {
      tmp___8 = (size_t )cookie->stream.gz.avail_in;
    } else {
      tmp___8 = cookie->stream.lzma.avail_in;
    }
    if (tmp___8 == 0UL) {
      nb = fread((void * __restrict  )(cookie->inbuf), (size_t )1, sizeof(cookie->inbuf),
                 (FILE * __restrict  )cookie->in);
      tmp___6 = ferror(cookie->in);
      if (tmp___6) {
        warn("error read core");
        exit(1);
      }
      if (nb == 0UL) {
        tmp___7 = feof(cookie->in);
        if (tmp___7) {
          warn("truncated file");
          exit(1);
        }
      }
      if ((unsigned int )cookie->ctype == 4U) {
        cookie->stream.lzma.avail_in = nb;
        cookie->stream.lzma.next_in = (uint8_t const   *)(cookie->inbuf);
      } else {
        cookie->stream.gz.avail_in = (uInt )nb;
        cookie->stream.gz.next_in = cookie->inbuf;
      }
    }
    if ((unsigned int )cookie->ctype == 4U) {
      cookie->stream.lzma.next_out = cookie->outbuf;
      cookie->stream.lzma.avail_out = sizeof(cookie->outbuf);
    } else {
      cookie->stream.gz.next_out = cookie->outbuf;
      cookie->stream.gz.avail_out = (uInt )sizeof(cookie->outbuf);
    }
    cookie->outbuf_start = (uint32_t )0;
    if ((unsigned int )cookie->ctype == 1U) {
      ret = inflate(& cookie->stream.gz, 0);
      if (ret != 0) {
        if (ret != 1) {
          tmp___9 = zError(ret);
          log_err("Found mem/data error while decompressing zlib stream: %s", tmp___9);
          return ((__ssize_t )-1);
        }
      }
    } else {
      lzret = lzma_code(& cookie->stream.lzma, (lzma_action )0);
      if ((unsigned int )lzret != 0U) {
        if ((unsigned int )lzret != 1U) {
          log_err("Found mem/data error while decompressing xz/lzma stream: %d", (unsigned int )lzret);
          return ((__ssize_t )-1);
        }
      }
    }
    if ((unsigned int )cookie->ctype == 1U) {
      tmp___10 = cookie->stream.gz.next_out;
    } else {
      tmp___10 = cookie->stream.lzma.next_out;
    }
    inflated = (size_t )(tmp___10 - & cookie->outbuf[0]);
    cookie->actual_len += inflated;
    tmp___11 = ferror(cookie->in);
    if (tmp___11) {
      break;
    } else
    if (! (size > 0UL)) {
      break;
    }
  }
  if (! (total <= 9223372036854775807L)) {
    __assert_fail("total <= SSIZE_MAX", "src/zfile.c", 329U, "zfile_read");
  }
  return (total);
}
}
static int zfile_seek(void *cookie_ , __off64_t *offset_ , int whence ) 
{ 
  struct zfile *cookie ;
  off64_t new_offset ;
  off64_t offset ;
  char *buf ;
  size_t bsz ;
  void *tmp ;
  size_t diff ;
  size_t _a ;
  uint64_t _b ;
  size_t tmp___0 ;
  ssize_t err___0 ;
  __ssize_t tmp___1 ;

  {
  cookie = (struct zfile *)cookie_;
  new_offset = (off64_t )0;
  offset = *offset_;
  if (whence == 0) {
    new_offset = offset;
  } else
  if (whence == 1) {
    new_offset = (off64_t )cookie->logic_offset + offset;
  } else {
    return (-1);
  }
  if (new_offset < 0L) {
    return (-1);
  }
  if (new_offset < (off64_t )cookie->logic_offset) {
    if (new_offset != 0L) {
      return (-1);
    }
  }
  if (new_offset == 0L) {
    cookie->decode_offset = (uint64_t )0;
    cookie->logic_offset = (uint64_t )0;
    zfile_cookie_cleanup(cookie);
    zfile_cookie_init(cookie);
  } else
  if ((uint64_t )new_offset > cookie->logic_offset) {
    bsz = (size_t )32768;
    tmp = malloc(bsz);
    buf = (char *)tmp;
    while ((uint64_t )new_offset > cookie->logic_offset) {
      _a = bsz;
      _b = (uint64_t )new_offset - cookie->logic_offset;
      if (_a < _b) {
        tmp___0 = _a;
      } else {
        tmp___0 = _b;
      }
      diff = tmp___0;
      tmp___1 = zfile_read(cookie_, buf, diff);
      err___0 = tmp___1;
      if (err___0 < 0L) {
        free((void *)buf);
        return (-1);
      }
      if (err___0 == 0L) {
        if (! cookie->eof) {
          __assert_fail("cookie->eof", "src/zfile.c", 378U, "zfile_seek");
        }
        new_offset = (off64_t )cookie->logic_offset;
        break;
      }
    }
    free((void *)buf);
  }
  if (! (cookie->logic_offset == (uint64_t )new_offset)) {
    __assert_fail("cookie->logic_offset == (uint64_t)new_offset", "src/zfile.c", 386U,
                  "zfile_seek");
  }
  *offset_ = new_offset;
  return (0);
}
}
static int zfile_close(void *cookie_ ) 
{ 
  struct zfile *cookie ;

  {
  cookie = (struct zfile *)cookie_;
  zfile_cookie_cleanup(cookie);
  fclose(cookie->in);
  free((void *)cookie);
  return (0);
}
}
