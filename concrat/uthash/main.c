/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef unsigned int __uint32_t;
typedef long __off_t;
typedef long __off64_t;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
struct __pthread_rwlock_arch_t {
   unsigned int __readers ;
   unsigned int __writers ;
   unsigned int __wrphase_futex ;
   unsigned int __writers_futex ;
   unsigned int __pad3 ;
   unsigned int __pad4 ;
   int __cur_writer ;
   int __shared ;
   signed char __rwelision ;
   unsigned char __pad1[7] ;
   unsigned long __pad2 ;
   unsigned int __flags ;
};
typedef unsigned long pthread_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
union __anonunion_pthread_rwlock_t_656928968 {
   struct __pthread_rwlock_arch_t __data ;
   char __size[56] ;
   long __align ;
};
typedef union __anonunion_pthread_rwlock_t_656928968 pthread_rwlock_t;
union __anonunion_pthread_rwlockattr_t_145707745 {
   char __size[8] ;
   long __align ;
};
typedef union __anonunion_pthread_rwlockattr_t_145707745 pthread_rwlockattr_t;
typedef long ptrdiff_t;
typedef __uint32_t uint32_t;
struct UT_hash_handle ;
struct UT_hash_bucket {
   struct UT_hash_handle *hh_head ;
   unsigned int count ;
   unsigned int expand_mult ;
};
typedef struct UT_hash_bucket UT_hash_bucket;
struct UT_hash_table {
   UT_hash_bucket *buckets ;
   unsigned int num_buckets ;
   unsigned int log2_num_buckets ;
   unsigned int num_items ;
   struct UT_hash_handle *tail ;
   ptrdiff_t hho ;
   unsigned int ideal_chain_maxlen ;
   unsigned int nonideal_items ;
   unsigned int ineff_expands ;
   unsigned int noexpand ;
   uint32_t signature ;
};
typedef struct UT_hash_table UT_hash_table;
struct UT_hash_handle {
   struct UT_hash_table *tbl ;
   void *prev ;
   void *next ;
   struct UT_hash_handle *hh_prev ;
   struct UT_hash_handle *hh_next ;
   void const   *key ;
   unsigned int keylen ;
   unsigned int hashv ;
};
typedef struct UT_hash_handle UT_hash_handle;
struct __anonstruct_elt_521126190 {
   int i ;
   UT_hash_handle hh ;
};
typedef struct __anonstruct_elt_521126190 elt;
#pragma merger("0","/tmp/cil-fEyfEM0f.i","-pthread")
extern FILE *stderr ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_rwlock_init)(pthread_rwlock_t * __restrict  __rwlock ,
                                                                                                pthread_rwlockattr_t const   * __restrict  __attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_rwlock_destroy)(pthread_rwlock_t *__rwlock ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_rwlock_rdlock)(pthread_rwlock_t *__rwlock ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_rwlock_wrlock)(pthread_rwlock_t *__rwlock ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_rwlock_unlock)(pthread_rwlock_t *__rwlock ) ;
elt *elts  =    (elt *)((void *)0);
pthread_rwlock_t lock  ;
void *thread_routine_r(void *arg ) 
{ 
  int i ;
  long num_found ;
  elt *e ;
  int tmp ;
  unsigned int _hf_hashv ;
  unsigned int _hj_i ;
  unsigned int _hj_j ;
  unsigned int _hj_k ;
  unsigned char const   *_hj_key ;
  unsigned int _hf_bkt ;
  int tmp___0 ;

  {
  num_found = 0L;
  i = 0;
  while (i < 100000) {
    tmp = pthread_rwlock_rdlock(& lock);
    if (tmp != 0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"can\'t acquire read lock\n");
      exit(-1);
    }
    while (1) {
      e = (elt *)((void *)0);
      if (elts) {
        while (1) {
          while (1) {
            _hj_key = (unsigned char const   *)(& i);
            _hf_hashv = 4276993775U;
            _hj_j = 2654435769U;
            _hj_i = _hj_j;
            _hj_k = (unsigned int )sizeof(int );
            while (_hj_k >= 12U) {
              _hj_i += (((unsigned int )*(_hj_key + 0) + ((unsigned int )*(_hj_key + 1) << 8)) + ((unsigned int )*(_hj_key + 2) << 16)) + ((unsigned int )*(_hj_key + 3) << 24);
              _hj_j += (((unsigned int )*(_hj_key + 4) + ((unsigned int )*(_hj_key + 5) << 8)) + ((unsigned int )*(_hj_key + 6) << 16)) + ((unsigned int )*(_hj_key + 7) << 24);
              _hf_hashv += (((unsigned int )*(_hj_key + 8) + ((unsigned int )*(_hj_key + 9) << 8)) + ((unsigned int )*(_hj_key + 10) << 16)) + ((unsigned int )*(_hj_key + 11) << 24);
              while (1) {
                _hj_i -= _hj_j;
                _hj_i -= _hf_hashv;
                _hj_i ^= _hf_hashv >> 13;
                _hj_j -= _hf_hashv;
                _hj_j -= _hj_i;
                _hj_j ^= _hj_i << 8;
                _hf_hashv -= _hj_i;
                _hf_hashv -= _hj_j;
                _hf_hashv ^= _hj_j >> 13;
                _hj_i -= _hj_j;
                _hj_i -= _hf_hashv;
                _hj_i ^= _hf_hashv >> 12;
                _hj_j -= _hf_hashv;
                _hj_j -= _hj_i;
                _hj_j ^= _hj_i << 16;
                _hf_hashv -= _hj_i;
                _hf_hashv -= _hj_j;
                _hf_hashv ^= _hj_j >> 5;
                _hj_i -= _hj_j;
                _hj_i -= _hf_hashv;
                _hj_i ^= _hf_hashv >> 3;
                _hj_j -= _hf_hashv;
                _hj_j -= _hj_i;
                _hj_j ^= _hj_i << 10;
                _hf_hashv -= _hj_i;
                _hf_hashv -= _hj_j;
                _hf_hashv ^= _hj_j >> 15;
                break;
              }
              _hj_key += 12;
              _hj_k -= 12U;
            }
            _hf_hashv += (unsigned int )sizeof(int );
            switch (_hj_k) {
            case 11U: 
            _hf_hashv += (unsigned int )*(_hj_key + 10) << 24;
            case 10U: 
            _hf_hashv += (unsigned int )*(_hj_key + 9) << 16;
            case 9U: 
            _hf_hashv += (unsigned int )*(_hj_key + 8) << 8;
            case 8U: 
            _hj_j += (unsigned int )*(_hj_key + 7) << 24;
            case 7U: 
            _hj_j += (unsigned int )*(_hj_key + 6) << 16;
            case 6U: 
            _hj_j += (unsigned int )*(_hj_key + 5) << 8;
            case 5U: 
            _hj_j += (unsigned int )*(_hj_key + 4);
            case 4U: 
            _hj_i += (unsigned int )*(_hj_key + 3) << 24;
            case 3U: 
            _hj_i += (unsigned int )*(_hj_key + 2) << 16;
            case 2U: 
            _hj_i += (unsigned int )*(_hj_key + 1) << 8;
            case 1U: 
            _hj_i += (unsigned int )*(_hj_key + 0);
            default: ;
            }
            while (1) {
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 13;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 8;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 13;
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 12;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 16;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 5;
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 3;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 10;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 15;
              break;
            }
            break;
          }
          break;
        }
        while (1) {
          e = (elt *)((void *)0);
          if (elts) {
            while (1) {
              _hf_bkt = _hf_hashv & ((elts->hh.tbl)->num_buckets - 1U);
              break;
            }
            while (1) {
              if ((unsigned long )((elts->hh.tbl)->buckets + _hf_bkt)->hh_head != (unsigned long )((void *)0)) {
                while (1) {
                  e = (elt *)((void *)((char *)((elts->hh.tbl)->buckets + _hf_bkt)->hh_head - (elts->hh.tbl)->hho));
                  break;
                }
              } else {
                e = (elt *)((void *)0);
              }
              while ((unsigned long )e != (unsigned long )((void *)0)) {
                if (e->hh.hashv == _hf_hashv) {
                  if ((unsigned long )e->hh.keylen == sizeof(int )) {
                    tmp___0 = memcmp(e->hh.key, (void const   *)(& i), sizeof(int ));
                    if (tmp___0 == 0) {
                      break;
                    }
                  }
                }
                if ((unsigned long )e->hh.hh_next != (unsigned long )((void *)0)) {
                  while (1) {
                    e = (elt *)((void *)((char *)e->hh.hh_next - (elts->hh.tbl)->hho));
                    break;
                  }
                } else {
                  e = (elt *)((void *)0);
                }
              }
              break;
            }
          }
          break;
        }
      }
      break;
    }
    if (e) {
      num_found ++;
    }
    pthread_rwlock_unlock(& lock);
    i ++;
  }
  return ((void *)num_found);
}
}
void *thread_routine_w(void *arg ) 
{ 
  int i ;
  long num_deld ;
  elt *e ;
  int tmp ;
  unsigned int _hf_hashv ;
  unsigned int _hj_i ;
  unsigned int _hj_j ;
  unsigned int _hj_k ;
  unsigned char const   *_hj_key ;
  unsigned int _hf_bkt ;
  int tmp___0 ;
  void *tmp___1 ;
  unsigned int _ha_hashv ;
  unsigned int _hj_i___0 ;
  unsigned int _hj_j___0 ;
  unsigned int _hj_k___0 ;
  unsigned char const   *_hj_key___0 ;
  void *tmp___2 ;
  void *tmp___3 ;
  unsigned int _ha_bkt ;
  UT_hash_bucket *_ha_head ;
  unsigned int _he_bkt ;
  unsigned int _he_bkt_i ;
  struct UT_hash_handle *_he_thh ;
  struct UT_hash_handle *_he_hh_nxt ;
  UT_hash_bucket *_he_new_buckets ;
  UT_hash_bucket *_he_newbkt ;
  void *tmp___4 ;
  unsigned int tmp___5 ;

  {
  num_deld = 0L;
  i = 0;
  while (i < 100000) {
    tmp = pthread_rwlock_wrlock(& lock);
    if (tmp != 0) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"can\'t acquire write lock\n");
      exit(-1);
    }
    while (1) {
      e = (elt *)((void *)0);
      if (elts) {
        while (1) {
          while (1) {
            _hj_key = (unsigned char const   *)(& i);
            _hf_hashv = 4276993775U;
            _hj_j = 2654435769U;
            _hj_i = _hj_j;
            _hj_k = (unsigned int )sizeof(int );
            while (_hj_k >= 12U) {
              _hj_i += (((unsigned int )*(_hj_key + 0) + ((unsigned int )*(_hj_key + 1) << 8)) + ((unsigned int )*(_hj_key + 2) << 16)) + ((unsigned int )*(_hj_key + 3) << 24);
              _hj_j += (((unsigned int )*(_hj_key + 4) + ((unsigned int )*(_hj_key + 5) << 8)) + ((unsigned int )*(_hj_key + 6) << 16)) + ((unsigned int )*(_hj_key + 7) << 24);
              _hf_hashv += (((unsigned int )*(_hj_key + 8) + ((unsigned int )*(_hj_key + 9) << 8)) + ((unsigned int )*(_hj_key + 10) << 16)) + ((unsigned int )*(_hj_key + 11) << 24);
              while (1) {
                _hj_i -= _hj_j;
                _hj_i -= _hf_hashv;
                _hj_i ^= _hf_hashv >> 13;
                _hj_j -= _hf_hashv;
                _hj_j -= _hj_i;
                _hj_j ^= _hj_i << 8;
                _hf_hashv -= _hj_i;
                _hf_hashv -= _hj_j;
                _hf_hashv ^= _hj_j >> 13;
                _hj_i -= _hj_j;
                _hj_i -= _hf_hashv;
                _hj_i ^= _hf_hashv >> 12;
                _hj_j -= _hf_hashv;
                _hj_j -= _hj_i;
                _hj_j ^= _hj_i << 16;
                _hf_hashv -= _hj_i;
                _hf_hashv -= _hj_j;
                _hf_hashv ^= _hj_j >> 5;
                _hj_i -= _hj_j;
                _hj_i -= _hf_hashv;
                _hj_i ^= _hf_hashv >> 3;
                _hj_j -= _hf_hashv;
                _hj_j -= _hj_i;
                _hj_j ^= _hj_i << 10;
                _hf_hashv -= _hj_i;
                _hf_hashv -= _hj_j;
                _hf_hashv ^= _hj_j >> 15;
                break;
              }
              _hj_key += 12;
              _hj_k -= 12U;
            }
            _hf_hashv += (unsigned int )sizeof(int );
            switch (_hj_k) {
            case 11U: 
            _hf_hashv += (unsigned int )*(_hj_key + 10) << 24;
            case 10U: 
            _hf_hashv += (unsigned int )*(_hj_key + 9) << 16;
            case 9U: 
            _hf_hashv += (unsigned int )*(_hj_key + 8) << 8;
            case 8U: 
            _hj_j += (unsigned int )*(_hj_key + 7) << 24;
            case 7U: 
            _hj_j += (unsigned int )*(_hj_key + 6) << 16;
            case 6U: 
            _hj_j += (unsigned int )*(_hj_key + 5) << 8;
            case 5U: 
            _hj_j += (unsigned int )*(_hj_key + 4);
            case 4U: 
            _hj_i += (unsigned int )*(_hj_key + 3) << 24;
            case 3U: 
            _hj_i += (unsigned int )*(_hj_key + 2) << 16;
            case 2U: 
            _hj_i += (unsigned int )*(_hj_key + 1) << 8;
            case 1U: 
            _hj_i += (unsigned int )*(_hj_key + 0);
            default: ;
            }
            while (1) {
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 13;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 8;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 13;
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 12;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 16;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 5;
              _hj_i -= _hj_j;
              _hj_i -= _hf_hashv;
              _hj_i ^= _hf_hashv >> 3;
              _hj_j -= _hf_hashv;
              _hj_j -= _hj_i;
              _hj_j ^= _hj_i << 10;
              _hf_hashv -= _hj_i;
              _hf_hashv -= _hj_j;
              _hf_hashv ^= _hj_j >> 15;
              break;
            }
            break;
          }
          break;
        }
        while (1) {
          e = (elt *)((void *)0);
          if (elts) {
            while (1) {
              _hf_bkt = _hf_hashv & ((elts->hh.tbl)->num_buckets - 1U);
              break;
            }
            while (1) {
              if ((unsigned long )((elts->hh.tbl)->buckets + _hf_bkt)->hh_head != (unsigned long )((void *)0)) {
                while (1) {
                  e = (elt *)((void *)((char *)((elts->hh.tbl)->buckets + _hf_bkt)->hh_head - (elts->hh.tbl)->hho));
                  break;
                }
              } else {
                e = (elt *)((void *)0);
              }
              while ((unsigned long )e != (unsigned long )((void *)0)) {
                if (e->hh.hashv == _hf_hashv) {
                  if ((unsigned long )e->hh.keylen == sizeof(int )) {
                    tmp___0 = memcmp(e->hh.key, (void const   *)(& i), sizeof(int ));
                    if (tmp___0 == 0) {
                      break;
                    }
                  }
                }
                if ((unsigned long )e->hh.hh_next != (unsigned long )((void *)0)) {
                  while (1) {
                    e = (elt *)((void *)((char *)e->hh.hh_next - (elts->hh.tbl)->hho));
                    break;
                  }
                } else {
                  e = (elt *)((void *)0);
                }
              }
              break;
            }
          }
          break;
        }
      }
      break;
    }
    if (! e) {
      tmp___1 = malloc(sizeof(elt ));
      e = (elt *)tmp___1;
      if (! e) {
        exit(-1);
      }
      e->i = i;
      while (1) {
        while (1) {
          while (1) {
            _hj_key___0 = (unsigned char const   *)(& e->i);
            _ha_hashv = 4276993775U;
            _hj_j___0 = 2654435769U;
            _hj_i___0 = _hj_j___0;
            _hj_k___0 = (unsigned int )sizeof(int );
            while (_hj_k___0 >= 12U) {
              _hj_i___0 += (((unsigned int )*(_hj_key___0 + 0) + ((unsigned int )*(_hj_key___0 + 1) << 8)) + ((unsigned int )*(_hj_key___0 + 2) << 16)) + ((unsigned int )*(_hj_key___0 + 3) << 24);
              _hj_j___0 += (((unsigned int )*(_hj_key___0 + 4) + ((unsigned int )*(_hj_key___0 + 5) << 8)) + ((unsigned int )*(_hj_key___0 + 6) << 16)) + ((unsigned int )*(_hj_key___0 + 7) << 24);
              _ha_hashv += (((unsigned int )*(_hj_key___0 + 8) + ((unsigned int )*(_hj_key___0 + 9) << 8)) + ((unsigned int )*(_hj_key___0 + 10) << 16)) + ((unsigned int )*(_hj_key___0 + 11) << 24);
              while (1) {
                _hj_i___0 -= _hj_j___0;
                _hj_i___0 -= _ha_hashv;
                _hj_i___0 ^= _ha_hashv >> 13;
                _hj_j___0 -= _ha_hashv;
                _hj_j___0 -= _hj_i___0;
                _hj_j___0 ^= _hj_i___0 << 8;
                _ha_hashv -= _hj_i___0;
                _ha_hashv -= _hj_j___0;
                _ha_hashv ^= _hj_j___0 >> 13;
                _hj_i___0 -= _hj_j___0;
                _hj_i___0 -= _ha_hashv;
                _hj_i___0 ^= _ha_hashv >> 12;
                _hj_j___0 -= _ha_hashv;
                _hj_j___0 -= _hj_i___0;
                _hj_j___0 ^= _hj_i___0 << 16;
                _ha_hashv -= _hj_i___0;
                _ha_hashv -= _hj_j___0;
                _ha_hashv ^= _hj_j___0 >> 5;
                _hj_i___0 -= _hj_j___0;
                _hj_i___0 -= _ha_hashv;
                _hj_i___0 ^= _ha_hashv >> 3;
                _hj_j___0 -= _ha_hashv;
                _hj_j___0 -= _hj_i___0;
                _hj_j___0 ^= _hj_i___0 << 10;
                _ha_hashv -= _hj_i___0;
                _ha_hashv -= _hj_j___0;
                _ha_hashv ^= _hj_j___0 >> 15;
                break;
              }
              _hj_key___0 += 12;
              _hj_k___0 -= 12U;
            }
            _ha_hashv += (unsigned int )sizeof(int );
            switch (_hj_k___0) {
            case 11U: 
            _ha_hashv += (unsigned int )*(_hj_key___0 + 10) << 24;
            case 10U: 
            _ha_hashv += (unsigned int )*(_hj_key___0 + 9) << 16;
            case 9U: 
            _ha_hashv += (unsigned int )*(_hj_key___0 + 8) << 8;
            case 8U: 
            _hj_j___0 += (unsigned int )*(_hj_key___0 + 7) << 24;
            case 7U: 
            _hj_j___0 += (unsigned int )*(_hj_key___0 + 6) << 16;
            case 6U: 
            _hj_j___0 += (unsigned int )*(_hj_key___0 + 5) << 8;
            case 5U: 
            _hj_j___0 += (unsigned int )*(_hj_key___0 + 4);
            case 4U: 
            _hj_i___0 += (unsigned int )*(_hj_key___0 + 3) << 24;
            case 3U: 
            _hj_i___0 += (unsigned int )*(_hj_key___0 + 2) << 16;
            case 2U: 
            _hj_i___0 += (unsigned int )*(_hj_key___0 + 1) << 8;
            case 1U: 
            _hj_i___0 += (unsigned int )*(_hj_key___0 + 0);
            default: ;
            }
            while (1) {
              _hj_i___0 -= _hj_j___0;
              _hj_i___0 -= _ha_hashv;
              _hj_i___0 ^= _ha_hashv >> 13;
              _hj_j___0 -= _ha_hashv;
              _hj_j___0 -= _hj_i___0;
              _hj_j___0 ^= _hj_i___0 << 8;
              _ha_hashv -= _hj_i___0;
              _ha_hashv -= _hj_j___0;
              _ha_hashv ^= _hj_j___0 >> 13;
              _hj_i___0 -= _hj_j___0;
              _hj_i___0 -= _ha_hashv;
              _hj_i___0 ^= _ha_hashv >> 12;
              _hj_j___0 -= _ha_hashv;
              _hj_j___0 -= _hj_i___0;
              _hj_j___0 ^= _hj_i___0 << 16;
              _ha_hashv -= _hj_i___0;
              _ha_hashv -= _hj_j___0;
              _ha_hashv ^= _hj_j___0 >> 5;
              _hj_i___0 -= _hj_j___0;
              _hj_i___0 -= _ha_hashv;
              _hj_i___0 ^= _ha_hashv >> 3;
              _hj_j___0 -= _ha_hashv;
              _hj_j___0 -= _hj_i___0;
              _hj_j___0 ^= _hj_i___0 << 10;
              _ha_hashv -= _hj_i___0;
              _ha_hashv -= _hj_j___0;
              _ha_hashv ^= _hj_j___0 >> 15;
              break;
            }
            break;
          }
          break;
        }
        while (1) {
          e->hh.hashv = _ha_hashv;
          e->hh.key = (void const   *)(& e->i);
          e->hh.keylen = (unsigned int )sizeof(int );
          if (! elts) {
            e->hh.next = (void *)0;
            e->hh.prev = (void *)0;
            while (1) {
              tmp___2 = malloc(sizeof(UT_hash_table ));
              e->hh.tbl = (UT_hash_table *)tmp___2;
              if (! e->hh.tbl) {
                exit(-1);
              } else {
                memset((void *)e->hh.tbl, '\000', sizeof(UT_hash_table ));
                (e->hh.tbl)->tail = & e->hh;
                (e->hh.tbl)->num_buckets = 32U;
                (e->hh.tbl)->log2_num_buckets = 5U;
                (e->hh.tbl)->hho = (char *)(& e->hh) - (char *)e;
                tmp___3 = malloc(32UL * sizeof(struct UT_hash_bucket ));
                (e->hh.tbl)->buckets = (UT_hash_bucket *)tmp___3;
                (e->hh.tbl)->signature = 2685476833U;
                if (! (e->hh.tbl)->buckets) {
                  exit(-1);
                  free((void *)e->hh.tbl);
                } else {
                  memset((void *)(e->hh.tbl)->buckets, '\000', 32UL * sizeof(struct UT_hash_bucket ));
                }
              }
              break;
            }
            elts = e;
          } else {
            e->hh.tbl = elts->hh.tbl;
            while (1) {
              e->hh.next = (void *)0;
              e->hh.prev = (void *)((char *)(elts->hh.tbl)->tail - (elts->hh.tbl)->hho);
              ((elts->hh.tbl)->tail)->next = (void *)e;
              (elts->hh.tbl)->tail = & e->hh;
              break;
            }
          }
          while (1) {
            ((elts->hh.tbl)->num_items) ++;
            while (1) {
              _ha_bkt = _ha_hashv & ((elts->hh.tbl)->num_buckets - 1U);
              break;
            }
            while (1) {
              _ha_head = (elts->hh.tbl)->buckets + _ha_bkt;
              (_ha_head->count) ++;
              e->hh.hh_next = _ha_head->hh_head;
              e->hh.hh_prev = (struct UT_hash_handle *)((void *)0);
              if ((unsigned long )_ha_head->hh_head != (unsigned long )((void *)0)) {
                (_ha_head->hh_head)->hh_prev = & e->hh;
              }
              _ha_head->hh_head = & e->hh;
              if (_ha_head->count >= (_ha_head->expand_mult + 1U) * 10U) {
                if (! (e->hh.tbl)->noexpand) {
                  while (1) {
                    tmp___4 = malloc((sizeof(struct UT_hash_bucket ) * (unsigned long )(e->hh.tbl)->num_buckets) * 2UL);
                    _he_new_buckets = (UT_hash_bucket *)tmp___4;
                    if (! _he_new_buckets) {
                      exit(-1);
                    } else {
                      memset((void *)_he_new_buckets, '\000', (sizeof(struct UT_hash_bucket ) * (unsigned long )(e->hh.tbl)->num_buckets) * 2UL);
                      if (((e->hh.tbl)->num_items & ((e->hh.tbl)->num_buckets * 2U - 1U)) != 0U) {
                        tmp___5 = 1U;
                      } else {
                        tmp___5 = 0U;
                      }
                      (e->hh.tbl)->ideal_chain_maxlen = ((e->hh.tbl)->num_items >> ((e->hh.tbl)->log2_num_buckets + 1U)) + tmp___5;
                      (e->hh.tbl)->nonideal_items = 0U;
                      _he_bkt_i = 0U;
                      while (_he_bkt_i < (e->hh.tbl)->num_buckets) {
                        _he_thh = ((e->hh.tbl)->buckets + _he_bkt_i)->hh_head;
                        while ((unsigned long )_he_thh != (unsigned long )((void *)0)) {
                          _he_hh_nxt = _he_thh->hh_next;
                          while (1) {
                            _he_bkt = _he_thh->hashv & ((e->hh.tbl)->num_buckets * 2U - 1U);
                            break;
                          }
                          _he_newbkt = _he_new_buckets + _he_bkt;
                          (_he_newbkt->count) ++;
                          if (_he_newbkt->count > (e->hh.tbl)->ideal_chain_maxlen) {
                            ((e->hh.tbl)->nonideal_items) ++;
                            if (_he_newbkt->count > _he_newbkt->expand_mult * (e->hh.tbl)->ideal_chain_maxlen) {
                              (_he_newbkt->expand_mult) ++;
                            }
                          }
                          _he_thh->hh_prev = (struct UT_hash_handle *)((void *)0);
                          _he_thh->hh_next = _he_newbkt->hh_head;
                          if ((unsigned long )_he_newbkt->hh_head != (unsigned long )((void *)0)) {
                            (_he_newbkt->hh_head)->hh_prev = _he_thh;
                          }
                          _he_newbkt->hh_head = _he_thh;
                          _he_thh = _he_hh_nxt;
                        }
                        _he_bkt_i ++;
                      }
                      free((void *)(e->hh.tbl)->buckets);
                      (e->hh.tbl)->num_buckets *= 2U;
                      ((e->hh.tbl)->log2_num_buckets) ++;
                      (e->hh.tbl)->buckets = _he_new_buckets;
                      if ((e->hh.tbl)->nonideal_items > (e->hh.tbl)->num_items >> 1) {
                        ((e->hh.tbl)->ineff_expands) ++;
                      } else {
                        (e->hh.tbl)->ineff_expands = 0U;
                      }
                      if ((e->hh.tbl)->ineff_expands > 1U) {
                        (e->hh.tbl)->noexpand = 1U;
                        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"warning: bucket expansion inhibited\n");
                      }
                    }
                    break;
                  }
                }
              }
              break;
            }
            break;
          }
          break;
        }
        break;
      }
    }
    pthread_rwlock_unlock(& lock);
    i ++;
  }
  return ((void *)num_deld);
}
}
int main(void) 
{ 
  unsigned int i ;
  long num_added ;
  int status ;
  pthread_t thread_r1 ;
  pthread_t thread_r2 ;
  pthread_t thread_w1 ;
  pthread_t thread_w2 ;
  void *thread_result ;
  int tmp___0 ;
  int tmp___1 ;

  {
  num_added = 0L;
  tmp___0 = pthread_rwlock_init((pthread_rwlock_t * __restrict  )(& lock), (pthread_rwlockattr_t const   * __restrict  )((void *)0));
  if (tmp___0 != 0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"lock init failed\n");
    exit(-1);
  }
  status = pthread_create((pthread_t * __restrict  )(& thread_r1), (pthread_attr_t const   * __restrict  )((void *)0),
                          & thread_routine_r, (void * __restrict  )((void *)0));
  if (status) {
    printf((char const   * __restrict  )"failure: status %d\n", status);
    exit(-1);
  }
  status = pthread_create((pthread_t * __restrict  )(& thread_r2), (pthread_attr_t const   * __restrict  )((void *)0),
                          & thread_routine_r, (void * __restrict  )((void *)0));
  if (status) {
    printf((char const   * __restrict  )"failure: status %d\n", status);
    exit(-1);
  }
  status = pthread_create((pthread_t * __restrict  )(& thread_w1), (pthread_attr_t const   * __restrict  )((void *)0),
                          & thread_routine_w, (void * __restrict  )((void *)0));
  if (status) {
    printf((char const   * __restrict  )"failure: status %d\n", status);
    exit(-1);
  }
  status = pthread_create((pthread_t * __restrict  )(& thread_w2), (pthread_attr_t const   * __restrict  )((void *)0),
                          & thread_routine_w, (void * __restrict  )((void *)0));
  if (status) {
    printf((char const   * __restrict  )"failure: status %d\n", status);
    exit(-1);
  }
  status = pthread_join(thread_r1, & thread_result);
  printf((char const   * __restrict  )"thread result: %d %ld\n", status, (long )thread_result);
  status = pthread_join(thread_r2, & thread_result);
  printf((char const   * __restrict  )"thread result: %d %ld\n", status, (long )thread_result);
  status = pthread_join(thread_w1, & thread_result);
  printf((char const   * __restrict  )"thread result: %d %ld\n", status, (long )thread_result);
  status = pthread_join(thread_w2, & thread_result);
  printf((char const   * __restrict  )"thread result: %d %ld\n", status, (long )thread_result);
  if ((unsigned long )elts != (unsigned long )((void *)0)) {
    i = (elts->hh.tbl)->num_items;
  } else {
    i = 0U;
  }
  printf((char const   * __restrict  )"final count of items in hash: %u\n", i);
  tmp___1 = pthread_rwlock_destroy(& lock);
  if (tmp___1 != 0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"lock destroy failed\n");
    exit(-1);
  }
  return (0);
}
}
#pragma merger("0","/tmp/cil-J7YZgYej.i","-pthread")
