/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned char __uint8_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned long __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef int __pid_t;
typedef long __clock_t;
typedef long __time_t;
typedef long __suseconds_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __blkcnt64_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
typedef char *__caddr_t;
typedef unsigned int __socklen_t;
typedef __gid_t gid_t;
typedef __uid_t uid_t;
typedef __pid_t pid_t;
typedef __ssize_t ssize_t;
typedef __time_t time_t;
typedef unsigned long size_t;
typedef __int32_t int32_t;
struct __anonstruct___sigset_t_991265788 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___sigset_t_991265788 __sigset_t;
typedef __sigset_t sigset_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
typedef __socklen_t socklen_t;
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct sockaddr_storage {
   sa_family_t ss_family ;
   char __ss_padding[(128UL - sizeof(unsigned short )) - sizeof(unsigned long )] ;
   unsigned long __ss_align ;
};
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
struct sockaddr_in ;
struct sockaddr_in6 ;
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef uint32_t in_addr_t;
struct in_addr {
   in_addr_t s_addr ;
};
struct ip_mreqn {
   struct in_addr imr_multiaddr ;
   struct in_addr imr_address ;
   int imr_ifindex ;
};
typedef uint16_t in_port_t;
union __anonunion___in6_u_979734923 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
struct in6_addr {
   union __anonunion___in6_u_979734923 __in6_u ;
};
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
struct ipv6_mreq {
   struct in6_addr ipv6mr_multiaddr ;
   unsigned int ipv6mr_interface ;
};
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
typedef union sigval __sigval_t;
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
struct __anonstruct__kill_244518854 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
struct __anonstruct__timer_490064738 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
struct __anonstruct__rt_619254530 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
struct __anonstruct__sigchld_284671705 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
struct __anonstruct__addr_bnd_5259977 {
   void *_lower ;
   void *_upper ;
};
union __anonunion__bounds_979030728 {
   struct __anonstruct__addr_bnd_5259977 _addr_bnd ;
   __uint32_t _pkey ;
};
struct __anonstruct__sigfault_33223220 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion__bounds_979030728 _bounds ;
};
struct __anonstruct__sigpoll_386613454 {
   long si_band ;
   int si_fd ;
};
struct __anonstruct__sigsys_44812255 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
union __anonunion__sifields_1013095824 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_244518854 _kill ;
   struct __anonstruct__timer_490064738 _timer ;
   struct __anonstruct__rt_619254530 _rt ;
   struct __anonstruct__sigchld_284671705 _sigchld ;
   struct __anonstruct__sigfault_33223220 _sigfault ;
   struct __anonstruct__sigpoll_386613454 _sigpoll ;
   struct __anonstruct__sigsys_44812255 _sigsys ;
};
struct __anonstruct_siginfo_t_781435142 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion__sifields_1013095824 _sifields ;
};
typedef struct __anonstruct_siginfo_t_781435142 siginfo_t;
union __anonunion___sigaction_handler_363639592 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
struct sigaction {
   union __anonunion___sigaction_handler_363639592 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
union __anonunion_ifr_ifrn_352126815 {
   char ifrn_name[16] ;
};
union __anonunion_ifr_ifru_537349870 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
struct ifreq {
   union __anonunion_ifr_ifrn_352126815 ifr_ifrn ;
   union __anonunion_ifr_ifru_537349870 ifr_ifru ;
};
typedef __builtin_va_list __gnuc_va_list;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef __gnuc_va_list va_list___0;
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
typedef unsigned long __cpu_mask;
struct __anonstruct_cpu_set_t_826868708 {
   __cpu_mask __bits[1024UL / (8UL * sizeof(__cpu_mask ))] ;
};
typedef struct __anonstruct_cpu_set_t_826868708 cpu_set_t;
struct stack_st {
   int num ;
   char **data ;
   int sorted ;
   int num_alloc ;
   int (*comp)(void const   * , void const   * ) ;
};
typedef struct stack_st _STACK;
struct asn1_string_st ;
typedef struct asn1_string_st ASN1_INTEGER;
typedef struct asn1_string_st ASN1_ENUMERATED;
typedef struct asn1_string_st ASN1_BIT_STRING;
typedef struct asn1_string_st ASN1_OCTET_STRING;
typedef struct asn1_string_st ASN1_PRINTABLESTRING;
typedef struct asn1_string_st ASN1_T61STRING;
typedef struct asn1_string_st ASN1_IA5STRING;
typedef struct asn1_string_st ASN1_GENERALSTRING;
typedef struct asn1_string_st ASN1_UNIVERSALSTRING;
typedef struct asn1_string_st ASN1_BMPSTRING;
typedef struct asn1_string_st ASN1_UTCTIME;
typedef struct asn1_string_st ASN1_TIME;
typedef struct asn1_string_st ASN1_GENERALIZEDTIME;
typedef struct asn1_string_st ASN1_VISIBLESTRING;
typedef struct asn1_string_st ASN1_UTF8STRING;
typedef struct asn1_string_st ASN1_STRING;
typedef int ASN1_BOOLEAN;
struct bignum_st ;
typedef struct bignum_st BIGNUM;
struct bignum_ctx ;
typedef struct bignum_ctx BN_CTX;
struct bn_blinding_st ;
typedef struct bn_blinding_st BN_BLINDING;
struct bn_mont_ctx_st ;
typedef struct bn_mont_ctx_st BN_MONT_CTX;
struct bn_gencb_st ;
typedef struct bn_gencb_st BN_GENCB;
struct buf_mem_st ;
typedef struct buf_mem_st BUF_MEM;
struct evp_cipher_st ;
typedef struct evp_cipher_st EVP_CIPHER;
struct evp_cipher_ctx_st ;
typedef struct evp_cipher_ctx_st EVP_CIPHER_CTX;
struct env_md_st ;
typedef struct env_md_st EVP_MD;
struct env_md_ctx_st ;
typedef struct env_md_ctx_st EVP_MD_CTX;
struct evp_pkey_st ;
typedef struct evp_pkey_st EVP_PKEY;
struct evp_pkey_asn1_method_st ;
typedef struct evp_pkey_asn1_method_st EVP_PKEY_ASN1_METHOD;
struct evp_pkey_ctx_st ;
typedef struct evp_pkey_ctx_st EVP_PKEY_CTX;
struct dh_st ;
typedef struct dh_st DH;
struct dh_method ;
typedef struct dh_method DH_METHOD;
struct dsa_st ;
typedef struct dsa_st DSA;
struct dsa_method ;
typedef struct dsa_method DSA_METHOD;
struct rsa_st ;
typedef struct rsa_st RSA;
struct rsa_meth_st ;
typedef struct rsa_meth_st RSA_METHOD;
struct x509_st ;
typedef struct x509_st X509;
struct X509_algor_st ;
typedef struct X509_algor_st X509_ALGOR;
struct X509_crl_st ;
typedef struct X509_crl_st X509_CRL;
struct x509_crl_method_st ;
typedef struct x509_crl_method_st X509_CRL_METHOD;
struct X509_name_st ;
typedef struct X509_name_st X509_NAME;
struct X509_pubkey_st ;
typedef struct X509_pubkey_st X509_PUBKEY;
struct x509_store_st ;
typedef struct x509_store_st X509_STORE;
struct x509_store_ctx_st ;
typedef struct x509_store_ctx_st X509_STORE_CTX;
struct engine_st ;
typedef struct engine_st ENGINE;
struct ssl_st ;
typedef struct ssl_st SSL;
struct ssl_ctx_st ;
typedef struct ssl_ctx_st SSL_CTX;
struct X509_POLICY_TREE_st ;
typedef struct X509_POLICY_TREE_st X509_POLICY_TREE;
struct X509_POLICY_CACHE_st ;
typedef struct X509_POLICY_CACHE_st X509_POLICY_CACHE;
struct AUTHORITY_KEYID_st ;
typedef struct AUTHORITY_KEYID_st AUTHORITY_KEYID;
struct ISSUING_DIST_POINT_st ;
typedef struct ISSUING_DIST_POINT_st ISSUING_DIST_POINT;
struct NAME_CONSTRAINTS_st ;
typedef struct NAME_CONSTRAINTS_st NAME_CONSTRAINTS;
struct crypto_ex_data_st ;
typedef struct crypto_ex_data_st CRYPTO_EX_DATA;
struct bio_st ;
struct stack_st_void ;
struct crypto_ex_data_st {
   struct stack_st_void *sk ;
   int dummy ;
};
struct stack_st_void {
   _STACK stack ;
};
struct comp_ctx_st ;
typedef struct comp_ctx_st COMP_CTX;
struct comp_method_st {
   int type ;
   char const   *name ;
   int (*init)(COMP_CTX *ctx ) ;
   void (*finish)(COMP_CTX *ctx ) ;
   int (*compress)(COMP_CTX *ctx , unsigned char *out , unsigned int olen , unsigned char *in ,
                   unsigned int ilen ) ;
   int (*expand)(COMP_CTX *ctx , unsigned char *out , unsigned int olen , unsigned char *in ,
                 unsigned int ilen ) ;
   long (*ctrl)(void) ;
   long (*callback_ctrl)(void) ;
};
typedef struct comp_method_st COMP_METHOD;
struct comp_ctx_st {
   COMP_METHOD *meth ;
   unsigned long compress_in ;
   unsigned long compress_out ;
   unsigned long expand_in ;
   unsigned long expand_out ;
   CRYPTO_EX_DATA ex_data ;
};
typedef struct bio_st BIO;
typedef void bio_info_cb(struct bio_st * , int  , char const   * , int  , long  ,
                         long  );
struct bio_method_st {
   int type ;
   char const   *name ;
   int (*bwrite)(BIO * , char const   * , int  ) ;
   int (*bread)(BIO * , char * , int  ) ;
   int (*bputs)(BIO * , char const   * ) ;
   int (*bgets)(BIO * , char * , int  ) ;
   long (*ctrl)(BIO * , int  , long  , void * ) ;
   int (*create)(BIO * ) ;
   int (*destroy)(BIO * ) ;
   long (*callback_ctrl)(BIO * , int  , bio_info_cb * ) ;
};
typedef struct bio_method_st BIO_METHOD;
struct bio_st {
   BIO_METHOD *method ;
   long (*callback)(struct bio_st * , int  , char const   * , int  , long  , long  ) ;
   char *cb_arg ;
   int init ;
   int shutdown ;
   int flags ;
   int retry_reason ;
   int num ;
   void *ptr ;
   struct bio_st *next_bio ;
   struct bio_st *prev_bio ;
   int references ;
   unsigned long num_read ;
   unsigned long num_write ;
   CRYPTO_EX_DATA ex_data ;
};
struct buf_mem_st {
   size_t length ;
   char *data ;
   size_t max ;
};
struct bignum_st {
   unsigned long *d ;
   int top ;
   int dmax ;
   int neg ;
   int flags ;
};
struct bn_mont_ctx_st {
   int ri ;
   BIGNUM RR ;
   BIGNUM N ;
   BIGNUM Ni ;
   unsigned long n0[2] ;
   int flags ;
};
union __anonunion_cb_888073939 {
   void (*cb_1)(int  , int  , void * ) ;
   int (*cb_2)(int  , int  , BN_GENCB * ) ;
};
struct bn_gencb_st {
   unsigned int ver ;
   void *arg ;
   union __anonunion_cb_888073939 cb ;
};
struct stack_st_X509_ALGOR {
   _STACK stack ;
};
struct asn1_object_st {
   char const   *sn ;
   char const   *ln ;
   int nid ;
   int length ;
   unsigned char const   *data ;
   int flags ;
};
typedef struct asn1_object_st ASN1_OBJECT;
struct asn1_string_st {
   int length ;
   int type ;
   unsigned char *data ;
   long flags ;
};
struct ASN1_ENCODING_st {
   unsigned char *enc ;
   long len ;
   int modified ;
};
typedef struct ASN1_ENCODING_st ASN1_ENCODING;
struct ASN1_VALUE_st ;
typedef struct ASN1_VALUE_st ASN1_VALUE;
union __anonunion_value_401497255 {
   char *ptr ;
   ASN1_BOOLEAN boolean ;
   ASN1_STRING *asn1_string ;
   ASN1_OBJECT *object ;
   ASN1_INTEGER *integer ;
   ASN1_ENUMERATED *enumerated ;
   ASN1_BIT_STRING *bit_string ;
   ASN1_OCTET_STRING *octet_string ;
   ASN1_PRINTABLESTRING *printablestring ;
   ASN1_T61STRING *t61string ;
   ASN1_IA5STRING *ia5string ;
   ASN1_GENERALSTRING *generalstring ;
   ASN1_BMPSTRING *bmpstring ;
   ASN1_UNIVERSALSTRING *universalstring ;
   ASN1_UTCTIME *utctime ;
   ASN1_GENERALIZEDTIME *generalizedtime ;
   ASN1_VISIBLESTRING *visiblestring ;
   ASN1_UTF8STRING *utf8string ;
   ASN1_STRING *set ;
   ASN1_STRING *sequence ;
   ASN1_VALUE *asn1_value ;
};
struct asn1_type_st {
   int type ;
   union __anonunion_value_401497255 value ;
};
typedef struct asn1_type_st ASN1_TYPE;
struct stack_st_ASN1_OBJECT {
   _STACK stack ;
};
struct ec_key_st ;
union __anonunion_pkey_1024245030 {
   char *ptr ;
   struct rsa_st *rsa ;
   struct dsa_st *dsa ;
   struct dh_st *dh ;
   struct ec_key_st *ec ;
};
struct stack_st_X509_ATTRIBUTE ;
struct evp_pkey_st {
   int type ;
   int save_type ;
   int references ;
   EVP_PKEY_ASN1_METHOD const   *ameth ;
   ENGINE *engine ;
   union __anonunion_pkey_1024245030 pkey ;
   int save_parameters ;
   struct stack_st_X509_ATTRIBUTE *attributes ;
};
struct env_md_st {
   int type ;
   int pkey_type ;
   int md_size ;
   unsigned long flags ;
   int (*init)(EVP_MD_CTX *ctx ) ;
   int (*update)(EVP_MD_CTX *ctx , void const   *data , size_t count ) ;
   int (*final)(EVP_MD_CTX *ctx , unsigned char *md ) ;
   int (*copy)(EVP_MD_CTX *to , EVP_MD_CTX const   *from ) ;
   int (*cleanup)(EVP_MD_CTX *ctx ) ;
   int (*sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
               unsigned int *siglen , void *key ) ;
   int (*verify)(int type , unsigned char const   *m , unsigned int m_length , unsigned char const   *sigbuf ,
                 unsigned int siglen , void *key ) ;
   int required_pkey_type[5] ;
   int block_size ;
   int ctx_size ;
   int (*md_ctrl)(EVP_MD_CTX *ctx , int cmd , int p1 , void *p2 ) ;
};
struct env_md_ctx_st {
   EVP_MD const   *digest ;
   ENGINE *engine ;
   unsigned long flags ;
   void *md_data ;
   EVP_PKEY_CTX *pctx ;
   int (*update)(EVP_MD_CTX *ctx , void const   *data , size_t count ) ;
};
struct evp_cipher_st {
   int nid ;
   int block_size ;
   int key_len ;
   int iv_len ;
   unsigned long flags ;
   int (*init)(EVP_CIPHER_CTX *ctx , unsigned char const   *key , unsigned char const   *iv ,
               int enc ) ;
   int (*do_cipher)(EVP_CIPHER_CTX *ctx , unsigned char *out , unsigned char const   *in ,
                    size_t inl ) ;
   int (*cleanup)(EVP_CIPHER_CTX * ) ;
   int ctx_size ;
   int (*set_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*get_asn1_parameters)(EVP_CIPHER_CTX * , ASN1_TYPE * ) ;
   int (*ctrl)(EVP_CIPHER_CTX * , int type , int arg , void *ptr ) ;
   void *app_data ;
};
struct evp_cipher_ctx_st {
   EVP_CIPHER const   *cipher ;
   ENGINE *engine ;
   int encrypt ;
   int buf_len ;
   unsigned char oiv[16] ;
   unsigned char iv[16] ;
   unsigned char buf[32] ;
   int num ;
   void *app_data ;
   int key_len ;
   unsigned long flags ;
   void *cipher_data ;
   int final_used ;
   int block_mask ;
   unsigned char final[32] ;
};
typedef struct ec_key_st EC_KEY;
struct rsa_meth_st {
   char const   *name ;
   int (*rsa_pub_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_pub_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                      RSA *rsa , int padding ) ;
   int (*rsa_priv_enc)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_priv_dec)(int flen , unsigned char const   *from , unsigned char *to ,
                       RSA *rsa , int padding ) ;
   int (*rsa_mod_exp)(BIGNUM *r0 , BIGNUM const   *I , RSA *rsa , BN_CTX *ctx ) ;
   int (*bn_mod_exp)(BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(RSA *rsa ) ;
   int (*finish)(RSA *rsa ) ;
   int flags ;
   char *app_data ;
   int (*rsa_sign)(int type , unsigned char const   *m , unsigned int m_length , unsigned char *sigret ,
                   unsigned int *siglen , RSA const   *rsa ) ;
   int (*rsa_verify)(int dtype , unsigned char const   *m , unsigned int m_length ,
                     unsigned char const   *sigbuf , unsigned int siglen , RSA const   *rsa ) ;
   int (*rsa_keygen)(RSA *rsa , int bits , BIGNUM *e , BN_GENCB *cb ) ;
};
struct rsa_st {
   int pad ;
   long version ;
   RSA_METHOD const   *meth ;
   ENGINE *engine ;
   BIGNUM *n ;
   BIGNUM *e ;
   BIGNUM *d ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *dmp1 ;
   BIGNUM *dmq1 ;
   BIGNUM *iqmp ;
   CRYPTO_EX_DATA ex_data ;
   int references ;
   int flags ;
   BN_MONT_CTX *_method_mod_n ;
   BN_MONT_CTX *_method_mod_p ;
   BN_MONT_CTX *_method_mod_q ;
   char *bignum_data ;
   BN_BLINDING *blinding ;
   BN_BLINDING *mt_blinding ;
};
struct dh_method {
   char const   *name ;
   int (*generate_key)(DH *dh ) ;
   int (*compute_key)(unsigned char *key , BIGNUM const   *pub_key , DH *dh ) ;
   int (*bn_mod_exp)(DH const   *dh , BIGNUM *r , BIGNUM const   *a , BIGNUM const   *p ,
                     BIGNUM const   *m , BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DH *dh ) ;
   int (*finish)(DH *dh ) ;
   int flags ;
   char *app_data ;
   int (*generate_params)(DH *dh , int prime_len , int generator , BN_GENCB *cb ) ;
};
struct dh_st {
   int pad ;
   int version ;
   BIGNUM *p ;
   BIGNUM *g ;
   long length ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   BIGNUM *q ;
   BIGNUM *j ;
   unsigned char *seed ;
   int seedlen ;
   BIGNUM *counter ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DH_METHOD const   *meth ;
   ENGINE *engine ;
};
struct DSA_SIG_st {
   BIGNUM *r ;
   BIGNUM *s ;
};
typedef struct DSA_SIG_st DSA_SIG;
struct dsa_method {
   char const   *name ;
   DSA_SIG *(*dsa_do_sign)(unsigned char const   *dgst , int dlen , DSA *dsa ) ;
   int (*dsa_sign_setup)(DSA *dsa , BN_CTX *ctx_in , BIGNUM **kinvp , BIGNUM **rp ) ;
   int (*dsa_do_verify)(unsigned char const   *dgst , int dgst_len , DSA_SIG *sig ,
                        DSA *dsa ) ;
   int (*dsa_mod_exp)(DSA *dsa , BIGNUM *rr , BIGNUM *a1 , BIGNUM *p1 , BIGNUM *a2 ,
                      BIGNUM *p2 , BIGNUM *m , BN_CTX *ctx , BN_MONT_CTX *in_mont ) ;
   int (*bn_mod_exp)(DSA *dsa , BIGNUM *r , BIGNUM *a , BIGNUM const   *p , BIGNUM const   *m ,
                     BN_CTX *ctx , BN_MONT_CTX *m_ctx ) ;
   int (*init)(DSA *dsa ) ;
   int (*finish)(DSA *dsa ) ;
   int flags ;
   char *app_data ;
   int (*dsa_paramgen)(DSA *dsa , int bits , unsigned char const   *seed , int seed_len ,
                       int *counter_ret , unsigned long *h_ret , BN_GENCB *cb ) ;
   int (*dsa_keygen)(DSA *dsa ) ;
};
struct dsa_st {
   int pad ;
   long version ;
   int write_params ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *g ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   BIGNUM *kinv ;
   BIGNUM *r ;
   int flags ;
   BN_MONT_CTX *method_mont_p ;
   int references ;
   CRYPTO_EX_DATA ex_data ;
   DSA_METHOD const   *meth ;
   ENGINE *engine ;
};
struct X509_algor_st {
   ASN1_OBJECT *algorithm ;
   ASN1_TYPE *parameter ;
};
struct X509_val_st {
   ASN1_TIME *notBefore ;
   ASN1_TIME *notAfter ;
};
typedef struct X509_val_st X509_VAL;
struct X509_pubkey_st {
   X509_ALGOR *algor ;
   ASN1_BIT_STRING *public_key ;
   EVP_PKEY *pkey ;
};
struct X509_name_entry_st {
   ASN1_OBJECT *object ;
   ASN1_STRING *value ;
   int set ;
   int size ;
};
typedef struct X509_name_entry_st X509_NAME_ENTRY;
struct stack_st_X509_NAME_ENTRY {
   _STACK stack ;
};
struct X509_name_st {
   struct stack_st_X509_NAME_ENTRY *entries ;
   int modified ;
   BUF_MEM *bytes ;
   unsigned char *canon_enc ;
   int canon_enclen ;
};
struct stack_st_X509_NAME {
   _STACK stack ;
};
struct stack_st_X509_EXTENSION ;
typedef struct stack_st_X509_EXTENSION X509_EXTENSIONS;
struct stack_st_X509_EXTENSION {
   _STACK stack ;
};
struct stack_st_X509_ATTRIBUTE {
   _STACK stack ;
};
struct x509_cinf_st {
   ASN1_INTEGER *version ;
   ASN1_INTEGER *serialNumber ;
   X509_ALGOR *signature ;
   X509_NAME *issuer ;
   X509_VAL *validity ;
   X509_NAME *subject ;
   X509_PUBKEY *key ;
   ASN1_BIT_STRING *issuerUID ;
   ASN1_BIT_STRING *subjectUID ;
   struct stack_st_X509_EXTENSION *extensions ;
   ASN1_ENCODING enc ;
};
typedef struct x509_cinf_st X509_CINF;
struct x509_cert_aux_st {
   struct stack_st_ASN1_OBJECT *trust ;
   struct stack_st_ASN1_OBJECT *reject ;
   ASN1_UTF8STRING *alias ;
   ASN1_OCTET_STRING *keyid ;
   struct stack_st_X509_ALGOR *other ;
};
typedef struct x509_cert_aux_st X509_CERT_AUX;
struct stack_st_DIST_POINT ;
struct stack_st_GENERAL_NAME ;
struct x509_st {
   X509_CINF *cert_info ;
   X509_ALGOR *sig_alg ;
   ASN1_BIT_STRING *signature ;
   int valid ;
   int references ;
   char *name ;
   CRYPTO_EX_DATA ex_data ;
   long ex_pathlen ;
   long ex_pcpathlen ;
   unsigned long ex_flags ;
   unsigned long ex_kusage ;
   unsigned long ex_xkusage ;
   unsigned long ex_nscert ;
   ASN1_OCTET_STRING *skid ;
   AUTHORITY_KEYID *akid ;
   X509_POLICY_CACHE *policy_cache ;
   struct stack_st_DIST_POINT *crldp ;
   struct stack_st_GENERAL_NAME *altname ;
   NAME_CONSTRAINTS *nc ;
   unsigned char sha1_hash[20] ;
   X509_CERT_AUX *aux ;
};
struct stack_st_X509 {
   _STACK stack ;
};
struct stack_st_X509_REVOKED {
   _STACK stack ;
};
struct X509_crl_info_st {
   ASN1_INTEGER *version ;
   X509_ALGOR *sig_alg ;
   X509_NAME *issuer ;
   ASN1_TIME *lastUpdate ;
   ASN1_TIME *nextUpdate ;
   struct stack_st_X509_REVOKED *revoked ;
   struct stack_st_X509_EXTENSION *extensions ;
   ASN1_ENCODING enc ;
};
typedef struct X509_crl_info_st X509_CRL_INFO;
struct stack_st_GENERAL_NAMES ;
struct X509_crl_st {
   X509_CRL_INFO *crl ;
   X509_ALGOR *sig_alg ;
   ASN1_BIT_STRING *signature ;
   int references ;
   int flags ;
   AUTHORITY_KEYID *akid ;
   ISSUING_DIST_POINT *idp ;
   int idp_flags ;
   int idp_reasons ;
   ASN1_INTEGER *crl_number ;
   ASN1_INTEGER *base_crl_number ;
   unsigned char sha1_hash[20] ;
   struct stack_st_GENERAL_NAMES *issuers ;
   X509_CRL_METHOD const   *meth ;
   void *meth_data ;
};
struct stack_st_X509_CRL {
   _STACK stack ;
};
struct stack_st_X509_LOOKUP {
   _STACK stack ;
};
struct stack_st_X509_OBJECT {
   _STACK stack ;
};
struct X509_VERIFY_PARAM_st {
   char *name ;
   time_t check_time ;
   unsigned long inh_flags ;
   unsigned long flags ;
   int purpose ;
   int trust ;
   int depth ;
   struct stack_st_ASN1_OBJECT *policies ;
};
typedef struct X509_VERIFY_PARAM_st X509_VERIFY_PARAM;
struct x509_store_st {
   int cache ;
   struct stack_st_X509_OBJECT *objs ;
   struct stack_st_X509_LOOKUP *get_cert_methods ;
   X509_VERIFY_PARAM *param ;
   int (*verify)(X509_STORE_CTX *ctx ) ;
   int (*verify_cb)(int ok , X509_STORE_CTX *ctx ) ;
   int (*get_issuer)(X509 **issuer , X509_STORE_CTX *ctx , X509 *x ) ;
   int (*check_issued)(X509_STORE_CTX *ctx , X509 *x , X509 *issuer ) ;
   int (*check_revocation)(X509_STORE_CTX *ctx ) ;
   int (*get_crl)(X509_STORE_CTX *ctx , X509_CRL **crl , X509 *x ) ;
   int (*check_crl)(X509_STORE_CTX *ctx , X509_CRL *crl ) ;
   int (*cert_crl)(X509_STORE_CTX *ctx , X509_CRL *crl , X509 *x ) ;
   struct stack_st_X509 *(*lookup_certs)(X509_STORE_CTX *ctx , X509_NAME *nm ) ;
   struct stack_st_X509_CRL *(*lookup_crls)(X509_STORE_CTX *ctx , X509_NAME *nm ) ;
   int (*cleanup)(X509_STORE_CTX *ctx ) ;
   CRYPTO_EX_DATA ex_data ;
   int references ;
};
struct x509_store_ctx_st {
   X509_STORE *ctx ;
   int current_method ;
   X509 *cert ;
   struct stack_st_X509 *untrusted ;
   struct stack_st_X509_CRL *crls ;
   X509_VERIFY_PARAM *param ;
   void *other_ctx ;
   int (*verify)(X509_STORE_CTX *ctx ) ;
   int (*verify_cb)(int ok , X509_STORE_CTX *ctx ) ;
   int (*get_issuer)(X509 **issuer , X509_STORE_CTX *ctx , X509 *x ) ;
   int (*check_issued)(X509_STORE_CTX *ctx , X509 *x , X509 *issuer ) ;
   int (*check_revocation)(X509_STORE_CTX *ctx ) ;
   int (*get_crl)(X509_STORE_CTX *ctx , X509_CRL **crl , X509 *x ) ;
   int (*check_crl)(X509_STORE_CTX *ctx , X509_CRL *crl ) ;
   int (*cert_crl)(X509_STORE_CTX *ctx , X509_CRL *crl , X509 *x ) ;
   int (*check_policy)(X509_STORE_CTX *ctx ) ;
   struct stack_st_X509 *(*lookup_certs)(X509_STORE_CTX *ctx , X509_NAME *nm ) ;
   struct stack_st_X509_CRL *(*lookup_crls)(X509_STORE_CTX *ctx , X509_NAME *nm ) ;
   int (*cleanup)(X509_STORE_CTX *ctx ) ;
   int valid ;
   int last_untrusted ;
   struct stack_st_X509 *chain ;
   X509_POLICY_TREE *tree ;
   int explicit_policy ;
   int error_depth ;
   int error ;
   X509 *current_cert ;
   X509 *current_issuer ;
   X509_CRL *current_crl ;
   int current_crl_score ;
   unsigned int current_reasons ;
   X509_STORE_CTX *parent ;
   CRYPTO_EX_DATA ex_data ;
};
typedef int pem_password_cb(char *buf , int size , int rwflag , void *userdata );
struct hmac_ctx_st {
   EVP_MD const   *md ;
   EVP_MD_CTX md_ctx ;
   EVP_MD_CTX i_ctx ;
   EVP_MD_CTX o_ctx ;
   unsigned int key_length ;
   unsigned char key[128] ;
};
typedef struct hmac_ctx_st HMAC_CTX;
struct tls_session_ticket_ext_st ;
typedef struct tls_session_ticket_ext_st TLS_SESSION_TICKET_EXT;
struct ssl_method_st ;
typedef struct ssl_method_st SSL_METHOD;
struct ssl_cipher_st ;
typedef struct ssl_cipher_st SSL_CIPHER;
struct ssl_session_st ;
typedef struct ssl_session_st SSL_SESSION;
struct stack_st_SSL_CIPHER {
   _STACK stack ;
};
struct srtp_protection_profile_st {
   char const   *name ;
   unsigned long id ;
};
typedef struct srtp_protection_profile_st SRTP_PROTECTION_PROFILE;
struct stack_st_SRTP_PROTECTION_PROFILE {
   _STACK stack ;
};
struct ssl_cipher_st {
   int valid ;
   char const   *name ;
   unsigned long id ;
   unsigned long algorithm_mkey ;
   unsigned long algorithm_auth ;
   unsigned long algorithm_enc ;
   unsigned long algorithm_mac ;
   unsigned long algorithm_ssl ;
   unsigned long algo_strength ;
   unsigned long algorithm2 ;
   int strength_bits ;
   int alg_bits ;
};
struct ssl3_enc_method ;
struct ssl_method_st {
   int version ;
   int (*ssl_new)(SSL *s ) ;
   void (*ssl_clear)(SSL *s ) ;
   void (*ssl_free)(SSL *s ) ;
   int (*ssl_accept)(SSL *s ) ;
   int (*ssl_connect)(SSL *s ) ;
   int (*ssl_read)(SSL *s , void *buf , int len ) ;
   int (*ssl_peek)(SSL *s , void *buf , int len ) ;
   int (*ssl_write)(SSL *s , void const   *buf , int len ) ;
   int (*ssl_shutdown)(SSL *s ) ;
   int (*ssl_renegotiate)(SSL *s ) ;
   int (*ssl_renegotiate_check)(SSL *s ) ;
   long (*ssl_get_message)(SSL *s , int st1 , int stn , int mt , long max , int *ok ) ;
   int (*ssl_read_bytes)(SSL *s , int type , unsigned char *buf , int len , int peek ) ;
   int (*ssl_write_bytes)(SSL *s , int type , void const   *buf_ , int len ) ;
   int (*ssl_dispatch_alert)(SSL *s ) ;
   long (*ssl_ctrl)(SSL *s , int cmd , long larg , void *parg ) ;
   long (*ssl_ctx_ctrl)(SSL_CTX *ctx , int cmd , long larg , void *parg ) ;
   SSL_CIPHER const   *(*get_cipher_by_char)(unsigned char const   *ptr ) ;
   int (*put_cipher_by_char)(SSL_CIPHER const   *cipher , unsigned char *ptr ) ;
   int (*ssl_pending)(SSL const   *s ) ;
   int (*num_ciphers)(void) ;
   SSL_CIPHER const   *(*get_cipher)(unsigned int ncipher ) ;
   struct ssl_method_st  const  *(*get_ssl_method)(int version ) ;
   long (*get_timeout)(void) ;
   struct ssl3_enc_method *ssl3_enc ;
   int (*ssl_version)(void) ;
   long (*ssl_callback_ctrl)(SSL *s , int cb_id , void (*fp)(void) ) ;
   long (*ssl_ctx_callback_ctrl)(SSL_CTX *s , int cb_id , void (*fp)(void) ) ;
};
struct sess_cert_st ;
struct ssl_session_st {
   int ssl_version ;
   unsigned int key_arg_length ;
   unsigned char key_arg[8] ;
   int master_key_length ;
   unsigned char master_key[48] ;
   unsigned int session_id_length ;
   unsigned char session_id[32] ;
   unsigned int sid_ctx_length ;
   unsigned char sid_ctx[32] ;
   char *psk_identity_hint ;
   char *psk_identity ;
   int not_resumable ;
   struct sess_cert_st *sess_cert ;
   X509 *peer ;
   long verify_result ;
   int references ;
   long timeout ;
   long time ;
   unsigned int compress_meth ;
   SSL_CIPHER const   *cipher ;
   unsigned long cipher_id ;
   struct stack_st_SSL_CIPHER *ciphers ;
   CRYPTO_EX_DATA ex_data ;
   struct ssl_session_st *prev ;
   struct ssl_session_st *next ;
   char *tlsext_hostname ;
   size_t tlsext_ecpointformatlist_length ;
   unsigned char *tlsext_ecpointformatlist ;
   size_t tlsext_ellipticcurvelist_length ;
   unsigned char *tlsext_ellipticcurvelist ;
   unsigned char *tlsext_tick ;
   size_t tlsext_ticklen ;
   long tlsext_tick_lifetime_hint ;
   char *srp_username ;
};
struct srp_ctx_st {
   void *SRP_cb_arg ;
   int (*TLS_ext_srp_username_callback)(SSL * , int * , void * ) ;
   int (*SRP_verify_param_callback)(SSL * , void * ) ;
   char *(*SRP_give_srp_client_pwd_callback)(SSL * , void * ) ;
   char *login ;
   BIGNUM *N ;
   BIGNUM *g ;
   BIGNUM *s ;
   BIGNUM *B ;
   BIGNUM *A ;
   BIGNUM *a ;
   BIGNUM *b ;
   BIGNUM *v ;
   char *info ;
   int strength ;
   unsigned long srp_Mask ;
};
typedef struct srp_ctx_st SRP_CTX;
struct ssl_comp_st ;
typedef struct ssl_comp_st SSL_COMP;
struct ssl_comp_st {
   int id ;
   char const   *name ;
   COMP_METHOD *method ;
};
struct stack_st_SSL_COMP {
   _STACK stack ;
};
struct lhash_st_SSL_SESSION {
   int dummy ;
};
struct __anonstruct_stats_359712565 {
   int sess_connect ;
   int sess_connect_renegotiate ;
   int sess_connect_good ;
   int sess_accept ;
   int sess_accept_renegotiate ;
   int sess_accept_good ;
   int sess_miss ;
   int sess_timeout ;
   int sess_cache_full ;
   int sess_hit ;
   int sess_cb_hit ;
};
struct cert_st ;
struct ssl3_buf_freelist_st ;
struct ssl_ctx_st {
   SSL_METHOD const   *method ;
   struct stack_st_SSL_CIPHER *cipher_list ;
   struct stack_st_SSL_CIPHER *cipher_list_by_id ;
   struct x509_store_st *cert_store ;
   struct lhash_st_SSL_SESSION *sessions ;
   unsigned long session_cache_size ;
   struct ssl_session_st *session_cache_head ;
   struct ssl_session_st *session_cache_tail ;
   int session_cache_mode ;
   long session_timeout ;
   int (*new_session_cb)(struct ssl_st *ssl , SSL_SESSION *sess ) ;
   void (*remove_session_cb)(struct ssl_ctx_st *ctx , SSL_SESSION *sess ) ;
   SSL_SESSION *(*get_session_cb)(struct ssl_st *ssl , unsigned char *data , int len ,
                                  int *copy ) ;
   struct __anonstruct_stats_359712565 stats ;
   int references ;
   int (*app_verify_callback)(X509_STORE_CTX * , void * ) ;
   void *app_verify_arg ;
   pem_password_cb *default_passwd_callback ;
   void *default_passwd_callback_userdata ;
   int (*client_cert_cb)(SSL *ssl , X509 **x509 , EVP_PKEY **pkey ) ;
   int (*app_gen_cookie_cb)(SSL *ssl , unsigned char *cookie , unsigned int *cookie_len ) ;
   int (*app_verify_cookie_cb)(SSL *ssl , unsigned char *cookie , unsigned int cookie_len ) ;
   CRYPTO_EX_DATA ex_data ;
   EVP_MD const   *rsa_md5 ;
   EVP_MD const   *md5 ;
   EVP_MD const   *sha1 ;
   struct stack_st_X509 *extra_certs ;
   struct stack_st_SSL_COMP *comp_methods ;
   void (*info_callback)(SSL const   *ssl , int type , int val ) ;
   struct stack_st_X509_NAME *client_CA ;
   unsigned long options ;
   unsigned long mode ;
   long max_cert_list ;
   struct cert_st *cert ;
   int read_ahead ;
   void (*msg_callback)(int write_p , int version , int content_type , void const   *buf ,
                        size_t len , SSL *ssl , void *arg ) ;
   void *msg_callback_arg ;
   int verify_mode ;
   unsigned int sid_ctx_length ;
   unsigned char sid_ctx[32] ;
   int (*default_verify_callback)(int ok , X509_STORE_CTX *ctx ) ;
   int (*generate_session_id)(SSL const   *ssl , unsigned char *id , unsigned int *id_len ) ;
   X509_VERIFY_PARAM *param ;
   int quiet_shutdown ;
   unsigned int max_send_fragment ;
   ENGINE *client_cert_engine ;
   int (*tlsext_servername_callback)(SSL * , int * , void * ) ;
   void *tlsext_servername_arg ;
   unsigned char tlsext_tick_key_name[16] ;
   unsigned char tlsext_tick_hmac_key[16] ;
   unsigned char tlsext_tick_aes_key[16] ;
   int (*tlsext_ticket_key_cb)(SSL *ssl , unsigned char *name , unsigned char *iv ,
                               EVP_CIPHER_CTX *ectx , HMAC_CTX *hctx , int enc ) ;
   int (*tlsext_status_cb)(SSL *ssl , void *arg ) ;
   void *tlsext_status_arg ;
   int (*tlsext_opaque_prf_input_callback)(SSL * , void *peerinput , size_t len ,
                                           void *arg ) ;
   void *tlsext_opaque_prf_input_callback_arg ;
   char *psk_identity_hint ;
   unsigned int (*psk_client_callback)(SSL *ssl , char const   *hint , char *identity ,
                                       unsigned int max_identity_len , unsigned char *psk ,
                                       unsigned int max_psk_len ) ;
   unsigned int (*psk_server_callback)(SSL *ssl , char const   *identity , unsigned char *psk ,
                                       unsigned int max_psk_len ) ;
   unsigned int freelist_max_len ;
   struct ssl3_buf_freelist_st *wbuf_freelist ;
   struct ssl3_buf_freelist_st *rbuf_freelist ;
   SRP_CTX srp_ctx ;
   int (*next_protos_advertised_cb)(SSL *s , unsigned char const   **buf , unsigned int *len ,
                                    void *arg ) ;
   void *next_protos_advertised_cb_arg ;
   int (*next_proto_select_cb)(SSL *s , unsigned char **out , unsigned char *outlen ,
                               unsigned char const   *in , unsigned int inlen , void *arg ) ;
   void *next_proto_select_cb_arg ;
   struct stack_st_SRTP_PROTECTION_PROFILE *srtp_profiles ;
};
struct ssl2_state_st ;
struct ssl3_state_st ;
struct dtls1_state_st ;
struct stack_st_OCSP_RESPID ;
struct ssl_st {
   int version ;
   int type ;
   SSL_METHOD const   *method ;
   BIO *rbio ;
   BIO *wbio ;
   BIO *bbio ;
   int rwstate ;
   int in_handshake ;
   int (*handshake_func)(SSL * ) ;
   int server ;
   int new_session ;
   int quiet_shutdown ;
   int shutdown ;
   int state ;
   int rstate ;
   BUF_MEM *init_buf ;
   void *init_msg ;
   int init_num ;
   int init_off ;
   unsigned char *packet ;
   unsigned int packet_length ;
   struct ssl2_state_st *s2 ;
   struct ssl3_state_st *s3 ;
   struct dtls1_state_st *d1 ;
   int read_ahead ;
   void (*msg_callback)(int write_p , int version , int content_type , void const   *buf ,
                        size_t len , SSL *ssl , void *arg ) ;
   void *msg_callback_arg ;
   int hit ;
   X509_VERIFY_PARAM *param ;
   struct stack_st_SSL_CIPHER *cipher_list ;
   struct stack_st_SSL_CIPHER *cipher_list_by_id ;
   int mac_flags ;
   EVP_CIPHER_CTX *enc_read_ctx ;
   EVP_MD_CTX *read_hash ;
   COMP_CTX *expand ;
   EVP_CIPHER_CTX *enc_write_ctx ;
   EVP_MD_CTX *write_hash ;
   COMP_CTX *compress ;
   struct cert_st *cert ;
   unsigned int sid_ctx_length ;
   unsigned char sid_ctx[32] ;
   SSL_SESSION *session ;
   int (*generate_session_id)(SSL const   *ssl , unsigned char *id , unsigned int *id_len ) ;
   int verify_mode ;
   int (*verify_callback)(int ok , X509_STORE_CTX *ctx ) ;
   void (*info_callback)(SSL const   *ssl , int type , int val ) ;
   int error ;
   int error_code ;
   unsigned int (*psk_client_callback)(SSL *ssl , char const   *hint , char *identity ,
                                       unsigned int max_identity_len , unsigned char *psk ,
                                       unsigned int max_psk_len ) ;
   unsigned int (*psk_server_callback)(SSL *ssl , char const   *identity , unsigned char *psk ,
                                       unsigned int max_psk_len ) ;
   SSL_CTX *ctx ;
   int debug ;
   long verify_result ;
   CRYPTO_EX_DATA ex_data ;
   struct stack_st_X509_NAME *client_CA ;
   int references ;
   unsigned long options ;
   unsigned long mode ;
   long max_cert_list ;
   int first_packet ;
   int client_version ;
   unsigned int max_send_fragment ;
   void (*tlsext_debug_cb)(SSL *s , int client_server , int type , unsigned char *data ,
                           int len , void *arg ) ;
   void *tlsext_debug_arg ;
   char *tlsext_hostname ;
   int servername_done ;
   int tlsext_status_type ;
   int tlsext_status_expected ;
   struct stack_st_OCSP_RESPID *tlsext_ocsp_ids ;
   X509_EXTENSIONS *tlsext_ocsp_exts ;
   unsigned char *tlsext_ocsp_resp ;
   int tlsext_ocsp_resplen ;
   int tlsext_ticket_expected ;
   size_t tlsext_ecpointformatlist_length ;
   unsigned char *tlsext_ecpointformatlist ;
   size_t tlsext_ellipticcurvelist_length ;
   unsigned char *tlsext_ellipticcurvelist ;
   void *tlsext_opaque_prf_input ;
   size_t tlsext_opaque_prf_input_len ;
   TLS_SESSION_TICKET_EXT *tlsext_session_ticket ;
   int (*tls_session_ticket_ext_cb)(SSL *s , unsigned char const   *data , int len ,
                                    void *arg ) ;
   void *tls_session_ticket_ext_cb_arg ;
   int (*tls_session_secret_cb)(SSL *s , void *secret , int *secret_len , struct stack_st_SSL_CIPHER *peer_ciphers ,
                                SSL_CIPHER **cipher , void *arg ) ;
   void *tls_session_secret_cb_arg ;
   SSL_CTX *initial_ctx ;
   unsigned char *next_proto_negotiated ;
   unsigned char next_proto_negotiated_len ;
   struct stack_st_SRTP_PROTECTION_PROFILE *srtp_profiles ;
   SRTP_PROTECTION_PROFILE *srtp_profile ;
   unsigned int tlsext_heartbeat ;
   unsigned int tlsext_hb_pending ;
   unsigned int tlsext_hb_seq ;
   int renegotiate ;
   SRP_CTX srp_ctx ;
};
struct __anonstruct_tmp_263383761 {
   unsigned int conn_id_length ;
   unsigned int cert_type ;
   unsigned int cert_length ;
   unsigned int csl ;
   unsigned int clear ;
   unsigned int enc ;
   unsigned char ccl[32] ;
   unsigned int cipher_spec_length ;
   unsigned int session_id_length ;
   unsigned int clen ;
   unsigned int rlen ;
};
struct ssl2_state_st {
   int three_byte_header ;
   int clear_text ;
   int escape ;
   int ssl2_rollback ;
   unsigned int wnum ;
   int wpend_tot ;
   unsigned char const   *wpend_buf ;
   int wpend_off ;
   int wpend_len ;
   int wpend_ret ;
   int rbuf_left ;
   int rbuf_offs ;
   unsigned char *rbuf ;
   unsigned char *wbuf ;
   unsigned char *write_ptr ;
   unsigned int padding ;
   unsigned int rlength ;
   int ract_data_length ;
   unsigned int wlength ;
   int wact_data_length ;
   unsigned char *ract_data ;
   unsigned char *wact_data ;
   unsigned char *mac_data ;
   unsigned char *read_key ;
   unsigned char *write_key ;
   unsigned int challenge_length ;
   unsigned char challenge[32] ;
   unsigned int conn_id_length ;
   unsigned char conn_id[16] ;
   unsigned int key_material_length ;
   unsigned char key_material[48] ;
   unsigned long read_sequence ;
   unsigned long write_sequence ;
   struct __anonstruct_tmp_263383761 tmp ;
};
struct ssl3_record_st {
   int type ;
   unsigned int length ;
   unsigned int off ;
   unsigned char *data ;
   unsigned char *input ;
   unsigned char *comp ;
   unsigned long epoch ;
   unsigned char seq_num[8] ;
};
typedef struct ssl3_record_st SSL3_RECORD;
struct ssl3_buffer_st {
   unsigned char *buf ;
   size_t len ;
   int offset ;
   int left ;
};
typedef struct ssl3_buffer_st SSL3_BUFFER;
struct __anonstruct_tmp_985610861 {
   unsigned char cert_verify_md[128] ;
   unsigned char finish_md[128] ;
   int finish_md_len ;
   unsigned char peer_finish_md[128] ;
   int peer_finish_md_len ;
   unsigned long message_size ;
   int message_type ;
   SSL_CIPHER const   *new_cipher ;
   DH *dh ;
   EC_KEY *ecdh ;
   int next_state ;
   int reuse_message ;
   int cert_req ;
   int ctype_num ;
   char ctype[9] ;
   struct stack_st_X509_NAME *ca_names ;
   int use_rsa_tmp ;
   int key_block_length ;
   unsigned char *key_block ;
   EVP_CIPHER const   *new_sym_enc ;
   EVP_MD const   *new_hash ;
   int new_mac_pkey_type ;
   int new_mac_secret_size ;
   SSL_COMP const   *new_compression ;
   int cert_request ;
};
struct ssl3_state_st {
   long flags ;
   int delay_buf_pop_ret ;
   unsigned char read_sequence[8] ;
   int read_mac_secret_size ;
   unsigned char read_mac_secret[64] ;
   unsigned char write_sequence[8] ;
   int write_mac_secret_size ;
   unsigned char write_mac_secret[64] ;
   unsigned char server_random[32] ;
   unsigned char client_random[32] ;
   int need_empty_fragments ;
   int empty_fragment_done ;
   int init_extra ;
   SSL3_BUFFER rbuf ;
   SSL3_BUFFER wbuf ;
   SSL3_RECORD rrec ;
   SSL3_RECORD wrec ;
   unsigned char alert_fragment[2] ;
   unsigned int alert_fragment_len ;
   unsigned char handshake_fragment[4] ;
   unsigned int handshake_fragment_len ;
   unsigned int wnum ;
   int wpend_tot ;
   int wpend_type ;
   int wpend_ret ;
   unsigned char const   *wpend_buf ;
   BIO *handshake_buffer ;
   EVP_MD_CTX **handshake_dgst ;
   int change_cipher_spec ;
   int warn_alert ;
   int fatal_alert ;
   int alert_dispatch ;
   unsigned char send_alert[2] ;
   int renegotiate ;
   int total_renegotiations ;
   int num_renegotiations ;
   int in_read_app_data ;
   void *client_opaque_prf_input ;
   size_t client_opaque_prf_input_len ;
   void *server_opaque_prf_input ;
   size_t server_opaque_prf_input_len ;
   struct __anonstruct_tmp_985610861 tmp ;
   unsigned char previous_client_finished[64] ;
   unsigned char previous_client_finished_len ;
   unsigned char previous_server_finished[64] ;
   unsigned char previous_server_finished_len ;
   int send_connection_binding ;
   int next_proto_neg_seen ;
   char is_probably_safari ;
};
struct tls_session_ticket_ext_st {
   unsigned short length ;
   void *data ;
};
struct _pqueue ;
typedef struct _pqueue *pqueue;
struct dtls1_bitmap_st {
   unsigned long map ;
   unsigned char max_seq_num[8] ;
};
typedef struct dtls1_bitmap_st DTLS1_BITMAP;
struct dtls1_retransmit_state {
   EVP_CIPHER_CTX *enc_write_ctx ;
   EVP_MD_CTX *write_hash ;
   COMP_CTX *compress ;
   SSL_SESSION *session ;
   unsigned short epoch ;
};
struct hm_header_st {
   unsigned char type ;
   unsigned long msg_len ;
   unsigned short seq ;
   unsigned long frag_off ;
   unsigned long frag_len ;
   unsigned int is_ccs ;
   struct dtls1_retransmit_state saved_retransmit_state ;
};
struct dtls1_timeout_st {
   unsigned int read_timeouts ;
   unsigned int write_timeouts ;
   unsigned int num_alerts ;
};
struct record_pqueue_st {
   unsigned short epoch ;
   pqueue q ;
};
typedef struct record_pqueue_st record_pqueue;
struct dtls1_state_st {
   unsigned int send_cookie ;
   unsigned char cookie[256] ;
   unsigned char rcvd_cookie[256] ;
   unsigned int cookie_len ;
   unsigned short r_epoch ;
   unsigned short w_epoch ;
   DTLS1_BITMAP bitmap ;
   DTLS1_BITMAP next_bitmap ;
   unsigned short handshake_write_seq ;
   unsigned short next_handshake_write_seq ;
   unsigned short handshake_read_seq ;
   unsigned char last_write_sequence[8] ;
   record_pqueue unprocessed_rcds ;
   record_pqueue processed_rcds ;
   pqueue buffered_messages ;
   pqueue sent_messages ;
   record_pqueue buffered_app_data ;
   unsigned int listen ;
   unsigned int link_mtu ;
   unsigned int mtu ;
   struct hm_header_st w_msg_hdr ;
   struct hm_header_st r_msg_hdr ;
   struct dtls1_timeout_st timeout ;
   struct timeval next_timeout ;
   unsigned short timeout_duration ;
   unsigned char alert_fragment[2] ;
   unsigned int alert_fragment_len ;
   unsigned char handshake_fragment[12] ;
   unsigned int handshake_fragment_len ;
   unsigned int retransmitting ;
   unsigned int change_cipher_spec_ok ;
};
struct otherName_st {
   ASN1_OBJECT *type_id ;
   ASN1_TYPE *value ;
};
typedef struct otherName_st OTHERNAME;
struct EDIPartyName_st {
   ASN1_STRING *nameAssigner ;
   ASN1_STRING *partyName ;
};
typedef struct EDIPartyName_st EDIPARTYNAME;
union __anonunion_d_825737363 {
   char *ptr ;
   OTHERNAME *otherName ;
   ASN1_IA5STRING *rfc822Name ;
   ASN1_IA5STRING *dNSName ;
   ASN1_TYPE *x400Address ;
   X509_NAME *directoryName ;
   EDIPARTYNAME *ediPartyName ;
   ASN1_IA5STRING *uniformResourceIdentifier ;
   ASN1_OCTET_STRING *iPAddress ;
   ASN1_OBJECT *registeredID ;
   ASN1_OCTET_STRING *ip ;
   X509_NAME *dirn ;
   ASN1_IA5STRING *ia5 ;
   ASN1_OBJECT *rid ;
   ASN1_TYPE *other ;
};
struct GENERAL_NAME_st {
   int type ;
   union __anonunion_d_825737363 d ;
};
typedef struct GENERAL_NAME_st GENERAL_NAME;
typedef struct stack_st_GENERAL_NAME GENERAL_NAMES;
struct stack_st_GENERAL_NAME {
   _STACK stack ;
};
union __anonunion_name_997224671 {
   GENERAL_NAMES *fullname ;
   struct stack_st_X509_NAME_ENTRY *relativename ;
};
struct DIST_POINT_NAME_st {
   int type ;
   union __anonunion_name_997224671 name ;
   X509_NAME *dpname ;
};
typedef struct DIST_POINT_NAME_st DIST_POINT_NAME;
struct stack_st_DIST_POINT {
   _STACK stack ;
};
struct AUTHORITY_KEYID_st {
   ASN1_OCTET_STRING *keyid ;
   GENERAL_NAMES *issuer ;
   ASN1_INTEGER *serial ;
};
struct stack_st_GENERAL_SUBTREE {
   _STACK stack ;
};
struct NAME_CONSTRAINTS_st {
   struct stack_st_GENERAL_SUBTREE *permittedSubtrees ;
   struct stack_st_GENERAL_SUBTREE *excludedSubtrees ;
};
struct ISSUING_DIST_POINT_st {
   DIST_POINT_NAME *distpoint ;
   int onlyuser ;
   int onlyCA ;
   ASN1_BIT_STRING *onlysomereasons ;
   int indirectCRL ;
   int onlyattr ;
};
typedef double ev_tstamp;
struct ev_loop ;
struct ev_watcher {
   int active ;
   int pending ;
   int priority ;
   void *data ;
   void (*cb)(struct ev_loop *loop , struct ev_watcher *w , int revents ) ;
};
typedef struct ev_watcher ev_watcher;
struct ev_watcher_list {
   int active ;
   int pending ;
   int priority ;
   void *data ;
   void (*cb)(struct ev_loop *loop , struct ev_watcher_list *w , int revents ) ;
   struct ev_watcher_list *next ;
};
struct ev_watcher_time {
   int active ;
   int pending ;
   int priority ;
   void *data ;
   void (*cb)(struct ev_loop *loop , struct ev_watcher_time *w , int revents ) ;
   ev_tstamp at ;
};
typedef struct ev_watcher_time ev_watcher_time;
struct ev_io {
   int active ;
   int pending ;
   int priority ;
   void *data ;
   void (*cb)(struct ev_loop *loop , struct ev_io *w , int revents ) ;
   struct ev_watcher_list *next ;
   int fd ;
   int events ;
};
typedef struct ev_io ev_io;
struct ev_timer {
   int active ;
   int pending ;
   int priority ;
   void *data ;
   void (*cb)(struct ev_loop *loop , struct ev_timer *w , int revents ) ;
   ev_tstamp at ;
   ev_tstamp repeat ;
};
typedef struct ev_timer ev_timer;
struct bufent {
   char data[32768] ;
   char *ptr ;
   size_t left ;
   struct bufent *next ;
};
typedef struct bufent bufent;
struct ringbuffer {
   bufent slots[3] ;
   bufent *head ;
   bufent *tail ;
   size_t used ;
};
typedef struct ringbuffer ringbuffer;
struct shcupd_peer_opt {
   char *ip ;
   char *port ;
};
typedef struct shcupd_peer_opt shcupd_peer_opt;
enum __anonenum_ENC_TYPE_1013557608 {
    ENC_TLS = 0,
    ENC_SSL = 1
} ;
typedef enum __anonenum_ENC_TYPE_1013557608 ENC_TYPE;
enum __anonenum_PROXY_MODE_13968060 {
    SSL_SERVER = 0,
    SSL_CLIENT = 1
} ;
typedef enum __anonenum_PROXY_MODE_13968060 PROXY_MODE;
struct cert_files {
   char *CERT_FILE ;
   struct cert_files *NEXT ;
};
struct __stud_config {
   ENC_TYPE ETYPE ;
   PROXY_MODE PMODE ;
   int WRITE_IP_OCTET ;
   int WRITE_PROXY_LINE ;
   int PROXY_PROXY_LINE ;
   char *CHROOT ;
   uid_t UID ;
   gid_t GID ;
   char *FRONT_IP ;
   char *FRONT_PORT ;
   char *BACK_IP ;
   char *BACK_PORT ;
   long NCORES ;
   struct cert_files *CERT_FILES ;
   char *CIPHER_SUITE ;
   char *ENGINE ;
   int BACKLOG ;
   int SHARED_CACHE ;
   char *SHCUPD_IP ;
   char *SHCUPD_PORT ;
   shcupd_peer_opt SHCUPD_PEERS[16] ;
   char *SHCUPD_MCASTIF ;
   char *SHCUPD_MCASTTTL ;
   int QUIET ;
   int SYSLOG ;
   int SYSLOG_FACILITY ;
   int TCP_KEEPALIVE_TIME ;
   int DAEMONIZE ;
   int PREFER_SERVER_CIPHERS ;
};
typedef struct __stud_config stud_config;
enum _SHUTDOWN_REQUESTOR {
    SHUTDOWN_HARD = 0,
    SHUTDOWN_CLEAR = 1,
    SHUTDOWN_SSL = 2
} ;
typedef enum _SHUTDOWN_REQUESTOR SHUTDOWN_REQUESTOR;
struct ctx_list {
   char *servername ;
   SSL_CTX *ctx ;
   struct ctx_list *next ;
};
typedef struct ctx_list ctx_list;
struct proxystate {
   ringbuffer ring_ssl2clear ;
   ringbuffer ring_clear2ssl ;
   ev_io ev_r_ssl ;
   ev_io ev_w_ssl ;
   ev_io ev_r_handshake ;
   ev_io ev_w_handshake ;
   ev_io ev_w_connect ;
   ev_io ev_r_clear ;
   ev_io ev_w_clear ;
   ev_io ev_proxy ;
   int fd_up ;
   int fd_down ;
   int want_shutdown : 1 ;
   int handshaked : 1 ;
   int clear_connected : 1 ;
   int renegotiation : 1 ;
   SSL *ssl ;
   struct sockaddr_storage remote_ip ;
};
typedef struct proxystate proxystate;
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
typedef unsigned long pthread_t;
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
typedef void eb_troot_t;
struct eb_root {
   eb_troot_t *b[1 << 1] ;
};
struct eb_node {
   struct eb_root branches ;
   eb_troot_t *node_p ;
   eb_troot_t *leaf_p ;
   short bit ;
   unsigned short pfx ;
};
struct ebmb_node {
   struct eb_node node ;
   unsigned char key[0] ;
};
struct shared_session {
   struct ebmb_node key ;
   unsigned char key_data[32] ;
   long c_date ;
   int data_len ;
   unsigned char data[512] ;
   struct shared_session *p ;
   struct shared_session *n ;
};
struct shared_context {
   pthread_mutex_t mutex ;
   struct shared_session active ;
   struct shared_session free ;
};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   void *__builtin_memset(void * , int  , int  ) ;  */
#pragma merger("0","/tmp/cil-PytHOJr7.i","-O2,-g,-std=c99,-fno-strict-aliasing,-Wall,-W")
__inline static __uint16_t __bswap_16(__uint16_t __bsx ) 
{ 


  {
  return ((__uint16_t )((((int )__bsx >> 8) & 255) | (((int )__bsx & 255) << 8)));
}
}
__inline static __uint32_t __bswap_32(__uint32_t __bsx ) 
{ 


  {
  return (((((__bsx & 4278190080U) >> 24) | ((__bsx & 16711680U) >> 8)) | ((__bsx & 65280U) << 8)) | ((__bsx & 255U) << 24));
}
}
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                               struct cmsghdr *__cmsg ) ;
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                               struct cmsghdr *__cmsg ) ;
__inline extern struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                 struct cmsghdr *__cmsg ) 
{ 


  {
  if (__cmsg->cmsg_len < sizeof(struct cmsghdr )) {
    return ((struct cmsghdr *)0);
  }
  __cmsg = (struct cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)));
  if ((unsigned long )((unsigned char *)(__cmsg + 1)) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  } else
  if ((unsigned long )((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  }
  return (__cmsg);
}
}
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  * __restrict  __addr ,
                                              socklen_t __len ) ;
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  * __restrict  __addr , socklen_t __addr_len ) ;
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigemptyset)(sigset_t *__set ) ;
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
extern __pid_t wait(int *__stat_loc ) ;
extern  __attribute__((__nothrow__)) in_addr_t inet_addr(char const   *__cp ) ;
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
extern  __attribute__((__nothrow__)) char const   *inet_ntop(int __af , void const   * __restrict  __cp ,
                                                             char * __restrict  __buf ,
                                                             socklen_t __len ) ;
extern FILE *stdin ;
extern FILE *stdout ;
extern FILE *stderr ;
extern int fclose(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
extern int getc(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
extern int putc(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
extern __ssize_t __getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                            int __delimiter , FILE * __restrict  __stream ) ;
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                     size_t * __restrict  __n ,
                                                                     FILE * __restrict  __stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
extern void perror(char const   *__s ) ;
extern int __uflow(FILE * ) ;
extern int __overflow(FILE * , int  ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) 
{ 
  int tmp ;

  {
  tmp = vfprintf((FILE * __restrict  )stdout, __fmt, __arg);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) 
{ 
  int tmp ;

  {
  tmp = getc(stdin);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(__fp);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = __fp->_IO_read_ptr;
    (__fp->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(stdin);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = stdin->_IO_read_ptr;
    (stdin->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) 
{ 
  int tmp ;

  {
  tmp = putc(__c, stdout);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = __stream->_IO_write_ptr;
    (__stream->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = stdout->_IO_write_ptr;
    (stdout->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                     size_t * __restrict  __n ,
                                                                     FILE * __restrict  __stream ) 
{ 
  __ssize_t tmp ;

  {
  tmp = __getdelim(__lineptr, __n, '\n', __stream);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 16) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 32) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1))) strtoll)(char const   * __restrict  __nptr ,
                                                                                          char ** __restrict  __endptr ,
                                                                                          int __base ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) atoi)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return ((int )tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long ( __attribute__((__nonnull__(1), __gnu_inline__)) atol)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long long ( __attribute__((__nonnull__(1), __gnu_inline__)) atoll)(char const   *__nptr ) 
{ 
  long long tmp ;

  {
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
  __l = (size_t )0;
  __u = __nmemb;
  while (__l < __u) {
    __idx = (__l + __u) / 2UL;
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
    __comparison = (*__compar)(__key, __p);
    if (__comparison < 0) {
      __u = __idx;
    } else
    if (__comparison > 0) {
      __l = __idx + 1UL;
    } else {
      return ((void *)__p);
    }
  }
  return ((void *)0);
}
}
extern  __attribute__((__nothrow__)) int abs(int __x )  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern double ( __attribute__((__nonnull__(1), __gnu_inline__)) atof)(char const   *__nptr ) 
{ 
  double tmp ;

  {
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
extern int close(int __fd ) ;
extern int pause(void) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chdir)(char const   *__path ) ;
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
extern  __attribute__((__nothrow__)) __pid_t getppid(void) ;
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) chroot)(char const   *__path ) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
extern void openlog(char const   *__ident , int __option , int __facility ) ;
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) tolower)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_tolower_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
    tmp___0 = (__int32_t const   )__c;
  }
  return ((int )tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) toupper)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_toupper_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
    tmp___0 = (__int32_t const   )__c;
  }
  return ((int )tmp___0);
}
}
extern  __attribute__((__nothrow__)) int sched_setaffinity(__pid_t __pid , size_t __cpusetsize ,
                                                           cpu_set_t const   *__cpuset ) ;
extern int sk_num(_STACK const   * ) ;
extern void *sk_value(_STACK const   * , int  ) ;
extern void sk_pop_free(_STACK *st , void (*func)(void * ) ) ;
extern unsigned long SSLeay(void) ;
extern int BIO_test_flags(BIO const   *b , int flags ) ;
extern BIO_METHOD *BIO_s_file(void) ;
extern BIO *BIO_new_file(char const   *filename , char const   *mode ) ;
extern BIO *BIO_new(BIO_METHOD *type ) ;
extern int BIO_free(BIO *a ) ;
extern int BIO_read(BIO *b , void *data , int len ) ;
extern long BIO_ctrl(BIO *bp , int cmd , long larg , void *parg ) ;
extern int ASN1_STRING_to_UTF8(unsigned char **out , ASN1_STRING *in ) ;
extern EVP_MD const   *EVP_sha1(void) ;
extern EC_KEY *EC_KEY_new_by_curve_name(int nid ) ;
extern void EC_KEY_free(EC_KEY *key ) ;
extern void RSA_free(RSA *r ) ;
extern int i2d_RSAPrivateKey(RSA const   *a , unsigned char **out ) ;
extern void DH_free(DH *dh ) ;
extern int DH_size(DH const   *dh ) ;
extern unsigned char *SHA1(unsigned char const   *d , size_t n , unsigned char *md ) ;
extern X509_NAME *X509_get_subject_name(X509 *a ) ;
extern int X509_NAME_get_index_by_NID(X509_NAME *name , int nid , int lastpos ) ;
extern X509_NAME_ENTRY *X509_NAME_get_entry(X509_NAME *name , int loc ) ;
extern void *X509_get_ext_d2i(X509 *x , int nid , int *crit , int *idx ) ;
extern X509 *PEM_read_bio_X509_AUX(BIO *bp , X509 **x , pem_password_cb *cb , void *u ) ;
extern RSA *PEM_read_bio_RSAPrivateKey(BIO *bp , RSA **x , pem_password_cb *cb , void *u ) ;
extern DH *PEM_read_bio_DHparams(BIO *bp , DH **x , pem_password_cb *cb , void *u ) ;
extern unsigned char *HMAC(EVP_MD const   *evp_md , void const   *key , int key_len ,
                           unsigned char const   *d , size_t n , unsigned char *md ,
                           unsigned int *md_len ) ;
extern void SSL_CTX_set_info_callback(SSL_CTX *ctx , void (*cb)(SSL const   *ssl ,
                                                                int type , int val ) ) ;
extern char const   *SSL_get_servername(SSL const   *s , int const   type ) ;
extern int SSL_CTX_set_cipher_list(SSL_CTX * , char const   *str ) ;
extern SSL_CTX *SSL_CTX_new(SSL_METHOD const   *meth ) ;
extern long SSL_CTX_get_timeout(SSL_CTX const   *ctx ) ;
extern int SSL_set_fd(SSL *s , int fd ) ;
extern BIO *SSL_get_rbio(SSL const   *s ) ;
extern int SSL_CTX_use_certificate_chain_file(SSL_CTX *ctx , char const   *file ) ;
extern void SSL_load_error_strings(void) ;
extern void SSL_SESSION_free(SSL_SESSION *ses ) ;
extern int SSL_set_session(SSL *to , SSL_SESSION *session ) ;
extern int SSL_CTX_use_RSAPrivateKey(SSL_CTX *ctx , RSA *rsa ) ;
extern SSL *SSL_new(SSL_CTX *ctx ) ;
extern void SSL_free(SSL *ssl ) ;
extern int SSL_read(SSL *ssl , void *buf , int num ) ;
extern int SSL_write(SSL *ssl , void const   *buf , int num ) ;
extern long SSL_ctrl(SSL *ssl , int cmd , long larg , void *parg ) ;
extern long SSL_CTX_ctrl(SSL_CTX *ctx , int cmd , long larg , void *parg ) ;
extern long SSL_CTX_callback_ctrl(SSL_CTX * , int  , void (*)(void) ) ;
extern int SSL_get_error(SSL const   *s , int ret_code ) ;
extern SSL_METHOD const   *SSLv23_server_method(void) ;
extern SSL_METHOD const   *SSLv23_client_method(void) ;
extern SSL_METHOD const   *TLSv1_server_method(void) ;
extern SSL_METHOD const   *TLSv1_client_method(void) ;
extern int SSL_do_handshake(SSL *s ) ;
extern void SSL_set_connect_state(SSL *s ) ;
extern void SSL_set_accept_state(SSL *s ) ;
extern int SSL_library_init(void) ;
extern void SSL_set_shutdown(SSL *ssl , int mode ) ;
extern SSL_SESSION *SSL_get1_session(SSL *ssl ) ;
extern SSL_CTX *SSL_set_SSL_CTX(SSL *ssl , SSL_CTX *ctx ) ;
extern int SSL_set_ex_data(SSL *ssl , int idx , void *data ) ;
extern void *SSL_get_ex_data(SSL const   *ssl , int idx ) ;
extern void GENERAL_NAME_free(GENERAL_NAME *a ) ;
extern void ERR_print_errors_fp(FILE *fp ) ;
extern ENGINE *ENGINE_by_id(char const   *id ) ;
extern void ENGINE_load_builtin_engines(void) ;
extern int ENGINE_register_all_complete(void) ;
extern int ENGINE_free(ENGINE *e ) ;
extern char const   *ENGINE_get_id(ENGINE const   *e ) ;
extern int ENGINE_init(ENGINE *e ) ;
extern int ENGINE_finish(ENGINE *e ) ;
extern int ENGINE_set_default(ENGINE *e , unsigned int flags ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat64)(int __fd , struct stat64 *__statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat64)(int __fd , char const   * __restrict  __filename , struct stat64 * __restrict  __statbuf ,
                            int __flag ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat)(int __ver ,
                                                                                     int __fildes ,
                                                                                     struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat)(int __ver ,
                                                                                      char const   *__filename ,
                                                                                      struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat)(int __ver ,
                                                                                       char const   *__filename ,
                                                                                       struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4))) __fxstatat)(int __ver ,
                                                                                         int __fildes ,
                                                                                         char const   *__filename ,
                                                                                         struct stat *__stat_buf ,
                                                                                         int __flag ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat64)(int __ver ,
                                                                                       int __fildes ,
                                                                                       struct stat64 *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat64)(int __ver ,
                                                                                        char const   *__filename ,
                                                                                        struct stat64 *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat64)(int __ver ,
                                                                                         char const   *__filename ,
                                                                                         struct stat64 *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4))) __fxstatat64)(int __ver ,
                                                                                           int __fildes ,
                                                                                           char const   *__filename ,
                                                                                           struct stat64 *__stat_buf ,
                                                                                           int __flag ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4))) __xmknod)(int __ver ,
                                                                                       char const   *__path ,
                                                                                       __mode_t __mode ,
                                                                                       __dev_t *__dev ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,5))) __xmknodat)(int __ver ,
                                                                                         int __fd ,
                                                                                         char const   *__path ,
                                                                                         __mode_t __mode ,
                                                                                         __dev_t *__dev ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) stat)(char const   * __restrict  __path ,
                                                                              struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __xstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) lstat)(char const   * __restrict  __path ,
                                                                               struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __lxstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) fstat)(int __fd ,
                                                                             struct stat *__statbuf ) 
{ 
  int tmp ;

  {
  tmp = __fxstat(1, __fd, __statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag ) ;
__inline extern int ( __attribute__((__nonnull__(2,3), __gnu_inline__)) fstatat)(int __fd ,
                                                                                 char const   * __restrict  __filename ,
                                                                                 struct stat * __restrict  __statbuf ,
                                                                                 int __flag ) 
{ 
  int tmp ;

  {
  tmp = __fxstatat(1, __fd, (char const   *)__filename, (struct stat *)__statbuf,
                   __flag);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) mknod)(char const   *__path ,
                                                                             __mode_t __mode ,
                                                                             __dev_t __dev ) 
{ 
  int tmp ;

  {
  tmp = __xmknod(0, __path, __mode, & __dev);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) mknodat)(int __fd ,
                                                                               char const   *__path ,
                                                                               __mode_t __mode ,
                                                                               __dev_t __dev ) 
{ 
  int tmp ;

  {
  tmp = __xmknodat(0, __fd, __path, __mode, & __dev);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) stat64)(char const   * __restrict  __path ,
                                                                                struct stat64 * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __xstat64(1, (char const   *)__path, (struct stat64 *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) lstat64)(char const   * __restrict  __path ,
                                                                                 struct stat64 * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __lxstat64(1, (char const   *)__path, (struct stat64 *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat64)(int __fd , struct stat64 *__statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) fstat64)(int __fd ,
                                                                               struct stat64 *__statbuf ) 
{ 
  int tmp ;

  {
  tmp = __fxstat64(1, __fd, __statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat64)(int __fd , char const   * __restrict  __filename , struct stat64 * __restrict  __statbuf ,
                            int __flag ) ;
__inline extern int ( __attribute__((__nonnull__(2,3), __gnu_inline__)) fstatat64)(int __fd ,
                                                                                   char const   * __restrict  __filename ,
                                                                                   struct stat64 * __restrict  __statbuf ,
                                                                                   int __flag ) 
{ 
  int tmp ;

  {
  tmp = __fxstatat64(1, __fd, (char const   *)__filename, (struct stat64 *)__statbuf,
                     __flag);
  return (tmp);
}
}
extern struct ev_loop *ev_default_loop(unsigned int flags ) ;
extern ev_tstamp ev_now(struct ev_loop *loop ) ;
extern int ev_run(struct ev_loop *loop , int flags ) ;
extern void ev_io_start(struct ev_loop *loop , ev_io *w ) ;
extern void ev_io_stop(struct ev_loop *loop , ev_io *w ) ;
extern void ev_timer_start(struct ev_loop *loop , ev_timer *w ) ;
extern void ev_timer_stop(struct ev_loop *loop , ev_timer *w ) ;
__inline static void ev_loop(struct ev_loop *loop___0 , int flags ) 
{ 


  {
  ev_run(loop___0, flags);
  return;
}
}
void ringbuffer_init(ringbuffer *rb ) ;
char *ringbuffer_read_next(ringbuffer *rb , int *length ) ;
void ringbuffer_read_skip(ringbuffer *rb , int length ) ;
void ringbuffer_read_pop(ringbuffer *rb ) ;
char *ringbuffer_write_ptr(ringbuffer *rb ) ;
void ringbuffer_write_append(ringbuffer *rb , int length ) ;
int ringbuffer_is_empty(ringbuffer *rb ) ;
int ringbuffer_is_full(ringbuffer *rb ) ;
void shsess_set_new_cbk(void (*func)(unsigned char *session , unsigned int len , long cdate ) ) ;
void shctx_sess_add(unsigned char const   *encsess , unsigned int len , long cdate ) ;
int shared_context_init(SSL_CTX *ctx , int size ) ;
stud_config *config_new(void) ;
void config_parse_cli(int argc , char **argv , stud_config *cfg ) ;
static struct ev_loop *loop  ;
static struct addrinfo *backaddr  ;
static pid_t master_pid  ;
static ev_io listener  ;
static int listener_socket  ;
static int child_num  ;
static pid_t *child_pids  ;
static SSL_CTX *default_ctx  ;
static SSL_SESSION *client_session  ;
static ev_io shcupd_listener  ;
static int shcupd_socket  ;
struct addrinfo *shcupd_peers[16]  ;
static unsigned char shared_secret[20]  ;
long openssl_version  ;
int create_workers  ;
stud_config *CONFIG  ;
static char tcp_proxy_line[128]  = {      (char )'\000'};
static ctx_list *sni_ctxs  ;
static void setnonblocking(int fd ) 
{ 
  int flag ;
  int tmp ;

  {
  flag = 1;
  tmp = ioctl(fd, 21537UL, & flag);
  if (! (tmp == 0)) {
    __assert_fail("ioctl(fd, FIONBIO, &flag) == 0", "stud.c", 194U, "setnonblocking");
  }
  return;
}
}
static void settcpkeepalive(int fd ) 
{ 
  int optval ;
  socklen_t optlen ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
  optval = 1;
  optlen = (socklen_t )sizeof(optval);
  tmp___3 = setsockopt(fd, 1, 9, (void const   *)(& optval), optlen);
  if (tmp___3 < 0) {
    while (1) {
      tmp = __errno_location();
      tmp___0 = strerror(*tmp);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error activating SO_KEEPALIVE on client socket: %s",
              tmp___0);
      if (CONFIG->SYSLOG) {
        tmp___1 = __errno_location();
        tmp___2 = strerror(*tmp___1);
        syslog(3, "Error activating SO_KEEPALIVE on client socket: %s", tmp___2);
      }
      break;
    }
  }
  optval = CONFIG->TCP_KEEPALIVE_TIME;
  optlen = (socklen_t )sizeof(optval);
  tmp___8 = setsockopt(fd, 6, 4, (void const   *)(& optval), optlen);
  if (tmp___8 < 0) {
    while (1) {
      tmp___4 = __errno_location();
      tmp___5 = strerror(*tmp___4);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error setting TCP_KEEPIDLE on client socket: %s",
              tmp___5);
      if (CONFIG->SYSLOG) {
        tmp___6 = __errno_location();
        tmp___7 = strerror(*tmp___6);
        syslog(3, "Error setting TCP_KEEPIDLE on client socket: %s", tmp___7);
      }
      break;
    }
  }
  return;
}
}
static void fail(char const   *s ) 
{ 


  {
  perror(s);
  exit(1);
}
}
void die(char *fmt  , ...) 
{ 
  va_list___0 args ;

  {
  __builtin_va_start(args, fmt);
  vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )fmt, args);
  __builtin_va_end(args);
  exit(1);
}
}
static int init_dh(SSL_CTX *ctx , char const   *cert ) 
{ 
  DH *dh ;
  BIO *bio ;
  int tmp ;
  int tmp___0 ;
  EC_KEY *ecdh ;

  {
  if (! cert) {
    __assert_fail("cert", "stud.c", 234U, "init_dh");
  }
  bio = BIO_new_file(cert, "r");
  if (! bio) {
    ERR_print_errors_fp(stderr);
    return (-1);
  }
  dh = PEM_read_bio_DHparams(bio, (DH **)((void *)0), (pem_password_cb *)((void *)0),
                             (void *)0);
  BIO_free(bio);
  if (! dh) {
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"{core} Note: no DH parameters found in %s\n",
              cert);
      if (CONFIG->SYSLOG) {
        syslog(3, "{core} Note: no DH parameters found in %s\n", cert);
      }
      break;
    }
    return (-1);
  }
  while (1) {
    if (! CONFIG->QUIET) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"{core} Using DH parameters from %s\n",
              cert);
    }
    if (CONFIG->SYSLOG) {
      syslog(6, "{core} Using DH parameters from %s\n", cert);
    }
    break;
  }
  SSL_CTX_ctrl(ctx, 3, 0L, (void *)((char *)dh));
  while (1) {
    if (! CONFIG->QUIET) {
      tmp = DH_size((DH const   *)dh);
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"{core} DH initialized with %d bit key\n",
              8 * tmp);
    }
    if (CONFIG->SYSLOG) {
      tmp___0 = DH_size((DH const   *)dh);
      syslog(6, "{core} DH initialized with %d bit key\n", 8 * tmp___0);
    }
    break;
  }
  DH_free(dh);
  ecdh = (EC_KEY *)((void *)0);
  ecdh = EC_KEY_new_by_curve_name(415);
  SSL_CTX_ctrl(ctx, 4, 0L, (void *)((char *)ecdh));
  EC_KEY_free(ecdh);
  while (1) {
    if (! CONFIG->QUIET) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"{core} ECDH Initialized with NIST P-256\n");
    }
    if (CONFIG->SYSLOG) {
      syslog(6, "{core} ECDH Initialized with NIST P-256\n");
    }
    break;
  }
  return (0);
}
}
static void info_callback(SSL const   *ssl___0 , int where , int ret ) 
{ 
  proxystate *ps ;
  void *tmp ;

  {
  if (where & 16) {
    tmp = SSL_get_ex_data(ssl___0, 0);
    ps = (proxystate *)tmp;
    if (ps->handshaked) {
      ps->renegotiation = 1;
      while (1) {
        if (! CONFIG->QUIET) {
          fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"{core} SSL renegotiation asked by client\n");
        }
        if (CONFIG->SYSLOG) {
          syslog(6, "{core} SSL renegotiation asked by client\n");
        }
        break;
      }
    }
  }
  return;
}
}
static void handle_shcupd(struct ev_loop *loop___0 , ev_io *w , int revents ) 
{ 
  unsigned char msg[(544UL + sizeof(uint32_t )) + 64UL] ;
  unsigned char hash[64] ;
  ssize_t r ;
  unsigned int hash_len ;
  uint32_t encdate ;
  long now ;
  ev_tstamp tmp ;
  EVP_MD const   *tmp___0 ;
  int tmp___1 ;
  __uint32_t tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp = ev_now(loop___0);
  now = (time_t )tmp;
  while (1) {
    r = recv(w->fd, (void *)(msg), sizeof(msg), 0);
    if (! (r > 0L)) {
      break;
    }
    if (r < (ssize_t )((int )(1UL + sizeof(shared_secret)))) {
      continue;
    }
    r = (ssize_t )((unsigned long )r - sizeof(shared_secret));
    tmp___0 = EVP_sha1();
    HMAC(tmp___0, (void const   *)(shared_secret), (int )sizeof(shared_secret), (unsigned char const   *)(msg),
         (size_t )r, hash, & hash_len);
    if ((unsigned long )hash_len != sizeof(shared_secret)) {
      continue;
    }
    tmp___1 = memcmp((void const   *)(msg + r), (void const   *)(hash), (size_t )hash_len);
    if (tmp___1) {
      continue;
    }
    if (r < (ssize_t )((int )(1UL + sizeof(uint32_t )))) {
      continue;
    }
    r = (ssize_t )((unsigned long )r - sizeof(uint32_t ));
    encdate = *((uint32_t *)(& msg[r]));
    tmp___2 = __bswap_32(encdate);
    tmp___3 = abs((int )((__uint32_t )((int32_t )now) - tmp___2));
    tmp___4 = SSL_CTX_get_timeout((SSL_CTX const   *)default_ctx);
    if (! ((long )tmp___3 < tmp___4)) {
      continue;
    }
    shctx_sess_add((unsigned char const   *)(msg), (unsigned int )r, now);
  }
  return;
}
}
void shcupd_session_new(unsigned char *msg , unsigned int len , long cdate ) 
{ 
  unsigned int hash_len ;
  struct addrinfo **pai ;
  uint32_t ncdate ;
  EVP_MD const   *tmp ;

  {
  pai = shcupd_peers;
  ncdate = __bswap_32((uint32_t )cdate);
  memcpy((void * __restrict  )(msg + len), (void const   * __restrict  )(& ncdate),
         sizeof(ncdate));
  len = (unsigned int )((unsigned long )len + sizeof(ncdate));
  tmp = EVP_sha1();
  HMAC(tmp, (void const   *)(shared_secret), (int )sizeof(shared_secret), (unsigned char const   *)msg,
       (size_t )len, msg + len, & hash_len);
  len += hash_len;
  while (*pai) {
    sendto(shcupd_socket, (void const   *)msg, (size_t )len, 0, (struct sockaddr  const  * __restrict  )(*pai)->ai_addr,
           (*pai)->ai_addrlen);
    pai ++;
  }
  return;
}
}
static int compute_secret(RSA *rsa , unsigned char *secret ) 
{ 
  unsigned char *buf ;
  unsigned char *p ;
  unsigned int length ;
  int tmp ;
  void *tmp___0 ;

  {
  tmp = i2d_RSAPrivateKey((RSA const   *)rsa, (unsigned char **)((void *)0));
  length = (unsigned int )tmp;
  if (length <= 0U) {
    return (-1);
  }
  tmp___0 = malloc((unsigned long )length * sizeof(unsigned char ));
  buf = (unsigned char *)tmp___0;
  p = buf;
  if (! buf) {
    return (-1);
  }
  i2d_RSAPrivateKey((RSA const   *)rsa, & p);
  SHA1((unsigned char const   *)buf, (size_t )length, secret);
  free((void *)buf);
  return (0);
}
}
static int create_shcupd_socket(void) 
{ 
  struct addrinfo *ai ;
  struct addrinfo hints ;
  struct addrinfo **pai ;
  int gai_err ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int s ;
  int tmp___2 ;
  int t ;
  struct ip_mreqn mreqn ;
  struct ifreq ifr ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  unsigned short const   **tmp___7 ;
  int *tmp___8 ;
  unsigned char loop___0 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  unsigned char ttl ;
  int tmp___12 ;
  int tmp___13 ;
  struct ipv6_mreq mreq ;
  struct ifreq ifr___0 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  unsigned short const   **tmp___18 ;
  int *tmp___19 ;
  unsigned int loop___1 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int hops ;
  int tmp___23 ;
  int tmp___24 ;

  {
  pai = shcupd_peers;
  memset((void *)(& hints), 0, sizeof(hints));
  hints.ai_family = 0;
  hints.ai_socktype = 2;
  hints.ai_flags = 33;
  tmp = getaddrinfo((char const   * __restrict  )CONFIG->SHCUPD_IP, (char const   * __restrict  )CONFIG->SHCUPD_PORT,
                    (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& ai));
  gai_err = tmp;
  if (gai_err != 0) {
    while (1) {
      tmp___0 = gai_strerror(gai_err);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"{getaddrinfo}: [%s]\n",
              tmp___0);
      if (CONFIG->SYSLOG) {
        tmp___1 = gai_strerror(gai_err);
        syslog(3, "{getaddrinfo}: [%s]\n", tmp___1);
      }
      break;
    }
    exit(1);
  }
  while (*pai) {
    if ((*pai)->ai_family != ai->ai_family) {
      while (1) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Share host and peers inet family differs\n");
        if (CONFIG->SYSLOG) {
          syslog(3, "Share host and peers inet family differs\n");
        }
        break;
      }
      exit(1);
    }
    pai ++;
  }
  tmp___2 = socket(ai->ai_family, 2, 17);
  s = tmp___2;
  if (s == -1) {
    fail("{socket: shared cache updates}");
  }
  t = 1;
  setsockopt(s, 1, 2, (void const   *)(& t), (socklen_t )sizeof(int ));
  setsockopt(s, 1, 15, (void const   *)(& t), (socklen_t )sizeof(int ));
  setnonblocking(s);
  if ((int )(ai->ai_addr)->sa_family == 2) {
    memset((void *)(& mreqn), 0, sizeof(mreqn));
    mreqn.imr_multiaddr.s_addr = ((struct sockaddr_in *)ai->ai_addr)->sin_addr.s_addr;
    if (CONFIG->SHCUPD_MCASTIF) {
      tmp___7 = __ctype_b_loc();
      if ((int const   )*(*tmp___7 + (int )*(CONFIG->SHCUPD_MCASTIF)) & 1024) {
        memset((void *)(& ifr), 0, sizeof(ifr));
        tmp___3 = strlen((char const   *)CONFIG->SHCUPD_MCASTIF);
        if (tmp___3 > 16UL) {
          while (1) {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error iface name is too long [%s]\n",
                    CONFIG->SHCUPD_MCASTIF);
            if (CONFIG->SYSLOG) {
              syslog(3, "Error iface name is too long [%s]\n", CONFIG->SHCUPD_MCASTIF);
            }
            break;
          }
          exit(1);
        }
        tmp___4 = strlen((char const   *)CONFIG->SHCUPD_MCASTIF);
        memcpy((void * __restrict  )(ifr.ifr_ifrn.ifrn_name), (void const   * __restrict  )CONFIG->SHCUPD_MCASTIF,
               tmp___4);
        tmp___5 = ioctl(s, 35123UL, & ifr);
        if (tmp___5) {
          fail("{ioctl: SIOCGIFINDEX}");
        }
        mreqn.imr_ifindex = ifr.ifr_ifru.ifru_ivalue;
      } else {
        tmp___6 = strchr((char const   *)CONFIG->SHCUPD_MCASTIF, '.');
        if (tmp___6) {
          mreqn.imr_address.s_addr = inet_addr((char const   *)CONFIG->SHCUPD_MCASTIF);
        } else {
          mreqn.imr_ifindex = atoi((char const   *)CONFIG->SHCUPD_MCASTIF);
        }
      }
    }
    tmp___10 = setsockopt(s, 0, 35, (void const   *)(& mreqn), (socklen_t )sizeof(mreqn));
    if (tmp___10 < 0) {
      tmp___8 = __errno_location();
      if (*tmp___8 != 22) {
        fail("{setsockopt: IP_ADD_MEMBERSIP}");
      }
    } else {
      loop___0 = (unsigned char)0;
      tmp___9 = setsockopt(s, 0, 34, (void const   *)(& loop___0), (socklen_t )sizeof(loop___0));
      if (tmp___9 < 0) {
        fail("{setsockopt: IP_MULTICAST_LOOP}");
      }
    }
    if (CONFIG->SHCUPD_MCASTIF) {
      tmp___11 = setsockopt(s, 0, 32, (void const   *)(& mreqn), (socklen_t )sizeof(mreqn));
      if (tmp___11 < 0) {
        fail("{setsockopt: IP_MULTICAST_IF}");
      }
    }
    if (CONFIG->SHCUPD_MCASTTTL) {
      tmp___12 = atoi((char const   *)CONFIG->SHCUPD_MCASTTTL);
      ttl = (unsigned char )tmp___12;
      tmp___13 = setsockopt(s, 0, 33, (void const   *)(& ttl), (socklen_t )sizeof(ttl));
      if (tmp___13 < 0) {
        fail("{setsockopt: IP_MULTICAST_TTL}");
      }
    }
  } else
  if ((int )(ai->ai_addr)->sa_family == 10) {
    memset((void *)(& mreq), 0, sizeof(mreq));
    memcpy((void * __restrict  )(& mreq.ipv6mr_multiaddr), (void const   * __restrict  )(& ((struct sockaddr_in6 *)ai->ai_addr)->sin6_addr),
           sizeof(mreq.ipv6mr_multiaddr));
    if (CONFIG->SHCUPD_MCASTIF) {
      tmp___18 = __ctype_b_loc();
      if ((int const   )*(*tmp___18 + (int )*(CONFIG->SHCUPD_MCASTIF)) & 1024) {
        memset((void *)(& ifr___0), 0, sizeof(ifr___0));
        tmp___14 = strlen((char const   *)CONFIG->SHCUPD_MCASTIF);
        if (tmp___14 > 16UL) {
          while (1) {
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error iface name is too long [%s]\n",
                    CONFIG->SHCUPD_MCASTIF);
            if (CONFIG->SYSLOG) {
              syslog(3, "Error iface name is too long [%s]\n", CONFIG->SHCUPD_MCASTIF);
            }
            break;
          }
          exit(1);
        }
        tmp___15 = strlen((char const   *)CONFIG->SHCUPD_MCASTIF);
        memcpy((void * __restrict  )(ifr___0.ifr_ifrn.ifrn_name), (void const   * __restrict  )CONFIG->SHCUPD_MCASTIF,
               tmp___15);
        tmp___16 = ioctl(s, 35123UL, & ifr___0);
        if (tmp___16) {
          fail("{ioctl: SIOCGIFINDEX}");
        }
        mreq.ipv6mr_interface = (unsigned int )ifr___0.ifr_ifru.ifru_ivalue;
      } else {
        tmp___17 = atoi((char const   *)CONFIG->SHCUPD_MCASTIF);
        mreq.ipv6mr_interface = (unsigned int )tmp___17;
      }
    }
    tmp___21 = setsockopt(s, 41, 20, (void const   *)(& mreq), (socklen_t )sizeof(mreq));
    if (tmp___21 < 0) {
      tmp___19 = __errno_location();
      if (*tmp___19 != 22) {
        fail("{setsockopt: IPV6_ADD_MEMBERSIP}");
      }
    } else {
      loop___1 = 0U;
      tmp___20 = setsockopt(s, 41, 19, (void const   *)(& loop___1), (socklen_t )sizeof(loop___1));
      if (tmp___20 < 0) {
        fail("{setsockopt: IPV6_MULTICAST_LOOP}");
      }
    }
    tmp___22 = setsockopt(s, 41, 17, (void const   *)(& mreq.ipv6mr_interface), (socklen_t )sizeof(mreq.ipv6mr_interface));
    if (tmp___22 < 0) {
      fail("{setsockopt: IPV6_MULTICAST_IF}");
    }
    if (CONFIG->SHCUPD_MCASTTTL) {
      hops = atoi((char const   *)CONFIG->SHCUPD_MCASTTTL);
      tmp___23 = setsockopt(s, 41, 18, (void const   *)(& hops), (socklen_t )sizeof(hops));
      if (tmp___23 < 0) {
        fail("{setsockopt: IPV6_MULTICAST_HOPS}");
      }
    }
  }
  tmp___24 = bind(s, (struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen);
  if (tmp___24) {
    fail("{bind-socket}");
  }
  freeaddrinfo(ai);
  return (s);
}
}
RSA *load_rsa_privatekey(SSL_CTX *ctx , char const   *file ) 
{ 
  BIO *bio ;
  RSA *rsa ;

  {
  bio = BIO_new_file(file, "r");
  if (! bio) {
    ERR_print_errors_fp(stderr);
    return ((RSA *)((void *)0));
  }
  rsa = PEM_read_bio_RSAPrivateKey(bio, (RSA **)((void *)0), ctx->default_passwd_callback,
                                   ctx->default_passwd_callback_userdata);
  BIO_free(bio);
  return (rsa);
}
}
int sni_switch_ctx(SSL *ssl___0 , int *al , void *data ) 
{ 
  char const   *servername ;
  ctx_list const   *cl ;
  int tmp ;

  {
  servername = SSL_get_servername((SSL const   *)ssl___0, (int const   )0);
  if (! servername) {
    return (3);
  }
  cl = (ctx_list const   *)sni_ctxs;
  while ((unsigned long )cl != (unsigned long )((void *)0)) {
    tmp = strcasecmp(servername, (char const   *)cl->servername);
    if (tmp == 0) {
      SSL_set_SSL_CTX(ssl___0, (SSL_CTX *)cl->ctx);
      return (3);
    }
    cl = (ctx_list const   *)cl->next;
  }
  return (3);
}
}
SSL_CTX *make_ctx(char const   *pemfile ) 
{ 
  SSL_CTX *ctx ;
  RSA *rsa ;
  long ssloptions ;
  SSL_METHOD const   *tmp ;
  SSL_METHOD const   *tmp___0 ;
  SSL_METHOD const   *tmp___1 ;
  SSL_METHOD const   *tmp___2 ;
  SSL_METHOD const   *tmp___3 ;
  SSL_METHOD const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  ssloptions = 2164329471L;
  ssloptions |= 131072L;
  if ((unsigned int )CONFIG->ETYPE == 0U) {
    if ((unsigned int )CONFIG->PMODE == 1U) {
      tmp = TLSv1_client_method();
      tmp___1 = tmp;
    } else {
      tmp___0 = TLSv1_server_method();
      tmp___1 = tmp___0;
    }
    ctx = SSL_CTX_new(tmp___1);
  } else
  if ((unsigned int )CONFIG->ETYPE == 1U) {
    if ((unsigned int )CONFIG->PMODE == 1U) {
      tmp___2 = SSLv23_client_method();
      tmp___4 = tmp___2;
    } else {
      tmp___3 = SSLv23_server_method();
      tmp___4 = tmp___3;
    }
    ctx = SSL_CTX_new(tmp___4);
  } else {
    if (! ((unsigned int )CONFIG->ETYPE == 0U)) {
      if (! ((unsigned int )CONFIG->ETYPE == 1U)) {
        __assert_fail("CONFIG->ETYPE == ENC_TLS || CONFIG->ETYPE == ENC_SSL", "stud.c",
                      607U, "make_ctx");
      }
    }
    return ((SSL_CTX *)((void *)0));
  }
  SSL_CTX_ctrl(ctx, 32, ssloptions, (void *)0);
  SSL_CTX_set_info_callback(ctx, & info_callback);
  if (CONFIG->CIPHER_SUITE) {
    tmp___5 = SSL_CTX_set_cipher_list(ctx, (char const   *)CONFIG->CIPHER_SUITE);
    if (tmp___5 != 1) {
      ERR_print_errors_fp(stderr);
    }
  }
  if (CONFIG->PREFER_SERVER_CIPHERS) {
    SSL_CTX_ctrl(ctx, 32, 4194304L, (void *)0);
  }
  if ((unsigned int )CONFIG->PMODE == 1U) {
    return (ctx);
  }
  tmp___6 = SSL_CTX_use_certificate_chain_file(ctx, pemfile);
  if (tmp___6 <= 0) {
    ERR_print_errors_fp(stderr);
    exit(1);
  }
  rsa = load_rsa_privatekey(ctx, pemfile);
  if (! rsa) {
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error loading rsa private key\n");
      if (CONFIG->SYSLOG) {
        syslog(3, "Error loading rsa private key\n");
      }
      break;
    }
    exit(1);
  }
  tmp___7 = SSL_CTX_use_RSAPrivateKey(ctx, rsa);
  if (tmp___7 <= 0) {
    ERR_print_errors_fp(stderr);
    exit(1);
  }
  init_dh(ctx, pemfile);
  tmp___8 = SSL_CTX_callback_ctrl(ctx, 53, (void (*)(void))(& sni_switch_ctx));
  if (! tmp___8) {
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error setting up SNI support\n");
      if (CONFIG->SYSLOG) {
        syslog(3, "Error setting up SNI support\n");
      }
      break;
    }
  }
  if (CONFIG->SHARED_CACHE) {
    tmp___9 = shared_context_init(ctx, CONFIG->SHARED_CACHE);
    if (tmp___9 < 0) {
      while (1) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unable to alloc memory for shared cache.\n");
        if (CONFIG->SYSLOG) {
          syslog(3, "Unable to alloc memory for shared cache.\n");
        }
        break;
      }
      exit(1);
    }
    if (CONFIG->SHCUPD_PORT) {
      tmp___10 = compute_secret(rsa, shared_secret);
      if (tmp___10 < 0) {
        while (1) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unable to compute shared secret.\n");
          if (CONFIG->SYSLOG) {
            syslog(3, "Unable to compute shared secret.\n");
          }
          break;
        }
        exit(1);
      }
      SSL_CTX_ctrl(ctx, 32, 16384L, (void *)0);
      if (shcupd_peers[0]) {
        shsess_set_new_cbk(& shcupd_session_new);
      }
    }
  }
  RSA_free(rsa);
  return (ctx);
}
}
SSL_CTX *init_openssl(void) 
{ 
  struct cert_files *cf ;
  int i ;
  SSL_CTX *ctx ;
  X509 *x509 ;
  BIO *f ;
  struct stack_st_GENERAL_NAME *names ;
  GENERAL_NAME *name ;
  BIO_METHOD *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  struct ctx_list *cl ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  X509_NAME *x509_name ;
  X509_NAME *tmp___6 ;
  X509_NAME_ENTRY *x509_entry ;
  X509_NAME_ENTRY *tmp___7 ;
  struct ctx_list *cl___0 ;
  void *tmp___8 ;
  ENGINE *e ;
  int tmp___9 ;
  int tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  int tmp___13 ;

  {
  SSL_library_init();
  SSL_load_error_strings();
  if (! ((unsigned long )CONFIG->CERT_FILES != (unsigned long )((void *)0))) {
    __assert_fail("CONFIG->CERT_FILES != NULL", "stud.c", 688U, "init_openssl");
  }
  default_ctx = make_ctx((char const   *)(CONFIG->CERT_FILES)->CERT_FILE);
  names = (struct stack_st_GENERAL_NAME *)((void *)0);
  cf = (CONFIG->CERT_FILES)->NEXT;
  while ((unsigned long )cf != (unsigned long )((void *)0)) {
    ctx = make_ctx((char const   *)cf->CERT_FILE);
    tmp = BIO_s_file();
    f = BIO_new(tmp);
    tmp___0 = BIO_ctrl(f, 108, 3L, (void *)cf->CERT_FILE);
    if (! tmp___0) {
      while (1) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not read cert \'%s\'\n",
                cf->CERT_FILE);
        if (CONFIG->SYSLOG) {
          syslog(3, "Could not read cert \'%s\'\n", cf->CERT_FILE);
        }
        break;
      }
    }
    x509 = PEM_read_bio_X509_AUX(f, (X509 **)((void *)0), (pem_password_cb *)((void *)0),
                                 (void *)0);
    BIO_free(f);
    tmp___1 = X509_get_ext_d2i(x509, 85, (int *)((void *)0), (int *)((void *)0));
    names = (struct stack_st_GENERAL_NAME *)tmp___1;
    i = 0;
    while (1) {
      tmp___4 = sk_num((_STACK const   *)((_STACK *)names));
      if (! (i < tmp___4)) {
        break;
      }
      tmp___2 = sk_value((_STACK const   *)((_STACK *)names), i);
      name = (GENERAL_NAME *)tmp___2;
      if (name->type == 2) {
        while (1) {
          tmp___3 = calloc((size_t )1, sizeof(*cl));
          cl = (struct ctx_list *)tmp___3;
          ASN1_STRING_to_UTF8((unsigned char **)(& cl->servername), name->d.dNSName);
          cl->ctx = ctx;
          cl->next = sni_ctxs;
          sni_ctxs = cl;
          break;
        }
      }
      i ++;
    }
    tmp___5 = sk_num((_STACK const   *)((_STACK *)names));
    if (tmp___5 > 0) {
      sk_pop_free((_STACK *)names, (void (*)(void * ))(& GENERAL_NAME_free));
      goto __Cont;
    } else
    if ((unsigned long )names != (unsigned long )((void *)0)) {
      sk_pop_free((_STACK *)names, (void (*)(void * ))(& GENERAL_NAME_free));
    }
    tmp___6 = X509_get_subject_name(x509);
    x509_name = tmp___6;
    i = X509_NAME_get_index_by_NID(x509_name, 13, -1);
    if (i < 0) {
      while (1) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not find Subject Alternative Names or a CN on cert %s\n",
                cf->CERT_FILE);
        if (CONFIG->SYSLOG) {
          syslog(3, "Could not find Subject Alternative Names or a CN on cert %s\n",
                 cf->CERT_FILE);
        }
        break;
      }
    }
    tmp___7 = X509_NAME_get_entry(x509_name, i);
    x509_entry = tmp___7;
    while (1) {
      tmp___8 = calloc((size_t )1, sizeof(*cl___0));
      cl___0 = (struct ctx_list *)tmp___8;
      ASN1_STRING_to_UTF8((unsigned char **)(& cl___0->servername), x509_entry->value);
      cl___0->ctx = ctx;
      cl___0->next = sni_ctxs;
      sni_ctxs = cl___0;
      break;
    }
    __Cont: /* CIL Label */ 
    cf = cf->NEXT;
  }
  if (CONFIG->ENGINE) {
    e = (ENGINE *)((void *)0);
    ENGINE_load_builtin_engines();
    tmp___13 = strcmp((char const   *)CONFIG->ENGINE, "auto");
    if (tmp___13) {
      e = ENGINE_by_id((char const   *)CONFIG->ENGINE);
      if ((unsigned long )e == (unsigned long )((void *)0)) {
        ERR_print_errors_fp(stderr);
        exit(1);
      } else {
        tmp___9 = ENGINE_init(e);
        if (tmp___9) {
          tmp___10 = ENGINE_set_default(e, 65535U);
          if (! tmp___10) {
            ERR_print_errors_fp(stderr);
            exit(1);
          }
        } else {
          ERR_print_errors_fp(stderr);
          exit(1);
        }
      }
      while (1) {
        if (! CONFIG->QUIET) {
          tmp___11 = ENGINE_get_id((ENGINE const   *)e);
          fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"{core} will use OpenSSL engine %s.\n",
                  tmp___11);
        }
        if (CONFIG->SYSLOG) {
          tmp___12 = ENGINE_get_id((ENGINE const   *)e);
          syslog(6, "{core} will use OpenSSL engine %s.\n", tmp___12);
        }
        break;
      }
      ENGINE_finish(e);
      ENGINE_free(e);
    } else {
      ENGINE_register_all_complete();
    }
  }
  return ((SSL_CTX *)0);
}
}
static void prepare_proxy_line(struct sockaddr *ai_addr ) 
{ 
  char tcp6_address_string[46] ;
  struct sockaddr_in *addr ;
  size_t res ;
  __uint16_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  struct sockaddr_in6 *addr___0 ;
  size_t res___0 ;
  __uint16_t tmp___2 ;
  int tmp___3 ;

  {
  tcp_proxy_line[0] = (char)0;
  if ((int )ai_addr->sa_family == 2) {
    addr = (struct sockaddr_in *)ai_addr;
    tmp = __bswap_16(addr->sin_port);
    tmp___0 = inet_ntoa(addr->sin_addr);
    tmp___1 = snprintf((char * __restrict  )(tcp_proxy_line), sizeof(tcp_proxy_line),
                       (char const   * __restrict  )"PROXY %%s %%s %s %%hu %hu\r\n",
                       tmp___0, (int )tmp);
    res = (size_t )tmp___1;
    if (! (res < sizeof(tcp_proxy_line))) {
      __assert_fail("res < sizeof(tcp_proxy_line)", "stud.c", 788U, "prepare_proxy_line");
    }
  } else
  if ((int )ai_addr->sa_family == 10) {
    addr___0 = (struct sockaddr_in6 *)ai_addr;
    inet_ntop(10, (void const   * __restrict  )(& addr___0->sin6_addr), (char * __restrict  )(tcp6_address_string),
              (socklen_t )46);
    tmp___2 = __bswap_16(addr___0->sin6_port);
    tmp___3 = snprintf((char * __restrict  )(tcp_proxy_line), sizeof(tcp_proxy_line),
                       (char const   * __restrict  )"PROXY %%s %%s %s %%hu %hu\r\n",
                       tcp6_address_string, (int )tmp___2);
    res___0 = (size_t )tmp___3;
    if (! (res___0 < sizeof(tcp_proxy_line))) {
      __assert_fail("res < sizeof(tcp_proxy_line)", "stud.c", 798U, "prepare_proxy_line");
    }
  } else {
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"The --write-proxy mode is not implemented for this address family.\n");
      if (CONFIG->SYSLOG) {
        syslog(3, "The --write-proxy mode is not implemented for this address family.\n");
      }
      break;
    }
    exit(1);
  }
  return;
}
}
static int create_main_socket(void) 
{ 
  struct addrinfo *ai ;
  struct addrinfo hints ;
  int gai_err ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int s ;
  int tmp___2 ;
  int t ;
  int tmp___3 ;
  int timeout ;

  {
  memset((void *)(& hints), 0, sizeof(hints));
  hints.ai_family = 0;
  hints.ai_socktype = 1;
  hints.ai_flags = 33;
  tmp = getaddrinfo((char const   * __restrict  )CONFIG->FRONT_IP, (char const   * __restrict  )CONFIG->FRONT_PORT,
                    (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& ai));
  gai_err = tmp;
  if (gai_err != 0) {
    while (1) {
      tmp___0 = gai_strerror(gai_err);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"{getaddrinfo}: [%s]\n",
              tmp___0);
      if (CONFIG->SYSLOG) {
        tmp___1 = gai_strerror(gai_err);
        syslog(3, "{getaddrinfo}: [%s]\n", tmp___1);
      }
      break;
    }
    exit(1);
  }
  tmp___2 = socket(ai->ai_family, 1, 6);
  s = tmp___2;
  if (s == -1) {
    fail("{socket: main}");
  }
  t = 1;
  setsockopt(s, 1, 2, (void const   *)(& t), (socklen_t )sizeof(int ));
  setsockopt(s, 1, 15, (void const   *)(& t), (socklen_t )sizeof(int ));
  setnonblocking(s);
  tmp___3 = bind(s, (struct sockaddr  const  * __restrict  )ai->ai_addr, ai->ai_addrlen);
  if (tmp___3) {
    fail("{bind-socket}");
  }
  timeout = 1;
  setsockopt(s, 6, 9, (void const   *)(& timeout), (socklen_t )sizeof(int ));
  prepare_proxy_line(ai->ai_addr);
  freeaddrinfo(ai);
  listen(s, CONFIG->BACKLOG);
  return (s);
}
}
static int create_back_socket(void) 
{ 
  int s ;
  int tmp ;
  int flag ;
  int ret ;
  int tmp___0 ;

  {
  tmp = socket(backaddr->ai_family, 1, 6);
  s = tmp;
  if (s == -1) {
    return (-1);
  }
  flag = 1;
  tmp___0 = setsockopt(s, 6, 1, (void const   *)((char *)(& flag)), (socklen_t )sizeof(flag));
  ret = tmp___0;
  if (ret == -1) {
    perror("Couldn\'t setsockopt to backend (TCP_NODELAY)\n");
  }
  setnonblocking(s);
  return (s);
}
}
static void safe_enable_io(proxystate *ps , ev_io *w ) 
{ 


  {
  if (! ps->want_shutdown) {
    ev_io_start(loop, w);
  }
  return;
}
}
static void shutdown_proxy(proxystate *ps , SHUTDOWN_REQUESTOR req ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  if (ps->want_shutdown) {
    goto _L___0;
  } else
  if ((unsigned int )req == 0U) {
    _L___0: /* CIL Label */ 
    ev_io_stop(loop, & ps->ev_w_ssl);
    ev_io_stop(loop, & ps->ev_r_ssl);
    ev_io_stop(loop, & ps->ev_w_handshake);
    ev_io_stop(loop, & ps->ev_r_handshake);
    ev_io_stop(loop, & ps->ev_w_connect);
    ev_io_stop(loop, & ps->ev_w_clear);
    ev_io_stop(loop, & ps->ev_r_clear);
    ev_io_stop(loop, & ps->ev_proxy);
    close(ps->fd_up);
    close(ps->fd_down);
    SSL_set_shutdown(ps->ssl, 1);
    SSL_free(ps->ssl);
    free((void *)ps);
  } else {
    ps->want_shutdown = 1;
    if ((unsigned int )req == 1U) {
      tmp___0 = ringbuffer_is_empty(& ps->ring_clear2ssl);
      if (tmp___0) {
        shutdown_proxy(ps, (SHUTDOWN_REQUESTOR )0);
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
    if ((unsigned int )req == 2U) {
      tmp = ringbuffer_is_empty(& ps->ring_ssl2clear);
      if (tmp) {
        shutdown_proxy(ps, (SHUTDOWN_REQUESTOR )0);
      }
    }
  }
  return;
}
}
static void handle_socket_errno(proxystate *ps , int backend ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;

  {
  tmp = __errno_location();
  if (*tmp == 11) {
    return;
  } else {
    tmp___0 = __errno_location();
    if (*tmp___0 == 11) {
      return;
    } else {
      tmp___1 = __errno_location();
      if (*tmp___1 == 4) {
        return;
      }
    }
  }
  tmp___10 = __errno_location();
  if (*tmp___10 == 104) {
    while (1) {
      if (backend) {
        tmp___2 = "backend";
      } else {
        tmp___2 = "client";
      }
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"{%s} Connection reset by peer\n",
              tmp___2);
      if (CONFIG->SYSLOG) {
        if (backend) {
          tmp___3 = "backend";
        } else {
          tmp___3 = "client";
        }
        syslog(3, "{%s} Connection reset by peer\n", tmp___3);
      }
      break;
    }
  } else {
    tmp___9 = __errno_location();
    if (*tmp___9 == 110) {
      while (1) {
        if (backend) {
          tmp___4 = "backend";
        } else {
          tmp___4 = "client";
        }
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"{%s} Connection to backend timed out\n",
                tmp___4);
        if (CONFIG->SYSLOG) {
          if (backend) {
            tmp___5 = "backend";
          } else {
            tmp___5 = "client";
          }
          syslog(3, "{%s} Connection to backend timed out\n", tmp___5);
        }
        break;
      }
    } else {
      tmp___8 = __errno_location();
      if (*tmp___8 == 32) {
        while (1) {
          if (backend) {
            tmp___6 = "backend";
          } else {
            tmp___6 = "client";
          }
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"{%s} Broken pipe to backend (EPIPE)\n",
                  tmp___6);
          if (CONFIG->SYSLOG) {
            if (backend) {
              tmp___7 = "backend";
            } else {
              tmp___7 = "client";
            }
            syslog(3, "{%s} Broken pipe to backend (EPIPE)\n", tmp___7);
          }
          break;
        }
      } else {
        perror("{backend} [errno]");
      }
    }
  }
  shutdown_proxy(ps, (SHUTDOWN_REQUESTOR )1);
  return;
}
}
static void start_connect(proxystate *ps ) 
{ 
  int t ;
  int *tmp ;
  int *tmp___0 ;

  {
  t = 1;
  t = connect(ps->fd_down, (struct sockaddr  const  * __restrict  )backaddr->ai_addr,
              backaddr->ai_addrlen);
  if (t == 0) {
    ev_io_start(loop, & ps->ev_w_connect);
    return;
  } else {
    tmp = __errno_location();
    if (*tmp == 115) {
      ev_io_start(loop, & ps->ev_w_connect);
      return;
    } else {
      tmp___0 = __errno_location();
      if (*tmp___0 == 4) {
        ev_io_start(loop, & ps->ev_w_connect);
        return;
      }
    }
  }
  perror("{backend-connect}");
  shutdown_proxy(ps, (SHUTDOWN_REQUESTOR )0);
  return;
}
}
static void clear_read(struct ev_loop *loop___0 , ev_io *w , int revents ) 
{ 
  int t ;
  proxystate *ps ;
  int fd ;
  char *buf ;
  char *tmp ;
  ssize_t tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;

  {
  ps = (proxystate *)w->data;
  if (ps->want_shutdown) {
    ev_io_stop(loop___0, & ps->ev_r_clear);
    return;
  }
  fd = w->fd;
  tmp = ringbuffer_write_ptr(& ps->ring_clear2ssl);
  buf = tmp;
  tmp___0 = recv(fd, (void *)buf, (size_t )32768, 0);
  t = (int )tmp___0;
  if (t > 0) {
    ringbuffer_write_append(& ps->ring_clear2ssl, t);
    tmp___1 = ringbuffer_is_full(& ps->ring_clear2ssl);
    if (tmp___1) {
      ev_io_stop(loop___0, & ps->ev_r_clear);
    }
    if (ps->handshaked) {
      safe_enable_io(ps, & ps->ev_w_ssl);
    }
  } else
  if (t == 0) {
    while (1) {
      if (! CONFIG->QUIET) {
        if (fd == ps->fd_down) {
          tmp___2 = "backend";
        } else {
          tmp___2 = "client";
        }
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"{%s} Connection closed\n",
                tmp___2);
      }
      if (CONFIG->SYSLOG) {
        if (fd == ps->fd_down) {
          tmp___3 = "backend";
        } else {
          tmp___3 = "client";
        }
        syslog(6, "{%s} Connection closed\n", tmp___3);
      }
      break;
    }
    shutdown_proxy(ps, (SHUTDOWN_REQUESTOR )1);
  } else {
    if (! (t == -1)) {
      __assert_fail("t == -1", "stud.c", 960U, "clear_read");
    }
    if (fd == ps->fd_down) {
      tmp___4 = 1;
    } else {
      tmp___4 = 0;
    }
    handle_socket_errno(ps, tmp___4);
  }
  return;
}
}
static void clear_write(struct ev_loop *loop___0 , ev_io *w , int revents ) 
{ 
  int t ;
  proxystate *ps ;
  int fd ;
  int sz ;
  int tmp ;
  char *next ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  ps = (proxystate *)w->data;
  fd = w->fd;
  tmp = ringbuffer_is_empty(& ps->ring_ssl2clear);
  if (tmp) {
    __assert_fail("!ringbuffer_is_empty(&ps->ring_ssl2clear)", "stud.c", 973U, "clear_write");
  }
  tmp___0 = ringbuffer_read_next(& ps->ring_ssl2clear, & sz);
  next = tmp___0;
  tmp___1 = send(fd, (void const   *)next, (size_t )sz, 16384);
  t = (int )tmp___1;
  if (t > 0) {
    if (t == sz) {
      ringbuffer_read_pop(& ps->ring_ssl2clear);
      if (ps->handshaked) {
        safe_enable_io(ps, & ps->ev_r_ssl);
      }
      tmp___2 = ringbuffer_is_empty(& ps->ring_ssl2clear);
      if (tmp___2) {
        if (ps->want_shutdown) {
          shutdown_proxy(ps, (SHUTDOWN_REQUESTOR )0);
          return;
        }
        ev_io_stop(loop___0, & ps->ev_w_clear);
      }
    } else {
      ringbuffer_read_skip(& ps->ring_ssl2clear, t);
    }
  } else {
    if (! (t == -1)) {
      __assert_fail("t == -1", "stud.c", 996U, "clear_write");
    }
    if (fd == ps->fd_down) {
      tmp___3 = 1;
    } else {
      tmp___3 = 0;
    }
    handle_socket_errno(ps, tmp___3);
  }
  return;
}
}
static void start_handshake(proxystate *ps , int err ) ;
static void handle_connect(struct ev_loop *loop___0 , ev_io *w , int revents ) 
{ 
  int t ;
  proxystate *ps ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;

  {
  ps = (proxystate *)w->data;
  t = connect(ps->fd_down, (struct sockaddr  const  * __restrict  )backaddr->ai_addr,
              backaddr->ai_addrlen);
  if (! t) {
    goto _L;
  } else {
    tmp___4 = __errno_location();
    if (*tmp___4 == 106) {
      goto _L;
    } else {
      tmp___5 = __errno_location();
      if (*tmp___5) {
        tmp___1 = __errno_location();
        if (! (*tmp___1 == 115)) {
          tmp___2 = __errno_location();
          if (! (*tmp___2 == 4)) {
            tmp___3 = __errno_location();
            if (! (*tmp___3 == 114)) {
              perror("{backend-connect}");
              shutdown_proxy(ps, (SHUTDOWN_REQUESTOR )0);
            }
          }
        }
      } else {
        _L: /* CIL Label */ 
        ev_io_stop(loop___0, & ps->ev_w_connect);
        if (! ps->clear_connected) {
          ps->clear_connected = 1;
          tmp = ringbuffer_is_full(& ps->ring_clear2ssl);
          if (! tmp) {
            safe_enable_io(ps, & ps->ev_r_clear);
          }
          tmp___0 = ringbuffer_is_empty(& ps->ring_ssl2clear);
          if (! tmp___0) {
            ev_io_start(loop___0, & ps->ev_w_clear);
          }
        } else {
          start_handshake(ps, 3);
        }
      }
    }
  }
  return;
}
}
static void start_handshake(proxystate *ps , int err ) 
{ 


  {
  ev_io_stop(loop, & ps->ev_r_ssl);
  ev_io_stop(loop, & ps->ev_w_ssl);
  ps->handshaked = 0;
  if (err == 2) {
    ev_io_start(loop, & ps->ev_r_handshake);
  } else
  if (err == 3) {
    ev_io_start(loop, & ps->ev_w_handshake);
  }
  return;
}
}
static void end_handshake(proxystate *ps ) 
{ 
  char tcp6_address_string[46] ;
  size_t written ;
  char *ring_pnt ;
  char *tmp ;
  struct sockaddr_in *addr ;
  __uint16_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  struct sockaddr_in6 *addr___0 ;
  __uint16_t tmp___3 ;
  int tmp___4 ;
  char *ring_pnt___0 ;
  char *tmp___5 ;
  char *tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  written = (size_t )0;
  ev_io_stop(loop, & ps->ev_r_handshake);
  ev_io_stop(loop, & ps->ev_w_handshake);
  if ((ps->ssl)->s3) {
    ((ps->ssl)->s3)->flags |= 1L;
  }
  ps->handshaked = 1;
  if (! ps->clear_connected) {
    if (CONFIG->WRITE_PROXY_LINE) {
      tmp = ringbuffer_write_ptr(& ps->ring_ssl2clear);
      ring_pnt = tmp;
      if (! ((int )ps->remote_ip.ss_family == 2)) {
        if (! ((int )ps->remote_ip.ss_family == 10)) {
          __assert_fail("ps->remote_ip.ss_family == AF_INET || ps->remote_ip.ss_family == AF_INET6",
                        "stud.c", 1072U, "end_handshake");
        }
      }
      if ((int )ps->remote_ip.ss_family == 2) {
        addr = (struct sockaddr_in *)(& ps->remote_ip);
        tmp___0 = __bswap_16(addr->sin_port);
        tmp___1 = inet_ntoa(addr->sin_addr);
        tmp___2 = snprintf((char * __restrict  )ring_pnt, (size_t )32768, (char const   * __restrict  )(tcp_proxy_line),
                           "TCP4", tmp___1, (int )tmp___0);
        written = (size_t )tmp___2;
      } else
      if ((int )ps->remote_ip.ss_family == 10) {
        addr___0 = (struct sockaddr_in6 *)(& ps->remote_ip);
        inet_ntop(10, (void const   * __restrict  )(& addr___0->sin6_addr), (char * __restrict  )(tcp6_address_string),
                  (socklen_t )46);
        tmp___3 = __bswap_16(addr___0->sin6_port);
        tmp___4 = snprintf((char * __restrict  )ring_pnt, (size_t )32768, (char const   * __restrict  )(tcp_proxy_line),
                           "TCP6", tcp6_address_string, (int )tmp___3);
        written = (size_t )tmp___4;
      }
      ringbuffer_write_append(& ps->ring_ssl2clear, (int )written);
    } else
    if (CONFIG->WRITE_IP_OCTET) {
      tmp___5 = ringbuffer_write_ptr(& ps->ring_ssl2clear);
      ring_pnt___0 = tmp___5;
      if (! ((int )ps->remote_ip.ss_family == 2)) {
        if (! ((int )ps->remote_ip.ss_family == 10)) {
          __assert_fail("ps->remote_ip.ss_family == AF_INET || ps->remote_ip.ss_family == AF_INET6",
                        "stud.c", 1097U, "end_handshake");
        }
      }
      tmp___6 = ring_pnt___0;
      ring_pnt___0 ++;
      *tmp___6 = (char )((unsigned char )ps->remote_ip.ss_family);
      if ((int )ps->remote_ip.ss_family == 10) {
        memcpy((void * __restrict  )ring_pnt___0, (void const   * __restrict  )(& ((struct sockaddr_in6 *)(& ps->remote_ip))->sin6_addr.__in6_u.__u6_addr8),
               (size_t )16U);
        ringbuffer_write_append(& ps->ring_ssl2clear, 17);
      } else {
        memcpy((void * __restrict  )ring_pnt___0, (void const   * __restrict  )(& ((struct sockaddr_in *)(& ps->remote_ip))->sin_addr.s_addr),
               (size_t )4U);
        ringbuffer_write_append(& ps->ring_ssl2clear, 5);
      }
    }
    start_connect(ps);
  } else {
    tmp___7 = SSL_ctrl(ps->ssl, 8, 0L, (void *)0);
    if (! tmp___7) {
      if (client_session) {
        SSL_SESSION_free(client_session);
      }
      client_session = SSL_get1_session(ps->ssl);
    }
  }
  tmp___8 = ringbuffer_is_full(& ps->ring_ssl2clear);
  if (! tmp___8) {
    safe_enable_io(ps, & ps->ev_r_ssl);
  }
  tmp___9 = ringbuffer_is_empty(& ps->ring_clear2ssl);
  if (! tmp___9) {
    ev_io_start(loop, & ps->ev_w_ssl);
  }
  return;
}
}
static void client_proxy_proxy(struct ev_loop *loop___0 , ev_io *w , int revents ) 
{ 
  int t ;
  char *proxy ;
  char *end ;
  proxystate *ps ;
  BIO *b ;
  BIO *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *ring ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  proxy = tcp_proxy_line;
  end = tcp_proxy_line + sizeof(tcp_proxy_line);
  ps = (proxystate *)w->data;
  tmp = SSL_get_rbio((SSL const   *)ps->ssl);
  b = tmp;
  while (1) {
    if ((unsigned long )proxy != (unsigned long )end) {
      t = BIO_read(b, (void *)proxy, 1);
      if (! (t == 1)) {
        break;
      }
    } else {
      break;
    }
    tmp___0 = proxy;
    proxy ++;
    if ((int )*tmp___0 == 10) {
      break;
    }
  }
  if ((unsigned long )proxy == (unsigned long )end) {
    while (1) {
      if (! CONFIG->QUIET) {
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"{client} Unexpectedly long PROXY line. Perhaps a malformed request?");
      }
      if (CONFIG->SYSLOG) {
        syslog(6, "{client} Unexpectedly long PROXY line. Perhaps a malformed request?");
      }
      break;
    }
    shutdown_proxy(ps, (SHUTDOWN_REQUESTOR )2);
  } else
  if (t == 1) {
    tmp___1 = ringbuffer_is_full(& ps->ring_ssl2clear);
    if (tmp___1) {
      while (1) {
        if (! CONFIG->QUIET) {
          fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"{client} Error writing PROXY line");
        }
        if (CONFIG->SYSLOG) {
          syslog(6, "{client} Error writing PROXY line");
        }
        break;
      }
      shutdown_proxy(ps, (SHUTDOWN_REQUESTOR )2);
      return;
    }
    tmp___2 = ringbuffer_write_ptr(& ps->ring_ssl2clear);
    ring = tmp___2;
    memcpy((void * __restrict  )ring, (void const   * __restrict  )(tcp_proxy_line),
           (size_t )(proxy - tcp_proxy_line));
    ringbuffer_write_append(& ps->ring_ssl2clear, (int )(proxy - tcp_proxy_line));
    if ((int )*(proxy - 1) == 10) {
      ev_io_stop(loop___0, & ps->ev_proxy);
      start_handshake(ps, 2);
    }
  } else {
    tmp___3 = BIO_test_flags((BIO const   *)b, 8);
    if (! tmp___3) {
      while (1) {
        if (! CONFIG->QUIET) {
          fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"{client} Unexpected error reading PROXY line");
        }
        if (CONFIG->SYSLOG) {
          syslog(6, "{client} Unexpected error reading PROXY line");
        }
        break;
      }
      shutdown_proxy(ps, (SHUTDOWN_REQUESTOR )2);
    }
  }
  return;
}
}
static void client_handshake(struct ev_loop *loop___0 , ev_io *w , int revents ) 
{ 
  int t ;
  proxystate *ps ;
  int err ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
  ps = (proxystate *)w->data;
  t = SSL_do_handshake(ps->ssl);
  if (t == 1) {
    end_handshake(ps);
  } else {
    tmp = SSL_get_error((SSL const   *)ps->ssl, t);
    err = tmp;
    if (err == 2) {
      ev_io_stop(loop___0, & ps->ev_w_handshake);
      ev_io_start(loop___0, & ps->ev_r_handshake);
    } else
    if (err == 3) {
      ev_io_stop(loop___0, & ps->ev_r_handshake);
      ev_io_start(loop___0, & ps->ev_w_handshake);
    } else
    if (err == 6) {
      while (1) {
        if (! CONFIG->QUIET) {
          if (w->fd == ps->fd_up) {
            tmp___0 = "client";
          } else {
            tmp___0 = "backend";
          }
          fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"{%s} Connection closed (in handshake)\n",
                  tmp___0);
        }
        if (CONFIG->SYSLOG) {
          if (w->fd == ps->fd_up) {
            tmp___1 = "client";
          } else {
            tmp___1 = "backend";
          }
          syslog(6, "{%s} Connection closed (in handshake)\n", tmp___1);
        }
        break;
      }
      shutdown_proxy(ps, (SHUTDOWN_REQUESTOR )2);
    } else {
      while (1) {
        if (! CONFIG->QUIET) {
          if (w->fd == ps->fd_up) {
            tmp___2 = "client";
          } else {
            tmp___2 = "backend";
          }
          fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"{%s} Unexpected SSL error (in handshake): %d\n",
                  tmp___2, err);
        }
        if (CONFIG->SYSLOG) {
          if (w->fd == ps->fd_up) {
            tmp___3 = "client";
          } else {
            tmp___3 = "backend";
          }
          syslog(6, "{%s} Unexpected SSL error (in handshake): %d\n", tmp___3, err);
        }
        break;
      }
      shutdown_proxy(ps, (SHUTDOWN_REQUESTOR )2);
    }
  }
  return;
}
}
static void handle_fatal_ssl_error(proxystate *ps , int err , int backend ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;

  {
  if (err == 6) {
    while (1) {
      if (backend) {
        tmp = "backend";
      } else {
        tmp = "client";
      }
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"{%s} Connection closed (in data)\n",
              tmp);
      if (CONFIG->SYSLOG) {
        if (backend) {
          tmp___0 = "backend";
        } else {
          tmp___0 = "client";
        }
        syslog(3, "{%s} Connection closed (in data)\n", tmp___0);
      }
      break;
    }
  } else
  if (err == 5) {
    tmp___4 = __errno_location();
    if (*tmp___4 == 0) {
      while (1) {
        if (backend) {
          tmp___1 = "backend";
        } else {
          tmp___1 = "client";
        }
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"{%s} Connection closed (in data)\n",
                tmp___1);
        if (CONFIG->SYSLOG) {
          if (backend) {
            tmp___2 = "backend";
          } else {
            tmp___2 = "client";
          }
          syslog(3, "{%s} Connection closed (in data)\n", tmp___2);
        }
        break;
      }
    } else {
      if (backend) {
        tmp___3 = "{backend} [errno] ";
      } else {
        tmp___3 = "{client} [errno] ";
      }
      perror(tmp___3);
    }
  } else {
    while (1) {
      if (backend) {
        tmp___5 = "backend";
      } else {
        tmp___5 = "client";
      }
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"{%s} Unexpected SSL_read error: %d\n",
              tmp___5, err);
      if (CONFIG->SYSLOG) {
        if (backend) {
          tmp___6 = "backend";
        } else {
          tmp___6 = "client";
        }
        syslog(3, "{%s} Unexpected SSL_read error: %d\n", tmp___6, err);
      }
      break;
    }
  }
  shutdown_proxy(ps, (SHUTDOWN_REQUESTOR )2);
  return;
}
}
static void ssl_read(struct ev_loop *loop___0 , ev_io *w , int revents ) 
{ 
  int t ;
  proxystate *ps ;
  char *buf ;
  char *tmp ;
  int tmp___0 ;
  int err ;
  int tmp___1 ;
  int tmp___2 ;

  {
  ps = (proxystate *)w->data;
  if (ps->want_shutdown) {
    ev_io_stop(loop___0, & ps->ev_r_ssl);
    return;
  }
  tmp = ringbuffer_write_ptr(& ps->ring_ssl2clear);
  buf = tmp;
  t = SSL_read(ps->ssl, (void *)buf, 32768);
  if (ps->renegotiation) {
    shutdown_proxy(ps, (SHUTDOWN_REQUESTOR )2);
    return;
  }
  if (t > 0) {
    ringbuffer_write_append(& ps->ring_ssl2clear, t);
    tmp___0 = ringbuffer_is_full(& ps->ring_ssl2clear);
    if (tmp___0) {
      ev_io_stop(loop___0, & ps->ev_r_ssl);
    }
    if (ps->clear_connected) {
      safe_enable_io(ps, & ps->ev_w_clear);
    }
  } else {
    tmp___1 = SSL_get_error((SSL const   *)ps->ssl, t);
    err = tmp___1;
    if (err == 3) {
      start_handshake(ps, err);
    } else
    if (! (err == 2)) {
      if (w->fd == ps->fd_up) {
        tmp___2 = 0;
      } else {
        tmp___2 = 1;
      }
      handle_fatal_ssl_error(ps, err, tmp___2);
    }
  }
  return;
}
}
static void ssl_write(struct ev_loop *loop___0 , ev_io *w , int revents ) 
{ 
  int t ;
  int sz ;
  proxystate *ps ;
  int tmp ;
  char *next ;
  char *tmp___0 ;
  int tmp___1 ;
  int err ;
  int tmp___2 ;
  int tmp___3 ;

  {
  ps = (proxystate *)w->data;
  tmp = ringbuffer_is_empty(& ps->ring_clear2ssl);
  if (tmp) {
    __assert_fail("!ringbuffer_is_empty(&ps->ring_clear2ssl)", "stud.c", 1264U, "ssl_write");
  }
  tmp___0 = ringbuffer_read_next(& ps->ring_clear2ssl, & sz);
  next = tmp___0;
  t = SSL_write(ps->ssl, (void const   *)next, sz);
  if (t > 0) {
    if (t == sz) {
      ringbuffer_read_pop(& ps->ring_clear2ssl);
      if (ps->clear_connected) {
        safe_enable_io(ps, & ps->ev_r_clear);
      }
      tmp___1 = ringbuffer_is_empty(& ps->ring_clear2ssl);
      if (tmp___1) {
        if (ps->want_shutdown) {
          shutdown_proxy(ps, (SHUTDOWN_REQUESTOR )0);
          return;
        }
        ev_io_stop(loop___0, & ps->ev_w_ssl);
      }
    } else {
      ringbuffer_read_skip(& ps->ring_clear2ssl, t);
    }
  } else {
    tmp___2 = SSL_get_error((SSL const   *)ps->ssl, t);
    err = tmp___2;
    if (err == 2) {
      start_handshake(ps, err);
    } else
    if (! (err == 3)) {
      if (w->fd == ps->fd_up) {
        tmp___3 = 0;
      } else {
        tmp___3 = 1;
      }
      handle_fatal_ssl_error(ps, err, tmp___3);
    }
  }
  return;
}
}
static void handle_accept(struct ev_loop *loop___0 , ev_io *w , int revents ) 
{ 
  struct sockaddr_storage addr ;
  socklen_t sl ;
  int client___0 ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int flag ;
  int ret ;
  int tmp___4 ;
  int back ;
  int tmp___5 ;
  SSL_CTX *ctx ;
  SSL *ssl___0 ;
  SSL *tmp___6 ;
  long mode ;
  proxystate *ps ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
  sl = (socklen_t )sizeof(addr);
  tmp = accept(w->fd, (struct sockaddr * __restrict  )((struct sockaddr *)(& addr)),
               (socklen_t * __restrict  )(& sl));
  client___0 = tmp;
  if (client___0 == -1) {
    tmp___0 = __errno_location();
    switch (*tmp___0) {
    case 24: 
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"{client} accept() failed; too many open files for this process\n");
      if (CONFIG->SYSLOG) {
        syslog(3, "{client} accept() failed; too many open files for this process\n");
      }
      break;
    }
    break;
    case 23: 
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"{client} accept() failed; too many open files for this system\n");
      if (CONFIG->SYSLOG) {
        syslog(3, "{client} accept() failed; too many open files for this system\n");
      }
      break;
    }
    break;
    default: 
    tmp___1 = __errno_location();
    if (! (*tmp___1 == 4)) {
      tmp___2 = __errno_location();
      if (! (*tmp___2 == 11)) {
        tmp___3 = __errno_location();
        if (! (*tmp___3 == 11)) {
          __assert_fail("errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN",
                        "stud.c", 1315U, "handle_accept");
        }
      }
    }
    break;
    }
    return;
  }
  flag = 1;
  tmp___4 = setsockopt(client___0, 6, 1, (void const   *)((char *)(& flag)), (socklen_t )sizeof(flag));
  ret = tmp___4;
  if (ret == -1) {
    perror("Couldn\'t setsockopt on client (TCP_NODELAY)\n");
  }
  setnonblocking(client___0);
  settcpkeepalive(client___0);
  tmp___5 = create_back_socket();
  back = tmp___5;
  if (back == -1) {
    close(client___0);
    perror("{backend-socket}");
    return;
  }
  ctx = (SSL_CTX *)w->data;
  tmp___6 = SSL_new(ctx);
  ssl___0 = tmp___6;
  mode = 1L;
  mode |= 16L;
  SSL_ctrl(ssl___0, 33, mode, (void *)0);
  SSL_set_accept_state(ssl___0);
  SSL_set_fd(ssl___0, client___0);
  tmp___7 = malloc(sizeof(proxystate ));
  ps = (proxystate *)tmp___7;
  ps->fd_up = client___0;
  ps->fd_down = back;
  ps->ssl = ssl___0;
  ps->want_shutdown = 0;
  ps->clear_connected = 0;
  ps->handshaked = 0;
  ps->renegotiation = 0;
  ps->remote_ip = addr;
  ringbuffer_init(& ps->ring_clear2ssl);
  ringbuffer_init(& ps->ring_ssl2clear);
  while (1) {
    while (1) {
      tmp___8 = 0;
      ((ev_watcher *)((void *)(& ps->ev_r_ssl)))->pending = tmp___8;
      ((ev_watcher *)((void *)(& ps->ev_r_ssl)))->active = tmp___8;
      ((ev_watcher *)((void *)(& ps->ev_r_ssl)))->priority = 0;
      ps->ev_r_ssl.cb = & ssl_read;
      memmove((void *)(& ((ev_watcher *)(& ps->ev_r_ssl))->cb), (void const   *)(& ps->ev_r_ssl.cb),
              sizeof(ps->ev_r_ssl.cb));
      break;
    }
    while (1) {
      ps->ev_r_ssl.fd = client___0;
      ps->ev_r_ssl.events = 129;
      break;
    }
    break;
  }
  while (1) {
    while (1) {
      tmp___9 = 0;
      ((ev_watcher *)((void *)(& ps->ev_w_ssl)))->pending = tmp___9;
      ((ev_watcher *)((void *)(& ps->ev_w_ssl)))->active = tmp___9;
      ((ev_watcher *)((void *)(& ps->ev_w_ssl)))->priority = 0;
      ps->ev_w_ssl.cb = & ssl_write;
      memmove((void *)(& ((ev_watcher *)(& ps->ev_w_ssl))->cb), (void const   *)(& ps->ev_w_ssl.cb),
              sizeof(ps->ev_w_ssl.cb));
      break;
    }
    while (1) {
      ps->ev_w_ssl.fd = client___0;
      ps->ev_w_ssl.events = 130;
      break;
    }
    break;
  }
  while (1) {
    while (1) {
      tmp___10 = 0;
      ((ev_watcher *)((void *)(& ps->ev_r_handshake)))->pending = tmp___10;
      ((ev_watcher *)((void *)(& ps->ev_r_handshake)))->active = tmp___10;
      ((ev_watcher *)((void *)(& ps->ev_r_handshake)))->priority = 0;
      ps->ev_r_handshake.cb = & client_handshake;
      memmove((void *)(& ((ev_watcher *)(& ps->ev_r_handshake))->cb), (void const   *)(& ps->ev_r_handshake.cb),
              sizeof(ps->ev_r_handshake.cb));
      break;
    }
    while (1) {
      ps->ev_r_handshake.fd = client___0;
      ps->ev_r_handshake.events = 129;
      break;
    }
    break;
  }
  while (1) {
    while (1) {
      tmp___11 = 0;
      ((ev_watcher *)((void *)(& ps->ev_w_handshake)))->pending = tmp___11;
      ((ev_watcher *)((void *)(& ps->ev_w_handshake)))->active = tmp___11;
      ((ev_watcher *)((void *)(& ps->ev_w_handshake)))->priority = 0;
      ps->ev_w_handshake.cb = & client_handshake;
      memmove((void *)(& ((ev_watcher *)(& ps->ev_w_handshake))->cb), (void const   *)(& ps->ev_w_handshake.cb),
              sizeof(ps->ev_w_handshake.cb));
      break;
    }
    while (1) {
      ps->ev_w_handshake.fd = client___0;
      ps->ev_w_handshake.events = 130;
      break;
    }
    break;
  }
  while (1) {
    while (1) {
      tmp___12 = 0;
      ((ev_watcher *)((void *)(& ps->ev_proxy)))->pending = tmp___12;
      ((ev_watcher *)((void *)(& ps->ev_proxy)))->active = tmp___12;
      ((ev_watcher *)((void *)(& ps->ev_proxy)))->priority = 0;
      ps->ev_proxy.cb = & client_proxy_proxy;
      memmove((void *)(& ((ev_watcher *)(& ps->ev_proxy))->cb), (void const   *)(& ps->ev_proxy.cb),
              sizeof(ps->ev_proxy.cb));
      break;
    }
    while (1) {
      ps->ev_proxy.fd = client___0;
      ps->ev_proxy.events = 129;
      break;
    }
    break;
  }
  while (1) {
    while (1) {
      tmp___13 = 0;
      ((ev_watcher *)((void *)(& ps->ev_w_connect)))->pending = tmp___13;
      ((ev_watcher *)((void *)(& ps->ev_w_connect)))->active = tmp___13;
      ((ev_watcher *)((void *)(& ps->ev_w_connect)))->priority = 0;
      ps->ev_w_connect.cb = & handle_connect;
      memmove((void *)(& ((ev_watcher *)(& ps->ev_w_connect))->cb), (void const   *)(& ps->ev_w_connect.cb),
              sizeof(ps->ev_w_connect.cb));
      break;
    }
    while (1) {
      ps->ev_w_connect.fd = back;
      ps->ev_w_connect.events = 130;
      break;
    }
    break;
  }
  while (1) {
    while (1) {
      tmp___14 = 0;
      ((ev_watcher *)((void *)(& ps->ev_w_clear)))->pending = tmp___14;
      ((ev_watcher *)((void *)(& ps->ev_w_clear)))->active = tmp___14;
      ((ev_watcher *)((void *)(& ps->ev_w_clear)))->priority = 0;
      ps->ev_w_clear.cb = & clear_write;
      memmove((void *)(& ((ev_watcher *)(& ps->ev_w_clear))->cb), (void const   *)(& ps->ev_w_clear.cb),
              sizeof(ps->ev_w_clear.cb));
      break;
    }
    while (1) {
      ps->ev_w_clear.fd = back;
      ps->ev_w_clear.events = 130;
      break;
    }
    break;
  }
  while (1) {
    while (1) {
      tmp___15 = 0;
      ((ev_watcher *)((void *)(& ps->ev_r_clear)))->pending = tmp___15;
      ((ev_watcher *)((void *)(& ps->ev_r_clear)))->active = tmp___15;
      ((ev_watcher *)((void *)(& ps->ev_r_clear)))->priority = 0;
      ps->ev_r_clear.cb = & clear_read;
      memmove((void *)(& ((ev_watcher *)(& ps->ev_r_clear))->cb), (void const   *)(& ps->ev_r_clear.cb),
              sizeof(ps->ev_r_clear.cb));
      break;
    }
    while (1) {
      ps->ev_r_clear.fd = back;
      ps->ev_r_clear.events = 129;
      break;
    }
    break;
  }
  ps->ev_r_ssl.data = (void *)ps;
  ps->ev_w_ssl.data = (void *)ps;
  ps->ev_r_clear.data = (void *)ps;
  ps->ev_w_clear.data = (void *)ps;
  ps->ev_proxy.data = (void *)ps;
  ps->ev_w_connect.data = (void *)ps;
  ps->ev_r_handshake.data = (void *)ps;
  ps->ev_w_handshake.data = (void *)ps;
  SSL_set_ex_data(ssl___0, 0, (void *)((char *)ps));
  if (CONFIG->PROXY_PROXY_LINE) {
    ev_io_start(loop___0, & ps->ev_proxy);
  } else {
    start_handshake(ps, 2);
  }
  return;
}
}
static void check_ppid(struct ev_loop *loop___0 , ev_timer *w , int revents ) 
{ 
  pid_t ppid ;
  __pid_t tmp ;

  {
  tmp = getppid();
  ppid = tmp;
  if (ppid != master_pid) {
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"{core} Process %d detected parent death, closing listener socket.\n",
              child_num);
      if (CONFIG->SYSLOG) {
        syslog(3, "{core} Process %d detected parent death, closing listener socket.\n",
               child_num);
      }
      break;
    }
    ev_timer_stop(loop___0, w);
    ev_io_stop(loop___0, & listener);
    close(listener_socket);
  }
  return;
}
}
static void handle_clear_accept(struct ev_loop *loop___0 , ev_io *w , int revents ) 
{ 
  struct sockaddr_storage addr ;
  socklen_t sl ;
  int client___0 ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int flag ;
  int ret ;
  int tmp___4 ;
  int back ;
  int tmp___5 ;
  SSL_CTX *ctx ;
  SSL *ssl___0 ;
  SSL *tmp___6 ;
  long mode ;
  proxystate *ps ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  sl = (socklen_t )sizeof(addr);
  tmp = accept(w->fd, (struct sockaddr * __restrict  )((struct sockaddr *)(& addr)),
               (socklen_t * __restrict  )(& sl));
  client___0 = tmp;
  if (client___0 == -1) {
    tmp___0 = __errno_location();
    switch (*tmp___0) {
    case 24: 
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"{client} accept() failed; too many open files for this process\n");
      if (CONFIG->SYSLOG) {
        syslog(3, "{client} accept() failed; too many open files for this process\n");
      }
      break;
    }
    break;
    case 23: 
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"{client} accept() failed; too many open files for this system\n");
      if (CONFIG->SYSLOG) {
        syslog(3, "{client} accept() failed; too many open files for this system\n");
      }
      break;
    }
    break;
    default: 
    tmp___1 = __errno_location();
    if (! (*tmp___1 == 4)) {
      tmp___2 = __errno_location();
      if (! (*tmp___2 == 11)) {
        tmp___3 = __errno_location();
        if (! (*tmp___3 == 11)) {
          __assert_fail("errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN",
                        "stud.c", 1432U, "handle_clear_accept");
        }
      }
    }
    break;
    }
    return;
  }
  flag = 1;
  tmp___4 = setsockopt(client___0, 6, 1, (void const   *)((char *)(& flag)), (socklen_t )sizeof(flag));
  ret = tmp___4;
  if (ret == -1) {
    perror("Couldn\'t setsockopt on client (TCP_NODELAY)\n");
  }
  setnonblocking(client___0);
  settcpkeepalive(client___0);
  tmp___5 = create_back_socket();
  back = tmp___5;
  if (back == -1) {
    close(client___0);
    perror("{backend-socket}");
    return;
  }
  ctx = (SSL_CTX *)w->data;
  tmp___6 = SSL_new(ctx);
  ssl___0 = tmp___6;
  mode = 1L;
  mode |= 16L;
  SSL_ctrl(ssl___0, 33, mode, (void *)0);
  SSL_set_connect_state(ssl___0);
  SSL_set_fd(ssl___0, back);
  if (client_session) {
    SSL_set_session(ssl___0, client_session);
  }
  tmp___7 = malloc(sizeof(proxystate ));
  ps = (proxystate *)tmp___7;
  ps->fd_up = client___0;
  ps->fd_down = back;
  ps->ssl = ssl___0;
  ps->want_shutdown = 0;
  ps->clear_connected = 1;
  ps->handshaked = 0;
  ps->renegotiation = 0;
  ps->remote_ip = addr;
  ringbuffer_init(& ps->ring_clear2ssl);
  ringbuffer_init(& ps->ring_ssl2clear);
  while (1) {
    while (1) {
      tmp___8 = 0;
      ((ev_watcher *)((void *)(& ps->ev_r_clear)))->pending = tmp___8;
      ((ev_watcher *)((void *)(& ps->ev_r_clear)))->active = tmp___8;
      ((ev_watcher *)((void *)(& ps->ev_r_clear)))->priority = 0;
      ps->ev_r_clear.cb = & clear_read;
      memmove((void *)(& ((ev_watcher *)(& ps->ev_r_clear))->cb), (void const   *)(& ps->ev_r_clear.cb),
              sizeof(ps->ev_r_clear.cb));
      break;
    }
    while (1) {
      ps->ev_r_clear.fd = client___0;
      ps->ev_r_clear.events = 129;
      break;
    }
    break;
  }
  while (1) {
    while (1) {
      tmp___9 = 0;
      ((ev_watcher *)((void *)(& ps->ev_w_clear)))->pending = tmp___9;
      ((ev_watcher *)((void *)(& ps->ev_w_clear)))->active = tmp___9;
      ((ev_watcher *)((void *)(& ps->ev_w_clear)))->priority = 0;
      ps->ev_w_clear.cb = & clear_write;
      memmove((void *)(& ((ev_watcher *)(& ps->ev_w_clear))->cb), (void const   *)(& ps->ev_w_clear.cb),
              sizeof(ps->ev_w_clear.cb));
      break;
    }
    while (1) {
      ps->ev_w_clear.fd = client___0;
      ps->ev_w_clear.events = 130;
      break;
    }
    break;
  }
  while (1) {
    while (1) {
      tmp___10 = 0;
      ((ev_watcher *)((void *)(& ps->ev_w_connect)))->pending = tmp___10;
      ((ev_watcher *)((void *)(& ps->ev_w_connect)))->active = tmp___10;
      ((ev_watcher *)((void *)(& ps->ev_w_connect)))->priority = 0;
      ps->ev_w_connect.cb = & handle_connect;
      memmove((void *)(& ((ev_watcher *)(& ps->ev_w_connect))->cb), (void const   *)(& ps->ev_w_connect.cb),
              sizeof(ps->ev_w_connect.cb));
      break;
    }
    while (1) {
      ps->ev_w_connect.fd = back;
      ps->ev_w_connect.events = 130;
      break;
    }
    break;
  }
  while (1) {
    while (1) {
      tmp___11 = 0;
      ((ev_watcher *)((void *)(& ps->ev_r_handshake)))->pending = tmp___11;
      ((ev_watcher *)((void *)(& ps->ev_r_handshake)))->active = tmp___11;
      ((ev_watcher *)((void *)(& ps->ev_r_handshake)))->priority = 0;
      ps->ev_r_handshake.cb = & client_handshake;
      memmove((void *)(& ((ev_watcher *)(& ps->ev_r_handshake))->cb), (void const   *)(& ps->ev_r_handshake.cb),
              sizeof(ps->ev_r_handshake.cb));
      break;
    }
    while (1) {
      ps->ev_r_handshake.fd = back;
      ps->ev_r_handshake.events = 129;
      break;
    }
    break;
  }
  while (1) {
    while (1) {
      tmp___12 = 0;
      ((ev_watcher *)((void *)(& ps->ev_w_handshake)))->pending = tmp___12;
      ((ev_watcher *)((void *)(& ps->ev_w_handshake)))->active = tmp___12;
      ((ev_watcher *)((void *)(& ps->ev_w_handshake)))->priority = 0;
      ps->ev_w_handshake.cb = & client_handshake;
      memmove((void *)(& ((ev_watcher *)(& ps->ev_w_handshake))->cb), (void const   *)(& ps->ev_w_handshake.cb),
              sizeof(ps->ev_w_handshake.cb));
      break;
    }
    while (1) {
      ps->ev_w_handshake.fd = back;
      ps->ev_w_handshake.events = 130;
      break;
    }
    break;
  }
  while (1) {
    while (1) {
      tmp___13 = 0;
      ((ev_watcher *)((void *)(& ps->ev_w_ssl)))->pending = tmp___13;
      ((ev_watcher *)((void *)(& ps->ev_w_ssl)))->active = tmp___13;
      ((ev_watcher *)((void *)(& ps->ev_w_ssl)))->priority = 0;
      ps->ev_w_ssl.cb = & ssl_write;
      memmove((void *)(& ((ev_watcher *)(& ps->ev_w_ssl))->cb), (void const   *)(& ps->ev_w_ssl.cb),
              sizeof(ps->ev_w_ssl.cb));
      break;
    }
    while (1) {
      ps->ev_w_ssl.fd = back;
      ps->ev_w_ssl.events = 130;
      break;
    }
    break;
  }
  while (1) {
    while (1) {
      tmp___14 = 0;
      ((ev_watcher *)((void *)(& ps->ev_r_ssl)))->pending = tmp___14;
      ((ev_watcher *)((void *)(& ps->ev_r_ssl)))->active = tmp___14;
      ((ev_watcher *)((void *)(& ps->ev_r_ssl)))->priority = 0;
      ps->ev_r_ssl.cb = & ssl_read;
      memmove((void *)(& ((ev_watcher *)(& ps->ev_r_ssl))->cb), (void const   *)(& ps->ev_r_ssl.cb),
              sizeof(ps->ev_r_ssl.cb));
      break;
    }
    while (1) {
      ps->ev_r_ssl.fd = back;
      ps->ev_r_ssl.events = 129;
      break;
    }
    break;
  }
  ps->ev_r_ssl.data = (void *)ps;
  ps->ev_w_ssl.data = (void *)ps;
  ps->ev_r_clear.data = (void *)ps;
  ps->ev_w_clear.data = (void *)ps;
  ps->ev_w_connect.data = (void *)ps;
  ps->ev_r_handshake.data = (void *)ps;
  ps->ev_w_handshake.data = (void *)ps;
  SSL_set_ex_data(ssl___0, 0, (void *)((char *)ps));
  ev_io_start(loop___0, & ps->ev_r_clear);
  start_connect(ps);
  return;
}
}
static void handle_connections(void) 
{ 
  cpu_set_t cpus ;
  size_t __cpu ;
  int res ;
  int tmp ;
  ev_timer timer_ppid_check ;
  int tmp___0 ;

  {
  while (1) {
    if (! CONFIG->QUIET) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"{core} Process %d online\n",
              child_num);
    }
    if (CONFIG->SYSLOG) {
      syslog(6, "{core} Process %d online\n", child_num);
    }
    break;
  }
  create_workers = 0;
  while (1) {
    __builtin_memset((void *)(& cpus), '\000', (int )sizeof(cpu_set_t ));
    break;
  }
  __cpu = (size_t )child_num;
  if (__cpu / 8UL < sizeof(cpu_set_t )) {
    cpus.__bits[__cpu / (8UL * sizeof(__cpu_mask ))] |= 1UL << __cpu % (8UL * sizeof(__cpu_mask ));
  }
  tmp = sched_setaffinity(0, sizeof(cpus), (cpu_set_t const   *)(& cpus));
  res = tmp;
  if (! res) {
    while (1) {
      if (! CONFIG->QUIET) {
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"{core} Successfully attached to CPU #%d\n",
                child_num);
      }
      if (CONFIG->SYSLOG) {
        syslog(6, "{core} Successfully attached to CPU #%d\n", child_num);
      }
      break;
    }
  } else {
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"{core-warning} Unable to attach to CPU #%d; do you have that many cores?\n",
              child_num);
      if (CONFIG->SYSLOG) {
        syslog(3, "{core-warning} Unable to attach to CPU #%d; do you have that many cores?\n",
               child_num);
      }
      break;
    }
  }
  loop = ev_default_loop(0U);
  while (1) {
    while (1) {
      tmp___0 = 0;
      ((ev_watcher *)((void *)(& timer_ppid_check)))->pending = tmp___0;
      ((ev_watcher *)((void *)(& timer_ppid_check)))->active = tmp___0;
      ((ev_watcher *)((void *)(& timer_ppid_check)))->priority = 0;
      timer_ppid_check.cb = & check_ppid;
      memmove((void *)(& ((ev_watcher *)(& timer_ppid_check))->cb), (void const   *)(& timer_ppid_check.cb),
              sizeof(timer_ppid_check.cb));
      break;
    }
    while (1) {
      ((ev_watcher_time *)(& timer_ppid_check))->at = 1.0;
      timer_ppid_check.repeat = 1.0;
      break;
    }
    break;
  }
  ev_timer_start(loop, & timer_ppid_check);
  while (1) {
    while (1) {
      ((ev_watcher *)((void *)(& listener)))->pending = 0;
      ((ev_watcher *)((void *)(& listener)))->active = ((ev_watcher *)((void *)(& listener)))->pending;
      ((ev_watcher *)((void *)(& listener)))->priority = 0;
      if ((unsigned int )CONFIG->PMODE == 1U) {
        listener.cb = & handle_clear_accept;
      } else {
        listener.cb = & handle_accept;
      }
      memmove((void *)(& ((ev_watcher *)(& listener))->cb), (void const   *)(& listener.cb),
              sizeof(listener.cb));
      break;
    }
    while (1) {
      listener.fd = listener_socket;
      listener.events = 129;
      break;
    }
    break;
  }
  listener.data = (void *)default_ctx;
  ev_io_start(loop, & listener);
  ev_loop(loop, 0);
  while (1) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"{core} Child %d exiting.\n",
            child_num);
    if (CONFIG->SYSLOG) {
      syslog(3, "{core} Child %d exiting.\n", child_num);
    }
    break;
  }
  exit(1);
}
}
void change_root(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  tmp = chroot((char const   *)CONFIG->CHROOT);
  if (tmp == -1) {
    fail("chroot");
  }
  tmp___0 = chdir("/");
  if (tmp___0) {
    fail("chdir");
  }
  return;
}
}
void drop_privileges(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  tmp = setgid(CONFIG->GID);
  if (tmp) {
    fail("setgid failed");
  }
  tmp___0 = setuid(CONFIG->UID);
  if (tmp___0) {
    fail("setuid failed");
  }
  return;
}
}
void init_globals(void) 
{ 
  struct addrinfo hints ;
  int gai_err ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  shcupd_peer_opt *spo ;
  struct addrinfo **pai ;
  int gai_err___0 ;
  char *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  void *tmp___6 ;

  {
  memset((void *)(& hints), 0, sizeof(hints));
  hints.ai_family = 0;
  hints.ai_socktype = 1;
  hints.ai_flags = 0;
  tmp = getaddrinfo((char const   * __restrict  )CONFIG->BACK_IP, (char const   * __restrict  )CONFIG->BACK_PORT,
                    (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& backaddr));
  gai_err = tmp;
  if (gai_err != 0) {
    while (1) {
      tmp___0 = gai_strerror(gai_err);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"{getaddrinfo}: [%s]",
              tmp___0);
      if (CONFIG->SYSLOG) {
        tmp___1 = gai_strerror(gai_err);
        syslog(3, "{getaddrinfo}: [%s]", tmp___1);
      }
      break;
    }
    exit(1);
  }
  if (CONFIG->SHARED_CACHE) {
    spo = CONFIG->SHCUPD_PEERS;
    pai = shcupd_peers;
    while (spo->ip) {
      memset((void *)(& hints), 0, sizeof(hints));
      hints.ai_family = 0;
      hints.ai_socktype = 2;
      hints.ai_flags = 0;
      if (spo->port) {
        tmp___2 = spo->port;
      } else {
        tmp___2 = CONFIG->SHCUPD_PORT;
      }
      tmp___3 = getaddrinfo((char const   * __restrict  )spo->ip, (char const   * __restrict  )tmp___2,
                            (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )pai);
      gai_err___0 = tmp___3;
      if (gai_err___0 != 0) {
        while (1) {
          tmp___4 = gai_strerror(gai_err___0);
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"{getaddrinfo}: [%s]",
                  tmp___4);
          if (CONFIG->SYSLOG) {
            tmp___5 = gai_strerror(gai_err___0);
            syslog(3, "{getaddrinfo}: [%s]", tmp___5);
          }
          break;
        }
        exit(1);
      }
      spo ++;
      pai ++;
    }
  }
  tmp___6 = calloc((size_t )CONFIG->NCORES, sizeof(pid_t ));
  child_pids = (pid_t *)tmp___6;
  if ((unsigned long )child_pids == (unsigned long )((void *)0)) {
    fail("calloc");
  }
  if (CONFIG->SYSLOG) {
    openlog("stud", 11, CONFIG->SYSLOG_FACILITY);
  }
  return;
}
}
void start_children(int start_index , int count ) 
{ 
  int pid ;
  __pid_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
  if (! create_workers) {
    return;
  }
  child_num = start_index;
  while (child_num < start_index + count) {
    tmp = fork();
    pid = tmp;
    if (pid == -1) {
      while (1) {
        tmp___0 = __errno_location();
        tmp___1 = strerror(*tmp___0);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"{core} fork() failed: %s; Goodbye cruel world!\n",
                tmp___1);
        if (CONFIG->SYSLOG) {
          tmp___2 = __errno_location();
          tmp___3 = strerror(*tmp___2);
          syslog(3, "{core} fork() failed: %s; Goodbye cruel world!\n", tmp___3);
        }
        break;
      }
      exit(1);
    } else
    if (pid == 0) {
      handle_connections();
      exit(0);
    } else {
      *(child_pids + child_num) = pid;
    }
    child_num ++;
  }
  return;
}
}
void replace_child_with_pid(pid_t pid ) 
{ 
  int i ;

  {
  i = 0;
  while ((long )i < CONFIG->NCORES) {
    if (*(child_pids + i) == pid) {
      start_children(i, 1);
      return;
    }
    i ++;
  }
  while (1) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Cannot find index for child pid %d",
            pid);
    if (CONFIG->SYSLOG) {
      syslog(3, "Cannot find index for child pid %d", pid);
    }
    break;
  }
  return;
}
}
static void do_wait(int signo  __attribute__((__unused__)) ) 
{ 
  int status ;
  int pid ;
  __pid_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  tmp = wait(& status);
  pid = tmp;
  if (pid == -1) {
    tmp___1 = __errno_location();
    if (*tmp___1 == 10) {
      while (1) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"{core} All children have exited! Restarting...\n");
        if (CONFIG->SYSLOG) {
          syslog(3, "{core} All children have exited! Restarting...\n");
        }
        break;
      }
      start_children(0, (int )CONFIG->NCORES);
    } else {
      tmp___0 = __errno_location();
      if (*tmp___0 == 4) {
        while (1) {
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"{core} Interrupted wait\n");
          if (CONFIG->SYSLOG) {
            syslog(3, "{core} Interrupted wait\n");
          }
          break;
        }
      } else {
        fail("wait");
      }
    }
  } else
  if ((status & 127) == 0) {
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"{core} Child %d exited with status %d. Replacing...\n",
              pid, (status & 65280) >> 8);
      if (CONFIG->SYSLOG) {
        syslog(3, "{core} Child %d exited with status %d. Replacing...\n", pid, (status & 65280) >> 8);
      }
      break;
    }
    replace_child_with_pid(pid);
  } else
  if ((int )((signed char )((status & 127) + 1)) >> 1 > 0) {
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"{core} Child %d was terminated by signal %d. Replacing...\n",
              pid, status & 127);
      if (CONFIG->SYSLOG) {
        syslog(3, "{core} Child %d was terminated by signal %d. Replacing...\n", pid,
               status & 127);
      }
      break;
    }
    replace_child_with_pid(pid);
  }
  return;
}
}
static void sigh_terminate(int signo  __attribute__((__unused__)) ) 
{ 
  int i ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  __pid_t tmp___4 ;

  {
  create_workers = 0;
  tmp___4 = getpid();
  if (tmp___4 == master_pid) {
    while (1) {
      if (! CONFIG->QUIET) {
        fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"{core} Received signal %d, shutting down.\n",
                signo);
      }
      if (CONFIG->SYSLOG) {
        syslog(6, "{core} Received signal %d, shutting down.\n", signo);
      }
      break;
    }
    i = 0;
    while ((long )i < CONFIG->NCORES) {
      if (*(child_pids + i) > 1) {
        tmp___3 = kill(*(child_pids + i), 15);
        if (tmp___3 != 0) {
          while (1) {
            tmp = __errno_location();
            tmp___0 = strerror(*tmp);
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"{core} Unable to send SIGTERM to worker pid %d: %s\n",
                    *(child_pids + i), tmp___0);
            if (CONFIG->SYSLOG) {
              tmp___1 = __errno_location();
              tmp___2 = strerror(*tmp___1);
              syslog(3, "{core} Unable to send SIGTERM to worker pid %d: %s\n", *(child_pids + i),
                     tmp___2);
            }
            break;
          }
        }
      }
      i ++;
    }
  }
  exit(0);
}
}
void init_signals(void) 
{ 
  struct sigaction act ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
  sigemptyset(& act.sa_mask);
  act.sa_flags = 0;
  act.__sigaction_handler.sa_handler = (void (*)(int  ))1;
  tmp = sigaction(13, (struct sigaction  const  * __restrict  )(& act), (struct sigaction * __restrict  )((void *)0));
  if (tmp < 0) {
    fail("sigaction - sigpipe");
  }
  act.sa_flags = 1;
  act.__sigaction_handler.sa_handler = & do_wait;
  tmp___0 = sigaction(17, (struct sigaction  const  * __restrict  )(& act), (struct sigaction * __restrict  )((void *)0));
  if (tmp___0 < 0) {
    fail("sigaction - sigchld");
  }
  act.sa_flags = 0;
  act.__sigaction_handler.sa_handler = & sigh_terminate;
  tmp___5 = sigaction(2, (struct sigaction  const  * __restrict  )(& act), (struct sigaction * __restrict  )((void *)0));
  if (tmp___5 < 0) {
    while (1) {
      tmp___1 = __errno_location();
      tmp___2 = strerror(*tmp___1);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unable to register SIGINT signal handler: %s\n",
              tmp___2);
      if (CONFIG->SYSLOG) {
        tmp___3 = __errno_location();
        tmp___4 = strerror(*tmp___3);
        syslog(3, "Unable to register SIGINT signal handler: %s\n", tmp___4);
      }
      break;
    }
    exit(1);
  }
  tmp___10 = sigaction(15, (struct sigaction  const  * __restrict  )(& act), (struct sigaction * __restrict  )((void *)0));
  if (tmp___10 < 0) {
    while (1) {
      tmp___6 = __errno_location();
      tmp___7 = strerror(*tmp___6);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unable to register SIGTERM signal handler: %s\n",
              tmp___7);
      if (CONFIG->SYSLOG) {
        tmp___8 = __errno_location();
        tmp___9 = strerror(*tmp___8);
        syslog(3, "Unable to register SIGTERM signal handler: %s\n", tmp___9);
      }
      break;
    }
    exit(1);
  }
  return;
}
}
void daemonize(void) 
{ 
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  pid_t pid ;
  __pid_t tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  pid_t s ;
  __pid_t tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  int *tmp___24 ;
  char *tmp___25 ;
  __pid_t tmp___26 ;
  __pid_t tmp___27 ;

  {
  tmp___3 = chdir("/");
  if (tmp___3 != 0) {
    while (1) {
      tmp = __errno_location();
      tmp___0 = strerror(*tmp);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unable change directory to /: %s\n",
              tmp___0);
      if (CONFIG->SYSLOG) {
        tmp___1 = __errno_location();
        tmp___2 = strerror(*tmp___1);
        syslog(3, "Unable change directory to /: %s\n", tmp___2);
      }
      break;
    }
    exit(1);
  }
  tmp___4 = fork();
  pid = tmp___4;
  if (pid < 0) {
    while (1) {
      tmp___5 = __errno_location();
      tmp___6 = strerror(*tmp___5);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unable to daemonize: fork failed: %s\n",
              tmp___6);
      if (CONFIG->SYSLOG) {
        tmp___7 = __errno_location();
        tmp___8 = strerror(*tmp___7);
        syslog(3, "Unable to daemonize: fork failed: %s\n", tmp___8);
      }
      break;
    }
    exit(1);
  }
  if (pid != 0) {
    printf((char const   * __restrict  )"{core} Daemonized as pid %d.\n", pid);
    exit(0);
  }
  fclose(stdin);
  fclose(stdout);
  fclose(stderr);
  stdin = fopen((char const   * __restrict  )"/dev/null", (char const   * __restrict  )"r");
  if ((unsigned long )stdin == (unsigned long )((void *)0)) {
    while (1) {
      tmp___9 = __errno_location();
      tmp___10 = strerror(*tmp___9);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unable to reopen stdin to %s: %s\n",
              "/dev/null", tmp___10);
      if (CONFIG->SYSLOG) {
        tmp___11 = __errno_location();
        tmp___12 = strerror(*tmp___11);
        syslog(3, "Unable to reopen stdin to %s: %s\n", "/dev/null", tmp___12);
      }
      break;
    }
    exit(1);
  }
  stdout = fopen((char const   * __restrict  )"/dev/null", (char const   * __restrict  )"w");
  if ((unsigned long )stdout == (unsigned long )((void *)0)) {
    while (1) {
      tmp___13 = __errno_location();
      tmp___14 = strerror(*tmp___13);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unable to reopen stdout to %s: %s\n",
              "/dev/null", tmp___14);
      if (CONFIG->SYSLOG) {
        tmp___15 = __errno_location();
        tmp___16 = strerror(*tmp___15);
        syslog(3, "Unable to reopen stdout to %s: %s\n", "/dev/null", tmp___16);
      }
      break;
    }
    exit(1);
  }
  stderr = fopen((char const   * __restrict  )"/dev/null", (char const   * __restrict  )"w");
  if ((unsigned long )stderr == (unsigned long )((void *)0)) {
    while (1) {
      tmp___17 = __errno_location();
      tmp___18 = strerror(*tmp___17);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unable to reopen stderr to %s: %s\n",
              "/dev/null", tmp___18);
      if (CONFIG->SYSLOG) {
        tmp___19 = __errno_location();
        tmp___20 = strerror(*tmp___19);
        syslog(3, "Unable to reopen stderr to %s: %s\n", "/dev/null", tmp___20);
      }
      break;
    }
    exit(1);
  }
  tmp___21 = setsid();
  s = tmp___21;
  if (s < 0) {
    while (1) {
      tmp___22 = __errno_location();
      tmp___23 = strerror(*tmp___22);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unable to create new session, setsid(2) failed: %s :: %d\n",
              tmp___23, s);
      if (CONFIG->SYSLOG) {
        tmp___24 = __errno_location();
        tmp___25 = strerror(*tmp___24);
        syslog(3, "Unable to create new session, setsid(2) failed: %s :: %d\n", tmp___25,
               s);
      }
      break;
    }
    exit(1);
  }
  while (1) {
    if (! CONFIG->QUIET) {
      tmp___26 = getpid();
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"Successfully daemonized as pid %d.\n",
              tmp___26);
    }
    if (CONFIG->SYSLOG) {
      tmp___27 = getpid();
      syslog(6, "Successfully daemonized as pid %d.\n", tmp___27);
    }
    break;
  }
  return;
}
}
void openssl_check_version(void) 
{ 
  unsigned long tmp ;

  {
  tmp = SSLeay();
  openssl_version = (long )tmp;
  if ((openssl_version ^ 268439903L) & -4081L) {
    while (1) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"WARNING: {core} OpenSSL version mismatch; stud was compiled with %lx, now using %lx.\n",
              268439903UL, (unsigned long )openssl_version);
      if (CONFIG->SYSLOG) {
        syslog(3, "WARNING: {core} OpenSSL version mismatch; stud was compiled with %lx, now using %lx.\n",
               268439903UL, (unsigned long )openssl_version);
      }
      break;
    }
  }
  while (1) {
    if (! CONFIG->QUIET) {
      fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"{core} Using OpenSSL version %lx.\n",
              (unsigned long )openssl_version);
    }
    if (CONFIG->SYSLOG) {
      syslog(6, "{core} Using OpenSSL version %lx.\n", (unsigned long )openssl_version);
    }
    break;
  }
  return;
}
}
int main(int argc , char **argv ) 
{ 


  {
  CONFIG = config_new();
  config_parse_cli(argc, argv, CONFIG);
  create_workers = 1;
  openssl_check_version();
  init_signals();
  init_globals();
  listener_socket = create_main_socket();
  if (CONFIG->SHCUPD_PORT) {
    shcupd_socket = create_shcupd_socket();
  }
  init_openssl();
  if (CONFIG->CHROOT) {
    if (*(CONFIG->CHROOT + 0)) {
      change_root();
    }
  }
  if (CONFIG->UID) {
    drop_privileges();
  } else
  if (CONFIG->GID) {
    drop_privileges();
  }
  if (CONFIG->DAEMONIZE) {
    CONFIG->QUIET = 1;
    CONFIG->SYSLOG = 1;
    daemonize();
  }
  master_pid = getpid();
  start_children(0, (int )CONFIG->NCORES);
  if (CONFIG->SHCUPD_PORT) {
    loop = ev_default_loop(0U);
    while (1) {
      while (1) {
        ((ev_watcher *)((void *)(& shcupd_listener)))->pending = 0;
        ((ev_watcher *)((void *)(& shcupd_listener)))->active = ((ev_watcher *)((void *)(& shcupd_listener)))->pending;
        ((ev_watcher *)((void *)(& shcupd_listener)))->priority = 0;
        shcupd_listener.cb = & handle_shcupd;
        memmove((void *)(& ((ev_watcher *)(& shcupd_listener))->cb), (void const   *)(& shcupd_listener.cb),
                sizeof(shcupd_listener.cb));
        break;
      }
      while (1) {
        shcupd_listener.fd = shcupd_socket;
        shcupd_listener.events = 129;
        break;
      }
      break;
    }
    ev_io_start(loop, & shcupd_listener);
    ev_loop(loop, 0);
  }
  while (1) {
    pause();
  }
  exit(0);
}
}
#pragma merger("0","/tmp/cil-YYEpa4WL.i","-O2,-g,-std=c99,-fno-strict-aliasing,-Wall,-W")
int ringbuffer_size(ringbuffer *rb ) ;
int ringbuffer_capacity(ringbuffer *rb ) ;
void ringbuffer_init(ringbuffer *rb ) 
{ 
  int x ;

  {
  rb->head = & rb->slots[0];
  rb->tail = & rb->slots[0];
  rb->used = (size_t )0;
  x = 0;
  while (x < 3) {
    rb->slots[x].next = & rb->slots[(x + 1) % 3];
    x ++;
  }
  return;
}
}
char *ringbuffer_read_next(ringbuffer *rb , int *length ) 
{ 


  {
  if (! rb->used) {
    __assert_fail("rb->used", "ringbuffer.c", 48U, "ringbuffer_read_next");
  }
  *length = (int )(rb->head)->left;
  return ((rb->head)->ptr);
}
}
void ringbuffer_read_skip(ringbuffer *rb , int length ) 
{ 


  {
  if (! rb->used) {
    __assert_fail("rb->used", "ringbuffer.c", 55U, "ringbuffer_read_skip");
  }
  (rb->head)->ptr += length;
  (rb->head)->left -= (size_t )length;
  return;
}
}
void ringbuffer_read_pop(ringbuffer *rb ) 
{ 


  {
  if (! rb->used) {
    __assert_fail("rb->used", "ringbuffer.c", 62U, "ringbuffer_read_pop");
  }
  rb->head = (rb->head)->next;
  (rb->used) --;
  return;
}
}
char *ringbuffer_write_ptr(ringbuffer *rb ) 
{ 


  {
  if (! (rb->used < 3UL)) {
    __assert_fail("rb->used < RING_SLOTS", "ringbuffer.c", 72U, "ringbuffer_write_ptr");
  }
  return ((rb->tail)->data);
}
}
void ringbuffer_write_append(ringbuffer *rb , int length ) 
{ 


  {
  if (! (rb->used < 3UL)) {
    __assert_fail("rb->used < RING_SLOTS", "ringbuffer.c", 79U, "ringbuffer_write_append");
  }
  (rb->used) ++;
  (rb->tail)->ptr = (rb->tail)->data;
  (rb->tail)->left = (size_t )length;
  rb->tail = (rb->tail)->next;
  return;
}
}
int ringbuffer_size(ringbuffer *rb ) 
{ 


  {
  return ((int )rb->used);
}
}
int ringbuffer_capacity(ringbuffer *rb ) 
{ 


  {
  return (3);
}
}
int ringbuffer_is_empty(ringbuffer *rb ) 
{ 


  {
  return (rb->used == 0UL);
}
}
int ringbuffer_is_full(ringbuffer *rb ) 
{ 


  {
  return (rb->used == 3UL);
}
}
#pragma merger("0","/tmp/cil-KSY3OnFI.i","-O2,-g,-std=c99,-fno-strict-aliasing,-Wall,-W")
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncat)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
extern char *optarg ;
extern int optind ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) getopt_long)(int ___argc ,
                                                                                          char * const  *___argv ,
                                                                                          char const   *__shortopts ,
                                                                                          struct option  const  *__longopts ,
                                                                                          int *__longind ) ;
extern  __attribute__((__nothrow__)) char *__xpg_basename(char *__path ) ;
extern struct passwd *getpwuid(__uid_t __uid ) ;
extern struct passwd *( __attribute__((__nonnull__(1))) getpwnam)(char const   *__name ) ;
extern struct group *getgrgid(__gid_t __gid ) ;
extern struct group *getgrnam(char const   *__name ) ;
char *config_error_get(void) ;
void config_destroy(stud_config *cfg ) ;
int config_file_parse(char *file , stud_config *cfg ) ;
static char var_buf[1024]  ;
static char val_buf[1024]  ;
static char error_buf[1024]  ;
static char tmp_buf[150]  ;
static void config_error_set(char *fmt  , ...) 
{ 
  va_list___0 args ;

  {
  memset((void *)(error_buf), '\000', sizeof(error_buf));
  __builtin_va_start(args, fmt);
  vsnprintf((char * __restrict  )(error_buf), sizeof(error_buf) - 1UL, (char const   * __restrict  )fmt,
            args);
  __builtin_va_end(args);
  return;
}
}
char *config_error_get(void) 
{ 


  {
  return (error_buf);
}
}
void config_die(char *fmt  , ...) 
{ 
  va_list___0 args ;

  {
  __builtin_va_start(args, fmt);
  vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )fmt, args);
  __builtin_va_end(args);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  exit(1);
}
}
stud_config *config_new(void) 
{ 
  stud_config *r ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int i ;

  {
  r = (stud_config *)((void *)0);
  tmp = malloc(sizeof(stud_config ));
  r = (stud_config *)tmp;
  if ((unsigned long )r == (unsigned long )((void *)0)) {
    tmp___0 = __errno_location();
    tmp___1 = strerror(*tmp___0);
    config_error_set((char *)"Unable to allocate memory for configuration structure: %s",
                     tmp___1);
    return ((stud_config *)((void *)0));
  }
  r->ETYPE = (ENC_TYPE )0;
  r->PMODE = (PROXY_MODE )0;
  r->WRITE_IP_OCTET = 0;
  r->WRITE_PROXY_LINE = 0;
  r->PROXY_PROXY_LINE = 0;
  r->CHROOT = (char *)((void *)0);
  r->UID = (uid_t )0;
  r->GID = (gid_t )0;
  r->FRONT_IP = (char *)((void *)0);
  r->FRONT_PORT = strdup("8443");
  r->BACK_IP = strdup("127.0.0.1");
  r->BACK_PORT = strdup("8000");
  r->NCORES = 1L;
  r->CERT_FILES = (struct cert_files *)((void *)0);
  r->CIPHER_SUITE = (char *)((void *)0);
  r->ENGINE = (char *)((void *)0);
  r->BACKLOG = 100;
  r->SHARED_CACHE = 0;
  r->SHCUPD_IP = (char *)((void *)0);
  r->SHCUPD_PORT = (char *)((void *)0);
  i = 0;
  while (i < 15) {
    memset((void *)(& r->SHCUPD_PEERS[i]), 0, sizeof(shcupd_peer_opt ));
    i ++;
  }
  r->SHCUPD_MCASTIF = (char *)((void *)0);
  r->SHCUPD_MCASTTTL = (char *)((void *)0);
  r->QUIET = 0;
  r->SYSLOG = 0;
  r->SYSLOG_FACILITY = 3 << 3;
  r->TCP_KEEPALIVE_TIME = 3600;
  r->DAEMONIZE = 0;
  r->PREFER_SERVER_CIPHERS = 0;
  return (r);
}
}
void config_destroy(stud_config *cfg ) 
{ 
  struct cert_files *curr ;
  struct cert_files *next ;
  int i ;

  {
  if ((unsigned long )cfg == (unsigned long )((void *)0)) {
    return;
  }
  if ((unsigned long )cfg->CHROOT != (unsigned long )((void *)0)) {
    free((void *)cfg->CHROOT);
  }
  if ((unsigned long )cfg->FRONT_IP != (unsigned long )((void *)0)) {
    free((void *)cfg->FRONT_IP);
  }
  if ((unsigned long )cfg->FRONT_PORT != (unsigned long )((void *)0)) {
    free((void *)cfg->FRONT_PORT);
  }
  if ((unsigned long )cfg->BACK_IP != (unsigned long )((void *)0)) {
    free((void *)cfg->BACK_IP);
  }
  if ((unsigned long )cfg->BACK_PORT != (unsigned long )((void *)0)) {
    free((void *)cfg->BACK_PORT);
  }
  if ((unsigned long )cfg->CERT_FILES != (unsigned long )((void *)0)) {
    curr = cfg->CERT_FILES;
    while ((unsigned long )cfg->CERT_FILES != (unsigned long )((void *)0)) {
      next = curr->NEXT;
      free((void *)curr);
      curr = next;
    }
  }
  if ((unsigned long )cfg->CIPHER_SUITE != (unsigned long )((void *)0)) {
    free((void *)cfg->CIPHER_SUITE);
  }
  if ((unsigned long )cfg->ENGINE != (unsigned long )((void *)0)) {
    free((void *)cfg->ENGINE);
  }
  if ((unsigned long )cfg->SHCUPD_IP != (unsigned long )((void *)0)) {
    free((void *)cfg->SHCUPD_IP);
  }
  if ((unsigned long )cfg->SHCUPD_PORT != (unsigned long )((void *)0)) {
    free((void *)cfg->SHCUPD_PORT);
  }
  i = 0;
  while (i < 15) {
    if ((unsigned long )cfg->SHCUPD_PEERS[i].ip != (unsigned long )((void *)0)) {
      free((void *)cfg->SHCUPD_PEERS[i].ip);
    }
    if ((unsigned long )cfg->SHCUPD_PEERS[i].port != (unsigned long )((void *)0)) {
      free((void *)cfg->SHCUPD_PEERS[i].port);
    }
    i ++;
  }
  if ((unsigned long )cfg->SHCUPD_MCASTIF != (unsigned long )((void *)0)) {
    free((void *)cfg->SHCUPD_MCASTIF);
  }
  if ((unsigned long )cfg->SHCUPD_MCASTTTL != (unsigned long )((void *)0)) {
    free((void *)cfg->SHCUPD_MCASTTTL);
  }
  free((void *)cfg);
  return;
}
}
char *config_get_param(char *str ) 
{ 
  char *ptr ;
  int i ;
  size_t tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  size_t tmp___3 ;

  {
  if ((unsigned long )str == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  tmp = strlen((char const   *)str);
  if (tmp < 1UL) {
    return ((char *)((void *)0));
  } else
  if ((int )*(str + 0) == 10) {
    return ((char *)((void *)0));
  } else {
    tmp___0 = strcmp((char const   *)str, "\r\n");
    if (tmp___0 == 0) {
      return ((char *)((void *)0));
    }
  }
  ptr = str;
  if ((int )*(str + 0) == 35) {
    return ((char *)((void *)0));
  }
  while (1) {
    if ((unsigned long )ptr != (unsigned long )((void *)0)) {
      tmp___1 = __ctype_b_loc();
      if ((int const   )*(*tmp___1 + (int )*ptr) & 1024) {
        break;
      }
    } else {
      break;
    }
    ptr ++;
  }
  memset((void *)(var_buf), '\000', sizeof(var_buf));
  i = 0;
  while (1) {
    if ((unsigned long )ptr != (unsigned long )((void *)0)) {
      tmp___2 = __ctype_b_loc();
      if (! ((int const   )*(*tmp___2 + (int )*ptr) & 8)) {
        if (! ((int )*ptr == 45)) {
          break;
        }
      }
    } else {
      break;
    }
    var_buf[i] = *ptr;
    i ++;
    ptr ++;
  }
  tmp___3 = strlen((char const   *)(var_buf));
  if (tmp___3 < 1UL) {
    return ((char *)((void *)0));
  }
  return (var_buf);
}
}
char *config_get_value(char *str ) 
{ 
  char *ptr ;
  int i ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  size_t tmp___3 ;

  {
  i = 0;
  if ((unsigned long )str == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  tmp = strlen((char const   *)str);
  if (tmp < 1UL) {
    return ((char *)((void *)0));
  }
  ptr = str;
  while (1) {
    if ((unsigned long )ptr != (unsigned long )((void *)0)) {
      if (! ((int )*ptr != 61)) {
        break;
      }
    } else {
      break;
    }
    ptr ++;
  }
  ptr ++;
  while (1) {
    if ((unsigned long )ptr != (unsigned long )((void *)0)) {
      tmp___0 = __ctype_b_loc();
      if ((int const   )*(*tmp___0 + (int )*ptr) & 32768) {
        break;
      }
    } else {
      break;
    }
    ptr ++;
  }
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  memset((void *)(val_buf), '\000', sizeof(val_buf));
  while (1) {
    if ((unsigned long )ptr != (unsigned long )((void *)0)) {
      tmp___2 = __ctype_b_loc();
      if (! ((int const   )*(*tmp___2 + (int )*ptr) & 32768)) {
        break;
      }
    } else {
      break;
    }
    tmp___1 = i;
    i ++;
    val_buf[tmp___1] = *ptr;
    ptr ++;
  }
  tmp___3 = strlen((char const   *)(val_buf));
  if (tmp___3 < 1UL) {
    return ((char *)((void *)0));
  }
  return (val_buf);
}
}
char *str_rtrim(char *str ) 
{ 
  char *ptr ;
  int len ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;

  {
  tmp = strlen((char const   *)str);
  len = (int )tmp;
  ptr = (str + len) - 1;
  while (1) {
    if ((unsigned long )ptr >= (unsigned long )str) {
      tmp___0 = __ctype_b_loc();
      if (! ((int const   )*(*tmp___0 + (int )*ptr) & 8192)) {
        if (! ((int )*ptr == 34)) {
          if (! ((int )*ptr == 39)) {
            break;
          }
        }
      }
    } else {
      break;
    }
    ptr --;
  }
  *(ptr + 1) = (char )'\000';
  return (str);
}
}
char *str_ltrim(char *str ) 
{ 
  char *ptr ;
  int len ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;

  {
  ptr = str;
  while (1) {
    if (*ptr) {
      tmp = __ctype_b_loc();
      if (! ((int const   )*(*tmp + (int )*ptr) & 8192)) {
        if (! ((int )*ptr == 34)) {
          if (! ((int )*ptr == 39)) {
            break;
          }
        }
      }
    } else {
      break;
    }
    ptr ++;
  }
  tmp___0 = strlen((char const   *)ptr);
  len = (int )tmp___0;
  memmove((void *)str, (void const   *)ptr, (size_t )(len + 1));
  return (str);
}
}
char *str_trim(char *str ) 
{ 
  char *ptr ;

  {
  ptr = str_rtrim(str);
  str = str_ltrim(ptr);
  return (str);
}
}
char *config_assign_str(char **dst , char *v ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
  if ((unsigned long )*dst == (unsigned long )((void *)0)) {
    if ((unsigned long )v != (unsigned long )((void *)0)) {
      tmp = strlen((char const   *)v);
      if (tmp > 0UL) {
        *dst = strdup((char const   *)v);
      }
    }
  } else
  if ((unsigned long )v != (unsigned long )((void *)0)) {
    tmp___2 = strlen((char const   *)v);
    if (tmp___2 > 0UL) {
      tmp___0 = strlen((char const   *)v);
      memset((void *)*dst, '\000', tmp___0 + 1UL);
      tmp___1 = strlen((char const   *)v);
      memcpy((void * __restrict  )*dst, (void const   * __restrict  )v, tmp___1);
    } else {
      free((void *)*dst);
    }
  } else {
    free((void *)*dst);
  }
  return (*dst);
}
}
int config_param_val_bool(char *val , int *res ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  if ((unsigned long )val == (unsigned long )((void *)0)) {
    return (0);
  }
  tmp = strcasecmp((char const   *)val, "on");
  if (tmp == 0) {
    *res = 1;
  } else {
    tmp___0 = strcasecmp((char const   *)val, "yes");
    if (tmp___0 == 0) {
      *res = 1;
    } else {
      tmp___1 = strcasecmp((char const   *)val, "y");
      if (tmp___1 == 0) {
        *res = 1;
      } else {
        tmp___2 = strcasecmp((char const   *)val, "true");
        if (tmp___2 == 0) {
          *res = 1;
        } else {
          tmp___3 = strcasecmp((char const   *)val, "t");
          if (tmp___3 == 0) {
            *res = 1;
          } else {
            tmp___4 = strcasecmp((char const   *)val, "1");
            if (tmp___4 == 0) {
              *res = 1;
            }
          }
        }
      }
    }
  }
  return (1);
}
}
char *config_param_val_str(char *val ) 
{ 
  char *tmp ;

  {
  tmp = strdup((char const   *)val);
  return (tmp);
}
}
int config_param_host_port_wildcard(char *str , char **addr , char **port , int wildcard_okay ) 
{ 
  int len ;
  size_t tmp ;
  size_t tmp___0 ;
  char port_buf[6] ;
  char addr_buf[150] ;
  char *ptr ;
  char *x ;
  char *tmp___1 ;
  char *x___0 ;
  char *tmp___2 ;
  int addr_len ;
  int p ;
  int tmp___3 ;
  int tmp___4 ;

  {
  if ((unsigned long )str != (unsigned long )((void *)0)) {
    tmp = strlen((char const   *)str);
    tmp___0 = tmp;
  } else {
    tmp___0 = (size_t )0;
  }
  len = (int )tmp___0;
  if ((unsigned long )str == (unsigned long )((void *)0)) {
    config_error_set((char *)"Invalid/unset host/port string.");
    return (0);
  } else
  if (! len) {
    config_error_set((char *)"Invalid/unset host/port string.");
    return (0);
  }
  memset((void *)(port_buf), '\000', sizeof(port_buf));
  memset((void *)(addr_buf), '\000', sizeof(addr_buf));
  if ((int )*str == 91) {
    ptr = str + 1;
    tmp___1 = strrchr((char const   *)ptr, ']');
    x = tmp___1;
    if ((unsigned long )x == (unsigned long )((void *)0)) {
      config_error_set((char *)"Invalid address \'%s\'.", str);
      return (0);
    }
    memcpy((void * __restrict  )(addr_buf), (void const   * __restrict  )ptr, (size_t )(x - ptr));
    x += 2;
    memcpy((void * __restrict  )(port_buf), (void const   * __restrict  )x, sizeof(port_buf) - 1UL);
  } else {
    tmp___2 = strrchr((char const   *)str, ',');
    x___0 = tmp___2;
    if ((unsigned long )x___0 == (unsigned long )((void *)0)) {
      config_error_set((char *)"Invalid address string \'%s\'", str);
      return (0);
    }
    addr_len = (int )(x___0 - str);
    memcpy((void * __restrict  )(addr_buf), (void const   * __restrict  )str, (size_t )addr_len);
    x___0 ++;
    memcpy((void * __restrict  )(port_buf), (void const   * __restrict  )x___0, sizeof(port_buf));
  }
  tmp___3 = atoi((char const   *)(port_buf));
  p = tmp___3;
  if (p < 1) {
    config_error_set((char *)"Invalid port number \'%s\'", port_buf);
    return (0);
  } else
  if (p > 65536) {
    config_error_set((char *)"Invalid port number \'%s\'", port_buf);
    return (0);
  }
  tmp___4 = strcmp((char const   *)(addr_buf), "*");
  if (tmp___4 == 0) {
    if (wildcard_okay) {
      free((void *)*addr);
    } else {
      config_error_set((char *)"Invalid address: wildcards are not allowed.");
      return (0);
    }
  } else {
    *addr = strdup((char const   *)(addr_buf));
  }
  *port = strdup((char const   *)(port_buf));
  return (1);
}
}
int config_param_host_port(char *str , char **addr , char **port ) 
{ 
  int tmp ;

  {
  tmp = config_param_host_port_wildcard(str, addr, port, 0);
  return (tmp);
}
}
int config_param_val_int(char *str , int *dst ) 
{ 
  int tmp ;

  {
  if ((unsigned long )str != (unsigned long )((void *)0)) {
    tmp = atoi((char const   *)str);
    *dst = tmp;
  } else {
    *dst = 0;
  }
  return (1);
}
}
int config_param_val_int_pos(char *str , int *dst ) 
{ 
  int num ;

  {
  num = 0;
  if ((unsigned long )str != (unsigned long )((void *)0)) {
    num = atoi((char const   *)str);
  }
  if (num < 1) {
    config_error_set((char *)"Not a positive number.");
    return (0);
  }
  *dst = num;
  return (1);
}
}
int config_param_val_intl(char *str , long *dst ) 
{ 
  long tmp ;

  {
  if ((unsigned long )str != (unsigned long )((void *)0)) {
    tmp = atol((char const   *)str);
    *dst = tmp;
  } else {
    *dst = 0L;
  }
  return (1);
}
}
int config_param_val_intl_pos(char *str , long *dst ) 
{ 
  long num ;

  {
  num = 0L;
  if ((unsigned long )str != (unsigned long )((void *)0)) {
    num = atol((char const   *)str);
  }
  if (num < 1L) {
    config_error_set((char *)"Not a positive number.");
    return (0);
  }
  *dst = num;
  return (1);
}
}
int config_param_shcupd_mcastif(char *str , char **iface , char **ttl ) 
{ 
  char buf[150] ;
  char *sp ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = strlen((char const   *)str);
  if (tmp >= sizeof(buf)) {
    config_error_set((char *)"Invalid option for IFACE[,TTL]");
    return (0);
  }
  sp = strchr((char const   *)str, ',');
  if (! sp) {
    tmp___0 = strcmp((char const   *)str, "*");
    if (tmp___0) {
      *iface = str;
    } else {
      *iface = (char *)((void *)0);
    }
    *ttl = (char *)((void *)0);
    return (1);
  } else {
    tmp___1 = strncmp((char const   *)str, "*", (size_t )(sp - str));
    if (tmp___1) {
      *sp = (char)0;
      *iface = str;
    } else {
      *iface = (char *)((void *)0);
    }
  }
  *ttl = sp + 1;
  return (1);
}
}
int config_param_shcupd_peer(char *str , stud_config *cfg ) 
{ 
  int r ;
  int offset ;
  int i ;
  char *addr ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *port ;
  void *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  if ((unsigned long )cfg == (unsigned long )((void *)0)) {
    config_error_set((char *)"Configuration pointer is NULL.");
    return (0);
  }
  r = 1;
  offset = 0;
  i = 0;
  i = 0;
  while (i < 15) {
    if ((unsigned long )cfg->SHCUPD_PEERS[i].ip == (unsigned long )((void *)0)) {
      if ((unsigned long )cfg->SHCUPD_PEERS[i].port == (unsigned long )((void *)0)) {
        offset = i;
        break;
      }
    }
    i ++;
  }
  if (i >= 15) {
    config_error_set((char *)"Reached maximum number of shared cache update peers (%d).",
                     15);
    return (0);
  }
  tmp = malloc((size_t )150);
  addr = (char *)tmp;
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
    tmp___0 = __errno_location();
    tmp___1 = strerror(*tmp___0);
    config_error_set((char *)"Unable to allocate memory for new shared cache update peer address: %s",
                     tmp___1);
    r = 0;
    goto outta_parse_peer;
  }
  memset((void *)addr, '\000', (size_t )150);
  tmp___2 = malloc((size_t )6);
  port = (char *)tmp___2;
  if ((unsigned long )port == (unsigned long )((void *)0)) {
    tmp___3 = __errno_location();
    tmp___4 = strerror(*tmp___3);
    config_error_set((char *)"Unable to allocate memory for new shared cache update peer port: %s",
                     tmp___4);
    r = 0;
    goto outta_parse_peer;
  }
  memset((void *)port, '\000', (size_t )6);
  tmp___5 = config_param_host_port(str, & addr, & port);
  if (! tmp___5) {
    r = 0;
    goto outta_parse_peer;
  }
  outta_parse_peer: 
  if (! r) {
    if ((unsigned long )addr != (unsigned long )((void *)0)) {
      free((void *)addr);
    }
    if ((unsigned long )port != (unsigned long )((void *)0)) {
      free((void *)port);
    }
  } else {
    cfg->SHCUPD_PEERS[offset].ip = addr;
    cfg->SHCUPD_PEERS[offset].port = port;
  }
  return (r);
}
}
void config_param_validate(char *k , char *v , stud_config *cfg , char *file , int line ) 
{ 
  int r ;
  struct stat st ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  struct passwd *passwd ;
  size_t tmp___8 ;
  struct group *grp ;
  size_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  struct cert_files *cert ;
  void *tmp___30 ;
  int tmp___31 ;
  size_t tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  char *tmp___58 ;
  char *tmp___59 ;

  {
  r = 1;
  tmp___57 = strcmp((char const   *)k, "tls");
  if (tmp___57 == 0) {
    cfg->ETYPE = (ENC_TYPE )0;
  } else {
    tmp___56 = strcmp((char const   *)k, "ssl");
    if (tmp___56 == 0) {
      cfg->ETYPE = (ENC_TYPE )1;
    } else {
      tmp___55 = strcmp((char const   *)k, "ciphers");
      if (tmp___55 == 0) {
        if ((unsigned long )v != (unsigned long )((void *)0)) {
          tmp = strlen((char const   *)v);
          if (tmp > 0UL) {
            config_assign_str(& cfg->CIPHER_SUITE, v);
          }
        }
      } else {
        tmp___54 = strcmp((char const   *)k, "ssl-engine");
        if (tmp___54 == 0) {
          if ((unsigned long )v != (unsigned long )((void *)0)) {
            tmp___0 = strlen((char const   *)v);
            if (tmp___0 > 0UL) {
              config_assign_str(& cfg->ENGINE, v);
            }
          }
        } else {
          tmp___53 = strcmp((char const   *)k, "prefer-server-ciphers");
          if (tmp___53 == 0) {
            r = config_param_val_bool(v, & cfg->PREFER_SERVER_CIPHERS);
          } else {
            tmp___52 = strcmp((char const   *)k, "frontend");
            if (tmp___52 == 0) {
              r = config_param_host_port_wildcard(v, & cfg->FRONT_IP, & cfg->FRONT_PORT,
                                                  1);
            } else {
              tmp___51 = strcmp((char const   *)k, "backend");
              if (tmp___51 == 0) {
                r = config_param_host_port(v, & cfg->BACK_IP, & cfg->BACK_PORT);
              } else {
                tmp___50 = strcmp((char const   *)k, "workers");
                if (tmp___50 == 0) {
                  r = config_param_val_intl_pos(v, & cfg->NCORES);
                } else {
                  tmp___49 = strcmp((char const   *)k, "backlog");
                  if (tmp___49 == 0) {
                    r = config_param_val_int(v, & cfg->BACKLOG);
                    if (r) {
                      if (cfg->BACKLOG < -1) {
                        cfg->BACKLOG = -1;
                      }
                    }
                  } else {
                    tmp___48 = strcmp((char const   *)k, "keepalive");
                    if (tmp___48 == 0) {
                      r = config_param_val_int_pos(v, & cfg->TCP_KEEPALIVE_TIME);
                    } else {
                      tmp___47 = strcmp((char const   *)k, "shared-cache");
                      if (tmp___47 == 0) {
                        r = config_param_val_int(v, & cfg->SHARED_CACHE);
                      } else {
                        tmp___46 = strcmp((char const   *)k, "shared-cache-listen");
                        if (tmp___46 == 0) {
                          if ((unsigned long )v != (unsigned long )((void *)0)) {
                            tmp___1 = strlen((char const   *)v);
                            if (tmp___1 > 0UL) {
                              r = config_param_host_port_wildcard(v, & cfg->SHCUPD_IP,
                                                                  & cfg->SHCUPD_PORT,
                                                                  1);
                            }
                          }
                        } else {
                          tmp___45 = strcmp((char const   *)k, "shared-cache-peer");
                          if (tmp___45 == 0) {
                            r = config_param_shcupd_peer(v, cfg);
                          } else {
                            tmp___44 = strcmp((char const   *)k, "shared-cache-if");
                            if (tmp___44 == 0) {
                              r = config_param_shcupd_mcastif(v, & cfg->SHCUPD_MCASTIF,
                                                              & cfg->SHCUPD_MCASTTTL);
                            } else {
                              tmp___43 = strcmp((char const   *)k, "chroot");
                              if (tmp___43 == 0) {
                                if ((unsigned long )v != (unsigned long )((void *)0)) {
                                  tmp___7 = strlen((char const   *)v);
                                  if (tmp___7 > 0UL) {
                                    tmp___6 = stat((char const   * __restrict  )v,
                                                   (struct stat * __restrict  )(& st));
                                    if (tmp___6 != 0) {
                                      tmp___2 = __errno_location();
                                      tmp___3 = strerror(*tmp___2);
                                      config_error_set((char *)"Unable to stat directory \'%s\': %s\'.",
                                                       v, tmp___3);
                                      r = 0;
                                    } else
                                    if (! ((st.st_mode & 61440U) == 16384U)) {
                                      tmp___4 = __errno_location();
                                      tmp___5 = strerror(*tmp___4);
                                      config_error_set((char *)"Bad chroot directory \'%s\': Not a directory.",
                                                       v, tmp___5);
                                      r = 0;
                                    } else {
                                      config_assign_str(& cfg->CHROOT, v);
                                    }
                                  }
                                }
                              } else {
                                tmp___42 = strcmp((char const   *)k, "user");
                                if (tmp___42 == 0) {
                                  if ((unsigned long )v != (unsigned long )((void *)0)) {
                                    tmp___8 = strlen((char const   *)v);
                                    if (tmp___8 > 0UL) {
                                      passwd = getpwnam((char const   *)v);
                                      if (! passwd) {
                                        config_error_set((char *)"Invalid user \'%s\'.",
                                                         v);
                                        r = 0;
                                      } else {
                                        cfg->UID = passwd->pw_uid;
                                        cfg->GID = passwd->pw_gid;
                                      }
                                    }
                                  }
                                } else {
                                  tmp___41 = strcmp((char const   *)k, "group");
                                  if (tmp___41 == 0) {
                                    if ((unsigned long )v != (unsigned long )((void *)0)) {
                                      tmp___9 = strlen((char const   *)v);
                                      if (tmp___9 > 0UL) {
                                        grp = getgrnam((char const   *)v);
                                        if (! grp) {
                                          config_error_set((char *)"Invalid group \'%s\'.",
                                                           v);
                                          r = 0;
                                        } else {
                                          cfg->GID = grp->gr_gid;
                                        }
                                      }
                                    }
                                  } else {
                                    tmp___40 = strcmp((char const   *)k, "quiet");
                                    if (tmp___40 == 0) {
                                      r = config_param_val_bool(v, & cfg->QUIET);
                                    } else {
                                      tmp___39 = strcmp((char const   *)k, "syslog");
                                      if (tmp___39 == 0) {
                                        r = config_param_val_bool(v, & cfg->SYSLOG);
                                      } else {
                                        tmp___38 = strcmp((char const   *)k, "syslog-facility");
                                        if (tmp___38 == 0) {
                                          r = 1;
                                          tmp___26 = strcmp((char const   *)v, "auth");
                                          if (tmp___26) {
                                            tmp___27 = strcmp((char const   *)v, "authpriv");
                                            if (tmp___27) {
                                              tmp___25 = strcmp((char const   *)v,
                                                                "cron");
                                              if (tmp___25) {
                                                tmp___24 = strcmp((char const   *)v,
                                                                  "daemon");
                                                if (tmp___24) {
                                                  tmp___23 = strcmp((char const   *)v,
                                                                    "ftp");
                                                  if (tmp___23) {
                                                    tmp___22 = strcmp((char const   *)v,
                                                                      "local0");
                                                    if (tmp___22) {
                                                      tmp___21 = strcmp((char const   *)v,
                                                                        "local1");
                                                      if (tmp___21) {
                                                        tmp___20 = strcmp((char const   *)v,
                                                                          "local2");
                                                        if (tmp___20) {
                                                          tmp___19 = strcmp((char const   *)v,
                                                                            "local3");
                                                          if (tmp___19) {
                                                            tmp___18 = strcmp((char const   *)v,
                                                                              "local4");
                                                            if (tmp___18) {
                                                              tmp___17 = strcmp((char const   *)v,
                                                                                "local5");
                                                              if (tmp___17) {
                                                                tmp___16 = strcmp((char const   *)v,
                                                                                  "local6");
                                                                if (tmp___16) {
                                                                  tmp___15 = strcmp((char const   *)v,
                                                                                    "local7");
                                                                  if (tmp___15) {
                                                                    tmp___14 = strcmp((char const   *)v,
                                                                                      "lpr");
                                                                    if (tmp___14) {
                                                                      tmp___13 = strcmp((char const   *)v,
                                                                                        "mail");
                                                                      if (tmp___13) {
                                                                        tmp___12 = strcmp((char const   *)v,
                                                                                          "news");
                                                                        if (tmp___12) {
                                                                          tmp___11 = strcmp((char const   *)v,
                                                                                            "user");
                                                                          if (tmp___11) {
                                                                            tmp___10 = strcmp((char const   *)v,
                                                                                              "uucp");
                                                                            if (tmp___10) {
                                                                              config_error_set((char *)"Invalid facility \'%s\'.",
                                                                                               v);
                                                                              r = 0;
                                                                            } else {
                                                                              cfg->SYSLOG_FACILITY = 8 << 3;
                                                                            }
                                                                          } else {
                                                                            cfg->SYSLOG_FACILITY = 1 << 3;
                                                                          }
                                                                        } else {
                                                                          cfg->SYSLOG_FACILITY = 7 << 3;
                                                                        }
                                                                      } else {
                                                                        cfg->SYSLOG_FACILITY = 2 << 3;
                                                                      }
                                                                    } else {
                                                                      cfg->SYSLOG_FACILITY = 6 << 3;
                                                                    }
                                                                  } else {
                                                                    cfg->SYSLOG_FACILITY = 23 << 3;
                                                                  }
                                                                } else {
                                                                  cfg->SYSLOG_FACILITY = 22 << 3;
                                                                }
                                                              } else {
                                                                cfg->SYSLOG_FACILITY = 21 << 3;
                                                              }
                                                            } else {
                                                              cfg->SYSLOG_FACILITY = 20 << 3;
                                                            }
                                                          } else {
                                                            cfg->SYSLOG_FACILITY = 19 << 3;
                                                          }
                                                        } else {
                                                          cfg->SYSLOG_FACILITY = 18 << 3;
                                                        }
                                                      } else {
                                                        cfg->SYSLOG_FACILITY = 17 << 3;
                                                      }
                                                    } else {
                                                      cfg->SYSLOG_FACILITY = 16 << 3;
                                                    }
                                                  } else {
                                                    cfg->SYSLOG_FACILITY = 11 << 3;
                                                  }
                                                } else {
                                                  cfg->SYSLOG_FACILITY = 3 << 3;
                                                }
                                              } else {
                                                cfg->SYSLOG_FACILITY = 9 << 3;
                                              }
                                            } else {
                                              cfg->SYSLOG_FACILITY = 10 << 3;
                                            }
                                          } else {
                                            cfg->SYSLOG_FACILITY = 10 << 3;
                                          }
                                        } else {
                                          tmp___37 = strcmp((char const   *)k, "daemon");
                                          if (tmp___37 == 0) {
                                            r = config_param_val_bool(v, & cfg->DAEMONIZE);
                                          } else {
                                            tmp___36 = strcmp((char const   *)k, "write-ip");
                                            if (tmp___36 == 0) {
                                              r = config_param_val_bool(v, & cfg->WRITE_IP_OCTET);
                                            } else {
                                              tmp___35 = strcmp((char const   *)k,
                                                                "write-proxy");
                                              if (tmp___35 == 0) {
                                                r = config_param_val_bool(v, & cfg->WRITE_PROXY_LINE);
                                              } else {
                                                tmp___34 = strcmp((char const   *)k,
                                                                  "proxy-proxy");
                                                if (tmp___34 == 0) {
                                                  r = config_param_val_bool(v, & cfg->PROXY_PROXY_LINE);
                                                } else {
                                                  tmp___33 = strcmp((char const   *)k,
                                                                    "pem-file");
                                                  if (tmp___33 == 0) {
                                                    if ((unsigned long )v != (unsigned long )((void *)0)) {
                                                      tmp___32 = strlen((char const   *)v);
                                                      if (tmp___32 > 0UL) {
                                                        tmp___31 = stat((char const   * __restrict  )v,
                                                                        (struct stat * __restrict  )(& st));
                                                        if (tmp___31 != 0) {
                                                          tmp___28 = __errno_location();
                                                          tmp___29 = strerror(*tmp___28);
                                                          config_error_set((char *)"Unable to stat x509 certificate PEM file \'%s\': ",
                                                                           v, tmp___29);
                                                          r = 0;
                                                        } else
                                                        if (! ((st.st_mode & 61440U) == 32768U)) {
                                                          config_error_set((char *)"Invalid x509 certificate PEM file \'%s\': Not a file.",
                                                                           v);
                                                          r = 0;
                                                        } else {
                                                          tmp___30 = calloc((size_t )1,
                                                                            sizeof(*cert));
                                                          cert = (struct cert_files *)tmp___30;
                                                          config_assign_str(& cert->CERT_FILE,
                                                                            v);
                                                          cert->NEXT = cfg->CERT_FILES;
                                                          cfg->CERT_FILES = cert;
                                                        }
                                                      }
                                                    }
                                                  } else {
                                                    fprintf((FILE * __restrict  )stderr,
                                                            (char const   * __restrict  )"Ignoring unknown configuration key \'%s\' in configuration file \'%s\', line %d\n",
                                                            k, file, line);
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (! r) {
    if ((unsigned long )file != (unsigned long )((void *)0)) {
      tmp___58 = config_error_get();
      config_die((char *)"Error in configuration file \'%s\', line %d: %s\n", file,
                 line, tmp___58);
    } else {
      tmp___59 = config_error_get();
      config_die((char *)"Invalid parameter \'%s\': %s", k, tmp___59);
    }
  }
  return;
}
}
int config_file_parse(char *file , stud_config *cfg ) 
{ 
  char line[1024] ;
  FILE *fd ;
  size_t tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int i ;
  char *tmp___3 ;
  char *key ;
  char *val ;

  {
  if ((unsigned long )cfg == (unsigned long )((void *)0)) {
    config_die((char *)"Undefined stud options; THIS IS A BUG!\n");
  }
  fd = (FILE *)((void *)0);
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    fd = stdin;
  } else {
    tmp = strlen((char const   *)file);
    if (tmp < 1UL) {
      fd = stdin;
    } else {
      tmp___0 = strcmp((char const   *)file, "-");
      if (tmp___0 == 0) {
        fd = stdin;
      } else {
        fd = fopen((char const   * __restrict  )file, (char const   * __restrict  )"r");
      }
    }
  }
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    tmp___1 = __errno_location();
    tmp___2 = strerror(*tmp___1);
    config_die((char *)"Unable to open configuration file \'%s\': %s\n", file, tmp___2);
  }
  i = 0;
  while (i < 10000) {
    memset((void *)(line), '\000', sizeof(line));
    tmp___3 = fgets((char * __restrict  )(line), (int )(sizeof(line) - 1UL), (FILE * __restrict  )fd);
    if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
      break;
    }
    i ++;
    key = config_get_param(line);
    if ((unsigned long )key == (unsigned long )((void *)0)) {
      continue;
    }
    val = config_get_value(line);
    if ((unsigned long )val == (unsigned long )((void *)0)) {
      continue;
    }
    str_trim(val);
    config_param_validate(key, val, cfg, file, i);
  }
  fclose(fd);
  return (1);
}
}
char *config_disp_str(char *str ) 
{ 
  char const   *tmp ;

  {
  if ((unsigned long )str == (unsigned long )((void *)0)) {
    tmp = "";
  } else {
    tmp = (char const   *)str;
  }
  return ((char *)tmp);
}
}
char *config_disp_bool(int v ) 
{ 
  char const   *tmp ;

  {
  if (v > 0) {
    tmp = "on";
  } else {
    tmp = "off";
  }
  return ((char *)tmp);
}
}
char *config_disp_uid(uid_t uid ) 
{ 
  __uid_t tmp ;
  struct passwd *pw ;
  struct passwd *tmp___0 ;
  size_t tmp___1 ;

  {
  memset((void *)(tmp_buf), '\000', sizeof(tmp_buf));
  if (uid == 0U) {
    tmp = geteuid();
    if (tmp != 0U) {
      return (tmp_buf);
    }
  }
  tmp___0 = getpwuid(uid);
  pw = tmp___0;
  if (pw) {
    tmp___1 = strlen((char const   *)pw->pw_name);
    memcpy((void * __restrict  )(tmp_buf), (void const   * __restrict  )pw->pw_name,
           tmp___1);
  }
  return (tmp_buf);
}
}
char *config_disp_gid(gid_t gid ) 
{ 
  __uid_t tmp ;
  struct group *gr ;
  struct group *tmp___0 ;
  size_t tmp___1 ;

  {
  memset((void *)(tmp_buf), '\000', sizeof(tmp_buf));
  if (gid == 0U) {
    tmp = geteuid();
    if (tmp != 0U) {
      return (tmp_buf);
    }
  }
  tmp___0 = getgrgid(gid);
  gr = tmp___0;
  if (gr) {
    tmp___1 = strlen((char const   *)gr->gr_name);
    memcpy((void * __restrict  )(tmp_buf), (void const   * __restrict  )gr->gr_name,
           tmp___1);
  }
  return (tmp_buf);
}
}
char *config_disp_hostport(char *host , char *port ) 
{ 


  {
  memset((void *)(tmp_buf), '\000', sizeof(tmp_buf));
  if ((unsigned long )host == (unsigned long )((void *)0)) {
    if ((unsigned long )port == (unsigned long )((void *)0)) {
      return ((char *)"");
    }
  }
  strcat((char * __restrict  )(tmp_buf), (char const   * __restrict  )"[");
  if ((unsigned long )host == (unsigned long )((void *)0)) {
    strcat((char * __restrict  )(tmp_buf), (char const   * __restrict  )"*");
  } else {
    strncat((char * __restrict  )(tmp_buf), (char const   * __restrict  )host, (size_t )40);
  }
  strcat((char * __restrict  )(tmp_buf), (char const   * __restrict  )"]:");
  strncat((char * __restrict  )(tmp_buf), (char const   * __restrict  )port, (size_t )5);
  return (tmp_buf);
}
}
char const   *config_disp_log_facility(int facility ) 
{ 


  {
  switch (facility) {
  case 10 << 3: 
  return ("authpriv");
  case 9 << 3: 
  return ("cron");
  case 3 << 3: 
  return ("daemon");
  case 11 << 3: 
  return ("ftp");
  case 16 << 3: 
  return ("local0");
  case 17 << 3: 
  return ("local1");
  case 18 << 3: 
  return ("local2");
  case 19 << 3: 
  return ("local3");
  case 20 << 3: 
  return ("local4");
  case 21 << 3: 
  return ("local5");
  case 22 << 3: 
  return ("local6");
  case 23 << 3: 
  return ("local7");
  case 6 << 3: 
  return ("lpr");
  case 2 << 3: 
  return ("mail");
  case 7 << 3: 
  return ("news");
  case 1 << 3: 
  return ("user");
  case 8 << 3: 
  return ("uucp");
  default: 
  return ("UNKNOWN");
  }
}
}
void config_print_usage_fd(char *prog , stud_config *cfg , FILE *out ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;

  {
  if ((unsigned long )out == (unsigned long )((void *)0)) {
    out = stderr;
  }
  tmp = __xpg_basename(prog);
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"Usage: %s [OPTIONS] PEM\n\n",
          tmp);
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"This is stud, The Scalable TLS Unwrapping Daemon.\n\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"CONFIGURATION:\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"        --config=FILE      Load configuration from specified file.\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"        --default-config   Prints default configuration to stdout.\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"ENCRYPTION METHODS:\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"      --tls                   TLSv1 (default)\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"      --ssl                   SSLv3 (implies no TLSv1)\n");
  tmp___0 = config_disp_str(cfg->CIPHER_SUITE);
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"  -c  --ciphers=SUITE         Sets allowed ciphers (Default: \"%s\")\n",
          tmp___0);
  tmp___1 = config_disp_str(cfg->ENGINE);
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"  -e  --ssl-engine=NAME       Sets OpenSSL engine (Default: \"%s\")\n",
          tmp___1);
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"  -O  --prefer-server-ciphers Prefer server list order\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"SOCKET:\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"  --client                    Enable client proxy mode\n");
  tmp___2 = config_disp_hostport(cfg->BACK_IP, cfg->BACK_PORT);
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"  -b  --backend=HOST,PORT     Backend [connect] (default is \"%s\")\n",
          tmp___2);
  tmp___3 = config_disp_hostport(cfg->FRONT_IP, cfg->FRONT_PORT);
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"  -f  --frontend=HOST,PORT    Frontend [bind] (default is \"%s\")\n",
          tmp___3);
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"  -U  --shared-cache-listen=HOST,PORT\n");
  tmp___4 = config_disp_hostport(cfg->SHCUPD_IP, cfg->SHCUPD_PORT);
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"                              Accept cache updates on UDP (Default: \"%s\")\n",
          tmp___4);
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"                              NOTE: This option requires enabled SSL session cache.\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"  -P  --shared-cache-peer=HOST,PORT\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"                              Send cache updates to specified peer\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"                              NOTE: This option can be specified multiple times.\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"  -M  --shared-cache-if=IFACE[,TTL]\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"                              Force iface and ttl to receive and send multicast updates\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"PERFORMANCE:\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"  -n  --workers=NUM          Number of worker processes (Default: %ld)\n",
          cfg->NCORES);
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"  -B  --backlog=NUM          Set listen backlog size (Default: %d)\n",
          cfg->BACKLOG);
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"  -k  --keepalive=SECS       TCP keepalive on client socket (Default: %d)\n",
          cfg->TCP_KEEPALIVE_TIME);
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"  -C  --session-cache=NUM    Enable and set SSL session cache to specified number\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"                             of sessions (Default: %d)\n",
          cfg->SHARED_CACHE);
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"SECURITY:\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\n");
  tmp___5 = config_disp_str(cfg->CHROOT);
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"  -r  --chroot=DIR           Sets chroot directory (Default: \"%s\")\n",
          tmp___5);
  tmp___6 = config_disp_uid(cfg->UID);
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"  -u  --user=USER            Set uid/gid after binding the socket (Default: \"%s\")\n",
          tmp___6);
  tmp___7 = config_disp_gid(cfg->GID);
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"  -g  --group=GROUP          Set gid after binding the socket (Default: \"%s\")\n",
          tmp___7);
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"LOGGING:\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"  -q  --quiet                Be quiet; emit only error messages\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"  -s  --syslog               Send log message to syslog in addition to stderr/stdout\n");
  tmp___8 = config_disp_log_facility(cfg->SYSLOG_FACILITY);
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"  --syslog-facility=FACILITY Syslog facility to use (Default: \"%s\")\n",
          tmp___8);
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"OTHER OPTIONS:\n");
  tmp___9 = config_disp_bool(cfg->DAEMONIZE);
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"      --daemon               Fork into background and become a daemon (Default: %s)\n",
          tmp___9);
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"      --write-ip             Write 1 octet with the IP family followed by the IP\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"                             address in 4 (IPv4) or 16 (IPv6) octets little-endian\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"                             to backend before the actual data\n");
  tmp___10 = config_disp_bool(cfg->WRITE_IP_OCTET);
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"                             (Default: %s)\n",
          tmp___10);
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"      --write-proxy          Write HaProxy\'s PROXY (IPv4 or IPv6) protocol line\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"                             before actual data\n");
  tmp___11 = config_disp_bool(cfg->WRITE_PROXY_LINE);
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"                             (Default: %s)\n",
          tmp___11);
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"      --proxy-proxy          Proxy HaProxy\'s PROXY (IPv4 or IPv6) protocol line\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"                             before actual data\n");
  tmp___12 = config_disp_bool(cfg->PROXY_PROXY_LINE);
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"                             (Default: %s)\n",
          tmp___12);
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"  -t  --test                 Test configuration and exit\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"  -V  --version              Print program version and exit\n");
  fprintf((FILE * __restrict  )out, (char const   * __restrict  )"  -h  --help                 This help message\n");
  return;
}
}
void config_print_default(FILE *fd , stud_config *cfg ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int i ;
  char *tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;

  {
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
    return;
  }
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"#\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# stud(8), The Scalable TLS Unwrapping Daemon\'s configuration\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"#\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# NOTE: all config file parameters can be overriden\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"#       from command line!\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# Listening address. REQUIRED.\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"#\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# type: string\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# syntax: [HOST]:PORT\n");
  tmp = config_disp_hostport(cfg->FRONT_IP, cfg->FRONT_PORT);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"%s = \"%s\"\n", "frontend",
          tmp);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# Upstream server address. REQUIRED.\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"#\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# type: string\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# syntax: [HOST]:PORT.\n");
  tmp___0 = config_disp_hostport(cfg->BACK_IP, cfg->BACK_PORT);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"%s = \"%s\"\n", "backend",
          tmp___0);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# SSL x509 certificate file. REQUIRED.\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# List multiple certs to use SNI. Certs are used in the order they\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# are listed; the last cert listed will be used if none of the others match\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"#\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# type: string\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"%s = \"%s\"\n", "pem-file",
          "");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# SSL protocol.\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"#\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# tls = on\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# ssl = off\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# List of allowed SSL ciphers.\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"#\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# Run openssl ciphers for list of available ciphers.\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# type: string\n");
  tmp___1 = config_disp_str(cfg->CIPHER_SUITE);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"%s = \"%s\"\n", "ciphers",
          tmp___1);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# Enforce server cipher list order\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"#\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# type: boolean\n");
  tmp___2 = config_disp_bool(cfg->PREFER_SERVER_CIPHERS);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"%s = %s\n", "prefer-server-ciphers",
          tmp___2);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# Use specified SSL engine\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"#\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# type: string\n");
  tmp___3 = config_disp_str(cfg->ENGINE);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"%s = \"%s\"\n", "ssl-engine",
          tmp___3);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# Number of worker processes\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"#\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# type: integer\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"%s = %d\n", "workers",
          (int )cfg->NCORES);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# Listen backlog size\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"#\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# type: integer\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"%s = %d\n", "backlog",
          cfg->BACKLOG);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# TCP socket keepalive interval in seconds\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"#\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# type: integer\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"%s = %d\n", "keepalive",
          cfg->TCP_KEEPALIVE_TIME);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# SSL session cache size\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"#\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# type: integer\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"%s = %d\n", "shared-cache",
          cfg->SHARED_CACHE);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# Accept shared SSL cache updates on specified listener.\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"#\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# type: string\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# syntax: [HOST]:PORT\n");
  tmp___4 = config_disp_hostport(cfg->SHCUPD_IP, cfg->SHCUPD_PORT);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"%s = \"%s\"\n", "shared-cache-listen",
          tmp___4);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# Shared cache peer address.\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# Multiple stud processes on multiple hosts (host limit: %d)\n",
          15);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# can share SSL session cache by sending updates to peers.\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"#\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# NOTE: This parameter can be specified multiple times in order\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"#       to specify multiple peers.\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"#\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# type: string\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# syntax: [HOST]:PORT\n");
  tmp___5 = config_disp_hostport((char *)((void *)0), (char *)((void *)0));
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# %s = \"%s\"\n",
          "shared-cache-peer", tmp___5);
  i = 0;
  while (i < 15) {
    if ((unsigned long )cfg->SHCUPD_PEERS[i].ip == (unsigned long )((void *)0)) {
      if ((unsigned long )cfg->SHCUPD_PEERS[i].port == (unsigned long )((void *)0)) {
        break;
      }
    }
    tmp___6 = config_disp_hostport(cfg->SHCUPD_PEERS[i].ip, cfg->SHCUPD_PEERS[i].port);
    fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"%s = \"%s\"\n",
            "shared-cache-peer", tmp___6);
    i ++;
  }
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# Shared cache interface name and optional TTL\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"#\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# type: string\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# syntax: iface[,TTL]\n");
  tmp___7 = config_disp_str(cfg->SHCUPD_MCASTIF);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# %s = \"%s", "shared-cache-if",
          tmp___7);
  if ((unsigned long )cfg->SHCUPD_MCASTTTL != (unsigned long )((void *)0)) {
    tmp___8 = strlen((char const   *)cfg->SHCUPD_MCASTTTL);
    if (tmp___8 > 0UL) {
      fprintf((FILE * __restrict  )fd, (char const   * __restrict  )",%s", cfg->SHCUPD_MCASTTTL);
    }
  }
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\"\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# Chroot directory\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"#\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# type: string\n");
  tmp___9 = config_disp_str(cfg->CHROOT);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"%s = \"%s\"\n", "chroot",
          tmp___9);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# Set uid after binding a socket\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"#\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# type: string\n");
  tmp___10 = config_disp_uid(cfg->UID);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"%s = \"%s\"\n", "user",
          tmp___10);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# Set gid after binding a socket\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"#\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# type: string\n");
  tmp___11 = config_disp_gid(cfg->GID);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"%s = \"%s\"\n", "group",
          tmp___11);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# Quiet execution, report only error messages\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"#\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# type: boolean\n");
  tmp___12 = config_disp_bool(cfg->QUIET);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"%s = %s\n", "quiet",
          tmp___12);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# Use syslog for logging\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"#\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# type: boolean\n");
  tmp___13 = config_disp_bool(cfg->SYSLOG);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"%s = %s\n", "syslog",
          tmp___13);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# Syslog facility to use\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"#\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# type: string\n");
  tmp___14 = config_disp_log_facility(cfg->SYSLOG_FACILITY);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"%s = \"%s\"\n", "syslog-facility",
          tmp___14);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# Run as daemon\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"#\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# type: boolean\n");
  tmp___15 = config_disp_bool(cfg->DAEMONIZE);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"%s = %s\n", "daemon",
          tmp___15);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# Report client address by writing IP before sending data\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"#\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# NOTE: This option is mutually exclusive with option %s and %s.\n",
          "write-proxy", "proxy-proxy");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"#\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# type: boolean\n");
  tmp___16 = config_disp_bool(cfg->WRITE_IP_OCTET);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"%s = %s\n", "write-ip",
          tmp___16);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# Report client address using SENDPROXY protocol, see\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# http://haproxy.1wt.eu/download/1.5/doc/proxy-protocol.txt\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# for details.\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"#\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# NOTE: This option is mutually exclusive with option %s and %s.\n",
          "write-ip", "proxy-proxy");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"#\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# type: boolean\n");
  tmp___17 = config_disp_bool(cfg->WRITE_PROXY_LINE);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"%s = %s\n", "write-proxy",
          tmp___17);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# Proxy an existing SENDPROXY protocol header through this request.\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"#\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# NOTE: This option is mutually exclusive with option %s and %s.\n",
          "write-ip", "write-proxy");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"#\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# type: boolean\n");
  tmp___18 = config_disp_bool(cfg->PROXY_PROXY_LINE);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"%s = %s\n", "proxy-proxy",
          tmp___18);
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )fd, (char const   * __restrict  )"# EOF\n");
  return;
}
}
void config_print_usage(char *prog , stud_config *cfg ) 
{ 


  {
  config_print_usage_fd(prog, cfg, stdout);
  return;
}
}
static int tls  =    0;
static int ssl  =    0;
static int client  =    0;
void config_parse_cli(int argc , char **argv , stud_config *cfg ) 
{ 
  int c ;
  int i ;
  int test_only ;
  char *prog ;
  struct option long_options[30] ;
  int option_index ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  SSL_CTX *tmp___3 ;
  char *tmp___4 ;

  {
  test_only = 0;
  long_options[0].name = "config";
  long_options[0].has_arg = 1;
  long_options[0].flag = (int *)((void *)0);
  long_options[0].val = 10000;
  long_options[1].name = "default-config";
  long_options[1].has_arg = 0;
  long_options[1].flag = (int *)((void *)0);
  long_options[1].val = 10001;
  long_options[2].name = "tls";
  long_options[2].has_arg = 0;
  long_options[2].flag = & tls;
  long_options[2].val = 1;
  long_options[3].name = "ssl";
  long_options[3].has_arg = 0;
  long_options[3].flag = & ssl;
  long_options[3].val = 1;
  long_options[4].name = "client";
  long_options[4].has_arg = 0;
  long_options[4].flag = & client;
  long_options[4].val = 1;
  long_options[5].name = "ciphers";
  long_options[5].has_arg = 1;
  long_options[5].flag = (int *)((void *)0);
  long_options[5].val = 'c';
  long_options[6].name = "prefer-server-ciphers";
  long_options[6].has_arg = 0;
  long_options[6].flag = (int *)((void *)0);
  long_options[6].val = 'O';
  long_options[7].name = "backend";
  long_options[7].has_arg = 1;
  long_options[7].flag = (int *)((void *)0);
  long_options[7].val = 'b';
  long_options[8].name = "frontend";
  long_options[8].has_arg = 1;
  long_options[8].flag = (int *)((void *)0);
  long_options[8].val = 'f';
  long_options[9].name = "workers";
  long_options[9].has_arg = 1;
  long_options[9].flag = (int *)((void *)0);
  long_options[9].val = 'n';
  long_options[10].name = "backlog";
  long_options[10].has_arg = 1;
  long_options[10].flag = (int *)((void *)0);
  long_options[10].val = 'B';
  long_options[11].name = "shared-cache";
  long_options[11].has_arg = 1;
  long_options[11].flag = (int *)((void *)0);
  long_options[11].val = 'C';
  long_options[12].name = "shared-cache-listen";
  long_options[12].has_arg = 1;
  long_options[12].flag = (int *)((void *)0);
  long_options[12].val = 'U';
  long_options[13].name = "shared-cache-peer";
  long_options[13].has_arg = 1;
  long_options[13].flag = (int *)((void *)0);
  long_options[13].val = 'P';
  long_options[14].name = "shared-cache-if";
  long_options[14].has_arg = 1;
  long_options[14].flag = (int *)((void *)0);
  long_options[14].val = 'M';
  long_options[15].name = "keepalive";
  long_options[15].has_arg = 1;
  long_options[15].flag = (int *)((void *)0);
  long_options[15].val = 'k';
  long_options[16].name = "chroot";
  long_options[16].has_arg = 1;
  long_options[16].flag = (int *)((void *)0);
  long_options[16].val = 'r';
  long_options[17].name = "user";
  long_options[17].has_arg = 1;
  long_options[17].flag = (int *)((void *)0);
  long_options[17].val = 'u';
  long_options[18].name = "group";
  long_options[18].has_arg = 1;
  long_options[18].flag = (int *)((void *)0);
  long_options[18].val = 'g';
  long_options[19].name = "quiet";
  long_options[19].has_arg = 0;
  long_options[19].flag = (int *)((void *)0);
  long_options[19].val = 'q';
  long_options[20].name = "syslog";
  long_options[20].has_arg = 0;
  long_options[20].flag = (int *)((void *)0);
  long_options[20].val = 's';
  long_options[21].name = "syslog-facility";
  long_options[21].has_arg = 1;
  long_options[21].flag = (int *)((void *)0);
  long_options[21].val = 11015;
  long_options[22].name = "daemon";
  long_options[22].has_arg = 0;
  long_options[22].flag = & cfg->DAEMONIZE;
  long_options[22].val = 1;
  long_options[23].name = "write-ip";
  long_options[23].has_arg = 0;
  long_options[23].flag = & cfg->WRITE_IP_OCTET;
  long_options[23].val = 1;
  long_options[24].name = "write-proxy";
  long_options[24].has_arg = 0;
  long_options[24].flag = & cfg->WRITE_PROXY_LINE;
  long_options[24].val = 1;
  long_options[25].name = "proxy-proxy";
  long_options[25].has_arg = 0;
  long_options[25].flag = & cfg->PROXY_PROXY_LINE;
  long_options[25].val = 1;
  long_options[26].name = "test";
  long_options[26].has_arg = 0;
  long_options[26].flag = (int *)((void *)0);
  long_options[26].val = 't';
  long_options[27].name = "version";
  long_options[27].has_arg = 0;
  long_options[27].flag = (int *)((void *)0);
  long_options[27].val = 'V';
  long_options[28].name = "help";
  long_options[28].has_arg = 0;
  long_options[28].flag = (int *)((void *)0);
  long_options[28].val = 'h';
  long_options[29].name = (char const   *)0;
  long_options[29].has_arg = 0;
  long_options[29].flag = (int *)0;
  long_options[29].val = 0;
  while (1) {
    option_index = 0;
    c = getopt_long(argc, (char * const  *)argv, "c:e:Ob:f:n:B:C:U:P:M:k:r:u:g:qstVh",
                    (struct option  const  *)(long_options), & option_index);
    if (c == -1) {
      break;
    }
    switch (c) {
    case 0: 
    break;
    case 10000: 
    tmp___0 = config_file_parse(optarg, cfg);
    if (! tmp___0) {
      tmp = config_error_get();
      config_die((char *)"%s", tmp);
    }
    break;
    case 10001: 
    config_print_default(stdout, cfg);
    exit(0);
    break;
    case 11015: 
    config_param_validate((char *)"syslog-facility", optarg, cfg, (char *)((void *)0),
                          0);
    break;
    case 99: 
    config_param_validate((char *)"ciphers", optarg, cfg, (char *)((void *)0), 0);
    break;
    case 101: 
    config_param_validate((char *)"ssl-engine", optarg, cfg, (char *)((void *)0),
                          0);
    break;
    case 79: 
    config_param_validate((char *)"prefer-server-ciphers", (char *)"on", cfg, (char *)((void *)0),
                          0);
    break;
    case 98: 
    config_param_validate((char *)"backend", optarg, cfg, (char *)((void *)0), 0);
    break;
    case 102: 
    config_param_validate((char *)"frontend", optarg, cfg, (char *)((void *)0), 0);
    break;
    case 110: 
    config_param_validate((char *)"workers", optarg, cfg, (char *)((void *)0), 0);
    break;
    case 66: 
    config_param_validate((char *)"backlog", optarg, cfg, (char *)((void *)0), 0);
    break;
    case 67: 
    config_param_validate((char *)"shared-cache", optarg, cfg, (char *)((void *)0),
                          0);
    break;
    case 85: 
    config_param_validate((char *)"shared-cache-listen", optarg, cfg, (char *)((void *)0),
                          0);
    break;
    case 80: 
    config_param_validate((char *)"shared-cache-peer", optarg, cfg, (char *)((void *)0),
                          0);
    break;
    case 77: 
    config_param_validate((char *)"shared-cache-if", optarg, cfg, (char *)((void *)0),
                          0);
    break;
    case 107: 
    config_param_validate((char *)"keepalive", optarg, cfg, (char *)((void *)0), 0);
    break;
    case 114: 
    config_param_validate((char *)"chroot", optarg, cfg, (char *)((void *)0), 0);
    break;
    case 117: 
    config_param_validate((char *)"user", optarg, cfg, (char *)((void *)0), 0);
    break;
    case 103: 
    config_param_validate((char *)"group", optarg, cfg, (char *)((void *)0), 0);
    break;
    case 113: 
    config_param_validate((char *)"quiet", (char *)"on", cfg, (char *)((void *)0),
                          0);
    break;
    case 115: 
    config_param_validate((char *)"syslog", (char *)"on", cfg, (char *)((void *)0),
                          0);
    break;
    case 116: 
    test_only = 1;
    break;
    case 86: 
    tmp___1 = __xpg_basename(*(argv + 0));
    printf((char const   * __restrict  )"%s %s\n", tmp___1, "0.3-dev");
    exit(0);
    break;
    case 104: 
    config_print_usage(*(argv + 0), cfg);
    exit(0);
    break;
    default: 
    tmp___2 = __xpg_basename(*(argv + 0));
    config_die((char *)"Invalid command line parameters. Run %s --help for instructions.",
               tmp___2);
    }
  }
  prog = *(argv + 0);
  if (tls) {
    if (ssl) {
      config_die((char *)"Options --tls and --ssl are mutually exclusive.");
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (ssl) {
    cfg->ETYPE = (ENC_TYPE )1;
  } else
  if (tls) {
    cfg->ETYPE = (ENC_TYPE )0;
  }
  if (client) {
    cfg->PMODE = (PROXY_MODE )1;
  }
  if (cfg->WRITE_IP_OCTET) {
    if (cfg->WRITE_PROXY_LINE) {
      config_die((char *)"Options --write-ip and --write-proxy are mutually exclusive.");
    }
  }
  if (cfg->WRITE_PROXY_LINE) {
    if (cfg->PROXY_PROXY_LINE) {
      config_die((char *)"Options --write-proxy and --proxy-proxy are mutually exclusive.");
    }
  }
  if (cfg->WRITE_IP_OCTET) {
    if (cfg->PROXY_PROXY_LINE) {
      config_die((char *)"Options --write-ip and --proxy-proxy are mutually exclusive.");
    }
  }
  if (cfg->DAEMONIZE) {
    cfg->SYSLOG = 1;
    cfg->QUIET = 1;
  }
  if ((unsigned long )cfg->SHCUPD_IP != (unsigned long )((void *)0)) {
    if (! cfg->SHARED_CACHE) {
      config_die((char *)"Shared cache update listener is defined, but shared cache is disabled.");
    }
  }
  argc -= optind;
  argv += optind;
  i = 0;
  while (i < argc) {
    config_param_validate((char *)"pem-file", *(argv + i), cfg, (char *)((void *)0),
                          0);
    i ++;
  }
  if ((unsigned int )cfg->PMODE == 0U) {
    if ((unsigned long )cfg->CERT_FILES == (unsigned long )((void *)0)) {
      config_die((char *)"No x509 certificate PEM file specified!");
    }
  }
  if (test_only) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Trying to initialize SSL contexts with your certificates");
    tmp___3 = init_openssl();
    if (! tmp___3) {
      config_die((char *)"Error initializing OpenSSL.");
    }
    tmp___4 = __xpg_basename(prog);
    printf((char const   * __restrict  )"%s configuration looks ok.\n", tmp___4);
    exit(0);
  }
  return;
}
}
#pragma merger("0","/tmp/cil-ASTV4RAb.i","-O2,-g,-std=c99,-fno-strict-aliasing,-Wall,-W")
extern  __attribute__((__nothrow__)) void *mmap(void *__addr , size_t __len , int __prot ,
                                                int __flags , int __fd , __off_t __offset ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutexattr_init)(pthread_mutexattr_t *__attr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutexattr_setpshared)(pthread_mutexattr_t *__attr ,
                                                                                                         int __pshared ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                     pthread_t __thread2 ) 
{ 


  {
  return (__thread1 == __thread2);
}
}
extern void eb_delete(struct eb_node *node ) ;
__inline static void ( __attribute__((__always_inline__)) ebmb_delete)(struct ebmb_node *ebmb ) 
{ 


  {
  eb_delete(& ebmb->node);
  return;
}
}
extern struct ebmb_node *ebmb_lookup(struct eb_root *root , void const   *x , unsigned int len ) ;
extern struct ebmb_node *ebmb_insert(struct eb_root *root , struct ebmb_node *new ,
                                     unsigned int len ) ;
extern void SSL_CTX_sess_set_new_cb(SSL_CTX *ctx , int (*new_session_cb)(struct ssl_st *ssl ,
                                                                         SSL_SESSION *sess ) ) ;
extern void SSL_CTX_sess_set_remove_cb(SSL_CTX *ctx , void (*remove_session_cb)(struct ssl_ctx_st *ctx ,
                                                                                SSL_SESSION *sess ) ) ;
extern void SSL_CTX_sess_set_get_cb(SSL_CTX *ctx , SSL_SESSION *(*get_session_cb)(struct ssl_st *ssl ,
                                                                                  unsigned char *data ,
                                                                                  int len ,
                                                                                  int *copy ) ) ;
extern long SSL_SESSION_get_time(SSL_SESSION const   *s ) ;
extern long SSL_SESSION_set_time(SSL_SESSION *s , long t ) ;
extern int i2d_SSL_SESSION(SSL_SESSION *in , unsigned char **pp ) ;
extern SSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a , unsigned char const   **pp ,
                                    long length ) ;
static struct shared_context *shctx  =    (struct shared_context *)((void *)0);
static void (*shared_session_new_cbk)(unsigned char *session , unsigned int session_len ,
                                      long cdate )  ;
int shctx_new_cb(SSL *ssl___0 , SSL_SESSION *sess ) 
{ 
  struct shared_session *shsess ;
  unsigned char *data ;
  unsigned char *p ;
  unsigned int data_len ;
  unsigned char encsess[(544UL + sizeof(uint32_t )) + 64UL] ;
  int tmp ;
  struct ebmb_node *tmp___0 ;
  long tmp___1 ;

  {
  tmp = i2d_SSL_SESSION(sess, (unsigned char **)((void *)0));
  data_len = (unsigned int )tmp;
  if (data_len > 512U) {
    return (1);
  }
  data = encsess + 32;
  p = data;
  i2d_SSL_SESSION(sess, & p);
  pthread_mutex_lock(& shctx->mutex);
  if ((unsigned long )shctx->free.p == (unsigned long )shctx->free.n) {
    shsess = shctx->active.p;
  } else {
    shsess = shctx->free.p;
  }
  ebmb_delete(& shsess->key);
  memcpy((void * __restrict  )(shsess->key_data), (void const   * __restrict  )(sess->session_id),
         (size_t )sess->session_id_length);
  if (sess->session_id_length < 32U) {
    memset((void *)(shsess->key_data + sess->session_id_length), 0, (size_t )(32U - sess->session_id_length));
  }
  tmp___0 = ebmb_insert(& shctx->active.key.node.branches, & shsess->key, 32U);
  shsess = (struct shared_session *)tmp___0;
  shsess->data_len = (int )data_len;
  memcpy((void * __restrict  )(shsess->data), (void const   * __restrict  )data, (size_t )data_len);
  shsess->c_date = SSL_SESSION_get_time((SSL_SESSION const   *)sess);
  (shsess->n)->p = shsess->p;
  (shsess->p)->n = shsess->n;
  shsess->p = & shctx->active;
  shsess->n = shctx->active.n;
  (shctx->active.n)->p = shsess;
  shctx->active.n = shsess;
  pthread_mutex_unlock(& shctx->mutex);
  if (shared_session_new_cbk) {
    memcpy((void * __restrict  )(encsess), (void const   * __restrict  )(sess->session_id),
           (size_t )sess->session_id_length);
    if (sess->session_id_length < 32U) {
      memset((void *)(encsess + sess->session_id_length), 0, (size_t )(32U - sess->session_id_length));
    }
    tmp___1 = SSL_SESSION_get_time((SSL_SESSION const   *)sess);
    (*shared_session_new_cbk)(encsess, 32U + data_len, tmp___1);
  }
  return (0);
}
}
SSL_SESSION *shctx_get_cb(SSL *ssl___0 , unsigned char *key , int key_len , int *do_copy ) 
{ 
  struct shared_session *shsess ;
  unsigned char data[512] ;
  unsigned char *p ;
  unsigned char tmpkey[32] ;
  unsigned int data_len ;
  long cdate ;
  SSL_SESSION *sess ;
  struct ebmb_node *tmp ;

  {
  *do_copy = 0;
  if (key_len < 32) {
    memcpy((void * __restrict  )(tmpkey), (void const   * __restrict  )key, (size_t )key_len);
    memset((void *)(tmpkey + key_len), 0, (size_t )(32 - key_len));
    key = tmpkey;
  }
  pthread_mutex_lock(& shctx->mutex);
  tmp = ebmb_lookup(& shctx->active.key.node.branches, (void const   *)key, 32U);
  shsess = (struct shared_session *)tmp;
  if (! shsess) {
    pthread_mutex_unlock(& shctx->mutex);
    return ((SSL_SESSION *)((void *)0));
  }
  cdate = shsess->c_date;
  data_len = (unsigned int )shsess->data_len;
  memcpy((void * __restrict  )(data), (void const   * __restrict  )(shsess->data),
         (size_t )shsess->data_len);
  (shsess->n)->p = shsess->p;
  (shsess->p)->n = shsess->n;
  shsess->p = & shctx->active;
  shsess->n = shctx->active.n;
  (shctx->active.n)->p = shsess;
  shctx->active.n = shsess;
  pthread_mutex_unlock(& shctx->mutex);
  p = data;
  sess = d2i_SSL_SESSION((SSL_SESSION **)((void *)0), (unsigned char const   **)(& p),
                         (long )data_len);
  if (sess) {
    SSL_SESSION_set_time(sess, cdate);
  }
  return (sess);
}
}
void shctx_remove_cb(SSL_CTX *ctx , SSL_SESSION *sess ) 
{ 
  struct shared_session *shsess ;
  unsigned char tmpkey[32] ;
  unsigned char *key ;
  struct ebmb_node *tmp ;

  {
  key = sess->session_id;
  if (sess->session_id_length < 32U) {
    memcpy((void * __restrict  )(tmpkey), (void const   * __restrict  )(sess->session_id),
           (size_t )sess->session_id_length);
    memset((void *)(tmpkey + sess->session_id_length), 0, (size_t )(32U - sess->session_id_length));
    key = tmpkey;
  }
  pthread_mutex_lock(& shctx->mutex);
  tmp = ebmb_lookup(& shctx->active.key.node.branches, (void const   *)key, 32U);
  shsess = (struct shared_session *)tmp;
  if (shsess) {
    (shsess->n)->p = shsess->p;
    (shsess->p)->n = shsess->n;
    shsess->p = & shctx->free;
    shsess->n = shctx->free.n;
    (shctx->free.n)->p = shsess;
    shctx->free.n = shsess;
  }
  pthread_mutex_unlock(& shctx->mutex);
  return;
}
}
void shctx_sess_add(unsigned char const   *encsess , unsigned int len , long cdate ) 
{ 
  struct shared_session *shsess ;
  struct ebmb_node *tmp ;

  {
  if (len <= 32U) {
    return;
  } else
  if (len > 544U) {
    return;
  }
  pthread_mutex_lock(& shctx->mutex);
  if ((unsigned long )shctx->free.p == (unsigned long )shctx->free.n) {
    shsess = shctx->active.p;
  } else {
    shsess = shctx->free.p;
  }
  ebmb_delete(& shsess->key);
  memcpy((void * __restrict  )(shsess->key_data), (void const   * __restrict  )encsess,
         (size_t )32);
  tmp = ebmb_insert(& shctx->active.key.node.branches, & shsess->key, 32U);
  shsess = (struct shared_session *)tmp;
  if (cdate) {
    shsess->c_date = cdate;
  }
  shsess->data_len = (int )(len - 32U);
  memcpy((void * __restrict  )(shsess->data), (void const   * __restrict  )(encsess + 32),
         (size_t )shsess->data_len);
  (shsess->n)->p = shsess->p;
  (shsess->p)->n = shsess->n;
  shsess->p = & shctx->active;
  shsess->n = shctx->active.n;
  (shctx->active.n)->p = shsess;
  shctx->active.n = shsess;
  pthread_mutex_unlock(& shctx->mutex);
  return;
}
}
void shsess_set_new_cbk(void (*func)(unsigned char *session , unsigned int len , long cdate ) ) 
{ 


  {
  shared_session_new_cbk = func;
  return;
}
}
int shared_context_init(SSL_CTX *ctx , int size ) 
{ 
  int ret ;
  int i ;
  pthread_mutexattr_t attr ;
  struct shared_session *prev ;
  struct shared_session *cur ;
  void *tmp ;
  struct shared_session *tmp___0 ;

  {
  ret = 0;
  if (! shctx) {
    tmp = mmap((void *)0, sizeof(struct shared_context ) + (unsigned long )size * sizeof(struct shared_session ),
               3, 33, -1, (__off_t )0);
    shctx = (struct shared_context *)tmp;
    if (! shctx) {
      return (-1);
    } else
    if ((unsigned long )shctx == (unsigned long )((void *)-1)) {
      return (-1);
    }
    pthread_mutexattr_init(& attr);
    pthread_mutexattr_setpshared(& attr, 1);
    pthread_mutex_init(& shctx->mutex, (pthread_mutexattr_t const   *)(& attr));
    memset((void *)(& shctx->active.key), 0, sizeof(struct ebmb_node ));
    memset((void *)(& shctx->free.key), 0, sizeof(struct ebmb_node ));
    shctx->active.key.node.branches.b[1] = (void *)1;
    cur = & shctx->active;
    tmp___0 = cur;
    cur->p = tmp___0;
    cur->n = tmp___0;
    cur = & shctx->free;
    i = 0;
    while (i < size) {
      prev = cur;
      cur = (struct shared_session *)((char *)prev + sizeof(struct shared_session ));
      prev->n = cur;
      cur->p = prev;
      i ++;
    }
    cur->n = & shctx->free;
    shctx->free.p = cur;
    ret = size;
  }
  SSL_CTX_ctrl(ctx, 42, (long )((size >> 3) | 1023), (void *)0);
  SSL_CTX_sess_set_new_cb(ctx, & shctx_new_cb);
  SSL_CTX_sess_set_get_cb(ctx, & shctx_get_cb);
  SSL_CTX_sess_set_remove_cb(ctx, & shctx_remove_cb);
  return (ret);
}
}
