/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef int __int32_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned long __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef long __time_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __blkcnt64_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
typedef unsigned int __socklen_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
typedef unsigned long pthread_t;
typedef __builtin_va_list __gnuc_va_list;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef __gnuc_va_list va_list___0;
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
typedef __socklen_t socklen_t;
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
struct __anonstruct_abuf_t_653462436 {
   char *p ;
   size_t len ;
};
typedef struct __anonstruct_abuf_t_653462436 abuf_t;
typedef unsigned short __uint16_t;
typedef unsigned long __uint64_t;
typedef long __suseconds_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
typedef __time_t time_t;
typedef __mode_t mode_t;
typedef __off_t off_t;
typedef __ssize_t ssize_t;
typedef long __fd_mask;
struct __anonstruct_fd_set_356711149 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
typedef struct __anonstruct_fd_set_356711149 fd_set;
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
typedef __uint16_t uint16_t;
typedef __uint64_t uint64_t;
typedef unsigned short sa_family_t;
struct __anonstruct_message_t_933122616 {
   void *next ;
   char text[(size_t )1024] ;
};
typedef struct __anonstruct_message_t_933122616 message_t;
typedef message_t url_t;
typedef message_t if_t;
struct __anonstruct_conf_t_915110938 {
   char default_filename[(size_t )1024] ;
   char http_proxy[(size_t )1024] ;
   char no_proxy[(size_t )1024] ;
   uint16_t num_connections ;
   int strip_cgi_parameters ;
   int save_state_interval ;
   int connection_timeout ;
   int reconnect_delay ;
   int max_redirect ;
   int buffer_size ;
   unsigned long long max_speed ;
   int verbose ;
   int alternate_output ;
   int insecure ;
   int no_clobber ;
   int percentage ;
   if_t *interfaces ;
   sa_family_t ai_family ;
   int search_timeout ;
   int search_threads ;
   int search_amount ;
   int search_top ;
   unsigned int io_timeout ;
   int add_header_count ;
   char add_header[10][(size_t )1024] ;
};
typedef struct __anonstruct_conf_t_915110938 conf_t;
struct __anonstruct_tcp_t_13748673 {
   int fd ;
   sa_family_t ai_family ;
};
typedef struct __anonstruct_tcp_t_13748673 tcp_t;
struct __anonstruct_ftp_t_515051304 {
   char cwd[(size_t )1024] ;
   char *message ;
   int status ;
   tcp_t tcp ;
   tcp_t data_tcp ;
   int proto ;
   int ftp_mode ;
   char *local_if ;
};
typedef struct __anonstruct_ftp_t_515051304 ftp_t;
struct __anonstruct_http_t_677330235 {
   char host[(size_t )1024] ;
   char auth[(size_t )1024] ;
   abuf_t request[1] ;
   abuf_t headers[1] ;
   int port ;
   int proto ;
   int proxy ;
   char proxy_auth[(size_t )1024] ;
   off_t firstbyte ;
   off_t lastbyte ;
   int status ;
   tcp_t tcp ;
   char *local_if ;
};
typedef struct __anonstruct_http_t_677330235 http_t;
struct __anonstruct_conn_t_702709736 {
   conf_t *conf ;
   int proto ;
   int port ;
   int proxy ;
   char host[(size_t )1024] ;
   char dir[(size_t )1024] ;
   char file[(size_t )1024] ;
   char user[(size_t )1024] ;
   char pass[(size_t )1024] ;
   char output_filename[(size_t )1024] ;
   ftp_t ftp[1] ;
   http_t http[1] ;
   off_t size ;
   off_t currentbyte ;
   off_t lastbyte ;
   tcp_t *tcp ;
   _Bool enabled ;
   _Bool supported ;
   int last_transfer ;
   char *message ;
   char *local_if ;
   _Bool state ;
   pthread_t setup_thread[1] ;
   pthread_mutex_t lock ;
};
typedef struct __anonstruct_conn_t_702709736 conn_t;
struct __anonstruct_search_t_969092730 {
   char url[(size_t )1024] ;
   double speed_start_time ;
   off_t speed ;
   off_t size ;
   pthread_t speed_thread[1] ;
   conf_t *conf ;
};
typedef struct __anonstruct_search_t_969092730 search_t;
struct __anonstruct_axel_t_40439293 {
   conn_t *conn ;
   conf_t *conf ;
   char filename[(size_t )1024] ;
   double start_time ;
   int next_state ;
   int finish_time ;
   off_t bytes_done ;
   off_t start_byte ;
   off_t size ;
   long long bytes_per_second ;
   struct timespec delay_time ;
   int outfd ;
   int ready ;
   message_t *message ;
   message_t *last_message ;
   url_t *url ;
};
typedef struct __anonstruct_axel_t_40439293 axel_t;
typedef unsigned int __uint32_t;
typedef char *__caddr_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct sockaddr_in ;
typedef __uint32_t uint32_t;
typedef uint32_t in_addr_t;
struct in_addr {
   in_addr_t s_addr ;
};
typedef uint16_t in_port_t;
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
union __anonunion_ifr_ifrn_352126815 {
   char ifrn_name[16] ;
};
union __anonunion_ifr_ifru_537349870 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
struct ifreq {
   union __anonunion_ifr_ifrn_352126815 ifr_ifrn ;
   union __anonunion_ifr_ifru_537349870 ifr_ifru ;
};
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
typedef void (*__sighandler_t)(int  );
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#pragma merger("0","/tmp/cil-28FZhebB.i","-fno-strict-aliasing,-Wnested-externs,-Wmissing-prototypes,-Wstrict-prototypes,-Wdeclaration-after-statement,-Wimplicit-function-declaration,-Wold-style-definition,-Wjump-misses-init,-Wall,-Wextra,-Wundef,-Wwrite-strings,-Wpointer-arith,-Wmissing-declarations,-Wredundant-decls,-Wno-unused-parameter,-Wno-missing-field-initializers,-Wformat=2,-Wcast-align,-Wformat-nonliteral,-Wformat-security,-Wsign-compare,-Wstrict-aliasing,-Wshadow,-Winline,-Wpacked,-Wmissing-format-attribute,-Wmissing-noreturn,-Winit-self,-Wmissing-include-dirs,-Wunused-but-set-variable,-Warray-bounds,-Wreturn-type,-Wswitch-enum,-Wswitch-default,-Wduplicated-cond,-Wduplicated-branches,-Wlogical-op,-Wrestrict,-Wnull-dereference,-Wdouble-promotion,-Werror,-Wno-suggest-attribute=format,-Wno-error=unused-parameter,-Wno-error=missing-field-initializers,-Wno-declaration-after-statement,-Wno-error=cast-align,-Wno-error=inline,-pthread,-g,-O2")
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1))) strtoll)(char const   * __restrict  __nptr ,
                                                                                          char ** __restrict  __endptr ,
                                                                                          int __base ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) atoi)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return ((int )tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long ( __attribute__((__nonnull__(1), __gnu_inline__)) atol)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long long ( __attribute__((__nonnull__(1), __gnu_inline__)) atoll)(char const   *__nptr ) 
{ 
  long long tmp ;

  {
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
  __l = (size_t )0;
  __u = __nmemb;
  while (__l < __u) {
    __idx = (__l + __u) / 2UL;
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
    __comparison = (*__compar)(__key, __p);
    if (__comparison < 0) {
      __u = __idx;
    } else
    if (__comparison > 0) {
      __l = __idx + 1UL;
    } else {
      return ((void *)__p);
    }
  }
  return ((void *)0);
}
}
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern double ( __attribute__((__nonnull__(1), __gnu_inline__)) atof)(char const   *__nptr ) 
{ 
  double tmp ;

  {
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
  return (tmp);
}
}
extern FILE *stdin ;
extern FILE *stdout ;
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
extern int getc(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
extern int putc(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
extern __ssize_t __getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                            int __delimiter , FILE * __restrict  __stream ) ;
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                     size_t * __restrict  __n ,
                                                                     FILE * __restrict  __stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
extern int __uflow(FILE * ) ;
extern int __overflow(FILE * , int  ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) 
{ 
  int tmp ;

  {
  tmp = vfprintf((FILE * __restrict  )stdout, __fmt, __arg);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) 
{ 
  int tmp ;

  {
  tmp = getc(stdin);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(__fp);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = __fp->_IO_read_ptr;
    (__fp->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(stdin);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = stdin->_IO_read_ptr;
    (stdin->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) 
{ 
  int tmp ;

  {
  tmp = putc(__c, stdout);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = __stream->_IO_write_ptr;
    (__stream->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = stdout->_IO_write_ptr;
    (stdout->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                     size_t * __restrict  __n ,
                                                                     FILE * __restrict  __stream ) 
{ 
  __ssize_t tmp ;

  {
  tmp = __getdelim(__lineptr, __n, '\n', __stream);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 16) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 32) != 0);
}
}
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) tolower)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_tolower_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
    tmp___0 = (__int32_t const   )__c;
  }
  return ((int )tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) toupper)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_toupper_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
    tmp___0 = (__int32_t const   )__c;
  }
  return ((int )tmp___0);
}
}
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat64)(int __fd , struct stat64 *__statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat64)(int __fd , char const   * __restrict  __filename , struct stat64 * __restrict  __statbuf ,
                            int __flag ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat)(int __ver ,
                                                                                     int __fildes ,
                                                                                     struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat)(int __ver ,
                                                                                      char const   *__filename ,
                                                                                      struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat)(int __ver ,
                                                                                       char const   *__filename ,
                                                                                       struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4))) __fxstatat)(int __ver ,
                                                                                         int __fildes ,
                                                                                         char const   *__filename ,
                                                                                         struct stat *__stat_buf ,
                                                                                         int __flag ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat64)(int __ver ,
                                                                                       int __fildes ,
                                                                                       struct stat64 *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat64)(int __ver ,
                                                                                        char const   *__filename ,
                                                                                        struct stat64 *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat64)(int __ver ,
                                                                                         char const   *__filename ,
                                                                                         struct stat64 *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4))) __fxstatat64)(int __ver ,
                                                                                           int __fildes ,
                                                                                           char const   *__filename ,
                                                                                           struct stat64 *__stat_buf ,
                                                                                           int __flag ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4))) __xmknod)(int __ver ,
                                                                                       char const   *__path ,
                                                                                       __mode_t __mode ,
                                                                                       __dev_t *__dev ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,5))) __xmknodat)(int __ver ,
                                                                                         int __fd ,
                                                                                         char const   *__path ,
                                                                                         __mode_t __mode ,
                                                                                         __dev_t *__dev ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) stat)(char const   * __restrict  __path ,
                                                                              struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __xstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) lstat)(char const   * __restrict  __path ,
                                                                               struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __lxstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) fstat)(int __fd ,
                                                                             struct stat *__statbuf ) 
{ 
  int tmp ;

  {
  tmp = __fxstat(1, __fd, __statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag ) ;
__inline extern int ( __attribute__((__nonnull__(2,3), __gnu_inline__)) fstatat)(int __fd ,
                                                                                 char const   * __restrict  __filename ,
                                                                                 struct stat * __restrict  __statbuf ,
                                                                                 int __flag ) 
{ 
  int tmp ;

  {
  tmp = __fxstatat(1, __fd, (char const   *)__filename, (struct stat *)__statbuf,
                   __flag);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) mknod)(char const   *__path ,
                                                                             __mode_t __mode ,
                                                                             __dev_t __dev ) 
{ 
  int tmp ;

  {
  tmp = __xmknod(0, __path, __mode, & __dev);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) mknodat)(int __fd ,
                                                                               char const   *__path ,
                                                                               __mode_t __mode ,
                                                                               __dev_t __dev ) 
{ 
  int tmp ;

  {
  tmp = __xmknodat(0, __fd, __path, __mode, & __dev);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) stat64)(char const   * __restrict  __path ,
                                                                                struct stat64 * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __xstat64(1, (char const   *)__path, (struct stat64 *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) lstat64)(char const   * __restrict  __path ,
                                                                                 struct stat64 * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
  tmp = __lxstat64(1, (char const   *)__path, (struct stat64 *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat64)(int __fd , struct stat64 *__statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) fstat64)(int __fd ,
                                                                               struct stat64 *__statbuf ) 
{ 
  int tmp ;

  {
  tmp = __fxstat64(1, __fd, __statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat64)(int __fd , char const   * __restrict  __filename , struct stat64 * __restrict  __statbuf ,
                            int __flag ) ;
__inline extern int ( __attribute__((__nonnull__(2,3), __gnu_inline__)) fstatat64)(int __fd ,
                                                                                   char const   * __restrict  __filename ,
                                                                                   struct stat64 * __restrict  __statbuf ,
                                                                                   int __flag ) 
{ 
  int tmp ;

  {
  tmp = __fxstatat64(1, __fd, (char const   *)__filename, (struct stat64 *)__statbuf,
                     __flag);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                               struct cmsghdr *__cmsg ) ;
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                               struct cmsghdr *__cmsg ) ;
__inline extern struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                 struct cmsghdr *__cmsg ) 
{ 


  {
  if (__cmsg->cmsg_len < sizeof(struct cmsghdr )) {
    return ((struct cmsghdr *)0);
  }
  __cmsg = (struct cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)));
  if ((unsigned long )((unsigned char *)(__cmsg + 1)) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  } else
  if ((unsigned long )((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  }
  return (__cmsg);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                     pthread_t __thread2 ) 
{ 


  {
  return (__thread1 == __thread2);
}
}
size_t strlcat(char *dst , char const   *src , size_t dsize ) ;
int abuf_setup(abuf_t *abuf , size_t len ) ;
int ( /* format attribute */  abuf_printf)(abuf_t *abuf , char const   *fmt  , ...) ;
int abuf_strcat(abuf_t *abuf , char const   *src ) ;
int abuf_setup(abuf_t *abuf , size_t len ) 
{ 
  char *p ;
  void *tmp ;

  {
  tmp = realloc((void *)abuf->p, len);
  p = (char *)tmp;
  if (! p) {
    if (len) {
      return (-12);
    }
  }
  abuf->p = p;
  abuf->len = len;
  return (0);
}
}
int ( /* format attribute */  abuf_printf)(abuf_t *abuf , char const   *fmt  , ...) 
{ 
  va_list___0 ap ;
  size_t len ;
  int tmp ;
  int r ;
  int tmp___0 ;

  {
  __builtin_va_start(ap, fmt);
  while (1) {
    tmp = vsnprintf((char * __restrict  )abuf->p, abuf->len, (char const   * __restrict  )fmt,
                    ap);
    len = (size_t )tmp;
    if (len < abuf->len) {
      break;
    }
    tmp___0 = abuf_setup(abuf, len + 1UL);
    r = tmp___0;
    if (r < 0) {
      return (r);
    }
  }
  __builtin_va_end(ap);
  return (0);
}
}
int abuf_strcat(abuf_t *abuf , char const   *src ) 
{ 
  size_t nread ;
  size_t tmp ;
  size_t done ;
  int ret ;
  int tmp___0 ;

  {
  tmp = strlcat(abuf->p, src, abuf->len);
  nread = tmp;
  if (nread > abuf->len) {
    done = abuf->len - 1UL;
    tmp___0 = abuf_setup(abuf, nread);
    ret = tmp___0;
    if (ret < 0) {
      return (ret);
    }
    memcpy((void * __restrict  )(abuf->p + done), (void const   * __restrict  )(src + done),
           nread - done);
  }
  return (0);
}
}
#pragma merger("0","/tmp/cil-M0vNaygu.i","-fno-strict-aliasing,-Wnested-externs,-Wmissing-prototypes,-Wstrict-prototypes,-Wdeclaration-after-statement,-Wimplicit-function-declaration,-Wold-style-definition,-Wjump-misses-init,-Wall,-Wextra,-Wundef,-Wwrite-strings,-Wpointer-arith,-Wmissing-declarations,-Wredundant-decls,-Wno-unused-parameter,-Wno-missing-field-initializers,-Wformat=2,-Wcast-align,-Wformat-nonliteral,-Wformat-security,-Wsign-compare,-Wstrict-aliasing,-Wshadow,-Winline,-Wpacked,-Wmissing-format-attribute,-Wmissing-noreturn,-Winit-self,-Wmissing-include-dirs,-Wunused-but-set-variable,-Warray-bounds,-Wreturn-type,-Wswitch-enum,-Wswitch-default,-Wduplicated-cond,-Wduplicated-branches,-Wlogical-op,-Wrestrict,-Wnull-dereference,-Wdouble-promotion,-Werror,-Wno-suggest-attribute=format,-Wno-error=unused-parameter,-Wno-error=missing-field-initializers,-Wno-declaration-after-statement,-Wno-error=cast-align,-Wno-error=inline,-pthread,-g,-O2")
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
extern FILE *stderr ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern void perror(char const   *__s ) ;
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) access)(char const   *__name ,
                                                                                   int __type ) ;
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
extern int close(int __fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2))) strcspn)(char const   *__s ,
                                                                                         char const   *__reject )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                         void * __restrict  __tz ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
extern int pthread_setcancelstate(int __state , int *__oldstate ) ;
extern int pthread_setcanceltype(int __type , int *__oldtype ) ;
extern int pthread_cancel(pthread_t __th ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_trylock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
size_t strlcpy(char *dst , char const   *src , size_t dsize ) ;
extern  __attribute__((__nothrow__)) char *dcgettext(char const   *__domainname ,
                                                     char const   *__msgid , int __category )  __attribute__((__format_arg__(2))) ;
ssize_t tcp_read(tcp_t *tcp , void *buffer___0 , int size ) ;
void http_decode(char *s ) ;
int conn_set(conn_t *conn , char const   *set_url ) ;
char *conn_url(char *dst , size_t len , conn_t *conn ) ;
void conn_disconnect(conn_t *conn ) ;
int conn_init(conn_t *conn ) ;
int conn_setup(conn_t *conn ) ;
int conn_exec(conn_t *conn ) ;
int conn_info(conn_t *conn ) ;
int conn_info_status_get(char *msg , size_t size , conn_t *conn ) ;
axel_t *axel_new(conf_t *conf , int count , search_t const   *res ) ;
int axel_open(axel_t *axel ) ;
void axel_start(axel_t *axel ) ;
void axel_do(axel_t *axel ) ;
void axel_close(axel_t *axel ) ;
void print_messages(axel_t *axel ) ;
double axel_gettime(void) ;
char *axel_size_human(char *dst , size_t len , size_t value ) ;
int axel_sleep(struct timespec delay ) ;
static void save_state(axel_t *axel ) ;
static void *setup_thread(void *c ) ;
static void ( /* format attribute */  axel_message)(axel_t *axel , char const   *format 
                                                    , ...) ;
static void axel_divide(axel_t *axel ) ;
static char *buffer  =    (char *)((void *)0);
static char *stfile_makename(char const   *bname ) 
{ 
  char suffix[4] ;
  size_t bname_len ;
  size_t tmp ;
  char *buf ;
  void *tmp___0 ;

  {
  suffix[0] = (char )'.';
  suffix[1] = (char )'s';
  suffix[2] = (char )'t';
  suffix[3] = (char )'\000';
  tmp = strlen(bname);
  bname_len = tmp;
  tmp___0 = malloc(bname_len + sizeof(suffix));
  buf = (char *)tmp___0;
  if (! buf) {
    perror("stfile_open");
    abort();
  }
  memcpy((void * __restrict  )buf, (void const   * __restrict  )bname, bname_len);
  memcpy((void * __restrict  )(buf + bname_len), (void const   * __restrict  )(suffix),
         sizeof(suffix));
  return (buf);
}
}
static int stfile_unlink(char const   *bname ) 
{ 
  char *stname ;
  char *tmp ;
  int ret ;
  int tmp___0 ;

  {
  tmp = stfile_makename(bname);
  stname = tmp;
  tmp___0 = unlink((char const   *)stname);
  ret = tmp___0;
  free((void *)stname);
  return (ret);
}
}
static int stfile_access(char const   *bname , int mode ) 
{ 
  char *stname ;
  char *tmp ;
  int ret ;
  int tmp___0 ;

  {
  tmp = stfile_makename(bname);
  stname = tmp;
  tmp___0 = access((char const   *)stname, mode);
  ret = tmp___0;
  free((void *)stname);
  return (ret);
}
}
static int stfile_open(char const   *bname , int flags , mode_t mode ) 
{ 
  char *stname ;
  char *tmp ;
  int fd ;
  int tmp___0 ;

  {
  tmp = stfile_makename(bname);
  stname = tmp;
  tmp___0 = open((char const   *)stname, flags, mode);
  fd = tmp___0;
  free((void *)stname);
  return (fd);
}
}
axel_t *axel_new(conf_t *conf , int count , search_t const   *res ) 
{ 
  axel_t *axel ;
  int status ;
  uint64_t delay ;
  url_t *u ;
  char *s ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int ret ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char msg[80] ;
  int code ;
  int tmp___11 ;
  char *tmp___12 ;
  char hsize[32] ;
  char *tmp___13 ;
  char *tmp___14 ;
  size_t tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;

  {
  if (! count) {
    return ((axel_t *)((void *)0));
  } else
  if (! res) {
    return ((axel_t *)((void *)0));
  }
  tmp = calloc((size_t )1, sizeof(axel_t ));
  axel = (axel_t *)tmp;
  if (! axel) {
    goto nomem;
  }
  axel->conf = conf;
  tmp___0 = calloc((size_t )(axel->conf)->num_connections, sizeof(conn_t ));
  axel->conn = (conn_t *)tmp___0;
  if (! axel->conn) {
    goto nomem;
  }
  i = 0;
  while (i < (int )(axel->conf)->num_connections) {
    pthread_mutex_init(& (axel->conn + i)->lock, (pthread_mutexattr_t const   *)((void *)0));
    i ++;
  }
  if ((axel->conf)->max_speed > 0ULL) {
    if ((16ULL * (axel->conf)->max_speed) / (unsigned long long )(axel->conf)->buffer_size < 8ULL) {
      if ((axel->conf)->verbose >= 2) {
        tmp___1 = dcgettext((char const   *)((void *)0), "Buffer resized for this speed.",
                            5);
        axel_message(axel, (char const   *)tmp___1);
      }
      (axel->conf)->buffer_size = (int )(axel->conf)->max_speed;
    }
    delay = (uint64_t )((unsigned long long )((1000000000 * (axel->conf)->buffer_size) * (int )(axel->conf)->num_connections) / (axel->conf)->max_speed);
    axel->delay_time.tv_sec = (__time_t )(delay / 1000000000UL);
    axel->delay_time.tv_nsec = (__syscall_slong_t )(delay % 1000000000UL);
  }
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    tmp___2 = malloc((size_t )(axel->conf)->buffer_size);
    buffer = (char *)tmp___2;
    if (! buffer) {
      goto nomem;
    }
  }
  tmp___3 = malloc(sizeof(url_t ) * (unsigned long )count);
  u = (url_t *)tmp___3;
  if (! u) {
    goto nomem;
  }
  axel->url = u;
  i = 0;
  while (i < count) {
    strlcpy((u + i)->text, (char const   *)((res + i)->url), sizeof((u + i)->text));
    (u + i)->next = (void *)(u + (i + 1));
    i ++;
  }
  (u + (count - 1))->next = (void *)u;
  (axel->conn + 0)->conf = axel->conf;
  tmp___5 = conn_set(axel->conn + 0, (char const   *)((axel->url)->text));
  if (! tmp___5) {
    tmp___4 = dcgettext((char const   *)((void *)0), "Could not parse URL.\n", 5);
    axel_message(axel, (char const   *)tmp___4);
    axel->ready = -1;
    return (axel);
  }
  (axel->conn + 0)->local_if = ((axel->conf)->interfaces)->text;
  (axel->conf)->interfaces = (if_t *)((axel->conf)->interfaces)->next;
  strlcpy(axel->filename, (char const   *)((axel->conn + 0)->file), sizeof(axel->filename));
  http_decode(axel->filename);
  s = strchr((char const   *)(axel->filename), '?');
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    if ((axel->conf)->strip_cgi_parameters) {
      *s = (char)0;
    }
  }
  if ((int )axel->filename[0] == 0) {
    strlcpy(axel->filename, (char const   *)((axel->conf)->default_filename), sizeof(axel->filename));
  }
  if ((axel->conf)->no_clobber) {
    tmp___9 = access((char const   *)(axel->filename), 0);
    if (tmp___9 == 0) {
      tmp___6 = stfile_access((char const   *)(axel->filename), 0);
      ret = tmp___6;
      if (ret) {
        tmp___7 = dcgettext((char const   *)((void *)0), "File \'%s\' already there; not retrieving.\n",
                            5);
        printf((char const   * __restrict  )tmp___7, axel->filename);
        axel->ready = -1;
        return (axel);
      }
      tmp___8 = dcgettext((char const   *)((void *)0), "Incomplete download found, ignoring no-clobber option\n",
                          5);
      printf((char const   * __restrict  )tmp___8);
    }
  }
  while (1) {
    tmp___10 = conn_init(axel->conn + 0);
    if (! tmp___10) {
      axel_message(axel, "%s", (axel->conn + 0)->message);
      axel->ready = -1;
      return (axel);
    }
    status = conn_info(axel->conn + 0);
    if (! status) {
      tmp___11 = conn_info_status_get(msg, sizeof(msg), axel->conn);
      code = tmp___11;
      tmp___12 = dcgettext((char const   *)((void *)0), "ERROR %d: %s.\n", 5);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___12,
              code, msg);
      axel->ready = -1;
      return (axel);
    }
    if (! (status == -1)) {
      break;
    }
  }
  conn_url((axel->url)->text, sizeof((axel->url)->text) - 1UL, axel->conn);
  axel->size = (axel->conn + 0)->size;
  if ((axel->conf)->verbose > 0) {
    if ((long long )axel->size != 9223372036854775807LL) {
      axel_size_human(hsize, sizeof(hsize), (size_t )axel->size);
      tmp___13 = dcgettext((char const   *)((void *)0), "File size: %s (%jd bytes)",
                           5);
      axel_message(axel, (char const   *)tmp___13, hsize, axel->size);
    } else {
      tmp___14 = dcgettext((char const   *)((void *)0), "File size: unavailable",
                           5);
      axel_message(axel, (char const   *)tmp___14);
    }
  }
  tmp___15 = strcspn((char const   *)(axel->filename), "*?");
  if (axel->filename[tmp___15]) {
    strlcpy(axel->filename, (char const   *)((axel->conn + 0)->file), sizeof(axel->filename));
  }
  if ((int )(axel->conn + 0)->output_filename[0] != 0) {
    strlcpy(axel->filename, (char const   *)((axel->conn + 0)->output_filename), sizeof(axel->filename));
  }
  return (axel);
  nomem: 
  axel_close(axel);
  tmp___16 = __errno_location();
  tmp___17 = strerror(*tmp___16);
  printf((char const   * __restrict  )"%s\n", tmp___17);
  return ((axel_t *)((void *)0));
}
}
int axel_open(axel_t *axel ) 
{ 
  int i ;
  int fd ;
  ssize_t nread ;
  char *tmp ;
  char *tmp___0 ;
  void *new_conn ;
  void *tmp___1 ;
  int old_format ;
  off_t stsize ;
  __off_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  void *new_conn___0 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  off_t j ;
  ssize_t nwrite ;
  int *tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  off_t __a ;
  int __b ;
  off_t tmp___15 ;
  __off_t tmp___16 ;

  {
  if ((axel->conf)->verbose > 0) {
    tmp = dcgettext((char const   *)((void *)0), "Opening output file %s", 5);
    axel_message(axel, (char const   *)tmp, axel->filename);
  }
  axel->outfd = -1;
  if (! (axel->conn + 0)->supported) {
    tmp___0 = dcgettext((char const   *)((void *)0), "Server unsupported, starting from scratch with one connection.",
                        5);
    axel_message(axel, (char const   *)tmp___0);
    (axel->conf)->num_connections = (uint16_t )1;
    tmp___1 = realloc((void *)axel->conn, sizeof(conn_t ));
    new_conn = tmp___1;
    if (! new_conn) {
      return (0);
    }
    axel->conn = (conn_t *)new_conn;
    axel_divide(axel);
  } else {
    fd = stfile_open((char const   *)(axel->filename), 0, (mode_t )0);
    if (fd != -1) {
      old_format = 0;
      tmp___2 = lseek(fd, (__off_t )0, 2);
      stsize = tmp___2;
      lseek(fd, (__off_t )0, 0);
      nread = read(fd, (void *)(& (axel->conf)->num_connections), sizeof((axel->conf)->num_connections));
      if ((unsigned long )nread != sizeof((axel->conf)->num_connections)) {
        tmp___3 = dcgettext((char const   *)((void *)0), "%s.st: Error, truncated state file\n",
                            5);
        printf((char const   * __restrict  )tmp___3, axel->filename);
        close(fd);
        return (0);
      }
      if ((int )(axel->conf)->num_connections < 1) {
        tmp___4 = dcgettext((char const   *)((void *)0), "Bogus number of connections stored in state file\n",
                            5);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___4);
        close(fd);
        return (0);
      }
      if (stsize < (off_t )((sizeof((axel->conf)->num_connections) + sizeof(axel->bytes_done)) + (unsigned long )(2 * (int )(axel->conf)->num_connections) * sizeof((axel->conn + 0)->currentbyte))) {
        old_format = 1;
      }
      tmp___5 = realloc((void *)axel->conn, sizeof(conn_t ) * (unsigned long )(axel->conf)->num_connections);
      new_conn___0 = tmp___5;
      if (! new_conn___0) {
        close(fd);
        return (0);
      }
      axel->conn = (conn_t *)new_conn___0;
      memset((void *)(axel->conn + 1), 0, sizeof(conn_t ) * (unsigned long )((int )(axel->conf)->num_connections - 1));
      if (old_format) {
        axel_divide(axel);
      }
      nread = read(fd, (void *)(& axel->bytes_done), sizeof(axel->bytes_done));
      i = 0;
      while (i < (int )(axel->conf)->num_connections) {
        nread = read(fd, (void *)(& (axel->conn + i)->currentbyte), sizeof((axel->conn + i)->currentbyte));
        if (! old_format) {
          nread = read(fd, (void *)(& (axel->conn + i)->lastbyte), sizeof((axel->conn + i)->lastbyte));
        }
        i ++;
      }
      tmp___6 = dcgettext((char const   *)((void *)0), "State file found: %jd bytes downloaded, %jd to go.",
                          5);
      axel_message(axel, (char const   *)tmp___6, axel->bytes_done, axel->size - axel->bytes_done);
      close(fd);
      tmp___8 = open((char const   *)(axel->filename), 1, 438);
      axel->outfd = tmp___8;
      if (tmp___8 == -1) {
        tmp___7 = dcgettext((char const   *)((void *)0), "Error opening local file",
                            5);
        axel_message(axel, (char const   *)tmp___7);
        return (0);
      }
    }
  }
  if (axel->outfd == -1) {
    axel_divide(axel);
    tmp___10 = open((char const   *)(axel->filename), 65, 438);
    axel->outfd = tmp___10;
    if (tmp___10 == -1) {
      tmp___9 = dcgettext((char const   *)((void *)0), "Error opening local file",
                          5);
      axel_message(axel, (char const   *)tmp___9);
      return (0);
    }
    tmp___16 = lseek(axel->outfd, axel->size, 0);
    if (tmp___16 == -1L) {
      if ((int )(axel->conf)->num_connections > 1) {
        tmp___11 = dcgettext((char const   *)((void *)0), "Crappy filesystem/OS.. Working around. :-(",
                             5);
        axel_message(axel, (char const   *)tmp___11);
        lseek(axel->outfd, (__off_t )0, 0);
        memset((void *)buffer, 0, (size_t )(axel->conf)->buffer_size);
        j = axel->size;
        while (j > 0L) {
          __a = j;
          __b = (axel->conf)->buffer_size;
          if (__a < (off_t )__b) {
            tmp___15 = __a;
          } else {
            tmp___15 = (off_t )__b;
          }
          nwrite = write(axel->outfd, (void const   *)buffer, (size_t )tmp___15);
          if (nwrite < 0L) {
            tmp___12 = __errno_location();
            if (*tmp___12 == 4) {
              continue;
            } else {
              tmp___13 = __errno_location();
              if (*tmp___13 == 11) {
                continue;
              }
            }
            tmp___14 = dcgettext((char const   *)((void *)0), "Error creating local file",
                                 5);
            axel_message(axel, (char const   *)tmp___14);
            return (0);
          }
          j -= nwrite;
        }
      }
    }
  }
  return (1);
}
}
static void reactivate_connection(axel_t *axel , int thread ) 
{ 
  off_t max_remaining ;
  int idx ;
  int j ;
  off_t remaining ;

  {
  max_remaining = (off_t )102399;
  idx = -1;
  if ((axel->conn + thread)->enabled) {
    return;
  } else
  if ((axel->conn + thread)->currentbyte < (axel->conn + thread)->lastbyte) {
    return;
  }
  j = 0;
  while (j < (int )(axel->conf)->num_connections) {
    remaining = (axel->conn + j)->lastbyte - (axel->conn + j)->currentbyte;
    if (remaining > max_remaining) {
      max_remaining = remaining;
      idx = j;
    }
    j ++;
  }
  if (idx == -1) {
    return;
  }
  (axel->conn + thread)->lastbyte = (axel->conn + idx)->lastbyte;
  (axel->conn + idx)->lastbyte = (axel->conn + idx)->currentbyte + max_remaining / 2L;
  (axel->conn + thread)->currentbyte = (axel->conn + idx)->lastbyte;
  return;
}
}
void axel_start(axel_t *axel ) 
{ 
  int i ;
  url_t *url_ptr ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  url_ptr = axel->url;
  i = 0;
  while (i < (int )(axel->conf)->num_connections) {
    conn_set(axel->conn + i, (char const   *)(url_ptr->text));
    url_ptr = (url_t *)url_ptr->next;
    (axel->conn + i)->local_if = ((axel->conf)->interfaces)->text;
    (axel->conf)->interfaces = (if_t *)((axel->conf)->interfaces)->next;
    (axel->conn + i)->conf = axel->conf;
    if (i) {
      (axel->conn + i)->supported = (_Bool)1;
    }
    i ++;
  }
  if ((axel->conf)->verbose > 0) {
    tmp = dcgettext((char const   *)((void *)0), "Starting download", 5);
    axel_message(axel, (char const   *)tmp);
  }
  i = 0;
  while (i < (int )(axel->conf)->num_connections) {
    if ((axel->conn + i)->currentbyte >= (axel->conn + i)->lastbyte) {
      pthread_mutex_lock(& (axel->conn + i)->lock);
      reactivate_connection(axel, i);
      pthread_mutex_unlock(& (axel->conn + i)->lock);
    } else
    if ((axel->conn + i)->currentbyte < (axel->conn + i)->lastbyte) {
      if ((axel->conf)->verbose >= 2) {
        tmp___0 = dcgettext((char const   *)((void *)0), "Connection %i downloading from %s:%i using interface %s",
                            5);
        axel_message(axel, (char const   *)tmp___0, i, (axel->conn + i)->host, (axel->conn + i)->port,
                     (axel->conn + i)->local_if);
      }
      (axel->conn + i)->state = (_Bool)1;
      tmp___2 = pthread_create((pthread_t * __restrict  )((axel->conn + i)->setup_thread),
                               (pthread_attr_t const   * __restrict  )((void *)0),
                               & setup_thread, (void * __restrict  )(axel->conn + i));
      if (tmp___2 != 0) {
        tmp___1 = dcgettext((char const   *)((void *)0), "pthread error!!!", 5);
        axel_message(axel, (char const   *)tmp___1);
        axel->ready = -1;
      }
    }
    i ++;
  }
  axel->start_time = axel_gettime();
  axel->ready = 0;
  return;
}
}
void axel_do(axel_t *axel ) 
{ 
  fd_set fds[1] ;
  int hifd ;
  int i ;
  off_t remaining ;
  off_t size ;
  struct timeval timeval[1] ;
  url_t *url_ptr ;
  struct timespec delay ;
  unsigned long long max_speed_ratio ;
  double tmp ;
  double tmp___0 ;
  int __d0 ;
  int __d1 ;
  int __a ;
  int __b ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  time_t timeout ;
  char *tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  ssize_t tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  double tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  double tmp___23 ;
  double tmp___24 ;
  int *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;

  {
  delay.tv_sec = (__time_t )0;
  delay.tv_nsec = (__syscall_slong_t )100000000;
  tmp___0 = axel_gettime();
  if (tmp___0 > (double )axel->next_state) {
    save_state(axel);
    tmp = axel_gettime();
    axel->next_state = (int )(tmp + (double )(axel->conf)->save_state_interval);
  }
  while (1) {
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fds[0].fds_bits[0]): "memory");
    break;
  }
  hifd = 0;
  i = 0;
  while (i < (int )(axel->conf)->num_connections) {
    tmp___2 = pthread_mutex_trylock(& (axel->conn + i)->lock);
    if (! tmp___2) {
      if ((axel->conn + i)->enabled) {
        fds[0].fds_bits[((axel->conn + i)->tcp)->fd / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << ((axel->conn + i)->tcp)->fd % (8 * (int )sizeof(__fd_mask )));
        __a = hifd;
        __b = ((axel->conn + i)->tcp)->fd;
        if (__a > __b) {
          tmp___1 = __a;
        } else {
          tmp___1 = __b;
        }
        hifd = tmp___1;
      }
      pthread_mutex_unlock(& (axel->conn + i)->lock);
    }
    i ++;
  }
  if (hifd == 0) {
    tmp___6 = axel_sleep(delay);
    if (tmp___6 < 0) {
      tmp___3 = __errno_location();
      tmp___4 = strerror(*tmp___3);
      tmp___5 = dcgettext((char const   *)((void *)0), "Error while waiting for connection: %s",
                          5);
      axel_message(axel, (char const   *)tmp___5, tmp___4);
      axel->ready = -1;
      return;
    }
    goto conn_check;
  }
  timeval[0].tv_sec = (__time_t )0;
  timeval[0].tv_usec = (__suseconds_t )100000;
  tmp___7 = select(hifd + 1, (fd_set * __restrict  )(fds), (fd_set * __restrict  )((void *)0),
                   (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )(timeval));
  if (tmp___7 == -1) {
    axel->ready = -1;
    return;
  }
  i = 0;
  while (i < (int )(axel->conf)->num_connections) {
    tmp___8 = pthread_mutex_trylock(& (axel->conn + i)->lock);
    if (tmp___8) {
      goto __Cont;
    }
    if (! (axel->conn + i)->enabled) {
      goto next_conn;
    }
    if (! ((fds[0].fds_bits[((axel->conn + i)->tcp)->fd / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << ((axel->conn + i)->tcp)->fd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
      timeout = (time_t )((axel->conn + i)->last_transfer + (axel->conf)->connection_timeout);
      tmp___10 = axel_gettime();
      if (tmp___10 > (double )timeout) {
        if ((axel->conf)->verbose) {
          tmp___9 = dcgettext((char const   *)((void *)0), "Connection %i timed out",
                              5);
          axel_message(axel, (char const   *)tmp___9, i);
        }
        conn_disconnect(axel->conn + i);
      }
      goto next_conn;
    }
    tmp___11 = axel_gettime();
    (axel->conn + i)->last_transfer = (int )tmp___11;
    size = tcp_read((axel->conn + i)->tcp, (void *)buffer, (axel->conf)->buffer_size);
    if (size == -1L) {
      if ((axel->conf)->verbose) {
        tmp___12 = dcgettext((char const   *)((void *)0), "Error on connection %i! Connection closed",
                             5);
        axel_message(axel, (char const   *)tmp___12, i);
      }
      conn_disconnect(axel->conn + i);
      goto next_conn;
    }
    if (size == 0L) {
      if ((axel->conf)->verbose) {
        if ((axel->conn + i)->currentbyte < (axel->conn + i)->lastbyte) {
          if ((long long )axel->size != 9223372036854775807LL) {
            tmp___13 = dcgettext((char const   *)((void *)0), "Connection %i unexpectedly closed",
                                 5);
            axel_message(axel, (char const   *)tmp___13, i);
          } else {
            tmp___14 = dcgettext((char const   *)((void *)0), "Connection %i finished",
                                 5);
            axel_message(axel, (char const   *)tmp___14, i);
          }
        } else {
          tmp___14 = dcgettext((char const   *)((void *)0), "Connection %i finished",
                               5);
          axel_message(axel, (char const   *)tmp___14, i);
        }
      }
      if (! (axel->conn + 0)->supported) {
        axel->ready = 1;
      }
      conn_disconnect(axel->conn + i);
      reactivate_connection(axel, i);
      goto next_conn;
    }
    remaining = (axel->conn + i)->lastbyte - (axel->conn + i)->currentbyte;
    if (remaining < size) {
      if ((axel->conf)->verbose) {
        tmp___15 = dcgettext((char const   *)((void *)0), "Connection %i finished",
                             5);
        axel_message(axel, (char const   *)tmp___15, i);
      }
      conn_disconnect(axel->conn + i);
      size = remaining;
    }
    lseek(axel->outfd, (axel->conn + i)->currentbyte, 0);
    tmp___17 = write(axel->outfd, (void const   *)buffer, (size_t )size);
    if (tmp___17 != size) {
      tmp___16 = dcgettext((char const   *)((void *)0), "Write error!", 5);
      axel_message(axel, (char const   *)tmp___16);
      axel->ready = -1;
      pthread_mutex_unlock(& (axel->conn + i)->lock);
      return;
    }
    (axel->conn + i)->currentbyte += size;
    axel->bytes_done += size;
    if (remaining == size) {
      reactivate_connection(axel, i);
    }
    next_conn: 
    pthread_mutex_unlock(& (axel->conn + i)->lock);
    __Cont: /* CIL Label */ 
    i ++;
  }
  if (axel->ready) {
    return;
  }
  conn_check: 
  url_ptr = axel->url;
  i = 0;
  while (i < (int )(axel->conf)->num_connections) {
    tmp___18 = pthread_mutex_trylock(& (axel->conn + i)->lock);
    if (tmp___18) {
      goto __Cont___0;
    }
    if (! (axel->conn + i)->enabled) {
      if ((axel->conn + i)->currentbyte < (axel->conn + i)->lastbyte) {
        if (! (axel->conn + i)->state) {
          pthread_join((axel->conn + i)->setup_thread[0], (void **)((void *)0));
          conn_set(axel->conn + i, (char const   *)(url_ptr->text));
          url_ptr = (url_t *)url_ptr->next;
          if ((axel->conf)->verbose >= 2) {
            tmp___19 = dcgettext((char const   *)((void *)0), "Connection %i downloading from %s:%i using interface %s",
                                 5);
            axel_message(axel, (char const   *)tmp___19, i, (axel->conn + i)->host,
                         (axel->conn + i)->port, (axel->conn + i)->local_if);
          }
          (axel->conn + i)->state = (_Bool)1;
          tmp___22 = pthread_create((pthread_t * __restrict  )((axel->conn + i)->setup_thread),
                                    (pthread_attr_t const   * __restrict  )((void *)0),
                                    & setup_thread, (void * __restrict  )(axel->conn + i));
          if (tmp___22 == 0) {
            tmp___20 = axel_gettime();
            (axel->conn + i)->last_transfer = (int )tmp___20;
          } else {
            tmp___21 = dcgettext((char const   *)((void *)0), "pthread error!!!",
                                 5);
            axel_message(axel, (char const   *)tmp___21);
            axel->ready = -1;
          }
        } else {
          tmp___23 = axel_gettime();
          if (tmp___23 > (double )((axel->conn + i)->last_transfer + (axel->conf)->reconnect_delay)) {
            pthread_cancel((axel->conn + i)->setup_thread[0]);
            (axel->conn + i)->state = (_Bool)0;
            pthread_join((axel->conn + i)->setup_thread[0], (void **)((void *)0));
          }
        }
      }
    }
    pthread_mutex_unlock(& (axel->conn + i)->lock);
    __Cont___0: /* CIL Label */ 
    i ++;
  }
  tmp___24 = axel_gettime();
  axel->bytes_per_second = (long long )((off_t )((double )(axel->bytes_done - axel->start_byte) / (tmp___24 - axel->start_time)));
  if (axel->bytes_per_second != 0LL) {
    axel->finish_time = (int )(axel->start_time + (double )(axel->size - axel->start_byte) / (double )axel->bytes_per_second);
  } else {
    axel->finish_time = 2147483647;
  }
  if ((axel->conf)->max_speed > 0ULL) {
    max_speed_ratio = (unsigned long long )(1000LL * axel->bytes_per_second) / (axel->conf)->max_speed;
    if (max_speed_ratio > 1050ULL) {
      axel->delay_time.tv_nsec += 10000000L;
      if (axel->delay_time.tv_nsec >= 1000000000L) {
        (axel->delay_time.tv_sec) ++;
        axel->delay_time.tv_nsec -= 1000000000L;
      }
    } else
    if (max_speed_ratio < 950ULL) {
      if (axel->delay_time.tv_nsec >= 10000000L) {
        axel->delay_time.tv_nsec -= 10000000L;
      } else
      if (axel->delay_time.tv_sec > 0L) {
        (axel->delay_time.tv_sec) --;
        axel->delay_time.tv_nsec += 999000000L;
      } else {
        axel->delay_time.tv_sec = (__time_t )0;
        axel->delay_time.tv_nsec = (__syscall_slong_t )0;
      }
    }
    tmp___28 = axel_sleep(axel->delay_time);
    if (tmp___28 < 0) {
      tmp___25 = __errno_location();
      tmp___26 = strerror(*tmp___25);
      tmp___27 = dcgettext((char const   *)((void *)0), "Error while enforcing throttling: %s",
                           5);
      axel_message(axel, (char const   *)tmp___27, tmp___26);
      axel->ready = -1;
      return;
    }
  }
  if (axel->bytes_done == axel->size) {
    axel->ready = 1;
  }
  return;
}
}
void axel_close(axel_t *axel ) 
{ 
  int i ;

  {
  if (! axel) {
    return;
  }
  i = 0;
  while (i < (int )(axel->conf)->num_connections) {
    if ((axel->conn + i)->setup_thread[0] != 0UL) {
      pthread_cancel((axel->conn + i)->setup_thread[0]);
      pthread_join((axel->conn + i)->setup_thread[0], (void **)((void *)0));
    }
    conn_disconnect(axel->conn + i);
    i ++;
  }
  free((void *)axel->url);
  if (axel->ready == 1) {
    stfile_unlink((char const   *)(axel->filename));
  } else
  if (axel->bytes_done > 0L) {
    save_state(axel);
  }
  print_messages(axel);
  close(axel->outfd);
  if (! (((axel->conn)->proto & (1 << 1)) == 0)) {
    abuf_setup((axel->conn)->http[0].request, (size_t )0);
    abuf_setup((axel->conn)->http[0].headers, (size_t )0);
  } else
  if ((axel->conn)->proxy) {
    abuf_setup((axel->conn)->http[0].request, (size_t )0);
    abuf_setup((axel->conn)->http[0].headers, (size_t )0);
  }
  free((void *)axel->conn);
  free((void *)axel);
  free((void *)buffer);
  return;
}
}
double axel_gettime(void) 
{ 
  struct timeval time___0[1] ;

  {
  gettimeofday((struct timeval * __restrict  )(time___0), (void * __restrict  )((void *)0));
  return ((double )time___0[0].tv_sec + (double )time___0[0].tv_usec / (double )1000000);
}
}
static void save_state(axel_t *axel ) 
{ 
  int fd ;
  ssize_t nwrite ;
  int i ;

  {
  if (! (axel->conn + 0)->supported) {
    return;
  }
  fd = stfile_open((char const   *)(axel->filename), 577, (mode_t )438);
  if (fd == -1) {
    return;
  }
  nwrite = write(fd, (void const   *)(& (axel->conf)->num_connections), sizeof((axel->conf)->num_connections));
  nwrite = write(fd, (void const   *)(& axel->bytes_done), sizeof(axel->bytes_done));
  i = 0;
  while (i < (int )(axel->conf)->num_connections) {
    nwrite = write(fd, (void const   *)(& (axel->conn + i)->currentbyte), sizeof((axel->conn + i)->currentbyte));
    nwrite = write(fd, (void const   *)(& (axel->conn + i)->lastbyte), sizeof((axel->conn + i)->lastbyte));
    i ++;
  }
  close(fd);
  return;
}
}
static void *setup_thread(void *c ) 
{ 
  conn_t *conn ;
  int oldstate ;
  double tmp ;
  double tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  conn = (conn_t *)c;
  pthread_setcancelstate(0, & oldstate);
  pthread_setcanceltype(1, & oldstate);
  pthread_mutex_lock(& conn->lock);
  tmp___2 = conn_setup(conn);
  if (tmp___2) {
    tmp = axel_gettime();
    conn->last_transfer = (int )tmp;
    tmp___1 = conn_exec(conn);
    if (tmp___1) {
      tmp___0 = axel_gettime();
      conn->last_transfer = (int )tmp___0;
      conn->enabled = (_Bool)1;
      goto out;
    }
  }
  conn_disconnect(conn);
  out: 
  conn->state = (_Bool)0;
  pthread_mutex_unlock(& conn->lock);
  return ((void *)0);
}
}
static void ( /* format attribute */  axel_message)(axel_t *axel , char const   *format 
                                                    , ...) 
{ 
  message_t *m ;
  va_list___0 params ;
  void *tmp ;
  message_t *tmp___0 ;

  {
  if (! axel) {
    goto nomem;
  }
  tmp = calloc((size_t )1, sizeof(message_t ));
  m = (message_t *)tmp;
  if (! m) {
    goto nomem;
  }
  __builtin_va_start(params, format);
  vsnprintf((char * __restrict  )(m->text), (size_t )1024, (char const   * __restrict  )format,
            params);
  __builtin_va_end(params);
  if ((unsigned long )axel->message == (unsigned long )((void *)0)) {
    tmp___0 = m;
    axel->last_message = tmp___0;
    axel->message = tmp___0;
  } else {
    (axel->last_message)->next = (void *)m;
    axel->last_message = m;
  }
  return;
  nomem: 
  print_messages(axel);
  __builtin_va_start(params, format);
  vprintf((char const   * __restrict  )format, params);
  __builtin_va_end(params);
  return;
}
}
static void axel_divide(axel_t *axel ) 
{ 
  off_t maxconns ;
  unsigned int __a ;
  off_t __b ;
  off_t tmp ;
  off_t seg_len ;
  char *tmp___0 ;
  conn_t *new_conn ;
  void *tmp___1 ;
  int i ;
  size_t tail ;

  {
  __a = 1U;
  __b = axel->size / 102400L;
  if ((off_t )__a > __b) {
    tmp = (off_t )__a;
  } else {
    tmp = __b;
  }
  maxconns = tmp;
  if (maxconns < (off_t )(axel->conf)->num_connections) {
    (axel->conf)->num_connections = (uint16_t )maxconns;
  }
  seg_len = axel->size / (off_t )(axel->conf)->num_connections;
  if (! seg_len) {
    tmp___0 = dcgettext((char const   *)((void *)0), "Too few bytes remaining, forcing a single connection\n",
                        5);
    printf((char const   * __restrict  )tmp___0);
    (axel->conf)->num_connections = (uint16_t )1;
    seg_len = axel->size;
    tmp___1 = realloc((void *)axel->conn, sizeof(*(axel->conn)));
    new_conn = (conn_t *)tmp___1;
    if (new_conn) {
      axel->conn = new_conn;
    }
  }
  i = 0;
  while (i < (int )(axel->conf)->num_connections) {
    (axel->conn + i)->currentbyte = seg_len * (off_t )i;
    (axel->conn + i)->lastbyte = seg_len * (off_t )i + seg_len;
    i ++;
  }
  tail = (size_t )(axel->size % seg_len);
  (axel->conn + ((int )(axel->conf)->num_connections - 1))->lastbyte = (off_t )((size_t )(axel->conn + ((int )(axel->conf)->num_connections - 1))->lastbyte + tail);
  return;
}
}
#pragma merger("0","/tmp/cil-35rsCP2c.i","-fno-strict-aliasing,-Wnested-externs,-Wmissing-prototypes,-Wstrict-prototypes,-Wdeclaration-after-statement,-Wimplicit-function-declaration,-Wold-style-definition,-Wjump-misses-init,-Wall,-Wextra,-Wundef,-Wwrite-strings,-Wpointer-arith,-Wmissing-declarations,-Wredundant-decls,-Wno-unused-parameter,-Wno-missing-field-initializers,-Wformat=2,-Wcast-align,-Wformat-nonliteral,-Wformat-security,-Wsign-compare,-Wstrict-aliasing,-Wshadow,-Winline,-Wpacked,-Wmissing-format-attribute,-Wmissing-noreturn,-Winit-self,-Wmissing-include-dirs,-Wunused-but-set-variable,-Warray-bounds,-Wreturn-type,-Wswitch-enum,-Wswitch-default,-Wduplicated-cond,-Wduplicated-branches,-Wlogical-op,-Wrestrict,-Wnull-dereference,-Wdouble-promotion,-Werror,-Wno-suggest-attribute=format,-Wno-error=unused-parameter,-Wno-error=missing-field-initializers,-Wno-declaration-after-statement,-Wno-error=cast-align,-Wno-error=inline,-pthread,-g,-O2")
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
int axel_sleep(struct timespec delay ) 
{ 
  int res ;
  int *tmp ;

  {
  while (1) {
    res = nanosleep((struct timespec  const  *)(& delay), & delay);
    if (res) {
      tmp = __errno_location();
      if (! (*tmp == 4)) {
        break;
      }
    } else {
      break;
    }
  }
  return (res);
}
}
#pragma merger("0","/tmp/cil-goxqH45G.i","-fno-strict-aliasing,-Wnested-externs,-Wmissing-prototypes,-Wstrict-prototypes,-Wdeclaration-after-statement,-Wimplicit-function-declaration,-Wold-style-definition,-Wjump-misses-init,-Wall,-Wextra,-Wundef,-Wwrite-strings,-Wpointer-arith,-Wmissing-declarations,-Wredundant-decls,-Wno-unused-parameter,-Wno-missing-field-initializers,-Wformat=2,-Wcast-align,-Wformat-nonliteral,-Wformat-security,-Wsign-compare,-Wstrict-aliasing,-Wshadow,-Winline,-Wpacked,-Wmissing-format-attribute,-Wmissing-noreturn,-Winit-self,-Wmissing-include-dirs,-Wunused-but-set-variable,-Warray-bounds,-Wreturn-type,-Wswitch-enum,-Wswitch-default,-Wduplicated-cond,-Wduplicated-branches,-Wlogical-op,-Wrestrict,-Wnull-dereference,-Wdouble-promotion,-Werror,-Wno-suggest-attribute=format,-Wno-error=unused-parameter,-Wno-error=missing-field-initializers,-Wno-declaration-after-statement,-Wno-error=cast-align,-Wno-error=inline,-pthread,-g,-O2")
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
extern int fclose(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...)  __asm__("__isoc99_sscanf")  ;
extern int ( /* format attribute */  vfscanf)(FILE * __restrict  __s , char const   * __restrict  __format ,
                                              __gnuc_va_list __arg )  __asm__("__isoc99_vfscanf")  ;
extern int fgetc(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__nonnull__(1))) strtoull)(char const   * __restrict  __nptr ,
                                                                                                    char ** __restrict  __endptr ,
                                                                                                    int __base ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) getenv)(char const   *__name ) ;
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcasecmp)(char const   *__s1 ,
                                                                                         char const   *__s2 )  __attribute__((__pure__)) ;
int conf_loadfile(conf_t *conf , char const   *file ) ;
int conf_init(conf_t *conf ) ;
void conf_free(conf_t *conf ) ;
__inline static void conf_hdr_make(char *dst , char const   *k , char const   *v ) 
{ 


  {
  snprintf((char * __restrict  )dst, sizeof(((conf_t *)0)->add_header[0]), (char const   * __restrict  )"%s: %s",
           k, v);
  return;
}
}
int get_if_ip(char *dst , size_t len , char const   *iface ) ;
int parse_interfaces(conf_t *conf , char *s ) ;
static int ( /* format attribute */  axel_fscanf)(FILE *fp , char const   *format 
                                                  , ...) 
{ 
  va_list___0 params ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  __builtin_va_start(params, format);
  ret = vfscanf((FILE * __restrict  )fp, (char const   * __restrict  )format, params);
  __builtin_va_end(params);
  if (ret == -1) {
    tmp = ferror(fp);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 1;
  }
  ret = tmp___0;
  if (! ret) {
    tmp___1 = __errno_location();
    tmp___2 = strerror(*tmp___1);
    tmp___3 = dcgettext((char const   *)((void *)0), "I/O error while reading config file: %s\n",
                        5);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___3, tmp___2);
  }
  return (ret);
}
}
static int parse_protocol(conf_t *conf , char const   *value ) 
{ 
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp___1 = strcasecmp(value, "ipv4");
  if (tmp___1 == 0) {
    conf->ai_family = (sa_family_t )2;
  } else {
    tmp___0 = strcasecmp(value, "ipv6");
    if (tmp___0 == 0) {
      conf->ai_family = (sa_family_t )10;
    } else {
      tmp = dcgettext((char const   *)((void *)0), "Unknown protocol %s\n", 5);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp, value);
      return (0);
    }
  }
  return (1);
}
}
int conf_loadfile(conf_t *conf , char const   *file ) 
{ 
  int line ;
  int ret ;
  FILE *fp ;
  char s[(size_t )1024] ;
  char key[(size_t )1024] ;
  char *tmp ;
  char *value ;
  void *dst ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int num ;
  int tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  char *tmp___33 ;
  int tmp___34 ;

  {
  line = 0;
  ret = 1;
  fp = fopen((char const   * __restrict  )file, (char const   * __restrict  )"r");
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    return (1);
  }
  while (1) {
    tmp___34 = feof(fp);
    if (tmp___34) {
      break;
    }
    value = (char *)((void *)0);
    line ++;
    s[0] = (char)0;
    ret = axel_fscanf(fp, "%100[^\n#]s", s);
    if (! ret) {
      break;
    }
    ret = axel_fscanf(fp, "%*[^\n]s");
    if (! ret) {
      break;
    }
    tmp___0 = fgetc(fp);
    if (tmp___0 != 10) {
      tmp___1 = feof(fp);
      if (! tmp___1) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Expected newline\n");
        goto error;
      }
    }
    tmp = strchr((char const   *)(s), '=');
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      continue;
    }
    sscanf((char const   * __restrict  )(s), (char const   * __restrict  )"%[^= \t]s",
           key);
    while (1) {
      tmp___2 = __ctype_b_loc();
      tmp ++;
      if (! ((int const   )*(*tmp___2 + (int )*tmp) & 8192)) {
        break;
      }
    }
    value = tmp;
    while (1) {
      if (*tmp) {
        tmp___3 = __ctype_b_loc();
        if ((int const   )*(*tmp___3 + (int )*tmp) & 8192) {
          break;
        }
      } else {
        break;
      }
      tmp ++;
    }
    *tmp = (char )'\000';
    tmp___6 = strcmp((char const   *)(key), "default_filename");
    if (tmp___6) {
      tmp___5 = strcmp((char const   *)(key), "http_proxy");
      if (tmp___5) {
        tmp___4 = strcmp((char const   *)(key), "no_proxy");
        if (tmp___4) {
          goto num_keys;
        } else {
          dst = (void *)(& conf->no_proxy);
        }
      } else {
        dst = (void *)(& conf->http_proxy);
      }
    } else {
      dst = (void *)(& conf->default_filename);
    }
    strlcpy((char *)dst, (char const   *)value, (size_t )1024);
    continue;
    num_keys: 
    tmp___22 = strcmp((char const   *)(key), "strip_cgi_parameters");
    if (tmp___22) {
      tmp___21 = strcmp((char const   *)(key), "save_state_interval");
      if (tmp___21) {
        tmp___20 = strcmp((char const   *)(key), "connection_timeout");
        if (tmp___20) {
          tmp___19 = strcmp((char const   *)(key), "reconnect_delay");
          if (tmp___19) {
            tmp___18 = strcmp((char const   *)(key), "max_redirect");
            if (tmp___18) {
              tmp___17 = strcmp((char const   *)(key), "buffer_size");
              if (tmp___17) {
                tmp___16 = strcmp((char const   *)(key), "max_speed");
                if (tmp___16) {
                  tmp___15 = strcmp((char const   *)(key), "verbose");
                  if (tmp___15) {
                    tmp___14 = strcmp((char const   *)(key), "alternate_output");
                    if (tmp___14) {
                      tmp___13 = strcmp((char const   *)(key), "percentage");
                      if (tmp___13) {
                        tmp___12 = strcmp((char const   *)(key), "insecure");
                        if (tmp___12) {
                          tmp___11 = strcmp((char const   *)(key), "no_clobber");
                          if (tmp___11) {
                            tmp___10 = strcmp((char const   *)(key), "search_timeout");
                            if (tmp___10) {
                              tmp___9 = strcmp((char const   *)(key), "search_threads");
                              if (tmp___9) {
                                tmp___8 = strcmp((char const   *)(key), "search_amount");
                                if (tmp___8) {
                                  tmp___7 = strcmp((char const   *)(key), "search_top");
                                  if (tmp___7) {
                                    goto long_num_keys;
                                  } else {
                                    dst = (void *)(& conf->search_top);
                                  }
                                } else {
                                  dst = (void *)(& conf->search_amount);
                                }
                              } else {
                                dst = (void *)(& conf->search_threads);
                              }
                            } else {
                              dst = (void *)(& conf->search_timeout);
                            }
                          } else {
                            dst = (void *)(& conf->no_clobber);
                          }
                        } else {
                          dst = (void *)(& conf->insecure);
                        }
                      } else {
                        dst = (void *)(& conf->percentage);
                      }
                    } else {
                      dst = (void *)(& conf->alternate_output);
                    }
                  } else {
                    dst = (void *)(& conf->verbose);
                  }
                } else {
                  dst = (void *)(& conf->max_speed);
                }
              } else {
                dst = (void *)(& conf->buffer_size);
              }
            } else {
              dst = (void *)(& conf->max_redirect);
            }
          } else {
            dst = (void *)(& conf->reconnect_delay);
          }
        } else {
          dst = (void *)(& conf->connection_timeout);
        }
      } else {
        dst = (void *)(& conf->save_state_interval);
      }
    } else {
      dst = (void *)(& conf->strip_cgi_parameters);
    }
    *((int *)dst) = atoi((char const   *)value);
    continue;
    long_num_keys: 
    tmp___23 = strcmp((char const   *)(key), "max_speed");
    if (tmp___23) {
      goto other_keys;
    } else {
      dst = (void *)(& conf->max_speed);
    }
    *((unsigned long long *)dst) = strtoull((char const   * __restrict  )value, (char ** __restrict  )((void *)0),
                                            10);
    continue;
    other_keys: 
    tmp___32 = strcmp((char const   *)(key), "speed_type");
    if (tmp___32 == 0) {
      continue;
    } else {
      tmp___31 = strcmp((char const   *)(key), "interfaces");
      if (tmp___31 == 0) {
        tmp___24 = parse_interfaces(conf, value);
        if (tmp___24) {
          continue;
        }
      } else {
        tmp___30 = strcmp((char const   *)(key), "use_protocol");
        if (tmp___30 == 0) {
          tmp___25 = parse_protocol(conf, (char const   *)value);
          if (tmp___25) {
            continue;
          }
        } else {
          tmp___29 = strcmp((char const   *)(key), "num_connections");
          if (tmp___29 == 0) {
            tmp___26 = atoi((char const   *)value);
            num = tmp___26;
            if (num <= 65535) {
              conf->num_connections = (uint16_t )num;
              continue;
            }
            tmp___27 = dcgettext((char const   *)((void *)0), "Requested too many connections, max is %i\n",
                                 5);
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___27,
                    65535);
          } else {
            tmp___28 = strcmp((char const   *)(key), "user_agent");
            if (! tmp___28) {
              conf_hdr_make(conf->add_header[0], "User-Agent", "Axel/2.17.11+gab2f84 (linux-gnu)");
              continue;
            }
          }
        }
      }
    }
    error: 
    tmp___33 = dcgettext((char const   *)((void *)0), "Error in %s line %i.\n", 5);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___33, file,
            line);
    ret = 0;
    break;
  }
  fclose(fp);
  return (ret);
}
}
int conf_init(conf_t *conf ) 
{ 
  char *s2 ;
  int i ;
  void *tmp ;
  int tmp___0 ;
  char s[(size_t )1024] ;
  int ret ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  memset((void *)conf, 0, sizeof(conf_t ));
  strlcpy(conf->default_filename, "default", sizeof(conf->default_filename));
  conf->http_proxy[0] = (char)0;
  conf->no_proxy[0] = (char)0;
  conf->strip_cgi_parameters = 1;
  conf->save_state_interval = 10;
  conf->connection_timeout = 45;
  conf->reconnect_delay = 20;
  conf->num_connections = (uint16_t )4;
  conf->max_redirect = 20;
  conf->io_timeout = 120U;
  conf->buffer_size = 5120;
  conf->max_speed = 0ULL;
  conf->verbose = 1;
  conf->insecure = 0;
  conf->no_clobber = 0;
  conf->search_timeout = 10;
  conf->search_threads = 3;
  conf->search_amount = 15;
  conf->search_top = 3;
  conf->ai_family = (sa_family_t )0;
  conf_hdr_make(conf->add_header[0], "User-Agent", "Axel/2.17.11+gab2f84 (linux-gnu)");
  conf->add_header_count = 1;
  tmp = calloc((size_t )1, sizeof(if_t ));
  conf->interfaces = (if_t *)tmp;
  if (! conf->interfaces) {
    return (0);
  }
  (conf->interfaces)->next = (void *)conf->interfaces;
  conf->alternate_output = isatty(1);
  s2 = getenv("http_proxy");
  if (s2) {
    strlcpy(conf->http_proxy, (char const   *)s2, sizeof(conf->http_proxy));
  } else {
    s2 = getenv("HTTP_PROXY");
    if (s2) {
      strlcpy(conf->http_proxy, (char const   *)s2, sizeof(conf->http_proxy));
    }
  }
  tmp___0 = conf_loadfile(conf, "/etc/axelrc");
  if (! tmp___0) {
    return (0);
  }
  s2 = getenv("HOME");
  if ((unsigned long )s2 != (unsigned long )((void *)0)) {
    ret = snprintf((char * __restrict  )(s), sizeof(s), (char const   * __restrict  )"%s/.axelrc",
                   s2);
    if (ret >= (int )sizeof(s)) {
      tmp___1 = dcgettext((char const   *)((void *)0), "HOME env variable too long\n",
                          5);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___1);
      return (0);
    }
    tmp___2 = conf_loadfile(conf, (char const   *)(s));
    if (! tmp___2) {
      return (0);
    }
  }
  i = 0;
  while (conf->no_proxy[i]) {
    if ((int )conf->no_proxy[i] == 44) {
      conf->no_proxy[i] = (char)0;
    }
    i ++;
  }
  conf->no_proxy[i + 1] = (char)0;
  return (1);
}
}
void conf_free(conf_t *conf ) 
{ 


  {
  free((void *)conf->interfaces);
  return;
}
}
int parse_interfaces(conf_t *conf , char *s ) 
{ 
  char *s2 ;
  if_t *iface ;
  if_t *i ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  iface = (if_t *)(conf->interfaces)->next;
  while ((unsigned long )iface != (unsigned long )conf->interfaces) {
    i = (if_t *)iface->next;
    free((void *)iface);
    iface = i;
  }
  free((void *)conf->interfaces);
  if (! *s) {
    tmp = calloc((size_t )1, sizeof(if_t ));
    conf->interfaces = (if_t *)tmp;
    if (! conf->interfaces) {
      return (0);
    }
    (conf->interfaces)->next = (void *)conf->interfaces;
    return (1);
  }
  tmp___0 = strlen((char const   *)s);
  *(s + (tmp___0 + 1UL)) = (char)0;
  tmp___1 = malloc(sizeof(if_t ));
  iface = (if_t *)tmp___1;
  conf->interfaces = iface;
  if (! conf->interfaces) {
    return (0);
  }
  while (1) {
    while (1) {
      if ((int )*s == 32) {
        goto _L;
      } else
      if ((int )*s == 9) {
        _L: /* CIL Label */ 
        if (! *s) {
          break;
        }
      } else {
        break;
      }
      s ++;
    }
    s2 = s;
    while (1) {
      if ((int )*s2 != 32) {
        if ((int )*s2 != 9) {
          if (! *s2) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      s2 ++;
    }
    *s2 = (char)0;
    if ((int )*s < 48) {
      get_if_ip(iface->text, sizeof(iface->text), (char const   *)s);
    } else
    if ((int )*s > 57) {
      get_if_ip(iface->text, sizeof(iface->text), (char const   *)s);
    } else {
      strlcpy(iface->text, (char const   *)s, sizeof(iface->text));
    }
    s = s2 + 1;
    if (*s) {
      iface->next = malloc(sizeof(if_t ));
      if (! iface->next) {
        return (0);
      }
      iface = (if_t *)iface->next;
    } else {
      iface->next = (void *)conf->interfaces;
      break;
    }
  }
  return (1);
}
}
#pragma merger("0","/tmp/cil-RgcpTDrX.i","-fno-strict-aliasing,-Wnested-externs,-Wmissing-prototypes,-Wstrict-prototypes,-Wdeclaration-after-statement,-Wimplicit-function-declaration,-Wold-style-definition,-Wjump-misses-init,-Wall,-Wextra,-Wundef,-Wwrite-strings,-Wpointer-arith,-Wmissing-declarations,-Wredundant-decls,-Wno-unused-parameter,-Wno-missing-field-initializers,-Wformat=2,-Wcast-align,-Wformat-nonliteral,-Wformat-security,-Wsign-compare,-Wstrict-aliasing,-Wshadow,-Winline,-Wpacked,-Wmissing-format-attribute,-Wmissing-noreturn,-Winit-self,-Wmissing-include-dirs,-Wunused-but-set-variable,-Warray-bounds,-Wreturn-type,-Wswitch-enum,-Wswitch-default,-Wduplicated-cond,-Wduplicated-branches,-Wlogical-op,-Wrestrict,-Wnull-dereference,-Wdouble-promotion,-Werror,-Wno-suggest-attribute=format,-Wno-error=unused-parameter,-Wno-error=missing-field-initializers,-Wno-declaration-after-statement,-Wno-error=cast-align,-Wno-error=inline,-pthread,-g,-O2")
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strrchr)(char const   *__s ,
                                                                                      int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strstr)(char const   *__haystack ,
                                                                                       char const   *__needle )  __attribute__((__pure__)) ;
int is_ipv6_addr(char const   *hostname ) ;
int ftp_connect(ftp_t *conn , int proto , char *host , int port , char *user , char *pass ,
                unsigned int io_timeout ) ;
void ftp_disconnect(ftp_t *conn ) ;
int ftp_wait(ftp_t *conn ) ;
int ( /* format attribute */  ftp_command)(ftp_t *conn , char const   *format  , ...) ;
int ftp_cwd(ftp_t *conn , char *cwd ) ;
int ftp_data(ftp_t *conn , unsigned int io_timeout ) ;
off_t ftp_size(ftp_t *conn , char *file , int maxredir , unsigned int io_timeout ) ;
int http_connect(http_t *conn , int proto , char *proxy , char *host , int port ,
                 char *user , char *pass , unsigned int io_timeout ) ;
void http_disconnect(http_t *conn ) ;
void http_get(http_t *conn , char *lurl ) ;
void ( /* format attribute */  http_addheader)(http_t *conn , char const   *format 
                                               , ...) ;
int http_exec(http_t *conn ) ;
char const   *http_header(http_t const   *conn , char const   *header ) ;
void http_filename(http_t const   *conn , char *filename ) ;
off_t http_size(http_t *conn ) ;
off_t http_size_from_range(http_t *conn ) ;
void http_encode(char *s , size_t len ) ;
__inline static int is_proto_http(int proto ) 
{ 


  {
  return ((proto & (1 << 1)) == 1 << 1);
}
}
char const   *scheme_from_proto(int proto ) ;
int conn_set(conn_t *conn , char const   *set_url ) 
{ 
  char url[(size_t )1024] ;
  char *i ;
  char *j ;
  int proto_len ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  i = strstr(set_url, "://");
  if ((unsigned long )i == (unsigned long )((void *)0)) {
    conn->proto = 1 << 1;
    conn->port = 80;
    strlcpy(url, set_url, sizeof(url));
  } else {
    proto_len = (int )(i - (char *)set_url);
    tmp___3 = strncmp(set_url, "ftp", (size_t )proto_len);
    if (tmp___3 == 0) {
      conn->proto = 0;
      conn->port = 21;
    } else {
      tmp___2 = strncmp(set_url, "http", (size_t )proto_len);
      if (tmp___2 == 0) {
        conn->proto = 1 << 1;
        conn->port = 80;
      } else {
        tmp___1 = strncmp(set_url, "ftps", (size_t )proto_len);
        if (tmp___1 == 0) {
          conn->proto = 1;
          conn->port = 990;
        } else {
          tmp___0 = strncmp(set_url, "https", (size_t )proto_len);
          if (tmp___0 == 0) {
            conn->proto = (1 << 1) | 1;
            conn->port = 443;
          } else {
            tmp = dcgettext((char const   *)((void *)0), "Unsupported protocol\n",
                            5);
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp);
            return (0);
          }
        }
      }
    }
    if ((conn->proto & 1) == 1) {
      tmp___4 = dcgettext((char const   *)((void *)0), "Secure protocol is not supported\n",
                          5);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___4);
      return (0);
    }
    strlcpy(url, (char const   *)(i + 3), sizeof(url));
  }
  i = strchr((char const   *)(url), '/');
  if ((unsigned long )i == (unsigned long )((void *)0)) {
    strcpy((char * __restrict  )(conn->dir), (char const   * __restrict  )"/");
  } else {
    *i = (char)0;
    snprintf((char * __restrict  )(conn->dir), (size_t )1024, (char const   * __restrict  )"/%s",
             i + 1);
    if (conn->proto == 1 << 1) {
      http_encode(conn->dir, sizeof(conn->dir));
    } else
    if (conn->proto == ((1 << 1) | 1)) {
      http_encode(conn->dir, sizeof(conn->dir));
    }
  }
  j = strchr((char const   *)(conn->dir), '?');
  if ((unsigned long )j != (unsigned long )((void *)0)) {
    *j = (char)0;
  }
  i = strrchr((char const   *)(conn->dir), '/');
  if ((unsigned long )i != (unsigned long )((void *)0)) {
    *i = (char)0;
  }
  if ((unsigned long )j != (unsigned long )((void *)0)) {
    *j = (char )'?';
  }
  if ((unsigned long )i == (unsigned long )((void *)0)) {
    strlcpy(conn->file, (char const   *)(conn->dir), sizeof(conn->file));
    strcpy((char * __restrict  )(conn->dir), (char const   * __restrict  )"/");
  } else {
    strlcpy(conn->file, (char const   *)(i + 1), sizeof(conn->file));
    strlcat(conn->dir, "/", sizeof(conn->dir));
  }
  tmp___6 = strrchr((char const   *)(url), '@');
  if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
    strlcpy(conn->user, (char const   *)(url), sizeof(conn->user));
    i = strrchr((char const   *)(conn->user), '@');
    *i = (char)0;
    strlcpy(url, (char const   *)(i + 1), sizeof(url));
    conn->pass[0] = (char)0;
  } else
  if ((conn->proto & (1 << 1)) == 0) {
    strcpy((char * __restrict  )(conn->user), (char const   * __restrict  )"anonymous");
    strcpy((char * __restrict  )(conn->pass), (char const   * __restrict  )"mailto:axel@axel.project");
  } else {
    tmp___5 = (char)0;
    conn->pass[0] = tmp___5;
    conn->user[0] = tmp___5;
  }
  i = strchr((char const   *)(conn->user), ':');
  if ((unsigned long )i != (unsigned long )((void *)0)) {
    *i = (char)0;
    strlcpy(conn->pass, (char const   *)(i + 1), sizeof(conn->pass));
  }
  if ((int )url[0] == 91) {
    strlcpy(conn->host, (char const   *)(url + 1), sizeof(conn->host));
    i = strrchr((char const   *)(conn->host), ']');
    if ((unsigned long )i != (unsigned long )((void *)0)) {
      tmp___7 = i;
      i ++;
      *tmp___7 = (char)0;
    } else {
      return (0);
    }
  } else {
    strlcpy(conn->host, (char const   *)(url), sizeof(conn->host));
    i = conn->host;
    while (1) {
      if (*i) {
        if (! ((int )*i != 58)) {
          break;
        }
      } else {
        break;
      }
      i ++;
    }
  }
  if ((int )*i == 58) {
    *i = (char)0;
    sscanf((char const   * __restrict  )(i + 1), (char const   * __restrict  )"%i",
           & conn->port);
    i = conn->host;
  }
  return (conn->port > 0);
}
}
char const   *scheme_from_proto(int proto ) 
{ 


  {
  switch (proto) {
  case 0: 
  return ("ftp://");
  case 1: 
  return ("ftps://");
  default: 
  return ("http://");
  case (1 << 1) | 1: 
  return ("https://");
  }
}
}
char *conn_url(char *dst , size_t len , conn_t *conn ) 
{ 
  char const   *prefix ;
  char const   *postfix ;
  char const   *scheme ;
  char const   *tmp ;
  size_t scheme_len ;
  size_t tmp___0 ;
  char *p ;
  int plen ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int plen___0 ;
  char *tmp___4 ;

  {
  prefix = "";
  postfix = "";
  tmp = scheme_from_proto(conn->proto);
  scheme = tmp;
  tmp___0 = strlcpy(dst, scheme, len);
  scheme_len = tmp___0;
  if (scheme_len > len) {
    return ((char *)((void *)0));
  }
  len -= scheme_len;
  p = dst + scheme_len;
  if ((int )conn->user[0] != 0) {
    tmp___2 = strcmp((char const   *)(conn->user), "anonymous");
    if (tmp___2 != 0) {
      tmp___1 = snprintf((char * __restrict  )p, len, (char const   * __restrict  )"%s:%s@",
                         conn->user, conn->pass);
      plen = tmp___1;
      if (plen < 0) {
        return ((char *)((void *)0));
      }
      len -= (size_t )plen;
      p += plen;
    }
  }
  tmp___3 = is_ipv6_addr((char const   *)(conn->host));
  if (tmp___3) {
    prefix = "[";
    postfix = "]";
  }
  plen___0 = snprintf((char * __restrict  )p, len, (char const   * __restrict  )"%s%s%s:%i%s%s",
                      prefix, conn->host, postfix, conn->port, conn->dir, conn->file);
  if (plen___0 < 0) {
    tmp___4 = (char *)((void *)0);
  } else {
    tmp___4 = dst;
  }
  return (tmp___4);
}
}
void conn_disconnect(conn_t *conn ) 
{ 


  {
  if ((conn->proto & (1 << 1)) == 0) {
    if (! conn->proxy) {
      ftp_disconnect(conn->ftp);
    } else {
      http_disconnect(conn->http);
    }
  } else {
    http_disconnect(conn->http);
  }
  conn->tcp = (tcp_t *)((void *)0);
  conn->enabled = (_Bool)0;
  return;
}
}
int conn_init(conn_t *conn ) 
{ 
  char *proxy ;
  char *host ;
  int i ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  proxy = (conn->conf)->http_proxy;
  host = (conn->conf)->no_proxy;
  if ((int )(conn->conf)->http_proxy[0] == 0) {
    proxy = (char *)((void *)0);
  } else
  if ((int )(conn->conf)->no_proxy[0] != 0) {
    i = 0;
    while (1) {
      if ((int )(conn->conf)->no_proxy[i] == 0) {
        tmp = strstr((char const   *)(conn->host), (char const   *)host);
        if ((unsigned long )tmp != (unsigned long )((void *)0)) {
          proxy = (char *)((void *)0);
        }
        host = & (conn->conf)->no_proxy[i + 1];
        if ((int )(conn->conf)->no_proxy[i + 1] == 0) {
          break;
        }
      }
      i ++;
    }
  }
  conn->proxy = (unsigned long )proxy != (unsigned long )((void *)0);
  if ((conn->proto & (1 << 1)) == 0) {
    if (! conn->proxy) {
      conn->ftp[0].local_if = conn->local_if;
      conn->ftp[0].ftp_mode = 1;
      conn->ftp[0].tcp.ai_family = (conn->conf)->ai_family;
      tmp___0 = ftp_connect(conn->ftp, conn->proto, conn->host, conn->port, conn->user,
                            conn->pass, (conn->conf)->io_timeout);
      if (! tmp___0) {
        conn->message = conn->ftp[0].message;
        conn_disconnect(conn);
        return (0);
      }
      conn->message = conn->ftp[0].message;
      tmp___1 = ftp_cwd(conn->ftp, conn->dir);
      if (! tmp___1) {
        conn_disconnect(conn);
        return (0);
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    conn->http[0].local_if = conn->local_if;
    conn->http[0].tcp.ai_family = (conn->conf)->ai_family;
    tmp___2 = http_connect(conn->http, conn->proto, proxy, conn->host, conn->port,
                           conn->user, conn->pass, (conn->conf)->io_timeout);
    if (! tmp___2) {
      conn->message = conn->http[0].headers[0].p;
      conn_disconnect(conn);
      return (0);
    }
    conn->message = conn->http[0].headers[0].p;
    conn->tcp = & conn->http[0].tcp;
  }
  return (1);
}
}
int conn_setup(conn_t *conn ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char s[2048UL] ;
  int i ;

  {
  if (conn->ftp[0].tcp.fd <= 0) {
    if (conn->http[0].tcp.fd <= 0) {
      tmp = conn_init(conn);
      if (! tmp) {
        return (0);
      }
    }
  }
  if ((conn->proto & (1 << 1)) == 0) {
    if (! conn->proxy) {
      tmp___0 = ftp_data(conn->ftp, (conn->conf)->io_timeout);
      if (! tmp___0) {
        return (0);
      }
      conn->tcp = & conn->ftp[0].data_tcp;
      if (conn->currentbyte) {
        ftp_command(conn->ftp, "REST %jd", conn->currentbyte);
        tmp___1 = ftp_wait(conn->ftp);
        if (tmp___1 / 100 != 3) {
          if (conn->ftp[0].status / 100 != 2) {
            return (0);
          }
        }
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    snprintf((char * __restrict  )(s), sizeof(s), (char const   * __restrict  )"%s%s",
             conn->dir, conn->file);
    if (conn->supported) {
      conn->http[0].firstbyte = conn->currentbyte;
    } else {
      conn->http[0].firstbyte = (off_t )-1;
    }
    conn->http[0].lastbyte = conn->lastbyte;
    abuf_setup(conn->http[0].request, (size_t )2048);
    http_get(conn->http, s);
    i = 0;
    while (i < (conn->conf)->add_header_count) {
      http_addheader(conn->http, "%s", (conn->conf)->add_header[i]);
      i ++;
    }
  }
  return (1);
}
}
int conn_exec(conn_t *conn ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if ((conn->proto & (1 << 1)) == 0) {
    if (! conn->proxy) {
      tmp = ftp_command(conn->ftp, "RETR %s", conn->file);
      if (! tmp) {
        return (0);
      }
      tmp___0 = ftp_wait(conn->ftp);
      return (tmp___0 / 100 == 1);
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    abuf_setup(conn->http[0].headers, (size_t )1024);
    tmp___1 = http_exec(conn->http);
    if (! tmp___1) {
      return (0);
    }
    return (conn->http[0].status / 100 == 2);
  }
}
}
static int conn_info_ftp(conn_t *conn ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  ftp_command(conn->ftp, "REST %d", 1);
  tmp = ftp_wait(conn->ftp);
  if (tmp / 100 == 3) {
    conn->supported = (_Bool)1;
    ftp_command(conn->ftp, "REST %d", 0);
    ftp_wait(conn->ftp);
  } else
  if (conn->ftp[0].status / 100 == 2) {
    conn->supported = (_Bool)1;
    ftp_command(conn->ftp, "REST %d", 0);
    ftp_wait(conn->ftp);
  } else {
    conn->supported = (_Bool)0;
  }
  tmp___0 = ftp_cwd(conn->ftp, conn->dir);
  if (! tmp___0) {
    return (0);
  }
  conn->size = ftp_size(conn->ftp, conn->file, (conn->conf)->max_redirect, (conn->conf)->io_timeout);
  if (conn->size < 0L) {
    conn->supported = (_Bool)0;
  }
  if (conn->size == -1L) {
    return (0);
  } else
  if (conn->size == -2L) {
    conn->size = (off_t )9223372036854775807LL;
  }
  return (1);
}
}
int conn_info(conn_t *conn ) 
{ 
  int tmp ;
  char s[1005] ;
  long long i ;
  char const   *t ;
  int setup_ret ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  off_t __a ;
  off_t __b ;
  off_t tmp___6 ;
  off_t tmp___7 ;

  {
  if ((conn->proto & (1 << 1)) == 0) {
    if (! conn->proxy) {
      tmp = conn_info_ftp(conn);
      return (tmp);
    }
  }
  i = 0LL;
  while (1) {
    conn->supported = (_Bool)1;
    conn->currentbyte = (off_t )0;
    pthread_mutex_lock(& conn->lock);
    tmp___0 = conn_setup(conn);
    setup_ret = tmp___0;
    pthread_mutex_unlock(& conn->lock);
    if (! setup_ret) {
      return (0);
    }
    conn_exec(conn);
    conn_disconnect(conn);
    http_filename((http_t const   *)(conn->http), conn->output_filename);
    if (conn->http[0].status / 100 != 3) {
      break;
    }
    t = http_header((http_t const   *)(conn->http), "location:");
    if ((unsigned long )t == (unsigned long )((void *)0)) {
      return (0);
    }
    sscanf((char const   * __restrict  )t, (char const   * __restrict  )"%1000s",
           s);
    if ((int )s[0] == 47) {
      tmp___1 = scheme_from_proto(conn->proto);
      abuf_printf(conn->http[0].headers, "%s%s:%i%s", tmp___1, conn->host, conn->port,
                  s);
      strlcpy(s, (char const   *)conn->http[0].headers[0].p, sizeof(s));
    } else {
      tmp___2 = strstr((char const   *)(s), "://");
      if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
        conn_url(conn->http[0].headers[0].p, conn->http[0].headers[0].len, conn);
        strlcat(conn->http[0].headers[0].p, (char const   *)(s), conn->http[0].headers[0].len);
        strlcpy(s, (char const   *)conn->http[0].headers[0].p, sizeof(s));
      }
    }
    tmp___3 = conn_set(conn, (char const   *)(s));
    if (! tmp___3) {
      return (0);
    }
    if ((conn->proto & (1 << 1)) == 0) {
      if (! conn->proxy) {
        return (-1);
      }
    }
    i ++;
    if (i >= (long long )(conn->conf)->max_redirect) {
      tmp___4 = dcgettext((char const   *)((void *)0), "Too many redirects.\n", 5);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___4);
      return (0);
    }
    if (! (conn->http[0].status / 100 == 3)) {
      break;
    }
  }
  if (conn->http[0].status != 416) {
    if (conn->http[0].status / 100 != 2) {
      return (0);
    }
  }
  conn->size = http_size_from_range(conn->http);
  if (conn->http[0].status == 206) {
    tmp___5 = 1;
  } else
  if (conn->size > 0L) {
    tmp___5 = 1;
  } else {
    tmp___5 = 0;
  }
  conn->supported = (_Bool )tmp___5;
  if (conn->size <= 0L) {
    switch (conn->http[0].status) {
    case 416: 
    case 200: 
    conn->supported = (_Bool)0;
    case 206: 
    break;
    default: 
    return (0);
    }
  }
  __a = conn->size;
  tmp___6 = http_size(conn->http);
  __b = tmp___6;
  if (__a > __b) {
    tmp___7 = __a;
  } else {
    tmp___7 = __b;
  }
  conn->size = tmp___7;
  if (conn->size <= 0L) {
    conn->size = (off_t )9223372036854775807LL;
    conn->supported = (_Bool)0;
  }
  return (1);
}
}
int conn_info_status_get(char *msg , size_t size , conn_t *conn ) 
{ 
  char *p ;
  char *tmp ;
  char *tmp___0 ;
  size_t len ;
  size_t tmp___1 ;
  size_t __a ;
  size_t __b ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
  tmp___3 = is_proto_http(conn->proto);
  if (tmp___3) {
    p = conn->http[0].headers[0].p;
    while (1) {
      tmp = p;
      p ++;
      if (! ((int )*tmp != 32)) {
        break;
      }
    }
    while (1) {
      tmp___0 = p;
      p ++;
      if (! ((int )*tmp___0 != 32)) {
        break;
      }
    }
    tmp___1 = strcspn((char const   *)p, "\r\n");
    len = tmp___1;
    if (len) {
      __a = len + 1UL;
      __b = size;
      if (__a < __b) {
        tmp___2 = __a;
      } else {
        tmp___2 = __b;
      }
      strlcpy(msg, (char const   *)p, tmp___2);
      return (conn->http[0].status);
    }
  }
  tmp___4 = dcgettext((char const   *)((void *)0), "Unknown Error", 5);
  strlcpy(msg, (char const   *)tmp___4, size);
  return (-1);
}
}
#pragma merger("0","/tmp/cil-0T4SySoy.i","-fno-strict-aliasing,-Wnested-externs,-Wmissing-prototypes,-Wstrict-prototypes,-Wdeclaration-after-statement,-Wimplicit-function-declaration,-Wold-style-definition,-Wjump-misses-init,-Wall,-Wextra,-Wundef,-Wwrite-strings,-Wpointer-arith,-Wmissing-declarations,-Wredundant-decls,-Wno-unused-parameter,-Wno-missing-field-initializers,-Wformat=2,-Wcast-align,-Wformat-nonliteral,-Wformat-security,-Wsign-compare,-Wstrict-aliasing,-Wshadow,-Winline,-Wpacked,-Wmissing-format-attribute,-Wmissing-noreturn,-Winit-self,-Wmissing-include-dirs,-Wunused-but-set-variable,-Warray-bounds,-Wreturn-type,-Wswitch-enum,-Wswitch-default,-Wduplicated-cond,-Wduplicated-branches,-Wlogical-op,-Wrestrict,-Wnull-dereference,-Wdouble-promotion,-Werror,-Wno-suggest-attribute=format,-Wno-error=unused-parameter,-Wno-error=missing-field-initializers,-Wno-declaration-after-statement,-Wno-error=cast-align,-Wno-error=inline,-pthread,-g,-O2")
int tcp_connect(tcp_t *tcp , char *hostname , int port , int secure , char *local_if ,
                unsigned int io_timeout ) ;
void tcp_close(tcp_t *tcp ) ;
ssize_t tcp_write(tcp_t *tcp , void *buffer___0 , int size ) ;
int ftp_connect(ftp_t *conn , int proto , char *host , int port , char *user , char *pass ,
                unsigned int io_timeout ) 
{ 
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  conn->data_tcp.fd = -1;
  tmp = malloc((size_t )1024);
  conn->message = (char *)tmp;
  if (! conn->message) {
    return (0);
  }
  conn->proto = proto;
  tmp___0 = tcp_connect(& conn->tcp, host, port, (conn->proto & 1) == 1, conn->local_if,
                        io_timeout);
  if (tmp___0 == -1) {
    return (0);
  }
  tmp___1 = ftp_wait(conn);
  if (tmp___1 / 100 != 2) {
    return (0);
  }
  ftp_command(conn, "USER %s", user);
  tmp___3 = ftp_wait(conn);
  if (tmp___3 / 100 != 2) {
    if (conn->status / 100 == 3) {
      ftp_command(conn, "PASS %s", pass);
      tmp___2 = ftp_wait(conn);
      if (tmp___2 / 100 != 2) {
        return (0);
      }
    } else {
      return (0);
    }
  }
  ftp_command(conn, "TYPE I");
  tmp___4 = ftp_wait(conn);
  if (tmp___4 / 100 != 2) {
    return (0);
  }
  return (1);
}
}
void ftp_disconnect(ftp_t *conn ) 
{ 


  {
  tcp_close(& conn->tcp);
  tcp_close(& conn->data_tcp);
  if (conn->message) {
    free((void *)conn->message);
    conn->message = (char *)((void *)0);
  }
  conn->cwd[0] = (char)0;
  return;
}
}
int ftp_cwd(ftp_t *conn , char *cwd ) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  tmp = strncmp((char const   *)(conn->cwd), (char const   *)cwd, (size_t )1024);
  if (tmp == 0) {
    return (1);
  }
  ftp_command(conn, "CWD %s", cwd);
  tmp___1 = ftp_wait(conn);
  if (tmp___1 / 100 != 2) {
    tmp___0 = dcgettext((char const   *)((void *)0), "Can\'t change directory to %s\n",
                        5);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___0, cwd);
    return (0);
  }
  strlcpy(conn->cwd, (char const   *)cwd, sizeof(conn->cwd));
  return (1);
}
}
off_t ftp_size(ftp_t *conn , char *file , int maxredir , unsigned int io_timeout ) 
{ 
  off_t i ;
  off_t j ;
  off_t size ;
  char *reply ;
  char *s ;
  char fn[(size_t )1024] ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  off_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
  size = (off_t )((size_t )1024);
  tmp___1 = strchr((char const   *)file, '*');
  if (! tmp___1) {
    tmp___2 = strchr((char const   *)file, '?');
    if (! tmp___2) {
      ftp_command(conn, "SIZE %s", file);
      tmp___0 = ftp_wait(conn);
      if (tmp___0 / 100 == 2) {
        sscanf((char const   * __restrict  )conn->message, (char const   * __restrict  )"%*i %jd",
               & i);
        return (i);
      } else
      if (conn->status / 10 != 50) {
        tmp = dcgettext((char const   *)((void *)0), "File not found.\n", 5);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp);
        return ((off_t )-1);
      }
    }
  }
  if (maxredir == 0) {
    tmp___3 = dcgettext((char const   *)((void *)0), "Too many redirects.\n", 5);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___3);
    return ((off_t )-1);
  }
  tmp___4 = ftp_data(conn, io_timeout);
  if (! tmp___4) {
    return ((off_t )-1);
  }
  ftp_command(conn, "LIST %s", file);
  tmp___5 = ftp_wait(conn);
  if (tmp___5 / 100 != 1) {
    return ((off_t )-1);
  }
  tmp___6 = calloc((size_t )1, (size_t )size);
  reply = (char *)tmp___6;
  if (! reply) {
    return ((off_t )-1);
  }
  *reply = (char )'\n';
  i = (off_t )1;
  while (1) {
    j = tcp_read(& conn->data_tcp, (void *)(reply + i), (int )((size - i) - 3L));
    if (! (j > 0L)) {
      break;
    }
    i += j;
    *(reply + i) = (char)0;
    if (size - i <= 10L) {
      size *= 2L;
      tmp___8 = realloc((void *)reply, (size_t )size);
      tmp___7 = (char *)tmp___8;
      if (! tmp___7) {
        free((void *)reply);
        return ((off_t )-1);
      }
      reply = tmp___7;
      memset((void *)(reply + size / 2L), 0, (size_t )(size / 2L));
    }
  }
  tcp_close(& conn->data_tcp);
  tmp___9 = ftp_wait(conn);
  if (tmp___9 / 100 != 2) {
    free((void *)reply);
    return ((off_t )-1);
  }
  j = (off_t )0;
  i = (off_t )1;
  while (1) {
    if (*(reply + i)) {
      if (! *(reply + (i + 1L))) {
        break;
      }
    } else {
      break;
    }
    if ((int )*(reply + i) == 45) {
      j ++;
    } else
    if ((int )*(reply + i) == 108) {
      j ++;
    } else {
      while (1) {
        if ((int )*(reply + i) != 10) {
          if (! *(reply + i)) {
            break;
          }
        } else {
          break;
        }
        i ++;
      }
    }
    i ++;
  }
  if (j != 1L) {
    if (j == 0L) {
      tmp___10 = dcgettext((char const   *)((void *)0), "File not found.\n", 5);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___10);
    } else {
      tmp___11 = dcgettext((char const   *)((void *)0), "Multiple matches for this URL.\n",
                           5);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___11);
    }
    free((void *)reply);
    return ((off_t )-1);
  }
  s = strstr((char const   *)reply, "\nl");
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    sscanf((char const   * __restrict  )s, (char const   * __restrict  )"%*s %*i %*s %*s %*i %*s %*i %*s %100s",
           fn);
    strcpy((char * __restrict  )file, (char const   * __restrict  )(fn));
    tmp___12 = strstr((char const   *)s, "->");
    strlcpy(fn, (char const   *)(tmp___12 + 3), sizeof(fn));
    fn[sizeof(fn) - 1UL] = (char )'\000';
    free((void *)reply);
    reply = strchr((char const   *)(fn), '\r');
    if ((unsigned long )reply != (unsigned long )((void *)0)) {
      *reply = (char)0;
    }
    reply = strchr((char const   *)(fn), '\n');
    if ((unsigned long )reply != (unsigned long )((void *)0)) {
      *reply = (char)0;
    }
    tmp___13 = ftp_size(conn, fn, maxredir - 1, io_timeout);
    return (tmp___13);
  } else {
    s = strstr((char const   *)reply, "\n-");
    tmp___14 = sscanf((char const   * __restrict  )s, (char const   * __restrict  )"%*s %*i %*s %*s %jd %*s %*i %*s %100s",
                      & size, fn);
    i = (off_t )tmp___14;
    if (i < 2L) {
      tmp___15 = sscanf((char const   * __restrict  )s, (char const   * __restrict  )"%*s %*i %jd %*i %*s %*i %*i %100s",
                        & size, fn);
      i = (off_t )tmp___15;
      if (i < 2L) {
        return ((off_t )-2);
      }
    }
    strcpy((char * __restrict  )file, (char const   * __restrict  )(fn));
    free((void *)reply);
    return (size);
  }
}
}
int ftp_data(ftp_t *conn , unsigned int io_timeout ) 
{ 
  int i ;
  int info[6] ;
  char host[(size_t )1024] ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  if (conn->data_tcp.fd > 0) {
    return (0);
  }
  ftp_command(conn, "PASV");
  tmp = ftp_wait(conn);
  if (tmp / 100 != 2) {
    return (0);
  }
  host[0] = (char)0;
  i = 0;
  while (*(conn->message + i)) {
    tmp___0 = sscanf((char const   * __restrict  )(conn->message + i), (char const   * __restrict  )"%i,%i,%i,%i,%i,%i",
                     & info[0], & info[1], & info[2], & info[3], & info[4], & info[5]);
    if (tmp___0 == 6) {
      snprintf((char * __restrict  )(host), sizeof(host), (char const   * __restrict  )"%i.%i.%i.%i",
               info[0], info[1], info[2], info[3]);
      break;
    }
    i ++;
  }
  if (! host[0]) {
    tmp___1 = dcgettext((char const   *)((void *)0), "Error opening passive data connection.\n",
                        5);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___1);
    return (0);
  }
  tmp___2 = tcp_connect(& conn->data_tcp, host, info[4] * 256 + info[5], (conn->proto & 1) == 1,
                        conn->local_if, io_timeout);
  if (tmp___2 == -1) {
    return (0);
  }
  return (1);
}
}
int ( /* format attribute */  ftp_command)(ftp_t *conn , char const   *format  , ...) 
{ 
  va_list___0 params ;
  char cmd[(size_t )1024] ;
  char *tmp ;
  size_t tmp___0 ;
  ssize_t tmp___1 ;
  size_t tmp___2 ;

  {
  __builtin_va_start(params, format);
  vsnprintf((char * __restrict  )(cmd), sizeof(cmd) - 3UL, (char const   * __restrict  )format,
            params);
  strlcat(cmd, "\r\n", sizeof(cmd));
  __builtin_va_end(params);
  tmp___0 = strlen((char const   *)(cmd));
  tmp___1 = tcp_write(& conn->tcp, (void *)(cmd), (int )tmp___0);
  tmp___2 = strlen((char const   *)(cmd));
  if (tmp___1 != (ssize_t )tmp___2) {
    tmp = dcgettext((char const   *)((void *)0), "Error writing command %s\n", 5);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp, cmd);
    return (0);
  } else {
    return (1);
  }
}
}
int ftp_wait(ftp_t *conn ) 
{ 
  int size ;
  int r ;
  int complete ;
  int i ;
  int j ;
  void *new_msg ;
  void *tmp ;
  ssize_t tmp___0 ;
  char *tmp___1 ;
  void *new_msg___0 ;
  void *tmp___2 ;
  int k ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
  size = (int )((size_t )1024);
  r = 0;
  tmp = realloc((void *)conn->message, (size_t )size);
  new_msg = tmp;
  if (! new_msg) {
    return (-1);
  }
  conn->message = (char *)new_msg;
  while (1) {
    while (1) {
      tmp___0 = tcp_read(& conn->tcp, (void *)(conn->message + r), 1);
      i = (int )tmp___0;
      r += i;
      if (i <= 0) {
        tmp___1 = dcgettext((char const   *)((void *)0), "Connection gone.\n", 5);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___1);
        return (-1);
      }
      if (r + 10 >= size) {
        size = (int )((size_t )size + 1024UL);
        tmp___2 = realloc((void *)conn->message, (size_t )size);
        new_msg___0 = tmp___2;
        if (! new_msg___0) {
          return (-1);
        }
        conn->message = (char *)new_msg___0;
      }
      if (! ((int )*(conn->message + (r - 1)) != 10)) {
        break;
      }
    }
    *(conn->message + r) = (char)0;
    sscanf((char const   * __restrict  )conn->message, (char const   * __restrict  )"%i",
           & conn->status);
    if ((int )*(conn->message + 3) == 32) {
      complete = 1;
    } else {
      complete = 0;
    }
    i = 0;
    while (*(conn->message + i)) {
      if ((int )*(conn->message + i) == 10) {
        if (complete == 1) {
          complete = 2;
          break;
        }
        if ((int )*(conn->message + (i + 4)) == 32) {
          j = -1;
          sscanf((char const   * __restrict  )(conn->message + (i + 1)), (char const   * __restrict  )"%3i",
                 & j);
          if (j == conn->status) {
            complete = 1;
          }
        }
      }
      i ++;
    }
    if (! (complete != 2)) {
      break;
    }
  }
  tmp___3 = strcspn((char const   *)conn->message, "\r\n");
  k = (int )tmp___3;
  *(conn->message + k) = (char)0;
  tmp___4 = realloc((void *)conn->message, (size_t )(k + 1));
  conn->message = (char *)tmp___4;
  return (conn->status);
}
}
#pragma merger("0","/tmp/cil-B4fy7znR.i","-fno-strict-aliasing,-Wnested-externs,-Wmissing-prototypes,-Wstrict-prototypes,-Wdeclaration-after-statement,-Wimplicit-function-declaration,-Wold-style-definition,-Wjump-misses-init,-Wall,-Wextra,-Wundef,-Wwrite-strings,-Wpointer-arith,-Wmissing-declarations,-Wredundant-decls,-Wno-unused-parameter,-Wno-missing-field-initializers,-Wformat=2,-Wcast-align,-Wformat-nonliteral,-Wformat-security,-Wsign-compare,-Wstrict-aliasing,-Wshadow,-Winline,-Wpacked,-Wmissing-format-attribute,-Wmissing-noreturn,-Winit-self,-Wmissing-include-dirs,-Wunused-but-set-variable,-Warray-bounds,-Wreturn-type,-Wswitch-enum,-Wswitch-default,-Wduplicated-cond,-Wduplicated-branches,-Wlogical-op,-Wrestrict,-Wnull-dereference,-Wdouble-promotion,-Werror,-Wno-suggest-attribute=format,-Wno-error=unused-parameter,-Wno-error=missing-field-initializers,-Wno-declaration-after-statement,-Wno-error=cast-align,-Wno-error=inline,-pthread,-g,-O2")
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2))) strspn)(char const   *__s ,
                                                                                        char const   *__accept )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strpbrk)(char const   *__s ,
                                                                                        char const   *__accept )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncasecmp)(char const   *__s1 ,
                                                                                          char const   *__s2 ,
                                                                                          size_t __n )  __attribute__((__pure__)) ;
__inline static int is_default_port(int proto , int port ) 
{ 
  int tmp ;

  {
  if (proto == 1 << 1) {
    if (port == 80) {
      tmp = 1;
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (proto == ((1 << 1) | 1)) {
    if (port == 443) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
__inline static char chain_next(char const   ***p ) 
{ 
  char const   *tmp ;
  int tmp___0 ;

  {
  while (1) {
    if (*(*p)) {
      if (! (! *(*(*p)))) {
        break;
      }
    } else {
      break;
    }
    (*p) ++;
  }
  if (*(*p)) {
    tmp = *(*p);
    (*(*p)) ++;
    tmp___0 = (int const   )*tmp;
  } else {
    tmp___0 = (int const   )0;
  }
  return ((char )tmp___0);
}
}
static void http_auth_token(char *token , char const   *user , char const   *pass ) 
{ 
  char base64_encode[64] ;
  char const   *auth[4] ;
  char const   **p ;
  char a ;
  char tmp ;
  char *tmp___0 ;
  char b ;
  char tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char c ;
  char tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
  base64_encode[0] = (char )'A';
  base64_encode[1] = (char )'B';
  base64_encode[2] = (char )'C';
  base64_encode[3] = (char )'D';
  base64_encode[4] = (char )'E';
  base64_encode[5] = (char )'F';
  base64_encode[6] = (char )'G';
  base64_encode[7] = (char )'H';
  base64_encode[8] = (char )'I';
  base64_encode[9] = (char )'J';
  base64_encode[10] = (char )'K';
  base64_encode[11] = (char )'L';
  base64_encode[12] = (char )'M';
  base64_encode[13] = (char )'N';
  base64_encode[14] = (char )'O';
  base64_encode[15] = (char )'P';
  base64_encode[16] = (char )'Q';
  base64_encode[17] = (char )'R';
  base64_encode[18] = (char )'S';
  base64_encode[19] = (char )'T';
  base64_encode[20] = (char )'U';
  base64_encode[21] = (char )'V';
  base64_encode[22] = (char )'W';
  base64_encode[23] = (char )'X';
  base64_encode[24] = (char )'Y';
  base64_encode[25] = (char )'Z';
  base64_encode[26] = (char )'a';
  base64_encode[27] = (char )'b';
  base64_encode[28] = (char )'c';
  base64_encode[29] = (char )'d';
  base64_encode[30] = (char )'e';
  base64_encode[31] = (char )'f';
  base64_encode[32] = (char )'g';
  base64_encode[33] = (char )'h';
  base64_encode[34] = (char )'i';
  base64_encode[35] = (char )'j';
  base64_encode[36] = (char )'k';
  base64_encode[37] = (char )'l';
  base64_encode[38] = (char )'m';
  base64_encode[39] = (char )'n';
  base64_encode[40] = (char )'o';
  base64_encode[41] = (char )'p';
  base64_encode[42] = (char )'q';
  base64_encode[43] = (char )'r';
  base64_encode[44] = (char )'s';
  base64_encode[45] = (char )'t';
  base64_encode[46] = (char )'u';
  base64_encode[47] = (char )'v';
  base64_encode[48] = (char )'w';
  base64_encode[49] = (char )'x';
  base64_encode[50] = (char )'y';
  base64_encode[51] = (char )'z';
  base64_encode[52] = (char )'0';
  base64_encode[53] = (char )'1';
  base64_encode[54] = (char )'2';
  base64_encode[55] = (char )'3';
  base64_encode[56] = (char )'4';
  base64_encode[57] = (char )'5';
  base64_encode[58] = (char )'6';
  base64_encode[59] = (char )'7';
  base64_encode[60] = (char )'8';
  base64_encode[61] = (char )'9';
  base64_encode[62] = (char )'+';
  base64_encode[63] = (char )'/';
  auth[0] = user;
  auth[1] = ":";
  auth[2] = pass;
  auth[3] = (char const   *)((void *)0);
  p = auth;
  while (*p) {
    tmp = chain_next(& p);
    a = tmp;
    if (! a) {
      break;
    }
    tmp___0 = token;
    token ++;
    *tmp___0 = base64_encode[(int )a >> 2];
    tmp___1 = chain_next(& p);
    b = tmp___1;
    tmp___2 = token;
    token ++;
    *tmp___2 = base64_encode[(((int )a & 3) << 4) | ((int )b >> 4)];
    if (! b) {
      tmp___3 = token;
      token ++;
      *tmp___3 = (char )'=';
      tmp___4 = token;
      token ++;
      *tmp___4 = (char )'=';
      break;
    } else {
      tmp___5 = chain_next(& p);
      c = tmp___5;
      tmp___6 = token;
      token ++;
      *tmp___6 = base64_encode[(((int )b & 15) << 2) | ((int )c >> 6)];
      if (! c) {
        tmp___7 = token;
        token ++;
        *tmp___7 = (char )'=';
        break;
      } else {
        tmp___8 = token;
        token ++;
        *tmp___8 = base64_encode[(int )c & 63];
      }
    }
  }
  return;
}
}
int http_connect(http_t *conn , int proto , char *proxy , char *host , int port ,
                 char *user , char *pass , unsigned int io_timeout ) 
{ 
  char const   *puser ;
  char const   *ppass ;
  conn_t tconn[1] ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  puser = (char const   *)((void *)0);
  ppass = "";
  strlcpy(conn->host, (char const   *)host, sizeof(conn->host));
  conn->port = port;
  conn->proto = proto;
  if (proxy) {
    if (*proxy) {
      tmp___0 = conn_set(tconn, (char const   *)proxy);
      if (! tmp___0) {
        tmp = dcgettext((char const   *)((void *)0), "Invalid proxy string: %s\n",
                        5);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp, proxy);
        return (0);
      }
      host = tconn[0].host;
      port = tconn[0].port;
      proto = tconn[0].proto;
      puser = (char const   *)(tconn[0].user);
      ppass = (char const   *)(tconn[0].pass);
      conn->proxy = 1;
    }
  }
  tmp___1 = tcp_connect(& conn->tcp, host, port, (proto & 1) == 1, conn->local_if,
                        io_timeout);
  if (tmp___1 == -1) {
    return (0);
  }
  if ((int )*user == 0) {
    conn->auth[0] = (char)0;
  } else {
    http_auth_token(conn->auth, (char const   *)user, (char const   *)pass);
  }
  if (! conn->proxy) {
    conn->proxy_auth[0] = (char)0;
  } else
  if (! puser) {
    conn->proxy_auth[0] = (char)0;
  } else
  if ((int const   )*puser == 0) {
    conn->proxy_auth[0] = (char)0;
  } else {
    http_auth_token(conn->proxy_auth, puser, ppass);
  }
  return (1);
}
}
void http_disconnect(http_t *conn ) 
{ 


  {
  tcp_close(& conn->tcp);
  return;
}
}
void http_get(http_t *conn , char *lurl ) 
{ 
  char const   *prefix ;
  char const   *postfix ;
  int tmp ;
  char const   *proto ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  prefix = "";
  postfix = "";
  tmp = is_ipv6_addr((char const   *)(conn->host));
  if (tmp) {
    prefix = "[";
    postfix = "]";
  }
  *(conn->request[0].p) = (char)0;
  if (conn->proxy) {
    tmp___0 = scheme_from_proto(conn->proto);
    proto = tmp___0;
    tmp___1 = is_default_port(conn->proto, conn->port);
    if (tmp___1) {
      http_addheader(conn, "GET %s%s%s%s%s HTTP/1.0", proto, prefix, conn->host, postfix,
                     lurl);
    } else {
      http_addheader(conn, "GET %s%s%s%s:%i%s HTTP/1.0", proto, prefix, conn->host,
                     postfix, conn->port, lurl);
    }
  } else {
    http_addheader(conn, "GET %s HTTP/1.0", lurl);
    tmp___2 = is_default_port(conn->proto, conn->port);
    if (tmp___2) {
      http_addheader(conn, "Host: %s%s%s", prefix, conn->host, postfix);
    } else {
      http_addheader(conn, "Host: %s%s%s:%i", prefix, conn->host, postfix, conn->port);
    }
  }
  if (conn->auth[0]) {
    http_addheader(conn, "Authorization: Basic %s", conn->auth);
  }
  if (conn->proxy_auth[0]) {
    http_addheader(conn, "Proxy-Authorization: Basic %s", conn->proxy_auth);
  }
  http_addheader(conn, "Accept: */*");
  http_addheader(conn, "Accept-Encoding: identity");
  if (conn->lastbyte) {
    if (conn->firstbyte >= 0L) {
      http_addheader(conn, "Range: bytes=%jd-%jd", conn->firstbyte, conn->lastbyte - 1L);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
  if (conn->firstbyte >= 0L) {
    http_addheader(conn, "Range: bytes=%jd-", conn->firstbyte);
  }
  return;
}
}
void ( /* format attribute */  http_addheader)(http_t *conn , char const   *format 
                                               , ...) 
{ 
  char s[(size_t )1024] ;
  va_list___0 params ;
  int tmp ;

  {
  __builtin_va_start(params, format);
  vsnprintf((char * __restrict  )(s), sizeof(s) - 3UL, (char const   * __restrict  )format,
            params);
  strlcat(s, "\r\n", sizeof(s));
  __builtin_va_end(params);
  tmp = abuf_strcat(conn->request, (char const   *)(s));
  if (tmp < 0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Out of memory\n");
  }
  return;
}
}
int http_exec(http_t *conn ) 
{ 
  char *s2 ;
  size_t reqlen ;
  size_t tmp ;
  size_t nwrite ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *s ;
  char *tmp___4 ;
  ssize_t tmp___5 ;
  size_t pos ;
  int tmp___6 ;
  int tmp___7 ;
  size_t reslen ;
  int ret ;
  int tmp___8 ;

  {
  strlcat(conn->request[0].p, "\r\n", conn->request[0].len);
  tmp = strlen((char const   *)conn->request[0].p);
  reqlen = tmp;
  nwrite = (size_t )0;
  while (nwrite < reqlen) {
    tmp___0 = tcp_write(& conn->tcp, (void *)(conn->request[0].p + nwrite), (int )(reqlen - nwrite));
    if (tmp___0 < 0L) {
      tmp___1 = __errno_location();
      if (*tmp___1 == 4) {
        continue;
      } else {
        tmp___2 = __errno_location();
        if (*tmp___2 == 11) {
          continue;
        }
      }
      tmp___3 = dcgettext((char const   *)((void *)0), "Connection gone while writing.\n",
                          5);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___3);
      return (0);
    }
    nwrite += (size_t )tmp___0;
  }
  *(conn->headers[0].p) = (char)0;
  s = conn->headers[0].p;
  while (1) {
    tmp___5 = tcp_read(& conn->tcp, (void *)s, 1);
    if (tmp___5 <= 0L) {
      tmp___4 = dcgettext((char const   *)((void *)0), "Connection gone.\n", 5);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___4);
      return (0);
    }
    if ((int )*s == 13) {
      goto __Cont;
    } else
    if ((int )*s == 10) {
      if ((unsigned long )s > (unsigned long )conn->headers[0].p) {
        if ((int )*(s + -1) == 10) {
          *s = (char)0;
          break;
        }
      }
    }
    s ++;
    pos = (size_t )(s - conn->headers[0].p);
    if (pos + 10UL < conn->headers[0].len) {
      tmp___7 = abuf_setup(conn->headers, conn->headers[0].len + 512UL);
      tmp___6 = tmp___7;
      if (tmp___6 < 0) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Out of memory\n");
        return (0);
      }
      s = conn->headers[0].p + pos;
    }
    __Cont: /* CIL Label */ ;
  }
  sscanf((char const   * __restrict  )conn->headers[0].p, (char const   * __restrict  )"%*s %3i",
         & conn->status);
  s2 = strchr((char const   *)conn->headers[0].p, '\n');
  if (s2) {
    *s2 = (char)0;
  }
  reslen = (size_t )((s2 - conn->headers[0].p) + 1L);
  if (conn->request[0].len < reqlen) {
    tmp___8 = abuf_setup(conn->request, reslen);
    ret = tmp___8;
    if (ret < 0) {
      return (0);
    }
  }
  memcpy((void * __restrict  )conn->request[0].p, (void const   * __restrict  )conn->headers[0].p,
         reslen);
  *s2 = (char )'\n';
  return (1);
}
}
char const   *http_header(http_t const   *conn , char const   *header ) 
{ 
  char const   *p ;
  size_t hlen ;
  size_t tmp ;
  int tmp___0 ;

  {
  p = (char const   *)conn->headers[0].p;
  tmp = strlen(header);
  hlen = tmp;
  while (1) {
    tmp___0 = strncasecmp(p, header, hlen);
    if (tmp___0 == 0) {
      return (p + hlen);
    }
    while (1) {
      if ((int const   )*p != 10) {
        if (! *p) {
          break;
        }
      } else {
        break;
      }
      p ++;
    }
    if ((int const   )*p == 10) {
      p ++;
    }
    if (! *p) {
      break;
    }
  }
  return ((char const   *)((void *)0));
}
}
off_t http_size(http_t *conn ) 
{ 
  char const   *i ;
  off_t j ;

  {
  i = http_header((http_t const   *)conn, "Content-Length:");
  if ((unsigned long )i == (unsigned long )((void *)0)) {
    return ((off_t )-2);
  }
  sscanf((char const   * __restrict  )i, (char const   * __restrict  )"%jd", & j);
  return (j);
}
}
off_t http_size_from_range(http_t *conn ) 
{ 
  char const   *i ;
  char *tmp ;
  char const   *tmp___0 ;
  off_t j ;
  long long tmp___1 ;

  {
  i = http_header((http_t const   *)conn, "Content-Range:");
  if ((unsigned long )i == (unsigned long )((void *)0)) {
    return ((off_t )-2);
  }
  tmp = strchr(i, '/');
  i = (char const   *)tmp;
  tmp___0 = i;
  i ++;
  if (! tmp___0) {
    return ((off_t )-2);
  }
  tmp___1 = strtoll((char const   * __restrict  )i, (char ** __restrict  )((void *)0),
                    10);
  j = (off_t )tmp___1;
  if (! j) {
    if ((int const   )*i != 48) {
      return ((off_t )-3);
    }
  }
  return (j);
}
}
void http_filename(http_t const   *conn , char *filename ) 
{ 
  char const   *h ;
  char space[3] ;
  char *n ;
  char *p ;
  size_t tmp ;
  char invalid[10] ;
  char replacement ;
  char *i ;

  {
  h = http_header(conn, "Content-Disposition:");
  if ((unsigned long )h != (unsigned long )((void *)0)) {
    sscanf((char const   * __restrict  )h, (char const   * __restrict  )"%*s%*[ \t]filename%*[ \t=\"\'-]%254[^\n\"\']",
           filename);
    space[0] = (char )'\t';
    space[1] = (char )' ';
    space[2] = (char )'\000';
    p = filename;
    while (1) {
      p = strpbrk((char const   *)p, (char const   *)(space));
      if (! p) {
        break;
      }
      tmp = strspn((char const   *)p, (char const   *)(space));
      n = p + tmp;
      if (! *n) {
        *p = (char)0;
        break;
      }
      p = n;
    }
    invalid[0] = (char )'/';
    invalid[1] = (char )'\\';
    invalid[2] = (char )'?';
    invalid[3] = (char )'%';
    invalid[4] = (char )'*';
    invalid[5] = (char )':';
    invalid[6] = (char )'|';
    invalid[7] = (char )'<';
    invalid[8] = (char )'>';
    invalid[9] = (char )'\000';
    replacement = (char )'_';
    i = filename;
    while (1) {
      i = strpbrk((char const   *)i, (char const   *)(invalid));
      if (! i) {
        break;
      }
      *i = replacement;
      i ++;
    }
  }
  return;
}
}
__inline static char decode_nibble(char n ) 
{ 


  {
  if ((int )n <= 57) {
    return ((char )((int )n - 48));
  }
  if ((int )n >= 97) {
    n = (char )((int )n - 32);
  }
  return ((char )(((int )n - 65) + 10));
}
}
__inline static char encode_nibble(char n ) 
{ 
  int tmp ;

  {
  if ((int )n > 9) {
    tmp = ((int )n + 97) - 10;
  } else {
    tmp = (int )n + 48;
  }
  return ((char )tmp);
}
}
__inline static void encode_byte(char *dst , char n ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  tmp = dst;
  dst ++;
  *tmp = (char )'%';
  tmp___0 = dst;
  dst ++;
  *tmp___0 = encode_nibble((char )((int )n >> 4));
  *dst = encode_nibble((char )((int )n & 15));
  return;
}
}
void http_decode(char *s ) 
{ 
  char *p ;
  char *tmp ;
  char tmp___0 ;
  char tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  while (1) {
    if (*s) {
      if (! ((int )*s != 37)) {
        break;
      }
    } else {
      break;
    }
    s ++;
  }
  if (! *s) {
    return;
  }
  p = s;
  while (1) {
    if (! *(s + 1)) {
      break;
    } else
    if (! *(s + 2)) {
      break;
    }
    tmp = p;
    p ++;
    tmp___0 = decode_nibble(*(s + 1));
    tmp___1 = decode_nibble(*(s + 2));
    *tmp = (char )(((int )tmp___0 << 4) | (int )tmp___1);
    s += 3;
    while (1) {
      if (*s) {
        if (! ((int )*s != 37)) {
          break;
        }
      } else {
        break;
      }
      tmp___2 = p;
      p ++;
      tmp___3 = s;
      s ++;
      *tmp___2 = *tmp___3;
    }
    if (! ((int )*s == 37)) {
      break;
    }
  }
  *p = (char)0;
  return;
}
}
void http_encode(char *s , size_t len ) 
{ 
  char t[(size_t )1024] ;
  unsigned int i ;
  unsigned int j ;

  {
  j = 0U;
  i = j;
  while (1) {
    if (*(s + i)) {
      if (! ((unsigned long )j < sizeof(t) - 1UL)) {
        break;
      }
    } else {
      break;
    }
    t[j] = *(s + i);
    if ((int )*(s + i) <= 32) {
      goto _L;
    } else
    if ((int )*(s + i) >= 127) {
      _L: /* CIL Label */ 
      if ((unsigned long )j >= sizeof(t) - 3UL) {
        break;
      }
      encode_byte((char *)(t + j), *(s + i));
      j += 2U;
    }
    i ++;
    j ++;
  }
  t[j] = (char)0;
  strlcpy(s, (char const   *)(t), len);
  return;
}
}
#pragma merger("0","/tmp/cil-uLIIzeAi.i","-fno-strict-aliasing,-Wnested-externs,-Wmissing-prototypes,-Wstrict-prototypes,-Wdeclaration-after-statement,-Wimplicit-function-declaration,-Wold-style-definition,-Wjump-misses-init,-Wall,-Wextra,-Wundef,-Wwrite-strings,-Wpointer-arith,-Wmissing-declarations,-Wredundant-decls,-Wno-unused-parameter,-Wno-missing-field-initializers,-Wformat=2,-Wcast-align,-Wformat-nonliteral,-Wformat-security,-Wsign-compare,-Wstrict-aliasing,-Wshadow,-Winline,-Wpacked,-Wmissing-format-attribute,-Wmissing-noreturn,-Winit-self,-Wmissing-include-dirs,-Wunused-but-set-variable,-Warray-bounds,-Wreturn-type,-Wswitch-enum,-Wswitch-default,-Wduplicated-cond,-Wduplicated-branches,-Wlogical-op,-Wrestrict,-Wnull-dereference,-Wdouble-promotion,-Werror,-Wno-suggest-attribute=format,-Wno-error=unused-parameter,-Wno-error=missing-field-initializers,-Wno-declaration-after-statement,-Wno-error=cast-align,-Wno-error=inline,-pthread,-g,-O2")
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
int search_makelist(search_t *results , char *orig_url ) ;
int search_getspeeds(search_t *results , int count ) ;
void search_sortlist(search_t *results , int count ) ;
static void *search_speedtest(void *r ) ;
static int search_sortlist_qsort(void const   *a , void const   *b ) ;
int search_makelist(search_t *results , char *orig_url ) 
{ 
  int size ;
  conn_t conn[1] ;
  double t ;
  char const   *start ;
  char const   *end ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t orig_len ;
  size_t tmp___2 ;
  double tmp___3 ;
  int nresults ;
  char *s ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int j ;
  int i ;
  char *tmp___9 ;
  void *tmp___10 ;
  ssize_t tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char const   *url ;
  char const   *eol ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;

  {
  size = 8192;
  memset((void *)(conn), 0, sizeof(conn_t ));
  conn[0].conf = results->conf;
  t = axel_gettime();
  tmp = conn_set(conn, (char const   *)orig_url);
  if (tmp) {
    tmp___0 = conn_init(conn);
    if (tmp___0) {
      tmp___1 = conn_info(conn);
      if (! tmp___1) {
        return (-1);
      }
    } else {
      return (-1);
    }
  } else {
    return (-1);
  }
  tmp___2 = strlcpy((results + 0)->url, (char const   *)orig_url, sizeof((results + 0)->url));
  orig_len = tmp___2;
  tmp___3 = axel_gettime();
  (results + 0)->speed = (off_t )((double )1 + (double )1000 * (tmp___3 - t));
  (results + 0)->size = conn[0].size;
  nresults = 1;
  tmp___4 = malloc((size_t )size);
  s = (char *)tmp___4;
  if (! s) {
    return (1);
  }
  snprintf((char * __restrict  )s, (size_t )size, (char const   * __restrict  )"http://www.filesearching.com/cgi-bin/s?w=a&x=15&y=15&s=on&e=on&l=en&t=f&o=n&q=%s&m=%i&s1=%jd&s2=%jd",
           conn[0].file, (results->conf)->search_amount, conn[0].size, conn[0].size);
  conn_disconnect(conn);
  memset((void *)(conn), 0, sizeof(conn_t ));
  conn[0].conf = results->conf;
  tmp___5 = conn_set(conn, (char const   *)s);
  if (! tmp___5) {
    goto done;
  }
  pthread_mutex_lock(& conn[0].lock);
  tmp___7 = conn_setup(conn);
  tmp___6 = tmp___7;
  pthread_mutex_unlock(& conn[0].lock);
  if (! tmp___6) {
    goto done;
  } else {
    tmp___8 = conn_exec(conn);
    if (! tmp___8) {
      goto done;
    }
  }
  j = 0;
  while (1) {
    tmp___11 = tcp_read(conn[0].tcp, (void *)(s + j), size - j);
    i = (int )tmp___11;
    if (! (i > 0)) {
      break;
    }
    j += i;
    if (j + 10 >= size) {
      size *= 2;
      tmp___10 = realloc((void *)s, (size_t )size);
      tmp___9 = (char *)tmp___10;
      if (! tmp___9) {
        goto done;
      }
      s = tmp___9;
      memset((void *)(s + size / 2), 0, (size_t )(size / 2));
    }
  }
  *(s + j) = (char )'\000';
  conn_disconnect(conn);
  tmp___12 = strstr((char const   *)s, "<pre class=list");
  start = (char const   *)tmp___12;
  if (! start) {
    goto done;
  }
  tmp___13 = strstr(start, "</pre>");
  end = (char const   *)tmp___13;
  if (! end) {
    goto done;
  }
  while (1) {
    if ((unsigned long )start < (unsigned long )end) {
      if (! (nresults < (results->conf)->search_amount)) {
        break;
      }
    } else {
      break;
    }
    tmp___14 = strchr(start, '\n');
    eol = (char const   *)tmp___14;
    if ((unsigned long )eol > (unsigned long )end) {
      eol = end;
    } else
    if (! eol) {
      eol = end;
    }
    while (1) {
      url = start;
      tmp___15 = strstr(start, "<a href=");
      start = (char const   *)(tmp___15 + 8);
      if (! ((unsigned long )start < (unsigned long )eol)) {
        break;
      }
    }
    tmp___16 = strncmp(url, (char const   *)orig_url, orig_len);
    if (! tmp___16) {
      goto __Cont;
    }
    strlcpy((results + nresults)->url, url, sizeof((results + 0)->url));
    (results + nresults)->size = (results + 0)->size;
    (results + nresults)->conf = results->conf;
    nresults ++;
    __Cont: /* CIL Label */ 
    start = eol + 1;
  }
  done: 
  free((void *)s);
  return (nresults);
}
}
int search_getspeeds(search_t *results , int count ) 
{ 
  struct timespec delay ;
  int left ;
  int correct ;
  int i ;
  int running ;
  int i___0 ;
  double tmp ;
  int tmp___0 ;

  {
  delay.tv_sec = 0L;
  delay.tv_nsec = (__syscall_slong_t )10000000;
  left = count;
  correct = 0;
  i = 0;
  while (i < count) {
    if ((results + i)->speed) {
      (results + i)->speed_start_time = (double )0;
      left --;
      if ((results + i)->speed > 0L) {
        correct ++;
      }
    }
    i ++;
  }
  running = 0;
  while (left > 0) {
    i___0 = 0;
    while (i___0 < count) {
      switch ((results + i___0)->speed) {
      case -3L: 
      tmp = axel_gettime();
      if (tmp < (results + i___0)->speed_start_time + (double )(results->conf)->search_timeout) {
        goto __Cont;
      }
      pthread_cancel((results + i___0)->speed_thread[0]);
      break;
      case -2L: 
      break;
      case -1L: 
      goto __Cont;
      case 0L: 
      if (running >= (results->conf)->search_threads) {
        goto __Cont;
      }
      (results + i___0)->speed = (off_t )-3;
      (results + i___0)->speed_start_time = axel_gettime();
      tmp___0 = pthread_create((pthread_t * __restrict  )((results + i___0)->speed_thread),
                               (pthread_attr_t const   * __restrict  )((void *)0),
                               & search_speedtest, (void * __restrict  )(results + i___0));
      if (tmp___0 == 0) {
        running ++;
      } else {
        (results + i___0)->speed = (off_t )0;
      }
      goto __Cont;
      default: 
      if (! (results + i___0)->speed_start_time) {
        goto __Cont;
      }
      }
      pthread_join((results + i___0)->speed_thread[0], (void **)((void *)0));
      running --;
      left --;
      switch ((results + i___0)->speed) {
      case -2L: 
      case -3L: 
      (results + i___0)->speed = (off_t )-1;
      break;
      default: 
      (results + i___0)->speed_start_time = (double )0;
      if ((results + i___0)->speed > 0L) {
        correct ++;
      }
      }
      __Cont: /* CIL Label */ 
      i___0 ++;
    }
    axel_sleep(delay);
  }
  return (correct);
}
}
static void *search_speedtest(void *r ) 
{ 
  search_t *results ;
  conn_t conn[1] ;
  int oldstate ;
  double tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  results = (search_t *)r;
  pthread_setcancelstate(0, & oldstate);
  pthread_setcanceltype(1, & oldstate);
  memset((void *)(conn), 0, sizeof(conn_t ));
  conn[0].conf = results->conf;
  tmp___0 = conn_set(conn, (char const   *)(results->url));
  if (tmp___0) {
    tmp___1 = conn_init(conn);
    if (tmp___1) {
      tmp___2 = conn_info(conn);
      if (tmp___2) {
        if (conn[0].size == results->size) {
          tmp = axel_gettime();
          results->speed = (off_t )((double )1 + (double )1000 * (tmp - results->speed_start_time));
        } else {
          results->speed = (off_t )-2;
        }
      } else {
        results->speed = (off_t )-2;
      }
    } else {
      results->speed = (off_t )-2;
    }
  } else {
    results->speed = (off_t )-2;
  }
  conn_disconnect(conn);
  return ((void *)0);
}
}
void search_sortlist(search_t *results , int count ) 
{ 


  {
  qsort((void *)results, (size_t )count, sizeof(search_t ), & search_sortlist_qsort);
  return;
}
}
static int search_sortlist_qsort(void const   *a , void const   *b ) 
{ 


  {
  if (((search_t *)a)->speed < 0L) {
    if (((search_t *)b)->speed > 0L) {
      return (1);
    }
  }
  if (((search_t *)a)->speed > 0L) {
    if (((search_t *)b)->speed < 0L) {
      return (-1);
    }
  }
  if (((search_t *)a)->speed < ((search_t *)b)->speed) {
    return (-1);
  } else {
    return (((search_t *)a)->speed > ((search_t *)b)->speed);
  }
}
}
#pragma merger("0","/tmp/cil-ajf84bkQ.i","-fno-strict-aliasing,-Wnested-externs,-Wmissing-prototypes,-Wstrict-prototypes,-Wdeclaration-after-statement,-Wimplicit-function-declaration,-Wold-style-definition,-Wjump-misses-init,-Wall,-Wextra,-Wundef,-Wwrite-strings,-Wpointer-arith,-Wmissing-declarations,-Wredundant-decls,-Wno-unused-parameter,-Wno-missing-field-initializers,-Wformat=2,-Wcast-align,-Wformat-nonliteral,-Wformat-security,-Wsign-compare,-Wstrict-aliasing,-Wshadow,-Winline,-Wpacked,-Wmissing-format-attribute,-Wmissing-noreturn,-Winit-self,-Wmissing-include-dirs,-Wunused-but-set-variable,-Warray-bounds,-Wreturn-type,-Wswitch-enum,-Wswitch-default,-Wduplicated-cond,-Wduplicated-branches,-Wlogical-op,-Wrestrict,-Wnull-dereference,-Wdouble-promotion,-Werror,-Wno-suggest-attribute=format,-Wno-error=unused-parameter,-Wno-error=missing-field-initializers,-Wno-declaration-after-statement,-Wno-error=cast-align,-Wno-error=inline,-pthread,-g,-O2")
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  * __restrict  __addr ,
                                              socklen_t __len ) ;
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
extern  __attribute__((__nothrow__)) char const   *gai_strerror(int __ecode ) ;
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
extern int fcntl(int __fd , int __cmd  , ...) ;
extern  __attribute__((__nothrow__)) in_addr_t inet_addr(char const   *__cp ) ;
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
extern  __attribute__((__nothrow__)) int inet_pton(int __af , char const   * __restrict  __cp ,
                                                   void * __restrict  __buf ) ;
int is_ipv6_addr(char const   *hostname ) 
{ 
  char buf[16] ;
  int tmp ;
  int tmp___0 ;

  {
  if (hostname) {
    tmp = inet_pton(10, (char const   * __restrict  )hostname, (void * __restrict  )(buf));
    if (1 == tmp) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
__inline static void tcp_error(char *hostname , int port , char const   *reason ) 
{ 
  char *tmp ;

  {
  tmp = dcgettext((char const   *)((void *)0), "Unable to connect to server %s:%i: %s\n",
                  5);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp, hostname,
          port, reason);
  return;
}
}
int tcp_connect(tcp_t *tcp , char *hostname , int port , int secure , char *local_if ,
                unsigned int io_timeout ) 
{ 
  struct sockaddr_in local_addr ;
  char portstr[10] ;
  struct addrinfo ai_hints ;
  struct addrinfo *gai_results ;
  struct addrinfo *gai_result ;
  int ret ;
  int sock_fd ;
  char const   *tmp ;
  int tcp_fastopen ;
  int *tmp___0 ;
  fd_set fdset ;
  int __d0 ;
  int __d1 ;
  struct timeval tout ;
  int *tmp___1 ;
  char *tmp___2 ;
  struct timeval tout___0 ;

  {
  sock_fd = -1;
  memset((void *)(& local_addr), 0, sizeof(local_addr));
  if (local_if) {
    if (! *local_if) {
      local_if = (char *)((void *)0);
    } else
    if ((int )tcp->ai_family != 2) {
      local_if = (char *)((void *)0);
    } else {
      local_addr.sin_family = (sa_family_t )2;
      local_addr.sin_port = (in_port_t )0;
      local_addr.sin_addr.s_addr = inet_addr((char const   *)local_if);
    }
  }
  snprintf((char * __restrict  )(portstr), sizeof(portstr), (char const   * __restrict  )"%d",
           port);
  memset((void *)(& ai_hints), 0, sizeof(ai_hints));
  ai_hints.ai_family = (int )tcp->ai_family;
  ai_hints.ai_socktype = 1;
  ai_hints.ai_flags = 32;
  ai_hints.ai_protocol = 0;
  ret = getaddrinfo((char const   * __restrict  )hostname, (char const   * __restrict  )(portstr),
                    (struct addrinfo  const  * __restrict  )(& ai_hints), (struct addrinfo ** __restrict  )(& gai_results));
  if (ret != 0) {
    tmp = gai_strerror(ret);
    tcp_error(hostname, port, tmp);
    return (-1);
  }
  gai_result = gai_results;
  while (1) {
    tcp_fastopen = -1;
    if (sock_fd != -1) {
      close(sock_fd);
      sock_fd = -1;
    }
    sock_fd = socket(gai_result->ai_family, gai_result->ai_socktype, gai_result->ai_protocol);
    if (sock_fd == -1) {
      goto __Cont;
    }
    if (local_if) {
      if (gai_result->ai_family == 2) {
        bind(sock_fd, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& local_addr)),
             (socklen_t )sizeof(local_addr));
      }
    }
    tcp_fastopen = setsockopt(sock_fd, 6, 30, (void const   *)((void *)0), (socklen_t )0);
    ret = connect(sock_fd, (struct sockaddr  const  * __restrict  )gai_result->ai_addr,
                  gai_result->ai_addrlen);
    if (ret != -1) {
      break;
    }
    tmp___0 = __errno_location();
    if (*tmp___0 != 115) {
      goto __Cont;
    }
    if (tcp_fastopen != -1) {
      break;
    }
    while (1) {
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fdset.fds_bits[0]): "memory");
      break;
    }
    fdset.fds_bits[sock_fd / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << sock_fd % (8 * (int )sizeof(__fd_mask )));
    tout.tv_sec = (__time_t )io_timeout;
    tout.tv_usec = 0L;
    ret = select(sock_fd + 1, (fd_set * __restrict  )((void *)0), (fd_set * __restrict  )(& fdset),
                 (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )(& tout));
    if (ret != -1) {
      break;
    }
    __Cont: /* CIL Label */ 
    gai_result = gai_result->ai_next;
    if (! gai_result) {
      break;
    }
  }
  freeaddrinfo(gai_results);
  if (sock_fd == -1) {
    tmp___1 = __errno_location();
    tmp___2 = strerror(*tmp___1);
    tcp_error(hostname, port, (char const   *)tmp___2);
    return (-1);
  }
  fcntl(sock_fd, 4, 0);
  tcp->fd = sock_fd;
  tout___0.tv_sec = (__time_t )io_timeout;
  tout___0.tv_usec = 0L;
  setsockopt(sock_fd, 1, 20, (void const   *)(& tout___0), (socklen_t )sizeof(tout___0));
  setsockopt(sock_fd, 1, 21, (void const   *)(& tout___0), (socklen_t )sizeof(tout___0));
  return (1);
}
}
ssize_t tcp_read(tcp_t *tcp , void *buffer___0 , int size ) 
{ 
  ssize_t tmp ;

  {
  tmp = read(tcp->fd, buffer___0, (size_t )size);
  return (tmp);
}
}
ssize_t tcp_write(tcp_t *tcp , void *buffer___0 , int size ) 
{ 
  ssize_t tmp ;

  {
  tmp = write(tcp->fd, (void const   *)buffer___0, (size_t )size);
  return (tmp);
}
}
void tcp_close(tcp_t *tcp ) 
{ 


  {
  if (tcp->fd > 0) {
    close(tcp->fd);
    tcp->fd = -1;
  }
  return;
}
}
int get_if_ip(char *dst , size_t len , char const   *iface ) 
{ 
  struct ifreq ifr ;
  int ret ;
  int fd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct sockaddr_in *x ;
  char *tmp___2 ;

  {
  tmp = socket(2, 2, 0);
  fd = tmp;
  if (fd < 0) {
    return (0);
  }
  memset((void *)(& ifr), 0, sizeof(struct ifreq ));
  strlcpy(ifr.ifr_ifrn.ifrn_name, iface, sizeof(ifr.ifr_ifrn.ifrn_name));
  ifr.ifr_ifru.ifru_addr.sa_family = (sa_family_t )2;
  tmp___0 = ioctl(fd, 35093UL, & ifr);
  if (tmp___0) {
    tmp___1 = 0;
  } else {
    tmp___1 = 1;
  }
  ret = tmp___1;
  if (ret) {
    x = (struct sockaddr_in *)(& ifr.ifr_ifru.ifru_addr);
    tmp___2 = inet_ntoa(x->sin_addr);
    strlcpy(dst, (char const   *)tmp___2, len);
  }
  close(fd);
  return (ret);
}
}
/* compiler builtin: 
   int __builtin_clzll(unsigned long long  ) ;  */
#pragma merger("0","/tmp/cil-pobjVruR.i","-fno-strict-aliasing,-Wnested-externs,-Wmissing-prototypes,-Wstrict-prototypes,-Wdeclaration-after-statement,-Wimplicit-function-declaration,-Wold-style-definition,-Wjump-misses-init,-Wall,-Wextra,-Wundef,-Wwrite-strings,-Wpointer-arith,-Wmissing-declarations,-Wredundant-decls,-Wno-unused-parameter,-Wno-missing-field-initializers,-Wformat=2,-Wcast-align,-Wformat-nonliteral,-Wformat-security,-Wsign-compare,-Wstrict-aliasing,-Wshadow,-Winline,-Wpacked,-Wmissing-format-attribute,-Wmissing-noreturn,-Winit-self,-Wmissing-include-dirs,-Wunused-but-set-variable,-Warray-bounds,-Wreturn-type,-Wswitch-enum,-Wswitch-default,-Wduplicated-cond,-Wduplicated-branches,-Wlogical-op,-Wrestrict,-Wnull-dereference,-Wdouble-promotion,-Werror,-Wno-suggest-attribute=format,-Wno-error=unused-parameter,-Wno-error=missing-field-initializers,-Wno-declaration-after-statement,-Wno-error=cast-align,-Wno-error=inline,-pthread,-g,-O2")
extern int fflush(FILE *__stream ) ;
extern int scanf(char const   * __restrict  __format  , ...)  __asm__("__isoc99_scanf")  ;
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
extern char *optarg ;
extern int optind ;
extern int opterr ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) getopt_long)(int ___argc ,
                                                                                          char * const  *___argv ,
                                                                                          char const   *__shortopts ,
                                                                                          struct option  const  *__longopts ,
                                                                                          int *__longind ) ;
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) strtoul)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
extern  __attribute__((__nothrow__)) char *textdomain(char const   *__domainname ) ;
extern  __attribute__((__nothrow__)) char *bindtextdomain(char const   *__domainname ,
                                                          char const   *__dirname ) ;
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
static void stop(int signal___0 ) ;
static char *time_human(char *dst , size_t len , unsigned int value ) ;
static void print_commas(off_t bytes_done ) ;
static void print_alternate_output(axel_t *axel ) ;
static void print_progress(off_t cur , off_t prev , off_t total , double kbps ) ;
static void print_help(void) ;
static void print_version(void) ;
static void print_version_info(void) ;
static int get_term_width(void) ;
int run  =    1;
static struct option axel_options[20]  = 
  {      {"max-speed", 1, (int *)((void *)0), 's'}, 
        {"num-connections", 1, (int *)((void *)0), 'n'}, 
        {"max-redirect", 1, (int *)((void *)0), 256}, 
        {"output", 1, (int *)((void *)0), 'o'}, 
        {"search", 2, (int *)((void *)0), 'S'}, 
        {"ipv4", 0, (int *)((void *)0), '4'}, 
        {"ipv6", 0, (int *)((void *)0), '6'}, 
        {"no-proxy", 0, (int *)((void *)0), 'N'}, 
        {"quiet", 0, (int *)((void *)0), 'q'}, 
        {"verbose", 0, (int *)((void *)0), 'v'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"version", 0, (int *)((void *)0), 'V'}, 
        {"alternate", 0, (int *)((void *)0), 'a'}, 
        {"percentage", 0, (int *)((void *)0), 'p'}, 
        {"insecure", 0, (int *)((void *)0), 'k'}, 
        {"no-clobber", 0, (int *)((void *)0), 'c'}, 
        {"header", 1, (int *)((void *)0), 'H'}, 
        {"user-agent", 1, (int *)((void *)0), 'U'}, 
        {"timeout", 1, (int *)((void *)0), 'T'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
static unsigned int calc_percentage(off_t cur , off_t total ) 
{ 
  int __a ;
  off_t __b ;
  off_t tmp ;

  {
  __a = 100;
  __b = (100L * cur + total / 2L) / total;
  if ((off_t )__a < __b) {
    tmp = (off_t )__a;
  } else {
    tmp = __b;
  }
  return ((unsigned int )tmp);
}
}
int main(int argc , char **argv ) 
{ 
  char fn[(size_t )1024] ;
  int do_search ;
  search_t *search ;
  conf_t conf[1] ;
  axel_t *axel ;
  int j ;
  int ret ;
  char *s ;
  int tmp ;
  int option ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  unsigned long tmp___9 ;
  void *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  void *tmp___17 ;
  char *tmp___18 ;
  int i ;
  int tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  int __a ;
  int __b ;
  int tmp___24 ;
  char *tmp___25 ;
  void *tmp___26 ;
  int i___0 ;
  struct stat buf ;
  size_t fnlen ;
  size_t tmp___27 ;
  size_t axelfnlen ;
  size_t tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  char statefn[1027UL] ;
  char *tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  char *tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  size_t tmp___37 ;
  int i___1 ;
  char statefn___0[1027UL] ;
  int f_exists ;
  int tmp___38 ;
  int tmp___39 ;
  int st_exists ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  off_t prev ;
  unsigned int tmp___43 ;
  char hsize[512UL] ;
  char htime[512UL] ;
  double tmp___44 ;
  char *tmp___45 ;

  {
  do_search = 0;
  ret = 1;
  fn[0] = (char)0;
  setlocale(6, "");
  bindtextdomain("axel", "/usr/local/share/locale");
  textdomain("axel");
  tmp = conf_init(conf);
  if (! tmp) {
    return (1);
  }
  opterr = 0;
  j = -1;
  while (1) {
    tmp___0 = getopt_long(argc, (char * const  *)argv, "s:n:o:S::46NqvhVapkcH:U:T:",
                          (struct option  const  *)(axel_options), (int *)((void *)0));
    option = tmp___0;
    if (option == -1) {
      break;
    }
    switch (option) {
    case 85: 
    conf_hdr_make(conf[0].add_header[0], "User-Agent", (char const   *)optarg);
    break;
    case 72: 
    if (! (conf[0].add_header_count < 10)) {
      tmp___1 = dcgettext((char const   *)((void *)0), "Too many custom headers (-H)! Currently only %u custom headers can be appended.\n",
                          5);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___1, 9);
      goto free_conf;
    }
    tmp___2 = conf[0].add_header_count;
    (conf[0].add_header_count) ++;
    strlcpy(conf[0].add_header[tmp___2], (char const   *)optarg, sizeof(conf[0].add_header[0]));
    break;
    case 115: 
    tmp___3 = sscanf((char const   * __restrict  )optarg, (char const   * __restrict  )"%llu",
                     & conf[0].max_speed);
    if (! tmp___3) {
      print_help();
      goto free_conf;
    }
    break;
    case 110: 
    tmp___4 = sscanf((char const   * __restrict  )optarg, (char const   * __restrict  )"%hu",
                     & conf[0].num_connections);
    if (! tmp___4) {
      print_help();
      goto free_conf;
    }
    break;
    case 256: 
    tmp___5 = sscanf((char const   * __restrict  )optarg, (char const   * __restrict  )"%i",
                     & conf[0].max_redirect);
    if (! tmp___5) {
      print_help();
      return (1);
    }
    break;
    case 111: 
    strlcpy(fn, (char const   *)optarg, sizeof(fn));
    break;
    case 83: 
    do_search = 1;
    if (optarg) {
      tmp___6 = sscanf((char const   * __restrict  )optarg, (char const   * __restrict  )"%i",
                       & conf[0].search_top);
      if (! tmp___6) {
        print_help();
        goto free_conf;
      }
    }
    break;
    case 54: 
    conf[0].ai_family = (sa_family_t )10;
    break;
    case 52: 
    conf[0].ai_family = (sa_family_t )2;
    break;
    case 97: 
    conf[0].alternate_output = 1;
    break;
    case 112: 
    conf[0].percentage = 1;
    break;
    case 107: 
    conf[0].insecure = 1;
    break;
    case 99: 
    conf[0].no_clobber = 1;
    break;
    case 78: 
    conf[0].http_proxy[0] = (char)0;
    break;
    case 104: 
    print_help();
    ret = 0;
    goto free_conf;
    case 118: 
    if (j == -1) {
      j = 1;
    } else {
      j ++;
    }
    break;
    case 86: 
    print_version_info();
    ret = 0;
    goto free_conf;
    case 113: 
    close(1);
    conf[0].verbose = -1;
    tmp___8 = open("/dev/null", 1);
    if (tmp___8 != 1) {
      tmp___7 = dcgettext((char const   *)((void *)0), "Can\'t redirect stdout to /dev/null.\n",
                          5);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___7);
      goto free_conf;
    }
    break;
    case 84: 
    tmp___9 = strtoul((char const   * __restrict  )optarg, (char ** __restrict  )((void *)0),
                      0);
    conf[0].io_timeout = (unsigned int )tmp___9;
    break;
    default: 
    print_help();
    goto free_conf;
    }
  }
  if (conf[0].verbose < 0) {
    conf[0].alternate_output = 0;
    conf[0].percentage = 0;
  } else
  if (j > -1) {
    conf[0].verbose = j;
  }
  if ((int )conf[0].num_connections < 1) {
    print_help();
    goto free_conf;
  }
  if (conf[0].max_redirect < 0) {
    print_help();
    return (1);
  }
  if (argc - optind == 0) {
    print_help();
    goto free_conf;
  } else {
    tmp___15 = strcmp((char const   *)*(argv + optind), "-");
    if (tmp___15 == 0) {
      tmp___10 = malloc((size_t )1024);
      s = (char *)tmp___10;
      if (! s) {
        goto free_conf;
      }
      tmp___12 = scanf((char const   * __restrict  )"%1024[^\n]s", s);
      if (tmp___12 != 1) {
        tmp___11 = dcgettext((char const   *)((void *)0), "Error when trying to read URL (Too long?).\n",
                             5);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___11);
        free((void *)s);
        goto free_conf;
      }
    } else {
      s = *(argv + optind);
      tmp___14 = strlen((char const   *)s);
      if (tmp___14 > 1024UL) {
        tmp___13 = dcgettext((char const   *)((void *)0), "Can\'t handle URLs of length over %zu\n",
                             5);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___13,
                (size_t )1024);
        goto free_conf;
      }
    }
  }
  if (! conf[0].percentage) {
    tmp___16 = dcgettext((char const   *)((void *)0), "Initializing download: %s\n",
                         5);
    printf((char const   * __restrict  )tmp___16, s);
  }
  if (do_search) {
    tmp___17 = calloc((size_t )(conf[0].search_amount + 1), sizeof(search_t ));
    search = (search_t *)tmp___17;
    if (! search) {
      goto free_conf;
    }
    (search + 0)->conf = conf;
    if (conf[0].verbose) {
      tmp___18 = dcgettext((char const   *)((void *)0), "Doing search...\n", 5);
      printf((char const   * __restrict  )tmp___18);
    }
    tmp___19 = search_makelist(search, s);
    i = tmp___19;
    if (i < 0) {
      tmp___20 = dcgettext((char const   *)((void *)0), "File not found\n", 5);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___20);
      goto free_conf;
    }
    if (conf[0].verbose) {
      tmp___21 = dcgettext((char const   *)((void *)0), "Testing speeds, this can take a while...\n",
                           5);
      printf((char const   * __restrict  )tmp___21);
    }
    j = search_getspeeds(search, i);
    if (j < 0) {
      tmp___22 = dcgettext((char const   *)((void *)0), "Speed testing failed\n",
                           5);
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___22);
      return (1);
    }
    search_sortlist(search, i);
    if (conf[0].verbose) {
      tmp___23 = dcgettext((char const   *)((void *)0), "%i usable servers found, will use these URLs:\n",
                           5);
      printf((char const   * __restrict  )tmp___23, j);
      __a = j;
      __b = conf[0].search_top;
      if (__a < __b) {
        tmp___24 = __a;
      } else {
        tmp___24 = __b;
      }
      j = tmp___24;
      tmp___25 = dcgettext((char const   *)((void *)0), "Speed", 5);
      printf((char const   * __restrict  )"%-60s %15s\n", "URL", tmp___25);
      i = 0;
      while (i < j) {
        printf((char const   * __restrict  )"%-70.70s %5jd\n", (search + i)->url,
               (search + i)->speed);
        i ++;
      }
      printf((char const   * __restrict  )"\n");
    }
    axel = axel_new(conf, j, (search_t const   *)search);
    free((void *)search);
    if (! axel) {
      print_messages(axel);
      goto close_axel;
    } else
    if (axel->ready == -1) {
      print_messages(axel);
      goto close_axel;
    }
  } else {
    tmp___26 = calloc((size_t )(argc - optind), sizeof(search_t ));
    search = (search_t *)tmp___26;
    if (! search) {
      goto free_conf;
    }
    i___0 = 0;
    while (i___0 < argc - optind) {
      strlcpy((search + i___0)->url, (char const   *)*(argv + (optind + i___0)), sizeof((search + i___0)->url));
      i___0 ++;
    }
    axel = axel_new(conf, argc - optind, (search_t const   *)search);
    free((void *)search);
    if (! axel) {
      print_messages(axel);
      goto close_axel;
    } else
    if (axel->ready == -1) {
      print_messages(axel);
      goto close_axel;
    }
  }
  print_messages(axel);
  if ((unsigned long )s != (unsigned long )*(argv + optind)) {
    free((void *)s);
  }
  if (fn[0]) {
    tmp___30 = stat((char const   * __restrict  )(fn), (struct stat * __restrict  )(& buf));
    if (tmp___30 == 0) {
      if ((buf.st_mode & 61440U) == 16384U) {
        tmp___27 = strlen((char const   *)(fn));
        fnlen = tmp___27;
        tmp___28 = strlen((char const   *)(axel->filename));
        axelfnlen = tmp___28;
        if (((fnlen + 1UL) + axelfnlen) + 1UL > 1024UL) {
          tmp___29 = dcgettext((char const   *)((void *)0), "Filename too long!\n",
                               5);
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___29);
          goto close_axel;
        }
        fn[fnlen] = (char )'/';
        memcpy((void * __restrict  )((fn + fnlen) + 1), (void const   * __restrict  )(axel->filename),
               axelfnlen);
        fn[(fnlen + 1UL) + axelfnlen] = (char )'\000';
      }
    }
    snprintf((char * __restrict  )(statefn), sizeof(statefn), (char const   * __restrict  )"%s.st",
             fn);
    tmp___32 = access((char const   *)(fn), 0);
    if (tmp___32 == 0) {
      tmp___33 = access((char const   *)(statefn), 0);
      if (tmp___33 != 0) {
        tmp___31 = dcgettext((char const   *)((void *)0), "No state file, cannot resume!\n",
                             5);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___31);
        goto close_axel;
      }
    }
    tmp___35 = access((char const   *)(statefn), 0);
    if (tmp___35 == 0) {
      tmp___36 = access((char const   *)(fn), 0);
      if (tmp___36 != 0) {
        tmp___34 = dcgettext((char const   *)((void *)0), "State file found, but no downloaded data. Starting from scratch.\n",
                             5);
        printf((char const   * __restrict  )tmp___34);
        unlink((char const   *)(statefn));
      }
    }
    strlcpy(axel->filename, (char const   *)(fn), sizeof(axel->filename));
  } else {
    tmp___37 = strlen((char const   *)(axel->filename));
    s = axel->filename + tmp___37;
    i___1 = 0;
    while (1) {
      snprintf((char * __restrict  )(statefn___0), sizeof(statefn___0), (char const   * __restrict  )"%s.st",
               axel->filename);
      tmp___38 = access((char const   *)(axel->filename), 0);
      if (tmp___38) {
        tmp___39 = 0;
      } else {
        tmp___39 = 1;
      }
      f_exists = tmp___39;
      tmp___40 = access((char const   *)(statefn___0), 0);
      if (tmp___40) {
        tmp___41 = 0;
      } else {
        tmp___41 = 1;
      }
      st_exists = tmp___41;
      if (f_exists) {
        if ((axel->conn + 0)->supported) {
          if (st_exists) {
            break;
          }
        }
      } else
      if (! st_exists) {
        break;
      }
      snprintf((char * __restrict  )s, (size_t )((axel->filename + sizeof(axel->filename)) - s),
               (char const   * __restrict  )".%i", i___1);
      i___1 ++;
    }
  }
  tmp___42 = axel_open(axel);
  if (! tmp___42) {
    print_messages(axel);
    goto close_axel;
  }
  print_messages(axel);
  axel_start(axel);
  print_messages(axel);
  if (conf[0].alternate_output) {
    putchar('\n');
  } else
  if (conf[0].percentage) {
    putchar('\n');
  } else
  if (axel->bytes_done > 0L) {
    putchar('\n');
    print_commas(axel->bytes_done);
    fflush(stdout);
  }
  axel->start_byte = axel->bytes_done;
  signal(2, & stop);
  signal(15, & stop);
  while (1) {
    if (! axel->ready) {
      if (! run) {
        break;
      }
    } else {
      break;
    }
    prev = axel->bytes_done;
    axel_do(axel);
    if (conf[0].percentage) {
      if (! axel->message) {
        if (prev != axel->bytes_done) {
          tmp___43 = calc_percentage(axel->bytes_done, axel->size);
          printf((char const   * __restrict  )"%u\n", tmp___43);
        }
      }
    } else
    if (conf[0].alternate_output) {
      if (! axel->message) {
        if (prev != axel->bytes_done) {
          print_alternate_output(axel);
        }
      }
    } else
    if (conf[0].verbose > -1) {
      print_progress(axel->bytes_done, prev, axel->size, (double )axel->bytes_per_second / (double )1024);
    }
    if (axel->message) {
      if (conf[0].alternate_output == 1) {
        fputs((char const   * __restrict  )"\033[2K\r", (FILE * __restrict  )stdout);
      } else {
        putchar('\n');
      }
      print_messages(axel);
      if (! axel->ready) {
        if (conf[0].alternate_output != 1) {
          print_commas(axel->bytes_done);
        } else {
          print_alternate_output(axel);
        }
      }
    } else
    if (axel->ready) {
      putchar('\n');
    }
    fflush(stdout);
  }
  tmp___44 = axel_gettime();
  time_human(htime, sizeof(htime), (unsigned int )(tmp___44 - axel->start_time));
  axel_size_human(hsize, sizeof(hsize), (size_t )(axel->bytes_done - axel->start_byte));
  tmp___45 = dcgettext((char const   *)((void *)0), "\nDownloaded %s in %s. (%.2f KB/s)\n",
                       5);
  printf((char const   * __restrict  )tmp___45, hsize, htime, (double )axel->bytes_per_second / (double )1024);
  if (axel->ready) {
    ret = 0;
  } else {
    ret = 2;
  }
  close_axel: 
  axel_close(axel);
  free_conf: 
  conf_free(conf);
  return (ret);
}
}
static void stop(int signal___0 ) 
{ 


  {
  run = 0;
  return;
}
}
__inline static unsigned int log2i(unsigned long long x ) 
{ 
  int tmp ;
  unsigned long tmp___0 ;

  {
  if (x) {
    tmp = __builtin_clzll(x);
    tmp___0 = (sizeof(x) * 8UL - 1UL) - (unsigned long )tmp;
  } else {
    tmp___0 = 0UL;
  }
  return ((unsigned int )tmp___0);
}
}
char *axel_size_human(char *dst , size_t len , size_t value ) 
{ 
  double fval ;
  char const   *oname[5] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned int order ;
  unsigned long __a ;
  unsigned int __b ;
  unsigned int tmp___4 ;
  unsigned long tmp___5 ;
  int ret ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;

  {
  fval = (double )value;
  tmp = dcgettext((char const   *)((void *)0), "Kilo", 5);
  tmp___0 = dcgettext((char const   *)((void *)0), "Mega", 5);
  tmp___1 = dcgettext((char const   *)((void *)0), "Giga", 5);
  tmp___2 = dcgettext((char const   *)((void *)0), "Tera", 5);
  oname[0] = "";
  oname[1] = (char const   *)tmp;
  oname[2] = (char const   *)tmp___0;
  oname[3] = (char const   *)tmp___1;
  oname[4] = (char const   *)tmp___2;
  __a = sizeof(oname) / sizeof(oname[0]) - 1UL;
  tmp___4 = log2i((unsigned long long )fval);
  __b = tmp___4 / 10U;
  if (__a < (unsigned long )__b) {
    tmp___5 = __a;
  } else {
    tmp___5 = (unsigned long )__b;
  }
  order = (unsigned int )tmp___5;
  fval /= (double )(1 << order * 10U);
  tmp___6 = dcgettext((char const   *)((void *)0), "%g %sbyte(s)", 5);
  tmp___7 = snprintf((char * __restrict  )dst, len, (char const   * __restrict  )tmp___6,
                     fval, oname[order]);
  ret = tmp___7;
  if (ret < 0) {
    tmp___8 = (char *)((void *)0);
  } else {
    tmp___8 = dst;
  }
  return (tmp___8);
}
}
static char *time_human(char *dst , size_t len , unsigned int value ) 
{ 
  unsigned int hh ;
  unsigned int mm ;
  unsigned int ss ;
  int ret ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  ss = value % 60U;
  mm = (value / 60U) % 60U;
  hh = value / 3600U;
  if (hh) {
    tmp = dcgettext((char const   *)((void *)0), "%i:%02i:%02i hour(s)", 5);
    ret = snprintf((char * __restrict  )dst, len, (char const   * __restrict  )tmp,
                   hh, mm, ss);
  } else
  if (mm) {
    tmp___0 = dcgettext((char const   *)((void *)0), "%i:%02i minute(s)", 5);
    ret = snprintf((char * __restrict  )dst, len, (char const   * __restrict  )tmp___0,
                   mm, ss);
  } else {
    tmp___1 = dcgettext((char const   *)((void *)0), "%i second(s)", 5);
    ret = snprintf((char * __restrict  )dst, len, (char const   * __restrict  )tmp___1,
                   ss);
  }
  if (ret < 0) {
    tmp___2 = (char *)((void *)0);
  } else {
    tmp___2 = dst;
  }
  return (tmp___2);
}
}
static void print_commas(off_t bytes_done ) 
{ 
  int i ;
  int j ;

  {
  printf((char const   * __restrict  )"       ");
  j = (int )((bytes_done / 1024L) % 50L);
  if (j == 0) {
    j = 50;
  }
  i = 0;
  while (i < j) {
    if (i % 10 == 0) {
      putchar(' ');
    }
    putchar(',');
    i ++;
  }
  return;
}
}
static void print_progress(off_t cur , off_t prev , off_t total , double kbps ) 
{ 
  _Bool print_speed ;
  off_t i ;
  unsigned int tmp ;

  {
  prev /= 1024L;
  cur /= 1024L;
  print_speed = (_Bool )(prev > 0L);
  i = prev;
  while (i < cur) {
    if (i % 50L == 0L) {
      if (print_speed) {
        printf((char const   * __restrict  )"  [%6.1fKB/s]", kbps);
      }
      if ((long long )total == 9223372036854775807LL) {
        printf((char const   * __restrict  )"\n[ N/A]  ");
      } else {
        tmp = calc_percentage(1024L * i, total);
        printf((char const   * __restrict  )"\n[%3u%%]  ", tmp);
      }
    } else
    if (i % 10L == 0L) {
      putchar(' ');
    }
    putchar('.');
    i ++;
  }
  return;
}
}
static char alt_id(int n ) 
{ 
  char const   *p ;
  int tmp ;

  {
  p = "09AZaz";
  while (1) {
    if (*p) {
      if (! (n > (int )((int const   )*(p + 1) - (int const   )*(p + 0)))) {
        break;
      }
    } else {
      break;
    }
    n -= (int )(((int const   )*(p + 1) - (int const   )*(p + 0)) + 1);
    p += 2;
  }
  if (*p) {
    tmp = (int const   )*p + (int const   )n;
  } else {
    tmp = (int const   )'*';
  }
  return ((char )tmp);
}
}
static void print_alternate_output_progress(axel_t *axel , char *progress , int width ,
                                            off_t done , off_t total , double now ) 
{ 
  int i ;
  int offset ;
  int __a ;
  off_t __b ;
  off_t tmp ;
  unsigned int tmp___0 ;

  {
  if (! width) {
    width = 1;
  }
  if (! total) {
    total = (off_t )1;
  }
  i = 0;
  while (i < (int )(axel->conf)->num_connections) {
    offset = (int )(((axel->conn + i)->currentbyte * (off_t )width) / total);
    if ((axel->conn + i)->currentbyte < (axel->conn + i)->lastbyte) {
      if (now <= (double )((axel->conn + i)->last_transfer + (axel->conf)->connection_timeout / 2)) {
        *(progress + offset) = alt_id(i);
      } else {
        *(progress + offset) = (char )'#';
      }
    }
    __a = 0;
    __b = (((axel->conn + i)->lastbyte * (off_t )width) / total - (off_t )offset) - 1L;
    if ((off_t )__a > __b) {
      tmp = (off_t )__a;
    } else {
      tmp = __b;
    }
    memset((void *)((progress + offset) + 1), ' ', (size_t )tmp);
    i ++;
  }
  *(progress + width) = (char )'\000';
  tmp___0 = calc_percentage(done, total);
  printf((char const   * __restrict  )"\r[%3u%%] [%s", tmp___0, progress);
  return;
}
}
static void print_alternate_output(axel_t *axel ) 
{ 
  off_t done ;
  off_t total ;
  double now ;
  double tmp ;
  int width ;
  int tmp___0 ;
  char *progress ;
  char *tmp___1 ;
  void *tmp___2 ;
  int seconds ;
  int minutes ;
  int hours ;
  int days ;

  {
  done = axel->bytes_done;
  total = axel->size;
  tmp = axel_gettime();
  now = tmp;
  tmp___0 = get_term_width();
  width = tmp___0;
  if (width < 40) {
    tmp___1 = dcgettext((char const   *)((void *)0), "Can\'t setup alternate output. Deactivating.\n",
                        5);
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp___1);
    (axel->conf)->alternate_output = 0;
    return;
  }
  width -= 30;
  tmp___2 = malloc((size_t )(width + 1));
  progress = (char *)tmp___2;
  if (! progress) {
    return;
  }
  memset((void *)progress, '.', (size_t )width);
  if ((long long )total != 9223372036854775807LL) {
    print_alternate_output_progress(axel, progress, width, done, total, now);
  } else {
    *(progress + width) = (char )'\000';
    printf((char const   * __restrict  )"\r[ N/A] [%s", progress);
  }
  if (axel->bytes_per_second > 1048576LL) {
    printf((char const   * __restrict  )"] [%6.1fMB/s]", (double )axel->bytes_per_second / (double )1048576);
  } else
  if (axel->bytes_per_second > 1024LL) {
    printf((char const   * __restrict  )"] [%6.1fKB/s]", (double )axel->bytes_per_second / (double )1024);
  } else {
    printf((char const   * __restrict  )"] [%6.1fB/s]", (double )axel->bytes_per_second);
  }
  if ((long long )total != 9223372036854775807LL) {
    if (done < total) {
      seconds = (int )((double )axel->finish_time - now);
      minutes = seconds / 60;
      seconds -= minutes * 60;
      hours = minutes / 60;
      minutes -= hours * 60;
      days = hours / 24;
      hours -= days * 24;
      if (days) {
        printf((char const   * __restrict  )" [%2dd%2d]", days, hours);
      } else
      if (hours) {
        printf((char const   * __restrict  )" [%2dh%02d]", hours, minutes);
      } else {
        printf((char const   * __restrict  )" [%02d:%02d]", minutes, seconds);
      }
    }
  }
  free((void *)progress);
  return;
}
}
static int get_term_width(void) 
{ 
  struct winsize w ;

  {
  ioctl(1, 21523UL, & w);
  return ((int )w.ws_col);
}
}
static void print_help(void) 
{ 
  char *tmp ;

  {
  print_version();
  tmp = dcgettext((char const   *)((void *)0), "Usage: axel [options] url1 [url2] [url...]\n\n--max-speed=x\t\t-s x\tSpecify maximum speed (bytes per second)\n--num-connections=x\t-n x\tSpecify maximum number of connections\n--max-redirect=x\t\tSpecify maximum number of redirections\n--output=f\t\t-o f\tSpecify local output file\n--search[=n]\t\t-S[n]\tSearch for mirrors and download from n servers\n--ipv4\t\t\t-4\tUse the IPv4 protocol\n--ipv6\t\t\t-6\tUse the IPv6 protocol\n--header=x\t\t-H x\tAdd HTTP header string\n--user-agent=x\t\t-U x\tSet user agent\n--no-proxy\t\t-N\tJust don\'t use any proxy server\n--insecure\t\t-k\tDon\'t verify the SSL certificate\n--no-clobber\t\t-c\tSkip download if file already exists\n--quiet\t\t\t-q\tLeave stdout alone\n--verbose\t\t-v\tMore status information\n--alternate\t\t-a\tAlternate progress indicator\n--percentage\t\t-p\tPrint simple percentages instead of progress bar (0-100)\n--help\t\t\t-h\tThis information\n--timeout=x\t\t-T x\tSet I/O and connection timeout\n--version\t\t-V\tVersion information\n\nVisit https://github.com/axel-download-accelerator/axel/issues to report bugs\n",
                  5);
  printf((char const   * __restrict  )tmp);
  return;
}
}
static void print_version(void) 
{ 
  char *tmp ;

  {
  tmp = dcgettext((char const   *)((void *)0), "Axel %s (%s)\n", 5);
  printf((char const   * __restrict  )tmp, "2.17.11+gab2f84", "linux-gnu");
  return;
}
}
static void print_version_info(void) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  print_version();
  tmp = dcgettext((char const   *)((void *)0), "Please, see the CREDITS file.\n\n",
                  5);
  tmp___0 = dcgettext((char const   *)((void *)0), "and others.", 5);
  printf((char const   * __restrict  )"\nCopyright 2001-2007 Wilmer van der Gaast,\n\t  2007-2009 Giridhar Appaji Nag,\n\t  2008-2010 Philipp Hagemeister,\n\t  2015-2017 Joao Eriberto Mota Filho,\n\t  2016-2017 Stephen Thirlwall,\n\t  2017      Ismael Luceno,\n\t  2017      Antonio Quartulli,\n\t\t    %s\n%s\n\n",
         tmp___0, tmp);
  return;
}
}
void print_messages(axel_t *axel ) 
{ 
  message_t *m ;

  {
  if (! axel) {
    return;
  }
  while (1) {
    m = axel->message;
    if (! m) {
      break;
    }
    printf((char const   * __restrict  )"%s\n", m->text);
    axel->message = (message_t *)m->next;
    free((void *)m);
  }
  return;
}
}
#pragma merger("0","/tmp/cil-K40IHUKd.i","-fno-strict-aliasing,-Wnested-externs,-Wmissing-prototypes,-Wstrict-prototypes,-Wdeclaration-after-statement,-Wimplicit-function-declaration,-Wold-style-definition,-Wjump-misses-init,-Wall,-Wextra,-Wundef,-Wwrite-strings,-Wpointer-arith,-Wmissing-declarations,-Wredundant-decls,-Wno-unused-parameter,-Wno-missing-field-initializers,-Wformat=2,-Wcast-align,-Wformat-nonliteral,-Wformat-security,-Wsign-compare,-Wstrict-aliasing,-Wshadow,-Winline,-Wpacked,-Wmissing-format-attribute,-Wmissing-noreturn,-Winit-self,-Wmissing-include-dirs,-Wunused-but-set-variable,-Warray-bounds,-Wreturn-type,-Wswitch-enum,-Wswitch-default,-Wduplicated-cond,-Wduplicated-branches,-Wlogical-op,-Wrestrict,-Wnull-dereference,-Wdouble-promotion,-Werror,-Wno-suggest-attribute=format,-Wno-error=unused-parameter,-Wno-error=missing-field-initializers,-Wno-declaration-after-statement,-Wno-error=cast-align,-Wno-error=inline,-g,-O2")
size_t strlcpy(char *dst , char const   *src , size_t dsize ) 
{ 
  char const   *osrc ;
  size_t nleft ;
  char *tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  osrc = src;
  nleft = dsize;
  if (nleft != 0UL) {
    while (1) {
      nleft --;
      if (! (nleft != 0UL)) {
        break;
      }
      tmp = dst;
      dst ++;
      tmp___1 = src;
      src ++;
      tmp___0 = (char )*tmp___1;
      *tmp = tmp___0;
      if ((int )tmp___0 == 0) {
        break;
      }
    }
  }
  if (nleft == 0UL) {
    if (dsize != 0UL) {
      *dst = (char )'\000';
    }
    while (1) {
      tmp___2 = src;
      src ++;
      if (! *tmp___2) {
        break;
      }
    }
  }
  return ((size_t )((src - osrc) - 1L));
}
}
#pragma merger("0","/tmp/cil-_vki1zEg.i","-fno-strict-aliasing,-Wnested-externs,-Wmissing-prototypes,-Wstrict-prototypes,-Wdeclaration-after-statement,-Wimplicit-function-declaration,-Wold-style-definition,-Wjump-misses-init,-Wall,-Wextra,-Wundef,-Wwrite-strings,-Wpointer-arith,-Wmissing-declarations,-Wredundant-decls,-Wno-unused-parameter,-Wno-missing-field-initializers,-Wformat=2,-Wcast-align,-Wformat-nonliteral,-Wformat-security,-Wsign-compare,-Wstrict-aliasing,-Wshadow,-Winline,-Wpacked,-Wmissing-format-attribute,-Wmissing-noreturn,-Winit-self,-Wmissing-include-dirs,-Wunused-but-set-variable,-Warray-bounds,-Wreturn-type,-Wswitch-enum,-Wswitch-default,-Wduplicated-cond,-Wduplicated-branches,-Wlogical-op,-Wrestrict,-Wnull-dereference,-Wdouble-promotion,-Werror,-Wno-suggest-attribute=format,-Wno-error=unused-parameter,-Wno-error=missing-field-initializers,-Wno-declaration-after-statement,-Wno-error=cast-align,-Wno-error=inline,-g,-O2")
size_t strlcat(char *dst , char const   *src , size_t dsize ) 
{ 
  char const   *odst ;
  char const   *osrc ;
  size_t n ;
  size_t dlen ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;

  {
  odst = (char const   *)dst;
  osrc = src;
  n = dsize;
  while (1) {
    tmp = n;
    n --;
    if (tmp != 0UL) {
      if (! ((int )*dst != 0)) {
        break;
      }
    } else {
      break;
    }
    dst ++;
  }
  dlen = (size_t )(dst - (char *)odst);
  n = dsize - dlen;
  tmp___1 = n;
  n --;
  if (tmp___1 == 0UL) {
    tmp___0 = strlen(src);
    return (dlen + tmp___0);
  }
  while ((int const   )*src != 0) {
    if (n != 0UL) {
      tmp___2 = dst;
      dst ++;
      *tmp___2 = (char )*src;
      n --;
    }
    src ++;
  }
  *dst = (char )'\000';
  return (dlen + (size_t )(src - osrc));
}
}
