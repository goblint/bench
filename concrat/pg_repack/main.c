/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned int Oid;
typedef unsigned long size_t;
typedef __builtin_va_list __gnuc_va_list;
typedef unsigned char __uint8_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef unsigned int __gid_t;
typedef long __off_t;
typedef long __off64_t;
typedef long __time_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
typedef unsigned int __socklen_t;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef __ssize_t ssize_t;
struct obstack ;
typedef int wchar_t;
typedef __time_t time_t;
struct __anonstruct___sigset_t_991265788 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___sigset_t_991265788 __sigset_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
typedef __socklen_t socklen_t;
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
struct sockaddr_at ;
struct sockaddr_ax25 ;
struct sockaddr_dl ;
struct sockaddr_eon ;
struct sockaddr_in ;
struct sockaddr_in6 ;
struct sockaddr_inarp ;
struct sockaddr_ipx ;
struct sockaddr_iso ;
struct sockaddr_ns ;
struct sockaddr_un ;
struct sockaddr_x25 ;
union __anonunion___SOCKADDR_ARG_627422263 {
   struct sockaddr * __restrict  __sockaddr__ ;
   struct sockaddr_at * __restrict  __sockaddr_at__ ;
   struct sockaddr_ax25 * __restrict  __sockaddr_ax25__ ;
   struct sockaddr_dl * __restrict  __sockaddr_dl__ ;
   struct sockaddr_eon * __restrict  __sockaddr_eon__ ;
   struct sockaddr_in * __restrict  __sockaddr_in__ ;
   struct sockaddr_in6 * __restrict  __sockaddr_in6__ ;
   struct sockaddr_inarp * __restrict  __sockaddr_inarp__ ;
   struct sockaddr_ipx * __restrict  __sockaddr_ipx__ ;
   struct sockaddr_iso * __restrict  __sockaddr_iso__ ;
   struct sockaddr_ns * __restrict  __sockaddr_ns__ ;
   struct sockaddr_un * __restrict  __sockaddr_un__ ;
   struct sockaddr_x25 * __restrict  __sockaddr_x25__ ;
};
typedef union __anonunion___SOCKADDR_ARG_627422263  __attribute__((__transparent_union__)) __SOCKADDR_ARG;
typedef uint32_t in_addr_t;
struct in_addr {
   in_addr_t s_addr ;
};
typedef uint16_t in_port_t;
union __anonunion___in6_u_979734923 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
struct in6_addr {
   union __anonunion___in6_u_979734923 __in6_u ;
};
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
enum __anonenum_ConnStatusType_301395160 {
    CONNECTION_OK = 0,
    CONNECTION_BAD = 1,
    CONNECTION_STARTED = 2,
    CONNECTION_MADE = 3,
    CONNECTION_AWAITING_RESPONSE = 4,
    CONNECTION_AUTH_OK = 5,
    CONNECTION_SETENV = 6,
    CONNECTION_SSL_STARTUP = 7,
    CONNECTION_NEEDED = 8,
    CONNECTION_CHECK_WRITABLE = 9,
    CONNECTION_CONSUME = 10,
    CONNECTION_GSS_STARTUP = 11,
    CONNECTION_CHECK_TARGET = 12,
    CONNECTION_CHECK_STANDBY = 13
} ;
typedef enum __anonenum_ConnStatusType_301395160 ConnStatusType;
enum __anonenum_ExecStatusType_61969095 {
    PGRES_EMPTY_QUERY = 0,
    PGRES_COMMAND_OK = 1,
    PGRES_TUPLES_OK = 2,
    PGRES_COPY_OUT = 3,
    PGRES_COPY_IN = 4,
    PGRES_BAD_RESPONSE = 5,
    PGRES_NONFATAL_ERROR = 6,
    PGRES_FATAL_ERROR = 7,
    PGRES_COPY_BOTH = 8,
    PGRES_SINGLE_TUPLE = 9,
    PGRES_PIPELINE_SYNC = 10,
    PGRES_PIPELINE_ABORTED = 11
} ;
typedef enum __anonenum_ExecStatusType_61969095 ExecStatusType;
struct pg_conn ;
typedef struct pg_conn PGconn;
struct pg_result ;
typedef struct pg_result PGresult;
struct PQExpBufferData {
   char *data ;
   size_t len ;
   size_t maxlen ;
};
typedef struct PQExpBufferData PQExpBufferData;
typedef PQExpBufferData *PQExpBuffer;
struct SimpleStringListCell {
   struct SimpleStringListCell *next ;
   char val[1] ;
};
typedef struct SimpleStringListCell SimpleStringListCell;
struct SimpleStringList {
   SimpleStringListCell *head ;
   SimpleStringListCell *tail ;
};
typedef struct SimpleStringList SimpleStringList;
enum pgut_optsrc {
    SOURCE_DEFAULT = 0,
    SOURCE_ENV = 1,
    SOURCE_FILE = 2,
    SOURCE_CMDLINE = 3,
    SOURCE_CONST = 4
} ;
typedef enum pgut_optsrc pgut_optsrc;
struct pgut_option {
   char type ;
   char sname ;
   char const   *lname ;
   void *var ;
   pgut_optsrc allowed ;
   pgut_optsrc source ;
};
typedef struct pgut_option pgut_option;
struct worker_conns {
   int max_num_workers ;
   int num_workers ;
   PGconn **conns ;
};
typedef struct worker_conns worker_conns;
typedef unsigned long nfds_t;
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
enum __anonenum_index_status_t_747877378 {
    UNPROCESSED = 0,
    INPROGRESS = 1,
    FINISHED = 2
} ;
typedef enum __anonenum_index_status_t_747877378 index_status_t;
struct repack_index {
   Oid target_oid ;
   char const   *create_index ;
   index_status_t status ;
   int worker_idx ;
};
typedef struct repack_index repack_index;
struct repack_table {
   char const   *target_name ;
   Oid target_oid ;
   Oid target_toast ;
   Oid target_tidx ;
   Oid pkid ;
   Oid ckid ;
   char const   *create_pktype ;
   char const   *create_log ;
   char const   *create_trigger ;
   char const   *enable_trigger ;
   char const   *create_table ;
   char const   *copy_data ;
   char const   *alter_col_storage ;
   char const   *drop_columns ;
   char const   *delete_log ;
   char const   *lock_table ;
   char const   *sql_peek ;
   char const   *sql_insert ;
   char const   *sql_delete ;
   char const   *sql_update ;
   char const   *sql_pop ;
   int n_indexes ;
   repack_index *indexes ;
};
typedef struct repack_table repack_table;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned long __ino_t;
typedef unsigned long __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __suseconds_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __blkcnt64_t;
typedef __gnuc_va_list va_list___0;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
typedef long __fd_mask;
struct __anonstruct_fd_set_356711149 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
typedef struct __anonstruct_fd_set_356711149 fd_set;
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
typedef unsigned long pthread_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
typedef int int32;
typedef unsigned int uint32;
typedef long int64;
typedef unsigned long uint64;
typedef void (*pqsigfunc)(int signo );
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
enum __anonenum_PGTransactionStatusType_947083977 {
    PQTRANS_IDLE = 0,
    PQTRANS_ACTIVE = 1,
    PQTRANS_INTRANS = 2,
    PQTRANS_INERROR = 3,
    PQTRANS_UNKNOWN = 4
} ;
typedef enum __anonenum_PGTransactionStatusType_947083977 PGTransactionStatusType;
struct pg_cancel ;
typedef struct pg_cancel PGcancel;
enum YesNo {
    DEFAULT = 0,
    NO = 1,
    YES = 2
} ;
typedef enum YesNo YesNo;
struct pgutConn ;
typedef struct pgutConn pgutConn;
struct pgutConn {
   PGconn *conn ;
   PGcancel *cancel ;
   pgutConn *next ;
};
struct pgutErrorData {
   int elevel ;
   int save_errno ;
   int code ;
   PQExpBufferData msg ;
   PQExpBufferData detail ;
};
typedef struct pgutErrorData pgutErrorData;
struct pgut_atexit_item ;
typedef struct pgut_atexit_item pgut_atexit_item;
struct pgut_atexit_item {
   void (*callback)(_Bool fatal , void *userdata ) ;
   void *userdata ;
   pgut_atexit_item *next ;
};
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
/* compiler builtin:
   void *__builtin___mempcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin:
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin:
   char *__builtin___stpcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin:
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* compiler builtin:
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin:
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin:
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* compiler builtin:
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin:
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin:
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin:
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin:
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* compiler builtin:
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
#pragma merger("0","/tmp/cil-cvujKFDm.i","-Wall,-Wmissing-prototypes,-Wpointer-arith,-Wdeclaration-after-statement,-Werror=vla,-Wendif-labels,-Wmissing-format-attribute,-Wimplicit-fallthrough=3,-Wformat-security,-fno-strict-aliasing,-fwrapv,-fexcess-precision=standard,-Wno-format-truncation,-Wno-stringop-truncation,-g,-g,-O2,-fstack-protector-strong,-Wformat,-Werror=format-security,-fno-omit-frame-pointer,-Wdate-time")
char const   *PROGRAM_URL  =    "https://reorg.github.io/pg_repack/";
char const   *PROGRAM_ISSUES  =    "https://github.com/reorg/pg_repack/issues";
char const   *PROGRAM_VERSION  =    "1.4.7";
extern FILE *stdin ;
extern FILE *stdout ;
extern FILE *stderr ;
__inline extern int ( __attribute__((__gnu_inline__, __always_inline__)) vfprintf)(FILE * __restrict  __stream ,
                                                                                   char const   * __restrict  __fmt ,
                                                                                   __gnuc_va_list __ap ) ;
__inline extern int ( __attribute__((__gnu_inline__, __always_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                                                  __gnuc_va_list __ap ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__,
__always_inline__)) vsprintf)(char * __restrict  __s , char const   * __restrict  __fmt ,
                              __gnuc_va_list __ap ) ;
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__gnu_inline__,
__always_inline__)) vsnprintf)(char * __restrict  __s , size_t __n , char const   * __restrict  __fmt ,
                               __gnuc_va_list __ap ) ;
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__warn_unused_result__,
__gnu_inline__, __always_inline__)) vasprintf)(char ** __restrict  __ptr , char const   * __restrict  __fmt ,
                                               __gnuc_va_list __ap ) ;
__inline extern int ( /* format attribute */ __attribute__((__gnu_inline__, __always_inline__)) vdprintf)(int __fd ,
                                                                                                          char const   * __restrict  __fmt ,
                                                                                                          __gnuc_va_list __ap ) ;
extern int getc(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
extern int putc(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) fgets)(char * __restrict  __s ,
                                                                                                          int __n ,
                                                                                                          FILE * __restrict  __stream ) ;
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) fgets_unlocked)(char * __restrict  __s ,
                                                                                                                   int __n ,
                                                                                                                   FILE * __restrict  __stream ) ;
extern __ssize_t ( __attribute__((__warn_unused_result__)) __getdelim)(char ** __restrict  __lineptr ,
                                                                       size_t * __restrict  __n ,
                                                                       int __delimiter ,
                                                                       FILE * __restrict  __stream ) ;
__inline extern __ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                                             size_t * __restrict  __n ,
                                                                                             FILE * __restrict  __stream ) ;
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) fread)(void * __restrict  __ptr ,
                                                                                                           size_t __size ,
                                                                                                           size_t __n ,
                                                                                                           FILE * __restrict  __stream ) ;
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) fread_unlocked)(void * __restrict  __ptr ,
                                                                                                                    size_t __size ,
                                                                                                                    size_t __n ,
                                                                                                                    FILE * __restrict  __stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__gnu_inline__,
__always_inline__)) obstack_vprintf)(struct obstack * __restrict  __obstack , char const   * __restrict  __fmt ,
                                     __gnuc_va_list __ap ) ;
extern int __uflow(FILE * ) ;
extern int __overflow(FILE * , int  ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void)
{
  int tmp ;

  {
  tmp = getc(stdin);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp )
{
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(__fp);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = __fp->_IO_read_ptr;
    (__fp->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void)
{
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(stdin);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = stdin->_IO_read_ptr;
    (stdin->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c )
{
  int tmp ;

  {
  tmp = putc(__c, stdout);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream )
{
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = __stream->_IO_write_ptr;
    (__stream->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c )
{
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = stdout->_IO_write_ptr;
    (stdout->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern __ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                                             size_t * __restrict  __n ,
                                                                                             FILE * __restrict  __stream )
{
  __ssize_t tmp ;

  {
  tmp = __getdelim(__lineptr, __n, '\n', __stream);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__warn_unused_result__, __gnu_inline__)) feof_unlocked)(FILE *__stream )
{


  {
  return ((__stream->_flags & 16) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__warn_unused_result__, __gnu_inline__)) ferror_unlocked)(FILE *__stream )
{


  {
  return ((__stream->_flags & 32) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__,
__always_inline__)) vsprintf)(char * __restrict  __s , char const   * __restrict  __fmt ,
                              __gnuc_va_list __ap ) ;
__inline extern int ( __attribute__((__gnu_inline__, __always_inline__)) vsprintf)(char * __restrict  __s ,
                                                                                   char const   * __restrict  __fmt ,
                                                                                   __gnuc_va_list __ap )
{
  unsigned long tmp ;
  int tmp___0 ;

  {
  tmp = __builtin_object_size((void *)__s, 1);
  tmp___0 = __builtin___vsprintf_chk((char *)__s, 1, tmp, (char const   *)__fmt, __ap);
  return (tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__gnu_inline__,
__always_inline__)) vsnprintf)(char * __restrict  __s , size_t __n , char const   * __restrict  __fmt ,
                               __gnuc_va_list __ap ) ;
__inline extern int ( /* format attribute */ __attribute__((__gnu_inline__, __always_inline__)) vsnprintf)(char * __restrict  __s ,
                                                                                                           size_t __n ,
                                                                                                           char const   * __restrict  __fmt ,
                                                                                                           __gnuc_va_list __ap )
{
  unsigned long tmp ;
  int tmp___0 ;

  {
  tmp = __builtin_object_size((void *)__s, 1);
  tmp___0 = __builtin___vsnprintf_chk((char *)__s, __n, 1, tmp, (char const   *)__fmt,
                                      __ap);
  return (tmp___0);
}
}
extern int __vfprintf_chk(FILE * __restrict  __stream , int __flag , char const   * __restrict  __format ,
                          __gnuc_va_list __ap ) ;
__inline extern int ( __attribute__((__gnu_inline__, __always_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                                                  __gnuc_va_list __ap )
{
  int tmp ;

  {
  tmp = __vfprintf_chk((FILE * __restrict  )stdout, 1, __fmt, __ap);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__, __always_inline__)) vfprintf)(FILE * __restrict  __stream ,
                                                                                   char const   * __restrict  __fmt ,
                                                                                   __gnuc_va_list __ap )
{
  int tmp ;

  {
  tmp = __vfprintf_chk(__stream, 1, __fmt, __ap);
  return (tmp);
}
}
extern int ( /* format attribute */  __vdprintf_chk)(int __fd , int __flag , char const   * __restrict  __fmt ,
                                                     __gnuc_va_list __arg ) ;
__inline extern int ( /* format attribute */ __attribute__((__gnu_inline__, __always_inline__)) vdprintf)(int __fd ,
                                                                                                          char const   * __restrict  __fmt ,
                                                                                                          __gnuc_va_list __ap )
{
  int tmp ;

  {
  tmp = __vdprintf_chk(__fd, 1, __fmt, __ap);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__warn_unused_result__)) __vasprintf_chk)(char ** __restrict  __ptr ,
                                                                                                                           int __flag ,
                                                                                                                           char const   * __restrict  __fmt ,
                                                                                                                           __gnuc_va_list __arg ) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  __obstack_vprintf_chk)(struct obstack * __restrict  __obstack ,
                                                                                          int __flag ,
                                                                                          char const   * __restrict  __format ,
                                                                                          __gnuc_va_list __args ) ;
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__warn_unused_result__,
__gnu_inline__, __always_inline__)) vasprintf)(char ** __restrict  __ptr , char const   * __restrict  __fmt ,
                                               __gnuc_va_list __ap ) ;
__inline extern int ( /* format attribute */ __attribute__((__warn_unused_result__,
__gnu_inline__, __always_inline__)) vasprintf)(char ** __restrict  __ptr , char const   * __restrict  __fmt ,
                                               __gnuc_va_list __ap )
{
  int tmp ;

  {
  tmp = __vasprintf_chk(__ptr, 1, __fmt, __ap);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__gnu_inline__,
__always_inline__)) obstack_vprintf)(struct obstack * __restrict  __obstack , char const   * __restrict  __fmt ,
                                     __gnuc_va_list __ap ) ;
__inline extern int ( /* format attribute */ __attribute__((__gnu_inline__, __always_inline__)) obstack_vprintf)(struct obstack * __restrict  __obstack ,
                                                                                                                 char const   * __restrict  __fmt ,
                                                                                                                 __gnuc_va_list __ap )
{
  int tmp ;

  {
  tmp = __obstack_vprintf_chk(__obstack, 1, __fmt, __ap);
  return (tmp);
}
}
extern char *( __attribute__((__warn_unused_result__)) __fgets_chk)(char * __restrict  __s ,
                                                                    size_t __size ,
                                                                    int __n , FILE * __restrict  __stream ) ;
extern char *( __attribute__((__warn_unused_result__)) __fgets_alias)(char * __restrict  __s ,
                                                                      int __n , FILE * __restrict  __stream )  __asm__("fgets")  ;
extern char *( __attribute__((__warn_unused_result__)) __fgets_chk_warn)(char * __restrict  __s ,
                                                                         size_t __size ,
                                                                         int __n ,
                                                                         FILE * __restrict  __stream )  __asm__("__fgets_chk")  ;
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) fgets)(char * __restrict  __s ,
                                                                                                          int __n ,
                                                                                                          FILE * __restrict  __stream )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__s, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__s, 1);
    tmp___0 = __fgets_chk(__s, tmp, __n, __stream);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__s, 1);
    if ((size_t )__n > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__s, 1);
      tmp___2 = __fgets_chk_warn(__s, tmp___1, __n, __stream);
      return (tmp___2);
    }
  }
  tmp___5 = __fgets_alias(__s, __n, __stream);
  return (tmp___5);
}
}
extern size_t ( __attribute__((__warn_unused_result__)) __fread_chk)(void * __restrict  __ptr ,
                                                                     size_t __ptrlen ,
                                                                     size_t __size ,
                                                                     size_t __n ,
                                                                     FILE * __restrict  __stream ) ;
extern size_t ( __attribute__((__warn_unused_result__)) __fread_alias)(void * __restrict  __ptr ,
                                                                       size_t __size ,
                                                                       size_t __n ,
                                                                       FILE * __restrict  __stream )  __asm__("fread")  ;
extern size_t ( __attribute__((__warn_unused_result__)) __fread_chk_warn)(void * __restrict  __ptr ,
                                                                          size_t __ptrlen ,
                                                                          size_t __size ,
                                                                          size_t __n ,
                                                                          FILE * __restrict  __stream )  __asm__("__fread_chk")  ;
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) fread)(void * __restrict  __ptr ,
                                                                                                           size_t __size ,
                                                                                                           size_t __n ,
                                                                                                           FILE * __restrict  __stream )
{
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__ptr, 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__ptr, 0);
    tmp___0 = __fread_chk(__ptr, tmp, __size, __n, __stream);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__ptr, 0);
    if (__size * __n > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__ptr, 0);
      tmp___2 = __fread_chk_warn(__ptr, tmp___1, __size, __n, __stream);
      return (tmp___2);
    }
  }
  tmp___5 = __fread_alias(__ptr, __size, __n, __stream);
  return (tmp___5);
}
}
extern char *( __attribute__((__warn_unused_result__)) __fgets_unlocked_chk)(char * __restrict  __s ,
                                                                             size_t __size ,
                                                                             int __n ,
                                                                             FILE * __restrict  __stream ) ;
extern char *( __attribute__((__warn_unused_result__)) __fgets_unlocked_alias)(char * __restrict  __s ,
                                                                               int __n ,
                                                                               FILE * __restrict  __stream )  __asm__("fgets_unlocked")  ;
extern char *( __attribute__((__warn_unused_result__)) __fgets_unlocked_chk_warn)(char * __restrict  __s ,
                                                                                  size_t __size ,
                                                                                  int __n ,
                                                                                  FILE * __restrict  __stream )  __asm__("__fgets_unlocked_chk")  ;
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) fgets_unlocked)(char * __restrict  __s ,
                                                                                                                   int __n ,
                                                                                                                   FILE * __restrict  __stream )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__s, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__s, 1);
    tmp___0 = __fgets_unlocked_chk(__s, tmp, __n, __stream);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__s, 1);
    if ((size_t )__n > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__s, 1);
      tmp___2 = __fgets_unlocked_chk_warn(__s, tmp___1, __n, __stream);
      return (tmp___2);
    }
  }
  tmp___5 = __fgets_unlocked_alias(__s, __n, __stream);
  return (tmp___5);
}
}
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_chk)(void * __restrict  __ptr ,
                                                                              size_t __ptrlen ,
                                                                              size_t __size ,
                                                                              size_t __n ,
                                                                              FILE * __restrict  __stream ) ;
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_alias)(void * __restrict  __ptr ,
                                                                                size_t __size ,
                                                                                size_t __n ,
                                                                                FILE * __restrict  __stream )  __asm__("fread_unlocked")  ;
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_chk_warn)(void * __restrict  __ptr ,
                                                                                   size_t __ptrlen ,
                                                                                   size_t __size ,
                                                                                   size_t __n ,
                                                                                   FILE * __restrict  __stream )  __asm__("__fread_unlocked_chk")  ;
__inline extern size_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) fread_unlocked)(void * __restrict  __ptr ,
                                                                                                                    size_t __size ,
                                                                                                                    size_t __n ,
                                                                                                                    FILE * __restrict  __stream )
{
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___7 ;

  {
  tmp___4 = __builtin_object_size((void *)__ptr, 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__ptr, 0);
    tmp___0 = __fread_unlocked_chk(__ptr, tmp, __size, __n, __stream);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__ptr, 0);
    if (__size * __n > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__ptr, 0);
      tmp___2 = __fread_unlocked_chk_warn(__ptr, tmp___1, __size, __n, __stream);
      return (tmp___2);
    }
  }
  tmp___7 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
  return (tmp___7);
}
}
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__warn_unused_result__,
__nonnull__(1), __gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1))) strtoul)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1))) strtoll)(char const   * __restrict  __nptr ,
                                                                                          char ** __restrict  __endptr ,
                                                                                          int __base ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __gnu_inline__)) atoi)(char const   *__nptr )
{
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return ((int )tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __gnu_inline__)) atol)(char const   *__nptr )
{
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )
{
  long long tmp ;

  {
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) calloc)(size_t __nmemb ,
                                                                                             size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__nonnull__(1))) getenv)(char const   *__name ) ;
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__gnu_inline__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                              char * __restrict  __resolved ) ;
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch)(void const   *__key , void const   *__base , size_t __nmemb ,
                          size_t __size , int (*__compar)(void const   * , void const   * ) ) ;
__inline extern void *( __attribute__((__warn_unused_result__, __nonnull__(1,2,5),
__gnu_inline__)) bsearch)(void const   *__key , void const   *__base , size_t __nmemb ,
                          size_t __size , int (*__compar)(void const   * , void const   * ) )
{
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
  __l = (size_t )0;
  __u = __nmemb;
  while (__l < __u) {
    __idx = (__l + __u) / 2UL;
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
    __comparison = (*__compar)(__key, __p);
    if (__comparison < 0) {
      __u = __idx;
    } else
    if (__comparison > 0) {
      __l = __idx + 1UL;
    } else {
      return ((void *)__p);
    }
  }
  return ((void *)0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__gnu_inline__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar ) ;
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__,
__always_inline__)) mbstowcs)(wchar_t * __restrict  __dst , char const   * __restrict  __src ,
                              size_t __len ) ;
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__,
__always_inline__)) wcstombs)(char * __restrict  __dst , wchar_t const   * __restrict  __src ,
                              size_t __len ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__, __always_inline__)) ptsname_r)(int __fd , char *__buf , size_t __buflen ) ;
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__warn_unused_result__,
__nonnull__(1), __gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __gnu_inline__)) atof)(char const   *__nptr )
{
  double tmp ;

  {
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__)) __realpath_chk)(char const   * __restrict  __name ,
                                                                                                     char * __restrict  __resolved ,
                                                                                                     size_t __resolvedlen ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__)) __realpath_alias)(char const   * __restrict  __name ,
                                                                                                       char * __restrict  __resolved )  __asm__("realpath")  ;
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__gnu_inline__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                              char * __restrict  __resolved ) ;
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                                                                                             char * __restrict  __resolved )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
  tmp___1 = __builtin_object_size((void *)__resolved, 1);
  if (tmp___1 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__resolved, 1);
    tmp___0 = __realpath_chk(__name, __resolved, tmp);
    return (tmp___0);
  }
  tmp___2 = __realpath_alias(__name, __resolved);
  return (tmp___2);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) __ptsname_r_chk)(int __fd ,
                                                                                            char *__buf ,
                                                                                            size_t __buflen ,
                                                                                            size_t __nreal ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) __ptsname_r_alias)(int __fd ,
                                                                                              char *__buf ,
                                                                                              size_t __buflen )  __asm__("ptsname_r")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) __ptsname_r_chk_warn)(int __fd ,
                                                                                                 char *__buf ,
                                                                                                 size_t __buflen ,
                                                                                                 size_t __nreal )  __asm__("__ptsname_r_chk")  ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__, __always_inline__)) ptsname_r)(int __fd , char *__buf , size_t __buflen ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__, __always_inline__)) ptsname_r)(int __fd ,
                                                                                                    char *__buf ,
                                                                                                    size_t __buflen )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __ptsname_r_chk(__fd, __buf, __buflen, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (__buflen > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __ptsname_r_chk_warn(__fd, __buf, __buflen, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __ptsname_r_alias(__fd, __buf, __buflen);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__)) __wctomb_chk)(char *__s ,
                                                                                                 wchar_t __wchar ,
                                                                                                 size_t __buflen ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__)) __wctomb_alias)(char *__s ,
                                                                                                   wchar_t __wchar )  __asm__("wctomb")  ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__gnu_inline__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar ) ;
__inline extern int ( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) wctomb)(char *__s ,
                                                                                                         wchar_t __wchar )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;

  {
  tmp___1 = __builtin_object_size((void *)__s, 1);
  if (tmp___1 != 0xffffffffffffffffUL) {
    tmp___2 = __builtin_object_size((void *)__s, 1);
    if (16UL > tmp___2) {
      tmp = __builtin_object_size((void *)__s, 1);
      tmp___0 = __wctomb_chk(__s, __wchar, tmp);
      return (tmp___0);
    }
  }
  tmp___3 = __wctomb_alias(__s, __wchar);
  return (tmp___3);
}
}
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk(wchar_t * __restrict  __dst ,
                                                           char const   * __restrict  __src ,
                                                           size_t __len , size_t __dstlen ) ;
extern  __attribute__((__nothrow__)) size_t __mbstowcs_alias(wchar_t * __restrict  __dst ,
                                                             char const   * __restrict  __src ,
                                                             size_t __len )  __asm__("mbstowcs")  ;
extern  __attribute__((__nothrow__)) size_t __mbstowcs_chk_warn(wchar_t * __restrict  __dst ,
                                                                char const   * __restrict  __src ,
                                                                size_t __len , size_t __dstlen )  __asm__("__mbstowcs_chk")  ;
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__,
__always_inline__)) mbstowcs)(wchar_t * __restrict  __dst , char const   * __restrict  __src ,
                              size_t __len ) ;
__inline extern size_t ( __attribute__((__gnu_inline__, __always_inline__)) mbstowcs)(wchar_t * __restrict  __dst ,
                                                                                      char const   * __restrict  __src ,
                                                                                      size_t __len )
{
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__dst, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__dst, 1);
    tmp___0 = __mbstowcs_chk(__dst, __src, __len, tmp / sizeof(wchar_t ));
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__dst, 1);
    if (__len > tmp___3 / sizeof(wchar_t )) {
      tmp___1 = __builtin_object_size((void *)__dst, 1);
      tmp___2 = __mbstowcs_chk_warn(__dst, __src, __len, tmp___1 / sizeof(wchar_t ));
      return (tmp___2);
    }
  }
  tmp___5 = __mbstowcs_alias(__dst, __src, __len);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk(char * __restrict  __dst ,
                                                           wchar_t const   * __restrict  __src ,
                                                           size_t __len , size_t __dstlen ) ;
extern  __attribute__((__nothrow__)) size_t __wcstombs_alias(char * __restrict  __dst ,
                                                             wchar_t const   * __restrict  __src ,
                                                             size_t __len )  __asm__("wcstombs")  ;
extern  __attribute__((__nothrow__)) size_t __wcstombs_chk_warn(char * __restrict  __dst ,
                                                                wchar_t const   * __restrict  __src ,
                                                                size_t __len , size_t __dstlen )  __asm__("__wcstombs_chk")  ;
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__,
__always_inline__)) wcstombs)(char * __restrict  __dst , wchar_t const   * __restrict  __src ,
                              size_t __len ) ;
__inline extern size_t ( __attribute__((__gnu_inline__, __always_inline__)) wcstombs)(char * __restrict  __dst ,
                                                                                      wchar_t const   * __restrict  __src ,
                                                                                      size_t __len )
{
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__dst, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__dst, 1);
    tmp___0 = __wcstombs_chk(__dst, __src, __len, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__dst, 1);
    if (__len > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__dst, 1);
      tmp___2 = __wcstombs_chk_warn(__dst, __src, __len, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __wcstombs_alias(__dst, __src, __len);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) tolower)(int __c )
{
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_tolower_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
    tmp___0 = (__int32_t const   )__c;
  }
  return ((int )tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) toupper)(int __c )
{
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_toupper_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
    tmp___0 = (__int32_t const   )__c;
  }
  return ((int )tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                               struct cmsghdr *__cmsg ) ;
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                               struct cmsghdr *__cmsg ) ;
__inline extern struct cmsghdr *( __attribute__((__gnu_inline__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                 struct cmsghdr *__cmsg )
{


  {
  if (__cmsg->cmsg_len < sizeof(struct cmsghdr )) {
    return ((struct cmsghdr *)0);
  }
  __cmsg = (struct cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)));
  if ((unsigned long )((unsigned char *)(__cmsg + 1)) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  } else
  if ((unsigned long )((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  }
  return (__cmsg);
}
}
__inline extern ssize_t ( __attribute__((__gnu_inline__, __always_inline__)) recv)(int __fd ,
                                                                                   void *__buf ,
                                                                                   size_t __n ,
                                                                                   int __flags ) ;
__inline extern ssize_t ( __attribute__((__gnu_inline__, __always_inline__)) recvfrom)(int __fd ,
                                                                                       void * __restrict  __buf ,
                                                                                       size_t __n ,
                                                                                       int __flags ,
                                                                                       struct sockaddr * __restrict  __cil_tmp14 ,
                                                                                       socklen_t * __restrict  __addr_len ) ;
extern ssize_t __recv_chk(int __fd , void *__buf , size_t __n , size_t __buflen ,
                          int __flags ) ;
extern ssize_t __recv_alias(int __fd , void *__buf , size_t __n , int __flags )  __asm__("recv")  ;
extern ssize_t __recv_chk_warn(int __fd , void *__buf , size_t __n , size_t __buflen ,
                               int __flags )  __asm__("__recv_chk")  ;
__inline extern ssize_t ( __attribute__((__gnu_inline__, __always_inline__)) recv)(int __fd ,
                                                                                   void *__buf ,
                                                                                   size_t __n ,
                                                                                   int __flags )
{
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size(__buf, 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size(__buf, 0);
    tmp___0 = __recv_chk(__fd, __buf, __n, tmp, __flags);
    return (tmp___0);
    tmp___3 = __builtin_object_size(__buf, 0);
    if (__n > tmp___3) {
      tmp___1 = __builtin_object_size(__buf, 0);
      tmp___2 = __recv_chk_warn(__fd, __buf, __n, tmp___1, __flags);
      return (tmp___2);
    }
  }
  tmp___5 = __recv_alias(__fd, __buf, __n, __flags);
  return (tmp___5);
}
}
extern ssize_t __recvfrom_chk(int __fd , void * __restrict  __buf , size_t __n , size_t __buflen ,
                              int __flags , struct sockaddr * __restrict  __addr ,
                              socklen_t * __restrict  __addr_len ) ;
extern ssize_t __recvfrom_alias(int __fd , void * __restrict  __buf , size_t __n ,
                                int __flags , struct sockaddr * __restrict  __addr ,
                                socklen_t * __restrict  __addr_len )  __asm__("recvfrom")  ;
extern ssize_t __recvfrom_chk_warn(int __fd , void * __restrict  __buf , size_t __n ,
                                   size_t __buflen , int __flags , struct sockaddr * __restrict  __addr ,
                                   socklen_t * __restrict  __addr_len )  __asm__("__recvfrom_chk")  ;
__inline extern ssize_t ( __attribute__((__gnu_inline__, __always_inline__)) recvfrom)(int __fd ,
                                                                                       void * __restrict  __buf ,
                                                                                       size_t __n ,
                                                                                       int __flags ,
                                                                                       struct sockaddr * __restrict  __cil_tmp14 ,
                                                                                       socklen_t * __restrict  __addr_len )
{
  __SOCKADDR_ARG __addr ;
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
  __addr.__sockaddr__ = __cil_tmp14;
  tmp___4 = __builtin_object_size((void *)__buf, 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 0);
    tmp___0 = __recvfrom_chk(__fd, __buf, __n, tmp, __flags, __addr.__sockaddr__,
                             __addr_len);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 0);
    if (__n > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 0);
      tmp___2 = __recvfrom_chk_warn(__fd, __buf, __n, tmp___1, __flags, __addr.__sockaddr__,
                                    __addr_len);
      return (tmp___2);
    }
  }
  tmp___5 = __recvfrom_alias(__fd, __buf, __n, __flags, __addr.__sockaddr__, __addr_len);
  return (tmp___5);
}
}
extern int ( /* format attribute */  pg_snprintf)(char *str , size_t count , char const   *fmt
                                                  , ...) ;
extern int ( /* format attribute */  pg_sprintf)(char *str , char const   *fmt  , ...) ;
extern int ( /* format attribute */  pg_fprintf)(FILE *stream , char const   *fmt
                                                 , ...) ;
extern int ( /* format attribute */  pg_printf)(char const   *fmt  , ...) ;
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) read)(int __fd ,
                                                                                                           void *__buf ,
                                                                                                           size_t __nbytes ) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) pread)(int __fd ,
                                                                                                            void *__buf ,
                                                                                                            size_t __nbytes ,
                                                                                                            __off_t __offset ) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) pread64)(int __fd ,
                                                                                                              void *__buf ,
                                                                                                              size_t __nbytes ,
                                                                                                              __off64_t __offset ) ;
extern unsigned int sleep(unsigned int __seconds ) ;
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__gnu_inline__, __always_inline__)) getcwd)(char *__buf , size_t __size ) ;
__inline extern  __attribute__((__nothrow__)) char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __gnu_inline__, __always_inline__)) getwd)(char *__buf )  __attribute__((__deprecated__)) ;
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__,
__always_inline__)) confstr)(int __name , char *__buf , size_t __len ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__gnu_inline__, __always_inline__)) getgroups)(int __size , __gid_t *__list ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(2), __gnu_inline__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen ) ;
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __gnu_inline__, __always_inline__)) readlink)(char const   * __restrict  __path ,
                                                                char * __restrict  __buf ,
                                                                size_t __len ) ;
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __gnu_inline__, __always_inline__)) readlinkat)(int __fd , char const   * __restrict  __path ,
                                                                  char * __restrict  __buf ,
                                                                  size_t __len ) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__, __always_inline__)) getlogin_r)(char *__buf ,
                                                                                                     size_t __buflen ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__, __always_inline__)) gethostname)(char *__buf , size_t __buflen ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __gnu_inline__, __always_inline__)) getdomainname)(char *__buf , size_t __buflen ) ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_chk)(int __fd , void *__buf ,
                                                                     size_t __nbytes ,
                                                                     size_t __buflen ) ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_alias)(int __fd ,
                                                                       void *__buf ,
                                                                       size_t __nbytes )  __asm__("read")  ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_chk_warn)(int __fd ,
                                                                          void *__buf ,
                                                                          size_t __nbytes ,
                                                                          size_t __buflen )  __asm__("__read_chk")  ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) read)(int __fd ,
                                                                                                           void *__buf ,
                                                                                                           size_t __nbytes )
{
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size(__buf, 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size(__buf, 0);
    tmp___0 = __read_chk(__fd, __buf, __nbytes, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size(__buf, 0);
    if (__nbytes > tmp___3) {
      tmp___1 = __builtin_object_size(__buf, 0);
      tmp___2 = __read_chk_warn(__fd, __buf, __nbytes, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __read_alias(__fd, __buf, __nbytes);
  return (tmp___5);
}
}
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread_chk)(int __fd , void *__buf ,
                                                                      size_t __nbytes ,
                                                                      __off_t __offset ,
                                                                      size_t __bufsize ) ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread64_chk)(int __fd ,
                                                                        void *__buf ,
                                                                        size_t __nbytes ,
                                                                        __off64_t __offset ,
                                                                        size_t __bufsize ) ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread_alias)(int __fd ,
                                                                        void *__buf ,
                                                                        size_t __nbytes ,
                                                                        __off_t __offset )  __asm__("pread")  ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread64_alias)(int __fd ,
                                                                          void *__buf ,
                                                                          size_t __nbytes ,
                                                                          __off64_t __offset )  __asm__("pread64")  ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread_chk_warn)(int __fd ,
                                                                           void *__buf ,
                                                                           size_t __nbytes ,
                                                                           __off_t __offset ,
                                                                           size_t __bufsize )  __asm__("__pread_chk")  ;
extern ssize_t ( __attribute__((__warn_unused_result__)) __pread64_chk_warn)(int __fd ,
                                                                             void *__buf ,
                                                                             size_t __nbytes ,
                                                                             __off64_t __offset ,
                                                                             size_t __bufsize )  __asm__("__pread64_chk")  ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) pread)(int __fd ,
                                                                                                            void *__buf ,
                                                                                                            size_t __nbytes ,
                                                                                                            __off_t __offset )
{
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size(__buf, 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size(__buf, 0);
    tmp___0 = __pread_chk(__fd, __buf, __nbytes, __offset, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size(__buf, 0);
    if (__nbytes > tmp___3) {
      tmp___1 = __builtin_object_size(__buf, 0);
      tmp___2 = __pread_chk_warn(__fd, __buf, __nbytes, __offset, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __pread_alias(__fd, __buf, __nbytes, __offset);
  return (tmp___5);
}
}
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) pread64)(int __fd ,
                                                                                                              void *__buf ,
                                                                                                              size_t __nbytes ,
                                                                                                              __off64_t __offset )
{
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size(__buf, 0);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size(__buf, 0);
    tmp___0 = __pread64_chk(__fd, __buf, __nbytes, __offset, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size(__buf, 0);
    if (__nbytes > tmp___3) {
      tmp___1 = __builtin_object_size(__buf, 0);
      tmp___2 = __pread64_chk_warn(__fd, __buf, __nbytes, __offset, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __pread64_alias(__fd, __buf, __nbytes, __offset);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2))) __readlink_chk)(char const   * __restrict  __path , char * __restrict  __buf ,
                                   size_t __len , size_t __buflen ) ;
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2))) __readlink_alias)(char const   * __restrict  __path , char * __restrict  __buf ,
                                     size_t __len )  __asm__("readlink")  ;
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2))) __readlink_chk_warn)(char const   * __restrict  __path , char * __restrict  __buf ,
                                        size_t __len , size_t __buflen )  __asm__("__readlink_chk")  ;
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __gnu_inline__, __always_inline__)) readlink)(char const   * __restrict  __path ,
                                                                char * __restrict  __buf ,
                                                                size_t __len ) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2),
__gnu_inline__, __always_inline__)) readlink)(char const   * __restrict  __path ,
                                              char * __restrict  __buf , size_t __len )
{
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __readlink_chk(__path, __buf, __len, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (__len > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __readlink_chk_warn(__path, __buf, __len, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __readlink_alias(__path, __buf, __len);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3))) __readlinkat_chk)(int __fd , char const   * __restrict  __path ,
                                     char * __restrict  __buf , size_t __len , size_t __buflen ) ;
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3))) __readlinkat_alias)(int __fd , char const   * __restrict  __path ,
                                       char * __restrict  __buf , size_t __len )  __asm__("readlinkat")  ;
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3))) __readlinkat_chk_warn)(int __fd , char const   * __restrict  __path ,
                                          char * __restrict  __buf , size_t __len ,
                                          size_t __buflen )  __asm__("__readlinkat_chk")  ;
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __gnu_inline__, __always_inline__)) readlinkat)(int __fd , char const   * __restrict  __path ,
                                                                  char * __restrict  __buf ,
                                                                  size_t __len ) ;
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3),
__gnu_inline__, __always_inline__)) readlinkat)(int __fd , char const   * __restrict  __path ,
                                                char * __restrict  __buf , size_t __len )
{
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __readlinkat_chk(__fd, __path, __buf, __len, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (__len > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __readlinkat_chk_warn(__fd, __path, __buf, __len, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __readlinkat_alias(__fd, __path, __buf, __len);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__)) __getcwd_chk)(char *__buf ,
                                                                                                   size_t __size ,
                                                                                                   size_t __buflen ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__)) __getcwd_alias)(char *__buf ,
                                                                                                     size_t __size )  __asm__("getcwd")  ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__)) __getcwd_chk_warn)(char *__buf ,
                                                                                                        size_t __size ,
                                                                                                        size_t __buflen )  __asm__("__getcwd_chk")  ;
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__gnu_inline__, __always_inline__)) getcwd)(char *__buf , size_t __size ) ;
__inline extern char *( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) getcwd)(char *__buf ,
                                                                                                           size_t __size )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __getcwd_chk(__buf, __size, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (__size > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __getcwd_chk_warn(__buf, __size, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __getcwd_alias(__buf, __size);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__nonnull__(1))) __getwd_chk)(char *__buf , size_t buflen ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__nonnull__(1))) __getwd_warn)(char *__buf )  __asm__("getwd")  ;
__inline extern  __attribute__((__nothrow__)) char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __gnu_inline__, __always_inline__)) getwd)(char *__buf )  __attribute__((__deprecated__)) ;
__inline extern char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __gnu_inline__, __always_inline__)) getwd)(char *__buf )
{
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
  tmp___1 = __builtin_object_size((void *)__buf, 1);
  if (tmp___1 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __getwd_chk(__buf, tmp);
    return ((char __attribute__((__deprecated__))  *)tmp___0);
  }
  tmp___2 = __getwd_warn(__buf);
  return ((char __attribute__((__deprecated__))  *)tmp___2);
}
}
extern  __attribute__((__nothrow__)) size_t __confstr_chk(int __name , char *__buf ,
                                                          size_t __len , size_t __buflen ) ;
extern  __attribute__((__nothrow__)) size_t __confstr_alias(int __name , char *__buf ,
                                                            size_t __len )  __asm__("confstr")  ;
extern  __attribute__((__nothrow__)) size_t __confstr_chk_warn(int __name , char *__buf ,
                                                               size_t __len , size_t __buflen )  __asm__("__confstr_chk")  ;
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__gnu_inline__,
__always_inline__)) confstr)(int __name , char *__buf , size_t __len ) ;
__inline extern size_t ( __attribute__((__gnu_inline__, __always_inline__)) confstr)(int __name ,
                                                                                     char *__buf ,
                                                                                     size_t __len )
{
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __confstr_chk(__name, __buf, __len, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (tmp___3 < __len) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __confstr_chk_warn(__name, __buf, __len, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __confstr_alias(__name, __buf, __len);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__)) __getgroups_chk)(int __size ,
                                                                                                    __gid_t *__list ,
                                                                                                    size_t __listlen ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__)) __getgroups_alias)(int __size ,
                                                                                                      __gid_t *__list )  __asm__("getgroups")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__)) __getgroups_chk_warn)(int __size ,
                                                                                                         __gid_t *__list ,
                                                                                                         size_t __listlen )  __asm__("__getgroups_chk")  ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__gnu_inline__, __always_inline__)) getgroups)(int __size , __gid_t *__list ) ;
__inline extern int ( __attribute__((__warn_unused_result__, __gnu_inline__, __always_inline__)) getgroups)(int __size ,
                                                                                                            __gid_t *__list )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__list, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__list, 1);
    tmp___0 = __getgroups_chk(__size, __list, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__list, 1);
    if ((unsigned long )__size * sizeof(__gid_t ) > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__list, 1);
      tmp___2 = __getgroups_chk_warn(__size, __list, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __getgroups_alias(__size, __list);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) __ttyname_r_chk)(int __fd ,
                                                                                            char *__buf ,
                                                                                            size_t __buflen ,
                                                                                            size_t __nreal ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) __ttyname_r_alias)(int __fd ,
                                                                                              char *__buf ,
                                                                                              size_t __buflen )  __asm__("ttyname_r")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2))) __ttyname_r_chk_warn)(int __fd ,
                                                                                                 char *__buf ,
                                                                                                 size_t __buflen ,
                                                                                                 size_t __nreal )  __asm__("__ttyname_r_chk")  ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(2), __gnu_inline__, __always_inline__)) ttyname_r)(int __fd , char *__buf ,
                                                               size_t __buflen ) ;
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __gnu_inline__,
__always_inline__)) ttyname_r)(int __fd , char *__buf , size_t __buflen )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __ttyname_r_chk(__fd, __buf, __buflen, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (__buflen > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __ttyname_r_chk_warn(__fd, __buf, __buflen, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __ttyname_r_alias(__fd, __buf, __buflen);
  return (tmp___5);
}
}
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_chk)(char *__buf , size_t __buflen ,
                                                               size_t __nreal ) ;
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_alias)(char *__buf , size_t __buflen )  __asm__("getlogin_r")  ;
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_chk_warn)(char *__buf ,
                                                                    size_t __buflen ,
                                                                    size_t __nreal )  __asm__("__getlogin_r_chk")  ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__, __always_inline__)) getlogin_r)(char *__buf ,
                                                                                                     size_t __buflen )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __getlogin_r_chk(__buf, __buflen, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (__buflen > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __getlogin_r_chk_warn(__buf, __buflen, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __getlogin_r_alias(__buf, __buflen);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) __gethostname_chk)(char *__buf ,
                                                                                              size_t __buflen ,
                                                                                              size_t __nreal ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) __gethostname_alias)(char *__buf ,
                                                                                                size_t __buflen )  __asm__("gethostname")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) __gethostname_chk_warn)(char *__buf ,
                                                                                                   size_t __buflen ,
                                                                                                   size_t __nreal )  __asm__("__gethostname_chk")  ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__, __always_inline__)) gethostname)(char *__buf , size_t __buflen ) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__, __always_inline__)) gethostname)(char *__buf ,
                                                                                                      size_t __buflen )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __gethostname_chk(__buf, __buflen, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (__buflen > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __gethostname_chk_warn(__buf, __buflen, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __gethostname_alias(__buf, __buflen);
  return (tmp___5);
}
}
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1))) __getdomainname_chk)(char *__buf , size_t __buflen , size_t __nreal ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1))) __getdomainname_alias)(char *__buf , size_t __buflen )  __asm__("getdomainname")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1))) __getdomainname_chk_warn)(char *__buf , size_t __buflen , size_t __nreal )  __asm__("__getdomainname_chk")  ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __gnu_inline__, __always_inline__)) getdomainname)(char *__buf , size_t __buflen ) ;
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __gnu_inline__,
__always_inline__)) getdomainname)(char *__buf , size_t __buflen )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__buf, 1);
  if (tmp___4 != 0xffffffffffffffffUL) {
    tmp = __builtin_object_size((void *)__buf, 1);
    tmp___0 = __getdomainname_chk(__buf, __buflen, tmp);
    return (tmp___0);
    tmp___3 = __builtin_object_size((void *)__buf, 1);
    if (__buflen > tmp___3) {
      tmp___1 = __builtin_object_size((void *)__buf, 1);
      tmp___2 = __getdomainname_chk_warn(__buf, __buflen, tmp___1);
      return (tmp___2);
    }
  }
  tmp___5 = __getdomainname_alias(__buf, __buflen);
  return (tmp___5);
}
}
extern ConnStatusType PQstatus(PGconn const   *conn ) ;
extern char const   *PQparameterStatus(PGconn const   *conn , char const   *paramName ) ;
extern int PQserverVersion(PGconn const   *conn ) ;
extern char *PQerrorMessage(PGconn const   *conn ) ;
extern int PQsocket(PGconn const   *conn ) ;
extern int PQsendQuery(PGconn *conn , char const   *query ) ;
extern PGresult *PQgetResult(PGconn *conn ) ;
extern int PQisBusy(PGconn *conn ) ;
extern int PQconsumeInput(PGconn *conn ) ;
extern int PQsetnonblocking(PGconn *conn , int arg ) ;
extern ExecStatusType PQresultStatus(PGresult const   *res ) ;
extern char *PQresultErrorField(PGresult const   *res , int fieldcode ) ;
extern int PQntuples(PGresult const   *res ) ;
extern char *PQgetvalue(PGresult const   *res , int tup_num , int field_num ) ;
extern int PQgetisnull(PGresult const   *res , int tup_num , int field_num ) ;
extern void PQclear(PGresult *res ) ;
extern void initPQExpBuffer(PQExpBuffer str ) ;
extern void termPQExpBuffer(PQExpBuffer str ) ;
extern void resetPQExpBuffer(PQExpBuffer str ) ;
extern void ( /* format attribute */  printfPQExpBuffer)(PQExpBuffer str , char const   *fmt
                                                         , ...) ;
extern void ( /* format attribute */  appendPQExpBuffer)(PQExpBuffer str , char const   *fmt
                                                         , ...) ;
extern void appendPQExpBufferStr(PQExpBuffer str , char const   *data ) ;
extern void appendPQExpBufferChar(PQExpBuffer str , char ch ) ;
int errcode(int sqlerrcode ) ;
int ( /* format attribute */  errmsg)(char const   *fmt  , ...) ;
int ( /* format attribute */  errdetail)(char const   *fmt  , ...) ;
char const   *PROGRAM_NAME ;
void pgut_atexit_push(void (*callback)(_Bool fatal , void *userdata ) , void *userdata ) ;
PGresult *pgut_execute(PGconn *conn , char const   *query , int nParams , char const   **params ) ;
PGresult *pgut_execute_elevel(PGconn *conn , char const   *query , int nParams , char const   **params ,
                              int elevel ) ;
ExecStatusType pgut_command(PGconn *conn , char const   *query , int nParams , char const   **params ) ;
void pgut_rollback(PGconn *conn ) ;
void *pgut_malloc(size_t size ) ;
char *pgut_strdup(char const   *str ) ;
void ( /* format attribute */  elog)(int elevel , char const   *fmt  , ...) ;
_Bool pgut_errstart(int elevel ) ;
void pgut_errfinish(int dummy  , ...) ;
void simple_string_list_append(SimpleStringList *list , char const   *val ) ;
size_t simple_string_list_size(SimpleStringList list ) ;
char *dbname ;
PGconn *connection ;
PGconn *conn2 ;
worker_conns workers ;
void pgut_help(_Bool details ) ;
void disconnect(void) ;
void reconnect(int elevel ) ;
void setup_workers(int num_workers ) ;
PGresult *execute(char const   *query , int nParams , char const   **params ) ;
PGresult *execute_elevel(char const   *query , int nParams , char const   **params ,
                         int elevel ) ;
ExecStatusType command(char const   *query , int nParams , char const   **params ) ;
int pgut_getopt(int argc , char **argv , pgut_option *options___0 ) ;
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
__inline extern int ( __attribute__((__gnu_inline__, __always_inline__)) poll)(struct pollfd *__fds ,
                                                                               nfds_t __nfds ,
                                                                               int __timeout ) ;
__inline extern int ( __attribute__((__gnu_inline__, __always_inline__)) ppoll)(struct pollfd *__fds ,
                                                                                nfds_t __nfds ,
                                                                                struct timespec  const  *__timeout ,
                                                                                __sigset_t const   *__ss ) ;
extern int __poll_alias(struct pollfd *__fds , nfds_t __nfds , int __timeout )  __asm__("poll")  ;
extern int __poll_chk(struct pollfd *__fds , nfds_t __nfds , int __timeout , unsigned long __fdslen ) ;
__inline extern int ( __attribute__((__gnu_inline__, __always_inline__)) poll)(struct pollfd *__fds ,
                                                                               nfds_t __nfds ,
                                                                               int __timeout )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__fds, 1);
  if (tmp___4 != 18446744073709551615) {
    tmp = __builtin_object_size((void *)__fds, 1);
    tmp___0 = __poll_chk(__fds, __nfds, __timeout, tmp);
    return (tmp___0);
  }
  tmp___5 = __poll_alias(__fds, __nfds, __timeout);
  return (tmp___5);
}
}
extern int __ppoll_alias(struct pollfd *__fds , nfds_t __nfds , struct timespec  const  *__timeout ,
                         __sigset_t const   *__ss )  __asm__("ppoll")  ;
extern int __ppoll_chk(struct pollfd *__fds , nfds_t __nfds , struct timespec  const  *__timeout ,
                       __sigset_t const   *__ss , unsigned long __fdslen ) ;
__inline extern int ( __attribute__((__gnu_inline__, __always_inline__)) ppoll)(struct pollfd *__fds ,
                                                                                nfds_t __nfds ,
                                                                                struct timespec  const  *__timeout ,
                                                                                __sigset_t const   *__ss )
{
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
  tmp___4 = __builtin_object_size((void *)__fds, 1);
  if (tmp___4 != 18446744073709551615) {
    tmp = __builtin_object_size((void *)__fds, 1);
    tmp___0 = __ppoll_chk(__fds, __nfds, __timeout, __ss, tmp);
    return (tmp___0);
  }
  tmp___5 = __ppoll_alias(__fds, __nfds, __timeout, __ss);
  return (tmp___5);
}
}
static _Bool is_superuser(void) ;
static void check_tablespace(void) ;
static _Bool preliminary_checks(char *errbuf , size_t errsize ) ;
static _Bool is_requested_relation_exists(char *errbuf , size_t errsize ) ;
static void repack_all_databases(char const   *orderby___0 ) ;
static _Bool repack_one_database(char const   *orderby___0 , char *errbuf , size_t errsize ) ;
static void repack_one_table(repack_table *table , char const   *orderby___0 ) ;
static _Bool repack_table_indexes(PGresult *index_details ) ;
static _Bool repack_all_indexes(char *errbuf , size_t errsize ) ;
static void repack_cleanup(_Bool fatal , repack_table const   *table ) ;
static void repack_cleanup_callback(_Bool fatal , void *userdata ) ;
static _Bool rebuild_indexes(repack_table const   *table ) ;
static char *getstr(PGresult *res , int row , int col ) ;
static Oid getoid(PGresult *res , int row , int col ) ;
static _Bool advisory_lock(PGconn *conn , char const   *relid ) ;
static _Bool lock_exclusive(PGconn *conn , char const   *relid , char const   *lock_query ,
                            _Bool start_xact ) ;
static _Bool kill_ddl(PGconn *conn , Oid relid , _Bool terminate ) ;
static _Bool lock_access_share(PGconn *conn , Oid relid , char const   *target_name ) ;
static _Bool sqlstate_equals(PGresult *res , char const   *state )
{
  char *tmp ;
  int tmp___0 ;

  {
  tmp = PQresultErrorField((PGresult const   *)res, 'C');
  tmp___0 = strcmp((char const   *)tmp, state);
  return ((_Bool )(tmp___0 == 0));
}
}
static _Bool analyze  =    (_Bool)1;
static _Bool alldb  =    (_Bool)0;
static _Bool noorder  =    (_Bool)0;
static SimpleStringList parent_table_list  =    {(SimpleStringListCell *)((void *)0), (SimpleStringListCell *)((void *)0)};
static SimpleStringList table_list  =    {(SimpleStringListCell *)((void *)0), (SimpleStringListCell *)((void *)0)};
static SimpleStringList schema_list  =    {(SimpleStringListCell *)((void *)0), (SimpleStringListCell *)((void *)0)};
static char *orderby  =    (char *)((void *)0);
static char *tablespace  =    (char *)((void *)0);
static _Bool moveidx  =    (_Bool)0;
static SimpleStringList r_index  =    {(SimpleStringListCell *)((void *)0), (SimpleStringListCell *)((void *)0)};
static _Bool only_indexes  =    (_Bool)0;
static int wait_timeout  =    60;
static int jobs  =    0;
static _Bool dryrun  =    (_Bool)0;
static unsigned int temp_obj_num  =    0U;
static _Bool no_kill_backend  =    (_Bool)0;
static _Bool no_superuser_check  =    (_Bool)0;
static SimpleStringList exclude_extension_list  =    {(SimpleStringListCell *)((void *)0), (SimpleStringListCell *)((void *)0)};
static char *utoa(unsigned int value , char *buffer )
{


  {
  pg_sprintf(buffer, "%u", value);
  return (buffer);
}
}
static pgut_option options[18]  =
  {      {(char )'b', (char )'a', "all", (void *)(& alldb), 0U, 0U},
        {(char )'l', (char )'t', "table", (void *)(& table_list), 0U, 0U},
        {(char )'l', (char )'I', "parent-table", (void *)(& parent_table_list), 0U, 0U},
        {(char )'l',
      (char )'c', "schema", (void *)(& schema_list), 0U, 0U},
        {(char )'b', (char )'n', "no-order", (void *)(& noorder), 0U, 0U},
        {(char )'b', (char )'N', "dry-run", (void *)(& dryrun), 0U, 0U},
        {(char )'s', (char )'o', "order-by", (void *)(& orderby), 0U, 0U},
        {(char )'s', (char )'s', "tablespace", (void *)(& tablespace), 0U, 0U},
        {(char )'b', (char )'S', "moveidx", (void *)(& moveidx), 0U, 0U},
        {(char )'l', (char )'i', "index", (void *)(& r_index), 0U, 0U},
        {(char )'b', (char )'x', "only-indexes", (void *)(& only_indexes), 0U, 0U},
        {(char )'i', (char )'T', "wait-timeout", (void *)(& wait_timeout), 0U, 0U},
        {(char )'B', (char )'Z', "no-analyze", (void *)(& analyze), 0U, 0U},
        {(char )'i', (char )'j', "jobs", (void *)(& jobs), 0U, 0U},
        {(char )'b', (char )'D', "no-kill-backend", (void *)(& no_kill_backend), 0U,
      0U},
        {(char )'b', (char )'k', "no-superuser-check", (void *)(& no_superuser_check),
      0U, 0U},
        {(char )'l', (char )'C', "exclude-extension", (void *)(& exclude_extension_list),
      0U, 0U},
        {(char)0, (char)0, (char const   *)0, (void *)0, 0U, 0U}};
int main(int argc , char **argv )
{
  int i ;
  char errbuf[256] ;
  int tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  _Bool tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  _Bool tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  _Bool tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  _Bool tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  _Bool tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  _Bool tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  _Bool tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  _Bool tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  _Bool tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  _Bool tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  _Bool tmp___37 ;
  _Bool tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  _Bool tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  _Bool tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  _Bool tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  _Bool tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  _Bool tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  _Bool tmp___56 ;
  _Bool tmp___57 ;

  {
  i = pgut_getopt(argc, argv, options);
  if (i == argc - 1) {
    dbname = *(argv + i);
  } else
  if (i < argc) {
    tmp___1 = pgut_errstart(20);
    if (tmp___1) {
      tmp = errmsg("too many arguments");
      tmp___0 = errcode(22);
      pgut_errfinish(tmp___0, tmp);
    }
  }
  check_tablespace();
  if (dryrun) {
    elog(17, "Dry run enabled, not executing repack");
  }
  if (r_index.head) {
    goto _L___6;
  } else
  if (only_indexes) {
    _L___6: /* CIL Label */
    if (r_index.head) {
      if (table_list.head) {
        tmp___4 = pgut_errstart(20);
        if (tmp___4) {
          tmp___2 = errmsg("cannot specify --index (-i) and --table (-t)");
          tmp___3 = errcode(22);
          pgut_errfinish(tmp___3, tmp___2);
        }
      }
    }
    if (r_index.head) {
      if (parent_table_list.head) {
        tmp___7 = pgut_errstart(20);
        if (tmp___7) {
          tmp___5 = errmsg("cannot specify --index (-i) and --parent-table (-I)");
          tmp___6 = errcode(22);
          pgut_errfinish(tmp___6, tmp___5);
        }
      } else {
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */
    if (r_index.head) {
      if (only_indexes) {
        tmp___10 = pgut_errstart(20);
        if (tmp___10) {
          tmp___8 = errmsg("cannot specify --index (-i) and --only-indexes (-x)");
          tmp___9 = errcode(22);
          pgut_errfinish(tmp___9, tmp___8);
        }
      } else {
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */
    if (r_index.head) {
      if (exclude_extension_list.head) {
        tmp___13 = pgut_errstart(20);
        if (tmp___13) {
          tmp___11 = errmsg("cannot specify --index (-i) and --exclude-extension (-C)");
          tmp___12 = errcode(22);
          pgut_errfinish(tmp___12, tmp___11);
        }
      } else {
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */
    if (only_indexes) {
      if (table_list.head) {
        goto _L___0;
      } else
      if (parent_table_list.head) {
        goto _L___0;
      } else {
        tmp___16 = pgut_errstart(20);
        if (tmp___16) {
          tmp___14 = errmsg("cannot repack all indexes of database, specify the table(s)via --table (-t) or --parent-table (-I)");
          tmp___15 = errcode(22);
          pgut_errfinish(tmp___15, tmp___14);
        }
      }
    } else
    _L___0: /* CIL Label */
    if (only_indexes) {
      if (exclude_extension_list.head) {
        tmp___19 = pgut_errstart(20);
        if (tmp___19) {
          tmp___17 = errmsg("cannot specify --only-indexes (-x) and --exclude-extension (-C)");
          tmp___18 = errcode(22);
          pgut_errfinish(tmp___18, tmp___17);
        }
      } else {
        goto _L;
      }
    } else
    _L: /* CIL Label */
    if (alldb) {
      tmp___22 = pgut_errstart(20);
      if (tmp___22) {
        tmp___20 = errmsg("cannot repack specific index(es) in all databases");
        tmp___21 = errcode(22);
        pgut_errfinish(tmp___21, tmp___20);
      }
    } else {
      if (orderby) {
        tmp___25 = pgut_errstart(19);
        if (tmp___25) {
          tmp___23 = errmsg("option -o (--order-by) has no effect while repacking indexes");
          tmp___24 = errcode(22);
          pgut_errfinish(tmp___24, tmp___23);
        }
      } else
      if (noorder) {
        tmp___28 = pgut_errstart(19);
        if (tmp___28) {
          tmp___26 = errmsg("option -n (--no-order) has no effect while repacking indexes");
          tmp___27 = errcode(22);
          pgut_errfinish(tmp___27, tmp___26);
        }
      } else
      if (! analyze) {
        tmp___31 = pgut_errstart(19);
        if (tmp___31) {
          tmp___29 = errmsg("ANALYZE is not performed after repacking indexes, -z (--no-analyze) has no effect");
          tmp___30 = errcode(22);
          pgut_errfinish(tmp___30, tmp___29);
        }
      } else
      if (jobs) {
        tmp___34 = pgut_errstart(19);
        if (tmp___34) {
          tmp___32 = errmsg("option -j (--jobs) has no effect, repacking indexes does not use parallel jobs");
          tmp___33 = errcode(22);
          pgut_errfinish(tmp___33, tmp___32);
        }
      }
      tmp___38 = repack_all_indexes(errbuf, sizeof(errbuf));
      if (! tmp___38) {
        tmp___37 = pgut_errstart(20);
        if (tmp___37) {
          tmp___35 = errmsg("%s", errbuf);
          tmp___36 = errcode(20);
          pgut_errfinish(tmp___36, tmp___35);
        }
      }
    }
  } else {
    if (schema_list.head) {
      if (table_list.head) {
        goto _L___4;
      } else
      if (parent_table_list.head) {
        _L___4: /* CIL Label */
        tmp___41 = pgut_errstart(20);
        if (tmp___41) {
          tmp___39 = errmsg("cannot repack specific table(s) in schema, use schema.table notation instead");
          tmp___40 = errcode(22);
          pgut_errfinish(tmp___40, tmp___39);
        }
      }
    }
    if (exclude_extension_list.head) {
      if (table_list.head) {
        tmp___44 = pgut_errstart(20);
        if (tmp___44) {
          tmp___42 = errmsg("cannot specify --table (-t) and --exclude-extension (-C)");
          tmp___43 = errcode(22);
          pgut_errfinish(tmp___43, tmp___42);
        }
      }
    }
    if (exclude_extension_list.head) {
      if (parent_table_list.head) {
        tmp___47 = pgut_errstart(20);
        if (tmp___47) {
          tmp___45 = errmsg("cannot specify --parent-table (-I) and --exclude-extension (-C)");
          tmp___46 = errcode(22);
          pgut_errfinish(tmp___46, tmp___45);
        }
      }
    }
    if (noorder) {
      orderby = (char *)"";
    }
    if (alldb) {
      if (table_list.head) {
        goto _L___5;
      } else
      if (parent_table_list.head) {
        _L___5: /* CIL Label */
        tmp___50 = pgut_errstart(20);
        if (tmp___50) {
          tmp___48 = errmsg("cannot repack specific table(s) in all databases");
          tmp___49 = errcode(22);
          pgut_errfinish(tmp___49, tmp___48);
        }
      }
      if (schema_list.head) {
        tmp___53 = pgut_errstart(20);
        if (tmp___53) {
          tmp___51 = errmsg("cannot repack specific schema(s) in all databases");
          tmp___52 = errcode(22);
          pgut_errfinish(tmp___52, tmp___51);
        }
      }
      repack_all_databases((char const   *)orderby);
    } else {
      tmp___57 = repack_one_database((char const   *)orderby, errbuf, sizeof(errbuf));
      if (! tmp___57) {
        tmp___56 = pgut_errstart(20);
        if (tmp___56) {
          tmp___54 = errmsg("%s failed with error: %s", PROGRAM_NAME, errbuf);
          tmp___55 = errcode(20);
          pgut_errfinish(tmp___55, tmp___54);
        }
      }
    }
  }
  return (0);
}
}
static _Bool is_superuser(void)
{
  char const   *val ;
  int tmp ;

  {
  if (no_superuser_check) {
    return ((_Bool)1);
  }
  if (! connection) {
    return ((_Bool)0);
  }
  val = PQparameterStatus((PGconn const   *)connection, "is_superuser");
  if (val) {
    tmp = strcmp(val, "on");
    if (tmp == 0) {
      return ((_Bool)1);
    }
  }
  return ((_Bool)0);
}
}
static void check_tablespace(void)
{
  PGresult *res ;
  char const   *params[1] ;
  int tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  _Bool tmp___9 ;
  ExecStatusType tmp___10 ;

  {
  res = (PGresult *)((void *)0);
  if ((unsigned long )tablespace == (unsigned long )((void *)0)) {
    if (moveidx) {
      tmp___1 = pgut_errstart(20);
      if (tmp___1) {
        tmp = errmsg("cannot specify --moveidx (-S) without --tablespace (-s)");
        tmp___0 = errcode(22);
        pgut_errfinish(tmp___0, tmp);
      }
    }
    return;
  }
  reconnect(20);
  params[0] = (char const   *)tablespace;
  res = execute_elevel("select spcname from pg_tablespace where spcname = $1", 1,
                       params, 13);
  tmp___10 = PQresultStatus((PGresult const   *)res);
  if ((unsigned int )tmp___10 == 2U) {
    tmp___5 = PQntuples((PGresult const   *)res);
    if (tmp___5 == 0) {
      tmp___4 = pgut_errstart(20);
      if (tmp___4) {
        tmp___2 = errmsg("the tablespace \"%s\" doesn\'t exist", tablespace);
        tmp___3 = errcode(22);
        pgut_errfinish(tmp___3, tmp___2);
      }
    }
  } else {
    tmp___9 = pgut_errstart(20);
    if (tmp___9) {
      tmp___6 = PQerrorMessage((PGconn const   *)connection);
      tmp___7 = errmsg("error checking the namespace: %s", tmp___6);
      tmp___8 = errcode(22);
      pgut_errfinish(tmp___8, tmp___7);
    }
  }
  while (1) {
    PQclear(res);
    res = (PGresult *)((void *)0);
    break;
  }
  return;
}
}
static _Bool preliminary_checks(char *errbuf , size_t errsize )
{
  _Bool ret ;
  PGresult *res ;
  _Bool tmp ;
  char const   *libver ;
  char buf[64] ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  ExecStatusType tmp___7 ;

  {
  ret = (_Bool)0;
  res = (PGresult *)((void *)0);
  tmp = is_superuser();
  if (! tmp) {
    if (errbuf) {
      pg_snprintf(errbuf, errsize, "You must be a superuser to use %s", PROGRAM_NAME);
    }
    goto cleanup;
  }
  res = execute_elevel("select repack.version(), repack.version_sql()", 0, (char const   **)((void *)0),
                       13);
  tmp___7 = PQresultStatus((PGresult const   *)res);
  if ((unsigned int )tmp___7 == 2U) {
    pg_snprintf(buf, sizeof(buf), "%s %s", PROGRAM_NAME, PROGRAM_VERSION);
    tmp___0 = getstr(res, 0, 0);
    libver = (char const   *)tmp___0;
    tmp___1 = strcmp((char const   *)(buf), libver);
    if (0 != tmp___1) {
      if (errbuf) {
        pg_snprintf(errbuf, errsize, "program \'%s\' does not match database library \'%s\'",
                    buf, libver);
      }
      goto cleanup;
    }
    tmp___2 = getstr(res, 0, 1);
    libver = (char const   *)tmp___2;
    tmp___3 = strcmp((char const   *)(buf), libver);
    if (0 != tmp___3) {
      if (errbuf) {
        pg_snprintf(errbuf, errsize, "extension \'%s\' required, found \'%s\'; please drop and re-create the extension",
                    buf, libver);
      }
      goto cleanup;
    }
  } else {
    tmp___5 = sqlstate_equals(res, "3F000");
    if (tmp___5) {
      goto _L;
    } else {
      tmp___6 = sqlstate_equals(res, "42883");
      if (tmp___6) {
        _L: /* CIL Label */
        if (errbuf) {
          pg_snprintf(errbuf, errsize, "%s %s is not installed in the database", PROGRAM_NAME,
                      PROGRAM_VERSION);
        }
      } else
      if (errbuf) {
        tmp___4 = PQerrorMessage((PGconn const   *)connection);
        pg_snprintf(errbuf, errsize, "%s", tmp___4);
      }
    }
    goto cleanup;
  }
  while (1) {
    PQclear(res);
    res = (PGresult *)((void *)0);
    break;
  }
  command("SET statement_timeout = 0", 0, (char const   **)((void *)0));
  command("SET search_path = pg_catalog, pg_temp, public", 0, (char const   **)((void *)0));
  command("SET client_min_messages = warning", 0, (char const   **)((void *)0));
  ret = (_Bool)1;
  cleanup:
  while (1) {
    PQclear(res);
    res = (PGresult *)((void *)0);
    break;
  }
  return (ret);
}
}
static _Bool is_requested_relation_exists(char *errbuf , size_t errsize )
{
  _Bool ret ;
  PGresult *res ;
  char const   **params ;
  int iparam ;
  PQExpBufferData sql ;
  int num_relations ;
  SimpleStringListCell *cell ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int num ;
  int i ;
  PQExpBufferData rel_names ;
  char *tmp___5 ;
  char *tmp___6 ;
  ExecStatusType tmp___7 ;

  {
  ret = (_Bool)0;
  res = (PGresult *)((void *)0);
  params = (char const   **)((void *)0);
  iparam = 0;
  tmp = simple_string_list_size(parent_table_list);
  tmp___0 = simple_string_list_size(table_list);
  num_relations = (int )(tmp + tmp___0);
  if (num_relations == 0) {
    return ((_Bool)1);
  }
  tmp___1 = PQserverVersion((PGconn const   *)connection);
  if (tmp___1 < 90600) {
    return ((_Bool)1);
  }
  tmp___2 = pgut_malloc((unsigned long )num_relations * sizeof(char *));
  params = (char const   **)tmp___2;
  initPQExpBuffer(& sql);
  appendPQExpBufferStr(& sql, "SELECT r FROM (VALUES ");
  cell = table_list.head;
  while (cell) {
    appendPQExpBuffer(& sql, "($%d)", iparam + 1);
    tmp___3 = iparam;
    iparam ++;
    *(params + tmp___3) = (char const   *)(cell->val);
    if (iparam < num_relations) {
      appendPQExpBufferChar(& sql, (char )',');
    }
    cell = cell->next;
  }
  cell = parent_table_list.head;
  while (cell) {
    appendPQExpBuffer(& sql, "($%d)", iparam + 1);
    tmp___4 = iparam;
    iparam ++;
    *(params + tmp___4) = (char const   *)(cell->val);
    if (iparam < num_relations) {
      appendPQExpBufferChar(& sql, (char )',');
    }
    cell = cell->next;
  }
  appendPQExpBufferStr(& sql, ") AS given_t(r) WHERE NOT EXISTS(  SELECT FROM repack.tables WHERE relid=to_regclass(given_t.r) )");
  if (iparam != num_relations) {
    if (errbuf) {
      pg_snprintf(errbuf, errsize, "internal error: bad parameters count: %i instead of %i",
                  iparam, num_relations);
    }
    goto cleanup;
  }
  res = execute_elevel((char const   *)sql.data, iparam, params, 13);
  tmp___7 = PQresultStatus((PGresult const   *)res);
  if ((unsigned int )tmp___7 == 2U) {
    num = PQntuples((PGresult const   *)res);
    if (num != 0) {
      initPQExpBuffer(& rel_names);
      i = 0;
      while (i < num) {
        tmp___5 = getstr(res, i, 0);
        appendPQExpBuffer(& rel_names, "\"%s\"", tmp___5);
        if (i + 1 != num) {
          appendPQExpBufferStr(& rel_names, ", ");
        }
        i ++;
      }
      if (errbuf) {
        if (num > 1) {
          pg_snprintf(errbuf, errsize, "relations do not exist: %s", rel_names.data);
        } else {
          pg_snprintf(errbuf, errsize, "ERROR:  relation %s does not exist", rel_names.data);
        }
      }
      termPQExpBuffer(& rel_names);
    } else {
      ret = (_Bool)1;
    }
  } else
  if (errbuf) {
    tmp___6 = PQerrorMessage((PGconn const   *)connection);
    pg_snprintf(errbuf, errsize, "%s", tmp___6);
  }
  while (1) {
    PQclear(res);
    res = (PGresult *)((void *)0);
    break;
  }
  cleanup:
  while (1) {
    PQclear(res);
    res = (PGresult *)((void *)0);
    break;
  }
  termPQExpBuffer(& sql);
  free((void *)params);
  return (ret);
}
}
static void repack_all_databases(char const   *orderby___0 )
{
  PGresult *result ;
  int i ;
  _Bool tmp ;
  _Bool ret ;
  char errbuf[256] ;
  int tmp___0 ;

  {
  dbname = (char *)"postgres";
  reconnect(20);
  tmp = is_superuser();
  if (! tmp) {
    elog(20, "You must be a superuser to use %s", PROGRAM_NAME);
  }
  result = execute("SELECT datname FROM pg_database WHERE datallowconn ORDER BY 1;",
                   0, (char const   **)((void *)0));
  disconnect();
  i = 0;
  while (1) {
    tmp___0 = PQntuples((PGresult const   *)result);
    if (! (i < tmp___0)) {
      break;
    }
    dbname = PQgetvalue((PGresult const   *)result, i, 0);
    elog(17, "repacking database \"%s\"", dbname);
    if (! dryrun) {
      ret = repack_one_database(orderby___0, errbuf, sizeof(errbuf));
      if (! ret) {
        elog(17, "database \"%s\" skipped: %s", dbname, errbuf);
      }
    }
    i ++;
  }
  while (1) {
    PQclear(result);
    result = (PGresult *)((void *)0);
    break;
  }
  return;
}
}
static char *getstr(PGresult *res , int row , int col )
{
  char *tmp ;
  int tmp___0 ;

  {
  tmp___0 = PQgetisnull((PGresult const   *)res, row, col);
  if (tmp___0) {
    return ((char *)((void *)0));
  } else {
    tmp = PQgetvalue((PGresult const   *)res, row, col);
    return (tmp);
  }
}
}
static Oid getoid(PGresult *res , int row , int col )
{
  char *tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
  tmp___1 = PQgetisnull((PGresult const   *)res, row, col);
  if (tmp___1) {
    return ((Oid )0);
  } else {
    tmp = PQgetvalue((PGresult const   *)res, row, col);
    tmp___0 = strtoul((char const   * __restrict  )tmp, (char ** __restrict  )((void *)0),
                      10);
    return ((Oid )tmp___0);
  }
}
}
static _Bool repack_one_database(char const   *orderby___0 , char *errbuf , size_t errsize )
{
  _Bool ret ;
  PGresult *res ;
  int i ;
  int num ;
  PQExpBufferData sql ;
  SimpleStringListCell *cell ;
  char const   **params ;
  int iparam ;
  size_t num_parent_tables ;
  size_t num_tables ;
  size_t num_schemas ;
  size_t num_params ;
  size_t num_excluded_extensions ;
  void *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  ExecStatusType tmp___9 ;
  repack_table table ;
  PQExpBufferData copy_sql ;
  char const   *create_table_1 ;
  char const   *create_table_2 ;
  char const   *tablespace___0 ;
  char const   *ckey ;
  int c ;
  int tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  _Bool tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  char *tmp___31 ;
  int tmp___32 ;
  char *tmp___33 ;
  int tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  char *tmp___37 ;
  int tmp___38 ;
  char *tmp___39 ;
  int tmp___40 ;
  char *tmp___41 ;
  int tmp___42 ;
  char *tmp___43 ;
  int tmp___44 ;
  char *tmp___45 ;
  int tmp___46 ;
  char *tmp___47 ;
  int tmp___48 ;
  char *tmp___49 ;
  int tmp___50 ;
  char *tmp___51 ;
  int tmp___52 ;
  char *tmp___53 ;
  int tmp___54 ;
  char *tmp___55 ;
  int tmp___56 ;
  char *tmp___57 ;

  {
  ret = (_Bool)0;
  res = (PGresult *)((void *)0);
  params = (char const   **)((void *)0);
  iparam = 0;
  num_parent_tables = simple_string_list_size(parent_table_list);
  num_tables = simple_string_list_size(table_list);
  num_schemas = simple_string_list_size(schema_list);
  num_excluded_extensions = simple_string_list_size(exclude_extension_list);
  num_params = (((num_excluded_extensions + num_parent_tables) + num_tables) + num_schemas) + 1UL;
  tmp = pgut_malloc(num_params * sizeof(char *));
  params = (char const   **)tmp;
  initPQExpBuffer(& sql);
  reconnect(20);
  if (jobs > 1) {
    setup_workers(jobs);
  }
  tmp___0 = preliminary_checks(errbuf, errsize);
  if (! tmp___0) {
    goto cleanup;
  }
  tmp___1 = is_requested_relation_exists(errbuf, errsize);
  if (! tmp___1) {
    goto cleanup;
  }
  appendPQExpBufferStr(& sql, "SELECT t.*, coalesce(v.tablespace, t.tablespace_orig) as tablespace_dest FROM repack.tables t,  (VALUES (quote_ident($1::text))) as v (tablespace) WHERE ");
  tmp___2 = iparam;
  iparam ++;
  *(params + tmp___2) = (char const   *)tablespace;
  if (num_tables) {
    goto _L;
  } else
  if (num_parent_tables) {
    _L: /* CIL Label */
    if (num_tables) {
      appendPQExpBufferStr(& sql, "(");
      cell = table_list.head;
      while (cell) {
        appendPQExpBuffer(& sql, "relid = $%d::regclass", iparam + 1);
        tmp___3 = iparam;
        iparam ++;
        *(params + tmp___3) = (char const   *)(cell->val);
        if (cell->next) {
          appendPQExpBufferStr(& sql, " OR ");
        }
        cell = cell->next;
      }
      appendPQExpBufferStr(& sql, ")");
    }
    if (num_tables) {
      if (num_parent_tables) {
        appendPQExpBufferStr(& sql, " OR ");
      }
    }
    if (num_parent_tables) {
      appendPQExpBufferStr(& sql, "(");
      cell = parent_table_list.head;
      while (cell) {
        appendPQExpBuffer(& sql, "relid = ANY(repack.get_table_and_inheritors($%d::regclass))",
                          iparam + 1);
        tmp___4 = iparam;
        iparam ++;
        *(params + tmp___4) = (char const   *)(cell->val);
        if (cell->next) {
          appendPQExpBufferStr(& sql, " OR ");
        }
        cell = cell->next;
      }
      appendPQExpBufferStr(& sql, ")");
    }
  } else
  if (num_schemas) {
    appendPQExpBufferStr(& sql, "schemaname IN (");
    cell = schema_list.head;
    while (cell) {
      appendPQExpBuffer(& sql, "$%d", iparam + 1);
      tmp___5 = iparam;
      iparam ++;
      *(params + tmp___5) = (char const   *)(cell->val);
      if (cell->next) {
        appendPQExpBufferStr(& sql, ", ");
      }
      cell = cell->next;
    }
    appendPQExpBufferStr(& sql, ")");
  } else {
    appendPQExpBufferStr(& sql, "pkid IS NOT NULL");
  }
  if (exclude_extension_list.head) {
    appendPQExpBufferStr(& sql, " AND t.relid NOT IN  (SELECT d.objid::regclass   FROM pg_depend d JOIN pg_extension e   ON d.refobjid = e.oid   WHERE d.classid = \'pg_class\'::regclass AND (");
    cell = exclude_extension_list.head;
    while (cell) {
      appendPQExpBuffer(& sql, "e.extname = $%d", iparam + 1);
      tmp___6 = iparam;
      iparam ++;
      *(params + tmp___6) = (char const   *)(cell->val);
      if (cell->next) {
        tmp___7 = " OR ";
      } else {
        tmp___7 = ")";
      }
      appendPQExpBufferStr(& sql, tmp___7);
      cell = cell->next;
    }
    appendPQExpBufferStr(& sql, ")");
  }
  appendPQExpBufferStr(& sql, " ORDER BY t.relname, t.schemaname");
  if ((size_t )iparam != num_params) {
    if (errbuf) {
      pg_snprintf(errbuf, errsize, "internal error: bad parameters count: %i instead of %zi",
                  iparam, num_params);
    }
    goto cleanup;
  }
  res = execute_elevel((char const   *)sql.data, (int )num_params, params, 13);
  tmp___9 = PQresultStatus((PGresult const   *)res);
  if ((unsigned int )tmp___9 != 2U) {
    if (errbuf) {
      tmp___8 = PQerrorMessage((PGconn const   *)connection);
      pg_snprintf(errbuf, errsize, "%s", tmp___8);
    }
    goto cleanup;
  }
  num = PQntuples((PGresult const   *)res);
  i = 0;
  while (i < num) {
    c = 0;
    tmp___10 = c;
    c ++;
    tmp___11 = getstr(res, i, tmp___10);
    table.target_name = (char const   *)tmp___11;
    tmp___12 = c;
    c ++;
    table.target_oid = getoid(res, i, tmp___12);
    tmp___13 = c;
    c ++;
    table.target_toast = getoid(res, i, tmp___13);
    tmp___14 = c;
    c ++;
    table.target_tidx = getoid(res, i, tmp___14);
    c ++;
    tmp___15 = c;
    c ++;
    table.pkid = getoid(res, i, tmp___15);
    tmp___16 = c;
    c ++;
    table.ckid = getoid(res, i, tmp___16);
    if (table.pkid == 0U) {
      tmp___19 = pgut_errstart(19);
      if (tmp___19) {
        tmp___17 = errmsg("relation \"%s\" must have a primary key or not-null unique keys",
                          table.target_name);
        tmp___18 = errcode(-2);
        pgut_errfinish(tmp___18, tmp___17);
      }
      goto __Cont;
    }
    tmp___20 = c;
    c ++;
    tmp___21 = getstr(res, i, tmp___20);
    table.create_pktype = (char const   *)tmp___21;
    tmp___22 = c;
    c ++;
    tmp___23 = getstr(res, i, tmp___22);
    table.create_log = (char const   *)tmp___23;
    tmp___24 = c;
    c ++;
    tmp___25 = getstr(res, i, tmp___24);
    table.create_trigger = (char const   *)tmp___25;
    tmp___26 = c;
    c ++;
    tmp___27 = getstr(res, i, tmp___26);
    table.enable_trigger = (char const   *)tmp___27;
    tmp___28 = c;
    c ++;
    tmp___29 = getstr(res, i, tmp___28);
    create_table_1 = (char const   *)tmp___29;
    tmp___30 = c;
    c ++;
    tmp___31 = getstr(res, i, tmp___30);
    tablespace___0 = (char const   *)tmp___31;
    tmp___32 = c;
    c ++;
    tmp___33 = getstr(res, i, tmp___32);
    create_table_2 = (char const   *)tmp___33;
    tmp___34 = c;
    c ++;
    tmp___35 = getstr(res, i, tmp___34);
    table.copy_data = (char const   *)tmp___35;
    tmp___36 = c;
    c ++;
    tmp___37 = getstr(res, i, tmp___36);
    table.alter_col_storage = (char const   *)tmp___37;
    tmp___38 = c;
    c ++;
    tmp___39 = getstr(res, i, tmp___38);
    table.drop_columns = (char const   *)tmp___39;
    tmp___40 = c;
    c ++;
    tmp___41 = getstr(res, i, tmp___40);
    table.delete_log = (char const   *)tmp___41;
    tmp___42 = c;
    c ++;
    tmp___43 = getstr(res, i, tmp___42);
    table.lock_table = (char const   *)tmp___43;
    tmp___44 = c;
    c ++;
    tmp___45 = getstr(res, i, tmp___44);
    ckey = (char const   *)tmp___45;
    tmp___46 = c;
    c ++;
    tmp___47 = getstr(res, i, tmp___46);
    table.sql_peek = (char const   *)tmp___47;
    tmp___48 = c;
    c ++;
    tmp___49 = getstr(res, i, tmp___48);
    table.sql_insert = (char const   *)tmp___49;
    tmp___50 = c;
    c ++;
    tmp___51 = getstr(res, i, tmp___50);
    table.sql_delete = (char const   *)tmp___51;
    tmp___52 = c;
    c ++;
    tmp___53 = getstr(res, i, tmp___52);
    table.sql_update = (char const   *)tmp___53;
    tmp___54 = c;
    c ++;
    tmp___55 = getstr(res, i, tmp___54);
    table.sql_pop = (char const   *)tmp___55;
    tmp___56 = c;
    c ++;
    tmp___57 = getstr(res, i, tmp___56);
    tablespace___0 = (char const   *)tmp___57;
    resetPQExpBuffer(& sql);
    appendPQExpBufferStr(& sql, create_table_1);
    appendPQExpBufferStr(& sql, tablespace___0);
    appendPQExpBufferStr(& sql, create_table_2);
    appendPQExpBufferStr(& sql, " WITH NO DATA");
    table.create_table = (char const   *)sql.data;
    initPQExpBuffer(& copy_sql);
    appendPQExpBufferStr(& copy_sql, table.copy_data);
    if (! orderby___0) {
      if ((unsigned long )ckey != (unsigned long )((void *)0)) {
        appendPQExpBufferStr(& copy_sql, " ORDER BY ");
        appendPQExpBufferStr(& copy_sql, ckey);
      }
    } else
    if (! (! *(orderby___0 + 0))) {
      appendPQExpBufferStr(& copy_sql, " ORDER BY ");
      appendPQExpBufferStr(& copy_sql, orderby___0);
    }
    table.copy_data = (char const   *)copy_sql.data;
    repack_one_table(& table, orderby___0);
    __Cont: /* CIL Label */
    i ++;
  }
  ret = (_Bool)1;
  cleanup:
  while (1) {
    PQclear(res);
    res = (PGresult *)((void *)0);
    break;
  }
  disconnect();
  termPQExpBuffer(& sql);
  free((void *)params);
  return (ret);
}
}
static int apply_log(PGconn *conn , repack_table const   *table , int count )
{
  int result ;
  PGresult *res ;
  char const   *params[6] ;
  char buffer[12] ;
  char *tmp ;
  char *tmp___0 ;

  {
  params[0] = (char const   *)table->sql_peek;
  params[1] = (char const   *)table->sql_insert;
  params[2] = (char const   *)table->sql_delete;
  params[3] = (char const   *)table->sql_update;
  params[4] = (char const   *)table->sql_pop;
  tmp = utoa((unsigned int )count, buffer);
  params[5] = (char const   *)tmp;
  res = pgut_execute(conn, "SELECT repack.repack_apply($1, $2, $3, $4, $5, $6)", 6,
                     params);
  tmp___0 = PQgetvalue((PGresult const   *)res, 0, 0);
  result = atoi((char const   *)tmp___0);
  while (1) {
    PQclear(res);
    res = (PGresult *)((void *)0);
    break;
  }
  return (result);
}
}
static _Bool rebuild_indexes(repack_table const   *table )
{
  PGresult *res ;
  int num_indexes ;
  int i ;
  int num_active_workers ;
  int num_workers ;
  repack_index *index_jobs ;
  _Bool have_error ;
  char *tmp ;
  int tmp___0 ;
  int freed_worker ;
  int ret ;
  struct pollfd *input_fds ;
  void *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  ExecStatusType tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
  res = (PGresult *)((void *)0);
  have_error = (_Bool)0;
  elog(13, "---- create indexes ----");
  num_indexes = (int )table->n_indexes;
  if (num_indexes > workers.num_workers) {
    num_workers = workers.num_workers;
  } else {
    num_workers = num_indexes;
  }
  num_active_workers = num_workers;
  elog(13, "Have %d indexes and num_workers=%d", num_indexes, num_workers);
  index_jobs = (repack_index *)table->indexes;
  i = 0;
  while (i < num_indexes) {
    elog(13, "set up index_jobs [%d]", i);
    elog(13, "target_oid   : %u", (index_jobs + i)->target_oid);
    elog(13, "create_index : %s", (index_jobs + i)->create_index);
    if (num_workers <= 1) {
      command((index_jobs + i)->create_index, 0, (char const   **)((void *)0));
      (index_jobs + i)->status = (index_status_t )2;
    } else
    if (i < num_workers) {
      (index_jobs + i)->status = (index_status_t )1;
      (index_jobs + i)->worker_idx = i;
      elog(15, "Initial worker %d to build index: %s", i, (index_jobs + i)->create_index);
      tmp___0 = PQsendQuery(*(workers.conns + i), (index_jobs + i)->create_index);
      if (! tmp___0) {
        tmp = PQerrorMessage((PGconn const   *)*(workers.conns + i));
        elog(19, "Error sending async query: %s\n%s", (index_jobs + i)->create_index,
             tmp);
        have_error = (_Bool)1;
        goto cleanup;
      }
    }
    i ++;
  }
  if (num_workers > 1) {
    freed_worker = -1;
    tmp___1 = pgut_malloc(sizeof(struct pollfd ) * (unsigned long )num_workers);
    input_fds = (struct pollfd *)tmp___1;
    i = 0;
    while (i < num_workers) {
      (input_fds + i)->fd = PQsocket((PGconn const   *)*(workers.conns + i));
      (input_fds + i)->events = (short)9;
      (input_fds + i)->revents = (short)0;
      i ++;
    }
    while (num_active_workers > 0) {
      elog(13, "polling %d active workers", num_active_workers);
      ret = poll(input_fds, (nfds_t )num_workers, 3000);
      if (ret < 0) {
        tmp___3 = __errno_location();
        if (*tmp___3 != 4) {
          tmp___2 = __errno_location();
          elog(20, "poll() failed: %d, %d", ret, *tmp___2);
        }
      }
      elog(13, "Poll returned: %d", ret);
      i = 0;
      while (i < num_indexes) {
        if ((unsigned int )(index_jobs + i)->status == 1U) {
          tmp___5 = PQconsumeInput(*(workers.conns + (index_jobs + i)->worker_idx));
          if (tmp___5 != 1) {
            tmp___4 = PQerrorMessage((PGconn const   *)*(workers.conns + (index_jobs + i)->worker_idx));
            elog(19, "Error fetching async query status: %s", tmp___4);
            have_error = (_Bool)1;
            goto cleanup;
          }
          tmp___8 = PQisBusy(*(workers.conns + (index_jobs + i)->worker_idx));
          if (! tmp___8) {
            elog(15, "Command finished in worker %d: %s", (index_jobs + i)->worker_idx,
                 (index_jobs + i)->create_index);
            while (1) {
              res = PQgetResult(*(workers.conns + (index_jobs + i)->worker_idx));
              if (! res) {
                break;
              }
              tmp___7 = PQresultStatus((PGresult const   *)res);
              if ((unsigned int )tmp___7 != 1U) {
                tmp___6 = PQerrorMessage((PGconn const   *)*(workers.conns + (index_jobs + i)->worker_idx));
                elog(19, "Error with create index: %s", tmp___6);
                have_error = (_Bool)1;
                goto cleanup;
              }
              while (1) {
                PQclear(res);
                res = (PGresult *)((void *)0);
                break;
              }
            }
            freed_worker = (index_jobs + i)->worker_idx;
            (index_jobs + i)->status = (index_status_t )2;
            num_active_workers --;
            break;
          }
        }
        i ++;
      }
      if (freed_worker > -1) {
        i = 0;
        while (i < num_indexes) {
          if ((unsigned int )(index_jobs + i)->status == 0U) {
            (index_jobs + i)->status = (index_status_t )1;
            (index_jobs + i)->worker_idx = freed_worker;
            elog(15, "Assigning worker %d to build index #%d: %s", freed_worker, i,
                 (index_jobs + i)->create_index);
            tmp___10 = PQsendQuery(*(workers.conns + freed_worker), (index_jobs + i)->create_index);
            if (! tmp___10) {
              tmp___9 = PQerrorMessage((PGconn const   *)*(workers.conns + freed_worker));
              elog(19, "Error sending async query: %s\n%s", (index_jobs + i)->create_index,
                   tmp___9);
              have_error = (_Bool)1;
              goto cleanup;
            }
            num_active_workers ++;
            break;
          }
          i ++;
        }
        freed_worker = -1;
      }
    }
  }
  cleanup:
  while (1) {
    PQclear(res);
    res = (PGresult *)((void *)0);
    break;
  }
  return ((_Bool )(! have_error));
}
}
static void repack_one_table(repack_table *table , char const   *orderby___0 )
{
  PGresult *res ;
  char const   *params[3] ;
  int num ;
  char *vxid ;
  char buffer[12] ;
  PQExpBufferData sql ;
  _Bool ret ;
  PGresult *indexres ;
  char const   *indexparams[2] ;
  char indexbuffer[12] ;
  int j ;
  char const   *appname ;
  char *tmp ;
  _Bool table_init ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  char *tmp___5 ;
  char const   *indexdef ;
  char *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  _Bool tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  _Bool tmp___19 ;
  char *tmp___20 ;
  ExecStatusType tmp___21 ;
  int tmp___22 ;
  char const   *tmp___25 ;
  int tmp___26 ;
  char const   *tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  _Bool tmp___30 ;
  _Bool tmp___31 ;
  char *tmp___32 ;
  int tmp___33 ;
  char *tmp___34 ;
  _Bool tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  _Bool tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;

  {
  res = (PGresult *)((void *)0);
  vxid = (char *)((void *)0);
  ret = (_Bool)0;
  indexres = (PGresult *)((void *)0);
  tmp = getenv("PGAPPNAME");
  appname = (char const   *)tmp;
  table_init = (_Bool)0;
  initPQExpBuffer(& sql);
  elog(17, "repacking table \"%s\"", table->target_name);
  elog(13, "---- repack_one_table ----");
  elog(13, "target_name       : %s", table->target_name);
  elog(13, "target_oid        : %u", table->target_oid);
  elog(13, "target_toast      : %u", table->target_toast);
  elog(13, "target_tidx       : %u", table->target_tidx);
  elog(13, "pkid              : %u", table->pkid);
  elog(13, "ckid              : %u", table->ckid);
  elog(13, "create_pktype     : %s", table->create_pktype);
  elog(13, "create_log        : %s", table->create_log);
  elog(13, "create_trigger    : %s", table->create_trigger);
  elog(13, "enable_trigger    : %s", table->enable_trigger);
  elog(13, "create_table      : %s", table->create_table);
  elog(13, "copy_data         : %s", table->copy_data);
  if (table->alter_col_storage) {
    tmp___0 = table->alter_col_storage;
  } else {
    tmp___0 = "(skipped)";
  }
  elog(13, "alter_col_storage : %s", tmp___0);
  if (table->drop_columns) {
    tmp___1 = table->drop_columns;
  } else {
    tmp___1 = "(skipped)";
  }
  elog(13, "drop_columns      : %s", tmp___1);
  elog(13, "delete_log        : %s", table->delete_log);
  elog(13, "lock_table        : %s", table->lock_table);
  elog(13, "sql_peek          : %s", table->sql_peek);
  elog(13, "sql_insert        : %s", table->sql_insert);
  elog(13, "sql_delete        : %s", table->sql_delete);
  elog(13, "sql_update        : %s", table->sql_update);
  elog(13, "sql_pop           : %s", table->sql_pop);
  if (dryrun) {
    return;
  }
  pgut_atexit_push(& repack_cleanup_callback, (void *)(& table->target_oid));
  elog(13, "---- setup ----");
  tmp___2 = utoa(table->target_oid, buffer);
  params[0] = (char const   *)tmp___2;
  tmp___3 = advisory_lock(connection, (char const   *)(buffer));
  if (! tmp___3) {
    goto cleanup;
  }
  tmp___4 = lock_exclusive(connection, (char const   *)(buffer), table->lock_table,
                           (_Bool)1);
  if (! tmp___4) {
    if (no_kill_backend) {
      elog(17, "Skipping repack %s due to timeout", table->target_name);
    } else {
      elog(19, "lock_exclusive() failed for %s", table->target_name);
    }
    goto cleanup;
  }
  tmp___5 = utoa(table->target_oid, indexbuffer);
  indexparams[0] = (char const   *)tmp___5;
  if (moveidx) {
    indexparams[1] = (char const   *)tablespace;
  } else {
    indexparams[1] = (char const   *)((void *)0);
  }
  indexres = execute("SELECT pg_get_indexdef(indexrelid) FROM pg_index WHERE indrelid = $1 AND NOT indisvalid",
                     1, indexparams);
  j = 0;
  while (1) {
    tmp___7 = PQntuples((PGresult const   *)indexres);
    if (! (j < tmp___7)) {
      break;
    }
    tmp___6 = getstr(indexres, j, 0);
    indexdef = (char const   *)tmp___6;
    elog(19, "skipping invalid index: %s", indexdef);
    j ++;
  }
  indexres = execute("SELECT indexrelid, repack.repack_indexdef(indexrelid, indrelid, $2, FALSE)  FROM pg_index WHERE indrelid = $1 AND indisvalid",
                     2, indexparams);
  table->n_indexes = PQntuples((PGresult const   *)indexres);
  tmp___8 = pgut_malloc((unsigned long )table->n_indexes * sizeof(repack_index ));
  table->indexes = (repack_index *)tmp___8;
  j = 0;
  while (j < table->n_indexes) {
    (table->indexes + j)->target_oid = getoid(indexres, j, 0);
    tmp___9 = getstr(indexres, j, 1);
    (table->indexes + j)->create_index = (char const   *)tmp___9;
    (table->indexes + j)->status = (index_status_t )0;
    (table->indexes + j)->worker_idx = -1;
    j ++;
  }
  j = 0;
  while (j < table->n_indexes) {
    elog(13, "index[%d].target_oid      : %u", j, (table->indexes + j)->target_oid);
    elog(13, "index[%d].create_index    : %s", j, (table->indexes + j)->create_index);
    j ++;
  }
  res = execute("SELECT repack.conflicted_triggers($1)", 1, params);
  tmp___14 = PQntuples((PGresult const   *)res);
  if (tmp___14 > 0) {
    tmp___13 = pgut_errstart(19);
    if (tmp___13) {
      tmp___10 = errdetail("The trigger was probably installed during a previous attempt to run pg_repack on the table which was interrupted and for some reason failed to clean up the temporary objects.  Please drop the trigger or drop and recreate the pg_repack extension altogether to remove all the temporary objects left over.");
      tmp___11 = errmsg("the table \"%s\" already has a trigger called \"%s\"", table->target_name,
                        "repack_trigger");
      tmp___12 = errcode(-2);
      pgut_errfinish(tmp___12, tmp___11, tmp___10);
    }
    goto cleanup;
  }
  while (1) {
    PQclear(res);
    res = (PGresult *)((void *)0);
    break;
  }
  command(table->create_pktype, 0, (char const   **)((void *)0));
  temp_obj_num ++;
  command(table->create_log, 0, (char const   **)((void *)0));
  temp_obj_num ++;
  command(table->create_trigger, 0, (char const   **)((void *)0));
  temp_obj_num ++;
  command(table->enable_trigger, 0, (char const   **)((void *)0));
  printfPQExpBuffer(& sql, "SELECT repack.disable_autovacuum(\'repack.log_%u\')",
                    table->target_oid);
  command((char const   *)sql.data, 0, (char const   **)((void *)0));
  pgut_command(conn2, "BEGIN ISOLATION LEVEL READ COMMITTED", 0, (char const   **)((void *)0));
  res = pgut_execute(conn2, "SELECT pg_backend_pid()", 0, (char const   **)((void *)0));
  buffer[0] = (char )'\000';
  tmp___15 = PQgetvalue((PGresult const   *)res, 0, 0);
  strncat((char * __restrict  )(buffer), (char const   * __restrict  )tmp___15, sizeof(buffer) - 1UL);
  while (1) {
    PQclear(res);
    res = (PGresult *)((void *)0);
    break;
  }
  printfPQExpBuffer(& sql, "LOCK TABLE %s IN ACCESS SHARE MODE", table->target_name);
  elog(13, "LOCK TABLE %s IN ACCESS SHARE MODE", table->target_name);
  tmp___16 = PQsetnonblocking(conn2, 1);
  if (tmp___16) {
    elog(19, "Unable to set conn2 nonblocking.");
    goto cleanup;
  }
  tmp___18 = PQsendQuery(conn2, (char const   *)sql.data);
  if (! tmp___18) {
    tmp___17 = PQerrorMessage((PGconn const   *)conn2);
    elog(19, "Error sending async query: %s\n%s", sql.data, tmp___17);
    goto cleanup;
  }
  tmp___19 = kill_ddl(connection, table->target_oid, (_Bool)1);
  if (! tmp___19) {
    if (no_kill_backend) {
      elog(17, "Skipping repack %s due to timeout.", table->target_name);
    } else {
      elog(19, "kill_ddl() failed.");
    }
    goto cleanup;
  }
  command("COMMIT", 0, (char const   **)((void *)0));
  table_init = (_Bool)1;
  while (1) {
    res = PQgetResult(conn2);
    if (! res) {
      break;
    }
    elog(13, "Waiting on ACCESS SHARE lock...");
    tmp___21 = PQresultStatus((PGresult const   *)res);
    if ((unsigned int )tmp___21 != 1U) {
      tmp___20 = PQerrorMessage((PGconn const   *)conn2);
      elog(19, "Error with LOCK TABLE: %s", tmp___20);
      goto cleanup;
    }
    while (1) {
      PQclear(res);
      res = (PGresult *)((void *)0);
      break;
    }
  }
  tmp___22 = PQsetnonblocking(conn2, 0);
  if (tmp___22) {
    elog(19, "Unable to set conn2 blocking.");
    goto cleanup;
  }
  elog(13, "---- copy tuples ----");
  command("BEGIN ISOLATION LEVEL SERIALIZABLE", 0, (char const   **)((void *)0));
  command("SELECT set_config(\'work_mem\', current_setting(\'maintenance_work_mem\'), true)",
          0, (char const   **)((void *)0));
  if (orderby___0) {
    if (! *(orderby___0 + 0)) {
      command("SET LOCAL synchronize_seqscans = off", 0, (char const   **)((void *)0));
    }
  }
  params[0] = (char const   *)(buffer);
  params[1] = PROGRAM_NAME;
  tmp___28 = PQserverVersion((PGconn const   *)connection);
  if (tmp___28 >= 90200) {
    tmp___27 = "SELECT coalesce(array_agg(l.virtualtransaction), \'{}\')   FROM pg_locks AS l   LEFT JOIN pg_stat_activity AS a     ON l.pid = a.pid   LEFT JOIN pg_database AS d     ON a.datid = d.oid   WHERE l.locktype = \'virtualxid\'   AND l.pid NOT IN (pg_backend_pid(), $1)   AND (l.virtualxid, l.virtualtransaction) <> (\'1/1\', \'-1/0\')   AND (a.application_name IS NULL OR a.application_name <> $2)  AND a.query !~* E\'^\\\\s*vacuum\\\\s+\'   AND a.query !~ E\'^autovacuum: \'   AND ((d.datname IS NULL OR d.datname = current_database()) OR l.database = 0)";
  } else {
    tmp___26 = PQserverVersion((PGconn const   *)connection);
    if (tmp___26 >= 90000) {
      tmp___25 = "SELECT coalesce(array_agg(l.virtualtransaction), \'{}\')   FROM pg_locks AS l   LEFT JOIN pg_stat_activity AS a     ON l.pid = a.procpid   LEFT JOIN pg_database AS d     ON a.datid = d.oid   WHERE l.locktype = \'virtualxid\'   AND l.pid NOT IN (pg_backend_pid(), $1)   AND (l.virtualxid, l.virtualtransaction) <> (\'1/1\', \'-1/0\')   AND (a.application_name IS NULL OR a.application_name <> $2)  AND a.current_query !~* E\'^\\\\s*vacuum\\\\s+\'   AND a.current_query !~ E\'^autovacuum: \'   AND ((d.datname IS NULL OR d.datname = current_database()) OR l.database = 0)";
    } else {
      tmp___25 = "SELECT coalesce(array_agg(l.virtualtransaction), \'{}\')   FROM pg_locks AS l  LEFT JOIN pg_stat_activity AS a     ON l.pid = a.procpid   LEFT JOIN pg_database AS d     ON a.datid = d.oid  WHERE l.locktype = \'virtualxid\' AND l.pid NOT IN (pg_backend_pid(), $1) AND (l.virtualxid, l.virtualtransaction) <> (\'1/1\', \'-1/0\')  AND a.current_query !~* E\'^\\\\s*vacuum\\\\s+\'  AND a.current_query !~ E\'^autovacuum: \'  AND ((d.datname IS NULL OR d.datname = current_database()) OR l.database = 0) AND ($2::text IS NOT NULL)";
    }
    tmp___27 = tmp___25;
  }
  res = execute(tmp___27, 2, params);
  tmp___29 = PQgetvalue((PGresult const   *)res, 0, 0);
  vxid = pgut_strdup((char const   *)tmp___29);
  while (1) {
    PQclear(res);
    res = (PGresult *)((void *)0);
    break;
  }
  command(table->delete_log, 0, (char const   **)((void *)0));
  tmp___30 = lock_access_share(connection, table->target_oid, table->target_name);
  if (! tmp___30) {
    goto cleanup;
  }
  command(table->create_table, 0, (char const   **)((void *)0));
  if (table->alter_col_storage) {
    command(table->alter_col_storage, 0, (char const   **)((void *)0));
  }
  command(table->copy_data, 0, (char const   **)((void *)0));
  temp_obj_num ++;
  printfPQExpBuffer(& sql, "SELECT repack.disable_autovacuum(\'repack.table_%u\')",
                    table->target_oid);
  if (table->drop_columns) {
    command(table->drop_columns, 0, (char const   **)((void *)0));
  }
  command((char const   *)sql.data, 0, (char const   **)((void *)0));
  command("COMMIT", 0, (char const   **)((void *)0));
  tmp___31 = rebuild_indexes((repack_table const   *)table);
  if (! tmp___31) {
    goto cleanup;
  }
  while (1) {
    PQclear(indexres);
    indexres = (PGresult *)((void *)0);
    break;
  }
  while (1) {
    PQclear(res);
    res = (PGresult *)((void *)0);
    break;
  }
  while (1) {
    num = apply_log(connection, (repack_table const   *)table, 1000);
    if (num > 20) {
      goto __Cont;
    }
    params[0] = (char const   *)vxid;
    res = execute("SELECT pid FROM pg_locks WHERE locktype = \'virtualxid\' AND pid <> pg_backend_pid() AND virtualtransaction = ANY($1)",
                  1, params);
    num = PQntuples((PGresult const   *)res);
    if (num > 0) {
      if (! appname) {
        tmp___32 = PQgetvalue((PGresult const   *)res, 0, 0);
        elog(18, "Waiting for %d transactions to finish. First PID: %s", num, tmp___32);
      } else {
        tmp___33 = strcmp(appname, "pg_regress");
        if (tmp___33 != 0) {
          tmp___32 = PQgetvalue((PGresult const   *)res, 0, 0);
          elog(18, "Waiting for %d transactions to finish. First PID: %s", num, tmp___32);
        }
      }
      while (1) {
        PQclear(res);
        res = (PGresult *)((void *)0);
        break;
      }
      sleep(1U);
      goto __Cont;
    } else {
      while (1) {
        PQclear(res);
        res = (PGresult *)((void *)0);
        break;
      }
      break;
    }
    __Cont: /* CIL Label */ ;
  }
  elog(13, "---- swap ----");
  tmp___34 = utoa(table->target_oid, buffer);
  tmp___35 = lock_exclusive(conn2, (char const   *)tmp___34, table->lock_table, (_Bool)0);
  if (! tmp___35) {
    elog(19, "lock_exclusive() failed in conn2 for %s", table->target_name);
    goto cleanup;
  }
  apply_log(conn2, (repack_table const   *)table, 0);
  tmp___36 = utoa(table->target_oid, buffer);
  params[0] = (char const   *)tmp___36;
  pgut_command(conn2, "SELECT repack.repack_swap($1)", 1, params);
  pgut_command(conn2, "COMMIT", 0, (char const   **)((void *)0));
  elog(13, "---- drop ----");
  command("BEGIN ISOLATION LEVEL READ COMMITTED", 0, (char const   **)((void *)0));
  tmp___37 = utoa(table->target_oid, buffer);
  tmp___38 = lock_exclusive(connection, (char const   *)tmp___37, table->lock_table,
                            (_Bool)0);
  if (! tmp___38) {
    elog(19, "lock_exclusive() failed in connection for %s", table->target_name);
    goto cleanup;
  }
  tmp___39 = utoa(temp_obj_num, indexbuffer);
  params[1] = (char const   *)tmp___39;
  command("SELECT repack.repack_drop($1, $2)", 2, params);
  command("COMMIT", 0, (char const   **)((void *)0));
  temp_obj_num = 0U;
  if (analyze) {
    elog(13, "---- analyze ----");
    command("BEGIN ISOLATION LEVEL READ COMMITTED", 0, (char const   **)((void *)0));
    printfPQExpBuffer(& sql, "ANALYZE %s", table->target_name);
    command((char const   *)sql.data, 0, (char const   **)((void *)0));
    command("COMMIT", 0, (char const   **)((void *)0));
  }
  params[0] = "16185446";
  tmp___40 = utoa(table->target_oid, buffer);
  params[1] = (char const   *)tmp___40;
  res = pgut_execute(connection, "SELECT pg_advisory_unlock($1, CAST(-2147483648 + $2::bigint AS integer))",
                     2, params);
  ret = (_Bool)1;
  cleanup:
  while (1) {
    PQclear(res);
    res = (PGresult *)((void *)0);
    break;
  }
  termPQExpBuffer(& sql);
  if (vxid) {
    free((void *)vxid);
  }
  pgut_rollback(connection);
  pgut_rollback(conn2);
  if (! ret) {
    if (table_init) {
      repack_cleanup((_Bool)0, (repack_table const   *)table);
    }
  }
  return;
}
}
static _Bool kill_ddl(PGconn *conn , Oid relid , _Bool terminate )
{
  _Bool ret ;
  PGresult *res ;
  PQExpBufferData sql ;
  int n_tuples ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  ExecStatusType tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  ExecStatusType tmp___7 ;

  {
  ret = (_Bool)1;
  initPQExpBuffer(& sql);
  printfPQExpBuffer(& sql, "SELECT pid FROM pg_locks WHERE locktype = \'relation\' AND granted = false AND relation = %u AND mode = \'AccessExclusiveLock\' AND pid <> pg_backend_pid()",
                    relid);
  res = pgut_execute(conn, (char const   *)sql.data, 0, (char const   **)((void *)0));
  n_tuples = PQntuples((PGresult const   *)res);
  if (n_tuples != 0) {
    if (no_kill_backend) {
      elog(19, "%d unsafe queries remain but do not cancel them and skip to repack it",
           n_tuples);
      ret = (_Bool)0;
    } else {
      resetPQExpBuffer(& sql);
      printfPQExpBuffer(& sql, "SELECT pg_cancel_backend(pid) FROM pg_locks WHERE locktype = \'relation\' AND granted = false AND relation = %u AND mode = \'AccessExclusiveLock\' AND pid <> pg_backend_pid()",
                        relid);
      res = pgut_execute(conn, (char const   *)sql.data, 0, (char const   **)((void *)0));
      tmp___7 = PQresultStatus((PGresult const   *)res);
      if ((unsigned int )tmp___7 != 2U) {
        tmp = PQerrorMessage((PGconn const   *)conn);
        elog(19, "Error canceling unsafe queries: %s", tmp);
        ret = (_Bool)0;
      } else {
        tmp___5 = PQntuples((PGresult const   *)res);
        if (tmp___5 > 0) {
          if (terminate) {
            tmp___6 = PQserverVersion((PGconn const   *)conn);
            if (tmp___6 >= 80400) {
              tmp___0 = PQntuples((PGresult const   *)res);
              elog(19, "Canceled %d unsafe queries. Terminating any remaining PIDs.",
                   tmp___0);
              while (1) {
                PQclear(res);
                res = (PGresult *)((void *)0);
                break;
              }
              printfPQExpBuffer(& sql, "SELECT pg_terminate_backend(pid) FROM pg_locks WHERE locktype = \'relation\' AND granted = false AND relation = %u AND mode = \'AccessExclusiveLock\' AND pid <> pg_backend_pid()",
                                relid);
              res = pgut_execute(conn, (char const   *)sql.data, 0, (char const   **)((void *)0));
              tmp___2 = PQresultStatus((PGresult const   *)res);
              if ((unsigned int )tmp___2 != 2U) {
                tmp___1 = PQerrorMessage((PGconn const   *)conn);
                elog(19, "Error killing unsafe queries: %s", tmp___1);
                ret = (_Bool)0;
              }
            } else {
              goto _L___0;
            }
          } else {
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */
          tmp___4 = PQntuples((PGresult const   *)res);
          if (tmp___4 > 0) {
            tmp___3 = PQntuples((PGresult const   *)res);
            elog(18, "Canceled %d unsafe queries", tmp___3);
          }
        }
      }
    }
  } else {
    elog(13, "No competing DDL to cancel.");
  }
  while (1) {
    PQclear(res);
    res = (PGresult *)((void *)0);
    break;
  }
  termPQExpBuffer(& sql);
  return (ret);
}
}
static _Bool lock_access_share(PGconn *conn , Oid relid , char const   *target_name )
{
  PQExpBufferData sql ;
  time_t start ;
  time_t tmp ;
  int i ;
  _Bool ret ;
  time_t duration ;
  PGresult *res ;
  int wait_msec ;
  time_t tmp___0 ;
  char *tmp___1 ;
  _Bool tmp___2 ;
  ExecStatusType tmp___3 ;

  {
  tmp = time((time_t *)((void *)0));
  start = tmp;
  ret = (_Bool)1;
  initPQExpBuffer(& sql);
  i = 1;
  while (1) {
    tmp___0 = time((time_t *)((void *)0));
    duration = tmp___0 - start;
    if (duration > (time_t )(wait_timeout * 2)) {
      ret = kill_ddl(conn, relid, (_Bool)1);
    } else {
      ret = kill_ddl(conn, relid, (_Bool)0);
    }
    if (! ret) {
      break;
    }
    if (1000 < i * 100) {
      wait_msec = 1000;
    } else {
      wait_msec = i * 100;
    }
    printfPQExpBuffer(& sql, "SET LOCAL statement_timeout = %d", wait_msec);
    pgut_command(conn, (char const   *)sql.data, 0, (char const   **)((void *)0));
    printfPQExpBuffer(& sql, "LOCK TABLE %s IN ACCESS SHARE MODE", target_name);
    res = pgut_execute_elevel(conn, (char const   *)sql.data, 0, (char const   **)((void *)0),
                              13);
    tmp___3 = PQresultStatus((PGresult const   *)res);
    if ((unsigned int )tmp___3 == 1U) {
      while (1) {
        PQclear(res);
        res = (PGresult *)((void *)0);
        break;
      }
      break;
    } else {
      tmp___2 = sqlstate_equals(res, "57014");
      if (tmp___2) {
        while (1) {
          PQclear(res);
          res = (PGresult *)((void *)0);
          break;
        }
        pgut_rollback(conn);
        goto __Cont;
      } else {
        tmp___1 = PQerrorMessage((PGconn const   *)connection);
        elog(19, "%s", tmp___1);
        while (1) {
          PQclear(res);
          res = (PGresult *)((void *)0);
          break;
        }
        ret = (_Bool)0;
        break;
      }
    }
    __Cont: /* CIL Label */
    i ++;
  }
  termPQExpBuffer(& sql);
  pgut_command(conn, "RESET statement_timeout", 0, (char const   **)((void *)0));
  return (ret);
}
}
static _Bool advisory_lock(PGconn *conn , char const   *relid )
{
  PGresult *res ;
  _Bool ret ;
  char const   *params[2] ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  ExecStatusType tmp___2 ;

  {
  res = (PGresult *)((void *)0);
  ret = (_Bool)0;
  params[0] = "16185446";
  params[1] = relid;
  res = pgut_execute(conn, "SELECT pg_try_advisory_lock($1, CAST(-2147483648 + $2::bigint AS integer))",
                     2, params);
  tmp___2 = PQresultStatus((PGresult const   *)res);
  if ((unsigned int )tmp___2 != 2U) {
    tmp = PQerrorMessage((PGconn const   *)connection);
    elog(20, "%s", tmp);
  } else {
    tmp___0 = getstr(res, 0, 0);
    tmp___1 = strcmp((char const   *)tmp___0, "t");
    if (tmp___1 != 0) {
      elog(20, "Another pg_repack command may be running on the table. Please try again later.");
    } else {
      ret = (_Bool)1;
    }
  }
  while (1) {
    PQclear(res);
    res = (PGresult *)((void *)0);
    break;
  }
  return (ret);
}
}
static _Bool lock_exclusive(PGconn *conn , char const   *relid , char const   *lock_query ,
                            _Bool start_xact )
{
  time_t start ;
  time_t tmp ;
  int i ;
  _Bool ret ;
  time_t duration ;
  char sql[1024] ;
  PGresult *res ;
  int wait_msec ;
  time_t tmp___0 ;
  char const   *cancel_query ;
  int tmp___1 ;
  char *tmp___2 ;
  _Bool tmp___3 ;
  ExecStatusType tmp___4 ;

  {
  tmp = time((time_t *)((void *)0));
  start = tmp;
  ret = (_Bool)1;
  i = 1;
  while (1) {
    if (start_xact) {
      pgut_command(conn, "BEGIN ISOLATION LEVEL READ COMMITTED", 0, (char const   **)((void *)0));
    } else {
      pgut_command(conn, "SAVEPOINT repack_sp1", 0, (char const   **)((void *)0));
    }
    tmp___0 = time((time_t *)((void *)0));
    duration = tmp___0 - start;
    if (duration > (time_t )wait_timeout) {
      if (no_kill_backend) {
        elog(19, "timed out, do not cancel conflicting backends");
        ret = (_Bool)0;
        if (start_xact) {
          pgut_rollback(conn);
        } else {
          pgut_command(conn, "ROLLBACK TO SAVEPOINT repack_sp1", 0, (char const   **)((void *)0));
        }
        break;
      } else {
        tmp___1 = PQserverVersion((PGconn const   *)conn);
        if (tmp___1 >= 80400) {
          if (duration > (time_t )(wait_timeout * 2)) {
            elog(19, "terminating conflicted backends");
            cancel_query = "SELECT pg_terminate_backend(pid) FROM pg_locks WHERE locktype = \'relation\'   AND relation = $1 AND pid <> pg_backend_pid()";
          } else {
            elog(19, "canceling conflicted backends");
            cancel_query = "SELECT pg_cancel_backend(pid) FROM pg_locks WHERE locktype = \'relation\'   AND relation = $1 AND pid <> pg_backend_pid()";
          }
        } else {
          elog(19, "canceling conflicted backends");
          cancel_query = "SELECT pg_cancel_backend(pid) FROM pg_locks WHERE locktype = \'relation\'   AND relation = $1 AND pid <> pg_backend_pid()";
        }
        pgut_command(conn, cancel_query, 1, & relid);
      }
    }
    if (1000 < i * 100) {
      wait_msec = 1000;
    } else {
      wait_msec = i * 100;
    }
    pg_snprintf(sql, sizeof(sql) / sizeof(sql[0]), "SET LOCAL statement_timeout = %d",
                wait_msec);
    pgut_command(conn, (char const   *)(sql), 0, (char const   **)((void *)0));
    res = pgut_execute_elevel(conn, lock_query, 0, (char const   **)((void *)0), 13);
    tmp___4 = PQresultStatus((PGresult const   *)res);
    if ((unsigned int )tmp___4 == 1U) {
      while (1) {
        PQclear(res);
        res = (PGresult *)((void *)0);
        break;
      }
      break;
    } else {
      tmp___3 = sqlstate_equals(res, "57014");
      if (tmp___3) {
        while (1) {
          PQclear(res);
          res = (PGresult *)((void *)0);
          break;
        }
        if (start_xact) {
          pgut_rollback(conn);
        } else {
          pgut_command(conn, "ROLLBACK TO SAVEPOINT repack_sp1", 0, (char const   **)((void *)0));
        }
        goto __Cont;
      } else {
        tmp___2 = PQerrorMessage((PGconn const   *)connection);
        pg_printf("%s", tmp___2);
        while (1) {
          PQclear(res);
          res = (PGresult *)((void *)0);
          break;
        }
        ret = (_Bool)0;
        break;
      }
    }
    __Cont: /* CIL Label */
    i ++;
  }
  pgut_command(conn, "RESET statement_timeout", 0, (char const   **)((void *)0));
  return (ret);
}
}
static void repack_cleanup_callback(_Bool fatal , void *userdata )
{
  Oid target_table ;
  char const   *params[2] ;
  char buffer[12] ;
  char num_buff[12] ;
  char *tmp ;
  char *tmp___0 ;

  {
  target_table = *((Oid *)userdata);
  if (fatal) {
    tmp = utoa(target_table, buffer);
    params[0] = (char const   *)tmp;
    tmp___0 = utoa(temp_obj_num, num_buff);
    params[1] = (char const   *)tmp___0;
    reconnect(20);
    command("SELECT repack.repack_drop($1, $2)", 2, params);
    temp_obj_num = 0U;
  }
  return;
}
}
static void repack_cleanup(_Bool fatal , repack_table const   *table )
{
  char buffer[12] ;
  char num_buff[12] ;
  char const   *params[2] ;
  ConnStatusType tmp ;
  ConnStatusType tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  if (fatal) {
    pg_fprintf(stderr, "!!!FATAL ERROR!!! Please refer to the manual.\n\n");
  } else {
    tmp = PQstatus((PGconn const   *)connection);
    if ((unsigned int )tmp != 0U) {
      reconnect(20);
    } else {
      tmp___0 = PQstatus((PGconn const   *)conn2);
      if ((unsigned int )tmp___0 != 0U) {
        reconnect(20);
      }
    }
    tmp___1 = utoa((unsigned int )table->target_oid, buffer);
    params[0] = (char const   *)tmp___1;
    tmp___2 = utoa(temp_obj_num, num_buff);
    params[1] = (char const   *)tmp___2;
    command("SELECT repack.repack_drop($1, $2)", 2, params);
    temp_obj_num = 0U;
  }
  return;
}
}
static _Bool repack_table_indexes(PGresult *index_details )
{
  _Bool ret ;
  PGresult *res ;
  PGresult *res2 ;
  PQExpBufferData sql ;
  PQExpBufferData sql_drop ;
  char buffer[2][12] ;
  char const   *create_idx ;
  char const   *schema_name ;
  char const   *table_name ;
  char const   *params[3] ;
  Oid table ;
  Oid index___0 ;
  int i ;
  int num ;
  int num_repacked ;
  _Bool *repacked_indexes ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  char *isvalid ;
  char *tmp___10 ;
  char *idx_name ;
  char *tmp___11 ;
  char *tmp___12 ;
  ExecStatusType tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  _Bool tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  _Bool tmp___26 ;
  ExecStatusType tmp___27 ;
  char *tmp___28 ;
  _Bool tmp___29 ;
  char *tmp___30 ;

  {
  ret = (_Bool)0;
  res = (PGresult *)((void *)0);
  res2 = (PGresult *)((void *)0);
  num_repacked = 0;
  initPQExpBuffer(& sql);
  num = PQntuples((PGresult const   *)index_details);
  table = getoid(index_details, 0, 3);
  tmp = utoa(table, buffer[1]);
  params[1] = (char const   *)tmp;
  params[2] = (char const   *)tablespace;
  tmp___0 = getstr(index_details, 0, 5);
  schema_name = (char const   *)tmp___0;
  tmp___1 = getstr(index_details, 0, 4);
  table_name = (char const   *)tmp___1;
  tmp___5 = calloc((size_t )num, sizeof(_Bool ));
  repacked_indexes = (_Bool *)tmp___5;
  if (! repacked_indexes) {
    tmp___4 = pgut_errstart(20);
    if (tmp___4) {
      tmp___2 = errmsg("Unable to calloc repacked_indexes");
      tmp___3 = errcode(12);
      pgut_errfinish(tmp___3, tmp___2);
    }
  }
  tmp___9 = advisory_lock(connection, params[1]);
  if (! tmp___9) {
    tmp___8 = pgut_errstart(20);
    if (tmp___8) {
      tmp___6 = errmsg("Unable to obtain advisory lock on \"%s\"", table_name);
      tmp___7 = errcode(22);
      pgut_errfinish(tmp___7, tmp___6);
    }
  }
  i = 0;
  while (i < num) {
    tmp___10 = getstr(index_details, i, 2);
    isvalid = tmp___10;
    tmp___11 = getstr(index_details, i, 0);
    idx_name = tmp___11;
    if ((int )*(isvalid + 0) == 116) {
      index___0 = getoid(index_details, i, 1);
      resetPQExpBuffer(& sql);
      appendPQExpBuffer(& sql, "SELECT pgc.relname, nsp.nspname FROM pg_class pgc INNER JOIN pg_namespace nsp ON nsp.oid = pgc.relnamespace WHERE pgc.relname = \'index_%u\' AND nsp.nspname = $1",
                        index___0);
      params[0] = schema_name;
      elog(17, "repacking index \"%s\"", idx_name);
      res = execute((char const   *)sql.data, 1, params);
      tmp___13 = PQresultStatus((PGresult const   *)res);
      if ((unsigned int )tmp___13 != 2U) {
        tmp___12 = PQerrorMessage((PGconn const   *)connection);
        elog(19, "%s", tmp___12);
        goto __Cont;
      }
      tmp___18 = PQntuples((PGresult const   *)res);
      if (tmp___18 > 0) {
        tmp___17 = pgut_errstart(19);
        if (tmp___17) {
          tmp___14 = errdetail("An invalid index may have been left behind by a previous pg_repack on the table which was interrupted. Please use DROP INDEX \"%s\".\"index_%u\" to remove this index and try again.",
                               schema_name, index___0);
          tmp___15 = errmsg("Cannot create index \"%s\".\"index_%u\", already exists",
                            schema_name, index___0);
          tmp___16 = errcode(-2);
          pgut_errfinish(tmp___16, tmp___15, tmp___14);
        }
        goto __Cont;
      }
      if (dryrun) {
        goto __Cont;
      }
      tmp___19 = utoa(index___0, buffer[0]);
      params[0] = (char const   *)tmp___19;
      res = execute("SELECT repack.repack_indexdef($1, $2, $3, true)", 3, params);
      tmp___21 = PQntuples((PGresult const   *)res);
      if (tmp___21 < 1) {
        tmp___20 = getstr(index_details, i, 0);
        elog(19, "unable to generate SQL to CREATE work index for %s", tmp___20);
        goto __Cont;
      }
      tmp___22 = getstr(res, 0, 0);
      create_idx = (char const   *)tmp___22;
      res2 = execute_elevel(create_idx, 0, (char const   **)((void *)0), 13);
      tmp___27 = PQresultStatus((PGresult const   *)res2);
      if ((unsigned int )tmp___27 != 1U) {
        tmp___26 = pgut_errstart(19);
        if (tmp___26) {
          tmp___23 = PQerrorMessage((PGconn const   *)connection);
          tmp___24 = errmsg("Error creating index \"%s\".\"index_%u\": %s", schema_name,
                            index___0, tmp___23);
          tmp___25 = errcode(-2);
          pgut_errfinish(tmp___25, tmp___24);
        }
      } else {
        *(repacked_indexes + i) = (_Bool)1;
        num_repacked ++;
      }
      while (1) {
        PQclear(res);
        res = (PGresult *)((void *)0);
        break;
      }
      while (1) {
        PQclear(res2);
        res2 = (PGresult *)((void *)0);
        break;
      }
    } else {
      tmp___28 = getstr(index_details, i, 0);
      elog(19, "skipping invalid index: %s.%s", schema_name, tmp___28);
    }
    __Cont: /* CIL Label */
    i ++;
  }
  if (dryrun) {
    ret = (_Bool)1;
    goto done;
  }
  if (! num_repacked) {
    elog(19, "Skipping index swapping for \"%s\", since no new indexes built", table_name);
    goto drop_idx;
  }
  resetPQExpBuffer(& sql);
  appendPQExpBuffer(& sql, "LOCK TABLE %s IN ACCESS EXCLUSIVE MODE", table_name);
  tmp___29 = lock_exclusive(connection, params[1], (char const   *)sql.data, (_Bool)1);
  if (! tmp___29) {
    elog(19, "lock_exclusive() failed in connection for %s", table_name);
    goto drop_idx;
  }
  i = 0;
  while (i < num) {
    index___0 = getoid(index_details, i, 1);
    if (*(repacked_indexes + i)) {
      tmp___30 = utoa(index___0, buffer[0]);
      params[0] = (char const   *)tmp___30;
      pgut_command(connection, "SELECT repack.repack_index_swap($1)", 1, params);
    } else {
      elog(17, "Skipping index swap for index_%u", index___0);
    }
    i ++;
  }
  pgut_command(connection, "COMMIT", 0, (char const   **)((void *)0));
  ret = (_Bool)1;
  drop_idx:
  resetPQExpBuffer(& sql);
  initPQExpBuffer(& sql_drop);
  appendPQExpBufferStr(& sql, "DROP INDEX CONCURRENTLY ");
  appendPQExpBuffer(& sql, "\"%s\".", schema_name);
  i = 0;
  while (i < num) {
    index___0 = getoid(index_details, i, 1);
    if (*(repacked_indexes + i)) {
      initPQExpBuffer(& sql_drop);
      appendPQExpBuffer(& sql_drop, "%s\"index_%u\"", sql.data, index___0);
      command((char const   *)sql_drop.data, 0, (char const   **)((void *)0));
    } else {
      elog(17, "Skipping drop of index_%u", index___0);
    }
    i ++;
  }
  termPQExpBuffer(& sql_drop);
  termPQExpBuffer(& sql);
  done:
  while (1) {
    PQclear(res);
    res = (PGresult *)((void *)0);
    break;
  }
  free((void *)repacked_indexes);
  return (ret);
}
}
static _Bool repack_all_indexes(char *errbuf , size_t errsize )
{
  _Bool ret ;
  PGresult *res ;
  PQExpBufferData sql ;
  SimpleStringListCell *cell ;
  char const   *params[1] ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  int nchildren ;
  int i ;
  char *tmp___2 ;
  ExecStatusType tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  ExecStatusType tmp___6 ;
  int tmp___7 ;
  _Bool tmp___8 ;

  {
  ret = (_Bool)0;
  res = (PGresult *)((void *)0);
  cell = (SimpleStringListCell *)((void *)0);
  initPQExpBuffer(& sql);
  reconnect(20);
  if (! r_index.head) {
    if (! table_list.head) {
      if (! parent_table_list.head) {
        __assert_fail("r_index.head || table_list.head || parent_table_list.head",
                      "pg_repack.c", 2225U, "repack_all_indexes");
      }
    }
  }
  tmp___0 = preliminary_checks(errbuf, errsize);
  if (! tmp___0) {
    goto cleanup;
  }
  tmp___1 = is_requested_relation_exists(errbuf, errsize);
  if (! tmp___1) {
    goto cleanup;
  }
  if (r_index.head) {
    appendPQExpBufferStr(& sql, "SELECT repack.oid2text(i.oid), idx.indexrelid, idx.indisvalid, idx.indrelid, repack.oid2text(idx.indrelid), n.nspname FROM pg_index idx JOIN pg_class i ON i.oid = idx.indexrelid JOIN pg_namespace n ON n.oid = i.relnamespace WHERE idx.indexrelid = $1::regclass ORDER BY indisvalid DESC, i.relname, n.nspname");
    cell = r_index.head;
  } else
  if (table_list.head) {
    goto _L;
  } else
  if (parent_table_list.head) {
    _L: /* CIL Label */
    appendPQExpBufferStr(& sql, "SELECT repack.oid2text(i.oid), idx.indexrelid, idx.indisvalid, idx.indrelid, $1::text, n.nspname FROM pg_index idx JOIN pg_class i ON i.oid = idx.indexrelid JOIN pg_namespace n ON n.oid = i.relnamespace WHERE idx.indrelid = $1::regclass ORDER BY indisvalid DESC, i.relname, n.nspname");
    cell = parent_table_list.head;
    while (cell) {
      params[0] = (char const   *)(cell->val);
      res = execute_elevel("SELECT quote_ident(n.nspname) || \'.\' || quote_ident(c.relname) FROM pg_class c JOIN pg_namespace n on n.oid = c.relnamespace WHERE c.oid = ANY (repack.get_table_and_inheritors($1::regclass)) ORDER BY n.nspname, c.relname",
                           1, params, 13);
      tmp___3 = PQresultStatus((PGresult const   *)res);
      if ((unsigned int )tmp___3 != 2U) {
        tmp___2 = PQerrorMessage((PGconn const   *)connection);
        elog(19, "%s", tmp___2);
        goto __Cont;
      }
      nchildren = PQntuples((PGresult const   *)res);
      if (nchildren == 0) {
        elog(19, "relation \"%s\" does not exist", cell->val);
        goto __Cont;
      }
      i = 0;
      while (i < nchildren) {
        tmp___4 = getstr(res, i, 0);
        simple_string_list_append(& table_list, (char const   *)tmp___4);
        i ++;
      }
      __Cont: /* CIL Label */
      cell = cell->next;
    }
    while (1) {
      PQclear(res);
      res = (PGresult *)((void *)0);
      break;
    }
    cell = table_list.head;
  }
  while (cell) {
    params[0] = (char const   *)(cell->val);
    res = execute_elevel((char const   *)sql.data, 1, params, 13);
    tmp___6 = PQresultStatus((PGresult const   *)res);
    if ((unsigned int )tmp___6 != 2U) {
      tmp___5 = PQerrorMessage((PGconn const   *)connection);
      elog(19, "%s", tmp___5);
      goto __Cont___0;
    }
    tmp___7 = PQntuples((PGresult const   *)res);
    if (tmp___7 == 0) {
      if (table_list.head) {
        elog(19, "\"%s\" does not have any indexes", cell->val);
      } else
      if (r_index.head) {
        elog(19, "\"%s\" is not a valid index", cell->val);
      }
      goto __Cont___0;
    }
    if (table_list.head) {
      elog(17, "repacking indexes of \"%s\"", cell->val);
    }
    tmp___8 = repack_table_indexes(res);
    if (! tmp___8) {
      elog(19, "repack failed for \"%s\"", cell->val);
    }
    while (1) {
      PQclear(res);
      res = (PGresult *)((void *)0);
      break;
    }
    __Cont___0: /* CIL Label */
    cell = cell->next;
  }
  ret = (_Bool)1;
  cleanup:
  disconnect();
  termPQExpBuffer(& sql);
  return (ret);
}
}
void pgut_help(_Bool details )
{


  {
  pg_printf("%s re-organizes a PostgreSQL database.\n\n", PROGRAM_NAME);
  pg_printf("Usage:\n");
  pg_printf("  %s [OPTION]... [DBNAME]\n", PROGRAM_NAME);
  if (! details) {
    return;
  }
  pg_printf("Options:\n");
  pg_printf("  -a, --all                 repack all databases\n");
  pg_printf("  -t, --table=TABLE         repack specific table only\n");
  pg_printf("  -I, --parent-table=TABLE  repack specific parent table and its inheritors\n");
  pg_printf("  -c, --schema=SCHEMA       repack tables in specific schema only\n");
  pg_printf("  -s, --tablespace=TBLSPC   move repacked tables to a new tablespace\n");
  pg_printf("  -S, --moveidx             move repacked indexes to TBLSPC too\n");
  pg_printf("  -o, --order-by=COLUMNS    order by columns instead of cluster keys\n");
  pg_printf("  -n, --no-order            do vacuum full instead of cluster\n");
  pg_printf("  -N, --dry-run             print what would have been repacked\n");
  pg_printf("  -j, --jobs=NUM            Use this many parallel jobs for each table\n");
  pg_printf("  -i, --index=INDEX         move only the specified index\n");
  pg_printf("  -x, --only-indexes        move only indexes of the specified table\n");
  pg_printf("  -T, --wait-timeout=SECS   timeout to cancel other backends on conflict\n");
  pg_printf("  -D, --no-kill-backend     don\'t kill other backends when timed out\n");
  pg_printf("  -Z, --no-analyze          don\'t analyze at end\n");
  pg_printf("  -k, --no-superuser-check  skip superuser checks in client\n");
  pg_printf("  -C, --exclude-extension   don\'t repack tables which belong to specific extension\n");
  return;
}
}
/* compiler builtin:
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin:
   void __builtin_va_end(__builtin_va_list  ) ;  */
#pragma merger("0","/tmp/cil-qILHDzCn.i","-Wall,-Wmissing-prototypes,-Wpointer-arith,-Wdeclaration-after-statement,-Werror=vla,-Wendif-labels,-Wmissing-format-attribute,-Wimplicit-fallthrough=3,-Wformat-security,-fno-strict-aliasing,-fwrapv,-fexcess-precision=standard,-Wno-format-truncation,-Wno-stringop-truncation,-g,-g,-O2,-fstack-protector-strong,-Wformat,-Werror=format-security,-fno-omit-frame-pointer,-Wdate-time")
extern int fflush(FILE *__stream ) ;
extern FILE *( __attribute__((__warn_unused_result__)) fopen)(char const   * __restrict  __filename ,
                                                              char const   * __restrict  __modes ) ;
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format
                                                , ...)  __asm__("__isoc99_sscanf")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__)) ferror)(FILE *__stream ) ;
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
extern long __fdelt_chk(long __d ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) atexit)(void (*__func)(void) ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) putenv)(char *__string ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
extern char const   *get_progname(char const   *argv0 ) ;
extern void get_parent_directory(char *path ) ;
extern void set_pglocale_pgservice(char const   *argv0 , char const   *app ) ;
extern int pg_strcasecmp(char const   *s1 , char const   *s2 ) ;
extern int pg_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) ;
extern int pg_vsnprintf(char *str , size_t count , char const   *fmt , va_list___0 args ) ;
extern char *pg_strerror(int errnum ) ;
extern void simple_prompt(char const   *prompt , char *destination , size_t destlen ,
                          _Bool echo ) ;
extern size_t strlcpy(char *dst , char const   *src , size_t siz ) ;
extern pqsigfunc pqsignal(int signo , void (*func)(int signo ) ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat64)(int __fd , struct stat64 *__statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat64)(int __fd , char const   * __restrict  __filename , struct stat64 * __restrict  __statbuf ,
                            int __flag ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) mkdir)(char const   *__path ,
                                                                                  __mode_t __mode ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat)(int __ver ,
                                                                                     int __fildes ,
                                                                                     struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat)(int __ver ,
                                                                                      char const   *__filename ,
                                                                                      struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat)(int __ver ,
                                                                                       char const   *__filename ,
                                                                                       struct stat *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4))) __fxstatat)(int __ver ,
                                                                                         int __fildes ,
                                                                                         char const   *__filename ,
                                                                                         struct stat *__stat_buf ,
                                                                                         int __flag ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3))) __fxstat64)(int __ver ,
                                                                                       int __fildes ,
                                                                                       struct stat64 *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __xstat64)(int __ver ,
                                                                                        char const   *__filename ,
                                                                                        struct stat64 *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) __lxstat64)(int __ver ,
                                                                                         char const   *__filename ,
                                                                                         struct stat64 *__stat_buf ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4))) __fxstatat64)(int __ver ,
                                                                                           int __fildes ,
                                                                                           char const   *__filename ,
                                                                                           struct stat64 *__stat_buf ,
                                                                                           int __flag ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4))) __xmknod)(int __ver ,
                                                                                       char const   *__path ,
                                                                                       __mode_t __mode ,
                                                                                       __dev_t *__dev ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,5))) __xmknodat)(int __ver ,
                                                                                         int __fd ,
                                                                                         char const   *__path ,
                                                                                         __mode_t __mode ,
                                                                                         __dev_t *__dev ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) stat)(char const   * __restrict  __path ,
                                                                              struct stat * __restrict  __statbuf )
{
  int tmp ;

  {
  tmp = __xstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) lstat)(char const   * __restrict  __path ,
                                                                               struct stat * __restrict  __statbuf )
{
  int tmp ;

  {
  tmp = __lxstat(1, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat)(int __fd , struct stat *__statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) fstat)(int __fd ,
                                                                             struct stat *__statbuf )
{
  int tmp ;

  {
  tmp = __fxstat(1, __fd, __statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                          int __flag ) ;
__inline extern int ( __attribute__((__nonnull__(2,3), __gnu_inline__)) fstatat)(int __fd ,
                                                                                 char const   * __restrict  __filename ,
                                                                                 struct stat * __restrict  __statbuf ,
                                                                                 int __flag )
{
  int tmp ;

  {
  tmp = __fxstatat(1, __fd, (char const   *)__filename, (struct stat *)__statbuf,
                   __flag);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) mknod)(char const   *__path ,
                                                                             __mode_t __mode ,
                                                                             __dev_t __dev )
{
  int tmp ;

  {
  tmp = __xmknod(0, __path, __mode, & __dev);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) mknodat)(int __fd ,
                                                                               char const   *__path ,
                                                                               __mode_t __mode ,
                                                                               __dev_t __dev )
{
  int tmp ;

  {
  tmp = __xmknodat(0, __fd, __path, __mode, & __dev);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) stat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) stat64)(char const   * __restrict  __path ,
                                                                                struct stat64 * __restrict  __statbuf )
{
  int tmp ;

  {
  tmp = __xstat64(1, (char const   *)__path, (struct stat64 *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__gnu_inline__)) lstat64)(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(1,2), __gnu_inline__)) lstat64)(char const   * __restrict  __path ,
                                                                                 struct stat64 * __restrict  __statbuf )
{
  int tmp ;

  {
  tmp = __lxstat64(1, (char const   *)__path, (struct stat64 *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__gnu_inline__)) fstat64)(int __fd , struct stat64 *__statbuf ) ;
__inline extern int ( __attribute__((__nonnull__(2), __gnu_inline__)) fstat64)(int __fd ,
                                                                               struct stat64 *__statbuf )
{
  int tmp ;

  {
  tmp = __fxstat64(1, __fd, __statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__gnu_inline__)) fstatat64)(int __fd , char const   * __restrict  __filename , struct stat64 * __restrict  __statbuf ,
                            int __flag ) ;
__inline extern int ( __attribute__((__nonnull__(2,3), __gnu_inline__)) fstatat64)(int __fd ,
                                                                                   char const   * __restrict  __filename ,
                                                                                   struct stat64 * __restrict  __statbuf ,
                                                                                   int __flag )
{
  int tmp ;

  {
  tmp = __fxstatat64(1, __fd, (char const   *)__filename, (struct stat64 *)__statbuf,
                     __flag);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                     pthread_t __thread2 )
{


  {
  return (__thread1 == __thread2);
}
}
extern PGconn *PQconnectdb(char const   *conninfo ) ;
extern void PQfinish(PGconn *conn ) ;
extern PGcancel *PQgetCancel(PGconn *conn ) ;
extern void PQfreeCancel(PGcancel *cancel ) ;
extern int PQcancel(PGcancel *cancel , char *errbuf , int errbufsize ) ;
extern PGTransactionStatusType PQtransactionStatus(PGconn const   *conn ) ;
extern int PQconnectionNeedsPassword(PGconn const   *conn ) ;
extern PGresult *PQexec(PGconn *conn , char const   *query ) ;
extern PGresult *PQexecParams(PGconn *conn , char const   *command , int nParams ,
                              Oid const   *paramTypes , char const   * const  *paramValues ,
                              int const   *paramLengths , int const   *paramFormats ,
                              int resultFormat ) ;
extern int PQsendQueryParams(PGconn *conn , char const   *command , int nParams ,
                             Oid const   *paramTypes , char const   * const  *paramValues ,
                             int const   *paramLengths , int const   *paramFormats ,
                             int resultFormat ) ;
extern int enlargePQExpBuffer(PQExpBuffer str , size_t needed ) ;
_Bool interrupted ;
int pgut_log_level ;
int pgut_abort_level ;
_Bool pgut_echo ;
void pgut_init(int argc , char **argv ) ;
void pgut_atexit_pop(void (*callback)(_Bool fatal , void *userdata ) , void *userdata ) ;
void pgut_putenv(char const   *key , char const   *value ) ;
PGconn *pgut_connect(char const   *info , YesNo prompt , int elevel ) ;
void pgut_disconnect(PGconn *conn ) ;
void pgut_disconnect_all(void) ;
_Bool pgut_commit(PGconn *conn ) ;
_Bool pgut_send(PGconn *conn , char const   *query , int nParams , char const   **params ) ;
int pgut_wait(int num , PGconn **connections , struct timeval *timeout ) ;
void *pgut_realloc(void *p , size_t size ) ;
char *strdup_with_len(char const   *str , size_t len ) ;
char *strdup_trim(char const   *str ) ;
FILE *pgut_fopen(char const   *path , char const   *omode ) ;
_Bool pgut_mkdir(char const   *dirpath ) ;
char const   *format_elevel(int elevel ) ;
int parse_elevel(char const   *value ) ;
int errcode_errno(void) ;
_Bool log_required(int elevel , int log_min_level ) ;
void pgut_error(int elevel , int code , char const   *msg , char const   *detail ) ;
void CHECK_FOR_INTERRUPTS(void) ;
_Bool ( /* format attribute */  pgut_appendStringInfoVA)(PQExpBuffer str , char const   *fmt ,
                                                         va_list___0 args ) ;
int appendStringInfoFile(PQExpBuffer str , FILE *fp ) ;
int appendStringInfoFd(PQExpBuffer str , int fd ) ;
_Bool parse_bool(char const   *value , _Bool *result ) ;
_Bool parse_bool_with_len(char const   *value , size_t len , _Bool *result ) ;
_Bool parse_int32(char const   *value , int32 *result ) ;
_Bool parse_uint32(char const   *value , uint32 *result ) ;
_Bool parse_int64(char const   *value , int64 *result ) ;
_Bool parse_uint64(char const   *value , uint64 *result ) ;
_Bool parse_time(char const   *value , time_t *time___0 ) ;
_Bool simple_string_list_member(SimpleStringList *list , char const   *val ) ;
int wait_for_socket(int sock , struct timeval *timeout ) ;
int wait_for_sockets(int nfds , fd_set *fds , struct timeval *timeout ) ;
static pthread_mutex_t pgut_conn_mutex  ;
char const   *PROGRAM_NAME  =    (char const   *)((void *)0);
_Bool interrupted  =    (_Bool)0;
static _Bool in_cleanup  =    (_Bool)0;
int pgut_log_level  =    17;
int pgut_abort_level  =    20;
_Bool pgut_echo  =    (_Bool)0;
static pgutConn *pgut_connections  ;
static void init_cancel_handler(void) ;
static void on_before_exec(pgutConn *conn ) ;
static void on_after_exec(pgutConn *conn ) ;
static void on_interrupt(void) ;
static void on_cleanup(void) ;
static void exit_or_abort(int exitcode , int elevel ) ;
void pgut_init(int argc , char **argv )
{
  char *tmp ;

  {
  if ((unsigned long )PROGRAM_NAME == (unsigned long )((void *)0)) {
    PROGRAM_NAME = get_progname((char const   *)*(argv + 0));
    set_pglocale_pgservice((char const   *)*(argv + 0), "pgscripts");
    tmp = getenv("PGAPPNAME");
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      pgut_putenv("PGAPPNAME", PROGRAM_NAME);
    }
    init_cancel_handler();
    atexit(& on_cleanup);
  }
  return;
}
}
void pgut_putenv(char const   *key , char const   *value )
{
  char buf[1024] ;
  char *tmp ;

  {
  pg_snprintf(buf, sizeof(buf) / sizeof(buf[0]), "%s=%s", key, value);
  tmp = pgut_strdup((char const   *)(buf));
  putenv(tmp);
  return;
}
}
_Bool parse_bool(char const   *value , _Bool *result )
{
  size_t tmp ;
  _Bool tmp___0 ;

  {
  tmp = strlen(value);
  tmp___0 = parse_bool_with_len(value, tmp, result);
  return (tmp___0);
}
}
_Bool parse_bool_with_len(char const   *value , size_t len , _Bool *result )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;

  {
  switch ((int const   )*value) {
  case 84:
  case 116:
  tmp = pg_strncasecmp(value, "true", len);
  if (tmp == 0) {
    if (result) {
      *result = (_Bool)1;
    }
    return ((_Bool)1);
  }
  break;
  case 70:
  case 102:
  tmp___0 = pg_strncasecmp(value, "false", len);
  if (tmp___0 == 0) {
    if (result) {
      *result = (_Bool)0;
    }
    return ((_Bool)1);
  }
  break;
  case 89:
  case 121:
  tmp___1 = pg_strncasecmp(value, "yes", len);
  if (tmp___1 == 0) {
    if (result) {
      *result = (_Bool)1;
    }
    return ((_Bool)1);
  }
  break;
  case 78:
  case 110:
  tmp___2 = pg_strncasecmp(value, "no", len);
  if (tmp___2 == 0) {
    if (result) {
      *result = (_Bool)0;
    }
    return ((_Bool)1);
  }
  break;
  case 79:
  case 111:
  if (len > 2UL) {
    tmp___5 = len;
  } else {
    tmp___5 = (size_t )2;
  }
  tmp___6 = pg_strncasecmp(value, "on", tmp___5);
  if (tmp___6 == 0) {
    if (result) {
      *result = (_Bool)1;
    }
    return ((_Bool)1);
  } else {
    if (len > 2UL) {
      tmp___3 = len;
    } else {
      tmp___3 = (size_t )2;
    }
    tmp___4 = pg_strncasecmp(value, "off", tmp___3);
    if (tmp___4 == 0) {
      if (result) {
        *result = (_Bool)0;
      }
      return ((_Bool)1);
    }
  }
  break;
  case 49:
  if (len == 1UL) {
    if (result) {
      *result = (_Bool)1;
    }
    return ((_Bool)1);
  }
  break;
  case 48:
  if (len == 1UL) {
    if (result) {
      *result = (_Bool)0;
    }
    return ((_Bool)1);
  }
  break;
  default:
  break;
  }
  if (result) {
    *result = (_Bool)0;
  }
  return ((_Bool)0);
}
}
_Bool parse_int32(char const   *value , int32 *result )
{
  int64 val ;
  char *endptr ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  tmp = strcmp(value, "INFINITE");
  if (tmp == 0) {
    *result = 2147483647;
    return ((_Bool)1);
  }
  tmp___0 = __errno_location();
  *tmp___0 = 0;
  val = strtol((char const   * __restrict  )value, (char ** __restrict  )(& endptr),
               0);
  if ((unsigned long )endptr == (unsigned long )value) {
    return ((_Bool)0);
  } else
  if (*endptr) {
    return ((_Bool)0);
  }
  tmp___1 = __errno_location();
  if (*tmp___1 == 34) {
    return ((_Bool)0);
  } else
  if (val != (int64 )((int32 )val)) {
    return ((_Bool)0);
  }
  *result = (int32 )val;
  return ((_Bool)1);
}
}
_Bool parse_uint32(char const   *value , uint32 *result )
{
  uint64 val ;
  char *endptr ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  tmp = strcmp(value, "INFINITE");
  if (tmp == 0) {
    *result = 4294967295U;
    return ((_Bool)1);
  }
  tmp___0 = __errno_location();
  *tmp___0 = 0;
  val = strtoul((char const   * __restrict  )value, (char ** __restrict  )(& endptr),
                0);
  if ((unsigned long )endptr == (unsigned long )value) {
    return ((_Bool)0);
  } else
  if (*endptr) {
    return ((_Bool)0);
  }
  tmp___1 = __errno_location();
  if (*tmp___1 == 34) {
    return ((_Bool)0);
  } else
  if (val != (uint64 )((uint32 )val)) {
    return ((_Bool)0);
  }
  *result = (uint32 )val;
  return ((_Bool)1);
}
}
_Bool parse_int64(char const   *value , int64 *result )
{
  int64 val ;
  char *endptr ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  tmp = strcmp(value, "INFINITE");
  if (tmp == 0) {
    *result = (int64 )9223372036854775807LL;
    return ((_Bool)1);
  }
  tmp___0 = __errno_location();
  *tmp___0 = 0;
  val = strtol((char const   * __restrict  )value, (char ** __restrict  )(& endptr),
               0);
  if ((unsigned long )endptr == (unsigned long )value) {
    return ((_Bool)0);
  } else
  if (*endptr) {
    return ((_Bool)0);
  }
  tmp___1 = __errno_location();
  if (*tmp___1 == 34) {
    return ((_Bool)0);
  }
  *result = val;
  return ((_Bool)1);
}
}
_Bool parse_uint64(char const   *value , uint64 *result )
{
  uint64 val ;
  char *endptr ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  tmp = strcmp(value, "INFINITE");
  if (tmp == 0) {
    *result = 18446744073709551615;
    return ((_Bool)1);
  }
  tmp___0 = __errno_location();
  *tmp___0 = 0;
  val = strtoul((char const   * __restrict  )value, (char ** __restrict  )(& endptr),
                0);
  if ((unsigned long )endptr == (unsigned long )value) {
    return ((_Bool)0);
  } else
  if (*endptr) {
    return ((_Bool)0);
  }
  tmp___1 = __errno_location();
  if (*tmp___1 == 34) {
    return ((_Bool)0);
  }
  *result = val;
  return ((_Bool)1);
}
}
_Bool parse_time(char const   *value , time_t *time___0 )
{
  size_t len ;
  char *tmp ;
  int i ;
  struct tm tm ;
  char junk[2] ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  unsigned short const   **tmp___4 ;

  {
  tmp___0 = strlen(value);
  tmp___1 = pgut_malloc(tmp___0 + 1UL);
  tmp = (char *)tmp___1;
  len = (size_t )0;
  i = 0;
  while (*(value + i)) {
    tmp___2 = len;
    len ++;
    tmp___4 = __ctype_b_loc();
    if ((int const   )*(*tmp___4 + (int )((unsigned char )*(value + i))) & 8) {
      *(tmp + tmp___2) = (char )*(value + i);
    } else {
      *(tmp + tmp___2) = (char )' ';
    }
    i ++;
  }
  *(tmp + len) = (char )'\000';
  memset((void *)(& tm), 0, sizeof(tm));
  tm.tm_year = 0;
  tm.tm_mon = 0;
  tm.tm_mday = 1;
  tm.tm_hour = 0;
  tm.tm_min = 0;
  tm.tm_sec = 0;
  i = sscanf((char const   * __restrict  )tmp, (char const   * __restrict  )"%04d %02d %02d %02d %02d %02d%1s",
             & tm.tm_year, & tm.tm_mon, & tm.tm_mday, & tm.tm_hour, & tm.tm_min, & tm.tm_sec,
             junk);
  free((void *)tmp);
  if (i < 1) {
    return ((_Bool)0);
  } else
  if (6 < i) {
    return ((_Bool)0);
  }
  if (tm.tm_year < 100) {
    tm.tm_year += 100;
  } else
  if (tm.tm_year >= 1900) {
    tm.tm_year -= 1900;
  }
  if (i > 1) {
    (tm.tm_mon) --;
  }
  tm.tm_isdst = -1;
  *time___0 = mktime(& tm);
  return ((_Bool)1);
}
}
void simple_string_list_append(SimpleStringList *list , char const   *val )
{
  SimpleStringListCell *cell ;
  size_t tmp ;
  void *tmp___0 ;

  {
  tmp = strlen(val);
  tmp___0 = pgut_malloc(sizeof(SimpleStringListCell ) + tmp);
  cell = (SimpleStringListCell *)tmp___0;
  cell->next = (struct SimpleStringListCell *)((void *)0);
  strcpy((char * __restrict  )(cell->val), (char const   * __restrict  )val);
  if (list->tail) {
    (list->tail)->next = cell;
  } else {
    list->head = cell;
  }
  list->tail = cell;
  return;
}
}
_Bool simple_string_list_member(SimpleStringList *list , char const   *val )
{
  SimpleStringListCell *cell ;
  int tmp ;

  {
  cell = list->head;
  while (cell) {
    tmp = strcmp((char const   *)(cell->val), val);
    if (tmp == 0) {
      return ((_Bool)1);
    }
    cell = cell->next;
  }
  return ((_Bool)0);
}
}
size_t simple_string_list_size(SimpleStringList list )
{
  size_t i ;
  SimpleStringListCell *cell ;

  {
  i = (size_t )0;
  cell = list.head;
  while (cell) {
    cell = cell->next;
    i ++;
  }
  return (i);
}
}
static char *passwdbuf  ;
static char *prompt_for_password(void) ;
static _Bool have_passwd  =    (_Bool)0;
static char *prompt_for_password(void)
{
  char *buf ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;

  {
  tmp = pgut_malloc((size_t )100);
  buf = (char *)tmp;
  if (have_passwd) {
    memcpy((void * __restrict  )buf, (void const   * __restrict  )passwdbuf, sizeof(char ) * 100UL);
  } else {
    if ((unsigned long )buf != (unsigned long )((void *)0)) {
      simple_prompt("Password: ", buf, (size_t )100, (_Bool)0);
    }
    have_passwd = (_Bool)1;
    tmp___0 = pgut_malloc((size_t )100);
    passwdbuf = (char *)tmp___0;
    memcpy((void * __restrict  )passwdbuf, (void const   * __restrict  )buf, sizeof(char ) * 100UL);
  }
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
    tmp___3 = pgut_errstart(21);
    if (tmp___3) {
      tmp___1 = errmsg("could not allocate memory (%lu bytes): ", (uint64 )100);
      tmp___2 = errcode_errno();
      pgut_errfinish(tmp___2, tmp___1);
    }
  }
  return (buf);
}
}
PGconn *pgut_connect(char const   *info , YesNo prompt , int elevel )
{
  char *passwd ;
  PQExpBufferData add_pass ;
  PGconn *conn ;
  pgutConn *c ;
  void *tmp ;
  ConnStatusType tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;

  {
  if ((unsigned int )prompt == 2U) {
    passwd = prompt_for_password();
    initPQExpBuffer(& add_pass);
    appendPQExpBufferStr(& add_pass, info);
    appendPQExpBuffer(& add_pass, " password=%s ", passwd);
  } else {
    passwd = (char *)((void *)0);
    add_pass.data = (char *)((void *)0);
  }
  while (1) {
    CHECK_FOR_INTERRUPTS();
    if (! passwd) {
      conn = PQconnectdb(info);
    } else {
      conn = PQconnectdb((char const   *)add_pass.data);
    }
    tmp___0 = PQstatus((PGconn const   *)conn);
    if ((unsigned int )tmp___0 == 0U) {
      tmp = pgut_malloc(sizeof(pgutConn ));
      c = (pgutConn *)tmp;
      c->conn = conn;
      c->cancel = (PGcancel *)((void *)0);
      pthread_mutex_lock(& pgut_conn_mutex);
      c->next = pgut_connections;
      pgut_connections = c;
      pthread_mutex_unlock(& pgut_conn_mutex);
      if ((unsigned long )add_pass.data != (unsigned long )((void *)0)) {
        termPQExpBuffer(& add_pass);
      }
      free((void *)passwd);
      pgut_command(conn, "SET search_path TO pg_catalog, pg_temp, public", 0, (char const   **)((void *)0));
      return (conn);
    }
    if (conn) {
      tmp___1 = PQconnectionNeedsPassword((PGconn const   *)conn);
      if (tmp___1) {
        if ((unsigned int )prompt != 1U) {
          PQfinish(conn);
          free((void *)passwd);
          passwd = prompt_for_password();
          if ((unsigned long )add_pass.data != (unsigned long )((void *)0)) {
            resetPQExpBuffer(& add_pass);
          } else {
            initPQExpBuffer(& add_pass);
          }
          appendPQExpBufferStr(& add_pass, info);
          appendPQExpBuffer(& add_pass, " password=%s ", passwd);
          goto __Cont;
        }
      }
    }
    if ((unsigned long )add_pass.data != (unsigned long )((void *)0)) {
      termPQExpBuffer(& add_pass);
    }
    free((void *)passwd);
    tmp___5 = pgut_errstart(elevel);
    if (tmp___5) {
      tmp___2 = PQerrorMessage((PGconn const   *)conn);
      tmp___3 = errmsg("could not connect to database: %s", tmp___2);
      tmp___4 = errcode(-1);
      pgut_errfinish(tmp___4, tmp___3);
    }
    PQfinish(conn);
    return ((PGconn *)((void *)0));
    __Cont: /* CIL Label */ ;
  }
}
}
void pgut_disconnect(PGconn *conn )
{
  pgutConn *c ;
  pgutConn **prev ;

  {
  if (conn) {
    pthread_mutex_lock(& pgut_conn_mutex);
    prev = & pgut_connections;
    c = pgut_connections;
    while (c) {
      if ((unsigned long )c->conn == (unsigned long )conn) {
        *prev = c->next;
        break;
      }
      prev = & c->next;
      c = c->next;
    }
    pthread_mutex_unlock(& pgut_conn_mutex);
    PQfinish(conn);
  }
  return;
}
}
void pgut_disconnect_all(void)
{


  {
  pthread_mutex_lock(& pgut_conn_mutex);
  while (pgut_connections) {
    PQfinish(pgut_connections->conn);
    pgut_connections = pgut_connections->next;
  }
  pthread_mutex_unlock(& pgut_conn_mutex);
  return;
}
}
static void echo_query(char const   *query , int nParams , char const   **params )
{
  int i ;
  char *tmp ;
  char const   *tmp___0 ;

  {
  tmp = strchr(query, '\n');
  if (tmp) {
    elog(15, "(query)\n%s", query);
  } else {
    elog(15, "(query) %s", query);
  }
  i = 0;
  while (i < nParams) {
    if (*(params + i)) {
      tmp___0 = *(params + i);
    } else {
      tmp___0 = "(null)";
    }
    elog(15, "\t(param:%d) = %s", i, tmp___0);
    i ++;
  }
  return;
}
}
PGresult *pgut_execute(PGconn *conn , char const   *query , int nParams , char const   **params )
{
  PGresult *tmp ;

  {
  tmp = pgut_execute_elevel(conn, query, nParams, params, 20);
  return (tmp);
}
}
PGresult *pgut_execute_elevel(PGconn *conn , char const   *query , int nParams , char const   **params ,
                              int elevel )
{
  PGresult *res ;
  pgutConn *c ;
  int tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  ExecStatusType tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  _Bool tmp___7 ;

  {
  CHECK_FOR_INTERRUPTS();
  if (pgut_echo) {
    echo_query(query, nParams, params);
  }
  if ((unsigned long )conn == (unsigned long )((void *)0)) {
    tmp___1 = pgut_errstart(elevel);
    if (tmp___1) {
      tmp = errmsg("not connected");
      tmp___0 = errcode(-2);
      pgut_errfinish(tmp___0, tmp);
    }
    return ((PGresult *)((void *)0));
  }
  pthread_mutex_lock(& pgut_conn_mutex);
  c = pgut_connections;
  while (c) {
    if ((unsigned long )c->conn == (unsigned long )conn) {
      break;
    }
    c = c->next;
  }
  pthread_mutex_unlock(& pgut_conn_mutex);
  if (c) {
    on_before_exec(c);
  }
  if (nParams == 0) {
    res = PQexec(conn, query);
  } else {
    res = PQexecParams(conn, query, nParams, (Oid const   *)((void *)0), (char const   * const  *)params,
                       (int const   *)((void *)0), (int const   *)((void *)0), 0);
  }
  if (c) {
    on_after_exec(c);
  }
  tmp___2 = PQresultStatus((PGresult const   *)res);
  switch ((unsigned int )tmp___2) {
  case 4U:
  case 1U:
  case 2U:
  break;
  default:
  tmp___7 = pgut_errstart(elevel);
  if (tmp___7) {
    tmp___3 = errdetail("query was: %s", query);
    tmp___4 = PQerrorMessage((PGconn const   *)conn);
    tmp___5 = errmsg("query failed: %s", tmp___4);
    tmp___6 = errcode(-2);
    pgut_errfinish(tmp___6, tmp___5, tmp___3);
  }
  break;
  }
  return (res);
}
}
ExecStatusType pgut_command(PGconn *conn , char const   *query , int nParams , char const   **params )
{
  PGresult *res ;
  ExecStatusType code ;

  {
  res = pgut_execute(conn, query, nParams, params);
  code = PQresultStatus((PGresult const   *)res);
  PQclear(res);
  return (code);
}
}
_Bool pgut_commit(PGconn *conn )
{
  ExecStatusType tmp ;
  PGTransactionStatusType tmp___0 ;

  {
  if (conn) {
    tmp___0 = PQtransactionStatus((PGconn const   *)conn);
    if ((unsigned int )tmp___0 != 0U) {
      tmp = pgut_command(conn, "COMMIT", 0, (char const   **)((void *)0));
      return ((_Bool )((unsigned int )tmp == 1U));
    }
  }
  return ((_Bool)1);
}
}
void pgut_rollback(PGconn *conn )
{
  PGTransactionStatusType tmp ;

  {
  if (conn) {
    tmp = PQtransactionStatus((PGconn const   *)conn);
    if ((unsigned int )tmp != 0U) {
      pgut_command(conn, "ROLLBACK", 0, (char const   **)((void *)0));
    }
  }
  return;
}
}
_Bool pgut_send(PGconn *conn , char const   *query , int nParams , char const   **params )
{
  int res ;
  int tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  _Bool tmp___6 ;

  {
  CHECK_FOR_INTERRUPTS();
  if (pgut_echo) {
    echo_query(query, nParams, params);
  }
  if ((unsigned long )conn == (unsigned long )((void *)0)) {
    tmp___1 = pgut_errstart(20);
    if (tmp___1) {
      tmp = errmsg("not connected");
      tmp___0 = errcode(-2);
      pgut_errfinish(tmp___0, tmp);
    }
    return ((_Bool)0);
  }
  if (nParams == 0) {
    res = PQsendQuery(conn, query);
  } else {
    res = PQsendQueryParams(conn, query, nParams, (Oid const   *)((void *)0), (char const   * const  *)params,
                            (int const   *)((void *)0), (int const   *)((void *)0),
                            0);
  }
  if (res != 1) {
    tmp___6 = pgut_errstart(20);
    if (tmp___6) {
      tmp___2 = errdetail("query was: %s", query);
      tmp___3 = PQerrorMessage((PGconn const   *)conn);
      tmp___4 = errmsg("query failed: %s", tmp___3);
      tmp___5 = errcode(-2);
      pgut_errfinish(tmp___5, tmp___4, tmp___2);
    }
    return ((_Bool)0);
  }
  return ((_Bool)1);
}
}
int pgut_wait(int num , PGconn **connections , struct timeval *timeout )
{
  int i ;
  fd_set mask ;
  int maxsock ;
  int __d0 ;
  int __d1 ;
  int sock ;
  long __d ;
  long tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  long __d___0 ;
  int tmp___4 ;
  long tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;

  {
  while (! interrupted) {
    while (1) {
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& mask.fds_bits[0]): "memory");
      break;
    }
    maxsock = -1;
    i = 0;
    while (i < num) {
      if ((unsigned long )*(connections + i) == (unsigned long )((void *)0)) {
        goto __Cont;
      }
      sock = PQsocket((PGconn const   *)*(connections + i));
      if (sock >= 0) {
        __d = (long )sock;
        tmp___1 = __fdelt_chk(__d);
        mask.fds_bits[tmp___1] |= (__fd_mask )(1UL << sock % (8 * (int )sizeof(__fd_mask )));
        if (maxsock < sock) {
          maxsock = sock;
        }
      }
      __Cont: /* CIL Label */
      i ++;
    }
    if (maxsock == -1) {
      tmp___2 = __errno_location();
      *tmp___2 = 2;
      return (-1);
    }
    i = wait_for_sockets(maxsock + 1, & mask, timeout);
    if (i == 0) {
      break;
    }
    i = 0;
    while (i < num) {
      if (*(connections + i)) {
        tmp___4 = PQsocket((PGconn const   *)*(connections + i));
        __d___0 = (long )tmp___4;
        tmp___7 = __fdelt_chk(__d___0);
        tmp___8 = PQsocket((PGconn const   *)*(connections + i));
        if ((mask.fds_bits[tmp___7] & (__fd_mask )(1UL << tmp___8 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          PQconsumeInput(*(connections + i));
          tmp___3 = PQisBusy(*(connections + i));
          if (tmp___3) {
            goto __Cont___0;
          }
          return (i);
        }
      }
      __Cont___0: /* CIL Label */
      i ++;
    }
  }
  tmp___9 = __errno_location();
  *tmp___9 = 4;
  return (-1);
}
}
void CHECK_FOR_INTERRUPTS(void)
{
  int tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;

  {
  if (interrupted) {
    if (! in_cleanup) {
      tmp___1 = pgut_errstart(21);
      if (tmp___1) {
        tmp = errmsg("interrupted");
        tmp___0 = errcode(4);
        pgut_errfinish(tmp___0, tmp);
      }
    }
  }
  return;
}
}
static pgutErrorData edata  ;
static pgutErrorData *getErrorData(void)
{


  {
  return (& edata);
}
}
static pgutErrorData *pgut_errinit(int elevel )
{
  int save_errno ;
  int *tmp ;
  pgutErrorData *edata___0 ;
  pgutErrorData *tmp___0 ;

  {
  tmp = __errno_location();
  save_errno = *tmp;
  tmp___0 = getErrorData();
  edata___0 = tmp___0;
  edata___0->elevel = elevel;
  edata___0->save_errno = save_errno;
  if (elevel >= 20) {
    edata___0->code = 1;
  } else {
    edata___0->code = 0;
  }
  if (edata___0->msg.data) {
    resetPQExpBuffer(& edata___0->msg);
  } else {
    initPQExpBuffer(& edata___0->msg);
  }
  if (edata___0->detail.data) {
    resetPQExpBuffer(& edata___0->detail);
  } else {
    initPQExpBuffer(& edata___0->detail);
  }
  return (edata___0);
}
}
static void trimStringBuffer(PQExpBuffer str )
{
  unsigned short const   **tmp ;

  {
  while (1) {
    if (str->len > 0UL) {
      tmp = __ctype_b_loc();
      if (! ((int const   )*(*tmp + (int )((unsigned char )*(str->data + (str->len - 1UL)))) & 8192)) {
        break;
      }
    } else {
      break;
    }
    (str->len) --;
    *(str->data + str->len) = (char )'\000';
  }
  return;
}
}
void ( /* format attribute */  elog)(int elevel , char const   *fmt  , ...)
{
  va_list___0 args ;
  _Bool ok ;
  size_t len ;
  pgutErrorData *edata___0 ;
  _Bool tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  if (elevel < pgut_abort_level) {
    tmp = log_required(elevel, pgut_log_level);
    if (! tmp) {
      return;
    }
  }
  edata___0 = pgut_errinit(elevel);
  while (1) {
    __builtin_va_start(args, fmt);
    ok = pgut_appendStringInfoVA(& edata___0->msg, fmt, args);
    __builtin_va_end(args);
    if (! (! ok)) {
      break;
    }
  }
  len = strlen(fmt);
  if (len > 2UL) {
    tmp___1 = strcmp((fmt + len) - 2, ": ");
    if (tmp___1 == 0) {
      tmp___0 = pg_strerror(edata___0->save_errno);
      appendPQExpBufferStr(& edata___0->msg, (char const   *)tmp___0);
    }
  }
  trimStringBuffer(& edata___0->msg);
  pgut_errfinish(1);
  return;
}
}
_Bool pgut_errstart(int elevel )
{
  _Bool tmp ;

  {
  if (elevel < pgut_abort_level) {
    tmp = log_required(elevel, pgut_log_level);
    if (! tmp) {
      return ((_Bool)0);
    }
  }
  pgut_errinit(elevel);
  return ((_Bool)1);
}
}
void pgut_errfinish(int dummy  , ...)
{
  pgutErrorData *edata___0 ;
  pgutErrorData *tmp ;
  char const   *tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = getErrorData();
  edata___0 = tmp;
  tmp___1 = log_required(edata___0->elevel, pgut_log_level);
  if (tmp___1) {
    if (edata___0->msg.data) {
      tmp___0 = (char const   *)edata___0->msg.data;
    } else {
      tmp___0 = "unknown";
    }
    pgut_error(edata___0->elevel, edata___0->code, tmp___0, (char const   *)edata___0->detail.data);
  }
  if (pgut_abort_level <= edata___0->elevel) {
    if (edata___0->elevel <= 22) {
      in_cleanup = (_Bool)1;
      exit_or_abort(edata___0->code, edata___0->elevel);
    }
  }
  return;
}
}
void pgut_error(int elevel , int code , char const   *msg , char const   *detail )
{
  char const   *tag ;
  char const   *tmp ;

  {
  tmp = format_elevel(elevel);
  tag = tmp;
  if (detail) {
    if (*(detail + 0)) {
      pg_fprintf(stderr, "%s: %s\nDETAIL: %s\n", tag, msg, detail);
    } else {
      pg_fprintf(stderr, "%s: %s\n", tag, msg);
    }
  } else {
    pg_fprintf(stderr, "%s: %s\n", tag, msg);
  }
  fflush(stderr);
  return;
}
}
_Bool log_required(int elevel , int log_min_level )
{


  {
  if (elevel == 15) {
    goto _L;
  } else
  if (elevel == 16) {
    _L: /* CIL Label */
    if (log_min_level == 15) {
      return ((_Bool)1);
    } else
    if (log_min_level <= 20) {
      return ((_Bool)1);
    }
  } else
  if (log_min_level == 15) {
    if (elevel >= 21) {
      return ((_Bool)1);
    }
  } else
  if (elevel >= log_min_level) {
    return ((_Bool)1);
  }
  return ((_Bool)0);
}
}
char const   *format_elevel(int elevel )
{
  int tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;

  {
  switch (elevel) {
  case 14:
  case 13:
  case 12:
  case 11:
  case 10:
  return ("DEBUG");
  case 15:
  return ("LOG");
  case 17:
  return ("INFO");
  case 18:
  return ("NOTICE");
  case 19:
  return ("WARNING");
  case 20:
  case 16:
  return ("ERROR");
  case 21:
  return ("FATAL");
  case 22:
  return ("PANIC");
  default:
  tmp___1 = pgut_errstart(20);
  if (tmp___1) {
    tmp = errmsg("invalid elevel: %d", elevel);
    tmp___0 = errcode(22);
    pgut_errfinish(tmp___0, tmp);
  }
  return ("");
  }
}
}
int parse_elevel(char const   *value )
{
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  _Bool tmp___9 ;

  {
  tmp___6 = pg_strcasecmp(value, "DEBUG");
  if (tmp___6 == 0) {
    return (13);
  } else {
    tmp___5 = pg_strcasecmp(value, "INFO");
    if (tmp___5 == 0) {
      return (17);
    } else {
      tmp___4 = pg_strcasecmp(value, "NOTICE");
      if (tmp___4 == 0) {
        return (18);
      } else {
        tmp___3 = pg_strcasecmp(value, "LOG");
        if (tmp___3 == 0) {
          return (15);
        } else {
          tmp___2 = pg_strcasecmp(value, "WARNING");
          if (tmp___2 == 0) {
            return (19);
          } else {
            tmp___1 = pg_strcasecmp(value, "ERROR");
            if (tmp___1 == 0) {
              return (20);
            } else {
              tmp___0 = pg_strcasecmp(value, "FATAL");
              if (tmp___0 == 0) {
                return (21);
              } else {
                tmp = pg_strcasecmp(value, "PANIC");
                if (tmp == 0) {
                  return (22);
                }
              }
            }
          }
        }
      }
    }
  }
  tmp___9 = pgut_errstart(20);
  if (tmp___9) {
    tmp___7 = errmsg("invalid elevel: %s", value);
    tmp___8 = errcode(22);
    pgut_errfinish(tmp___8, tmp___7);
  }
  return (20);
}
}
int errcode(int sqlerrcode )
{
  pgutErrorData *edata___0 ;
  pgutErrorData *tmp ;

  {
  tmp = getErrorData();
  edata___0 = tmp;
  edata___0->code = sqlerrcode;
  return (0);
}
}
int errcode_errno(void)
{
  pgutErrorData *edata___0 ;
  pgutErrorData *tmp ;

  {
  tmp = getErrorData();
  edata___0 = tmp;
  edata___0->code = edata___0->save_errno;
  return (0);
}
}
int ( /* format attribute */  errmsg)(char const   *fmt  , ...)
{
  pgutErrorData *edata___0 ;
  pgutErrorData *tmp ;
  va_list___0 args ;
  size_t len ;
  _Bool ok ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  tmp = getErrorData();
  edata___0 = tmp;
  while (1) {
    __builtin_va_start(args, fmt);
    ok = pgut_appendStringInfoVA(& edata___0->msg, fmt, args);
    __builtin_va_end(args);
    if (! (! ok)) {
      break;
    }
  }
  len = strlen(fmt);
  if (len > 2UL) {
    tmp___1 = strcmp((fmt + len) - 2, ": ");
    if (tmp___1 == 0) {
      tmp___0 = pg_strerror(edata___0->save_errno);
      appendPQExpBufferStr(& edata___0->msg, (char const   *)tmp___0);
    }
  }
  trimStringBuffer(& edata___0->msg);
  return (0);
}
}
int ( /* format attribute */  errdetail)(char const   *fmt  , ...)
{
  pgutErrorData *edata___0 ;
  pgutErrorData *tmp ;
  va_list___0 args ;
  _Bool ok ;

  {
  tmp = getErrorData();
  edata___0 = tmp;
  while (1) {
    __builtin_va_start(args, fmt);
    ok = pgut_appendStringInfoVA(& edata___0->detail, fmt, args);
    __builtin_va_end(args);
    if (! (! ok)) {
      break;
    }
  }
  trimStringBuffer(& edata___0->detail);
  return (0);
}
}
static void on_before_exec(pgutConn *conn )
{
  PGcancel *old ;

  {
  if (in_cleanup) {
    return;
  }
  old = conn->cancel;
  conn->cancel = (PGcancel *)((void *)0);
  if ((unsigned long )old != (unsigned long )((void *)0)) {
    PQfreeCancel(old);
  }
  conn->cancel = PQgetCancel(conn->conn);
  return;
}
}
static void on_after_exec(pgutConn *conn )
{
  PGcancel *old ;

  {
  if (in_cleanup) {
    return;
  }
  old = conn->cancel;
  conn->cancel = (PGcancel *)((void *)0);
  if ((unsigned long )old != (unsigned long )((void *)0)) {
    PQfreeCancel(old);
  }
  return;
}
}
static void on_interrupt(void)
{
  pgutConn *c ;
  int save_errno ;
  int *tmp ;
  char buf[256] ;
  int tmp___0 ;
  int *tmp___1 ;

  {
  tmp = __errno_location();
  save_errno = *tmp;
  interrupted = (_Bool)1;
  if (in_cleanup) {
    return;
  }
  pthread_mutex_lock(& pgut_conn_mutex);
  c = pgut_connections;
  while (c) {
    if ((unsigned long )c->cancel != (unsigned long )((void *)0)) {
      tmp___0 = PQcancel(c->cancel, buf, (int )sizeof(buf));
      if (tmp___0) {
        elog(19, "Cancel request sent");
      }
    }
    c = c->next;
  }
  pthread_mutex_unlock(& pgut_conn_mutex);
  tmp___1 = __errno_location();
  *tmp___1 = save_errno;
  return;
}
}
static pgut_atexit_item *pgut_atexit_stack  =    (pgut_atexit_item *)((void *)0);
void pgut_atexit_push(void (*callback)(_Bool fatal , void *userdata ) , void *userdata )
{
  pgut_atexit_item *item ;
  void *tmp ;

  {
  tmp = pgut_malloc(sizeof(pgut_atexit_item ));
  item = (pgut_atexit_item *)tmp;
  item->callback = callback;
  item->userdata = userdata;
  item->next = pgut_atexit_stack;
  pgut_atexit_stack = item;
  return;
}
}
void pgut_atexit_pop(void (*callback)(_Bool fatal , void *userdata ) , void *userdata )
{
  pgut_atexit_item *item ;
  pgut_atexit_item **prev ;

  {
  item = pgut_atexit_stack;
  prev = & pgut_atexit_stack;
  while (item) {
    if ((unsigned long )item->callback == (unsigned long )callback) {
      if ((unsigned long )item->userdata == (unsigned long )userdata) {
        *prev = item->next;
        free((void *)item);
        break;
      }
    }
    prev = & item->next;
    item = item->next;
  }
  return;
}
}
static void call_atexit_callbacks(_Bool fatal )
{
  pgut_atexit_item *item ;

  {
  item = pgut_atexit_stack;
  while (item) {
    (*(item->callback))(fatal, item->userdata);
    item = item->next;
  }
  return;
}
}
static void on_cleanup(void)
{


  {
  in_cleanup = (_Bool)1;
  interrupted = (_Bool)0;
  call_atexit_callbacks((_Bool)0);
  pgut_disconnect_all();
  return;
}
}
static void exit_or_abort(int exitcode , int elevel )
{


  {
  if (in_cleanup) {
    if (21 > elevel) {
      call_atexit_callbacks((_Bool)1);
      exit(exitcode);
    } else {
      goto _L;
    }
  } else
  _L: /* CIL Label */
  if (elevel >= 21) {
    if (elevel <= 22) {
      call_atexit_callbacks((_Bool)1);
      abort();
    } else {
      exit(exitcode);
    }
  } else {
    exit(exitcode);
  }
}
}
_Bool ( /* format attribute */  pgut_appendStringInfoVA)(PQExpBuffer str , char const   *fmt ,
                                                         va_list___0 args )
{
  size_t avail ;
  int nprinted ;

  {
  avail = (str->maxlen - str->len) - 1UL;
  nprinted = pg_vsnprintf(str->data + str->len, avail, fmt, args);
  if (nprinted >= 0) {
    if (nprinted < (int )avail - 1) {
      str->len += (size_t )nprinted;
      return ((_Bool)1);
    }
  }
  enlargePQExpBuffer(str, str->maxlen);
  return ((_Bool)0);
}
}
int appendStringInfoFile(PQExpBuffer str , FILE *fp )
{
  int rc ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;

  {
  while (1) {
    if (str->maxlen - str->len < 2UL) {
      tmp___1 = enlargePQExpBuffer(str, (size_t )1024);
      if (tmp___1 == 0) {
        tmp = __errno_location();
        tmp___0 = 12;
        *tmp = tmp___0;
        return (tmp___0);
      }
    }
    tmp___2 = fread((void * __restrict  )(str->data + str->len), (size_t )1, (str->maxlen - str->len) - 1UL,
                    (FILE * __restrict  )fp);
    rc = (int )tmp___2;
    if (rc == 0) {
      break;
    } else
    if (rc > 0) {
      str->len += (size_t )rc;
      *(str->data + str->len) = (char )'\000';
    } else {
      tmp___4 = ferror(fp);
      if (tmp___4) {
        tmp___5 = __errno_location();
        if (*tmp___5 != 4) {
          tmp___3 = __errno_location();
          return (*tmp___3);
        }
      }
    }
  }
  return (0);
}
}
int appendStringInfoFd(PQExpBuffer str , int fd )
{
  int rc ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
  while (1) {
    if (str->maxlen - str->len < 2UL) {
      tmp___1 = enlargePQExpBuffer(str, (size_t )1024);
      if (tmp___1 == 0) {
        tmp = __errno_location();
        tmp___0 = 12;
        *tmp = tmp___0;
        return (tmp___0);
      }
    }
    tmp___2 = read(fd, (void *)(str->data + str->len), (str->maxlen - str->len) - 1UL);
    rc = (int )tmp___2;
    if (rc == 0) {
      break;
    } else
    if (rc > 0) {
      str->len += (size_t )rc;
      *(str->data + str->len) = (char )'\000';
    } else {
      tmp___4 = __errno_location();
      if (*tmp___4 != 4) {
        tmp___3 = __errno_location();
        return (*tmp___3);
      }
    }
  }
  return (0);
}
}
void *pgut_malloc(size_t size )
{
  char *ret ;
  int tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  void *tmp___2 ;

  {
  tmp___2 = malloc(size);
  ret = (char *)tmp___2;
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    tmp___1 = pgut_errstart(21);
    if (tmp___1) {
      tmp = errmsg("could not allocate memory (%lu bytes): ", size);
      tmp___0 = errcode_errno();
      pgut_errfinish(tmp___0, tmp);
    }
  }
  return ((void *)ret);
}
}
void *pgut_realloc(void *p , size_t size )
{
  char *ret ;
  int tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  void *tmp___2 ;

  {
  tmp___2 = realloc(p, size);
  ret = (char *)tmp___2;
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    tmp___1 = pgut_errstart(21);
    if (tmp___1) {
      tmp = errmsg("could not re-allocate memory (%lu bytes): ", size);
      tmp___0 = errcode_errno();
      pgut_errfinish(tmp___0, tmp);
    }
  }
  return ((void *)ret);
}
}
char *pgut_strdup(char const   *str )
{
  char *ret ;
  int tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;

  {
  if ((unsigned long )str == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  ret = strdup(str);
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    tmp___1 = pgut_errstart(21);
    if (tmp___1) {
      tmp = errmsg("could not duplicate string \"%s\": ", str);
      tmp___0 = errcode_errno();
      pgut_errfinish(tmp___0, tmp);
    }
  }
  return (ret);
}
}
char *strdup_with_len(char const   *str , size_t len )
{
  char *r ;
  void *tmp ;

  {
  if ((unsigned long )str == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  tmp = pgut_malloc(len + 1UL);
  r = (char *)tmp;
  memcpy((void * __restrict  )r, (void const   * __restrict  )str, len);
  *(r + len) = (char )'\000';
  return (r);
}
}
char *strdup_trim(char const   *str )
{
  size_t len ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;

  {
  if ((unsigned long )str == (unsigned long )((void *)0)) {
    return ((char *)((void *)0));
  }
  while (1) {
    tmp = __ctype_b_loc();
    if (! ((int const   )*(*tmp + (int )((unsigned char )*(str + 0))) & 8192)) {
      break;
    }
    str ++;
  }
  len = strlen(str);
  while (1) {
    if (len > 0UL) {
      tmp___0 = __ctype_b_loc();
      if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*(str + (len - 1UL)))) & 8192)) {
        break;
      }
    } else {
      break;
    }
    len --;
  }
  tmp___1 = strdup_with_len(str, len);
  return (tmp___1);
}
}
FILE *pgut_fopen(char const   *path , char const   *omode )
{
  FILE *fp ;
  _Bool missing_ok ;
  char mode[16] ;
  char dir[1024] ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;

  {
  missing_ok = (_Bool)0;
  strlcpy(mode, omode, sizeof(mode) / sizeof(mode[0]));
  if ((int )mode[0] == 82) {
    mode[0] = (char )'r';
    missing_ok = (_Bool)1;
  }
  retry:
  fp = fopen((char const   * __restrict  )path, (char const   * __restrict  )(mode));
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    tmp = __errno_location();
    if (*tmp == 2) {
      if (missing_ok) {
        return ((FILE *)((void *)0));
      }
      if ((int )mode[0] == 119) {
        strlcpy(dir, path, (size_t )1024);
        get_parent_directory(dir);
        pgut_mkdir((char const   *)(dir));
        goto retry;
      } else
      if ((int )mode[0] == 97) {
        strlcpy(dir, path, (size_t )1024);
        get_parent_directory(dir);
        pgut_mkdir((char const   *)(dir));
        goto retry;
      }
    }
    tmp___2 = pgut_errstart(20);
    if (tmp___2) {
      tmp___0 = errmsg("could not open file \"%s\": ", path);
      tmp___1 = errcode_errno();
      pgut_errfinish(tmp___1, tmp___0);
    }
  }
  return (fp);
}
}
_Bool pgut_mkdir(char const   *dirpath )
{
  struct stat sb ;
  int first ;
  int last ;
  int retval ;
  char *path ;
  char *p ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  _Bool tmp___6 ;

  {
  path = pgut_strdup(dirpath);
  p = path;
  retval = 0;
  if ((int )*(p + 0) == 47) {
    p ++;
  }
  first = 1;
  last = 0;
  while (! last) {
    if ((int )*(p + 0) == 0) {
      last = 1;
    } else
    if ((int )*(p + 0) != 47) {
      goto __Cont;
    }
    *p = (char )'\000';
    if (! last) {
      if ((int )*(p + 1) == 0) {
        last = 1;
      }
    }
    if (first) {
      first = 0;
    }
    retry:
    tmp___3 = stat((char const   * __restrict  )path, (struct stat * __restrict  )(& sb));
    if (tmp___3 == 0) {
      if (! ((sb.st_mode & 61440U) == 16384U)) {
        if (last) {
          tmp = __errno_location();
          *tmp = 17;
        } else {
          tmp___0 = __errno_location();
          *tmp___0 = 20;
        }
        retval = 1;
        break;
      }
    } else {
      tmp___2 = mkdir((char const   *)path, (__mode_t )448);
      if (tmp___2 < 0) {
        tmp___1 = __errno_location();
        if (*tmp___1 == 17) {
          goto retry;
        }
        retval = 1;
        break;
      }
    }
    if (! last) {
      *p = (char )'/';
    }
    __Cont: /* CIL Label */
    p ++;
  }
  free((void *)path);
  if (retval == 0) {
    tmp___6 = pgut_errstart(20);
    if (tmp___6) {
      tmp___4 = errmsg("could not create directory \"%s\": ", dirpath);
      tmp___5 = errcode_errno();
      pgut_errfinish(tmp___5, tmp___4);
    }
    return ((_Bool)0);
  }
  return ((_Bool)1);
}
}
int wait_for_socket(int sock , struct timeval *timeout )
{
  fd_set fds ;
  int __d0 ;
  int __d1 ;
  long __d ;
  long tmp___1 ;
  int tmp___2 ;

  {
  while (1) {
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fds.fds_bits[0]): "memory");
    break;
  }
  __d = (long )sock;
  tmp___1 = __fdelt_chk(__d);
  fds.fds_bits[tmp___1] |= (__fd_mask )(1UL << sock % (8 * (int )sizeof(__fd_mask )));
  tmp___2 = wait_for_sockets(sock + 1, & fds, timeout);
  return (tmp___2);
}
}
int wait_for_sockets(int nfds , fd_set *fds , struct timeval *timeout )
{
  int i ;
  int tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  int *tmp___2 ;

  {
  while (1) {
    i = select(nfds, (fd_set * __restrict  )fds, (fd_set * __restrict  )((void *)0),
               (fd_set * __restrict  )((void *)0), (struct timeval * __restrict  )timeout);
    if (i < 0) {
      CHECK_FOR_INTERRUPTS();
      tmp___2 = __errno_location();
      if (*tmp___2 != 4) {
        tmp___1 = pgut_errstart(20);
        if (tmp___1) {
          tmp = errmsg("select failed: ");
          tmp___0 = errcode_errno();
          pgut_errfinish(tmp___0, tmp);
        }
        return (-1);
      }
    } else {
      return (i);
    }
  }
}
}
static void handle_sigint(int postgres_signal_arg )
{


  {
  on_interrupt();
  return;
}
}
static void init_cancel_handler(void)
{


  {
  pqsignal(2, & handle_sigint);
  return;
}
}
#pragma merger("0","/tmp/cil-IATQKE0h.i","-Wall,-Wmissing-prototypes,-Wpointer-arith,-Wdeclaration-after-statement,-Werror=vla,-Wendif-labels,-Wmissing-format-attribute,-Wimplicit-fallthrough=3,-Wformat-security,-fno-strict-aliasing,-fwrapv,-fexcess-precision=standard,-Wno-format-truncation,-Wno-stringop-truncation,-g,-g,-O2,-fstack-protector-strong,-Wformat,-Werror=format-security,-fno-omit-frame-pointer,-Wdate-time")
extern int fclose(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2))) strcspn)(char const   *__s ,
                                                                                         char const   *__reject )  __attribute__((__pure__)) ;
extern struct passwd *getpwuid(__uid_t __uid ) ;
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
extern char *optarg ;
extern int optind ;
extern char *PQpass(PGconn const   *conn ) ;
char *host ;
char *port ;
char *username ;
char *password ;
YesNo prompt_password ;
void help(_Bool details ) ;
void disconnect_workers(void) ;
void pgut_readopt(char const   *path , pgut_option *options___0 , int elevel ) ;
void pgut_setopt(pgut_option *opt , char const   *optarg___0 , pgut_optsrc src ) ;
_Bool pgut_keyeq(char const   *lhs , char const   *rhs ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) getopt_long)(int ___argc ,
                                                                                          char * const  *___argv ,
                                                                                          char const   *__shortopts ,
                                                                                          struct option  const  *__longopts ,
                                                                                          int *__longind ) ;
char *dbname  =    (char *)((void *)0);
char *host  =    (char *)((void *)0);
char *port  =    (char *)((void *)0);
char *username  =    (char *)((void *)0);
char *password  =    (char *)((void *)0);
YesNo prompt_password  =    (YesNo )0;
PGconn *connection  =    (PGconn *)((void *)0);
PGconn *conn2  =    (PGconn *)((void *)0);
worker_conns workers  =    {0, 0, (PGconn **)((void *)0)};
static _Bool parse_pair(char const   *buffer , char *key , char *value ) ;
static char *get_username(void) ;
void setup_workers(int num_workers )
{
  PQExpBufferData buf ;
  int i ;
  PGconn *conn ;
  void *tmp ;
  char *tmp___0 ;
  ConnStatusType tmp___1 ;
  int tmp___2 ;

  {
  elog(13, "In setup_workers(), target num_workers = %d", num_workers);
  if (num_workers > 1) {
    if (num_workers > workers.num_workers) {
      initPQExpBuffer(& buf);
      if (dbname) {
        if (*(dbname + 0)) {
          appendPQExpBuffer(& buf, "dbname=%s ", dbname);
        }
      }
      if (host) {
        if (*(host + 0)) {
          appendPQExpBuffer(& buf, "host=%s ", host);
        }
      }
      if (port) {
        if (*(port + 0)) {
          appendPQExpBuffer(& buf, "port=%s ", port);
        }
      }
      if (username) {
        if (*(username + 0)) {
          appendPQExpBuffer(& buf, "user=%s ", username);
        }
      }
      if (password) {
        if (*(password + 0)) {
          appendPQExpBuffer(& buf, "password=%s ", password);
        }
      }
      if ((unsigned long )workers.conns == (unsigned long )((void *)0)) {
        elog(18, "Setting up workers.conns");
        tmp = pgut_malloc(sizeof(PGconn *) * (unsigned long )num_workers);
        workers.conns = (PGconn **)tmp;
      } else {
        elog(20, "TODO: Implement pool resizing.");
      }
      i = 0;
      while (i < num_workers) {
        elog(13, "Setting up worker conn %d", i);
        conn = PQconnectdb((char const   *)buf.data);
        tmp___1 = PQstatus((PGconn const   *)conn);
        if ((unsigned int )tmp___1 == 0U) {
          *(workers.conns + i) = conn;
        } else {
          tmp___0 = PQerrorMessage((PGconn const   *)conn);
          elog(19, "Unable to set up worker conn #%d: %s", i, tmp___0);
          break;
        }
        pgut_command(conn, "SET search_path TO pg_catalog, pg_temp, public", 0, (char const   **)((void *)0));
        tmp___2 = PQsetnonblocking(*(workers.conns + i), 1);
        if (tmp___2) {
          elog(20, "Unable to set worker connection %d non-blocking.", i);
        }
        i ++;
      }
      workers.num_workers = i;
      termPQExpBuffer(& buf);
    }
  }
  return;
}
}
void disconnect_workers(void)
{
  int i ;

  {
  if (! workers.num_workers) {
    elog(13, "No workers to disconnect.");
  } else {
    i = 0;
    while (i < workers.num_workers) {
      if (*(workers.conns + i)) {
        elog(13, "Disconnecting worker %d.", i);
        PQfinish(*(workers.conns + i));
        *(workers.conns + i) = (PGconn *)((void *)0);
      } else {
        elog(18, "Worker %d already disconnected?", i);
      }
      i ++;
    }
    workers.num_workers = 0;
    free((void *)workers.conns);
    workers.conns = (PGconn **)((void *)0);
  }
  return;
}
}
void reconnect(int elevel )
{
  PQExpBufferData buf ;
  char *new_password ;
  int tmp ;

  {
  disconnect();
  initPQExpBuffer(& buf);
  if (dbname) {
    if (*(dbname + 0)) {
      appendPQExpBuffer(& buf, "dbname=%s ", dbname);
    }
  }
  if (host) {
    if (*(host + 0)) {
      appendPQExpBuffer(& buf, "host=%s ", host);
    }
  }
  if (port) {
    if (*(port + 0)) {
      appendPQExpBuffer(& buf, "port=%s ", port);
    }
  }
  if (username) {
    if (*(username + 0)) {
      appendPQExpBuffer(& buf, "user=%s ", username);
    }
  }
  if (password) {
    if (*(password + 0)) {
      appendPQExpBuffer(& buf, "password=%s ", password);
    }
  }
  connection = pgut_connect((char const   *)buf.data, prompt_password, elevel);
  conn2 = pgut_connect((char const   *)buf.data, prompt_password, elevel);
  if (connection) {
    new_password = PQpass((PGconn const   *)connection);
    if (new_password) {
      if (*(new_password + 0)) {
        if ((unsigned long )password == (unsigned long )((void *)0)) {
          free((void *)password);
          password = pgut_strdup((char const   *)new_password);
        } else {
          tmp = strcmp((char const   *)new_password, (char const   *)password);
          if (tmp != 0) {
            free((void *)password);
            password = pgut_strdup((char const   *)new_password);
          }
        }
      }
    }
  }
  termPQExpBuffer(& buf);
  return;
}
}
void disconnect(void)
{


  {
  if (connection) {
    pgut_disconnect(connection);
    connection = (PGconn *)((void *)0);
  }
  if (conn2) {
    pgut_disconnect(conn2);
    conn2 = (PGconn *)((void *)0);
  }
  disconnect_workers();
  return;
}
}
static void option_from_env(pgut_option *options___0 )
{
  size_t i ;
  pgut_option *opt ;
  char name[256] ;
  size_t j ;
  char const   *s ;
  char const   *value ;
  int __res ;
  __int32_t const   **tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  i = (size_t )0;
  while (1) {
    if (options___0) {
      if (! (options___0 + i)->type) {
        break;
      }
    } else {
      break;
    }
    opt = options___0 + i;
    if ((unsigned int )opt->source > 1U) {
      goto __Cont;
    } else
    if ((unsigned int )opt->allowed == 0U) {
      goto __Cont;
    } else
    if ((unsigned int )opt->allowed > 1U) {
      goto __Cont;
    }
    s = opt->lname;
    j = (size_t )0;
    while (1) {
      if (*s) {
        if (! (j < sizeof(name) / sizeof(name[0]) - 1UL)) {
          break;
        }
      } else {
        break;
      }
      tmp___1 = strchr("-_ ", (int )*s);
      if (tmp___1) {
        name[j] = (char )'_';
      } else {
        if (sizeof(*s) > 1UL) {
          __res = toupper((int )*s);
        } else {
          tmp___0 = __ctype_toupper_loc();
          __res = (int )*(*tmp___0 + (int )*s);
        }
        name[j] = (char )__res;
      }
      s ++;
      j ++;
    }
    name[j] = (char )'\000';
    tmp___2 = getenv((char const   *)(name));
    value = (char const   *)tmp___2;
    if ((unsigned long )value != (unsigned long )((void *)0)) {
      pgut_setopt(opt, value, (pgut_optsrc )1);
    }
    __Cont: /* CIL Label */
    i ++;
  }
  return;
}
}
_Bool pgut_keyeq(char const   *lhs , char const   *rhs )
{
  char *tmp ;
  int __res ;
  __int32_t const   **tmp___1 ;
  int __res___0 ;
  __int32_t const   **tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  while (1) {
    if (*lhs) {
      if (! *rhs) {
        break;
      }
    } else {
      break;
    }
    tmp___4 = strchr("-_ ", (int )*lhs);
    if (tmp___4) {
      tmp = strchr("-_ ", (int )*rhs);
      if (! tmp) {
        return ((_Bool)0);
      }
    } else {
      if (sizeof((unsigned char )*lhs) > 1UL) {
        __res = tolower((int )((unsigned char )*lhs));
      } else {
        tmp___1 = __ctype_tolower_loc();
        __res = (int )*(*tmp___1 + (int )((unsigned char )*lhs));
      }
      if (sizeof((unsigned char )*rhs) > 1UL) {
        __res___0 = tolower((int )((unsigned char )*rhs));
      } else {
        tmp___3 = __ctype_tolower_loc();
        __res___0 = (int )*(*tmp___3 + (int )((unsigned char )*rhs));
      }
      if (__res != __res___0) {
        return ((_Bool)0);
      }
    }
    lhs ++;
    rhs ++;
  }
  if ((int const   )*lhs == 0) {
    if ((int const   )*rhs == 0) {
      tmp___5 = 1;
    } else {
      tmp___5 = 0;
    }
  } else {
    tmp___5 = 0;
  }
  return ((_Bool )tmp___5);
}
}
void pgut_setopt(pgut_option *opt , char const   *optarg___0 , pgut_optsrc src )
{
  char const   *message ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool value ;
  _Bool tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  _Bool tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  _Bool tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  _Bool tmp___14 ;
  unsigned short const   **tmp___15 ;

  {
  if ((unsigned long )opt == (unsigned long )((void *)0)) {
    pg_fprintf(stderr, "Try \"%s --help\" for more information.\n", PROGRAM_NAME);
    exit(22);
  }
  if ((unsigned int )opt->source > (unsigned int )src) {
    return;
  } else
  if ((unsigned int )src >= 3U) {
    if ((unsigned int )opt->source >= (unsigned int )src) {
      if ((int )opt->type != 108) {
        message = "specified only once";
      } else {
        goto _L___0;
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */
    opt->source = src;
    switch ((int )opt->type) {
    case 66:
    case 98:
    if ((unsigned long )optarg___0 == (unsigned long )((void *)0)) {
      *((_Bool *)opt->var) = (_Bool )((int )opt->type == 98);
      return;
    } else {
      tmp = parse_bool(optarg___0, (_Bool *)opt->var);
      if (tmp) {
        return;
      }
    }
    message = "a boolean";
    break;
    case 102:
    (*((void (*)(pgut_option *opt , char const   *arg ))opt->var))(opt, optarg___0);
    return;
    case 105:
    tmp___0 = parse_int32(optarg___0, (int32 *)opt->var);
    if (tmp___0) {
      return;
    }
    message = "a 32bit signed integer";
    break;
    case 108:
    message = "a List";
    simple_string_list_append((SimpleStringList *)opt->var, optarg___0);
    return;
    case 117:
    tmp___1 = parse_uint32(optarg___0, (uint32 *)opt->var);
    if (tmp___1) {
      return;
    }
    message = "a 32bit unsigned integer";
    break;
    case 73:
    tmp___2 = parse_int64(optarg___0, (int64 *)opt->var);
    if (tmp___2) {
      return;
    }
    message = "a 64bit signed integer";
    break;
    case 85:
    tmp___3 = parse_uint64(optarg___0, (uint64 *)opt->var);
    if (tmp___3) {
      return;
    }
    message = "a 64bit unsigned integer";
    break;
    case 115:
    if ((unsigned int )opt->source != 0U) {
      free((void *)*((char **)opt->var));
    }
    *((char **)opt->var) = pgut_strdup(optarg___0);
    return;
    case 116:
    tmp___4 = parse_time(optarg___0, (time_t *)opt->var);
    if (tmp___4) {
      return;
    }
    message = "a time";
    break;
    case 89:
    case 121:
    if ((unsigned long )optarg___0 == (unsigned long )((void *)0)) {
      if ((int )opt->type == 121) {
        *((YesNo *)opt->var) = (YesNo )2;
      } else {
        *((YesNo *)opt->var) = (YesNo )1;
      }
      return;
    } else {
      tmp___5 = parse_bool(optarg___0, & value);
      if (tmp___5) {
        if (value) {
          *((YesNo *)opt->var) = (YesNo )2;
        } else {
          *((YesNo *)opt->var) = (YesNo )1;
        }
        return;
      }
    }
    message = "a boolean";
    break;
    default:
    tmp___8 = pgut_errstart(20);
    if (tmp___8) {
      tmp___6 = errmsg("invalid option type: %c", (int )opt->type);
      tmp___7 = errcode(22);
      pgut_errfinish(tmp___7, tmp___6);
    }
    return;
    }
  }
  tmp___15 = __ctype_b_loc();
  if ((int const   )*(*tmp___15 + (int )opt->sname) & 16384) {
    tmp___11 = pgut_errstart(20);
    if (tmp___11) {
      tmp___9 = errmsg("option -%c, --%s should be %s: \'%s\'", (int )opt->sname,
                       opt->lname, message, optarg___0);
      tmp___10 = errcode(22);
      pgut_errfinish(tmp___10, tmp___9);
    }
  } else {
    tmp___14 = pgut_errstart(20);
    if (tmp___14) {
      tmp___12 = errmsg("option --%s should be %s: \'%s\'", opt->lname, message, optarg___0);
      tmp___13 = errcode(22);
      pgut_errfinish(tmp___13, tmp___12);
    }
  }
  return;
}
}
void pgut_readopt(char const   *path , pgut_option *options___0 , int elevel )
{
  FILE *fp ;
  char buf[1024] ;
  char key[1024] ;
  char value[1024] ;
  size_t i ;
  unsigned short const   **tmp ;
  pgut_option *opt ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  char *tmp___2 ;

  {
  if (! options___0) {
    return;
  }
  fp = pgut_fopen(path, "Rt");
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    return;
  }
  while (1) {
    tmp___2 = fgets((char * __restrict  )(buf), (int )(sizeof(buf) / sizeof(buf[0])),
                    (FILE * __restrict  )fp);
    if (! tmp___2) {
      break;
    }
    i = strlen((char const   *)(buf));
    while (1) {
      if (i > 0UL) {
        tmp = __ctype_b_loc();
        if (! ((int const   )*(*tmp + (int )((unsigned char )buf[i - 1UL])) & 8192)) {
          break;
        }
      } else {
        break;
      }
      buf[i - 1UL] = (char )'\000';
      i --;
    }
    tmp___1 = parse_pair((char const   *)(buf), key, value);
    if (tmp___1) {
      i = (size_t )0;
      while ((options___0 + i)->type) {
        opt = options___0 + i;
        tmp___0 = pgut_keyeq((char const   *)(key), opt->lname);
        if (tmp___0) {
          if ((unsigned int )opt->allowed == 0U) {
            elog(elevel, "option %s cannot specified in file", opt->lname);
          } else
          if ((unsigned int )opt->allowed > 2U) {
            elog(elevel, "option %s cannot specified in file", opt->lname);
          } else
          if ((unsigned int )opt->source <= 2U) {
            pgut_setopt(opt, (char const   *)(value), (pgut_optsrc )2);
          }
          break;
        }
        i ++;
      }
      if (! (options___0 + i)->type) {
        elog(elevel, "invalid option \"%s\"", key);
      }
    }
  }
  fclose(fp);
  return;
}
}
static char const   *skip_space(char const   *str , char const   *line )
{
  unsigned short const   **tmp ;

  {
  while (1) {
    tmp = __ctype_b_loc();
    if (! ((int const   )*(*tmp + (int )((unsigned char )*str)) & 8192)) {
      break;
    }
    str ++;
  }
  return (str);
}
}
static char const   *get_next_token(char const   *src , char *dst , char const   *line )
{
  char const   *s ;
  size_t i ;
  size_t j ;
  int k ;
  long octVal ;

  {
  s = skip_space(src, line);
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    return ((char const   *)((void *)0));
  }
  if ((int const   )*s == 39) {
    s ++;
    i = (size_t )0;
    j = (size_t )0;
    while ((int const   )*(s + i) != 0) {
      if ((int const   )*(s + i) == 92) {
        i ++;
        switch ((int const   )*(s + i)) {
        case 98:
        *(dst + j) = (char )'\b';
        break;
        case 102:
        *(dst + j) = (char )'\f';
        break;
        case 110:
        *(dst + j) = (char )'\n';
        break;
        case 114:
        *(dst + j) = (char )'\r';
        break;
        case 116:
        *(dst + j) = (char )'\t';
        break;
        case 55:
        case 54:
        case 53:
        case 52:
        case 51:
        case 50:
        case 49:
        case 48:
        octVal = 0L;
        k = 0;
        while (1) {
          if ((int const   )*(s + (i + (size_t )k)) >= 48) {
            if ((int const   )*(s + (i + (size_t )k)) <= 55) {
              if (! (k < 3)) {
                break;
              }
            } else {
              break;
            }
          } else {
            break;
          }
          octVal = (octVal << 3) + (long )((int const   )*(s + (i + (size_t )k)) - 48);
          k ++;
        }
        i += (size_t )(k - 1);
        *(dst + j) = (char )octVal;
        break;
        default:
        *(dst + j) = (char )*(s + i);
        break;
        }
      } else
      if ((int const   )*(s + i) == 39) {
        i ++;
        if ((int const   )*(s + i) == 39) {
          *(dst + j) = (char )*(s + i);
        } else {
          break;
        }
      } else {
        *(dst + j) = (char )*(s + i);
      }
      j ++;
      i ++;
    }
  } else {
    j = strcspn(s, "# \n\r\t\v");
    i = j;
    memcpy((void * __restrict  )dst, (void const   * __restrict  )s, j);
  }
  *(dst + j) = (char )'\000';
  return (s + i);
}
}
static _Bool parse_pair(char const   *buffer , char *key , char *value )
{
  char const   *start ;
  char const   *end ;
  char tmp ;
  size_t tmp___0 ;

  {
  tmp = (char )'\000';
  *(value + 0) = tmp;
  *(key + 0) = tmp;
  start = buffer;
  start = skip_space(start, buffer);
  if ((unsigned long )start == (unsigned long )((void *)0)) {
    return ((_Bool)0);
  }
  tmp___0 = strcspn(start, "=# \n\r\t\v");
  end = start + tmp___0;
  if (end - start <= 0L) {
    if ((int const   )*start == 61) {
      elog(19, "syntax error in \"%s\"", buffer);
    }
    return ((_Bool)0);
  }
  strncpy((char * __restrict  )key, (char const   * __restrict  )start, (size_t )(end - start));
  *(key + (end - start)) = (char )'\000';
  start = skip_space(end, buffer);
  if ((unsigned long )start == (unsigned long )((void *)0)) {
    return ((_Bool)0);
  }
  if ((int const   )*start != 61) {
    elog(19, "syntax error in \"%s\"", buffer);
    return ((_Bool)0);
  }
  start ++;
  end = get_next_token(start, value, buffer);
  if ((unsigned long )end == (unsigned long )((void *)0)) {
    return ((_Bool)0);
  }
  start = skip_space(end, buffer);
  if ((unsigned long )start == (unsigned long )((void *)0)) {
    return ((_Bool)0);
  }
  if ((int const   )*start != 0) {
    if ((int const   )*start != 35) {
      elog(19, "syntax error in \"%s\"", buffer);
      return ((_Bool)0);
    }
  }
  return ((_Bool)1);
}
}
PGresult *execute(char const   *query , int nParams , char const   **params )
{
  PGresult *tmp ;

  {
  tmp = pgut_execute(connection, query, nParams, params);
  return (tmp);
}
}
PGresult *execute_elevel(char const   *query , int nParams , char const   **params ,
                         int elevel )
{
  PGresult *tmp ;

  {
  tmp = pgut_execute_elevel(connection, query, nParams, params, elevel);
  return (tmp);
}
}
ExecStatusType command(char const   *query , int nParams , char const   **params )
{
  ExecStatusType tmp ;

  {
  tmp = pgut_command(connection, query, nParams, params);
  return (tmp);
}
}
static void set_elevel(pgut_option *opt , char const   *arg )
{


  {
  pgut_log_level = parse_elevel(arg);
  return;
}
}
static pgut_option default_options[9]  =
  {      {(char )'b', (char )'e', "echo", (void *)(& pgut_echo), 0U, 0U},
        {(char )'f', (char )'E', "elevel", (void *)(& set_elevel), 0U, 0U},
        {(char )'s', (char )'d', "dbname", (void *)(& dbname), 0U, 0U},
        {(char )'s', (char )'h', "host", (void *)(& host), 0U, 0U},
        {(char )'s', (char )'p', "port", (void *)(& port), 0U, 0U},
        {(char )'s', (char )'U', "username", (void *)(& username), 0U, 0U},
        {(char )'Y', (char )'w', "no-password", (void *)(& prompt_password), 0U, 0U},
        {(char )'y',
      (char )'W', "password", (void *)(& prompt_password), 0U, 0U},
        {(char)0, (char)0, (char const   *)0, (void *)0, 0U, 0U}};
static size_t option_length(pgut_option const   *opts )
{
  size_t len ;

  {
  len = (size_t )0;
  while (1) {
    if (opts) {
      if (! (opts + len)->type) {
        break;
      }
    } else {
      break;
    }
    len ++;
  }
  return (len);
}
}
static pgut_option *option_find(int c , pgut_option *opts1 , pgut_option *opts2 )
{
  size_t i ;

  {
  i = (size_t )0;
  while (1) {
    if (opts1) {
      if (! (opts1 + i)->type) {
        break;
      }
    } else {
      break;
    }
    if ((int )(opts1 + i)->sname == c) {
      return (opts1 + i);
    }
    i ++;
  }
  i = (size_t )0;
  while (1) {
    if (opts2) {
      if (! (opts2 + i)->type) {
        break;
      }
    } else {
      break;
    }
    if ((int )(opts2 + i)->sname == c) {
      return (opts2 + i);
    }
    i ++;
  }
  return ((pgut_option *)((void *)0));
}
}
static char *get_username(void)
{
  char *ret ;
  struct passwd *pw ;
  __uid_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;

  {
  tmp = geteuid();
  pw = getpwuid(tmp);
  if (pw) {
    ret = pw->pw_name;
  } else {
    ret = (char *)((void *)0);
  }
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
    tmp___2 = pgut_errstart(20);
    if (tmp___2) {
      tmp___0 = errmsg("could not get current user name: ");
      tmp___1 = errcode_errno();
      pgut_errfinish(tmp___1, tmp___0);
    }
  }
  return (ret);
}
}
static int option_has_arg(char type )
{


  {
  switch ((int )type) {
  case 89:
  case 121:
  case 66:
  case 98:
  return (0);
  default:
  return (1);
  }
}
}
static void option_copy(struct option *dst , pgut_option const   *opts , size_t len )
{
  size_t i ;

  {
  i = (size_t )0;
  while (i < len) {
    (dst + i)->name = (char const   *)(opts + i)->lname;
    (dst + i)->has_arg = option_has_arg((char )(opts + i)->type);
    (dst + i)->flag = (int *)((void *)0);
    (dst + i)->val = (int )(opts + i)->sname;
    i ++;
  }
  return;
}
}
static struct option *option_merge(pgut_option const   *opts1 , pgut_option const   *opts2 )
{
  struct option *result ;
  size_t len1 ;
  size_t tmp ;
  size_t len2 ;
  size_t tmp___0 ;
  size_t n ;
  void *tmp___1 ;

  {
  tmp = option_length(opts1);
  len1 = tmp;
  tmp___0 = option_length(opts2);
  len2 = tmp___0;
  n = len1 + len2;
  tmp___1 = pgut_malloc(sizeof(struct option ) * (n + 1UL));
  result = (struct option *)tmp___1;
  option_copy(result, opts1, len1);
  option_copy(result + len1, opts2, len2);
  memset((void *)(result + n), 0, sizeof(pgut_option ));
  return (result);
}
}
static char *longopts_to_optstring(struct option  const  *opts )
{
  size_t len ;
  char *result ;
  char *s ;
  void *tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  len = (size_t )0;
  while ((opts + len)->name) {
    len ++;
  }
  tmp = pgut_malloc(len * 2UL + 1UL);
  result = (char *)tmp;
  s = result;
  len = (size_t )0;
  while ((opts + len)->name) {
    tmp___0 = __ctype_b_loc();
    if (! ((int const   )*(*tmp___0 + (int )(opts + len)->val) & 16384)) {
      goto __Cont;
    }
    tmp___1 = s;
    s ++;
    *tmp___1 = (char )(opts + len)->val;
    if ((opts + len)->has_arg != 0) {
      tmp___2 = s;
      s ++;
      *tmp___2 = (char )':';
    }
    __Cont: /* CIL Label */
    len ++;
  }
  *s = (char )'\000';
  return (result);
}
}
int pgut_getopt(int argc , char **argv , pgut_option *options___0 )
{
  int c ;
  int optindex ;
  char *optstring ;
  struct option *longopts ;
  pgut_option *opt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  optindex = 0;
  pgut_init(argc, argv);
  if (argc > 1) {
    tmp = strcmp((char const   *)*(argv + 1), "--help");
    if (tmp == 0) {
      help((_Bool)1);
      exit(0);
    } else {
      tmp___0 = strcmp((char const   *)*(argv + 1), "-?");
      if (tmp___0 == 0) {
        help((_Bool)1);
        exit(0);
      }
    }
    tmp___1 = strcmp((char const   *)*(argv + 1), "--version");
    if (tmp___1 == 0) {
      pg_printf("%s %s\n", PROGRAM_NAME, PROGRAM_VERSION);
      exit(0);
    } else {
      tmp___2 = strcmp((char const   *)*(argv + 1), "-V");
      if (tmp___2 == 0) {
        pg_printf("%s %s\n", PROGRAM_NAME, PROGRAM_VERSION);
        exit(0);
      }
    }
    tmp___3 = strcmp((char const   *)*(argv + 1), "--configuration");
    if (tmp___3 == 0) {
      pg_printf("%s\n", "PostgreSQL 13.7 (Ubuntu 13.7-1.pgdg20.04+1) on x86_64-pc-linux-gnu, compiled by gcc (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0, 64-bit");
      exit(0);
    }
  }
  longopts = option_merge((pgut_option const   *)(default_options), (pgut_option const   *)options___0);
  optstring = longopts_to_optstring((struct option  const  *)longopts);
  while (1) {
    c = getopt_long(argc, (char * const  *)argv, (char const   *)optstring, (struct option  const  *)longopts,
                    & optindex);
    if (! (c != -1)) {
      break;
    }
    opt = option_find(c, default_options, options___0);
    pgut_setopt(opt, (char const   *)optarg, (pgut_optsrc )3);
  }
  option_from_env(options___0);
  if (dbname) {
    tmp___4 = 1;
  } else {
    dbname = getenv("PGDATABASE");
    if (dbname) {
      tmp___4 = 1;
    } else {
      dbname = getenv("PGUSER");
      if (dbname) {
        tmp___4 = 1;
      } else {
        dbname = get_username();
        if (dbname) {
          tmp___4 = 1;
        } else {
          tmp___4 = 0;
        }
      }
    }
  }
  return (optind);
}
}
void help(_Bool details )
{


  {
  pgut_help(details);
  if (details) {
    pg_printf("\nConnection options:\n");
    pg_printf("  -d, --dbname=DBNAME       database to connect\n");
    pg_printf("  -h, --host=HOSTNAME       database server host or socket directory\n");
    pg_printf("  -p, --port=PORT           database server port\n");
    pg_printf("  -U, --username=USERNAME   user name to connect as\n");
    pg_printf("  -w, --no-password         never prompt for password\n");
    pg_printf("  -W, --password            force password prompt\n");
  }
  pg_printf("\nGeneric options:\n");
  if (details) {
    pg_printf("  -e, --echo                echo queries\n");
    pg_printf("  -E, --elevel=LEVEL        set output message level\n");
  }
  pg_printf("  --help                    show this help, then exit\n");
  pg_printf("  --version                 output version information, then exit\n");
  if (details) {
    if (PROGRAM_URL) {
      goto _L;
    } else
    if (PROGRAM_ISSUES) {
      _L: /* CIL Label */
      pg_printf("\n");
      if (PROGRAM_URL) {
        pg_printf("Read the website for details: <%s>.\n", PROGRAM_URL);
      }
      if (PROGRAM_ISSUES) {
        pg_printf("Report bugs to <%s>.\n", PROGRAM_ISSUES);
      }
    }
  }
  return;
}
}
