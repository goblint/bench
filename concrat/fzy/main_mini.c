/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/select.h>
#include <termios.h>
#include <sys/ioctl.h>
#include <signal.h>
#include <pthread.h>
#include <stdint.h>
#include <time.h>

typedef double score_t;
typedef unsigned char cc_t;
typedef unsigned int speed_t;
typedef unsigned int tcflag_t;

struct __anonstruct_tty_t_116520144 {
   int fdin ;
   FILE *fout ;
   struct termios original_termios ;
   int fgcolor ;
   size_t maxwidth ;
   size_t maxheight ;
};
typedef struct __anonstruct_tty_t_116520144 tty_t;
struct __anonstruct_options_t_734899051 {
   int benchmark ;
   char const   *filter ;
   char const   *init_search ;
   char const   *tty_filename ;
   int show_scores ;
   unsigned int num_lines ;
   unsigned int scrolloff ;
   char const   *prompt ;
   unsigned int workers ;
   char input_delimiter ;
   int show_info ;
};
typedef struct __anonstruct_options_t_734899051 options_t;
struct scored_result {
   score_t score ;
   char const   *str ;
};
struct __anonstruct_choices_t_109572495 {
   char *buffer ;
   size_t buffer_size ;
   size_t capacity ;
   size_t size ;
   char const   **strings ;
   struct scored_result *results ;
   size_t available ;
   size_t selection ;
   unsigned int worker_count ;
};
typedef struct __anonstruct_choices_t_109572495 choices_t;
struct __anonstruct_tty_interface_t_641585985 {
   tty_t *tty ;
   choices_t *choices ;
   options_t *options ;
   char search[4097] ;
   char last_search[4097] ;
   size_t cursor ;
   int ambiguous_key_pending ;
   char input[32] ;
   int exit ;
};
typedef struct __anonstruct_tty_interface_t_641585985 tty_interface_t;
struct match_struct {
   int needle_len ;
   int haystack_len ;
   char lower_needle[1024] ;
   char lower_haystack[1024] ;
   score_t match_bonus[1024] ;
};
typedef long __time_t;
typedef long __syscall_slong_t;
typedef __gnuc_va_list va_list___0;
typedef __ssize_t ssize_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
struct __anonstruct___sigset_t_991265788 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___sigset_t_991265788 __sigset_t;
typedef __sigset_t sigset_t;
typedef long __fd_mask;
struct __anonstruct_fd_set_356711149 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
typedef struct __anonstruct_fd_set_356711149 fd_set;
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
typedef void (*__sighandler_t)(int  );
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};

typedef union pthread_attr_t pthread_attr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
struct result_list {
   struct scored_result *list ;
   size_t size ;
};
struct worker ;
struct search_job {
   pthread_mutex_t lock ;
   choices_t *choices ;
   char const   *search ;
   size_t processed ;
   struct worker *workers ;
};
struct worker {
   pthread_t thread_id ;
   struct search_job *job ;
   unsigned int worker_num ;
   struct result_list result ;
};

extern int __uflow(FILE * ) ;
extern int __overflow(FILE * , int  ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;

void tty_init(tty_t *tty , char const   *tty_filename ) ;

void choices_search(choices_t *c , char const   *search ) ;

void tty_interface_init(tty_interface_t *state , tty_t *tty , choices_t *choices ,
                        options_t *options ) ;
int tty_interface_run(tty_interface_t *state ) ;
int main(int argc , char **argv ) 
{ 
  int ret ;
  options_t options ;
  choices_t choices ;
  int i ;
  size_t i___0 ;
  score_t tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  tty_t tty ;
  int tmp___3 ;
  int num_lines_adjustment ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  tty_interface_t tty_interface ;

  {
  ret = 0;

  if (options.benchmark) {
    if (! options.filter) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Must specify -e/--show-matches with --benchmark\n");
      exit(1);
    }

    i = 0;
    while (i < options.benchmark) {
      choices_search(& choices, options.filter);
      i ++;
    }
  } else
  if (options.filter) {
    choices_search(& choices, options.filter);
    i___0 = (size_t )0;
    while (1) {
      if (! (i___0 < tmp___1)) {
        break;
      }
      if (options.show_scores) {

        printf((char const   * __restrict  )"%f\t", tmp);
      }
      printf((char const   * __restrict  )"%s\n", tmp___0);
      i___0 ++;
    }
  } else {
    tmp___2 = isatty(0);
    if (tmp___2) {
    }
    tty_init(& tty, options.tty_filename);
    tmp___3 = isatty(0);
    if (! tmp___3) {
    }
    if ((size_t )options.num_lines > choices.size) {
      options.num_lines = (unsigned int )choices.size;
    }
    num_lines_adjustment = 1;
    if (options.show_info) {
      num_lines_adjustment ++;
    }
    if ((size_t )(options.num_lines + (unsigned int )num_lines_adjustment) > tmp___5) {
      options.num_lines = (unsigned int )(tmp___4 - (size_t )num_lines_adjustment);
    }
    tty_interface_init(& tty_interface, & tty, & choices, & options);
    ret = tty_interface_run(& tty_interface);
  }

  return (ret);
}
}

score_t match(char const   *needle , char const   *haystack ) ;
score_t match(char const   *needle , char const   *haystack ) 
{ 
  float tmp ;
  struct match_struct match___0 ;
  int n ;
  int m ;
  float tmp___0 ;
  float tmp___1 ;
  score_t D[2][1024] ;
  score_t M[2][1024] ;
  score_t *last_D ;
  score_t *last_M ;
  score_t *curr_D ;
  score_t *curr_M ;
  int i ;
  score_t *SWAP ;
  score_t *SWAP___0 ;

  {
  if (! *needle) {
    tmp = __builtin_inff();
    return ((score_t )(- tmp));
  }
 
  n = match___0.needle_len;
  m = match___0.haystack_len;
  if (m > 1024) {
    tmp___0 = __builtin_inff();
    return ((score_t )(- tmp___0));
  } else
  if (n > m) {
    tmp___0 = __builtin_inff();
    return ((score_t )(- tmp___0));
  } else
  if (n == m) {
    tmp___1 = __builtin_inff();
    return ((score_t )tmp___1);
  }
  last_D = D[0];
  last_M = M[0];
  curr_D = D[1];
  curr_M = M[1];
  i = 0;
  while (i < n) {
    while (1) {
      SWAP = curr_D;
      curr_D = last_D;
      last_D = SWAP;
      break;
    }
    while (1) {
      SWAP___0 = curr_M;
      curr_M = last_M;
      last_M = SWAP___0;
      break;
    }
    i ++;
  }
  return (*(last_M + (m - 1)));
}
}

extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;

void tty_init(tty_t *tty , char const   *tty_filename ) 
{ 
  int tmp ;
  int tmp___0 ;
  struct termios new_termios ;
  int tmp___1 ;

  {
  tty->fdin = open(tty_filename, 0);
  if (tty->fdin < 0) {
    perror("Failed to open tty");
    exit(1);
  }
  tty->fout = fopen((char const   * __restrict  )tty_filename, (char const   * __restrict  )"w");
  if (! tty->fout) {
    perror("Failed to open tty");
    exit(1);
  }
  tmp = setvbuf((FILE * __restrict  )tty->fout, (char * __restrict  )((void *)0),
                0, (size_t )4096);
  if (tmp) {
    perror("setvbuf");
    exit(1);
  }
  tmp___0 = tcgetattr(tty->fdin, & tty->original_termios);
  if (tmp___0) {
    perror("tcgetattr");
    exit(1);
  }
  new_termios = tty->original_termios;
  new_termios.c_iflag &= 4294967039U;
  new_termios.c_lflag &= 4294967284U;
  tmp___1 = tcsetattr(tty->fdin, 0, (struct termios  const  *)(& new_termios));
  if (tmp___1) {
    perror("tcsetattr");
  }
  return;
}
}
static int cmpchoice(void const   *_idx1 , void const   *_idx2 ) 
{ 
  struct scored_result  const  *a ;
  struct scored_result  const  *b ;

  {
  a = (struct scored_result  const  *)_idx1;
  b = (struct scored_result  const  *)_idx2;
  if (a->score == b->score) {
    if ((unsigned long )a->str < (unsigned long )b->str) {
      return (-1);
    } else {
      return (1);
    }
  } else
  if (a->score < b->score) {
    return (1);
  } else {
    return (-1);
  }
}
}

static void worker_get_next_batch(struct search_job *job , size_t *start , size_t *end ) 
{ 


  {
  pthread_mutex_lock(& job->lock);
  *start = job->processed;
  job->processed += 512UL;
  if (job->processed > (job->choices)->size) {
    job->processed = (job->choices)->size;
  }
  *end = job->processed;
  pthread_mutex_unlock(& job->lock);
  return;
}
}
static struct result_list merge2(struct result_list list1 , struct result_list list2 ) 
{ 
  size_t result_index ;
  size_t index1 ;
  size_t index2 ;
  struct result_list result ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
  result_index = (size_t )0;
  index1 = (size_t )0;
  index2 = (size_t )0;
  result.size = list1.size + list2.size;
  tmp = malloc(result.size * sizeof(struct scored_result ));
  result.list = (struct scored_result *)tmp;
  while (1) {
    if (index1 < list1.size) {
      if (! (index2 < list2.size)) {
        break;
      }
    } else {
      break;
    }
    tmp___4 = cmpchoice((void const   *)(list1.list + index1), (void const   *)(list2.list + index2));
    if (tmp___4 < 0) {
      tmp___0 = result_index;
      result_index ++;
      tmp___1 = index1;
      index1 ++;
      *(result.list + tmp___0) = *(list1.list + tmp___1);
    } else {
      tmp___2 = result_index;
      result_index ++;
      tmp___3 = index2;
      index2 ++;
      *(result.list + tmp___2) = *(list2.list + tmp___3);
    }
  }
  while (index1 < list1.size) {
    tmp___5 = result_index;
    result_index ++;
    tmp___6 = index1;
    index1 ++;
    *(result.list + tmp___5) = *(list1.list + tmp___6);
  }
  while (index2 < list2.size) {
    tmp___7 = result_index;
    result_index ++;
    tmp___8 = index2;
    index2 ++;
    *(result.list + tmp___7) = *(list2.list + tmp___8);
  }
  free((void *)list1.list);
  free((void *)list2.list);
  return (result);
}
}
static void *choices_search_worker(void *data ) 
{ 
  struct worker *w ;
  struct search_job *job ;
  choices_t const   *c ;
  struct result_list *result ;
  size_t start ;
  size_t end ;
  size_t i ;
  int tmp ;
  unsigned int step ;
  unsigned int next_worker ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  w = (struct worker *)data;
  job = w->job;
  c = (choices_t const   *)job->choices;
  result = & w->result;
  while (1) {
    worker_get_next_batch(job, & start, & end);
    if (start == end) {
      break;
    }
    i = start;
    while (i < end) {

      if (tmp) {
        (result->list + result->size)->str = *(c->strings + i);
        (result->list + result->size)->score = match(job->search, *(c->strings + i));
        (result->size) ++;
      }
      i ++;
    }
  }
  qsort((void *)result->list, result->size, sizeof(struct scored_result ), & cmpchoice);
  step = 0U;
  while (! (w->worker_num % (unsigned int )(2 << step))) {
    next_worker = w->worker_num | (unsigned int )(1 << step);
    if (next_worker >= (unsigned int )c->worker_count) {
      break;
    }
    tmp___0 = __errno_location();
    tmp___1 = pthread_join((job->workers + next_worker)->thread_id, (void **)((void *)0));
    *tmp___0 = tmp___1;
    if (tmp___1) {
      perror("pthread_join");
      exit(1);
    }
    w->result = merge2(w->result, (job->workers + next_worker)->result);
    step ++;
  }
  return ((void *)0);
}
}
void choices_search(choices_t *c , char const   *search ) 
{ 
  struct search_job *job ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  struct worker *workers ;
  int i ;
  void *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {

  tmp = calloc((size_t )1, sizeof(struct search_job ));
  job = (struct search_job *)tmp;
  job->search = search;
  job->choices = c;
  tmp___0 = pthread_mutex_init(& job->lock, (pthread_mutexattr_t const   *)((void *)0));
  if (tmp___0 != 0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: pthread_mutex_init failed\n");
    abort();
  }
  tmp___1 = calloc((size_t )c->worker_count, sizeof(struct worker ));
  job->workers = (struct worker *)tmp___1;
  workers = job->workers;
  i = (int )(c->worker_count - 1U);
  while (i >= 0) {
    (workers + i)->job = job;
    (workers + i)->worker_num = (unsigned int )i;
    (workers + i)->result.size = (size_t )0;
    tmp___2 = malloc(c->size * sizeof(struct scored_result ));
    (workers + i)->result.list = (struct scored_result *)tmp___2;
    tmp___3 = __errno_location();
    tmp___4 = pthread_create((pthread_t * __restrict  )(& (workers + i)->thread_id),
                             (pthread_attr_t const   * __restrict  )((void *)0), & choices_search_worker,
                             (void * __restrict  )(workers + i));
    *tmp___3 = tmp___4;
    if (tmp___4) {
      perror("pthread_create");
      exit(1);
    }
    i --;
  }
  tmp___5 = pthread_join((workers + 0)->thread_id, (void **)((void *)0));
  if (tmp___5) {
    perror("pthread_join");
    exit(1);
  }
  c->results = (workers + 0)->result.list;
  c->available = (workers + 0)->result.size;
  free((void *)workers);
  pthread_mutex_destroy(& job->lock);
  free((void *)job);
  return;
}
}

extern char *optarg ;
extern int optind ;

extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;

static void draw(tty_interface_t *state ) 
{ 
  tty_t *tty ;
  choices_t *choices ;
  options_t *options ;
  unsigned int num_lines ;
  size_t start ;
  size_t current_selection ;
  size_t available ;
  size_t tmp ;
  size_t i ;
  char const   *choice ;
  char const   *tmp___0 ;
  size_t i___0 ;

  {
  tty = state->tty;
  choices = state->choices;
  options = state->options;
  num_lines = options->num_lines;
  start = (size_t )0;
  current_selection = choices->selection;
  if (current_selection + (size_t )options->scrolloff >= (size_t )num_lines) {
    start = ((current_selection + (size_t )options->scrolloff) - (size_t )num_lines) + 1UL;
    available = tmp;
    if (start + (size_t )num_lines >= available) {
      if (available > 0UL) {
        start = available - (size_t )num_lines;
      }
    }
  }
  if (options->show_info) {
  }
  i = start;
  while (i < start + (size_t )num_lines) {
    choice = tmp___0;
    if (choice) {

    }
    i ++;
  }
  fputs((char const   * __restrict  )options->prompt, (FILE * __restrict  )tty->fout);
  i___0 = (size_t )0;
  while (i___0 < state->cursor) {
    fputc((int )state->search[i___0], tty->fout);
    i___0 ++;
  }
  return;
}
}
static void update_search(tty_interface_t *state ) 
{ 


  {
  choices_search(state->choices, (char const   *)(state->search));
  strcpy((char * __restrict  )(state->last_search), (char const   * __restrict  )(state->search));
  return;
}
}


void tty_interface_init(tty_interface_t *state , tty_t *tty , choices_t *choices ,
                        options_t *options ) 
{ 


  {
  state->tty = tty;
  state->choices = choices;
  state->options = options;
  state->ambiguous_key_pending = 0;
  strcpy((char * __restrict  )(state->input), (char const   * __restrict  )"");
  strcpy((char * __restrict  )(state->search), (char const   * __restrict  )"");
  strcpy((char * __restrict  )(state->last_search), (char const   * __restrict  )"");
  state->exit = -1;
  if (options->init_search) {
    strncpy((char * __restrict  )(state->search), (char const   * __restrict  )options->init_search,
            (size_t )4096);
  }
  state->cursor = strlen((char const   *)(state->search));
  update_search(state);
  return;
}
}
int tty_interface_run(tty_interface_t *state ) 
{ 
  int tmp ;
  char s[2] ;
  char tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char s___0[1] ;

  {
  draw(state);
  while (1) {
    while (1) {
      while (1) {
     
        if (tmp) {
          break;
        }
        draw(state);
      }

      s[0] = tmp___0;
      s[1] = (char )'\000';

      if (state->exit >= 0) {
        return (state->exit);
      }
      draw(state);
      if (state->ambiguous_key_pending) {
        tmp___1 = 25;
      } else {
        tmp___1 = 0;
      }

      if (! tmp___2) {
        break;
      }
    }
    if (state->ambiguous_key_pending) {
      s___0[0] = (char )'\000';
      handle_input(state, (char const   *)(s___0), 1);
      if (state->exit >= 0) {
        return (state->exit);
      }
    }

  }
}
}