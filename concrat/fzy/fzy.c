/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef __builtin_va_list __gnuc_va_list;
typedef int __int32_t;
typedef long __off_t;
typedef long __off64_t;
typedef long __ssize_t;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef double score_t;
typedef unsigned char cc_t;
typedef unsigned int speed_t;
typedef unsigned int tcflag_t;
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
struct __anonstruct_tty_t_116520144 {
   int fdin ;
   FILE *fout ;
   struct termios original_termios ;
   int fgcolor ;
   size_t maxwidth ;
   size_t maxheight ;
};
typedef struct __anonstruct_tty_t_116520144 tty_t;
struct __anonstruct_options_t_734899051 {
   int benchmark ;
   char const   *filter ;
   char const   *init_search ;
   char const   *tty_filename ;
   int show_scores ;
   unsigned int num_lines ;
   unsigned int scrolloff ;
   char const   *prompt ;
   unsigned int workers ;
   char input_delimiter ;
   int show_info ;
};
typedef struct __anonstruct_options_t_734899051 options_t;
struct scored_result {
   score_t score ;
   char const   *str ;
};
struct __anonstruct_choices_t_109572495 {
   char *buffer ;
   size_t buffer_size ;
   size_t capacity ;
   size_t size ;
   char const   **strings ;
   struct scored_result *results ;
   size_t available ;
   size_t selection ;
   unsigned int worker_count ;
};
typedef struct __anonstruct_choices_t_109572495 choices_t;
struct __anonstruct_tty_interface_t_641585985 {
   tty_t *tty ;
   choices_t *choices ;
   options_t *options ;
   char search[4097] ;
   char last_search[4097] ;
   size_t cursor ;
   int ambiguous_key_pending ;
   char input[32] ;
   int exit ;
};
typedef struct __anonstruct_tty_interface_t_641585985 tty_interface_t;
struct match_struct {
   int needle_len ;
   int haystack_len ;
   char lower_needle[1024] ;
   char lower_haystack[1024] ;
   score_t match_bonus[1024] ;
};
typedef long __time_t;
typedef long __syscall_slong_t;
typedef __gnuc_va_list va_list___0;
typedef __ssize_t ssize_t;
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
struct __anonstruct___sigset_t_991265788 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___sigset_t_991265788 __sigset_t;
typedef __sigset_t sigset_t;
typedef long __fd_mask;
struct __anonstruct_fd_set_356711149 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
typedef struct __anonstruct_fd_set_356711149 fd_set;
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
typedef void (*__sighandler_t)(int  );
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
typedef unsigned long pthread_t;
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
struct result_list {
   struct scored_result *list ;
   size_t size ;
};
struct worker ;
struct search_job {
   pthread_mutex_t lock ;
   choices_t *choices ;
   char const   *search ;
   size_t processed ;
   struct worker *workers ;
};
struct worker {
   pthread_t thread_id ;
   struct search_job *job ;
   unsigned int worker_num ;
   struct result_list result ;
};
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
struct __anonstruct_keybinding_t_984224788 {
   char const   *key ;
   void (*action)(tty_interface_t * ) ;
};
typedef struct __anonstruct_keybinding_t_984224788 keybinding_t;
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#pragma merger("0","/tmp/cil-_iODznWl.i","-Wall,-Wextra,-g,-std=c99,-O3,-pedantic,-Werror=vla")
extern FILE *stdin ;
extern FILE *stdout ;
extern FILE *stderr ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern int printf(char const   * __restrict  __format  , ...) ;
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) ;
extern int getc(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
extern int putc(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
extern __ssize_t __getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                            int __delimiter , FILE * __restrict  __stream ) ;
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                     size_t * __restrict  __n ,
                                                                     FILE * __restrict  __stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
extern int __uflow(FILE * ) ;
extern int __overflow(FILE * , int  ) ;
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) 
{ 
  int tmp ;

  {
  tmp = vfprintf((FILE * __restrict  )stdout, __fmt, __arg);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) 
{ 
  int tmp ;

  {
  tmp = getc(stdin);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(__fp);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = __fp->_IO_read_ptr;
    (__fp->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(stdin);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = stdin->_IO_read_ptr;
    (stdin->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) 
{ 
  int tmp ;

  {
  tmp = putc(__c, stdout);
  return (tmp);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = __stream->_IO_write_ptr;
    (__stream->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = stdout->_IO_write_ptr;
    (stdout->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                     size_t * __restrict  __n ,
                                                                     FILE * __restrict  __stream ) 
{ 
  __ssize_t tmp ;

  {
  tmp = __getdelim(__lineptr, __n, '\n', __stream);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 16) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
__inline extern int ( __attribute__((__gnu_inline__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
  return ((__stream->_flags & 32) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1))) strtod)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1))) strtol)(char const   * __restrict  __nptr ,
                                                                                    char ** __restrict  __endptr ,
                                                                                    int __base ) ;
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1))) strtoll)(char const   * __restrict  __nptr ,
                                                                                          char ** __restrict  __endptr ,
                                                                                          int __base ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern int ( __attribute__((__nonnull__(1), __gnu_inline__)) atoi)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return ((int )tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long ( __attribute__((__nonnull__(1), __gnu_inline__)) atol)(char const   *__nptr ) 
{ 
  long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1),
__gnu_inline__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern long long ( __attribute__((__nonnull__(1), __gnu_inline__)) atoll)(char const   *__nptr ) 
{ 
  long long tmp ;

  {
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
  return (tmp);
}
}
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) ;
__inline extern void *( __attribute__((__nonnull__(1,2,5), __gnu_inline__)) bsearch)(void const   *__key ,
                                                                                     void const   *__base ,
                                                                                     size_t __nmemb ,
                                                                                     size_t __size ,
                                                                                     int (*__compar)(void const   * ,
                                                                                                     void const   * ) ) 
{ 
  size_t __l ;
  size_t __u ;
  size_t __idx ;
  void const   *__p ;
  int __comparison ;

  {
  __l = (size_t )0;
  __u = __nmemb;
  while (__l < __u) {
    __idx = (__l + __u) / 2UL;
    __p = (void const   *)((void *)((char const   *)__base + __idx * __size));
    __comparison = (*__compar)(__key, __p);
    if (__comparison < 0) {
      __u = __idx;
    } else
    if (__comparison > 0) {
      __l = __idx + 1UL;
    } else {
      return ((void *)__p);
    }
  }
  return ((void *)0);
}
}
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1),
__gnu_inline__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
__inline extern double ( __attribute__((__nonnull__(1), __gnu_inline__)) atof)(char const   *__nptr ) 
{ 
  double tmp ;

  {
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) tolower)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) tolower)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_tolower_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
    tmp___0 = (__int32_t const   )__c;
  }
  return ((int )tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) toupper)(int __c ) ;
__inline extern int ( __attribute__((__gnu_inline__)) toupper)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_toupper_loc();
      tmp___0 = *(*tmp + __c);
    } else {
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
    tmp___0 = (__int32_t const   )__c;
  }
  return ((int )tmp___0);
}
}
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
void tty_init(tty_t *tty , char const   *tty_filename ) ;
size_t tty_getheight(tty_t *tty ) ;
void options_parse(options_t *options , int argc , char **argv ) ;
void choices_init(choices_t *c , options_t *options ) ;
void choices_fread(choices_t *c , FILE *file , char input_delimiter ) ;
void choices_destroy(choices_t *c ) ;
size_t choices_available(choices_t *c ) ;
void choices_search(choices_t *c , char const   *search ) ;
char const   *choices_get(choices_t *c , size_t n ) ;
score_t choices_getscore(choices_t *c , size_t n ) ;
void tty_interface_init(tty_interface_t *state , tty_t *tty , choices_t *choices ,
                        options_t *options ) ;
int tty_interface_run(tty_interface_t *state ) ;
int main(int argc , char **argv ) 
{ 
  int ret ;
  options_t options ;
  choices_t choices ;
  int i ;
  size_t i___0 ;
  score_t tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  tty_t tty ;
  int tmp___3 ;
  int num_lines_adjustment ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  tty_interface_t tty_interface ;

  {
  ret = 0;
  options_parse(& options, argc, argv);
  choices_init(& choices, & options);
  if (options.benchmark) {
    if (! options.filter) {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Must specify -e/--show-matches with --benchmark\n");
      exit(1);
    }
    choices_fread(& choices, stdin, options.input_delimiter);
    i = 0;
    while (i < options.benchmark) {
      choices_search(& choices, options.filter);
      i ++;
    }
  } else
  if (options.filter) {
    choices_fread(& choices, stdin, options.input_delimiter);
    choices_search(& choices, options.filter);
    i___0 = (size_t )0;
    while (1) {
      tmp___1 = choices_available(& choices);
      if (! (i___0 < tmp___1)) {
        break;
      }
      if (options.show_scores) {
        tmp = choices_getscore(& choices, i___0);
        printf((char const   * __restrict  )"%f\t", tmp);
      }
      tmp___0 = choices_get(& choices, i___0);
      printf((char const   * __restrict  )"%s\n", tmp___0);
      i___0 ++;
    }
  } else {
    tmp___2 = isatty(0);
    if (tmp___2) {
      choices_fread(& choices, stdin, options.input_delimiter);
    }
    tty_init(& tty, options.tty_filename);
    tmp___3 = isatty(0);
    if (! tmp___3) {
      choices_fread(& choices, stdin, options.input_delimiter);
    }
    if ((size_t )options.num_lines > choices.size) {
      options.num_lines = (unsigned int )choices.size;
    }
    num_lines_adjustment = 1;
    if (options.show_info) {
      num_lines_adjustment ++;
    }
    tmp___5 = tty_getheight(& tty);
    if ((size_t )(options.num_lines + (unsigned int )num_lines_adjustment) > tmp___5) {
      tmp___4 = tty_getheight(& tty);
      options.num_lines = (unsigned int )(tmp___4 - (size_t )num_lines_adjustment);
    }
    tty_interface_init(& tty_interface, & tty, & choices, & options);
    ret = tty_interface_run(& tty_interface);
  }
  choices_destroy(& choices);
  return (ret);
}
}
/* compiler builtin: 
   float __builtin_inff(void) ;  */
#pragma merger("0","/tmp/cil-E2UPu7mH.i","-Wall,-Wextra,-g,-std=c99,-O3,-pedantic,-Werror=vla")
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strpbrk)(char const   *__s ,
                                                                                        char const   *__accept )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
int has_match(char const   *needle , char const   *haystack ) ;
score_t match_positions(char const   *needle , char const   *haystack , size_t *positions ) ;
score_t match(char const   *needle , char const   *haystack ) ;
score_t const   bonus_states[3][256]  = { {        (score_t const   )0}, 
   {        0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            (score_t const   )0.8,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        (score_t const   )0.8,        (score_t const   )0.6,        (score_t const   )0.9, 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        (score_t const   )0.8}, 
   {        0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            (score_t const   )0.8,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        (score_t const   )0.8,        (score_t const   )0.6,        (score_t const   )0.9, 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        0., 
            0.,        0.,        0.,        (score_t const   )0.8, 
            0.,        (score_t const   )0.7,        (score_t const   )0.7,        (score_t const   )0.7, 
            (score_t const   )0.7,        (score_t const   )0.7,        (score_t const   )0.7,        (score_t const   )0.7, 
            (score_t const   )0.7,        (score_t const   )0.7,        (score_t const   )0.7,        (score_t const   )0.7, 
            (score_t const   )0.7,        (score_t const   )0.7,        (score_t const   )0.7,        (score_t const   )0.7, 
            (score_t const   )0.7,        (score_t const   )0.7,        (score_t const   )0.7,        (score_t const   )0.7, 
            (score_t const   )0.7,        (score_t const   )0.7,        (score_t const   )0.7,        (score_t const   )0.7, 
            (score_t const   )0.7,        (score_t const   )0.7,        (score_t const   )0.7}};
size_t const   bonus_index[256]  = 
  {      0UL,      0UL,      0UL,      0UL, 
        0UL,      0UL,      0UL,      0UL, 
        0UL,      0UL,      0UL,      0UL, 
        0UL,      0UL,      0UL,      0UL, 
        0UL,      0UL,      0UL,      0UL, 
        0UL,      0UL,      0UL,      0UL, 
        0UL,      0UL,      0UL,      0UL, 
        0UL,      0UL,      0UL,      0UL, 
        0UL,      0UL,      0UL,      0UL, 
        0UL,      0UL,      0UL,      0UL, 
        0UL,      0UL,      0UL,      0UL, 
        0UL,      0UL,      0UL,      0UL, 
        (size_t const   )1,      (size_t const   )1,      (size_t const   )1,      (size_t const   )1, 
        (size_t const   )1,      (size_t const   )1,      (size_t const   )1,      (size_t const   )1, 
        (size_t const   )1,      (size_t const   )1,      0UL,      0UL, 
        0UL,      0UL,      0UL,      0UL, 
        0UL,      (size_t const   )2,      (size_t const   )2,      (size_t const   )2, 
        (size_t const   )2,      (size_t const   )2,      (size_t const   )2,      (size_t const   )2, 
        (size_t const   )2,      (size_t const   )2,      (size_t const   )2,      (size_t const   )2, 
        (size_t const   )2,      (size_t const   )2,      (size_t const   )2,      (size_t const   )2, 
        (size_t const   )2,      (size_t const   )2,      (size_t const   )2,      (size_t const   )2, 
        (size_t const   )2,      (size_t const   )2,      (size_t const   )2,      (size_t const   )2, 
        (size_t const   )2,      (size_t const   )2,      (size_t const   )2,      0UL, 
        0UL,      0UL,      0UL,      0UL, 
        0UL,      (size_t const   )1,      (size_t const   )1,      (size_t const   )1, 
        (size_t const   )1,      (size_t const   )1,      (size_t const   )1,      (size_t const   )1, 
        (size_t const   )1,      (size_t const   )1,      (size_t const   )1,      (size_t const   )1, 
        (size_t const   )1,      (size_t const   )1,      (size_t const   )1,      (size_t const   )1, 
        (size_t const   )1,      (size_t const   )1,      (size_t const   )1,      (size_t const   )1, 
        (size_t const   )1,      (size_t const   )1,      (size_t const   )1,      (size_t const   )1, 
        (size_t const   )1,      (size_t const   )1,      (size_t const   )1};
char *strcasechr(char const   *s , char c ) 
{ 
  char accept[3] ;
  int __res ;
  __int32_t const   **tmp___0 ;
  char *tmp___1 ;

  {
  if (sizeof(c) > 1UL) {
    __res = toupper((int )c);
  } else {
    tmp___0 = __ctype_toupper_loc();
    __res = (int )*(*tmp___0 + (int )c);
  }
  accept[0] = c;
  accept[1] = (char )__res;
  accept[2] = (char)0;
  tmp___1 = strpbrk(s, (char const   *)(accept));
  return (tmp___1);
}
}
int has_match(char const   *needle , char const   *haystack ) 
{ 
  char nch ;
  char const   *tmp ;
  char *tmp___0 ;

  {
  while (*needle) {
    tmp = needle;
    needle ++;
    nch = (char )*tmp;
    tmp___0 = strcasechr(haystack, nch);
    haystack = (char const   *)tmp___0;
    if (! haystack) {
      return (0);
    }
    haystack ++;
  }
  return (1);
}
}
static void precompute_bonus(char const   *haystack , score_t *match_bonus ) 
{ 
  char last_ch ;
  int i ;
  char ch ;

  {
  last_ch = (char )'/';
  i = 0;
  while (*(haystack + i)) {
    ch = (char )*(haystack + i);
    *(match_bonus + i) = (score_t )bonus_states[bonus_index[(unsigned char )ch]][(unsigned char )last_ch];
    last_ch = ch;
    i ++;
  }
  return;
}
}
static void setup_match_struct(struct match_struct *match___0 , char const   *needle ,
                               char const   *haystack ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  int i ;
  int __res ;
  __int32_t const   **tmp___2 ;
  int i___0 ;
  int __res___0 ;
  __int32_t const   **tmp___4 ;

  {
  tmp = strlen(needle);
  match___0->needle_len = (int )tmp;
  tmp___0 = strlen(haystack);
  match___0->haystack_len = (int )tmp___0;
  if (match___0->haystack_len > 1024) {
    return;
  } else
  if (match___0->needle_len > match___0->haystack_len) {
    return;
  }
  i = 0;
  while (i < match___0->needle_len) {
    if (sizeof(*(needle + i)) > 1UL) {
      __res = tolower((int )*(needle + i));
    } else {
      tmp___2 = __ctype_tolower_loc();
      __res = (int )*(*tmp___2 + (int )*(needle + i));
    }
    match___0->lower_needle[i] = (char )__res;
    i ++;
  }
  i___0 = 0;
  while (i___0 < match___0->haystack_len) {
    if (sizeof(*(haystack + i___0)) > 1UL) {
      __res___0 = tolower((int )*(haystack + i___0));
    } else {
      tmp___4 = __ctype_tolower_loc();
      __res___0 = (int )*(*tmp___4 + (int )*(haystack + i___0));
    }
    match___0->lower_haystack[i___0] = (char )__res___0;
    i___0 ++;
  }
  precompute_bonus(haystack, match___0->match_bonus);
  return;
}
}
__inline static void match_row(struct match_struct  const  *match___0 , int row ,
                               score_t *curr_D , score_t *curr_M , score_t const   *last_D ,
                               score_t const   *last_M ) 
{ 
  int n ;
  int m ;
  int i ;
  char const   *lower_needle ;
  char const   *lower_haystack ;
  score_t const   *match_bonus ;
  score_t prev_score ;
  float tmp ;
  score_t gap_score ;
  double tmp___0 ;
  int j ;
  score_t score ;
  float tmp___1 ;
  float tmp___2 ;

  {
  n = (int )match___0->needle_len;
  m = (int )match___0->haystack_len;
  i = row;
  lower_needle = (char const   *)(match___0->lower_needle);
  lower_haystack = (char const   *)(match___0->lower_haystack);
  match_bonus = (score_t const   *)(match___0->match_bonus);
  tmp = __builtin_inff();
  prev_score = (score_t )(- tmp);
  if (i == n - 1) {
    tmp___0 = - 0.005;
  } else {
    tmp___0 = - 0.01;
  }
  gap_score = tmp___0;
  j = 0;
  while (j < m) {
    if ((int const   )*(lower_needle + i) == (int const   )*(lower_haystack + j)) {
      tmp___1 = __builtin_inff();
      score = (score_t )(- tmp___1);
      if (! i) {
        score = (double )j * - 0.005 + (double )*(match_bonus + j);
      } else
      if (j) {
        if (*(last_M + (j - 1)) + *(match_bonus + j) > *(last_D + (j - 1)) + (score_t const   )1.0) {
          score = (score_t )(*(last_M + (j - 1)) + *(match_bonus + j));
        } else {
          score = (score_t )(*(last_D + (j - 1)) + (score_t const   )1.0);
        }
      }
      *(curr_D + j) = score;
      if (score > prev_score + gap_score) {
        prev_score = score;
      } else {
        prev_score += gap_score;
      }
      *(curr_M + j) = prev_score;
    } else {
      tmp___2 = __builtin_inff();
      *(curr_D + j) = (score_t )(- tmp___2);
      prev_score += gap_score;
      *(curr_M + j) = prev_score;
    }
    j ++;
  }
  return;
}
}
score_t match(char const   *needle , char const   *haystack ) 
{ 
  float tmp ;
  struct match_struct match___0 ;
  int n ;
  int m ;
  float tmp___0 ;
  float tmp___1 ;
  score_t D[2][1024] ;
  score_t M[2][1024] ;
  score_t *last_D ;
  score_t *last_M ;
  score_t *curr_D ;
  score_t *curr_M ;
  int i ;
  score_t *SWAP ;
  score_t *SWAP___0 ;

  {
  if (! *needle) {
    tmp = __builtin_inff();
    return ((score_t )(- tmp));
  }
  setup_match_struct(& match___0, needle, haystack);
  n = match___0.needle_len;
  m = match___0.haystack_len;
  if (m > 1024) {
    tmp___0 = __builtin_inff();
    return ((score_t )(- tmp___0));
  } else
  if (n > m) {
    tmp___0 = __builtin_inff();
    return ((score_t )(- tmp___0));
  } else
  if (n == m) {
    tmp___1 = __builtin_inff();
    return ((score_t )tmp___1);
  }
  last_D = D[0];
  last_M = M[0];
  curr_D = D[1];
  curr_M = M[1];
  i = 0;
  while (i < n) {
    match_row((struct match_struct  const  *)(& match___0), i, curr_D, curr_M, (score_t const   *)last_D,
              (score_t const   *)last_M);
    while (1) {
      SWAP = curr_D;
      curr_D = last_D;
      last_D = SWAP;
      break;
    }
    while (1) {
      SWAP___0 = curr_M;
      curr_M = last_M;
      last_M = SWAP___0;
      break;
    }
    i ++;
  }
  return (*(last_M + (m - 1)));
}
}
score_t match_positions(char const   *needle , char const   *haystack , size_t *positions ) 
{ 
  float tmp ;
  struct match_struct match___0 ;
  int n ;
  int m ;
  float tmp___0 ;
  int i ;
  float tmp___1 ;
  score_t (*D)[1024] ;
  score_t (*M)[1024] ;
  void *tmp___2 ;
  void *tmp___3 ;
  score_t *last_D ;
  score_t *last_M ;
  score_t *curr_D ;
  score_t *curr_M ;
  int i___0 ;
  int match_required ;
  int i___1 ;
  int j ;
  int tmp___4 ;
  int tmp___5 ;
  float tmp___6 ;
  score_t result ;

  {
  if (! *needle) {
    tmp = __builtin_inff();
    return ((score_t )(- tmp));
  }
  setup_match_struct(& match___0, needle, haystack);
  n = match___0.needle_len;
  m = match___0.haystack_len;
  if (m > 1024) {
    tmp___0 = __builtin_inff();
    return ((score_t )(- tmp___0));
  } else
  if (n > m) {
    tmp___0 = __builtin_inff();
    return ((score_t )(- tmp___0));
  } else
  if (n == m) {
    if (positions) {
      i = 0;
      while (i < n) {
        *(positions + i) = (size_t )i;
        i ++;
      }
    }
    tmp___1 = __builtin_inff();
    return ((score_t )tmp___1);
  }
  tmp___2 = malloc((sizeof(score_t ) * 1024UL) * (unsigned long )n);
  M = (score_t (*)[1024])tmp___2;
  tmp___3 = malloc((sizeof(score_t ) * 1024UL) * (unsigned long )n);
  D = (score_t (*)[1024])tmp___3;
  i___0 = 0;
  while (i___0 < n) {
    curr_D = & (*(D + i___0))[0];
    curr_M = & (*(M + i___0))[0];
    match_row((struct match_struct  const  *)(& match___0), i___0, curr_D, curr_M,
              (score_t const   *)last_D, (score_t const   *)last_M);
    last_D = curr_D;
    last_M = curr_M;
    i___0 ++;
  }
  if (positions) {
    match_required = 0;
    i___1 = n - 1;
    j = m - 1;
    while (i___1 >= 0) {
      while (j >= 0) {
        tmp___6 = __builtin_inff();
        if ((*(D + i___1))[j] != (score_t )(- tmp___6)) {
          if (match_required) {
            goto _L;
          } else
          if ((*(D + i___1))[j] == (*(M + i___1))[j]) {
            _L: /* CIL Label */ 
            if (i___1) {
              if (j) {
                if ((*(M + i___1))[j] == (*(D + (i___1 - 1)))[j - 1] + 1.0) {
                  tmp___4 = 1;
                } else {
                  tmp___4 = 0;
                }
              } else {
                tmp___4 = 0;
              }
            } else {
              tmp___4 = 0;
            }
            match_required = tmp___4;
            tmp___5 = j;
            j --;
            *(positions + i___1) = (size_t )tmp___5;
            break;
          }
        }
        j --;
      }
      i___1 --;
    }
  }
  result = (*(M + (n - 1)))[m - 1];
  free((void *)M);
  free((void *)D);
  return (result);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#pragma merger("0","/tmp/cil-aTh1ixlh.i","-Wall,-Wextra,-g,-std=c99,-O3,-pedantic,-Werror=vla")
extern int fclose(FILE *__stream ) ;
extern int fflush(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern  __attribute__((__nothrow__)) int setvbuf(FILE * __restrict  __stream , char * __restrict  __buf ,
                                                 int __modes , size_t __n ) ;
extern int fputc(int __c , FILE *__stream ) ;
extern void perror(char const   *__s ) ;
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
extern int close(int __fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
extern int pselect(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                   fd_set * __restrict  __exceptfds , struct timespec  const  * __restrict  __timeout ,
                   __sigset_t const   * __restrict  __sigmask ) ;
extern  __attribute__((__nothrow__)) int tcgetattr(int __fd , struct termios *__termios_p ) ;
extern  __attribute__((__nothrow__)) int tcsetattr(int __fd , int __optional_actions ,
                                                   struct termios  const  *__termios_p ) ;
extern  __attribute__((__nothrow__)) int ioctl(int __fd , unsigned long __request 
                                               , ...) ;
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigemptyset)(sigset_t *__set ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) sigaddset)(sigset_t *__set ,
                                                                                      int __signo ) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
void tty_reset(tty_t *tty ) ;
void tty_close(tty_t *tty ) ;
void tty_getwinsz(tty_t *tty ) ;
char tty_getchar(tty_t *tty ) ;
int tty_input_ready(tty_t *tty , long timeout , int return_on_signal ) ;
void tty_setfg(tty_t *tty , int fg ) ;
void tty_setinvert(tty_t *tty ) ;
void tty_setunderline(tty_t *tty ) ;
void tty_setnormal(tty_t *tty ) ;
void tty_setnowrap(tty_t *tty ) ;
void tty_setwrap(tty_t *tty ) ;
void tty_newline(tty_t *tty ) ;
void tty_clearline(tty_t *tty ) ;
void tty_moveup(tty_t *tty , int i ) ;
void tty_setcol(tty_t *tty , int col ) ;
void tty_printf(tty_t *tty , char const   *fmt  , ...) ;
void tty_putc(tty_t *tty , char c ) ;
void tty_flush(tty_t *tty ) ;
size_t tty_getwidth(tty_t *tty ) ;
void tty_reset(tty_t *tty ) 
{ 


  {
  tcsetattr(tty->fdin, 0, (struct termios  const  *)(& tty->original_termios));
  return;
}
}
void tty_close(tty_t *tty ) 
{ 


  {
  tty_reset(tty);
  fclose(tty->fout);
  close(tty->fdin);
  return;
}
}
static void handle_sigwinch(int sig ) 
{ 


  {
  return;
}
}
void tty_init(tty_t *tty , char const   *tty_filename ) 
{ 
  int tmp ;
  int tmp___0 ;
  struct termios new_termios ;
  int tmp___1 ;

  {
  tty->fdin = open(tty_filename, 0);
  if (tty->fdin < 0) {
    perror("Failed to open tty");
    exit(1);
  }
  tty->fout = fopen((char const   * __restrict  )tty_filename, (char const   * __restrict  )"w");
  if (! tty->fout) {
    perror("Failed to open tty");
    exit(1);
  }
  tmp = setvbuf((FILE * __restrict  )tty->fout, (char * __restrict  )((void *)0),
                0, (size_t )4096);
  if (tmp) {
    perror("setvbuf");
    exit(1);
  }
  tmp___0 = tcgetattr(tty->fdin, & tty->original_termios);
  if (tmp___0) {
    perror("tcgetattr");
    exit(1);
  }
  new_termios = tty->original_termios;
  new_termios.c_iflag &= 4294967039U;
  new_termios.c_lflag &= 4294967284U;
  tmp___1 = tcsetattr(tty->fdin, 0, (struct termios  const  *)(& new_termios));
  if (tmp___1) {
    perror("tcsetattr");
  }
  tty_getwinsz(tty);
  tty_setnormal(tty);
  signal(28, & handle_sigwinch);
  return;
}
}
void tty_getwinsz(tty_t *tty ) 
{ 
  struct winsize ws ;
  int tmp ;
  int tmp___0 ;

  {
  tmp = fileno(tty->fout);
  tmp___0 = ioctl(tmp, 21523UL, & ws);
  if (tmp___0 == -1) {
    tty->maxwidth = (size_t )80;
    tty->maxheight = (size_t )25;
  } else {
    tty->maxwidth = (size_t )ws.ws_col;
    tty->maxheight = (size_t )ws.ws_row;
  }
  return;
}
}
char tty_getchar(tty_t *tty ) 
{ 
  char ch ;
  int size ;
  ssize_t tmp ;

  {
  tmp = read(tty->fdin, (void *)(& ch), (size_t )1);
  size = (int )tmp;
  if (size < 0) {
    perror("error reading from tty");
    exit(1);
  } else
  if (size == 0) {
    exit(1);
  } else {
    return (ch);
  }
}
}
int tty_input_ready(tty_t *tty , long timeout , int return_on_signal ) 
{ 
  fd_set readfs ;
  int __d0 ;
  int __d1 ;
  struct timespec ts ;
  sigset_t mask ;
  int err ;
  sigset_t *tmp ;
  struct timespec *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;

  {
  while (1) {
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& readfs.fds_bits[0]): "memory");
    break;
  }
  readfs.fds_bits[tty->fdin / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << tty->fdin % (8 * (int )sizeof(__fd_mask )));
  ts.tv_sec = timeout / 1000L;
  ts.tv_nsec = (timeout % 1000L) * 1000000L;
  sigemptyset(& mask);
  if (! return_on_signal) {
    sigaddset(& mask, 28);
  }
  if (return_on_signal) {
    tmp = (sigset_t *)((void *)0);
  } else {
    tmp = & mask;
  }
  if (timeout < 0L) {
    tmp___0 = (struct timespec *)((void *)0);
  } else {
    tmp___0 = & ts;
  }
  tmp___1 = pselect(tty->fdin + 1, (fd_set * __restrict  )(& readfs), (fd_set * __restrict  )((void *)0),
                    (fd_set * __restrict  )((void *)0), (struct timespec  const  * __restrict  )tmp___0,
                    (__sigset_t const   * __restrict  )tmp);
  err = tmp___1;
  if (err < 0) {
    tmp___2 = __errno_location();
    if (*tmp___2 == 4) {
      return (0);
    } else {
      perror("select");
      exit(1);
    }
  } else {
    return ((readfs.fds_bits[tty->fdin / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << tty->fdin % (8 * (int )sizeof(__fd_mask )))) != 0L);
  }
}
}
static void tty_sgr(tty_t *tty , int code ) 
{ 


  {
  tty_printf(tty, "%c%c%im", 27, '[', code);
  return;
}
}
void tty_setfg(tty_t *tty , int fg ) 
{ 


  {
  if (tty->fgcolor != fg) {
    tty_sgr(tty, 30 + fg);
    tty->fgcolor = fg;
  }
  return;
}
}
void tty_setinvert(tty_t *tty ) 
{ 


  {
  tty_sgr(tty, 7);
  return;
}
}
void tty_setunderline(tty_t *tty ) 
{ 


  {
  tty_sgr(tty, 4);
  return;
}
}
void tty_setnormal(tty_t *tty ) 
{ 


  {
  tty_sgr(tty, 0);
  tty->fgcolor = 9;
  return;
}
}
void tty_setnowrap(tty_t *tty ) 
{ 


  {
  tty_printf(tty, "%c%c?7l", 27, '[');
  return;
}
}
void tty_setwrap(tty_t *tty ) 
{ 


  {
  tty_printf(tty, "%c%c?7h", 27, '[');
  return;
}
}
void tty_newline(tty_t *tty ) 
{ 


  {
  tty_printf(tty, "%c%cK\n", 27, '[');
  return;
}
}
void tty_clearline(tty_t *tty ) 
{ 


  {
  tty_printf(tty, "%c%cK", 27, '[');
  return;
}
}
void tty_setcol(tty_t *tty , int col ) 
{ 


  {
  tty_printf(tty, "%c%c%iG", 27, '[', col + 1);
  return;
}
}
void tty_moveup(tty_t *tty , int i ) 
{ 


  {
  tty_printf(tty, "%c%c%iA", 27, '[', i);
  return;
}
}
void tty_printf(tty_t *tty , char const   *fmt  , ...) 
{ 
  va_list___0 args ;

  {
  __builtin_va_start(args, fmt);
  vfprintf((FILE * __restrict  )tty->fout, (char const   * __restrict  )fmt, args);
  __builtin_va_end(args);
  return;
}
}
void tty_putc(tty_t *tty , char c ) 
{ 


  {
  fputc((int )c, tty->fout);
  return;
}
}
void tty_flush(tty_t *tty ) 
{ 


  {
  fflush(tty->fout);
  return;
}
}
size_t tty_getwidth(tty_t *tty ) 
{ 


  {
  return (tty->maxwidth);
}
}
size_t tty_getheight(tty_t *tty ) 
{ 


  {
  return (tty->maxheight);
}
}
#pragma merger("0","/tmp/cil-eFJMl0bf.i","-Wall,-Wextra,-g,-std=c99,-O3,-pedantic,-Werror=vla")
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1))) strchr)(char const   *__s ,
                                                                                     int __c )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                                                   pthread_t __thread2 )  __attribute__((__const__)) ;
__inline extern int ( __attribute__((__gnu_inline__)) pthread_equal)(pthread_t __thread1 ,
                                                                     pthread_t __thread2 ) 
{ 


  {
  return (__thread1 == __thread2);
}
}
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
void choices_add(choices_t *c , char const   *choice ) ;
void choices_prev(choices_t *c ) ;
void choices_next(choices_t *c ) ;
static int cmpchoice(void const   *_idx1 , void const   *_idx2 ) 
{ 
  struct scored_result  const  *a ;
  struct scored_result  const  *b ;

  {
  a = (struct scored_result  const  *)_idx1;
  b = (struct scored_result  const  *)_idx2;
  if (a->score == b->score) {
    if ((unsigned long )a->str < (unsigned long )b->str) {
      return (-1);
    } else {
      return (1);
    }
  } else
  if (a->score < b->score) {
    return (1);
  } else {
    return (-1);
  }
}
}
static void *safe_realloc(void *buffer , size_t size ) 
{ 


  {
  buffer = realloc(buffer, size);
  if (! buffer) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: Can\'t allocate memory (%zu bytes)\n",
            size);
    abort();
  }
  return (buffer);
}
}
void choices_fread(choices_t *c , FILE *file , char input_delimiter ) 
{ 
  size_t buffer_start ;
  size_t capacity ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  char const   *line_end ;
  char *line ;
  char *nl ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  buffer_start = c->buffer_size;
  capacity = (size_t )4096;
  while (capacity <= c->buffer_size) {
    capacity *= 2UL;
  }
  tmp = safe_realloc((void *)c->buffer, capacity);
  c->buffer = (char *)tmp;
  while (1) {
    tmp___1 = fread((void * __restrict  )(c->buffer + c->buffer_size), (size_t )1,
                    capacity - c->buffer_size, (FILE * __restrict  )file);
    tmp___2 = c->buffer_size + tmp___1;
    c->buffer_size = tmp___2;
    if (! (tmp___2 == capacity)) {
      break;
    }
    capacity *= 2UL;
    tmp___0 = safe_realloc((void *)c->buffer, capacity);
    c->buffer = (char *)tmp___0;
  }
  tmp___3 = safe_realloc((void *)c->buffer, c->buffer_size + 1UL);
  c->buffer = (char *)tmp___3;
  tmp___4 = c->buffer_size;
  (c->buffer_size) ++;
  *(c->buffer + tmp___4) = (char )'\000';
  line_end = (char const   *)(c->buffer + c->buffer_size);
  line = c->buffer + buffer_start;
  while (1) {
    tmp___5 = strchr((char const   *)line, (int )input_delimiter);
    nl = tmp___5;
    if (nl) {
      tmp___6 = nl;
      nl ++;
      *tmp___6 = (char )'\000';
    }
    if (*line) {
      choices_add(c, (char const   *)line);
    }
    line = nl;
    if (line) {
      if (! ((unsigned long )line < (unsigned long )line_end)) {
        break;
      }
    } else {
      break;
    }
  }
  return;
}
}
static void choices_resize(choices_t *c , size_t new_capacity ) 
{ 
  void *tmp ;

  {
  tmp = safe_realloc((void *)c->strings, new_capacity * sizeof(char const   *));
  c->strings = (char const   **)tmp;
  c->capacity = new_capacity;
  return;
}
}
static void choices_reset_search(choices_t *c ) 
{ 
  size_t tmp ;

  {
  free((void *)c->results);
  tmp = (size_t )0;
  c->available = tmp;
  c->selection = tmp;
  c->results = (struct scored_result *)((void *)0);
  return;
}
}
void choices_init(choices_t *c , options_t *options ) 
{ 
  size_t tmp ;
  long tmp___0 ;

  {
  c->strings = (char const   **)((void *)0);
  c->results = (struct scored_result *)((void *)0);
  c->buffer_size = (size_t )0;
  c->buffer = (char *)((void *)0);
  tmp = (size_t )0;
  c->size = tmp;
  c->capacity = tmp;
  choices_resize(c, (size_t )128);
  if (options->workers) {
    c->worker_count = options->workers;
  } else {
    tmp___0 = sysconf(84);
    c->worker_count = (unsigned int )((int )tmp___0);
  }
  choices_reset_search(c);
  return;
}
}
void choices_destroy(choices_t *c ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
  free((void *)c->buffer);
  c->buffer = (char *)((void *)0);
  c->buffer_size = (size_t )0;
  free((void *)c->strings);
  c->strings = (char const   **)((void *)0);
  tmp = (size_t )0;
  c->size = tmp;
  c->capacity = tmp;
  free((void *)c->results);
  c->results = (struct scored_result *)((void *)0);
  tmp___0 = (size_t )0;
  c->selection = tmp___0;
  c->available = tmp___0;
  return;
}
}
void choices_add(choices_t *c , char const   *choice ) 
{ 
  size_t tmp ;

  {
  choices_reset_search(c);
  if (c->size == c->capacity) {
    choices_resize(c, c->capacity * 2UL);
  }
  tmp = c->size;
  (c->size) ++;
  *(c->strings + tmp) = choice;
  return;
}
}
size_t choices_available(choices_t *c ) 
{ 


  {
  return (c->available);
}
}
static void worker_get_next_batch(struct search_job *job , size_t *start , size_t *end ) 
{ 


  {
  pthread_mutex_lock(& job->lock);
  *start = job->processed;
  job->processed += 512UL;
  if (job->processed > (job->choices)->size) {
    job->processed = (job->choices)->size;
  }
  *end = job->processed;
  pthread_mutex_unlock(& job->lock);
  return;
}
}
static struct result_list merge2(struct result_list list1 , struct result_list list2 ) 
{ 
  size_t result_index ;
  size_t index1 ;
  size_t index2 ;
  struct result_list result ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
  result_index = (size_t )0;
  index1 = (size_t )0;
  index2 = (size_t )0;
  result.size = list1.size + list2.size;
  tmp = malloc(result.size * sizeof(struct scored_result ));
  result.list = (struct scored_result *)tmp;
  if (! result.list) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: Can\'t allocate memory\n");
    abort();
  }
  while (1) {
    if (index1 < list1.size) {
      if (! (index2 < list2.size)) {
        break;
      }
    } else {
      break;
    }
    tmp___4 = cmpchoice((void const   *)(list1.list + index1), (void const   *)(list2.list + index2));
    if (tmp___4 < 0) {
      tmp___0 = result_index;
      result_index ++;
      tmp___1 = index1;
      index1 ++;
      *(result.list + tmp___0) = *(list1.list + tmp___1);
    } else {
      tmp___2 = result_index;
      result_index ++;
      tmp___3 = index2;
      index2 ++;
      *(result.list + tmp___2) = *(list2.list + tmp___3);
    }
  }
  while (index1 < list1.size) {
    tmp___5 = result_index;
    result_index ++;
    tmp___6 = index1;
    index1 ++;
    *(result.list + tmp___5) = *(list1.list + tmp___6);
  }
  while (index2 < list2.size) {
    tmp___7 = result_index;
    result_index ++;
    tmp___8 = index2;
    index2 ++;
    *(result.list + tmp___7) = *(list2.list + tmp___8);
  }
  free((void *)list1.list);
  free((void *)list2.list);
  return (result);
}
}
static void *choices_search_worker(void *data ) 
{ 
  struct worker *w ;
  struct search_job *job ;
  choices_t const   *c ;
  struct result_list *result ;
  size_t start ;
  size_t end ;
  size_t i ;
  int tmp ;
  unsigned int step ;
  unsigned int next_worker ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  w = (struct worker *)data;
  job = w->job;
  c = (choices_t const   *)job->choices;
  result = & w->result;
  while (1) {
    worker_get_next_batch(job, & start, & end);
    if (start == end) {
      break;
    }
    i = start;
    while (i < end) {
      tmp = has_match(job->search, *(c->strings + i));
      if (tmp) {
        (result->list + result->size)->str = *(c->strings + i);
        (result->list + result->size)->score = match(job->search, *(c->strings + i));
        (result->size) ++;
      }
      i ++;
    }
  }
  qsort((void *)result->list, result->size, sizeof(struct scored_result ), & cmpchoice);
  step = 0U;
  while (! (w->worker_num % (unsigned int )(2 << step))) {
    next_worker = w->worker_num | (unsigned int )(1 << step);
    if (next_worker >= (unsigned int )c->worker_count) {
      break;
    }
    tmp___0 = __errno_location();
    tmp___1 = pthread_join((job->workers + next_worker)->thread_id, (void **)((void *)0));
    *tmp___0 = tmp___1;
    if (tmp___1) {
      perror("pthread_join");
      exit(1);
    }
    w->result = merge2(w->result, (job->workers + next_worker)->result);
    step ++;
  }
  return ((void *)0);
}
}
void choices_search(choices_t *c , char const   *search ) 
{ 
  struct search_job *job ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  struct worker *workers ;
  int i ;
  void *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  choices_reset_search(c);
  tmp = calloc((size_t )1, sizeof(struct search_job ));
  job = (struct search_job *)tmp;
  job->search = search;
  job->choices = c;
  tmp___0 = pthread_mutex_init(& job->lock, (pthread_mutexattr_t const   *)((void *)0));
  if (tmp___0 != 0) {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: pthread_mutex_init failed\n");
    abort();
  }
  tmp___1 = calloc((size_t )c->worker_count, sizeof(struct worker ));
  job->workers = (struct worker *)tmp___1;
  workers = job->workers;
  i = (int )(c->worker_count - 1U);
  while (i >= 0) {
    (workers + i)->job = job;
    (workers + i)->worker_num = (unsigned int )i;
    (workers + i)->result.size = (size_t )0;
    tmp___2 = malloc(c->size * sizeof(struct scored_result ));
    (workers + i)->result.list = (struct scored_result *)tmp___2;
    tmp___3 = __errno_location();
    tmp___4 = pthread_create((pthread_t * __restrict  )(& (workers + i)->thread_id),
                             (pthread_attr_t const   * __restrict  )((void *)0), & choices_search_worker,
                             (void * __restrict  )(workers + i));
    *tmp___3 = tmp___4;
    if (tmp___4) {
      perror("pthread_create");
      exit(1);
    }
    i --;
  }
  tmp___5 = pthread_join((workers + 0)->thread_id, (void **)((void *)0));
  if (tmp___5) {
    perror("pthread_join");
    exit(1);
  }
  c->results = (workers + 0)->result.list;
  c->available = (workers + 0)->result.size;
  free((void *)workers);
  pthread_mutex_destroy(& job->lock);
  free((void *)job);
  return;
}
}
char const   *choices_get(choices_t *c , size_t n ) 
{ 


  {
  if (n < c->available) {
    return ((c->results + n)->str);
  } else {
    return ((char const   *)((void *)0));
  }
}
}
score_t choices_getscore(choices_t *c , size_t n ) 
{ 


  {
  return ((c->results + n)->score);
}
}
void choices_prev(choices_t *c ) 
{ 


  {
  if (c->available) {
    c->selection = ((c->selection + c->available) - 1UL) % c->available;
  }
  return;
}
}
void choices_next(choices_t *c ) 
{ 


  {
  if (c->available) {
    c->selection = (c->selection + 1UL) % c->available;
  }
  return;
}
}
#pragma merger("0","/tmp/cil-DFDTnt56.i","-Wall,-Wextra,-g,-std=c99,-O3,-pedantic,-Werror=vla")
extern char *optarg ;
extern int optind ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3))) getopt_long)(int ___argc ,
                                                                                          char * const  *___argv ,
                                                                                          char const   *__shortopts ,
                                                                                          struct option  const  *__longopts ,
                                                                                          int *__longind ) ;
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...)  __asm__("__isoc99_sscanf")  ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strcmp)(char const   *__s1 ,
                                                                                     char const   *__s2 )  __attribute__((__pure__)) ;
void options_init(options_t *options ) ;
static char const   *usage_str  =    "Usage: fzy [OPTION]...\n -l, --lines=LINES        Specify how many lines of results to show (default 10)\n -p, --prompt=PROMPT      Input prompt (default \'> \')\n -q, --query=QUERY        Use QUERY as the initial search string\n -e, --show-matches=QUERY Output the sorted matches of QUERY\n -t, --tty=TTY            Specify file to use as TTY device (default /dev/tty)\n -s, --show-scores        Show the scores of each match\n -0, --read-null          Read input delimited by ASCII NUL characters\n -j, --workers NUM        Use NUM workers for searching. (default is # of CPUs)\n -i, --show-info          Show selection info line\n -h, --help     Display this help and exit\n -v, --version  Output version information and exit\n";
static void usage(char const   *argv0 ) 
{ 


  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )usage_str, argv0);
  return;
}
}
static struct option longopts[13]  = 
  {      {"show-matches", 1, (int *)((void *)0), 'e'}, 
        {"query", 1, (int *)((void *)0), 'q'}, 
        {"lines", 1, (int *)((void *)0), 'l'}, 
        {"tty", 1, (int *)((void *)0), 't'}, 
        {"prompt", 1, (int *)((void *)0), 'p'}, 
        {"show-scores", 0, (int *)((void *)0), 's'}, 
        {"read-null", 0, (int *)((void *)0), '0'}, 
        {"version", 0, (int *)((void *)0), 'v'}, 
        {"benchmark", 2, (int *)((void *)0), 'b'}, 
        {"workers", 1, (int *)((void *)0), 'j'}, 
        {"show-info", 0, (int *)((void *)0), 'i'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
void options_init(options_t *options ) 
{ 


  {
  options->benchmark = 0;
  options->filter = (char const   *)((void *)0);
  options->init_search = (char const   *)((void *)0);
  options->show_scores = 0;
  options->scrolloff = 1U;
  options->tty_filename = "/dev/tty";
  options->num_lines = 10U;
  options->prompt = "> ";
  options->workers = 0U;
  options->input_delimiter = (char )'\n';
  options->show_info = 0;
  return;
}
}
void options_parse(options_t *options , int argc , char **argv ) 
{ 
  int c ;
  int tmp ;
  int tmp___0 ;
  int l ;
  int tmp___1 ;
  int tmp___2 ;

  {
  options_init(options);
  while (1) {
    c = getopt_long(argc, (char * const  *)argv, "vhs0e:q:l:t:p:j:i", (struct option  const  *)(longopts),
                    (int *)((void *)0));
    if (! (c != -1)) {
      break;
    }
    switch (c) {
    case 118: 
    printf((char const   * __restrict  )"%s 1.0 \302\251 2014-2018 John Hawthorn\n",
           *(argv + 0));
    exit(0);
    case 115: 
    options->show_scores = 1;
    break;
    case 48: 
    options->input_delimiter = (char )'\000';
    break;
    case 113: 
    options->init_search = (char const   *)optarg;
    break;
    case 101: 
    options->filter = (char const   *)optarg;
    break;
    case 98: 
    if (optarg) {
      tmp = sscanf((char const   * __restrict  )optarg, (char const   * __restrict  )"%d",
                   & options->benchmark);
      if (tmp != 1) {
        usage((char const   *)*(argv + 0));
        exit(1);
      }
    } else {
      options->benchmark = 100;
    }
    break;
    case 116: 
    options->tty_filename = (char const   *)optarg;
    break;
    case 112: 
    options->prompt = (char const   *)optarg;
    break;
    case 106: 
    tmp___0 = sscanf((char const   * __restrict  )optarg, (char const   * __restrict  )"%u",
                     & options->workers);
    if (tmp___0 != 1) {
      usage((char const   *)*(argv + 0));
      exit(1);
    }
    break;
    case 108: 
    tmp___2 = strcmp((char const   *)optarg, "max");
    if (tmp___2) {
      tmp___1 = sscanf((char const   * __restrict  )optarg, (char const   * __restrict  )"%d",
                       & l);
      if (tmp___1 != 1) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid format for --lines: %s\n",
                optarg);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Must be integer in range 3..\n");
        usage((char const   *)*(argv + 0));
        exit(1);
      } else
      if (l < 3) {
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Invalid format for --lines: %s\n",
                optarg);
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Must be integer in range 3..\n");
        usage((char const   *)*(argv + 0));
        exit(1);
      }
    } else {
      l = 2147483647;
    }
    options->num_lines = (unsigned int )l;
    break;
    case 105: 
    options->show_info = 1;
    break;
    default: 
    usage((char const   *)*(argv + 0));
    exit(0);
    }
  }
  if (optind != argc) {
    usage((char const   *)*(argv + 0));
    exit(1);
  }
  return;
}
}
#pragma merger("0","/tmp/cil-Z0QrBiGH.i","-Wall,-Wextra,-g,-std=c99,-O3,-pedantic,-Werror=vla")
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memmove)(void *__dest ,
                                                                                        void const   *__src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcpy)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strncpy)(char * __restrict  __dest ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __n ) ;
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2))) strcat)(char * __restrict  __dest ,
                                                                                       char const   * __restrict  __src ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) strncmp)(char const   *__s1 ,
                                                                                      char const   *__s2 ,
                                                                                      size_t __n )  __attribute__((__pure__)) ;
static int isprint_unicode(char c ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
  tmp = __ctype_b_loc();
  if ((int const   )*(*tmp + (int )c) & 16384) {
    tmp___0 = 1;
  } else
  if ((int )c & (1 << 7)) {
    tmp___0 = 1;
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
static int is_boundary(char c ) 
{ 
  int tmp ;

  {
  if (~ ((int )c) & (1 << 7)) {
    tmp = 1;
  } else
  if ((int )c & (1 << 6)) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
static void clear(tty_interface_t *state ) 
{ 
  tty_t *tty ;
  size_t line ;
  size_t tmp ;
  int tmp___0 ;

  {
  tty = state->tty;
  tty_setcol(tty, 0);
  line = (size_t )0;
  while (1) {
    tmp = line;
    line ++;
    if ((state->options)->show_info) {
      tmp___0 = 1;
    } else {
      tmp___0 = 0;
    }
    if (! (tmp < (size_t )((state->options)->num_lines + (unsigned int )tmp___0))) {
      break;
    }
    tty_newline(tty);
  }
  tty_clearline(tty);
  if ((state->options)->num_lines > 0U) {
    tty_moveup(tty, (int )(line - 1UL));
  }
  tty_flush(tty);
  return;
}
}
static void draw_match(tty_interface_t *state , char const   *choice , int selected ) 
{ 
  tty_t *tty ;
  options_t *options ;
  char *search ;
  int n ;
  size_t tmp ;
  size_t positions[1024] ;
  int i ;
  score_t score ;
  score_t tmp___0 ;
  float tmp___1 ;
  size_t i___0 ;
  size_t p ;

  {
  tty = state->tty;
  options = state->options;
  search = state->last_search;
  tmp = strlen((char const   *)search);
  n = (int )tmp;
  i = 0;
  while (1) {
    if (i < n + 1) {
      if (! (i < 1024)) {
        break;
      }
    } else {
      break;
    }
    positions[i] = (size_t )-1;
    i ++;
  }
  tmp___0 = match_positions((char const   *)search, choice, & positions[0]);
  score = tmp___0;
  if (options->show_scores) {
    tmp___1 = __builtin_inff();
    if (score == (score_t )(- tmp___1)) {
      tty_printf(tty, "(     ) ");
    } else {
      tty_printf(tty, "(%5.2f) ", score);
    }
  }
  if (selected) {
    tty_setinvert(tty);
  }
  tty_setnowrap(tty);
  i___0 = (size_t )0;
  p = (size_t )0;
  while ((int const   )*(choice + i___0) != 0) {
    if (positions[p] == i___0) {
      tty_setfg(tty, 3);
      p ++;
    } else {
      tty_setfg(tty, 9);
    }
    if ((int const   )*(choice + i___0) == 10) {
      tty_putc(tty, (char )' ');
    } else {
      tty_printf(tty, "%c", (int const   )*(choice + i___0));
    }
    i___0 ++;
  }
  tty_setwrap(tty);
  tty_setnormal(tty);
  return;
}
}
static void draw(tty_interface_t *state ) 
{ 
  tty_t *tty ;
  choices_t *choices ;
  options_t *options ;
  unsigned int num_lines ;
  size_t start ;
  size_t current_selection ;
  size_t available ;
  size_t tmp ;
  size_t i ;
  char const   *choice ;
  char const   *tmp___0 ;
  size_t i___0 ;

  {
  tty = state->tty;
  choices = state->choices;
  options = state->options;
  num_lines = options->num_lines;
  start = (size_t )0;
  current_selection = choices->selection;
  if (current_selection + (size_t )options->scrolloff >= (size_t )num_lines) {
    start = ((current_selection + (size_t )options->scrolloff) - (size_t )num_lines) + 1UL;
    tmp = choices_available(choices);
    available = tmp;
    if (start + (size_t )num_lines >= available) {
      if (available > 0UL) {
        start = available - (size_t )num_lines;
      }
    }
  }
  tty_setcol(tty, 0);
  tty_printf(tty, "%s%s", options->prompt, state->search);
  tty_clearline(tty);
  if (options->show_info) {
    tty_printf(tty, "\n[%lu/%lu]", choices->available, choices->size);
    tty_clearline(tty);
  }
  i = start;
  while (i < start + (size_t )num_lines) {
    tty_printf(tty, "\n");
    tty_clearline(tty);
    tmp___0 = choices_get(choices, i);
    choice = tmp___0;
    if (choice) {
      draw_match(state, choice, i == choices->selection);
    }
    i ++;
  }
  if (num_lines + (unsigned int )options->show_info) {
    tty_moveup(tty, (int )(num_lines + (unsigned int )options->show_info));
  }
  tty_setcol(tty, 0);
  fputs((char const   * __restrict  )options->prompt, (FILE * __restrict  )tty->fout);
  i___0 = (size_t )0;
  while (i___0 < state->cursor) {
    fputc((int )state->search[i___0], tty->fout);
    i___0 ++;
  }
  tty_flush(tty);
  return;
}
}
static void update_search(tty_interface_t *state ) 
{ 


  {
  choices_search(state->choices, (char const   *)(state->search));
  strcpy((char * __restrict  )(state->last_search), (char const   * __restrict  )(state->search));
  return;
}
}
static void update_state(tty_interface_t *state ) 
{ 
  int tmp ;

  {
  tmp = strcmp((char const   *)(state->last_search), (char const   *)(state->search));
  if (tmp) {
    update_search(state);
    draw(state);
  }
  return;
}
}
static void action_emit(tty_interface_t *state ) 
{ 
  char const   *selection ;
  char const   *tmp ;

  {
  update_state(state);
  clear(state);
  tty_close(state->tty);
  tmp = choices_get(state->choices, (state->choices)->selection);
  selection = tmp;
  if (selection) {
    printf((char const   * __restrict  )"%s\n", selection);
  } else {
    printf((char const   * __restrict  )"%s\n", state->search);
  }
  state->exit = 0;
  return;
}
}
static void action_del_char(tty_interface_t *state ) 
{ 
  size_t length ;
  size_t tmp ;
  size_t original_cursor ;
  int tmp___0 ;

  {
  tmp = strlen((char const   *)(state->search));
  length = tmp;
  if (state->cursor == 0UL) {
    return;
  }
  original_cursor = state->cursor;
  while (1) {
    (state->cursor) --;
    tmp___0 = is_boundary(state->search[state->cursor]);
    if (tmp___0) {
      break;
    } else
    if (! state->cursor) {
      break;
    }
  }
  memmove((void *)(& state->search[state->cursor]), (void const   *)(& state->search[original_cursor]),
          (length - original_cursor) + 1UL);
  return;
}
}
static void action_del_word(tty_interface_t *state ) 
{ 
  size_t original_cursor ;
  size_t cursor ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;

  {
  original_cursor = state->cursor;
  cursor = state->cursor;
  while (1) {
    if (cursor) {
      tmp = __ctype_b_loc();
      if (! ((int const   )*(*tmp + (int )state->search[cursor - 1UL]) & 8192)) {
        break;
      }
    } else {
      break;
    }
    cursor --;
  }
  while (1) {
    if (cursor) {
      tmp___0 = __ctype_b_loc();
      if ((int const   )*(*tmp___0 + (int )state->search[cursor - 1UL]) & 8192) {
        break;
      }
    } else {
      break;
    }
    cursor --;
  }
  tmp___1 = strlen((char const   *)(state->search));
  memmove((void *)(& state->search[cursor]), (void const   *)(& state->search[original_cursor]),
          (tmp___1 - original_cursor) + 1UL);
  state->cursor = cursor;
  return;
}
}
static void action_del_all(tty_interface_t *state ) 
{ 
  size_t tmp ;

  {
  tmp = strlen((char const   *)(state->search));
  memmove((void *)(state->search), (void const   *)(& state->search[state->cursor]),
          (tmp - state->cursor) + 1UL);
  state->cursor = (size_t )0;
  return;
}
}
static void action_prev(tty_interface_t *state ) 
{ 


  {
  update_state(state);
  choices_prev(state->choices);
  return;
}
}
static void action_ignore(tty_interface_t *state ) 
{ 


  {
  return;
}
}
static void action_next(tty_interface_t *state ) 
{ 


  {
  update_state(state);
  choices_next(state->choices);
  return;
}
}
static void action_left(tty_interface_t *state ) 
{ 
  int tmp ;

  {
  if (state->cursor > 0UL) {
    (state->cursor) --;
    while (1) {
      tmp = is_boundary(state->search[state->cursor]);
      if (tmp) {
        break;
      } else
      if (! state->cursor) {
        break;
      }
      (state->cursor) --;
    }
  }
  return;
}
}
static void action_right(tty_interface_t *state ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  tmp___0 = strlen((char const   *)(state->search));
  if (state->cursor < tmp___0) {
    (state->cursor) ++;
    while (1) {
      tmp = is_boundary(state->search[state->cursor]);
      if (tmp) {
        break;
      }
      (state->cursor) ++;
    }
  }
  return;
}
}
static void action_beginning(tty_interface_t *state ) 
{ 


  {
  state->cursor = (size_t )0;
  return;
}
}
static void action_end(tty_interface_t *state ) 
{ 


  {
  state->cursor = strlen((char const   *)(state->search));
  return;
}
}
static void action_pageup(tty_interface_t *state ) 
{ 
  size_t i ;

  {
  update_state(state);
  i = (size_t )0;
  while (1) {
    if (i < (size_t )(state->options)->num_lines) {
      if (! ((state->choices)->selection > 0UL)) {
        break;
      }
    } else {
      break;
    }
    choices_prev(state->choices);
    i ++;
  }
  return;
}
}
static void action_pagedown(tty_interface_t *state ) 
{ 
  size_t i ;

  {
  update_state(state);
  i = (size_t )0;
  while (1) {
    if (i < (size_t )(state->options)->num_lines) {
      if (! ((state->choices)->selection < (state->choices)->available - 1UL)) {
        break;
      }
    } else {
      break;
    }
    choices_next(state->choices);
    i ++;
  }
  return;
}
}
static void action_autocomplete(tty_interface_t *state ) 
{ 
  char const   *current_selection ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  update_state(state);
  tmp = choices_get(state->choices, (state->choices)->selection);
  current_selection = tmp;
  if (current_selection) {
    tmp___0 = choices_get(state->choices, (state->choices)->selection);
    strncpy((char * __restrict  )(state->search), (char const   * __restrict  )tmp___0,
            (size_t )4096);
    state->cursor = strlen((char const   *)(state->search));
  }
  return;
}
}
static void action_exit(tty_interface_t *state ) 
{ 


  {
  clear(state);
  tty_close(state->tty);
  state->exit = 1;
  return;
}
}
static void append_search(tty_interface_t *state , char ch ) 
{ 
  char *search ;
  size_t search_size ;
  size_t tmp ;

  {
  search = state->search;
  tmp = strlen((char const   *)search);
  search_size = tmp;
  if (search_size < 4096UL) {
    memmove((void *)(search + (state->cursor + 1UL)), (void const   *)(search + state->cursor),
            (search_size - state->cursor) + 1UL);
    *(search + state->cursor) = ch;
    (state->cursor) ++;
  }
  return;
}
}
void tty_interface_init(tty_interface_t *state , tty_t *tty , choices_t *choices ,
                        options_t *options ) 
{ 


  {
  state->tty = tty;
  state->choices = choices;
  state->options = options;
  state->ambiguous_key_pending = 0;
  strcpy((char * __restrict  )(state->input), (char const   * __restrict  )"");
  strcpy((char * __restrict  )(state->search), (char const   * __restrict  )"");
  strcpy((char * __restrict  )(state->last_search), (char const   * __restrict  )"");
  state->exit = -1;
  if (options->init_search) {
    strncpy((char * __restrict  )(state->search), (char const   * __restrict  )options->init_search,
            (size_t )4096);
  }
  state->cursor = strlen((char const   *)(state->search));
  update_search(state);
  return;
}
}
static char const   __constr_expr_0[2]  = {      (char const   )8,      (char const   )'\000'};
static char const   __constr_expr_1[2]  = {      (char const   )23,      (char const   )'\000'};
static char const   __constr_expr_2[2]  = {      (char const   )21,      (char const   )'\000'};
static char const   __constr_expr_3[2]  = {      (char const   )9,      (char const   )'\000'};
static char const   __constr_expr_4[2]  = {      (char const   )3,      (char const   )'\000'};
static char const   __constr_expr_5[2]  = {      (char const   )4,      (char const   )'\000'};
static char const   __constr_expr_6[2]  = {      (char const   )7,      (char const   )'\000'};
static char const   __constr_expr_7[2]  = {      (char const   )13,      (char const   )'\000'};
static char const   __constr_expr_8[2]  = {      (char const   )16,      (char const   )'\000'};
static char const   __constr_expr_9[2]  = {      (char const   )14,      (char const   )'\000'};
static char const   __constr_expr_10[2]  = {      (char const   )11,      (char const   )'\000'};
static char const   __constr_expr_11[2]  = {      (char const   )10,      (char const   )'\000'};
static char const   __constr_expr_12[2]  = {      (char const   )1,      (char const   )'\000'};
static char const   __constr_expr_13[2]  = {      (char const   )5,      (char const   )'\000'};
static keybinding_t const   keybindings[33]  = 
  {      {"\033", & action_exit}, 
        {"\177", & action_del_char}, 
        {__constr_expr_0, & action_del_char}, 
        {__constr_expr_1, & action_del_word}, 
        {__constr_expr_2, & action_del_all}, 
        {__constr_expr_3, & action_autocomplete}, 
        {__constr_expr_4, & action_exit}, 
        {__constr_expr_5, & action_exit}, 
        {__constr_expr_6, & action_exit}, 
        {__constr_expr_7, & action_emit}, 
        {__constr_expr_8, & action_prev}, 
        {__constr_expr_9, & action_next}, 
        {__constr_expr_10, & action_prev}, 
        {__constr_expr_11, & action_next}, 
        {__constr_expr_12, & action_beginning}, 
        {__constr_expr_13, & action_end}, 
        {"\033OD", & action_left}, 
        {"\033[D", & action_left}, 
        {"\033OC", & action_right}, 
        {"\033[C", & action_right}, 
        {"\033[1~", & action_beginning}, 
        {"\033[H", & action_beginning}, 
        {"\033[4~", & action_end}, 
        {"\033[F", & action_end}, 
        {"\033[A", & action_prev}, 
        {"\033OA", & action_prev}, 
        {"\033[B", & action_next}, 
        {"\033OB", & action_next}, 
        {"\033[5~", & action_pageup}, 
        {"\033[6~", & action_pagedown}, 
        {"\033[200~", & action_ignore}, 
        {"\033[201~", & action_ignore}, 
        {(char const   *)((void *)0), (void (*)(tty_interface_t * ))((void *)0)}};
static void handle_input(tty_interface_t *state , char const   *s , int handle_ambiguous_key ) 
{ 
  char *input ;
  int found_keybinding ;
  int in_middle ;
  int i ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int i___0 ;
  int tmp___2 ;

  {
  state->ambiguous_key_pending = 0;
  input = state->input;
  strcat((char * __restrict  )(state->input), (char const   * __restrict  )s);
  found_keybinding = -1;
  in_middle = 0;
  i = 0;
  while (keybindings[i].key) {
    tmp___1 = strcmp((char const   *)input, (char const   *)keybindings[i].key);
    if (tmp___1) {
      tmp = strlen((char const   *)(state->input));
      tmp___0 = strncmp((char const   *)input, (char const   *)keybindings[i].key,
                        tmp);
      if (! tmp___0) {
        in_middle = 1;
      }
    } else {
      found_keybinding = i;
    }
    i ++;
  }
  if (found_keybinding != -1) {
    if (! in_middle) {
      (*(keybindings[found_keybinding].action))(state);
      strcpy((char * __restrict  )input, (char const   * __restrict  )"");
      return;
    } else
    if (handle_ambiguous_key) {
      (*(keybindings[found_keybinding].action))(state);
      strcpy((char * __restrict  )input, (char const   * __restrict  )"");
      return;
    }
  }
  if (found_keybinding != -1) {
    if (in_middle) {
      state->ambiguous_key_pending = 1;
      return;
    }
  }
  if (in_middle) {
    return;
  }
  i___0 = 0;
  while (*(input + i___0)) {
    tmp___2 = isprint_unicode(*(input + i___0));
    if (tmp___2) {
      append_search(state, *(input + i___0));
    }
    i___0 ++;
  }
  strcpy((char * __restrict  )input, (char const   * __restrict  )"");
  return;
}
}
int tty_interface_run(tty_interface_t *state ) 
{ 
  int tmp ;
  char s[2] ;
  char tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char s___0[1] ;

  {
  draw(state);
  while (1) {
    while (1) {
      while (1) {
        tmp = tty_input_ready(state->tty, -1L, 1);
        if (tmp) {
          break;
        }
        draw(state);
      }
      tmp___0 = tty_getchar(state->tty);
      s[0] = tmp___0;
      s[1] = (char )'\000';
      handle_input(state, (char const   *)(s), 0);
      if (state->exit >= 0) {
        return (state->exit);
      }
      draw(state);
      if (state->ambiguous_key_pending) {
        tmp___1 = 25;
      } else {
        tmp___1 = 0;
      }
      tmp___2 = tty_input_ready(state->tty, (long )tmp___1, 0);
      if (! tmp___2) {
        break;
      }
    }
    if (state->ambiguous_key_pending) {
      s___0[0] = (char )'\000';
      handle_input(state, (char const   *)(s___0), 1);
      if (state->exit >= 0) {
        return (state->exit);
      }
    }
    update_state(state);
  }
  return (state->exit);
}
}
