/* Generated by CIL v. 1.8.2 */
/* print_CIL_Input is true */

typedef void (*__sighandler_t)(int  );
typedef unsigned int rmtU32;
typedef char const   *rmtPStr;
struct Remotery ;
typedef struct Remotery Remotery;
enum rmtError {
    RMT_ERROR_NONE = 0,
    RMT_ERROR_RECURSIVE_SAMPLE = 1,
    RMT_ERROR_UNKNOWN = 2,
    RMT_ERROR_INVALID_INPUT = 3,
    RMT_ERROR_RESOURCE_CREATE_FAIL = 4,
    RMT_ERROR_RESOURCE_ACCESS_FAIL = 5,
    RMT_ERROR_TIMEOUT = 6,
    RMT_ERROR_MALLOC_FAIL = 7,
    RMT_ERROR_TLS_ALLOC_FAIL = 8,
    RMT_ERROR_VIRTUAL_MEMORY_BUFFER_FAIL = 9,
    RMT_ERROR_CREATE_THREAD_FAIL = 10,
    RMT_ERROR_OPEN_THREAD_HANDLE_FAIL = 11,
    RMT_ERROR_SOCKET_INVALID_POLL = 12,
    RMT_ERROR_SOCKET_SELECT_FAIL = 13,
    RMT_ERROR_SOCKET_POLL_ERRORS = 14,
    RMT_ERROR_SOCKET_SEND_FAIL = 15,
    RMT_ERROR_SOCKET_RECV_NO_DATA = 16,
    RMT_ERROR_SOCKET_RECV_TIMEOUT = 17,
    RMT_ERROR_SOCKET_RECV_FAILED = 18,
    RMT_ERROR_WEBSOCKET_HANDSHAKE_NOT_GET = 19,
    RMT_ERROR_WEBSOCKET_HANDSHAKE_NO_VERSION = 20,
    RMT_ERROR_WEBSOCKET_HANDSHAKE_BAD_VERSION = 21,
    RMT_ERROR_WEBSOCKET_HANDSHAKE_NO_HOST = 22,
    RMT_ERROR_WEBSOCKET_HANDSHAKE_BAD_HOST = 23,
    RMT_ERROR_WEBSOCKET_HANDSHAKE_NO_KEY = 24,
    RMT_ERROR_WEBSOCKET_HANDSHAKE_BAD_KEY = 25,
    RMT_ERROR_WEBSOCKET_HANDSHAKE_STRING_FAIL = 26,
    RMT_ERROR_WEBSOCKET_DISCONNECTED = 27,
    RMT_ERROR_WEBSOCKET_BAD_FRAME_HEADER = 28,
    RMT_ERROR_WEBSOCKET_BAD_FRAME_HEADER_SIZE = 29,
    RMT_ERROR_WEBSOCKET_BAD_FRAME_HEADER_MASK = 30,
    RMT_ERROR_WEBSOCKET_RECEIVE_TIMEOUT = 31,
    RMT_ERROR_REMOTERY_NOT_CREATED = 32,
    RMT_ERROR_SEND_ON_INCOMPLETE_PROFILE = 33,
    RMT_ERROR_CUDA_DEINITIALIZED = 34,
    RMT_ERROR_CUDA_NOT_INITIALIZED = 35,
    RMT_ERROR_CUDA_INVALID_CONTEXT = 36,
    RMT_ERROR_CUDA_INVALID_VALUE = 37,
    RMT_ERROR_CUDA_INVALID_HANDLE = 38,
    RMT_ERROR_CUDA_OUT_OF_MEMORY = 39,
    RMT_ERROR_ERROR_NOT_READY = 40,
    RMT_ERROR_D3D11_FAILED_TO_CREATE_QUERY = 41,
    RMT_ERROR_OPENGL_ERROR = 42,
    RMT_ERROR_CUDA_UNKNOWN = 43
} ;
typedef enum rmtError rmtError;
typedef unsigned int rmtBool;
typedef unsigned char rmtU8;
typedef unsigned short rmtU16;
typedef unsigned long long rmtU64;
typedef char rmtS8;
typedef int rmtS32;
typedef long long rmtS64;
typedef float rmtF32;
typedef double rmtF64;
struct Msg_SampleTree ;
typedef struct Msg_SampleTree rmtSampleTree;
struct Sample ;
typedef struct Sample rmtSample;
struct rmtProperty ;
enum rmtSampleType {
    RMT_SampleType_CPU = 0,
    RMT_SampleType_CUDA = 1,
    RMT_SampleType_D3D11 = 2,
    RMT_SampleType_D3D12 = 3,
    RMT_SampleType_OpenGL = 4,
    RMT_SampleType_Metal = 5,
    RMT_SampleType_Count = 6
} ;
typedef enum rmtSampleType rmtSampleType;
struct rmtSettings {
   rmtU16 port ;
   rmtBool reuse_open_port ;
   rmtBool limit_connections_to_localhost ;
   rmtBool enableThreadSampler ;
   rmtU32 msSleepBetweenServerUpdates ;
   rmtU32 messageQueueSizeInBytes ;
   rmtU32 maxNbMessagesPerUpdate ;
   void *(*malloc)(void *mm_context , rmtU32 size ) ;
   void *(*realloc)(void *mm_context , void *ptr , rmtU32 size ) ;
   void (*free)(void *mm_context , void *ptr ) ;
   void *mm_context ;
   void (*input_handler)(char const   *text , void *context ) ;
   void (*sampletree_handler)(void *cbk_context , rmtSampleTree *sample_tree ) ;
   void *sampletree_context ;
   void (*snapshot_callback)(void *cbk_context , struct rmtProperty *root ) ;
   void *snapshot_context ;
   void *input_handler_context ;
   rmtPStr logPath ;
};
typedef struct rmtSettings rmtSettings;
enum __anonenum_rmtPropertyFlags_993090800 {
    RMT_PropertyFlags_NoFlags = 0,
    RMT_PropertyFlags_FrameReset = 1
} ;
typedef enum __anonenum_rmtPropertyFlags_993090800 rmtPropertyFlags;
enum __anonenum_rmtPropertyType_767673012 {
    RMT_PropertyType_rmtGroup = 0,
    RMT_PropertyType_rmtBool = 1,
    RMT_PropertyType_rmtS32 = 2,
    RMT_PropertyType_rmtU32 = 3,
    RMT_PropertyType_rmtF32 = 4,
    RMT_PropertyType_rmtS64 = 5,
    RMT_PropertyType_rmtU64 = 6,
    RMT_PropertyType_rmtF64 = 7
} ;
typedef enum __anonenum_rmtPropertyType_767673012 rmtPropertyType;
union rmtPropertyValue {
   rmtBool Bool ;
   rmtS32 S32 ;
   rmtU32 U32 ;
   rmtF32 F32 ;
   rmtS64 S64 ;
   rmtU64 U64 ;
   rmtF64 F64 ;
};
typedef union rmtPropertyValue rmtPropertyValue;
struct rmtProperty {
   rmtBool initialised ;
   rmtPropertyType type ;
   rmtPropertyFlags flags ;
   rmtPropertyValue value ;
   rmtPropertyValue lastFrameValue ;
   rmtPropertyValue prevValue ;
   rmtU32 prevValueFrame ;
   char const   *name ;
   char const   *description ;
   rmtPropertyValue defaultValue ;
   struct rmtProperty *parent ;
   struct rmtProperty *firstChild ;
   struct rmtProperty *lastChild ;
   struct rmtProperty *nextSibling ;
   rmtU32 nameHash ;
   rmtU32 uniqueID ;
};
typedef struct rmtProperty rmtProperty;
struct rmtSampleIterator {
   rmtSample *sample ;
   rmtSample *initial ;
};
typedef struct rmtSampleIterator rmtSampleIterator;
struct rmtPropertyIterator {
   rmtProperty *property ;
   rmtProperty *initial ;
};
typedef struct rmtPropertyIterator rmtPropertyIterator;
typedef unsigned long size_t;
typedef int wchar_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long __off_t;
typedef long __off64_t;
typedef long __clock_t;
typedef long __time_t;
typedef unsigned int __useconds_t;
typedef long __suseconds_t;
typedef int __clockid_t;
typedef long __ssize_t;
typedef long __syscall_slong_t;
typedef unsigned int __socklen_t;
struct _IO_FILE ;
typedef struct _IO_FILE FILE;
struct _IO_marker ;
struct _IO_codecvt ;
struct _IO_wide_data ;
typedef void _IO_lock_t;
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   struct _IO_codecvt *_codecvt ;
   struct _IO_wide_data *_wide_data ;
   struct _IO_FILE *_freeres_list ;
   void *_freeres_buf ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef __ssize_t ssize_t;
typedef __clock_t clock_t;
typedef __time_t time_t;
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
typedef __clockid_t clockid_t;
typedef __int32_t int32_t;
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
typedef long __fd_mask;
struct __anonstruct_fd_set_356711149 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
typedef struct __anonstruct_fd_set_356711149 fd_set;
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
typedef struct __pthread_internal_list __pthread_list_t;
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
typedef unsigned long pthread_t;
union __anonunion_pthread_mutexattr_t_488594144 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_488594144 pthread_mutexattr_t;
typedef unsigned int pthread_key_t;
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
typedef union pthread_attr_t pthread_attr_t;
union __anonunion_pthread_mutex_t_335460617 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_335460617 pthread_mutex_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef unsigned long uintptr_t;
typedef __socklen_t socklen_t;
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
typedef uint32_t in_addr_t;
struct in_addr {
   in_addr_t s_addr ;
};
typedef uint16_t in_port_t;
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
typedef rmtU64 LARGE_INTEGER;
struct __anonstruct_usTimer_887188579 {
   LARGE_INTEGER counter_start ;
   double counter_scale ;
};
typedef struct __anonstruct_usTimer_887188579 usTimer;
typedef pthread_key_t rmtTLS;
typedef pthread_mutex_t rmtMutex;
typedef rmtS32 volatile   rmtAtomicS32;
typedef rmtU32 volatile   rmtAtomicU32;
struct VirtualMirrorBuffer {
   rmtU32 size ;
   rmtU8 *ptr ;
};
typedef struct VirtualMirrorBuffer VirtualMirrorBuffer;
typedef int errno_t;
typedef unsigned int r_size_t;
typedef uintptr_t rmtThreadId;
typedef pthread_t rmtThreadHandle;
typedef int rmtCpuContext;
struct Thread_t ;
typedef struct Thread_t rmtThread;
struct Thread_t {
   rmtThreadHandle handle ;
   rmtError (*callback)(rmtThread *thread ) ;
   void *param ;
   rmtError error ;
   rmtBool volatile   request_exit ;
};
struct ObjectLink_s {
   struct ObjectLink_s * volatile  next ;
};
typedef struct ObjectLink_s ObjectLink;
struct __anonstruct_ObjectAllocator_929114526 {
   rmtU32 object_size ;
   rmtError (*constructor)(void * ) ;
   void (*destructor)(void * ) ;
   rmtAtomicS32 nb_free ;
   rmtAtomicS32 nb_inuse ;
   rmtAtomicS32 nb_allocated ;
   ObjectLink *first_free ;
};
typedef struct __anonstruct_ObjectAllocator_929114526 ObjectAllocator;
struct __anonstruct_Buffer_678719378 {
   rmtU32 alloc_granularity ;
   rmtU32 bytes_allocated ;
   rmtU32 bytes_used ;
   rmtU8 *data ;
};
typedef struct __anonstruct_Buffer_678719378 Buffer;
union __anonunion_u_919609132 {
   unsigned int i ;
   unsigned char c[sizeof(unsigned int )] ;
};
union __anonunion_u_682901414 {
   double d ;
   unsigned char c[sizeof(double )] ;
};
struct __anonstruct_HashSlot_851742752 {
   rmtU32 key ;
   rmtU64 value ;
};
typedef struct __anonstruct_HashSlot_851742752 HashSlot;
struct __anonstruct_rmtHashTable_1056137675 {
   rmtU32 maxNbSlots ;
   rmtU32 nbSlots ;
   HashSlot *slots ;
};
typedef struct __anonstruct_rmtHashTable_1056137675 rmtHashTable;
struct __anonstruct_StringTable_515543109 {
   Buffer *text ;
   rmtHashTable *text_map ;
};
typedef struct __anonstruct_StringTable_515543109 StringTable;
typedef int SOCKET;
struct __anonstruct_TCPSocket_44120681 {
   SOCKET socket ;
};
typedef struct __anonstruct_TCPSocket_44120681 TCPSocket;
struct __anonstruct_SocketStatus_11743799 {
   rmtBool can_read ;
   rmtBool can_write ;
   rmtError error_state ;
};
typedef struct __anonstruct_SocketStatus_11743799 SocketStatus;
struct __anonstruct_SHA1_345707942 {
   rmtU8 data[20] ;
};
typedef struct __anonstruct_SHA1_345707942 SHA1;
enum WebSocketMode {
    WEBSOCKET_NONE = 0,
    WEBSOCKET_TEXT = 1,
    WEBSOCKET_BINARY = 2
} ;
union __anonunion_data_769749382 {
   rmtU8 mask[4] ;
   rmtU32 mask_u32 ;
};
struct __anonstruct_WebSocket_37999051 {
   TCPSocket *tcp_socket ;
   enum WebSocketMode mode ;
   rmtU32 frame_bytes_remaining ;
   rmtU32 mask_offset ;
   union __anonunion_data_769749382 data ;
};
typedef struct __anonstruct_WebSocket_37999051 WebSocket;
enum MessageID {
    MsgID_NotReady = 0,
    MsgID_AddToStringTable = 1,
    MsgID_LogText = 2,
    MsgID_SampleTree = 3,
    MsgID_ProcessorThreads = 4,
    MsgID_None = 5,
    MsgID_PropertySnapshot = 6,
    MsgID_Force32Bits = 4294967295U
} ;
typedef enum MessageID MessageID;
struct ThreadProfiler ;
struct Message {
   MessageID id ;
   rmtU32 payload_size ;
   struct ThreadProfiler *threadProfiler ;
   rmtU8 payload[1] ;
};
typedef struct Message Message;
struct rmtMessageQueue {
   rmtU32 size ;
   VirtualMirrorBuffer *data ;
   rmtAtomicU32 read_pos ;
   rmtAtomicU32 write_pos ;
};
typedef struct rmtMessageQueue rmtMessageQueue;
struct __anonstruct_Server_646260831 {
   WebSocket *listen_socket ;
   WebSocket *client_socket ;
   rmtU32 last_ping_time ;
   rmtU16 port ;
   rmtBool reuse_open_port ;
   rmtBool limit_connections_to_localhost ;
   Buffer *bin_buf ;
   rmtError (*receive_handler)(void * , char * , rmtU32  ) ;
   void *receive_handler_context ;
};
typedef struct __anonstruct_Server_646260831 Server;
struct Sample {
   ObjectLink Link ;
   enum rmtSampleType type ;
   rmtU32 name_hash ;
   rmtU32 unique_id ;
   rmtU8 uniqueColour[3] ;
   struct Sample *parent ;
   struct Sample *first_child ;
   struct Sample *last_child ;
   struct Sample *next_sibling ;
   rmtU32 nb_children ;
   rmtU64 us_start ;
   rmtU64 us_end ;
   rmtU64 us_length ;
   rmtU64 us_sampled_length ;
   rmtU64 usGpuIssueOnCpu ;
   rmtU32 call_count ;
   rmtU16 recurse_depth ;
   rmtU16 max_recurse_depth ;
};
typedef struct Sample Sample;
struct SampleTree {
   ObjectAllocator *allocator ;
   Sample *root ;
   Sample *currentParent ;
   rmtAtomicU32 msLastTreeSendTime ;
   rmtAtomicU32 treeBeingModified ;
   Sample *sendSampleOnClose ;
};
typedef struct SampleTree SampleTree;
struct Msg_SampleTree {
   Sample *rootSample ;
   ObjectAllocator *allocator ;
   rmtPStr threadName ;
   rmtU32 userData ;
   rmtBool partialTree ;
};
typedef struct Msg_SampleTree Msg_SampleTree;
struct Msg_AddToStringTable {
   rmtU32 hash ;
   rmtU32 length ;
};
typedef struct Msg_AddToStringTable Msg_AddToStringTable;
struct ThreadProfiler {
   rmtU64 registerBackup0 ;
   rmtU64 registerBackup1 ;
   rmtU64 registerBackup2 ;
   rmtAtomicS32 nbSamplesWithoutCallback ;
   rmtU32 processorIndex ;
   rmtU32 lastProcessorIndex ;
   rmtThreadId threadId ;
   rmtThreadHandle threadHandle ;
   char threadName[64] ;
   rmtU32 threadNameHash ;
   SampleTree *sampleTrees[6] ;
};
typedef struct ThreadProfiler ThreadProfiler;
struct ThreadProfilers {
   usTimer *timer ;
   rmtMessageQueue *mqToRmtThread ;
   void *compiledSampleFn ;
   rmtU32 compiledSampleFnSize ;
   rmtTLS threadProfilerTlsHandle ;
   ThreadProfiler threadProfilers[256] ;
   rmtAtomicU32 nbThreadProfilers ;
   rmtU32 maxNbThreadProfilers ;
   rmtMutex threadProfilerMutex ;
   rmtThread *threadSampleThread ;
   rmtThread *threadGatherThread ;
};
typedef struct ThreadProfilers ThreadProfilers;
struct Processor {
   ThreadProfiler *threadProfiler ;
   rmtU32 sampleCount ;
   rmtU64 sampleTime ;
};
typedef struct Processor Processor;
struct Msg_ProcessorThreads {
   rmtU64 messageIndex ;
   rmtU32 nbProcessors ;
   Processor processors[1] ;
};
typedef struct Msg_ProcessorThreads Msg_ProcessorThreads;
struct PropertySnapshot {
   ObjectLink Link ;
   rmtPropertyType type ;
   rmtPropertyValue value ;
   rmtPropertyValue prevValue ;
   rmtU32 prevValueFrame ;
   rmtU32 nameHash ;
   rmtU32 uniqueID ;
   rmtU8 depth ;
   rmtU32 nbChildren ;
   struct PropertySnapshot *nextSnapshot ;
};
typedef struct PropertySnapshot PropertySnapshot;
struct Msg_PropertySnapshot {
   PropertySnapshot *rootSnapshot ;
   rmtU32 nbSnapshots ;
   rmtU32 propertyFrame ;
};
typedef struct Msg_PropertySnapshot Msg_PropertySnapshot;
struct Remotery {
   Server *server ;
   usTimer timer ;
   rmtMessageQueue *mq_to_rmt_thread ;
   rmtThread *thread ;
   StringTable *string_table ;
   FILE *logfile ;
   void (*map_message_queue_fn)(Remotery *rmt , Message * ) ;
   void *map_message_queue_data ;
   ThreadProfilers *threadProfilers ;
   rmtMutex propertyMutex ;
   rmtProperty rootProperty ;
   ObjectAllocator *propertyAllocator ;
   rmtU32 propertyFrame ;
};
#pragma merger("0","/tmp/cil-XAv1Taj_.i","-pthread")
extern  __attribute__((__nothrow__)) int rand(void) ;
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
extern int printf(char const   * __restrict  __format  , ...) ;
enum rmtError _rmt_CreateGlobalInstance(Remotery **remotery ) ;
void _rmt_DestroyGlobalInstance(Remotery *remotery ) ;
void _rmt_LogText(rmtPStr text ) ;
void _rmt_BeginCPUSample(rmtPStr name , rmtU32 flags , rmtU32 *hash_cache ) ;
void _rmt_EndCPUSample(void) ;
void aggregateFunction(void) ;
static rmtU32 rmt_sample_hash_aggregate  =    (rmtU32 )0;
void aggregateFunction(void) 
{ 


  {
  _rmt_BeginCPUSample("aggregate", (rmtU32 )1, & rmt_sample_hash_aggregate);
  _rmt_EndCPUSample();
  return;
}
}
void recursiveFunction(int depth ) ;
static rmtU32 rmt_sample_hash_recursive  =    (rmtU32 )0;
void recursiveFunction(int depth ) 
{ 


  {
  _rmt_BeginCPUSample("recursive", (rmtU32 )2, & rmt_sample_hash_recursive);
  if (depth < 5) {
    recursiveFunction(depth + 1);
  }
  _rmt_EndCPUSample();
  return;
}
}
double delay(void) ;
static rmtU32 rmt_sample_hash_delay  =    (rmtU32 )0;
double delay(void) 
{ 
  int i ;
  int end ;
  double j ;
  int tmp ;
  double tmp___0 ;

  {
  j = (double )0;
  _rmt_BeginCPUSample("delay", (rmtU32 )0, & rmt_sample_hash_delay);
  i = 0;
  tmp = rand();
  end = tmp / 100;
  while (i < end) {
    tmp___0 = sin((double )i);
    j += tmp___0;
    i ++;
  }
  recursiveFunction(0);
  aggregateFunction();
  aggregateFunction();
  aggregateFunction();
  _rmt_EndCPUSample();
  return (j);
}
}
int sig  =    0;
void sigintHandler(int sig_num ) 
{ 


  {
  sig = sig_num;
  printf((char const   * __restrict  )"Interrupted\n");
  return;
}
}
int main(void) 
{ 
  Remotery *rmt ;
  rmtError error ;

  {
  signal(2, & sigintHandler);
  error = _rmt_CreateGlobalInstance(& rmt);
  if (0U != (unsigned int )error) {
    printf((char const   * __restrict  )"Error launching Remotery %d\n", (unsigned int )error);
    return (-1);
  }
  while (sig == 0) {
    _rmt_LogText("start profiling");
    delay();
    _rmt_LogText("end profiling");
  }
  _rmt_DestroyGlobalInstance(rmt);
  printf((char const   * __restrict  )"Cleaned up and quit\n");
  return (0);
}
}
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_add(...) ;  */
/* compiler builtin: 
   _Bool __sync_bool_compare_and_swap(...) ;  */
#pragma merger("0","/tmp/cil-oOB36fKS.i","-pthread")
rmtPStr rmt_GetLastErrorMessage(void) ;
void _rmt_PropertySetValue(rmtProperty *property ) ;
void _rmt_PropertyAddValue(rmtProperty *property , rmtPropertyValue add_value ) ;
rmtError _rmt_PropertySnapshotAll(void) ;
void _rmt_PropertyFrameResetAll(void) ;
rmtU32 _rmt_HashString32(char const   *s , int len , rmtU32 seed ) ;
rmtSettings *_rmt_Settings(void) ;
void _rmt_SetGlobalInstance(Remotery *remotery ) ;
Remotery *_rmt_GetGlobalInstance(void) ;
void _rmt_SetCurrentThreadName(rmtPStr thread_name ) ;
rmtError _rmt_MarkFrame(void) ;
void _rmt_IterateChildren(rmtSampleIterator *iterator , rmtSample *sample ) ;
rmtBool _rmt_IterateNext(rmtSampleIterator *iter ) ;
char const   *_rmt_SampleTreeGetThreadName(rmtSampleTree *sample_tree ) ;
rmtSample *_rmt_SampleTreeGetRootSample(rmtSampleTree *sample_tree ) ;
char const   *_rmt_SampleGetName(rmtSample *sample ) ;
rmtU32 _rmt_SampleGetNameHash(rmtSample *sample ) ;
rmtU32 _rmt_SampleGetCallCount(rmtSample *sample ) ;
rmtU64 _rmt_SampleGetStart(rmtSample *sample ) ;
rmtU64 _rmt_SampleGetTime(rmtSample *sample ) ;
rmtU64 _rmt_SampleGetSelfTime(rmtSample *sample ) ;
void _rmt_SampleGetColour(rmtSample *sample , rmtU8 *r , rmtU8 *g , rmtU8 *b ) ;
rmtSampleType _rmt_SampleGetType(rmtSample *sample ) ;
void _rmt_PropertyIterateChildren(rmtPropertyIterator *iterator , rmtProperty *property ) ;
rmtBool _rmt_PropertyIterateNext(rmtPropertyIterator *iter ) ;
rmtPropertyType _rmt_PropertyGetType(rmtProperty *property ) ;
rmtU32 _rmt_PropertyGetNameHash(rmtProperty *property ) ;
char const   *_rmt_PropertyGetName(rmtProperty *property ) ;
char const   *_rmt_PropertyGetDescription(rmtProperty *property ) ;
rmtPropertyValue _rmt_PropertyGetValue(rmtProperty *property ) ;
static rmtSettings g_Settings  ;
static rmtBool g_SettingsInitialized  =    (rmtBool )0;
extern int fclose(FILE *__stream ) ;
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__)) realloc)(void *__ptr ,
                                                                                              size_t __size ) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
extern  __attribute__((__nothrow__)) clock_t clock(void) ;
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
extern  __attribute__((__nothrow__)) struct tm *gmtime(time_t const   *__timer ) ;
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
extern  __attribute__((__nothrow__)) int abs(int __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t * __restrict  __pwcs ,
                                                     char const   * __restrict  __s ,
                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) double fabs(double __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) double fmod(double __x , double __y ) ;
extern  __attribute__((__nothrow__)) int prctl(int __option  , ...) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
extern  __attribute__((__nothrow__)) pthread_t pthread_self(void)  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int pthread_equal(pthread_t __thread1 , pthread_t __thread2 )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                               pthread_mutexattr_t const   *__mutexattr ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_key_create)(pthread_key_t *__key ,
                                                                                               void (*__destr_function)(void * ) ) ;
extern  __attribute__((__nothrow__)) int pthread_key_delete(pthread_key_t __key ) ;
extern  __attribute__((__nothrow__)) void *pthread_getspecific(pthread_key_t __key ) ;
extern  __attribute__((__nothrow__)) int pthread_setspecific(pthread_key_t __key ,
                                                             void const   *__pointer ) ;
extern int close(int __fd ) ;
extern int usleep(__useconds_t __useconds ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) unlink)(char const   *__name ) ;
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off_t __length ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2))) memcpy)(void * __restrict  __dest ,
                                                                                       void const   * __restrict  __src ,
                                                                                       size_t __n ) ;
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1))) memset)(void *__s ,
                                                                                     int __c ,
                                                                                     size_t __n ) ;
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2))) memcmp)(void const   *__s1 ,
                                                                                     void const   *__s2 ,
                                                                                     size_t __n )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1))) strlen)(char const   *__s )  __attribute__((__pure__)) ;
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  *__addr ,
                                              socklen_t __len ) ;
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
extern  __attribute__((__nothrow__)) void *mmap(void *__addr , size_t __len , int __prot ,
                                                int __flags , int __fd , __off_t __offset ) ;
extern  __attribute__((__nothrow__)) int munmap(void *__addr , size_t __len ) ;
extern  __attribute__((__nothrow__)) uint32_t htonl(uint32_t __hostlong )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) uint16_t htons(uint16_t __hostshort )  __attribute__((__const__)) ;
extern int fcntl(int __fd , int __cmd  , ...) ;
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
static rmtU16 maxU16(rmtU16 a , rmtU16 b ) 
{ 
  int tmp ;

  {
  if ((int )a > (int )b) {
    tmp = (int )a;
  } else {
    tmp = (int )b;
  }
  return ((rmtU16 )tmp);
}
}
static rmtS32 minS32(rmtS32 a , rmtS32 b ) 
{ 
  rmtS32 tmp ;

  {
  if (a < b) {
    tmp = a;
  } else {
    tmp = b;
  }
  return (tmp);
}
}
static rmtS32 maxS32(rmtS32 a , rmtS32 b ) 
{ 
  rmtS32 tmp ;

  {
  if (a > b) {
    tmp = a;
  } else {
    tmp = b;
  }
  return (tmp);
}
}
static rmtU32 minU32(rmtU32 a , rmtU32 b ) 
{ 
  rmtU32 tmp ;

  {
  if (a < b) {
    tmp = a;
  } else {
    tmp = b;
  }
  return (tmp);
}
}
static rmtS64 maxS64(rmtS64 a , rmtS64 b ) 
{ 
  rmtS64 tmp ;

  {
  if (a > b) {
    tmp = a;
  } else {
    tmp = b;
  }
  return (tmp);
}
}
static void *rmtMalloc(rmtU32 size ) 
{ 
  void *tmp ;

  {
  tmp = (*(g_Settings.malloc))(g_Settings.mm_context, size);
  return (tmp);
}
}
static void *rmtRealloc(void *ptr , rmtU32 size ) 
{ 
  void *tmp ;

  {
  tmp = (*(g_Settings.realloc))(g_Settings.mm_context, ptr, size);
  return (tmp);
}
}
static void rmtFree(void *ptr ) 
{ 


  {
  (*(g_Settings.free))(g_Settings.mm_context, ptr);
  return;
}
}
static FILE *rmtOpenFile(char const   *filename , char const   *mode ) 
{ 
  FILE *tmp ;

  {
  tmp = fopen((char const   * __restrict  )filename, (char const   * __restrict  )mode);
  return (tmp);
}
}
void rmtCloseFile(FILE *fp ) 
{ 


  {
  if ((unsigned long )fp != (unsigned long )((void *)0)) {
    fclose(fp);
  }
  return;
}
}
rmtBool rmtWriteFile(FILE *fp , void const   *data , rmtU32 size ) 
{ 
  rmtBool tmp___1 ;
  size_t tmp___2 ;

  {
  if (! ((unsigned long )fp != (unsigned long )((void *)0))) {
    __assert_fail("fp != NULL", "lib/Remotery.c", 251U, "rmtWriteFile");
  }
  tmp___2 = fwrite((void const   * __restrict  )data, (size_t )size, (size_t )1, (FILE * __restrict  )fp);
  if (tmp___2 == (size_t )size) {
    tmp___1 = (rmtBool )1;
  } else {
    tmp___1 = (rmtBool )0;
  }
  return (tmp___1);
}
}
static rmtU32 msTimer_Get(void) 
{ 
  clock_t time___0 ;
  clock_t tmp ;
  rmtU32 msTime ;

  {
  tmp = clock();
  time___0 = tmp;
  msTime = (rmtU32 )(time___0 / 1000L);
  return (msTime);
}
}
static void usTimer_Init(usTimer *timer ) 
{ 
  struct timespec tv ;

  {
  clock_gettime(0, & tv);
  timer->counter_start = (rmtU64 )tv.tv_sec * 1000000ULL + (rmtU64 )((double )tv.tv_nsec * 0.001);
  return;
}
}
static rmtU64 usTimer_Get(usTimer *timer ) 
{ 
  struct timespec tv ;

  {
  clock_gettime(0, & tv);
  return (((rmtU64 )tv.tv_sec * 1000000ULL + (rmtU64 )((double )tv.tv_nsec * 0.001)) - timer->counter_start);
}
}
static void msSleep(rmtU32 time_ms ) 
{ 


  {
  usleep(time_ms * 1000U);
  return;
}
}
static struct tm *TimeDateNow(void) 
{ 
  time_t time_now ;
  time_t tmp ;
  struct tm *tmp___0 ;

  {
  tmp = time((time_t *)((void *)0));
  time_now = tmp;
  tmp___0 = gmtime((time_t const   *)(& time_now));
  return (tmp___0);
}
}
static rmtError tlsAlloc(rmtTLS *handle ) 
{ 
  int tmp___0 ;

  {
  if (! ((unsigned long )handle != (unsigned long )((void *)0))) {
    __assert_fail("handle != NULL", "lib/Remotery.c", 439U, "tlsAlloc");
  }
  tmp___0 = pthread_key_create(handle, (void (*)(void * ))((void *)0));
  if (tmp___0 != 0) {
    *handle = 4294967295U;
    return ((rmtError )8);
  }
  return ((rmtError )0);
}
}
static void tlsFree(rmtTLS handle ) 
{ 


  {
  if (! (handle != 4294967295U)) {
    __assert_fail("handle != TLS_INVALID_HANDLE", "lib/Remotery.c", 461U, "tlsFree");
  }
  pthread_key_delete(handle);
  return;
}
}
static void tlsSet(rmtTLS handle , void *value ) 
{ 


  {
  if (! (handle != 4294967295U)) {
    __assert_fail("handle != TLS_INVALID_HANDLE", "lib/Remotery.c", 471U, "tlsSet");
  }
  pthread_setspecific(handle, (void const   *)value);
  return;
}
}
static void *tlsGet(rmtTLS handle ) 
{ 
  void *tmp___0 ;

  {
  if (! (handle != 4294967295U)) {
    __assert_fail("handle != TLS_INVALID_HANDLE", "lib/Remotery.c", 481U, "tlsGet");
  }
  tmp___0 = pthread_getspecific(handle);
  return (tmp___0);
}
}
static rmtTLS g_lastErrorMessageTlsHandle  =    4294967295U;
static unsigned int const   g_errorMessageSize  =    (rmtU32 const   )1024;
static rmtError rmtMakeError(rmtError error , rmtPStr error_message ) 
{ 
  char *thread_message_ptr ;
  rmtU32 error_len ;
  rmtError error___0 ;
  rmtError tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  if (g_lastErrorMessageTlsHandle == 4294967295U) {
    tmp = tlsAlloc(& g_lastErrorMessageTlsHandle);
    error___0 = tmp;
    if ((unsigned int )error___0 != 0U) {
      return (error___0);
    }
  }
  tmp___0 = tlsGet(g_lastErrorMessageTlsHandle);
  thread_message_ptr = (char *)tmp___0;
  if ((unsigned long )thread_message_ptr == (unsigned long )((void *)0)) {
    tmp___1 = rmtMalloc((rmtU32 )g_errorMessageSize);
    thread_message_ptr = (char *)tmp___1;
    if ((unsigned long )thread_message_ptr == (unsigned long )((void *)0)) {
      return ((rmtError )7);
    }
    tlsSet(g_lastErrorMessageTlsHandle, (void *)thread_message_ptr);
  }
  tmp___2 = strlen(error_message);
  error_len = (rmtU32 )tmp___2;
  if (error_len >= (rmtU32 )g_errorMessageSize) {
    error_len = (rmtU32 )(g_errorMessageSize - 1U);
  } else {
    error_len = error_len;
  }
  memcpy((void * __restrict  )thread_message_ptr, (void const   * __restrict  )error_message,
         (size_t )error_len);
  *(thread_message_ptr + error_len) = (char)0;
  return (error);
}
}
rmtPStr rmt_GetLastErrorMessage(void) 
{ 
  rmtPStr thread_message_ptr ;
  void *tmp ;

  {
  if (g_lastErrorMessageTlsHandle == 4294967295U) {
    return ("No error message");
  }
  tmp = tlsGet(g_lastErrorMessageTlsHandle);
  thread_message_ptr = (rmtPStr )tmp;
  if ((unsigned long )thread_message_ptr == (unsigned long )((void *)0)) {
    return ("No error message");
  }
  return (thread_message_ptr);
}
}
static void mtxInit(rmtMutex *mutex ) 
{ 


  {
  if (! ((unsigned long )mutex != (unsigned long )((void *)0))) {
    __assert_fail("mutex != NULL", "lib/Remotery.c", 571U, "mtxInit");
  }
  pthread_mutex_init(mutex, (pthread_mutexattr_t const   *)((void *)0));
  return;
}
}
static void mtxLock(rmtMutex *mutex ) 
{ 


  {
  if (! ((unsigned long )mutex != (unsigned long )((void *)0))) {
    __assert_fail("mutex != NULL", "lib/Remotery.c", 581U, "mtxLock");
  }
  pthread_mutex_lock(mutex);
  return;
}
}
static void mtxUnlock(rmtMutex *mutex ) 
{ 


  {
  if (! ((unsigned long )mutex != (unsigned long )((void *)0))) {
    __assert_fail("mutex != NULL", "lib/Remotery.c", 591U, "mtxUnlock");
  }
  pthread_mutex_unlock(mutex);
  return;
}
}
static void mtxDelete(rmtMutex *mutex ) 
{ 


  {
  if (! ((unsigned long )mutex != (unsigned long )((void *)0))) {
    __assert_fail("mutex != NULL", "lib/Remotery.c", 601U, "mtxDelete");
  }
  pthread_mutex_destroy(mutex);
  return;
}
}
static rmtBool AtomicCompareAndSwapU32(rmtU32 volatile   *val , long old_val , long new_val ) 
{ 
  rmtBool tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp___1 = __sync_bool_compare_and_swap(val, old_val, new_val);
  if (tmp___1) {
    tmp___0 = (rmtBool )1;
  } else {
    tmp___0 = (rmtBool )0;
  }
  return (tmp___0);
}
}
static rmtBool AtomicCompareAndSwapPointer(long * volatile  *ptr , long *old_ptr ,
                                           long *new_ptr ) 
{ 
  rmtBool tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp___1 = __sync_bool_compare_and_swap(ptr, old_ptr, new_ptr);
  if (tmp___1) {
    tmp___0 = (rmtBool )1;
  } else {
    tmp___0 = (rmtBool )0;
  }
  return (tmp___0);
}
}
static rmtS32 AtomicAddS32(rmtAtomicS32 *value , rmtS32 add ) 
{ 
  rmtAtomicS32 tmp ;

  {
  tmp = (rmtAtomicS32 )__sync_fetch_and_add(value, add);
  return ((rmtS32 )tmp);
}
}
static void AtomicSubS32(rmtAtomicS32 *value , rmtS32 sub ) 
{ 


  {
  AtomicAddS32(value, - sub);
  return;
}
}
static void CompilerWriteFence(void) 
{ 


  {
  __asm__  volatile   ("": : : "memory");
  return;
}
}
static void CompilerReadFence(void) 
{ 


  {
  __asm__  volatile   ("": : : "memory");
  return;
}
}
static rmtU32 LoadAcquire(rmtAtomicU32 *address ) 
{ 
  rmtU32 value ;

  {
  value = (rmtU32 )*address;
  CompilerReadFence();
  return (value);
}
}
static long *LoadAcquirePointer(long * volatile  *ptr ) 
{ 
  long *value ;

  {
  value = (long *)*ptr;
  CompilerReadFence();
  return (value);
}
}
static void StoreRelease(rmtAtomicU32 *address , rmtU32 value ) 
{ 


  {
  CompilerWriteFence();
  *address = (rmtAtomicU32 )value;
  return;
}
}
static void StoreReleasePointer(long * volatile  *ptr , long *value ) 
{ 


  {
  CompilerWriteFence();
  *ptr = (long * volatile  )value;
  return;
}
}
static rmtU32 Well512_State[16]  ;
static rmtU32 Well512_Index  ;
static void Well512_Init(rmtU32 seed ) 
{ 
  rmtU32 i ;
  rmtU32 prev ;

  {
  Well512_State[0] = seed;
  i = (rmtU32 )1;
  while (i < 16U) {
    prev = Well512_State[i - 1U];
    Well512_State[i] = 1812433253U * (prev ^ (prev >> 30)) + i;
    i ++;
  }
  Well512_Index = (rmtU32 )0;
  return;
}
}
static rmtU32 Well512_RandomU32(void) 
{ 
  rmtU32 a ;
  rmtU32 b ;
  rmtU32 c ;
  rmtU32 d ;
  rmtU32 tmp ;

  {
  a = Well512_State[Well512_Index];
  c = Well512_State[(Well512_Index + 13U) & 15U];
  b = ((a ^ c) ^ (a << 16)) ^ (c << 15);
  c = Well512_State[(Well512_Index + 9U) & 15U];
  c ^= c >> 11;
  tmp = b ^ c;
  Well512_State[Well512_Index] = tmp;
  a = tmp;
  d = (rmtU32 )((unsigned long )a ^ ((unsigned long )(a << 5) & 3661901092UL));
  Well512_Index = (Well512_Index + 15U) & 15U;
  a = Well512_State[Well512_Index];
  Well512_State[Well512_Index] = ((((a ^ b) ^ d) ^ (a << 2)) ^ (b << 18)) ^ (c << 28);
  return (Well512_State[Well512_Index]);
}
}
static rmtU32 Well512_RandomOpenLimit(rmtU32 limit ) 
{ 
  rmtU32 bucket_size ;
  rmtU32 bucket_limit ;
  rmtU32 r ;

  {
  bucket_size = 4294967295U / limit;
  bucket_limit = bucket_size * limit;
  while (1) {
    r = Well512_RandomU32();
    if (! (r >= bucket_limit)) {
      break;
    }
  }
  return (r / bucket_size);
}
}
static rmtU32 Log2i(rmtU32 x ) ;
static rmtU8 const   MultiplyDeBruijnBitPosition[32]  = 
  {      (rmtU8 const   )0,      (rmtU8 const   )9,      (rmtU8 const   )1,      (rmtU8 const   )10, 
        (rmtU8 const   )13,      (rmtU8 const   )21,      (rmtU8 const   )2,      (rmtU8 const   )29, 
        (rmtU8 const   )11,      (rmtU8 const   )14,      (rmtU8 const   )16,      (rmtU8 const   )18, 
        (rmtU8 const   )22,      (rmtU8 const   )25,      (rmtU8 const   )3,      (rmtU8 const   )30, 
        (rmtU8 const   )8,      (rmtU8 const   )12,      (rmtU8 const   )20,      (rmtU8 const   )28, 
        (rmtU8 const   )15,      (rmtU8 const   )17,      (rmtU8 const   )24,      (rmtU8 const   )7, 
        (rmtU8 const   )19,      (rmtU8 const   )27,      (rmtU8 const   )23,      (rmtU8 const   )6, 
        (rmtU8 const   )26,      (rmtU8 const   )5,      (rmtU8 const   )4,      (rmtU8 const   )31};
static rmtU32 Log2i(rmtU32 x ) 
{ 


  {
  x |= x >> 1;
  x |= x >> 2;
  x |= x >> 4;
  x |= x >> 8;
  x |= x >> 16;
  return ((rmtU32 )MultiplyDeBruijnBitPosition[x * 130329821U >> 27]);
}
}
static rmtU32 GaloisLFSRMask(rmtU32 table_size_log2 ) ;
static rmtU8 const   XORMasks[7]  = {      (rmtU8 const   )(1 | (1 << 1)),      (rmtU8 const   )((1 << 1) | (1 << 2)),      (rmtU8 const   )((1 << 2) | (1 << 3)),      (rmtU8 const   )((1 << 2) | (1 << 4)), 
        (rmtU8 const   )((1 << 4) | (1 << 5)),      (rmtU8 const   )((1 << 5) | (1 << 6)),      (rmtU8 const   )((((1 << 3) | (1 << 4)) | (1 << 5)) | (1 << 7))};
static rmtU32 GaloisLFSRMask(rmtU32 table_size_log2 ) 
{ 


  {
  if (! (table_size_log2 >= 2U)) {
    __assert_fail("table_size_log2 >= 2", "lib/Remotery.c", 853U, "GaloisLFSRMask");
  }
  if (! (table_size_log2 <= 8U)) {
    __assert_fail("table_size_log2 <= 8", "lib/Remotery.c", 854U, "GaloisLFSRMask");
  }
  return ((rmtU32 )XORMasks[table_size_log2 - 2U]);
}
}
static rmtU32 GaloisLFSRNext(rmtU32 value , rmtU32 xor_mask ) 
{ 
  rmtU32 lsb ;

  {
  lsb = value & 1U;
  value >>= 1;
  if (lsb != 0U) {
    value ^= xor_mask;
  }
  return (value);
}
}
static rmtError VirtualMirrorBuffer_Constructor(VirtualMirrorBuffer *buffer , rmtU32 size ,
                                                int nb_attempts ) ;
static unsigned int const   k_64  =    (rmtU32 const   )65536;
static rmtError VirtualMirrorBuffer_Constructor(VirtualMirrorBuffer *buffer , rmtU32 size ,
                                                int nb_attempts ) 
{ 
  char path[28] ;
  int file_descriptor ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  path[0] = (char )'/';
  path[1] = (char )'d';
  path[2] = (char )'e';
  path[3] = (char )'v';
  path[4] = (char )'/';
  path[5] = (char )'s';
  path[6] = (char )'h';
  path[7] = (char )'m';
  path[8] = (char )'/';
  path[9] = (char )'r';
  path[10] = (char )'i';
  path[11] = (char )'n';
  path[12] = (char )'g';
  path[13] = (char )'-';
  path[14] = (char )'b';
  path[15] = (char )'u';
  path[16] = (char )'f';
  path[17] = (char )'f';
  path[18] = (char )'e';
  path[19] = (char )'r';
  path[20] = (char )'-';
  path[21] = (char )'X';
  path[22] = (char )'X';
  path[23] = (char )'X';
  path[24] = (char )'X';
  path[25] = (char )'X';
  path[26] = (char )'X';
  path[27] = (char )'\000';
  size = (((size + (rmtU32 )k_64) - 1U) / (rmtU32 )k_64) * (rmtU32 )k_64;
  buffer->size = size;
  buffer->ptr = (rmtU8 *)((void *)0);
  file_descriptor = mkstemp(path);
  if (file_descriptor < 0) {
    return ((rmtError )9);
  }
  tmp = unlink((char const   *)(path));
  if (tmp) {
    return ((rmtError )9);
  }
  tmp___0 = ftruncate(file_descriptor, (__off_t )(size * 2U));
  if (tmp___0) {
    return ((rmtError )9);
  }
  tmp___1 = mmap((void *)0, (size_t )(size * 2U), 0, 34, -1, (__off_t )0);
  buffer->ptr = (rmtU8 *)tmp___1;
  if ((unsigned long )buffer->ptr == (unsigned long )((void *)-1)) {
    buffer->ptr = (rmtU8 *)((void *)0);
    return ((rmtError )9);
  }
  tmp___2 = mmap((void *)buffer->ptr, (size_t )size, 3, 17, file_descriptor, (__off_t )0);
  if ((unsigned long )tmp___2 != (unsigned long )buffer->ptr) {
    return ((rmtError )9);
  } else {
    tmp___3 = mmap((void *)(buffer->ptr + size), (size_t )size, 3, 17, file_descriptor,
                   (__off_t )0);
    if ((unsigned long )tmp___3 != (unsigned long )(buffer->ptr + size)) {
      return ((rmtError )9);
    }
  }
  if ((unsigned long )buffer->ptr == (unsigned long )((void *)0)) {
    return ((rmtError )9);
  }
  return ((rmtError )0);
}
}
static void VirtualMirrorBuffer_Destructor(VirtualMirrorBuffer *buffer ) 
{ 


  {
  if (! ((unsigned long )buffer != (unsigned long )((VirtualMirrorBuffer *)0))) {
    __assert_fail("buffer != 0", "lib/Remotery.c", 1351U, "VirtualMirrorBuffer_Destructor");
  }
  if ((unsigned long )buffer->ptr != (unsigned long )((void *)0)) {
    munmap((void *)buffer->ptr, (size_t )(buffer->size * 2U));
  }
  buffer->ptr = (rmtU8 *)((void *)0);
  return;
}
}
static r_size_t strnlen_s_safe_c(char const   *dest , r_size_t dmax ) 
{ 
  r_size_t count ;

  {
  if ((unsigned long )dest == (unsigned long )((void *)0)) {
    return ((r_size_t )0);
  }
  if (dmax == 0U) {
    return ((r_size_t )0);
  }
  if ((unsigned long )dmax > 4UL << 10) {
    return ((r_size_t )0);
  }
  count = (r_size_t )0;
  while (1) {
    if (*dest) {
      if (! dmax) {
        break;
      }
    } else {
      break;
    }
    count ++;
    dmax --;
    dest ++;
  }
  return (count);
}
}
static errno_t strstr_s(char *dest , r_size_t dmax , char const   *src , r_size_t slen ,
                        char **substring ) 
{ 
  r_size_t len ;
  r_size_t dlen ;
  int i ;

  {
  if ((unsigned long )substring == (unsigned long )((void *)0)) {
    return (400);
  }
  *substring = (char *)((void *)0);
  if ((unsigned long )dest == (unsigned long )((void *)0)) {
    return (400);
  }
  if (dmax == 0U) {
    return (401);
  }
  if ((unsigned long )dmax > 4UL << 10) {
    return (403);
  }
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    return (400);
  }
  if (slen == 0U) {
    return (401);
  }
  if ((unsigned long )slen > 4UL << 10) {
    return (403);
  }
  if ((int const   )*src == 0) {
    *substring = dest;
    return (0);
  } else
  if ((unsigned long )dest == (unsigned long )src) {
    *substring = dest;
    return (0);
  }
  while (1) {
    if (*dest) {
      if (! dmax) {
        break;
      }
    } else {
      break;
    }
    i = 0;
    len = slen;
    dlen = dmax;
    while (1) {
      if (*(src + i)) {
        if (! dlen) {
          break;
        }
      } else {
        break;
      }
      if ((int )*(dest + i) != (int )*(src + i)) {
        break;
      }
      i ++;
      len --;
      dlen --;
      if ((int const   )*(src + i) == 0) {
        *substring = dest;
        return (0);
      } else
      if (! len) {
        *substring = dest;
        return (0);
      }
    }
    dest ++;
    dmax --;
  }
  *substring = (char *)((void *)0);
  return (409);
}
}
static errno_t strncat_s_safe_c(char *dest , r_size_t dmax , char const   *src , r_size_t slen ) 
{ 
  char const   *overlap_bumper ;

  {
  if ((unsigned long )dest == (unsigned long )((void *)0)) {
    return (400);
  }
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    return (400);
  }
  if ((unsigned long )slen > 4UL << 10) {
    return (403);
  }
  if (dmax == 0U) {
    return (401);
  }
  if ((unsigned long )dmax > 4UL << 10) {
    return (403);
  }
  if ((unsigned long )dest < (unsigned long )src) {
    overlap_bumper = src;
    while ((int )*dest != 0) {
      if ((unsigned long )dest == (unsigned long )overlap_bumper) {
        return (404);
      }
      dest ++;
      dmax --;
      if (dmax == 0U) {
        return (407);
      }
    }
    while (dmax > 0U) {
      if ((unsigned long )dest == (unsigned long )overlap_bumper) {
        return (404);
      }
      if (slen == 0U) {
        *dest = (char )'\000';
        return (0);
      }
      *dest = (char )*src;
      if ((int )*dest == 0) {
        return (0);
      }
      dmax --;
      slen --;
      dest ++;
      src ++;
    }
  } else {
    overlap_bumper = (char const   *)dest;
    while ((int )*dest != 0) {
      dest ++;
      dmax --;
      if (dmax == 0U) {
        return (407);
      }
    }
    while (dmax > 0U) {
      if ((unsigned long )src == (unsigned long )overlap_bumper) {
        return (404);
      }
      if (slen == 0U) {
        *dest = (char )'\000';
        return (0);
      }
      *dest = (char )*src;
      if ((int )*dest == 0) {
        return (0);
      }
      dmax --;
      slen --;
      dest ++;
      src ++;
    }
  }
  return (406);
}
}
errno_t strcpy_s_safe_c(char *dest , r_size_t dmax , char const   *src ) 
{ 
  char const   *overlap_bumper ;

  {
  if ((unsigned long )dest == (unsigned long )((void *)0)) {
    return (400);
  }
  if (dmax == 0U) {
    return (401);
  }
  if ((unsigned long )dmax > 4UL << 10) {
    return (403);
  }
  if ((unsigned long )src == (unsigned long )((void *)0)) {
    *dest = (char )'\000';
    return (400);
  }
  if ((unsigned long )dest == (unsigned long )src) {
    return (0);
  }
  if ((unsigned long )dest < (unsigned long )src) {
    overlap_bumper = src;
    while (dmax > 0U) {
      if ((unsigned long )dest == (unsigned long )overlap_bumper) {
        return (404);
      }
      *dest = (char )*src;
      if ((int )*dest == 0) {
        return (0);
      }
      dmax --;
      dest ++;
      src ++;
    }
  } else {
    overlap_bumper = (char const   *)dest;
    while (dmax > 0U) {
      if ((unsigned long )src == (unsigned long )overlap_bumper) {
        return (404);
      }
      *dest = (char )*src;
      if ((int )*dest == 0) {
        return (0);
      }
      dmax --;
      dest ++;
      src ++;
    }
  }
  return (406);
}
}
static char const   *hex_encoding_table  =    "0123456789ABCDEF";
static void itoahex_s(char *dest , r_size_t dmax , rmtS32 value ) 
{ 
  r_size_t len ;
  rmtS32 halfbytepos ;

  {
  halfbytepos = 8;
  while (halfbytepos > 1) {
    halfbytepos --;
    if ((value >> 4 * halfbytepos) & 15) {
      halfbytepos ++;
      break;
    }
  }
  len = (r_size_t )0;
  while (1) {
    if (len + 1U < dmax) {
      if (! (halfbytepos > 0)) {
        break;
      }
    } else {
      break;
    }
    halfbytepos --;
    *(dest + len) = (char )*(hex_encoding_table + ((value >> 4 * halfbytepos) & 15));
    len ++;
  }
  if (len < dmax) {
    *(dest + len) = (char)0;
  }
  return;
}
}
static char const   *itoa_s(rmtS32 value ) ;
static char temp_dest[12]  = 
  {      (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0, 
        (char)0,      (char)0,      (char)0,      (char)0};
static char const   *itoa_s(rmtS32 value ) 
{ 
  int pos ;
  rmtS32 abs_value ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  pos = 10;
  tmp = abs(value);
  abs_value = tmp;
  while (abs_value > 0) {
    tmp___0 = pos;
    pos --;
    temp_dest[tmp___0] = (char )(48 + abs_value % 10);
    abs_value /= 10;
  }
  if (value < 0) {
    tmp___1 = pos;
    pos --;
    temp_dest[tmp___1] = (char )'-';
  }
  return ((char const   *)((temp_dest + pos) + 1));
}
}
static rmtU32 rmtGetNbProcessors(void) 
{ 


  {
  return ((rmtU32 )0);
}
}
static rmtThreadId rmtGetCurrentThreadId(void) 
{ 
  pthread_t tmp ;

  {
  tmp = pthread_self();
  return (tmp);
}
}
static rmtBool rmtSuspendThread(rmtThreadHandle thread_handle ) 
{ 


  {
  return ((rmtBool )0);
}
}
static void rmtResumeThread(rmtThreadHandle thread_handle ) 
{ 


  {
  return;
}
}
static rmtBool rmtGetUserModeThreadContext(rmtThreadHandle thread , rmtCpuContext *context ) 
{ 


  {
  return ((rmtBool )0);
}
}
static void rmtSetThreadContext(rmtThreadHandle thread_handle , rmtCpuContext *context ) 
{ 


  {
  return;
}
}
static rmtError rmtOpenThreadHandle(rmtThreadId thread_id , rmtThreadHandle *out_thread_handle ) 
{ 


  {
  return ((rmtError )0);
}
}
static void rmtCloseThreadHandle(rmtThreadHandle thread_handle ) 
{ 


  {
  return;
}
}
static void rmtGetThreadNameFallback(char *out_thread_name , rmtU32 thread_name_size ) ;
static rmtS32 countThreads  =    0;
static void rmtGetThreadNameFallback(char *out_thread_name , rmtU32 thread_name_size ) 
{ 
  rmtS32 tmp ;

  {
  *(out_thread_name + 0) = (char)0;
  strncat_s_safe_c(out_thread_name, thread_name_size, "Thread", (r_size_t )6);
  tmp = AtomicAddS32((rmtAtomicS32 *)(& countThreads), 1);
  itoahex_s(out_thread_name + 6, thread_name_size - 6U, tmp);
  return;
}
}
static void rmtGetThreadName(rmtThreadId thread_id , rmtThreadHandle thread_handle ,
                             char *out_thread_name , rmtU32 thread_name_size ) 
{ 


  {
  rmtGetThreadNameFallback(out_thread_name, thread_name_size);
  return;
}
}
static void *StartFunc(void *pArgs ) 
{ 
  rmtThread *thread ;

  {
  thread = (rmtThread *)pArgs;
  if (! ((unsigned long )thread != (unsigned long )((void *)0))) {
    __assert_fail("thread != NULL", "lib/Remotery.c", 2156U, "StartFunc");
  }
  thread->error = (*(thread->callback))(thread);
  return ((void *)0);
}
}
static int rmtThread_Valid(rmtThread *thread ) 
{ 
  pthread_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (! ((unsigned long )thread != (unsigned long )((void *)0))) {
    __assert_fail("thread != NULL", "lib/Remotery.c", 2164U, "rmtThread_Valid");
  }
  tmp___0 = pthread_self();
  tmp___1 = pthread_equal(thread->handle, tmp___0);
  if (tmp___1) {
    tmp___2 = 0;
  } else {
    tmp___2 = 1;
  }
  return (tmp___2);
}
}
static rmtError rmtThread_Constructor(rmtThread *thread , rmtError (*callback)(rmtThread *thread ) ,
                                      void *param ) 
{ 
  int32_t error ;
  int tmp___0 ;

  {
  if (! ((unsigned long )thread != (unsigned long )((void *)0))) {
    __assert_fail("thread != NULL", "lib/Remotery.c", 2175U, "rmtThread_Constructor");
  }
  thread->callback = callback;
  thread->param = param;
  thread->error = (rmtError )0;
  thread->request_exit = (rmtBool volatile   )((rmtBool )0);
  tmp___0 = pthread_create((pthread_t * __restrict  )(& thread->handle), (pthread_attr_t const   * __restrict  )((void *)0),
                           & StartFunc, (void * __restrict  )thread);
  error = tmp___0;
  if (error) {
    thread->handle = pthread_self();
    return ((rmtError )10);
  }
  return ((rmtError )0);
}
}
static void rmtThread_RequestExit(rmtThread *thread ) 
{ 


  {
  if (! ((unsigned long )thread != (unsigned long )((void *)0))) {
    __assert_fail("thread != NULL", "lib/Remotery.c", 2215U, "rmtThread_RequestExit");
  }
  thread->request_exit = (rmtBool volatile   )((rmtBool )1);
  return;
}
}
static void rmtThread_Join(rmtThread *thread ) 
{ 
  int tmp___2 ;

  {
  tmp___2 = rmtThread_Valid(thread);
  if (! tmp___2) {
    __assert_fail("rmtThread_Valid(thread)", "lib/Remotery.c", 2221U, "rmtThread_Join");
  }
  pthread_join(thread->handle, (void **)((void *)0));
  return;
}
}
static void rmtThread_Destructor(rmtThread *thread ) 
{ 
  int tmp___0 ;

  {
  if (! ((unsigned long )thread != (unsigned long )((void *)0))) {
    __assert_fail("thread != NULL", "lib/Remotery.c", 2232U, "rmtThread_Destructor");
  }
  tmp___0 = rmtThread_Valid(thread);
  if (tmp___0) {
    rmtThread_RequestExit(thread);
    rmtThread_Join(thread);
  }
  return;
}
}
static void ObjectLink_Constructor(ObjectLink *link___0 ) 
{ 


  {
  if (! ((unsigned long )link___0 != (unsigned long )((void *)0))) {
    __assert_fail("link != NULL", "lib/Remotery.c", 2267U, "ObjectLink_Constructor");
  }
  link___0->next = (struct ObjectLink_s * volatile  )((void *)0);
  return;
}
}
static rmtError ObjectAllocator_Constructor(ObjectAllocator *allocator , rmtU32 object_size ,
                                            rmtError (*constructor)(void * ) , void (*destructor)(void * ) ) 
{ 


  {
  allocator->object_size = object_size;
  allocator->constructor = constructor;
  allocator->destructor = destructor;
  allocator->nb_free = (rmtAtomicS32 )0;
  allocator->nb_inuse = (rmtAtomicS32 )0;
  allocator->nb_allocated = (rmtAtomicS32 )0;
  allocator->first_free = (ObjectLink *)((void *)0);
  return ((rmtError )0);
}
}
static void ObjectAllocator_Destructor(ObjectAllocator *allocator ) 
{ 
  ObjectLink *next ;

  {
  if (! ((unsigned long )allocator != (unsigned long )((void *)0))) {
    __assert_fail("allocator != NULL", "lib/Remotery.c", 2309U, "ObjectAllocator_Destructor");
  }
  if (! (allocator->nb_inuse == (rmtAtomicS32 )0)) {
    __assert_fail("allocator->nb_inuse == 0", "lib/Remotery.c", 2310U, "ObjectAllocator_Destructor");
  }
  while ((unsigned long )allocator->first_free != (unsigned long )((void *)0)) {
    next = (ObjectLink *)(allocator->first_free)->next;
    if (! ((unsigned long )allocator->destructor != (unsigned long )((void *)0))) {
      __assert_fail("allocator->destructor != NULL", "lib/Remotery.c", 2316U, "ObjectAllocator_Destructor");
    }
    (*(allocator->destructor))((void *)allocator->first_free);
    rmtFree((void *)allocator->first_free);
    allocator->first_free = next;
  }
  return;
}
}
static void ObjectAllocator_Push(ObjectAllocator *allocator , ObjectLink *start ,
                                 ObjectLink *end ) 
{ 
  ObjectLink *old_link ;
  rmtBool tmp___2 ;

  {
  if (! ((unsigned long )allocator != (unsigned long )((void *)0))) {
    __assert_fail("allocator != NULL", "lib/Remotery.c", 2325U, "ObjectAllocator_Push");
  }
  if (! ((unsigned long )start != (unsigned long )((void *)0))) {
    __assert_fail("start != NULL", "lib/Remotery.c", 2326U, "ObjectAllocator_Push");
  }
  if (! ((unsigned long )end != (unsigned long )((void *)0))) {
    __assert_fail("end != NULL", "lib/Remotery.c", 2327U, "ObjectAllocator_Push");
  }
  while (1) {
    old_link = allocator->first_free;
    end->next = (struct ObjectLink_s * volatile  )old_link;
    tmp___2 = AtomicCompareAndSwapPointer((long * volatile  *)(& allocator->first_free),
                                          (long *)old_link, (long *)start);
    if (tmp___2 == 1U) {
      break;
    }
  }
  return;
}
}
static ObjectLink *ObjectAllocator_Pop(ObjectAllocator *allocator ) 
{ 
  ObjectLink *link___0 ;
  ObjectLink *old_link ;
  ObjectLink *next_link ;
  rmtBool tmp___0 ;

  {
  if (! ((unsigned long )allocator != (unsigned long )((void *)0))) {
    __assert_fail("allocator != NULL", "lib/Remotery.c", 2344U, "ObjectAllocator_Pop");
  }
  while (1) {
    old_link = allocator->first_free;
    if ((unsigned long )old_link == (unsigned long )((void *)0)) {
      return ((ObjectLink *)((void *)0));
    }
    next_link = (ObjectLink *)old_link->next;
    tmp___0 = AtomicCompareAndSwapPointer((long * volatile  *)(& allocator->first_free),
                                          (long *)old_link, (long *)next_link);
    if (tmp___0 == 1U) {
      link___0 = old_link;
      break;
    }
  }
  link___0->next = (struct ObjectLink_s * volatile  )((void *)0);
  return (link___0);
}
}
static rmtError ObjectAllocator_Alloc(ObjectAllocator *allocator , void **object ) 
{ 
  ObjectLink *tmp___1 ;
  rmtError error ;

  {
  if (! ((unsigned long )allocator != (unsigned long )((void *)0))) {
    __assert_fail("allocator != NULL", "lib/Remotery.c", 2372U, "ObjectAllocator_Alloc");
  }
  if (! ((unsigned long )object != (unsigned long )((void *)0))) {
    __assert_fail("object != NULL", "lib/Remotery.c", 2373U, "ObjectAllocator_Alloc");
  }
  tmp___1 = ObjectAllocator_Pop(allocator);
  *object = (void *)tmp___1;
  if ((unsigned long )*object == (unsigned long )((void *)0)) {
    *object = rmtMalloc(allocator->object_size);
    if ((unsigned long )*object == (unsigned long )((void *)0)) {
      return ((rmtError )7);
    }
    if (! ((unsigned long )allocator->constructor != (unsigned long )((void *)0))) {
      __assert_fail("allocator->constructor != NULL", "lib/Remotery.c", 2387U, "ObjectAllocator_Alloc");
    }
    error = (*(allocator->constructor))(*object);
    if ((unsigned int )error != 0U) {
      if (! ((unsigned long )allocator->destructor != (unsigned long )((void *)0))) {
        __assert_fail("allocator->destructor != NULL", "lib/Remotery.c", 2392U, "ObjectAllocator_Alloc");
      }
      (*(allocator->destructor))(*object);
      rmtFree(*object);
      return (error);
    }
    AtomicAddS32(& allocator->nb_allocated, 1);
  } else {
    AtomicSubS32(& allocator->nb_free, 1);
  }
  AtomicAddS32(& allocator->nb_inuse, 1);
  return ((rmtError )0);
}
}
static void ObjectAllocator_Free(ObjectAllocator *allocator , void *object ) 
{ 


  {
  if (! ((unsigned long )allocator != (unsigned long )((void *)0))) {
    __assert_fail("allocator != NULL", "lib/Remotery.c", 2413U, "ObjectAllocator_Free");
  }
  ObjectAllocator_Push(allocator, (ObjectLink *)object, (ObjectLink *)object);
  AtomicSubS32(& allocator->nb_inuse, 1);
  AtomicAddS32(& allocator->nb_free, 1);
  return;
}
}
static void ObjectAllocator_FreeRange(ObjectAllocator *allocator , void *start , void *end ,
                                      rmtU32 count ) 
{ 


  {
  if (! ((unsigned long )allocator != (unsigned long )((void *)0))) {
    __assert_fail("allocator != NULL", "lib/Remotery.c", 2421U, "ObjectAllocator_FreeRange");
  }
  ObjectAllocator_Push(allocator, (ObjectLink *)start, (ObjectLink *)end);
  AtomicSubS32(& allocator->nb_inuse, (rmtS32 )count);
  AtomicAddS32(& allocator->nb_free, (rmtS32 )count);
  return;
}
}
static rmtError Buffer_Constructor(Buffer *buffer , rmtU32 alloc_granularity ) 
{ 


  {
  if (! ((unsigned long )buffer != (unsigned long )((void *)0))) {
    __assert_fail("buffer != NULL", "lib/Remotery.c", 2447U, "Buffer_Constructor");
  }
  buffer->alloc_granularity = alloc_granularity;
  buffer->bytes_allocated = (rmtU32 )0;
  buffer->bytes_used = (rmtU32 )0;
  buffer->data = (rmtU8 *)((void *)0);
  return ((rmtError )0);
}
}
static void Buffer_Destructor(Buffer *buffer ) 
{ 


  {
  if (! ((unsigned long )buffer != (unsigned long )((void *)0))) {
    __assert_fail("buffer != NULL", "lib/Remotery.c", 2457U, "Buffer_Destructor");
  }
  if ((unsigned long )buffer->data != (unsigned long )((void *)0)) {
    rmtFree((void *)buffer->data);
    buffer->data = (rmtU8 *)((void *)0);
  }
  return;
}
}
static rmtError Buffer_Grow(Buffer *buffer , rmtU32 length ) 
{ 
  rmtU32 granularity ;
  rmtU32 allocate ;
  void *tmp ;

  {
  granularity = buffer->alloc_granularity;
  allocate = buffer->bytes_allocated + length;
  allocate += (granularity - 1U) - (allocate - 1U) % granularity;
  buffer->bytes_allocated = allocate;
  tmp = rmtRealloc((void *)buffer->data, buffer->bytes_allocated);
  buffer->data = (rmtU8 *)tmp;
  if ((unsigned long )buffer->data == (unsigned long )((void *)0)) {
    return ((rmtError )7);
  }
  return ((rmtError )0);
}
}
static rmtError Buffer_Pad(Buffer *buffer , rmtU32 length ) 
{ 
  rmtError error ;
  rmtError tmp___0 ;

  {
  if (! ((unsigned long )buffer != (unsigned long )((void *)0))) {
    __assert_fail("buffer != NULL", "lib/Remotery.c", 2483U, "Buffer_Pad");
  }
  if (buffer->bytes_used + length > buffer->bytes_allocated) {
    tmp___0 = Buffer_Grow(buffer, length);
    error = tmp___0;
    if ((unsigned int )error != 0U) {
      return (error);
    }
  }
  buffer->bytes_used += length;
  return ((rmtError )0);
}
}
static rmtError Buffer_AlignedPad(Buffer *buffer , rmtU32 start_pos ) 
{ 
  rmtError tmp ;

  {
  tmp = Buffer_Pad(buffer, (4U - ((buffer->bytes_used - start_pos) & 3U)) & 3U);
  return (tmp);
}
}
static rmtError Buffer_Write(Buffer *buffer , void const   *data , rmtU32 length ) 
{ 
  rmtError error ;
  rmtError tmp___0 ;

  {
  if (! ((unsigned long )buffer != (unsigned long )((void *)0))) {
    __assert_fail("buffer != NULL", "lib/Remotery.c", 2504U, "Buffer_Write");
  }
  if (buffer->bytes_used + length > buffer->bytes_allocated) {
    tmp___0 = Buffer_Grow(buffer, length);
    error = tmp___0;
    if ((unsigned int )error != 0U) {
      return (error);
    }
  }
  memcpy((void * __restrict  )(buffer->data + buffer->bytes_used), (void const   * __restrict  )data,
         (size_t )length);
  buffer->bytes_used += length;
  return ((rmtError )0);
}
}
static rmtError Buffer_WriteStringZ(Buffer *buffer , rmtPStr string ) 
{ 
  r_size_t tmp___0 ;
  rmtError tmp___1 ;

  {
  if (! ((unsigned long )string != (unsigned long )((void *)0))) {
    __assert_fail("string != NULL", "lib/Remotery.c", 2521U, "Buffer_WriteStringZ");
  }
  tmp___0 = strnlen_s_safe_c(string, (r_size_t )2048);
  tmp___1 = Buffer_Write(buffer, (void const   *)((void *)string), tmp___0 + 1U);
  return (tmp___1);
}
}
static void U32ToByteArray(rmtU8 *dest , rmtU32 value ) 
{ 


  {
  *(dest + 0) = (rmtU8 )(value & 255U);
  *(dest + 1) = (rmtU8 )((value >> 8) & 255U);
  *(dest + 2) = (rmtU8 )((value >> 16) & 255U);
  *(dest + 3) = (rmtU8 )(value >> 24);
  return;
}
}
static rmtError Buffer_WriteU32(Buffer *buffer , rmtU32 value ) 
{ 
  rmtError error ;
  rmtError tmp___0 ;

  {
  if (! ((unsigned long )buffer != (unsigned long )((void *)0))) {
    __assert_fail("buffer != NULL", "lib/Remotery.c", 2541U, "Buffer_WriteU32");
  }
  if ((unsigned long )buffer->bytes_used + sizeof(value) > (unsigned long )buffer->bytes_allocated) {
    tmp___0 = Buffer_Grow(buffer, (rmtU32 )sizeof(value));
    error = tmp___0;
    if ((unsigned int )error != 0U) {
      return (error);
    }
  }
  U32ToByteArray(buffer->data + buffer->bytes_used, value);
  buffer->bytes_used = (rmtU32 )((unsigned long )buffer->bytes_used + sizeof(value));
  return ((rmtError )0);
}
}
static rmtBool IsLittleEndian(void) 
{ 
  union __anonunion_u_919609132 u ;
  rmtBool tmp ;

  {
  u.i = 1U;
  if ((int )u.c[0] == 1) {
    tmp = (rmtBool )1;
  } else {
    tmp = (rmtBool )0;
  }
  return (tmp);
}
}
static rmtError Buffer_WriteF64(Buffer *buffer , rmtF64 value ) 
{ 
  rmtError error ;
  rmtError tmp___0 ;
  union __anonunion_u_682901414 u ;
  rmtU8 *dest ;
  rmtBool tmp___1 ;

  {
  if (! ((unsigned long )buffer != (unsigned long )((void *)0))) {
    __assert_fail("buffer != NULL", "lib/Remotery.c", 2575U, "Buffer_WriteF64");
  }
  if ((unsigned long )buffer->bytes_used + sizeof(value) > (unsigned long )buffer->bytes_allocated) {
    tmp___0 = Buffer_Grow(buffer, (rmtU32 )sizeof(value));
    error = tmp___0;
    if ((unsigned int )error != 0U) {
      return (error);
    }
  }
  dest = buffer->data + buffer->bytes_used;
  u.d = value;
  tmp___1 = IsLittleEndian();
  if (tmp___1) {
    *(dest + 0) = u.c[0];
    *(dest + 1) = u.c[1];
    *(dest + 2) = u.c[2];
    *(dest + 3) = u.c[3];
    *(dest + 4) = u.c[4];
    *(dest + 5) = u.c[5];
    *(dest + 6) = u.c[6];
    *(dest + 7) = u.c[7];
  } else {
    *(dest + 0) = u.c[7];
    *(dest + 1) = u.c[6];
    *(dest + 2) = u.c[5];
    *(dest + 3) = u.c[4];
    *(dest + 4) = u.c[3];
    *(dest + 5) = u.c[2];
    *(dest + 6) = u.c[1];
    *(dest + 7) = u.c[0];
  }
  buffer->bytes_used = (rmtU32 )((unsigned long )buffer->bytes_used + sizeof(value));
  return ((rmtError )0);
}
}
static rmtError Buffer_WriteU64(Buffer *buffer , rmtU64 value ) 
{ 
  rmtError tmp ;

  {
  tmp = Buffer_WriteF64(buffer, (double )value);
  return (tmp);
}
}
static rmtError Buffer_WriteStringWithLength(Buffer *buffer , rmtPStr string ) 
{ 
  rmtU32 length ;
  r_size_t tmp ;
  rmtError error ;
  rmtError tmp___0 ;
  rmtError tmp___1 ;

  {
  tmp = strnlen_s_safe_c(string, (r_size_t )2048);
  length = tmp;
  tmp___0 = Buffer_WriteU32(buffer, length);
  error = tmp___0;
  if ((unsigned int )error != 0U) {
    return (error);
  }
  tmp___1 = Buffer_Write(buffer, (void const   *)((void *)string), length);
  return (tmp___1);
}
}
static rmtError rmtHashTable_Constructor(rmtHashTable *table , rmtU32 max_nb_slots ) 
{ 
  void *tmp___0 ;

  {
  if (! ((unsigned long )table != (unsigned long )((void *)0))) {
    __assert_fail("table != NULL", "lib/Remotery.c", 2669U, "rmtHashTable_Constructor");
  }
  table->maxNbSlots = max_nb_slots;
  table->nbSlots = (rmtU32 )0;
  tmp___0 = rmtMalloc((rmtU32 )((unsigned long )table->maxNbSlots * sizeof(HashSlot )));
  table->slots = (HashSlot *)tmp___0;
  if ((unsigned long )table->slots == (unsigned long )((void *)0)) {
    return ((rmtError )7);
  }
  memset((void *)table->slots, 0, (unsigned long )table->maxNbSlots * sizeof(HashSlot ));
  return ((rmtError )0);
}
}
static void rmtHashTable_Destructor(rmtHashTable *table ) 
{ 


  {
  if (! ((unsigned long )table != (unsigned long )((void *)0))) {
    __assert_fail("table != NULL", "lib/Remotery.c", 2682U, "rmtHashTable_Destructor");
  }
  if ((unsigned long )table->slots != (unsigned long )((void *)0)) {
    rmtFree((void *)table->slots);
    table->slots = (HashSlot *)((void *)0);
  }
  return;
}
}
static rmtError rmtHashTable_Resize(rmtHashTable *table ) ;
static rmtError rmtHashTable_Insert(rmtHashTable *table , rmtU32 key , rmtU64 value ) 
{ 
  HashSlot *slot ;
  rmtError error ;
  rmtU32 index_mask ;
  rmtU32 index___0 ;

  {
  slot = (HashSlot *)((void *)0);
  error = (rmtError )0;
  index_mask = table->maxNbSlots - 1U;
  index___0 = key & index_mask;
  if (! (key != 0U)) {
    __assert_fail("key != 0", "lib/Remotery.c", 2702U, "rmtHashTable_Insert");
  }
  if (! (value != 0xffffffffffffffffULL)) {
    __assert_fail("value != RMT_NOT_FOUND", "lib/Remotery.c", 2703U, "rmtHashTable_Insert");
  }
  while ((table->slots + index___0)->key) {
    if ((table->slots + index___0)->key == key) {
      (table->nbSlots) --;
      break;
    }
    index___0 = (index___0 + 1U) & index_mask;
  }
  if (! (index___0 < table->maxNbSlots)) {
    __assert_fail("index < table->maxNbSlots", "lib/Remotery.c", 2720U, "rmtHashTable_Insert");
  }
  slot = table->slots + index___0;
  slot->key = key;
  slot->value = value;
  (table->nbSlots) ++;
  if (table->nbSlots > (table->maxNbSlots * 2U) / 3U) {
    error = rmtHashTable_Resize(table);
  }
  return (error);
}
}
static rmtError rmtHashTable_Resize(rmtHashTable *table ) 
{ 
  rmtU32 old_max_nb_slots ;
  HashSlot *new_slots ;
  HashSlot *old_slots ;
  rmtU32 i ;
  rmtU32 new_max_nb_slots ;
  void *tmp ;
  HashSlot *slot ;

  {
  old_max_nb_slots = table->maxNbSlots;
  new_slots = (HashSlot *)((void *)0);
  old_slots = table->slots;
  new_max_nb_slots = table->maxNbSlots;
  if (new_max_nb_slots < 32768U) {
    new_max_nb_slots *= 4U;
  } else {
    new_max_nb_slots *= 2U;
  }
  tmp = rmtMalloc((rmtU32 )((unsigned long )new_max_nb_slots * sizeof(HashSlot )));
  new_slots = (HashSlot *)tmp;
  if ((unsigned long )new_slots == (unsigned long )((void *)0)) {
    return ((rmtError )7);
  }
  memset((void *)new_slots, 0, (unsigned long )new_max_nb_slots * sizeof(HashSlot ));
  table->slots = new_slots;
  table->maxNbSlots = new_max_nb_slots;
  table->nbSlots = (rmtU32 )0;
  i = (rmtU32 )0;
  while (i < old_max_nb_slots) {
    slot = old_slots + i;
    if (slot->key != 0U) {
      rmtHashTable_Insert(table, slot->key, slot->value);
    }
    i ++;
  }
  rmtFree((void *)old_slots);
  return ((rmtError )0);
}
}
static rmtU64 rmtHashTable_Find(rmtHashTable *table , rmtU32 key ) 
{ 
  rmtU32 index_mask ;
  rmtU32 index___0 ;
  HashSlot *slot ;

  {
  index_mask = table->maxNbSlots - 1U;
  index___0 = key & index_mask;
  while ((table->slots + index___0)->key) {
    slot = table->slots + index___0;
    if (slot->key == key) {
      return (slot->value);
    }
    index___0 = (index___0 + 1U) & index_mask;
  }
  return ((rmtU64 )18446744073709551615);
}
}
static rmtError StringTable_Constructor(StringTable *table ) 
{ 
  void *tmp___0 ;
  rmtError error ;
  rmtError tmp___1 ;
  void *tmp___2 ;
  rmtError error___0 ;
  rmtError tmp___3 ;

  {
  if (! ((unsigned long )table != (unsigned long )((void *)0))) {
    __assert_fail("table != NULL", "lib/Remotery.c", 2821U, "StringTable_Constructor");
  }
  table->text = (Buffer *)((void *)0);
  table->text_map = (rmtHashTable *)((void *)0);
  tmp___0 = rmtMalloc((rmtU32 )sizeof(Buffer ));
  table->text = (Buffer *)tmp___0;
  if ((unsigned long )table->text == (unsigned long )((void *)0)) {
    return ((rmtError )7);
  }
  tmp___1 = Buffer_Constructor(table->text, (rmtU32 )8192);
  error = tmp___1;
  if ((unsigned int )error != 0U) {
    if ((unsigned long )table->text != (unsigned long )((void *)0)) {
      Buffer_Destructor(table->text);
      rmtFree((void *)table->text);
      table->text = (Buffer *)((void *)0);
    }
    return (error);
  }
  tmp___2 = rmtMalloc((rmtU32 )sizeof(rmtHashTable ));
  table->text_map = (rmtHashTable *)tmp___2;
  if ((unsigned long )table->text_map == (unsigned long )((void *)0)) {
    return ((rmtError )7);
  }
  tmp___3 = rmtHashTable_Constructor(table->text_map, (rmtU32 )1024);
  error___0 = tmp___3;
  if ((unsigned int )error___0 != 0U) {
    if ((unsigned long )table->text_map != (unsigned long )((void *)0)) {
      rmtHashTable_Destructor(table->text_map);
      rmtFree((void *)table->text_map);
      table->text_map = (rmtHashTable *)((void *)0);
    }
    return (error___0);
  }
  return ((rmtError )0);
}
}
static void StringTable_Destructor(StringTable *table ) 
{ 


  {
  if (! ((unsigned long )table != (unsigned long )((void *)0))) {
    __assert_fail("table != NULL", "lib/Remotery.c", 2834U, "StringTable_Destructor");
  }
  if ((unsigned long )table->text_map != (unsigned long )((void *)0)) {
    rmtHashTable_Destructor(table->text_map);
    rmtFree((void *)table->text_map);
    table->text_map = (rmtHashTable *)((void *)0);
  }
  if ((unsigned long )table->text != (unsigned long )((void *)0)) {
    Buffer_Destructor(table->text);
    rmtFree((void *)table->text);
    table->text = (Buffer *)((void *)0);
  }
  return;
}
}
static rmtPStr StringTable_Find(StringTable *table , rmtU32 name_hash ) 
{ 
  rmtU64 text_offset ;
  rmtU64 tmp ;

  {
  tmp = rmtHashTable_Find(table->text_map, name_hash);
  text_offset = tmp;
  if (text_offset != 0xffffffffffffffffULL) {
    return ((rmtPStr )((table->text)->data + text_offset));
  }
  return ((rmtPStr )((void *)0));
}
}
static rmtBool StringTable_Insert(StringTable *table , rmtU32 name_hash , rmtPStr name ) 
{ 
  rmtU64 text_offset ;
  rmtU64 tmp ;

  {
  tmp = rmtHashTable_Find(table->text_map, name_hash);
  text_offset = tmp;
  if (text_offset == 0xffffffffffffffffULL) {
    text_offset = (rmtU64 )(table->text)->bytes_used;
    Buffer_WriteStringZ(table->text, name);
    rmtHashTable_Insert(table->text_map, name_hash, text_offset);
    return ((rmtBool )1);
  }
  return ((rmtBool )0);
}
}
static void TCPSocket_Close(TCPSocket *tcp_socket ) ;
static rmtError InitialiseNetwork(void) 
{ 


  {
  return ((rmtError )0);
}
}
static void ShutdownNetwork(void) 
{ 


  {
  return;
}
}
static rmtError TCPSocket_Constructor(TCPSocket *tcp_socket ) 
{ 
  rmtError tmp___0 ;

  {
  if (! ((unsigned long )tcp_socket != (unsigned long )((void *)0))) {
    __assert_fail("tcp_socket != NULL", "lib/Remotery.c", 2931U, "TCPSocket_Constructor");
  }
  tcp_socket->socket = -1;
  tmp___0 = InitialiseNetwork();
  return (tmp___0);
}
}
static void TCPSocket_Destructor(TCPSocket *tcp_socket ) 
{ 


  {
  if (! ((unsigned long )tcp_socket != (unsigned long )((void *)0))) {
    __assert_fail("tcp_socket != NULL", "lib/Remotery.c", 2938U, "TCPSocket_Destructor");
  }
  TCPSocket_Close(tcp_socket);
  ShutdownNetwork();
  return;
}
}
static rmtError TCPSocket_RunServer(TCPSocket *tcp_socket , rmtU16 port , rmtBool reuse_open_port ,
                                    rmtBool limit_connections_to_localhost ) 
{ 
  SOCKET s ;
  struct sockaddr_in sin___0 ;
  rmtError tmp___0 ;
  int enable ;
  in_addr_t tmp___1 ;
  rmtError tmp___2 ;
  int tmp___3 ;
  rmtError tmp___4 ;
  int tmp___5 ;
  rmtError tmp___6 ;
  int tmp___7 ;

  {
  s = -1;
  memset((void *)(& sin___0), 0, sizeof(sin___0));
  if (! ((unsigned long )tcp_socket != (unsigned long )((void *)0))) {
    __assert_fail("tcp_socket != NULL", "lib/Remotery.c", 2953U, "TCPSocket_RunServer");
  }
  s = socket(2, 1, 6);
  if (s == -1) {
    tmp___0 = rmtMakeError((rmtError )4, "Can\'t create a socket for connection to the remote viewer");
    return (tmp___0);
  }
  if (reuse_open_port) {
    enable = 1;
    setsockopt(s, 1, 2, (void const   *)(& enable), (socklen_t )sizeof(enable));
  }
  sin___0.sin_family = (sa_family_t )2;
  if (limit_connections_to_localhost) {
    tmp___1 = (in_addr_t )2130706433;
  } else {
    tmp___1 = (in_addr_t )0;
  }
  sin___0.sin_addr.s_addr = htonl(tmp___1);
  sin___0.sin_port = htons(port);
  tmp___3 = bind(s, (struct sockaddr  const  *)((struct sockaddr *)(& sin___0)), (socklen_t )sizeof(sin___0));
  if (tmp___3 == -1) {
    tmp___2 = rmtMakeError((rmtError )5, "Can\'t bind a socket for the server");
    return (tmp___2);
  }
  tcp_socket->socket = s;
  tmp___5 = listen(s, 1);
  if (tmp___5 == -1) {
    tmp___4 = rmtMakeError((rmtError )5, "Created server socket failed to enter a listen state");
    return (tmp___4);
  }
  tmp___7 = fcntl(tcp_socket->socket, 4, 2048);
  if (tmp___7 == -1) {
    tmp___6 = rmtMakeError((rmtError )5, "Created server socket failed to switch to a non-blocking state");
    return (tmp___6);
  }
  return ((rmtError )0);
}
}
static void TCPSocket_Close(TCPSocket *tcp_socket ) 
{ 
  int result ;
  int tmp___0 ;
  int total ;
  char temp_buf[128] ;
  ssize_t tmp___1 ;

  {
  if (! ((unsigned long )tcp_socket != (unsigned long )((void *)0))) {
    __assert_fail("tcp_socket != NULL", "lib/Remotery.c", 3017U, "TCPSocket_Close");
  }
  if (tcp_socket->socket != -1) {
    tmp___0 = shutdown(tcp_socket->socket, 1);
    result = tmp___0;
    if (result != -1) {
      total = 0;
      while (result > 0) {
        tmp___1 = recv(tcp_socket->socket, (void *)(temp_buf), sizeof(temp_buf), 0);
        result = (int )tmp___1;
        total += result;
      }
    }
    close(tcp_socket->socket);
    tcp_socket->socket = -1;
  }
  return;
}
}
static SocketStatus TCPSocket_PollStatus(TCPSocket *tcp_socket ) 
{ 
  SocketStatus status ;
  fd_set fd_read ;
  fd_set fd_write ;
  fd_set fd_errors ;
  struct timeval tv ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int __d0___1 ;
  int __d1___1 ;
  int tmp___0 ;

  {
  status.can_read = (rmtBool )0;
  status.can_write = (rmtBool )0;
  status.error_state = (rmtError )0;
  if (! ((unsigned long )tcp_socket != (unsigned long )((void *)0))) {
    __assert_fail("tcp_socket != NULL", "lib/Remotery.c", 3051U, "TCPSocket_PollStatus");
  }
  if (tcp_socket->socket == -1) {
    status.error_state = (rmtError )12;
    return (status);
  }
  while (1) {
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fd_read.__fds_bits[0]): "memory");
    break;
  }
  while (1) {
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fd_write.__fds_bits[0]): "memory");
    break;
  }
  while (1) {
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___1), "=D" (__d1___1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fd_errors.__fds_bits[0]): "memory");
    break;
  }
  fd_read.__fds_bits[tcp_socket->socket / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << tcp_socket->socket % (8 * (int )sizeof(__fd_mask )));
  fd_write.__fds_bits[tcp_socket->socket / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << tcp_socket->socket % (8 * (int )sizeof(__fd_mask )));
  fd_errors.__fds_bits[tcp_socket->socket / (8 * (int )sizeof(__fd_mask ))] |= (__fd_mask )(1UL << tcp_socket->socket % (8 * (int )sizeof(__fd_mask )));
  tv.tv_sec = (__time_t )0;
  tv.tv_usec = (__suseconds_t )0;
  tmp___0 = select(tcp_socket->socket + 1, (fd_set * __restrict  )(& fd_read), (fd_set * __restrict  )(& fd_write),
                   (fd_set * __restrict  )(& fd_errors), (struct timeval * __restrict  )(& tv));
  if (tmp___0 == -1) {
    status.error_state = (rmtError )13;
    return (status);
  }
  if (((fd_read.__fds_bits[tcp_socket->socket / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << tcp_socket->socket % (8 * (int )sizeof(__fd_mask )))) != 0L) != 0) {
    status.can_read = (rmtBool )1;
  } else {
    status.can_read = (rmtBool )0;
  }
  if (((fd_write.__fds_bits[tcp_socket->socket / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << tcp_socket->socket % (8 * (int )sizeof(__fd_mask )))) != 0L) != 0) {
    status.can_write = (rmtBool )1;
  } else {
    status.can_write = (rmtBool )0;
  }
  if (((fd_errors.__fds_bits[tcp_socket->socket / (8 * (int )sizeof(__fd_mask ))] & (__fd_mask )(1UL << tcp_socket->socket % (8 * (int )sizeof(__fd_mask )))) != 0L) != 0) {
    status.error_state = (rmtError )14;
  } else {
    status.error_state = (rmtError )0;
  }
  return (status);
}
}
static rmtError TCPSocket_AcceptConnection(TCPSocket *tcp_socket , TCPSocket **client_socket ) 
{ 
  SocketStatus status ;
  SOCKET s ;
  rmtError tmp___0 ;
  void *tmp___2 ;
  rmtError error ;
  rmtError tmp___3 ;

  {
  if (! ((unsigned long )tcp_socket != (unsigned long )((void *)0))) {
    __assert_fail("tcp_socket != NULL", "lib/Remotery.c", 3094U, "TCPSocket_AcceptConnection");
  }
  status = TCPSocket_PollStatus(tcp_socket);
  if ((unsigned int )status.error_state != 0U) {
    return (status.error_state);
  } else
  if (! status.can_read) {
    return (status.error_state);
  }
  s = accept(tcp_socket->socket, (struct sockaddr * __restrict  )0, (socklen_t * __restrict  )0);
  if (s == -1) {
    tmp___0 = rmtMakeError((rmtError )4, "Server failed to accept connection from client");
    return (tmp___0);
  }
  if (! ((unsigned long )client_socket != (unsigned long )((void *)0))) {
    __assert_fail("client_socket != NULL", "lib/Remotery.c", 3119U, "TCPSocket_AcceptConnection");
  }
  tmp___2 = rmtMalloc((rmtU32 )sizeof(TCPSocket ));
  *client_socket = (TCPSocket *)tmp___2;
  if ((unsigned long )*client_socket == (unsigned long )((void *)0)) {
    return ((rmtError )7);
  }
  tmp___3 = TCPSocket_Constructor(*client_socket);
  error = tmp___3;
  if ((unsigned int )error != 0U) {
    if ((unsigned long )*client_socket != (unsigned long )((void *)0)) {
      TCPSocket_Destructor(*client_socket);
      rmtFree((void *)*client_socket);
      *client_socket = (TCPSocket *)((void *)0);
    }
    return (error);
  }
  (*client_socket)->socket = s;
  return ((rmtError )0);
}
}
static int TCPTryAgain(void) 
{ 
  int *tmp ;

  {
  tmp = __errno_location();
  return (*tmp == 11);
}
}
static rmtError TCPSocket_Send(TCPSocket *tcp_socket , void const   *data , rmtU32 length ,
                               rmtU32 timeout_ms ) 
{ 
  SocketStatus status ;
  char *cur_data ;
  char *end_data ;
  rmtU32 start_ms ;
  rmtU32 cur_ms ;
  rmtError tmp___0 ;
  int bytes_sent ;
  int send_flags ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  rmtError tmp___3 ;

  {
  cur_data = (char *)((void *)0);
  end_data = (char *)((void *)0);
  start_ms = (rmtU32 )0;
  cur_ms = (rmtU32 )0;
  if (! ((unsigned long )tcp_socket != (unsigned long )((void *)0))) {
    __assert_fail("tcp_socket != NULL", "lib/Remotery.c", 3148U, "TCPSocket_Send");
  }
  start_ms = msTimer_Get();
  status.can_write = (rmtBool )0;
  while (! status.can_write) {
    status = TCPSocket_PollStatus(tcp_socket);
    if ((unsigned int )status.error_state != 0U) {
      return (status.error_state);
    }
    cur_ms = msTimer_Get();
    if (cur_ms - start_ms > timeout_ms) {
      tmp___0 = rmtMakeError((rmtError )6, "Timed out trying to send data");
      return (tmp___0);
    }
  }
  cur_data = (char *)data;
  end_data = cur_data + length;
  while ((unsigned long )cur_data < (unsigned long )end_data) {
    send_flags = 0;
    send_flags = 16384;
    tmp___1 = send(tcp_socket->socket, (void const   *)cur_data, (size_t )((int )(end_data - cur_data)),
                   send_flags);
    bytes_sent = (int )tmp___1;
    if (bytes_sent == -1) {
      goto _L;
    } else
    if (bytes_sent == 0) {
      _L: /* CIL Label */ 
      if (bytes_sent != 0) {
        tmp___2 = TCPTryAgain();
        if (! tmp___2) {
          return ((rmtError )15);
        }
      }
      cur_ms = msTimer_Get();
      if (cur_ms < start_ms) {
        start_ms = cur_ms;
        continue;
      }
      if (cur_ms - start_ms > timeout_ms) {
        tmp___3 = rmtMakeError((rmtError )6, "Timed out trying to send data");
        return (tmp___3);
      }
    } else {
      cur_data += bytes_sent;
    }
  }
  return ((rmtError )0);
}
}
static rmtError TCPSocket_Receive(TCPSocket *tcp_socket , void *data , rmtU32 length ,
                                  rmtU32 timeout_ms ) 
{ 
  SocketStatus status ;
  char *cur_data ;
  char *end_data ;
  rmtU32 start_ms ;
  rmtU32 cur_ms ;
  int bytes_received ;
  ssize_t tmp___0 ;
  int tmp___1 ;

  {
  cur_data = (char *)((void *)0);
  end_data = (char *)((void *)0);
  start_ms = (rmtU32 )0;
  cur_ms = (rmtU32 )0;
  if (! ((unsigned long )tcp_socket != (unsigned long )((void *)0))) {
    __assert_fail("tcp_socket != NULL", "lib/Remotery.c", 3230U, "TCPSocket_Receive");
  }
  status = TCPSocket_PollStatus(tcp_socket);
  if ((unsigned int )status.error_state != 0U) {
    return (status.error_state);
  }
  if (! status.can_read) {
    return ((rmtError )16);
  }
  cur_data = (char *)data;
  end_data = cur_data + length;
  start_ms = msTimer_Get();
  while ((unsigned long )cur_data < (unsigned long )end_data) {
    tmp___0 = recv(tcp_socket->socket, (void *)cur_data, (size_t )((int )(end_data - cur_data)),
                   0);
    bytes_received = (int )tmp___0;
    if (bytes_received == -1) {
      goto _L;
    } else
    if (bytes_received == 0) {
      _L: /* CIL Label */ 
      if (bytes_received != 0) {
        tmp___1 = TCPTryAgain();
        if (! tmp___1) {
          return ((rmtError )18);
        }
      }
      cur_ms = msTimer_Get();
      if (cur_ms < start_ms) {
        start_ms = cur_ms;
        continue;
      }
      if (cur_ms - start_ms > timeout_ms) {
        return ((rmtError )17);
      }
    } else {
      cur_data += bytes_received;
    }
  }
  return ((rmtError )0);
}
}
static unsigned int rol(unsigned int const   value , unsigned int const   steps ) 
{ 


  {
  return ((unsigned int )((value << steps) | (value >> (32U - steps))));
}
}
static void clearWBuffert(unsigned int *buffert ) 
{ 
  int pos ;

  {
  pos = 16;
  while (1) {
    pos --;
    if (! (pos >= 0)) {
      break;
    }
    *(buffert + pos) = 0U;
  }
  return;
}
}
static void innerHash(unsigned int *result , unsigned int *w ) 
{ 
  unsigned int a ;
  unsigned int b ;
  unsigned int c ;
  unsigned int d ;
  unsigned int e ;
  int round___0 ;
  unsigned int t ;
  unsigned int tmp ;
  unsigned int t___0 ;
  unsigned int tmp___0 ;
  unsigned int t___1 ;
  unsigned int tmp___1 ;
  unsigned int t___2 ;
  unsigned int tmp___2 ;
  unsigned int t___3 ;
  unsigned int tmp___3 ;

  {
  a = *(result + 0);
  b = *(result + 1);
  c = *(result + 2);
  d = *(result + 3);
  e = *(result + 4);
  round___0 = 0;
  while (round___0 < 16) {
    tmp = rol((unsigned int const   )a, (unsigned int const   )5);
    t = (((tmp + ((b & c) | (~ b & d))) + e) + 1518500249U) + *(w + round___0);
    e = d;
    d = c;
    c = rol((unsigned int const   )b, (unsigned int const   )30);
    b = a;
    a = t;
    round___0 ++;
  }
  while (round___0 < 20) {
    *(w + round___0) = rol((unsigned int const   )(((*(w + (round___0 - 3)) ^ *(w + (round___0 - 8))) ^ *(w + (round___0 - 14))) ^ *(w + (round___0 - 16))),
                           (unsigned int const   )1);
    tmp___0 = rol((unsigned int const   )a, (unsigned int const   )5);
    t___0 = (((tmp___0 + ((b & c) | (~ b & d))) + e) + 1518500249U) + *(w + round___0);
    e = d;
    d = c;
    c = rol((unsigned int const   )b, (unsigned int const   )30);
    b = a;
    a = t___0;
    round___0 ++;
  }
  while (round___0 < 40) {
    *(w + round___0) = rol((unsigned int const   )(((*(w + (round___0 - 3)) ^ *(w + (round___0 - 8))) ^ *(w + (round___0 - 14))) ^ *(w + (round___0 - 16))),
                           (unsigned int const   )1);
    tmp___1 = rol((unsigned int const   )a, (unsigned int const   )5);
    t___1 = (((tmp___1 + ((b ^ c) ^ d)) + e) + 1859775393U) + *(w + round___0);
    e = d;
    d = c;
    c = rol((unsigned int const   )b, (unsigned int const   )30);
    b = a;
    a = t___1;
    round___0 ++;
  }
  while (round___0 < 60) {
    *(w + round___0) = rol((unsigned int const   )(((*(w + (round___0 - 3)) ^ *(w + (round___0 - 8))) ^ *(w + (round___0 - 14))) ^ *(w + (round___0 - 16))),
                           (unsigned int const   )1);
    tmp___2 = rol((unsigned int const   )a, (unsigned int const   )5);
    t___2 = (((tmp___2 + (((b & c) | (b & d)) | (c & d))) + e) + 2400959708U) + *(w + round___0);
    e = d;
    d = c;
    c = rol((unsigned int const   )b, (unsigned int const   )30);
    b = a;
    a = t___2;
    round___0 ++;
  }
  while (round___0 < 80) {
    *(w + round___0) = rol((unsigned int const   )(((*(w + (round___0 - 3)) ^ *(w + (round___0 - 8))) ^ *(w + (round___0 - 14))) ^ *(w + (round___0 - 16))),
                           (unsigned int const   )1);
    tmp___3 = rol((unsigned int const   )a, (unsigned int const   )5);
    t___3 = (((tmp___3 + ((b ^ c) ^ d)) + e) + 3395469782U) + *(w + round___0);
    e = d;
    d = c;
    c = rol((unsigned int const   )b, (unsigned int const   )30);
    b = a;
    a = t___3;
    round___0 ++;
  }
  *(result + 0) += a;
  *(result + 1) += b;
  *(result + 2) += c;
  *(result + 3) += d;
  *(result + 4) += e;
  return;
}
}
static void calc(void const   *src , int const   bytelength , unsigned char *hash ) 
{ 
  int roundPos ;
  int lastBlockBytes ;
  int hashByte ;
  unsigned int result[5] ;
  unsigned char const   *sarray ;
  unsigned int w[80] ;
  int endOfFullBlocks ;
  int endCurrentBlock ;
  int currentBlock ;
  int tmp ;

  {
  result[0] = 1732584193U;
  result[1] = 4023233417U;
  result[2] = 2562383102U;
  result[3] = 271733878U;
  result[4] = 3285377520U;
  sarray = (unsigned char const   *)src;
  endOfFullBlocks = (int )(bytelength - 64);
  currentBlock = 0;
  while (currentBlock <= endOfFullBlocks) {
    endCurrentBlock = currentBlock + 64;
    roundPos = 0;
    while (currentBlock < endCurrentBlock) {
      tmp = roundPos;
      roundPos ++;
      w[tmp] = (((unsigned int )*(sarray + (currentBlock + 3)) | ((unsigned int )*(sarray + (currentBlock + 2)) << 8)) | ((unsigned int )*(sarray + (currentBlock + 1)) << 16)) | ((unsigned int )*(sarray + currentBlock) << 24);
      currentBlock += 4;
    }
    innerHash(result, w);
  }
  endCurrentBlock = (int )(bytelength - (int const   )currentBlock);
  clearWBuffert(w);
  lastBlockBytes = 0;
  while (lastBlockBytes < endCurrentBlock) {
    w[lastBlockBytes >> 2] |= (unsigned int )*(sarray + (lastBlockBytes + currentBlock)) << ((3 - (lastBlockBytes & 3)) << 3);
    lastBlockBytes ++;
  }
  w[lastBlockBytes >> 2] |= 128U << ((3 - (lastBlockBytes & 3)) << 3);
  if (endCurrentBlock >= 56) {
    innerHash(result, w);
    clearWBuffert(w);
  }
  w[15] = (unsigned int )(bytelength << 3);
  innerHash(result, w);
  hashByte = 20;
  while (1) {
    hashByte --;
    if (! (hashByte >= 0)) {
      break;
    }
    *(hash + hashByte) = (unsigned char )((result[hashByte >> 2] >> (((3 - hashByte) & 3) << 3)) & 255U);
  }
  return;
}
}
static SHA1 SHA1_Calculate(void const   *src , unsigned int length ) 
{ 
  SHA1 hash ;

  {
  if (! ((int )length >= 0)) {
    __assert_fail("(int)length >= 0", "lib/Remotery.c", 3476U, "SHA1_Calculate");
  }
  calc(src, (int const   )length, hash.data);
  return (hash);
}
}
static char const   *b64_encoding_table  =    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
static rmtU32 Base64_CalculateEncodedLength(rmtU32 length ) 
{ 


  {
  return (4U * ((length + 2U) / 3U));
}
}
static void Base64_Encode(rmtU8 const   *in_bytes , rmtU32 length , rmtU8 *out_bytes ) 
{ 
  rmtU32 i ;
  rmtU32 encoded_length ;
  rmtU32 remaining_bytes ;
  rmtU8 *optr ;
  rmtU32 c0 ;
  rmtU32 tmp ;
  int tmp___0 ;
  rmtU32 c1 ;
  rmtU32 tmp___1 ;
  int tmp___2 ;
  rmtU32 c2 ;
  rmtU32 tmp___3 ;
  int tmp___4 ;
  rmtU32 triple ;
  rmtU8 *tmp___5 ;
  rmtU8 *tmp___6 ;
  rmtU8 *tmp___7 ;
  rmtU8 *tmp___8 ;

  {
  optr = out_bytes;
  i = (rmtU32 )0;
  while (i < length) {
    if (i < length) {
      tmp = i;
      i ++;
      tmp___0 = (int const   )*(in_bytes + tmp);
    } else {
      tmp___0 = (int const   )0;
    }
    c0 = (rmtU32 )tmp___0;
    if (i < length) {
      tmp___1 = i;
      i ++;
      tmp___2 = (int const   )*(in_bytes + tmp___1);
    } else {
      tmp___2 = (int const   )0;
    }
    c1 = (rmtU32 )tmp___2;
    if (i < length) {
      tmp___3 = i;
      i ++;
      tmp___4 = (int const   )*(in_bytes + tmp___3);
    } else {
      tmp___4 = (int const   )0;
    }
    c2 = (rmtU32 )tmp___4;
    triple = ((c0 << 16) + (c1 << 8)) + c2;
    tmp___5 = optr;
    optr ++;
    *tmp___5 = (rmtU8 )*(b64_encoding_table + ((triple >> 18) & 63U));
    tmp___6 = optr;
    optr ++;
    *tmp___6 = (rmtU8 )*(b64_encoding_table + ((triple >> 12) & 63U));
    tmp___7 = optr;
    optr ++;
    *tmp___7 = (rmtU8 )*(b64_encoding_table + ((triple >> 6) & 63U));
    tmp___8 = optr;
    optr ++;
    *tmp___8 = (rmtU8 )*(b64_encoding_table + (triple & 63U));
  }
  encoded_length = Base64_CalculateEncodedLength(length);
  remaining_bytes = (3U - (length + 2U) % 3U) - 1U;
  i = (rmtU32 )0;
  while (i < remaining_bytes) {
    *(out_bytes + ((encoded_length - 1U) - i)) = (rmtU8 )'=';
    i ++;
  }
  *(out_bytes + encoded_length) = (rmtU8 )0;
  return;
}
}
static rmtU32 rotl32(rmtU32 x , rmtS8 r ) 
{ 


  {
  return ((x << (int )r) | (x >> (32 - (int )r)));
}
}
static rmtU32 getblock32(rmtU32 const   *p , int i ) 
{ 
  rmtU32 result ;
  rmtU8 const   *src ;

  {
  src = (rmtU8 const   *)p + i * (int )sizeof(rmtU32 );
  memcpy((void * __restrict  )(& result), (void const   * __restrict  )src, sizeof(result));
  return (result);
}
}
static rmtU32 fmix32(rmtU32 h ) 
{ 


  {
  h ^= h >> 16;
  h *= 2246822507U;
  h ^= h >> 13;
  h *= 3266489909U;
  h ^= h >> 16;
  return (h);
}
}
static rmtU32 MurmurHash3_x86_32(void const   *key , int len , rmtU32 seed ) 
{ 
  rmtU8 const   *data ;
  int nblocks ;
  rmtU32 h1 ;
  rmtU32 c1 ;
  rmtU32 c2 ;
  int i ;
  rmtU32 const   *blocks ;
  rmtU8 const   *tail ;
  rmtU32 k1 ;
  rmtU32 k2 ;
  rmtU32 tmp ;

  {
  data = (rmtU8 const   *)key;
  nblocks = len / 4;
  h1 = seed;
  c1 = 3432918353U;
  c2 = (rmtU32 )461845907;
  blocks = (rmtU32 const   *)(data + nblocks * 4);
  tail = data + nblocks * 4;
  k1 = (rmtU32 )0;
  i = - nblocks;
  while (i) {
    tmp = getblock32(blocks, i);
    k2 = tmp;
    k2 *= c1;
    k2 = rotl32(k2, (rmtS8 )15);
    k2 *= c2;
    h1 ^= k2;
    h1 = rotl32(h1, (rmtS8 )13);
    h1 = h1 * 5U + 3864292196U;
    i ++;
  }
  switch (len & 3) {
  case 3: 
  k1 ^= (unsigned int )((int const   )*(tail + 2) << 16);
  case 2: 
  k1 ^= (unsigned int )((int const   )*(tail + 1) << 8);
  case 1: 
  k1 ^= (unsigned int )*(tail + 0);
  k1 *= c1;
  k1 = rotl32(k1, (rmtS8 )15);
  k1 *= c2;
  h1 ^= k1;
  }
  h1 ^= (unsigned int )len;
  h1 = fmix32(h1);
  return (h1);
}
}
rmtU32 _rmt_HashString32(char const   *s , int len , rmtU32 seed ) 
{ 
  rmtU32 tmp ;

  {
  tmp = MurmurHash3_x86_32((void const   *)s, len, seed);
  return (tmp);
}
}
static void WebSocket_Close(WebSocket *web_socket ) ;
static char *GetField(char *buffer , r_size_t buffer_length , rmtPStr field_name ) 
{ 
  char *field ;
  char *buffer_end ;
  r_size_t field_length ;
  r_size_t tmp ;
  errno_t tmp___0 ;
  size_t tmp___1 ;

  {
  field = (char *)((void *)0);
  buffer_end = (buffer + buffer_length) - 1;
  tmp = strnlen_s_safe_c(field_name, buffer_length);
  field_length = tmp;
  if (field_length == 0U) {
    return ((char *)((void *)0));
  }
  tmp___0 = strstr_s(buffer, buffer_length, field_name, field_length, & field);
  if (tmp___0 != 0) {
    return ((char *)((void *)0));
  }
  tmp___1 = strlen(field_name);
  field += tmp___1;
  while ((int )*field == 32) {
    if ((unsigned long )field >= (unsigned long )buffer_end) {
      return ((char *)((void *)0));
    }
    field ++;
  }
  return (field);
}
}
static char const   websocket_guid[37]  = 
  {      (char const   )'2',      (char const   )'5',      (char const   )'8',      (char const   )'E', 
        (char const   )'A',      (char const   )'F',      (char const   )'A',      (char const   )'5', 
        (char const   )'-',      (char const   )'E',      (char const   )'9',      (char const   )'1', 
        (char const   )'4',      (char const   )'-',      (char const   )'4',      (char const   )'7', 
        (char const   )'D',      (char const   )'A',      (char const   )'-',      (char const   )'9', 
        (char const   )'5',      (char const   )'C',      (char const   )'A',      (char const   )'-', 
        (char const   )'C',      (char const   )'5',      (char const   )'A',      (char const   )'B', 
        (char const   )'0',      (char const   )'D',      (char const   )'C',      (char const   )'8', 
        (char const   )'5',      (char const   )'B',      (char const   )'1',      (char const   )'1', 
        (char const   )'\000'};
static char const   websocket_response[98]  = 
  {      (char const   )'H',      (char const   )'T',      (char const   )'T',      (char const   )'P', 
        (char const   )'/',      (char const   )'1',      (char const   )'.',      (char const   )'1', 
        (char const   )' ',      (char const   )'1',      (char const   )'0',      (char const   )'1', 
        (char const   )' ',      (char const   )'S',      (char const   )'w',      (char const   )'i', 
        (char const   )'t',      (char const   )'c',      (char const   )'h',      (char const   )'i', 
        (char const   )'n',      (char const   )'g',      (char const   )' ',      (char const   )'P', 
        (char const   )'r',      (char const   )'o',      (char const   )'t',      (char const   )'o', 
        (char const   )'c',      (char const   )'o',      (char const   )'l',      (char const   )'s', 
        (char const   )'\r',      (char const   )'\n',      (char const   )'U',      (char const   )'p', 
        (char const   )'g',      (char const   )'r',      (char const   )'a',      (char const   )'d', 
        (char const   )'e',      (char const   )':',      (char const   )' ',      (char const   )'w', 
        (char const   )'e',      (char const   )'b',      (char const   )'s',      (char const   )'o', 
        (char const   )'c',      (char const   )'k',      (char const   )'e',      (char const   )'t', 
        (char const   )'\r',      (char const   )'\n',      (char const   )'C',      (char const   )'o', 
        (char const   )'n',      (char const   )'n',      (char const   )'e',      (char const   )'c', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )':',      (char const   )' ',      (char const   )'U',      (char const   )'p', 
        (char const   )'g',      (char const   )'r',      (char const   )'a',      (char const   )'d', 
        (char const   )'e',      (char const   )'\r',      (char const   )'\n',      (char const   )'S', 
        (char const   )'e',      (char const   )'c',      (char const   )'-',      (char const   )'W', 
        (char const   )'e',      (char const   )'b',      (char const   )'S',      (char const   )'o', 
        (char const   )'c',      (char const   )'k',      (char const   )'e',      (char const   )'t', 
        (char const   )'-',      (char const   )'A',      (char const   )'c',      (char const   )'c', 
        (char const   )'e',      (char const   )'p',      (char const   )'t',      (char const   )':', 
        (char const   )' ',      (char const   )'\000'};
static rmtError WebSocketHandshake(TCPSocket *tcp_socket , rmtPStr limit_host ) 
{ 
  rmtU32 start_ms ;
  rmtU32 now_ms ;
  char buffer[1024] ;
  char *buffer_ptr ;
  int buffer_len ;
  char *buffer_end ;
  char response_buffer[256] ;
  int response_buffer_len ;
  char *version ;
  char *host ;
  char *key ;
  char *key_end ;
  SHA1 hash ;
  rmtError error ;
  rmtError tmp___0 ;
  int tmp___2 ;
  r_size_t limit_host_len ;
  r_size_t tmp___3 ;
  char *found ;
  errno_t tmp___4 ;
  errno_t tmp___5 ;
  errno_t tmp___6 ;
  errno_t tmp___7 ;
  r_size_t tmp___8 ;
  errno_t tmp___9 ;
  errno_t tmp___10 ;
  errno_t tmp___11 ;
  r_size_t tmp___12 ;
  rmtError tmp___13 ;

  {
  buffer_ptr = buffer;
  buffer_len = (int )(sizeof(buffer) - 1UL);
  buffer_end = buffer + buffer_len;
  response_buffer_len = (int )(sizeof(response_buffer) - 1UL);
  if (! ((unsigned long )tcp_socket != (unsigned long )((void *)0))) {
    __assert_fail("tcp_socket != NULL", "lib/Remotery.c", 3731U, "WebSocketHandshake");
  }
  start_ms = msTimer_Get();
  while (buffer_ptr - buffer < (long )buffer_len) {
    tmp___0 = TCPSocket_Receive(tcp_socket, (void *)buffer_ptr, (rmtU32 )1, (rmtU32 )20);
    error = tmp___0;
    if ((unsigned int )error == 18U) {
      return (error);
    }
    if ((unsigned int )error == 16U) {
      goto _L;
    } else
    if ((unsigned int )error == 17U) {
      _L: /* CIL Label */ 
      now_ms = msTimer_Get();
      if (now_ms - start_ms > 1000U) {
        return ((rmtError )17);
      }
      continue;
    }
    if (! ((unsigned int )error == 0U)) {
      __assert_fail("error == RMT_ERROR_NONE", "lib/Remotery.c", 3754U, "WebSocketHandshake");
    }
    if (buffer_ptr - buffer >= 4L) {
      if ((int )*(buffer_ptr - 3) == 13) {
        if ((int )*(buffer_ptr - 2) == 10) {
          if ((int )*(buffer_ptr - 1) == 13) {
            if ((int )*(buffer_ptr - 0) == 10) {
              break;
            }
          }
        }
      }
    }
    buffer_ptr ++;
  }
  *buffer_ptr = (char)0;
  tmp___2 = memcmp((void const   *)(buffer), (void const   *)"GET", (size_t )3);
  if (tmp___2 != 0) {
    return ((rmtError )19);
  }
  version = GetField(buffer, (r_size_t )buffer_len, "Sec-WebSocket-Version:");
  if ((unsigned long )version == (unsigned long )((void *)0)) {
    return ((rmtError )20);
  }
  if (buffer_end - version < 2L) {
    return ((rmtError )21);
  } else
  if ((int )*(version + 0) != 56) {
    if ((int )*(version + 0) != 49) {
      return ((rmtError )21);
    } else
    if ((int )*(version + 1) != 51) {
      return ((rmtError )21);
    }
  }
  host = GetField(buffer, (r_size_t )buffer_len, "Host:");
  if ((unsigned long )host == (unsigned long )((void *)0)) {
    return ((rmtError )22);
  }
  if ((unsigned long )limit_host != (unsigned long )((void *)0)) {
    tmp___3 = strnlen_s_safe_c(limit_host, (r_size_t )128);
    limit_host_len = tmp___3;
    found = (char *)((void *)0);
    tmp___4 = strstr_s(host, (r_size_t )(buffer_end - host), limit_host, limit_host_len,
                       & found);
    if (tmp___4 != 0) {
      return ((rmtError )23);
    }
  }
  key = GetField(buffer, (r_size_t )buffer_len, "Sec-WebSocket-Key:");
  if ((unsigned long )key == (unsigned long )((void *)0)) {
    return ((rmtError )24);
  }
  tmp___5 = strstr_s(key, (r_size_t )(buffer_end - key), "\r\n", (r_size_t )2, & key_end);
  if (tmp___5 != 0) {
    return ((rmtError )25);
  }
  *key_end = (char)0;
  buffer[0] = (char)0;
  tmp___6 = strncat_s_safe_c(buffer, (r_size_t )buffer_len, (char const   *)key, (r_size_t )(key_end - key));
  if (tmp___6 != 0) {
    return ((rmtError )26);
  }
  tmp___7 = strncat_s_safe_c(buffer, (r_size_t )buffer_len, websocket_guid, (r_size_t )sizeof(websocket_guid));
  if (tmp___7 != 0) {
    return ((rmtError )26);
  }
  tmp___8 = strnlen_s_safe_c((char const   *)(buffer), (r_size_t )buffer_len);
  hash = SHA1_Calculate((void const   *)(buffer), tmp___8);
  Base64_Encode((rmtU8 const   *)(hash.data), (rmtU32 )sizeof(hash.data), (rmtU8 *)(buffer));
  response_buffer[0] = (char)0;
  tmp___9 = strncat_s_safe_c(response_buffer, (r_size_t )response_buffer_len, websocket_response,
                             (r_size_t )sizeof(websocket_response));
  if (tmp___9 != 0) {
    return ((rmtError )26);
  }
  tmp___10 = strncat_s_safe_c(response_buffer, (r_size_t )response_buffer_len, (char const   *)(buffer),
                              (r_size_t )buffer_len);
  if (tmp___10 != 0) {
    return ((rmtError )26);
  }
  tmp___11 = strncat_s_safe_c(response_buffer, (r_size_t )response_buffer_len, "\r\n\r\n",
                              (r_size_t )4);
  if (tmp___11 != 0) {
    return ((rmtError )26);
  }
  tmp___12 = strnlen_s_safe_c((char const   *)(response_buffer), (r_size_t )response_buffer_len);
  tmp___13 = TCPSocket_Send(tcp_socket, (void const   *)(response_buffer), tmp___12,
                            (rmtU32 )1000);
  return (tmp___13);
}
}
static rmtError WebSocket_Constructor(WebSocket *web_socket , TCPSocket *tcp_socket ) 
{ 
  rmtError error ;
  void *tmp___0 ;
  rmtError error___0 ;
  rmtError tmp___1 ;

  {
  error = (rmtError )0;
  if (! ((unsigned long )web_socket != (unsigned long )((void *)0))) {
    __assert_fail("web_socket != NULL", "lib/Remotery.c", 3824U, "WebSocket_Constructor");
  }
  web_socket->tcp_socket = tcp_socket;
  web_socket->mode = (enum WebSocketMode )0;
  web_socket->frame_bytes_remaining = (rmtU32 )0;
  web_socket->mask_offset = (rmtU32 )0;
  web_socket->data.mask[0] = (rmtU8 )0;
  web_socket->data.mask[1] = (rmtU8 )0;
  web_socket->data.mask[2] = (rmtU8 )0;
  web_socket->data.mask[3] = (rmtU8 )0;
  if ((unsigned long )web_socket->tcp_socket == (unsigned long )((void *)0)) {
    tmp___0 = rmtMalloc((rmtU32 )sizeof(TCPSocket ));
    web_socket->tcp_socket = (TCPSocket *)tmp___0;
    if ((unsigned long )web_socket->tcp_socket == (unsigned long )((void *)0)) {
      return ((rmtError )7);
    }
    tmp___1 = TCPSocket_Constructor(web_socket->tcp_socket);
    error___0 = tmp___1;
    if ((unsigned int )error___0 != 0U) {
      if ((unsigned long )web_socket->tcp_socket != (unsigned long )((void *)0)) {
        TCPSocket_Destructor(web_socket->tcp_socket);
        rmtFree((void *)web_socket->tcp_socket);
        web_socket->tcp_socket = (TCPSocket *)((void *)0);
      }
      return (error___0);
    }
  }
  return (error);
}
}
static void WebSocket_Destructor(WebSocket *web_socket ) 
{ 


  {
  WebSocket_Close(web_socket);
  return;
}
}
static rmtError WebSocket_RunServer(WebSocket *web_socket , rmtU16 port , rmtBool reuse_open_port ,
                                    rmtBool limit_connections_to_localhost , enum WebSocketMode mode ) 
{ 
  rmtError tmp___0 ;

  {
  if (! ((unsigned long )web_socket != (unsigned long )((void *)0))) {
    __assert_fail("web_socket != NULL", "lib/Remotery.c", 3850U, "WebSocket_RunServer");
  }
  web_socket->mode = mode;
  tmp___0 = TCPSocket_RunServer(web_socket->tcp_socket, port, reuse_open_port, limit_connections_to_localhost);
  return (tmp___0);
}
}
static void WebSocket_Close(WebSocket *web_socket ) 
{ 


  {
  if (! ((unsigned long )web_socket != (unsigned long )((void *)0))) {
    __assert_fail("web_socket != NULL", "lib/Remotery.c", 3857U, "WebSocket_Close");
  }
  if ((unsigned long )web_socket->tcp_socket != (unsigned long )((void *)0)) {
    TCPSocket_Destructor(web_socket->tcp_socket);
    rmtFree((void *)web_socket->tcp_socket);
    web_socket->tcp_socket = (TCPSocket *)((void *)0);
  }
  return;
}
}
static SocketStatus WebSocket_PollStatus(WebSocket *web_socket ) 
{ 
  SocketStatus tmp___0 ;

  {
  if (! ((unsigned long )web_socket != (unsigned long )((void *)0))) {
    __assert_fail("web_socket != NULL", "lib/Remotery.c", 3863U, "WebSocket_PollStatus");
  }
  tmp___0 = TCPSocket_PollStatus(web_socket->tcp_socket);
  return (tmp___0);
}
}
static rmtError WebSocket_AcceptConnection(WebSocket *web_socket , WebSocket **client_socket ) 
{ 
  TCPSocket *tcp_socket ;
  rmtError error ;
  rmtError tmp___0 ;
  rmtError error___0 ;
  rmtError tmp___1 ;
  void *tmp___3 ;
  rmtError error___1 ;
  rmtError tmp___4 ;

  {
  tcp_socket = (TCPSocket *)((void *)0);
  if (! ((unsigned long )web_socket != (unsigned long )((void *)0))) {
    __assert_fail("web_socket != NULL", "lib/Remotery.c", 3872U, "WebSocket_AcceptConnection");
  }
  tmp___0 = TCPSocket_AcceptConnection(web_socket->tcp_socket, & tcp_socket);
  error = tmp___0;
  if ((unsigned int )error != 0U) {
    return (error);
  }
  if ((unsigned long )tcp_socket == (unsigned long )((void *)0)) {
    return ((rmtError )0);
  }
  tmp___1 = WebSocketHandshake(tcp_socket, (rmtPStr )((void *)0));
  error___0 = tmp___1;
  if ((unsigned int )error___0 != 0U) {
    return (error___0);
  }
  if (! ((unsigned long )client_socket != (unsigned long )((void *)0))) {
    __assert_fail("client_socket != NULL", "lib/Remotery.c", 3882U, "WebSocket_AcceptConnection");
  }
  tmp___3 = rmtMalloc((rmtU32 )sizeof(WebSocket ));
  *client_socket = (WebSocket *)tmp___3;
  if ((unsigned long )*client_socket == (unsigned long )((void *)0)) {
    return ((rmtError )7);
  }
  tmp___4 = WebSocket_Constructor(*client_socket, tcp_socket);
  error___1 = tmp___4;
  if ((unsigned int )error___1 != 0U) {
    if ((unsigned long )*client_socket != (unsigned long )((void *)0)) {
      WebSocket_Destructor(*client_socket);
      rmtFree((void *)*client_socket);
      *client_socket = (WebSocket *)((void *)0);
    }
    return (error___1);
  }
  (*client_socket)->mode = web_socket->mode;
  return ((rmtError )0);
}
}
static void WriteSize(rmtU32 size , rmtU8 *dest , rmtU32 dest_size , rmtU32 dest_offset ) 
{ 
  int size_size ;
  rmtU32 i ;
  int j ;

  {
  size_size = (int )(dest_size - dest_offset);
  i = (rmtU32 )0;
  while (i < dest_size) {
    j = (int )(i - dest_offset);
    if (j < 0) {
      *(dest + i) = (rmtU8 )0;
    } else {
      *(dest + i) = (rmtU8 )((size >> ((size_size - j) - 1) * 8) & 255U);
    }
    i ++;
  }
  return;
}
}
static void WebSocket_PrepareBuffer(Buffer *buffer ) 
{ 
  char empty_frame_header[10] ;

  {
  if (! ((unsigned long )buffer != (unsigned long )((void *)0))) {
    __assert_fail("buffer != NULL", "lib/Remotery.c", 3908U, "WebSocket_PrepareBuffer");
  }
  buffer->bytes_used = (rmtU32 )0;
  Buffer_Write(buffer, (void const   *)(empty_frame_header), (rmtU32 )sizeof(empty_frame_header));
  return;
}
}
static rmtU32 WebSocket_FrameHeaderSize(rmtU32 length ) 
{ 


  {
  if (length <= 125U) {
    return ((rmtU32 )2);
  }
  if (length <= 65535U) {
    return ((rmtU32 )4);
  }
  return ((rmtU32 )10);
}
}
static void WebSocket_WriteFrameHeader(WebSocket *web_socket , rmtU8 *dest , rmtU32 length ) 
{ 
  rmtU8 final_fragment ;
  rmtU8 frame_type ;

  {
  final_fragment = (rmtU8 )(1 << 7);
  frame_type = (rmtU8 )web_socket->mode;
  *(dest + 0) = (rmtU8 )((int )final_fragment | (int )frame_type);
  if (length <= 125U) {
    *(dest + 1) = (rmtU8 )length;
  } else
  if (length <= 65535U) {
    *(dest + 1) = (rmtU8 )126;
    WriteSize(length, dest + 2, (rmtU32 )2, (rmtU32 )0);
  } else {
    *(dest + 1) = (rmtU8 )127;
    WriteSize(length, dest + 2, (rmtU32 )8, (rmtU32 )4);
  }
  return;
}
}
static rmtError WebSocket_Send(WebSocket *web_socket , void const   *data , rmtU32 length ,
                               rmtU32 timeout_ms ) 
{ 
  rmtError error ;
  SocketStatus status ;
  rmtU32 payload_length ;
  rmtU32 frame_header_size ;
  rmtU32 delta ;

  {
  if (! ((unsigned long )web_socket != (unsigned long )((void *)0))) {
    __assert_fail("web_socket != NULL", "lib/Remotery.c", 3956U, "WebSocket_Send");
  }
  if (! ((unsigned long )data != (unsigned long )((void *)0))) {
    __assert_fail("data != NULL", "lib/Remotery.c", 3957U, "WebSocket_Send");
  }
  status = WebSocket_PollStatus(web_socket);
  if ((unsigned int )status.error_state != 0U) {
    return (status.error_state);
  }
  payload_length = length - 10U;
  frame_header_size = WebSocket_FrameHeaderSize(payload_length);
  delta = 10U - frame_header_size;
  data = (void const   *)((void *)((rmtU8 *)data + delta));
  length -= delta;
  WebSocket_WriteFrameHeader(web_socket, (rmtU8 *)data, payload_length);
  error = TCPSocket_Send(web_socket->tcp_socket, data, length, timeout_ms);
  return (error);
}
}
static rmtError ReceiveFrameHeader(WebSocket *web_socket ) 
{ 
  rmtU8 msg_header[2] ;
  int msg_length ;
  int size_bytes_remaining ;
  int i ;
  rmtBool mask_present ;
  rmtError error ;
  rmtError tmp___0 ;
  rmtU8 size_bytes[8] ;
  rmtError error___0 ;
  rmtError tmp___1 ;
  rmtError error___1 ;
  rmtError tmp___2 ;

  {
  msg_header[0] = (rmtU8 )0;
  msg_header[1] = (rmtU8 )0;
  if (! ((unsigned long )web_socket != (unsigned long )((void *)0))) {
    __assert_fail("web_socket != NULL", "lib/Remotery.c", 3985U, "ReceiveFrameHeader");
  }
  tmp___0 = TCPSocket_Receive(web_socket->tcp_socket, (void *)(msg_header), (rmtU32 )2,
                              (rmtU32 )20);
  error = tmp___0;
  if ((unsigned int )error != 0U) {
    return (error);
  }
  if ((int )msg_header[0] == 136) {
    return ((rmtError )27);
  }
  if ((int )msg_header[0] != 129) {
    if ((int )msg_header[0] != 130) {
      return ((rmtError )28);
    }
  }
  msg_length = (int )msg_header[1] & 127;
  size_bytes_remaining = 0;
  switch (msg_length) {
  case 126: 
  size_bytes_remaining = 2;
  break;
  case 127: 
  size_bytes_remaining = 8;
  break;
  }
  if (size_bytes_remaining > 0) {
    tmp___1 = TCPSocket_Receive(web_socket->tcp_socket, (void *)(size_bytes), (rmtU32 )size_bytes_remaining,
                                (rmtU32 )20);
    error___0 = tmp___1;
    if ((unsigned int )error___0 != 0U) {
      return (error___0);
    }
    msg_length = 0;
    i = 0;
    while (i < size_bytes_remaining) {
      msg_length |= (int )size_bytes[i] << ((size_bytes_remaining - 1) - i) * 8;
      i ++;
    }
  }
  if (((int )msg_header[1] & 128) != 0) {
    mask_present = (rmtBool )1;
  } else {
    mask_present = (rmtBool )0;
  }
  if (mask_present) {
    tmp___2 = TCPSocket_Receive(web_socket->tcp_socket, (void *)(web_socket->data.mask),
                                (rmtU32 )4, (rmtU32 )20);
    error___1 = tmp___2;
    if ((unsigned int )error___1 != 0U) {
      return (error___1);
    }
  }
  web_socket->frame_bytes_remaining = (rmtU32 )msg_length;
  web_socket->mask_offset = (rmtU32 )0;
  return ((rmtError )0);
}
}
static rmtError WebSocket_Receive(WebSocket *web_socket , void *data , rmtU32 *msg_len ,
                                  rmtU32 length , rmtU32 timeout_ms ) 
{ 
  SocketStatus status ;
  char *cur_data ;
  char *end_data ;
  rmtU32 start_ms ;
  rmtU32 now_ms ;
  rmtU32 bytes_to_read ;
  rmtError error ;
  rmtError error___0 ;
  rmtError tmp___0 ;
  rmtU32 i ;

  {
  if (! ((unsigned long )web_socket != (unsigned long )((void *)0))) {
    __assert_fail("web_socket != NULL", "lib/Remotery.c", 4045U, "WebSocket_Receive");
  }
  status = WebSocket_PollStatus(web_socket);
  if ((unsigned int )status.error_state != 0U) {
    return (status.error_state);
  }
  cur_data = (char *)data;
  end_data = cur_data + length;
  start_ms = msTimer_Get();
  while ((unsigned long )cur_data < (unsigned long )end_data) {
    if (web_socket->frame_bytes_remaining == 0U) {
      tmp___0 = ReceiveFrameHeader(web_socket);
      error___0 = tmp___0;
      if ((unsigned int )error___0 != 0U) {
        return (error___0);
      }
      if ((unsigned long )msg_len != (unsigned long )((void *)0)) {
        *msg_len = web_socket->frame_bytes_remaining;
      }
    }
    if (web_socket->frame_bytes_remaining < length) {
      bytes_to_read = web_socket->frame_bytes_remaining;
    } else {
      bytes_to_read = length;
    }
    error = TCPSocket_Receive(web_socket->tcp_socket, (void *)cur_data, bytes_to_read,
                              (rmtU32 )20);
    if ((unsigned int )error == 18U) {
      return (error);
    }
    if ((unsigned int )error == 16U) {
      goto _L;
    } else
    if ((unsigned int )error == 17U) {
      _L: /* CIL Label */ 
      now_ms = msTimer_Get();
      if (now_ms - start_ms > timeout_ms) {
        return ((rmtError )17);
      }
      continue;
    }
    if (web_socket->data.mask_u32 != 0U) {
      i = (rmtU32 )0;
      while (i < bytes_to_read) {
        *((rmtU8 *)cur_data + i) = (rmtU8 )((int )*((rmtU8 *)cur_data + i) ^ (int )web_socket->data.mask[web_socket->mask_offset & 3U]);
        (web_socket->mask_offset) ++;
        i ++;
      }
    }
    cur_data += bytes_to_read;
    web_socket->frame_bytes_remaining -= bytes_to_read;
  }
  return ((rmtError )0);
}
}
static rmtError rmtMessageQueue_Constructor(rmtMessageQueue *queue , rmtU32 size ) 
{ 
  void *tmp___0 ;
  rmtError error ;
  rmtError tmp___1 ;

  {
  if (! ((unsigned long )queue != (unsigned long )((void *)0))) {
    __assert_fail("queue != NULL", "lib/Remotery.c", 4153U, "rmtMessageQueue_Constructor");
  }
  queue->size = (rmtU32 )0;
  queue->data = (VirtualMirrorBuffer *)((void *)0);
  queue->read_pos = (rmtAtomicU32 )0;
  queue->write_pos = (rmtAtomicU32 )0;
  tmp___0 = rmtMalloc((rmtU32 )sizeof(VirtualMirrorBuffer ));
  queue->data = (VirtualMirrorBuffer *)tmp___0;
  if ((unsigned long )queue->data == (unsigned long )((void *)0)) {
    return ((rmtError )7);
  }
  tmp___1 = VirtualMirrorBuffer_Constructor(queue->data, size, 10);
  error = tmp___1;
  if ((unsigned int )error != 0U) {
    if ((unsigned long )queue->data != (unsigned long )((void *)0)) {
      VirtualMirrorBuffer_Destructor(queue->data);
      rmtFree((void *)queue->data);
      queue->data = (VirtualMirrorBuffer *)((void *)0);
    }
    return (error);
  }
  queue->size = (queue->data)->size;
  memset((void *)(queue->data)->ptr, 0, (size_t )queue->size);
  return ((rmtError )0);
}
}
static void rmtMessageQueue_Destructor(rmtMessageQueue *queue ) 
{ 


  {
  if (! ((unsigned long )queue != (unsigned long )((void *)0))) {
    __assert_fail("queue != NULL", "lib/Remotery.c", 4175U, "rmtMessageQueue_Destructor");
  }
  if ((unsigned long )queue->data != (unsigned long )((void *)0)) {
    VirtualMirrorBuffer_Destructor(queue->data);
    rmtFree((void *)queue->data);
    queue->data = (VirtualMirrorBuffer *)((void *)0);
  }
  return;
}
}
static rmtU32 rmtMessageQueue_SizeForPayload(rmtU32 payload_size ) 
{ 
  rmtU32 size ;

  {
  size = (rmtU32 )(sizeof(Message ) + (unsigned long )payload_size);
  size = (size + 3U) & 4294967292U;
  return (size);
}
}
static Message *rmtMessageQueue_AllocMessage(rmtMessageQueue *queue , rmtU32 payload_size ,
                                             struct ThreadProfiler *thread_profiler ) 
{ 
  Message *msg ;
  rmtU32 write_size ;
  rmtU32 tmp ;
  rmtU32 s ;
  rmtU32 w ;
  rmtU32 tmp___1 ;
  rmtU32 r ;
  rmtU32 tmp___2 ;
  rmtBool tmp___3 ;

  {
  tmp = rmtMessageQueue_SizeForPayload(payload_size);
  write_size = tmp;
  if (! ((unsigned long )queue != (unsigned long )((void *)0))) {
    __assert_fail("queue != NULL", "lib/Remotery.c", 4198U, "rmtMessageQueue_AllocMessage");
  }
  while (1) {
    s = queue->size;
    tmp___1 = LoadAcquire(& queue->write_pos);
    w = tmp___1;
    tmp___2 = LoadAcquire(& queue->read_pos);
    r = tmp___2;
    if ((int )(w - r) > (int )(s - write_size)) {
      return ((Message *)((void *)0));
    }
    msg = (Message *)((queue->data)->ptr + (w & (s - 1U)));
    tmp___3 = AtomicCompareAndSwapU32(& queue->write_pos, (long )w, (long )(w + write_size));
    if (tmp___3 == 1U) {
      msg->payload_size = payload_size;
      msg->threadProfiler = thread_profiler;
      break;
    }
  }
  return (msg);
}
}
static void rmtMessageQueue_CommitMessage(Message *message , MessageID id ) 
{ 
  rmtU32 tmp___3 ;

  {
  if (! ((unsigned long )message != (unsigned long )((void *)0))) {
    __assert_fail("message != NULL", "lib/Remotery.c", 4229U, "rmtMessageQueue_CommitMessage");
  }
  tmp___3 = LoadAcquire((rmtAtomicU32 *)((rmtU32 *)(& message->id)));
  if (! (tmp___3 == 0U)) {
    __assert_fail("LoadAcquire((rmtU32*)&message->id) == MsgID_NotReady", "lib/Remotery.c",
                  4232U, "rmtMessageQueue_CommitMessage");
  }
  StoreRelease((rmtAtomicU32 *)((rmtU32 *)(& message->id)), (rmtU32 )id);
  return;
}
}
Message *rmtMessageQueue_PeekNextMessage(rmtMessageQueue *queue ) 
{ 
  Message *ptr ;
  rmtU32 r ;
  rmtU32 w ;
  MessageID id ;
  rmtU32 tmp___0 ;

  {
  if (! ((unsigned long )queue != (unsigned long )((void *)0))) {
    __assert_fail("queue != NULL", "lib/Remotery.c", 4242U, "rmtMessageQueue_PeekNextMessage");
  }
  w = LoadAcquire(& queue->write_pos);
  r = (rmtU32 )queue->read_pos;
  if (w - r == 0U) {
    return ((Message *)((void *)0));
  }
  r &= queue->size - 1U;
  ptr = (Message *)((queue->data)->ptr + r);
  tmp___0 = LoadAcquire((rmtAtomicU32 *)((rmtU32 *)(& ptr->id)));
  id = (MessageID )tmp___0;
  if ((unsigned int )id != 0U) {
    return (ptr);
  }
  return ((Message *)((void *)0));
}
}
static void rmtMessageQueue_ConsumeNextMessage(rmtMessageQueue *queue , Message *message ) 
{ 
  rmtU32 message_size ;
  rmtU32 read_pos ;

  {
  if (! ((unsigned long )queue != (unsigned long )((void *)0))) {
    __assert_fail("queue != NULL", "lib/Remotery.c", 4266U, "rmtMessageQueue_ConsumeNextMessage");
  }
  if (! ((unsigned long )message != (unsigned long )((void *)0))) {
    __assert_fail("message != NULL", "lib/Remotery.c", 4267U, "rmtMessageQueue_ConsumeNextMessage");
  }
  message_size = rmtMessageQueue_SizeForPayload(message->payload_size);
  memset((void *)message, 0, (size_t )message_size);
  read_pos = (rmtU32 )(queue->read_pos + (rmtAtomicU32 )message_size);
  StoreRelease(& queue->read_pos, read_pos);
  return;
}
}
static rmtError Server_CreateListenSocket(Server *server , rmtU16 port , rmtBool reuse_open_port ,
                                          rmtBool limit_connections_to_localhost ) 
{ 
  void *tmp ;
  rmtError error ;
  rmtError tmp___0 ;
  rmtError error___0 ;
  rmtError tmp___1 ;

  {
  tmp = rmtMalloc((rmtU32 )sizeof(WebSocket ));
  server->listen_socket = (WebSocket *)tmp;
  if ((unsigned long )server->listen_socket == (unsigned long )((void *)0)) {
    return ((rmtError )7);
  }
  tmp___0 = WebSocket_Constructor(server->listen_socket, (TCPSocket *)((void *)0));
  error = tmp___0;
  if ((unsigned int )error != 0U) {
    if ((unsigned long )server->listen_socket != (unsigned long )((void *)0)) {
      WebSocket_Destructor(server->listen_socket);
      rmtFree((void *)server->listen_socket);
      server->listen_socket = (WebSocket *)((void *)0);
    }
    return (error);
  }
  tmp___1 = WebSocket_RunServer(server->listen_socket, port, reuse_open_port, limit_connections_to_localhost,
                                (enum WebSocketMode )2);
  error___0 = tmp___1;
  if ((unsigned int )error___0 != 0U) {
    return (error___0);
  }
  return ((rmtError )0);
}
}
static rmtError Server_Constructor(Server *server , rmtU16 port , rmtBool reuse_open_port ,
                                   rmtBool limit_connections_to_localhost ) 
{ 
  void *tmp___0 ;
  rmtError error ;
  rmtError tmp___1 ;
  rmtError tmp___2 ;

  {
  if (! ((unsigned long )server != (unsigned long )((void *)0))) {
    __assert_fail("server != NULL", "lib/Remotery.c", 4328U, "Server_Constructor");
  }
  server->listen_socket = (WebSocket *)((void *)0);
  server->client_socket = (WebSocket *)((void *)0);
  server->last_ping_time = (rmtU32 )0;
  server->port = port;
  server->reuse_open_port = reuse_open_port;
  server->limit_connections_to_localhost = limit_connections_to_localhost;
  server->bin_buf = (Buffer *)((void *)0);
  server->receive_handler = (rmtError (*)(void * , char * , rmtU32  ))((void *)0);
  server->receive_handler_context = (void *)0;
  tmp___0 = rmtMalloc((rmtU32 )sizeof(Buffer ));
  server->bin_buf = (Buffer *)tmp___0;
  if ((unsigned long )server->bin_buf == (unsigned long )((void *)0)) {
    return ((rmtError )7);
  }
  tmp___1 = Buffer_Constructor(server->bin_buf, (rmtU32 )4096);
  error = tmp___1;
  if ((unsigned int )error != 0U) {
    if ((unsigned long )server->bin_buf != (unsigned long )((void *)0)) {
      Buffer_Destructor(server->bin_buf);
      rmtFree((void *)server->bin_buf);
      server->bin_buf = (Buffer *)((void *)0);
    }
    return (error);
  }
  tmp___2 = Server_CreateListenSocket(server, port, reuse_open_port, limit_connections_to_localhost);
  return (tmp___2);
}
}
static void Server_Destructor(Server *server ) 
{ 


  {
  if (! ((unsigned long )server != (unsigned long )((void *)0))) {
    __assert_fail("server != NULL", "lib/Remotery.c", 4348U, "Server_Destructor");
  }
  if ((unsigned long )server->client_socket != (unsigned long )((void *)0)) {
    WebSocket_Destructor(server->client_socket);
    rmtFree((void *)server->client_socket);
    server->client_socket = (WebSocket *)((void *)0);
  }
  if ((unsigned long )server->listen_socket != (unsigned long )((void *)0)) {
    WebSocket_Destructor(server->listen_socket);
    rmtFree((void *)server->listen_socket);
    server->listen_socket = (WebSocket *)((void *)0);
  }
  if ((unsigned long )server->bin_buf != (unsigned long )((void *)0)) {
    Buffer_Destructor(server->bin_buf);
    rmtFree((void *)server->bin_buf);
    server->bin_buf = (Buffer *)((void *)0);
  }
  return;
}
}
static rmtBool Server_IsClientConnected(Server *server ) 
{ 
  rmtBool tmp___0 ;

  {
  if (! ((unsigned long )server != (unsigned long )((void *)0))) {
    __assert_fail("server != NULL", "lib/Remotery.c", 4356U, "Server_IsClientConnected");
  }
  if ((unsigned long )server->client_socket != (unsigned long )((void *)0)) {
    tmp___0 = (rmtBool )1;
  } else {
    tmp___0 = (rmtBool )0;
  }
  return (tmp___0);
}
}
static void Server_DisconnectClient(Server *server ) 
{ 
  WebSocket *client_socket ;

  {
  if (! ((unsigned long )server != (unsigned long )((void *)0))) {
    __assert_fail("server != NULL", "lib/Remotery.c", 4364U, "Server_DisconnectClient");
  }
  client_socket = server->client_socket;
  server->client_socket = (WebSocket *)((void *)0);
  CompilerWriteFence();
  if ((unsigned long )client_socket != (unsigned long )((void *)0)) {
    WebSocket_Destructor(client_socket);
    rmtFree((void *)client_socket);
    client_socket = (WebSocket *)((void *)0);
  }
  return;
}
}
static rmtError Server_Send(Server *server , void const   *data , rmtU32 length ,
                            rmtU32 timeout ) 
{ 
  rmtError error ;
  rmtError tmp___0 ;
  rmtBool tmp___1 ;

  {
  if (! ((unsigned long )server != (unsigned long )((void *)0))) {
    __assert_fail("server != NULL", "lib/Remotery.c", 4375U, "Server_Send");
  }
  tmp___1 = Server_IsClientConnected(server);
  if (tmp___1) {
    tmp___0 = WebSocket_Send(server->client_socket, data, length, timeout);
    error = tmp___0;
    if ((unsigned int )error == 15U) {
      Server_DisconnectClient(server);
    }
    return (error);
  }
  return ((rmtError )0);
}
}
static rmtError Server_ReceiveMessage(Server *server , char message_first_byte , rmtU32 message_length ) 
{ 
  char message_data[1024] ;
  rmtError error ;
  rmtError tmp ;
  rmtError error___0 ;
  rmtError tmp___0 ;

  {
  if ((unsigned long )message_length >= sizeof(message_data) - 1UL) {
    _rmt_LogText("Ignoring console input bigger than internal receive buffer (1024 bytes)");
    return ((rmtError )0);
  }
  message_data[0] = message_first_byte;
  tmp = WebSocket_Receive(server->client_socket, (void *)(message_data + 1), (rmtU32 *)((void *)0),
                          message_length - 1U, (rmtU32 )100);
  error = tmp;
  if ((unsigned int )error != 0U) {
    return (error);
  }
  message_data[message_length] = (char)0;
  if (message_length < 4U) {
    return ((rmtError )0);
  }
  if (server->receive_handler) {
    tmp___0 = (*(server->receive_handler))(server->receive_handler_context, message_data,
                                           message_length);
    error___0 = tmp___0;
    if ((unsigned int )error___0 != 0U) {
      return (error___0);
    }
  }
  return ((rmtError )0);
}
}
static rmtError bin_MessageHeader(Buffer *buffer , char const   *id , rmtU32 *out_write_start_offset ) 
{ 
  rmtError error ;
  rmtError tmp ;
  rmtError error___0 ;
  rmtError tmp___0 ;

  {
  *out_write_start_offset = buffer->bytes_used;
  tmp = Buffer_Write(buffer, (void const   *)((void *)id), (rmtU32 )4);
  error = tmp;
  if ((unsigned int )error != 0U) {
    return (error);
  }
  tmp___0 = Buffer_Write(buffer, (void const   *)((void *)"    "), (rmtU32 )4);
  error___0 = tmp___0;
  if ((unsigned int )error___0 != 0U) {
    return (error___0);
  }
  return ((rmtError )0);
}
}
static rmtError bin_MessageFooter(Buffer *buffer , rmtU32 write_start_offset ) 
{ 
  rmtError error ;
  rmtError tmp ;

  {
  tmp = Buffer_AlignedPad(buffer, write_start_offset);
  error = tmp;
  if ((unsigned int )error != 0U) {
    return (error);
  }
  U32ToByteArray((buffer->data + write_start_offset) + 4, buffer->bytes_used - write_start_offset);
  return ((rmtError )0);
}
}
static void Server_Update(Server *server ) 
{ 
  rmtU32 cur_time ;
  WebSocket *client_socket ;
  rmtError error ;
  rmtError tmp___0 ;
  char message_first_byte ;
  rmtU32 message_length ;
  rmtError error___0 ;
  rmtError tmp___1 ;
  Buffer *bin_buf ;
  rmtU32 write_start_offset ;

  {
  if (! ((unsigned long )server != (unsigned long )((void *)0))) {
    __assert_fail("server != NULL", "lib/Remotery.c", 4439U, "Server_Update");
  }
  if ((unsigned long )server->listen_socket == (unsigned long )((void *)0)) {
    Server_CreateListenSocket(server, server->port, server->reuse_open_port, server->limit_connections_to_localhost);
  }
  if ((unsigned long )server->listen_socket != (unsigned long )((void *)0)) {
    if ((unsigned long )server->client_socket == (unsigned long )((void *)0)) {
      client_socket = (WebSocket *)((void *)0);
      tmp___0 = WebSocket_AcceptConnection(server->listen_socket, & client_socket);
      error = tmp___0;
      if ((unsigned int )error == 0U) {
        server->client_socket = client_socket;
      } else
      if ((unsigned long )server->listen_socket != (unsigned long )((void *)0)) {
        WebSocket_Destructor(server->listen_socket);
        rmtFree((void *)server->listen_socket);
        server->listen_socket = (WebSocket *)((void *)0);
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    while (1) {
      tmp___1 = WebSocket_Receive(server->client_socket, (void *)(& message_first_byte),
                                  & message_length, (rmtU32 )1, (rmtU32 )0);
      error___0 = tmp___1;
      if ((unsigned int )error___0 == 0U) {
        error___0 = Server_ReceiveMessage(server, message_first_byte, message_length);
        if ((unsigned int )error___0 != 0U) {
          Server_DisconnectClient(server);
          break;
        }
        goto __Cont;
      }
      if ((unsigned int )error___0 == 16U) {
        break;
      }
      if ((unsigned int )error___0 == 17U) {
        break;
      }
      Server_DisconnectClient(server);
      break;
      __Cont: /* CIL Label */ ;
    }
  }
  cur_time = msTimer_Get();
  if (cur_time - server->last_ping_time > 1000U) {
    bin_buf = server->bin_buf;
    WebSocket_PrepareBuffer(bin_buf);
    bin_MessageHeader(bin_buf, "PING", & write_start_offset);
    bin_MessageFooter(bin_buf, write_start_offset);
    Server_Send(server, (void const   *)bin_buf->data, bin_buf->bytes_used, (rmtU32 )10);
    server->last_ping_time = cur_time;
  }
  return;
}
}
static rmtError Sample_Constructor(Sample *sample ) 
{ 


  {
  if (! ((unsigned long )sample != (unsigned long )((void *)0))) {
    __assert_fail("sample != NULL", "lib/Remotery.c", 4577U, "Sample_Constructor");
  }
  ObjectLink_Constructor((ObjectLink *)sample);
  sample->type = (enum rmtSampleType )0;
  sample->name_hash = (rmtU32 )0;
  sample->unique_id = (rmtU32 )0;
  sample->uniqueColour[0] = (rmtU8 )0;
  sample->uniqueColour[1] = (rmtU8 )0;
  sample->uniqueColour[2] = (rmtU8 )0;
  sample->parent = (struct Sample *)((void *)0);
  sample->first_child = (struct Sample *)((void *)0);
  sample->last_child = (struct Sample *)((void *)0);
  sample->next_sibling = (struct Sample *)((void *)0);
  sample->nb_children = (rmtU32 )0;
  sample->us_start = (rmtU64 )0;
  sample->us_end = (rmtU64 )0;
  sample->us_length = (rmtU64 )0;
  sample->us_sampled_length = (rmtU64 )0;
  sample->usGpuIssueOnCpu = (rmtU64 )0;
  sample->call_count = (rmtU32 )0;
  sample->recurse_depth = (rmtU16 )0;
  sample->max_recurse_depth = (rmtU16 )0;
  return ((rmtError )0);
}
}
static void Sample_Destructor(Sample *sample ) 
{ 


  {
  return;
}
}
static void Sample_Prepare(Sample *sample , rmtU32 name_hash , Sample *parent ) 
{ 


  {
  sample->name_hash = name_hash;
  sample->unique_id = (rmtU32 )0;
  sample->parent = parent;
  sample->first_child = (struct Sample *)((void *)0);
  sample->last_child = (struct Sample *)((void *)0);
  sample->next_sibling = (struct Sample *)((void *)0);
  sample->nb_children = (rmtU32 )0;
  sample->us_start = (rmtU64 )0;
  sample->us_end = (rmtU64 )0;
  sample->us_length = (rmtU64 )0;
  sample->us_sampled_length = (rmtU64 )0;
  sample->usGpuIssueOnCpu = (rmtU64 )0;
  sample->call_count = (rmtU32 )1;
  sample->recurse_depth = (rmtU16 )0;
  sample->max_recurse_depth = (rmtU16 )0;
  return;
}
}
static void Sample_Close(Sample *sample , rmtS64 us_end ) 
{ 
  rmtS64 us_length ;

  {
  us_length = (rmtS64 )0;
  if (sample->call_count > 1U) {
    if ((int )sample->max_recurse_depth == 0) {
      us_length = maxS64((rmtS64 )((rmtU64 )us_end - sample->us_end), (rmtS64 )0);
    } else {
      us_length = maxS64((rmtS64 )((rmtU64 )us_end - sample->us_start), (rmtS64 )0);
    }
  } else {
    us_length = maxS64((rmtS64 )((rmtU64 )us_end - sample->us_start), (rmtS64 )0);
  }
  sample->us_length += (rmtU64 )us_length;
  if ((unsigned long )sample->parent != (unsigned long )((void *)0)) {
    (sample->parent)->us_sampled_length += (rmtU64 )us_length;
  }
  return;
}
}
static void Sample_CopyState(Sample *dst_sample , Sample const   *src_sample ) 
{ 


  {
  dst_sample->type = (enum rmtSampleType )src_sample->type;
  dst_sample->name_hash = (rmtU32 )src_sample->name_hash;
  dst_sample->unique_id = (rmtU32 )src_sample->unique_id;
  dst_sample->nb_children = (rmtU32 )src_sample->nb_children;
  dst_sample->us_start = (rmtU64 )src_sample->us_start;
  dst_sample->us_end = (rmtU64 )src_sample->us_end;
  dst_sample->us_length = (rmtU64 )src_sample->us_length;
  dst_sample->us_sampled_length = (rmtU64 )src_sample->us_sampled_length;
  dst_sample->usGpuIssueOnCpu = (rmtU64 )src_sample->usGpuIssueOnCpu;
  dst_sample->call_count = (rmtU32 )src_sample->call_count;
  dst_sample->recurse_depth = (rmtU16 )src_sample->recurse_depth;
  dst_sample->max_recurse_depth = (rmtU16 )src_sample->max_recurse_depth;
  dst_sample->parent = (struct Sample *)((void *)0);
  dst_sample->first_child = (struct Sample *)((void *)0);
  dst_sample->last_child = (struct Sample *)((void *)0);
  dst_sample->next_sibling = (struct Sample *)((void *)0);
  return;
}
}
static rmtError bin_SampleArray(Buffer *buffer , Sample *parent_sample , rmtU8 depth ) ;
static rmtError bin_Sample(Buffer *buffer , Sample *sample , rmtU8 depth ) 
{ 
  rmtError error ;
  rmtError tmp___0 ;
  rmtError error___0 ;
  rmtError tmp___1 ;
  rmtError error___1 ;
  rmtError tmp___2 ;
  rmtError error___2 ;
  rmtError tmp___3 ;
  rmtError error___3 ;
  rmtError tmp___4 ;
  rmtError error___4 ;
  rmtError tmp___5 ;
  rmtError error___5 ;
  rmtS64 tmp___6 ;
  rmtError tmp___7 ;
  rmtError error___6 ;
  rmtError tmp___8 ;
  rmtError error___7 ;
  rmtError tmp___9 ;
  rmtError error___8 ;
  rmtError tmp___10 ;
  rmtError error___9 ;
  rmtError tmp___11 ;

  {
  if (! ((unsigned long )sample != (unsigned long )((void *)0))) {
    __assert_fail("sample != NULL", "lib/Remotery.c", 4678U, "bin_Sample");
  }
  tmp___0 = Buffer_WriteU32(buffer, sample->name_hash);
  error = tmp___0;
  if ((unsigned int )error != 0U) {
    return (error);
  }
  tmp___1 = Buffer_WriteU32(buffer, sample->unique_id);
  error___0 = tmp___1;
  if ((unsigned int )error___0 != 0U) {
    return (error___0);
  }
  tmp___2 = Buffer_Write(buffer, (void const   *)(sample->uniqueColour), (rmtU32 )3);
  error___1 = tmp___2;
  if ((unsigned int )error___1 != 0U) {
    return (error___1);
  }
  tmp___3 = Buffer_Write(buffer, (void const   *)(& depth), (rmtU32 )1);
  error___2 = tmp___3;
  if ((unsigned int )error___2 != 0U) {
    return (error___2);
  }
  tmp___4 = Buffer_WriteU64(buffer, sample->us_start);
  error___3 = tmp___4;
  if ((unsigned int )error___3 != 0U) {
    return (error___3);
  }
  tmp___5 = Buffer_WriteU64(buffer, sample->us_length);
  error___4 = tmp___5;
  if ((unsigned int )error___4 != 0U) {
    return (error___4);
  }
  tmp___6 = maxS64((rmtS64 )(sample->us_length - sample->us_sampled_length), (rmtS64 )0);
  tmp___7 = Buffer_WriteU64(buffer, (rmtU64 )tmp___6);
  error___5 = tmp___7;
  if ((unsigned int )error___5 != 0U) {
    return (error___5);
  }
  tmp___8 = Buffer_WriteU64(buffer, sample->usGpuIssueOnCpu);
  error___6 = tmp___8;
  if ((unsigned int )error___6 != 0U) {
    return (error___6);
  }
  tmp___9 = Buffer_WriteU32(buffer, sample->call_count);
  error___7 = tmp___9;
  if ((unsigned int )error___7 != 0U) {
    return (error___7);
  }
  tmp___10 = Buffer_WriteU32(buffer, (rmtU32 )sample->max_recurse_depth);
  error___8 = tmp___10;
  if ((unsigned int )error___8 != 0U) {
    return (error___8);
  }
  tmp___11 = bin_SampleArray(buffer, sample, (rmtU8 )((int )depth + 1));
  error___9 = tmp___11;
  if ((unsigned int )error___9 != 0U) {
    return (error___9);
  }
  return ((rmtError )0);
}
}
static rmtError bin_SampleArray(Buffer *buffer , Sample *parent_sample , rmtU8 depth ) 
{ 
  Sample *sample ;
  rmtError error ;
  rmtError tmp ;
  rmtError error___0 ;
  rmtError tmp___0 ;

  {
  tmp = Buffer_WriteU32(buffer, parent_sample->nb_children);
  error = tmp;
  if ((unsigned int )error != 0U) {
    return (error);
  }
  sample = parent_sample->first_child;
  while ((unsigned long )sample != (unsigned long )((void *)0)) {
    tmp___0 = bin_Sample(buffer, sample, depth);
    error___0 = tmp___0;
    if ((unsigned int )error___0 != 0U) {
      return (error___0);
    }
    sample = sample->next_sibling;
  }
  return ((rmtError )0);
}
}
static rmtError SampleTree_Constructor(SampleTree *tree , rmtU32 sample_size , rmtError (*constructor)(void * ) ,
                                       void (*destructor)(void * ) ) 
{ 
  void *tmp___0 ;
  rmtError error ;
  rmtError tmp___1 ;
  rmtError error___0 ;
  rmtError tmp___2 ;

  {
  if (! ((unsigned long )tree != (unsigned long )((void *)0))) {
    __assert_fail("tree != NULL", "lib/Remotery.c", 4745U, "SampleTree_Constructor");
  }
  tree->allocator = (ObjectAllocator *)((void *)0);
  tree->root = (Sample *)((void *)0);
  tree->currentParent = (Sample *)((void *)0);
  StoreRelease(& tree->msLastTreeSendTime, (rmtU32 )0);
  StoreRelease(& tree->treeBeingModified, (rmtU32 )0);
  tree->sendSampleOnClose = (Sample *)((void *)0);
  tmp___0 = rmtMalloc((rmtU32 )sizeof(ObjectAllocator ));
  tree->allocator = (ObjectAllocator *)tmp___0;
  if ((unsigned long )tree->allocator == (unsigned long )((void *)0)) {
    return ((rmtError )7);
  }
  tmp___1 = ObjectAllocator_Constructor(tree->allocator, sample_size, constructor,
                                        destructor);
  error = tmp___1;
  if ((unsigned int )error != 0U) {
    if ((unsigned long )tree->allocator != (unsigned long )((void *)0)) {
      ObjectAllocator_Destructor(tree->allocator);
      rmtFree((void *)tree->allocator);
      tree->allocator = (ObjectAllocator *)((void *)0);
    }
    return (error);
  }
  tmp___2 = ObjectAllocator_Alloc(tree->allocator, (void **)(& tree->root));
  error___0 = tmp___2;
  if ((unsigned int )error___0 != 0U) {
    return (error___0);
  }
  Sample_Prepare(tree->root, (rmtU32 )0, (Sample *)((void *)0));
  tree->currentParent = tree->root;
  return ((rmtError )0);
}
}
static void SampleTree_Destructor(SampleTree *tree ) 
{ 


  {
  if (! ((unsigned long )tree != (unsigned long )((void *)0))) {
    __assert_fail("tree != NULL", "lib/Remotery.c", 4767U, "SampleTree_Destructor");
  }
  if ((unsigned long )tree->root != (unsigned long )((void *)0)) {
    ObjectAllocator_Free(tree->allocator, (void *)tree->root);
    tree->root = (Sample *)((void *)0);
  }
  if ((unsigned long )tree->allocator != (unsigned long )((void *)0)) {
    ObjectAllocator_Destructor(tree->allocator);
    rmtFree((void *)tree->allocator);
    tree->allocator = (ObjectAllocator *)((void *)0);
  }
  return;
}
}
static rmtU32 HashCombine(rmtU32 hash_a , rmtU32 hash_b ) ;
static rmtU32 random_bits  =    2654435769U;
static rmtU32 HashCombine(rmtU32 hash_a , rmtU32 hash_b ) 
{ 


  {
  hash_a ^= ((hash_b + random_bits) + (hash_a << 6)) + (hash_a >> 2);
  return (hash_a);
}
}
static rmtError SampleTree_Push(SampleTree *tree , rmtU32 name_hash , rmtU32 flags ,
                                Sample **sample ) 
{ 
  Sample *parent ;
  rmtU32 unique_id ;
  Sample *sibling ;
  rmtError error ;
  rmtError tmp___2 ;
  rmtError error___0 ;
  rmtError tmp___5 ;

  {
  if (! ((unsigned long )tree != (unsigned long )((void *)0))) {
    __assert_fail("tree != NULL", "lib/Remotery.c", 4795U, "SampleTree_Push");
  }
  if (! ((unsigned long )tree->currentParent != (unsigned long )((void *)0))) {
    __assert_fail("tree->currentParent != NULL", "lib/Remotery.c", 4796U, "SampleTree_Push");
  }
  parent = tree->currentParent;
  if (flags != 0U) {
    if ((flags & 4U) != 0U) {
      if (! ((unsigned long )parent->parent == (unsigned long )((void *)0))) {
        __assert_fail("parent->parent == NULL", "lib/Remotery.c", 4805U, "SampleTree_Push");
      }
    }
    if ((flags & 1U) != 0U) {
      sibling = parent->first_child;
      while ((unsigned long )sibling != (unsigned long )((void *)0)) {
        if (sibling->name_hash == name_hash) {
          tree->currentParent = sibling;
          (sibling->call_count) ++;
          *sample = sibling;
          return ((rmtError )0);
        }
        sibling = sibling->next_sibling;
      }
    }
    if ((flags & 2U) != 0U) {
      if (parent->name_hash == name_hash) {
        parent->recurse_depth = (rmtU16 )((int )parent->recurse_depth + 1);
        parent->max_recurse_depth = maxU16(parent->max_recurse_depth, parent->recurse_depth);
        (parent->call_count) ++;
        *sample = parent;
        return ((rmtError )1);
      }
    }
    tmp___2 = ObjectAllocator_Alloc(tree->allocator, (void **)sample);
    error = tmp___2;
    if ((unsigned int )error != 0U) {
      return (error);
    }
    Sample_Prepare(*sample, name_hash, parent);
    if ((flags & 8U) != 0U) {
      if (! ((unsigned long )tree->currentParent != (unsigned long )((void *)0))) {
        __assert_fail("tree->currentParent != NULL", "lib/Remotery.c", 4841U, "SampleTree_Push");
      }
      if (! ((unsigned long )tree->sendSampleOnClose == (unsigned long )((void *)0))) {
        __assert_fail("tree->sendSampleOnClose == NULL", "lib/Remotery.c", 4842U,
                      "SampleTree_Push");
      }
      tree->sendSampleOnClose = *sample;
    }
  } else {
    tmp___5 = ObjectAllocator_Alloc(tree->allocator, (void **)sample);
    error___0 = tmp___5;
    if ((unsigned int )error___0 != 0U) {
      return (error___0);
    }
    Sample_Prepare(*sample, name_hash, parent);
  }
  unique_id = parent->unique_id;
  unique_id = HashCombine(unique_id, (*sample)->name_hash);
  unique_id = HashCombine(unique_id, parent->nb_children);
  (*sample)->unique_id = unique_id;
  (parent->nb_children) ++;
  if ((unsigned long )parent->first_child == (unsigned long )((void *)0)) {
    parent->first_child = *sample;
    parent->last_child = *sample;
  } else {
    if (! ((unsigned long )parent->last_child != (unsigned long )((void *)0))) {
      __assert_fail("parent->last_child != NULL", "lib/Remotery.c", 4869U, "SampleTree_Push");
    }
    (parent->last_child)->next_sibling = *sample;
    parent->last_child = *sample;
  }
  tree->currentParent = *sample;
  return ((rmtError )0);
}
}
static void SampleTree_Pop(SampleTree *tree , Sample *sample ) 
{ 


  {
  if (! ((unsigned long )tree != (unsigned long )((void *)0))) {
    __assert_fail("tree != NULL", "lib/Remotery.c", 4882U, "SampleTree_Pop");
  }
  if (! ((unsigned long )sample != (unsigned long )((void *)0))) {
    __assert_fail("sample != NULL", "lib/Remotery.c", 4883U, "SampleTree_Pop");
  }
  if (! ((unsigned long )sample != (unsigned long )tree->root)) {
    __assert_fail("sample != tree->root", "lib/Remotery.c", 4884U, "SampleTree_Pop");
  }
  tree->currentParent = sample->parent;
  return;
}
}
static ObjectLink *FlattenSamples(Sample *sample , rmtU32 *nb_samples ) 
{ 
  Sample *child ;
  ObjectLink *cur_link ;
  ObjectLink *last_link ;
  ObjectLink *tmp___1 ;

  {
  cur_link = & sample->Link;
  if (! ((unsigned long )sample != (unsigned long )((void *)0))) {
    __assert_fail("sample != NULL", "lib/Remotery.c", 4893U, "FlattenSamples");
  }
  if (! ((unsigned long )nb_samples != (unsigned long )((void *)0))) {
    __assert_fail("nb_samples != NULL", "lib/Remotery.c", 4894U, "FlattenSamples");
  }
  (*nb_samples) ++;
  sample->Link.next = (struct ObjectLink_s * volatile  )((ObjectLink *)sample->first_child);
  child = sample->first_child;
  while ((unsigned long )child != (unsigned long )((void *)0)) {
    tmp___1 = FlattenSamples(child, nb_samples);
    last_link = tmp___1;
    last_link->next = (struct ObjectLink_s * volatile  )((ObjectLink *)child->next_sibling);
    cur_link = last_link;
    child = child->next_sibling;
  }
  sample->first_child = (struct Sample *)((void *)0);
  sample->last_child = (struct Sample *)((void *)0);
  sample->nb_children = (rmtU32 )0;
  return (cur_link);
}
}
static void FreeSamples(Sample *sample , ObjectAllocator *allocator ) 
{ 
  rmtU32 nb_cleared_samples ;
  ObjectLink *last_link ;
  ObjectLink *tmp ;

  {
  nb_cleared_samples = (rmtU32 )0;
  tmp = FlattenSamples(sample, & nb_cleared_samples);
  last_link = tmp;
  if ((unsigned long )sample->Link.next != (unsigned long )((void *)0)) {
    ObjectAllocator_FreeRange(allocator, (void *)sample, (void *)last_link, nb_cleared_samples);
  } else {
    ObjectAllocator_Free(allocator, (void *)sample);
  }
  return;
}
}
static rmtError SampleTree_CopySample(Sample **out_dst_sample , Sample *dst_parent_sample ,
                                      ObjectAllocator *allocator , Sample const   *src_sample ) 
{ 
  Sample *src_child ;
  Sample *dst_sample ;
  rmtError error ;
  rmtError tmp ;
  Sample *dst_child ;
  rmtError error___0 ;
  rmtError tmp___1 ;

  {
  tmp = ObjectAllocator_Alloc(allocator, (void **)(& dst_sample));
  error = tmp;
  if ((unsigned int )error != 0U) {
    return (error);
  }
  Sample_CopyState(dst_sample, src_sample);
  if ((unsigned long )dst_parent_sample != (unsigned long )((void *)0)) {
    if ((unsigned long )dst_parent_sample->first_child == (unsigned long )((void *)0)) {
      dst_parent_sample->first_child = dst_sample;
      dst_parent_sample->last_child = dst_sample;
    } else {
      if (! ((unsigned long )dst_parent_sample->last_child != (unsigned long )((void *)0))) {
        __assert_fail("dst_parent_sample->last_child != NULL", "lib/Remotery.c", 4952U,
                      "SampleTree_CopySample");
      }
      (dst_parent_sample->last_child)->next_sibling = dst_sample;
      dst_parent_sample->last_child = dst_sample;
    }
  }
  src_child = (Sample *)src_sample->first_child;
  while ((unsigned long )src_child != (unsigned long )((void *)0)) {
    tmp___1 = SampleTree_CopySample(& dst_child, dst_sample, allocator, (Sample const   *)src_child);
    error___0 = tmp___1;
    if ((unsigned int )error___0 != 0U) {
      return (error___0);
    }
    src_child = src_child->next_sibling;
  }
  *out_dst_sample = dst_sample;
  return ((rmtError )0);
}
}
static rmtError SampleTree_Copy(SampleTree *dst_tree , SampleTree const   *src_tree ) 
{ 
  ObjectAllocator *allocator ;
  rmtError error ;
  rmtError tmp ;

  {
  allocator = (ObjectAllocator *)src_tree->allocator;
  dst_tree->allocator = allocator;
  tmp = SampleTree_CopySample(& dst_tree->root, (Sample *)((void *)0), allocator,
                              (Sample const   *)src_tree->root);
  error = tmp;
  if ((unsigned int )error != 0U) {
    return (error);
  }
  dst_tree->currentParent = dst_tree->root;
  return ((rmtError )0);
}
}
static void QueueSampleTree(rmtMessageQueue *queue , Sample *sample , ObjectAllocator *allocator ,
                            rmtPStr thread_name , rmtU32 user_data , struct ThreadProfiler *thread_profiler ,
                            rmtBool partial_tree ) 
{ 
  Msg_SampleTree *payload ;
  Message *message ;
  Message *tmp ;

  {
  tmp = rmtMessageQueue_AllocMessage(queue, (rmtU32 )sizeof(Msg_SampleTree ), thread_profiler);
  message = tmp;
  if ((unsigned long )message == (unsigned long )((void *)0)) {
    FreeSamples(sample, allocator);
    return;
  }
  payload = (Msg_SampleTree *)(message->payload);
  payload->rootSample = sample;
  payload->allocator = allocator;
  payload->threadName = thread_name;
  payload->userData = user_data;
  payload->partialTree = partial_tree;
  rmtMessageQueue_CommitMessage(message, (MessageID )3);
  return;
}
}
static rmtBool QueueAddToStringTable(rmtMessageQueue *queue , rmtU32 hash , char const   *string ,
                                     size_t length , struct ThreadProfiler *thread_profiler ) 
{ 
  Msg_AddToStringTable *payload ;
  size_t nb_string_bytes ;
  Message *message ;
  Message *tmp ;

  {
  nb_string_bytes = length + 1UL;
  tmp = rmtMessageQueue_AllocMessage(queue, (rmtU32 )(sizeof(Msg_AddToStringTable ) + nb_string_bytes),
                                     thread_profiler);
  message = tmp;
  if ((unsigned long )message == (unsigned long )((void *)0)) {
    return ((rmtBool )0);
  }
  payload = (Msg_AddToStringTable *)(message->payload);
  payload->hash = hash;
  payload->length = (rmtU32 )length;
  memcpy((void * __restrict  )(payload + 1), (void const   * __restrict  )string,
         nb_string_bytes);
  rmtMessageQueue_CommitMessage(message, (MessageID )1);
  return ((rmtBool )1);
}
}
static rmtError ThreadProfiler_Constructor(rmtMessageQueue *mq_to_rmt , ThreadProfiler *thread_profiler ,
                                           rmtThreadId thread_id ) 
{ 
  rmtU32 name_length ;
  rmtError error ;
  rmtError tmp ;
  void *tmp___0 ;
  rmtError error___0 ;
  rmtError tmp___1 ;

  {
  thread_profiler->nbSamplesWithoutCallback = (rmtAtomicS32 )0;
  thread_profiler->processorIndex = (rmtU32 )-1;
  thread_profiler->lastProcessorIndex = (rmtU32 )-1;
  thread_profiler->threadId = thread_id;
  memset((void *)(thread_profiler->sampleTrees), 0, sizeof(thread_profiler->sampleTrees));
  tmp = rmtOpenThreadHandle(thread_id, & thread_profiler->threadHandle);
  error = tmp;
  if ((unsigned int )error != 0U) {
    return (error);
  }
  rmtGetThreadName(thread_id, thread_profiler->threadHandle, thread_profiler->threadName,
                   (rmtU32 )sizeof(thread_profiler->threadName));
  name_length = strnlen_s_safe_c((char const   *)(thread_profiler->threadName), (r_size_t )64);
  thread_profiler->threadNameHash = _rmt_HashString32((char const   *)(thread_profiler->threadName),
                                                      (int )name_length, (rmtU32 )0);
  QueueAddToStringTable(mq_to_rmt, thread_profiler->threadNameHash, (char const   *)(thread_profiler->threadName),
                        (size_t )name_length, thread_profiler);
  tmp___0 = rmtMalloc((rmtU32 )sizeof(SampleTree ));
  thread_profiler->sampleTrees[0] = (SampleTree *)tmp___0;
  if ((unsigned long )thread_profiler->sampleTrees[0] == (unsigned long )((void *)0)) {
    return ((rmtError )7);
  }
  tmp___1 = SampleTree_Constructor(thread_profiler->sampleTrees[0], (rmtU32 )sizeof(Sample ),
                                   (rmtError (*)(void * ))(& Sample_Constructor),
                                   (void (*)(void * ))(& Sample_Destructor));
  error___0 = tmp___1;
  if ((unsigned int )error___0 != 0U) {
    if ((unsigned long )thread_profiler->sampleTrees[0] != (unsigned long )((void *)0)) {
      SampleTree_Destructor(thread_profiler->sampleTrees[0]);
      rmtFree((void *)thread_profiler->sampleTrees[0]);
      thread_profiler->sampleTrees[0] = (SampleTree *)((void *)0);
    }
    return (error___0);
  }
  return ((rmtError )0);
}
}
static void ThreadProfiler_Destructor(ThreadProfiler *thread_profiler ) 
{ 
  rmtU32 index___0 ;

  {
  index___0 = (rmtU32 )0;
  while (index___0 < 6U) {
    if ((unsigned long )thread_profiler->sampleTrees[index___0] != (unsigned long )((void *)0)) {
      SampleTree_Destructor(thread_profiler->sampleTrees[index___0]);
      rmtFree((void *)thread_profiler->sampleTrees[index___0]);
      thread_profiler->sampleTrees[index___0] = (SampleTree *)((void *)0);
    }
    index___0 ++;
  }
  rmtCloseThreadHandle(thread_profiler->threadHandle);
  return;
}
}
static rmtError ThreadProfiler_Push(SampleTree *tree , rmtU32 name_hash , rmtU32 flags ,
                                    Sample **sample ) 
{ 
  rmtError error ;

  {
  StoreRelease(& tree->treeBeingModified, (rmtU32 )1);
  error = SampleTree_Push(tree, name_hash, flags, sample);
  StoreRelease(& tree->treeBeingModified, (rmtU32 )0);
  return (error);
}
}
static void CloseOpenSamples(Sample *sample , rmtU64 sample_time_us , rmtU32 parents_are_last ) 
{ 
  Sample *child_sample ;
  rmtU32 is_last ;
  int tmp ;

  {
  child_sample = sample->first_child;
  while ((unsigned long )child_sample != (unsigned long )((void *)0)) {
    if ((unsigned long )child_sample == (unsigned long )sample->last_child) {
      tmp = 1;
    } else {
      tmp = 0;
    }
    is_last = parents_are_last & (unsigned int )tmp;
    CloseOpenSamples(child_sample, sample_time_us, is_last);
    child_sample = child_sample->next_sibling;
  }
  if (parents_are_last > 0U) {
    Sample_Close(sample, (rmtS64 )sample_time_us);
  }
  return;
}
}
static rmtError MakePartialTreeCopy(SampleTree *sample_tree , rmtU64 sample_time_us ,
                                    SampleTree *out_sample_tree_copy ) 
{ 
  rmtU32 sample_time_s ;
  rmtError error ;
  rmtError tmp ;

  {
  sample_time_s = (rmtU32 )(sample_time_us / 1000ULL);
  StoreRelease(& sample_tree->msLastTreeSendTime, sample_time_s);
  tmp = SampleTree_Copy(out_sample_tree_copy, (SampleTree const   *)sample_tree);
  error = tmp;
  if ((unsigned int )error != 0U) {
    return (error);
  }
  CloseOpenSamples(out_sample_tree_copy->root, sample_time_us, (rmtU32 )1);
  return ((rmtError )0);
}
}
static rmtBool ThreadProfiler_Pop(ThreadProfiler *thread_profiler , rmtMessageQueue *queue ,
                                  Sample *sample , rmtU32 msg_user_data ) 
{ 
  SampleTree *tree ;
  Sample *root ;
  SampleTree partial_tree ;
  Sample *sample___0 ;
  rmtError tmp___0 ;

  {
  tree = thread_profiler->sampleTrees[sample->type];
  SampleTree_Pop(tree, sample);
  if ((unsigned long )tree->currentParent == (unsigned long )tree->root) {
    StoreRelease(& tree->treeBeingModified, (rmtU32 )1);
    root = tree->root;
    root->first_child = (struct Sample *)((void *)0);
    root->last_child = (struct Sample *)((void *)0);
    root->nb_children = (rmtU32 )0;
    StoreRelease(& tree->treeBeingModified, (rmtU32 )0);
    QueueSampleTree(queue, sample, tree->allocator, (rmtPStr )(thread_profiler->threadName),
                    msg_user_data, thread_profiler, (rmtBool )0);
    StoreRelease(& tree->msLastTreeSendTime, (rmtU32 )(sample->us_end / 1000ULL));
    return ((rmtBool )1);
  }
  if ((unsigned long )tree->sendSampleOnClose == (unsigned long )sample) {
    tmp___0 = MakePartialTreeCopy(tree, sample->us_start + sample->us_length, & partial_tree);
    if ((unsigned int )tmp___0 == 0U) {
      sample___0 = (partial_tree.root)->first_child;
      if (! ((unsigned long )sample___0 != (unsigned long )((void *)0))) {
        __assert_fail("sample != NULL", "lib/Remotery.c", 5241U, "ThreadProfiler_Pop");
      }
      QueueSampleTree(queue, sample___0, partial_tree.allocator, (rmtPStr )(thread_profiler->threadName),
                      msg_user_data, thread_profiler, (rmtBool )1);
    }
    if ((unsigned long )partial_tree.root != (unsigned long )((void *)0)) {
      FreeSamples(partial_tree.root, partial_tree.allocator);
    }
    tree->sendSampleOnClose = (Sample *)((void *)0);
  }
  return ((rmtBool )0);
}
}
static rmtU32 ThreadProfiler_GetNameHash(ThreadProfiler *thread_profiler , rmtMessageQueue *queue ,
                                         rmtPStr name , rmtU32 *hash_cache ) 
{ 
  size_t name_len ;
  rmtU32 name_hash ;
  r_size_t tmp___0 ;
  rmtBool tmp___1 ;
  r_size_t tmp___2 ;

  {
  if ((unsigned long )hash_cache != (unsigned long )((void *)0)) {
    name_hash = *hash_cache;
    if (name_hash == 0U) {
      if (! ((unsigned long )name != (unsigned long )((void *)0))) {
        __assert_fail("name != NULL", "lib/Remotery.c", 5269U, "ThreadProfiler_GetNameHash");
      }
      tmp___0 = strnlen_s_safe_c(name, (r_size_t )256);
      name_len = (size_t )tmp___0;
      name_hash = _rmt_HashString32(name, (int )name_len, (rmtU32 )0);
      tmp___1 = QueueAddToStringTable(queue, name_hash, name, name_len, thread_profiler);
      if (tmp___1 == 1U) {
        *hash_cache = name_hash;
      }
    }
    return (name_hash);
  }
  tmp___2 = strnlen_s_safe_c(name, (r_size_t )256);
  name_len = (size_t )tmp___2;
  name_hash = _rmt_HashString32(name, (int )name_len, (rmtU32 )0);
  QueueAddToStringTable(queue, name_hash, name, name_len, thread_profiler);
  return (name_hash);
}
}
static rmtError SampleThreadsLoop(rmtThread *rmt_thread ) ;
static rmtError ThreadProfilers_Constructor(ThreadProfilers *thread_profilers , usTimer *timer ,
                                            rmtMessageQueue *mq_to_rmt_thread ) 
{ 
  rmtError error ;
  rmtError tmp ;
  void *tmp___0 ;
  rmtError error___0 ;
  rmtError tmp___1 ;

  {
  thread_profilers->timer = timer;
  thread_profilers->mqToRmtThread = mq_to_rmt_thread;
  thread_profilers->compiledSampleFn = (void *)0;
  thread_profilers->compiledSampleFnSize = (rmtU32 )0;
  thread_profilers->threadProfilerTlsHandle = 4294967295U;
  thread_profilers->nbThreadProfilers = (rmtAtomicU32 )0;
  thread_profilers->maxNbThreadProfilers = (rmtU32 )(sizeof(thread_profilers->threadProfilers) / sizeof(thread_profilers->threadProfilers[0]));
  mtxInit(& thread_profilers->threadProfilerMutex);
  thread_profilers->threadSampleThread = (rmtThread *)((void *)0);
  thread_profilers->threadGatherThread = (rmtThread *)((void *)0);
  tmp = tlsAlloc(& thread_profilers->threadProfilerTlsHandle);
  error = tmp;
  if ((unsigned int )error != 0U) {
    return (error);
  }
  if (g_Settings.enableThreadSampler == 1U) {
    tmp___0 = rmtMalloc((rmtU32 )sizeof(rmtThread ));
    thread_profilers->threadSampleThread = (rmtThread *)tmp___0;
    if ((unsigned long )thread_profilers->threadSampleThread == (unsigned long )((void *)0)) {
      return ((rmtError )7);
    }
    tmp___1 = rmtThread_Constructor(thread_profilers->threadSampleThread, & SampleThreadsLoop,
                                    (void *)thread_profilers);
    error___0 = tmp___1;
    if ((unsigned int )error___0 != 0U) {
      if ((unsigned long )thread_profilers->threadSampleThread != (unsigned long )((void *)0)) {
        rmtThread_Destructor(thread_profilers->threadSampleThread);
        rmtFree((void *)thread_profilers->threadSampleThread);
        thread_profilers->threadSampleThread = (rmtThread *)((void *)0);
      }
      return (error___0);
    }
  }
  return ((rmtError )0);
}
}
static void ThreadProfilers_Destructor(ThreadProfilers *thread_profilers ) 
{ 
  rmtU32 thread_index ;
  ThreadProfiler *thread_profiler ;

  {
  if ((unsigned long )thread_profilers->threadSampleThread != (unsigned long )((void *)0)) {
    rmtThread_Destructor(thread_profilers->threadSampleThread);
    rmtFree((void *)thread_profilers->threadSampleThread);
    thread_profilers->threadSampleThread = (rmtThread *)((void *)0);
  }
  thread_index = (rmtU32 )0;
  while (thread_index < (rmtU32 )thread_profilers->nbThreadProfilers) {
    thread_profiler = thread_profilers->threadProfilers + thread_index;
    ThreadProfiler_Destructor(thread_profiler);
    thread_index ++;
  }
  if (thread_profilers->threadProfilerTlsHandle != 4294967295U) {
    tlsFree(thread_profilers->threadProfilerTlsHandle);
  }
  mtxDelete(& thread_profilers->threadProfilerMutex);
  return;
}
}
static rmtError ThreadProfilers_GetThreadProfiler(ThreadProfilers *thread_profilers ,
                                                  rmtThreadId thread_id , ThreadProfiler **out_thread_profiler ) 
{ 
  rmtU32 profiler_index ;
  ThreadProfiler *thread_profiler ;
  rmtError error ;

  {
  mtxLock(& thread_profilers->threadProfilerMutex);
  profiler_index = (rmtU32 )0;
  while (profiler_index < (rmtU32 )thread_profilers->nbThreadProfilers) {
    thread_profiler = thread_profilers->threadProfilers + profiler_index;
    if (thread_profiler->threadId == thread_id) {
      *out_thread_profiler = thread_profiler;
      mtxUnlock(& thread_profilers->threadProfilerMutex);
      return ((rmtError )0);
    }
    profiler_index ++;
  }
  thread_profiler = thread_profilers->threadProfilers + thread_profilers->nbThreadProfilers;
  error = ThreadProfiler_Constructor(thread_profilers->mqToRmtThread, thread_profiler,
                                     thread_id);
  if ((unsigned int )error != 0U) {
    ThreadProfiler_Destructor(thread_profiler);
    mtxUnlock(& thread_profilers->threadProfilerMutex);
    return (error);
  }
  *out_thread_profiler = thread_profiler;
  StoreRelease(& thread_profilers->nbThreadProfilers, (rmtU32 )(thread_profilers->nbThreadProfilers + (rmtAtomicU32 )1));
  mtxUnlock(& thread_profilers->threadProfilerMutex);
  return ((rmtError )0);
}
}
static rmtError ThreadProfilers_GetCurrentThreadProfiler(ThreadProfilers *thread_profilers ,
                                                         ThreadProfiler **out_thread_profiler ) 
{ 
  void *tmp ;
  rmtError error ;
  rmtThreadId tmp___0 ;
  rmtError tmp___1 ;

  {
  tmp = tlsGet(thread_profilers->threadProfilerTlsHandle);
  *out_thread_profiler = (ThreadProfiler *)tmp;
  if ((unsigned long )*out_thread_profiler == (unsigned long )((void *)0)) {
    tmp___0 = rmtGetCurrentThreadId();
    tmp___1 = ThreadProfilers_GetThreadProfiler(thread_profilers, tmp___0, out_thread_profiler);
    error = tmp___1;
    if ((unsigned int )error != 0U) {
      return (error);
    }
    tlsSet(thread_profilers->threadProfilerTlsHandle, (void *)*out_thread_profiler);
  }
  return ((rmtError )0);
}
}
static rmtBool ThreadProfilers_ThreadInCallback(ThreadProfilers *thread_profilers ,
                                                rmtCpuContext *context ) 
{ 


  {
  return ((rmtBool )0);
}
}
static void GatherThreads(ThreadProfilers *thread_profilers ) 
{ 


  {
  if (! ((unsigned long )thread_profilers != (unsigned long )((void *)0))) {
    __assert_fail("thread_profilers != NULL", "lib/Remotery.c", 5486U, "GatherThreads");
  }
  return;
}
}
static rmtError GatherThreadsLoop(rmtThread *thread ) 
{ 
  ThreadProfilers *thread_profilers ;
  rmtU32 sleep_time ;

  {
  thread_profilers = (ThreadProfilers *)thread->param;
  sleep_time = (rmtU32 )100;
  if (! ((unsigned long )thread_profilers != (unsigned long )((void *)0))) {
    __assert_fail("thread_profilers != NULL", "lib/Remotery.c", 5529U, "GatherThreadsLoop");
  }
  _rmt_SetCurrentThreadName("RemoteryGatherThreads");
  while (thread->request_exit == (rmtBool volatile   )0U) {
    GatherThreads(thread_profilers);
    msSleep(sleep_time);
    sleep_time = minU32(sleep_time * 2U, (rmtU32 )2000);
  }
  return ((rmtError )0);
}
}
static void QueueProcessorThreads(rmtMessageQueue *queue , rmtU64 message_index ,
                                  rmtU32 nb_processors , Processor *processors ) 
{ 
  Msg_ProcessorThreads *payload ;
  rmtU32 array_size ;
  Message *message ;
  Message *tmp ;

  {
  array_size = (rmtU32 )((unsigned long )(nb_processors - 1U) * sizeof(Processor ));
  tmp = rmtMessageQueue_AllocMessage(queue, (rmtU32 )(sizeof(Msg_ProcessorThreads ) + (unsigned long )array_size),
                                     (struct ThreadProfiler *)((void *)0));
  message = tmp;
  if ((unsigned long )message == (unsigned long )((void *)0)) {
    return;
  }
  payload = (Msg_ProcessorThreads *)(message->payload);
  payload->messageIndex = message_index;
  payload->nbProcessors = nb_processors;
  memcpy((void * __restrict  )(payload->processors), (void const   * __restrict  )processors,
         (unsigned long )nb_processors * sizeof(Processor ));
  rmtMessageQueue_CommitMessage(message, (MessageID )4);
  return;
}
}
static rmtError CheckForStallingSamples(SampleTree *stalling_sample_tree , ThreadProfiler *thread_profiler ,
                                        rmtU64 sample_time_us ) 
{ 
  SampleTree *sample_tree ;
  rmtU32 sample_time_s ;
  rmtU32 tmp ;
  Sample *root_sample ;
  rmtError error ;
  rmtError tmp___0 ;
  rmtU32 tmp___1 ;

  {
  sample_time_s = (rmtU32 )(sample_time_us / 1000ULL);
  stalling_sample_tree->root = (Sample *)((void *)0);
  stalling_sample_tree->allocator = (ObjectAllocator *)((void *)0);
  sample_tree = thread_profiler->sampleTrees[0];
  tmp = LoadAcquire(& sample_tree->treeBeingModified);
  if (tmp != 0U) {
    return ((rmtError )0);
  }
  if ((unsigned long )sample_tree != (unsigned long )((void *)0)) {
    root_sample = sample_tree->root;
    if ((unsigned long )root_sample != (unsigned long )((void *)0)) {
      if (root_sample->nb_children > 0U) {
        tmp___1 = LoadAcquire(& sample_tree->msLastTreeSendTime);
        if (sample_time_s - tmp___1 > 1000U) {
          tmp___0 = MakePartialTreeCopy(sample_tree, sample_time_us, stalling_sample_tree);
          error = tmp___0;
          if ((unsigned int )error != 0U) {
            return (error);
          }
        }
      }
    }
  }
  return ((rmtError )0);
}
}
static rmtError InitThreadSampling(ThreadProfilers *thread_profilers ) 
{ 
  void *tmp ;
  rmtError error ;
  rmtError tmp___0 ;
  time_t tmp___1 ;

  {
  _rmt_SetCurrentThreadName("RemoterySampleThreads");
  GatherThreads(thread_profilers);
  tmp = rmtMalloc((rmtU32 )sizeof(rmtThread ));
  thread_profilers->threadGatherThread = (rmtThread *)tmp;
  if ((unsigned long )thread_profilers->threadGatherThread == (unsigned long )((void *)0)) {
    return ((rmtError )7);
  }
  tmp___0 = rmtThread_Constructor(thread_profilers->threadGatherThread, & GatherThreadsLoop,
                                  (void *)thread_profilers);
  error = tmp___0;
  if ((unsigned int )error != 0U) {
    if ((unsigned long )thread_profilers->threadGatherThread != (unsigned long )((void *)0)) {
      rmtThread_Destructor(thread_profilers->threadGatherThread);
      rmtFree((void *)thread_profilers->threadGatherThread);
      thread_profilers->threadGatherThread = (rmtThread *)((void *)0);
    }
    return (error);
  }
  tmp___1 = time((time_t *)((void *)0));
  Well512_Init((rmtU32 )tmp___1);
  return ((rmtError )0);
}
}
static rmtError SampleThreadsLoop(rmtThread *rmt_thread ) 
{ 
  rmtCpuContext context ;
  rmtU32 processor_message_index ;
  rmtU32 nb_processors ;
  Processor *processors ;
  rmtU32 processor_index ;
  ThreadProfilers *thread_profilers ;
  rmtError error ;
  rmtError tmp ;
  void *tmp___0 ;
  rmtU32 lfsr_seed ;
  rmtU32 lfsr_value ;
  rmtU32 nb_thread_profilers ;
  rmtU32 tmp___1 ;
  rmtU32 highest_bit_set ;
  rmtU32 tmp___2 ;
  rmtU32 table_size_log2 ;
  rmtU32 xor_mask ;
  rmtU32 tmp___3 ;
  rmtU32 thread_index ;
  rmtThreadId thread_id ;
  ThreadProfiler *thread_profiler ;
  rmtThreadHandle thread_handle ;
  rmtU64 sample_time_us ;
  rmtU32 sample_count ;
  SampleTree stalling_sample_tree ;
  rmtBool tmp___4 ;
  rmtS32 tmp___5 ;
  rmtBool tmp___7 ;
  rmtBool tmp___8 ;
  rmtError tmp___10 ;
  Sample *sample ;
  Processor *processor ;
  ThreadProfiler *thread_profiler___0 ;
  rmtU32 last_processor_index ;
  rmtU32 tmp___14 ;

  {
  processor_message_index = (rmtU32 )0;
  thread_profilers = (ThreadProfilers *)rmt_thread->param;
  nb_processors = rmtGetNbProcessors();
  if (nb_processors == 0U) {
    return ((rmtError )2);
  }
  tmp = InitThreadSampling(thread_profilers);
  error = tmp;
  if ((unsigned int )error != 0U) {
    return (error);
  }
  tmp___0 = rmtMalloc((rmtU32 )((unsigned long )nb_processors * sizeof(Processor )));
  processors = (Processor *)tmp___0;
  if ((unsigned long )processors == (unsigned long )((void *)0)) {
    return ((rmtError )7);
  }
  processor_index = (rmtU32 )0;
  while (processor_index < nb_processors) {
    (processors + processor_index)->threadProfiler = (ThreadProfiler *)((void *)0);
    (processors + processor_index)->sampleTime = (rmtU64 )0;
    processor_index ++;
  }
  while (rmt_thread->request_exit == (rmtBool volatile   )0U) {
    tmp___1 = LoadAcquire(& thread_profilers->nbThreadProfilers);
    nb_thread_profilers = tmp___1;
    tmp___2 = Log2i(nb_thread_profilers);
    highest_bit_set = tmp___2;
    table_size_log2 = highest_bit_set + 1U;
    tmp___3 = GaloisLFSRMask(table_size_log2);
    xor_mask = tmp___3;
    lfsr_seed = Well512_RandomOpenLimit(nb_thread_profilers);
    lfsr_value = lfsr_seed;
    while (1) {
      lfsr_value = GaloisLFSRNext(lfsr_value, xor_mask);
      thread_index = lfsr_value - 1U;
      if (thread_index >= nb_thread_profilers) {
        goto __Cont;
      }
      thread_id = rmtGetCurrentThreadId();
      thread_profiler = thread_profilers->threadProfilers + thread_index;
      if (thread_profiler->threadId == thread_id) {
        goto __Cont;
      }
      thread_handle = thread_profiler->threadHandle;
      tmp___4 = rmtSuspendThread(thread_handle);
      if (tmp___4 == 0U) {
        goto __Cont;
      }
      sample_time_us = usTimer_Get(thread_profilers->timer);
      tmp___5 = AtomicAddS32(& thread_profiler->nbSamplesWithoutCallback, 1);
      sample_count = (rmtU32 )tmp___5;
      processor_index = thread_profiler->processorIndex;
      if (processor_index != 4294967295U) {
        if (! (processor_index < nb_processors)) {
          __assert_fail("processor_index < nb_processors", "lib/Remotery.c", 5888U,
                        "SampleThreadsLoop");
        }
        (processors + processor_index)->threadProfiler = thread_profiler;
        (processors + processor_index)->sampleCount = sample_count;
        (processors + processor_index)->sampleTime = sample_time_us;
      }
      if (sample_count == 0U) {
        tmp___7 = rmtGetUserModeThreadContext(thread_handle, & context);
        if (tmp___7 == 1U) {
          tmp___8 = ThreadProfilers_ThreadInCallback(thread_profilers, & context);
          if (tmp___8 == 0U) {
            rmtSetThreadContext(thread_handle, & context);
          } else {
            AtomicAddS32(& thread_profiler->nbSamplesWithoutCallback, -1);
          }
        } else {
          AtomicAddS32(& thread_profiler->nbSamplesWithoutCallback, -1);
        }
      }
      tmp___10 = CheckForStallingSamples(& stalling_sample_tree, thread_profiler,
                                         sample_time_us);
      if (0U != (unsigned int )tmp___10) {
        if (! ((unsigned long )stalling_sample_tree.allocator != (unsigned long )((void *)0))) {
          __assert_fail("stalling_sample_tree.allocator != NULL", "lib/Remotery.c",
                        5936U, "SampleThreadsLoop");
        }
        if ((unsigned long )stalling_sample_tree.root != (unsigned long )((void *)0)) {
          FreeSamples(stalling_sample_tree.root, stalling_sample_tree.allocator);
        }
      }
      rmtResumeThread(thread_handle);
      if ((unsigned long )stalling_sample_tree.root != (unsigned long )((void *)0)) {
        sample = (stalling_sample_tree.root)->first_child;
        if (! ((unsigned long )sample != (unsigned long )((void *)0))) {
          __assert_fail("sample != NULL", "lib/Remotery.c", 5951U, "SampleThreadsLoop");
        }
        QueueSampleTree(thread_profilers->mqToRmtThread, sample, stalling_sample_tree.allocator,
                        (rmtPStr )(thread_profiler->threadName), (rmtU32 )0, thread_profiler,
                        (rmtBool )1);
        (stalling_sample_tree.root)->first_child = (struct Sample *)((void *)0);
        (stalling_sample_tree.root)->last_child = (struct Sample *)((void *)0);
        (stalling_sample_tree.root)->nb_children = (rmtU32 )0;
        if (! ((unsigned long )stalling_sample_tree.allocator != (unsigned long )((void *)0))) {
          __assert_fail("stalling_sample_tree.allocator != NULL", "lib/Remotery.c",
                        5960U, "SampleThreadsLoop");
        }
        FreeSamples(stalling_sample_tree.root, stalling_sample_tree.allocator);
      }
      __Cont: /* CIL Label */ 
      if (! (lfsr_value != lfsr_seed)) {
        break;
      }
    }
    processor_index = (rmtU32 )0;
    while (processor_index < nb_processors) {
      processor = processors + processor_index;
      thread_profiler___0 = processor->threadProfiler;
      if ((unsigned long )thread_profiler___0 != (unsigned long )((void *)0)) {
        last_processor_index = thread_profiler___0->lastProcessorIndex;
        if (last_processor_index != 4294967295U) {
          if (last_processor_index != processor_index) {
            if (! (last_processor_index < nb_processors)) {
              __assert_fail("last_processor_index < nb_processors", "lib/Remotery.c",
                            5980U, "SampleThreadsLoop");
            }
            if ((unsigned long )(processors + last_processor_index)->threadProfiler == (unsigned long )thread_profiler___0) {
              (processors + last_processor_index)->threadProfiler = (ThreadProfiler *)((void *)0);
            }
          } else {
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
        if (processor->sampleCount > 1U) {
          processor->threadProfiler = (ThreadProfiler *)((void *)0);
        }
        thread_profiler___0->lastProcessorIndex = thread_profiler___0->processorIndex;
      }
      processor_index ++;
    }
    tmp___14 = processor_message_index;
    processor_message_index ++;
    QueueProcessorThreads(thread_profilers->mqToRmtThread, (rmtU64 )tmp___14, nb_processors,
                          processors);
  }
  if ((unsigned long )thread_profilers->threadGatherThread != (unsigned long )((void *)0)) {
    rmtThread_Destructor(thread_profilers->threadGatherThread);
    rmtFree((void *)thread_profilers->threadGatherThread);
    thread_profilers->threadGatherThread = (rmtThread *)((void *)0);
  }
  rmtFree((void *)processors);
  return ((rmtError )0);
}
}
static rmtError PropertySnapshot_Constructor(PropertySnapshot *snapshot ) 
{ 


  {
  if (! ((unsigned long )snapshot != (unsigned long )((void *)0))) {
    __assert_fail("snapshot != NULL", "lib/Remotery.c", 6063U, "PropertySnapshot_Constructor");
  }
  ObjectLink_Constructor((ObjectLink *)snapshot);
  snapshot->type = (rmtPropertyType )1;
  snapshot->value.Bool = (rmtBool )0;
  snapshot->nameHash = (rmtU32 )0;
  snapshot->uniqueID = (rmtU32 )0;
  snapshot->nbChildren = (rmtU32 )0;
  snapshot->depth = (rmtU8 )0;
  snapshot->nextSnapshot = (struct PropertySnapshot *)((void *)0);
  return ((rmtError )0);
}
}
static void PropertySnapshot_Destructor(PropertySnapshot *snapshot ) 
{ 


  {
  return;
}
}
static Remotery *g_Remotery  =    (Remotery *)((void *)0);
static rmtBool g_RemoteryCreated  =    (rmtBool )0;
static double saturate(double v ) 
{ 


  {
  if (v < (double )0) {
    return ((double )0);
  }
  if (v > (double )1) {
    return ((double )1);
  }
  return (v);
}
}
static void PostProcessSamples(Sample *sample , rmtU32 *nb_samples ) 
{ 
  Sample *child ;
  double h ;
  double r ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double g ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double b ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double k ;
  rmtS32 tmp___10 ;
  rmtS32 tmp___11 ;
  rmtS32 tmp___12 ;
  rmtS32 tmp___13 ;
  rmtS32 tmp___14 ;
  rmtS32 tmp___15 ;

  {
  if (! ((unsigned long )sample != (unsigned long )((void *)0))) {
    __assert_fail("sample != NULL", "lib/Remotery.c", 6165U, "PostProcessSamples");
  }
  if (! ((unsigned long )nb_samples != (unsigned long )((void *)0))) {
    __assert_fail("nb_samples != NULL", "lib/Remotery.c", 6166U, "PostProcessSamples");
  }
  (*nb_samples) ++;
  h = (double )sample->name_hash / (double )4294967295U;
  tmp___1 = fmod(h * (double )6 + (double )0, (double )6);
  tmp___2 = fabs(tmp___1 - (double )3);
  tmp___3 = saturate(tmp___2 - (double )1);
  r = tmp___3;
  tmp___4 = fmod(h * (double )6 + (double )4, (double )6);
  tmp___5 = fabs(tmp___4 - (double )3);
  tmp___6 = saturate(tmp___5 - (double )1);
  g = tmp___6;
  tmp___7 = fmod(h * (double )6 + (double )2, (double )6);
  tmp___8 = fabs(tmp___7 - (double )3);
  tmp___9 = saturate(tmp___8 - (double )1);
  b = tmp___9;
  r = (r * r) * ((double )3 - (double )2 * r);
  g = (g * g) * ((double )3 - (double )2 * g);
  b = (b * b) * ((double )3 - (double )2 * b);
  k = 0.4;
  r = r * k + ((double )1 - k);
  g = g * k + ((double )1 - k);
  b = b * k + ((double )1 - k);
  tmp___10 = minS32((rmtS32 )(r * (double )255), 255);
  tmp___11 = maxS32(tmp___10, 0);
  sample->uniqueColour[0] = (rmtU8 )tmp___11;
  tmp___12 = minS32((rmtS32 )(g * (double )255), 255);
  tmp___13 = maxS32(tmp___12, 0);
  sample->uniqueColour[1] = (rmtU8 )tmp___13;
  tmp___14 = minS32((rmtS32 )(b * (double )255), 255);
  tmp___15 = maxS32(tmp___14, 0);
  sample->uniqueColour[2] = (rmtU8 )tmp___15;
  child = sample->first_child;
  while ((unsigned long )child != (unsigned long )((void *)0)) {
    PostProcessSamples(child, nb_samples);
    child = child->next_sibling;
  }
  return;
}
}
static rmtError Remotery_SendLogTextMessage(Remotery *rmt , Message *message ) 
{ 
  rmtError error ;
  Buffer *bin_buf ;
  rmtU32 write_start_offset ;
  rmtError error___0 ;
  rmtError tmp___1 ;
  rmtError error___1 ;
  rmtError tmp___2 ;
  rmtError error___2 ;
  rmtError tmp___3 ;
  rmtBool tmp___4 ;

  {
  error = (rmtError )0;
  if (! ((unsigned long )rmt != (unsigned long )((void *)0))) {
    __assert_fail("rmt != NULL", "lib/Remotery.c", 6213U, "Remotery_SendLogTextMessage");
  }
  if (! ((unsigned long )message != (unsigned long )((void *)0))) {
    __assert_fail("message != NULL", "lib/Remotery.c", 6214U, "Remotery_SendLogTextMessage");
  }
  bin_buf = (rmt->server)->bin_buf;
  WebSocket_PrepareBuffer(bin_buf);
  tmp___1 = bin_MessageHeader(bin_buf, "LOGM", & write_start_offset);
  error___0 = tmp___1;
  if ((unsigned int )error___0 != 0U) {
    return (error___0);
  }
  tmp___2 = Buffer_Write(bin_buf, (void const   *)(message->payload), message->payload_size);
  error___1 = tmp___2;
  if ((unsigned int )error___1 != 0U) {
    return (error___1);
  }
  tmp___3 = bin_MessageFooter(bin_buf, write_start_offset);
  error___2 = tmp___3;
  if ((unsigned int )error___2 != 0U) {
    return (error___2);
  }
  tmp___4 = Server_IsClientConnected(rmt->server);
  if (tmp___4 == 1U) {
    error = Server_Send(rmt->server, (void const   *)bin_buf->data, bin_buf->bytes_used,
                        (rmtU32 )20);
  }
  if ((unsigned long )rmt->logfile != (unsigned long )((void *)0)) {
    rmtWriteFile(rmt->logfile, (void const   *)(bin_buf->data + 10), bin_buf->bytes_used - 10U);
  }
  return (error);
}
}
static rmtError bin_SampleName(Buffer *buffer , char const   *name , rmtU32 name_hash ,
                               rmtU32 name_length ) 
{ 
  rmtU32 write_start_offset ;
  rmtError error ;
  rmtError tmp ;
  rmtError error___0 ;
  rmtError tmp___0 ;
  rmtError error___1 ;
  rmtError tmp___1 ;
  rmtError error___2 ;
  rmtError tmp___2 ;
  rmtError error___3 ;
  rmtError tmp___3 ;

  {
  tmp = bin_MessageHeader(buffer, "SSMP", & write_start_offset);
  error = tmp;
  if ((unsigned int )error != 0U) {
    return (error);
  }
  tmp___0 = Buffer_WriteU32(buffer, name_hash);
  error___0 = tmp___0;
  if ((unsigned int )error___0 != 0U) {
    return (error___0);
  }
  tmp___1 = Buffer_WriteU32(buffer, name_length);
  error___1 = tmp___1;
  if ((unsigned int )error___1 != 0U) {
    return (error___1);
  }
  tmp___2 = Buffer_Write(buffer, (void const   *)((void *)name), name_length);
  error___2 = tmp___2;
  if ((unsigned int )error___2 != 0U) {
    return (error___2);
  }
  tmp___3 = bin_MessageFooter(buffer, write_start_offset);
  error___3 = tmp___3;
  if ((unsigned int )error___3 != 0U) {
    return (error___3);
  }
  return ((rmtError )0);
}
}
static rmtError Remotery_AddToStringTable(Remotery *rmt , Message *message ) 
{ 
  Msg_AddToStringTable *payload ;
  char const   *name ;
  rmtBool name_inserted ;
  rmtBool tmp ;
  Buffer *bin_buf ;
  rmtError error ;
  rmtError tmp___0 ;

  {
  payload = (Msg_AddToStringTable *)(message->payload);
  name = (char const   *)(payload + 1);
  tmp = StringTable_Insert(rmt->string_table, payload->hash, name);
  name_inserted = tmp;
  if (name_inserted == 1U) {
    if ((unsigned long )rmt->logfile != (unsigned long )((void *)0)) {
      bin_buf = (rmt->server)->bin_buf;
      bin_buf->bytes_used = (rmtU32 )0;
      tmp___0 = bin_SampleName(bin_buf, name, payload->hash, payload->length);
      error = tmp___0;
      if ((unsigned int )error != 0U) {
        return (error);
      }
      rmtWriteFile(rmt->logfile, (void const   *)bin_buf->data, bin_buf->bytes_used);
    }
  }
  return ((rmtError )0);
}
}
static rmtError bin_SampleTree(Buffer *buffer , Msg_SampleTree *msg ) 
{ 
  Sample *root_sample ;
  char thread_name[256] ;
  rmtU32 nb_samples ;
  rmtU32 write_start_offset ;
  r_size_t tmp___2 ;
  rmtError error ;
  rmtError tmp___3 ;
  rmtError error___0 ;
  rmtError tmp___4 ;
  rmtError error___1 ;
  rmtError tmp___5 ;
  rmtError error___2 ;
  int tmp___6 ;
  rmtError tmp___7 ;
  rmtError error___3 ;
  rmtError tmp___8 ;
  rmtError error___4 ;
  rmtError tmp___9 ;
  rmtError error___5 ;
  rmtError tmp___10 ;

  {
  nb_samples = (rmtU32 )0;
  write_start_offset = (rmtU32 )0;
  if (! ((unsigned long )buffer != (unsigned long )((void *)0))) {
    __assert_fail("buffer != NULL", "lib/Remotery.c", 6273U, "bin_SampleTree");
  }
  if (! ((unsigned long )msg != (unsigned long )((void *)0))) {
    __assert_fail("msg != NULL", "lib/Remotery.c", 6274U, "bin_SampleTree");
  }
  root_sample = msg->rootSample;
  if (! ((unsigned long )root_sample != (unsigned long )((void *)0))) {
    __assert_fail("root_sample != NULL", "lib/Remotery.c", 6278U, "bin_SampleTree");
  }
  thread_name[0] = (char)0;
  tmp___2 = strnlen_s_safe_c(msg->threadName, (r_size_t )255);
  strncat_s_safe_c(thread_name, (r_size_t )sizeof(thread_name), msg->threadName, tmp___2);
  if ((unsigned int )root_sample->type == 1U) {
    strncat_s_safe_c(thread_name, (r_size_t )sizeof(thread_name), " (CUDA)", (r_size_t )7);
  }
  if ((unsigned int )root_sample->type == 2U) {
    strncat_s_safe_c(thread_name, (r_size_t )sizeof(thread_name), " (D3D11)", (r_size_t )8);
  }
  if ((unsigned int )root_sample->type == 3U) {
    strncat_s_safe_c(thread_name, (r_size_t )sizeof(thread_name), " (D3D12)", (r_size_t )8);
  }
  if ((unsigned int )root_sample->type == 4U) {
    strncat_s_safe_c(thread_name, (r_size_t )sizeof(thread_name), " (OpenGL)", (r_size_t )9);
  }
  if ((unsigned int )root_sample->type == 5U) {
    strncat_s_safe_c(thread_name, (r_size_t )sizeof(thread_name), " (Metal)", (r_size_t )8);
  }
  PostProcessSamples(root_sample, & nb_samples);
  tmp___3 = bin_MessageHeader(buffer, "SMPL", & write_start_offset);
  error = tmp___3;
  if ((unsigned int )error != 0U) {
    return (error);
  }
  tmp___4 = Buffer_WriteStringWithLength(buffer, (rmtPStr )(thread_name));
  error___0 = tmp___4;
  if ((unsigned int )error___0 != 0U) {
    return (error___0);
  }
  tmp___5 = Buffer_WriteU32(buffer, nb_samples);
  error___1 = tmp___5;
  if ((unsigned int )error___1 != 0U) {
    return (error___1);
  }
  if (msg->partialTree) {
    tmp___6 = 1;
  } else {
    tmp___6 = 0;
  }
  tmp___7 = Buffer_WriteU32(buffer, (rmtU32 )tmp___6);
  error___2 = tmp___7;
  if ((unsigned int )error___2 != 0U) {
    return (error___2);
  }
  tmp___8 = Buffer_AlignedPad(buffer, write_start_offset);
  error___3 = tmp___8;
  if ((unsigned int )error___3 != 0U) {
    return (error___3);
  }
  tmp___9 = bin_Sample(buffer, root_sample, (rmtU8 )0);
  error___4 = tmp___9;
  if ((unsigned int )error___4 != 0U) {
    return (error___4);
  }
  tmp___10 = bin_MessageFooter(buffer, write_start_offset);
  error___5 = tmp___10;
  if ((unsigned int )error___5 != 0U) {
    return (error___5);
  }
  return ((rmtError )0);
}
}
static rmtError Remotery_SendToViewerAndLog(Remotery *rmt , Buffer *bin_buf , rmtU32 timeout ) ;
static rmtU32 rmt_sample_hash_Server_Send  =    (rmtU32 )0;
static rmtError Remotery_SendToViewerAndLog(Remotery *rmt , Buffer *bin_buf , rmtU32 timeout ) 
{ 
  rmtError error ;
  rmtBool tmp ;

  {
  error = (rmtError )0;
  tmp = Server_IsClientConnected(rmt->server);
  if (tmp == 1U) {
    _rmt_BeginCPUSample("Server_Send", (rmtU32 )1, & rmt_sample_hash_Server_Send);
    error = Server_Send(rmt->server, (void const   *)bin_buf->data, bin_buf->bytes_used,
                        timeout);
    _rmt_EndCPUSample();
  }
  if ((unsigned long )rmt->logfile != (unsigned long )((void *)0)) {
    rmtWriteFile(rmt->logfile, (void const   *)(bin_buf->data + 10), bin_buf->bytes_used - 10U);
  }
  return (error);
}
}
static rmtError Remotery_SendSampleTreeMessage(Remotery *rmt , Message *message ) ;
static rmtU32 rmt_sample_hash_bin_SampleTree  =    (rmtU32 )0;
static rmtError Remotery_SendSampleTreeMessage(Remotery *rmt , Message *message ) 
{ 
  rmtError error ;
  Msg_SampleTree *sample_tree ;
  Sample *sample ;
  Buffer *bin_buf ;
  rmtError tmp___2 ;

  {
  error = (rmtError )0;
  if (! ((unsigned long )rmt != (unsigned long )((void *)0))) {
    __assert_fail("rmt != NULL", "lib/Remotery.c", 6357U, "Remotery_SendSampleTreeMessage");
  }
  if (! ((unsigned long )message != (unsigned long )((void *)0))) {
    __assert_fail("message != NULL", "lib/Remotery.c", 6358U, "Remotery_SendSampleTreeMessage");
  }
  sample_tree = (Msg_SampleTree *)(message->payload);
  sample = sample_tree->rootSample;
  if (! ((unsigned long )sample != (unsigned long )((void *)0))) {
    __assert_fail("sample != NULL", "lib/Remotery.c", 6363U, "Remotery_SendSampleTreeMessage");
  }
  bin_buf = (rmt->server)->bin_buf;
  WebSocket_PrepareBuffer(bin_buf);
  _rmt_BeginCPUSample("bin_SampleTree", (rmtU32 )1, & rmt_sample_hash_bin_SampleTree);
  error = bin_SampleTree(bin_buf, sample_tree);
  _rmt_EndCPUSample();
  if ((unsigned long )g_Settings.sampletree_handler != (unsigned long )((void *)0)) {
    (*(g_Settings.sampletree_handler))(g_Settings.sampletree_context, sample_tree);
  }
  FreeSamples(sample, sample_tree->allocator);
  if ((unsigned int )error != 0U) {
    return (error);
  }
  tmp___2 = Remotery_SendToViewerAndLog(rmt, bin_buf, (rmtU32 )50000);
  return (tmp___2);
}
}
static rmtError Remotery_SendProcessorThreads(Remotery *rmt , Message *message ) 
{ 
  rmtU32 processor_index ;
  rmtError error ;
  Msg_ProcessorThreads *processor_threads ;
  Buffer *bin_buf ;
  rmtU32 write_start_offset ;
  rmtError error___0 ;
  rmtError tmp ;
  rmtError error___1 ;
  rmtError tmp___0 ;
  rmtError error___2 ;
  rmtError tmp___1 ;
  Processor *processor ;
  rmtError error___3 ;
  rmtError tmp___2 ;
  rmtError error___4 ;
  rmtError tmp___3 ;
  rmtError error___5 ;
  rmtError tmp___4 ;
  rmtError error___6 ;
  rmtError tmp___5 ;
  rmtError error___7 ;
  rmtError tmp___6 ;
  rmtError error___8 ;
  rmtError tmp___7 ;
  rmtError error___9 ;
  rmtError tmp___8 ;
  rmtError tmp___9 ;

  {
  error = (rmtError )0;
  processor_threads = (Msg_ProcessorThreads *)(message->payload);
  bin_buf = (rmt->server)->bin_buf;
  WebSocket_PrepareBuffer(bin_buf);
  tmp = bin_MessageHeader(bin_buf, "PRTH", & write_start_offset);
  error___0 = tmp;
  if ((unsigned int )error___0 != 0U) {
    return (error___0);
  }
  tmp___0 = Buffer_WriteU32(bin_buf, processor_threads->nbProcessors);
  error___1 = tmp___0;
  if ((unsigned int )error___1 != 0U) {
    return (error___1);
  }
  tmp___1 = Buffer_WriteU64(bin_buf, processor_threads->messageIndex);
  error___2 = tmp___1;
  if ((unsigned int )error___2 != 0U) {
    return (error___2);
  }
  processor_index = (rmtU32 )0;
  while (processor_index < processor_threads->nbProcessors) {
    processor = processor_threads->processors + processor_index;
    if ((unsigned long )processor->threadProfiler != (unsigned long )((void *)0)) {
      tmp___2 = Buffer_WriteU32(bin_buf, (rmtU32 )(processor->threadProfiler)->threadId);
      error___3 = tmp___2;
      if ((unsigned int )error___3 != 0U) {
        return (error___3);
      }
      tmp___3 = Buffer_WriteU32(bin_buf, (processor->threadProfiler)->threadNameHash);
      error___4 = tmp___3;
      if ((unsigned int )error___4 != 0U) {
        return (error___4);
      }
      tmp___4 = Buffer_WriteU64(bin_buf, processor->sampleTime);
      error___5 = tmp___4;
      if ((unsigned int )error___5 != 0U) {
        return (error___5);
      }
    } else {
      tmp___5 = Buffer_WriteU32(bin_buf, (rmtU32 )-1);
      error___6 = tmp___5;
      if ((unsigned int )error___6 != 0U) {
        return (error___6);
      }
      tmp___6 = Buffer_WriteU32(bin_buf, (rmtU32 )0);
      error___7 = tmp___6;
      if ((unsigned int )error___7 != 0U) {
        return (error___7);
      }
      tmp___7 = Buffer_WriteU64(bin_buf, (rmtU64 )0);
      error___8 = tmp___7;
      if ((unsigned int )error___8 != 0U) {
        return (error___8);
      }
    }
    processor_index ++;
  }
  tmp___8 = bin_MessageFooter(bin_buf, write_start_offset);
  error___9 = tmp___8;
  if ((unsigned int )error___9 != 0U) {
    return (error___9);
  }
  tmp___9 = Remotery_SendToViewerAndLog(rmt, bin_buf, (rmtU32 )50);
  return (tmp___9);
}
}
static void FreePropertySnapshots(PropertySnapshot *snapshot ) 
{ 


  {
  if ((unsigned long )snapshot == (unsigned long )((void *)0)) {
    return;
  }
  if ((unsigned long )snapshot->nextSnapshot != (unsigned long )((void *)0)) {
    FreePropertySnapshots(snapshot->nextSnapshot);
  }
  ObjectAllocator_Free(g_Remotery->propertyAllocator, (void *)snapshot);
  return;
}
}
static rmtError Remotery_SerialisePropertySnapshots(Buffer *bin_buf , Msg_PropertySnapshot *msg_snapshot ) 
{ 
  PropertySnapshot *snapshot ;
  rmtU8 empty_group[16] ;
  rmtU32 write_start_offset ;
  rmtError error ;
  rmtError tmp ;
  rmtError error___0 ;
  rmtError tmp___0 ;
  rmtError error___1 ;
  rmtError tmp___1 ;
  rmtU8 colour_depth[4] ;
  unsigned int tmp___2 ;
  rmtError error___2 ;
  rmtError tmp___3 ;
  rmtError error___3 ;
  rmtError tmp___4 ;
  rmtError error___4 ;
  rmtError tmp___5 ;
  rmtError error___5 ;
  rmtError tmp___6 ;
  rmtError error___6 ;
  rmtError tmp___7 ;
  rmtError error___7 ;
  rmtError tmp___8 ;
  rmtError error___8 ;
  rmtError tmp___9 ;
  rmtError error___9 ;
  rmtError tmp___10 ;
  rmtError error___10 ;
  rmtError tmp___11 ;
  rmtError error___11 ;
  rmtError tmp___12 ;
  rmtError error___12 ;
  rmtError tmp___13 ;
  rmtError error___13 ;
  rmtError tmp___14 ;
  rmtError error___14 ;
  rmtError tmp___15 ;
  rmtError error___15 ;
  rmtError tmp___16 ;
  rmtError error___16 ;
  rmtError tmp___17 ;
  rmtError error___17 ;
  rmtError tmp___18 ;
  rmtError error___18 ;
  rmtError tmp___19 ;
  rmtError error___19 ;
  rmtError tmp___20 ;
  rmtError error___20 ;
  rmtError tmp___21 ;
  rmtError error___21 ;
  rmtError tmp___22 ;

  {
  empty_group[0] = (rmtU8 )0;
  empty_group[1] = (rmtU8 )0;
  empty_group[2] = (rmtU8 )0;
  empty_group[3] = (rmtU8 )0;
  empty_group[4] = (rmtU8 )0;
  empty_group[5] = (rmtU8 )0;
  empty_group[6] = (rmtU8 )0;
  empty_group[7] = (rmtU8 )0;
  empty_group[8] = (rmtU8 )0;
  empty_group[9] = (rmtU8 )0;
  empty_group[10] = (rmtU8 )0;
  empty_group[11] = (rmtU8 )0;
  empty_group[12] = (rmtU8 )0;
  empty_group[13] = (rmtU8 )0;
  empty_group[14] = (rmtU8 )0;
  empty_group[15] = (rmtU8 )0;
  tmp = bin_MessageHeader(bin_buf, "PSNP", & write_start_offset);
  error = tmp;
  if ((unsigned int )error != 0U) {
    return (error);
  }
  tmp___0 = Buffer_WriteU32(bin_buf, msg_snapshot->nbSnapshots);
  error___0 = tmp___0;
  if ((unsigned int )error___0 != 0U) {
    return (error___0);
  }
  tmp___1 = Buffer_WriteU32(bin_buf, msg_snapshot->propertyFrame);
  error___1 = tmp___1;
  if ((unsigned int )error___1 != 0U) {
    return (error___1);
  }
  snapshot = msg_snapshot->rootSnapshot;
  while ((unsigned long )snapshot != (unsigned long )((void *)0)) {
    colour_depth[0] = (rmtU8 )0;
    colour_depth[1] = (rmtU8 )0;
    colour_depth[2] = (rmtU8 )0;
    tmp___2 = 3U;
    while (! (tmp___2 >= 4U)) {
      colour_depth[tmp___2] = (unsigned char)0;
      tmp___2 ++;
    }
    tmp___3 = Buffer_WriteU32(bin_buf, snapshot->nameHash);
    error___2 = tmp___3;
    if ((unsigned int )error___2 != 0U) {
      return (error___2);
    }
    tmp___4 = Buffer_WriteU32(bin_buf, snapshot->uniqueID);
    error___3 = tmp___4;
    if ((unsigned int )error___3 != 0U) {
      return (error___3);
    }
    colour_depth[3] = snapshot->depth;
    tmp___5 = Buffer_Write(bin_buf, (void const   *)(colour_depth), (rmtU32 )4);
    error___4 = tmp___5;
    if ((unsigned int )error___4 != 0U) {
      return (error___4);
    }
    tmp___6 = Buffer_WriteU32(bin_buf, (rmtU32 )snapshot->type);
    error___5 = tmp___6;
    if ((unsigned int )error___5 != 0U) {
      return (error___5);
    }
    switch ((unsigned int )snapshot->type) {
    case 0U: 
    tmp___7 = Buffer_Write(bin_buf, (void const   *)(empty_group), (rmtU32 )16);
    error___6 = tmp___7;
    if ((unsigned int )error___6 != 0U) {
      return (error___6);
    }
    break;
    case 1U: 
    tmp___8 = Buffer_WriteF64(bin_buf, (rmtF64 )snapshot->value.Bool);
    error___7 = tmp___8;
    if ((unsigned int )error___7 != 0U) {
      return (error___7);
    }
    tmp___9 = Buffer_WriteF64(bin_buf, (rmtF64 )snapshot->prevValue.Bool);
    error___8 = tmp___9;
    if ((unsigned int )error___8 != 0U) {
      return (error___8);
    }
    break;
    case 2U: 
    tmp___10 = Buffer_WriteF64(bin_buf, (rmtF64 )snapshot->value.S32);
    error___9 = tmp___10;
    if ((unsigned int )error___9 != 0U) {
      return (error___9);
    }
    tmp___11 = Buffer_WriteF64(bin_buf, (rmtF64 )snapshot->prevValue.S32);
    error___10 = tmp___11;
    if ((unsigned int )error___10 != 0U) {
      return (error___10);
    }
    break;
    case 3U: 
    tmp___12 = Buffer_WriteF64(bin_buf, (rmtF64 )snapshot->value.U32);
    error___11 = tmp___12;
    if ((unsigned int )error___11 != 0U) {
      return (error___11);
    }
    tmp___13 = Buffer_WriteF64(bin_buf, (rmtF64 )snapshot->prevValue.U32);
    error___12 = tmp___13;
    if ((unsigned int )error___12 != 0U) {
      return (error___12);
    }
    break;
    case 4U: 
    tmp___14 = Buffer_WriteF64(bin_buf, (rmtF64 )snapshot->value.F32);
    error___13 = tmp___14;
    if ((unsigned int )error___13 != 0U) {
      return (error___13);
    }
    tmp___15 = Buffer_WriteF64(bin_buf, (rmtF64 )snapshot->prevValue.F32);
    error___14 = tmp___15;
    if ((unsigned int )error___14 != 0U) {
      return (error___14);
    }
    break;
    case 6U: 
    case 5U: 
    tmp___16 = Buffer_WriteU64(bin_buf, snapshot->value.U64);
    error___15 = tmp___16;
    if ((unsigned int )error___15 != 0U) {
      return (error___15);
    }
    tmp___17 = Buffer_WriteU64(bin_buf, snapshot->prevValue.U64);
    error___16 = tmp___17;
    if ((unsigned int )error___16 != 0U) {
      return (error___16);
    }
    break;
    case 7U: 
    tmp___18 = Buffer_WriteF64(bin_buf, snapshot->value.F64);
    error___17 = tmp___18;
    if ((unsigned int )error___17 != 0U) {
      return (error___17);
    }
    tmp___19 = Buffer_WriteF64(bin_buf, snapshot->prevValue.F64);
    error___18 = tmp___19;
    if ((unsigned int )error___18 != 0U) {
      return (error___18);
    }
    break;
    }
    tmp___20 = Buffer_WriteU32(bin_buf, snapshot->prevValueFrame);
    error___19 = tmp___20;
    if ((unsigned int )error___19 != 0U) {
      return (error___19);
    }
    tmp___21 = Buffer_WriteU32(bin_buf, snapshot->nbChildren);
    error___20 = tmp___21;
    if ((unsigned int )error___20 != 0U) {
      return (error___20);
    }
    snapshot = snapshot->nextSnapshot;
  }
  tmp___22 = bin_MessageFooter(bin_buf, write_start_offset);
  error___21 = tmp___22;
  if ((unsigned int )error___21 != 0U) {
    return (error___21);
  }
  return ((rmtError )0);
}
}
static rmtError Remotery_SendPropertySnapshot(Remotery *rmt , Message *message ) 
{ 
  Msg_PropertySnapshot *msg_snapshot ;
  rmtError error ;
  Buffer *bin_buf ;

  {
  msg_snapshot = (Msg_PropertySnapshot *)(message->payload);
  error = (rmtError )0;
  bin_buf = (rmt->server)->bin_buf;
  WebSocket_PrepareBuffer(bin_buf);
  error = Remotery_SerialisePropertySnapshots(bin_buf, msg_snapshot);
  if ((unsigned int )error == 0U) {
    error = Remotery_SendToViewerAndLog(rmt, bin_buf, (rmtU32 )50);
  }
  FreePropertySnapshots(msg_snapshot->rootSnapshot);
  return (error);
}
}
static rmtError Remotery_ConsumeMessageQueue(Remotery *rmt ) ;
static rmtU32 rmt_sample_hash_SendSampleTreeMessage  =    (rmtU32 )0;
static rmtError Remotery_ConsumeMessageQueue(Remotery *rmt ) 
{ 
  rmtU32 nb_messages_sent ;
  rmtU32 maxNbMessagesPerUpdate ;
  rmtError error ;
  Message *message ;
  Message *tmp___0 ;

  {
  nb_messages_sent = (rmtU32 )0;
  maxNbMessagesPerUpdate = g_Settings.maxNbMessagesPerUpdate;
  if (! ((unsigned long )rmt != (unsigned long )((void *)0))) {
    __assert_fail("rmt != NULL", "lib/Remotery.c", 6572U, "Remotery_ConsumeMessageQueue");
  }
  while (nb_messages_sent < maxNbMessagesPerUpdate) {
    error = (rmtError )0;
    tmp___0 = rmtMessageQueue_PeekNextMessage(rmt->mq_to_rmt_thread);
    message = tmp___0;
    if ((unsigned long )message == (unsigned long )((void *)0)) {
      break;
    }
    switch ((unsigned int )message->id) {
    case 0U: 
    __assert_fail("RMT_FALSE", "lib/Remotery.c", 6587U, "Remotery_ConsumeMessageQueue");
    break;
    case 1U: 
    error = Remotery_AddToStringTable(rmt, message);
    break;
    case 2U: 
    error = Remotery_SendLogTextMessage(rmt, message);
    nb_messages_sent ++;
    break;
    case 3U: 
    _rmt_BeginCPUSample("SendSampleTreeMessage", (rmtU32 )1, & rmt_sample_hash_SendSampleTreeMessage);
    error = Remotery_SendSampleTreeMessage(rmt, message);
    nb_messages_sent ++;
    _rmt_EndCPUSample();
    break;
    case 4U: 
    Remotery_SendProcessorThreads(rmt, message);
    nb_messages_sent ++;
    break;
    case 6U: 
    error = Remotery_SendPropertySnapshot(rmt, message);
    break;
    default: 
    break;
    }
    rmtMessageQueue_ConsumeNextMessage(rmt->mq_to_rmt_thread, message);
    if ((unsigned int )error != 0U) {
      return (error);
    }
  }
  return ((rmtError )0);
}
}
static void Remotery_FlushMessageQueue(Remotery *rmt ) 
{ 
  Message *message ;
  Message *tmp___0 ;
  Msg_SampleTree *sample_tree ;
  Msg_PropertySnapshot *msg_snapshot ;

  {
  if (! ((unsigned long )rmt != (unsigned long )((void *)0))) {
    __assert_fail("rmt != NULL", "lib/Remotery.c", 6629U, "Remotery_FlushMessageQueue");
  }
  while (1) {
    tmp___0 = rmtMessageQueue_PeekNextMessage(rmt->mq_to_rmt_thread);
    message = tmp___0;
    if ((unsigned long )message == (unsigned long )((void *)0)) {
      break;
    }
    switch ((unsigned int )message->id) {
    case 2U: 
    case 1U: 
    case 0U: 
    break;
    case 3U: 
    sample_tree = (Msg_SampleTree *)(message->payload);
    FreeSamples(sample_tree->rootSample, sample_tree->allocator);
    break;
    case 6U: 
    msg_snapshot = (Msg_PropertySnapshot *)(message->payload);
    FreePropertySnapshots(msg_snapshot->rootSnapshot);
    break;
    default: 
    break;
    }
    rmtMessageQueue_ConsumeNextMessage(rmt->mq_to_rmt_thread, message);
  }
  return;
}
}
static void Remotery_MapMessageQueue(Remotery *rmt ) 
{ 
  rmtU32 read_pos ;
  rmtU32 write_pos ;
  rmtMessageQueue *queue ;
  long *tmp___0 ;
  rmtU32 r ;
  Message *message ;
  rmtU32 message_size ;
  rmtU32 tmp___1 ;

  {
  if (! ((unsigned long )rmt != (unsigned long )((void *)0))) {
    __assert_fail("rmt != NULL", "lib/Remotery.c", 6672U, "Remotery_MapMessageQueue");
  }
  while (1) {
    tmp___0 = LoadAcquirePointer((long * volatile  *)(& rmt->map_message_queue_data));
    if (! ((unsigned long )tmp___0 == (unsigned long )((void *)0))) {
      break;
    }
    msSleep((rmtU32 )1);
  }
  queue = rmt->mq_to_rmt_thread;
  write_pos = LoadAcquire(& queue->write_pos);
  read_pos = (rmtU32 )queue->read_pos;
  while (read_pos < write_pos) {
    r = read_pos & (queue->size - 1U);
    message = (Message *)((queue->data)->ptr + r);
    tmp___1 = rmtMessageQueue_SizeForPayload(message->payload_size);
    message_size = tmp___1;
    (*(rmt->map_message_queue_fn))(rmt, message);
    read_pos += message_size;
  }
  StoreReleasePointer((long * volatile  *)(& rmt->map_message_queue_data), (long *)((void *)0));
  return;
}
}
static rmtError Remotery_ThreadMain(rmtThread *thread ) ;
static rmtU32 rmt_sample_hash_Wakeup  =    (rmtU32 )0;
static rmtU32 rmt_sample_hash_ServerUpdate  =    (rmtU32 )0;
static rmtU32 rmt_sample_hash_ConsumeMessageQueue  =    (rmtU32 )0;
static rmtError Remotery_ThreadMain(rmtThread *thread ) 
{ 
  Remotery *rmt ;
  long *tmp___0 ;

  {
  rmt = (Remotery *)thread->param;
  if (! ((unsigned long )rmt != (unsigned long )((void *)0))) {
    __assert_fail("rmt != NULL", "lib/Remotery.c", 6700U, "Remotery_ThreadMain");
  }
  _rmt_SetCurrentThreadName("Remotery");
  while (thread->request_exit == (rmtBool volatile   )0U) {
    _rmt_BeginCPUSample("Wakeup", (rmtU32 )0, & rmt_sample_hash_Wakeup);
    _rmt_BeginCPUSample("ServerUpdate", (rmtU32 )0, & rmt_sample_hash_ServerUpdate);
    Server_Update(rmt->server);
    _rmt_EndCPUSample();
    _rmt_BeginCPUSample("ConsumeMessageQueue", (rmtU32 )0, & rmt_sample_hash_ConsumeMessageQueue);
    Remotery_ConsumeMessageQueue(rmt);
    _rmt_EndCPUSample();
    _rmt_EndCPUSample();
    tmp___0 = LoadAcquirePointer((long * volatile  *)(& rmt->map_message_queue_fn));
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
      Remotery_MapMessageQueue(rmt);
      StoreReleasePointer((long * volatile  *)(& rmt->map_message_queue_fn), (long *)((void *)0));
    }
    msSleep(g_Settings.msSleepBetweenServerUpdates);
  }
  Remotery_FlushMessageQueue(rmt);
  return ((rmtError )0);
}
}
static rmtError Remotery_ReceiveMessage(void *context , char *message_data , rmtU32 message_length ) 
{ 
  Remotery *rmt ;
  rmtU32 message_id ;
  rmtPStr name ;
  rmtU32 name_hash ;
  char const   *cur ;
  char const   *end ;
  char const   *tmp ;
  rmtU32 name_length ;
  r_size_t tmp___0 ;
  Buffer *bin_buf ;
  rmtError tmp___1 ;

  {
  rmt = (Remotery *)context;
  message_id = *((rmtU32 *)message_data);
  switch (message_id) {
  case (rmtU32 )((((73 << 24) | (78 << 16)) | (79 << 8)) | 67): 
  _rmt_LogText("Console message received...");
  _rmt_LogText((rmtPStr )(message_data + 4));
  if ((unsigned long )g_Settings.input_handler != (unsigned long )((void *)0)) {
    (*(g_Settings.input_handler))((char const   *)(message_data + 4), g_Settings.input_handler_context);
  }
  break;
  case (rmtU32 )((((80 << 24) | (77 << 16)) | (83 << 8)) | 71): 
  name_hash = (rmtU32 )0;
  cur = (char const   *)(message_data + 4);
  end = (cur + message_length) - 4;
  while ((unsigned long )cur < (unsigned long )end) {
    tmp = cur;
    cur ++;
    name_hash = (name_hash * 10U + (rmtU32 )*tmp) - 48U;
  }
  name = StringTable_Find(rmt->string_table, name_hash);
  if ((unsigned long )name != (unsigned long )((void *)0)) {
    tmp___0 = strnlen_s_safe_c(name, (r_size_t )244);
    name_length = tmp___0;
    bin_buf = (rmt->server)->bin_buf;
    WebSocket_PrepareBuffer(bin_buf);
    bin_SampleName(bin_buf, name, name_hash, name_length);
    tmp___1 = Server_Send(rmt->server, (void const   *)bin_buf->data, bin_buf->bytes_used,
                          (rmtU32 )10);
    return (tmp___1);
  }
  break;
  }
  return ((rmtError )0);
}
}
static rmtError Remotery_Constructor(Remotery *rmt ) 
{ 
  rmtProperty *root_property ;
  void *tmp___0 ;
  rmtError error ;
  rmtError tmp___1 ;
  void *tmp___2 ;
  rmtError error___0 ;
  rmtError tmp___3 ;
  void *tmp___4 ;
  rmtError error___1 ;
  rmtError tmp___5 ;
  struct tm *now_tm ;
  struct tm *tmp___6 ;
  char filename[512] ;
  unsigned int tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  void *tmp___14 ;
  rmtError error___2 ;
  rmtError tmp___15 ;
  void *tmp___16 ;
  rmtError error___3 ;
  rmtError tmp___17 ;
  void *tmp___19 ;
  rmtError error___4 ;
  rmtError tmp___20 ;

  {
  if (! ((unsigned long )rmt != (unsigned long )((void *)0))) {
    __assert_fail("rmt != NULL", "lib/Remotery.c", 6802U, "Remotery_Constructor");
  }
  rmt->server = (Server *)((void *)0);
  rmt->mq_to_rmt_thread = (rmtMessageQueue *)((void *)0);
  rmt->thread = (rmtThread *)((void *)0);
  rmt->string_table = (StringTable *)((void *)0);
  rmt->logfile = (FILE *)((void *)0);
  rmt->map_message_queue_fn = (void (*)(Remotery *rmt , Message * ))((void *)0);
  rmt->map_message_queue_data = (void *)0;
  rmt->threadProfilers = (ThreadProfilers *)((void *)0);
  mtxInit(& rmt->propertyMutex);
  rmt->propertyAllocator = (ObjectAllocator *)((void *)0);
  rmt->propertyFrame = (rmtU32 )0;
  root_property = & rmt->rootProperty;
  root_property->initialised = (rmtBool )1;
  root_property->type = (rmtPropertyType )0;
  root_property->value.Bool = (rmtBool )0;
  root_property->flags = (rmtPropertyFlags )0;
  root_property->name = "Root Property";
  root_property->description = "";
  root_property->defaultValue.Bool = (rmtBool )0;
  root_property->parent = (struct rmtProperty *)((void *)0);
  root_property->firstChild = (struct rmtProperty *)((void *)0);
  root_property->lastChild = (struct rmtProperty *)((void *)0);
  root_property->nextSibling = (struct rmtProperty *)((void *)0);
  root_property->nameHash = (rmtU32 )0;
  root_property->uniqueID = (rmtU32 )0;
  usTimer_Init(& rmt->timer);
  tmp___0 = rmtMalloc((rmtU32 )sizeof(Server ));
  rmt->server = (Server *)tmp___0;
  if ((unsigned long )rmt->server == (unsigned long )((void *)0)) {
    return ((rmtError )7);
  }
  tmp___1 = Server_Constructor(rmt->server, g_Settings.port, g_Settings.reuse_open_port,
                               g_Settings.limit_connections_to_localhost);
  error = tmp___1;
  if ((unsigned int )error != 0U) {
    if ((unsigned long )rmt->server != (unsigned long )((void *)0)) {
      Server_Destructor(rmt->server);
      rmtFree((void *)rmt->server);
      rmt->server = (Server *)((void *)0);
    }
    return (error);
  }
  (rmt->server)->receive_handler = & Remotery_ReceiveMessage;
  (rmt->server)->receive_handler_context = (void *)rmt;
  tmp___2 = rmtMalloc((rmtU32 )sizeof(rmtMessageQueue ));
  rmt->mq_to_rmt_thread = (rmtMessageQueue *)tmp___2;
  if ((unsigned long )rmt->mq_to_rmt_thread == (unsigned long )((void *)0)) {
    return ((rmtError )7);
  }
  tmp___3 = rmtMessageQueue_Constructor(rmt->mq_to_rmt_thread, g_Settings.messageQueueSizeInBytes);
  error___0 = tmp___3;
  if ((unsigned int )error___0 != 0U) {
    if ((unsigned long )rmt->mq_to_rmt_thread != (unsigned long )((void *)0)) {
      rmtMessageQueue_Destructor(rmt->mq_to_rmt_thread);
      rmtFree((void *)rmt->mq_to_rmt_thread);
      rmt->mq_to_rmt_thread = (rmtMessageQueue *)((void *)0);
    }
    return (error___0);
  }
  tmp___4 = rmtMalloc((rmtU32 )sizeof(StringTable ));
  rmt->string_table = (StringTable *)tmp___4;
  if ((unsigned long )rmt->string_table == (unsigned long )((void *)0)) {
    return ((rmtError )7);
  }
  tmp___5 = StringTable_Constructor(rmt->string_table);
  error___1 = tmp___5;
  if ((unsigned int )error___1 != 0U) {
    if ((unsigned long )rmt->string_table != (unsigned long )((void *)0)) {
      StringTable_Destructor(rmt->string_table);
      rmtFree((void *)rmt->string_table);
      rmt->string_table = (StringTable *)((void *)0);
    }
    return (error___1);
  }
  if ((unsigned long )g_Settings.logPath != (unsigned long )((void *)0)) {
    tmp___6 = TimeDateNow();
    now_tm = tmp___6;
    filename[0] = (char)0;
    tmp___7 = 1U;
    while (! (tmp___7 >= 512U)) {
      filename[tmp___7] = (char)0;
      tmp___7 ++;
    }
    strncat_s_safe_c(filename, (r_size_t )sizeof(filename), g_Settings.logPath, (r_size_t )512);
    strncat_s_safe_c(filename, (r_size_t )sizeof(filename), "/remotery-log-", (r_size_t )14);
    tmp___8 = itoa_s(now_tm->tm_year + 1900);
    strncat_s_safe_c(filename, (r_size_t )sizeof(filename), tmp___8, (r_size_t )11);
    strncat_s_safe_c(filename, (r_size_t )sizeof(filename), "-", (r_size_t )1);
    tmp___9 = itoa_s(now_tm->tm_mon + 1);
    strncat_s_safe_c(filename, (r_size_t )sizeof(filename), tmp___9, (r_size_t )11);
    strncat_s_safe_c(filename, (r_size_t )sizeof(filename), "-", (r_size_t )1);
    tmp___10 = itoa_s(now_tm->tm_mday);
    strncat_s_safe_c(filename, (r_size_t )sizeof(filename), tmp___10, (r_size_t )11);
    strncat_s_safe_c(filename, (r_size_t )sizeof(filename), "-", (r_size_t )1);
    tmp___11 = itoa_s(now_tm->tm_hour);
    strncat_s_safe_c(filename, (r_size_t )sizeof(filename), tmp___11, (r_size_t )11);
    strncat_s_safe_c(filename, (r_size_t )sizeof(filename), "-", (r_size_t )1);
    tmp___12 = itoa_s(now_tm->tm_min);
    strncat_s_safe_c(filename, (r_size_t )sizeof(filename), tmp___12, (r_size_t )11);
    strncat_s_safe_c(filename, (r_size_t )sizeof(filename), "-", (r_size_t )1);
    tmp___13 = itoa_s(now_tm->tm_sec);
    strncat_s_safe_c(filename, (r_size_t )sizeof(filename), tmp___13, (r_size_t )11);
    strncat_s_safe_c(filename, (r_size_t )sizeof(filename), ".rbin", (r_size_t )5);
    rmt->logfile = rmtOpenFile((char const   *)(filename), "w");
    if ((unsigned long )rmt->logfile != (unsigned long )((void *)0)) {
      rmtWriteFile(rmt->logfile, (void const   *)"RMTBLOGF", (rmtU32 )8);
    }
  }
  tmp___14 = rmtMalloc((rmtU32 )sizeof(ThreadProfilers ));
  rmt->threadProfilers = (ThreadProfilers *)tmp___14;
  if ((unsigned long )rmt->threadProfilers == (unsigned long )((void *)0)) {
    return ((rmtError )7);
  }
  tmp___15 = ThreadProfilers_Constructor(rmt->threadProfilers, & rmt->timer, rmt->mq_to_rmt_thread);
  error___2 = tmp___15;
  if ((unsigned int )error___2 != 0U) {
    if ((unsigned long )rmt->threadProfilers != (unsigned long )((void *)0)) {
      ThreadProfilers_Destructor(rmt->threadProfilers);
      rmtFree((void *)rmt->threadProfilers);
      rmt->threadProfilers = (ThreadProfilers *)((void *)0);
    }
    return (error___2);
  }
  tmp___16 = rmtMalloc((rmtU32 )sizeof(ObjectAllocator ));
  rmt->propertyAllocator = (ObjectAllocator *)tmp___16;
  if ((unsigned long )rmt->propertyAllocator == (unsigned long )((void *)0)) {
    return ((rmtError )7);
  }
  tmp___17 = ObjectAllocator_Constructor(rmt->propertyAllocator, (rmtU32 )sizeof(PropertySnapshot ),
                                         (rmtError (*)(void * ))(& PropertySnapshot_Constructor),
                                         (void (*)(void * ))(& PropertySnapshot_Destructor));
  error___3 = tmp___17;
  if ((unsigned int )error___3 != 0U) {
    if ((unsigned long )rmt->propertyAllocator != (unsigned long )((void *)0)) {
      ObjectAllocator_Destructor(rmt->propertyAllocator);
      rmtFree((void *)rmt->propertyAllocator);
      rmt->propertyAllocator = (ObjectAllocator *)((void *)0);
    }
    return (error___3);
  }
  if (! ((unsigned long )g_Remotery == (unsigned long )((void *)0))) {
    __assert_fail("g_Remotery == NULL", "lib/Remotery.c", 6922U, "Remotery_Constructor");
  }
  g_Remotery = rmt;
  g_RemoteryCreated = (rmtBool )1;
  CompilerWriteFence();
  tmp___19 = rmtMalloc((rmtU32 )sizeof(rmtThread ));
  rmt->thread = (rmtThread *)tmp___19;
  if ((unsigned long )rmt->thread == (unsigned long )((void *)0)) {
    return ((rmtError )7);
  }
  tmp___20 = rmtThread_Constructor(rmt->thread, & Remotery_ThreadMain, (void *)rmt);
  error___4 = tmp___20;
  if ((unsigned int )error___4 != 0U) {
    if ((unsigned long )rmt->thread != (unsigned long )((void *)0)) {
      rmtThread_Destructor(rmt->thread);
      rmtFree((void *)rmt->thread);
      rmt->thread = (rmtThread *)((void *)0);
    }
    return (error___4);
  }
  return ((rmtError )0);
}
}
static void Remotery_Destructor(Remotery *rmt ) 
{ 


  {
  if (! ((unsigned long )rmt != (unsigned long )((void *)0))) {
    __assert_fail("rmt != NULL", "lib/Remotery.c", 6937U, "Remotery_Destructor");
  }
  if ((unsigned long )rmt->thread != (unsigned long )((void *)0)) {
    rmtThread_Destructor(rmt->thread);
    rmtFree((void *)rmt->thread);
    rmt->thread = (rmtThread *)((void *)0);
  }
  if (g_RemoteryCreated) {
    g_Remotery = (Remotery *)((void *)0);
    g_RemoteryCreated = (rmtBool )0;
  }
  if ((unsigned long )rmt->propertyAllocator != (unsigned long )((void *)0)) {
    ObjectAllocator_Destructor(rmt->propertyAllocator);
    rmtFree((void *)rmt->propertyAllocator);
    rmt->propertyAllocator = (ObjectAllocator *)((void *)0);
  }
  if ((unsigned long )rmt->threadProfilers != (unsigned long )((void *)0)) {
    ThreadProfilers_Destructor(rmt->threadProfilers);
    rmtFree((void *)rmt->threadProfilers);
    rmt->threadProfilers = (ThreadProfilers *)((void *)0);
  }
  rmtCloseFile(rmt->logfile);
  if ((unsigned long )rmt->string_table != (unsigned long )((void *)0)) {
    StringTable_Destructor(rmt->string_table);
    rmtFree((void *)rmt->string_table);
    rmt->string_table = (StringTable *)((void *)0);
  }
  if ((unsigned long )rmt->mq_to_rmt_thread != (unsigned long )((void *)0)) {
    rmtMessageQueue_Destructor(rmt->mq_to_rmt_thread);
    rmtFree((void *)rmt->mq_to_rmt_thread);
    rmt->mq_to_rmt_thread = (rmtMessageQueue *)((void *)0);
  }
  if ((unsigned long )rmt->server != (unsigned long )((void *)0)) {
    Server_Destructor(rmt->server);
    rmtFree((void *)rmt->server);
    rmt->server = (Server *)((void *)0);
  }
  if (g_lastErrorMessageTlsHandle != 4294967295U) {
    tlsFree(g_lastErrorMessageTlsHandle);
    g_lastErrorMessageTlsHandle = 4294967295U;
  }
  mtxDelete(& rmt->propertyMutex);
  return;
}
}
static void *CRTMalloc(void *mm_context , rmtU32 size ) 
{ 
  void *tmp ;

  {
  tmp = malloc((size_t )size);
  return (tmp);
}
}
static void CRTFree(void *mm_context , void *ptr ) 
{ 


  {
  free(ptr);
  return;
}
}
static void *CRTRealloc(void *mm_context , void *ptr , rmtU32 size ) 
{ 
  void *tmp ;

  {
  tmp = realloc(ptr, (size_t )size);
  return (tmp);
}
}
rmtSettings *_rmt_Settings(void) 
{ 


  {
  if (g_SettingsInitialized == 0U) {
    g_Settings.port = (rmtU16 )17815;
    g_Settings.reuse_open_port = (rmtBool )0;
    g_Settings.limit_connections_to_localhost = (rmtBool )0;
    g_Settings.enableThreadSampler = (rmtBool )1;
    g_Settings.msSleepBetweenServerUpdates = (rmtU32 )4;
    g_Settings.messageQueueSizeInBytes = (rmtU32 )1048576;
    g_Settings.maxNbMessagesPerUpdate = (rmtU32 )1000;
    g_Settings.malloc = & CRTMalloc;
    g_Settings.free = & CRTFree;
    g_Settings.realloc = & CRTRealloc;
    g_Settings.input_handler = (void (*)(char const   *text , void *context ))((void *)0);
    g_Settings.input_handler_context = (void *)0;
    g_Settings.logPath = (rmtPStr )((void *)0);
    g_Settings.sampletree_handler = (void (*)(void *cbk_context , rmtSampleTree *sample_tree ))((void *)0);
    g_Settings.sampletree_context = (void *)0;
    g_Settings.snapshot_callback = (void (*)(void *cbk_context , struct rmtProperty *root ))((void *)0);
    g_Settings.snapshot_context = (void *)0;
    g_SettingsInitialized = (rmtBool )1;
  }
  return (& g_Settings);
}
}
enum rmtError _rmt_CreateGlobalInstance(Remotery **remotery ) 
{ 
  void *tmp___1 ;
  rmtError error ;
  rmtError tmp___2 ;

  {
  if (! (sizeof(MessageID ) == sizeof(rmtU32 ))) {
    __assert_fail("sizeof(MessageID) == sizeof(rmtU32)", "lib/Remotery.c", 7037U,
                  "_rmt_CreateGlobalInstance");
  }
  _rmt_Settings();
  if (! ((unsigned long )remotery != (unsigned long )((void *)0))) {
    __assert_fail("remotery != NULL", "lib/Remotery.c", 7043U, "_rmt_CreateGlobalInstance");
  }
  tmp___1 = rmtMalloc((rmtU32 )sizeof(Remotery ));
  *remotery = (Remotery *)tmp___1;
  if ((unsigned long )*remotery == (unsigned long )((void *)0)) {
    return ((enum rmtError )7);
  }
  tmp___2 = Remotery_Constructor(*remotery);
  error = tmp___2;
  if ((unsigned int )error != 0U) {
    if ((unsigned long )*remotery != (unsigned long )((void *)0)) {
      Remotery_Destructor(*remotery);
      rmtFree((void *)*remotery);
      *remotery = (Remotery *)((void *)0);
    }
    return (error);
  }
  return ((enum rmtError )0);
}
}
void _rmt_DestroyGlobalInstance(Remotery *remotery ) 
{ 


  {
  if (! (g_RemoteryCreated == 1U)) {
    __assert_fail("g_RemoteryCreated == RMT_TRUE", "lib/Remotery.c", 7051U, "_rmt_DestroyGlobalInstance");
  }
  if (! ((unsigned long )g_Remotery == (unsigned long )remotery)) {
    __assert_fail("g_Remotery == remotery", "lib/Remotery.c", 7052U, "_rmt_DestroyGlobalInstance");
  }
  if ((unsigned long )remotery != (unsigned long )((void *)0)) {
    Remotery_Destructor(remotery);
    rmtFree((void *)remotery);
    remotery = (Remotery *)((void *)0);
  }
  return;
}
}
void _rmt_SetGlobalInstance(Remotery *remotery ) 
{ 


  {
  _rmt_Settings();
  g_Remotery = remotery;
  return;
}
}
Remotery *_rmt_GetGlobalInstance(void) 
{ 


  {
  return (g_Remotery);
}
}
wchar_t *MakeWideString(char const   *string ) 
{ 
  size_t wlen ;
  wchar_t *wstr ;
  void *tmp ;
  size_t tmp___0 ;

  {
  wlen = mbstowcs((wchar_t * __restrict  )((void *)0), (char const   * __restrict  )string,
                  (size_t )256);
  tmp = rmtMalloc((rmtU32 )((wlen + 1UL) * sizeof(wchar_t )));
  wstr = (wchar_t *)tmp;
  if ((unsigned long )wstr == (unsigned long )((void *)0)) {
    return ((wchar_t *)((void *)0));
  }
  tmp___0 = mbstowcs((wchar_t * __restrict  )wstr, (char const   * __restrict  )string,
                     wlen + 1UL);
  if (tmp___0 != wlen) {
    rmtFree((void *)wstr);
    return ((wchar_t *)((void *)0));
  }
  return (wstr);
}
}
static void SetDebuggerThreadName(char const   *name ) 
{ 
  char name_clamp[16] ;

  {
  name_clamp[0] = (char)0;
  strncat_s_safe_c(name_clamp, (r_size_t )sizeof(name_clamp), name, (r_size_t )15);
  prctl(15, name_clamp, 0, 0, 0);
  return;
}
}
void _rmt_SetCurrentThreadName(rmtPStr thread_name ) 
{ 
  ThreadProfiler *thread_profiler ;
  rmtError tmp ;
  r_size_t tmp___0 ;

  {
  if ((unsigned long )g_Remotery == (unsigned long )((void *)0)) {
    return;
  }
  tmp = ThreadProfilers_GetCurrentThreadProfiler(g_Remotery->threadProfilers, & thread_profiler);
  if ((unsigned int )tmp != 0U) {
    return;
  }
  strcpy_s_safe_c(thread_profiler->threadName, (r_size_t )sizeof(thread_profiler->threadName),
                  thread_name);
  tmp___0 = strnlen_s_safe_c(thread_name, (r_size_t )64);
  thread_profiler->threadNameHash = _rmt_HashString32(thread_name, (int )tmp___0,
                                                      (rmtU32 )0);
  SetDebuggerThreadName(thread_name);
  return;
}
}
static rmtBool QueueLine(rmtMessageQueue *queue , unsigned char *text , rmtU32 size ,
                         struct ThreadProfiler *thread_profiler ) 
{ 
  Message *message ;
  rmtU32 text_size ;

  {
  if (! ((unsigned long )queue != (unsigned long )((void *)0))) {
    __assert_fail("queue != NULL", "lib/Remotery.c", 7207U, "QueueLine");
  }
  text_size = size - 4U;
  U32ToByteArray(text, text_size);
  message = rmtMessageQueue_AllocMessage(queue, size, thread_profiler);
  if ((unsigned long )message == (unsigned long )((void *)0)) {
    return ((rmtBool )0);
  }
  memcpy((void * __restrict  )(message->payload), (void const   * __restrict  )text,
         (size_t )size);
  rmtMessageQueue_CommitMessage(message, (MessageID )2);
  return ((rmtBool )1);
}
}
void _rmt_LogText(rmtPStr text ) 
{ 
  int start_offset ;
  int offset ;
  int i ;
  unsigned char line_buffer[1024] ;
  unsigned int tmp ;
  ThreadProfiler *thread_profiler ;
  rmtError tmp___0 ;
  char c ;
  rmtBool tmp___1 ;
  int tmp___2 ;

  {
  line_buffer[0] = (unsigned char)0;
  tmp = 1U;
  while (! (tmp >= 1024U)) {
    line_buffer[tmp] = (unsigned char)0;
    tmp ++;
  }
  if ((unsigned long )g_Remotery == (unsigned long )((void *)0)) {
    return;
  }
  tmp___0 = ThreadProfilers_GetCurrentThreadProfiler(g_Remotery->threadProfilers,
                                                     & thread_profiler);
  if ((unsigned int )tmp___0 != 0U) {
    return;
  }
  line_buffer[0] = (unsigned char )' ';
  line_buffer[1] = (unsigned char )' ';
  line_buffer[2] = (unsigned char )' ';
  line_buffer[3] = (unsigned char )' ';
  start_offset = 4;
  offset = start_offset;
  i = 0;
  while ((int const   )*(text + i) != 0) {
    c = (char )*(text + i);
    if ((unsigned long )offset == sizeof(line_buffer) - 1UL) {
      goto _L;
    } else
    if ((int )c == 10) {
      _L: /* CIL Label */ 
      tmp___1 = QueueLine(g_Remotery->mq_to_rmt_thread, line_buffer, (rmtU32 )offset,
                          thread_profiler);
      if (tmp___1 == 0U) {
        return;
      }
      offset = start_offset;
      if ((int )c == 10) {
        goto __Cont;
      }
    }
    tmp___2 = offset;
    offset ++;
    line_buffer[tmp___2] = (unsigned char )c;
    __Cont: /* CIL Label */ 
    i ++;
  }
  if (offset > start_offset) {
    if (! (offset < (int )sizeof(line_buffer))) {
      __assert_fail("offset < (int)sizeof(line_buffer)", "lib/Remotery.c", 7276U,
                    "_rmt_LogText");
    }
    QueueLine(g_Remotery->mq_to_rmt_thread, line_buffer, (rmtU32 )offset, thread_profiler);
  }
  return;
}
}
void _rmt_BeginCPUSample(rmtPStr name , rmtU32 flags , rmtU32 *hash_cache ) 
{ 
  ThreadProfiler *thread_profiler ;
  Sample *sample ;
  rmtU32 name_hash ;
  rmtU32 tmp ;
  rmtError tmp___0 ;
  rmtError tmp___1 ;

  {
  if ((unsigned long )g_Remotery == (unsigned long )((void *)0)) {
    return;
  }
  tmp___1 = ThreadProfilers_GetCurrentThreadProfiler(g_Remotery->threadProfilers,
                                                     & thread_profiler);
  if ((unsigned int )tmp___1 == 0U) {
    tmp = ThreadProfiler_GetNameHash(thread_profiler, g_Remotery->mq_to_rmt_thread,
                                     name, hash_cache);
    name_hash = tmp;
    tmp___0 = ThreadProfiler_Push(thread_profiler->sampleTrees[0], name_hash, flags,
                                  & sample);
    if ((unsigned int )tmp___0 == 0U) {
      if (sample->call_count > 1U) {
        sample->us_end = usTimer_Get(& g_Remotery->timer);
      } else {
        sample->us_start = usTimer_Get(& g_Remotery->timer);
      }
    }
  }
  return;
}
}
void _rmt_EndCPUSample(void) 
{ 
  ThreadProfiler *thread_profiler ;
  Sample *sample ;
  rmtU64 us_end ;
  rmtU64 tmp ;
  rmtError tmp___0 ;

  {
  if ((unsigned long )g_Remotery == (unsigned long )((void *)0)) {
    return;
  }
  tmp___0 = ThreadProfilers_GetCurrentThreadProfiler(g_Remotery->threadProfilers,
                                                     & thread_profiler);
  if ((unsigned int )tmp___0 == 0U) {
    sample = (thread_profiler->sampleTrees[0])->currentParent;
    if ((int )sample->recurse_depth > 0) {
      sample->recurse_depth = (rmtU16 )((int )sample->recurse_depth - 1);
    } else {
      tmp = usTimer_Get(& g_Remotery->timer);
      us_end = tmp;
      Sample_Close(sample, (rmtS64 )us_end);
      ThreadProfiler_Pop(thread_profiler, g_Remotery->mq_to_rmt_thread, sample, (rmtU32 )0);
    }
  }
  return;
}
}
rmtError _rmt_MarkFrame(void) 
{ 


  {
  if ((unsigned long )g_Remotery == (unsigned long )((void *)0)) {
    return ((rmtError )32);
  }
  return ((rmtError )0);
}
}
void _rmt_IterateChildren(rmtSampleIterator *iterator , rmtSample *sample ) 
{ 


  {
  iterator->sample = (rmtSample *)0;
  if ((unsigned long )sample != (unsigned long )((void *)0)) {
    iterator->initial = sample->first_child;
  } else {
    iterator->initial = (rmtSample *)0;
  }
  return;
}
}
rmtBool _rmt_IterateNext(rmtSampleIterator *iter ) 
{ 
  rmtBool tmp ;

  {
  if ((unsigned long )iter->initial != (unsigned long )((void *)0)) {
    iter->sample = iter->initial;
    iter->initial = (rmtSample *)0;
  } else
  if ((unsigned long )iter->sample != (unsigned long )((void *)0)) {
    iter->sample = (iter->sample)->next_sibling;
  }
  if ((unsigned long )iter->sample != (unsigned long )((void *)0)) {
    tmp = (rmtBool )1;
  } else {
    tmp = (rmtBool )0;
  }
  return (tmp);
}
}
char const   *_rmt_SampleTreeGetThreadName(rmtSampleTree *sample_tree ) 
{ 


  {
  return (sample_tree->threadName);
}
}
rmtSample *_rmt_SampleTreeGetRootSample(rmtSampleTree *sample_tree ) 
{ 


  {
  return (sample_tree->rootSample);
}
}
char const   *_rmt_SampleGetName(rmtSample *sample ) 
{ 
  char const   *name ;
  rmtPStr tmp ;

  {
  tmp = StringTable_Find(g_Remotery->string_table, sample->name_hash);
  name = tmp;
  if ((unsigned long )name == (unsigned long )((void *)0)) {
    return ("null");
  }
  return (name);
}
}
rmtU32 _rmt_SampleGetNameHash(rmtSample *sample ) 
{ 


  {
  return (sample->name_hash);
}
}
rmtU32 _rmt_SampleGetCallCount(rmtSample *sample ) 
{ 


  {
  return (sample->call_count);
}
}
rmtU64 _rmt_SampleGetStart(rmtSample *sample ) 
{ 


  {
  return (sample->us_start);
}
}
rmtU64 _rmt_SampleGetTime(rmtSample *sample ) 
{ 


  {
  return (sample->us_length);
}
}
rmtU64 _rmt_SampleGetSelfTime(rmtSample *sample ) 
{ 
  rmtS64 tmp ;

  {
  tmp = maxS64((rmtS64 )(sample->us_length - sample->us_sampled_length), (rmtS64 )0);
  return ((rmtU64 )tmp);
}
}
rmtSampleType _rmt_SampleGetType(rmtSample *sample ) 
{ 


  {
  return (sample->type);
}
}
void _rmt_SampleGetColour(rmtSample *sample , rmtU8 *r , rmtU8 *g , rmtU8 *b ) 
{ 


  {
  *r = sample->uniqueColour[0];
  *g = sample->uniqueColour[1];
  *b = sample->uniqueColour[2];
  return;
}
}
void _rmt_PropertyIterateChildren(rmtPropertyIterator *iterator , rmtProperty *property ) 
{ 


  {
  iterator->property = (rmtProperty *)0;
  if ((unsigned long )property != (unsigned long )((void *)0)) {
    iterator->initial = property->firstChild;
  } else {
    iterator->initial = (rmtProperty *)0;
  }
  return;
}
}
rmtBool _rmt_PropertyIterateNext(rmtPropertyIterator *iter ) 
{ 
  rmtBool tmp ;

  {
  if ((unsigned long )iter->initial != (unsigned long )((void *)0)) {
    iter->property = iter->initial;
    iter->initial = (rmtProperty *)0;
  } else
  if ((unsigned long )iter->property != (unsigned long )((void *)0)) {
    iter->property = (iter->property)->nextSibling;
  }
  if ((unsigned long )iter->property != (unsigned long )((void *)0)) {
    tmp = (rmtBool )1;
  } else {
    tmp = (rmtBool )0;
  }
  return (tmp);
}
}
char const   *_rmt_PropertyGetName(rmtProperty *property ) 
{ 


  {
  return (property->name);
}
}
char const   *_rmt_PropertyGetDescription(rmtProperty *property ) 
{ 


  {
  return (property->description);
}
}
rmtU32 _rmt_PropertyGetNameHash(rmtProperty *property ) 
{ 


  {
  return (property->nameHash);
}
}
rmtPropertyType _rmt_PropertyGetType(rmtProperty *property ) 
{ 


  {
  return (property->type);
}
}
rmtPropertyValue _rmt_PropertyGetValue(rmtProperty *property ) 
{ 


  {
  return (property->value);
}
}
static void RegisterProperty(rmtProperty *property , rmtBool can_lock ) 
{ 
  rmtU32 name_len ;
  rmtProperty *parent_property ;

  {
  if (property->initialised == 0U) {
    if (can_lock) {
      mtxLock(& g_Remotery->propertyMutex);
    }
    if (property->initialised == 0U) {
      parent_property = property->parent;
      if ((unsigned long )parent_property == (unsigned long )((void *)0)) {
        property->parent = & g_Remotery->rootProperty;
        parent_property = property->parent;
      }
      RegisterProperty(parent_property, (rmtBool )0);
      if ((unsigned long )parent_property->firstChild != (unsigned long )((void *)0)) {
        (parent_property->lastChild)->nextSibling = property;
        parent_property->lastChild = property;
      } else {
        parent_property->firstChild = property;
        parent_property->lastChild = property;
      }
      name_len = strnlen_s_safe_c(property->name, (r_size_t )256);
      property->nameHash = _rmt_HashString32(property->name, (int )name_len, (rmtU32 )0);
      QueueAddToStringTable(g_Remotery->mq_to_rmt_thread, property->nameHash, property->name,
                            (size_t )name_len, (struct ThreadProfiler *)((void *)0));
      property->uniqueID = parent_property->uniqueID;
      property->uniqueID = HashCombine(property->uniqueID, property->nameHash);
      property->initialised = (rmtBool )1;
    }
    if (can_lock) {
      mtxUnlock(& g_Remotery->propertyMutex);
    }
  }
  return;
}
}
void _rmt_PropertySetValue(rmtProperty *property ) 
{ 


  {
  if ((unsigned long )g_Remotery == (unsigned long )((void *)0)) {
    return;
  }
  RegisterProperty(property, (rmtBool )1);
  return;
}
}
void _rmt_PropertyAddValue(rmtProperty *property , rmtPropertyValue add_value ) 
{ 


  {
  if ((unsigned long )g_Remotery == (unsigned long )((void *)0)) {
    return;
  }
  RegisterProperty(property, (rmtBool )1);
  return;
}
}
static rmtError TakePropertySnapshot(rmtProperty *property , PropertySnapshot *parent_snapshot ,
                                     PropertySnapshot **first_snapshot , PropertySnapshot **prev_snapshot ,
                                     rmtU32 depth ) 
{ 
  rmtError error ;
  rmtProperty *child_property ;
  PropertySnapshot *snapshot ;

  {
  error = ObjectAllocator_Alloc(g_Remotery->propertyAllocator, (void **)(& snapshot));
  if ((unsigned int )error != 0U) {
    return (error);
  }
  snapshot->type = property->type;
  snapshot->value = property->value;
  snapshot->prevValue = property->prevValue;
  snapshot->prevValueFrame = property->prevValueFrame;
  snapshot->nameHash = property->nameHash;
  snapshot->uniqueID = property->uniqueID;
  snapshot->nbChildren = (rmtU32 )0;
  snapshot->depth = (rmtU8 )depth;
  snapshot->nextSnapshot = (struct PropertySnapshot *)((void *)0);
  if ((unsigned long )parent_snapshot != (unsigned long )((void *)0)) {
    (parent_snapshot->nbChildren) ++;
  }
  if ((unsigned long )*first_snapshot == (unsigned long )((void *)0)) {
    *first_snapshot = snapshot;
  }
  if ((unsigned long )*prev_snapshot != (unsigned long )((void *)0)) {
    (*prev_snapshot)->nextSnapshot = snapshot;
  }
  *prev_snapshot = snapshot;
  child_property = property->firstChild;
  while ((unsigned long )child_property != (unsigned long )((void *)0)) {
    error = TakePropertySnapshot(child_property, snapshot, first_snapshot, prev_snapshot,
                                 depth + 1U);
    if ((unsigned int )error != 0U) {
      return (error);
    }
    child_property = child_property->nextSibling;
  }
  return ((rmtError )0);
}
}
rmtError _rmt_PropertySnapshotAll(void) 
{ 
  rmtError error ;
  PropertySnapshot *first_snapshot ;
  PropertySnapshot *prev_snapshot ;
  Msg_PropertySnapshot *payload ;
  Message *message ;
  rmtU32 nb_snapshot_allocs ;

  {
  if ((unsigned long )g_Remotery == (unsigned long )((void *)0)) {
    return ((rmtError )32);
  }
  if ((unsigned long )g_Remotery->rootProperty.firstChild == (unsigned long )((void *)0)) {
    return ((rmtError )0);
  }
  nb_snapshot_allocs = (rmtU32 )(g_Remotery->propertyAllocator)->nb_inuse;
  first_snapshot = (PropertySnapshot *)((void *)0);
  prev_snapshot = (PropertySnapshot *)((void *)0);
  mtxLock(& g_Remotery->propertyMutex);
  error = TakePropertySnapshot(& g_Remotery->rootProperty, (PropertySnapshot *)((void *)0),
                               & first_snapshot, & prev_snapshot, (rmtU32 )0);
  if ((unsigned long )g_Settings.snapshot_callback != (unsigned long )((void *)0)) {
    (*(g_Settings.snapshot_callback))(g_Settings.snapshot_context, & g_Remotery->rootProperty);
  }
  mtxUnlock(& g_Remotery->propertyMutex);
  if ((unsigned int )error != 0U) {
    FreePropertySnapshots(first_snapshot);
    return (error);
  }
  message = rmtMessageQueue_AllocMessage(g_Remotery->mq_to_rmt_thread, (rmtU32 )sizeof(Msg_PropertySnapshot ),
                                         (struct ThreadProfiler *)((void *)0));
  if ((unsigned long )message == (unsigned long )((void *)0)) {
    FreePropertySnapshots(first_snapshot);
    return ((rmtError )2);
  }
  payload = (Msg_PropertySnapshot *)(message->payload);
  payload->rootSnapshot = first_snapshot;
  payload->nbSnapshots = (rmtU32 )(g_Remotery->propertyAllocator)->nb_inuse - nb_snapshot_allocs;
  payload->propertyFrame = g_Remotery->propertyFrame;
  rmtMessageQueue_CommitMessage(message, (MessageID )6);
  return ((rmtError )0);
}
}
static void PropertyFrameReset(Remotery *rmt , rmtProperty *first_property ) 
{ 
  rmtProperty *property ;
  rmtBool changed ;

  {
  property = first_property;
  while ((unsigned long )property != (unsigned long )((void *)0)) {
    PropertyFrameReset(rmt, property->firstChild);
    changed = (rmtBool )0;
    switch ((unsigned int )property->type) {
    case 0U: 
    break;
    case 1U: 
    changed = (rmtBool )(property->lastFrameValue.Bool != property->value.Bool);
    break;
    case 4U: 
    case 3U: 
    case 2U: 
    changed = (rmtBool )(property->lastFrameValue.U32 != property->value.U32);
    break;
    case 7U: 
    case 6U: 
    case 5U: 
    changed = (rmtBool )(property->lastFrameValue.U64 != property->value.U64);
    break;
    }
    if (changed) {
      property->prevValue = property->lastFrameValue;
      property->prevValueFrame = rmt->propertyFrame;
    }
    property->lastFrameValue = property->value;
    if (((unsigned int )property->flags & 1U) != 0U) {
      property->value = property->defaultValue;
    }
    property = property->nextSibling;
  }
  return;
}
}
void _rmt_PropertyFrameResetAll(void) 
{ 


  {
  if ((unsigned long )g_Remotery == (unsigned long )((void *)0)) {
    return;
  }
  mtxLock(& g_Remotery->propertyMutex);
  PropertyFrameReset(g_Remotery, g_Remotery->rootProperty.firstChild);
  mtxUnlock(& g_Remotery->propertyMutex);
  (g_Remotery->propertyFrame) ++;
  return;
}
}
